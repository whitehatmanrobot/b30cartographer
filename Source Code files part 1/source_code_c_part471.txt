,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___RefDialEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_RefDial;

#ifdef __cplusplus

class DECLSPEC_UUID("1E794A0A-86F4-11D1-ADD8-0000F87734F0")
RefDial;
#endif

EXTERN_C const CLSID CLSID_DialErr;

#ifdef __cplusplus

class DECLSPEC_UUID("462F7758-8848-11D1-ADD8-0000F87734F0")
DialErr;
#endif

EXTERN_C const CLSID CLSID_SmartStart;

#ifdef __cplusplus

class DECLSPEC_UUID("5D8D8F1A-8B89-11D1-ADDB-0000F87734F0")
SmartStart;
#endif

EXTERN_C const CLSID CLSID_ICWSystemConfig;

#ifdef __cplusplus

class DECLSPEC_UUID("7954DD9B-8C2A-11D1-ADDB-0000F87734F0")
ICWSystemConfig;
#endif

EXTERN_C const CLSID CLSID_TapiLocationInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("CB632C76-8DD4-11D1-ADDF-0000F87734F0")
TapiLocationInfo;
#endif

EXTERN_C const CLSID CLSID_UserInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("9E12E76D-94D6-11D1-ADE2-0000F87734F0")
UserInfo;
#endif

#ifndef ___WebGateEvents_DISPINTERFACE_DEFINED__
#define ___WebGateEvents_DISPINTERFACE_DEFINED__

/* dispinterface _WebGateEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__WebGateEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("166A20C0-AE10-11D1-ADEB-0000F87734F0")
    _WebGateEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _WebGateEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _WebGateEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _WebGateEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _WebGateEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _WebGateEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _WebGateEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _WebGateEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _WebGateEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _WebGateEventsVtbl;

    interface _WebGateEvents
    {
        CONST_VTBL struct _WebGateEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _WebGateEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _WebGateEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _WebGateEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _WebGateEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _WebGateEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _WebGateEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _WebGateEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___WebGateEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WebGate;

#ifdef __cplusplus

class DECLSPEC_UUID("3724B9A1-9503-11D1-B86A-00A0C90DC849")
WebGate;
#endif

#ifndef ___INSHandlerEvents_DISPINTERFACE_DEFINED__
#define ___INSHandlerEvents_DISPINTERFACE_DEFINED__

/* dispinterface _INSHandlerEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__INSHandlerEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("1F6D88A2-98D2-11d1-ADE3-0000F87734F0")
    _INSHandlerEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _INSHandlerEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _INSHandlerEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _INSHandlerEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _INSHandlerEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _INSHandlerEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _INSHandlerEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _INSHandlerEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _INSHandlerEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _INSHandlerEventsVtbl;

    interface _INSHandlerEvents
    {
        CONST_VTBL struct _INSHandlerEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _INSHandlerEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _INSHandlerEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _INSHandlerEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _INSHandlerEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _INSHandlerEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _INSHandlerEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _INSHandlerEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___INSHandlerEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_INSHandler;

#ifdef __cplusplus

class DECLSPEC_UUID("6342E1B6-94DB-11D1-ADE2-0000F87734F0")
INSHandler;
#endif
#endif /* __ICWHELPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\icwhelp_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0158 */
/* at Fri May 08 10:39:03 1998
 */
/* Compiler settings for icwhelp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IRefDial = {0x1E794A09,0x86F4,0x11D1,{0xAD,0xD8,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID IID_IDialErr = {0x462F7757,0x8848,0x11D1,{0xAD,0xD8,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID IID_ISmartStart = {0x5D8D8F19,0x8B89,0x11D1,{0xAD,0xDB,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID IID_IICWSystemConfig = {0x7954DD9A,0x8C2A,0x11D1,{0xAD,0xDB,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID IID_ITapiLocationInfo = {0xCB632C75,0x8DD4,0x11D1,{0xAD,0xDF,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID IID_IUserInfo = {0x9E12E76C,0x94D6,0x11D1,{0xAD,0xE2,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID IID_IWebGate = {0x3724B9A0,0x9503,0x11D1,{0xB8,0x6A,0x00,0xA0,0xC9,0x0D,0xC8,0x49}};


const IID IID_IINSHandler = {0x6342E1B5,0x94DB,0x11D1,{0xAD,0xE2,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID LIBID_ICWHELPLib = {0x1E7949FA,0x86F4,0x11D1,{0xAD,0xD8,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID DIID__RefDialEvents = {0x07DB96D0,0x91D8,0x11D1,{0xAD,0xE1,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_RefDial = {0x1E794A0A,0x86F4,0x11D1,{0xAD,0xD8,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_DialErr = {0x462F7758,0x8848,0x11D1,{0xAD,0xD8,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_SmartStart = {0x5D8D8F1A,0x8B89,0x11D1,{0xAD,0xDB,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_ICWSystemConfig = {0x7954DD9B,0x8C2A,0x11D1,{0xAD,0xDB,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_TapiLocationInfo = {0xCB632C76,0x8DD4,0x11D1,{0xAD,0xDF,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_UserInfo = {0x9E12E76D,0x94D6,0x11D1,{0xAD,0xE2,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID DIID__WebGateEvents = {0x166A20C0,0xAE10,0x11D1,{0xAD,0xEB,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_WebGate = {0x3724B9A1,0x9503,0x11D1,{0xB8,0x6A,0x00,0xA0,0xC9,0x0D,0xC8,0x49}};


const IID DIID__INSHandlerEvents = {0x1F6D88A2,0x98D2,0x11d1,{0xAD,0xE3,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_INSHandler = {0x6342E1B6,0x94DB,0x11D1,{0xAD,0xE2,0x00,0x00,0xF8,0x77,0x34,0xF0}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\icwerr.h ===
#define IDS_PPPRANDOMFAILURE 6999
#define IDS_RASNOCARRIER     6998
#define IDS_PHONEBUSY        6997
#define IDS_NODIALTONE       6996
#define IDS_NODEVICE         6995
#define IDS_USERCANCELEDDIAL 6994
#define IDS_MEDIAINIERROR    6993
#define IDS_NOANSWER         6992
#define IDS_TCPINSTALLERROR  6991

#define IDS_RAS_DIALING      6990
#define IDS_RAS_PORTOPENED   6989
#define IDS_RAS_OPENPORT      6988
#define IDS_RAS_CONNECTED     6987
#define IDS_RAS_LOCATING      6986

#if !defined(ERROR_USERCANCEL)
#define ERROR_USERCANCEL 32767
#endif

#if !defined(ERROR_USERBACK)
#define ERROR_USERBACK 32766
#endif

#if !defined(ERROR_USERNEXT)
#define ERROR_USERNEXT 32765
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\icwunicd.h ===
//**********************************************************************
// File name: icwunicd.h
//
//      Commonly used UNICDE definition header.
//
// Copyright (c) 1993-1999 Microsoft Corporation. All rights reserved.
//**********************************************************************
#ifndef _ICWUNICD_H_
#define _ICWUNICD_H_

#ifdef UNICODE
#define REALLY_USE_UNICODE
#endif

#include <tchar.h>   // _tsplitpath, _tmakepath, _ttoi, _itot

#endif // _ICWUNICD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\mcreg.h ===
#pragma once

class CMcRegistry
{
public:
    CMcRegistry();
    ~CMcRegistry();

public:
    bool OpenKey(HKEY hkeyStart, LPCTSTR strKey, REGSAM sam = KEY_READ | KEY_WRITE);
    bool CreateKey(HKEY hkeyStart, LPCTSTR strKey);
    bool CloseKey();

    bool GetValue(LPCTSTR strValue, LPTSTR strData, ULONG nBufferSize);
    bool GetValue(LPCTSTR strValue, DWORD& rdw);

    bool SetValue(LPCTSTR strValue, LPCTSTR strData);
    bool SetValue(LPCTSTR strValue, DWORD rdw);

private:
    HKEY    m_hkey;
};

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\inetapi.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************

//
// INETAPI.H -  APIs for system configuration for Internet and phone number
//              setting
//

//  HISTORY:
//  
//  3/3/95  jeremys     Created.
//  96/03/21  markdu  Use private string sizes (MSN_) for PHONENUM since the
//            RAS ones (RAS_) change depending on platform, but MSN does not
//            expect this so the structure sizes won't match on existing code.
//

#ifndef _INETAPI_H_
#define _INETAPI_H_

#ifndef _RNAP_H_
// (copied from RNA header file)

#define MSN_MaxAreaCode     10
#define MSN_MaxLocal        36
#define MSN_MaxExtension    5

typedef struct tagPHONENUMA {
    DWORD dwCountryID;
    DWORD dwCountryCode;
    CHAR  szAreaCode[MSN_MaxAreaCode+1];
    CHAR  szLocal[MSN_MaxLocal+1];
    CHAR  szExtension[MSN_MaxExtension+1];
} PHONENUMA, FAR * LPPHONENUMA;

typedef struct tagPHONENUMW {
    DWORD dwCountryID;
    DWORD dwCountryCode;
    WCHAR szAreaCode[MSN_MaxAreaCode+1];
    WCHAR szLocal[MSN_MaxLocal+1];
    WCHAR szExtension[MSN_MaxExtension+1];
} PHONENUMW, FAR * LPPHONENUMW;

#ifdef UNICODE
#define PHONENUM     PHONENUMW
#define LPPHONENUM   LPPHONENUMW
#else
#define PHONENUM     PHONENUMA
#define LPPHONENUM   LPPHONENUMA
#endif

#endif // ifndef _RNAP_H_

// input flags for APIs
#define ICIF_NOCONFIGURE    0x0001  // for SetInternetPhoneNumber, see comments below
#define ICIF_DONTSETASINTERNETENTRY 0x0002  // if set, phone number will be updated
                            // but this connectoid will not be set as the internet connectoid
#define ICIF_NODNSCHECK     0x0004  // if set, won't check and warn if static DNS is set

// output flags for APIs
#define ICOF_NEEDREBOOT     0x0001  // indicates that caller must restart system


// structures used to contain API parameters

typedef struct tagINTERNET_CONFIGA
{
    DWORD cbSize;           // size of this structure in bytes
    HWND hwndParent;        // parent window handle

    LPCSTR pszModemName;    // name of modem to use
    LPCSTR pszUserName;     // user name for RNA connectoid (ignored if NULL)
    LPCSTR pszPassword;     // password for RNA connectoid (ignored if NULL)

    PHONENUMA PhoneNum;     // phone number to use
    LPCSTR pszEntryName;    // title to use for RNA connectoid (default name
                            // used if NULL)

    PHONENUMA PhoneNum2;    // backup phone number to use
    LPCSTR pszEntryName2;   // title to use for RNA connectoid (default name
                            // used if NULL)


    LPCSTR pszDNSServer;    // points to string w/IP address (e.g. "108.9.107.4");
                            // (ignored if NULL)
    LPCSTR pszDNSServer2;   // points to string w/IP address(e.g. "108.9.107.4");
                            // (ignored if NULL)

    LPCSTR pszAutodialDllName;  // optional: name of autodial dll to use (ignored if NULL)
    LPCSTR pszAutodialFcnName;  // optional: name of function in autodiall dll to use (ignored if NULL)

    DWORD dwInputFlags;     // at entry, some combination of ICIF_ flags
    DWORD dwOutputFlags;    // at return, set to some combination of ICOF_ flags

} INTERNET_CONFIGA, FAR * LPINTERNET_CONFIGA;

typedef struct tagINTERNET_CONFIGW
{
    DWORD cbSize;           // size of this structure in bytes
    HWND hwndParent;        // parent window handle

    LPCWSTR pszModemName;   // name of modem to use
    LPCWSTR pszUserName;    // user name for RNA connectoid (ignored if NULL)
    LPCWSTR pszPassword;    // password for RNA connectoid (ignored if NULL)

    PHONENUMW PhoneNum;     // phone number to use
    LPCWSTR pszEntryName;   // title to use for RNA connectoid (default name
                            // used if NULL)

    PHONENUMW PhoneNum2;    // backup phone number to use
    LPCWSTR pszEntryName2;  // title to use for RNA connectoid (default name
                            // used if NULL)


    LPCWSTR pszDNSServer;   // points to string w/IP address (e.g. "108.9.107.4");
                            // (ignored if NULL)
    LPCWSTR pszDNSServer2;  // points to string w/IP address(e.g. "108.9.107.4");
                            // (ignored if NULL)

    LPCWSTR pszAutodialDllName;  // optional: name of autodial dll to use (ignored if NULL)
    LPCWSTR pszAutodialFcnName;  // optional: name of function in autodiall dll to use (ignored if NULL)

    DWORD dwInputFlags;     // at entry, some combination of ICIF_ flags
    DWORD dwOutputFlags;    // at return, set to some combination of ICOF_ flags

} INTERNET_CONFIGW, FAR * LPINTERNET_CONFIGW;

#ifdef UNICODE
typedef INTERNET_CONFIGW    INTERNET_CONFIG;
typedef LPINTERNET_CONFIGW  LPINTERNET_CONFIG;
#else
typedef INTERNET_CONFIGA    INTERNET_CONFIG;
typedef LPINTERNET_CONFIGA  LPINTERNET_CONFIG;
#endif
 
// function prototypes


/*******************************************************************

    NAME:       ConfigureSystemForInternet

    SYNOPSIS:   Performs all necessary configuration to set system up
                to use Internet.

    ENTRY:      lpInternetConfig - pointer to structure with configuration
                information.

    EXIT:       TRUE if successful, or FALSE if fails.  Displays its
                own error message upon failure.

                If the output flag ICOF_NEEDREBOOT is set, the caller
                must restart the system before continuing.

    NOTES:      Will install TCP/IP, RNA, PPPMAC as necessary; will
                create or modify an Internet RNA connectoid.

                This API displays error messages itself rather than
                passing back an error code because there is a wide range of
                possible error codes from different families, it is difficult
                for the caller to obtain text for all of them.
                
********************************************************************/
extern "C" BOOL WINAPI ConfigureSystemForInternetA(LPINTERNET_CONFIGA lpInternetConfig);
extern "C" BOOL WINAPI ConfigureSystemForInternetW(LPINTERNET_CONFIGW lpInternetConfig);

#ifdef UNICODE
#define ConfigureSystemForInternet ConfigureSystemForInternetW
#else
#define ConfigureSystemForInternet ConfigureSystemForInternetA
#endif


/*******************************************************************

    NAME:       SetInternetPhoneNumber

    SYNOPSIS:   Sets the phone number used to auto-dial to the Internet.

                If the system is not fully configured when this API is called,
                this API will do the configuration after checking with the user.
                (This step is included for extra robustness, in case the user has
                removed something since the system was configured.)
    
    ENTRY:      lpPhonenumConfig - pointer to structure with configuration
                information.

                If the input flag ICIF_NOCONFIGURE is set, then if the system
                is not already configured properly, this API will display an
                error message and return FALSE.  (Otherwise this API will
                ask the user if it's OK to configure the system, and do it.)

    EXIT:       TRUE if successful, or FALSE if fails.  Displays its
                own error message upon failure.

                If the output flag ICOF_NEEDREBOOT is set, the caller
                must restart the system before continuing.  (

    NOTES:      Will create a new connectoid if a connectoid for the internet
                does not exist yet, otherwise modifies existing internet
                connectoid.

                This API displays error messages itself rather than
                passing back an error code because there is a wide range of
                possible error codes from different families, it is difficult
                for the caller to obtain text for all of them.
                
********************************************************************/
extern "C" BOOL WINAPI SetInternetPhoneNumberA(LPINTERNET_CONFIGA lpInternetConfig);
extern "C" BOOL WINAPI SetInternetPhoneNumberW(LPINTERNET_CONFIGW lpInternetConfig);

#ifdef UNICODE
#define SetInternetPhoneNumber  SetInternetPhoneNumberW
#else
#define SetInternetPhoneNumber  SetInternetPhoneNumberA
#endif

#endif // _INETAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\netmpr.h ===
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    netmpr.h

Abstract:

    DDK WINNET Header File for WIN32

Environment:

    User Mode -Win32

Notes:


Revision History:

    20-Mar-1995     LenS
        Created.

--*/

#ifndef _INC_NETMPR_
#define _INC_NETMPR_


//
//  Authentication and Logon/Logoff.
//

#define LOGON_DONE              0x00000001
#define LOGON_PRIMARY           0x00000002
#define LOGON_MUST_VALIDATE     0x00000004

#define LOGOFF_PENDING  1
#define LOGOFF_COMMIT   2
#define LOGOFF_CANCEL   3


//
//  Password Cache.
//

#ifndef PCE_STRUCT_DEFINED
#define PCE_STRUCT_DEFINED

struct PASSWORD_CACHE_ENTRY {
    WORD cbEntry;               /* size of this entry in bytes, incl. pad */
    WORD cbResource;            /* size of resource name in bytes */
    WORD cbPassword;            /* size of password in bytes */
    BYTE iEntry;                /* index number of this entry, for MRU */
    BYTE nType;                 /* type of entry (see below) */
    char abResource[1];         /* resource name (may not be ASCIIZ at all) */
};

#define PCE_MEMORYONLY          0x01    /* for flags field when adding */

/*
    Typedef for the callback routine passed to the enumeration functions.
    It will be called once for each entry that matches the criteria
    requested.  It returns TRUE if it wants the enumeration to
    continue, FALSE to stop.
*/
typedef BOOL (FAR PASCAL *CACHECALLBACK)( struct PASSWORD_CACHE_ENTRY FAR *pce, DWORD dwRefData );

#endif  /* PCE_STRUCT_DEFINED */

DWORD APIENTRY
WNetCachePassword(
    LPSTR pbResource,
    WORD  cbResource,
    LPSTR pbPassword,
    WORD  cbPassword,
    BYTE  nType,
    UINT  fnFlags
    );

DWORD APIENTRY
WNetGetCachedPassword(
    LPSTR  pbResource,
    WORD   cbResource,
    LPSTR  pbPassword,
    LPWORD pcbPassword,
    BYTE   nType
    );

DWORD APIENTRY
WNetRemoveCachedPassword(
    LPSTR pbResource,
    WORD  cbResource,
    BYTE  nType
    );

DWORD APIENTRY
WNetEnumCachedPasswords(
    LPSTR pbPrefix,
    WORD  cbPrefix,
    BYTE  nType,
    CACHECALLBACK pfnCallback,
    DWORD dwRefData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\inetcfg.h ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996 - 97
//
//  *** N O T   F O R   E X T E R N A L   R E L E A S E *******
//  This header file is not intended for distribution outside Microsoft.
//
//  FILE: INETCFG.H
//
//  PURPOSE:  Contains API's exported from inetcfg.dll and structures
//            required by those functions. 
//            Note:  Definitions in this header file require RAS.H.
//
//*******************************************************************

#ifndef _INETCFG_H_
#define _INETCFG_H_

#ifndef UNLEN
#include <lmcons.h>
#endif

// Generic HRESULT error code
#define ERROR_INETCFG_UNKNOWN 0x20000000L

#define MAX_EMAIL_NAME          64
#define MAX_EMAIL_ADDRESS       128
#define MAX_LOGON_NAME          UNLEN
#define MAX_LOGON_PASSWORD      PWLEN
#define MAX_SERVER_NAME         64  // max length of DNS name per RFC 1035 +1

// IE Auto proxy value in registry
#define AUTO_ONCE_EVER              0           // Auto proxy discovery
#define AUTO_DISABLED               1 
#define AUTO_ONCE_PER_SESSION       2
#define AUTO_ALWAYS                 3

// Flags for dwfOptions

// install Internet mail
#define INETCFG_INSTALLMAIL           0x00000001
// Invoke InstallModem wizard if NO MODEM IS INSTALLED
#define INETCFG_INSTALLMODEM          0x00000002
// install RNA (if needed)
#define INETCFG_INSTALLRNA            0x00000004
// install TCP (if needed)
#define INETCFG_INSTALLTCP            0x00000008
// connecting with LAN (vs modem)
#define INETCFG_CONNECTOVERLAN        0x00000010
// Set the phone book entry for autodial
#define INETCFG_SETASAUTODIAL         0x00000020
// Overwrite the phone book entry if it exists
// Note: if this flag is not set, and the entry exists, a unique name will
// be created for the entry.
#define INETCFG_OVERWRITEENTRY        0x00000040
// Do not show the dialog that tells the user that files are about to be installed,
// with OK/Cancel buttons.
#define INETCFG_SUPPRESSINSTALLUI     0x00000080
// Check if TCP/IP file sharing is turned on, and warn user to turn it off.
// Reboot is required if the user turns it off.
#define INETCFG_WARNIFSHARINGBOUND    0x00000100
// Check if TCP/IP file sharing is turned on, and force user to turn it off.
// If user does not want to turn it off, return will be ERROR_CANCELLED
// Reboot is required if the user turns it off.
#define INETCFG_REMOVEIFSHARINGBOUND  0x00000200
// Indicates that this is a temporary phone book entry
// In Win3.1 an icon will not be created
#define INETCFG_TEMPPHONEBOOKENTRY    0x00000400
// Show the busy dialog while checking system configuration
#define INETCFG_SHOWBUSYANIMATION     0x00000800

//
// Chrisk 5/8/97
// Note: the next three switches are only valid for InetNeedSystemComponents
// Check if LAN adapter is installed and bound to TCP
//
#define INETCFG_INSTALLLAN            0x00001000

//
// Check if DIALUP adapter is installed and bound to TCP
//
#define INETCFG_INSTALLDIALUP         0x00002000

//
// Check to see if TCP is installed requardless of binding
//
#define INETCFG_INSTALLTCPONLY        0x00004000

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

// constants for INETCLIENTINFO.dwFlags

#define INETC_LOGONMAIL     0x00000001
#define INETC_LOGONNEWS     0x00000002
#define INETC_LOGONDIRSERV  0x00000004

// Struct INETCLIENTINFO
//
// This structure is used when getting and setting the internet
// client parameters
//
// The members are as follows:
//
//  dwSize
//    size of this structure, for future versioning
//    this member should be set before passing the structure to the DLL
//  dwFlags
//    miscellaneous flags
//    see definitions above
//  szEMailName
//    user's internet email name
//  szEMailAddress
//    user's internet email address
//  ***Note: the following three fields are outdated, and should only be used by old legacy code.
//  ***      new code should use szIncomingMail* and iIncomingProtocol fields.
//  szPOPLogonName
//    user's internet mail server logon name 
//  szPOPLogonPassword
//    user's internet mail server logon password
//  szPOPServer
//    user's internet mail POP3 server
//  szSMTPServer
//    user's internet mail SMTP server
//  szNNTPLogonName
//    user's news server logon name
//  szNNTPLogonPassword
//    user's news server logon password
//  szNNTPServer
//    user's news server
//  ** End of original 1.0 structure.
//  ??/??/96 ValdonB
//  szNNTPName
//    user's friendly name to include in NNTP posts.(?? Valdon?)
//  szNNTPAddress
//    user's reply-to email address for NNTP posts.(?? Valdon?)
//  11/23/96  jmazner Normandy #8504
//  iIncomingProtocol
//    user's choice of POP3 or IMAP4 protocol for incoming mail
//    Holds the enum values defined in ACCTTYPE from imact.h//
//  szIncomingMailLogonName
//    user's internet mail server logon name 
//  szIncomingMailLogonPassword
//    user's internet mail server logon password
//  szIncomingMailServer
//    user's internet mail POP3 server
//  12/15/96    jmazner 
//  fMailLogonSPA
//    Use Sicily/SPA/DPA for the incoming mail server
//  fNewsLogonSPA
//    Use Sicily/SPA/DPA for the news server
//  2/4/96 jmazner -- LDAP functionality
//  szLDAPLogonName
//  szLDAPLogonPassword
//  szLDAPServer
//  fLDAPLogonSPA
//  fLDAPResolve

  typedef struct tagINETCLIENTINFOA
  {
    DWORD   dwSize;
    DWORD   dwFlags;
    CHAR    szEMailName[MAX_EMAIL_NAME + 1];
    CHAR    szEMailAddress[MAX_EMAIL_ADDRESS + 1];
    CHAR    szPOPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szPOPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szPOPServer[MAX_SERVER_NAME + 1];
    CHAR    szSMTPServer[MAX_SERVER_NAME + 1];
    CHAR    szNNTPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szNNTPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szNNTPServer[MAX_SERVER_NAME + 1];
    // end of version 1.0 structure;
    // extended 1.1 structure includes the following fields:
    CHAR    szNNTPName[MAX_EMAIL_NAME + 1];
    CHAR    szNNTPAddress[MAX_EMAIL_ADDRESS + 1];
    int     iIncomingProtocol;
    CHAR    szIncomingMailLogonName[MAX_LOGON_NAME + 1];
    CHAR    szIncomingMailLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szIncomingMailServer[MAX_SERVER_NAME + 1];
    BOOL    fMailLogonSPA;
    BOOL    fNewsLogonSPA;
    CHAR    szLDAPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szLDAPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szLDAPServer[MAX_SERVER_NAME + 1];
    BOOL    fLDAPLogonSPA;
    BOOL    fLDAPResolve;

  } INETCLIENTINFOA, *PINETCLIENTINFOA, FAR *LPINETCLIENTINFOA;

  typedef struct tagINETCLIENTINFOW
  {
    DWORD   dwSize;
    DWORD   dwFlags;
    WCHAR   szEMailName[MAX_EMAIL_NAME + 1];
    WCHAR   szEMailAddress[MAX_EMAIL_ADDRESS + 1];
    WCHAR   szPOPLogonName[MAX_LOGON_NAME + 1];
    WCHAR   szPOPLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR   szPOPServer[MAX_SERVER_NAME + 1];
    WCHAR   szSMTPServer[MAX_SERVER_NAME + 1];
    WCHAR   szNNTPLogonName[MAX_LOGON_NAME + 1];
    WCHAR   szNNTPLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR   szNNTPServer[MAX_SERVER_NAME + 1];
    // end of version 1.0 structure;
    // extended 1.1 structure includes the following fields:
    WCHAR   szNNTPName[MAX_EMAIL_NAME + 1];
    WCHAR   szNNTPAddress[MAX_EMAIL_ADDRESS + 1];
    int     iIncomingProtocol;
    WCHAR   szIncomingMailLogonName[MAX_LOGON_NAME + 1];
    WCHAR   szIncomingMailLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR   szIncomingMailServer[MAX_SERVER_NAME + 1];
    BOOL    fMailLogonSPA;
    BOOL    fNewsLogonSPA;
    WCHAR   szLDAPLogonName[MAX_LOGON_NAME + 1];
    WCHAR   szLDAPLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR   szLDAPServer[MAX_SERVER_NAME + 1];
    BOOL    fLDAPLogonSPA;
    BOOL    fLDAPResolve;

  } INETCLIENTINFOW, *PINETCLIENTINFOW, FAR *LPINETCLIENTINFOW;

#ifdef UNICODE
typedef INETCLIENTINFOW     INETCLIENTINFO;
typedef PINETCLIENTINFOW    PINETCLIENTINFO;
typedef LPINETCLIENTINFOW   LPINETCLIENTINFO;
#else
typedef INETCLIENTINFOA     INETCLIENTINFO;
typedef PINETCLIENTINFOA    PINETCLIENTINFO;
typedef LPINETCLIENTINFOA   LPINETCLIENTINFO;
#endif

// Function prototypes

//*******************************************************************
//
//  FUNCTION:   InetGetClientInfo
//
//  PURPOSE:    This function will get the internet client params
//              from the registry
//
//  PARAMETERS: lpClientInfo - on return, this structure will contain
//              the internet client params as set in the registry.
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetGetClientInfoA(
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFOA lpClientInfo);

HRESULT WINAPI InetGetClientInfoW(
  LPCWSTR           lpszProfileName,
  LPINETCLIENTINFOW lpClientInfo);

#ifdef UNICODE
#define InetGetClientInfo   InetGetClientInfoW
#else
#define InetGetClientInfo   InetGetClientInfoA
#endif


//*******************************************************************
//
//  FUNCTION:   InetSetClientInfo
//
//  PURPOSE:    This function will set the internet client params
//
//  PARAMETERS: lpClientInfo - pointer to struct with info to set
//              in the registry.
//              lpszProfileName - Name of client info profile to
//              modify.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetSetClientInfoA(
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFOA lpClientInfo);

HRESULT WINAPI InetSetClientInfoW(
  LPCWSTR           lpszProfileName,
  LPINETCLIENTINFOW lpClientInfo);

#ifdef UNICODE
#define InetSetClientInfo   InetSetClientInfoW
#else
#define InetSetClientInfo   InetSetClientInfoA
#endif

//*******************************************************************
//
//  FUNCTION:   InetConfigSystem
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install Internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetConfigSystem(
  HWND    hwndParent,          
  DWORD   dwfOptions,         
  LPBOOL  lpfNeedsRestart);  


//*******************************************************************
//
//  FUNCTION:   InetConfigSystemFromPath
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags and from the given [ath.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install Internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//              lpszSourcePath - full path of location of files to install.  If
//              this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetConfigSystemFromPathA(
  HWND    hwndParent,
  DWORD   dwfOptions,
  LPBOOL  lpfNeedsRestart,
  LPCSTR  lpszSourcePath);

HRESULT WINAPI InetConfigSystemFromPathW(
  HWND    hwndParent,
  DWORD   dwfOptions,
  LPBOOL  lpfNeedsRestart,
  LPCWSTR lpszSourcePath);

#ifdef UNICODE
#define InetConfigSystemFromPath  InetConfigSystemFromPathW
#else
#define InetConfigSystemFromPath  InetConfigSystemFromPathA
#endif

//*******************************************************************
//
//  FUNCTION:   InetConfigClient
//
//  PURPOSE:    This function requires a valid phone book entry name
//              (unless it is being used just to set the client info).
//              If lpRasEntry points to a valid RASENTRY struct, the phone
//              book entry will be created (or updated if it already exists)
//              with the data in the struct.
//              If username and password are given, these
//              will be set as the dial params for the phone book entry.
//              If a client info struct is given, that data will be set.
//              Any files (ie TCP and RNA) that are needed will be
//              installed by calling InetConfigSystem().
//              This function will also perform verification on the device
//              specified in the RASENTRY struct.  If no device is specified,
//              the user will be prompted to install one if there are none
//              installed, or they will be prompted to choose one if there
//              is more than one installed.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              lpszPhonebook - name of phone book to store the entry in
//              lpszEntryName - name of phone book entry to be
//              created or modified
//              lpRasEntry - specifies a RASENTRY struct that contains
//              the phone book entry data for the entry lpszEntryName
//              lpszUsername - username to associate with the phone book entry
//              lpszPassword - password to associate with the phone book entry
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//              lpINetClientInfo - client information
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install Internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.  Note that if
//                                       no modem is installed and this flag
//                                       is not set, the function will fail
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_SETASAUTODIAL - Set the phone book entry for autodial
//                INETCFG_OVERWRITEENTRY - Overwrite the phone book entry if it
//                                         exists.  Note: if this flag is not
//                                         set, and the entry exists, a unique
//                                         name will be created for the entry.
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetConfigClientA(
  HWND              hwndParent,         
  LPCSTR            lpszPhonebook,
  LPCSTR            lpszEntryName,
  LPRASENTRY        lpRasEntry,         
  LPCSTR            lpszUsername,       
  LPCSTR            lpszPassword,       
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFOA lpINetClientInfo,   
  DWORD             dwfOptions,                     
  LPBOOL            lpfNeedsRestart);              

HRESULT WINAPI InetConfigClientW(
  HWND              hwndParent,         
  LPCWSTR           lpszPhonebook,
  LPCWSTR           lpszEntryName,
  LPRASENTRY        lpRasEntry,         
  LPCWSTR           lpszUsername,       
  LPCWSTR           lpszPassword,       
  LPCWSTR           lpszProfileName,
  LPINETCLIENTINFOW lpINetClientInfo,   
  DWORD             dwfOptions,                     
  LPBOOL            lpfNeedsRestart);              

#ifdef UNICODE
#define InetConfigClient    InetConfigClientW
#else
#define InetConfigClient    InetConfigClientA
#endif

//*******************************************************************
//
//  FUNCTION:   InetGetAutodial
//
//  PURPOSE:    This function will get the autodial settings from the registry.
//
//  PARAMETERS: lpfEnable - on return, this will be TRUE if autodial
//              is enabled
//              lpszEntryName - on return, this buffer will contain the 
//              name of the phone book entry that is set for autodial
//              cbEntryNameSize - size of buffer for phone book entry name
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetGetAutodialA(
  LPBOOL  lpfEnable,     
  LPSTR   lpszEntryName,  
  DWORD   cbEntryNameSize);

HRESULT WINAPI InetGetAutodialW(
  LPBOOL  lpfEnable,     
  LPWSTR  lpszEntryName,  
  DWORD   cbEntryNameSize);

#ifdef UNICODE
#define InetGetAutodial   InetGetAutodialW
#else
#define InetGetAutodial   InetGetAutodialA
#endif

//*******************************************************************
//
//  FUNCTION:   InetSetAutodial
//
//  PURPOSE:    This function will set the autodial settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, autodial will be enabled.
//                        If set to FALSE, autodial will be disabled.
//              lpszEntryName - name of the phone book entry to set
//                              for autodial.  If this is "", the
//                              entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetSetAutodialA(
  BOOL    fEnable,       
  LPCSTR  lpszEntryName); 

HRESULT WINAPI   InetSetAutodialW(
  BOOL    fEnable,       
  LPCWSTR lpszEntryName); 

#ifdef UNICODE
#define InetSetAutodial    InetSetAutodialW
#else
#define InetSetAutodial    InetSetAutodialA
#endif

//*******************************************************************
//
//  FUNCTION:   InetSetAutoProxy
//
//  PURPOSE:    This function will set the auto config proxy settings
//              in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//              dwProxyDetectMode - value to be update in the
//                                  HKEY_CURRENT_USER\Software\Microsoft
//                                  \Windows\CurrentVersion\Internet Settings
//                                  AutoProxyDetectMode
//              lpszScriptAddr - value to be update in 
//                                  HKEY_CURRENT_USER\Software\Microsoft
//                                  \Windows\CurrentVersion\Internet Settings
//                                  AutoConfigURL
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetSetAutoProxyA(
  BOOL    fEnable,
  DWORD   dwProxyDetectMode,
  LPCSTR  lpszScriptAddr);

HRESULT WINAPI   InetSetAutoProxyW(
  BOOL    fEnable,
  DWORD   dwProxyDetectMode,
  LPCWSTR lpszScriptAddr);

#ifdef UNICODE
#define InetSetAutoProxy   InetSetAutoProxyW
#else
#define InetSetAutoProxy   InetSetAutoProxyA
#endif

//*******************************************************************
//
//  FUNCTION:   InetSetProxy
//
//  PURPOSE:    This function is currently replaced by InetSetProxyEx
//              due to a change in Wininet API. It will return 
//              ERROR_SUCCESS.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//              lpszServer - name of the proxy server.  If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//              lpszOverride - proxy override. If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    ERROR_SUCCESS
//
//*******************************************************************

HRESULT WINAPI   InetSetProxyA(
  BOOL    fEnable,
  LPCSTR  lpszServer,
  LPCSTR  lpszOverride);

HRESULT WINAPI   InetSetProxyW(
  BOOL    fEnable,
  LPCWSTR lpszServer,
  LPCWSTR lpszOverride);

#ifdef UNICODE
#define InetSetProxy   InetSetProxyW
#else
#define InetSetProxy   InetSetProxyA
#endif

//*******************************************************************
//
//  FUNCTION:   InetSetProxyEx
//
//  PURPOSE:    This function will set the proxy settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//                        If set to FALSE, proxy will be disabled.
//              lpszConnectoidName - Name of connectoid to set proxy on
//                                   NULL for LAN
//              lpszServer - name of the proxy server.  If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//              lpszOverride - proxy override. If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetSetProxyExA(
  BOOL    fEnable,
  LPCSTR  lpszConnectoidName,
  LPCSTR  lpszServer,
  LPCSTR  lpszOverride);

HRESULT WINAPI   InetSetProxyExW(
  BOOL    fEnable,
  LPCWSTR lpszConnectoidName,
  LPCWSTR lpszServer,
  LPCWSTR lpszOverride);

#ifdef UNICODE
#define InetSetProxyEx   InetSetProxyExW
#else
#define InetSetProxyEx   InetSetProxyExA
#endif

//*******************************************************************
//
//  FUNCTION:   InetGetProxy
//
//  PURPOSE:    This function will get the proxy settings from the registry.
//
//  PARAMETERS: lpfEnable - on return, this will be TRUE if proxy
//              is enabled
//              lpszServer - on return, this buffer will contain the 
//              name of the proxy server
//              cbServer - size of buffer for proxy server name
//              lpszOverride - on return, this buffer will contain the 
//              name of the proxy server
//              cbOverride - size of buffer for proxy override
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetGetProxyA(
  LPBOOL  lpfEnable,
  LPSTR   lpszServer,
  DWORD   cbServer,
  LPSTR   lpszOverride,
  DWORD   cbszOverride);

HRESULT WINAPI   InetGetProxyW(
  LPBOOL  lpfEnable,
  LPWSTR  lpszServer,
  DWORD   cbServer,
  LPWSTR  lpszOverride,
  DWORD   cbszOverride);

#ifdef UNICODE
#define InetGetProxy    InetGetProxyW
#else
#define InetGetProxy    InetGetProxyA
#endif

//*******************************************************************
//
//  FUNCTION:   InetStartServices
//
//  PURPOSE:    This function guarentees that RAS services are running
//
//  PARAMETERS: none
//
//  RETURNS     ERROR_SUCCESS - if the services are enabled and running
//
//*******************************************************************
HRESULT WINAPI  InetStartServices();

//*******************************************************************
//
//  Function:   IsSmartStart
//
//  Synopsis:   This function will determine if the ICW should be run.  The
//              decision is made based on the current state of the user's machine.
//              
//  Arguments:  none
//
//  Returns:    TRUE - run ICW; FALSE - quit now
//
//  History:    5/8/97  ChrisK  Created
//
//*******************************************************************
DWORD WINAPI IsSmartStart();

//*******************************************************************
//
//  FUNCTION:   SetAutoProxyConnectoid
//
//  PURPOSE:    This function will set the enable/disable auto
//              proxy settings in creating connectoid.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//
//*******************************************************************

HRESULT WINAPI SetAutoProxyConnectoid( BOOL bEnable);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //_INETCFG_H_#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\ocdbid.h ===
/*=--------------------------------------------------------------------------=
 * ocdbid.h
 *=--------------------------------------------------------------------------=
 * defines all the guids for OLE Controls Data Binding Interfaces interfaces.
 *
 * Copyright (c) 1994-1997 Microsoft Corporation, All Rights Reserved.
 *
 */

/* {9F6AA700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursor,
0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {ACFF0690-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorMove,
0xacff0690, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {BB87E420-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorScroll,
0xbb87e420, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {D14216A0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorUpdateARow,
0xd14216a0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {DB526CC0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_INotifyDBEvents,
0xdb526cc0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E01D7850-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorFind,
0xe01d7850, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E4D19810-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_IEntryID,
0xe4d19810, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E8BF1170-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_GUID_NAMEONLY,
0xe8bf1170, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {F6304BB0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_DBBMKGUID,
0xf6304bb0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {FE284700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_DBCIDGUID,
0xfe284700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\ocdb.h ===
/*=--------------------------------------------------------------------------=
 * ocdb.h
 *=--------------------------------------------------------------------------=
 * defines the interfaces and constants for use with the OLE Controls Data
 * binding interfaces.
 *
 * Copyright (c) 1994-1997 Microsoft Corporation, All Rights Reserved.
 *
 *
 *
 */
#ifndef __OCDB_H_

#undef Delete
#ifdef __cplusplus
extern "C" {
#endif

/* LPDBSTRs are MultiByte in 16bits, and Unicode in 32bits.
 */
#if defined(_WIN32) && !defined(OLE2ANSI)

#define LPDBSTR           LPWSTR
#define DBCHAR            WCHAR
#define ldbstrlen(str)    wcslen(str)
#define ldbstrcpy(a, b)   wcscpy((a), (b))
#define ldbstrcpyn(a,b,n) wcsncpy((a), (b), (n))
#define ldbstrcmp(a, b)   wcscmp((a), (b))
#define ldbstrcat(a, b)   wcscat((a), (b))
#define ldbstrcmpi(a,b)   wcsicmp((a),(b))
#define DBTEXT(quote)     L##quote

#else

#define LPDBSTR           LPSTR
#define DBCHAR            char
#define ldbstrlen(str)    lstrlen(str)
#define ldbstrcpy(a, b)   lstrcpy((a), (b))
#define ldbstrcpyn(a,b,n) lstrcpyn((a), (b), (n))
#define ldbstrcmp(a, b)   lstrcmp((a), (b))
#define ldbstrcat(a, b)   lstrcat((a), (b))
#define ldbstrcmpi(a,b)   lstrcmpi((a),(b))
#define DBTEXT(quote)     quote

#endif /* _WIN32 && !OLE2ANSI */

typedef LPDBSTR FAR *  LPLPDBSTR;


/* Many systems don't have BLOBs defined.
 */
#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED

typedef struct tagBLOB {

    ULONG cbSize;
    BYTE *pBlobData;

} BLOB, *LPBLOB;

#endif

/*----------------------------------------------------------------------------
 *
 *  dbvar.h
 *
 *----------------------------------------------------------------------------
 */
#ifndef _DBCOLUMNID_DEFINED
#define _DBCOLUMNID_DEFINED
typedef enum tagDBCOLKIND
  {
    DBCOLKIND_GUID_NAME = 0,
    DBCOLKIND_GUID_NUMBER = 1,
        DBCOLKIND_NAME = 2
  }
DBCOLKIND;

#define GUID_NAMEONLY   {0x88c8d398,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#define GUID_NUMBERONLY {0x88c8d399,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}

typedef struct tagDBCOLUMNID
  {
  GUID guid;
  DBCOLKIND dwKind;
union
    {
    LONG lNumber;
    LPDBSTR lpdbsz;
    }
  ;
  }
DBCOLUMNID;
#endif   /* ndef _COLUMNID_DEFINED */

#ifndef _DBVARENUM_DEFINED
#define _DBVARENUM_DEFINED
enum DBVARENUM
  {
    DBTYPE_EMPTY = 0,
    DBTYPE_NULL = 1,
    DBTYPE_I2 = 2,
    DBTYPE_I4 = 3,
    DBTYPE_R4 = 4,
    DBTYPE_R8 = 5,
    DBTYPE_CY = 6,
    DBTYPE_DATE = 7,
    DBTYPE_BOOL = 11,
    DBTYPE_UI2 = 18,
    DBTYPE_UI4 = 19,
        DBTYPE_I8 = 20,
        DBTYPE_UI8 = 21,
    DBTYPE_HRESULT = 25,
    DBTYPE_LPSTR = 30,
    DBTYPE_LPWSTR = 31,
    DBTYPE_FILETIME = 64,
    DBTYPE_BLOB = 65,
    DBTYPE_UUID = 72,
    DBTYPE_DBEXPR = 503,
    DBTYPE_COLUMNID = 507,
    DBTYPE_BYTES = 508,
    DBTYPE_CHARS = 509,
    DBTYPE_WCHARS = 510,
    DBTYPE_ANYVARIANT = 511
  }
;
#endif   /* ndef _DBVARENUM_DEFINED */

#define DBTYPE_EXT      0x100
#define DBTYPE_VECTOR   0x1000

typedef struct tagDBVARIANT DBVARIANT;

struct FARSTRUCT tagDBVARIANT{
    VARTYPE vt;
    unsigned short wReserved1;
    unsigned short wReserved2;
    unsigned short wReserved3;
    union {
      unsigned char bVal;        /* VT_UI1               */
      short    iVal;             /* VT_I2                */
      long     lVal;             /* VT_I4                */
      float    fltVal;           /* VT_R4                */
      double       dblVal;           /* VT_R8                */
      VARIANT_BOOL xbool;             /* VT_BOOL              */
      SCODE    scode;            /* VT_ERROR             */
      CY       cyVal;            /* VT_CY                */
      DATE     date;             /* VT_DATE              */
      BSTR     bstrVal;          /* VT_BSTR              */
      IUnknown     FAR* punkVal;     /* VT_UNKNOWN           */
      IDispatch    FAR* pdispVal;    /* VT_DISPATCH          */
      SAFEARRAY    FAR* parray;      /* VT_ARRAY|*           */

      unsigned char FAR *pbVal;      /* VT_BYREF|VT_UI1      */
      short    FAR* piVal;       /* VT_BYREF|VT_I2       */
      long     FAR* plVal;       /* VT_BYREF|VT_I4       */
      float    FAR* pfltVal;     /* VT_BYREF|VT_R4       */
      double       FAR* pdblVal;     /* VT_BYREF|VT_R8       */
      VARIANT_BOOL FAR* pbool;       /* VT_BYREF|VT_BOOL     */
      SCODE    FAR* pscode;      /* VT_BYREF|VT_ERROR    */
      CY       FAR* pcyVal;      /* VT_BYREF|VT_CY       */
      DATE     FAR* pdate;       /* VT_BYREF|VT_DATE     */
      BSTR     FAR* pbstrVal;    /* VT_BYREF|VT_BSTR     */
      IUnknown  FAR* FAR* ppunkVal;  /* VT_BYREF|VT_UNKNOWN  */
      IDispatch FAR* FAR* ppdispVal; /* VT_BYREF|VT_DISPATCH */
      SAFEARRAY FAR* FAR* pparray;   /* VT_BYREF|VT_ARRAY|*  */
      VARIANT      FAR* pvarVal;     /* VT_BYREF|VT_VARIANT  */

      void     FAR* byref;       /* Generic ByRef        */

      // types new to DBVARIANTs
      //
      BLOB         blob;             /* VT_BLOB              */
      DBCOLUMNID  *pColumnid;        /* DBTYPE_COLUMNID      */
      LPSTR        pszVal;           /* VT_LPSTR             */
#ifdef WIN32
      LPWSTR       pwszVal;          /* VT_LPWSTR            */
      LPWSTR FAR  *ppwszVal;         /* VT_LPWSTR|VT_BYREF   */
#endif /* WIN32 */
      BLOB FAR    *pblob;            /* VT_BYREF|VT_BLOB     */
      DBCOLUMNID **ppColumnid;       /* VT_BYREF|DBTYPE_COLID*/
      DBVARIANT   *pdbvarVal;        /* VT_BYREF|DBTYPE_VARIANT */
    }
#if defined(NONAMELESSUNION) || (defined(_MAC) && !defined(__cplusplus) && !defined(_MSC_VER))
    u
#endif
    ;
};

/*----------------------------------------------------------------------------
 *
 *  dbs.h
 *
 *----------------------------------------------------------------------------
 */
typedef enum tagDBROWFETCH
  {
    DBROWFETCH_DEFAULT = 0,
    DBROWFETCH_CALLEEALLOCATES = 1,
    DBROWFETCH_FORCEREFRESH = 2
  }
DBROWFETCH;

typedef struct tagDBFETCHROWS
  {
  ULONG      cRowsRequested;
  DWORD      dwFlags;
  VOID HUGEP *pData;
  VOID HUGEP *pVarData;
  ULONG      cbVarData;
  ULONG      cRowsReturned;
  }
DBFETCHROWS;

#define DB_NOMAXLENGTH   (DWORD)0
#define DB_NOVALUE       (DWORD)0xFFFFFFFF
#define DB_NULL          (DWORD)0xFFFFFFFF
#define DB_EMPTY         (DWORD)0xFFFFFFFE
#define DB_USEENTRYID    (DWORD)0xFFFFFFFD
#define DB_CANTCOERCE    (DWORD)0xFFFFFFFC
#define DB_TRUNCATED     (DWORD)0xFFFFFFFB
#define DB_UNKNOWN       (DWORD)0xFFFFFFFA
#define DB_NOINFO        (DWORD)0xFFFFFFF9

typedef enum tagDBBINDING
  {
    DBBINDING_DEFAULT = 0,
    DBBINDING_VARIANT = 1,
    DBBINDING_ENTRYID = 2
  }
DBBINDING;

typedef enum tagDBBINDTYPE
  {
        DBBINDTYPE_DATA    = 0,
    DBBINDTYPE_ENTRYID = 1,
    DBBDINTYPE_EITHER  = 2,
    DBBINDTYPE_BOTH    = 3
  }
DBBINDTYPE;

typedef struct tagDBCOLUMNBINDING
  {
  DBCOLUMNID columnID;
  ULONG obData;
  ULONG cbMaxLen;
  ULONG obVarDataLen;
  ULONG obInfo;
  DWORD dwBinding;
  DWORD dwDataType;
  }
DBCOLUMNBINDING;

typedef struct tagDBBINDPARAMS
  {
  ULONG cbMaxLen;
  DWORD dwBinding;
  DWORD dwDataType;
  ULONG cbVarDataLen;
  DWORD dwInfo;
  void *pData;
  }
DBBINDPARAMS;

#define CID_NUMBER_INVALID            -1
#define CID_NUMBER_AUTOINCREMENT       0
#define CID_NUMBER_BASECOLUMNNAME      1
#define CID_NUMBER_BASENAME            2
#define CID_NUMBER_BINARYCOMPARABLE    3
#define CID_NUMBER_BINDTYPE            4
#define CID_NUMBER_CASESENSITIVE       5
#define CID_NUMBER_COLLATINGORDER      6
#define CID_NUMBER_COLUMNID            7
#define CID_NUMBER_CURSORCOLUMN        8
#define CID_NUMBER_DATACOLUMN          9
#define CID_NUMBER_DEFAULTVALUE        10
#define CID_NUMBER_ENTRYIDMAXLENGTH    11
#define CID_NUMBER_FIXED               12
#define CID_NUMBER_HASDEFAULT          13
#define CID_NUMBER_MAXLENGTH           14
#define CID_NUMBER_MULTIVALUED         15
#define CID_NUMBER_NAME                16
#define CID_NUMBER_NULLABLE            17
#define CID_NUMBER_PHYSICALSORT        18
#define CID_NUMBER_NUMBER              19
#define CID_NUMBER_ROWENTRYID          20
#define CID_NUMBER_SCALE               21
#define CID_NUMBER_SEARCHABLE          22
#define CID_NUMBER_TYPE                23
#define CID_NUMBER_UNIQUE              24
#define CID_NUMBER_UPDATABLE           25
#define CID_NUMBER_VERSION             26
#define CID_NUMBER_STATUS              27

/* c and C++ have different meanings for const.
 */
#ifdef __cplusplus
#define EXTERNAL_DEFN    extern const
#else
#define EXTERNAL_DEFN    const
#endif /* __cplusplus */



#define DBCIDGUID {0xfe284700L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef DBINITCONSTANTS

EXTERNAL_DEFN DBCOLUMNID NEAR COLUMNID_INVALID         = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, -1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_AUTOINCREMENT     = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BASECOLUMNNAME    = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BASENAME          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BINARYCOMPARABLE  = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BINDTYPE          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_CASESENSITIVE     = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_COLLATINGORDER    = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_COLUMNID          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 7};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_CURSORCOLUMN      = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 8};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_DATACOLUMN        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 9};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_DEFAULTVALUE      = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 10};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_ENTRYIDMAXLENGTH  = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 11};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_FIXED             = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 12};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_HASDEFAULT        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 13};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_MAXLENGTH         = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 14};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_MULTIVALUED       = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 15};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NAME              = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 16};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NULLABLE          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 17};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_PHYSICALSORT      = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 18};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NUMBER            = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 19};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_ROWENTRYID        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 20};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_SCALE             = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 21};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_SEARCHABLE        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 22};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_TYPE              = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 23};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_UNIQUE            = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 24};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_UPDATABLE         = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 25};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_VERSION           = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 26};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_STATUS            = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 27};
#else
extern const DBCOLUMNID NEAR COLUMNID_INVALID;
extern const DBCOLUMNID NEAR COLUMN_AUTOINCREMENT;
extern const DBCOLUMNID NEAR COLUMN_BASECOLUMNNAME;
extern const DBCOLUMNID NEAR COLUMN_BASENAME;
extern const DBCOLUMNID NEAR COLUMN_BINARYCOMPARABLE;
extern const DBCOLUMNID NEAR COLUMN_BINDTYPE;
extern const DBCOLUMNID NEAR COLUMN_CASESENSITIVE;
extern const DBCOLUMNID NEAR COLUMN_COLLATINGORDER;
extern const DBCOLUMNID NEAR COLUMN_COLUMNID;
extern const DBCOLUMNID NEAR COLUMN_CURSORCOLUMN;
extern const DBCOLUMNID NEAR COLUMN_DATACOLUMN;
extern const DBCOLUMNID NEAR COLUMN_DEFAULTVALUE;
extern const DBCOLUMNID NEAR COLUMN_ENTRYIDMAXLENGTH;
extern const DBCOLUMNID NEAR COLUMN_FIXED;
extern const DBCOLUMNID NEAR COLUMN_HASDEFAULT;
extern const DBCOLUMNID NEAR COLUMN_MAXLENGTH;
extern const DBCOLUMNID NEAR COLUMN_MULTIVALUED;
extern const DBCOLUMNID NEAR COLUMN_NAME;
extern const DBCOLUMNID NEAR COLUMN_NULLABLE;
extern const DBCOLUMNID NEAR COLUMN_PHYSICALSORT;
extern const DBCOLUMNID NEAR COLUMN_NUMBER;
extern const DBCOLUMNID NEAR COLUMN_ROWENTRYID;
extern const DBCOLUMNID NEAR COLUMN_SCALE;
extern const DBCOLUMNID NEAR COLUMN_SEARCHABLE;
extern const DBCOLUMNID NEAR COLUMN_TYPE;
extern const DBCOLUMNID NEAR COLUMN_UNIQUE;
extern const DBCOLUMNID NEAR COLUMN_UPDATABLE;
extern const DBCOLUMNID NEAR COLUMN_VERSION;
extern const DBCOLUMNID NEAR COLUMN_STATUS;
#endif

#define BMK_NUMBER_BMKTEMPORARY    0
#define BMK_NUMBER_BMKTEMPORARYREL 1
#define BMK_NUMBER_BMKCURSOR       2
#define BMK_NUMBER_BMKCURSORREL    3
#define BMK_NUMBER_BMKSESSION      4
#define BMK_NUMBER_BMKSESSIONREL   5
#define BMK_NUMBER_BMKPERSIST      6
#define BMK_NUMBER_BMKPERSISTREL   7


#define DBBMKGUID {0xf6304bb0L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef DBINITCONSTANTS
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKTEMPORARY      = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKTEMPORARYREL   = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKCURSOR         = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKCURSORREL      = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKSESSION        = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKSESSIONREL     = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKPERSIST        = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKPERSISTREL     = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 7};
#else
extern const DBCOLUMNID NEAR COLUMN_BMKINVALID;
extern const DBCOLUMNID NEAR COLUMN_BMKTEMPORARY;
extern const DBCOLUMNID NEAR COLUMN_BMKTEMPORARYREL;
extern const DBCOLUMNID NEAR COLUMN_BMKCURSOR;
extern const DBCOLUMNID NEAR COLUMN_BMKCURSORREL;
extern const DBCOLUMNID NEAR COLUMN_BMKSESSION;
extern const DBCOLUMNID NEAR COLUMN_BMKSESSIONREL;
extern const DBCOLUMNID NEAR COLUMN_BMKPERSIST;
extern const DBCOLUMNID NEAR COLUMN_BMKPERSISTREL;
#endif

#define DB_BMK_SIZE        sizeof(BYTE)
#ifdef DBINITCONSTANTS
EXTERNAL_DEFN BYTE NEAR DBBMK_INVALID   = 0x0;
EXTERNAL_DEFN BYTE NEAR DBBMK_CURRENT   = 0x1;
EXTERNAL_DEFN BYTE NEAR DBBMK_BEGINNING = 0x2;
EXTERNAL_DEFN BYTE NEAR DBBMK_END       = 0x3;
#else
extern const BYTE NEAR DBBMK_INVALID;
extern const BYTE NEAR DBBMK_CURRENT;
extern const BYTE NEAR DBBMK_BEGINNING;
extern const BYTE NEAR DBBMK_END;
#endif

typedef enum tagDBCOLUMNBINDOPTS
  {
    DBCOLUMNBINDOPTS_REPLACE = 0,
    DBCOLUMNBINDOPTS_ADD = 1
  }
DBCOLUMNBINDOPTS;

typedef enum tagDBUPDATELOCK
  {
    DBUPDATELOCK_PESSIMISTIC = 0,
    DBUPDATELOCK_OPTIMISTIC = 1
  }
DBUPDATELOCK;

typedef enum tagDBCOLUMNDATA
  {
    DBCOLUMNDATA_UNCHANGED = 0,
    DBCOLUMNDATA_CHANGED = 1,
        DBCOLUMNDATA_UNKNOWN = 2
  }
DBCOLUMNDATA;

typedef enum tagDBROWACTION
  {
    DBROWACTION_IGNORE = 0,
    DBROWACTION_UPDATE = 1,
    DBROWACTION_DELETE = 2,
    DBROWACTION_ADD = 3,
    DBROWACTION_LOCK = 4,
    DBROWACTION_UNLOCK = 5
  }
DBROWACTION;

typedef enum tagDBUPDATEABLE
  {
    DBUPDATEABLE_UPDATEABLE = 0,
    DBUPDATEABLE_NOTUPDATEABLE = 1,
    DBUPDATEABLE_UNKNOWN = 2
  }
DBUPDATEABLE;

typedef struct tagDBROWSTATUS
  {
  HRESULT hrStatus;
  BLOB Bookmark;
  }
DBROWSTATUS;

typedef enum tagDBEVENTWHATS
  {
    DBEVENT_CURRENT_ROW_CHANGED = 1,
    DBEVENT_CURRENT_ROW_DATA_CHANGED = 2,
    DBEVENT_NONCURRENT_ROW_DATA_CHANGED = 4,
    DBEVENT_SET_OF_COLUMNS_CHANGED = 8,
    DBEVENT_ORDER_OF_COLUMNS_CHANGED = 16,
    DBEVENT_SET_OF_ROWS_CHANGED = 32,
    DBEVENT_ORDER_OF_ROWS_CHANGED = 64,
    DBEVENT_METADATA_CHANGED = 128,
    DBEVENT_ASYNCH_OP_FINISHED = 256,
    DBEVENT_FIND_CRITERIA_CHANGED = 512,
  }
DBEVENTWHATS;

typedef enum tagDBREASON
  {
    DBREASON_DELETED = 1,
    DBREASON_INSERTED = 2,
    DBREASON_MODIFIED = 3,
    DBREASON_REMOVEDFROMCURSOR = 4,
    DBREASON_MOVEDINCURSOR = 5,
    DBREASON_MOVE = 6,
    DBREASON_FIND = 7,
    DBREASON_NEWINDEX = 8,
    DBREASON_ROWFIXUP = 9,
    DBREASON_RECALC = 10,
    DBREASON_REFRESH = 11,
    DBREASON_NEWPARAMETERS = 12,
    DBREASON_SORTCHANGED = 13,
    DBREASON_FILTERCHANGED = 14,
    DBREASON_QUERYSPECCHANGED = 15,
    DBREASON_SEEK = 16,
    DBREASON_PERCENT = 17,
    DBREASON_FINDCRITERIACHANGED = 18,
    DBREASON_SETRANGECHANGED = 19,
    DBREASON_ADDNEW = 20,
    DBREASON_MOVEPERCENT = 21,
    DBREASON_BEGINTRANSACT = 22,
    DBREASON_ROLLBACK = 23,
    DBREASON_COMMIT = 24,
    DBREASON_CLOSE = 25,
    DBREASON_BULK_ERROR = 26,
    DBREASON_BULK_NOTTRANSACTABLE = 27,
    DBREASON_BULK_ABOUTTOEXECUTE = 28,
    DBREASON_CANCELUPDATE = 29,
    DBREASON_SETCOLUMN = 30,
    DBREASON_EDIT = 31,
    DBREASON_UNLOAD = 32
  }
DBREASON;

// Arg1 values for DBREASON_FIND
typedef enum tagDBFINDTYPES
  {
  DB_FINDFIRST = 1,
  DB_FINDLAST = 2,
  DB_FINDNEXT = 3,
  DB_FINDPRIOR = 4,
  DB_FIND = 5
  }
DBFINDTYPES;

typedef struct tagDBNOTIFYREASON
  {
  DWORD dwReason;
  DBVARIANT arg1;
  DBVARIANT arg2;
  }
DBNOTIFYREASON;

#define DB_E_BADBINDINFO           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e00)
#define DB_E_BADBOOKMARK           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e01)
#define DB_E_BADCOLUMNID           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e02)
#define DB_E_BADCRITERIA           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e03)
#define DB_E_BADENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e04)
#define DB_E_BADFRACTION           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e05)
#define DB_E_BADINDEXID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e06)
#define DB_E_BADQUERYSPEC          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e07)
#define DB_E_BADSORTORDER          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e08)
#define DB_E_BADVALUES             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e09)
#define DB_E_CANTCOERCE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0a)
#define DB_E_CANTLOCK              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0b)
#define DB_E_COLUMNUNAVAILABLE     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0c)
#define DB_E_DATACHANGED           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0d)
#define DB_E_INVALIDCOLUMNORDINAL  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0e)
#define DB_E_INVALIDINTERFACE      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0f)
#define DB_E_LOCKFAILED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e10)
#define DB_E_ROWDELETED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e11)
#define DB_E_ROWTOOSHORT           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e12)
#define DB_E_SCHEMAVIOLATION       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e13)
#define DB_E_SEEKKINDNOTSUPPORTED  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e14)
#define DB_E_UPDATEINPROGRESS      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e15)
#define DB_E_USEENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e16)
#define DB_E_STATEERROR            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e17)
#define DB_E_BADFETCHINFO          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e18)
#define DB_E_NOASYNC               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e19)
#define DB_E_ENTRYIDOPEN           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1a)
#define DB_E_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1b)
#define DB_S_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec0)
#define DB_S_CANCEL                MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec1)
#define DB_S_DATACHANGED           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec2)
#define DB_S_ENDOFCURSOR           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec3)
#define DB_S_ENDOFRESULTSET        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec4)
#define DB_S_OPERATIONCANCELLED    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec5)
#define DB_S_QUERYINTERFACE        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec6)
#define DB_S_WORKINGASYNC          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec7)
//#define DB_S_COULDNTCOERCE         MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec8)
#define DB_S_MOVEDTOFIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec9)
#define DB_S_CURRENTROWUNCHANGED   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0eca)
#define DB_S_ROWADDED              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecb)
#define DB_S_ROWUPDATED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecc)
#define DB_S_ROWDELETED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecd)

/*----------------------------------------------------------------------------
 *
 *  ICursor
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursor ICursor;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursor;

interface ICursor : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetColumnsCursor
    (
    REFIID riid,
    IUnknown **ppvColumnsCursor,
    ULONG *pcRows
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetBindings
    (
    ULONG cCol,
    DBCOLUMNBINDING rgBoundColumns[],
    ULONG cbRowLength,
    DWORD dwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBindings
    (
    ULONG *pcCol,
    DBCOLUMNBINDING *prgBoundColumns[],
    ULONG *pcbRowLength
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetNextRows
    (
    LARGE_INTEGER udlRowsToSkip,
    DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Requery
    (
        void
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursor;

typedef struct ICursorVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursor FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursor FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursor FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursor FAR *this,
    REFIID riid,
    IUnknown **ppvColumnsCursor,
    ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursor FAR *this,
    ULONG cCol,
    DBCOLUMNBINDING rgBoundColumns[],
    ULONG cbRowLength,
    DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursor FAR *this,
    ULONG *pcCol,
    DBCOLUMNBINDING *prgBoundColumns[],
    ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursor FAR *this,
    LARGE_INTEGER udlRowsToSkip,
    DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursor FAR *this
    );

} ICursorVtbl;

interface ICursor
{
    ICursorVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursor_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursor_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursor_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursor_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursor_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursor_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursor_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursor_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *  ICursorMove
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorMove ICursorMove;

typedef enum tagDBCLONEOPTS
  {
    DBCLONEOPTS_DEFAULT = 0,
    DBCLONEOPTS_SAMEROW = 1
  }
DBCLONEOPTS;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorMove;

interface ICursorMove : public ICursor
{
public:
    virtual HRESULT STDMETHODCALLTYPE Move
    (
    ULONG cbBookmark,
    void *pBookmark,
    LARGE_INTEGER dlOffset,
    DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBookmark
    (
    DBCOLUMNID *pBookmarkType,
    ULONG cbMaxSize,
    ULONG *pcbBookmark,
    void *pBookmark
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Clone
    (
    DWORD dwFlags,
    REFIID riid,
    IUnknown **ppvClonedCursor
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorMove;

typedef struct ICursorMoveVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorMove FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorMove FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorMove FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursorMove FAR *this,
    REFIID riid,
    IUnknown **ppvColumnsCursor,
    ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursorMove FAR *this,
    ULONG cCol,
    DBCOLUMNBINDING rgBoundColumns[],
    ULONG cbRowLength,
    DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursorMove FAR *this,
    ULONG *pcCol,
    DBCOLUMNBINDING *prgBoundColumns[],
    ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursorMove FAR *this,
    LARGE_INTEGER udlRowsToSkip,
    DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursorMove FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Move)
    (
        ICursorMove FAR *this,
    ULONG cbBookmark,
    void *pBookmark,
    LARGE_INTEGER dlOffset,
    DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
    (
        ICursorMove FAR *this,
    DBCOLUMNID *pBookmarkType,
    ULONG cbMaxSize,
    ULONG *pcbBookmark,
    void *pBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Clone)
    (
        ICursorMove FAR *this,
    DWORD dwFlags,
    REFIID riid,
    IUnknown **ppvClonedCursor
    );

} ICursorMoveVtbl;

interface ICursorMove
{
    ICursorMoveVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorMove_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorMove_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorMove_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorMove_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorMove_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorMove_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorMove_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorMove_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#define ICursorMove_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
    (*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorMove_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
    (*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorMove_Clone(pI, dwFlags, riid, ppvClonedCursor) \
    (*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *  ICursorScroll
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorScroll ICursorScroll;

typedef enum tagDBCURSORPOPULATED
  {
    DBCURSORPOPULATED_FULLY = 0,
    DBCURSORPOPULATED_PARTIALLY = 1
  }
DBCURSORPOPULATED;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorScroll;

interface ICursorScroll : public ICursorMove
{
public:
    virtual HRESULT STDMETHODCALLTYPE Scroll
    (
    ULONG ulNumerator,
    ULONG ulDenominator,
    DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetApproximatePosition
    (
    ULONG cbBookmark,
    void *pBookmark,
    ULONG *pulNumerator,
    ULONG *pulDenominator
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetApproximateCount
    (
    LARGE_INTEGER *pudlApproxCount,
    DWORD *pdwFullyPopulated
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorScroll;

typedef struct ICursorScrollVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorScroll FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorScroll FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorScroll FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursorScroll FAR *this,
    REFIID riid,
    IUnknown **ppvColumnsCursor,
    ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursorScroll FAR *this,
    ULONG cCol,
    DBCOLUMNBINDING rgBoundColumns[],
    ULONG cbRowLength,
    DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursorScroll FAR *this,
    ULONG *pcCol,
    DBCOLUMNBINDING *prgBoundColumns[],
    ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursorScroll FAR *this,
    LARGE_INTEGER udlRowsToSkip,
    DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursorScroll FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Move)
    (
        ICursorScroll FAR *this,
    ULONG cbBookmark,
    void *pBookmark,
    LARGE_INTEGER dlOffset,
    DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
    (
        ICursorScroll FAR *this,
    DBCOLUMNID *pBookmarkType,
    ULONG cbMaxSize,
    ULONG *pcbBookmark,
    void *pBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Clone)
    (
        ICursorScroll FAR *this,
    DWORD dwFlags,
    REFIID riid,
    IUnknown **ppvClonedCursor
    );

    HRESULT (STDMETHODCALLTYPE FAR *Scroll)
    (
        ICursorScroll FAR *this,
    ULONG ulNumerator,
    ULONG ulDenominator,
    DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetApproximatePosition)
    (
        ICursorScroll FAR *this,
    ULONG cbBookmark,
    void *pBookmark,
    ULONG *pulNumerator,
    ULONG *pulDenominator
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetApproximateCount)
    (
        ICursorScroll FAR *this,
    LARGE_INTEGER *pudlApproxCount,
    DWORD *pdwFullyPopulated
    );

} ICursorScrollVtbl;

interface ICursorScroll
{
    ICursorScrollVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorScroll_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorScroll_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorScroll_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorScroll_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorScroll_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorScroll_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorScroll_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorScroll_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#define ICursorScroll_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
    (*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorScroll_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
    (*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorScroll_Clone(pI, dwFlags, riid, ppvClonedCursor) \
    (*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)

#define ICursorScroll_Scroll(pI, ulNumerator, ulDenominator, pFetchParams) \
    (*(pI)->lpVtbl->Scroll)((pI), ulNumerator, ulDenominator, pFetchParams)

#define ICursorScroll_GetApproximatePosition(pI, cbBookmark, pBookmark, pulNumerator, pulDenominator) \
    (*(pI)->lpVtbl->GetApproximatePosition)((pI), cbBookmark, pBookmark, pulNumerator, pulDenominator)

#define ICursorScroll_GetApproximateCount(pI, pudlApproxCount, pdwFullyPopulated) \
    (*(pI)->lpVtbl->GetApproximateCount)((pI), pudlApproxCount, pdwFullyPopulated)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *  ICursorUpdateARow
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorUpdateARow ICursorUpdateARow;

typedef enum tagDBEDITMODE
  {
    DBEDITMODE_NONE = 1,
    DBEDITMODE_UPDATE = 2,
    DBEDITMODE_ADD = 3
  }
DBEDITMODE;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorUpdateARow;

interface ICursorUpdateARow : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE BeginUpdate
    (
    DWORD dwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetColumn
    (
    DBCOLUMNID *pcid,
    DBBINDPARAMS *pBindParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetColumn
    (
    DBCOLUMNID *pcid,
    DBBINDPARAMS *pBindParams,
    DWORD *pdwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetEditMode
    (
    DWORD *pdwState
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Update
    (
    DBCOLUMNID *pBookmarkType,
    ULONG *pcbBookmark,
    void **ppBookmark
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Cancel
    (
        void
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Delete
    (
    void
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorUpdateARow;

typedef struct ICursorUpdateARowVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorUpdateARow FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorUpdateARow FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorUpdateARow FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *BeginUpdate)
    (
        ICursorUpdateARow FAR *this,
    DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetColumn)
    (
        ICursorUpdateARow FAR *this,
    DBCOLUMNID *pcid,
    DBBINDPARAMS *pBindParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumn)
    (
        ICursorUpdateARow FAR *this,
    DBCOLUMNID *pcid,
    DBBINDPARAMS *pBindParams,
    DWORD *pdwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetEditMode)
    (
        ICursorUpdateARow FAR *this,
    DWORD *pdwState
    );

    HRESULT (STDMETHODCALLTYPE FAR *Update)
    (
        ICursorUpdateARow FAR *this,
    DBCOLUMNID *pBookmarkType,
    ULONG *pcbBookmark,
    void **ppBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Cancel)
    (
        ICursorUpdateARow FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Delete)
    (
        ICursorUpdateARow FAR *this
    );

} ICursorUpdateARowVtbl;

interface ICursorUpdateARow
{
    ICursorUpdateARowVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorUpdateARow_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorUpdateARow_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorUpdateARow_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorUpdateARow_BeginUpdate(pI, dwFlags) \
    (*(pI)->lpVtbl->BeginUpdate)((pI), dwFlags)

#define ICursorUpdateARow_SetColumn(pI, pcid, pBindParams) \
    (*(pI)->lpVtbl->SetColumn)((pI), pcid, pBindParams)

#define ICursorUpdateARow_GetColumn(pI, pcid, pBindParams, pdwFlags) \
    (*(pI)->lpVtbl->GetColumn)((pI), pcid, pBindParams, pdwFlags)

#define ICursorUpdateARow_GetEditMode(pI, pdwState) \
    (*(pI)->lpVtbl->GetEditMode)((pI), pdwState)

#define ICursorUpdateARow_Update(pI, pBookmarkType, pcbBookmark, ppBookmark) \
    (*(pI)->lpVtbl->Update)((pI), pBookmarkType, pcbBookmark, ppBookmark)

#define ICursorUpdateARow_Cancel(pI) \
    (*(pI)->lpVtbl->Cancel)((pI))

#define ICursorUpdateARow_Delete(pI) \
    (*(pI)->lpVtbl->Delete)((pI))


#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *  ICursorFind
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorFind ICursorFind;

typedef enum tagDBFINDFLAGS
  {
    DBFINDFLAGS_FINDNEXT = 1,
    DBFINDFLAGS_FINDPRIOR = 2,
    DBFINDFLAGS_INCLUDECURRENT = 4
  }
DBFINDFLAGS;


typedef enum tagDBSEEKFLAGS
  {
    DBSEEK_LT    = 1,
    DBSEEK_LE    = 2,
    DBSEEK_EQ    = 3,       // EXACT EQUALITY
    DBSEEK_GT    = 4,
    DBSEEK_GE    = 5,
    DBSEEK_PARTIALEQ = 6             // only for strings
  }
DBSEEKFLAGS;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorFind;

interface ICursorFind : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE FindByValues
    (
    ULONG            cbBookmark,
    LPVOID           pBookmark,
    DWORD            dwFindFlags,
    ULONG            cValues,
        DBCOLUMNID       rgColumns[],
    DBVARIANT        rgValues[],
    DWORD            rgdwSeekFlags[],
        DBFETCHROWS FAR *pFetchParams
    ) = 0;
};

#else

/* C Language Binding */
//extern const IID IID_ICursorFind;

typedef struct ICursorFindVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorFind FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorFind FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorFind FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *FindByValues)
    (
        ICursorFind FAR *this,
    ULONG            cbBookmark,
    LPVOID           pBookmark,
    DWORD            dwFindFlags,
    ULONG            cValues,
        DBCOLUMNID       rgColumns[],
    DBVARIANT        rgValues[],
    DWORD            rgdwSeekFlags[],
        DBFETCHROWS      pFetchParams
    );


} ICursorFindVtbl;

interface ICursorFind
{
    ICursorFindVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorFind_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorFind_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorFind_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorFind_FindByValues(pI, cbB, pB, dwFF, cV, rgC, rgV, rgSF, pF) \
    (*(pI)->lpVtbl->FindByValues)((pI), cbB, pB, dwFF, cB, rgC, rgV, rgSF, pF)

#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *  IEntryID
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface IEntryID IEntryID;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_IEntryID;

interface IEntryID : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetInterface
    (
    ULONG cbEntryID,
    void *pEntryID,
        DWORD dwFlags,
        REFIID riid,
    IUnknown **ppvObj
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_IEntryID;

typedef struct IEntryIDVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IEntryID FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IEntryID FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IEntryID FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetInterface)
    (
        IEntryID FAR *this,
    ULONG cbEntryID,
    void *pEntryID,
        REFIID riid,
    IUnknown **ppvObj
    );

} IEntryIDVtbl;

interface IEntryID
{
    IEntryIDVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define IEntryID_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define IEntryID_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define IEntryID_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define IEntryID_GetInterface(pI, cbEntryID, pEntryID, riid, ppvObj) \
    (*(pI)->lpVtbl->GetInterface)((pI), cbEntryID, pEntryID, riid, ppvObj)
#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *  INotifyDBEvents
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface INotifyDBEvents INotifyDBEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_INotifyDBEvents;

interface INotifyDBEvents : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE OKToDo
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Cancelled
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SyncBefore
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE AboutToDo
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE FailedToDo
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SyncAfter
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DidEvent
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

};

#else

/* C Language Binding */
extern const IID IID_INotifyDBEvents;

typedef struct INotifyDBEventsVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        INotifyDBEvents FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        INotifyDBEvents FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        INotifyDBEvents FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *OKToDo)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *Cancelled)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *SyncBefore)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *AboutToDo)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *FailedToDo)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *SyncAfter)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *DidEvent)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

} INotifyDBEventsVtbl;

interface INotifyDBEvents
{
    INotifyDBEventsVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define INotifyDBEvents_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define INotifyDBEvents_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define INotifyDBEvents_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define INotifyDBEvents_OKToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->OKToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_Cancelled(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->Cancelled)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncBefore(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->SyncBefore)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_AboutToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->AboutToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_FailedToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->FailedToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncAfter(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->SyncAfter)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_DidEvent(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->DidEvent)((pI), dwEventWhat, cReasons, rgReasons)
#endif /* COBJMACROS */

#endif


#ifdef __cplusplus
}
#endif

#define __OCDB_H_
#endif // __OCDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\oharestr.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//    OHARESTR.H - string defines for O'Hare components
//            
//

//    HISTORY:
//    
//    3/10/95        jeremys        Created.
//    1/10/98       DONALDM         Adapted to the GETCONN proj to be
//                                  be compatible with inetreg.h


#ifndef _OHARESTR_H_
#define _OHARESTR_H_

// string value under HKCU\REGSTR_PATH_REMOTEACCESS that contains name of
// connectoid used to connect to internet
#define REGSTR_VAL_BKUPINTERNETPROFILE    TEXT("BackupInternetProfile")

// class name for window to receive Winsock activity messages
#define AUTODIAL_MONITOR_CLASS_NAME    TEXT("MS_AutodialMonitor")

#endif // _OHARESTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\occimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef _AFX_NO_OCC_SUPPORT

#include "olebind.h"
#include "ocdbid.h"
#include "ocdb.h"

class CDataSourceControl;
class CDataBoundProperty;

// CCmdTarget
    class COleControlContainer;
    class COleControlSite;

class COccManager;
struct _AFX_OCC_DIALOG_INFO;

#define DISPID_DATASOURCE   0x80010001
#define DISPID_DATAFIELD    0x80010002


/////////////////////////////////////////////////////////////////////////////
// OLE Databinding support class for data sources

class CDataSourceControl
{
private:
    CDataSourceControl() {};
public:
    struct METAROWTYPE
    {
        DBCOLUMNID idColumnID;
        DWORD dwColumnID;
        LPSTR lpstrName;
        DWORD dwName;
        CPtrList* m_pClientList;
    };

    CDataSourceControl(COleControlSite *pClientSite);
    ~CDataSourceControl();
    HRESULT Initialize();
    virtual ICursor* GetCursor();
    HRESULT GetMetaData();
    virtual void BindProp(COleControlSite* pClientSite, BOOL bBind = TRUE);
    virtual void BindProp(CDataBoundProperty* pProperty, BOOL bBind = TRUE);
    virtual void BindColumns();
    BOOL CopyColumnID(DBCOLUMNID* pcidDst, DBCOLUMNID const *pcidSrc);
    HRESULT GetBoundClientRow();
    virtual HRESULT UpdateControls();
    virtual HRESULT UpdateCursor();

    COleControlSite *m_pClientSite;  // Back ptr to containing site
    ICursorMove* m_pCursorMove;
    ICursorUpdateARow* m_pCursorUpdateARow;
    int m_nColumns;
    METAROWTYPE* m_pMetaRowData;
    CPtrList m_CursorBoundProps;
    void* m_pVarData;
    int m_nBindings;
    DBCOLUMNBINDING *m_pColumnBindings;
    VARIANT* m_pValues;
    BOOL m_bUpdateInProgress;
};

/////////////////////////////////////////////////////////////////////////////
// OLE Databinding support class for bound controls

class CDataBoundProperty
{
protected:
    CDataBoundProperty() {};
public:
    CDataBoundProperty(CDataBoundProperty* pLast, DISPID dispid, WORD ctlid);
    ~CDataBoundProperty() {};
    void SetClientSite(COleControlSite *pClientSite);
    void SetDSCSite(COleControlSite *pDSCSite);
    void RemoveSource();
    void Notify();
    ICursor* GetCursor();
    CDataBoundProperty* GetNext();

    COleControlSite *m_pClientSite;  // Back ptr to containing site
    WORD m_ctlid;
    DISPID m_dispid;
    COleControlSite *m_pDSCSite;
    BOOL m_bOwnXferOut;
    BOOL m_bIsDirty;
    CDataBoundProperty* m_pNext;
};

/////////////////////////////////////////////////////////////////////////////
// Control containment helper functions

DLGTEMPLATE* _AfxSplitDialogTemplate(const DLGTEMPLATE* pTemplate,
    CMapWordToPtr* pOleItemMap);

void _AfxZOrderOleControls(CWnd* pWnd, CMapWordToPtr* pOleItemMap);

/////////////////////////////////////////////////////////////////////////////
// COleControlContainer - implementation class

class COleControlContainer : public CCmdTarget
{
public:
// Constructors/destructors
    COleControlContainer(CWnd*  pWnd);
    virtual ~COleControlContainer();

// Operations
    BOOL CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
        LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, UINT nID,
        CFile* pPersist=NULL, BOOL bStorage=FALSE, BSTR bstrLicKey=NULL,
        COleControlSite** ppNewSite=NULL);
    virtual COleControlSite* FindItem(UINT nID) const;
    virtual BOOL GetAmbientProp(COleControlSite* pSite, DISPID dispid,
        VARIANT* pvarResult);
    void CreateOleFont(CFont* pFont);
    void FreezeAllEvents(BOOL bFreeze);
    virtual void ScrollChildren(int dx, int dy);
    virtual void OnUIActivate(COleControlSite* pSite);
    virtual void OnUIDeactivate(COleControlSite* pSite);

    virtual void CheckDlgButton(int nIDButton, UINT nCheck);
    virtual void CheckRadioButton(int nIDFirstButton, int nIDLastButton,
        int nIDCheckButton);
    virtual CWnd* GetDlgItem(int nID) const;
    virtual void GetDlgItem(int nID, HWND* phWnd) const;
    virtual UINT GetDlgItemInt(int nID, BOOL* lpTrans, BOOL bSigned) const;
    virtual int GetDlgItemText(int nID, LPTSTR lpStr, int nMaxCount) const;
    virtual LRESULT SendDlgItemMessage(int nID, UINT message, WPARAM wParam,
        LPARAM lParam);
    virtual void SetDlgItemInt(int nID, UINT nValue, BOOL bSigned);
    virtual void SetDlgItemText(int nID, LPCTSTR lpszString);
    virtual UINT IsDlgButtonChecked(int nIDButton) const;

// Attributes
    CWnd* m_pWnd;
    CMapPtrToPtr m_siteMap;
    COLORREF m_crBack;
    COLORREF m_crFore;
    LPFONTDISP m_pOleFont;
    COleControlSite* m_pSiteUIActive;

public:
    // Interface maps
    BEGIN_INTERFACE_PART(OleIPFrame, IOleInPlaceFrame)
        INIT_INTERFACE_PART(COleControlContainer, OleIPFrame)
        STDMETHOD(GetWindow)(HWND*);
        STDMETHOD(ContextSensitiveHelp)(BOOL);
        STDMETHOD(GetBorder)(LPRECT);
        STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS);
        STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS);
        STDMETHOD(SetActiveObject)(LPOLEINPLACEACTIVEOBJECT, LPCOLESTR);
        STDMETHOD(InsertMenus)(HMENU, LPOLEMENUGROUPWIDTHS);
        STDMETHOD(SetMenu)(HMENU, HOLEMENU, HWND);
        STDMETHOD(RemoveMenus)(HMENU);
        STDMETHOD(SetStatusText)(LPCOLESTR);
        STDMETHOD(EnableModeless)(BOOL);
        STDMETHOD(TranslateAccelerator)(LPMSG, WORD);
    END_INTERFACE_PART(OleIPFrame)

    BEGIN_INTERFACE_PART(OleContainer, IOleContainer)
        INIT_INTERFACE_PART(COleControlContainer, OleContainer)
        STDMETHOD(ParseDisplayName)(LPBINDCTX, LPOLESTR, ULONG*, LPMONIKER*);
        STDMETHOD(EnumObjects)(DWORD, LPENUMUNKNOWN*);
        STDMETHOD(LockContainer)(BOOL);
    END_INTERFACE_PART(OleContainer)

    DECLARE_INTERFACE_MAP()
    DECLARE_DISPATCH_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// COleControlSite - implementation class

class COleControlSite : public CCmdTarget
{
public:
// Constructors/destructors
    COleControlSite(COleControlContainer* pCtrlCont);
    ~COleControlSite();

// Operations
    HRESULT CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
        LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, UINT nID,
        CFile* pPersist=NULL, BOOL bStorage=FALSE, BSTR bstrLicKey=NULL);
    virtual BOOL DestroyControl();
    UINT GetID();
    BOOL GetEventIID(IID* piid);
    virtual HRESULT DoVerb(LONG nVerb, LPMSG lpMsg = NULL);
    BOOL IsDefaultButton();
    DWORD GetDefBtnCode();
    void SetDefaultButton(BOOL bDefault);
    void GetControlInfo();
    BOOL IsMatchingMnemonic(LPMSG lpMsg);
    void SendMnemonic(LPMSG lpMsg);
    void FreezeEvents(BOOL bFreeze);

    virtual void InvokeHelperV(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
        void* pvRet, const BYTE* pbParamInfo, va_list argList);
    virtual void SetPropertyV(DISPID dwDispID, VARTYPE vtProp,
        va_list argList);
    virtual void AFX_CDECL InvokeHelper(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
        void* pvRet, const BYTE* pbParamInfo, ...);
    virtual void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;
    virtual void AFX_CDECL SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
    virtual BOOL AFX_CDECL SafeSetProperty(DISPID dwDispID, VARTYPE vtProp, ...);

    virtual DWORD GetStyle() const;
    virtual DWORD GetExStyle() const;
    virtual BOOL ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags);
    virtual BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags);
    virtual void SetWindowText(LPCTSTR lpszString);
    virtual void GetWindowText(CString& str) const;
    virtual int GetWindowText(LPTSTR lpszStringBuf, int nMaxCount) const;
    virtual int GetWindowTextLength() const;
    virtual int GetDlgCtrlID() const;
    virtual int SetDlgCtrlID(int nID);
    virtual void MoveWindow(int x, int y, int nWidth, int nHeight,
        BOOL bRepaint);
    virtual BOOL SetWindowPos(const CWnd* pWndInsertAfter, int x, int y,
        int cx, int cy, UINT nFlags);
    virtual BOOL ShowWindow(int nCmdShow);
    virtual BOOL IsWindowEnabled() const;
    virtual BOOL EnableWindow(BOOL bEnable);
    virtual CWnd* SetFocus();
    virtual void EnableDSC();
    virtual void BindDefaultProperty(DISPID dwDispID, VARTYPE vtProp, LPCTSTR szFieldName, CWnd* pDSCWnd);
    virtual void BindProperty(DISPID dwDispId, CWnd* pWndDSC);

// Overridables
    virtual BOOL QuickActivate();

// Attributes
    COleControlContainer* m_pCtrlCont;
    HWND m_hWnd;
    CWnd* m_pWndCtrl;
    UINT m_nID;
    CRect m_rect;
    IID m_iidEvents;
    LPOLEOBJECT m_pObject;
    LPOLEINPLACEOBJECT m_pInPlaceObject;
    LPOLEINPLACEACTIVEOBJECT m_pActiveObject;
    COleDispatchDriver m_dispDriver;
    DWORD m_dwEventSink;
    DWORD m_dwPropNotifySink;
    DWORD m_dwStyleMask;
    DWORD m_dwStyle;
    DWORD m_dwMiscStatus;
    CONTROLINFO m_ctlInfo;

    // Databound control stuff
    DWORD m_dwNotifyDBEvents; // INotifyDBEvents sink cookie
    CDataSourceControl* m_pDataSourceControl;
    CDataBoundProperty* m_pBindings;
    union {
        COleControlSite *m_pDSCSite;
        WORD m_ctlidRowSource;
    };
    DISPID m_defdispid;
    UINT m_dwType;
    CString m_strDataField;
    BOOL m_bIgnoreNotify;
    BOOL m_bIsDirty;
    VARIANT m_varResult;

protected:
// Implementation
    BOOL SetExtent();
    HRESULT CreateOrLoad(REFCLSID clsid, CFile* pPersist, BOOL bStorage,
        BSTR bstrLicKey);
    DWORD ConnectSink(REFIID iid, LPUNKNOWN punkSink);
    void DisconnectSink(REFIID iid, DWORD dwCookie);
    void AttachWindow();
    void DetachWindow();
    BOOL OnEvent(AFX_EVENT* pEvent);
    HRESULT GetCursor(DISPID dispid, LPLPCURSOR ppcursorOut, LPVOID *ppcidOut);

public:
// Interface maps
    BEGIN_INTERFACE_PART(OleClientSite, IOleClientSite)
        INIT_INTERFACE_PART(COleControlSite, OleClientSite)
        STDMETHOD(SaveObject)();
        STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
        STDMETHOD(GetContainer)(LPOLECONTAINER*);
        STDMETHOD(ShowObject)();
        STDMETHOD(OnShowWindow)(BOOL);
        STDMETHOD(RequestNewObjectLayout)();
    END_INTERFACE_PART(OleClientSite)

    BEGIN_INTERFACE_PART(OleIPSite, IOleInPlaceSite)
        INIT_INTERFACE_PART(COleControlSite, OleIPSite)
        STDMETHOD(GetWindow)(HWND*);
        STDMETHOD(ContextSensitiveHelp)(BOOL);
        STDMETHOD(CanInPlaceActivate)();
        STDMETHOD(OnInPlaceActivate)();
        STDMETHOD(OnUIActivate)();
        STDMETHOD(GetWindowContext)(LPOLEINPLACEFRAME*,
            LPOLEINPLACEUIWINDOW*, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
        STDMETHOD(Scroll)(SIZE);
        STDMETHOD(OnUIDeactivate)(BOOL);
        STDMETHOD(OnInPlaceDeactivate)();
        STDMETHOD(DiscardUndoState)();
        STDMETHOD(DeactivateAndUndo)();
        STDMETHOD(OnPosRectChange)(LPCRECT);
    END_INTERFACE_PART(OleIPSite)

    BEGIN_INTERFACE_PART(OleControlSite, IOleControlSite)
        INIT_INTERFACE_PART(COleControlSite, OleControlSite)
        STDMETHOD(OnControlInfoChanged)();
        STDMETHOD(LockInPlaceActive)(BOOL fLock);
        STDMETHOD(GetExtendedControl)(LPDISPATCH* ppDisp);
        STDMETHOD(TransformCoords)(POINTL* lpptlHimetric,
            POINTF* lpptfContainer, DWORD flags);
        STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, DWORD grfModifiers);
        STDMETHOD(OnFocus)(BOOL fGotFocus);
        STDMETHOD(ShowPropertyFrame)();
    END_INTERFACE_PART(OleControlSite)

    BEGIN_INTERFACE_PART(AmbientProps, IDispatch)
        INIT_INTERFACE_PART(COleControlSite, AmbientProps)
        STDMETHOD(GetTypeInfoCount)(unsigned int*);
        STDMETHOD(GetTypeInfo)(unsigned int, LCID, ITypeInfo**);
        STDMETHOD(GetIDsOfNames)(REFIID, LPOLESTR*, unsigned int, LCID, DISPID*);
        STDMETHOD(Invoke)(DISPID, REFIID, LCID, unsigned short, DISPPARAMS*,
                          VARIANT*, EXCEPINFO*, unsigned int*);
    END_INTERFACE_PART(AmbientProps)

    BEGIN_INTERFACE_PART(PropertyNotifySink, IPropertyNotifySink)
        INIT_INTERFACE_PART(COleControlSite, PropertyNotifySink)
        STDMETHOD(OnChanged)(DISPID dispid);
        STDMETHOD(OnRequestEdit)(DISPID dispid);
    END_INTERFACE_PART(PropertyNotifySink)

    BEGIN_INTERFACE_PART(EventSink, IDispatch)
        INIT_INTERFACE_PART(COleControlSite, EventSink)
        STDMETHOD(GetTypeInfoCount)(unsigned int*);
        STDMETHOD(GetTypeInfo)(unsigned int, LCID, ITypeInfo**);
        STDMETHOD(GetIDsOfNames)(REFIID, LPOLESTR*, unsigned int, LCID, DISPID*);
        STDMETHOD(Invoke)(DISPID, REFIID, LCID, unsigned short, DISPPARAMS*,
                          VARIANT*, EXCEPINFO*, unsigned int*);
    END_INTERFACE_PART(EventSink)

    BEGIN_INTERFACE_PART(BoundObjectSite, IBoundObjectSite)
        STDMETHOD(GetCursor)(DISPID dispid, LPLPCURSOR ppcursorOut, LPVOID *ppcidOut);
    END_INTERFACE_PART(BoundObjectSite)

    BEGIN_INTERFACE_PART(NotifyDBEvents, INotifyDBEvents)
        STDMETHOD(OKToDo)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
        STDMETHOD(Cancelled)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
        STDMETHOD(SyncBefore)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
        STDMETHOD(AboutToDo)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
        STDMETHOD(FailedToDo)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
        STDMETHOD(SyncAfter)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
        STDMETHOD(DidEvent)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);

        // Not part of i/f - just a helper
        HRESULT FireEvent(DWORD dwEventWhat, ULONG cReasons,
            DBNOTIFYREASON rgReasons[], DSCSTATE nState);
    END_INTERFACE_PART(NotifyDBEvents)

    DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// OLE control container manager

class COccManager : public CNoTrackObject
{
// Operations
public:
    // Event handling
    virtual BOOL OnEvent(CCmdTarget* pCmdTarget, UINT idCtrl, AFX_EVENT* pEvent,
        AFX_CMDHANDLERINFO* pHandlerInfo);

    // Internal object creation
    virtual COleControlContainer* CreateContainer(CWnd* pWnd);
    virtual COleControlSite* CreateSite(COleControlContainer* pCtrlCont);

    // Dialog creation
    virtual const DLGTEMPLATE* PreCreateDialog(_AFX_OCC_DIALOG_INFO* pOccDialogInfo,
        const DLGTEMPLATE* pOrigTemplate);
    virtual void PostCreateDialog(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
    virtual DLGTEMPLATE* SplitDialogTemplate(const DLGTEMPLATE* pTemplate,
        DLGITEMTEMPLATE** ppOleDlgItems);
    virtual BOOL CreateDlgControls(CWnd* pWndParent, LPCTSTR lpszResourceName,
        _AFX_OCC_DIALOG_INFO* pOccDialogInfo);
    virtual BOOL CreateDlgControls(CWnd* pWndParent, void* lpResource,
        _AFX_OCC_DIALOG_INFO* pOccDialogInfo);

    // Dialog manager
    virtual BOOL IsDialogMessage(CWnd* pWndDlg, LPMSG lpMsg);
    static BOOL AFX_CDECL IsLabelControl(CWnd* pWnd);
    static BOOL AFX_CDECL IsMatchingMnemonic(CWnd* pWnd, LPMSG lpMsg);
    static void AFX_CDECL SetDefaultButton(CWnd* pWnd, BOOL bDefault);
    static DWORD AFX_CDECL GetDefBtnCode(CWnd* pWnd);

// Implementation
protected:
    // Dialog creation
    HWND CreateDlgControl(CWnd* pWndParent, HWND hwAfter, BOOL bDialogEx,
        LPDLGITEMTEMPLATE pDlgItem, WORD nMsg, BYTE* lpData, DWORD cb);

    // Databinding
    void BindControls(CWnd* pWndParent);

    // Dialog manager
    static void AFX_CDECL UIActivateControl(CWnd* pWndNewFocus);
    static void AFX_CDECL UIDeactivateIfNecessary(CWnd* pWndOldFocus, CWnd* pWndNewFocus);
};

struct _AFX_OCC_DIALOG_INFO
{
    DLGTEMPLATE* m_pNewTemplate;
    DLGITEMTEMPLATE** m_ppOleDlgItems;
};

#endif // !_AFX_NO_OCC_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\port32.h ===
#ifdef WIN32

// These things have direct equivalents.

// Shouldn't be using these things.
#define WINCAPI __cdecl
#define _huge
#define _export
#define _loadds
#define SELECTOROF(x)   ((UINT)(x))
#define OFFSETOF(x)     ((UINT)(x))
#define ISLPTR(pv)      ((BOOL)pv)
#define MAKELP(hmem,off) ((LPVOID)((LPBYTE)hmem+off))
#define MAKELRESULTFROMUINT(i)  ((LRESULT)i)
#define ISVALIDHINSTANCE(hinst) ((BOOL)hinst)

#define DATASEG_READONLY    ".text" // read only data, same as one generated by linker
#define DATASEG_PERINSTANCE "INSTDATA"    // per instance data
#define DATASEG_SHARED                  // default data goes here
#define CODESEG_INIT        ".text"

#define GetWindowInt        GetWindowLong
#define SetWindowInt        SetWindowLong
#define SetWindowID(hwnd,id)    SetWindowLong(hwnd, GWL_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassLong(hwnd, GCL_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassLong(hwnd, GCL_HICON))


#ifdef WINNT

#else

typedef TBYTE TUCHAR;

#endif


#else  // !WIN32

typedef LPCSTR LPCTSTR;
typedef LPSTR  LPTSTR;
typedef const short far *LPCWSTR;
#define TEXT(x) (x)

#define ISLPTR(pv)          (SELECTOROF(pv))
#define MAKELRESULTFROMUINT(i)  MAKELRESULT(i,0)
#define ISVALIDHINSTANCE(hinst) ((UINT)hinst>=(UINT)HINSTANCE_ERROR)

#define DATASEG_READONLY    "_TEXT"
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED
#define CODESEG_INIT        "_INIT"

#define GetWindowInt        GetWindowWord
#define SetWindowInt        SetWindowWord
#define SetWindowID(hwnd,id)    SetWindowWord(hwnd, GWW_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassWord(hwnd, GCW_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassWord(hwnd, GCW_HICON))

#define MAKEPOINTS(l)     (*((POINTS FAR*)&(l)))

#define GlobalAlloc16(f, s) GlobalAlloc(f, s)
#define GlobalLock16(h)     GlobalLock(h)
#define GlobalUnlock16(h)   GlobalUnlock(h)
#define GlobalFree16(h)     GlobalFree(h)
#define GlobalSize16(h)     GlobalSize(h)

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\rnaapi.h ===
// ############################################################################
#define RASAPI_LIBRARY "RASAPI32.DLL"
#define RNAPH_LIBRARY "RNAPH.DLL"


#define RASAPI_RASSETENTRY "RasSetEntryPropertiesA"
#define RASAPI_RASGETENTRY "RasGetEntryPropertiesA"
#define RASAPI_RASDELETEENTRY "RasDeleteEntryA"

// ############################################################################
typedef DWORD (WINAPI* PFNRASENUMDEVICES)(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb, LPDWORD lpcDevices);
typedef DWORD (WINAPI* PFNRASVALIDATEENTRYNAE)(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASSETENTRYPROPERTIES)(LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASGETENTRYPROPERTIES)(LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASDELETEENTRY)(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASHANGUP)(HRASCONN);

typedef DWORD (WINAPI* PFNRASENUMCONNECTIONS)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* PFNRASDIAL)(LPRASDIALEXTENSIONS,LPTSTR,LPRASDIALPARAMS,DWORD,LPVOID,LPHRASCONN);
typedef DWORD (WINAPI* PFNRASGETENTRYDIALPARAMS)(LPTSTR,LPRASDIALPARAMS,LPBOOL);
typedef DWORD (WINAPI* PFNRASGETCONNECTSTATUS)(HRASCONN,LPRASCONNSTATUS);
typedef DWORD (WINAPI* PFNRASGETCOUNTRYINFO)(LPRASCTRYINFO,LPDWORD);
typedef DWORD (WINAPI* PFNRASSETENTRYDIALPARAMS)(LPTSTR,LPRASDIALPARAMS,BOOL);

// ############################################################################
class RNAAPI
{
public:
    RNAAPI();
    ~RNAAPI();

    DWORD RasEnumDevices(LPRASDEVINFO, LPDWORD, LPDWORD);
    DWORD RasValidateEntryName(LPTSTR,LPTSTR);
    DWORD RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
                                LPBYTE lpbEntryInfo,  DWORD dwEntryInfoSize,
                                LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
    DWORD RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
                                LPBYTE lpbEntryInfo,  LPDWORD lpdwEntryInfoSize,
                                LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);
    DWORD RasDeleteEntry(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
    DWORD RasHangUp(HRASCONN hrasconn);
    DWORD RasGetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
                                LPBOOL lpfPassword);
    DWORD RasDial(LPRASDIALEXTENSIONS lpRasDialExtensions,LPTSTR lpszPhonebook,
                  LPRASDIALPARAMS lpRasDialParams,DWORD dwNotifierType,LPVOID lpvNotifier,
                  LPHRASCONN lphRasConn);
    DWORD RasEnumConnections(LPRASCONN lprasconn,LPDWORD lpcb,LPDWORD lpcConnections);
   DWORD RasGetConnectStatus(HRASCONN, LPRASCONNSTATUS);
   DWORD RasGetCountryInfo(LPRASCTRYINFO, LPDWORD);
   DWORD RasSetEntryDialParams(LPTSTR,LPRASDIALPARAMS,BOOL);

private:
    BOOL LoadApi(LPCSTR, FARPROC*);

    HINSTANCE m_hInst;
    HINSTANCE m_hInst2;

    PFNRASENUMDEVICES m_fnRasEnumDeviecs;
    PFNRASVALIDATEENTRYNAE m_fnRasValidateEntryName;
    PFNRASSETENTRYPROPERTIES m_fnRasSetEntryProperties;
    PFNRASGETENTRYPROPERTIES m_fnRasGetEntryProperties;
    PFNRASDELETEENTRY m_fnRasDeleteEntry;
    PFNRASHANGUP m_fnRasHangUp;
    PFNRASENUMCONNECTIONS m_fnRasEnumConnections;
    PFNRASDIAL m_fnRasDial;
    PFNRASGETENTRYDIALPARAMS m_fnRasGetEntryDialParams;
    PFNRASGETCONNECTSTATUS m_fnRasGetConnectStatus;
    PFNRASGETCOUNTRYINFO m_fnRasGetCountryInfo;
    PFNRASSETENTRYDIALPARAMS m_fnRasSetEntryDialParams;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\olebind.h ===
/*****************************************************************************\
*                                                                             *
* olebind.h     Data binding interfaces for OLE                               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _OLEBIND_H_ )
#define _OLEBIND_H_

#if !defined( INITGUID )
#include <olectl.h>
#endif

DEFINE_GUID(IID_IBoundObject,
    0x9BFBBC00,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IBoundObjectSite,
    0x9BFBBC01,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);

typedef interface IBoundObject FAR* LPBOUNDOBJECT;
typedef interface IBoundObjectSite FAR* LPBOUNDOBJECTSITE;

typedef interface ICursor FAR* LPCURSOR;
typedef interface ICursor FAR* FAR* LPLPCURSOR;
typedef interface ICursorMove FAR* LPCURSORMOVE;
typedef interface ICursorScroll FAR* LPCURSORSCROLL;
typedef interface ICursorFind FAR* LPCURSORFIND;
typedef interface ICursorUpdateARow FAR* LPCURSORUPDATEAROW;

//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObject interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObject

DECLARE_INTERFACE_(IBoundObject, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObject methods
    //
    STDMETHOD(OnSourceChanged)(THIS_ DISPID dispid, BOOL fBound, BOOL FAR* lpfOwnXferOut) PURE;
    STDMETHOD(IsDirty)(THIS_ DISPID dispid) PURE;
};
//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObjectSite interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObjectSite

DECLARE_INTERFACE_(IBoundObjectSite, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObjectSite methods
    //
    STDMETHOD(GetCursor)(THIS_ DISPID dispid, LPLPCURSOR ppCursor, LPVOID FAR* ppcidOut) PURE;
};


#endif // !defined( _OLEBIND_H_ )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\ras2.h ===
/* Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
**
** ras.h
** Remote Access external API
** Public header for external API clients
**
** WINVER values in this file:
**      WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
**      WINVER = 0x400 = Windows 95, Windows NT SUR (default)
**      WINVER > 0x400 = Windows NT SUR enhancements
*/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

#include <pshpack4.h>

/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008

/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR szUserName[ UNLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName       0x00000001
#define RASCM_Password       0x00000002
#define RASCM_Domain         0x00000004

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4


DWORD APIENTRY RasGetSubEntryHandleA( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA);

DWORD APIENTRY RasGetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA, BOOL );

DWORD APIENTRY RasSetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW, BOOL );

DWORD APIENTRY RasConnectionNotificationA( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasConnectionNotificationW( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasGetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasGetAutodialAddressA( LPSTR, LPDWORD, LPRASAUTODIALENTRYA,
                    LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( LPWSTR, LPDWORD, LPRASAUTODIALENTRYW,
                    LPDWORD, LPDWORD);

DWORD APIENTRY RasSetAutodialAddressA( LPSTR, DWORD, LPRASAUTODIALENTRYA,
                    DWORD, DWORD );

DWORD APIENTRY RasSetAutodialAddressW( LPWSTR, DWORD, LPRASAUTODIALENTRYW,
                    DWORD, DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA( LPSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumAutodialAddressesW( LPWSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialEnableA( DWORD, LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( DWORD, LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( DWORD, BOOL );

DWORD APIENTRY RasSetAutodialEnableW( DWORD, BOOL );

DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( DWORD, LPVOID, DWORD );

DWORD APIENTRY RasSetAutodialParamW( DWORD, LPVOID, DWORD );


#ifdef UNICODE
#define RasDial                 RasDialW
#define RasEnumConnections      RasEnumConnectionsW
#define RasEnumEntries          RasEnumEntriesW
#define RasGetConnectStatus     RasGetConnectStatusW
#define RasGetErrorString       RasGetErrorStringW
#define RasHangUp               RasHangUpW
#define RasGetProjectionInfo    RasGetProjectionInfoW
#define RasCreatePhonebookEntry RasCreatePhonebookEntryW
#define RasEditPhonebookEntry   RasEditPhonebookEntryW
#define RasSetEntryDialParams   RasSetEntryDialParamsW
#define RasGetEntryDialParams   RasGetEntryDialParamsW
#define RasEnumDevices          RasEnumDevicesW
#define RasGetCountryInfo       RasGetCountryInfoW
#define RasGetEntryProperties   RasGetEntryPropertiesW
#define RasSetEntryProperties   RasSetEntryPropertiesW
#define RasRenameEntry          RasRenameEntryW
#define RasDeleteEntry          RasDeleteEntryW
#define RasValidateEntryName    RasValidateEntryNameW
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#else
#define RasDial                 RasDialA
#define RasEnumConnections      RasEnumConnectionsA
#define RasEnumEntries          RasEnumEntriesA
#define RasGetConnectStatus     RasGetConnectStatusA
#define RasGetErrorString       RasGetErrorStringA
#define RasHangUp               RasHangUpA
#define RasGetProjectionInfo    RasGetProjectionInfoA
#define RasCreatePhonebookEntry RasCreatePhonebookEntryA
#define RasEditPhonebookEntry   RasEditPhonebookEntryA
#define RasSetEntryDialParams   RasSetEntryDialParamsA
#define RasGetEntryDialParams   RasGetEntryDialParamsA
#define RasEnumDevices          RasEnumDevicesA
#define RasGetCountryInfo       RasGetCountryInfoA
#define RasGetEntryProperties   RasGetEntryPropertiesA
#define RasSetEntryProperties   RasSetEntryPropertiesA
#define RasRenameEntry          RasRenameEntryA
#define RasDeleteEntry          RasDeleteEntryA
#define RasValidateEntryName    RasValidateEntryNameA
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
                      
#ifdef __cplusplus
}
#endif

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\semaphor.h ===
//****************************************************************************
//
//  File:       sempahor.h
//
//  Content:    This is the include file that contains the semaphore names
//              used by the various ICW components to ensure that only
//              one component is running at a time
//              (with the following expections:
//                -- with icwconn1 running, isignup and icwconn2 can execute.
//                -- with isignup running, icwconn2 can execute.
//
//  History:
//  12/3/96 jmazner     Created for Normandy bugs 12140, 12088
//              
//
//  Copyright (c) Microsoft Corporation 1996
//
//****************************************************************************


#define ICWCONN1_SEMAPHORE TEXT("Internet Connection Wizard ICWCONN1.EXE")
#define ICW_ELSE_SEMAPHORE TEXT("Internet Connection Wizard Non ICWCONN1 Component")

#define DIALOG_CLASS_NAME   TEXT("#32770")

BOOL IsAnotherComponentRunning32(BOOL bCreatedSemaphore);


/******

                                    Allow this component to execute?
                        /------------------------------------------------------------\
                        | ICWCONN1  | ISIGNUP   | ISIGN.INS | ICWCONN2  | INETWIZ
            /   --------|-------------------------------------------------------------
            |           |           |           |           |           |
            |   ICWCONN1|   no      |   _YES_   |   _YES_   |   _YES_   |   no
            |           |           |           |           |           |
            |   --------|-----------|-----------|-----------|-----------|--------------
if this     |           |           |           |           |           |
component   |   ISIGNUP |   no      |   no      |   _YES_   |   _YES_   |   no      
is running  |           |           |           |           |           |
            |   --------|-----------|-----------|-----------|-----------|--------------
            |           |           |           |           |           |
            |   ISIGNUP |   no      |   no      |   _YES_   |   _YES_   |   no      
            |      .INS |           |           |           |           |
            |   --------|-----------|-----------|-----------|-----------|--------------
            |           |           |           |           |           |
            |   ICWCONN2|   no      |   no      |   _YES_   |   _YES_   |   no      
            |           |           |           |           |           |
            |   --------|-----------|-----------|-----------|-----------|--------------
            |           |           |           |           |           |
            |   INETWIZ |   no      |   no      |   _YES_   |   _YES_   |   no      
            |           |           |           |           |           |
            \   --------|-----------|-----------|-----------|-----------|--------------


Implement this using two semaphores, one for ICWCONN1, and one for everything else (ICW_ELSE)
On startup, each component set its semaphore, then checks what other components are running.

Conn1:          check for ICWCONN1, ICW_ELSE
Isignup:        check for ICW_ELSE
Isignup .ins:   no checks
ICWCONN2:       no checks
Inetwiz:        Check for ICWCONN1, ICW_ELSE

******/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\tapi.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

The  Telephony  API  is jointly copyrighted by Intel and Microsoft.  You are
granted  a royalty free worldwide, unlimited license to make copies, and use
the   API/SPI  for  making  applications/drivers  that  interface  with  the
specification provided that this paragraph and the Intel/Microsoft copyright
statement is maintained as is in the text and source code files.

Copyright 1995-96 Microsoft, all rights reserved.
Portions copyright 1992, 1993 Intel/Microsoft, all rights reserved.

Module Name:

    tapi.h

Notes:

    Additions to the Telephony Application Programming Interface (TAPI) since
    version 1.0 are noted by version number (e.g. "TAPI v1.4").

--*/

#ifndef TAPI_H
#define TAPI_H



//
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//
// To build  a TAPI 1.4 application put a define as below in your source
// file before you include TAPI.H:
//
// #define TAPI_CURRENT_VERSION 0x00010004
//
//
#ifndef TAPI_CURRENT_VERSION
#define TAPI_CURRENT_VERSION 0x00020000
#endif

#include <windows.h>

#pragma pack(1)
// Type definitions of the data types used in tapi

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//
// TAPI type definitions
//

#define DECLARE_OPAQUE32(name)  struct name##__ { int unused; }; \
                typedef const struct name##__ FAR* name

DECLARE_OPAQUE32(HCALL);
typedef HCALL FAR * LPHCALL;

DECLARE_OPAQUE32(HLINE);
typedef HLINE FAR * LPHLINE;

DECLARE_OPAQUE32(HPHONE);
typedef HPHONE FAR * LPHPHONE;

DECLARE_OPAQUE32(HLINEAPP);
typedef HLINEAPP FAR * LPHLINEAPP;

DECLARE_OPAQUE32(HPHONEAPP);
typedef HPHONEAPP FAR * LPHPHONEAPP;

typedef HICON FAR * LPHICON;

typedef void (CALLBACK * LINECALLBACK)(
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD               dwInstance,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );

typedef void (CALLBACK * PHONECALLBACK)(
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD               dwInstance,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );


// Messages for Phones and Lines

#define LINE_ADDRESSSTATE                       0L
#define LINE_CALLINFO                           1L
#define LINE_CALLSTATE                          2L
#define LINE_CLOSE                              3L
#define LINE_DEVSPECIFIC                        4L
#define LINE_DEVSPECIFICFEATURE                 5L
#define LINE_GATHERDIGITS                       6L
#define LINE_GENERATE                           7L
#define LINE_LINEDEVSTATE                       8L
#define LINE_MONITORDIGITS                      9L
#define LINE_MONITORMEDIA                       10L
#define LINE_MONITORTONE                        11L
#define LINE_REPLY                              12L
#define LINE_REQUEST                            13L
#define PHONE_BUTTON                            14L
#define PHONE_CLOSE                             15L
#define PHONE_DEVSPECIFIC                       16L
#define PHONE_REPLY                             17L
#define PHONE_STATE                             18L
#define LINE_CREATE                             19L             // TAPI v1.4
#define PHONE_CREATE                            20L             // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINE_AGENTSPECIFIC                      21L             // TAPI v2.0
#define LINE_AGENTSTATUS                        22L             // TAPI v2.0
#define LINE_APPNEWCALL                         23L             // TAPI v2.0
#define LINE_PROXYREQUEST                       24L             // TAPI v2.0
#define LINE_REMOVE                             25L             // TAPI v2.0
#define PHONE_REMOVE                            26L             // TAPI v2.0
#endif


#define INITIALIZE_NEGOTIATION                  0xFFFFFFFFL

#define LINEADDRCAPFLAGS_FWDNUMRINGS            0x00000001
#define LINEADDRCAPFLAGS_PICKUPGROUPID          0x00000002
#define LINEADDRCAPFLAGS_SECURE                 0x00000004
#define LINEADDRCAPFLAGS_BLOCKIDDEFAULT         0x00000008
#define LINEADDRCAPFLAGS_BLOCKIDOVERRIDE        0x00000010
#define LINEADDRCAPFLAGS_DIALED                 0x00000020
#define LINEADDRCAPFLAGS_ORIGOFFHOOK            0x00000040
#define LINEADDRCAPFLAGS_DESTOFFHOOK            0x00000080
#define LINEADDRCAPFLAGS_FWDCONSULT             0x00000100
#define LINEADDRCAPFLAGS_SETUPCONFNULL          0x00000200
#define LINEADDRCAPFLAGS_AUTORECONNECT          0x00000400
#define LINEADDRCAPFLAGS_COMPLETIONID           0x00000800
#define LINEADDRCAPFLAGS_TRANSFERHELD           0x00001000
#define LINEADDRCAPFLAGS_TRANSFERMAKE           0x00002000
#define LINEADDRCAPFLAGS_CONFERENCEHELD         0x00004000
#define LINEADDRCAPFLAGS_CONFERENCEMAKE         0x00008000
#define LINEADDRCAPFLAGS_PARTIALDIAL            0x00010000
#define LINEADDRCAPFLAGS_FWDSTATUSVALID         0x00020000
#define LINEADDRCAPFLAGS_FWDINTEXTADDR          0x00040000
#define LINEADDRCAPFLAGS_FWDBUSYNAADDR          0x00080000
#define LINEADDRCAPFLAGS_ACCEPTTOALERT          0x00100000
#define LINEADDRCAPFLAGS_CONFDROP               0x00200000
#define LINEADDRCAPFLAGS_PICKUPCALLWAIT         0x00400000
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRCAPFLAGS_PREDICTIVEDIALER       0x00800000      // TAPI v2.0
#define LINEADDRCAPFLAGS_QUEUE                  0x01000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_ROUTEPOINT             0x02000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_HOLDMAKESNEW           0x04000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOINTERNALCALLS        0x08000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOEXTERNALCALLS        0x10000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_SETCALLINGID           0x20000000      // TAPI v2.0
#endif

#define LINEADDRESSMODE_ADDRESSID               0x00000001
#define LINEADDRESSMODE_DIALABLEADDR            0x00000002

#define LINEADDRESSSHARING_PRIVATE              0x00000001
#define LINEADDRESSSHARING_BRIDGEDEXCL          0x00000002
#define LINEADDRESSSHARING_BRIDGEDNEW           0x00000004
#define LINEADDRESSSHARING_BRIDGEDSHARED        0x00000008
#define LINEADDRESSSHARING_MONITORED            0x00000010

#define LINEADDRESSSTATE_OTHER                  0x00000001
#define LINEADDRESSSTATE_DEVSPECIFIC            0x00000002
#define LINEADDRESSSTATE_INUSEZERO              0x00000004
#define LINEADDRESSSTATE_INUSEONE               0x00000008
#define LINEADDRESSSTATE_INUSEMANY              0x00000010
#define LINEADDRESSSTATE_NUMCALLS               0x00000020
#define LINEADDRESSSTATE_FORWARD                0x00000040
#define LINEADDRESSSTATE_TERMINALS              0x00000080
#define LINEADDRESSSTATE_CAPSCHANGE             0x00000100      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRESSSTATE_AGENT                  0x00000200      // TAPI v2.0
#define LINEADDRESSSTATE_AGENTSTATE             0x00000400      // TAPI v2.0
#define LINEADDRESSSTATE_AGENTACTIVITY          0x00000800      // TAPI v2.0
#endif

#define LINEADDRFEATURE_FORWARD                 0x00000001
#define LINEADDRFEATURE_MAKECALL                0x00000002
#define LINEADDRFEATURE_PICKUP                  0x00000004
#define LINEADDRFEATURE_SETMEDIACONTROL         0x00000008
#define LINEADDRFEATURE_SETTERMINAL             0x00000010
#define LINEADDRFEATURE_SETUPCONF               0x00000020
#define LINEADDRFEATURE_UNCOMPLETECALL          0x00000040
#define LINEADDRFEATURE_UNPARK                  0x00000080
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRFEATURE_PICKUPHELD              0x00000100      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPGROUP             0x00000200      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPDIRECT            0x00000400      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPWAITING           0x00000800      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDFWD              0x00001000      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDDND              0x00002000      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEAGENTFEATURE_SETAGENTGROUP          0x00000001      // TAPI v2.0
#define LINEAGENTFEATURE_SETAGENTSTATE          0x00000002      // TAPI v2.0
#define LINEAGENTFEATURE_SETAGENTACTIVITY       0x00000004      // TAPI v2.0
#define LINEAGENTFEATURE_AGENTSPECIFIC          0x00000008      // TAPI v2.0
#define LINEAGENTFEATURE_GETAGENTACTIVITYLIST   0x00000010      // TAPI v2.0
#define LINEAGENTFEATURE_GETAGENTGROUP          0x00000020      // TAPI v2.0

#define LINEAGENTSTATE_LOGGEDOFF                0x00000001      // TAPI v2.0
#define LINEAGENTSTATE_NOTREADY                 0x00000002      // TAPI v2.0
#define LINEAGENTSTATE_READY                    0x00000004      // TAPI v2.0
#define LINEAGENTSTATE_BUSYACD                  0x00000008      // TAPI v2.0
#define LINEAGENTSTATE_BUSYINCOMING             0x00000010      // TAPI v2.0
#define LINEAGENTSTATE_BUSYOUTBOUND             0x00000020      // TAPI v2.0
#define LINEAGENTSTATE_BUSYOTHER                0x00000040      // TAPI v2.0
#define LINEAGENTSTATE_WORKINGAFTERCALL         0x00000080      // TAPI v2.0
#define LINEAGENTSTATE_UNKNOWN                  0x00000100      // TAPI v2.0
#define LINEAGENTSTATE_UNAVAIL                  0x00000200      // TAPI v2.0

#define LINEAGENTSTATUS_GROUP                   0x00000001      // TAPI v2.0
#define LINEAGENTSTATUS_STATE                   0x00000002      // TAPI v2.0
#define LINEAGENTSTATUS_NEXTSTATE               0x00000004      // TAPI v2.0
#define LINEAGENTSTATUS_ACTIVITY                0x00000008      // TAPI v2.0
#define LINEAGENTSTATUS_ACTIVITYLIST            0x00000010      // TAPI v2.0
#define LINEAGENTSTATUS_GROUPLIST               0x00000020      // TAPI v2.0
#define LINEAGENTSTATUS_CAPSCHANGE              0x00000040      // TAPI v2.0
#define LINEAGENTSTATUS_VALIDSTATES             0x00000080      // TAPI v2.0
#define LINEAGENTSTATUS_VALIDNEXTSTATES         0x00000100      // TAPI v2.0
#endif


#define LINEANSWERMODE_NONE                     0x00000001
#define LINEANSWERMODE_DROP                     0x00000002
#define LINEANSWERMODE_HOLD                     0x00000004

#define LINEBEARERMODE_VOICE                    0x00000001
#define LINEBEARERMODE_SPEECH                   0x00000002
#define LINEBEARERMODE_MULTIUSE                 0x00000004
#define LINEBEARERMODE_DATA                     0x00000008
#define LINEBEARERMODE_ALTSPEECHDATA            0x00000010
#define LINEBEARERMODE_NONCALLSIGNALING         0x00000020
#define LINEBEARERMODE_PASSTHROUGH              0x00000040      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEBEARERMODE_RESTRICTEDDATA           0x00000080      // TAPI v2.0
#endif

#define LINEBUSYMODE_STATION                    0x00000001
#define LINEBUSYMODE_TRUNK                      0x00000002
#define LINEBUSYMODE_UNKNOWN                    0x00000004
#define LINEBUSYMODE_UNAVAIL                    0x00000008

#define LINECALLCOMPLCOND_BUSY                  0x00000001
#define LINECALLCOMPLCOND_NOANSWER              0x00000002

#define LINECALLCOMPLMODE_CAMPON                0x00000001
#define LINECALLCOMPLMODE_CALLBACK              0x00000002
#define LINECALLCOMPLMODE_INTRUDE               0x00000004
#define LINECALLCOMPLMODE_MESSAGE               0x00000008

#define LINECALLFEATURE_ACCEPT                  0x00000001
#define LINECALLFEATURE_ADDTOCONF               0x00000002
#define LINECALLFEATURE_ANSWER                  0x00000004
#define LINECALLFEATURE_BLINDTRANSFER           0x00000008
#define LINECALLFEATURE_COMPLETECALL            0x00000010
#define LINECALLFEATURE_COMPLETETRANSF          0x00000020
#define LINECALLFEATURE_DIAL                    0x00000040
#define LINECALLFEATURE_DROP                    0x00000080
#define LINECALLFEATURE_GATHERDIGITS            0x00000100
#define LINECALLFEATURE_GENERATEDIGITS          0x00000200
#define LINECALLFEATURE_GENERATETONE            0x00000400
#define LINECALLFEATURE_HOLD                    0x00000800
#define LINECALLFEATURE_MONITORDIGITS           0x00001000
#define LINECALLFEATURE_MONITORMEDIA            0x00002000
#define LINECALLFEATURE_MONITORTONES            0x00004000
#define LINECALLFEATURE_PARK                    0x00008000
#define LINECALLFEATURE_PREPAREADDCONF          0x00010000
#define LINECALLFEATURE_REDIRECT                0x00020000
#define LINECALLFEATURE_REMOVEFROMCONF          0x00040000
#define LINECALLFEATURE_SECURECALL              0x00080000
#define LINECALLFEATURE_SENDUSERUSER            0x00100000
#define LINECALLFEATURE_SETCALLPARAMS           0x00200000
#define LINECALLFEATURE_SETMEDIACONTROL         0x00400000
#define LINECALLFEATURE_SETTERMINAL             0x00800000
#define LINECALLFEATURE_SETUPCONF               0x01000000
#define LINECALLFEATURE_SETUPTRANSFER           0x02000000
#define LINECALLFEATURE_SWAPHOLD                0x04000000
#define LINECALLFEATURE_UNHOLD                  0x08000000
#define LINECALLFEATURE_RELEASEUSERUSERINFO     0x10000000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE_SETTREATMENT            0x20000000      // TAPI v2.0
#define LINECALLFEATURE_SETQOS                  0x40000000      // TAPI v2.0
#define LINECALLFEATURE_SETCALLDATA             0x80000000      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE2_NOHOLDCONFERENCE       0x00000001      // TAPI v2.0
#define LINECALLFEATURE2_ONESTEPTRANSFER        0x00000002      // TAPI v2.0
#define LINECALLFEATURE2_COMPLCAMPON            0x00000004      // TAPI v2.0
#define LINECALLFEATURE2_COMPLCALLBACK          0x00000008      // TAPI v2.0
#define LINECALLFEATURE2_COMPLINTRUDE           0x00000010      // TAPI v2.0
#define LINECALLFEATURE2_COMPLMESSAGE           0x00000020      // TAPI v2.0
#define LINECALLFEATURE2_TRANSFERNORM           0x00000040      // TAPI v2.0
#define LINECALLFEATURE2_TRANSFERCONF           0x00000080      // TAPI v2.0
#define LINECALLFEATURE2_PARKDIRECT             0x00000100      // TAPI v2.0
#define LINECALLFEATURE2_PARKNONDIRECT          0x00000200      // TAPI v2.0
#endif

#define LINECALLINFOSTATE_OTHER                 0x00000001
#define LINECALLINFOSTATE_DEVSPECIFIC           0x00000002
#define LINECALLINFOSTATE_BEARERMODE            0x00000004
#define LINECALLINFOSTATE_RATE                  0x00000008
#define LINECALLINFOSTATE_MEDIAMODE             0x00000010
#define LINECALLINFOSTATE_APPSPECIFIC           0x00000020
#define LINECALLINFOSTATE_CALLID                0x00000040
#define LINECALLINFOSTATE_RELATEDCALLID         0x00000080
#define LINECALLINFOSTATE_ORIGIN                0x00000100
#define LINECALLINFOSTATE_REASON                0x00000200
#define LINECALLINFOSTATE_COMPLETIONID          0x00000400
#define LINECALLINFOSTATE_NUMOWNERINCR          0x00000800
#define LINECALLINFOSTATE_NUMOWNERDECR          0x00001000
#define LINECALLINFOSTATE_NUMMONITORS           0x00002000
#define LINECALLINFOSTATE_TRUNK                 0x00004000
#define LINECALLINFOSTATE_CALLERID              0x00008000
#define LINECALLINFOSTATE_CALLEDID              0x00010000
#define LINECALLINFOSTATE_CONNECTEDID           0x00020000
#define LINECALLINFOSTATE_REDIRECTIONID         0x00040000
#define LINECALLINFOSTATE_REDIRECTINGID         0x00080000
#define LINECALLINFOSTATE_DISPLAY               0x00100000
#define LINECALLINFOSTATE_USERUSERINFO          0x00200000
#define LINECALLINFOSTATE_HIGHLEVELCOMP         0x00400000
#define LINECALLINFOSTATE_LOWLEVELCOMP          0x00800000
#define LINECALLINFOSTATE_CHARGINGINFO          0x01000000
#define LINECALLINFOSTATE_TERMINAL              0x02000000
#define LINECALLINFOSTATE_DIALPARAMS            0x04000000
#define LINECALLINFOSTATE_MONITORMODES          0x08000000
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLINFOSTATE_TREATMENT             0x10000000      // TAPI v2.0
#define LINECALLINFOSTATE_QOS                   0x20000000      // TAPI v2.0
#define LINECALLINFOSTATE_CALLDATA              0x40000000      // TAPI v2.0
#endif

#define LINECALLORIGIN_OUTBOUND                 0x00000001
#define LINECALLORIGIN_INTERNAL                 0x00000002
#define LINECALLORIGIN_EXTERNAL                 0x00000004
#define LINECALLORIGIN_UNKNOWN                  0x00000010
#define LINECALLORIGIN_UNAVAIL                  0x00000020
#define LINECALLORIGIN_CONFERENCE               0x00000040
#define LINECALLORIGIN_INBOUND                  0x00000080      // TAPI v1.4

#define LINECALLPARAMFLAGS_SECURE               0x00000001
#define LINECALLPARAMFLAGS_IDLE                 0x00000002
#define LINECALLPARAMFLAGS_BLOCKID              0x00000004
#define LINECALLPARAMFLAGS_ORIGOFFHOOK          0x00000008
#define LINECALLPARAMFLAGS_DESTOFFHOOK          0x00000010
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLPARAMFLAGS_NOHOLDCONFERENCE     0x00000020      // TAPI v2.0
#define LINECALLPARAMFLAGS_PREDICTIVEDIAL       0x00000040      // TAPI v2.0
#define LINECALLPARAMFLAGS_ONESTEPTRANSFER      0x00000080      // TAPI v2.0
#endif

#define LINECALLPARTYID_BLOCKED                 0x00000001
#define LINECALLPARTYID_OUTOFAREA               0x00000002
#define LINECALLPARTYID_NAME                    0x00000004
#define LINECALLPARTYID_ADDRESS                 0x00000008
#define LINECALLPARTYID_PARTIAL                 0x00000010
#define LINECALLPARTYID_UNKNOWN                 0x00000020
#define LINECALLPARTYID_UNAVAIL                 0x00000040

#define LINECALLPRIVILEGE_NONE                  0x00000001
#define LINECALLPRIVILEGE_MONITOR               0x00000002
#define LINECALLPRIVILEGE_OWNER                 0x00000004

#define LINECALLREASON_DIRECT                   0x00000001
#define LINECALLREASON_FWDBUSY                  0x00000002
#define LINECALLREASON_FWDNOANSWER              0x00000004
#define LINECALLREASON_FWDUNCOND                0x00000008
#define LINECALLREASON_PICKUP                   0x00000010
#define LINECALLREASON_UNPARK                   0x00000020
#define LINECALLREASON_REDIRECT                 0x00000040
#define LINECALLREASON_CALLCOMPLETION           0x00000080
#define LINECALLREASON_TRANSFER                 0x00000100
#define LINECALLREASON_REMINDER                 0x00000200
#define LINECALLREASON_UNKNOWN                  0x00000400
#define LINECALLREASON_UNAVAIL                  0x00000800
#define LINECALLREASON_INTRUDE                  0x00001000      // TAPI v1.4
#define LINECALLREASON_PARKED                   0x00002000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLREASON_CAMPEDON                 0x00004000      // TAPI v2.0
#define LINECALLREASON_ROUTEREQUEST             0x00008000      // TAPI v2.0
#endif

#define LINECALLSELECT_LINE                     0x00000001
#define LINECALLSELECT_ADDRESS                  0x00000002
#define LINECALLSELECT_CALL                     0x00000004

#define LINECALLSTATE_IDLE                      0x00000001
#define LINECALLSTATE_OFFERING                  0x00000002
#define LINECALLSTATE_ACCEPTED                  0x00000004
#define LINECALLSTATE_DIALTONE                  0x00000008
#define LINECALLSTATE_DIALING                   0x00000010
#define LINECALLSTATE_RINGBACK                  0x00000020
#define LINECALLSTATE_BUSY                      0x00000040
#define LINECALLSTATE_SPECIALINFO               0x00000080
#define LINECALLSTATE_CONNECTED                 0x00000100
#define LINECALLSTATE_PROCEEDING                0x00000200
#define LINECALLSTATE_ONHOLD                    0x00000400
#define LINECALLSTATE_CONFERENCED               0x00000800
#define LINECALLSTATE_ONHOLDPENDCONF            0x00001000
#define LINECALLSTATE_ONHOLDPENDTRANSFER        0x00002000
#define LINECALLSTATE_DISCONNECTED              0x00004000
#define LINECALLSTATE_UNKNOWN                   0x00008000

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLTREATMENT_SILENCE               0x00000001      // TAPI v2.0
#define LINECALLTREATMENT_RINGBACK              0x00000002      // TAPI v2.0
#define LINECALLTREATMENT_BUSY                  0x00000003      // TAPI v2.0
#define LINECALLTREATMENT_MUSIC                 0x00000004      // TAPI v2.0
#endif

#define LINECARDOPTION_PREDEFINED               0x00000001      // TAPI v1.4
#define LINECARDOPTION_HIDDEN                   0x00000002      // TAPI v1.4

#define LINECONNECTEDMODE_ACTIVE                0x00000001      // TAPI v1.4
#define LINECONNECTEDMODE_INACTIVE              0x00000002      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECONNECTEDMODE_ACTIVEHELD            0x00000004      // TAPI v2.0
#define LINECONNECTEDMODE_INACTIVEHELD          0x00000008      // TAPI v2.0
#define LINECONNECTEDMODE_CONFIRMED             0x00000010      // TAPI v2.0
#endif

#define LINEDEVCAPFLAGS_CROSSADDRCONF           0x00000001
#define LINEDEVCAPFLAGS_HIGHLEVCOMP             0x00000002
#define LINEDEVCAPFLAGS_LOWLEVCOMP              0x00000004
#define LINEDEVCAPFLAGS_MEDIACONTROL            0x00000008
#define LINEDEVCAPFLAGS_MULTIPLEADDR            0x00000010
#define LINEDEVCAPFLAGS_CLOSEDROP               0x00000020
#define LINEDEVCAPFLAGS_DIALBILLING             0x00000040
#define LINEDEVCAPFLAGS_DIALQUIET               0x00000080
#define LINEDEVCAPFLAGS_DIALDIALTONE            0x00000100

#define LINEDEVSTATE_OTHER                      0x00000001
#define LINEDEVSTATE_RINGING                    0x00000002
#define LINEDEVSTATE_CONNECTED                  0x00000004
#define LINEDEVSTATE_DISCONNECTED               0x00000008
#define LINEDEVSTATE_MSGWAITON                  0x00000010
#define LINEDEVSTATE_MSGWAITOFF                 0x00000020
#define LINEDEVSTATE_INSERVICE                  0x00000040
#define LINEDEVSTATE_OUTOFSERVICE               0x00000080
#define LINEDEVSTATE_MAINTENANCE                0x00000100
#define LINEDEVSTATE_OPEN                       0x00000200
#define LINEDEVSTATE_CLOSE                      0x00000400
#define LINEDEVSTATE_NUMCALLS                   0x00000800
#define LINEDEVSTATE_NUMCOMPLETIONS             0x00001000
#define LINEDEVSTATE_TERMINALS                  0x00002000
#define LINEDEVSTATE_ROAMMODE                   0x00004000
#define LINEDEVSTATE_BATTERY                    0x00008000
#define LINEDEVSTATE_SIGNAL                     0x00010000
#define LINEDEVSTATE_DEVSPECIFIC                0x00020000
#define LINEDEVSTATE_REINIT                     0x00040000
#define LINEDEVSTATE_LOCK                       0x00080000
#define LINEDEVSTATE_CAPSCHANGE                 0x00100000      // TAPI v1.4
#define LINEDEVSTATE_CONFIGCHANGE               0x00200000      // TAPI v1.4
#define LINEDEVSTATE_TRANSLATECHANGE            0x00400000      // TAPI v1.4
#define LINEDEVSTATE_COMPLCANCEL                0x00800000      // TAPI v1.4
#define LINEDEVSTATE_REMOVED                    0x01000000      // TAPI v1.4

#define LINEDEVSTATUSFLAGS_CONNECTED            0x00000001
#define LINEDEVSTATUSFLAGS_MSGWAIT              0x00000002
#define LINEDEVSTATUSFLAGS_INSERVICE            0x00000004
#define LINEDEVSTATUSFLAGS_LOCKED               0x00000008

#define LINEDIALTONEMODE_NORMAL                 0x00000001
#define LINEDIALTONEMODE_SPECIAL                0x00000002
#define LINEDIALTONEMODE_INTERNAL               0x00000004
#define LINEDIALTONEMODE_EXTERNAL               0x00000008
#define LINEDIALTONEMODE_UNKNOWN                0x00000010
#define LINEDIALTONEMODE_UNAVAIL                0x00000020
    
#define LINEDIGITMODE_PULSE                     0x00000001
#define LINEDIGITMODE_DTMF                      0x00000002
#define LINEDIGITMODE_DTMFEND                   0x00000004
    
#define LINEDISCONNECTMODE_NORMAL               0x00000001
#define LINEDISCONNECTMODE_UNKNOWN              0x00000002
#define LINEDISCONNECTMODE_REJECT               0x00000004
#define LINEDISCONNECTMODE_PICKUP               0x00000008
#define LINEDISCONNECTMODE_FORWARDED            0x00000010
#define LINEDISCONNECTMODE_BUSY                 0x00000020
#define LINEDISCONNECTMODE_NOANSWER             0x00000040
#define LINEDISCONNECTMODE_BADADDRESS           0x00000080
#define LINEDISCONNECTMODE_UNREACHABLE          0x00000100
#define LINEDISCONNECTMODE_CONGESTION           0x00000200
#define LINEDISCONNECTMODE_INCOMPATIBLE         0x00000400
#define LINEDISCONNECTMODE_UNAVAIL              0x00000800
#define LINEDISCONNECTMODE_NODIALTONE           0x00001000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEDISCONNECTMODE_NUMBERCHANGED        0x00002000      // TAPI v2.0
#define LINEDISCONNECTMODE_OUTOFORDER           0x00004000      // TAPI v2.0
#define LINEDISCONNECTMODE_TEMPFAILURE          0x00008000      // TAPI v2.0
#define LINEDISCONNECTMODE_QOSUNAVAIL           0x00010000      // TAPI v2.0
#define LINEDISCONNECTMODE_BLOCKED              0x00020000      // TAPI v2.0
#define LINEDISCONNECTMODE_DONOTDISTURB         0x00040000      // TAPI v2.0
#endif

#define LINEERR_ALLOCATED                       0x80000001
#define LINEERR_BADDEVICEID                     0x80000002
#define LINEERR_BEARERMODEUNAVAIL               0x80000003
#define LINEERR_CALLUNAVAIL                     0x80000005
#define LINEERR_COMPLETIONOVERRUN               0x80000006
#define LINEERR_CONFERENCEFULL                  0x80000007
#define LINEERR_DIALBILLING                     0x80000008
#define LINEERR_DIALDIALTONE                    0x80000009
#define LINEERR_DIALPROMPT                      0x8000000A
#define LINEERR_DIALQUIET                       0x8000000B
#define LINEERR_INCOMPATIBLEAPIVERSION          0x8000000C
#define LINEERR_INCOMPATIBLEEXTVERSION          0x8000000D
#define LINEERR_INIFILECORRUPT                  0x8000000E
#define LINEERR_INUSE                           0x8000000F
#define LINEERR_INVALADDRESS                    0x80000010
#define LINEERR_INVALADDRESSID                  0x80000011
#define LINEERR_INVALADDRESSMODE                0x80000012
#define LINEERR_INVALADDRESSSTATE               0x80000013
#define LINEERR_INVALAPPHANDLE                  0x80000014
#define LINEERR_INVALAPPNAME                    0x80000015
#define LINEERR_INVALBEARERMODE                 0x80000016
#define LINEERR_INVALCALLCOMPLMODE              0x80000017
#define LINEERR_INVALCALLHANDLE                 0x80000018
#define LINEERR_INVALCALLPARAMS                 0x80000019
#define LINEERR_INVALCALLPRIVILEGE              0x8000001A
#define LINEERR_INVALCALLSELECT                 0x8000001B
#define LINEERR_INVALCALLSTATE                  0x8000001C
#define LINEERR_INVALCALLSTATELIST              0x8000001D
#define LINEERR_INVALCARD                       0x8000001E
#define LINEERR_INVALCOMPLETIONID               0x8000001F
#define LINEERR_INVALCONFCALLHANDLE             0x80000020
#define LINEERR_INVALCONSULTCALLHANDLE          0x80000021
#define LINEERR_INVALCOUNTRYCODE                0x80000022
#define LINEERR_INVALDEVICECLASS                0x80000023
#define LINEERR_INVALDEVICEHANDLE               0x80000024
#define LINEERR_INVALDIALPARAMS                 0x80000025
#define LINEERR_INVALDIGITLIST                  0x80000026
#define LINEERR_INVALDIGITMODE                  0x80000027
#define LINEERR_INVALDIGITS                     0x80000028
#define LINEERR_INVALEXTVERSION                 0x80000029
#define LINEERR_INVALGROUPID                    0x8000002A
#define LINEERR_INVALLINEHANDLE                 0x8000002B
#define LINEERR_INVALLINESTATE                  0x8000002C
#define LINEERR_INVALLOCATION                   0x8000002D
#define LINEERR_INVALMEDIALIST                  0x8000002E
#define LINEERR_INVALMEDIAMODE                  0x8000002F
#define LINEERR_INVALMESSAGEID                  0x80000030
#define LINEERR_INVALPARAM                      0x80000032
#define LINEERR_INVALPARKID                     0x80000033
#define LINEERR_INVALPARKMODE                   0x80000034
#define LINEERR_INVALPOINTER                    0x80000035
#define LINEERR_INVALPRIVSELECT                 0x80000036
#define LINEERR_INVALRATE                       0x80000037
#define LINEERR_INVALREQUESTMODE                0x80000038
#define LINEERR_INVALTERMINALID                 0x80000039
#define LINEERR_INVALTERMINALMODE               0x8000003A
#define LINEERR_INVALTIMEOUT                    0x8000003B
#define LINEERR_INVALTONE                       0x8000003C
#define LINEERR_INVALTONELIST                   0x8000003D
#define LINEERR_INVALTONEMODE                   0x8000003E
#define LINEERR_INVALTRANSFERMODE               0x8000003F
#define LINEERR_LINEMAPPERFAILED                0x80000040
#define LINEERR_NOCONFERENCE                    0x80000041
#define LINEERR_NODEVICE                        0x80000042
#define LINEERR_NODRIVER                        0x80000043
#define LINEERR_NOMEM                           0x80000044
#define LINEERR_NOREQUEST                       0x80000045
#define LINEERR_NOTOWNER                        0x80000046
#define LINEERR_NOTREGISTERED                   0x80000047
#define LINEERR_OPERATIONFAILED                 0x80000048
#define LINEERR_OPERATIONUNAVAIL                0x80000049
#define LINEERR_RATEUNAVAIL                     0x8000004A
#define LINEERR_RESOURCEUNAVAIL                 0x8000004B
#define LINEERR_REQUESTOVERRUN                  0x8000004C
#define LINEERR_STRUCTURETOOSMALL               0x8000004D
#define LINEERR_TARGETNOTFOUND                  0x8000004E
#define LINEERR_TARGETSELF                      0x8000004F
#define LINEERR_UNINITIALIZED                   0x80000050
#define LINEERR_USERUSERINFOTOOBIG              0x80000051
#define LINEERR_REINIT                          0x80000052
#define LINEERR_ADDRESSBLOCKED                  0x80000053
#define LINEERR_BILLINGREJECTED                 0x80000054
#define LINEERR_INVALFEATURE                    0x80000055
#define LINEERR_NOMULTIPLEINSTANCE              0x80000056
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEERR_INVALAGENTID                    0x80000057      // TAPI v2.0
#define LINEERR_INVALAGENTGROUP                 0x80000058      // TAPI v2.0
#define LINEERR_INVALPASSWORD                   0x80000059      // TAPI v2.0
#define LINEERR_INVALAGENTSTATE                 0x8000005A      // TAPI v2.0
#define LINEERR_INVALAGENTACTIVITY              0x8000005B      // TAPI v2.0
#define LINEERR_DIALVOICEDETECT                 0x8000005C      // TAPI v2.0
#endif

#define LINEFEATURE_DEVSPECIFIC                 0x00000001
#define LINEFEATURE_DEVSPECIFICFEAT             0x00000002
#define LINEFEATURE_FORWARD                     0x00000004
#define LINEFEATURE_MAKECALL                    0x00000008
#define LINEFEATURE_SETMEDIACONTROL             0x00000010
#define LINEFEATURE_SETTERMINAL                 0x00000020
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEFEATURE_SETDEVSTATUS                0x00000040      // TAPI v2.0
#define LINEFEATURE_FORWARDFWD                  0x00000080      // TAPI v2.0
#define LINEFEATURE_FORWARDDND                  0x00000100      // TAPI v2.0
#endif

#define LINEFORWARDMODE_UNCOND                  0x00000001
#define LINEFORWARDMODE_UNCONDINTERNAL          0x00000002
#define LINEFORWARDMODE_UNCONDEXTERNAL          0x00000004
#define LINEFORWARDMODE_UNCONDSPECIFIC          0x00000008
#define LINEFORWARDMODE_BUSY                    0x00000010
#define LINEFORWARDMODE_BUSYINTERNAL            0x00000020
#define LINEFORWARDMODE_BUSYEXTERNAL            0x00000040
#define LINEFORWARDMODE_BUSYSPECIFIC            0x00000080
#define LINEFORWARDMODE_NOANSW                  0x00000100
#define LINEFORWARDMODE_NOANSWINTERNAL          0x00000200
#define LINEFORWARDMODE_NOANSWEXTERNAL          0x00000400
#define LINEFORWARDMODE_NOANSWSPECIFIC          0x00000800
#define LINEFORWARDMODE_BUSYNA                  0x00001000
#define LINEFORWARDMODE_BUSYNAINTERNAL          0x00002000
#define LINEFORWARDMODE_BUSYNAEXTERNAL          0x00004000
#define LINEFORWARDMODE_BUSYNASPECIFIC          0x00008000
#define LINEFORWARDMODE_UNKNOWN                 0x00010000      // TAPI v1.4
#define LINEFORWARDMODE_UNAVAIL                 0x00020000      // TAPI v1.4

#define LINEGATHERTERM_BUFFERFULL               0x00000001
#define LINEGATHERTERM_TERMDIGIT                0x00000002
#define LINEGATHERTERM_FIRSTTIMEOUT             0x00000004
#define LINEGATHERTERM_INTERTIMEOUT             0x00000008
#define LINEGATHERTERM_CANCEL                   0x00000010

#define LINEGENERATETERM_DONE                   0x00000001
#define LINEGENERATETERM_CANCEL                 0x00000002

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEINITIALIZEEXOPTION_USEHIDDENWINDOW      0x00000001  // TAPI v2.0
#define LINEINITIALIZEEXOPTION_USEEVENT             0x00000002  // TAPI v2.0
#define LINEINITIALIZEEXOPTION_USECOMPLETIONPORT    0x00000004  // TAPI v2.0
#endif

#define LINELOCATIONOPTION_PULSEDIAL            0x00000001      // TAPI v1.4

#define LINEMAPPER                              0xFFFFFFFF

#define LINEMEDIACONTROL_NONE                   0x00000001
#define LINEMEDIACONTROL_START                  0x00000002
#define LINEMEDIACONTROL_RESET                  0x00000004
#define LINEMEDIACONTROL_PAUSE                  0x00000008
#define LINEMEDIACONTROL_RESUME                 0x00000010
#define LINEMEDIACONTROL_RATEUP                 0x00000020
#define LINEMEDIACONTROL_RATEDOWN               0x00000040
#define LINEMEDIACONTROL_RATENORMAL             0x00000080
#define LINEMEDIACONTROL_VOLUMEUP               0x00000100
#define LINEMEDIACONTROL_VOLUMEDOWN             0x00000200
#define LINEMEDIACONTROL_VOLUMENORMAL           0x00000400

#define LINEMEDIAMODE_UNKNOWN                   0x00000002
#define LINEMEDIAMODE_INTERACTIVEVOICE          0x00000004
#define LINEMEDIAMODE_AUTOMATEDVOICE            0x00000008
#define LINEMEDIAMODE_DATAMODEM                 0x00000010
#define LINEMEDIAMODE_G3FAX                     0x00000020
#define LINEMEDIAMODE_TDD                       0x00000040
#define LINEMEDIAMODE_G4FAX                     0x00000080
#define LINEMEDIAMODE_DIGITALDATA               0x00000100
#define LINEMEDIAMODE_TELETEX                   0x00000200
#define LINEMEDIAMODE_VIDEOTEX                  0x00000400
#define LINEMEDIAMODE_TELEX                     0x00000800
#define LINEMEDIAMODE_MIXED                     0x00001000
#define LINEMEDIAMODE_ADSI                      0x00002000
#define LINEMEDIAMODE_VOICEVIEW                 0x00004000      // TAPI v1.4
#define LAST_LINEMEDIAMODE                      0x00004000

#define LINEOFFERINGMODE_ACTIVE                 0x00000001      // TAPI v1.4
#define LINEOFFERINGMODE_INACTIVE               0x00000002      // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEOPENOPTION_SINGLEADDRESS            0x80000000      // TAPI v2.0
#define LINEOPENOPTION_PROXY                    0x40000000      // TAPI v2.0
#endif

#define LINEPARKMODE_DIRECTED                   0x00000001
#define LINEPARKMODE_NONDIRECTED                0x00000002

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEPROXYREQUEST_SETAGENTGROUP          0x00000001      // TAPI v2.0
#define LINEPROXYREQUEST_SETAGENTSTATE          0x00000002      // TAPI v2.0
#define LINEPROXYREQUEST_SETAGENTACTIVITY       0x00000003      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTCAPS           0x00000004      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTSTATUS         0x00000005      // TAPI v2.0
#define LINEPROXYREQUEST_AGENTSPECIFIC          0x00000006      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTACTIVITYLIST   0x00000007      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTGROUPLIST      0x00000008      // TAPI v2.0
#endif

#define LINEREMOVEFROMCONF_NONE                 0x00000001
#define LINEREMOVEFROMCONF_LAST                 0x00000002
#define LINEREMOVEFROMCONF_ANY                  0x00000003

#define LINEREQUESTMODE_MAKECALL                0x00000001
#define LINEREQUESTMODE_MEDIACALL               0x00000002
#define LINEREQUESTMODE_DROP                    0x00000004
#define LAST_LINEREQUESTMODE                    LINEREQUESTMODE_MEDIACALL

#define LINEROAMMODE_UNKNOWN                    0x00000001
#define LINEROAMMODE_UNAVAIL                    0x00000002
#define LINEROAMMODE_HOME                       0x00000004
#define LINEROAMMODE_ROAMA                      0x00000008
#define LINEROAMMODE_ROAMB                      0x00000010

#define LINESPECIALINFO_NOCIRCUIT               0x00000001
#define LINESPECIALINFO_CUSTIRREG               0x00000002
#define LINESPECIALINFO_REORDER                 0x00000004
#define LINESPECIALINFO_UNKNOWN                 0x00000008
#define LINESPECIALINFO_UNAVAIL                 0x00000010

#define LINETERMDEV_PHONE                       0x00000001
#define LINETERMDEV_HEADSET                     0x00000002
#define LINETERMDEV_SPEAKER                     0x00000004

#define LINETERMMODE_BUTTONS                    0x00000001
#define LINETERMMODE_LAMPS                      0x00000002
#define LINETERMMODE_DISPLAY                    0x00000004
#define LINETERMMODE_RINGER                     0x00000008
#define LINETERMMODE_HOOKSWITCH                 0x00000010
#define LINETERMMODE_MEDIATOLINE                0x00000020
#define LINETERMMODE_MEDIAFROMLINE              0x00000040
#define LINETERMMODE_MEDIABIDIRECT              0x00000080

#define LINETERMSHARING_PRIVATE                 0x00000001
#define LINETERMSHARING_SHAREDEXCL              0x00000002
#define LINETERMSHARING_SHAREDCONF              0x00000004

#define LINETOLLLISTOPTION_ADD                  0x00000001
#define LINETOLLLISTOPTION_REMOVE               0x00000002

#define LINETONEMODE_CUSTOM                     0x00000001
#define LINETONEMODE_RINGBACK                   0x00000002
#define LINETONEMODE_BUSY                       0x00000004
#define LINETONEMODE_BEEP                       0x00000008
#define LINETONEMODE_BILLING                    0x00000010

#define LINETRANSFERMODE_TRANSFER               0x00000001
#define LINETRANSFERMODE_CONFERENCE             0x00000002

#define LINETRANSLATEOPTION_CARDOVERRIDE        0x00000001
#define LINETRANSLATEOPTION_CANCELCALLWAITING   0x00000002      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELOCAL          0x00000004      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELD             0x00000008      // TAPI v1.4

#define LINETRANSLATERESULT_CANONICAL           0x00000001
#define LINETRANSLATERESULT_INTERNATIONAL       0x00000002
#define LINETRANSLATERESULT_LONGDISTANCE        0x00000004
#define LINETRANSLATERESULT_LOCAL               0x00000008
#define LINETRANSLATERESULT_INTOLLLIST          0x00000010
#define LINETRANSLATERESULT_NOTINTOLLLIST       0x00000020
#define LINETRANSLATERESULT_DIALBILLING         0x00000040
#define LINETRANSLATERESULT_DIALQUIET           0x00000080
#define LINETRANSLATERESULT_DIALDIALTONE        0x00000100
#define LINETRANSLATERESULT_DIALPROMPT          0x00000200
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINETRANSLATERESULT_VOICEDETECT         0x00000400      // TAPI v2.0
#endif

#define PHONEBUTTONFUNCTION_UNKNOWN             0x00000000
#define PHONEBUTTONFUNCTION_CONFERENCE          0x00000001
#define PHONEBUTTONFUNCTION_TRANSFER            0x00000002
#define PHONEBUTTONFUNCTION_DROP                0x00000003
#define PHONEBUTTONFUNCTION_HOLD                0x00000004
#define PHONEBUTTONFUNCTION_RECALL              0x00000005
#define PHONEBUTTONFUNCTION_DISCONNECT          0x00000006
#define PHONEBUTTONFUNCTION_CONNECT             0x00000007
#define PHONEBUTTONFUNCTION_MSGWAITON           0x00000008
#define PHONEBUTTONFUNCTION_MSGWAITOFF          0x00000009
#define PHONEBUTTONFUNCTION_SELECTRING          0x0000000A
#define PHONEBUTTONFUNCTION_ABBREVDIAL          0x0000000B
#define PHONEBUTTONFUNCTION_FORWARD             0x0000000C
#define PHONEBUTTONFUNCTION_PICKUP              0x0000000D
#define PHONEBUTTONFUNCTION_RINGAGAIN           0x0000000E
#define PHONEBUTTONFUNCTION_PARK                0x0000000F
#define PHONEBUTTONFUNCTION_REJECT              0x00000010
#define PHONEBUTTONFUNCTION_REDIRECT            0x00000011
#define PHONEBUTTONFUNCTION_MUTE                0x00000012
#define PHONEBUTTONFUNCTION_VOLUMEUP            0x00000013
#define PHONEBUTTONFUNCTION_VOLUMEDOWN          0x00000014
#define PHONEBUTTONFUNCTION_SPEAKERON           0x00000015
#define PHONEBUTTONFUNCTION_SPEAKEROFF          0x00000016
#define PHONEBUTTONFUNCTION_FLASH               0x00000017
#define PHONEBUTTONFUNCTION_DATAON              0x00000018
#define PHONEBUTTONFUNCTION_DATAOFF             0x00000019
#define PHONEBUTTONFUNCTION_DONOTDISTURB        0x0000001A
#define PHONEBUTTONFUNCTION_INTERCOM            0x0000001B
#define PHONEBUTTONFUNCTION_BRIDGEDAPP          0x0000001C
#define PHONEBUTTONFUNCTION_BUSY                0x0000001D
#define PHONEBUTTONFUNCTION_CALLAPP             0x0000001E
#define PHONEBUTTONFUNCTION_DATETIME            0x0000001F
#define PHONEBUTTONFUNCTION_DIRECTORY           0x00000020
#define PHONEBUTTONFUNCTION_COVER               0x00000021
#define PHONEBUTTONFUNCTION_CALLID              0x00000022
#define PHONEBUTTONFUNCTION_LASTNUM             0x00000023
#define PHONEBUTTONFUNCTION_NIGHTSRV            0x00000024
#define PHONEBUTTONFUNCTION_SENDCALLS           0x00000025
#define PHONEBUTTONFUNCTION_MSGINDICATOR        0x00000026
#define PHONEBUTTONFUNCTION_REPDIAL             0x00000027
#define PHONEBUTTONFUNCTION_SETREPDIAL          0x00000028
#define PHONEBUTTONFUNCTION_SYSTEMSPEED         0x00000029
#define PHONEBUTTONFUNCTION_STATIONSPEED        0x0000002A
#define PHONEBUTTONFUNCTION_CAMPON              0x0000002B
#define PHONEBUTTONFUNCTION_SAVEREPEAT          0x0000002C
#define PHONEBUTTONFUNCTION_QUEUECALL           0x0000002D
#define PHONEBUTTONFUNCTION_NONE                0x0000002E

#define PHONEBUTTONMODE_DUMMY                   0x00000001
#define PHONEBUTTONMODE_CALL                    0x00000002
#define PHONEBUTTONMODE_FEATURE                 0x00000004
#define PHONEBUTTONMODE_KEYPAD                  0x00000008
#define PHONEBUTTONMODE_LOCAL                   0x00000010
#define PHONEBUTTONMODE_DISPLAY                 0x00000020

#define PHONEBUTTONSTATE_UP                     0x00000001
#define PHONEBUTTONSTATE_DOWN                   0x00000002
#define PHONEBUTTONSTATE_UNKNOWN                0x00000004      // TAPI v1.4
#define PHONEBUTTONSTATE_UNAVAIL                0x00000008      // TAPI v1.4

#define PHONEERR_ALLOCATED                      0x90000001
#define PHONEERR_BADDEVICEID                    0x90000002
#define PHONEERR_INCOMPATIBLEAPIVERSION         0x90000003
#define PHONEERR_INCOMPATIBLEEXTVERSION         0x90000004
#define PHONEERR_INIFILECORRUPT                 0x90000005
#define PHONEERR_INUSE                          0x90000006
#define PHONEERR_INVALAPPHANDLE                 0x90000007
#define PHONEERR_INVALAPPNAME                   0x90000008
#define PHONEERR_INVALBUTTONLAMPID              0x90000009
#define PHONEERR_INVALBUTTONMODE                0x9000000A
#define PHONEERR_INVALBUTTONSTATE               0x9000000B
#define PHONEERR_INVALDATAID                    0x9000000C
#define PHONEERR_INVALDEVICECLASS               0x9000000D
#define PHONEERR_INVALEXTVERSION                0x9000000E
#define PHONEERR_INVALHOOKSWITCHDEV             0x9000000F
#define PHONEERR_INVALHOOKSWITCHMODE            0x90000010
#define PHONEERR_INVALLAMPMODE                  0x90000011
#define PHONEERR_INVALPARAM                     0x90000012
#define PHONEERR_INVALPHONEHANDLE               0x90000013
#define PHONEERR_INVALPHONESTATE                0x90000014
#define PHONEERR_INVALPOINTER                   0x90000015
#define PHONEERR_INVALPRIVILEGE                 0x90000016
#define PHONEERR_INVALRINGMODE                  0x90000017
#define PHONEERR_NODEVICE                       0x90000018
#define PHONEERR_NODRIVER                       0x90000019
#define PHONEERR_NOMEM                          0x9000001A
#define PHONEERR_NOTOWNER                       0x9000001B
#define PHONEERR_OPERATIONFAILED                0x9000001C
#define PHONEERR_OPERATIONUNAVAIL               0x9000001D
#define PHONEERR_RESOURCEUNAVAIL                0x9000001F
#define PHONEERR_REQUESTOVERRUN                 0x90000020
#define PHONEERR_STRUCTURETOOSMALL              0x90000021
#define PHONEERR_UNINITIALIZED                  0x90000022
#define PHONEERR_REINIT                         0x90000023

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define PHONEFEATURE_GETBUTTONINFO              0x00000001      // TAPI v2.0
#define PHONEFEATURE_GETDATA                    0x00000002      // TAPI v2.0
#define PHONEFEATURE_GETDISPLAY                 0x00000004      // TAPI v2.0
#define PHONEFEATURE_GETGAINHANDSET             0x00000008      // TAPI v2.0
#define PHONEFEATURE_GETGAINSPEAKER             0x00000010      // TAPI v2.0
#define PHONEFEATURE_GETGAINHEADSET             0x00000020      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHHANDSET       0x00000040      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHSPEAKER       0x00000080      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHHEADSET       0x00000100      // TAPI v2.0
#define PHONEFEATURE_GETLAMP                    0x00000200      // TAPI v2.0
#define PHONEFEATURE_GETRING                    0x00000400      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMEHANDSET           0x00000800      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMESPEAKER           0x00001000      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMEHEADSET           0x00002000      // TAPI v2.0
#define PHONEFEATURE_SETBUTTONINFO              0x00004000      // TAPI v2.0
#define PHONEFEATURE_SETDATA                    0x00008000      // TAPI v2.0
#define PHONEFEATURE_SETDISPLAY                 0x00010000      // TAPI v2.0
#define PHONEFEATURE_SETGAINHANDSET             0x00020000      // TAPI v2.0
#define PHONEFEATURE_SETGAINSPEAKER             0x00040000      // TAPI v2.0
#define PHONEFEATURE_SETGAINHEADSET             0x00080000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHHANDSET       0x00100000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHSPEAKER       0x00200000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHHEADSET       0x00400000      // TAPI v2.0
#define PHONEFEATURE_SETLAMP                    0x00800000      // TAPI v2.0
#define PHONEFEATURE_SETRING                    0x01000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMEHANDSET           0x02000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMESPEAKER           0x04000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMEHEADSET           0x08000000      // TAPI v2.0
#endif

#define PHONEHOOKSWITCHDEV_HANDSET              0x00000001
#define PHONEHOOKSWITCHDEV_SPEAKER              0x00000002
#define PHONEHOOKSWITCHDEV_HEADSET              0x00000004

#define PHONEHOOKSWITCHMODE_ONHOOK              0x00000001
#define PHONEHOOKSWITCHMODE_MIC                 0x00000002
#define PHONEHOOKSWITCHMODE_SPEAKER             0x00000004
#define PHONEHOOKSWITCHMODE_MICSPEAKER          0x00000008
#define PHONEHOOKSWITCHMODE_UNKNOWN             0x00000010

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define PHONEINITIALIZEEXOPTION_USEHIDDENWINDOW     0x00000001  // TAPI v2.0
#define PHONEINITIALIZEEXOPTION_USEEVENT            0x00000002  // TAPI v2.0
#define PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT   0x00000004  // TAPI v2.0
#endif

#define PHONELAMPMODE_DUMMY                     0x00000001
#define PHONELAMPMODE_OFF                       0x00000002
#define PHONELAMPMODE_STEADY                    0x00000004
#define PHONELAMPMODE_WINK                      0x00000008
#define PHONELAMPMODE_FLASH                     0x00000010
#define PHONELAMPMODE_FLUTTER                   0x00000020
#define PHONELAMPMODE_BROKENFLUTTER             0x00000040
#define PHONELAMPMODE_UNKNOWN                   0x00000080

#define PHONEPRIVILEGE_MONITOR                  0x00000001
#define PHONEPRIVILEGE_OWNER                    0x00000002

#define PHONESTATE_OTHER                        0x00000001
#define PHONESTATE_CONNECTED                    0x00000002
#define PHONESTATE_DISCONNECTED                 0x00000004
#define PHONESTATE_OWNER                        0x00000008
#define PHONESTATE_MONITORS                     0x00000010
#define PHONESTATE_DISPLAY                      0x00000020
#define PHONESTATE_LAMP                         0x00000040
#define PHONESTATE_RINGMODE                     0x00000080
#define PHONESTATE_RINGVOLUME                   0x00000100
#define PHONESTATE_HANDSETHOOKSWITCH            0x00000200
#define PHONESTATE_HANDSETVOLUME                0x00000400
#define PHONESTATE_HANDSETGAIN                  0x00000800
#define PHONESTATE_SPEAKERHOOKSWITCH            0x00001000
#define PHONESTATE_SPEAKERVOLUME                0x00002000
#define PHONESTATE_SPEAKERGAIN                  0x00004000
#define PHONESTATE_HEADSETHOOKSWITCH            0x00008000
#define PHONESTATE_HEADSETVOLUME                0x00010000
#define PHONESTATE_HEADSETGAIN                  0x00020000
#define PHONESTATE_SUSPEND                      0x00040000
#define PHONESTATE_RESUME                       0x00080000
#define PHONESTATE_DEVSPECIFIC                  0x00100000
#define PHONESTATE_REINIT                       0x00200000
#define PHONESTATE_CAPSCHANGE                   0x00400000      // TAPI v1.4
#define PHONESTATE_REMOVED                      0x00800000      // TAPI v1.4

#define PHONESTATUSFLAGS_CONNECTED              0x00000001
#define PHONESTATUSFLAGS_SUSPENDED              0x00000002

#define STRINGFORMAT_ASCII                      0x00000001
#define STRINGFORMAT_DBCS                       0x00000002
#define STRINGFORMAT_UNICODE                    0x00000003
#define STRINGFORMAT_BINARY                     0x00000004

#define TAPI_REPLY                              WM_USER + 99

#define TAPIERR_CONNECTED                       0L
#define TAPIERR_DROPPED                         -1L
#define TAPIERR_NOREQUESTRECIPIENT              -2L
#define TAPIERR_REQUESTQUEUEFULL                -3L
#define TAPIERR_INVALDESTADDRESS                -4L
#define TAPIERR_INVALWINDOWHANDLE               -5L
#define TAPIERR_INVALDEVICECLASS                -6L
#define TAPIERR_INVALDEVICEID                   -7L
#define TAPIERR_DEVICECLASSUNAVAIL              -8L
#define TAPIERR_DEVICEIDUNAVAIL                 -9L
#define TAPIERR_DEVICEINUSE                     -10L
#define TAPIERR_DESTBUSY                        -11L
#define TAPIERR_DESTNOANSWER                    -12L
#define TAPIERR_DESTUNAVAIL                     -13L
#define TAPIERR_UNKNOWNWINHANDLE                -14L
#define TAPIERR_UNKNOWNREQUESTID                -15L
#define TAPIERR_REQUESTFAILED                   -16L
#define TAPIERR_REQUESTCANCELLED                -17L
#define TAPIERR_INVALPOINTER                    -18L

#define TAPIMAXDESTADDRESSSIZE                  80L
#define TAPIMAXAPPNAMESIZE                      40L
#define TAPIMAXCALLEDPARTYSIZE                  40L
#define TAPIMAXCOMMENTSIZE                      80L
#define TAPIMAXDEVICECLASSSIZE                  40L
#define TAPIMAXDEVICEIDSIZE                     40L



typedef struct lineaddresscaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwLineDeviceID;
    DWORD       dwAddressSize;
    DWORD       dwAddressOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;
    DWORD       dwAddressSharing;
    DWORD       dwAddressStates;
    DWORD       dwCallInfoStates;
    DWORD       dwCallerIDFlags;
    DWORD       dwCalledIDFlags;
    DWORD       dwConnectedIDFlags;
    DWORD       dwRedirectionIDFlags;
    DWORD       dwRedirectingIDFlags;
    DWORD       dwCallStates;
    DWORD       dwDialToneModes;
    DWORD       dwBusyModes;
    DWORD       dwSpecialInfo;
    DWORD       dwDisconnectModes;
    DWORD       dwMaxNumActiveCalls;
    DWORD       dwMaxNumOnHoldCalls;
    DWORD       dwMaxNumOnHoldPendingCalls;
    DWORD       dwMaxNumConference;
    DWORD       dwMaxNumTransConf;
    DWORD       dwAddrCapFlags;
    DWORD       dwCallFeatures;
    DWORD       dwRemoveFromConfCaps;
    DWORD       dwRemoveFromConfState;
    DWORD       dwTransferModes;
    DWORD       dwParkModes;
    DWORD       dwForwardModes;
    DWORD       dwMaxForwardEntries;
    DWORD       dwMaxSpecificEntries;
    DWORD       dwMinFwdNumRings;
    DWORD       dwMaxFwdNumRings;
    DWORD       dwMaxCallCompletions;
    DWORD       dwCallCompletionConds;
    DWORD       dwCallCompletionModes;
    DWORD       dwNumCompletionMessages;
    DWORD       dwCompletionMsgTextEntrySize;
    DWORD       dwCompletionMsgTextSize;
    DWORD       dwCompletionMsgTextOffset;

    DWORD       dwAddressFeatures;                              // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPredictiveAutoTransferStates;                 // TAPI v2.0
    DWORD       dwNumCallTreatments;                            // TAPI v2.0
    DWORD       dwCallTreatmentListSize;                        // TAPI v2.0
    DWORD       dwCallTreatmentListOffset;                      // TAPI v2.0
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    DWORD       dwMaxCallDataSize;                              // TAPI v2.0
    DWORD       dwCallFeatures2;                                // TAPI v2.0
    DWORD       dwMaxNoAnswerTimeout;                           // TAPI v2.0
    DWORD       dwConnectedModes;                               // TAPI v2.0
    DWORD       dwOfferingModes;                                // TAPI v2.0
    DWORD       dwAvailableMediaModes;                          // TAPI v2.0
#endif

} LINEADDRESSCAPS, FAR *LPLINEADDRESSCAPS;

typedef struct lineaddressstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumInUse;
    DWORD       dwNumActiveCalls;
    DWORD       dwNumOnHoldCalls;
    DWORD       dwNumOnHoldPendCalls;
    DWORD       dwAddressFeatures;
    DWORD       dwNumRingsNoAnswer;
    DWORD       dwForwardNumEntries;
    DWORD       dwForwardSize;
    DWORD       dwForwardOffset;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

} LINEADDRESSSTATUS, FAR *LPLINEADDRESSSTATUS;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineagentactivityentry_tag
{
    DWORD       dwID;                                           // TAPI v2.0
    DWORD       dwNameSize;                                     // TAPI v2.0
    DWORD       dwNameOffset;                                   // TAPI v2.0

} LINEAGENTACTIVITYENTRY, *LPLINEAGENTACTIVITYENTRY;

typedef struct lineagentactivitylist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwListSize;                                     // TAPI v2.0
    DWORD       dwListOffset;                                   // TAPI v2.0

} LINEAGENTACTIVITYLIST, *LPLINEAGENTACTIVITYLIST;

typedef struct lineagentcaps_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwAgentHandlerInfoSize;                         // TAPI v2.0
    DWORD       dwAgentHandlerInfoOffset;                       // TAPI v2.0
    DWORD       dwCapsVersion;                                  // TAPI v2.0
    DWORD       dwFeatures;                                     // TAPI v2.0
    DWORD       dwStates;                                       // TAPI v2.0
    DWORD       dwNextStates;                                   // TAPI v2.0
    DWORD       dwMaxNumGroupEntries;                           // TAPI v2.0
    DWORD       dwAgentStatusMessages;                          // TAPI v2.0
    DWORD       dwNumAgentExtensionIDs;                         // TAPI v2.0
    DWORD       dwAgentExtensionIDListSize;                     // TAPI v2.0
    DWORD       dwAgentExtensionIDListOffset;                   // TAPI v2.0

} LINEAGENTCAPS, *LPLINEAGENTCAPS;

typedef struct lineagentgroupentry_tag
{
    struct
    {
        DWORD   dwGroupID1;                                     // TAPI v2.0
        DWORD   dwGroupID2;                                     // TAPI v2.0
        DWORD   dwGroupID3;                                     // TAPI v2.0
        DWORD   dwGroupID4;                                     // TAPI v2.0

    } GroupID;

    DWORD       dwNameSize;                                     // TAPI v2.0
    DWORD       dwNameOffset;                                   // TAPI v2.0

} LINEAGENTGROUPENTRY, *LPLINEAGENTGROUPENTRY;

typedef struct lineagentgrouplist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwListSize;                                     // TAPI v2.0
    DWORD       dwListOffset;                                   // TAPI v2.0

} LINEAGENTGROUPLIST, *LPLINEAGENTGROUPLIST;

typedef struct lineagentstatus_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwGroupListSize;                                // TAPI v2.0
    DWORD       dwGroupListOffset;                              // TAPI v2.0
    DWORD       dwState;                                        // TAPI v2.0
    DWORD       dwNextState;                                    // TAPI v2.0
    DWORD       dwActivityID;                                   // TAPI v2.0
    DWORD       dwActivitySize;                                 // TAPI v2.0
    DWORD       dwActivityOffset;                               // TAPI v2.0
    DWORD       dwAgentFeatures;                                // TAPI v2.0
    DWORD       dwValidStates;                                  // TAPI v2.0
    DWORD       dwValidNextStates;                              // TAPI v2.0

} LINEAGENTSTATUS, *LPLINEAGENTSTATUS;

typedef struct lineappinfo_tag
{
    DWORD       dwMachineNameSize;                              // TAPI v2.0
    DWORD       dwMachineNameOffset;                            // TAPI v2.0
    DWORD       dwUserNameSize;                                 // TAPI v2.0
    DWORD       dwUserNameOffset;                               // TAPI v2.0
    DWORD       dwModuleFilenameSize;                           // TAPI v2.0
    DWORD       dwModuleFilenameOffset;                         // TAPI v2.0
    DWORD       dwFriendlyNameSize;                             // TAPI v2.0
    DWORD       dwFriendlyNameOffset;                           // TAPI v2.0
    DWORD       dwMediaModes;                                   // TAPI v2.0
    DWORD       dwAddressID;                                    // TAPI v2.0

} LINEAPPINFO, *LPLINEAPPINFO;
#endif


typedef struct linedialparams_tag
{
    DWORD       dwDialPause;
    DWORD       dwDialSpeed;
    DWORD       dwDigitDuration;
    DWORD       dwWaitForDialtone;

} LINEDIALPARAMS, FAR *LPLINEDIALPARAMS;

typedef struct linecallinfo_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    HLINE       hLine;
    DWORD       dwLineDeviceID;
    DWORD       dwAddressID;
    DWORD       dwBearerMode;
    DWORD       dwRate;
    DWORD       dwMediaMode;
    DWORD       dwAppSpecific;
    DWORD       dwCallID;
    DWORD       dwRelatedCallID;
    DWORD       dwCallParamFlags;
    DWORD       dwCallStates;
    DWORD       dwMonitorDigitModes;
    DWORD       dwMonitorMediaModes;
    LINEDIALPARAMS  DialParams;
    DWORD       dwOrigin;
    DWORD       dwReason;
    DWORD       dwCompletionID;
    DWORD       dwNumOwners;
    DWORD       dwNumMonitors;
    DWORD       dwCountryCode;
    DWORD       dwTrunk;
    DWORD       dwCallerIDFlags;
    DWORD       dwCallerIDSize;
    DWORD       dwCallerIDOffset;
    DWORD       dwCallerIDNameSize;
    DWORD       dwCallerIDNameOffset;
    DWORD       dwCalledIDFlags;
    DWORD       dwCalledIDSize;
    DWORD       dwCalledIDOffset;
    DWORD       dwCalledIDNameSize;
    DWORD       dwCalledIDNameOffset;
    DWORD       dwConnectedIDFlags;
    DWORD       dwConnectedIDSize;
    DWORD       dwConnectedIDOffset;
    DWORD       dwConnectedIDNameSize;
    DWORD       dwConnectedIDNameOffset;
    DWORD       dwRedirectionIDFlags;
    DWORD       dwRedirectionIDSize;
    DWORD       dwRedirectionIDOffset;
    DWORD       dwRedirectionIDNameSize;
    DWORD       dwRedirectionIDNameOffset;
    DWORD       dwRedirectingIDFlags;
    DWORD       dwRedirectingIDSize;
    DWORD       dwRedirectingIDOffset;
    DWORD       dwRedirectingIDNameSize;
    DWORD       dwRedirectingIDNameOffset;
    DWORD       dwAppNameSize;
    DWORD       dwAppNameOffset;
    DWORD       dwDisplayableAddressSize;
    DWORD       dwDisplayableAddressOffset;
    DWORD       dwCalledPartySize;
    DWORD       dwCalledPartyOffset;
    DWORD       dwCommentSize;
    DWORD       dwCommentOffset;
    DWORD       dwDisplaySize;
    DWORD       dwDisplayOffset;
    DWORD       dwUserUserInfoSize;
    DWORD       dwUserUserInfoOffset;
    DWORD       dwHighLevelCompSize;
    DWORD       dwHighLevelCompOffset;
    DWORD       dwLowLevelCompSize;
    DWORD       dwLowLevelCompOffset;
    DWORD       dwChargingInfoSize;
    DWORD       dwChargingInfoOffset;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwCallTreatment;                                // TAPI v2.0
    DWORD       dwCallDataSize;                                 // TAPI v2.0
    DWORD       dwCallDataOffset;                               // TAPI v2.0
    DWORD       dwSendingFlowspecSize;                          // TAPI v2.0
    DWORD       dwSendingFlowspecOffset;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecSize;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecOffset;                      // TAPI v2.0
#endif

} LINECALLINFO, FAR *LPLINECALLINFO;

typedef struct linecalllist_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwCallsNumEntries;
    DWORD       dwCallsSize;
    DWORD       dwCallsOffset;

} LINECALLLIST, FAR *LPLINECALLLIST;

typedef struct linecallparams_tag               // Defaults:
{
    DWORD       dwTotalSize;                    // ---------
    DWORD       dwBearerMode;                   // voice
    DWORD       dwMinRate;                      // (3.1kHz)
    DWORD       dwMaxRate;                      // (3.1kHz)
    DWORD       dwMediaMode;                    // interactiveVoice
    DWORD       dwCallParamFlags;               // 0
    DWORD       dwAddressMode;                  // addressID
    DWORD       dwAddressID;                    // (any available)
    LINEDIALPARAMS  DialParams;                 // (0, 0, 0, 0)
    DWORD       dwOrigAddressSize;              // 0
    DWORD       dwOrigAddressOffset;
    DWORD       dwDisplayableAddressSize;
    DWORD       dwDisplayableAddressOffset;
    DWORD       dwCalledPartySize;              // 0
    DWORD       dwCalledPartyOffset;
    DWORD       dwCommentSize;                  // 0
    DWORD       dwCommentOffset;
    DWORD       dwUserUserInfoSize;             // 0
    DWORD       dwUserUserInfoOffset;
    DWORD       dwHighLevelCompSize;            // 0
    DWORD       dwHighLevelCompOffset;
    DWORD       dwLowLevelCompSize;             // 0
    DWORD       dwLowLevelCompOffset;
    DWORD       dwDevSpecificSize;              // 0
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPredictiveAutoTransferStates;                 // TAPI v2.0
    DWORD       dwTargetAddressSize;                            // TAPI v2.0
    DWORD       dwTargetAddressOffset;                          // TAPI v2.0
    DWORD       dwSendingFlowspecSize;                          // TAPI v2.0
    DWORD       dwSendingFlowspecOffset;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecSize;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecOffset;                      // TAPI v2.0
    DWORD       dwDeviceClassSize;                              // TAPI v2.0
    DWORD       dwDeviceClassOffset;                            // TAPI v2.0
    DWORD       dwDeviceConfigSize;                             // TAPI v2.0
    DWORD       dwDeviceConfigOffset;                           // TAPI v2.0
    DWORD       dwCallDataSize;                                 // TAPI v2.0
    DWORD       dwCallDataOffset;                               // TAPI v2.0
    DWORD       dwNoAnswerTimeout;                              // TAPI v2.0
    DWORD       dwCallingPartyIDSize;                           // TAPI v2.0
    DWORD       dwCallingPartyIDOffset;                         // TAPI v2.0
#endif

} LINECALLPARAMS, FAR *LPLINECALLPARAMS;

typedef struct linecallstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwCallState;
    DWORD       dwCallStateMode;
    DWORD       dwCallPrivilege;
    DWORD       dwCallFeatures;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwCallFeatures2;                                // TAPI v2.0
#if WIN32
    SYSTEMTIME  tStateEntryTime;                                // TAPI v2.0
#else
    WORD        tStateEntryTime[8];                             // TAPI v2.0
#endif
#endif

} LINECALLSTATUS, FAR *LPLINECALLSTATUS;


#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linecalltreatmententry_tag
{
    DWORD       dwCallTreatmentID;                              // TAPI v2.0
    DWORD       dwCallTreatmentNameSize;                        // TAPI v2.0
    DWORD       dwCallTreatmentNameOffset;                      // TAPI v2.0

} LINECALLTREATMENTENTRY, FAR *LPLINECALLTREATMENTENTRY;
#endif


typedef struct linecardentry_tag
{
    DWORD       dwPermanentCardID;
    DWORD       dwCardNameSize;
    DWORD       dwCardNameOffset;
    DWORD       dwCardNumberDigits;                             // TAPI v1.4
    DWORD       dwSameAreaRuleSize;                             // TAPI v1.4
    DWORD       dwSameAreaRuleOffset;                           // TAPI v1.4
    DWORD       dwLongDistanceRuleSize;                         // TAPI v1.4
    DWORD       dwLongDistanceRuleOffset;                       // TAPI v1.4
    DWORD       dwInternationalRuleSize;                        // TAPI v1.4
    DWORD       dwInternationalRuleOffset;                      // TAPI v1.4
    DWORD       dwOptions;                                      // TAPI v1.4

} LINECARDENTRY, FAR *LPLINECARDENTRY;

typedef struct linecountryentry_tag
{
    DWORD       dwCountryID;                                    // TAPI v1.4
    DWORD       dwCountryCode;                                  // TAPI v1.4
    DWORD       dwNextCountryID;                                // TAPI v1.4
    DWORD       dwCountryNameSize;                              // TAPI v1.4
    DWORD       dwCountryNameOffset;                            // TAPI v1.4
    DWORD       dwSameAreaRuleSize;                             // TAPI v1.4
    DWORD       dwSameAreaRuleOffset;                           // TAPI v1.4
    DWORD       dwLongDistanceRuleSize;                         // TAPI v1.4
    DWORD       dwLongDistanceRuleOffset;                       // TAPI v1.4
    DWORD       dwInternationalRuleSize;                        // TAPI v1.4
    DWORD       dwInternationalRuleOffset;                      // TAPI v1.4

} LINECOUNTRYENTRY, FAR *LPLINECOUNTRYENTRY;

typedef struct linecountrylist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v1.4
    DWORD       dwNeededSize;                                   // TAPI v1.4
    DWORD       dwUsedSize;                                     // TAPI v1.4
    DWORD       dwNumCountries;                                 // TAPI v1.4
    DWORD       dwCountryListSize;                              // TAPI v1.4
    DWORD       dwCountryListOffset;                            // TAPI v1.4

} LINECOUNTRYLIST, FAR *LPLINECOUNTRYLIST;

typedef struct linedevcaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwProviderInfoSize;
    DWORD       dwProviderInfoOffset;
    DWORD       dwSwitchInfoSize;
    DWORD       dwSwitchInfoOffset;
    DWORD       dwPermanentLineID;
    DWORD       dwLineNameSize;
    DWORD       dwLineNameOffset;
    DWORD       dwStringFormat;
    DWORD       dwAddressModes;
    DWORD       dwNumAddresses;
    DWORD       dwBearerModes;
    DWORD       dwMaxRate;
    DWORD       dwMediaModes;
    DWORD       dwGenerateToneModes;
    DWORD       dwGenerateToneMaxNumFreq;
    DWORD       dwGenerateDigitModes;
    DWORD       dwMonitorToneMaxNumFreq;
    DWORD       dwMonitorToneMaxNumEntries;
    DWORD       dwMonitorDigitModes;
    DWORD       dwGatherDigitsMinTimeout;
    DWORD       dwGatherDigitsMaxTimeout;
    DWORD       dwMedCtlDigitMaxListSize;
    DWORD       dwMedCtlMediaMaxListSize;
    DWORD       dwMedCtlToneMaxListSize;
    DWORD       dwMedCtlCallStateMaxListSize;
    DWORD       dwDevCapFlags;
    DWORD       dwMaxNumActiveCalls;
    DWORD       dwAnswerMode;
    DWORD       dwRingModes;
    DWORD       dwLineStates;
    DWORD       dwUUIAcceptSize;
    DWORD       dwUUIAnswerSize;
    DWORD       dwUUIMakeCallSize;
    DWORD       dwUUIDropSize;
    DWORD       dwUUISendUserUserInfoSize;
    DWORD       dwUUICallInfoSize;
    LINEDIALPARAMS  MinDialParams;
    LINEDIALPARAMS  MaxDialParams;
    LINEDIALPARAMS  DefaultDialParams;
    DWORD       dwNumTerminals;
    DWORD       dwTerminalCapsSize;
    DWORD       dwTerminalCapsOffset;
    DWORD       dwTerminalTextEntrySize;
    DWORD       dwTerminalTextSize;
    DWORD       dwTerminalTextOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwLineFeatures;                                 // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwSettableDevStatus;                            // TAPI v2.0
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
#endif

} LINEDEVCAPS, FAR *LPLINEDEVCAPS;
    
typedef struct linedevstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumOpens;
    DWORD       dwOpenMediaModes;
    DWORD       dwNumActiveCalls;
    DWORD       dwNumOnHoldCalls;
    DWORD       dwNumOnHoldPendCalls;
    DWORD       dwLineFeatures;
    DWORD       dwNumCallCompletions;
    DWORD       dwRingMode;
    DWORD       dwSignalLevel;
    DWORD       dwBatteryLevel;
    DWORD       dwRoamMode;
    DWORD       dwDevStatusFlags;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwAvailableMediaModes;                          // TAPI v2.0
    DWORD       dwAppInfoSize;                                  // TAPI v2.0
    DWORD       dwAppInfoOffset;                                // TAPI v2.0
#endif

} LINEDEVSTATUS, FAR *LPLINEDEVSTATUS;

typedef struct lineextensionid_tag
{
    DWORD       dwExtensionID0;
    DWORD       dwExtensionID1;
    DWORD       dwExtensionID2;
    DWORD       dwExtensionID3;

} LINEEXTENSIONID, FAR *LPLINEEXTENSIONID;

typedef struct lineforward_tag
{
    DWORD       dwForwardMode;
    DWORD       dwCallerAddressSize;
    DWORD       dwCallerAddressOffset;
    DWORD       dwDestCountryCode;
    DWORD       dwDestAddressSize;
    DWORD       dwDestAddressOffset;

} LINEFORWARD, FAR *LPLINEFORWARD;

typedef struct lineforwardlist_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNumEntries;
    LINEFORWARD ForwardList[1];

} LINEFORWARDLIST, FAR *LPLINEFORWARDLIST;

typedef struct linegeneratetone_tag
{
    DWORD       dwFrequency;
    DWORD       dwCadenceOn;
    DWORD       dwCadenceOff;
    DWORD       dwVolume;

} LINEGENERATETONE, FAR *LPLINEGENERATETONE;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineinitializeexparams_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwOptions;                                      // TAPI v2.0

    union
    {
        HANDLE  hEvent;                                         // TAPI v2.0
        HANDLE  hCompletionPort;                                // TAPI v2.0

    } Handles;

    DWORD       dwCompletionKey;                                // TAPI v2.0

} LINEINITIALIZEEXPARAMS, FAR *LPLINEINITIALIZEEXPARAMS;
#endif

typedef struct linelocationentry_tag
{
    DWORD       dwPermanentLocationID;
    DWORD       dwLocationNameSize;
    DWORD       dwLocationNameOffset;
    DWORD       dwCountryCode;
    DWORD       dwCityCodeSize;
    DWORD       dwCityCodeOffset;
    DWORD       dwPreferredCardID;

    DWORD       dwLocalAccessCodeSize;                          // TAPI v1.4
    DWORD       dwLocalAccessCodeOffset;                        // TAPI v1.4
    DWORD       dwLongDistanceAccessCodeSize;                   // TAPI v1.4
    DWORD       dwLongDistanceAccessCodeOffset;                 // TAPI v1.4
    DWORD       dwTollPrefixListSize;                           // TAPI v1.4
    DWORD       dwTollPrefixListOffset;                         // TAPI v1.4
    DWORD       dwCountryID;                                    // TAPI v1.4
    DWORD       dwOptions;                                      // TAPI v1.4
    DWORD       dwCancelCallWaitingSize;                        // TAPI v1.4
    DWORD       dwCancelCallWaitingOffset;                      // TAPI v1.4

} LINELOCATIONENTRY, FAR *LPLINELOCATIONENTRY;

typedef struct linemediacontrolcallstate_tag
{
    DWORD       dwCallStates;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLCALLSTATE, FAR *LPLINEMEDIACONTROLCALLSTATE;

typedef struct linemediacontroldigit_tag
{
    DWORD       dwDigit;
    DWORD       dwDigitModes;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLDIGIT, FAR *LPLINEMEDIACONTROLDIGIT;

typedef struct linemediacontrolmedia_tag
{
    DWORD       dwMediaModes;
    DWORD       dwDuration;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLMEDIA, FAR *LPLINEMEDIACONTROLMEDIA;

typedef struct linemediacontroltone_tag
{
    DWORD       dwAppSpecific;
    DWORD       dwDuration;
    DWORD       dwFrequency1;
    DWORD       dwFrequency2;
    DWORD       dwFrequency3;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLTONE, FAR *LPLINEMEDIACONTROLTONE;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linemessage_tag
{
    DWORD       hDevice;                                        // TAPI v2.0
    DWORD       dwMessageID;                                    // TAPI v2.0
    DWORD       dwCallbackInstance;                             // TAPI v2.0
    DWORD       dwParam1;                                       // TAPI v2.0
    DWORD       dwParam2;                                       // TAPI v2.0
    DWORD       dwParam3;                                       // TAPI v2.0

} LINEMESSAGE, FAR *LPLINEMESSAGE;
#endif

typedef struct linemonitortone_tag
{
    DWORD       dwAppSpecific;
    DWORD       dwDuration;
    DWORD       dwFrequency1;
    DWORD       dwFrequency2;
    DWORD       dwFrequency3;

} LINEMONITORTONE, FAR *LPLINEMONITORTONE;

typedef struct lineproviderentry_tag
{
    DWORD       dwPermanentProviderID;                          // TAPI v1.4
    DWORD       dwProviderFilenameSize;                         // TAPI v1.4
    DWORD       dwProviderFilenameOffset;                       // TAPI v1.4

} LINEPROVIDERENTRY, FAR *LPLINEPROVIDERENTRY;

typedef struct lineproviderlist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v1.4
    DWORD       dwNeededSize;                                   // TAPI v1.4
    DWORD       dwUsedSize;                                     // TAPI v1.4
    DWORD       dwNumProviders;                                 // TAPI v1.4
    DWORD       dwProviderListSize;                             // TAPI v1.4
    DWORD       dwProviderListOffset;                           // TAPI v1.4

} LINEPROVIDERLIST, FAR *LPLINEPROVIDERLIST;


#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineproxyrequest_tag
{
    DWORD       dwSize;                                         // TAPI v2.0
    DWORD       dwClientMachineNameSize;                        // TAPI v2.0
    DWORD       dwClientMachineNameOffset;                      // TAPI v2.0
    DWORD       dwClientUserNameSize;                           // TAPI v2.0
    DWORD       dwClientUserNameOffset;                         // TAPI v2.0
    DWORD       dwClientAppAPIVersion;                          // TAPI v2.0
    DWORD       dwRequestType;                                  // TAPI v2.0

    union
    {
    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTGROUPLIST      GroupList;                      // TAPI v2.0

    } SetAgentGroup;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwAgentState;                   // TAPI v2.0
        DWORD                   dwNextAgentState;               // TAPI v2.0

    } SetAgentState;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwActivityID;                   // TAPI v2.0

    } SetAgentActivity;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTCAPS           AgentCaps;                      // TAPI v2.0

    } GetAgentCaps;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTSTATUS         AgentStatus;                    // TAPI v2.0

    } GetAgentStatus;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwAgentExtensionIDIndex;        // TAPI v2.0
        DWORD                   dwSize;                         // TAPI v2.0
        BYTE                    Params[1];                      // TAPI v2.0

    } AgentSpecific;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTACTIVITYLIST   ActivityList;                   // TAPI v2.0

    } GetAgentActivityList;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTGROUPLIST      GroupList;                      // TAPI v2.0

    } GetAgentGroupList;
    }; //ProxyRequestType;

} LINEPROXYREQUEST, *LPLINEPROXYREQUEST;
#endif


typedef struct linereqmakecall_tag
{
    char        szDestAddress[TAPIMAXDESTADDRESSSIZE];
    char        szAppName[TAPIMAXAPPNAMESIZE];
    char        szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    char        szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMAKECALL, FAR *LPLINEREQMAKECALL;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linereqmakecallW_tag
{
    WCHAR       szDestAddress[TAPIMAXDESTADDRESSSIZE];
    WCHAR       szAppName[TAPIMAXAPPNAMESIZE];
    WCHAR       szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    WCHAR       szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMAKECALLW, FAR *LPLINEREQMAKECALLW;
#endif

#ifdef UNICODE
#define LINEREQMAKECALL LINEREQMAKECALLW
#endif

typedef struct linereqmediacall_tag
{
    HWND        hWnd;
    WPARAM      wRequestID;
    char        szDeviceClass[TAPIMAXDEVICECLASSSIZE];
    unsigned char   ucDeviceID[TAPIMAXDEVICEIDSIZE];
    DWORD       dwSize;
    DWORD       dwSecure;
    char        szDestAddress[TAPIMAXDESTADDRESSSIZE];
    char        szAppName[TAPIMAXAPPNAMESIZE];
    char        szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    char        szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMEDIACALL, FAR *LPLINEREQMEDIACALL;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linereqmediacallW_tag
{
    HWND        hWnd;
    WPARAM      wRequestID;
    WCHAR       szDeviceClass[TAPIMAXDEVICECLASSSIZE];
    unsigned char   ucDeviceID[TAPIMAXDEVICEIDSIZE];
    DWORD       dwSize;
    DWORD       dwSecure;
    WCHAR       szDestAddress[TAPIMAXDESTADDRESSSIZE];
    WCHAR       szAppName[TAPIMAXAPPNAMESIZE];
    WCHAR       szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    WCHAR       szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMEDIACALLW, FAR *LPLINEREQMEDIACALLW;
#endif

#ifdef UNICODE
#define LINEREQMEDIACALL LINEREQMEDIACALLW
#endif


typedef struct linetermcaps_tag
{
    DWORD       dwTermDev;
    DWORD       dwTermModes;
    DWORD       dwTermSharing;

} LINETERMCAPS, FAR *LPLINETERMCAPS;

typedef struct linetranslatecaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumLocations;
    DWORD       dwLocationListSize;
    DWORD       dwLocationListOffset;
    DWORD       dwCurrentLocationID;
    DWORD       dwNumCards;
    DWORD       dwCardListSize;
    DWORD       dwCardListOffset;
    DWORD       dwCurrentPreferredCardID;

} LINETRANSLATECAPS, FAR *LPLINETRANSLATECAPS;

typedef struct linetranslateoutput_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwDialableStringSize;
    DWORD       dwDialableStringOffset;
    DWORD       dwDisplayableStringSize;
    DWORD       dwDisplayableStringOffset;
    DWORD       dwCurrentCountry;
    DWORD       dwDestCountry;
    DWORD       dwTranslateResults;

} LINETRANSLATEOUTPUT, FAR *LPLINETRANSLATEOUTPUT;

typedef struct phonebuttoninfo_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwButtonMode;
    DWORD       dwButtonFunction;
    DWORD       dwButtonTextSize;
    DWORD       dwButtonTextOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwButtonState;                                  // TAPI v1.4

} PHONEBUTTONINFO, FAR *LPPHONEBUTTONINFO;

typedef struct phonecaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwProviderInfoSize;
    DWORD       dwProviderInfoOffset;
    DWORD       dwPhoneInfoSize;
    DWORD       dwPhoneInfoOffset;
    DWORD       dwPermanentPhoneID;
    DWORD       dwPhoneNameSize;
    DWORD       dwPhoneNameOffset;
    DWORD       dwStringFormat;
    DWORD       dwPhoneStates;
    DWORD       dwHookSwitchDevs;
    DWORD       dwHandsetHookSwitchModes;
    DWORD       dwSpeakerHookSwitchModes;
    DWORD       dwHeadsetHookSwitchModes;
    DWORD       dwVolumeFlags;
    DWORD       dwGainFlags;
    DWORD       dwDisplayNumRows;
    DWORD       dwDisplayNumColumns;
    DWORD       dwNumRingModes;
    DWORD       dwNumButtonLamps;
    DWORD       dwButtonModesSize;
    DWORD       dwButtonModesOffset;
    DWORD       dwButtonFunctionsSize;
    DWORD       dwButtonFunctionsOffset;
    DWORD       dwLampModesSize;
    DWORD       dwLampModesOffset;
    DWORD       dwNumSetData;
    DWORD       dwSetDataSize;
    DWORD       dwSetDataOffset;
    DWORD       dwNumGetData;
    DWORD       dwGetDataSize;
    DWORD       dwGetDataOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    DWORD       dwPhoneFeatures;                                // TAPI v2.0
    DWORD       dwSettableHandsetHookSwitchModes;               // TAPI v2.0
    DWORD       dwSettableSpeakerHookSwitchModes;               // TAPI v2.0
    DWORD       dwSettableHeadsetHookSwitchModes;               // TAPI v2.0
    DWORD       dwMonitoredHandsetHookSwitchModes;              // TAPI v2.0
    DWORD       dwMonitoredSpeakerHookSwitchModes;              // TAPI v2.0
    DWORD       dwMonitoredHeadsetHookSwitchModes;              // TAPI v2.0
#endif

} PHONECAPS, FAR *LPPHONECAPS;

typedef struct phoneextensionid_tag
{
    DWORD       dwExtensionID0;
    DWORD       dwExtensionID1;
    DWORD       dwExtensionID2;
    DWORD       dwExtensionID3;

} PHONEEXTENSIONID, FAR *LPPHONEEXTENSIONID;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct phoneinitializeexparams_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwOptions;                                      // TAPI v2.0

    union
    {
        HANDLE  hEvent;                                         // TAPI v2.0
        HANDLE  hCompletionPort;                                // TAPI v2.0

    } Handles;

    DWORD       dwCompletionKey;                                // TAPI v2.0

} PHONEINITIALIZEEXPARAMS, FAR *LPPHONEINITIALIZEEXPARAMS;

typedef struct phonemessage_tag
{
    DWORD       hDevice;                                        // TAPI v2.0
    DWORD       dwMessageID;                                    // TAPI v2.0
    DWORD       dwCallbackInstance;                             // TAPI v2.0
    DWORD       dwParam1;                                       // TAPI v2.0
    DWORD       dwParam2;                                       // TAPI v2.0
    DWORD       dwParam3;                                       // TAPI v2.0

} PHONEMESSAGE, FAR *LPPHONEMESSAGE;
#endif

typedef struct phonestatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwStatusFlags;
    DWORD       dwNumOwners;
    DWORD       dwNumMonitors;
    DWORD       dwRingMode;
    DWORD       dwRingVolume;
    DWORD       dwHandsetHookSwitchMode;
    DWORD       dwHandsetVolume;
    DWORD       dwHandsetGain;
    DWORD       dwSpeakerHookSwitchMode;
    DWORD       dwSpeakerVolume;
    DWORD       dwSpeakerGain;
    DWORD       dwHeadsetHookSwitchMode;
    DWORD       dwHeadsetVolume;
    DWORD       dwHeadsetGain;
    DWORD       dwDisplaySize;
    DWORD       dwDisplayOffset;
    DWORD       dwLampModesSize;
    DWORD       dwLampModesOffset;
    DWORD       dwOwnerNameSize;
    DWORD       dwOwnerNameOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPhoneFeatures;                                // TAPI v2.0
#endif

} PHONESTATUS, FAR *LPPHONESTATUS;

typedef struct varstring_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwStringFormat;
    DWORD       dwStringSize;
    DWORD       dwStringOffset;

} VARSTRING, FAR *LPVARSTRING;



LONG
WINAPI
lineAccept(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineAddProvider(                                                // TAPI v1.4
    LPCSTR              lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    );

#ifdef WIN32
LONG
WINAPI
lineAddProviderW(
    LPCTSTR            lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    );

#ifdef UNICODE
#define lineAddProvider lineAddProviderW
#endif

#define lineAddProviderA lineAddProvider
#endif


LONG
WINAPI
lineAddToConference(
    HCALL               hConfCall,
    HCALL               hConsultCall
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineAgentSpecific(                                              // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentExtensionIDIndex,
    LPVOID              lpParams,
    DWORD               dwSize
    );
#endif

LONG
WINAPI
lineAnswer(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineBlindTransfer(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineBlindTransferW(
    HCALL               hCall,
    LPCTSTR            lpszDestAddressW,
    DWORD               dwCountryCode
    );

#ifdef UNICODE
#define lineBlindTransfer lineBlineTransferW
#endif
#define lineBlindTransferA lineBlineTransfer
#endif


LONG
WINAPI
lineClose(
    HLINE               hLine
    );

LONG
WINAPI
lineCompleteCall(
    HCALL               hCall,
    LPDWORD             lpdwCompletionID,
    DWORD               dwCompletionMode,
    DWORD               dwMessageID
    );

LONG
WINAPI
lineCompleteTransfer(
    HCALL               hCall,
    HCALL               hConsultCall,
    LPHCALL             lphConfCall,
    DWORD               dwTransferMode
    );

LONG
WINAPI
lineConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCTSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define lineConfigDialog lineConfigDialogW
#endif

#define lineConfigDialogA lineConfigDialog
#endif


LONG
WINAPI
lineConfigDialogEdit(                                           // TAPI v1.4
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

#if WIN32
LONG
WINAPI
lineConfigDialogEditW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCTSTR             lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

#ifdef UNICODE
#define lineConfigDialogEdit lineConfigDialogEditW
#endif

#define lineConfigDialogEditA lineConfigDialogEdit
#endif

LONG
WINAPI
lineConfigProvider(                                             // TAPI v1.4
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

LONG
WINAPI
lineDeallocateCall(
    HCALL               hCall
    );

LONG
WINAPI
lineDevSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
lineDevSpecificFeature(
    HLINE               hLine,
    DWORD               dwFeature,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
lineDial(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineDialW(
    HCALL               hCall,
    LPCTSTR            lpszDestAddress,
    DWORD               dwCountryCode
    );

#ifdef UNICODE
#define lineDial lineDialW
#endif

#define lineDialA lineDial
#endif

LONG
WINAPI
lineDrop(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineForward(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineForwardW(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineForward lineForwardW
#endif

#define lineForwardA lineForward
#endif

LONG
WINAPI
lineGatherDigits(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPSTR               lpsDigits,
    DWORD               dwNumDigits,
    LPCSTR              lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

#if WIN32
LONG
WINAPI
lineGatherDigitsW(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPWSTR              lpsDigits,
    DWORD               dwNumDigits,
    LPCTSTR            lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

#ifdef UNICODE
#define lineGatherDigits lineGatherDigitsW
#endif

#define lineGatherDigitsA lineGatherDigits
#endif

LONG
WINAPI
lineGenerateDigits(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCSTR              lpszDigits,
    DWORD               dwDuration
    );

#if WIN32
LONG
WINAPI
lineGenerateDigitsW(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCTSTR           lpszDigits,
    DWORD               dwDuration
    );

#ifdef UNICODE
#define lineGenerateDigits lineGenerateDigitsW
#endif

#define lineGenerateDigitsA lineGenerateDigits
#endif

LONG
WINAPI
lineGenerateTone(
    HCALL               hCall,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones
    );

LONG
WINAPI
lineGetAddressCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

#if WIN32
LONG
WINAPI
lineGetAddressCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

#ifdef UNICODE
#define lineGetAddressCaps lineGetAddressCapsW
#endif

#define lineGetAddressCapsA lineGetAddressCaps
#endif

LONG
WINAPI
lineGetAddressID(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCSTR              lpsAddress,
    DWORD               dwSize
    );

#if WIN32
LONG
WINAPI
lineGetAddressIDW(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCTSTR           lpsAddress,
    DWORD               dwSize
    );

#ifdef UNICODE
#define lineGetAddressID lineGetAddressIDW
#endif

#define lineGetAddressIDA lineGetAddressID
#endif

LONG
WINAPI
lineGetAddressStatus(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

#if WIN32
LONG
WINAPI
lineGetAddressStatusW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

#ifdef UNICODE
#define lineGetAddressStatus lineGetAddressStatusW
#endif

#define lineGetAddressStatusA lineGetAddressStatus
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineGetAgentActivityList(                                       // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    );

LONG
WINAPI
lineGetAgentActivityListW(                                       // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    );

#ifdef UNICODE
#define lineGetAgentActivityList lineGetAgentActivityListW
#endif

#define lineGetAgentActivityListA lineGetAgentActivityList
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineGetAgentCaps(                                               // TAPI v2.0
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    );

LONG
WINAPI
lineGetAgentGroupList(                                          // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    );

LONG
WINAPI
lineGetAgentStatus(                                             // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    );
#endif

LONG
WINAPI
lineGetAppPriority(                                             // TAPI v1.4
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    );

#if WIN32
LONG
WINAPI
lineGetAppPriorityW(                                             // TAPI v1.4
    LPCTSTR             lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    );

#ifdef UNICODE
#define lineGetAppPriority lineGetAppPriorityW
#endif

#define lineGetAppPriorityA lineGetAppPriority
#endif

LONG
WINAPI
lineGetCallInfo(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    );

#if WIN32
LONG
WINAPI
lineGetCallInfoW(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    );

#ifdef UNICODE
#define lineGetCallInfo lineGetCallInfoW
#endif

#define lineGetCallInfoA lineGetCallInfo
#endif

LONG
WINAPI
lineGetCallStatus(
    HCALL               hCall,
    LPLINECALLSTATUS    lpCallStatus
    );

LONG
WINAPI
lineGetConfRelatedCalls(
    HCALL               hCall,
    LPLINECALLLIST      lpCallList
    );
    
LONG
WINAPI
lineGetCountry(                                                 // TAPI v1.4
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    );

#if WIN32
LONG
WINAPI
lineGetCountryW(                                                // TAPI v1.4
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    );

#ifdef UNICODE
#define lineGetCountry lineGetCountryW
#endif

#define lineGetCountryA lineGetCountry
#endif


LONG
WINAPI
lineGetDevCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

#if WIN32
LONG
WINAPI
lineGetDevCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

#ifdef UNICODE
#define lineGetDevCaps lineGetDevCapsW
#endif

#define lineGetDevCapsA lineGetDevCaps
#endif

LONG
WINAPI
lineGetDevConfig(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineGetDevConfigW(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCTSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define lineGetDevConfig lineGetDevConfigW
#endif

#define lineGetDevConfigA lineGetDevConfig
#endif

LONG
WINAPI
lineGetNewCalls(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwSelect,
    LPLINECALLLIST      lpCallList
    );

LONG
WINAPI
lineGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    );

#if WIN32
LONG
WINAPI
lineGetIconW(
    DWORD               dwDeviceID,
    LPCTSTR           lpszDeviceClass,
    LPHICON             lphIcon
    );

#ifdef UNICODE
#define lineGetIcon lineGetIconW
#endif

#define lineGetIconA lineGetIcon
#endif
    
LONG
WINAPI
lineGetID(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineGetIDW(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCTSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define lineGetID lineGetIDW
#endif

#define lineGetIDA lineGetID
#endif

LONG
WINAPI
lineGetLineDevStatus(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

#if WIN32
LONG
WINAPI
lineGetLineDevStatusW(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

#ifdef UNICODE
#define lineGetDevStatus lineGetDevStatusW
#endif

#define lineGetDevStatusA lineGetDevStatus
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineGetMessage(                                                 // TAPI v2.0
    HLINEAPP        hLineApp,
    LPLINEMESSAGE   lpMessage,
    DWORD           dwTimeout
    );
#endif

LONG
WINAPI
lineGetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPDWORD             lpdwNumRings
    );

LONG
WINAPI
lineGetProviderList(                                            // TAPI v1.4
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    );

#if WIN32
LONG
WINAPI
lineGetProviderListW(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    );

#ifdef UNICODE
#define lineGetProviderList lineGetProviderListW
#endif

#define lineGetProviderListA lineGetProviderList
#endif

LONG
WINAPI
lineGetRequest(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    );

#if WIN32
LONG
WINAPI
lineGetRequestW(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    );

#ifdef UNICODE
#define lineGetRequest lineGetRequestW
#endif

#define lineGetRequestA lineGetRequest
#endif

LONG
WINAPI
lineGetStatusMessages(
    HLINE               hLine,
    LPDWORD             lpdwLineStates,
    LPDWORD             lpdwAddressStates
    );

LONG
WINAPI
lineGetTranslateCaps(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    );

#if WIN32
LONG
WINAPI
lineGetTranslateCapsW(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    );

#ifdef UNICODE
#define lineGetTranslateCaps lineGetTranslateCapsW
#endif

#define lineGetTranslateCapsA lineGetTranslateCaps
#endif


LONG
WINAPI
lineHandoff(
    HCALL               hCall,
    LPCSTR              lpszFileName,
    DWORD               dwMediaMode
    );

#if WIN32
LONG
WINAPI
lineHandoffW(
    HCALL               hCall,
    LPCTSTR             lpszFileName,
    DWORD               dwMediaMode
    );

#ifdef UNICODE
#define lineHandoff lineHandoffW
#endif

#define lineHandoffA lineHandoff
#endif

LONG
WINAPI
lineHold(
    HCALL               hCall
    );

LONG
WINAPI
lineInitialize(
    LPHLINEAPP          lphLineApp,
    HINSTANCE           hInstance,
    LINECALLBACK        lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineInitializeEx(                                               // TAPI v2.0
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    );

LONG
WINAPI
lineInitializeExW(                                               // TAPI v2.0
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCTSTR                   lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    );

#ifdef UNICODE
#define lineInitializeEx lineInitializeExW
#endif

#define lineInitializeExA lineInitializeEx
#endif


LONG
WINAPI
lineMakeCall(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineMakeCallW(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCTSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineMakeCall lineMakeCallW
#endif

#define lineMakeCallA lineMakeCall
#endif

LONG
WINAPI
lineMonitorDigits(
    HCALL               hCall,
    DWORD               dwDigitModes
    );

LONG
WINAPI
lineMonitorMedia(
    HCALL               hCall,
    DWORD               dwMediaModes
    );

LONG
WINAPI
lineMonitorTones(
    HCALL               hCall,
    LPLINEMONITORTONE   const lpToneList,
    DWORD               dwNumEntries
    );

LONG
WINAPI
lineNegotiateAPIVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    );

LONG
WINAPI
lineNegotiateExtVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
WINAPI
lineOpen(
    HLINEAPP hLineApp, 
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineOpenW(
    HLINEAPP hLineApp, 
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineOpen lineOpenW
#endif

#define lineOpenA lineOpen
#endif

LONG
WINAPI
linePark(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCSTR              lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

#if WIN32
LONG
WINAPI
lineParkW(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCTSTR             lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

#ifdef UNICODE
#define linePark lineParkW
#endif

#define lineParkA linePark
#endif

LONG
WINAPI
linePickup(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszGroupID
    );

#if WIN32
LONG
WINAPI
linePickupW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCTSTR             lpszDestAddress,
    LPCTSTR             lpszGroupID
    );

#ifdef UNICODE
#define linePickup linePickupW
#endif

#define linePickupA linePickup
#endif

LONG
WINAPI
linePrepareAddToConference(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
linePrepareAddToConferenceW(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define linePrepareAddToConference linePrepareAddToConferenceW
#endif

#define linePrepareAddToConferenceA linePrepareAddToConference
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineProxyMessage(                                               // TAPI v2.0
    HLINE               hLine,
    HCALL               hCall,
    DWORD               dwMsg,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );

LONG
WINAPI
lineProxyResponse(                                              // TAPI v2.0
    HLINE               hLine,
    LPLINEPROXYREQUEST  lpProxyRequest,
    DWORD               dwResult
    );
#endif

LONG
WINAPI
lineRedirect(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineRedirectW(
    HCALL               hCall,
    LPCTSTR             lpszDestAddress,
    DWORD               dwCountryCode
    );

#ifdef UNICODE
#define lineRedirect lineRedirectW
#endif

#define lineRedirectA lineRedirect
#endif

LONG
WINAPI
lineRegisterRequestRecipient(
    HLINEAPP            hLineApp,
    DWORD               dwRegistrationInstance,
    DWORD               dwRequestMode,
    DWORD               bEnable
    );

LONG
WINAPI
lineReleaseUserUserInfo(                                        // TAPI v1.4
    HCALL               hCall
    );

LONG
WINAPI
lineRemoveFromConference(
    HCALL               hCall
    );

LONG
WINAPI
lineRemoveProvider(                                             // TAPI v1.4
    DWORD               dwPermanentProviderID,
    HWND                hwndOwner
    );

LONG
WINAPI
lineSecureCall(
    HCALL               hCall
    );

LONG
WINAPI
lineSendUserUserInfo(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetAgentActivity(                                           // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwActivityID
    );

LONG
WINAPI
lineSetAgentGroup(                                              // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    );

LONG
WINAPI
lineSetAgentState(                                              // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState
    );
#endif

LONG
WINAPI
lineSetAppPriority(                                             // TAPI v1.4
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR              lpszExtensionName,
    DWORD               dwPriority
    );

#if WIN32
LONG
WINAPI
lineSetAppPriorityW(                                             // TAPI v1.4
    LPCTSTR           lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCTSTR           lpszExtensionName,
    DWORD               dwPriority
    );

#ifdef UNICODE
#define lineSetAppPriority lineSetAppPriorityW
#endif

#define lineSetAppPriorityA lineSetAppPriority
#endif

LONG
WINAPI
lineSetAppSpecific(
    HCALL               hCall,
    DWORD               dwAppSpecific
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetCallData(                                                // TAPI v2.0
    HCALL               hCall,
    LPVOID              lpCallData,
    DWORD               dwSize
    );
#endif

LONG
WINAPI
lineSetCallParams(
    HCALL               hCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    );

LONG
WINAPI
lineSetCallPrivilege(
    HCALL               hCall,
    DWORD               dwCallPrivilege
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetCallQualityOfService(                                    // TAPI v2.0
    HCALL               hCall,
    LPVOID              lpSendingFlowspec,
    DWORD               dwSendingFlowspecSize,
    LPVOID              lpReceivingFlowspec,
    DWORD               dwReceivingFlowspecSize
    );

LONG
WINAPI
lineSetCallTreatment(                                           // TAPI v2.0
    HCALL               hCall,
    DWORD               dwTreatment
    );
#endif

LONG
WINAPI
lineSetCurrentLocation(
    HLINEAPP            hLineApp,
    DWORD               dwLocation
    );

LONG
WINAPI
lineSetDevConfig(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineSetDevConfigW(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCTSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define lineSetDevConfig lineSetDevConfigW
#endif

#define lineSetDevConfigA lineSetDevConfig
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetLineDevStatus(                                           // TAPI v2.0
    HLINE               hLine,
    DWORD               dwStatusToChange,
    DWORD               fStatus
    );
#endif

LONG
WINAPI
lineSetMediaControl(
    HLINE                       hLine,
    DWORD                       dwAddressID,
    HCALL                       hCall,
    DWORD                       dwSelect,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList, 
    DWORD                       dwCallStateNumEntries
    );

LONG
WINAPI
lineSetMediaMode(
    HCALL               hCall,
    DWORD               dwMediaModes
    );

LONG
WINAPI
lineSetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwNumRings
    );

LONG
WINAPI
lineSetStatusMessages(
    HLINE               hLine,
    DWORD               dwLineStates,
    DWORD               dwAddressStates
    );

LONG
WINAPI
lineSetTerminal(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    DWORD               dwTerminalModes,
    DWORD               dwTerminalID,
    DWORD               bEnable
    );

LONG
WINAPI
lineSetTollList(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCSTR              lpszAddressIn,
    DWORD               dwTollListOption
    );

#if WIN32
LONG
WINAPI
lineSetTollListW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCTSTR           lpszAddressInW,
    DWORD               dwTollListOption
    );

#ifdef UNICODE
#define lineSetTollList lineSetTollListW
#endif

#define lineSetTollListA lineSetTollList
#endif


LONG
WINAPI
lineSetupConference(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineSetupConferenceW(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineSetupConference lineSetupConferenceW
#endif

#define lineSetupConferenceA lineSetupConference
#endif

LONG
WINAPI
lineSetupTransfer(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineSetupTransferW(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineSetupTransfer lineSetupTransferW
#endif

#define lineSetupTransferA lineSetupTransfer
#endif

LONG
WINAPI
lineShutdown(
    HLINEAPP            hLineApp
    );

LONG
WINAPI
lineSwapHold(
    HCALL               hActiveCall,
    HCALL               hHeldCall
    );

LONG
WINAPI
lineTranslateAddress(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

#if WIN32
LONG
WINAPI
lineTranslateAddressW(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCTSTR                 lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

#ifdef UNICODE
#define lineTranslateAddress lineTranslateAddressW
#endif

#define lineTranslateAddressA  lineTranslateAddress
#endif

LONG
WINAPI
lineTranslateDialog(                                            // TAPI v1.4
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCSTR              lpszAddressIn
    );

#if WIN32
LONG
WINAPI
lineTranslateDialogW(                                            // TAPI v2.0
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCTSTR           lpszAddressIn
    );

#ifdef UNICODE
#define lineTranslateDialog lineTranslateDialogW
#endif

#define lineTranslateDialogA  lineTranslateDialog
#endif

LONG
WINAPI
lineUncompleteCall(
    HLINE               hLine,
    DWORD               dwCompletionID
    );

LONG
WINAPI
lineUnhold(
    HCALL               hCall
    );

LONG
WINAPI
lineUnpark(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress
    );

#if WIN32
LONG
WINAPI
lineUnparkW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCTSTR           lpszDestAddress
    );

#ifdef UNICODE
#define lineUnpark lineUnparkW
#endif

#define lineUnparkA lineUnpark
#endif



LONG
WINAPI
phoneClose(
    HPHONE              hPhone
    );

LONG
WINAPI
phoneConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
phoneConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCTSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define phoneConfigDialog phoneConfigDialogW
#endif

#define phoneConfigDialogA phoneConfigDialog
#endif

LONG
WINAPI
phoneDevSpecific(
    HPHONE              hPhone,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
phoneGetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

#if WIN32
LONG
WINAPI
phoneGetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

#ifdef UNICODE
#define phoneGetButtonInfo phoneGetButtonInfoW
#endif

#define phoneGetButtonInfoA phoneGetButtonInfo
#endif

LONG
WINAPI
phoneGetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              lpData,
    DWORD               dwSize
    );

LONG
WINAPI
phoneGetDevCaps(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

#if WIN32
LONG
WINAPI
phoneGetDevCapsW(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

#ifdef UNICODE
#define phoneGetDevCaps phoneGetDevCapsW
#endif

#define phoneGetDevCapsA phoneGetDevCaps
#endif

LONG
WINAPI
phoneGetDisplay(
    HPHONE              hPhone,
    LPVARSTRING         lpDisplay
    );

LONG
WINAPI
phoneGetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwGain
    );

LONG
WINAPI
phoneGetHookSwitch(
    HPHONE              hPhone,
    LPDWORD             lpdwHookSwitchDevs
    );

LONG
WINAPI
phoneGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    );

#if WIN32
LONG
WINAPI
phoneGetIconW(
    DWORD               dwDeviceID,
    LPCTSTR             lpszDeviceClass,
    LPHICON             lphIcon
    );

#ifdef UNICODE
#define phoneGetIcon phoneGetIconW
#endif

#define phoneGetIconA phoneGetIcon
#endif

LONG
WINAPI
phoneGetID(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
phoneGetIDW(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCTSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define phoneGetID phoneGetIDW
#endif

#define phoneGetIDA phoneGetID
#endif

LONG
WINAPI
phoneGetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPDWORD             lpdwLampMode
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
phoneGetMessage(                                                // TAPI v2.0
    HPHONEAPP       hPhoneApp,
    LPPHONEMESSAGE  lpMessage,
    DWORD           dwTimeout
    );
#endif

LONG
WINAPI
phoneGetRing(
    HPHONE              hPhone,
    LPDWORD             lpdwRingMode,
    LPDWORD             lpdwVolume
    );

LONG
WINAPI
phoneGetStatus(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    );

#if WIN32
LONG
WINAPI
phoneGetStatusW(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    );


#ifdef UNICODE
#define phoneGetStatus phoneGetStatusW
#endif

#define phoneGetStatusA phoneGetStatus
#endif

LONG
WINAPI
phoneGetStatusMessages(
    HPHONE              hPhone,
    LPDWORD             lpdwPhoneStates,
    LPDWORD             lpdwButtonModes,
    LPDWORD             lpdwButtonStates
    );

LONG
WINAPI
phoneGetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwVolume
    );

LONG
WINAPI
phoneInitialize(
    LPHPHONEAPP         lphPhoneApp,
    HINSTANCE           hInstance,
    PHONECALLBACK       lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    );

#if WIN32
LONG
WINAPI
phoneInitializeW(
    LPHPHONEAPP         lphPhoneApp,
    HINSTANCE           hInstance,
    PHONECALLBACK       lpfnCallback,
    LPCTSTR           lpszAppNameW,
    LPDWORD             lpdwNumDevs
    );

#ifdef UNICODE
#define phoneInitialize phoneInitializeW
#endif

#define phoneInitializeA phoneInitialize
#endif


#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
phoneInitializeEx(                                              // TAPI v2.0
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    );

LONG
WINAPI
phoneInitializeExW(                                              // TAPI v2.0
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCTSTR                   lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    );

#ifdef UNICODE
#define phoneInitializeEx phoneInitializeExW
#endif

#define phoneInitializeExA phoneInitializeEx
#endif

LONG
WINAPI
phoneNegotiateAPIVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    );

LONG
WINAPI
phoneNegotiateExtVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
WINAPI
phoneOpen(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    LPHPHONE            lphPhone,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivilege
    );

LONG
WINAPI
phoneSetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

#if WIN32
LONG
WINAPI
phoneSetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

#ifdef UNICODE
#define phoneSetButtonInfo phoneSetButtonInfoW
#endif

#define phoneSetButtonInfoA phoneSetButtonInfo
#endif

LONG
WINAPI
phoneSetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              const lpData,
    DWORD               dwSize
    );

LONG
WINAPI
phoneSetDisplay(
    HPHONE              hPhone,
    DWORD               dwRow,
    DWORD               dwColumn,
    LPCSTR              lpsDisplay,
    DWORD               dwSize
    );

LONG
WINAPI
phoneSetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwGain
    );

LONG
WINAPI
phoneSetHookSwitch(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDevs,
    DWORD               dwHookSwitchMode
    );

LONG
WINAPI
phoneSetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    DWORD               dwLampMode
    );

LONG
WINAPI
phoneSetRing(
    HPHONE              hPhone,
    DWORD               dwRingMode,
    DWORD               dwVolume
    );

LONG
WINAPI
phoneSetStatusMessages(
    HPHONE              hPhone,
    DWORD               dwPhoneStates,
    DWORD               dwButtonModes,
    DWORD               dwButtonStates
    );

LONG
WINAPI
phoneSetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwVolume
    );

LONG
WINAPI
phoneShutdown(
    HPHONEAPP           hPhoneApp
    );



LONG
WINAPI
tapiGetLocationInfo(
    LPSTR               lpszCountryCode,
    LPSTR               lpszCityCode
    );

#if WIN32
LONG
WINAPI
tapiGetLocationInfoW(
    LPTSTR               lpszCountryCodeW,
    LPTSTR               lpszCityCodeW
    );

#ifdef UNICODE
#define tapiGetLocationInfo tapiGetLocationInfoW
#else
#define tapiGetLocationInfoA tapiGetLocationInfo
#endif
#endif
    

LONG
WINAPI
tapiRequestDrop(
    HWND                hwnd,
    WPARAM              wRequestID
    );

LONG
WINAPI
tapiRequestMakeCall(
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    );

#if WIN32
LONG
WINAPI
tapiRequestMakeCallW(
    LPCTSTR            lpszDestAddress,
    LPCTSTR            lpszAppName,
    LPCTSTR            lpszCalledParty,
    LPCTSTR            lpszComment
    );

#ifdef UNICODE
#define tapiRequestMakeCall tapiRequestMakeCallW
#endif

#define tapiRequestMakeCallA tapiRequestMakeCall
#endif
    
LONG
WINAPI
tapiRequestMediaCall(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCSTR              lpszDeviceClass,
    LPCSTR              lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    );

#if WIN32
LONG
WINAPI
tapiRequestMediaCallW(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCTSTR             lpszDeviceClass,
    LPCTSTR             lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCTSTR             lpszDestAddress,
    LPCTSTR             lpszAppName,
    LPCTSTR             lpszCalledParty,
    LPCTSTR             lpszComment
    );

#ifdef UNICODE
#define tapiRequestMediaCall tapiRequestMediaCallW
#endif

#define tapiRequestMediaCallA tapiRequestMediaCall
#endif




#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#pragma pack()

#endif // TAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\struct.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
// STRUCT.H - global data structures that need to go through thunk layers
//

//  HISTORY:
//  
//  11/20/94    jeremys     Created.
//  96/03/11  markdu    Added fDisallowTCPInstall and fDisallowRNAInstall.
//            These are used to prevent installing the components, and
//            since we want to allow the installation by default, setting
//            the structure to zeros gives default behaviour with these flags.
//  96/03/12  markdu    Removed nModems since we enumerate modems
//            with RNA now.
//

// Note: this structure is separated out from the main global inc file
// because #define's and other valid C syntax aren't valid for the thunk
// compiler, which just needs the structure.

// structure to hold information about client software configuration
typedef struct tagCLIENTCONFIG {
    BOOL fTcpip;            // TCP/IP currently installed

    BOOL fNetcard;          // net card installed
    BOOL fNetcardBoundTCP;  // TCP/IP bound to net card

    BOOL fPPPDriver;        // PPP driver installed
    BOOL fPPPBoundTCP;      // TCP/IP bound to PPP driver

    BOOL fMailInstalled;    // microsoft mail (exchange) files installed
    BOOL fRNAInstalled;     // RNA (remote access) files installed
    BOOL fMSNInstalled;     // Microsoft network files installed
    BOOL fMSN105Installed;  // MSN 1.05 (Rome) files installed
    BOOL fInetMailInstalled;    // Internet mail (rt. 66) files installed
  BOOL fDisallowTCPInstall; // Do not allow TCP/IP to be installed
  BOOL fDisallowRNAInstall; // Do not allow RNA to be installed
} CLIENTCONFIG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\validate.h ===
#ifndef _validate_h_
#define _validate_h_

#ifdef __cplusplus
extern "C" {
#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bOK = IS_VALID_READ_PTR(pfoo, CFOO);
 *
 * bOK = IS_VALID_HANDLE(hfoo, FOO);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#ifndef WIN16    
#define IS_VALID_STRING_PTRA(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(char)) || IsBadStringPtrA((ptr), (UINT)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(WCHAR)) || IsBadStringPtrW((ptr), (UINT)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPWSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)
#else
#define IS_VALID_STRING_PTRA(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(char)) || IsBadStringPtr((ptr), (UINT)(cch))) ? \
    (TraceMsg(TF_ERROR, "invalid LPSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(WCHAR)) || IsBadStringPtr((ptr), (UINT)(cch))) ? \
    (TraceMsg(TF_ERROR, "invalid LPWSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)
#endif

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs code pointer - %#08lx", (LPCSTR)#type, (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (IsBadReadPtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (IsBadWritePtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (TraceMsgA(TF_ERROR, "invalid flags set - %#08lx", ((dwFlags) & (~(dwAllFlags)))), FALSE) : \
    TRUE)

#define IS_VALID_PIDL(ptr) \
   ( !IsValidPIDL(ptr) ? \
    (TraceMsgA(TF_ERROR, "invalid PIDL pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) != (cbExpected) ? \
    (TraceMsgA(TF_ERROR, "invalid size - is %#08lx, expected %#08lx", (cb), (cbExpected)), FALSE) : \
    TRUE)


#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTRA(ptr, cch) \
   (! IsBadStringPtrA((ptr), (UINT)(cch)))

#define IS_VALID_STRING_PTRW(ptr, cch) \
   (! IsBadStringPtrW((ptr), (UINT)(cch)))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (! IsBadReadPtr((ptr), sizeof(type)*(len)))

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (! IsBadWritePtr((ptr), sizeof(type)*(len)))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#define IS_VALID_PIDL(ptr) \
   (IsValidPIDL(ptr))

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) == (cbExpected))

#endif

#ifdef UNICODE
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRW
#else
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRA
#endif


/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid H" #type " - %#08lx", (hnd)), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif

/* structure validation macros */

// Define VSTF if you want to validate the fields in structures.  This
// requires a handler function (of the form IsValid*()) that knows how
// to validate the specific structure type.

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif  // VSTF

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, ##iface)


#if !defined(NO_SHELL_VALIDATION)

BOOL IsValidPathA(LPCSTR pcszPath);
BOOL IsValidPathW(LPCWSTR pcszPath);

BOOL IsValidPathResultA(HRESULT hr, LPCSTR pcszPath, UINT cchPathBufLen);
BOOL IsValidPathResultW(HRESULT hr, LPCWSTR pcszPath, UINT cchPathBufLen);

BOOL IsValidExtensionA(LPCSTR pcszExt);
BOOL IsValidExtensionW(LPCWSTR pcszExt);

BOOL IsValidIconIndexA(HRESULT hr, LPCSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);
BOOL IsValidIconIndexW(HRESULT hr, LPCWSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);

BOOL IsFullPathA(LPCSTR pcszPath);
BOOL IsFullPathW(LPCWSTR pcszPath);

BOOL IsStringContainedA(LPCSTR pcszBigger, LPCSTR pcszSuffix);
BOOL IsStringContainedW(LPCWSTR pcszBigger, LPCWSTR pcszSuffix);

#ifdef UNICODE
#define IsValidPath         IsValidPathW
#define IsValidPathResult   IsValidPathResultW
#define IsValidExtension    IsValidExtensionW
#define IsValidIconIndex    IsValidIconIndexW
#define IsFullPath          IsFullPathW
#define IsStringContained   IsStringContainedW
#else
#define IsValidPath         IsValidPathA
#define IsValidPathResult   IsValidPathResultA
#define IsValidExtension    IsValidExtensionA
#define IsValidIconIndex    IsValidIconIndexA
#define IsFullPath          IsFullPathA
#define IsStringContained   IsStringContainedA
#endif

BOOL IsValidHANDLE(HANDLE hnd);         // Compares with NULL and INVALID_HANDLE_VALUE
BOOL IsValidHANDLE2(HANDLE hnd);        // Compares with INVALID_HANDLE_VALUE

#define IsValidHEVENT       IsValidHANDLE
#define IsValidHGLOBAL      IsValidHANDLE
#define IsValidHFILE        IsValidHANDLE
#define IsValidHINSTANCE    IsValidHANDLE
#define IsValidHICON        IsValidHANDLE
#define IsValidHKEY         IsValidHANDLE
#define IsValidHMODULE      IsValidHANDLE
#define IsValidHPROCESS     IsValidHANDLE

BOOL
IsValidHWND(
    HWND hwnd);

BOOL
IsValidHMENU(
    HMENU hmenu);

BOOL
IsValidShowCmd(
    int nShow);

// Hack for components like shlwapi who don't #include commctrl.h
#ifdef DPA_GetPtrCount
BOOL
IsValidHDPA(
    HDPA hdpa);

BOOL
IsValidHDSA(
    HDSA hdsa);
#endif


// For components like comctl32 who don't #include shlobj.h
#ifdef _SHLOBJ_H_
BOOL
IsValidPIDL(
    LPCITEMIDLIST pidl);
#endif

#endif // NO_SHELL_VALIDATION

#ifdef __cplusplus
};
#endif

#endif // _validate_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\webview.h ===
#ifndef _INC_WEBVIEW_H
#define _INC_WEBVIEW_H

#include <exdisp.h>
#include "icwhelp.h"
#include "appdefs.h"

interface IICWWebView : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleKey         (LPMSG lpMsg)                    = 0;
        virtual HRESULT STDMETHODCALLTYPE ConnectToWindow   (HWND hWnd, DWORD dwHtmPageType) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetFocus          ()                               = 0;
#ifndef UNICODE
        virtual HRESULT STDMETHODCALLTYPE DisplayHTML       (TCHAR* lpszURL)                 = 0;
#endif
        virtual HRESULT STDMETHODCALLTYPE DisplayHTML       (BSTR bstrURL)                   = 0;
        virtual HRESULT STDMETHODCALLTYPE SetHTMLColors     (LPTSTR lpszForeGrndColor, LPTSTR lpszBkGrndColor)    = 0;
        virtual HRESULT STDMETHODCALLTYPE SetHTMLBackgroundBitmap (HBITMAP hbm, LPRECT lpRC) = 0;
        virtual HRESULT STDMETHODCALLTYPE get_BrowserObject (IWebBrowser2** lpWebBrowser)    = 0;    
};

interface IICWWalker : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Walk                     ()                              = 0;
        virtual HRESULT STDMETHODCALLTYPE AttachToDocument         (IWebBrowser2* lpWebBrowser)    = 0;
        virtual HRESULT STDMETHODCALLTYPE AttachToMSHTML           (BSTR bstrURL)                  = 0;
        virtual HRESULT STDMETHODCALLTYPE Detach                   ()                              = 0;
        virtual HRESULT STDMETHODCALLTYPE InitForMSHTML            ()                              = 0;
        virtual HRESULT STDMETHODCALLTYPE TermForMSHTML            ()                              = 0;
        virtual HRESULT STDMETHODCALLTYPE LoadURLFromFile          (BSTR bstrURL)                  = 0;
        virtual HRESULT STDMETHODCALLTYPE ExtractUnHiddenText      (BSTR* pbstrText)               = 0;
        virtual HRESULT STDMETHODCALLTYPE ProcessOLSFile           (IWebBrowser2* lpWebBrowser)    = 0;
        virtual HRESULT STDMETHODCALLTYPE get_PageType             (LPDWORD pdwPageType)           = 0;
        virtual HRESULT STDMETHODCALLTYPE get_IsQuickFinish        (BOOL* pbIsQuickFinish)         = 0;
        virtual HRESULT STDMETHODCALLTYPE get_PageFlag             (LPDWORD pdwPageFlag)           = 0;
        virtual HRESULT STDMETHODCALLTYPE get_PageID               (BSTR* pbstrPageID)             = 0;
        virtual HRESULT STDMETHODCALLTYPE get_URL                  (LPTSTR lpszURL, BOOL bForward) = 0;
        virtual HRESULT STDMETHODCALLTYPE get_FirstFormQueryString (LPTSTR lpszQuery)              = 0;
        virtual HRESULT STDMETHODCALLTYPE get_IeakIspFile          (LPTSTR lpszIspFile)            = 0;
};

interface IICWGifConvert : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE GifToIcon(TCHAR * pszFile, UINT nIconSize, HICON* phIcon) = 0;
        virtual HRESULT STDMETHODCALLTYPE GifToBitmap(TCHAR * pszFile, HBITMAP* phBitmap) = 0;
        
};

enum IPSDataElements
{
    ISPDATA_USER_FIRSTNAME = 0,
    ISPDATA_USER_LASTNAME,
    ISPDATA_USER_ADDRESS,
    ISPDATA_USER_MOREADDRESS,
    ISPDATA_USER_CITY,
    ISPDATA_USER_STATE,
    ISPDATA_USER_ZIP,
    ISPDATA_USER_PHONE,
    ISPDATA_AREACODE,
    ISPDATA_COUNTRYCODE,
    ISPDATA_USER_FE_NAME,
    ISPDATA_PAYMENT_TYPE,
    ISPDATA_PAYMENT_BILLNAME,
    ISPDATA_PAYMENT_BILLADDRESS,
    ISPDATA_PAYMENT_BILLEXADDRESS,
    ISPDATA_PAYMENT_BILLCITY,
    ISPDATA_PAYMENT_BILLSTATE,
    ISPDATA_PAYMENT_BILLZIP,
    ISPDATA_PAYMENT_BILLPHONE,
    ISPDATA_PAYMENT_DISPLAYNAME,
    ISPDATA_PAYMENT_CARDNUMBER,
    ISPDATA_PAYMENT_EXMONTH,
    ISPDATA_PAYMENT_EXYEAR,
    ISPDATA_PAYMENT_CARDHOLDER,
    ISPDATA_SIGNED_PID,
    ISPDATA_GUID,
    ISPDATA_OFFERID,
    ISPDATA_BILLING_OPTION,
    ISPDATA_PAYMENT_CUSTOMDATA,
    ISPDATA_USER_COMPANYNAME,
    ISPDATA_ICW_VERSION
};

enum ISPDATAValidateLevels
{
    ISPDATA_Validate_None = 0,
    ISPDATA_Validate_DataPresent,
    ISPDATA_Validate_Content
};
    
interface IICWISPData : public IUnknown
{
    public:
        // IICWISPData
        virtual BOOL STDMETHODCALLTYPE      PutDataElement(WORD wElement, LPCTSTR lpValue, WORD wValidateLevel) = 0;
        virtual LPCTSTR STDMETHODCALLTYPE   GetDataElement(WORD wElement) = 0;
        virtual void STDMETHODCALLTYPE      PutValidationFlags(DWORD dwFlags) = 0;
        virtual void STDMETHODCALLTYPE      Init(HWND   hWndParent) = 0;
        virtual HRESULT STDMETHODCALLTYPE   GetQueryString(BSTR bstrBaseURL, BSTR *lpReturnURL) = 0;
};

#endif // _INC_WEBVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\wizdebug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME
#endif  // SZ_COMPNAME

static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
    if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
        break;
    }
    wsprintf(ach, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
    _AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  
    va_list args;

    va_start(args,pszMsg);
    wvsprintf(ach, pszMsg, args);
    //wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
    OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
    _DebugMsg(pszMsg);
    DebugBreak();
    //_asm {int 3};
}

//#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  DebugBreak(); } }
//#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  DebugBreak(); } }
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP       _DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\wizglob.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
// WIZGLOB.H -  global data structures and defines for all wizard components
//              (32-bit exe, 32-bit dll, 16-bit dll)

//  HISTORY:
//  
//  11/20/94    jeremys     Created.
//

#ifndef _WIZGLOB_H_
#define _WIZGLOB_H_

#ifndef SETUPX_INC
typedef UINT RETERR;             // setupx Return Error code type.
#endif  // SETUPX_INC

// structure to hold information about client software configuration
#include <struct.h> // separated out so thunk compiler can get at

typedef CLIENTCONFIG FAR * LPCLIENTCONFIG;
typedef char CHAR;
typedef BOOL FAR * LPBOOL;

// component defines for InstallComponent

#define IC_PPPMAC           0x0001      // install PPPMAC
#define IC_TCPIP            0x0002      // install TCP/IP
#define IC_INSTALLFILES     0x0003      // install files, etc from INF

// dwParam bits for IC_INSTALLFILES
#define ICIF_MAIL           0x0001      // install mail files
#define ICIF_RNA            0x0002      // install RNA files
#define ICIF_MSN            0x0004      // install Microsoft Network files
#define ICIF_MSN105         0x0008      // install MSN 1.05 (Rome) files
#define ICIF_INET_MAIL      0x0010      // install Internet mail files

// INSTANCE_ defines for TCP/IP configuration apis
#define INSTANCE_NETDRIVER      0x0001
#define INSTANCE_PPPDRIVER      0x0002
#define INSTANCE_ALL            (INSTANCE_NETDRIVER | INSTANCE_PPPDRIVER)

// PROT_ defines for protocol types
#define PROT_TCPIP              0x0001
#define PROT_IPX                0x0002
#define PROT_NETBEUI            0x0004

#define NEED_RESTART            ((WORD) -1)

#endif // _WIZGLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\webvwids.h ===
#ifndef _INC_WEBVWIDS_H
#define _INC_WEBVWIDS_H

// {99BA6178-219E-11D2-AE1B-0000F87734F0}
DEFINE_GUID(IID_IICWWebView, 0x99ba6178, 0x219e, 0x11d2, 0xae, 0x1b, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

// ICWUTILS's WebView CLSID
// This is used to create an instance of the WebView object
// {99BA617B-219E-11D2-AE1B-0000F87734F0}
DEFINE_GUID(CLSID_ICWWEBVIEW, 0x99ba617b, 0x219e, 0x11d2, 0xae, 0x1b, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

// {3B79EEAC-2728-11d2-8D58-0000F87734F0}
DEFINE_GUID(IID_IICWWalker, 0x3b79eeac, 0x2728, 0x11d2, 0x8d, 0x58, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

// {3B79EEAD-2728-11d2-8D58-0000F87734F0}
DEFINE_GUID(CLSID_ICWWALKER, 0x3b79eead, 0x2728, 0x11d2, 0x8d, 0x58, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);


// {F832C2B5-312D-11d2-8D5F-0000F87734F0}
DEFINE_GUID(IID_IICWGifConvert, 0xf832c2b5, 0x312d, 0x11d2, 0x8d, 0x5f, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

// {F832C2B2-312D-11d2-8D5F-0000F87734F0}
DEFINE_GUID(CLSID_ICWGIFCONVERT, 0xf832c2b2, 0x312d, 0x11d2, 0x8d, 0x5f, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

// {29548506-3886-11d2-8D63-0000F87734F0}
DEFINE_GUID(IID_IICWISPData, 0x29548506, 0x3886, 0x11d2, 0x8d, 0x63, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

// {29548507-3886-11d2-8D63-0000F87734F0}
DEFINE_GUID(CLSID_ICWISPDATA, 0x29548507, 0x3886, 0x11d2, 0x8d, 0x63, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

#endif // _INC_WEBVWDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\callout.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CALLOUT.C - Functions to call out to external components to install
//        devices
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#include "pch.hpp"

/*******************************************************************

  NAME:    InstallTCPIP

  SYNOPSIS:  Installs MS TCP/IP 

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    calls through thunk layer to 16-bit side which calls
        Device Manager

********************************************************************/
UINT InstallTCPIP(HWND hwndParent)
{
  WAITCURSOR WaitCursor;  // waitcursor object for hourglassing

  // call down to 16-bit dll to do this
  return InstallComponent(hwndParent,IC_TCPIP,0);
}

/*******************************************************************

  NAME:    InstallPPPMAC

  SYNOPSIS:  Installs PPPMAC (PPP driver)

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    calls through thunk layer to 16-bit side which calls
        Device Manager

********************************************************************/
UINT InstallPPPMAC(HWND hwndParent)
{
  WAITCURSOR WaitCursor;  // waitcursor object for hourglassing

  // call down to 16-bit dll to do this
  return InstallComponent(hwndParent,IC_PPPMAC,0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\debug.h ===
#ifndef _PHBKDEBUG
#define _PHBKDEBUG

//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
	void Dprintf(PCSTR pcsz, ...);
//#ifdef __cplusplus
//}
//#endif // __cplusplus

#ifdef DEBUG
//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
	BOOL FAssertProc(PCSTR szFile,  DWORD dwLine, PCSTR szMsg, DWORD dwFlags);
	void DebugSz(PCSTR psz);
//#ifdef __cplusplus
//}
//#endif // __cplusplus
	#define AssertSzFlg(f, sz, dwFlg)		( (f) ? 0 : FAssertProc(__FILE__, __LINE__, sz, dwFlg) ? DebugBreak() : 1 )
	#define AssertSz(f, sz)				AssertSzFlg(f, sz, 0)
	#define Assert(f)					AssertSz((f), "!(" #f ")")
#else
	#define DebugSz(x)
	#define AssertSzFlg(f, sz, dwFlg) f
	#define AssertSz(f, sz) f
	#define Assert(f) f
#endif
#endif //_PHBKDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\cfgapi.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  CFGAPI.C - Functions for exported config API.
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/27  markdu  Added lpGetLastInstallErrorText.
//

#include "pch.hpp"

UINT DetectModifyTCPIPBindings(DWORD dwCardFlags,LPCSTR pszBoundTo,BOOL fRemove,BOOL * pfBound);


//*******************************************************************
//
//  FUNCTION:   IcfgGetLastInstallErrorText
//
//  PURPOSE:    Get a text string that describes the last installation
//              error that occurred.  The string should be suitable
//              for display in a message box with no further formatting.
//
//  PARAMETERS: lpszErrorDesc - points to buffer to receive the string.
//              cbErrorDesc - size of buffer.
//
//  RETURNS:    The length of the string returned.
//
//*******************************************************************

extern "C" DWORD WINAPI IcfgGetLastInstallErrorText(LPSTR lpszErrorDesc, DWORD cbErrorDesc)
{
  if (lpszErrorDesc)
  {
    lstrcpyn(lpszErrorDesc, gpszLastErrorText, cbErrorDesc);
    return lstrlen(lpszErrorDesc);
  }
  else
  {
    return 0;
  }
}


//*******************************************************************
//
//  FUNCTION:   IcfgNeedInetComponents
//
//  PURPOSE:    Detects whether the specified system components are
//              installed or not.
//
//  PARAMETERS: dwfOptions - a combination of ICFG_ flags that specify
//              which components to detect as follows:
//
//                ICFG_INSTALLTCP - is TCP/IP needed?
//                ICFG_INSTALLRAS - is RAS needed?
//                ICFG_INSTALLMAIL - is exchange or internet mail needed?
//
//              lpfNeedComponents - TRUE if any specified component needs
//              to be installed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  History:	5/8/97 ChrisK Added INSTALLLAN,INSTALLDIALUP,INSTALLTCPONLY
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents)
{
  CLIENTCONFIG  ClientConfig;

  DEBUGMSG("cfgapi.c::IcfgNeedInetComponents()");

  ASSERT(lpfNeedComponents);

  // read client configuration
  ZeroMemory(&ClientConfig,sizeof(CLIENTCONFIG));
  DWORD dwErrCls;
  UINT err=GetConfig(&ClientConfig,&dwErrCls);
  if (err != OK)
  {
    LoadSz(IDS_ERRReadConfig, gpszLastErrorText, MAX_ERROR_TEXT);
    return err;
  }

  // check if we are allowed to install TCP/IP
  if (dwfOptions & ICFG_INSTALLTCP)
  {
    // need TCP/IP present and bound to PPP driver
    // if (!ClientConfig.fPPPBoundTCP)
    //
    // vyung - PPPBound TCP is not able to be installed through
    // ICW. So here we only check the TCPIP flag.
    if (!ClientConfig.fTcpip)
    {
      if (lpfNeedComponents)
      {
        *lpfNeedComponents = TRUE;
      }
      return ERROR_SUCCESS;
    }
  }

  // check if we are allowed to install RNA
  if (dwfOptions & ICFG_INSTALLRAS)
  {
    // need PPPMAC and RNA files if using modem
    if (!ClientConfig.fRNAInstalled ||
      !ClientConfig.fPPPDriver)
    {
      if (lpfNeedComponents)
      {
        *lpfNeedComponents = TRUE;
      }
      return ERROR_SUCCESS;
    }
  }

  // need Exchange if not installed and user wants to install mail
  if ((dwfOptions & ICFG_INSTALLMAIL) &&
    (!ClientConfig.fMailInstalled || !ClientConfig.fInetMailInstalled))
  {
    if (lpfNeedComponents)
    {
      *lpfNeedComponents = TRUE;
    }
    return ERROR_SUCCESS;
  }

  //
  // ChrisK	5/8/97
  // check if we have a bound LAN adapter
  //
  if (dwfOptions & ICFG_INSTALLLAN)
  {
	  if (!ClientConfig.fNetcard ||
		  !ClientConfig.fNetcardBoundTCP)
	  {
		  if (lpfNeedComponents)
		  {
			  *lpfNeedComponents = TRUE;
		  }
		  return ERROR_SUCCESS;
	  }
  }

  //
  // ChrisK	5/8/97
  // Check if we have a bound Dial up adapter
  //
  if (dwfOptions & ICFG_INSTALLDIALUP)
  {
	  if (!ClientConfig.fPPPDriver ||
		  !ClientConfig.fPPPBoundTCP)
	  {
		  if (lpfNeedComponents)
		  {
			  *lpfNeedComponents = TRUE;
		  }
		  return ERROR_SUCCESS;
	  }
  }

  //
  // ChrisK	5/8/97
  // Check if TCP is install at all on this system
  //
  if (dwfOptions & ICFG_INSTALLTCPONLY)
  {
	  if (!ClientConfig.fTcpip)
	  {
		  if (lpfNeedComponents)
		  {
			  *lpfNeedComponents = TRUE;
		  }
		  return ERROR_SUCCESS;
	  }
  }

  // no extra drivers needed
  if (lpfNeedComponents)
  {
    *lpfNeedComponents = FALSE;
  }
  return ERROR_SUCCESS;
}


//*******************************************************************
//
//  FUNCTION:   IcfgInstallInetComponents
//
//  PURPOSE:    Install the specified system components.
//
//  PARAMETERS: hwndParent - Parent window handle.
//              dwfOptions - a combination of ICFG_ flags that controls
//              the installation and configuration as follows:
//
//                ICFG_INSTALLTCP - install TCP/IP (if needed)
//                ICFG_INSTALLRAS - install RAS (if needed)
//                ICFG_INSTALLMAIL - install exchange and internet mail
//              
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart)
{
  RETERR err;
  DWORD dwFiles = 0;
  BOOL  fInitNetMAC = FALSE;
  BOOL  fNeedTCPIP=FALSE;
  BOOL  fNeedPPPMAC=FALSE;
  BOOL  fNeedToRemoveTCPIP=FALSE;
  BOOL  fNeedReboot = FALSE;
  DWORD dwErrCls;
  CLIENTCONFIG  ClientConfig;

  DEBUGMSG("cfgapi.c::IcfgInstallInetComponents()");

  // read client configuration
  ZeroMemory(&ClientConfig,sizeof(CLIENTCONFIG));
  err=GetConfig(&ClientConfig,&dwErrCls);
  if (err != OK)
  {
    LoadSz(IDS_ERRReadConfig, gpszLastErrorText, MAX_ERROR_TEXT);
    return err;
  }

  // see if we initially have any kind of net card
  fInitNetMAC = (ClientConfig.fNetcard | ClientConfig.fPPPDriver);

  // install files we need

  // install mail if user wants it and not already installed
  if (dwfOptions & ICFG_INSTALLMAIL)
  {
    // need mail files (capone)? 
    if (!ClientConfig.fMailInstalled)
    {
      DEBUGMSG("Installing Exchange files");
      dwFiles |= ICIF_MAIL;
    }

    // need internet mail files (rt 66)?
    if (!ClientConfig.fInetMailInstalled)
    {
      DEBUGMSG("Installing Internet Mail files");
      dwFiles |= ICIF_INET_MAIL;
    }
  }

  // check if we are allowed to install RNA
  if (dwfOptions & ICFG_INSTALLRAS)
  {
    // install RNA if user is connecting over modem and RNA
    // not already installed
    if (!ClientConfig.fRNAInstalled)
    {
      DEBUGMSG("Installing RNA files");
      dwFiles |= ICIF_RNA;
    }
  }

  if (dwFiles)
  {
    {
      WAITCURSOR WaitCursor;  // show hourglass
      // install the component files
      err = InstallComponent(hwndParent,IC_INSTALLFILES,
        dwFiles);
      if (err == NEED_RESTART)
      {
        DEBUGMSG("Setting restart flag");
        // set restart flag so we restart the system at end
        fNeedReboot = TRUE;
        // NEED_REBOOT also implies success, so set ret code to OK
        err = OK;
      }

      // force an update of the dialog
      if (hwndParent)
      {
        HWND hParent = GetParent(hwndParent);
        UpdateWindow(hParent ? hParent : hwndParent);
      }

      // runonce.exe may get run at next boot, twiddle the
      // registry to work around a bug where it trashes the wallpaper
      PrepareForRunOnceApp();
    }

    if (err != OK)
    {
      LoadSz(IDS_ERRInstallFiles, gpszLastErrorText, MAX_ERROR_TEXT);
      return err;
    }

    WAITCURSOR WaitCursor;  // show hourglass

    // do some extra stuff if we just installed mail
    if (dwFiles & ICIF_MAIL)
    {
      // .inf file leaves an entry in the registry to run
      // MS Exchange wizard, which we don't need since we'll be
      // configuring exchange ourselves.  Remove the registry
      // entry.
      RemoveRunOnceEntry(IDS_MAIL_WIZARD_REG_VAL);

      // run mlset32, Exchange setup app that it needs to have run.
      // need to display error if this fails, this is fairly important.
      err=RunMlsetExe(hwndParent);
      if (err != ERROR_SUCCESS)
      {
        LoadSz(IDS_ERRInstallFiles, gpszLastErrorText, MAX_ERROR_TEXT);
        return err;
      }
    }

    // run the group converter to put the Inbox icon on desktop,
    // put Exchange, RNA et al on start menu
    CHAR szExecGrpconv[SMALL_BUF_LEN],szParam[SMALL_BUF_LEN];
    LoadSz(IDS_EXEC_GRPCONV,szExecGrpconv,sizeof(szExecGrpconv));
    LoadSz(IDS_EXEC_GRPCONV_PARAM,szParam,sizeof(szParam));
    ShellExecute(NULL,NULL,szExecGrpconv,szParam,NULL,SW_SHOW);

  }

  // only install PPPMAC if we are allowed to install RNA
  if (dwfOptions & ICFG_INSTALLRAS)
  {
    // install PPPMAC if not already installed
    // Note that we have to install PPPMAC *before* TCP/IP, to work
    // in the case where the user has no net installed to start with.
    // Otherwise when we install TCP/IP, user gets prompted by net setup
    // for their net card; net setup doesn't like the idea of TCP/IP lying
    // around without something to bind it to.
    fNeedPPPMAC = (!ClientConfig.fPPPDriver);
    if (fNeedPPPMAC)
    {
      DEBUGMSG("Installing PPPMAC");

      // make up a computer and workgroup name if not already set, so
      // user doesn't get prompted
      GenerateComputerNameIfNeeded();
      
      err = InstallPPPMAC(hwndParent);

      //  96/05/20  markdu  MSN  BUG 8551 Check for reboot when installing PPPMAC.

	  //
	  // ChrisK 5/29/97 Olympus 4692
	  // Even if we just rebind PPPMAC we still need to restart the machine.
	  //
      if (err == NEED_RESTART || err == OK)
      {
        // set restart flag so we restart the system at end
        DEBUGMSG("Setting restart flag");
        fNeedReboot = TRUE;

        // NEED_REBOOT also implies success, so set ret code to OK
        err = OK;
      }

      if (err != OK)
      {
        LoadSz(IDS_ERRInstallPPPMAC, gpszLastErrorText, MAX_ERROR_TEXT);
        return err;
      }

      // when we install PPPMAC, if there is another net card then PPPMAC
      // will automatically "grow" all the protocols that were bound to the
      // net card.  Strip these off... (netbeui and IPX)
      RETERR errTmp = RemoveProtocols(hwndParent,INSTANCE_PPPDRIVER,
        PROT_NETBEUI | PROT_IPX);
      ASSERT(errTmp == OK);
    }
  }

  // check if we are allowed to install TCP/IP
  if (dwfOptions & ICFG_INSTALLTCP)
  {
      CLIENTCONFIG  newClientConfig;

      // read the client configuration again, since installing PPP might have
      // installed TCP/IP
      ZeroMemory(&newClientConfig,sizeof(CLIENTCONFIG));
      DWORD dwErrCls;
      UINT err=GetConfig(&newClientConfig,&dwErrCls);
      if (err != OK)
      {
        LoadSz(IDS_ERRReadConfig, gpszLastErrorText, MAX_ERROR_TEXT);
        return err;
      }
  
     // figure out if we need to install TCP/IP
     // BUGBUG - only put TCP/IP on appropriate type of card (net card
     // or PPP adapter)
     // user is connecting via modem, need TCP if not already present
     // and bound to PPPMAC.  Want to bind to PPP adapters,
    fNeedTCPIP = !newClientConfig.fPPPBoundTCP;
    if (fNeedTCPIP && newClientConfig.fNetcard &&
      !newClientConfig.fNetcardBoundTCP)
    {
      // if we have to add TCP to PPP driver, then check if TCP is already
      // on netcard.  If not, then TCP is going to glom on to netcard as
      // well as PPP driver when we install it, need to remove it from
      // netcard later.
      fNeedToRemoveTCPIP= TRUE;
    }

    // special case: if there were any existing instances of TCP/IP and
    // we just added PPPMAC then we don't need to install TCP/IP --
    // when the PPPMAC adapter got added it automatically gets an instance
    // of all installed protocols (incl. TCP/IP) created for it
    if (newClientConfig.fTcpip && fNeedPPPMAC)
    {
      fNeedTCPIP = FALSE;
    }
  } // if (dwfOptions & ICFG_INSTALLTCP)

  // install TCP/IP if necessary
  if (fNeedTCPIP)
  {
    DEBUGMSG("Installing TCP/IP");
    // call out to device manager to install TCP/IP
    err = InstallTCPIP(hwndParent);      

    //  96/05/20  markdu  MSN  BUG 8551 Check for reboot when installing TCP/IP.
    if (err == NEED_RESTART)
    {
      // NEED_REBOOT also implies success, so set ret code to OK
      // Reboot flag is set below ALWAYS.  Should really be set here,
      // but we don't want to suddenly stop rebooting in cases
      // where we used to reboot, even if not needed.
      err = OK;
    }

     if (err != OK)
     {
      LoadSz(IDS_ERRInstallTCPIP, gpszLastErrorText, MAX_ERROR_TEXT);
      return err;
    }

    if (fNeedToRemoveTCPIP)
    {
      // remove TCPIP that may have glommed onto net drivers other
      // than the one we intend it for
      UINT uErrTmp;
      uErrTmp=RemoveProtocols(hwndParent,INSTANCE_NETDRIVER,PROT_TCPIP);
      ASSERT(uErrTmp == OK);
    }

    DEBUGMSG("Setting restart flag");
    // set restart flag so we restart the system at end
    fNeedReboot = TRUE;
  }

  // if we just installed TCP/IP or PPPMAC, then adjust bindings 
  if (fNeedPPPMAC || fNeedTCPIP)
  {
    UINT uErrTmp;

    // if file sharing (vserver) is installed, TCP/IP will bind
    // to it by default.  This is bad, user could be sharing
    // files to Internet without knowing it.  Unbind VSERVER
    // from TCP/IP instances that may used to connect to Internet
    // (instances of type INSTANCE_PPPDRIVER)
    uErrTmp = IcfgTurnOffFileSharing(INSTANCE_PPPDRIVER, hwndParent);
    ASSERT (uErrTmp == ERROR_SUCCESS);

    // unbind TCP/IP from VREDIR, if bound on this card type
    BOOL fBound;
    uErrTmp = DetectModifyTCPIPBindings(INSTANCE_PPPDRIVER,szVREDIR,
      TRUE,&fBound);
    ASSERT(uErrTmp == ERROR_SUCCESS);
  }

  // refresh the client configuration info
  err = GetConfig(&ClientConfig,&dwErrCls);
  if (err != OK)
  {
    LoadSz(IDS_ERRReadConfig, gpszLastErrorText, MAX_ERROR_TEXT);
    return err;
  }

  // do some special handling if there were *no* netcard devices
  // (net cards or PPP drivers) initially installed
  if (!fInitNetMAC)
  {
    ASSERT(fNeedPPPMAC);  // should have just installed PPPMAC

    // net setup adds some extra net components "by default" when
    // we add PPPMAC and there are no net card devices, go kill them
    // off.
    RETERR reterr = RemoveUnneededDefaultComponents(hwndParent);
    ASSERT(reterr == OK);

    // since there were no net card devices to begin with, we need
    // to restart the system later.  (the NDIS VxD is a static VxD
    // which needs to run, only gets added when you install a net card.)

    DEBUGMSG("Setting restart flag");
    // set restart flag so we restart the system at end
    fNeedReboot = TRUE;
  }

  // tell caller whether we need to reboot or not
  if (lpfNeedsRestart)
  {
    *lpfNeedsRestart = fNeedReboot;
  }
  return ERROR_SUCCESS;
}


/*******************************************************************

  NAME:    GetConfig

  SYNOPSIS:  Retrieves client configuration

********************************************************************/
UINT GetConfig(CLIENTCONFIG * pClientConfig,DWORD * pdwErrCls)
{
  ASSERT(pClientConfig);
  ASSERT(pdwErrCls);

  // get most the client configuration from 16-bit dll
  UINT uRet = GetClientConfig(pClientConfig);
  if (uRet != OK) {
    // GetClientConfig returns SETUPX error codes
    *pdwErrCls = ERRCLS_SETUPX;
  } 

  return uRet;
}

//*******************************************************************
//
//  FUNCTION:   IcfgStartServices
//
//  PURPOSE:    This is a NOP designed to maintain parity with the NT
//              version (icfgnt.dll).
//
//  PARAMETERS: none
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT IcfgStartServices()
{
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\cfgtcp.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  TCPCFG.C - Functions to read and set TCP/IP configuration
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#include "pch.hpp"
// function prototypes
UINT DetectModifyTCPIPBindings(DWORD dwCardFlags,LPCSTR pszBoundTo,BOOL fRemove,BOOL * pfBound);

//*******************************************************************
//              
//  FUNCTION:   IcfgIsGlobalDNS
//
//  PURPOSE:    Determines whether there is Global DNS set.
//
//  PARAMETERS: lpfGlobalDNS - TRUE if global DNS is set, FALSE otherwise.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and 
//              should always return ERROR_SUCCESS and set lpfGlobalDNS
//              to FALSE in Windows NT.
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS)
{
  CHAR szDNSEnabled[2];    // big enough for "1"
  BOOL fGlobalDNS = FALSE;

  // open the global TCP/IP key
  RegEntry reTcp(szTCPGlobalKeyName,HKEY_LOCAL_MACHINE);
  HRESULT hr = reTcp.GetError();
  if (hr == ERROR_SUCCESS)
  {
    // read the registry value to see if DNS is enabled
    reTcp.GetString(szRegValEnableDNS,szDNSEnabled,sizeof(szDNSEnabled));
    hr = reTcp.GetError();
    if ((hr == ERROR_SUCCESS) && (!lstrcmpi(szDNSEnabled,sz1)))
    {
      // DNS is enabled
      fGlobalDNS = TRUE;
    }
  }

  if (NULL != lpfGlobalDNS)
  {
    *lpfGlobalDNS = fGlobalDNS;
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   IcfgRemoveGlobalDNS
//
//  PURPOSE:    Removes global DNS info from registry.
//
//  PARAMETERS: None.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and 
//              should always return ERROR_SUCCESS in Windows NT.
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgRemoveGlobalDNS(void)
{
  HRESULT hr = ERROR_SUCCESS;

  // open the global TCP/IP key
  RegEntry reTcp(szTCPGlobalKeyName,HKEY_LOCAL_MACHINE);
  hr = reTcp.GetError();
  ASSERT(hr == ERROR_SUCCESS);

  if (ERROR_SUCCESS == hr)
  {
    // no name servers; disable DNS.  Set registry switch to "0".
    hr = reTcp.SetValue(szRegValEnableDNS,sz0);
    ASSERT(hr == ERROR_SUCCESS);
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   IcfgIsFileSharingTurnedOn
//
//  PURPOSE:    Determines if file server (VSERVER) is bound to TCP/IP
//              for specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to check server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP	- PPPMAC
//
//              lpfSharingOn - TRUE if bound once or more, FALSE if not bound
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgIsFileSharingTurnedOn(DWORD dwfDriverType, LPBOOL lpfSharingOn)
{
  BOOL fBound = FALSE;

  ASSERT(lpfSharingOn);

  // call worker function
  HRESULT hr = DetectModifyTCPIPBindings(dwfDriverType,szVSERVER,FALSE,&fBound);

  if (NULL != lpfSharingOn)
  {
    *lpfSharingOn = fBound;
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   IcfgTurnOffFileSharing
//
//  PURPOSE:    Unbinds file server (VSERVER) from TCP/IP for 
//              specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to remove server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP	- PPPMAC
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgTurnOffFileSharing(DWORD dwfDriverType, HWND hwndParent)
{
  BOOL fBound;

  // call worker function
  return DetectModifyTCPIPBindings(dwfDriverType,szVSERVER,TRUE,&fBound);

}


/*******************************************************************

  NAME:    DetectModifyTCPIPBindings

  SYNOPSIS:  Finds (and optionally removes) bindings between
        VSERVER and TCP/IP for TCP/IP instances on a particular
        card type.

  ENTRY:    dwCardFlags - an INSTANCE_xxx flag to specify what
          card type to find/remove server-TCP/IP bindings for
        pszBoundTo - name of component to look for or modify bindings
          to.  Can be VSERVER or VREDIR
        fRemove - if TRUE, all bindings are removed as we find them.
          If FALSE, bindings are left alone but *pfBound is set
          to TRUE if bindings exist.
        pfBound - pointer to BOOL to be filled in

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    Worker function for TurnOffFileSharing and IsFileSharingTurnedOn

********************************************************************/
UINT DetectModifyTCPIPBindings(DWORD dwCardFlags,LPCSTR pszBoundTo,
  BOOL fRemove,BOOL * pfBound)
{
  ASSERT(pfBound);
  *pfBound = FALSE;  // assume not bound until proven otherwise

  ENUM_TCP_INSTANCE EnumTcpInstance(dwCardFlags,NT_ENUMNODE);

  UINT err = EnumTcpInstance.GetError();
  if (err != ERROR_SUCCESS)
    return err;

  HKEY hkeyInstance = EnumTcpInstance.Next();

  // for every TCP/IP node in enum branch, look at bindings key.
  // Scan the bindings (values in bindings key), if they begin
  // with the string pszBoundTo ("VSERVER" or "VREDIR") then
  // the binding exists.

  while (hkeyInstance) {
    // open bindings key
    RegEntry reBindings(szRegKeyBindings,hkeyInstance);
    ASSERT(reBindings.GetError() == ERROR_SUCCESS);
    if (reBindings.GetError() == ERROR_SUCCESS) {
      RegEnumValues * preBindingVals = new RegEnumValues(&reBindings);
      ASSERT(preBindingVals);
      if (!preBindingVals)
        return ERROR_NOT_ENOUGH_MEMORY;
  
      // enumerate binding values
      while (preBindingVals->Next() == ERROR_SUCCESS) {
        ASSERT(preBindingVals->GetName()); // should always have a valid ptr
        
        // does this binding begin with the string we were passed in
        // pszBoundTo

        CHAR szBindingVal[SMALL_BUF_LEN+1];
        DWORD dwBoundToLen = lstrlen(pszBoundTo);
        lstrcpy(szBindingVal,preBindingVals->GetName());
        if (((DWORD)lstrlen(szBindingVal)) >= dwBoundToLen) {
          // NULL-terminate the copy at the appropriate place
          // so we can do a strcmp rather than a strncmp, which
          // would involve pulling in C runtime or implementing
          // our own strncmp
          szBindingVal[dwBoundToLen] = '\0';
          if (!lstrcmpi(szBindingVal,pszBoundTo)) {

            *pfBound = TRUE;
            // remove the binding if specified by caller
            if (fRemove) {
              // delete the value
              reBindings.DeleteValue(preBindingVals->GetName());

              // destroy and reconstruct RegEnumValues object, otherwise
              // RegEnumValues api gets confused because we deleted a
              // value during enum
              delete preBindingVals;
              preBindingVals = new RegEnumValues(&reBindings);
              ASSERT(preBindingVals);
              if (!preBindingVals)
                return ERROR_NOT_ENOUGH_MEMORY;
            } else {
              // caller just wants to know if binding exists, we
              // filled in pfBound above so we're done
              return ERROR_SUCCESS;
            }
          }
        }
      }
    }
    hkeyInstance = EnumTcpInstance.Next();
  }

  return ERROR_SUCCESS;
}


/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::ENUM_TCP_INSTANCE

  SYNOPSIS:  Constructor for class to enumerate TCP/IP registry nodes
        according to type of card they are bound to

  ENTRY:    dwCardFlags - combination of INSTANCE_x flags indicating
          what kind of card to enumerate instances for
        dwNodeFlags  - combination of NT_ flags indicating what
          type of node to return (driver node, enum node)

********************************************************************/
ENUM_TCP_INSTANCE::ENUM_TCP_INSTANCE(DWORD dwCardFlags,DWORD dwNodeFlags) :
  _dwCardFlags (dwCardFlags), _dwNodeFlags (dwNodeFlags)
{
  _hkeyTcpNode = NULL;
  _error = ERROR_SUCCESS;

  // init/reset netcard enumeration
  BeginNetcardTCPIPEnum();
}

/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::~ENUM_TCP_INSTANCE

  SYNOPSIS:  Destructor for class

********************************************************************/
ENUM_TCP_INSTANCE::~ENUM_TCP_INSTANCE()
{
  // close current TCP node key, if any
  CloseNode();
}

/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::Next

  SYNOPSIS:  Enumerates next TCP/IP driver node

  EXIT:    Returns an open registry key handle, or NULL if
        no more nodes.

  NOTES:    Caller should not close the HKEY that is returned.  This
        HKEY will be valid until the next time the Next() method
        is called or until the object is destructed.

********************************************************************/
HKEY ENUM_TCP_INSTANCE::Next()
{
  CHAR  szSubkeyName[MAX_PATH+1];

  // close current TCP node key, if any
  CloseNode();

  while (_error == ERROR_SUCCESS) {
    CHAR szInstancePath[SMALL_BUF_LEN+1];
    CHAR szDriverPath[SMALL_BUF_LEN+1];

    if (!GetNextNetcardTCPIPNode(szSubkeyName,sizeof(szSubkeyName),
      _dwCardFlags))
      return NULL;  // no more nodes

    // open the enum branch, find the specified subkey
    RegEntry reEnumNet(szRegPathEnumNet,HKEY_LOCAL_MACHINE);

    // if caller wanted enum node, just open that node

    if (_dwNodeFlags & NT_ENUMNODE) {
    
      _error = RegOpenKey(reEnumNet.GetKey(),szSubkeyName,
        &_hkeyTcpNode);
      // return open key
      return _hkeyTcpNode;

    } else {
      // from enum node, figure out path to driver node
      
      reEnumNet.MoveToSubKey(szSubkeyName);
      if (reEnumNet.GetError() != ERROR_SUCCESS)
        continue;
      // find the driver path to the driver node
      if (!reEnumNet.GetString(szRegValDriver,szDriverPath,
        sizeof(szDriverPath))) {
         ASSERTSZ(FALSE,"No driver path in enum branch for TCP/IP instance");
        continue;  
      }

      // build the path to registry node for this instance
      lstrcpy(szInstancePath,szRegPathClass);
      lstrcat(szInstancePath,szDriverPath);

      _error = RegOpenKey(HKEY_LOCAL_MACHINE,szInstancePath,
        &_hkeyTcpNode);
      // return open key
      return _hkeyTcpNode;
    }
  }

  // ran through all net cards of specified type w/o finding TCP/IP bound
  _error = ERROR_NO_MORE_ITEMS;
  return NULL;
}

/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::CloseNode

  SYNOPSIS:  Private worker function to close TCP/IP node handle

********************************************************************/
VOID ENUM_TCP_INSTANCE::CloseNode()
{
  if (_hkeyTcpNode) {
    RegCloseKey(_hkeyTcpNode);
    _hkeyTcpNode = NULL;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\cfgdll.cpp ===
/*****************************************************************/
/**          Microsoft Windows for Workgroups        **/
/**          Copyright (C) Microsoft Corp., 1991-1992      **/
/*****************************************************************/ 

//
//  CFGDLL.C - 32-bit stubs for functions that call into 16-bit DLL
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//  96/05/27  markdu  Initialize and destroy gpszLastErrorText.
//

#include "pch.hpp"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)
HINSTANCE ghInstance=NULL;
LPSTR gpszLastErrorText=NULL;
#pragma data_seg(DATASEG_DEFAULT)

typedef UINT RETERR;

// prototypes for functions we thunk to
#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  extern RETERR __stdcall GetClientConfig16(LPCLIENTCONFIG pClientConfig);
  extern UINT __stdcall InstallComponent16(HWND hwndParent,DWORD dwComponent,DWORD dwParam);
  extern RETERR __stdcall BeginNetcardTCPIPEnum16(VOID);
  extern BOOL __stdcall GetNextNetcardTCPIPNode16(LPSTR pszTcpNode,WORD cbTcpNode,
    DWORD dwFlags);
  extern VOID __stdcall GetSETUPXErrorText16(DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc);
  extern RETERR __stdcall RemoveProtocols16(HWND hwndParent,DWORD dwRemoveFromCardType,DWORD dwProtocols);
  extern RETERR __stdcall RemoveUnneededDefaultComponents16(HWND hwndParent);
  extern RETERR __stdcall DoGenInstall16(HWND hwndParent,LPCSTR lpszInfFile,LPCSTR lpszInfSect);
  extern RETERR __stdcall SetInstallSourcePath16(LPCSTR szSourcePath);

  BOOL WINAPI wizthk_ThunkConnect32(LPSTR pszDll16,LPSTR pszDll32,HINSTANCE hInst,
    DWORD dwReason);
  BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#ifdef __cplusplus
}
#endif // __cplusplus

#if defined(CMBUILD)
static const CHAR szDll16[] = "CNET16.DLL";
static const CHAR szDll32[] = "CCFG32.DLL";
#else
static const CHAR szDll16[] = "INET16.DLL";
static const CHAR szDll32[] = "ICFG32.DLL";
#endif

/*******************************************************************

  NAME:    DllEntryPoint

  SYNOPSIS:  Entry point for DLL.

  NOTES:    Initializes thunk layer to inet16.DLL

********************************************************************/
BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
  // initialize thunk layer to inet16.dll
  if (!(wizthk_ThunkConnect32((LPSTR)szDll16,(LPSTR)szDll32,hInstDll,
    fdwReason)))
    return FALSE;

  if( fdwReason == DLL_PROCESS_ATTACH )
  {
    ghInstance = hInstDll;
 
    // Allocate memory for the error message text for GetLastInstallErrorText()
    gpszLastErrorText = (LPSTR)LocalAlloc(LPTR, MAX_ERROR_TEXT);
    if (NULL == gpszLastErrorText)
    {
      return FALSE;
    }
  }


  if( fdwReason == DLL_PROCESS_DETACH )
  {
    LocalFree(gpszLastErrorText);
  }

  return TRUE;
}



/*******************************************************************

  NAME:    GetClientConfig

  SYNOPSIS:  Retrieves client software configration

  ENTRY:    pClientConfig - pointer to struct to fill in with config info

  EXIT:    returns a SETUPX error code

  NOTES:    This is just the 32-bit side wrapper, thunks to GetClientConfig16
        to do real work.  Information needs to be obtained from
        setupx.dll, which is 16-bit.

********************************************************************/
RETERR GetClientConfig(CLIENTCONFIG * pClientConfig)
{
  ASSERT(pClientConfig);
   
  // thunk to GetClientConfig16 to do real work

  return GetClientConfig16(pClientConfig);
}

/*******************************************************************

  NAME:    InstallComponent

  SYNOPSIS:  Installs the specified component

  ENTRY:    dwComponent - ordinal of component to install
        (IC_xxx, defined in wizglob.h)
        dwParam - component-specific parameters, defined in wizglob.h

  EXIT:    returns ERROR_SUCCESS if successful, or a standard error code

  NOTES:    This is just the 32-bit side wrapper, thunks to InstallComponent16
        to do real work.

********************************************************************/
UINT InstallComponent(HWND hwndParent,DWORD dwComponent,DWORD dwParam)
{
  // thunk to InstallComponent16 to do real work

  return InstallComponent16(hwndParent,dwComponent,dwParam);
}


/*******************************************************************

  NAME:    BeginNetcardTCPIPEnum16Enum

  SYNOPSIS:  Begins an enumeration of netcard TCP/IP nodes

  NOTES:    Subsequent calls to GetNextNetcardTCPIPNode16 will
        enumerate TCP/IP nodes

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR BeginNetcardTCPIPEnum(VOID)
{
  return BeginNetcardTCPIPEnum16();
}

/*******************************************************************

  NAME:    GetNextNetcardTCPIPNode16

  SYNOPSIS:  Enumerates the next TCP/IP node of specified type

  ENTRY:    pszTcpNode - pointer to buffer to be filled in with
          node subkey name
        cbTcpNode - size of pszTcpNode buffer
        dwFlags - some combination of INSTANCE_ flags
          indicating what kind of instance to enumerate

  EXIT:    returns TRUE if a TCPIP node was enumerated,
        FALSE if no more nodes to enumerate

  NOTES:    BeginNetcardTCPIPEnum16 must be called before each
        enumeration to start at the beginning of the list.

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
BOOL GetNextNetcardTCPIPNode(LPSTR pszTcpNode,WORD cbTcpNode, DWORD dwFlags)
{
  return GetNextNetcardTCPIPNode16(pszTcpNode,cbTcpNode,dwFlags);
}


/*******************************************************************

  NAME:    GetSETUPXErrorText

  SYNOPSIS:  Gets text corresponding to SETUPX error code

  ENTRY:    dwErr - error to get text for
        pszErrorDesc - pointer to buffer to fill in with text
        cbErrorDesc - size of pszErrorDesc buffer

  NOTES:    This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
extern "C" VOID GetSETUPXErrorText(DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc)
{
  GetSETUPXErrorText16(dwErr,pszErrorDesc,cbErrorDesc);
}

/*******************************************************************

  NAME:    RemoveUnneededDefaultComponents

  SYNOPSIS:  Removes network components that we don't need which
        are installed by default when an adapter is added
        to a no-net system.

  NOTES:    Removes: vredir, nwredir, netbeui, ipx
        
        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR RemoveUnneededDefaultComponents(HWND hwndParent)
{
  return RemoveUnneededDefaultComponents16(hwndParent);
}

/*******************************************************************

  NAME:    RemoveProtocols

  SYNOPSIS:  Removes specified protocols from card of specified type

  NOTES:    This function is useful because if user has a net card
        and we add PPPMAC, all the protocols that were bound
        to the net card appear on PPPMAC.  We need to go through
        and strip them off.

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR RemoveProtocols(HWND hwndParent,DWORD dwRemoveFromCardType,DWORD dwProtocols)
{
  return RemoveProtocols16(hwndParent,dwRemoveFromCardType,dwProtocols);
}

/*******************************************************************

  NAME:    DoGenInstall

  SYNOPSIS:  Calls GenInstall to do file copies, registry entries,
        etc. in specified .inf file and section.

  ENTRY:    hwndParent - parent window
        lpszInfFile - name of .inf file.
        lpszInfSect - name of section in .inf file.

  EXIT:    returns OK, or a SETUPX error code.

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR DoGenInstall(HWND hwndParent,LPCSTR lpszInfFile,LPCSTR lpszInfSect)
{
  return DoGenInstall16(hwndParent,lpszInfFile,lpszInfSect);
}


//*******************************************************************
//
//  FUNCTION:   IcfgSetInstallSourcePath
//
//  PURPOSE:    Sets the path where windows looks when installing files.
//
//  PARAMETERS: lpszSourcePath - full path of location of files to install.
//              If this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgSetInstallSourcePath(LPCSTR lpszSourcePath)
{
  // thunk to InstallComponent16 to do real work

  return SetInstallSourcePath16(lpszSourcePath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\clsutil.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CLSUTIL.C - some small, useful C++ classes to wrap memory allocation,
//        registry access, etc.
//

//  HISTORY:
//  
//  12/07/94  jeremys Borrowed from WNET common library
//  96/05/22  markdu  Borrowed (from inetcfg.dll)
//

#include "pch.hpp"

BOOL BUFFER::Alloc( UINT cbBuffer )
{
  _lpBuffer = (LPSTR)::GlobalAlloc(GPTR,cbBuffer);
  if (_lpBuffer != NULL) {
    _cb = cbBuffer;
    return TRUE;
  }
  return FALSE;
}

BOOL BUFFER::Realloc( UINT cbNew )
{
  LPVOID lpNew = ::GlobalReAlloc((HGLOBAL)_lpBuffer, cbNew,
    GMEM_MOVEABLE | GMEM_ZEROINIT);
  if (lpNew == NULL)
    return FALSE;

  _lpBuffer = (LPSTR)lpNew;
  _cb = cbNew;
  return TRUE;
}

BUFFER::BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
  _lpBuffer( NULL )
{
  if (cbInitial)
    Alloc( cbInitial );
}

BUFFER::~BUFFER()
{
  if (_lpBuffer != NULL) {
    GlobalFree((HGLOBAL) _lpBuffer);
    _lpBuffer = NULL;
  }
}

BOOL BUFFER::Resize( UINT cbNew )
{
  BOOL fSuccess;

  if (QuerySize() == 0)
    fSuccess = Alloc( cbNew );
  else {
    fSuccess = Realloc( cbNew );
  }
  if (fSuccess)
    _cb = cbNew;
  return fSuccess;
}

RegEntry::RegEntry(const char *pszSubKey, HKEY hkey)
{
  _error = RegCreateKey(hkey, pszSubKey, &_hkey);
  if (_error) {
    bhkeyValid = FALSE;
  }
  else {
    bhkeyValid = TRUE;
  }
}

RegEntry::~RegEntry()
{ 
    if (bhkeyValid) {
        RegCloseKey(_hkey); 
    }
}

long RegEntry::SetValue(const char *pszValue, const char *string)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
            (unsigned char *)string, sizeof(TCHAR)*(lstrlen(string)+1));
    }
  return _error;
}

long RegEntry::SetValue(const char *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
            (unsigned char *)&dwNumber, sizeof(dwNumber));
    }
  return _error;
}

long RegEntry::DeleteValue(const char *pszValue)
{
    if (bhkeyValid) {
      _error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
  }
  return _error;
}


char *RegEntry::GetString(const char *pszValue, char *string, unsigned long length)
{
  DWORD   dwType = REG_SZ;
  
    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
            &length);
    }
  if (_error) {
    *string = '\0';
     return NULL;
  }

  return string;
}

long RegEntry::GetNumber(const char *pszValue, long dwDefault)
{
   DWORD   dwType = REG_BINARY;
   long  dwNumber = 0L;
   DWORD  dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
            &dwSize);
  }
  if (_error)
    dwNumber = dwDefault;
  
  return dwNumber;
}

long RegEntry::MoveToSubKey(const char *pszSubKeyName)
{
    HKEY  _hNewKey;

    if (bhkeyValid) {
        _error = RegOpenKey ( _hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (_error == ERROR_SUCCESS) {
            RegCloseKey(_hkey);
            _hkey = _hNewKey;
        }
    }

  return _error;
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
      _error = RegFlushKey(_hkey);
    }
  return _error;
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    _error = pRegEntry->GetError();
    if (_error == ERROR_SUCCESS) {
        _error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new CHAR[cMaxValueName];
            if (!pchName) {
                _error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        _error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete pchName;
    delete pbValue;
}

long RegEnumValues::Next()
{
    if (_error != ERROR_SUCCESS) {
        return _error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    _error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return _error;
}

int __cdecl _purecall(void)
{
   return(0);
}

void * _cdecl operator new(unsigned int size)
{
  return (void *)::GlobalAlloc(GPTR,size); 
}

void _cdecl operator delete(void *ptr)
{
  GlobalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\debug.cpp ===
// ############################################################################
// Debugging routines

#include "pch.hpp"

BOOL fInAssert=FALSE;

// ############################################################################
// DebugSz
//
// This function outputs debug string
// 
//  Created 1/28/96,		Chris Kauffman
// ############################################################################
void DebugSz(PCSTR psz)
{
	OutputDebugString(psz);
} // DebugSz

// ############################################################################
// Debug Printf to debug output screen
void Dprintf(PCSTR pcsz, ...)
{
#ifdef DEBUG
	va_list	argp;
	char	szBuf[1024];
	
	va_start(argp, pcsz);

	wvsprintf(szBuf, pcsz, argp);

	DebugSz(szBuf);
	va_end(argp);
#endif
} // Dprintf()

// ############################################################################
// Handle asserts
BOOL FAssertProc(PCSTR szFile,  DWORD dwLine, PCSTR szMsg, DWORD dwFlags)
{
	char szMsgEx[1024], szTitle[255], szFileName[MAX_PATH];
	int id;
	UINT fuStyle;
	BOOL fAssertIntoDebugger = FALSE;
	LPTSTR pszCommandLine = GetCommandLine();
	HANDLE	hAssertTxt;
	//BYTE	szTime[80];
	CHAR	szTime[80];
	SYSTEMTIME st;
	DWORD	cbWritten;
	
	// no recursive asserts
	if (fInAssert)
		{
		DebugSz("***Recursive Assert***\r\n");
		return(FALSE);
		}

	fInAssert = TRUE;
	
	GetModuleFileName(NULL, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%d\r\nProcess ID: %d %s, Thread ID: %d\r\n%s",
		szFile,dwLine,GetCurrentProcessId(),szFileName,GetCurrentThreadId(),szMsg);
	wsprintf(szTitle,"Assertion Failed");

	fuStyle = MB_APPLMODAL | MB_ABORTRETRYIGNORE;
	fuStyle |= MB_ICONSTOP;

	DebugSz(szTitle);		
	DebugSz(szMsgEx);		

	// dump the assert into ASSERT.TXT
	hAssertTxt = CreateFile("assert.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
	if (INVALID_HANDLE_VALUE != hAssertTxt) 
		{
		SetFilePointer(hAssertTxt, 0, NULL, FILE_END);
		GetLocalTime(&st);
		wsprintf(szTime, "\r\n\r\n%02d/%02d/%02d %d:%02d:%02d\r\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
		WriteFile(hAssertTxt, szTime, lstrlen(szTime), &cbWritten, NULL);
		WriteFile(hAssertTxt, szMsgEx, lstrlen(szMsgEx), &cbWritten, NULL);
		CloseHandle(hAssertTxt);
		}

    id = MessageBox(NULL, szMsgEx, szTitle, fuStyle);
    switch (id)
    	{
    	case IDABORT:
    		ExitProcess(0);
    		break;
    	case IDCANCEL:
    	case IDIGNORE:
    		break;
    	case IDRETRY:
    		fAssertIntoDebugger = TRUE;
    		break;
    	}
				
	fInAssert = FALSE;
	return(fAssertIntoDebugger);
} // AssertProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\clsutil.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CLSUTIL.H - header file for utility C++ classes
//

//  HISTORY:
//  
//  12/07/94  jeremys    Borrowed from WNET common library
//

#ifndef _CLSUTIL_H_
#define _CLSUTIL_H_

/*************************************************************************

    NAME:    BUFFER_BASE

    SYNOPSIS:  Base class for transient buffer classes

    INTERFACE:  BUFFER_BASE()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Returns TRUE if
          successful.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    None

    USES:    None

    CAVEATS:  This is an abstract class, which unifies the interface
        of BUFFER, GLOBAL_BUFFER, etc.

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created base class

**************************************************************************/

class BUFFER_BASE
{
protected:
  UINT _cb;

  virtual BOOL Alloc( UINT cbBuffer ) = 0;
  virtual BOOL Realloc( UINT cbBuffer ) = 0;

public:
  BUFFER_BASE()
    { _cb = 0; }  // buffer not allocated yet
  ~BUFFER_BASE()
    { _cb = 0; }  // buffer size no longer valid
  BOOL Resize( UINT cbNew );
  UINT QuerySize() const { return _cb; };
};

#define GLOBAL_BUFFER  BUFFER

/*************************************************************************

    NAME:    BUFFER

    SYNOPSIS:  Wrapper class for new and delete

    INTERFACE:  BUFFER()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Only works if the
          buffer hasn't been allocated yet.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    BUFFER_BASE

    USES:    operator new, operator delete

    CAVEATS:

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created

**************************************************************************/

class BUFFER : public BUFFER_BASE
{
protected:
  CHAR *_lpBuffer;

  virtual BOOL Alloc( UINT cbBuffer );
  virtual BOOL Realloc( UINT cbBuffer );

public:
  BUFFER( UINT cbInitial=0 );
  ~BUFFER();
  BOOL Resize( UINT cbNew );
  CHAR * QueryPtr() const { return (CHAR *)_lpBuffer; }
  operator CHAR *() const { return (CHAR *)_lpBuffer; }
};

class RegEntry
{
  public:
    RegEntry(const char *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
    ~RegEntry();
    
    long  GetError()  { return _error; }
    long  SetValue(const char *pszValue, const char *string);
    long  SetValue(const char *pszValue, unsigned long dwNumber);
    char *  GetString(const char *pszValue, char *string, unsigned long length);
    long  GetNumber(const char *pszValue, long dwDefault = 0);
    long  DeleteValue(const char *pszValue);
    long  FlushKey();
        long    MoveToSubKey(const char *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; }

  private:
    HKEY  _hkey;
    long  _error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
  public:
    RegEnumValues(RegEntry *pRegEntry);
    ~RegEnumValues();
    long  Next();
    char *  GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}
    long  GetError()  { return _error; }

  private:
        RegEntry * pRegEntry;
    DWORD   iEnum;
        DWORD   cEntries;
    CHAR *  pchName;
    LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    _error;
};

/*************************************************************************

    NAME:    WAITCURSOR

    SYNOPSIS:  Sets the cursor to an hourclass until object is destructed

**************************************************************************/
class WAITCURSOR
{
private:
    HCURSOR m_curOld;
    HCURSOR m_curNew;

public:
    WAITCURSOR() { m_curNew = ::LoadCursor( NULL, IDC_WAIT ); m_curOld = ::SetCursor( m_curNew ); }
    ~WAITCURSOR() { ::SetCursor( m_curOld ); }
};

#endif  // _CLSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\pch.hpp ===
#include "global.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\sources.inc ===
!IF $(386)
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\inet32

MAJORCOMP=icw
MINORCOMP=ICFG95

TARGETNAME=ICFG95
TARGETTYPE=DYNLINK
TARGETPATH=obj
DLLENTRY=DllEntryPoint
DLLBASE=$(DEFBASEADDR)
DLLDEF=..\inet32.def
NOT_LEAN_AND_MEAN=1
RCNOFONTMAP=1
C_DEFINES=-DICW32 -DNASHVILLE

USE_MSVCRT40=1

SOURCES= \
    ..\cfgdll.rc    \
    ..\callout.cpp  \
    ..\cfgapi.cpp   \
    ..\cfgdll.cpp   \
    ..\cfgtcp.cpp   \
    ..\clsutil.cpp  \
    ..\strings.cpp  \
    ..\util.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib      \
    $(SDK_LIB_PATH)\comctl32.lib      \
    $(SDK_LIB_PATH)\version.lib       \
    $(SDK_LIB_PATH)\winspool.lib      \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\thunk32.lib

i386_SOURCES = ..\wizthk.asm
386_ASMFLAGS = -DIS_32 -DMASM6 -DBUILDDLL -Sg
ASM_DEFINES = -DIS_32 -DMASM6 -DBUILDDLL -Sg

LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4231

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.hpp
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\pch.c ===
#include "global.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\global.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  GLOBAL.H - central header file for Internet config library
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#define STRICT                      // Use strict handle types
#define _SHELL32_

#ifdef DEBUG
// component name for debug spew
#define SZ_COMPNAME "ICFG32: "
#endif // DEBUG


#include <windows.h>                
#include <windowsx.h>
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "..\inc\oharestr.h"

// various RNA header files
#include <ras.h>
//#include <rnaph.h>

#include "..\inc\wizglob.h"
#include "..\inc\wizdebug.h"


#undef DATASEG_READONLY  
#define DATASEG_READONLY  ".rdata"
#include "inetcfg.h"
#include "cfgapi.h"
#include "clsutil.h"
#include "tcpcmn.h"
#include "ids.h"
#include "strings.h"

// Terminology: ISP - Internet Service Provider

// Defines
#define MAX_RES_LEN         255 // max length of string resources
#define SMALL_BUF_LEN       48  // convenient size for small text buffers

// Globals

extern HINSTANCE  ghInstance;         // global module instance handle
extern LPSTR      gpszLastErrorText;  // hold text of last error

// Defines

// error class defines for PrepareErrorMessage
#define ERRCLS_STANDARD 0x0001
#define ERRCLS_SETUPX   0x0002
#define ERRCLS_RNA      0x0003
#define ERRCLS_MAPI     0x0004

#define OK        0    // success code for SETUPX class errors

// functions in PROPMGR.C
UINT GetConfig(CLIENTCONFIG * pClientConfig,DWORD * pdwErrCls);

// functions in CALLOUT.C
UINT InstallTCPIP(HWND hwndParent);
UINT InstallPPPMAC(HWND hwndParent);

// functions in UTIL.C
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPSTR szText,UINT uIcon,UINT uButtons);
//int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...);
LPSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);
VOID _cdecl PrepareErrorMessage(UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,...);
VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass);
DWORD RunMlsetExe(HWND hwndOwner);
VOID RemoveRunOnceEntry(UINT uResourceID);
BOOL GenerateDefaultName(CHAR * pszName,DWORD cbName,CHAR * pszRegValName,
  UINT uIDDefName);
BOOL GenerateComputerNameIfNeeded(VOID);
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent);

// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.
//BOOL SetDesktopInternetIconToBrowser(VOID);

VOID PrepareForRunOnceApp(VOID);

// functions in INETAPI.C
BOOL DoDNSCheck(HWND hwndParent,BOOL * pfNeedRestart);

// functions in WIZDLL.C
RETERR   GetClientConfig(CLIENTCONFIG * pClientConfig);
UINT   InstallComponent(HWND hwndParent,DWORD dwComponent,DWORD dwParam);
RETERR   RemoveUnneededDefaultComponents(HWND hwndParent);
RETERR   RemoveProtocols(HWND hwndParent,DWORD dwRemoveFromCardType,DWORD dwProtocols);
RETERR   BeginNetcardTCPIPEnum(VOID);
BOOL  GetNextNetcardTCPIPNode(LPSTR pszTcpNode,WORD cbTcpNode,DWORD dwFlags);

// structure for getting proc addresses of api functions
typedef struct APIFCN {
  PVOID * ppFcnPtr;
  LPCSTR pszName;
} APIFCN;


#undef  DATASEG_PERINSTANCE
#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT    DATASEG_SHARED

#endif // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\i386\fltthk.inc ===
; File: fltthk.inc
;
;   Support macros and routines for the flat thunk mode of the thunk
;   compiler.
;
;   Included in *.asm files generated using the 
;   "flatthunks = true" semantic.
;





; Macro: FAPILOG16. Prints out a log message at the start of each thunk.
; Debug only.
FAPILOG16	macro	dwOffset
ifdef DEBUG
	pushd	offset FT_ThunkLogNames + dwOffset
	call	FAPILOG16_Hlp
endif ;DEBUG
endm ;FAPILOG16




ifdef DEBUG

LogApiThkLSF	proto	near stdcall, psz:dword

FAPILOG16_Hlp:
	push	ebp
	mov	ebp,[esp+8]

	invoke	LogApiThkLSF, ebp

	pop	ebp
	ret	4

endif ;DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\i386\wizthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\ids.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// string resource IDs
#define IDS_APPNAME                   1000
#define IDS_ERRFORMAT                 1001
#define IDS_EXEC_GRPCONV              1002
#define IDS_EXEC_GRPCONV_PARAM        1003
#define IDS_MAIL_WIZARD_REG_VAL       1004
#define IDS_DEF_COMPUTER_NAME         1005
#define IDS_DEF_WORKGROUP_NAME        1006
#define IDS_ERROutOfMemory            1100
#define IDS_ERRReadConfig             1101
#define IDS_ERRInstallTCPIP           1102
#define IDS_ERRInstallPPPMAC          1103
#define IDS_ERRInstallFiles           1104
#define IDS_ERRWriteDNS               1105

// dialog page IDs
//
// ChrisK 6/3/97 Olympus 5425
// Removed unused dialog
//

#define IDD_DNS_WARNING               2001

#ifdef IDC_HELP
#undef IDC_HELP
#endif

// dialog control IDs
#define IDC_UNUSED                    -1

#define IDC_DNS_WARNING_TEXT1         3000
#define IDC_DNS_WARNING_TEXT2         3001
#define IDC_DNS_WARNING_TEXT3         3002
#define IDC_DNS_WARNING_TEXT4         3003

// icon IDs
#define IDI_WORLD                     2200
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\strings.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  STRINGS.C - String literals for hard-coded strings
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)

#include "pch.hpp"

#pragma data_seg(DATASEG_READONLY)

//////////////////////////////////////////////////////
// registry strings
//////////////////////////////////////////////////////

// "Software\\Microsoft\\Windows\\CurrentVersion"
static const CHAR szRegPathSetup[] =       REGSTR_PATH_SETUP;

// "Software\\Microsoft\\Windows\\CurrentVersion\\"
static const CHAR szRegPathClass[] =       REGSTR_PATH_CLASS "\\";

// "Enum\\Network\\"
static const CHAR szRegPathEnumNet[] =      REGSTR_PATH_ENUM "\\Network\\";

// "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup"
static const CHAR szRegPathSetupRunOnce[] =   REGSTR_PATH_RUNONCE "\\Setup";

static const CHAR szRegPathSoftwareMicrosoft[]= "Software\\Microsoft";

// "RegisteredOwner"
static const CHAR szRegValOwner[] =       REGSTR_VAL_REGOWNER;

// "RegisteredOrganization"
static const CHAR szRegValOrganization[] =     REGSTR_VAL_REGORGANIZATION;

static const CHAR szRegValDriver[] =      "Driver";

// "System\\CurrentControlSet\\Services\\VxD\\MSTCP"
static const CHAR szTCPGlobalKeyName[] =     REGSTR_PATH_VXD "\\MSTCP";

// "RemoteAccess"
static const CHAR szRegKeyBindings[] =      "Bindings";
static const CHAR szRegValEnableDNS[] =     "EnableDNS";

static const CHAR szRegPathExchangeClientOpt[] = "Software\\Microsoft\\Exchange\\Client\\Options";
static const CHAR szRegValSilentRunning[] =    "SilentRunning";
static const CHAR szRegValMlSet[] =        "MlSet";

// "System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"
static const CHAR szRegPathComputerName[] =     REGSTR_PATH_COMPUTRNAME;

// "ComputerName"
static const CHAR szRegValComputerName[] =      REGSTR_VAL_COMPUTRNAME;

// "System\\CurrentControlSet\\Services\\VxD\\VNETSUP"
static const CHAR szRegPathWorkgroup[] =    REGSTR_PATH_VNETSUP;

// "Workgroup"
static const CHAR szRegValWorkgroup[] =      REGSTR_VAL_WORKGROUP;

// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.
//static const CHAR szRegPathInternetIconCommand[] = "CLSID\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}\\Shell\\Open\\Command";
static const CHAR szRegPathIexploreAppPath[] =  "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE";

// "Control Panel\\Desktop"
static const CHAR szRegPathDesktop[] =      REGSTR_PATH_DESKTOP;

// "Software\\Microsoft\\Windows\\CurrentVersion\\Setup"
static const CHAR szRegPathSetupWallpaper[] =  REGSTR_PATH_SETUP REGSTR_KEY_SETUP;

static const CHAR szRegValWallpaper[] =      "Wallpaper";
static const CHAR szRegValTileWallpaper[] =    "TileWallpaper";


//////////////////////////////////////////////////////
// misc strings
//////////////////////////////////////////////////////
static const CHAR sz0[]  =       "0";
static const CHAR sz1[]  =        "1";
static const CHAR szNull[] =       "";
static const CHAR szVSERVER[] =     "VSERVER";
static const CHAR szVREDIR[] =      "VREDIR";

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\strings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  STRINGS.H - Header file for hard-coded strings
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)

#ifndef _STRINGS_H_
#define _STRINGS_H_

// registry strings
extern const CHAR szRegPathSetup[];
extern const CHAR szRegPathClass[];
extern const CHAR szRegPathEnumNet[];
extern const CHAR szRegPathSetupRunOnce[];
extern const CHAR szRegPathSoftwareMicrosoft[];
extern const CHAR szRegValOwner[];
extern const CHAR szRegValOrganization[];
extern const CHAR szRegValDriver[];
extern const CHAR szTCPGlobalKeyName[];
extern const CHAR szRegKeyBindings[];
extern const CHAR szRegValEnableDNS[];
extern const CHAR szRegPathExchangeClientOpt[];
extern const CHAR szRegValSilentRunning[];
extern const CHAR szRegValMlSet[];
extern const CHAR szRegPathComputerName[];
extern const CHAR szRegValComputerName[];
extern const CHAR szRegPathWorkgroup[];
extern const CHAR szRegValWorkgroup[];

// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.
//extern const CHAR szRegPathInternetIconCommand[];

extern const CHAR szRegPathIexploreAppPath[];
extern const CHAR szRegPathDesktop[];
extern const CHAR szRegPathSetupWallpaper[];
extern const CHAR szRegValWallpaper[];
extern const CHAR szRegValTileWallpaper[];

// misc strings
extern const CHAR sz0[];
extern const CHAR sz1[];
extern const CHAR szNull[];
extern const CHAR szVSERVER[];
extern const CHAR szVREDIR[];

#endif // _STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\tcpcmn.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  TCPCMN.H - central header file for TCP/IP structures and configuration
//         functions
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#ifndef _TCPCMN_H_
#define _TCPCMN_H_

typedef DWORD IPADDRESS;

// same limits as in net setup UI
#define IP_ADDRESS_LEN          15    // big enough for www.xxx.yyy.zzz
#define MAX_GATEWAYS      8
#define MAX_DNSSERVER      3

// big enough for <ip>,<ip>,...
#define MAX_DNSSERVERLEN    MAX_DNSSERVER * (IP_ADDRESS_LEN+1)
#define MAX_GATEWAYLEN      MAX_GATEWAYS * (IP_ADDRESS_LEN+1)

// node type flags for _dwNodeFlags
#define NT_DRIVERNODE  0x0001
#define NT_ENUMNODE    0x0002

class ENUM_TCP_INSTANCE
{
private:
  DWORD       _dwCardFlags;  // INSTANCE_NETDRIVER, INSTANCE_PPPDRIVER, etc
  DWORD      _dwNodeFlags;  // NT_DRIVERNODE, NT_ENUMNODE, etc
  UINT       _error;
  HKEY       _hkeyTcpNode;
  VOID      CloseNode();
public:
  ENUM_TCP_INSTANCE(DWORD dwCardFlags,DWORD dwNodeFlags);
  ~ENUM_TCP_INSTANCE();
  HKEY Next();
  UINT GetError()  { return _error; }
};


#endif  // _TCPCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\i386\wizthk.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Fri Jun 21 14:07:10 1996

;Command Line: ..\..\..\..\dev\tools\binr\thunk.exe -NC _TEXT ..\wizthk.thk 

	TITLE	$..\wizthk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef AllocMappedBuffer	:near32
externDef FreeMappedBuffer		:near32
externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapLS	PROTO NEAR STDCALL :DWORD
UnMapLS	PROTO NEAR STDCALL :DWORD
MapSL	PROTO NEAR STDCALL p32:DWORD

;***************** START OF KERNEL32-ONLY SECTION ******************
; Hacks for kernel32 initialization.

IFDEF FT_DEFINEFTCOMMONROUTINES

	.data
public FT_wizthkTargetTable	;Flat address of target table in 16-bit module.

public FT_wizthkChecksum32
FT_wizthkChecksum32	dd	010e07h


ENDIF ;FT_DEFINEFTCOMMONROUTINES
;***************** END OF KERNEL32-ONLY SECTION ******************



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public wizthk_ThunkData32	;This symbol must be exported.
wizthk_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	010e07h	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_wizthk - offset wizthk_ThunkData32
	dd	offset FT_Prolog_wizthk - offset wizthk_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public wizthk_ThunkConnect32@16
wizthk_ThunkConnect32@16:
	pop	edx
	push	offset wizthk_ThkData16
	push	offset wizthk_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
wizthk_ThkData16 label byte
	db	"wizthk_ThunkData16",0


		


pfnQT_Thunk_wizthk	dd offset QT_Thunk_wizthk
pfnFT_Prolog_wizthk	dd offset FT_Prolog_wizthk
	.data
QT_Thunk_wizthk label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_wizthk label byte
	db	32 dup(0cch)	;Patch space.


	.code 




ebp_top		equ	<[ebp + 8]>	;First api parameter
ebp_retval	equ	<[ebp + -64]>	;Api return value
FT_ESPFIXUP	macro	dwSpOffset
	or	dword ptr [ebp + -20], 1 SHL ((dwSpOffset) SHR 1)
endm


ebp_qttop	equ	<[ebp + 8]>


include fltthk.inc	;Support definitions
include wizthk.inc



;************************ START OF THUNK BODIES************************




;
public GetClientConfig16@4
GetClientConfig16@4:
	FAPILOG16	212
	mov	cx, (1 SHL 10) + (0 SHL 8) + 8
; GetClientConfig16(16) = GetClientConfig16(32) {}
;
; dword ptr [ebp+8]:  pClientConfig
;
public IIGetClientConfig16@4
IIGetClientConfig16@4:
	call	dword ptr [pfnFT_Prolog_wizthk]
	sub	esp,24
	mov	esi,[ebp+8]
	or	esi,esi
	jnz	L0
	push	esi
	jmp	L1
L0:
	lea	edi,[ebp-88]
	push	edi	;pClientConfig: lpstruct32->lpstruct16
	or	dword ptr [ebp-20],01h	;Set flag to fixup ESP-rel argument.
	mov	ecx,12
@@:
	lodsd
	stosw
	loop	@B
L1:
	call	FT_Thunk
	movzx	ebx,ax
	mov	edi,[ebp+8]
	or	edi,edi
	jz	L2
	lea	esi,[ebp-88]	;pClientConfig  Struct16->Struct32
	mov	ecx,12
@@:
	lodsw
	cwde
	stosd
	loop	@B
L2:
	jmp	FT_Exit4





;
public BeginNetcardTCPIPEnum16@0
BeginNetcardTCPIPEnum16@0:
	FAPILOG16	161
	mov	cl,6
; BeginNetcardTCPIPEnum16(16) = BeginNetcardTCPIPEnum16(32) {}
;
;
public IIBeginNetcardTCPIPEnum16@0
IIBeginNetcardTCPIPEnum16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	leave
	retn





;
public GetNextNetcardTCPIPNode16@12
GetNextNetcardTCPIPNode16@12:
	FAPILOG16	131
	mov	cl,5
; GetNextNetcardTCPIPNode16(16) = GetNextNetcardTCPIPNode16(32) {}
;
; dword ptr [ebp+8]:  pszTcpNode
; dword ptr [ebp+12]:  cbTcpNode
; dword ptr [ebp+16]:  dwFlags
;
public IIGetNextNetcardTCPIPNode16@12
IIGetNextNetcardTCPIPNode16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	push	word ptr [ebp+12]	;cbTcpNode: dword->word
	push	dword ptr [ebp+16]	;dwFlags: dword->dword
	call	dword ptr [pfnQT_Thunk_wizthk]
	cwde
	call	SUnMapLS_IP_EBP_8
	leave
	retn	12





;
public GetSETUPXErrorText16@12
GetSETUPXErrorText16@12:
	FAPILOG16	106
	mov	cl,4
; GetSETUPXErrorText16(16) = GetSETUPXErrorText16(32) {}
;
; dword ptr [ebp+8]:  dwErr
; dword ptr [ebp+12]:  pszErrorDesc
; dword ptr [ebp+16]:  cbErrorDesc
;
public IIGetSETUPXErrorText16@12
IIGetSETUPXErrorText16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwErr: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;cbErrorDesc: dword->dword
	call	dword ptr [pfnQT_Thunk_wizthk]
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public RemoveUnneededDefaultComponents16@4
RemoveUnneededDefaultComponents16@4:
	FAPILOG16	68
	mov	cl,3
; RemoveUnneededDefaultComponents16(16) = RemoveUnneededDefaultComponents16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
;
public IIRemoveUnneededDefaultComponents16@4
IIRemoveUnneededDefaultComponents16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	leave
	retn	4





;
public RemoveProtocols16@12
RemoveProtocols16@12:
	FAPILOG16	46
	mov	cl,2
	jmp	IIRemoveProtocols16@12
public InstallComponent16@12
InstallComponent16@12:
	FAPILOG16	189
	mov	cl,7
; RemoveProtocols16(16) = RemoveProtocols16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
; dword ptr [ebp+12]:  dwRemoveFromCardType
; dword ptr [ebp+16]:  dwProtocols
;
public IIRemoveProtocols16@12
IIRemoveProtocols16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	push	dword ptr [ebp+12]	;dwRemoveFromCardType: dword->dword
	push	dword ptr [ebp+16]	;dwProtocols: dword->dword
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	leave
	retn	12





;
public DoGenInstall16@12
DoGenInstall16@12:
	FAPILOG16	27
	mov	cl,1
; DoGenInstall16(16) = DoGenInstall16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
; dword ptr [ebp+12]:  lpszInfFile
; dword ptr [ebp+16]:  lpszInfSect
;
public IIDoGenInstall16@12
IIDoGenInstall16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_12
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public SetInstallSourcePath16@4
SetInstallSourcePath16@4:
	FAPILOG16	0
	mov	cl,0
; SetInstallSourcePath16(16) = SetInstallSourcePath16(32) {}
;
; dword ptr [ebp+8]:  szSourcePath
;
public IISetInstallSourcePath16@4
IISetInstallSourcePath16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4




;-----------------------------------------------------------
ifdef DEBUG
FT_ThunkLogNames label byte
	db	'[F] SetInstallSourcePath16',0
	db	'[F] DoGenInstall16',0
	db	'[F] RemoveProtocols16',0
	db	'[F] RemoveUnneededDefaultComponents16',0
	db	'[F] GetSETUPXErrorText16',0
	db	'[F] GetNextNetcardTCPIPNode16',0
	db	'[F] BeginNetcardTCPIPEnum16',0
	db	'[F] InstallComponent16',0
	db	'[F] GetClientConfig16',0
endif ;DEBUG
;-----------------------------------------------------------



ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	_TEXT



externDef SetInstallSourcePath16:far16
externDef DoGenInstall16:far16
externDef RemoveProtocols16:far16
externDef RemoveUnneededDefaultComponents16:far16
externDef GetSETUPXErrorText16:far16
externDef GetNextNetcardTCPIPNode16:far16
externDef BeginNetcardTCPIPEnum16:far16
externDef InstallComponent16:far16
externDef GetClientConfig16:far16


FT_wizthkTargetTable label word
	dw	offset SetInstallSourcePath16
	dw	   seg SetInstallSourcePath16
	dw	offset DoGenInstall16
	dw	   seg DoGenInstall16
	dw	offset RemoveProtocols16
	dw	   seg RemoveProtocols16
	dw	offset RemoveUnneededDefaultComponents16
	dw	   seg RemoveUnneededDefaultComponents16
	dw	offset GetSETUPXErrorText16
	dw	   seg GetSETUPXErrorText16
	dw	offset GetNextNetcardTCPIPNode16
	dw	   seg GetNextNetcardTCPIPNode16
	dw	offset BeginNetcardTCPIPEnum16
	dw	   seg BeginNetcardTCPIPEnum16
	dw	offset InstallComponent16
	dw	   seg InstallComponent16
	dw	offset GetClientConfig16
	dw	   seg GetClientConfig16




	.data

public wizthk_ThunkData16	;This symbol must be exported.
wizthk_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	010e07h	;Checksum
	dw	offset FT_wizthkTargetTable
	dw	seg    FT_wizthkTargetTable
	dd	0	;First-time flag.



	.code _TEXT


externDef ThunkConnect16:far16

public wizthk_ThunkConnect16
wizthk_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    wizthk_ThunkData16
	push	offset wizthk_ThunkData16
	push	seg    wizthk_ThkData32
	push	offset wizthk_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
wizthk_ThkData32 label byte
	db	"wizthk_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\clsutil.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CLSUTIL.C - some small, useful C++ classes to wrap memory allocation,
//        registry access, etc.
//

//  HISTORY:
//  
//  12/07/94  jeremys    Borrowed from WNET common library
//

#include "wizard.h"

BOOL BUFFER::Alloc( UINT cbBuffer )
{
  _lpBuffer = (LPTSTR)::GlobalAlloc(GPTR,sizeof(TCHAR)*cbBuffer);
  if (_lpBuffer != NULL) {
    _cb = cbBuffer;
    return TRUE;
  }
  return FALSE;
}

BOOL BUFFER::Realloc( UINT cbNew )
{
  LPVOID lpNew = ::GlobalReAlloc((HGLOBAL)_lpBuffer, sizeof(TCHAR)*cbNew,
    GMEM_MOVEABLE | GMEM_ZEROINIT);
  if (lpNew == NULL)
    return FALSE;

  _lpBuffer = (LPTSTR)lpNew;
  _cb = cbNew;
  return TRUE;
}

BUFFER::BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
  _lpBuffer( NULL )
{
  if (cbInitial)
    Alloc( cbInitial );
}

BUFFER::~BUFFER()
{
  if (_lpBuffer != NULL) {
    GlobalFree((HGLOBAL) _lpBuffer);
    _lpBuffer = NULL;
  }
}

BOOL BUFFER::Resize( UINT cbNew )
{
  BOOL fSuccess;

  if (QuerySize() == 0)
    fSuccess = Alloc( cbNew );
  else {
    fSuccess = Realloc( cbNew );
  }
  if (fSuccess)
    _cb = cbNew;
  return fSuccess;
}

RegEntry::RegEntry(const TCHAR *pszSubKey, HKEY hkey)
{
  _error = RegCreateKey(hkey, pszSubKey, &_hkey);
  if (_error) {
    bhkeyValid = FALSE;
  }
  else {
    bhkeyValid = TRUE;
  }
}

RegEntry::~RegEntry()
{ 
    if (bhkeyValid) {
        RegCloseKey(_hkey); 
    }
}

long RegEntry::SetValue(const TCHAR *pszValue, const TCHAR *string)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
            (BYTE *)string, sizeof(TCHAR)*(lstrlen(string)+1));
    }
  return _error;
}

long RegEntry::SetValue(const TCHAR *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
            (BYTE *)&dwNumber, sizeof(dwNumber));
    }
  return _error;
}

long RegEntry::DeleteValue(const TCHAR *pszValue)
{
    if (bhkeyValid) {
      _error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
  }
  return _error;
}


TCHAR *RegEntry::GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length)
{
  DWORD   dwType = REG_SZ;
  
    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
            &length);
    }
  if (_error) {
    *string = '\0';
     return NULL;
  }

  return string;
}

long RegEntry::GetNumber(const TCHAR *pszValue, long dwDefault)
{
   DWORD   dwType = REG_BINARY;
   long  dwNumber = 0L;
   DWORD  dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
            &dwSize);
  }
  if (_error)
    dwNumber = dwDefault;
  
  return dwNumber;
}

long RegEntry::MoveToSubKey(const TCHAR *pszSubKeyName)
{
    HKEY  _hNewKey;

    if (bhkeyValid) {
        _error = RegOpenKey ( _hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (_error == ERROR_SUCCESS) {
            RegCloseKey(_hkey);
            _hkey = _hNewKey;
        }
    }

  return _error;
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
      _error = RegFlushKey(_hkey);
    }
  return _error;
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    _error = pRegEntry->GetError();
    if (_error == ERROR_SUCCESS) {
        _error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new TCHAR[cMaxValueName];
            if (!pchName) {
                _error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        _error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete pchName;
    delete pbValue;
}

long RegEnumValues::Next()
{
    if (_error != ERROR_SUCCESS) {
        return _error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    _error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return _error;
}

int __cdecl _purecall(void)
{
   return(0);
}

void * _cdecl operator new(size_t size)
{
  return (void *)::GlobalAlloc(GPTR,size); 
}

void _cdecl operator delete(void *ptr)
{
  GlobalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\callout.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CALLOUT.C - Functions to call out to external components to install
//        devices
//

//  HISTORY:
//  
//  11/27/94  jeremys  Created.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//

#include "wizard.h"

//
// Define and initialize all device class GUIDs.
// (This must only be done once per module!)
//
#include <devguid.h>

// global variables 
static const CHAR c_szModemCPL[] = "rundll32.exe Shell32.dll,Control_RunDLL modem.cpl,,add";

// Define prorotype for InstallNewDevice, exported
// by newdev.dll, which we will now call in order
// to get to the hardware wizard, instead of calling
// the class installer directly;
// also, define constants for the name of the dll and
// the export
typedef BOOL (WINAPI *PINSTNEWDEV)(HWND, LPGUID, PDWORD);

LPGUID g_pguidModem     = (LPGUID)&GUID_DEVCLASS_MODEM;


/*******************************************************************

  NAME:    InvokeModemWizard

  SYNOPSIS:  Starts the modem install wizard

  ENTRY:    hwndToHide - this window, if non-NULL, will be hidden while
        the modem CPL runs

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    launches RUNDLL32 as a process to run the modem wizard.
        Blocks on the completion of that process before returning.

        hwndToHide is not necessarily the calling window!
        For instance, in a property sheet hwndToHide should not be the
        dialog (hDlg), but GetParent(hDlg) so that we hide the property
        sheet itself instead of just the current page.

********************************************************************/
UINT InvokeModemWizard(HWND hwndToHide)
{
    BOOL bSleepNeeded = FALSE;
    UINT err = ERROR_SUCCESS;

    if (IsNT5())
    {
        BOOL bUserIsAdmin = FALSE;
        HKEY hkey;

        if(RegOpenKeyEx(HKEY_USERS, TEXT(".DEFAULT"), 0, KEY_WRITE, &hkey) == 0)
        {
            RegCloseKey(hkey);
            bUserIsAdmin = TRUE;
        }

        //Is the user an admin?
        if(!bUserIsAdmin)
        {
            return ERROR_PRIVILEGE_NOT_HELD;
        }

        /*
        We do this messy NT 5.0 hack because for the time being the 
        NT 4.0 API call fails to kil off the modem wizard in NT 5.0
        In the future when this problem is corrected the origional code should
        prpoably be restored a-jaswed

        Jason Cobb suggested to use InstallNewDevice method on NT5 to invoke MDM WIZ.
        */

        HINSTANCE hInst = NULL;
        PINSTNEWDEV pInstNewDev;
        BOOL bRet = 0;

        TCHAR msg[1024];

        hInst = LoadLibrary (TEXT("hdwwiz.cpl"));
        if (NULL != hInst)
        {

            pInstNewDev = (PINSTNEWDEV)GetProcAddress (hInst, "InstallNewDevice");
            if (NULL != pInstNewDev)
            {
                bRet = pInstNewDev (hwndToHide, g_pguidModem, NULL);
            }

        }
        if (!bRet)
            err = GetLastError();
        FreeLibrary (hInst);
        return err;

    }
    else if (FALSE == IsNT())
    {

        PROCESS_INFORMATION pi;
        BOOL fRet;
        STARTUPINFOA sti;
        TCHAR szWindowTitle[255];

        ZeroMemory(&sti,sizeof(STARTUPINFO));
        sti.cb = sizeof(STARTUPINFO);

        // run the modem wizard
        fRet = CreateProcessA(NULL, (LPSTR)c_szModemCPL,
                               NULL, NULL, FALSE, 0, NULL, NULL,
                               &sti, &pi);
        if (fRet) 
        {
            CloseHandle(pi.hThread);

            // wait for the modem wizard process to complete
            MsgWaitForMultipleObjectsLoop(pi.hProcess);
            CloseHandle(pi.hProcess);
        } 
        else
            err = GetLastError();
        return err;
    }
    else //NT 4.0
    {
        BOOL bNeedsStart;
        
        //
        // Call into icfg32 dll
        //
        if (NULL != lpIcfgInstallModem)
        {
            lpIcfgInstallModem(hwndToHide, 0L, &bNeedsStart);
            return ERROR_SUCCESS;
        }
        else
            return ERROR_GEN_FAILURE;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\clsutil.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CLSUTIL.H - header file for utility C++ classes
//

//  HISTORY:
//  
//  12/07/94  jeremys    Borrowed from WNET common library
//

#ifndef _CLSUTIL_H_
#define _CLSUTIL_H_

/*************************************************************************

    NAME:    BUFFER_BASE

    SYNOPSIS:  Base class for transient buffer classes

    INTERFACE:  BUFFER_BASE()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Returns TRUE if
          successful.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    None

    USES:    None

    CAVEATS:  This is an abstract class, which unifies the interface
        of BUFFER, GLOBAL_BUFFER, etc.

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created base class

**************************************************************************/

class BUFFER_BASE
{
protected:
  UINT _cb;

  virtual BOOL Alloc( UINT cbBuffer ) = 0;
  virtual BOOL Realloc( UINT cbBuffer ) = 0;

public:
  BUFFER_BASE()
    { _cb = 0; }  // buffer not allocated yet
  ~BUFFER_BASE()
    { _cb = 0; }  // buffer size no longer valid
  BOOL Resize( UINT cbNew );
  UINT QuerySize() const { return _cb; };
};

#define GLOBAL_BUFFER  BUFFER

/*************************************************************************

    NAME:    BUFFER

    SYNOPSIS:  Wrapper class for new and delete

    INTERFACE:  BUFFER()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Only works if the
          buffer hasn't been allocated yet.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    BUFFER_BASE

    USES:    operator new, operator delete

    CAVEATS:

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created

**************************************************************************/

class BUFFER : public BUFFER_BASE
{
protected:
  TCHAR *_lpBuffer;

  virtual BOOL Alloc( UINT cbBuffer );
  virtual BOOL Realloc( UINT cbBuffer );

public:
  BUFFER( UINT cbInitial=0 );
  ~BUFFER();
  BOOL Resize( UINT cbNew );
  TCHAR * QueryPtr() const { return (TCHAR *)_lpBuffer; }
  operator TCHAR *() const { return (TCHAR *)_lpBuffer; }
};

class RegEntry
{
  public:
    RegEntry(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
    ~RegEntry();
    
    long  GetError()  { return _error; }
    long  SetValue(const TCHAR *pszValue, const TCHAR *string);
    long  SetValue(const TCHAR *pszValue, unsigned long dwNumber);
    TCHAR *  GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length);
    long  GetNumber(const TCHAR *pszValue, long dwDefault = 0);
    long  DeleteValue(const TCHAR *pszValue);
    long  FlushKey();
        long    MoveToSubKey(const TCHAR *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; }

  private:
    HKEY  _hkey;
    long  _error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
  public:
    RegEnumValues(RegEntry *pRegEntry);
    ~RegEnumValues();
    long  Next();
    TCHAR *  GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}
    long  GetError()  { return _error; }

  private:
        RegEntry * pRegEntry;
    DWORD   iEnum;
        DWORD   cEntries;
    TCHAR *  pchName;
    LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    _error;
};

/*************************************************************************

    NAME:    WAITCURSOR

    SYNOPSIS:  Sets the cursor to an hourclass until object is destructed

**************************************************************************/
class WAITCURSOR
{
private:
    HCURSOR m_curOld;
    HCURSOR m_curNew;

public:
    WAITCURSOR() { m_curNew = ::LoadCursor( NULL, IDC_WAIT ); m_curOld = ::SetCursor( m_curNew ); }
    ~WAITCURSOR() { ::SetCursor( m_curOld ); }
};

#endif  // _CLSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inet32\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#include "pch.hpp"
#if 0
#include "string.h"
#endif

#define MAX_MSG_PARAM     8

// function prototypes
VOID _cdecl FormatErrorMessage(CHAR * pszMsg,DWORD cbMsg,CHAR * pszFmt,va_list ArgList);

/*******************************************************************

  NAME:    MsgBox

  SYNOPSIS:  Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    CHAR szMsgBuf[MAX_RES_LEN+1];
  CHAR szSmallBuf[SMALL_BUF_LEN+1];

    LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));
    LoadSz(nMsgID,szMsgBuf,sizeof(szMsgBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

/*******************************************************************

  NAME:    MsgBoxSz

  SYNOPSIS:  Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPSTR szText,UINT uIcon,UINT uButtons)
{
  CHAR szSmallBuf[SMALL_BUF_LEN+1];
  LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}


/*******************************************************************

  NAME:    LoadSz

  SYNOPSIS:  Loads specified string resource into buffer

  EXIT:    returns a pointer to the passed-in buffer

  NOTES:    If this function fails (most likely due to low
        memory), the returned buffer will have a leading NULL
        so it is generally safe to use this without checking for
        failure.

********************************************************************/
LPSTR LoadSz(UINT idString,LPSTR lpszBuf,UINT cbBuf)
{
  ASSERT(lpszBuf);

  // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( ghInstance, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

/*******************************************************************

  NAME:    GetErrorDescription

  SYNOPSIS:  Retrieves the text description for a given error code
        and class of error (standard, setupx)

********************************************************************/
VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass)
{
  ASSERT(pszErrorDesc);

  // set a leading null in error description
  *pszErrorDesc = '\0';
  
  switch (uErrorClass) {

    case ERRCLS_STANDARD:

      if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,
        uError,0,pszErrorDesc,cbErrorDesc,NULL)) {
        // if getting system text fails, make a string a la
        // "error <n> occurred"
        CHAR szFmt[SMALL_BUF_LEN+1];
        LoadSz(IDS_ERRFORMAT,szFmt,sizeof(szFmt));
        wsprintf(pszErrorDesc,szFmt,uError);
      }

      break;

    case ERRCLS_SETUPX:

      GetSETUPXErrorText(uError,pszErrorDesc,cbErrorDesc);
      break;

    default:

      DEBUGTRAP("Unknown error class %lu in GetErrorDescription",
        uErrorClass);

  }

}
  
/*******************************************************************

  NAME:    FormatErrorMessage

  SYNOPSIS:  Builds an error message by calling FormatMessage

  NOTES:    Worker function for PrepareErrorMessage

********************************************************************/
VOID _cdecl FormatErrorMessage(CHAR * pszMsg,DWORD cbMsg,CHAR * pszFmt,va_list ArgList)
{
  ASSERT(pszMsg);
  ASSERT(pszFmt);

  // build the message into the pszMsg buffer
  DWORD dwCount = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
    pszFmt,0,0,pszMsg,cbMsg,&ArgList);
  ASSERT(dwCount > 0);
}

/*******************************************************************

  NAME:    PrepareErrorMessage

  SYNOPSIS:  Displays an error message for given error 

  ENTRY:    hWnd - parent window
        uStrID - ID of string resource with message format.
          Should contain %1 to be replaced by error text,
          additional parameters can be specified as well.
        uError - error code for error to display
        uErrorClass - ERRCLS_xxx ID of class of error that
          uError belongs to (standard, setupx)
        uIcon - icon to display
        ... - additional parameters to be inserted in string
          specified by uStrID

********************************************************************/
VOID _cdecl PrepareErrorMessage(UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,...)
{
  // dynamically allocate buffers for messages
  BUFFER ErrorDesc(MAX_RES_LEN+1);
  BUFFER ErrorFmt(MAX_RES_LEN+1);

  if (!ErrorDesc || !ErrorFmt)
  {
    return;
  }

  // get a text description based on the error code and the class
  // of error it is
  GetErrorDescription(ErrorDesc.QueryPtr(),
    ErrorDesc.QuerySize(),uError,uErrorClass);

  // load the string for the message format
  LoadSz(uStrID,ErrorFmt.QueryPtr(),ErrorFmt.QuerySize());

#ifdef _M_ALPHA
  va_list args[MAX_MSG_PARAM];
  args[0].a0 = (LPSTR) ErrorDesc.QueryPtr();
#else
  LPSTR args[MAX_MSG_PARAM];
  args[0] = (LPSTR) ErrorDesc.QueryPtr();
#endif
  memcpy(&args[1],((CHAR *) &uIcon) + sizeof(uIcon),(MAX_MSG_PARAM - 1) * sizeof(LPSTR));

  FormatErrorMessage(gpszLastErrorText, MAX_ERROR_TEXT,
#ifdef _M_ALPHA
    ErrorFmt.QueryPtr(), args[1]);
#else
    ErrorFmt.QueryPtr(),(va_list) &args[1]);
#endif
}

/*******************************************************************

  NAME:    RunMlsetExe

  SYNOPSIS:  Runs mlset32.exe, an Exchange app that needs to be
        run after files are installed otherwise Exchange
        barfs

  NOTES:    We look in registry to find path to mlset32.exe

********************************************************************/
DWORD RunMlsetExe(HWND hwndOwner)
{
  DWORD dwRet = ERROR_SUCCESS;

  // get path to mlset32 out of registry
  RegEntry re(szRegPathSoftwareMicrosoft,HKEY_LOCAL_MACHINE);

  CHAR szAppPath[MAX_PATH+1];
  if (re.GetString(szRegValMlSet,szAppPath,sizeof(szAppPath))) {
    PROCESS_INFORMATION pi;
    STARTUPINFO sti;

    // set "SilentRunning" registry switch to make mlset32
    // not display the Exchange wizard
    RegEntry reSilent(szRegPathExchangeClientOpt,HKEY_LOCAL_MACHINE);
    reSilent.SetValue(szRegValSilentRunning,(DWORD) 1);

    ZeroMemory(&sti,sizeof(STARTUPINFO));
    sti.cb = sizeof(STARTUPINFO);
            
    // launch mlset32.exe
    BOOL fRet = CreateProcess(NULL, (LPSTR) szAppPath,
                           NULL, NULL, FALSE, 0, NULL, NULL,
                           &sti, &pi);
    if (fRet) {
      CloseHandle(pi.hThread);

      // wait for mlset to complete
      MsgWaitForMultipleObjectsLoop(pi.hProcess);

      CloseHandle(pi.hProcess);
    } else {
      dwRet = GetLastError();
    }

    // put our window in front of mlset32's
    SetForegroundWindow(hwndOwner);
  
  } else {
    dwRet = ERROR_FILE_NOT_FOUND;
  }

  return dwRet;
}

/*******************************************************************

  NAME:    RemoveRunOnceEntry

  SYNOPSIS:  Removes the specified value from setup runonce key

  ENTRY:    uResourceID - ID of value name in resource
          (may be localized)

********************************************************************/
VOID RemoveRunOnceEntry(UINT uResourceID)
{
  RegEntry re(szRegPathSetupRunOnce,HKEY_LOCAL_MACHINE);
  CHAR szValueName[SMALL_BUF_LEN+1];
  ASSERT(re.GetError() == ERROR_SUCCESS);
  re.DeleteValue(LoadSz(uResourceID,
    szValueName,sizeof(szValueName)));
}

/*******************************************************************

  NAME:    GenerateComputerNameIfNeeded

  SYNOPSIS:  Makes up and stores in the registry a computer and/or
        workgroup name if not already set.

  NOTES:    If we don't do this, user will get prompted for computer
        name and workgroup.  These aren't meaningful to the user
        so we'll just make something up if these aren't set.

********************************************************************/
BOOL GenerateComputerNameIfNeeded(VOID)
{
  CHAR szComputerName[CNLEN+1]="";
  CHAR szWorkgroupName[DNLEN+1]="";
  BOOL fNeedToSetComputerName = FALSE;

  // get the computer name out of the registry
  RegEntry reCompName(szRegPathComputerName,HKEY_LOCAL_MACHINE);
  if (reCompName.GetError() == ERROR_SUCCESS) {
    reCompName.GetString(szRegValComputerName,szComputerName,
      sizeof(szComputerName));
    if (!lstrlen(szComputerName)) {
      // no computer name set!  make one up
      GenerateDefaultName(szComputerName,sizeof(szComputerName),
        (CHAR *) szRegValOwner,IDS_DEF_COMPUTER_NAME);
      // store the generated computer name in the registry
      reCompName.SetValue(szRegValComputerName,szComputerName);

      // also need to store the computer name in the workgroup key
      // which we will open below... set a flag so we know to do this.
      // (don't ask me why they store the computer name in two places...
      // but we need to set both.)
      fNeedToSetComputerName = TRUE;
    }
  }

  // get the workgroup name out of the registry
  RegEntry reWorkgroup(szRegPathWorkgroup,HKEY_LOCAL_MACHINE);
  if (reWorkgroup.GetError() == ERROR_SUCCESS) {

    // if we set a new computer name up above, then we have to set
    // a 2nd copy of the new name now, in the workgroup key
    if (fNeedToSetComputerName) {
      reWorkgroup.SetValue(szRegValComputerName,szComputerName);
    }


    reWorkgroup.GetString(szRegValWorkgroup,szWorkgroupName,
      sizeof(szWorkgroupName));
    if (!lstrlen(szWorkgroupName)) {
      // no workgroup name set!  make one up
      GenerateDefaultName(szWorkgroupName,sizeof(szWorkgroupName),
        (CHAR *) szRegValOrganization,IDS_DEF_WORKGROUP_NAME);
      // store the generated workgroup name in the registry
      reWorkgroup.SetValue(szRegValWorkgroup,szWorkgroupName);
    }
  }

  return TRUE;
}

/*******************************************************************

  NAME:    GenerateDefaultName

  SYNOPSIS:  Generates default computer or workgroup name

  ENTRY:    pszName - buffer to be filled in with name
        cbName - size of cbName buffer
        pszRegValName - name of registry value in ...Windows\CurrentVersion
          key to generate name from
        uIDDefName - ID of string resource to use if no value is
          present in registry to generate name from

********************************************************************/
BOOL GenerateDefaultName(CHAR * pszName,DWORD cbName,CHAR * pszRegValName,
  UINT uIDDefName)
{
  ASSERT(pszName);
  ASSERT(pszRegValName);

  *pszName = '\0';  // NULL-terminate buffer

  // look for registered owner/organization name in registry
  RegEntry reSetup(szRegPathSetup,HKEY_LOCAL_MACHINE);
  if (reSetup.GetError() == ERROR_SUCCESS) {
    if (reSetup.GetString(pszRegValName,pszName,cbName) &&
      lstrlen(pszName)) {
      // got string from registry... now terminate at first whitespace
      CHAR * pch = pszName;
      while (*pch) {
        if (*pch == ' ') {
          // found a space, terminate here and stop
          *pch = '\0';           
        } else {
          // advance to next char, keep going
          pch = CharNext(pch);
        }
      }
      // all done!
      return TRUE; 
    }
  }
  
  // couldn't get this name from registry, go for our fallback name
  // from resource

  LoadSz(uIDDefName,pszName,cbName);
  return TRUE;
}

/*******************************************************************

  NAME:    MsgWaitForMultipleObjectsLoop

  SYNOPSIS:  Blocks until the specified object is signaled, while
        still dispatching messages to the main thread.

********************************************************************/
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent)
{
    MSG msg;
    DWORD dwObject;
    while (1)
    {
        // NB We need to let the run dialog become active so we have to half handle sent
        // messages but we don't want to handle any input events or we'll swallow the
        // type-ahead.
        dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE,INFINITE, QS_ALLINPUT);
        // Are we done waiting?
        switch (dwObject) {
        case WAIT_OBJECT_0:
        case WAIT_FAILED:
            return dwObject;

        case WAIT_OBJECT_0 + 1:
      // got a message, dispatch it and wait again
      while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE)) {
        DispatchMessage(&msg);
      }
            break;
        }
    }
    // never gets here
}


/*******************************************************************
// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.


  NAME:    SetDesktopInternetIconToBrowser

  SYNOPSIS:  "Points" The Internet desktop icon to web browser
        (Internet Explorer)

  NOTES:    The Internet icon may initially "point" at this wizard,
        we need to set it to launch web browser once we complete
        successfully.

********************************************************************/
/********BOOL SetDesktopInternetIconToBrowser(VOID)
{
	CHAR szAppPath[MAX_PATH+1]="";
	BOOL fRet = FALSE;

	// look in the app path section in registry to get path to internet
	// explorer

	RegEntry reAppPath(szRegPathIexploreAppPath,HKEY_LOCAL_MACHINE);
	ASSERT(reAppPath.GetError() == ERROR_SUCCESS);
	if (reAppPath.GetError() == ERROR_SUCCESS) {

		reAppPath.GetString(szNull,szAppPath,sizeof(szAppPath));
		ASSERT(reAppPath.GetError() == ERROR_SUCCESS);

	}

	// set the path to internet explorer as the open command for the 
	// internet desktop icon
	if (lstrlen(szAppPath)) {
		RegEntry reIconOpenCmd(szRegPathInternetIconCommand,HKEY_CLASSES_ROOT);
		ASSERT(reIconOpenCmd.GetError() == ERROR_SUCCESS);
		if (reIconOpenCmd.GetError() == ERROR_SUCCESS) {
			UINT uErr = reIconOpenCmd.SetValue(szNull,szAppPath);
			ASSERT(uErr == ERROR_SUCCESS);
			
			fRet = (uErr == ERROR_SUCCESS);
		}
	}

	return fRet;
}
******/

/*******************************************************************

  NAME:    PrepareForRunOnceApp

  SYNOPSIS:  Copies wallpaper value in registry to make the runonce
        app happy

  NOTES:    The runonce app (the app that displays a list of apps
        that are run once at startup) has a bug.  At first boot,
        it wants to change the wallpaper from the setup wallpaper
        to what the user had before running setup.  Setup tucks
        the "old" wallpaper away in a private key, then changes
        the wallpaper to the setup wallpaper.  After the runonce
        app finishes, it looks in the private key to get the old
        wallpaper and sets that to be the current wallpaper.
        However, it does this all the time, not just at first boot!
        The end effect is that whenever you do anything that
        causes runonce.exe to run (add stuff thru add/remove
        programs control panel), your wallpaper gets set back to
        whatever it was when you installed win 95.  This is
        especially bad for Plus!, since wallpaper settings are an
        important part of the product.

        To work around this bug, we copy the current wallpaper settings
        (which we want preserved) to setup's private key.  When
        runonce runs it will say "aha!" and copy those values back
        to the current settings.

********************************************************************/
VOID PrepareForRunOnceApp(VOID)
{
  // open a key to the current wallpaper settings
  RegEntry reDesktop(szRegPathDesktop,HKEY_CURRENT_USER);
  ASSERT(reDesktop.GetError() == ERROR_SUCCESS);

  // open a key to the private setup section
  RegEntry reSetup(szRegPathSetupWallpaper,HKEY_LOCAL_MACHINE);
  ASSERT(reSetup.GetError() == ERROR_SUCCESS);

  if (reDesktop.GetError() == ERROR_SUCCESS &&
    reSetup.GetError() == ERROR_SUCCESS) {
    CHAR szWallpaper[MAX_PATH+1]="";
    CHAR szTiled[10]="";  // big enough for "1" + slop

    // get the current wallpaper name
    if (reDesktop.GetString(szRegValWallpaper,szWallpaper,
      sizeof(szWallpaper))) {

      // set the current wallpaper name in setup's private section
      UINT uRet=reSetup.SetValue(szRegValWallpaper,szWallpaper);
      ASSERT(uRet == ERROR_SUCCESS);

      // get the current 'tiled' value. 
      reDesktop.GetString(szRegValTileWallpaper,szTiled,
        sizeof(szTiled));

      // set the 'tiled' value in setup's section
      if (lstrlen(szTiled)) {
        uRet=reSetup.SetValue(szRegValTileWallpaper,szTiled);
        ASSERT(uRet == ERROR_SUCCESS);
      }
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\export.cpp ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996
//
//  FILE: EXPORT.C
//
//  PURPOSE:  Contains external API's for use by signup wizard.
//
//  HISTORY:
//  96/03/05  markdu  Created.
//  96/03/11  markdu  Added InetConfigClient()
//  96/03/11  markdu  Added InetGetAutodial() and InetSetAutodial().
//  96/03/12  markdu  Added UI during file install.
//  96/03/12  markdu  Added ValidateConnectoidData().
//  96/03/12  markdu  Set connectoid for autodial if INETCFG_SETASAUTODIAL
//            is set.  Renamed ValidateConnectoidData to MakeConnectoid.
//  96/03/12  markdu  Added hwnd param to InetConfigClient() and
//            InetConfigSystem().
//  96/03/13  markdu  Added INETCFG_OVERWRITEENTRY.  Create unique neame
//            for connectoid if it already exists and we can't overwrite.
//  96/03/13  markdu  Added InstallTCPAndRNA().
//  96/03/13  markdu  Added LPINETCLIENTINFO param to InetConfigClient()
//  96/03/16  markdu  Added INETCFG_INSTALLMODEM flag.
//  96/03/16  markdu  Use ReInit member function to re-enumerate modems.
//  96/03/19  markdu  Split export.h into export.h and csexport.h
//  96/03/20  markdu  Combined export.h and iclient.h into inetcfg.h
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/24  markdu  Replaced lstrcpy with lstrcpyn where appropriate.
//  96/03/25  markdu  Validate lpfNeedsRestart before using.
//  96/03/25  markdu  Clean up some error handling.
//  96/03/26  markdu  Use MAX_ISP_NAME instead of RAS_MaxEntryName 
//            because of bug in RNA.
//  96/03/26  markdu  Implemented UpdateMailSettings().
//  96/03/27  mmaclin InetGetProxy()and InetSetProxy().
//  96/04/04  markdu  NASH BUG 15610  Check for file and printer sharing
//            bound to TCP/IP .
//  96/04/04  markdu  Added phonebook name param to InetConfigClient,
//            MakeConnectoid, SetConnectoidUsername, CreateConnectoid,
//            and ValidateConnectoidName.
//  96/04/05  markdu  Set internet icon on desktop to point to browser.
//  96/04/06  mmaclin Changed InetSetProxy to check for NULL.
//  96/04/06  markdu  NASH BUG 16404 Initialize gpWizardState in
//            UpdateMailSettings.
//  96/04/06  markdu  NASH BUG 16441 If InetSetAutodial is called with NULL
//            as the connection name, the entry is not changed.
//  96/04/18  markdu  NASH BUG 18443 Make exports WINAPI.
//  96/04/19  markdu  NASH BUG 18605 Handle ERROR_FILE_NOT_FOUND return
//            from ValidateConnectoidName.
//  96/04/19  markdu  NASH BUG 17760 Do not show choose profile UI.
//  96/04/22  markdu  NASH BUG 18901 Do not set desktop internet icon to 
//            browser if we are just creating a temp connectoid.
//  96/04/23  markdu  NASH BUG 18719 Make the choose profile dialog TOPMOST.
//  96/04/25  markdu  NASH BUG 19572 Only show choose profile dialog if
//            there is an existing profile.
//  96/04/29  markdu  NASH BUG 20003 Added InetConfigSystemFromPath
//            and removed InstallTCPAndRNA.
//  96/05/01  markdu  NASH BUG 20483 Do not display "installing files" dialog
//            if INETCFG_SUPPRESSINSTALLUI is set.
//  96/05/01  markdu  ICW BUG 8049 Reboot if modem is installed.  This is 
//            required because sometimes the configuration manager does not 
//            set up the modem correctly, and the user will not be able to
//            dial (will get cryptic error message) until reboot.
//  96/05/06  markdu  NASH BUG 21027  If DNS is set globally, clear it out so
//            the per-connectoid settings will be saved.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.
//  96/05/28  markdu  Moved InitConfig and DeInitConfig to DllEntryPoint.
//    96/10/21  valdonb Added CheckConnectionWizard and InetCreateMailNewsAccount
//
//*******************************************************************

#include "wizard.h"
#include "inetcfg.h"
#include "icwextsn.h"
#include <icwcfg.h>

// constants
#define LEN_APPEND_INT              3           // number of digits for MAX_APPEND_INT  
#define MAX_APPEND_INT              999         // maximum number to append to connectoid name                                  // when cycling through names to create unique name


#pragma data_seg(".rdata")

// Registry constants
static const TCHAR cszRegPathInternetSettings[]    = REGSTR_PATH_INTERNET_SETTINGS;
static const TCHAR cszRegPathInternetLanSettings[] = REGSTR_PATH_INTERNET_LAN_SETTINGS; 
static const TCHAR cszRegValProxyEnable[]          = REGSTR_VAL_PROXYENABLE;
static const TCHAR cszRegValProxyServer[]          = REGSTR_VAL_PROXYSERVER;
static const TCHAR cszRegValProxyOverride[]        = REGSTR_VAL_PROXYOVERRIDE;
static const TCHAR cszRegValAutoProxyDetectMode[]  = TEXT("AutoProxyDetectMode");
static const TCHAR cszRegValAutoConfigURL[]        = TEXT("AutoConfigURL");

static const TCHAR cszWininet[] = TEXT("WININET.DLL");
static const  CHAR cszInternetSetOption[]   = "InternetSetOptionA";  
static const  CHAR cszInternetQueryOption[] = "InternetQueryOptionA";

#define REGSTR_PATH_TELEPHONYLOCATIONS  REGSTR_PATH_SETUP TEXT("\\Telephony\\Locations")

#pragma data_seg()

// structure to pass data back from IDD_NEEDDRIVERS handler
typedef struct tagNEEDDRIVERSDLGINFO
{
  DWORD       dwfOptions;
  LPBOOL      lpfNeedsRestart;
} NEEDDRIVERSDLGINFO, * PNEEDDRIVERSDLGINFO;

// structure to pass data back from IDD_CHOOSEMODEMNAME handler
typedef struct tagCHOOSEMODEMDLGINFO
{
  TCHAR szModemName[RAS_MaxDeviceName + 1];
} CHOOSEMODEMDLGINFO, * PCHOOSEMODEMDLGINFO;

// structure to pass data back from IDD_CHOOSEPROFILENAME handler
typedef struct tagCHOOSEPROFILEDLGINFO
{
  TCHAR szProfileName[cchProfileNameMax+1];
  BOOL fSetProfileAsDefault;
} CHOOSEPROFILEDLGINFO, * PCHOOSEPROFILEDLGINFO;

// Function prototypes internal to this file
HRESULT UpdateMailSettings(HWND hwndParent, LPINETCLIENTINFO lpINetClientInfo,
  LPTSTR lpszEntryName);
INT_PTR CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL ChooseModemDlgInit(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);
BOOL ChooseModemDlgOK(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);
INT_PTR CALLBACK NeedDriversDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL NeedDriversDlgInit(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo);
int  NeedDriversDlgOK(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo);
VOID EnableDlg(HWND hDlg,BOOL fEnable);
INT_PTR CALLBACK ChooseProfileDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,  LPARAM lParam);
BOOL ChooseProfileDlgInit(HWND hDlg,CHOOSEPROFILEDLGINFO * pChooseProfileDlgInfo);
BOOL ChooseProfileDlgOK(HWND hDlg,CHOOSEPROFILEDLGINFO * pChooseProfileDlgInfo);
DWORD MakeConnectoid(
  HWND        hwndParent,
  DWORD       dwfOptions,
  LPCTSTR      lpszPhonebook,
  LPCTSTR      lpszEntryName,
  LPRASENTRY  lpRasEntry,
  LPCTSTR      lpszUsername,
  LPCTSTR      lpszPassword,
  LPBOOL      lpfNeedsRestart);
HWND WaitCfgInit(HWND hwndParent, DWORD dwIDS);

// Function prototypes external to this file
VOID InitWizardState(WIZARDSTATE * pWizardState, DWORD dwFlags);
BOOL DoNewProfileDlg(HWND hDlg);
extern DWORD SetIEClientInfo(LPINETCLIENTINFO lpClientInfo);
extern ICFGSETINSTALLSOURCEPATH     lpIcfgSetInstallSourcePath;
extern ICFGINSTALLSYSCOMPONENTS     lpIcfgInstallInetComponents;
extern ICFGNEEDSYSCOMPONENTS        lpIcfgNeedInetComponents;
extern ICFGGETLASTINSTALLERRORTEXT  lpIcfgGetLastInstallErrorText;

extern BOOL ValidateProductSuite(LPTSTR SuiteName);


#ifdef UNICODE
PWCHAR ToUnicodeWithAlloc(LPCSTR);
VOID   ToAnsiClientInfo(LPINETCLIENTINFOA, LPINETCLIENTINFOW);
VOID   ToUnicodeClientInfo(LPINETCLIENTINFOW, LPINETCLIENTINFOA);
#endif

//
// from rnacall.cpp
//
extern BOOL InitTAPILocation(HWND hwndParent);

#define SMART_RUNICW TRUE
#define SMART_QUITICW FALSE

#include "wininet.h"
typedef BOOL (WINAPI * INTERNETSETOPTION) (IN HINTERNET hInternet OPTIONAL,IN DWORD dwOption,IN LPVOID lpBuffer,IN DWORD dwBufferLength);
typedef BOOL (WINAPI * INTERNETQUERYOPTION) (IN HINTERNET hInternet OPTIONAL,IN DWORD dwOption,IN LPVOID lpBuffer,IN LPDWORD dwBufferLength);

static const TCHAR g_szRegPathICWSettings[] = TEXT("Software\\Microsoft\\Internet Connection Wizard");
static const TCHAR g_szRegValICWCompleted[] = TEXT("Completed");
BOOL        g_bUseAutoProxyforConnectoid = TRUE;

//*******************************************************************
//
//  FUNCTION:   InetConfigSystem
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install exchange and internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/05  markdu  Created.
//
//*******************************************************************

extern "C" HRESULT WINAPI InetConfigSystem(
                                           HWND hwndParent,
                                           DWORD dwfOptions,
                                           LPBOOL lpfNeedsRestart)
{
    DWORD         dwRet = ERROR_SUCCESS;
    BOOL          fNeedsRestart = FALSE;  // Default to no reboot needed
    // 4/2/97 ChrisK    Olympus 209
    HWND          hwndWaitDlg = NULL;
    TCHAR         szWindowTitle[255];
    BOOL          bSleepNeeded = FALSE;

    /*
    We do this messy NT 5.0 hack because for the time being the 
    NT 4.0 API call fails to kil off the modem wizard in NT 5.0
    , so we need to pretend we are like 9x
    In the future when this problem is corrected the origional code should
    prpoably be restored -- ALL references to this BOOL should be deleted.
    a-jaswed
    */
    BOOL bNT5NeedModem = FALSE;

    DEBUGMSG("export.c::InetConfigSystem()");
    
    // Validate the parent hwnd
    if (hwndParent && !IsWindow(hwndParent))
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // Set up the install options
    DWORD dwfInstallOptions = 0;
    if (dwfOptions & INETCFG_INSTALLTCP)
    {
        dwfInstallOptions |= ICFG_INSTALLTCP;
    }
    if (dwfOptions & INETCFG_INSTALLRNA)
    {
        dwfInstallOptions |= ICFG_INSTALLRAS;
    }
    if (dwfOptions & INETCFG_INSTALLMAIL)
    {
        dwfInstallOptions |= ICFG_INSTALLMAIL;
    }
    
    // see if we need to install drivers
    BOOL  fNeedSysComponents = FALSE;
    
    // 4/2/97 ChrisK Olympus 209 Display busy dialog
    if (INETCFG_SHOWBUSYANIMATION == (dwfOptions & INETCFG_SHOWBUSYANIMATION))
        hwndWaitDlg = WaitCfgInit(hwndParent,IDS_WAITCHECKING);
    
    // 
    // Kill Modem control panel if it's already running
    // 4/16/97 ChrisK Olympus 239
    // 6/9/97 jmazner moved this functionality from InvokeModemWizard
    szWindowTitle[0] = '\0';
    LoadSz(IDS_MODEM_WIZ_TITLE,szWindowTitle,255);
    HWND hwndModem = FindWindow(TEXT("#32770"),szWindowTitle);
    if (NULL != hwndModem)
    {
        // Close modem installation wizard
        PostMessage(hwndModem, WM_CLOSE, 0, 0);
        bSleepNeeded = TRUE;
    }
    
    // close modem control panel applet
    LoadSz(IDS_MODEM_CPL_TITLE,szWindowTitle,255);
    hwndModem = FindWindow(TEXT("#32770"),szWindowTitle);
    if (NULL != hwndModem)
    {
        PostMessage(hwndModem, WM_SYSCOMMAND,SC_CLOSE, 0);
        bSleepNeeded = TRUE;
    }
    
    if (bSleepNeeded)
    {
        Sleep(1000);
    }
    
    dwRet = lpIcfgNeedInetComponents(dwfInstallOptions, &fNeedSysComponents);
    
    if (ERROR_SUCCESS != dwRet)
    {
        TCHAR   szErrorText[MAX_ERROR_TEXT+1]=TEXT("");
        
        
        // 4/2/97 ChrisK Olympus 209
        // Dismiss busy dialog
        if (NULL != hwndWaitDlg)
        {
            BringWindowToTop(hwndParent);
            DestroyWindow(hwndWaitDlg);
            hwndWaitDlg = NULL;
        }
        
        //
        // Get the text of the error message and display it.
        //
        if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
        {
            MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
        }
        
        return dwRet;
    }
    
    if (fNeedSysComponents) 
    {
        // 4/2/97 ChrisK Olympus 209
        // if we are going to install something the busy dialog isn't needed
        if (NULL != hwndWaitDlg)
        {
            BringWindowToTop(hwndParent);
            ShowWindow(hwndWaitDlg,SW_HIDE);
        }
        
        if (dwfOptions & INETCFG_SUPPRESSINSTALLUI)
        {
            dwRet = lpIcfgInstallInetComponents(hwndParent, dwfInstallOptions, &fNeedsRestart);
            //
            // Display error message only if it failed due to something 
            // other than user cancel
            //
            if ((ERROR_SUCCESS != dwRet) && (ERROR_CANCELLED != dwRet))
            {
                TCHAR   szErrorText[MAX_ERROR_TEXT+1]=TEXT("");
                
                // Get the text of the error message and display it.
                if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
                {
                    MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
                }
            }
        }
        else
        {
            // structure to pass to dialog to fill out
            NEEDDRIVERSDLGINFO NeedDriversDlgInfo;
            NeedDriversDlgInfo.dwfOptions = dwfInstallOptions;
            NeedDriversDlgInfo.lpfNeedsRestart = &fNeedsRestart;
            
            // Clear out the last error code so we can safely use it.
            SetLastError(ERROR_SUCCESS);
            
            // Display a dialog and allow the user to cancel install
            int iRet = (int)DialogBoxParam(ghInstance,MAKEINTRESOURCE(IDD_NEEDDRIVERS),hwndParent,
                NeedDriversDlgProc,(LPARAM) &NeedDriversDlgInfo);
            if (0 == iRet)
            {
                // user cancelled
                dwRet = ERROR_CANCELLED;
            }
            else if (-1 == iRet)
            {
                // an error occurred.
                dwRet = GetLastError();
                if (ERROR_SUCCESS == dwRet)
                {
                    // Error occurred, but the error code was not set.
                    dwRet = ERROR_INETCFG_UNKNOWN;
                }
            }
        }
    }
    
    if ( (ERROR_SUCCESS == dwRet) && (TRUE == IsNT()) && (dwfOptions & INETCFG_INSTALLMODEM))
    {
        BOOL bNeedModem = FALSE;
        
        if (NULL == lpIcfgNeedModem)
        {
            //
            // 4/2/97 ChrisK Olympus 209
            //
            if (NULL != hwndWaitDlg)
            {
                BringWindowToTop(hwndParent);
                DestroyWindow(hwndWaitDlg);
                hwndWaitDlg = NULL;
            }
            
            return ERROR_GEN_FAILURE;
        }
        
        //
        // 4/2/97 ChrisK Olympus 209
        // Show busy dialog here, this can take a few seconds
        //
        if (NULL != hwndWaitDlg)
            ShowWindow(hwndWaitDlg,SW_SHOW);
        
        dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
        if (ERROR_SUCCESS != dwRet)
        {
            //
            // 4/2/97 ChrisK Olympus 209
            //
            if (NULL != hwndWaitDlg)
            {
                BringWindowToTop(hwndParent);
                DestroyWindow(hwndWaitDlg);
                hwndWaitDlg = NULL;
            }
            
            return dwRet;
        }
        
        if (TRUE == bNeedModem)
        {
            if (IsNT5() == TRUE)
            {
                bNT5NeedModem = bNeedModem;
            }
            else
            {
                // 4/2/97 ChrisK Olympus 209
                if (NULL != hwndWaitDlg)
                {  
                    BringWindowToTop(hwndParent);
                    DestroyWindow(hwndWaitDlg);
                    hwndWaitDlg = NULL;
                }
            
                MsgBoxParam(hwndParent,IDS_ERRNoDialOutModem,MB_ICONERROR,MB_OK);
                return ERROR_GEN_FAILURE;
            }
        }

        //
        // 7/15/97    jmazner    Olympus #6294
        // make sure TAPI location info is valid
        //
        if (!InitTAPILocation(hwndParent))
        {
            if (NULL != hwndWaitDlg)
            {  
                BringWindowToTop(hwndParent);
                DestroyWindow(hwndWaitDlg);
                hwndWaitDlg = NULL;
            }
        
            return ERROR_CANCELLED;
        }

    }
    
    // 4/2/97 ChrisK Olympus 209
    if (NULL != hwndWaitDlg)
    {
        BringWindowToTop(hwndParent);
        ShowWindow(hwndWaitDlg,SW_HIDE);
    }
    
    // See if we are supposed to check if file sharing is turned on
    if (ERROR_SUCCESS == dwRet && !(ValidateProductSuite( TEXT("Small Business") )))
    {
        BOOL fNeedsRestartTmp = FALSE;
        if (dwfOptions & INETCFG_REMOVEIFSHARINGBOUND)
        {
            // Tell user that we cannot continue unless binding is removed.
            dwRet = RemoveIfServerBound(hwndParent,
                (dwfOptions & INETCFG_CONNECTOVERLAN)? INSTANCE_NETDRIVER : INSTANCE_PPPDRIVER, &fNeedsRestartTmp);
        }
        else if (dwfOptions & INETCFG_WARNIFSHARINGBOUND)
        {
            // Warn user that binding should be removed.
            dwRet = WarnIfServerBound(hwndParent,
                (dwfOptions & INETCFG_CONNECTOVERLAN)?INSTANCE_NETDRIVER : INSTANCE_PPPDRIVER, &fNeedsRestartTmp);
        }
        
        // If the settings were removed, we need to reboot.
        if ((ERROR_SUCCESS == dwRet) && (TRUE == fNeedsRestartTmp))
        {
            fNeedsRestart = TRUE;
        }

        // If user installed net component but we need cancel F&P sharing, we still need to restart
        // or NT becomes unstable - Bug 68641
        if(ERROR_CANCELLED == dwRet && fNeedsRestart && IsNT())
            dwRet = ERROR_SUCCESS;
    }
    
    // 4/2/97 ChrisK Olympus 209
    // Dismiss dialog for good
    if (NULL != hwndWaitDlg)
    {
        BringWindowToTop(hwndParent);
        DestroyWindow(hwndWaitDlg);
        hwndWaitDlg = NULL;
    }
      
    //
    // If not NT then we install the modem after installing RAS
    //
    // See if we are supposed to install a modem
    if (((FALSE == IsNT()) || (bNT5NeedModem))  && (ERROR_SUCCESS == dwRet) && 
        (dwfOptions & INETCFG_INSTALLMODEM))
    {
        // Load RNA if not already loaded since ENUM_MODEM needs it.
        dwRet = EnsureRNALoaded();
        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }
        
        
        // Enumerate the modems 
        ENUM_MODEM  EnumModem;
        dwRet = EnumModem.GetError();
        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }

        // If there are no modems, install one if requested.
        if (0 == EnumModem.GetNumDevices())
        {    
            //
            // 5/22/97 jmazner    Olympus #4698
            // On Win95, calling RasEnumDevices launches RNAAP.EXE
            // If RNAAP.EXE is running, any modems you install won't be usable
            // So, nuke RNAAP.EXE before installing the modem.
            //
            TCHAR szWindowTitle[255] = TEXT("\0nogood");
            
            //
            // Unload the RAS dll's before killing RNAAP, just to be safe
            //
            DeInitRNA();
            
            LoadSz(IDS_RNAAP_TITLE,szWindowTitle,255);
            HWND hwnd = FindWindow(szWindowTitle, NULL);
            if (NULL != hwnd)
            {
                if (!PostMessage(hwnd, WM_CLOSE, 0, 0))
                {
                    DEBUGMSG("Trying to kill RNAAP window returned getError %d", GetLastError());
                }
            }
        
            // invoke the modem wizard UI to install the modem
            UINT uRet = InvokeModemWizard(hwndParent);
            
            if (ERROR_PRIVILEGE_NOT_HELD == uRet)
            {
                TCHAR szAdminDenied      [MAX_PATH] = TEXT("\0");
                LoadSz(IDS_ADMIN_ACCESS_DENIED, szAdminDenied, MAX_PATH);
                MsgBoxSz(hwndParent,szAdminDenied,MB_ICONEXCLAMATION,MB_OK);
                return ERROR_CANCELLED;

            }
            else if (uRet != ERROR_SUCCESS)
            {
                DisplayErrorMessage(hwndParent,IDS_ERRInstallModem,uRet,
                    ERRCLS_STANDARD,MB_ICONEXCLAMATION);
                return ERROR_INVALID_PARAMETER;
            }
            
            // Reload the RAS dlls now that the modem has been safely installed.
            InitRNA(hwndParent);
        
            // Re-numerate the modems to be sure we have the most recent changes  
            dwRet = EnumModem.ReInit();
            if (ERROR_SUCCESS != dwRet)
            {
                return dwRet;
            }
            
            // If there are still no modems, user cancelled
            if (0 == EnumModem.GetNumDevices())
            {
                return ERROR_CANCELLED;
            }
            else
            {
                // removed per GeoffR request 5-2-97
                ////  96/05/01  markdu  ICW BUG 8049 Reboot if modem is installed.
                //fNeedsRestart = TRUE;
            }
        }
        else
        {
            //
            // 7/15/97    jmazner    Olympus #6294
            // make sure TAPI location info is valid
            //
            // 4/15/99 vyung Tapi changed the location dlg
            if (!InitTAPILocation(hwndParent))
            {
                if (NULL != hwndWaitDlg)
                {  
                    BringWindowToTop(hwndParent);
                    DestroyWindow(hwndWaitDlg);
                    hwndWaitDlg = NULL;
                }

                return ERROR_CANCELLED;
            }
        }
    }
    
    // tell caller whether we need to reboot or not
    if ((ERROR_SUCCESS == dwRet) && (lpfNeedsRestart))
    {
        *lpfNeedsRestart = fNeedsRestart;
    }
    
    // 4/2/97 ChrisK    Olympus 209
    // Sanity check
    if (NULL != hwndWaitDlg)
    {
        BringWindowToTop(hwndParent);
        DestroyWindow(hwndWaitDlg);
        hwndWaitDlg = NULL;
    }
    
    return dwRet;
}




//*******************************************************************
//
//  FUNCTION:   InetNeedSystemComponents
//
//  PURPOSE:    This function will check is components that are needed
//              for internet access (such as TCP/IP and RNA) are already
//                configured based the state of the options flags.
//
//  PARAMETERS: dwfOptions - a combination of INETCFG_ flags that controls
//                                the installation and configuration as follows:
//
//                                INETCFG_INSTALLRNA - install RNA (if needed)
//                                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//
//              lpfNeedsConfig - On return, this will be 
//                                    TRUE if system component(s)
//                                    should be installed
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:    05/02/97  VetriV  Created.
//                05/08/97  ChrisK  Added INSTALLLAN, INSTALLDIALUP, and
//                                  INSTALLTCPONLY
//
//*******************************************************************

extern "C" HRESULT WINAPI InetNeedSystemComponents(DWORD dwfOptions,
                                                      LPBOOL lpbNeedsConfig)
{
    DWORD    dwRet = ERROR_SUCCESS;


    DEBUGMSG("export.cpp::InetNeedSystemComponents()");

    //
    // Validate parameters
    //
    if (!lpbNeedsConfig)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Set up the install options
    //
    DWORD dwfInstallOptions = 0;
    if (dwfOptions & INETCFG_INSTALLTCP)
    {
        dwfInstallOptions |= ICFG_INSTALLTCP;
    }
    if (dwfOptions & INETCFG_INSTALLRNA)
    {
        dwfInstallOptions |= ICFG_INSTALLRAS;
    }

    //
    // ChrisK 5/8/97
    //
    if (dwfOptions & INETCFG_INSTALLLAN)
    {
        dwfInstallOptions |= ICFG_INSTALLLAN;
    }
    if (dwfOptions & INETCFG_INSTALLDIALUP)
    {
        dwfInstallOptions |= ICFG_INSTALLDIALUP;
    }
    if (dwfOptions & INETCFG_INSTALLTCPONLY)
    {
        dwfInstallOptions |= ICFG_INSTALLTCPONLY;
    }

  
    //
    // see if we need to install drivers
    //
    BOOL  bNeedSysComponents = FALSE;

    dwRet = lpIcfgNeedInetComponents(dwfInstallOptions, &bNeedSysComponents);

    if (ERROR_SUCCESS != dwRet)
    {
        TCHAR   szErrorText[MAX_ERROR_TEXT+1]=TEXT("");

        //
        // Get the text of the error message and display it.
        //
        if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
        {
            DEBUGMSG(szErrorText);
        }

        return dwRet;
    }

    
    *lpbNeedsConfig = bNeedSysComponents;
    return ERROR_SUCCESS;
}

  

//*******************************************************************
//
//  FUNCTION:   InetNeedModem
//
//  PURPOSE:    This function will check if modem is needed or not
//
//  PARAMETERS: lpfNeedsConfig - On return, this will be 
//                                    TRUE if modem
//                                    should be installed
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:    05/02/97  VetriV  Created.
//
//*******************************************************************

extern "C" HRESULT WINAPI InetNeedModem(LPBOOL lpbNeedsModem)
{

    DWORD dwRet = ERROR_SUCCESS;
        
    //
    // Validate parameters
    //
    if (!lpbNeedsModem)
    {
        return ERROR_INVALID_PARAMETER;
    }

    
    if (TRUE == IsNT())
    {
        //
        // On NT call icfgnt.dll to determine if modem is needed
        //
        BOOL bNeedModem = FALSE;
        
        if (NULL == lpIcfgNeedModem)
        {
            return ERROR_GEN_FAILURE;
        }
    

        dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }

        *lpbNeedsModem = bNeedModem;
        return ERROR_SUCCESS;
    }
    else
    {
        //
        // Load RNA if not already loaded since ENUM_MODEM needs it.
        //
        dwRet = EnsureRNALoaded();
        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }

        //
        // Enumerate the modems
        //
        ENUM_MODEM  EnumModem;
        dwRet = EnumModem.GetError();
        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }

        //
        // If there are no modems, we need to install one
        //
        if (0 == EnumModem.GetNumDevices())
        {
            *lpbNeedsModem = TRUE;
        }
        else
        {
            *lpbNeedsModem = FALSE;
        }
        return ERROR_SUCCESS;
    }
}



//*******************************************************************
//
//  FUNCTION:   InetConfigSystemFromPath
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags and from the given [ath.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install exchange and internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//              lpszSourcePath - full path of location of files to install.  If
//              this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/04/29  markdu  Created.
//
//*******************************************************************

#ifdef UNICODE
HRESULT WINAPI InetConfigSystemFromPathA
(
  HWND hwndParent,
  DWORD dwfOptions,
  LPBOOL lpfNeedsRestart,
  LPCSTR lpszSourcePath
)
{
  TCHAR  szSourcePath[MAX_PATH+1];
  mbstowcs(szSourcePath, lpszSourcePath, lstrlenA(lpszSourcePath)+1);
  return InetConfigSystemFromPathW(hwndParent, dwfOptions,
                                   lpfNeedsRestart, szSourcePath);
}

HRESULT WINAPI InetConfigSystemFromPathW
#else
HRESULT WINAPI InetConfigSystemFromPathA
#endif
(
  HWND hwndParent,
  DWORD dwfOptions,
  LPBOOL lpfNeedsRestart,
  LPCTSTR lpszSourcePath
)
{
  DWORD dwRet;

  DEBUGMSG("export.c::InetConfigSystemFromPath()");

  // Validate the parent hwnd
  if (hwndParent && !IsWindow(hwndParent))
  {
    return ERROR_INVALID_PARAMETER;
  }

  // Set the install path here
  if (lpszSourcePath && lstrlen(lpszSourcePath))
  {
    dwRet = lpIcfgSetInstallSourcePath(lpszSourcePath);

    if (ERROR_SUCCESS != dwRet)
    {
      return dwRet;
    }
  }

  // Install files if needed.
  dwRet = InetConfigSystem(hwndParent,
    dwfOptions, lpfNeedsRestart);

  return dwRet;
}


//*******************************************************************
//
//  FUNCTION:   InetConfigClient
//
//  PURPOSE:    This function requires a valid phone book entry name
//              (unless it is being used just to set the client info).
//              If lpRasEntry points to a valid RASENTRY struct, the phone
//              book entry will be created (or updated if it already exists)
//              with the data in the struct.
//              If username and password are given, these
//              will be set as the dial params for the phone book entry.
//              If a client info struct is given, that data will be set.
//              Any files (ie TCP and RNA) that are needed will be
//              installed by calling InetConfigSystem().
//              This function will also perform verification on the device
//              specified in the RASENTRY struct.  If no device is specified,
//              the user will be prompted to install one if there are none
//              installed, or they will be prompted to choose one if there
//              is more than one installed.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              lpszPhonebook - name of phone book to store the entry in
//              lpszEntryName - name of phone book entry to be
//              created or modified
//              lpRasEntry - specifies a RASENTRY struct that contains
//              the phone book entry data for the entry lpszEntryName
//              lpszUsername - username to associate with the phone book entry
//              lpszPassword - password to associate with the phone book entry
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//              lpINetClientInfo - client information
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install exchange and internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.  Note that if
//                                       no modem is installed and this flag
//                                       is not set, the function will fail
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_SETASAUTODIAL - Set the phone book entry for autodial
//                INETCFG_OVERWRITEENTRY - Overwrite the phone book entry if it
//                                         exists.  Note: if this flag is not
//                                         set, and the entry exists, a unique
//                                         name will be created for the entry.
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/11  markdu  Created.
//
//*******************************************************************

#ifdef UNICODE
extern "C" HRESULT WINAPI InetConfigClientA
(
  HWND              hwndParent,
  LPCSTR            lpszPhonebook,
  LPCSTR            lpszEntryName,
  LPRASENTRY        lpRasEntry,
  LPCSTR            lpszUsername,
  LPCSTR            lpszPassword,
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFOA lpINetClientInfo,
  DWORD             dwfOptions,
  LPBOOL            lpfNeedsRestart
)
{
  LPTSTR pszPhonebook = NULL;
  LPTSTR pszEntryName = NULL;
  LPTSTR pszUsername = NULL;
  LPTSTR pszPassword = NULL;
  LPTSTR pszProfileName = NULL;
  INETCLIENTINFOW *pINetClientInfo = NULL;
  
  TCHAR szPhonebook[sizeof(TCHAR*)*(MAX_PATH+1)]    = TEXT("");
  TCHAR szEntryName[sizeof(TCHAR*)*(MAX_PATH+1)]    = TEXT("");
  TCHAR szUsername[sizeof(TCHAR*)*(MAX_PATH+1)]     = TEXT("");
  TCHAR szPassword[sizeof(TCHAR*)*(MAX_PATH+1)]     = TEXT("");
  TCHAR szProfileName[sizeof(TCHAR*)*(MAX_PATH+1)]  = TEXT("");
  INETCLIENTINFOW   INetClientInfo;

  if (NULL != lpszPhonebook)
  {
    mbstowcs(szPhonebook,   lpszPhonebook,   lstrlenA(lpszPhonebook)+1);
    pszPhonebook = szPhonebook;
  }
  if (NULL != lpszEntryName)
  {
    mbstowcs(szEntryName,   lpszEntryName,   lstrlenA(lpszEntryName)+1);
    pszEntryName = szEntryName;
  }
  if (NULL != lpszUsername)
  {
    mbstowcs(szUsername,    lpszUsername,    lstrlenA(lpszUsername)+1);
    pszUsername = szUsername;
  }
  if (NULL != lpszPassword)
  {
    mbstowcs(szPassword,    lpszPassword,    lstrlenA(lpszPassword)+1);
    pszPassword = szPassword;
  }
  if (NULL != lpszProfileName)
  {
    mbstowcs(szProfileName, lpszProfileName, lstrlenA(lpszProfileName)+1);
    pszProfileName = szProfileName;
  }

  if (lpINetClientInfo)
  {
    ToUnicodeClientInfo(&INetClientInfo, lpINetClientInfo);
    pINetClientInfo = &INetClientInfo;
  }

  return InetConfigClientW(hwndParent,
                           pszPhonebook,
                           pszEntryName,
                           lpRasEntry,
                           pszUsername,
                           pszPassword,
                           pszProfileName,
                           pINetClientInfo,
                           dwfOptions,
                           lpfNeedsRestart);
}

extern "C" HRESULT WINAPI InetConfigClientW
#else
extern "C" HRESULT WINAPI InetConfigClientA
#endif
(
  HWND              hwndParent,
  LPCTSTR           lpszPhonebook,
  LPCTSTR           lpszEntryName,
  LPRASENTRY        lpRasEntry,
  LPCTSTR           lpszUsername,
  LPCTSTR           lpszPassword,
  LPCTSTR           lpszProfileName,
  LPINETCLIENTINFO  lpINetClientInfo,
  DWORD             dwfOptions,
  LPBOOL            lpfNeedsRestart
)
{
  TCHAR szConnectoidName[MAX_ISP_NAME + 1] = TEXT("");
  BOOL  fNeedsRestart = FALSE;  // Default to no reboot needed
  HWND hwndWaitDlg = NULL;
  DEBUGMSG("export.c::InetConfigClient()");

  // Install files if needed.
  // Note:  the parent hwnd is validated in InetConfigSystem
  // We must also mask out the InstallModem flag since we want to
  // do that here, not in InetConfigSystem
  DWORD dwRet = InetConfigSystem(hwndParent,
    dwfOptions & ~INETCFG_INSTALLMODEM, &fNeedsRestart);
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  // 4/2/97 ChrisK Olympus 209 Display busy dialog
  if (INETCFG_SHOWBUSYANIMATION == (dwfOptions & INETCFG_SHOWBUSYANIMATION))
      hwndWaitDlg = WaitCfgInit(hwndParent,IDS_WAITCONNECT);
  
    
  // Make sure we have a connectoid name
  if (lpszEntryName && lstrlen(lpszEntryName))
  {
    // Copy the name into a private buffer in case we have 
    // to muck around with it
    lstrcpyn(szConnectoidName, lpszEntryName, sizeof(szConnectoidName)/sizeof(TCHAR));

    // Make sure the name is valid.
    dwRet = ValidateConnectoidName(lpszPhonebook, szConnectoidName);
    if ((ERROR_SUCCESS == dwRet) ||
      (ERROR_ALREADY_EXISTS == dwRet))
    {
      // Find out if we can overwrite an existing connectoid
      if (!(dwfOptions & INETCFG_OVERWRITEENTRY) &&
        (ERROR_ALREADY_EXISTS == dwRet))
      {
        TCHAR szConnectoidNameBase[MAX_ISP_NAME + 1];

        // Create a base string that is truncated to leave room for a space
        // and a 3-digit number to be appended.  So, the buffer size will be
        // MAX_ISP_NAME + 1 - (LEN_APPEND_INT + 1)
        lstrcpyn(szConnectoidNameBase, szConnectoidName,
          MAX_ISP_NAME - LEN_APPEND_INT);

        // If the entry exists, we have to create a unique name
        int nSuffix = 2;
        while ((ERROR_ALREADY_EXISTS == dwRet) && (nSuffix < MAX_APPEND_INT))
        {
          // Add the integer to the end of the base string and then bump it
          wsprintf(szConnectoidName, szFmtAppendIntToString,
            szConnectoidNameBase, nSuffix++);

          // Validate this new name
          dwRet = ValidateConnectoidName(lpszPhonebook, szConnectoidName);
        }

        // If we could not create a unique name, bail
        // Note that dwRet should still be ERROR_ALREADY_EXISTS in this case
        if (nSuffix >= MAX_APPEND_INT)
        {
          if (NULL != hwndWaitDlg)
              DestroyWindow(hwndWaitDlg);
          hwndWaitDlg = NULL;
          return dwRet;
        }
      }

      if (lpRasEntry && lpRasEntry->dwSize == sizeof(RASENTRY))
      {    
        // Create a connectoid with given properties
        dwRet = MakeConnectoid(hwndParent, dwfOptions, lpszPhonebook,
          szConnectoidName, lpRasEntry, lpszUsername, lpszPassword, &fNeedsRestart);
      }

      // If we created a connectoid, we already updated the dial params
      // with the user name and password.  However, if we didn't create a
      // connectoid we still may need to update dial params of an existing one
      else if ((lpszUsername && lstrlen(lpszUsername)) ||
              (lpszPassword && lstrlen(lpszPassword)))
      {
        // Update the dial params for the given connectoid. 
        dwRet = SetConnectoidUsername(lpszPhonebook, szConnectoidName,
          lpszUsername, lpszPassword);
      }

      // If the connectoid was created/updated successfully, see
      // if it is supposed to be set as the autodial connectoid.
      if ((ERROR_SUCCESS == dwRet) && (dwfOptions & INETCFG_SETASAUTODIAL))
      {
        dwRet = InetSetAutodial((DWORD)TRUE, szConnectoidName);

        // make sure "The Internet" icon on desktop points to web browser
        // (it may initially be pointing at internet wizard)
        // 96/04/22 markdu  NASH BUG 18901 Do not do this for temp connectoids.

        if (!(dwfOptions & INETCFG_TEMPPHONEBOOKENTRY))
        {
            //    //10/24/96 jmazner Normandy 6968
            //    //No longer neccessary thanks to Valdon's hooks for invoking ICW.
            // 11/21/96 jmazner Normandy 11812
            // oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
            // ICW 1.1 needs to morph the IE 3 icon.
          SetDesktopInternetIconToBrowser();
        }

      }
    }
  }

  // Now set the client info if provided and no errors have occurred yet.
  if (ERROR_SUCCESS == dwRet)
  {
    if (NULL != lpINetClientInfo)
    {
      dwRet = InetSetClientInfo(lpszProfileName, lpINetClientInfo);
      if (ERROR_SUCCESS != dwRet)
      {
        if (NULL != hwndWaitDlg)
          DestroyWindow(hwndWaitDlg);
        hwndWaitDlg = NULL;
        return dwRet;
      }
      // update IE news settings
      dwRet = SetIEClientInfo(lpINetClientInfo);
      if (ERROR_SUCCESS != dwRet)
      {
        if (NULL != hwndWaitDlg)
          DestroyWindow(hwndWaitDlg);
        hwndWaitDlg = NULL;
        return dwRet;
      }
    }

    // Now update the mail client if we were asked to do so.
    // Note: if we got here without errors, and INETCFG_INSTALLMAIL is set,
    // then mail has been installed by now.
    if (dwfOptions & INETCFG_INSTALLMAIL)
    {
      INETCLIENTINFO    INetClientInfo;
      ZeroMemory(&INetClientInfo, sizeof(INETCLIENTINFO));
      INetClientInfo.dwSize = sizeof(INETCLIENTINFO);

      // Use a temp pointer that we can modify.
      LPINETCLIENTINFO  lpTmpINetClientInfo = lpINetClientInfo;

      // If no client info struct was given, try to get the profile by name
      if ((NULL == lpTmpINetClientInfo) && (NULL != lpszProfileName) &&
        lstrlen(lpszProfileName))
      {
        lpTmpINetClientInfo = &INetClientInfo;
        dwRet = InetGetClientInfo(lpszProfileName, lpTmpINetClientInfo);
        if (ERROR_SUCCESS != dwRet)
        {
          if (NULL != hwndWaitDlg)
            DestroyWindow(hwndWaitDlg);
          hwndWaitDlg = NULL;
          return dwRet;
        }
      }

      // If we still don't have client info, we should enumerate the profiles
      // If there is one profile, get it.  If multiple, show UI to allow user
      // to choose.  If none, there is nothing to do at this point.
      // For now, we don't support enumeration, so just try to get the default.
      if (NULL == lpTmpINetClientInfo)
      {
        lpTmpINetClientInfo = &INetClientInfo;
        dwRet = InetGetClientInfo(NULL, lpTmpINetClientInfo);
        if (ERROR_SUCCESS != dwRet)
        {
          if (NULL != hwndWaitDlg)
            DestroyWindow(hwndWaitDlg);
          hwndWaitDlg = NULL;
          return dwRet;
        }
      }

      // If we have client info, update mail settings.
      if (NULL != lpTmpINetClientInfo)
      {
        dwRet = UpdateMailSettings(hwndParent, lpTmpINetClientInfo,
          szConnectoidName);
      }
    }
  }

  // tell caller whether we need to reboot or not
  if ((ERROR_SUCCESS == dwRet) && (lpfNeedsRestart))
  {
    *lpfNeedsRestart = fNeedsRestart;
  }

  if (NULL != hwndWaitDlg)
    DestroyWindow(hwndWaitDlg);
  hwndWaitDlg = NULL;

  return dwRet;
}


//*******************************************************************
//
//  FUNCTION:   UpdateMailSettings
//
//  PURPOSE:    This function will update the settings for mail in
//              the profile of the user's choice.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "choose profile"
//              dialog.
//              lpINetClientInfo - client information
//              lpszEntryName - name of phone book entry to be
//              set for connection.
//  
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/26  markdu  Created.
//
//*******************************************************************

HRESULT UpdateMailSettings(
  HWND              hwndParent,
  LPINETCLIENTINFO  lpINetClientInfo,
  LPTSTR             lpszEntryName)
{
  DWORD         dwRet = ERROR_SUCCESS;
  MAILCONFIGINFO MailConfigInfo;
  ZeroMemory(&MailConfigInfo,sizeof(MAILCONFIGINFO));  // zero out structure
 
  if (NULL == gpWizardState)
  {
    gpWizardState = new WIZARDSTATE;
    ASSERT(gpWizardState);
    if (gpWizardState)
    {
      InitWizardState(gpWizardState, 0);
    }
    else
    {
      return ERROR_OUTOFMEMORY;
    }
  }
  // call MAPI to set up profile and store this information in it
  if (InitMAPI(hwndParent))
  {
    CHOOSEPROFILEDLGINFO ChooseProfileDlgInfo;
    ZeroMemory(&ChooseProfileDlgInfo, sizeof(CHOOSEPROFILEDLGINFO));
    ChooseProfileDlgInfo.fSetProfileAsDefault = TRUE;

    ENUM_MAPI_PROFILE* pEnumMapiProfile = new(ENUM_MAPI_PROFILE);

    if (pEnumMapiProfile && pEnumMapiProfile->GetEntryCount()) 
    {
      // Display a dialog and allow the user to select/create profile
      BOOL fRet=(BOOL)DialogBoxParam(ghInstance,MAKEINTRESOURCE(IDD_CHOOSEPROFILENAME),
        hwndParent, ChooseProfileDlgProc,(LPARAM) &ChooseProfileDlgInfo);
      if (FALSE == fRet)
      {
        // user cancelled, bail
        return ERROR_CANCELLED;
      }
    }

    if (pEnumMapiProfile)
    {
      delete(pEnumMapiProfile);
      pEnumMapiProfile = NULL;
    }

    // set up a structure with mail config information
    MailConfigInfo.pszEmailAddress = lpINetClientInfo->szEMailAddress;
    MailConfigInfo.pszEmailServer = lpINetClientInfo->szPOPServer;
    MailConfigInfo.pszEmailDisplayName = lpINetClientInfo->szEMailName;
    MailConfigInfo.pszEmailAccountName = lpINetClientInfo->szPOPLogonName;
    MailConfigInfo.pszEmailAccountPwd = lpINetClientInfo->szPOPLogonPassword;
    MailConfigInfo.pszConnectoidName = lpszEntryName;
    MailConfigInfo.fRememberPassword = TRUE;
    MailConfigInfo.pszProfileName = ChooseProfileDlgInfo.szProfileName;
    MailConfigInfo.fSetProfileAsDefault = ChooseProfileDlgInfo.fSetProfileAsDefault;

    // BUGBUG SMTP

    // set up the profile through MAPI
    dwRet = SetMailProfileInformation(&MailConfigInfo);
    if (ERROR_SUCCESS != dwRet)
    {
      DisplayErrorMessage(hwndParent,IDS_ERRConfigureMail,
        (DWORD) dwRet,ERRCLS_MAPI,MB_ICONEXCLAMATION);
    }

    DeInitMAPI();
  }
  else
  {
    // an error occurred.
    dwRet = GetLastError();
    if (ERROR_SUCCESS == dwRet)
    {
      // Error occurred, but the error code was not set.
      dwRet = ERROR_INETCFG_UNKNOWN;
    }
  }

  return dwRet;
}


//*******************************************************************
//
//  FUNCTION:   MakeConnectoid
//
//  PURPOSE:    This function will create a connectoid with the
//              supplied name if lpRasEntry points to a valid RASENTRY
//              struct.  If username and password are given, these
//              will be set as the dial params for the connectoid.
//
//  PARAMETERS: 
//  hwndParent - window handle of calling application.  This
//               handle will be used as the parent for any dialogs that
//               are required for error messages or the "choose modem"
//               dialog.
//  dwfOptions - a combination of INETCFG_ flags that controls
//               the installation and configuration.
//  lpszPhonebook - name of phone book to store the entry in
//  lpszEntryName  - name of connectoid to create/modify
//  lpRasEntry - connectoid data
//  lpszUsername - username to associate with connectoid
//  lpszPassword - password to associate with connectoid
//  lpfNeedsRestart - set to true if we need a restart.  Note that
//                    since this is an internal helper function, we
//                    assume that the pointer is valid, and we don't
//                    initialize it (we only touch it if we are setting
//                    it to TRUE).
//  
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/12  markdu  Created.
//
//*******************************************************************

DWORD MakeConnectoid(
  HWND        hwndParent,
  DWORD       dwfOptions,
  LPCTSTR     lpszPhonebook,
  LPCTSTR     lpszEntryName,
  LPRASENTRY  lpRasEntry,
  LPCTSTR     lpszUsername,
  LPCTSTR     lpszPassword,
  LPBOOL      lpfNeedsRestart)
{
  DWORD dwRet;

  ASSERT(lpfNeedsRestart);
  
  if (dwfOptions & RASEO_UseCountryAndAreaCodes)
  {
    if ((0 == lpRasEntry->dwCountryCode) || (0 == lpRasEntry->dwCountryID))
        return ERROR_INVALID_PARAMETER;
  }
        
  if (0 == lstrlen(lpRasEntry->szLocalPhoneNumber))
  {
    return ERROR_INVALID_PARAMETER;  
  }
  
  
  // Load RNA if not already loaded since ENUM_MODEM needs it.
  dwRet = EnsureRNALoaded();
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  //
  // Enumerate the modems 
  //
  ENUM_MODEM  EnumModem;
  dwRet = EnumModem.GetError();
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }


    if (TRUE == IsNT())
    {
        BOOL bNeedModem = FALSE;
        
        if (NULL == lpIcfgNeedModem)
            return ERROR_GEN_FAILURE;
        
        dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }

        if (TRUE == bNeedModem)
        {
            if (NULL == lpIcfgInstallModem)
                return ERROR_GEN_FAILURE;

            dwRet = (*lpIcfgInstallModem)(NULL, 0,     lpfNeedsRestart);

            //
            // TODO: Check to see if user cancelled
            //
        }
    }
    else
    {
  // If there are no modems, install one if requested.
  if (0 == EnumModem.GetNumDevices())
  {
    if (!(dwfOptions & INETCFG_INSTALLMODEM))
    {
      // We have not been asked to install a modem, so there
      // is nothing further we can do.
      return ERROR_INVALID_PARAMETER;
    }

    if (FALSE == IsNT())
    {
        //
        // 5/22/97 jmazner    Olympus #4698
        // On Win95, calling RasEnumDevices launches RNAAP.EXE
        // If RNAAP.EXE is running, any modems you install won't be usable
        // So, nuke RNAAP.EXE before installing the modem.
        //
        TCHAR szWindowTitle[255] = TEXT("\0nogood");

        //
        // Unload the RAS dll's before killing RNAAP, just to be safe
        //
        DeInitRNA();

        LoadSz(IDS_RNAAP_TITLE,szWindowTitle,255);
        HWND hwnd = FindWindow(szWindowTitle, NULL);
        if (NULL != hwnd)
        {
            if (!PostMessage(hwnd, WM_CLOSE, 0, 0))
            {
                DEBUGMSG("Trying to kill RNAAP window returned getError %d", GetLastError());
            }
        }
    }

    // invoke the modem wizard UI to install the modem
    UINT uRet = InvokeModemWizard(NULL);

    if (uRet != ERROR_SUCCESS)
    {
      DisplayErrorMessage(hwndParent,IDS_ERRInstallModem,uRet,
        ERRCLS_STANDARD,MB_ICONEXCLAMATION);
      return ERROR_INVALID_PARAMETER;
    }

    if (FALSE == IsNT())
    {
        // Reload the RAS dlls now that the modem has been safely installed.
        InitRNA(hwndParent);
    }


    // Re-numerate the modems to be sure we have the most recent changes  
    dwRet = EnumModem.ReInit();
    if (ERROR_SUCCESS != dwRet)
    {
      return dwRet;
    }

    // If there are still no modems, user cancelled
    if (0 == EnumModem.GetNumDevices())
    {
      return ERROR_CANCELLED;
    }
    else
    {
        // ChrisK 5-2-97    Removed per GeoffR
        // //  96/05/01  markdu  ICW BUG 8049 Reboot if modem is installed.
        // *lpfNeedsRestart = TRUE;
    }
  }
    }

  // Validate the device if possible
  if (lstrlen(lpRasEntry->szDeviceName) && lstrlen(lpRasEntry->szDeviceType))
  {
    // Verify that there is a device with the given name and type
    if (!EnumModem.VerifyDeviceNameAndType(lpRasEntry->szDeviceName, 
      lpRasEntry->szDeviceType))
    {
      // There was no device that matched both name and type,
      // so reset the strings and bring up the choose modem UI.
      lpRasEntry->szDeviceName[0] = '\0';
      lpRasEntry->szDeviceType[0] = '\0';
    }
  }
  else if (lstrlen(lpRasEntry->szDeviceName))
  {
    // Only the name was given.  Try to find a matching type.
    // If this fails, fall through to recovery case below.
    LPTSTR szDeviceType = 
      EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName);
    if (szDeviceType)
    {
      lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
    }
  }
  else if (lstrlen(lpRasEntry->szDeviceType))
  {
    // Only the type was given.  Try to find a matching name.
    // If this fails, fall through to recovery case below.
    LPTSTR szDeviceName = 
      EnumModem.GetDeviceNameFromType(lpRasEntry->szDeviceType);
    if (szDeviceName)
    {
      lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
    }
  }

  // If either name or type is missing, bring up choose modem UI if there
  // are multiple devices, else just get first device.
  // Since we already verified that there was at least one device,
  // we can assume that this will succeed.
  if(!lstrlen(lpRasEntry->szDeviceName) ||
     !lstrlen(lpRasEntry->szDeviceType))
  {
    if (1 == EnumModem.GetNumDevices())
    {
      // There is just one device installed, so copy the name
      lstrcpy (lpRasEntry->szDeviceName, EnumModem.Next());
    }
    else
    {
      // structure to pass to dialog to fill out
      CHOOSEMODEMDLGINFO ChooseModemDlgInfo;

      // Display a dialog and allow the user to select modem
      BOOL fRet=(BOOL)DialogBoxParam(ghInstance,MAKEINTRESOURCE(IDD_CHOOSEMODEMNAME),hwndParent,
        ChooseModemDlgProc,(LPARAM) &ChooseModemDlgInfo);
      if (FALSE == fRet)
      {
        // user cancelled or an error occurred.
        dwRet = GetLastError();
        if (ERROR_SUCCESS == dwRet)
        {
          // Error occurred, but the error code was not set.
          dwRet = ERROR_INETCFG_UNKNOWN;
        }
        return dwRet;
      }

      // Copy the modem name string
      lstrcpy (lpRasEntry->szDeviceName, ChooseModemDlgInfo.szModemName);
    }

    // Now get the type string for this modem
    lstrcpy (lpRasEntry->szDeviceType,
      EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName));
    ASSERT(lstrlen(lpRasEntry->szDeviceName));
    ASSERT(lstrlen(lpRasEntry->szDeviceType));
  }

  // Create a connectoid with given properties
  dwRet = CreateConnectoid(lpszPhonebook, lpszEntryName, lpRasEntry,
    lpszUsername,lpszPassword);

  //  96/05/06  markdu  NASH BUG 21027  If DNS is set globally, clear it out so
  //            the per-connectoid settings will be saved.
  BOOL  fTemp;
  DoDNSCheck(hwndParent,&fTemp);
  if (TRUE == fTemp)
  {
    *lpfNeedsRestart = TRUE;
  }

  return dwRet;
}


//*******************************************************************
//
//  FUNCTION:   InetGetAutodial
//
//  PURPOSE:    This function will get the autodial settings from the registry.
//
//  PARAMETERS: lpfEnable - on return, this will be TRUE if autodial
//              is enabled
//              lpszEntryName - on return, this buffer will contain the 
//              name of the phone book entry that is set for autodial
//              cbEntryNameSize - size of buffer for phone book entry name
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/11  markdu  Created.
//
//*******************************************************************

#ifdef UNICODE
extern "C" HRESULT WINAPI InetGetAutodialA
(
  LPBOOL lpfEnable,
  LPSTR  lpszEntryName,
  DWORD  cbEntryNameSize
)
{
  HRESULT hr;
  TCHAR   *szEntryName = (TCHAR *)new TCHAR[cbEntryNameSize+1];

  if(szEntryName == NULL)
  {
      lpszEntryName[0] = '\0';
      return ERROR_NOT_ENOUGH_MEMORY;
  }
  
  hr = InetGetAutodialW(lpfEnable, szEntryName, (cbEntryNameSize)*sizeof(TCHAR));

  if (hr == ERROR_SUCCESS)
  {
    wcstombs(lpszEntryName, szEntryName, cbEntryNameSize);
  }
  
  delete [] szEntryName;

  return hr;
}

extern "C" HRESULT WINAPI InetGetAutodialW
#else
extern "C" HRESULT WINAPI InetGetAutodialA
#endif
(
  LPBOOL lpfEnable,
  LPTSTR lpszEntryName,
  DWORD  cbEntryNameSize
)
{
  HRESULT dwRet;

  DEBUGMSG("export.c::InetGetAutodial()");

  ASSERT(lpfEnable);
  ASSERT(lpszEntryName);
  ASSERT(cbEntryNameSize);

  if (!lpfEnable || !lpszEntryName || (cbEntryNameSize == 0))
  {
    return ERROR_BAD_ARGUMENTS;
  }

  HINSTANCE hInst = NULL;
  FARPROC fp = NULL;

  hInst = LoadLibrary(cszWininet);
  
  if (hInst)
  {
    fp = GetProcAddress(hInst,cszInternetQueryOption);
    if (fp)
    {
      CHAR  szDefaultConnection[RAS_MaxEntryName+1];
      DWORD cchDefaultConnection = 
        sizeof(szDefaultConnection) / sizeof(szDefaultConnection[0]);

      // cchDefaultConnection counts the null-terminator
      if (!((INTERNETQUERYOPTION)(fp))(
        NULL,
        INTERNET_OPTION_AUTODIAL_CONNECTION,
        szDefaultConnection,
        &cchDefaultConnection
        ))
      {
        dwRet = GetLastError();
      }
      else if ((cchDefaultConnection * sizeof(TCHAR)) > cbEntryNameSize)
      {
        dwRet = ERROR_INSUFFICIENT_BUFFER;
      }
      else
      {
        dwRet = ERROR_SUCCESS;

        if (cchDefaultConnection == 0)
        {
          lpszEntryName[0] = TEXT('\0');
        }
        else
        {
        
#ifdef UNICODE
          mbstowcs(lpszEntryName, szDefaultConnection, cchDefaultConnection);
#else
          lstrcpyn(lpszEntryName, szDefaultConnection, cchDefaultConnection);
#endif
        }
      }
    }
    else
    {
      dwRet = GetLastError();
    }
    
    FreeLibrary(hInst);
    hInst = NULL;
  }
  else
  {
    dwRet = GetLastError();
  }
  
  if (ERROR_SUCCESS != dwRet)
  {
  
    // Get the name of the connectoid set for autodial.
    // HKCU\RemoteAccess\InternetProfile
    RegEntry reName(szRegPathRNAWizard,HKEY_CURRENT_USER);
    dwRet = reName.GetError();
    if (ERROR_SUCCESS == dwRet)
    {
      reName.GetString(szRegValInternetProfile,lpszEntryName,cbEntryNameSize);
      dwRet = reName.GetError();
    }
  
    if (ERROR_SUCCESS != dwRet)
    {
      return dwRet;
    }

  }
  // Get setting from registry that indicates whether autodialing is enabled.
  // HKCU\Software\Microsoft\Windows\CurrentVersion\InternetSettings\EnableAutodial
  RegEntry reEnable(szRegPathInternetSettings,HKEY_CURRENT_USER);
  dwRet = reEnable.GetError();
  if (ERROR_SUCCESS == dwRet)
  {
    DWORD dwVal = reEnable.GetNumber(szRegValEnableAutodial, 0);
    dwRet = reEnable.GetError();
    if (ERROR_SUCCESS == dwRet)
    {
      *lpfEnable = dwVal;
    }
  }

  return dwRet;
}


//*******************************************************************
//
//  FUNCTION:   InetSetAutodial
//
//  PURPOSE:    This function will set the autodial settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, autodial will be enabled.
//                        If set to FALSE, autodial will be disabled.
//              lpszEntryName - name of the phone book entry to set
//                              for autodial.  If this is "", the
//                              entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/11  markdu  Created.
//
//*******************************************************************

#ifdef UNICODE
extern "C" HRESULT WINAPI InetSetAutodialA
(
  BOOL fEnable,
  LPCSTR lpszEntryName
)
{
    HRESULT hr;
    LPTSTR  szEntryName;

    szEntryName = ToUnicodeWithAlloc(lpszEntryName);
    hr = InetSetAutodialW(fEnable, szEntryName);
    if(szEntryName)
        GlobalFree(szEntryName);
    return hr;
}

extern "C" HRESULT WINAPI InetSetAutodialW
#else
extern "C" HRESULT WINAPI InetSetAutodialA
#endif
(
  BOOL fEnable,
  LPCTSTR lpszEntryName
)
{
    HRESULT dwRet = ERROR_SUCCESS;
    BOOL    bRet = FALSE;

    DEBUGMSG("export.c::InetSetAutodial()");

    // 2 seperate calls:
    HINSTANCE hInst = NULL;
    FARPROC fp = NULL;

    dwRet = ERROR_SUCCESS;

    hInst = LoadLibrary(cszWininet);
    if (hInst && lpszEntryName)
    {
        fp = GetProcAddress(hInst,cszInternetSetOption);
        if (fp)
        {
            CHAR szNewDefaultConnection[RAS_MaxEntryName+1];
#ifdef UNICODE
            wcstombs(szNewDefaultConnection, lpszEntryName, RAS_MaxEntryName);
#else
            lstrcpyn(szNewDefaultConnection, lpszEntryName, lstrlen(lpszEntryName)+1);
#endif

            bRet = ((INTERNETSETOPTION)fp) (NULL,
                                            INTERNET_OPTION_AUTODIAL_CONNECTION,
                                            szNewDefaultConnection,
                                            strlen(szNewDefaultConnection));

            if (bRet)
            {
                DWORD dwMode = AUTODIAL_MODE_ALWAYS;
                bRet = ((INTERNETSETOPTION)fp) (NULL, INTERNET_OPTION_AUTODIAL_MODE, &dwMode, sizeof(DWORD));
            }
            if( !bRet )
            {
                dwRet = GetLastError();
                DEBUGMSG("INETCFG export.c::InetSetAutodial() InternetSetOption failed");
            }
        }
        else
        {
            dwRet = GetLastError();
        }
    }

    // From DarrnMi, INTERNETSETOPTION for autodial is new for 5.5. 
    // We should try it this way and if the InternetSetOption fails (you'll get invalid option),
    // set the registry the old way.  That'll work everywhere.

    if (!bRet)
    {

        // Set the name if given, else do not change the entry.
        if (lpszEntryName)
        {
            // Set the name of the connectoid for autodial.
            // HKCU\RemoteAccess\InternetProfile
            RegEntry reName(szRegPathRNAWizard,HKEY_CURRENT_USER);
            dwRet = reName.GetError();
            if (ERROR_SUCCESS == dwRet)
            {
                dwRet = reName.SetValue(szRegValInternetProfile,lpszEntryName);
            }
        }

        //
        // 9/9/97 jmazner IE bug #57426
        // IE 4 uses HKEY_CURRENT_CONFIG to store autodial settings based on current
        // hardware config.  We need to update this key as well as HK_CU
        //
        if (ERROR_SUCCESS == dwRet)
        {
            // Set setting in the registry that indicates whether autodialing is enabled.
            // HKCC\Software\Microsoft\Windows\CurrentVersion\InternetSettings\EnableAutodial
            RegEntry reEnable(szRegPathInternetSettings,HKEY_CURRENT_CONFIG);
            dwRet = reEnable.GetError();
            if (ERROR_SUCCESS == dwRet)
            {
                dwRet = reEnable.SetValue(szRegValEnableAutodial, fEnable);
            }
        }


        if (ERROR_SUCCESS == dwRet)
        {
            // Set setting in the registry that indicates whether autodialing is enabled.
            // HKCU\Software\Microsoft\Windows\CurrentVersion\InternetSettings\EnableAutodial
            RegEntry reEnable(szRegPathInternetSettings,HKEY_CURRENT_USER);
            dwRet = reEnable.GetError();
            if (ERROR_SUCCESS == dwRet)
            {
                dwRet = reEnable.SetValue(szRegValEnableAutodial, fEnable);
                dwRet = reEnable.SetValue(szRegValNoNetAutodial, (unsigned long)FALSE);
            }
        }

  
        // 2/10/97    jmazner    Normandy #9705, 13233
        //            Notify wininet when we change proxy or autodial
        if (fp)
        {
            if( !((INTERNETSETOPTION)fp) (NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0) )
            {
                dwRet = GetLastError();
                DEBUGMSG("INETCFG export.c::InetSetAutodial() InternetSetOption failed");
            }
        }
        else
        {
            dwRet = GetLastError();
        }
    }

    if (hInst)
    {
        FreeLibrary(hInst);
        hInst = NULL;
    }
    return dwRet;
}



/*******************************************************************

  NAME:     NeedDriversDlgProc

  SYNOPSIS: Dialog proc for installing drivers

********************************************************************/
UINT g_uQueryCancelAutoPlay = 0;

INT_PTR CALLBACK NeedDriversDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            // lParam contains pointer to NEEDDRIVERSDLGINFO struct, set it
            // in window data
            ASSERT(lParam);
            SetWindowLongPtr(hDlg,DWLP_USER,lParam);
            return NeedDriversDlgInit(hDlg,(PNEEDDRIVERSDLGINFO) lParam);
            break;
        }
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    // get data pointer from window data
                    PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo =
                    (PNEEDDRIVERSDLGINFO) GetWindowLongPtr(hDlg,DWLP_USER);
                    ASSERT(pNeedDriversDlgInfo);
                    // pass the data to the OK handler
                    int fRet=NeedDriversDlgOK(hDlg,pNeedDriversDlgInfo);
                    EndDialog(hDlg,fRet);
                    break;
                }
                case IDCANCEL:
                {
                    SetLastError(ERROR_CANCELLED);
                    EndDialog(hDlg,0);
                    break;
                }
            }
            break;
        }
        default:
        {
            if(!g_uQueryCancelAutoPlay)
                g_uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay")); 
            if (uMsg && uMsg == g_uQueryCancelAutoPlay)
                return 1;  
        }
    }
    return FALSE;
}


/*******************************************************************

  NAME:    NeedDriversDlgInit

  SYNOPSIS: proc to handle initialization of dialog for installing files

********************************************************************/

BOOL NeedDriversDlgInit(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo)
{
  ASSERT(pNeedDriversDlgInfo);

  // put the dialog in the center of the screen
  RECT rc;
  GetWindowRect(hDlg, &rc);
  SetWindowPos(hDlg, NULL,
    ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
    ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
    0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

  return TRUE;
}

/*******************************************************************

  NAME:    NeedDriversDlgOK

  SYNOPSIS:  OK handler for dialog for installing files

********************************************************************/

int NeedDriversDlgOK(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo)
{
    int nResult = 1;
    ASSERT(pNeedDriversDlgInfo);

    // set the dialog text to "Installing files..." to give feedback to
    // user
    TCHAR szMsg[MAX_RES_LEN+1];
    LoadSz(IDS_INSTALLING_FILES,szMsg,sizeof(szMsg));
    SetDlgItemText(hDlg,IDC_TX_STATUS,szMsg);

    // disable buttons & dialog so it can't get focus
    EnableDlg(hDlg, FALSE);

    FARPROC hShell32VersionProc = NULL;
    BOOL    bWasEnabled         = FALSE;

    // install the drivers we need
    HMODULE hShell32Mod = (HMODULE)LoadLibrary(TEXT("shell32.dll"));
    
    if (hShell32Mod)
        hShell32VersionProc = GetProcAddress(hShell32Mod, "DllGetVersion");

    if(!hShell32VersionProc)
        bWasEnabled = TweakAutoRun(FALSE);
    
    DWORD dwRet = lpIcfgInstallInetComponents(hDlg,
    pNeedDriversDlgInfo->dwfOptions,
    pNeedDriversDlgInfo->lpfNeedsRestart);

    if(!hShell32VersionProc)
        TweakAutoRun(bWasEnabled);

    if (ERROR_SUCCESS != dwRet)
    {
        //
        // Don't display error message if user cancelled
        //
        nResult = 0;

        // Enable the dialog again
        EnableDlg(hDlg, TRUE);

        SetLastError(dwRet);
    }
    else
    {
        // Enable the dialog again
        EnableDlg(hDlg, TRUE);
    }

    return nResult;
}


/*******************************************************************

  NAME:      EnableDlg

  SYNOPSIS:  Enables or disables the dlg buttons and the dlg
            itself (so it can't receive focus)

********************************************************************/
VOID EnableDlg(HWND hDlg,BOOL fEnable)
{
  // disable/enable ok and cancel buttons
  EnableWindow(GetDlgItem(hDlg,IDOK),fEnable);
  EnableWindow(GetDlgItem(hDlg,IDCANCEL),fEnable);

  // disable/enable dlg
  EnableWindow(hDlg,fEnable);
  UpdateWindow(hDlg);
}


/*******************************************************************

  NAME:     ChooseModemDlgProc

  SYNOPSIS: Dialog proc for choosing modem

********************************************************************/
INT_PTR CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  BOOL fRet;

  switch (uMsg)
  {
    case WM_INITDIALOG:
      // lParam contains pointer to CHOOSEMODEMDLGINFO struct, set it
      // in window data
      ASSERT(lParam);
      SetWindowLongPtr(hDlg,DWLP_USER,lParam);
      fRet = ChooseModemDlgInit(hDlg,(PCHOOSEMODEMDLGINFO) lParam);
      if (!fRet)
      {
        // An error occured.
        EndDialog(hDlg,FALSE);
      }
      return fRet;
      break;

    case WM_COMMAND:
      switch (LOWORD(wParam))
      {
         case IDOK:
        {
          // get data pointer from window data
          PCHOOSEMODEMDLGINFO pChooseModemDlgInfo =
            (PCHOOSEMODEMDLGINFO) GetWindowLongPtr(hDlg,DWLP_USER);
          ASSERT(pChooseModemDlgInfo);

          // pass the data to the OK handler
          fRet=ChooseModemDlgOK(hDlg,pChooseModemDlgInfo);
          if (fRet)
          {
            EndDialog(hDlg,TRUE);
          }
        }
        break;

        case IDCANCEL:
          SetLastError(ERROR_CANCELLED);
          EndDialog(hDlg,FALSE);
          break;                  
      }
      break;
  }

  return FALSE;
}


/*******************************************************************

  NAME:    ChooseModemDlgInit

  SYNOPSIS: proc to handle initialization of dialog for choosing modem

********************************************************************/

BOOL ChooseModemDlgInit(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo)
{
  ASSERT(pChooseModemDlgInfo);

  // put the dialog in the center of the screen
  RECT rc;
  GetWindowRect(hDlg, &rc);
  SetWindowPos(hDlg, NULL,
    ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
    ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
    0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

  // fill the combobox with available modems
  DWORD dwRet = InitModemList(GetDlgItem(hDlg,IDC_MODEM));
  if (ERROR_SUCCESS != dwRet)
  {
    DisplayErrorMessage(hDlg,IDS_ERREnumModem,dwRet,
      ERRCLS_STANDARD,MB_ICONEXCLAMATION);

    SetLastError(dwRet);
    return FALSE;
  }

  return TRUE;
}

/*******************************************************************

  NAME:    ChooseModemDlgOK

  SYNOPSIS:  OK handler for dialog for choosing modem

********************************************************************/

BOOL ChooseModemDlgOK(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo)
{
  ASSERT(pChooseModemDlgInfo);

  // should always have a selection in combo box if we get here
  ASSERT(ComboBox_GetCurSel(GetDlgItem(hDlg,IDC_MODEM)) >= 0);

  // get modem name out of combo box
  ComboBox_GetText(GetDlgItem(hDlg,IDC_MODEM),
    pChooseModemDlgInfo->szModemName,
    ARRAYSIZE(pChooseModemDlgInfo->szModemName));
  NULL_TERM_TCHARS(pChooseModemDlgInfo->szModemName);
  ASSERT(lstrlen(pChooseModemDlgInfo->szModemName));
    
  // clear the modem list
  ComboBox_ResetContent(GetDlgItem(hDlg,IDC_MODEM));
  
  return TRUE;
}


/*******************************************************************

  NAME:     ChooseProfileDlgProc

  SYNOPSIS: Dialog proc for choosing profile

********************************************************************/

INT_PTR CALLBACK ChooseProfileDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  switch (uMsg)
  {
    case WM_INITDIALOG:
      // lParam contains pointer to CHOOSEPROFILEDLGINFO struct, set it
      // in window data
      ASSERT(lParam);
      SetWindowLongPtr(hDlg,DWLP_USER,lParam);
      return ChooseProfileDlgInit(hDlg,(PCHOOSEPROFILEDLGINFO) lParam);
      break;

    case WM_COMMAND:
      switch (LOWORD(wParam))
      {
         case IDOK:
        {
          // get data pointer from window data
          PCHOOSEPROFILEDLGINFO pChooseProfileDlgInfo =
            (PCHOOSEPROFILEDLGINFO) GetWindowLongPtr(hDlg,DWLP_USER);
          ASSERT(pChooseProfileDlgInfo);

          // pass the data to the OK handler
          BOOL fRet=ChooseProfileDlgOK(hDlg,pChooseProfileDlgInfo);
          if (fRet)
          {
            EndDialog(hDlg,TRUE);
          }
        }
        break;

        case IDCANCEL:
          EndDialog(hDlg,FALSE);
          break;                  

        case IDC_NEW_PROFILE:
          // user has requested to create a new profile
          DoNewProfileDlg(hDlg);
          return TRUE;    
          break;
      }
      break;
  }

  return FALSE;
}


/*******************************************************************

  NAME:     ChooseProfileDlgInit

  SYNOPSIS: proc to handle initialization of dialog for choosing profile

********************************************************************/

BOOL ChooseProfileDlgInit(HWND hDlg,PCHOOSEPROFILEDLGINFO pChooseProfileDlgInfo)
{
  ASSERT(pChooseProfileDlgInfo);

  // put the dialog in the center of the screen
  // 96/04/23 markdu  NASH BUG 18719 Make the choose profile dialog TOPMOST.
  RECT rc;
  GetWindowRect(hDlg, &rc);
  SetWindowPos(hDlg, HWND_TOPMOST,
    ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
    ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
    0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

  // populate the combo box with names of profiles
  ENUM_MAPI_PROFILE EnumMapiProfile;
  LPTSTR pProfileName=NULL;
  BOOL fDefault;
  int iSel;
  HWND hwndCombo = GetDlgItem(hDlg,IDC_PROFILE_LIST);
  ASSERT(hwndCombo);

  // enumerate profile names
  while (EnumMapiProfile.Next(&pProfileName,&fDefault))
  {
    ASSERT(pProfileName);

    // add profile names to combo box
    iSel=ComboBox_AddString(hwndCombo,pProfileName);
    ASSERT(iSel >= 0);

    // if this is the default profile, set it as selection
    if (fDefault)
    {
      ComboBox_SetCurSel(hwndCombo,iSel);
    }
  }

  // should always be a default profile (and should always be at least
  // one existing profile if we get here)... but just in case, select
  // the first profile in list if there's no selection made so far
  if (ComboBox_GetCurSel(hwndCombo) < 0)
    ComboBox_SetCurSel(hwndCombo,0);

  // initialize "set this profile as default" checkbox to be the
  // value that was passed in (in the structure)
  CheckDlgButton(hDlg,IDC_SETDEFAULT,pChooseProfileDlgInfo->fSetProfileAsDefault);

  return TRUE;
}

/*******************************************************************

  NAME:     ChooseProfileDlgOK

  SYNOPSIS: OK handler for dialog for choosing profile

********************************************************************/

BOOL ChooseProfileDlgOK(HWND hDlg,PCHOOSEPROFILEDLGINFO pChooseProfileDlgInfo)
{
  ASSERT(pChooseProfileDlgInfo);

  // should always have a selection in combo box if we get here
  ASSERT(ComboBox_GetCurSel(GetDlgItem(hDlg,IDC_PROFILE_LIST)) >= 0);

  // get selected profile from combo box
  ComboBox_GetText(GetDlgItem(hDlg,IDC_PROFILE_LIST),
    pChooseProfileDlgInfo->szProfileName,
    ARRAYSIZE(pChooseProfileDlgInfo->szProfileName));
  NULL_TERM_TCHARS(pChooseProfileDlgInfo->szProfileName);

  // get 'use as default profile' checkbox state
  pChooseProfileDlgInfo->fSetProfileAsDefault = IsDlgButtonChecked(hDlg,
    IDC_SETDEFAULT);

  return TRUE;
}

//*******************************************************************
//
//  FUNCTION:   InetSetAutoProxy
//
//  PURPOSE:    This function will set the auto config proxy settings
//              in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//              dwProxyDetectMode - value to be update in the
//                                  HKEY_CURRENT_USER\Software\Microsoft
//                                  \Windows\CurrentVersion\Internet Settings
//                                  AutoProxyDetectMode
//              lpszScriptAddr - value to be update in 
//                                  HKEY_CURRENT_USER\Software\Microsoft
//                                  \Windows\CurrentVersion\Internet Settings
//                                  AutoConfigURL
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

#ifdef UNICODE
HRESULT WINAPI   InetSetAutoProxyA
(
  BOOL    fEnable,
  DWORD   dwProxyDetectMode,
  LPCSTR  lpszScriptAddr
)
{
    HRESULT hr;
    LPTSTR  szScriptAddr;

    szScriptAddr = ToUnicodeWithAlloc(lpszScriptAddr);
    hr = InetSetAutoProxyW(fEnable, dwProxyDetectMode, szScriptAddr);
    if(szScriptAddr)
        GlobalFree(szScriptAddr);

    return hr;
}

HRESULT WINAPI   InetSetAutoProxyW
#else
HRESULT WINAPI   InetSetAutoProxyA
#endif
(
  BOOL    fEnable,
  DWORD   dwProxyDetectMode,
  LPCTSTR lpszScriptAddr
)
{
    DWORD dwRet = ERROR_GEN_FAILURE;
    HKEY hKey;

    if (!fEnable)
        return ERROR_SUCCESS;

    if (ERROR_SUCCESS == (dwRet = RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_INTERNET_SETTINGS, &hKey)) )
    {
        RegSetValueEx(hKey,
                      cszRegValAutoProxyDetectMode,
                      0,
                      REG_BINARY,
                      (LPBYTE) &dwProxyDetectMode,
                      sizeof(DWORD));                              
        RegSetValueEx(hKey,
                      cszRegValAutoConfigURL,
                      0,
                      REG_SZ,
                      (LPBYTE) lpszScriptAddr,
                      sizeof(TCHAR)*(lstrlen(lpszScriptAddr) + 1 ));

        RegCloseKey(hKey);
    }
    
    return dwRet;
}

//*******************************************************************
//
//  FUNCTION:   InetSetProxy
//
//  PURPOSE:    This function will set the proxy settings in the registry.
//                On Win32 platforms, it will then attempt to notify WinInet
//                of the changes made.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//              lpszServer - name of the proxy server.  If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//              lpszOverride - proxy override. If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

#ifdef UNICODE
HRESULT WINAPI   InetSetProxyA
(
  BOOL    fEnable,
  LPCSTR  lpszServer,
  LPCSTR  lpszOverride
)
{
    return ERROR_SUCCESS;
}

HRESULT WINAPI   InetSetProxyW
#else
HRESULT WINAPI   InetSetProxyA
#endif
(
  BOOL    fEnable,
  LPCTSTR lpszServer,
  LPCTSTR lpszOverride
)
{
    return ERROR_SUCCESS;
}

//*******************************************************************
//
//  FUNCTION:   InetSetProxyEx
//
//  PURPOSE:    This function will set the proxy settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//                        If set to FALSE, proxy will be disabled.
//              lpszConnectoidName - Name of connectoid to set proxy on
//                                   NULL for LAN
//              lpszServer - name of the proxy server.  If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//              lpszOverride - proxy override. If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

#ifdef UNICODE
HRESULT WINAPI   InetSetProxyExA
(
  BOOL    fEnable,
  LPCSTR  lpszConnectoidName,
  LPCSTR  lpszServer,
  LPCSTR  lpszOverride
)
{
    TCHAR szConnectoidNameW[MAX_ISP_NAME + 1];
    TCHAR szServerW[MAX_URL_STRING + 1];
    TCHAR szOverrideW[MAX_URL_STRING + 1];

    mbstowcs(szConnectoidNameW,lpszConnectoidName,lstrlenA(lpszConnectoidName)+1);
    mbstowcs(szServerW,   lpszServer,   lstrlenA(lpszServer)+1);
    mbstowcs(szOverrideW, lpszOverride, lstrlenA(lpszOverride)+1);

    return InetSetProxyExW(fEnable, szConnectoidNameW, szServerW, szOverrideW);
}

HRESULT WINAPI   InetSetProxyExW
#else
HRESULT WINAPI   InetSetProxyExA
#endif
(
  BOOL    fEnable,
  LPCTSTR lpszConnectoidName,
  LPCTSTR lpszServer,
  LPCTSTR lpszOverride
)
{
    HKEY hKeyCU;
    HKEY hKeyCC;
    HKEY hKeyCULan; 
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwVal;

    DEBUGMSG("export.c::InetSetProxy()");

    // 12/15/98   vyung  
    //            Change to use Wininet API to set proxy info. Old way of changing
    //            it through the registry is no longer supported.
    HINSTANCE hInst = NULL;
    
    FARPROC fpInternetSetOption, fpInternetQueryOption = NULL;
    dwRet = ERROR_SUCCESS;
    
    hInst = LoadLibrary(cszWininet);
    if (hInst)
    {
        fpInternetSetOption = GetProcAddress(hInst,cszInternetSetOption);
        fpInternetQueryOption = GetProcAddress(hInst,cszInternetQueryOption);
        if (fpInternetSetOption)
        {

            INTERNET_PER_CONN_OPTION_LISTA list;
            DWORD   dwBufSize = sizeof(list);
            CHAR    szProxyServer[RAS_MaxEntryName+1];
            CHAR    szProxyOverride[RAS_MaxEntryName+1];
            CHAR    szConnectoidName[RAS_MaxEntryName+1];
            DWORD   dwOptions = 4;              // always save FLAGS & DISCOVERY_FLAGS
            BOOL fRes;

            memset(szProxyServer,    0, sizeof(szProxyServer));
            memset(szProxyOverride,  0, sizeof(szProxyServer));
            memset(szConnectoidName, 0, sizeof(szProxyServer));

#ifdef UNICODE
            if (lpszServer)
                wcstombs(szProxyServer, lpszServer, RAS_MaxEntryName+1);
            if(lpszOverride)
                wcstombs(szProxyOverride, lpszOverride, RAS_MaxEntryName+1);
            if(lpszConnectoidName)
                wcstombs(szConnectoidName, lpszConnectoidName, RAS_MaxEntryName+1);
#else
            if (lpszServer)
                lstrcpy(szProxyServer, lpszServer);
            if(lpszOverride)
                lstrcpy(szProxyOverride, lpszOverride);
            if(lpszConnectoidName)
                lstrcpy(szConnectoidName, lpszConnectoidName);
#endif

            // fill out list struct
            list.dwSize = sizeof(list);
            if (NULL == lpszConnectoidName)
                list.pszConnection = NULL;                  // NULL == LAN, 
            else
                list.pszConnection = szConnectoidName;      // otherwise connectoid name
            list.dwOptionCount = 1;         // set three options
            list.pOptions = new INTERNET_PER_CONN_OPTIONA[5];
            if(NULL != list.pOptions)
            {
                // set flags
                list.pOptions[0].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;

                //
                // Query autodiscover flags - we just need to set one bit in there
                //
                if (fpInternetQueryOption)
                {
                    if( !((INTERNETQUERYOPTION)fpInternetQueryOption) (NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufSize) )
                    {
                        dwRet = GetLastError();
                        DEBUGMSG("INETCFG export.c::InetSetAutodial() InternetSetOption failed");
                    }
                }
                else
                    dwRet = GetLastError();

                // 
                // save off all other options
                //
                list.pOptions[0].Value.dwValue |= AUTO_PROXY_FLAG_USER_SET;

                list.pOptions[1].dwOption = INTERNET_PER_CONN_FLAGS;
                list.pOptions[1].Value.dwValue = PROXY_TYPE_DIRECT;

                //
                // save proxy settings
                //
                if (fEnable)
                {
                    list.pOptions[1].Value.dwValue |= PROXY_TYPE_PROXY;
                }

                list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
                list.pOptions[2].Value.pszValue = szProxyServer;

                list.pOptions[3].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
                list.pOptions[3].Value.pszValue = szProxyOverride;

                if (gpUserInfo)
                {
                    //
                    // save autodetect
                    //
                    if (gpUserInfo->bAutoDiscovery)
                    {
                        list.pOptions[1].Value.dwValue |= PROXY_TYPE_AUTO_DETECT;
                    }

                    //
                    // save autoconfig
                    //
                    if (gpUserInfo->bAutoConfigScript)
                    {
                        list.pOptions[1].Value.dwValue |= PROXY_TYPE_AUTO_PROXY_URL;

                        list.pOptions[dwOptions].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
#ifdef UNICODE
                        CHAR szAutoConfigURL[MAX_URL_STRING+1];
                        wcstombs(szAutoConfigURL, gpUserInfo->szAutoConfigURL, MAX_URL_STRING+1);
                        list.pOptions[dwOptions].Value.pszValue = szAutoConfigURL;
#else
                        list.pOptions[dwOptions].Value.pszValue = gpUserInfo->szAutoConfigURL;
#endif
                        dwOptions++;
                    }
                }


                list.dwOptionCount = dwOptions;
                if( !((INTERNETSETOPTION)fpInternetSetOption) (NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, dwBufSize) )
                {
                    dwRet = GetLastError();
                    DEBUGMSG("INETCFG export.c::InetSetProxy() InternetSetOption failed");
                }
                delete [] list.pOptions;
            }   
        }
        else
            dwRet = GetLastError();

        FreeLibrary(hInst);
        hInst = NULL;
    }
    else 
    {
        dwRet = GetLastError();
    }
    
    return dwRet;
}

//*******************************************************************
//
//  FUNCTION:   InetGetProxy
//
//  PURPOSE:    This function will get the proxy settings from the registry.
//
//  PARAMETERS: lpfEnable - on return, this will be TRUE if proxy
//              is enabled
//              lpszServer - on return, this buffer will contain the 
//              name of the proxy server
//              cbServer - size of buffer for proxy server name
//              lpszOverride - on return, this buffer will contain the 
//              name of the proxy server
//              cbOverride - size of buffer for proxy override
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

#ifdef UNICODE
HRESULT WINAPI   InetGetProxyA
(
  LPBOOL  lpfEnable,
  LPSTR   lpszServer,
  DWORD   cbServer,
  LPSTR   lpszOverride,
  DWORD   cbOverride
)
{
    HRESULT hr;
    TCHAR szServer[MAX_URL_STRING+1];
    TCHAR szOverride[MAX_URL_STRING+1];

    hr = InetGetProxyW(lpfEnable, szServer, cbServer, szOverride, cbOverride);
    wcstombs(lpszServer,   szServer,   MAX_URL_STRING+1);
    wcstombs(lpszOverride, szOverride, MAX_URL_STRING+1);

    return hr;
}

HRESULT WINAPI   InetGetProxyW
#else
HRESULT WINAPI   InetGetProxyA
#endif
(
  LPBOOL  lpfEnable,
  LPTSTR  lpszServer,
  DWORD   cbServer,
  LPTSTR  lpszOverride,
  DWORD   cbOverride
)
{
    HKEY hKey;
    DWORD dwRet;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwVal;

    DEBUGMSG("export.c::InetGetProxy()");

    // NEW WININET API
    //
    // Read proxy and autoconfig settings for this connection
    //

    // Comment for UNICODE
	// Wininet.dll doesn't support INTERNET_OPTION_PER_CONNECTION_OPTION
	// in InternetQueryOptionW. Only InternetQueryOptionA supports the flag.
	// Because of restriction of Wininet.dll I have to use A version.
	// WTSEO : 3/19/99
    INTERNET_PER_CONN_OPTION_LISTA list;
    DWORD dwBufSize = sizeof(list);
    //CHAR szEntryA[RAS_MaxEntryName + 1];

    list.pszConnection = NULL;
    list.dwSize = sizeof(list);
    list.dwOptionCount = 4;
    list.pOptions = new INTERNET_PER_CONN_OPTIONA[4];
    if(NULL == list.pOptions)
    {
        return FALSE;
    }

    list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    list.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

    HINSTANCE hInst = NULL;
    FARPROC fp = NULL;

    dwRet = ERROR_SUCCESS;
    
    hInst = LoadLibrary(cszWininet);
    if (hInst)
    {
        fp = GetProcAddress(hInst,cszInternetQueryOption);
        if (fp)
        {
            if( !((INTERNETQUERYOPTION)fp) (NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufSize) )
            {
                dwRet = 0;//GetLastError();
                DEBUGMSG("INETCFG export.c::InetSetAutodial() InternetSetOption failed");
            }
        }
        else
            dwRet = GetLastError();

        FreeLibrary(hInst);
        hInst = NULL;
    }
    else 
    {
        dwRet = GetLastError();
    }

    //
    // move options to gpUserInfo struct
    //
    if (gpUserInfo)
    {
        gpUserInfo->fProxyEnable = (list.pOptions[0].Value.dwValue & PROXY_TYPE_PROXY);
    }
    if(list.pOptions[1].Value.pszValue)
    {
#ifdef UNICODE
        mbstowcs(lpszServer, list.pOptions[1].Value.pszValue, MAX_URL_STRING);
#else
        lstrcpyn(lpszServer, list.pOptions[1].Value.pszValue, MAX_URL_STRING);
#endif
        cbServer = lstrlen(lpszServer);
    }
    if(list.pOptions[2].Value.pszValue)
    {
#ifdef UNICODE
        mbstowcs(lpszOverride, list.pOptions[2].Value.pszValue, MAX_URL_STRING);
#else
        lstrcpyn(lpszOverride, list.pOptions[2].Value.pszValue, MAX_URL_STRING);
#endif
        cbOverride = lstrlen(lpszOverride);;
    }

    //
    // fill in autoconfig and autoproxy field
    //
    if (gpUserInfo)
    {

        // autoconfig enable and url
        gpUserInfo->bAutoConfigScript = list.pOptions[0].Value.dwValue & PROXY_TYPE_AUTO_PROXY_URL;

        if(list.pOptions[3].Value.pszValue)
        {
#ifdef UNICODE
            mbstowcs(gpUserInfo->szAutoConfigURL, list.pOptions[3].Value.pszValue,
				                         lstrlenA(list.pOptions[3].Value.pszValue)+1);
#else
            lstrcpy(gpUserInfo->szAutoConfigURL, list.pOptions[3].Value.pszValue);
#endif
        }

        // autodiscovery enable
        gpUserInfo->bAutoDiscovery = list.pOptions[0].Value.dwValue & PROXY_TYPE_AUTO_DETECT;
    }

    // all done with options list
    delete [] list.pOptions;

    return dwRet;
}

//+----------------------------------------------------------------------------
//    Function    InetStartServices
//
//    Synopsis    This function guarentees that RAS services are running
//
//    Arguments    none
//
//    Return        ERROR_SUCCESS - if the services are enabled and running
//
//    History        10/16/96    ChrisK    Created
//-----------------------------------------------------------------------------
extern "C" HRESULT WINAPI InetStartServices()
{
    ASSERT(lpIcfgStartServices);
    if (NULL == lpIcfgStartServices)
        return ERROR_GEN_FAILURE;
    return (lpIcfgStartServices());
}

//+----------------------------------------------------------------------------
//
//    Function:    IEInstalled
//
//    Synopsis:    Tests whether a version of Internet Explorer is installed via registry keys
//
//    Arguments:    None
//
//    Returns:    TRUE - Found the IE executable
//                FALSE - No IE executable found
//
//    History:    jmazner        Created        8/19/96    (as fix for Normandy #4571)
//                valdonb        10/22/96    Shamelessly stole and used for my own purposes.
//
//-----------------------------------------------------------------------------

BOOL IEInstalled(void)
{
    HRESULT hr;
    HKEY hKey = 0;
    HANDLE hFindResult;
    TCHAR szTempPath[MAX_PATH + 1] = TEXT("");
    TCHAR szIELocalPath[MAX_PATH + 1] = TEXT("");
    DWORD dwPathSize;
    WIN32_FIND_DATA foundData;

    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPathIexploreAppPath, 0, KEY_READ, &hKey);
    if (hr != ERROR_SUCCESS) return( FALSE );

    dwPathSize = sizeof (szIELocalPath);
    hr = RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szIELocalPath, &dwPathSize);
    RegCloseKey( hKey );
    if (hr != ERROR_SUCCESS) return( FALSE );
    
    //
    // Olympus 9214 ChrisK
    // NT5 stores the path of IExplorer with environment strings
    //
    if (0 == ExpandEnvironmentStrings(szIELocalPath,szTempPath,MAX_PATH))
    {
        return (FALSE);
    };
    hFindResult = FindFirstFile( szTempPath, &foundData );
    FindClose( hFindResult );
    if (INVALID_HANDLE_VALUE == hFindResult) return( FALSE );

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//    Function:    IsIEAKSignUpNeeded
//
//    Synopsis:    Determine if the IEAK signup should be run by checking the
//                IEAK's registry flag and signup file location
//
//    Arguments:    pszPath - buffer to contain path to signup file
//                dwPathLen - size of pszPath
//
//    Returns:    TRUE - if IEAK signup should be run
//                FALSE - IEAK signup should not be run
//
//    History:    ChrisK    6/18/97    Created
//
//-----------------------------------------------------------------------------
BOOL IsIEAKSignUpNeeded(LPTSTR pszPath, DWORD dwPathLen)
{
    BOOL bRC = FALSE;


    //
    // Validate parameters
    //
    DEBUGMSG("INETCFG: IsIEAKSignUpNeeded.\n");
    ASSERT(pszPath);
    ASSERT(dwPathLen);

    if (NULL == pszPath || 0 == dwPathLen)
    {
        goto IsIEAKSignUpNeededExit;
    }


    //
    // Check if IEAK registry key is set
    //
    {
        RegEntry re(szRegIEAKSettings,HKEY_CURRENT_USER);

        if (ERROR_SUCCESS != re.GetError())
            goto IsIEAKSignUpNeededExit;

        if (0 == re.GetNumber(szREgIEAKNeededKey, 0))
        {
            bRC = FALSE;
            goto IsIEAKSignUpNeededExit;
        }
    }

    //
    // Check to see if IEAK signup page is available.
    //
    {
        RegEntry rePath(szRegPathIexploreAppPath,HKEY_LOCAL_MACHINE);

        if (ERROR_SUCCESS != rePath.GetError())
            goto IsIEAKSignUpNeededExit;

        if (NULL == rePath.GetString(szPathSubKey,pszPath,dwPathLen))
        {
            goto IsIEAKSignUpNeededExit;
        }

        dwPathLen = lstrlen(pszPath);
        ASSERT(dwPathLen);
    }

    //
    // Massage path to point at signup file
    //
    TCHAR *pc, *pcTemp;
    pc = &(pszPath[dwPathLen]);
    pc = CharPrev(pszPath,pc);

    if ('\\' == *pc)
    {
        //
        // add signup part of filename after \ character
        //
        pc = CharNext(pc);
    }
    else if (';' == *pc)
    {
        //
        // overwrite trailing ; character
        //
        // pc = pc
        pcTemp = CharPrev(pszPath,pc);

        //
        // check for trailing \ character and add one if needed
        //
        if ('\\' != *pcTemp)
        {
            *pc = '\\';
            pc = CharNext(pc);
        }
    }
    else
    {
        //
        // The path value contains something we don't understand
        //
        ASSERT(0);
    }

    lstrcpy(pc,szIEAKSignupFilename);
    if (0xFFFFFFFF != GetFileAttributes(pszPath))
    {
        bRC = TRUE;
    }


IsIEAKSignUpNeededExit:

    if (FALSE == bRC)
    {
        pszPath[0] = '\0';
    }

    return bRC;
}
/***************************************************************************

  Function    CheckConnectionWizard
  
  Synopsis    This function checks if ICW is present and if it has been run
            before.  If it is present but has not been run it does one of
            the following based on the value of dwRunFlags:  returns, runs
            the full ICW, or runs the manual path.

  Arguments    dwRunFlags is a combination of the following bit flags.

                Value                    Meaning
                ICW_CHECKSTATUS        Check if ICW is present and if it
                                    has been run.
                ICW_LAUNCHFULL        If ICW is present and the full path
                                    is available, run the full path, if
                                    possible.
                ICW_LAUNCHMANUAL    If ICW is present, run the manual path.
                ICW_USE_SHELLNEXT    If the full ICW path will be run, pass the
                                    value set by SetShellNext to icwconn1 using
                                    the /shellnext command line flag.
                ICW_FULL_SMARTSTART    If ICW is present and the full path
                                    is available, and ICW_LAUNCHFULL is
                                    specified, then add /smartstart parameter
                                    to command line.

            lpdwReturnFlags contains the results of the call.  It is a
                combination of the following bit flags.

                Value                Meaning
                ICW_FULLPRESENT     ICW full path is present on the system.
                ICW_MANUALPRESENT    ICW manual path is present.  This will
                                    always be set if ICW_FULLPRESENT is set.
                ICW_ALREADYRUN        ICW has already been run to completion
                                    before.
                ICW_LAUNCHEDFULL    The full path of ICW was started.
                ICW_LAUNCHEDMANUAL    The manual path of ICW was started.

            Note:    The calling application should exit if ICW_LAUNCHEDFULL or
                    ICW_LAUNCHEDMANUAL are set.  ICW may cause the system to
                    reboot if required system software needs to be installed.

  Return    ERROR_SUCCESS indicates a successful call.
            Any other value indicates failure.

****************************************************************************/
#define LAUNCHFULL_PARAMETER_SIZE (MAX_PATH + 2 + lstrlen(szICWShellNextFlag) + lstrlen(szICWSmartStartFlag))
extern "C" DWORD WINAPI CheckConnectionWizard(DWORD dwRunFlags, LPDWORD lpdwReturnFlags)
{
    DWORD dwRetFlags = 0;
    DWORD dwResult = ERROR_SUCCESS;
    TCHAR *szParameter = NULL;
    HINSTANCE hinst = NULL;
    
    //
    // ChrisK IE 39452 6/18/97
    // IEAK support of ISP mode
    //
    BOOL fIEAKNeeded = FALSE;
    TCHAR szIEAKPage[MAX_PATH + 1] = TEXT("\0invalid");

    fIEAKNeeded = IsIEAKSignUpNeeded(szIEAKPage,MAX_PATH);

    // Find out if full ICW is installed.  Since ICW is bound to the base
    // install of IE, we can just check if IE 3.0 is installed or not.
    // This may change in the future.
    if (IEInstalled())
        dwRetFlags |= ICW_FULLPRESENT;

    // Find out if manual ICW is installed.  Since this if part of INETCFG.DLL
    // and it also contains the manual ICW it is always present.
    dwRetFlags |= ICW_MANUALPRESENT;

    // If nothing's installed, exit now
#if 0    // Always at least manual path
    if (!((dwRetFlags & ICW_FULLPRESENT) || (dwRetFlags & ICW_MANUALPRESENT)))
        goto CheckConnectionWizardExit;
#endif

    // Find out if ICW has been run
    {
        RegEntry re(szRegPathICWSettings,HKEY_CURRENT_USER);

        dwResult = re.GetError();
        if (ERROR_SUCCESS != dwResult)
            goto CheckConnectionWizardExit;

        if (re.GetNumber(szRegValICWCompleted, 0))
        {
            dwRetFlags |= ICW_ALREADYRUN;
            goto CheckConnectionWizardExit;
        }
    }

    if ((dwRetFlags & ICW_FULLPRESENT) && (dwRunFlags & ICW_LAUNCHFULL))
    {


#if !defined(WIN16)
        if( dwRunFlags & ICW_USE_SHELLNEXT )
        {
            RegEntry re(szRegPathICWSettings,HKEY_CURRENT_USER);

            dwResult = re.GetError();
            if (ERROR_SUCCESS == dwResult)
            {
                TCHAR szShellNextCmd[MAX_PATH + 1];
                ZeroMemory( szShellNextCmd, sizeof(szShellNextCmd) );
                if( re.GetString(szRegValShellNext, szShellNextCmd, sizeof(szShellNextCmd)) )
                {
                    DEBUGMSG("CheckConnectionWizard read ShellNext = %s", szShellNextCmd);
                    szParameter = (TCHAR *)GlobalAlloc(GPTR, sizeof(TCHAR)*LAUNCHFULL_PARAMETER_SIZE);

                    if( szParameter )
                    {
                        ZeroMemory( szParameter, sizeof(szParameter) );
                        lstrcpy( szParameter, szICWShellNextFlag );
                        lstrcat( szParameter, szShellNextCmd );

                        //
                        // clean up after ourselves
                        //
                        // 7/9/97 jmazner Olympus #9170
                        // Nope, leave the reg key there for the manual path to find.
                        // conn1 and man path should clean this up when they finish.
                        //re.DeleteValue(szRegValShellNext);
                        //
                    }
                }
            }
        }

        //
        // ChrisK 5/25/97 Add the /smartstart parameter if appropriate
        //

        if (!fIEAKNeeded && dwRunFlags & ICW_FULL_SMARTSTART)
        {
            //
            // 6/6/97 jmazner Olympus #5927
            //

            //if(IsSmartStart())

            if( SMART_QUITICW == IsSmartStart() )
            {
                //
                // ChrisK Olympus 5902 6/6/97
                // Set completed flag is SmartStart is TRUE
                //

                RegEntry reg(szRegPathICWSettings,HKEY_CURRENT_USER);

                if (ERROR_SUCCESS == (dwResult = reg.GetError()))
                {
                    reg.SetValue(szRegValICWCompleted, (DWORD)1);
                }

                dwRetFlags |= ICW_ALREADYRUN;
                goto CheckConnectionWizardExit;
            }
        }
#endif

        if (!fIEAKNeeded)
        {
            // Launch the full ICW (ICWCONN1.EXE)
            hinst = ShellExecute (NULL, NULL, szFullICWFileName, szParameter, NULL, SW_NORMAL);
        }
        else
        {
            ASSERT(szIEAKPage[0]);
            //
            // Launch IEAK signup
            //
            hinst = ShellExecute (NULL, NULL, szISignupICWFileName, szIEAKPage, NULL, SW_NORMAL);
        }
    
        if (32 >= (DWORD_PTR)hinst)
        {
            if (NULL == hinst)
                dwResult = ERROR_OUTOFMEMORY;
            else
                dwResult = (DWORD)((DWORD_PTR)hinst);
            goto CheckConnectionWizardExit;
        }

        dwRetFlags |= ICW_LAUNCHEDFULL;
    }
    
    else if ((dwRetFlags & ICW_MANUALPRESENT) &&
             ((dwRunFlags & ICW_LAUNCHFULL) || (dwRunFlags & ICW_LAUNCHMANUAL)))
    {
        // Launch the manual ICW (INETWIZ.EXE)
        HINSTANCE hinst = ShellExecute (NULL, NULL, szManualICWFileName, NULL, NULL, SW_NORMAL);
        
        if (32 >= (DWORD)((DWORD_PTR)hinst))
        {

            if (NULL == hinst)
                dwResult = ERROR_OUTOFMEMORY;
            else
                dwResult = (DWORD)((DWORD_PTR)hinst);
            goto CheckConnectionWizardExit;
        }

        dwRetFlags |= ICW_LAUNCHEDMANUAL;
    }

CheckConnectionWizardExit:

    if( szParameter )
    {
        GlobalFree( szParameter );
    }

    *lpdwReturnFlags = dwRetFlags;
    return dwResult;
}

/******
 *
 * InetCreateMailNewsAccount and InetCreateDirectoryService, below, have
 * been obsoleted by the move to the wizard/apprentice model.  The Account
 * Manager now owns the UI for mail/news/ldap creation, thus there is no
 * longer a need for these entry points.
 *
 * 4/23/97 jmazner Olympus #3136
 *
 ******/

/***************************************************************************

  Function    InetCreateMailNewsAccount

  Synopsis  The InetCreateMailNewsAccount function will create a new Internet
            mail or news account.  The user is prompted through a wizard
            interface for the minimum required information to setup a new
            Internet mail or news account.

  Arguments    hwndparent is the window handle of the parent for the wizard
                dialogs.  If it is NULL the dialogs will be parentless.

            dwConfigType is of the following two enumerated types from ACCTTYPE.

                Value                Meaning
                ICW_ACCTMAIL (0)    Create a new Internet mail account.
                ICW_ACCTNEWS (1)    Create a new Internet news account.

            lpMailNewsInfo is a pointer to a IMNACCTINFO struct.  The values
                passed in will be used as defaults and the user's entries will
                be returned in this structure.  If this is NULL then ICW will
                use defaults as indicated in parentheses below.

  Return    ERROR_SUCCESS indicates a successful call.
            ERROR_CANCELLED indicates the user canceled the wizard.
            Any other value indicates failure.

****************************************************************************/
/***
extern "C" DWORD WINAPI InetCreateMailNewsAccount(    
    HWND hwndParent,                //parent of wizard dialogs                
    ICW_ACCTTYPE AccountType,        //account type                            
    IMNACCTINFO *lpMailNewsInfo,    // mail or news account information        
    DWORD dwInFlags                    // setup flags                            
    )

{
    DWORD dwResult = ERROR_SUCCESS;
    DWORD dwFlags = 0;

    // Initialize the wizard
    gpWizardState = new WIZARDSTATE;
    gpUserInfo = new USERINFO;
    gdwRasEntrySize = sizeof(RASENTRY);
    gpRasEntry = (LPRASENTRY) GlobalAlloc(GPTR,gdwRasEntrySize);

    if (!gpWizardState || !gpUserInfo || !gpRasEntry)
    {
        // display an out of memory error
        MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
        dwResult = ERROR_OUTOFMEMORY;
        goto InetCreateMailNewsAccountExit;
    }

    // Assign the global defaults pointer so we will use it later
    gpMailNewsInfo = lpMailNewsInfo;
    gfUseMailNewsDefaults = (dwInFlags & ICW_USEDEFAULTS);
    
    // Set the start page
    switch(AccountType)
    {
    case ICW_ACCTMAIL:
        dwFlags |= RSW_MAILACCT;
        break;

    case ICW_ACCTNEWS:
        dwFlags |= RSW_NEWSACCT;
        break;

    default:
        dwResult = ERROR_INVALID_PARAMETER;
        goto InetCreateMailNewsAccountExit;
        break;
    }

    gfUserFinished = FALSE;
    gfUserCancelled = FALSE;

    RunSignupWizard(dwFlags, hwndParent);

    if (gfUserFinished)
        dwResult = ERROR_SUCCESS;
    else if (gfUserCancelled)
        dwResult = ERROR_CANCELLED;
    else
        dwResult = ERROR_GEN_FAILURE;
    
InetCreateMailNewsAccountExit:

    // free global structures
    if (gpWizardState) 
        delete gpWizardState;

    if (gpUserInfo)
        delete gpUserInfo;

    if (gpEnumModem)
        delete gpEnumModem;

    if (gpRasEntry)
        GlobalFree(gpRasEntry);

    return dwResult;
}
******/

/***************************************************************************

  Function    InetCreateDirectoryService

  Synopsis  The InetCreateDirectoryService function will create a new Internet
            directory service (LDAP account).  The user is prompted through a wizard
            interface for the minimum required information to setup the service

  Arguments    hwndparent is the window handle of the parent for the wizard
                dialogs.  If it is NULL the dialogs will be parentless.

            AccountType should be ICW_ACCTDIRSERV

            lpDirServiceInfo is a pointer to a DIRSERVINFO struct.  The values
                passed in will be used as defaults and the user's entries will
                be returned in this structure.  If this is NULL then ICW will
                use defaults as indicated in parentheses below.

  Return    ERROR_SUCCESS indicates a successful call.
            ERROR_CANCELLED indicates the user canceled the wizard.
            Any other value indicates failure.

****************************************************************************/
/***********
extern "C" DWORD WINAPI InetCreateDirectoryService(    
    HWND hwndParent,                // parent of wizard dialogs    
    ICW_ACCTTYPE AccountType,        // account type    
    DIRSERVINFO *lpDirServiceInfo,    // LDAP account information    
    DWORD dwInFlags                    // setup flags
    )

{
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwFlags = 0;

    // Initialize the wizard
    gpWizardState = new WIZARDSTATE;
    gpUserInfo = new USERINFO;
    gdwRasEntrySize = sizeof(RASENTRY);
    gpRasEntry = (LPRASENTRY) GlobalAlloc(GPTR,gdwRasEntrySize);

    if (!gpWizardState || !gpUserInfo || !gpRasEntry)
    {
        // display an out of memory error
        MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
        dwRet = ERROR_OUTOFMEMORY;
        goto InetCreateDirectoryServiceExit;
    }

    // Assign the global defaults pointer so we will use it later
    gpDirServiceInfo = lpDirServiceInfo;
    gfUseDirServiceDefaults = (dwInFlags & ICW_USEDEFAULTS);
    
    // Set the start page
    switch(AccountType)
    {
    case ICW_ACCTDIRSERV:
        dwFlags |= RSW_DIRSERVACCT;
        break;

    default:
        dwRet = ERROR_INVALID_PARAMETER;
        goto InetCreateDirectoryServiceExit;
        break;
    }

    gfUserFinished = FALSE;
    gfUserCancelled = FALSE;

    RunSignupWizard(dwFlags, hwndParent);

    if (gfUserFinished)
        dwRet = ERROR_SUCCESS;
    else if (gfUserCancelled)
        dwRet = ERROR_CANCELLED;
    else
        dwRet = ERROR_GEN_FAILURE;
    
InetCreateDirectoryServiceExit:

    // free global structures
    if (gpWizardState) 
        delete gpWizardState;

    if (gpUserInfo)
        delete gpUserInfo;

    if (gpEnumModem)
        delete gpEnumModem;

    if (gpRasEntry)
        GlobalFree(gpRasEntry);

    return dwRet;
}
******/

#if !defined(WIN16)
// 4/1/97    ChrisK    Olympus 209
//+----------------------------------------------------------------------------
//    Function:    WaitCfgDlgProc
//
//    Synopsis:    Handle busy dialog messages
//
//    Arguments:    standard DialogProc
//
//    Returns:    standard DialogProc
//
//    History:    4/2/97    ChrisK    Created
//-----------------------------------------------------------------------------
INT_PTR CALLBACK WaitCfgDlgProc(
    HWND  hDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    HWND hwndAni;

    switch (uMsg)
    {
        case WM_DESTROY:
            hwndAni = GetDlgItem(hDlg,IDC_ANIMATE);
            if (hwndAni)
            {
                Animate_Stop(hwndAni);
                Animate_Close(hwndAni);
                hwndAni = NULL;
            }
            break;
        case WM_INITDIALOG:
            // Loop animation forever.
            hwndAni = GetDlgItem(hDlg,IDC_ANIMATE);
            if (hwndAni)
            {
                Animate_Open(hwndAni,MAKEINTRESOURCE(IDA_WAITINGCONFIG));
                Animate_Play(hwndAni, 0, -1, -1);
                hwndAni = NULL;
            }
            break;
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//    Function:    WaitCfgInit
//
//    Synopsis:    Create, center, and display busy dialog
//
//    Arguments:    hwndParent - handle of parent window
//                dwIDS - ID of string resource to display
//
//    Return:        handle to busy window
//
//    History:    4/2/97    ChrisK    Created
//-----------------------------------------------------------------------------
HWND WaitCfgInit(HWND hwndParent, DWORD dwIDS)
{
    HWND    hwnd;
    RECT    MyRect;
    RECT    DTRect;
    TCHAR   szMessage[255];

    // Create dialog
    hwnd = CreateDialog (ghInstance, MAKEINTRESOURCE(IDD_CONFIGWAIT), hwndParent, WaitCfgDlgProc);
    if (NULL != hwnd)
    {
        // Center dialog on desktop
        GetWindowRect(hwnd, &MyRect);
        GetWindowRect(GetDesktopWindow(), &DTRect);
        MoveWindow(hwnd, (DTRect.right - (MyRect.right - MyRect.left)) / 2, (DTRect.bottom - (MyRect.bottom - MyRect.top)) /2,
                            (MyRect.right - MyRect.left), (MyRect.bottom - MyRect.top), FALSE);

        // Load string for message
        szMessage[0] = '\0';
        LoadSz(dwIDS,szMessage,sizeof(szMessage)-1);
        SetDlgItemText(hwnd,IDC_LBLWAITCFG,szMessage);

        // Display dialog and paint text
        ShowWindow(hwnd,SW_SHOW);
        UpdateWindow(hwnd);
    }

    return hwnd;
}

//+----------------------------------------------------------------------------
//    Function:    SetShellNext
//
//    Synopsis:    Sets the ShellNext registry key with the passed in value.  This
//                key is passed to icwconn1 via the /shellnext command line option
//                if the ICW_USE_SHELLNEXT option is specified.
//
//    Arguments:    szShellNext -- pointer to a string containing the /shellnext cmd.
//                                **should have length <= MAX_PATH**
//
//    Return:        a win32 result code.  ERROR_SUCCESS indicates success.
//
//    History:    5/21/97    jmazner    Created for Olympus bug #4157
//-----------------------------------------------------------------------------

#ifdef UNICODE
extern "C" DWORD WINAPI SetShellNextA(CHAR *szShellNext)
{
    TCHAR* szShellNextW = new TCHAR[INTERNET_MAX_URL_LENGTH+1];
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    if (szShellNextW)
    {
        mbstowcs(szShellNextW, szShellNext, lstrlenA(szShellNext)+1);
        dwRet = SetShellNextW(szShellNextW);
        delete [] szShellNextW;
    }
    return dwRet;
}

extern "C" DWORD WINAPI SetShellNextW(WCHAR *szShellNext)
#else
extern "C" DWORD WINAPI SetShellNextA(CHAR  *szShellNext)
#endif
{
    DWORD dwResult = ERROR_SUCCESS;

    if( !szShellNext || !szShellNext[0] )
    {
        DEBUGMSG("SetShellNext got an invalid parameter\n");
        return ERROR_INVALID_PARAMETER;
    }

    RegEntry re(szRegPathICWSettings,HKEY_CURRENT_USER);

    dwResult = re.GetError();
    if (ERROR_SUCCESS == dwResult)
    {
        if( ERROR_SUCCESS == re.SetValue(szRegValShellNext, szShellNext) )
        {
            DEBUGMSG("SetShellNext set ShellNext = %s", szShellNext);
        }
        else
        {
            dwResult = re.GetError();
        }
    }

    return dwResult;
}

#ifdef OLD_SMART_START

#define IE4_PROXYSERVER_SETTING_KEY "ProxyServer"
#define IE4_PROXYENABLE_SETTING_KEY "ProxyEnable"
#define IE4_SETTINGS_STARTPAGE "Start Page"
#define IE4_SETTINGS_KEY "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define IE4_SETTINGS_MAIN "Software\\Microsoft\\Internet Explorer\\Main"
#define INETCFG_INETGETAUTODIAL "InetGetAutodial"
#define INETCFG_INETNEEDSYSTEMCOMPONENTS "InetNeedSystemComponents"
typedef HRESULT (WINAPI* PFNINETNEEDSYSTEMCOMPONENTS)(DWORD,LPBOOL);
typedef HRESULT (WINAPI* PFNINETGETAUTODIAL)(LPBOOL,LPTSTR,DWORD);
typedef DWORD (WINAPI* PFNRASGETAUTODIALADDRESS)(LPTSTR,LPDWORD,LPRASAUTODIALENTRY,LPDWORD,LPDWORD);

#define MIN_HTTP_ADDRESS (sizeof(SMART_HTTP) + 1) 
#define SMART_HTTP TEXT("http://")

//+----------------------------------------------------------------------------
//
//    Function:    SmartStartNetcard
//
//    Synopsis:    Check machine to see if it is setup to connect via a netcard
//                and proxy
//
//    Arguments:    none
//
//    Returns:    TRUE - run ICW; FALSE - quit now
//
//    History:    5/10/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL SmartStartNetcard()
{
    BOOL bResult = FALSE;
    HKEY hkey = NULL;
    DWORD dwSize = 0;
    DWORD dwData = 0;
    BOOL bRC = SMART_RUNICW;

    DEBUGMSG("INETCFG: SmartStartNetcard\n");
    //
    // Call Inetcfg to check for LAN card and TCP binding to that card
    //
    if (ERROR_SUCCESS != InetNeedSystemComponents(INETCFG_INSTALLLAN,
                            &bResult) || bResult)
    {
        DEBUGMSG("INETCFG: SmartStart not Netcard or not bound.\n");
        goto SmartStartNetcardExit;
    }

    //
    // Check to see if there are IE4 proxy settings
    //
    hkey = NULL;
    if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER,
                            IE4_SETTINGS_KEY,
                            &hkey)
        || NULL == hkey)
    {
        DEBUGMSG("INETCFG: SmartSmart IE4 Proxy key is not available.\n");
        goto SmartStartNetcardExit;
    }

    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS != RegQueryValueEx(hkey,
                            IE4_PROXYENABLE_SETTING_KEY,
                            NULL,    // lpReserved
                            NULL,    // lpType
                            (LPBYTE)&dwData,    // lpData
                            &dwSize)
        || 0 == dwData)
    {
        DEBUGMSG("INETCFG: SmartStart IE4 Proxy not enabled.\n");
        goto SmartStartNetcardExit;
    }
    
    if (ERROR_SUCCESS != RegQueryValueEx(hkey,
                            IE4_PROXYSERVER_SETTING_KEY,
                            NULL,    // lpReserved
                            NULL,    // lpType
                            NULL,    // lpData
                            &dwSize)
        || 1 >= dwSize)    // note: a single null character is length 1
    {
        DEBUGMSG("INETCFG: SmartStart IE 4 Proxy server not available.\n");
        goto SmartStartNetcardExit;
    }
    //
    // The user appears to have a valid configuration.  Do not
    // run the ICW.
    //
    bRC = SMART_QUITICW;

SmartStartNetcardExit:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
        hkey = NULL;
    }

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    IsSmartPPPConnectoid
//
//    Synopsis:    Given a connectoid name determine if the framing protocol is PPP
//
//    Arguments:    lpszEntry - name of connectoid
//
//    Returns:    TRUE - the framing protocol is PPP; FALSE - it is something else
//
//    History:    5/10/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL IsSmartPPPConnectoid(LPTSTR lpszEntry)
{
    LPRASENTRY lpRasEntry = NULL;
    DWORD dwRasEntrySize = 0;
    LPRASDEVINFO lpRasDevInfo = NULL;
    DWORD dwRasDevInfoSize = 0;
    DWORD dwSize;
    BOOL bRC = FALSE;

    DEBUGMSG("INETCFG: IsSmartPPPConnectoid\n");
    //
    // Check for PPP connectoid
    //

    //
    // ChrisK Olympus 6055 6/7/97
    // Make sure RNA dll functions are loaded, otherwise
    // GetEntry will assert.
    //
    if (ERROR_SUCCESS != EnsureRNALoaded() ||
        ERROR_SUCCESS != GetEntry(&lpRasEntry,
                            &dwRasEntrySize,
                            lpszEntry) ||
        RASFP_Ppp != lpRasEntry->dwFramingProtocol)
    {
        goto IsSmartPPPConnectoidExit;
    }
    else
    {
        //
        // The user appears to have a working modem connectoid
        // so skip the ICW
        //
        bRC = TRUE;
        goto IsSmartPPPConnectoidExit;
    }

IsSmartPPPConnectoidExit:
    //
    // Release memory
    //
    if (NULL != lpRasEntry)
    {
        GlobalFree(lpRasEntry);
        lpRasEntry = NULL;
    }

    if (NULL != lpRasDevInfo)
    {
        GlobalFree(lpRasDevInfo);
        lpRasDevInfo = NULL;
    }
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    SmartStartPPPConnectoidNT
//
//    Synopsis:    Check that the connectoid for the address of the start page is
//                a PPP connectoid
//
//    Arguments:
//
//    Returns:    TRUE - run ICW; FALSE - quit NOW
//
//    History:    5/10/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL SmartStartPPPConnectoidNT()
{
    BOOL bRC = SMART_RUNICW;
    HKEY hkey;
    TCHAR szStartPage[1024];
    TCHAR *pchFrom, *pchTo;
    HINSTANCE hRASAPI32;
    LPRASAUTODIALENTRY lpRasAutoDialEntry = NULL;
    DWORD dwSize=0;
    DWORD dwNum=0;
    FARPROC fp = NULL;

    DEBUGMSG("INETCFG: SmartStartPPPConnectoidNT\n");
    //
    // Read start page from registry
    //
    if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER,
                            IE4_SETTINGS_MAIN,
                            &hkey) && hkey)
    {
        goto SmartStartPPPConnectoidNTExit;
    }
    if (ERROR_SUCCESS != RegQueryValueEx(hkey,
                            IE4_SETTINGS_STARTPAGE,
                            NULL,                //lpReserved
                            NULL,                //lpType
                            (LPBYTE)szStartPage,//lpData
                            &dwSize)            //lpcbData
        && dwSize >= MIN_HTTP_ADDRESS)
    {
        goto SmartStartPPPConnectoidNTExit;
    }

    //
    // Parse server name out of start page URL and save it in szStartPage
    //
    if (2 != CompareString(LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                szStartPage,
                lstrlen(SMART_HTTP),
                SMART_HTTP,
                lstrlen(SMART_HTTP)))
    {
        goto SmartStartPPPConnectoidNTExit;
    }

    pchFrom = &szStartPage[sizeof(SMART_HTTP)];
    pchTo = &szStartPage[0];
    while (*pchFrom && '/' != *pchFrom)
    {
        *pchTo++ = *pchFrom++;
    }
    *pchTo = '\0';

    //
    // Look up address in RasAutodial database
    //
    if (NULL == (hRASAPI32 = LoadLibrary("rasapi32.dll")))
    {
        DEBUGMSG("INETCFG: rasapi32.dll didn't load.\n");
        goto SmartStartPPPConnectoidNTExit;
    }

#ifdef UNICODE
    if (NULL == (fp = GetProcAddress(hRASAPI32,"RasGetAutodialAddressW")))
#else
    if (NULL == (fp = GetProcAddress(hRASAPI32,"RasGetAutodialAddressA")))
#endif
    {
        DEBUGMSG("INETCFG: RasGetAutodialAddressA didn't load.\n");
        goto SmartStartPPPConnectoidNTExit;
    }

    if (ERROR_SUCCESS != ((PFNRASGETAUTODIALADDRESS)fp)(szStartPage,
                            NULL,        // lpdwReserved
                            NULL,        // lpAutoDialEntries
                            &dwSize,    // lpdwcbAutoDialEntries
                            &dwNum)        // lpdwcAutoDialEntries
        || 0 == dwNum)
    {
        goto SmartStartPPPConnectoidNTExit;
    }

    if (NULL == (lpRasAutoDialEntry = (LPRASAUTODIALENTRY)GlobalAlloc(GPTR,dwSize)))
    {
        goto SmartStartPPPConnectoidNTExit;
    }

    lpRasAutoDialEntry->dwSize = dwSize;
    if (ERROR_SUCCESS != ((PFNRASGETAUTODIALADDRESS)fp)(szStartPage,
                            NULL,                // lpdwReserved
                            lpRasAutoDialEntry,    // lpAutoDialEntries
                            &dwSize,            // lpdwcbAutoDialEntries
                            &dwNum))            // lpdwcAutoDialEntries
    {
        goto SmartStartPPPConnectoidNTExit;
    }

    //
    // Determine if the connectoid is PPP
    //
    if (IsSmartPPPConnectoid(lpRasAutoDialEntry->szEntry))
    {
        bRC = SMART_QUITICW;
    }

SmartStartPPPConnectoidNTExit:
    if (hkey)
    {
        RegCloseKey(hkey);
        hkey = NULL;
    }

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    SmartStartPPPConnectoid95
//
//    Synopsis:    Check that the connectoid set in the autodial setting is a PPP
//                connectoid
//
//    Arguments:
//
//    Returns:    TRUE - run ICW; FALSE - quit NOW
//
//    History:    5/10/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL SmartStartPPPConnectoid95()
{
    BOOL bAutodialEnabled = FALSE;
    CHAR szAutodialName[RAS_MaxEntryName + 1];
    DWORD dwSize;
    BOOL bRC = SMART_RUNICW;

    DEBUGMSG("INETCFG: SmartStartPPPConnectoid95\n");

    //
    // Get Autodial connectoid
    //
    dwSize = RAS_MaxEntryName;
    if (ERROR_SUCCESS != InetGetAutodial(&bAutodialEnabled,
                            szAutodialName,
                            dwSize) ||
        !bAutodialEnabled ||
        0 == lstrlen(szAutodialName))
    {
        goto SmartStartPPPConnectoid95Exit;
    }

    //
    // Determine if the connectoid is PPP
    //
    if (IsSmartPPPConnectoid(szAutodialName))
    {
        bRC = SMART_QUITICW;
    }

SmartStartPPPConnectoid95Exit:
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    AtLeastOneTAPILocation
//
//    Synopsis:    Check machine to verify that there is at least 1 tapi dialing
//                location
//
//    Arguments:    none
//
//    Returns:    TRUE 
//
//    History:    3 18 98   donaldm
//
//-----------------------------------------------------------------------------
BOOL AtLeastOneTAPILocation()
{
    HKEY    hkey;
    BOOL    bRet = FALSE;
        
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                      REGSTR_PATH_TELEPHONYLOCATIONS, 
                                      0, 
                                      KEY_ALL_ACCESS, 
                                      &hkey))
    {
        DWORD   dwSubKeys = 0;
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &dwSubKeys,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL))
        {
            // If there are any subkeys under locaitons, then there is at least 1
            if (dwSubKeys)
                bRet = TRUE;
        }                                                         
        RegCloseKey(hkey);
    }
    
    return(bRet);
}

//+----------------------------------------------------------------------------
//
//    Function:    SmartStartModem
//
//    Synopsis:    Check machine to verify that there is a modem and an autodial
//                connectoid
//
//    Arguments:    none
//
//    Returns:    TRUE - run ICW; FALSE - quit now
//
//    History:    5/10/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL SmartStartModem()
{
    BOOL bResult = FALSE;
    DWORD dwSize = 0;
    BOOL bRC = SMART_RUNICW;
    FARPROC fp;

    DEBUGMSG("INETCFG: SmartStartModem\n");
    //
    // Call Inetcfg to see if a modem is properly installed with TCP
    //
    if (ERROR_SUCCESS == InetNeedSystemComponents(INETCFG_INSTALLDIALUP,
                            &bResult)
        && !bResult)
    {
        //
        // Check to see if Dial-Up networking/RAS/RNA is install
        //
        if (ERROR_SUCCESS == InetNeedSystemComponents(INETCFG_INSTALLRNA,
                                &bResult) 
            && !bResult)
        {
            // DONALDM: GETCON bug 94. If there are no tapi locations, then
            // we can fail smart start, because there is no way the use
            // is connected. We want to bail here because InetNeedModem will call
            // RasEnumDevices, which will pop up the TAPI locations dialog
            if (AtLeastOneTAPILocation())
            {
        
                //
                // ChrisK Olympus 6324 6/11/97
                // Need to explicitly check for modem
                //
                if (ERROR_SUCCESS == InetNeedModem(&bResult) && 
                    !bResult)
                {
                    if (IsNT())
                    {
                        //
                        // Check that Ras services are running
                        //
                        //!JACOBBUGBUG!
                        if (ERROR_SUCCESS != InetStartServices())
                        {
                            goto SmartStartNetcardExit;
                        }

                        bRC = SmartStartPPPConnectoidNT();
                    }
                    else
                    {
                        bRC = SmartStartPPPConnectoid95();
                    }
                }
            }                
        }
    }

SmartStartNetcardExit:
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    IsSmartStart
//
//    Synopsis:    This function will determine if the ICW should be run.  The
//                decision is made based on the current state of the user's machine.
//                
//    Arguments:    none
//
//    Returns:    TRUE - run ICW; FALSE - quit now
//
//    History:    5/8/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
extern "C" DWORD WINAPI IsSmartStart()
{
    BOOL bRC = SMART_RUNICW;
    BOOL bResult;

    DEBUGMSG("INETCFG: IsSmartStart\n");

    if (IsNT())
    {
        DEBUGMSG("INETCFG: SmartStart not enabled on NT.\n");
        goto IsSmartStartExit;
    }

    //
    // #1. Check to see if TCP is installed
    //
    bResult = FALSE;
    if (ERROR_SUCCESS != InetNeedSystemComponents(INETCFG_INSTALLTCPONLY,
                            &bResult) || bResult)
    {
        DEBUGMSG("INETCFG: SmartStart TCP is missing\n");
        goto IsSmartStartExit;
    }

    //
    // #2. Check to see if there is a netcard installed
    //
    if (SMART_QUITICW == (bRC = SmartStartNetcard()))
    {
        DEBUGMSG("INETCFG: SmartStart LAN setup found.\n");
        goto IsSmartStartExit;
    }

    //
    // #3. Check to see if there is a modem installed
    //
    bRC = SmartStartModem();
    if (SMART_QUITICW == bRC)
    {
        DEBUGMSG("INETCFG: SmartStart Modem setup found.\n");
    }
    else
    {
        DEBUGMSG("INETCFG: SmartStart no valid setup found.\n");
    }
    
IsSmartStartExit:
    return bRC;
}

#endif      // OLD_SMART_START

//+----------------------------------------------------------------------------
//
//    Function:    IsSmartStartEx
//
//    Synopsis:    This function will determine if the ICW should be run.  The
//                decision is made based on the current state of the user's machine.
//                
//    Arguments:    none
//
//    Returns:    TRUE - run ICW; FALSE - quit now
//
//    History:    5/8/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
typedef DWORD (WINAPI *PFNInternetGetConnectedState)   (LPDWORD, DWORD);
typedef DWORD (WINAPI *PFNInternetGetConnectedStateEx) (LPDWORD, LPTSTR, DWORD, DWORD);

extern "C" DWORD WINAPI IsSmartStartEx(LPTSTR lpszConnectionName, DWORD dwBufLen)
{
    DEBUGMSG("INETCFG: IsSmartStartEx\n");

    BOOL  bRC              = SMART_RUNICW;
    DWORD dwConnectedFlags = 0;
    
    HINSTANCE hWinInet = LoadLibrary(TEXT("wininet.dll"));
    if (hWinInet)
    {
        PFNInternetGetConnectedState   pfnInternetGetConnectedState   = NULL;
        PFNInternetGetConnectedStateEx pfnInternetGetConnectedStateEx = NULL;

#ifdef UNICODE
        pfnInternetGetConnectedStateEx = (PFNInternetGetConnectedStateEx)GetProcAddress(hWinInet,"InternetGetConnectedStateExW");
#else
        pfnInternetGetConnectedStateEx = (PFNInternetGetConnectedStateEx)GetProcAddress(hWinInet,"InternetGetConnectedStateEx");
#endif
        pfnInternetGetConnectedState   = (PFNInternetGetConnectedState)GetProcAddress(hWinInet,"InternetGetConnectedState");

        if (pfnInternetGetConnectedStateEx)
        {
            pfnInternetGetConnectedStateEx(&dwConnectedFlags, 
                                         lpszConnectionName,
                                         dwBufLen,
                                         0);
        }
        else if(pfnInternetGetConnectedState)
        {
            pfnInternetGetConnectedState(&dwConnectedFlags, 0);
        }

        FreeLibrary(hWinInet);
    }
    // Existing connectoin is determined by existing modem or proxy, no need to run ICW
    // Check to see if there is a MODEM or PROXY connection
    if (dwConnectedFlags & 
        (INTERNET_CONNECTION_CONFIGURED | INTERNET_CONNECTION_LAN | 
         INTERNET_CONNECTION_PROXY | INTERNET_CONNECTION_MODEM
         )
        )
    {
        bRC = SMART_QUITICW;
    }
     
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    IsSmartStart
//
//    Synopsis:    This function will determine if the ICW should be run.  The
//                decision is made based on the current state of the user's machine.
//                
//    Arguments:    none
//
//    Returns:    TRUE - run ICW; FALSE - quit now
//
//    History:    5/8/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
extern "C" DWORD WINAPI IsSmartStart()
{
    return IsSmartStartEx(NULL, 0);
}

//*******************************************************************
//
//  FUNCTION:   SetAutoProxyConnectoid
//
//  PURPOSE:    This function will set the enable/disable auto
//              proxy settings in creating connectoid.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//
//*******************************************************************

HRESULT WINAPI SetAutoProxyConnectoid( BOOL bEnable)
{
    g_bUseAutoProxyforConnectoid = bEnable;
    return ERROR_SUCCESS;
}

#endif //!WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\icfgcall.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
//

//  HISTORY:
//  
//  96/05/23  markdu  Created.
//  96/05/26  markdu  Update config API.
//  96/05/27  markdu  Added lpIcfgGetLastInstallErrorText.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.

#include "wizard.h"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)

// Global variables
HINSTANCE ghInstConfigDll=NULL; // handle to Config dll we load explicitly
DWORD     dwCfgRefCount=0;
BOOL      fCFGLoaded=FALSE; // TRUE if config function addresses have been loaded

// global function pointers for Config apis
DOGENINSTALL            lpDoGenInstall=NULL;
GETSETUPXERRORTEXT      lpGetSETUPXErrorText=NULL;
ICFGSETINSTALLSOURCEPATH    lpIcfgSetInstallSourcePath=NULL;
ICFGINSTALLSYSCOMPONENTS    lpIcfgInstallInetComponents=NULL;
ICFGNEEDSYSCOMPONENTS       lpIcfgNeedInetComponents=NULL;
ICFGISGLOBALDNS             lpIcfgIsGlobalDNS=NULL;
ICFGREMOVEGLOBALDNS         lpIcfgRemoveGlobalDNS=NULL;
ICFGTURNOFFFILESHARING      lpIcfgTurnOffFileSharing=NULL;
ICFGISFILESHARINGTURNEDON   lpIcfgIsFileSharingTurnedOn=NULL;
ICFGGETLASTINSTALLERRORTEXT lpIcfgGetLastInstallErrorText=NULL;
ICFGSTARTSERVICES           lpIcfgStartServices=NULL;
//
// These two calls are only in NT icfg32.dll
//
ICFGNEEDMODEM               lpIcfgNeedModem = NULL;
ICFGINSTALLMODEM            lpIcfgInstallModem = NULL;

// API table for function addresses to fetch
#define NUM_CFGAPI_PROCS   11
APIFCN ConfigApiList[NUM_CFGAPI_PROCS] =
{
//  { (PVOID *) &lpDoGenInstall,            szDoGenInstall},
//  { (PVOID *) &lpGetSETUPXErrorText,      szGetSETUPXErrorText},
  { (PVOID *) &lpIcfgSetInstallSourcePath,    szIcfgSetInstallSourcePath},
  { (PVOID *) &lpIcfgInstallInetComponents,    szIcfgInstallInetComponents},
  { (PVOID *) &lpIcfgNeedInetComponents,       szIcfgNeedInetComponents},
  { (PVOID *) &lpIcfgIsGlobalDNS,             szIcfgIsGlobalDNS},
  { (PVOID *) &lpIcfgRemoveGlobalDNS,         szIcfgRemoveGlobalDNS},
  { (PVOID *) &lpIcfgTurnOffFileSharing,      szIcfgTurnOffFileSharing},
  { (PVOID *) &lpIcfgIsFileSharingTurnedOn,   szIcfgIsFileSharingTurnedOn},
  { (PVOID *) &lpIcfgGetLastInstallErrorText, szIcfgGetLastInstallErrorText},
  { (PVOID *) &lpIcfgStartServices,           szIcfgStartServices},
    //
    // These two calls are only in NT icfg32.dll
    //
  { (PVOID *) &lpIcfgNeedModem,         szIcfgNeedModem},
  { (PVOID *) &lpIcfgInstallModem,      szIcfgInstallModem}
};

#pragma data_seg(DATASEG_DEFAULT)

extern BOOL GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,
  UINT nApiProcs);

/*******************************************************************

  NAME:    InitConfig

  SYNOPSIS:  Loads the Config dll (ICFG32), gets proc addresses,

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

********************************************************************/
BOOL InitConfig(HWND hWnd)
{
  UINT uiNumCfgApiProcs = 0;

      
  DEBUGMSG("icfgcall.c::InitConfig()");

  // only actually do init stuff on first call to this function
  // (when reference count is 0), just increase reference count
  // for subsequent calls
  if (dwCfgRefCount == 0) {

    TCHAR szConfigDll[SMALL_BUF_LEN];

    DEBUGMSG("Loading Config DLL");

    // set an hourglass cursor
    WAITCURSOR WaitCursor;

    if (TRUE == IsNT())
    {
        if (TRUE == IsNT5())
        {
            LoadSz(IDS_CONFIGNT5DLL_FILENAME,szConfigDll,sizeof(szConfigDll));
        }
        else
        {
            //
            // On Windows NT get the filename (ICFGNT.DLL) out of resource
            //
            LoadSz(IDS_CONFIGNTDLL_FILENAME,szConfigDll,sizeof(szConfigDll));
        }            
    }
    else
    {
        //
        // On Windows 95 get the filename (ICFG95.DLL) out of resource
        //
        LoadSz(IDS_CONFIG95DLL_FILENAME,szConfigDll,sizeof(szConfigDll));
    }

    // load the Config api dll
    ghInstConfigDll = LoadLibrary(szConfigDll);
    if (!ghInstConfigDll) {
      UINT uErr = GetLastError();
      // Normandy 11985 - chrisk
      // filenames changed for Win95 and NT
      if (TRUE == IsNT())
      {
          DisplayErrorMessage(hWnd,IDS_ERRLoadConfigDllNT1,uErr,ERRCLS_STANDARD,
            MB_ICONSTOP);
      }
      else
      {
          DisplayErrorMessage(hWnd,IDS_ERRLoadConfigDll1,uErr,ERRCLS_STANDARD,
            MB_ICONSTOP);
      }
      return FALSE;
    }

    //
    // Cycle through the API table and get proc addresses for all the APIs we
    // need - on NT icfg32.dll has 2 extra entry points
    //
    if (TRUE == IsNT())
        uiNumCfgApiProcs = NUM_CFGAPI_PROCS;
    else
        uiNumCfgApiProcs = NUM_CFGAPI_PROCS - 2;
    
    if (!GetApiProcAddresses(ghInstConfigDll,ConfigApiList,uiNumCfgApiProcs)) {
    // Normandy 11985 - chrisk
    // filenames changed for Win95 and NT
      if (TRUE == IsNT())
      {
        MsgBox(hWnd,IDS_ERRLoadConfigDllNT2,MB_ICONSTOP,MB_OK);
      }
      else
      {
        MsgBox(hWnd,IDS_ERRLoadConfigDll2,MB_ICONSTOP,MB_OK);
      }
      DeInitConfig();
      return FALSE;
    }

  }

  fCFGLoaded = TRUE;

  dwCfgRefCount ++;

  return TRUE;
}

/*******************************************************************

  NAME:    DeInitConfig

  SYNOPSIS:  Unloads Config dll.

********************************************************************/
VOID DeInitConfig()
{
  DEBUGMSG("icfgcall.c::DeInitConfig()");

  UINT nIndex;

  // decrement reference count
  if (dwCfgRefCount)
    dwCfgRefCount --;

  // when the reference count hits zero, do real deinitialization stuff
  if (dwCfgRefCount == 0)
  {
    if (fCFGLoaded)
    {
      // set function pointers to NULL
      for (nIndex = 0;nIndex<NUM_CFGAPI_PROCS;nIndex++) 
        *ConfigApiList[nIndex].ppFcnPtr = NULL;

      fCFGLoaded = FALSE;
    }

    // free the Config dll
    if (ghInstConfigDll)
    {
    DEBUGMSG("Unloading Config DLL");
      FreeLibrary(ghInstConfigDll);
      ghInstConfigDll = NULL;
    }

  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\endui.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ENDUI.C - Functions for Wizard closing pages and internet tour
//      
//

//  HISTORY:
//  
//  1/12/95   jeremys Created.
//  96/03/09  markdu  Added LPRASENTRY parameter to CreateConnectoid()
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//  96/03/10  markdu  Made all TCP/IP stuff be per-connectoid.
//  96/03/23  markdu  Removed unused TCP/IP code.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/04/04  markdu  Added phonebook name param to CreateConnectoid.
//  96/04/06  markdu  NASH BUG 15369 Enable finish AND back button on last page,
//            and create the connectoid only after finish has been pressed.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//  96/05/02  markdu  NASH BUG 17333 Write out IE news settings.
//  96/05/06  markdu  NASH BUG 21139 Turn off proxy server if connecting
//            over modem.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//

#include "wizard.h"
#include "icwextsn.h"
#include "imnext.h"

typedef HRESULT (APIENTRY *PFNSETDEFAULTMAILHANDLER)(VOID);
typedef HRESULT (APIENTRY *PFNSETDEFAULTNEWSHANDLER)(VOID);

#define REGKEY_NDC       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")
#define REGKEY_NDC_ENTRY TEXT("CascadeNetworkConnections")
#define REGKEY_NDC_VALUE TEXT("YES")

BOOL CommitConfigurationChanges(HWND hDlg);

/*******************************************************************

  NAME:    ConnectedOKInitProc

  SYNOPSIS:  Called when "Your are connected" page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ConnectedOKInitProc(HWND hDlg,BOOL fFirstInit)
{
  // enable "finish" button instead of "next"
  PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_FINISH | PSWIZB_BACK);

  // if we've travelled through external apprentice pages,
  // it's easy for our current page pointer to get munged,
  // so reset it here for sanity's sake.
  gpWizardState->uCurrentPage = ORD_PAGE_CONNECTEDOK;

  return TRUE;
}

/*******************************************************************

  NAME:    ConnectedOKOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ConnectedOKOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{

  if (fForward)
  {
    if (CONNECT_RAS == gpUserInfo->uiConnectionType)
    {
        HKEY hKey = NULL; 

        RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_NDC, 0, KEY_WRITE, &hKey);
        if (hKey)
        {
            RegSetValueEx(hKey, REGKEY_NDC_ENTRY, 0, REG_SZ, (LPBYTE)REGKEY_NDC_VALUE, sizeof(REGKEY_NDC_VALUE));
            CloseHandle(hKey);
        }
    }

    // set flag to indicate that the user completed the wizard
    gfUserFinished = TRUE;

    // go configure mail, RNA
    if (!CommitConfigurationChanges(hDlg))
    {
      // set flag to indicate that wizard should exit now
      gfQuitWizard = TRUE;

      return FALSE;
    }
  }

  return TRUE;
}

/*******************************************************************

  NAME:    CommitConfigurationChanges

  SYNOPSIS:  Performs the following as appropriate:
        Mail configuration, RNA connectoid creation

  ENTRY:    hDlg - handle of parent window

  EXIT:    returns TRUE if successful or partially successful,
        FALSE if unsuccessful

  NOTES:    Displays its own error messages.  This function will
        continue as far as it can, if one item fails it will
        try to commit the rest.

********************************************************************/
BOOL CommitConfigurationChanges(HWND hDlg)
{
    HRESULT   hr;
    FARPROC   fpSetDefault;
    HKEY      hKey;
    TCHAR     szBuf[MAX_PATH+1];
    DWORD     size;


    // if connecting over modem, create a connectoid with
    // ISP name and phone number
    if ( CONNECT_RAS == gpUserInfo->uiConnectionType )
    {
        DWORD dwRet;

        // Only create the connectoid if it is new or has been modified
        if (gpUserInfo->fNewConnection || gpUserInfo->fModifyConnection)
        {
            DEBUGMSG("Creating/modifying connectoid %s", gpUserInfo->szISPName);
            dwRet = CreateConnectoid(NULL, gpUserInfo->szISPName, gpRasEntry,
              gpUserInfo->szAccountName,gpUserInfo->szPassword);

            if (dwRet != ERROR_SUCCESS)
            {
              DisplayErrorMessage(hDlg,IDS_ERRCreateConnectoid,
                dwRet,ERRCLS_RNA,MB_ICONEXCLAMATION);
              return FALSE;      
            }
        }

        // Only change the defaults if we are not just setting
        // up a new mail or news account.
        if ( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
        {
            //  96/05/06  markdu  NASH BUG 21139 Turn off proxy server if connecting
            //            over modem.
            gpUserInfo->fProxyEnable = FALSE;

            // set the name of this connectoid in registry as the connectoid
            // to use for autodialing
            //  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
            InetSetAutodial(TRUE, gpUserInfo->szISPName);

            // clear any old backup number
            SetBackupInternetConnectoid(NULL);
        }
    }
    else if ( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
    {
        // disable autodialing in registry because user is using LAN
        //  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
        InetSetAutodial(FALSE, NULL);
    }


    if ( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
    {
        if (CONNECT_LAN == gpUserInfo->uiConnectionType)
        {
            // write out proxy server config information
            hr = InetSetProxyEx(gpUserInfo->fProxyEnable,
                                NULL,
                                gpUserInfo->szProxyServer,
                                gpUserInfo->szProxyOverride);
            if (ERROR_SUCCESS != hr)
            {
                DisplayErrorMessage(hDlg,IDS_ERRConfigureProxy,
                  (DWORD) hr,ERRCLS_STANDARD,MB_ICONEXCLAMATION);
                return FALSE;    
            }
        }

        // make sure "The Internet" icon on desktop points to web browser
        // (it may initially be pointing at internet wizard)

        //  //10/24/96 jmazner Normandy 6968
        //  //No longer neccessary thanks to Valdon's hooks for invoking ICW.
        // 11/21/96 jmazner Normandy 11812
        // oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
        // ICW 1.1 needs to morph the IE 3 icon.

        SetDesktopInternetIconToBrowser();

        // set notation in registry whether user selected modem or LAN access,
        // for future reference...
        RegEntry re(szRegPathInternetSettings,HKEY_LOCAL_MACHINE);
        if (re.GetError() == ERROR_SUCCESS)
        {
            re.SetValue(szRegValAccessMedium,(DWORD)
              (CONNECT_LAN == gpUserInfo->uiConnectionType) ? USERPREF_LAN : USERPREF_MODEM);
            ASSERT(re.GetError() == ERROR_SUCCESS);

            re.SetValue(szRegValAccessType, (DWORD) ACCESSTYPE_OTHER_ISP);
            ASSERT(re.GetError() == ERROR_SUCCESS);
        }

        // set the username as the DNS host name, if there is no host name already
        // This is because some ISPs use the DNS host name for security for
        // access to mail, etc.  (Go figure!) 
        RegEntry reTcp(szTCPGlobalKeyName,HKEY_LOCAL_MACHINE);
        ASSERT(reTcp.GetError() == ERROR_SUCCESS);
        if (reTcp.GetError() == ERROR_SUCCESS)
        {
            TCHAR szHostName[SMALL_BUF_LEN+1]=TEXT("");
            // set DNS host name, but only if there's not a host name already set
            if (!reTcp.GetString(szRegValHostName,szHostName,sizeof(szHostName))
              || !lstrlen(szHostName))
              reTcp.SetValue(szRegValHostName,gpUserInfo->szAccountName);
        }

        // If DNS is set globally, clear it out so the per-connectoid settings
        // will be saved.
        BOOL  fTemp;
        DoDNSCheck(hDlg,&fTemp);
        if (TRUE == fTemp)
        {
            gpWizardState->fNeedReboot = TRUE;
        }
    }

    DWORD dwSaveErr = 0;

    if ( g_fAcctMgrUILoaded && gpImnApprentice )
    {
        CONNECTINFO myConnectInfo;
        myConnectInfo.cbSize = sizeof( CONNECTINFO );

#ifdef UNICODE
        wcstombs(myConnectInfo.szConnectoid, TEXT("Uninitialized\0"), MAX_PATH);
#else
        lstrcpy( myConnectInfo.szConnectoid, TEXT("Uninitialized\0"));
#endif

        myConnectInfo.type = gpUserInfo->uiConnectionType;

        if( CONNECT_RAS == myConnectInfo.type )
        {
#ifdef UNICODE
            wcstombs(myConnectInfo.szConnectoid, gpUserInfo->szISPName, MAX_PATH);
#else           
            lstrcpy( myConnectInfo.szConnectoid, gpUserInfo->szISPName);
#endif
        }


        gpImnApprentice->SetConnectionInformation( &myConnectInfo ); 
        gpImnApprentice->Save( g_pCICWExtension->m_hWizardHWND, &dwSaveErr );  

        if( ERR_MAIL_ACCT & dwSaveErr )
        {
            DEBUGMSG(TEXT("gpImnApprentice->Save returned with ERR_MAIL_ACCT!"));
        }
        if( ERR_NEWS_ACCT & dwSaveErr )
        {
            DEBUGMSG(TEXT("gpImnApprentice->Save returned with ERR_NEWS_ACCT!"));
        }
        if( ERR_DIRSERV_ACCT & dwSaveErr )
        {
            DEBUGMSG("gpImnApprentice->Save returned with ERR_DIR_SERV_ACCT!");
        }
    }
  

    // If we just completed the manual path (not just mail or news) then
    // set the registry key saying that we completed ICW.
    if ( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
    {
        RegEntry re(szRegPathICWSettings,HKEY_CURRENT_USER);
        if (ERROR_SUCCESS == re.GetError())
            re.SetValue(szRegValICWCompleted, (DWORD)1);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\icfgcall.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//  HISTORY:
//  
//  96/05/23  markdu  Created.
//  96/05/26  markdu  Update config API.
//  96/05/27  markdu  Added lpIcfgGetLastInstallErrorText.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.

#ifndef _ICFGCALL_H_
#define _ICFGCALL_H_

// function pointer typedefs for RNA apis from rnaph.dll and rasapi32.dll
typedef DWORD   (WINAPI * DOGENINSTALL               )  (HWND hwndParent,LPCTSTR lpszInfFile,LPCTSTR lpszInfSect);
typedef DWORD   (WINAPI * GETSETUPXERRORTEXT         )  (DWORD dwErr,LPTSTR pszErrorDesc,DWORD cbErrorDesc);
typedef HRESULT (WINAPI * ICFGSETINSTALLSOURCEPATH   )  (LPCTSTR lpszSourcePath);
typedef HRESULT (WINAPI * ICFGINSTALLSYSCOMPONENTS   )  (HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart);
typedef HRESULT (WINAPI * ICFGNEEDSYSCOMPONENTS      )  (DWORD dwfOptions, LPBOOL lpfNeedComponents);
typedef HRESULT (WINAPI * ICFGISGLOBALDNS            )  (LPBOOL lpfGlobalDNS);
typedef HRESULT (WINAPI * ICFGREMOVEGLOBALDNS        )  (void);
typedef HRESULT (WINAPI * ICFGTURNOFFFILESHARING     )  (DWORD dwfDriverType, HWND hwndParent);
typedef HRESULT (WINAPI * ICFGISFILESHARINGTURNEDON  )  (DWORD dwfDriverType, LPBOOL lpfSharingOn);
typedef DWORD   (WINAPI * ICFGGETLASTINSTALLERRORTEXT)  (LPTSTR lpszErrorDesc, DWORD cbErrorDesc);
typedef HRESULT (WINAPI * ICFGSTARTSERVICES          )  (void);

//
// These are available only on the NT icfg32.dll
//
typedef HRESULT (WINAPI * ICFGNEEDMODEM				)	(DWORD dwfOptions, LPBOOL lpfNeedModem);
typedef HRESULT (WINAPI * ICFGINSTALLMODEM			)	(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsStart);

BOOL InitConfig(HWND hWnd);
VOID DeInitConfig();

//
// global function pointers for Config apis
//
extern DOGENINSTALL					lpDoGenInstall;
extern GETSETUPXERRORTEXT			lpGetSETUPXErrorText;
extern ICFGSETINSTALLSOURCEPATH    lpIcfgSetInstallSourcePath;
extern ICFGINSTALLSYSCOMPONENTS    lpIcfgInstallInetComponents;
extern ICFGNEEDSYSCOMPONENTS       lpIcfgNeedInetComponents;
extern ICFGISGLOBALDNS             lpIcfgIsGlobalDNS;
extern ICFGREMOVEGLOBALDNS         lpIcfgRemoveGlobalDNS;
extern ICFGTURNOFFFILESHARING      lpIcfgTurnOffFileSharing;
extern ICFGISFILESHARINGTURNEDON   lpIcfgIsFileSharingTurnedOn;
extern ICFGGETLASTINSTALLERRORTEXT lpIcfgGetLastInstallErrorText;
extern ICFGSTARTSERVICES           lpIcfgStartServices;
//
// These two calls are only in NT icfg32.dll
//
extern ICFGNEEDMODEM				lpIcfgNeedModem;
extern ICFGINSTALLMODEM			lpIcfgInstallModem;


#endif // _ICFGCALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\factory.cpp ===
/****************************************************************************
 *
 *	FACTORY.cpp
 *
 *	Microsoft Confidential
 *	Copyright (c) Microsoft Corporation 1992-1997
 *	All rights reserved
 *
 *	This module provides the implementation of the methods for
 *  the CFactory class, which is used by COM's CoCreateInstance
 *
 *  The code comes almost verbatim from Chapter 7 of Dale Rogerson's
 *  "Inside COM", and thus is minimally commented.
 *
 *	4/24/97	jmazner	Created
 *
 ***************************************************************************/

#include "wizard.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"

#include "registry.h"

// Friendly name of component
const TCHAR g_szFriendlyName[] = TEXT("CLSID_ApprenticeICW") ;

// Version-independent ProgID
const TCHAR g_szVerIndProgID[] = TEXT("INETCFG.Apprentice") ;

// ProgID
const TCHAR g_szProgID[] = TEXT("INETCFG.Apprentice.1") ;

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

///////////////////////////////////////////////////////////
//
// Class factory
//
class CFactory : public IClassFactory
{
public:
	// IUnknown
	virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;         
	virtual ULONG   __stdcall AddRef() ;
	virtual ULONG   __stdcall Release() ;

	// Interface IClassFactory
	virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
	                                         const IID& iid,
	                                         void** ppv) ;
	virtual HRESULT __stdcall LockServer(BOOL bLock) ; 

	// Constructor
	CFactory() : m_cRef(1) {}

	// Destructor
	~CFactory() { DEBUGMSG("Class factory:\t\tDestroy self.") ;}

private:
	long m_cRef ;
} ;

//
// Class factory IUnknown implementation
//
HRESULT __stdcall CFactory::QueryInterface(const IID& iid, void** ppv)
{    
	DEBUGMSG("CFactory::QueryInterface");
	if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
	{
		*ppv = static_cast<IClassFactory*>(this) ; 
	}
	else
	{
		*ppv = NULL ;
		return E_NOINTERFACE ;
	}
	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
	return S_OK ;
}

ULONG __stdcall CFactory::AddRef()
{
	DEBUGMSG("CFactory::AddRef %d", m_cRef + 1);
	return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall CFactory::Release() 
{
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	DEBUGMSG("CFactory::Release %d", m_cRef);
	return m_cRef ;
}

//
// IClassFactory implementation
//
HRESULT __stdcall CFactory::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{
	DEBUGMSG("CFactory::CreateInstance:\t\tCreate component.") ;

	// Cannot aggregate.
	if (pUnknownOuter != NULL)
	{
		return CLASS_E_NOAGGREGATION ;
	}

	// Create component.  Since there's no direct IUnknown implementation,
	// use CICWApprentice.
	CICWApprentice *pApprentice = new CICWApprentice;
	
	DEBUGMSG("CFactory::CreateInstance CICWApprentice->AddRef");
	pApprentice->AddRef();
	
	if( NULL == pApprentice )
	{
		return E_OUTOFMEMORY;
	}

	// Get the requested interface.
	DEBUGMSG("CFactory::CreateInstance About to QI on CICWApprentice");
	HRESULT hr = pApprentice->QueryInterface(iid, ppv) ;

	// Release the IUnknown pointer.
	// (If QueryInterface failed, component will delete itself.)
	DEBUGMSG("CFactory::CreateInstance done with CICWApprentice, releasing (aprtc should have ct of 1)");
	pApprentice->Release() ;
	
	return hr ;
}

// LockServer
HRESULT __stdcall CFactory::LockServer(BOOL bLock) 
{
	if (bLock)
	{
		InterlockedIncrement(&g_cServerLocks) ; 
	}
	else
	{
		InterlockedDecrement(&g_cServerLocks) ;
	}
	return S_OK ;
}


///////////////////////////////////////////////////////////
//
// Exported functions
//
// These are the functions that COM expects to find
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
	if ((g_cComponents == 0) && (g_cServerLocks == 0))
	{
		return S_OK ;
	}
	else
	{
		return S_FALSE ;
	}
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	DEBUGMSG("DllGetClassObject:\tCreate class factory.") ;

	// Can we create this component?
	if (clsid != CLSID_ApprenticeICW)
	{
		return CLASS_E_CLASSNOTAVAILABLE ;
	}

	// Create class factory.
	CFactory* pFactory = new CFactory ;  // No AddRef in constructor
	if (pFactory == NULL)
	{
		return E_OUTOFMEMORY ;
	}

	// Get requested interface.
	DEBUGMSG("DllGetClassObject about to QI on CFactory");
	HRESULT hr = pFactory->QueryInterface(iid, ppv) ;
	DEBUGMSG("DllGetClassObject done with CFactory, releasing");
	pFactory->Release() ;


	return hr ;
}


// The following two exported functions are what regsvr32 uses to
// self-register and unregister the dll.  See REGISTRY.CPP for
// actual implementation

//
// Server registration
//
STDAPI DllRegisterServer()
{
	return RegisterServer(ghInstance, 
	                      CLSID_ApprenticeICW,
	                      g_szFriendlyName,
	                      g_szVerIndProgID,
	                      g_szProgID) ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
	return UnregisterServer(CLSID_ApprenticeICW,
	                        g_szVerIndProgID,
	                        g_szProgID) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\iclient.cpp ===
//****************************************************************************
//
//  Module:     INETCFG.DLL
//  File:       iclient.c
//  Content:    This file contains all the functions that handle importing
//              client information.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//  96/03/13  markdu  Assimilated with inetcfg.dll.
//  96/03/20  markdu  Combined export.h and iclient.h into inetcfg.h
//  96/04/18  markdu  NASH BUG 18443
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "wizard.h"
#include "inetcfg.h"

#define REGSTR_PATH_INTERNET_CLIENT     TEXT("Software\\Microsoft\\Internet ClientX")

#pragma data_seg(".rdata")

// registry constants
static const TCHAR cszRegPathInternetClient[] =  REGSTR_PATH_INTERNET_CLIENT;

static const TCHAR cszRegValEMailName[] =           TEXT("EMail_Name");
static const TCHAR cszRegValEMailAddress[] =        TEXT("EMail_Address");
static const TCHAR cszRegValPOPLogonRequired[] =    TEXT("POP_Logon_Required");
static const TCHAR cszRegValPOPLogonName[] =        TEXT("POP_Logon_Name");
static const TCHAR cszRegValPOPLogonPassword[] =    TEXT("POP_Logon_Password");
static const TCHAR cszRegValPOPServer[] =           TEXT("POP_Server");
static const TCHAR cszRegValSMTPServer[] =          TEXT("SMTP_Server");
static const TCHAR cszRegValNNTPLogonRequired[] =   TEXT("NNTP_Logon_Required");
static const TCHAR cszRegValNNTPLogonName[] =       TEXT("NNTP_Logon_Name");
static const TCHAR cszRegValNNTPLogonPassword[] =   TEXT("NNTP_Logon_Password");
static const TCHAR cszRegValNNTPServer[] =          TEXT("NNTP_Server");
static const TCHAR cszNull[] = TEXT("");
static const TCHAR cszYes[] = TEXT("yes");
static const TCHAR cszNo[] = TEXT("no");

#pragma data_seg()

#ifdef UNICODE
PWCHAR ToUnicodeWithAlloc(LPCSTR);
VOID   ToAnsiClientInfo(LPINETCLIENTINFOA, LPINETCLIENTINFOW);
VOID   ToUnicodeClientInfo(LPINETCLIENTINFOW, LPINETCLIENTINFOA);
#endif

//*******************************************************************
//
//  FUNCTION:   InetGetClientInfo
//
//  PURPOSE:    This function will get the internet client params
//              from the registry
//
//  PARAMETERS: lpClientInfo - on return, this structure will contain
//              the internet client params as set in the registry.
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************
#ifdef UNICODE
extern "C" HRESULT WINAPI InetGetClientInfoA
(
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFOA lpClientInfo
)
{
    HRESULT hr;
    TCHAR   lpszProfileNameW[MAX_PATH+1];
    INETCLIENTINFOW ClientInfoW;

    mbstowcs(lpszProfileNameW, lpszProfileName, lstrlenA(lpszProfileName)+1);
    hr = InetGetClientInfoW(lpszProfileNameW, &ClientInfoW);
    ToAnsiClientInfo(lpClientInfo, &ClientInfoW);

    return hr;
}

extern "C" HRESULT WINAPI InetGetClientInfoW
#else
extern "C" HRESULT WINAPI InetGetClientInfoA
#endif
(
  LPCTSTR           lpszProfileName,
  LPINETCLIENTINFO  lpClientInfo
)
{
    HKEY hKey;
    DWORD dwRet;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwVal;

    if (sizeof(INETCLIENTINFO) > lpClientInfo->dwSize)
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    dwRet = RegOpenKey(HKEY_CURRENT_USER, cszRegPathInternetClient, &hKey);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    lpClientInfo->dwFlags = 0;

    dwSize = sizeof(dwVal);
    dwType = REG_DWORD;
    RegQueryValueEx(
            hKey,
            cszRegValPOPLogonRequired,
            0L,
            &dwType,
            (LPBYTE)&dwVal,
            &dwSize);

    if (dwVal)
    {
        lpClientInfo->dwFlags |= INETC_LOGONMAIL;
    }

    dwSize = sizeof(dwVal);
    dwType = REG_DWORD;
    RegQueryValueEx(
            hKey,
            cszRegValNNTPLogonRequired,
            0L,
            &dwType,
            (LPBYTE)&dwVal,
            &dwSize);

    if (dwVal)
    {
        lpClientInfo->dwFlags |= INETC_LOGONNEWS;
    }

    dwSize = sizeof(lpClientInfo->szEMailName);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValEMailName,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szEMailName,
            &dwSize);

    dwSize = sizeof(lpClientInfo->szEMailAddress);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValEMailAddress,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szEMailAddress,
            &dwSize);

    dwSize = sizeof(lpClientInfo->szPOPServer);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValPOPServer,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szPOPServer,
            &dwSize);

    dwSize = sizeof(lpClientInfo->szSMTPServer);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValSMTPServer,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szSMTPServer,
            &dwSize);

    dwSize = sizeof(lpClientInfo->szNNTPServer);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValNNTPServer,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szNNTPServer,
            &dwSize);

    RegCloseKey(hKey);

    return ERROR_SUCCESS;
}


//*******************************************************************
//
//  FUNCTION:   InetSetClientInfo
//
//  PURPOSE:    This function will set the internet client params
//
//  PARAMETERS: lpClientInfo - pointer to struct with info to set
//              in the registry.
//              lpszProfileName - Name of client info profile to
//              modify.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

#ifdef UNICODE
extern "C" HRESULT WINAPI InetSetClientInfoA
(
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFOA lpClientInfo
)
{
    TCHAR   szProfileNameW[MAX_PATH+1];
    INETCLIENTINFOW ClientInfoW;

    mbstowcs(szProfileNameW, lpszProfileName, lstrlenA(lpszProfileName)+1);
    ToUnicodeClientInfo(&ClientInfoW, lpClientInfo);
    return InetSetClientInfoW(szProfileNameW, &ClientInfoW);
}

extern "C" HRESULT WINAPI InetSetClientInfoW
#else
extern "C" HRESULT WINAPI InetSetClientInfoA
#endif
(
  LPCTSTR           lpszProfileName,
  LPINETCLIENTINFO  lpClientInfo
)
{
    HKEY hKey;
    DWORD dwRet;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwVal;

    if (sizeof(INETCLIENTINFO) > lpClientInfo->dwSize)
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    dwRet = RegCreateKey(HKEY_CURRENT_USER, cszRegPathInternetClient, &hKey);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    dwVal = lpClientInfo->dwFlags & INETC_LOGONMAIL ? 1 : 0;
    dwSize = sizeof(dwVal);
    dwType = REG_DWORD;
    RegSetValueEx(
            hKey,
            cszRegValPOPLogonRequired,
            0L,
            dwType,
            (LPBYTE)&dwVal,
            dwSize);

    dwVal = lpClientInfo->dwFlags & INETC_LOGONNEWS ? 1 : 0;
    dwSize = sizeof(dwVal);
    dwType = REG_DWORD;
    RegSetValueEx(
            hKey,
            cszRegValNNTPLogonRequired,
            0L,
            dwType,
            (LPBYTE)&dwVal,
            dwSize);

    dwSize = sizeof(lpClientInfo->szEMailName);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValEMailName,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szEMailName,
            dwSize);

    dwSize = sizeof(lpClientInfo->szEMailAddress);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValEMailAddress,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szEMailAddress,
            dwSize);

    dwSize = sizeof(lpClientInfo->szPOPServer);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValPOPServer,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szPOPServer,
            dwSize);

    dwSize = sizeof(lpClientInfo->szSMTPServer);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValSMTPServer,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szSMTPServer,
            dwSize);

    dwSize = sizeof(lpClientInfo->szNNTPServer);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPServer,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szNNTPServer,
            dwSize);

    RegCloseKey(hKey);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\icwaprtc.cpp ===
/****************************************************************************
 *
 *	ICWAPRTC.cpp
 *
 *	Microsoft Confidential
 *	Copyright (c) Microsoft Corporation 1992-1997
 *	All rights reserved
 *
 *	This module provides the implementation of the methods for
 *  the CICWApprentice class.
 *
 *	5/1/97	jmazner	Created
 *
 ***************************************************************************/

#include "wizard.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"
#include "pagefcns.h"
#include "icwcfg.h"

UINT	g_uExternUIPrev, g_uExternUINext;

IICWExtension	*g_pExternalIICWExtension = NULL;
BOOL			g_fConnectionInfoValid = FALSE;

//defined/allocated in propmgr.cpp
extern PAGEINFO PageInfo[NUM_WIZARD_PAGES];
extern INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
								LPARAM lParam);
extern VOID InitWizardState(WIZARDSTATE * pWizardState, DWORD dwFlags);
extern VOID InitUserInfo(USERINFO * pUserInfo);

//define in rnacall.cpp
extern void InitRasEntry(LPRASENTRY lpEntry);

//defined in endui.cpp
extern BOOL CommitConfigurationChanges(HWND hDlg);


/*** Class definition, for reference only ***
  (actual definition is in icwaprtc.h)

class CICWApprentice : public IICWApprentice
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(IICWExtension *pExt);
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages(DWORD dwFlags);
        virtual HRESULT STDMETHODCALLTYPE GetConnectionInformation(CONNECTINFO *pInfo);
        virtual HRESULT STDMETHODCALLTYPE SetConnectionInformation(CONNECTINFO *pInfo);
        virtual HRESULT STDMETHODCALLTYPE Save(HWND hwnd, DWORD *pdwError);
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID);

		virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
		virtual ULONG	STDMETHODCALLTYPE AddRef( void );
		virtual ULONG	STDMETHODCALLTYPE Release( void );

		CICWApprentice( void );
		~CICWApprentice( void );

		IICWExtension	*m_pIICWExt;

    private:
		LONG	m_lRefCount;

};
****/

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::Initialize
//
//	Synopsis	Called by the main Wizard to initialize class members and
//				globals
//
//	Arguments	[in] pExt -- pointer the Wizard's IICWExtension interface, which
//							encapsulates the functionality needed to add wizard
//							pages.
//
//	Returns		E_OUTOFMEMORY -- unable to allocate global vars.
//				S_OK indicates success
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::Initialize(IICWExtension *pExt)
{
	DEBUGMSG("CICWApprentice::Initialize");

	ASSERT( pExt );
	m_pIICWExt = pExt;

	m_pIICWExt->AddRef();

	// various page OKProcs will need this pointer in order
	// to call SetFirstLastPage
	ASSERT( NULL == g_pExternalIICWExtension );
	g_pExternalIICWExtension = pExt;

	g_fConnectionInfoValid = FALSE;

	if( !gpWizardState)
	{
		gpWizardState = new WIZARDSTATE;
	}

	if( !gpUserInfo )
	{
		gpUserInfo = new USERINFO;
	}

	if( !gpRasEntry )
	{
		gdwRasEntrySize = sizeof(RASENTRY);
		gpRasEntry = (LPRASENTRY) GlobalAlloc(GPTR,gdwRasEntrySize);
	}

	if( !gpRasEntry || !gpWizardState || !gpUserInfo )
	{
		DEBUGMSG("CICWApprentice::Initialize couldn't initialize the globals!");
		return E_OUTOFMEMORY;
	}

	// stolen from RunSignupWizard in propmgr.cpp
	// initialize the rasentry structure
	InitRasEntry(gpRasEntry);

	// initialize the app state structure
	InitWizardState(gpWizardState, RSW_APPRENTICE);

	gpWizardState->dwRunFlags |= RSW_APPRENTICE;

	// initialize user data structure
	InitUserInfo(gpUserInfo);

    //
	// 6/2/97	jmazner	Olympus #4542
	// default to CONNECT_RAS
	//
	gpUserInfo->uiConnectionType = CONNECT_RAS;

	
	return S_OK;

}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::AddWizardPages
//
//	Synopsis	Creates a series of Property Sheet pages, and adds them to the
//				main wizard via the m_pIICWExt interface pointer.  Note that
//				we add every page in the global PageInfo struct, even though the
//				Apprentice may not use some pages (eg, CONNECTEDOK)
//
//	Arguments	[] dwFlags -- currently unused
//
//	Returns		S_OK indicates success
//				E_FAIL indicates failure.  If for any reason all pages can not be
//						added, we will attempt to remove any pages that had been
//						added prior to the failure.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::AddWizardPages(DWORD dwFlags)
{
	HPROPSHEETPAGE hWizPage[NUM_WIZARD_PAGES];  // array to hold handles to pages
	PROPSHEETPAGE psPage;    // struct used to create prop sheet pages
	UINT nPageIndex;
	HRESULT hr = S_OK;
	unsigned long ulNumItems = 0;

	DEBUGMSG("CICWApprentice::AddWizardPages");

	gpWizardState->dwRunFlags |= RSW_APPRENTICE;

	ZeroMemory(&hWizPage,sizeof(hWizPage));   // hWizPage is an array
	ZeroMemory(&psPage,sizeof(PROPSHEETPAGE));

    if (dwFlags & WIZ_USE_WIZARD97)
        g_fIsExternalWizard97 = TRUE;

	// fill out common data property sheet page struct
	psPage.dwSize = sizeof(psPage);
	psPage.hInstance = ghInstance;
	psPage.pfnDlgProc = GenDlgProc;

	// create a property sheet page for each page in the wizard
	for (nPageIndex = 0; nPageIndex < NUM_WIZARD_PAGES; nPageIndex++)
	{
        UINT    uDlgID;
	    psPage.dwFlags = PSP_DEFAULT | PSP_HASHELP;
        if (g_fIsExternalWizard97)
        {
            psPage.dwFlags |= PSP_USETITLE;
            psPage.pszTitle= gpWizardState->cmnStateData.szWizTitle;    
            uDlgID = PageInfo[nPageIndex].uDlgID97External;
        }
        else
            uDlgID = PageInfo[nPageIndex].uDlgID;
    	psPage.pszTemplate = MAKEINTRESOURCE(uDlgID);
                 
		// set a pointer to the PAGEINFO struct as the private data for this
		// page
		psPage.lParam = (LPARAM) &PageInfo[nPageIndex];

        if (g_fIsExternalWizard97 && PageInfo[nPageIndex].nIdTitle)
        {
		    psPage.dwFlags |= PSP_USEHEADERTITLE | (PageInfo[nPageIndex].nIdSubTitle ? PSP_USEHEADERSUBTITLE : 0);
    		psPage.pszHeaderTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdTitle);
	    	psPage.pszHeaderSubTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdSubTitle);
        }

		hWizPage[nPageIndex] = CreatePropertySheetPage(&psPage);

		if (!hWizPage[nPageIndex])
		{
			DEBUGTRAP("Failed to create property sheet page");
			MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);

			hr = E_FAIL;
			// creating page failed, free any pages already created and bail
			goto AddWizardPagesErrorExit;
		}

		hr = m_pIICWExt->AddExternalPage( hWizPage[nPageIndex], uDlgID);

		if( FAILED(hr) )
		{
			// free any pages already created and bail
			goto AddWizardPagesErrorExit;
		}


	}
  
    if (((dwFlags & WIZ_HOST_ICW_LAN) || (dwFlags & WIZ_HOST_ICW_PHONE)) ||
        (dwFlags & WIZ_HOST_ICW_MPHONE))
    {
        UINT uNextPage;
        BOOL bDummy;

        g_fIsICW = TRUE;

        if (!InitWizard(0))
        {
            hr = E_FAIL;
            DeinitWizard(RSW_NOREBOOT);
        }
        else
        {
            if (S_OK != ProcessCustomFlags(dwFlags))
            {
                DeinitWizard(RSW_NOREBOOT);
                hr = E_FAIL;
            }
        }

    }
    else  
    {
	    // of course, we have no idea what the last page will really be.
	    // so make a guess here, and update it later when we know for sure.
        if (g_fIsExternalWizard97)
	        m_pIICWExt->SetFirstLastPage( IDD_PAGE_HOWTOCONNECT97, IDD_PAGE_HOWTOCONNECT97 );
        else        
	        m_pIICWExt->SetFirstLastPage( IDD_PAGE_HOWTOCONNECT, IDD_PAGE_HOWTOCONNECT );
    }

	return hr;


AddWizardPagesErrorExit:
	UINT nFreeIndex;
	for (nFreeIndex=0;nFreeIndex<nPageIndex;nFreeIndex++)
	{
        UINT    uDlgID;
        if (g_fIsExternalWizard97)
            uDlgID = PageInfo[nPageIndex].uDlgID97External;
        else
            uDlgID = PageInfo[nPageIndex].uDlgID;
    
		DestroyPropertySheetPage(hWizPage[nFreeIndex]);
		m_pIICWExt->RemoveExternalPage( hWizPage[nFreeIndex], uDlgID );
	}

	return hr;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::GetConnectionInformation
//
//	Synopsis	Fills the passed in CONNECTINFO structure with the connection
//				information entered by the user.
//
//	Arguments	[in] pInfo -- pointer to a CONNECTINFO structure
//				[out] pInfo -- the indicated structure will contain the user's
//								connection information.
//
//	Returns		S_OK indicates success
//				E_POINTER --  the pInfo pointer is not valid
//				E_FAIL -- the user has not entered any connection info.  This
//							error will occur if the function is called before
//							the user has completed the apprentice.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::GetConnectionInformation(CONNECTINFO *pInfo)
{
	DEBUGMSG("CICWApprentice::GetConnectionInformation");
	ASSERTSZ(pInfo, "CONNECTINFO *pInfo is NULL!");
	if( !pInfo )
	{
		return E_POINTER;
	}

	if( !g_fConnectionInfoValid )
	{
		DEBUGMSG("CICWApprentice::GetConnectionInformation: haven't gathered any connection info yet!");
		return E_FAIL;
	}
	else
	{
		pInfo->cbSize = sizeof( CONNECTINFO );
		
#ifdef UNICODE
        wcstombs(pInfo->szConnectoid, TEXT("Uninitialized\0"), MAX_PATH);
#else
		lstrcpy( pInfo->szConnectoid, TEXT("Uninitialized\0"));
#endif
		pInfo->type = gpUserInfo->uiConnectionType;

		if( CONNECT_RAS == pInfo->type )
		{
#ifdef UNICODE
            wcstombs(pInfo->szConnectoid, gpUserInfo->szISPName, MAX_PATH);
#else
			lstrcpy( pInfo->szConnectoid, gpUserInfo->szISPName);
#endif
		}
	}


	return S_OK;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::SetConnectionInformation
//
//	Synopsis	Sets the default connectoin information for the Apprentice
//
//	Arguments	[in] pInfo -- pointer to a CONNECTINFO structure containing the
//								defaults to use.
//
//	Returns		S_OK indicates success
//				E_POINTER --  the pInfo pointer is not valid
//				E_INVALIDARG -- pInfo appears to point a different CONNECTINO
//								structure than the one we know about (based on
//								the cbSize member).
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::SetConnectionInformation(CONNECTINFO *pInfo)
{
	DEBUGMSG("CICWApprentice::SetConnectionInformation");

	ASSERTSZ(pInfo, "CONNECTINFO *pInfo is NULL!");
	if( !pInfo )
	{
		return E_POINTER;
	}
	
	if( !(sizeof( CONNECTINFO ) == pInfo->cbSize) )
	{
		DEBUGMSG("CICWApprentice::SetConnectionInformation pInfo->cbSize is unknown!");
		return E_INVALIDARG;
	}
	
	gpUserInfo->uiConnectionType = pInfo->type;
	if( CONNECT_RAS == pInfo->type )
	{
#ifdef UNICODE
        mbstowcs(gpUserInfo->szISPName, pInfo->szConnectoid, MAX_PATH);
#else
		lstrcpy( gpUserInfo->szISPName, pInfo->szConnectoid);
#endif
	}

	return S_OK;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::Save
//
//	Synopsis	Called by the Wizard to commit changes
//
//	Arguments	[in] hwnd -- hwnd of Wizard window, used to display modal msgs
//				[out] pdwError -- implementation specfic error code.  Not used.
//
//	Returns		S_OK indicates success
//				Otherwise, returns E_FAIL.
//
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::Save(HWND hwnd, DWORD *pdwError)
{
	DEBUGMSG("CICWApprentice::Save");
	if( CommitConfigurationChanges(hwnd) )
	{
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}

HRESULT CICWApprentice::SetDlgHwnd(HWND hDlg)
{
	m_hwndDlg = hDlg;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::SetPrevNextPage
//
//	Synopsis	Lets the apprentice notify the wizard of the dialog IDs of the
//				first and last pages in the apprentice
//
//
//	Arguments	uPrevPageDlgID -- DlgID of wizard page to back up to
//				uNextPageDlgID -- DlgID of wizard page to go forwards into
//
//
//	Returns		FALSE if both parameters are 0
//				TRUE if the update succeeded.
//
//	Notes:		If either variable is set to 0, the function will not update
//				that information, i.e. a value of 0 means "ignore me".  If both
//				variables are 0, the function immediately returns FALSE.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID)
{
	DEBUGMSG("CICWApprentice::SetPrevNextPage: updating prev = %d, next = %d",
		uPrevPageDlgID, uNextPageDlgID);

	if( (0 == uPrevPageDlgID) && (0 == uNextPageDlgID) )
	{
		DEBUGMSG("SetFirstLastPage: both IDs are 0!");
		return( E_INVALIDARG );
	}

	if( 0 != uPrevPageDlgID )
		g_uExternUIPrev = uPrevPageDlgID;
	if( 0 != uNextPageDlgID )
		g_uExternUINext = uNextPageDlgID;


	return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::ProcessCustomFlags
//
//  Synopsis    Lets the apprentice know that there is a special modification
//              to this set of apprentice pages after it is loaded
//
//  Arguments   dwFlags -- info needed to pass to the external pages
//
//
//  Returns     FALSE if both parameters are 0
//              TRUE if the update succeeded.
//
//  History     9/23/97 vyung     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::ProcessCustomFlags(DWORD dwFlags)
{
    UINT uNextPage;
    BOOL bDummy;
    HRESULT hr = S_OK;

    if (gpUserInfo)
        gpUserInfo->uiConnectionType = (dwFlags & WIZ_HOST_ICW_LAN) ? CONNECT_LAN : CONNECT_RAS;

    g_bSkipMultiModem = (BOOL) (dwFlags & WIZ_HOST_ICW_PHONE);

    if (gpWizardState)
    {
        gpWizardState->cmnStateData.dwFlags = 0;
        if (dwFlags & (WIZ_NO_MAIL_ACCT | WIZ_NO_NEWS_ACCT))
        {
    	    gpWizardState->dwRunFlags |= RSW_NOIMN;
        }
    }

    if (!HowToConnectOKProc(m_hwndDlg, TRUE, &uNextPage, &bDummy))
    {
        if (g_bReboot && gpWizardState && g_fIsICW)
        {
            // Set a registry value indicating that we messed with the desktop
           DWORD dwFlags = 0x00800000;//ICW_CFGFLAG_SMARTREBOOT_MANUAL;
            DWORD dwDisposition;
            HKEY hkey = 0;
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
                                                ICW_REGPATHSETTINGS,
                                                0,
                                                NULL,
                                                REG_OPTION_NON_VOLATILE, 
                                                KEY_ALL_ACCESS, 
                                                NULL, 
                                                &hkey, 
                                                &dwDisposition))
            {
                DWORD   dwDesktopChanged = 1;    
                RegSetValueEx(hkey, 
                              ICW_REGKEYERROR, 
                              0, 
                              REG_DWORD,
                              (LPBYTE)&dwFlags, 
                              sizeof(DWORD));
                RegCloseKey(hkey);
            }
            g_bRebootAtExit = FALSE;
        }
        hr = E_FAIL;
    }
    else
    {
        switch( uNextPage )
        {
            case ORD_PAGE_USEPROXY:
                m_pIICWExt->SetFirstLastPage( IDD_PAGE_USEPROXY97, IDD_PAGE_USEPROXY97 );
                break;
            case ORD_PAGE_SETUP_PROXY:
                m_pIICWExt->SetFirstLastPage( IDD_PAGE_SETUP_PROXY97, IDD_PAGE_SETUP_PROXY97 );
                break;
            case ORD_PAGE_CHOOSEMODEM:
                m_pIICWExt->SetFirstLastPage( IDD_PAGE_CHOOSEMODEM97, IDD_PAGE_CHOOSEMODEM97 );
                break;
            case ORD_PAGE_PHONENUMBER:
            case ORD_PAGE_CONNECTION:
                m_pIICWExt->SetFirstLastPage( IDD_PAGE_PHONENUMBER97, IDD_PAGE_PHONENUMBER97 );
                break;
            default:
                m_pIICWExt->SetFirstLastPage( 0, 0 );
                break;
        } // end of switch
    }
	return hr;
}

HRESULT CICWApprentice::SetStateDataFromExeToDll(LPCMNSTATEDATA lpData) 
{
    ASSERT(gpWizardState);
    memcpy(&gpWizardState->cmnStateData, lpData, sizeof(CMNSTATEDATA));
    
    return S_OK;
}

//converse of the previous function
HRESULT CICWApprentice::SetStateDataFromDllToExe(LPCMNSTATEDATA lpData) 
{
    ASSERT(gpWizardState);
    
    memcpy(lpData, &gpWizardState->cmnStateData, sizeof(CMNSTATEDATA));
    
    return (S_OK);
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::QueryInterface
//
//	Synopsis	This is the standard QI, with support for
//				IID_Unknown, IICW_Extension and IID_ICWApprentice
//				(stolen from Inside COM, chapter 7)
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::QueryInterface( REFIID riid, void** ppv )
{
	DEBUGMSG("CICWApprentice::QueryInterface");
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	// IID_IICWApprentice
	if (IID_IICWApprentice == riid)
		*ppv = (void *)(IICWApprentice *)this;
	// IID_IICWApprenticeEx
	else if (IID_IICWApprenticeEx == riid)
		*ppv = (void *)(IICWApprenticeEx *)this;
    // IID_IICWExtension
    else if (IID_IICWExtension == riid)
        *ppv = (void *)(IICWExtension *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
		*ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::AddRef
//
//	Synopsis	This is the standard AddRef
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
ULONG CICWApprentice::AddRef( void )
{
	DEBUGMSG("CICWApprentice::AddRef %d", m_lRefCount + 1);
	return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::Release
//
//	Synopsis	This is the standard Release
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
ULONG CICWApprentice::Release( void )
{
	ASSERT( m_lRefCount > 0 );

	InterlockedDecrement(&m_lRefCount);

	DEBUGMSG("CICWApprentice::Release %d", m_lRefCount);
	if( 0 == m_lRefCount )
	{
		m_pIICWExt->Release();
		m_pIICWExt = NULL;

		delete( this );
		return( 0 );
	}
	else
	{
		return( m_lRefCount );
	}
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::CICWApprentice
//
//	Synopsis	This is the constructor, nothing fancy
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
CICWApprentice::CICWApprentice( void )
{
	DEBUGMSG("CICWApprentice constructor called");
	m_lRefCount = 0;
	m_pIICWExt = NULL;

}


//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::~CICWApprentice
//
//	Synopsis	This is the destructor.  We want to clean up all the memory
//				we allocated in ::Initialize
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
CICWApprentice::~CICWApprentice( void )
{
	DEBUGMSG("CICWApprentice destructor called with ref count of %d", m_lRefCount);

	if (gpImnApprentice)
	{
		gpImnApprentice->Release();  // DeinitWizard is called in Release() 
		gpImnApprentice = NULL;
	}

	if( g_fIsICW )  // if ICW, we need to clean up, otherwise, leave cleanup later
		DeinitWizard(0);
       
	if( m_pIICWExt )
	{
		m_pIICWExt->Release();
		m_pIICWExt = NULL;
	}

	g_pExternalIICWExtension = NULL;

	g_fConnectionInfoValid = FALSE;

	if( gpWizardState)
	{
		delete gpWizardState;
		gpWizardState = NULL;
	}

	if( gpUserInfo )
	{
		delete gpUserInfo;
		gpUserInfo = NULL;
	}

	if( gpRasEntry )
	{
		GlobalFree(gpRasEntry);
		gpRasEntry = NULL;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\icwaprtc.h ===
#include "icwacct.h"

extern	UINT	g_uExternUIPrev, g_uExternUINext;

extern	IICWExtension	*g_pExternalIICWExtension;
extern	BOOL			g_fConnectionInfoValid;


class CICWApprentice : public IICWApprentice, public IICWApprenticeEx
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize               (IICWExtension *pExt);
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages           (DWORD dwFlags);
        virtual HRESULT STDMETHODCALLTYPE GetConnectionInformation (CONNECTINFO *pInfo);
        virtual HRESULT STDMETHODCALLTYPE SetConnectionInformation (CONNECTINFO *pInfo);
        virtual HRESULT STDMETHODCALLTYPE Save                     (HWND hwnd, DWORD *pdwError);
        virtual HRESULT STDMETHODCALLTYPE SetDlgHwnd               (HWND hDlg);    
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage          (UINT uPrevPageDlgID, UINT uNextPageDlgID);
        virtual HRESULT STDMETHODCALLTYPE ProcessCustomFlags       (DWORD dwFlags);
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromExeToDll (LPCMNSTATEDATA lpData);
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromDllToExe (LPCMNSTATEDATA lpData);
		virtual HRESULT STDMETHODCALLTYPE QueryInterface           (REFIID theGUID, void** retPtr);
		virtual ULONG	STDMETHODCALLTYPE AddRef                   (void);
		virtual ULONG	STDMETHODCALLTYPE Release                  (void);

		CICWApprentice  (void);
		~CICWApprentice (void);

		IICWExtension *m_pIICWExt;
       
	private:
		LONG m_lRefCount;
        HWND m_hwndDlg;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\icwextsn.h ===
#include "icwacct.h"

extern	UINT	g_uAcctMgrUIFirst, g_uAcctMgrUILast;
#ifndef EXTERNAL_DIALOGID_MAXIMUM
#define EXTERNAL_DIALOGID_MAXIMUM 3000
#endif
#ifndef EXTERNAL_DIALOGID_MINIMUM
#define EXTERNAL_DIALOGID_MINIMUM 2000
#endif

class CICWExtension : public IICWExtension
{
	public:
		virtual BOOL	STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
		virtual BOOL	STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
		virtual BOOL	STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type);
		virtual BOOL	STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID);

		virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
		virtual ULONG	STDMETHODCALLTYPE AddRef( void );
		virtual ULONG	STDMETHODCALLTYPE Release( void );

		CICWExtension( void );
		~CICWExtension( void );

		HWND m_hWizardHWND;

	private:
		LONG	m_lRefCount;
};

// This _has_ to be a pointer -- if you just instantiate directly, the compiler doesn't
// correctly fill in the vtable, and thus it can't be treated as an IICWExtension pointer.
extern CICWExtension *g_pCICWExtension;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\icwextsn.cpp ===
/****************************************************************************
 *
 *	ICWESTSN.cpp
 *
 *	Microsoft Confidential
 *	Copyright (c) Microsoft Corporation 1992-1997
 *	All rights reserved
 *
 *	This module provides the implementation of the methods for
 *  the CICWExtension class.
 *
 *	4/24/97	jmazner	Created
 *
 ***************************************************************************/

#include "wizard.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"

// in propmgr.cpp
extern BOOL DialogIDAlreadyInUse( UINT uDlgID );
extern BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse );

/*** Class definition, for reference only ***
  (actual definition is in icwextsn.h)

  class CICWExtension : public IICWExtension
{
	public:
		virtual BOOL	STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
		virtual BOOL	STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
		virtual BOOL	STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type);
		virtual BOOL	STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID);

		virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
		virtual ULONG	STDMETHODCALLTYPE AddRef( void );
		virtual ULONG	STDMETHODCALLTYPE Release( void );

		HWND m_hWizardHWND;

	private:
		LONG	m_lRefCount;
};
****/

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::AddExternalPage
//
//	Synopsis	Adds a page created via CreatePropertySheetPage to the main
//				property sheet/wizard.
//
//
//	Arguments	hPage -- page handle returned from CreatePropertySheetPage
//				uDlgID -- the dialog ID of the page to be added, as defined
//						  the resource file of the page's owner.
//
//
//	Returns		FALSE is the dlgID is already in use in the Wizard
//				TRUE otherwise
//
//	Notes:		PropSheet_AddPage does not return a usefull error code.  Thus
//				the assumption here is that every AddPage will succeed.  But, even
//				though it is not enforced by PropSheet_AddPage, every page in the
//				PropSheet must have a unique dialog ID.  Thus, if the uDlgID passed
//				in has previously been added to the PropSheet, we'll return FALSE.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::AddExternalPage( HPROPSHEETPAGE hPage, UINT uDlgID )
{
	LRESULT lResult= 0;

	if ( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uDlgID) )
	{
		DEBUGMSG("SetFirstLastPage: uDlgID %d is out of range!", uDlgID);
		return( FALSE );
	}

	if( !DialogIDAlreadyInUse(uDlgID) )
	{

		SetDialogIDInUse( uDlgID, TRUE );
		lResult = PropSheet_AddPage(m_hWizardHWND, hPage);
		DEBUGMSG("propmgr: PS_AddPage DlgID %d", uDlgID);

		return(TRUE);
	}
	else
	{
		DEBUGMSG("AddExternalPage DlgID %d is already in use, rejecting this page!", uDlgID);
		return(FALSE);
	}
}

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::RemoveExternalPage
//
//	Synopsis	Removes a page added via ::AddExternalPage to the main
//				property sheet/wizard.
//
//
//	Arguments	hPage -- page handle returned from CreatePropertySheetPage
//				uDlgID -- the dialog ID of the page to be removed, as defined
//						  the resource file of the page's owner.
//
//
//	Returns		FALSE is the dlgID is not already in use in the Wizard
//				TRUE otherwise
//
//	Notes:		PropSheet_RemovePage does not return a usefull error code.  Thus
//				the assumption here is that every RemovePage will succeed if that
//				dialog id is currently in the property sheet
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::RemoveExternalPage( HPROPSHEETPAGE hPage, UINT uDlgID )
{
	if ( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uDlgID) )
	{
		DEBUGMSG("SetFirstLastPage: uDlgID %d is out of range!", uDlgID);
		return( FALSE );
	}

	if( DialogIDAlreadyInUse(uDlgID) )
	{
		SetDialogIDInUse( uDlgID, FALSE );
		PropSheet_RemovePage(m_hWizardHWND, NULL, hPage);
		DEBUGMSG("propmgr: PS_RemovePage DlgID %d", uDlgID);

		return(TRUE);
	}
	else
	{
		DEBUGMSG("RemoveExternalPage: DlgID %d was not marked as in use!", uDlgID);
		return(FALSE);
	}
}

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::ExternalCancel
//
//	Synopsis	Notifies the wizard that the user has cancelled while in the
//				apprentice pages
//
//
//	Arguments	uCancelType -- tells the wizard whether it should immediately
//								quit out, or whether it should show the confirmation
//								dialog (as though the user had hit Cancel within the
//								wizard itself.)
//
//
//	Returns		TRUE if we're about to exit the wizard
//				FALSE if not.
//
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::ExternalCancel( CANCELTYPE uCancelType )
{
	DEBUGMSG("propmgr.cpp: received ExternalCancel callback");
	switch( uCancelType )
	{
		case CANCEL_PROMPT:
			gfUserCancelled = (MsgBox(m_hWizardHWND,IDS_QUERYCANCEL,
							MB_ICONQUESTION,MB_YESNO |
							MB_DEFBUTTON2) == IDYES);
	
			if( gfUserCancelled )
			{
				PropSheet_PressButton( m_hWizardHWND, PSBTN_CANCEL );
				gfQuitWizard = TRUE;
				return( TRUE );
			}
			else
			{
				return( FALSE );
			}
			break;

		case CANCEL_SILENT:
			PropSheet_PressButton( m_hWizardHWND, PSBTN_CANCEL );
			gfQuitWizard = TRUE;
			return( TRUE );
			break;

		case CANCEL_REBOOT:
			PropSheet_PressButton( m_hWizardHWND, PSBTN_CANCEL );
			gfQuitWizard = TRUE;
			gpWizardState->fNeedReboot = TRUE;
			return( TRUE );
			break;

		default:
			DEBUGMSG("ExternalCancel got an unkown CancelType!");
			return( FALSE );
	}
	
}

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::SetFirstLastPage
//
//	Synopsis	Lets the apprentice notify the wizard of the dialog IDs of the
//				first and last pages in the apprentice
//
//
//	Arguments	uFirstPageDlgID -- DlgID of first page in apprentice.
//				uLastPageDlgID -- DlgID of last page in apprentice
//
//
//	Returns		FALSE if the parameters passed in are out of range
//				TRUE if the update succeeded.
//
//	Notes:		If either variable is set to 0, the function will not update
//				that information, i.e. a value of 0 means "ignore me".  If both
//				variables are 0, the function immediately returns FALSE.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID)
{

	// validation code galore!
	if( (0 == uFirstPageDlgID) && (0 == uLastPageDlgID) )
	{
		DEBUGMSG("SetFirstLastPage: both IDs are 0!");
		return( FALSE );
	}

	if( (0 != uFirstPageDlgID) )
	{
		if ( (uFirstPageDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uFirstPageDlgID) )
		{
			DEBUGMSG("SetFirstLastPage: uFirstPageDlgID %d is out of range!", uFirstPageDlgID);
			return( FALSE );
		}

		if( !DialogIDAlreadyInUse(uFirstPageDlgID) )
		{
			DEBUGMSG("SetFirstLastPage: uFirstPageDlgID %d not marked as in use!", uFirstPageDlgID);
			return( FALSE );
		}
	}

	if( (0 != uLastPageDlgID) )
	{
		if ( (uLastPageDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uLastPageDlgID) )
		{
			DEBUGMSG("SetFirstLastPage: uLastPageDlgID %d is out of range!", uFirstPageDlgID);
			return( FALSE );
		}

		if( !DialogIDAlreadyInUse(uLastPageDlgID) )
		{
			DEBUGMSG("SetFirstLastPage: uLastPageDlgID %d not marked as in use!", uFirstPageDlgID);
			return( FALSE );
		}
	}
	
	if( 0 != uFirstPageDlgID )
		g_uAcctMgrUIFirst = uFirstPageDlgID;
	if( 0 != uLastPageDlgID )
		g_uAcctMgrUILast = uLastPageDlgID;
	DEBUGMSG("SetFirstLastPage: updating mail, first = %d, last = %d",
		uFirstPageDlgID, uLastPageDlgID);

	return TRUE;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::QueryInterface
//
//	Synopsis	This is the standard QI, with support for
//				IID_Unknown, IICW_Extension and IID_ICWApprentice
//				(Taken from Inside COM, chapter 7)
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWExtension::QueryInterface( REFIID riid, void** ppv )
{

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	// IID_IICWApprentice
	if (IID_IICWApprentice == riid)
		*ppv = (void *)(IICWApprentice *)this;
	// IID_IICWApprenticeEx
	else if (IID_IICWApprenticeEx == riid)
		*ppv = (void *)(IICWApprenticeEx *)this;
    // IID_IICWExtension
    else if (IID_IICWExtension == riid)
        *ppv = (void *)(IICWExtension *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
		*ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::AddRef
//
//	Synopsis	This is the standard AddRef
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
ULONG CICWExtension::AddRef( void )
{
	DEBUGMSG("CICWExtension::AddRef called %d", m_lRefCount + 1);

	return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::Release
//
//	Synopsis	This is the standard Release
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
ULONG CICWExtension::Release( void )
{

	ASSERT( m_lRefCount > 0 );

	InterlockedDecrement(&m_lRefCount);

	DEBUGMSG("CICWExtension::Release called %d", m_lRefCount);

	if( 0 == m_lRefCount )
	{
		delete( this );
		return( 0 );
	}
	else
	{
		return( m_lRefCount );
	}
	
}


//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::CICWExtension
//
//	Synopsis	The constructor.  Initializes member variables to NULL.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
CICWExtension::CICWExtension( void )
{
	DEBUGMSG("CICWExtension constructor called");
	m_lRefCount = 0;
	m_hWizardHWND = NULL;
}


//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::CICWExtension
//
//	Synopsis	The constructor.  Since there was no fancy initialization,
//				there's nothing to do here.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
CICWExtension::~CICWExtension( void )
{
	DEBUGMSG("CICWExtension destructor called with ref count of %d", m_lRefCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\ienews.cpp ===
//****************************************************************************
//
//  Module:     INETCFG.DLL
//  File:       ienews.c
//  Content:    This file contains all the functions that handle importing
//              connection information.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//          this code started its life as ixport.c in RNAUI.DLL
//          my thanks to viroont
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "wizard.h"
#include "inetcfg.h"
extern "C" {
#include <netmpr.h>
}


#pragma data_seg(".rdata")

#define REGSTR_PATH_IE_SERVICES         REGSTR_PATH_IEXPLORER TEXT("\\Services")

static const TCHAR cszRegPathIEServices[] =      REGSTR_PATH_IE_SERVICES;
static const TCHAR cszRegValNNTPEnabled[] =      TEXT("NNTP_Enabled");
static const TCHAR cszRegValNNTPUseAuth[] =      TEXT("NNTP_Use_Auth");
static const TCHAR cszRegValNNTPServer[] =       TEXT("NNTP_Server");
static const TCHAR cszRegValNNTPMailName[] =     TEXT("NNTP_MailName");
static const TCHAR cszRegValNNTPMailAddress[] =  TEXT("NNTP_MailAddr");
static const TCHAR cszYes[] = TEXT("yes");
static const TCHAR cszNo[] = TEXT("no");

#pragma data_seg()

#define PCE_WWW_BASIC 0x13
TCHAR szNNTP_Resource[] = TEXT("NNTP");
typedef DWORD (APIENTRY *PFNWNETGETCACHEDPASSWORD)(LPTSTR,WORD,LPTSTR,LPWORD,BYTE);

DWORD MyWNetGetCachedPassword(LPTSTR pbResource,WORD cbResource,LPTSTR pbPassword,
    LPWORD pcbPassword,BYTE   nType)
{
	HINSTANCE hInst = NULL;
	FARPROC fp = NULL;
	DWORD dwRet = 0;
	
	hInst = LoadLibrary(TEXT("MPR.DLL"));
	if (hInst)
	{
		fp = GetProcAddress(hInst,"WNetGetCachedPassword");
		if (fp)
			dwRet = ((PFNWNETGETCACHEDPASSWORD)fp) (pbResource, cbResource, pbPassword, pcbPassword, nType);
		else
			dwRet = GetLastError();
		FreeLibrary(hInst);
		hInst = NULL;
	} else {
		dwRet = GetLastError();
	}
	return dwRet;
}


BOOL
GetAuthInfo( TCHAR *szUsername, int cbUser, TCHAR *szPassword, int cbPass )
{
    int     wnet_status;
    TCHAR   szUserInfo[256];
    WORD    cbUserInfo = sizeof(szUserInfo);
    TCHAR   *p;

    if (cbUser && szUsername)
        *szUsername = '\0';
    if (cbPass && szPassword)
        *szPassword = '\0';

    wnet_status = MyWNetGetCachedPassword (szNNTP_Resource, sizeof(szNNTP_Resource) - 1, szUserInfo, &cbUserInfo, PCE_WWW_BASIC);
    switch (wnet_status)  {
        case WN_NOT_SUPPORTED:
            return( FALSE );    // Cache not enabled
            break;
        case WN_CANCEL:
            return( TRUE );     // Cache enabled but no password set
            break;
        case WN_SUCCESS:
            p = _tcschr(szUserInfo,':');
            if (p)  {
                *p = 0;
                lstrcpyn(szUsername, szUserInfo, cbUser - 1);
                szUserInfo[cbUser - 1] = '\0';
                lstrcpyn(szPassword, p+1, cbPass - 1);
                szPassword[cbPass - 1] = '\0';
            }
            return( TRUE );
            break;
        default:
////            XX_Assert((0),("Unexpected Return from WNetGetCachedPassword: %d", wnet_status ));
            return( FALSE );
    }

    /*NOTREACHED*/
    return(FALSE);
}

typedef DWORD (APIENTRY *PFNWNETCACHEPASSWORD)(LPTSTR,WORD,LPTSTR,WORD,BYTE,UINT);

DWORD MyWNetCachePassword(
    LPTSTR pbResource,
    WORD   cbResource,
    LPTSTR pbPassword,
    WORD   cbPassword,
    BYTE   nType,
    UINT   fnFlags
    )
{
	HINSTANCE hInst = NULL;
	FARPROC fp = NULL;
	DWORD dwRet = 0;
	hInst = LoadLibrary(TEXT("MPR.DLL"));
	if (hInst)
	{
		fp = GetProcAddress(hInst,"WNetCachePassword");
		if (fp)
			dwRet = ((PFNWNETCACHEPASSWORD)fp)(pbResource,cbResource,pbPassword,cbPassword,nType,fnFlags);
		else
			dwRet = GetLastError();
		FreeLibrary(hInst);
		hInst = NULL;
		fp = NULL;
	} else {
		dwRet = GetLastError();
	}
	return dwRet;
}


BOOL
SetAuthInfo( TCHAR *szUsername,  TCHAR *szPassword)
{
    int     wnet_status;
    TCHAR   szUserInfo[256];
    WORD    cbUserInfo = sizeof(szUserInfo);

    if (_tcschr(szUsername, ':'))  {
////        XX_Assert((0),("SetAuthInfo(): Username has ':' in it!: %s", szUsername ));
        return(FALSE);
    }

    lstrcpy( szUserInfo, szUsername );
    lstrcat( szUserInfo, TEXT(":") );
    lstrcat( szUserInfo, szPassword );

     wnet_status = MyWNetCachePassword (szNNTP_Resource, sizeof(szNNTP_Resource) - 1, szUserInfo, (USHORT)lstrlen( szUserInfo ), PCE_WWW_BASIC, 0);

    return( wnet_status == WN_SUCCESS );
}

DWORD SetIEClientInfo(LPINETCLIENTINFO lpClientInfo)
{
    HKEY hKey;
    DWORD dwRet;
    DWORD dwSize;
    DWORD dwType;

    dwRet = RegCreateKey(HKEY_CURRENT_USER, cszRegPathIEServices, &hKey);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    dwSize = *lpClientInfo->szNNTPServer ? sizeof(cszYes) : sizeof(cszNo);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPEnabled,
            0L,
            dwType,
            (LPBYTE)(*lpClientInfo->szNNTPServer ? cszYes : cszNo),
            dwSize);

    dwSize = (lpClientInfo->dwFlags & INETC_LOGONNEWS) ? sizeof(cszYes) : sizeof(cszNo);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPUseAuth,
            0L,
            dwType,
            (LPBYTE)((lpClientInfo->dwFlags & INETC_LOGONNEWS) ? cszYes : cszNo),
            dwSize);


    dwSize = sizeof(lpClientInfo->szEMailName);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPMailName,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szEMailName,
            dwSize);

    dwSize = sizeof(lpClientInfo->szEMailAddress);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPMailAddress,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szEMailAddress,
            dwSize);


    dwSize = sizeof(lpClientInfo->szNNTPServer);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPServer,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szNNTPServer,
            dwSize);

    RegCloseKey(hKey);

    SetAuthInfo(lpClientInfo->szNNTPLogonName,  lpClientInfo->szNNTPLogonPassword);
    
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\ids.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// dialog size
#define MY_CXDLG                      304
#define MY_CYDLG                      163

#define MY_CXDLG97                    343
#define MY_CYDLG97                    177
#define MY_CYFIRSTLASTPG              215

#define MY_CXBMP                      79
#define MY_CYBMP                      160

// string resource IDs
#define IDS_APPNAME                   1000
#define IDS_QUERYCANCEL               1002
#define IDS_ERRFORMAT                 1003
#define IDS_RNADLL_FILENAME           1004
#define IDS_COUNTRY_FMT               1005
#define IDS_SHORT_FMT                 1006
#define IDS_DEFAULT_PROFILE_NAME      1007
#define IDS_MAPIDLL_FILENAME          1008
#define IDS_RNAPHDLL_FILENAME         1013
#define IDS_GENERIC_RNA_ERROR         1015
#define IDS_GENERIC_MAPI_ERROR        1016
#define IDS_HELPFILE_NAME             1022
#define IDS_MSN105_INF_FILE           1026
#define IDS_MSN105_UNINSTALL_SECT     1027
#define IDS_MSN100_INF_FILE           1028
#define IDS_MSN100_UNINSTALL_SECT     1029
#define IDS_SCRIPT_FILE_FILTER        1030
#define IDS_CONFIG95DLL_FILENAME      1031
#define IDS_CONFIGNTDLL_FILENAME      1032
#define IDS_CONFIGNT5DLL_FILENAME     1033

#define IDS_INTERNETMAIL_SERVICENAME  1050
#define IDS_MESSAGESTORE_SERVICENAME  1051
#define IDS_ADDRESSBOOK_SERVICENAME   1052
#define IDS_INTERNETMAIL_DESCRIPTION  1053
#define IDS_MESSAGESTORE_DESCRIPTION  1054
#define IDS_ADDRESSBOOK_DESCRIPTION   1055
#define IDS_PROFILENAME               1056
#define IDS_PROFILENAME1              1057

#define IDS_MESSAGESTORE_FILENAME     1060
#define IDS_MESSAGESTORE_FILENAME1    1061
#define IDS_ADDRESSBOOK_FILENAME      1062
#define IDS_ADDRESSBOOK_FILENAME1     1063

#define IDS_ERROutOfMemory            1100
#define IDS_ERRInstallModem           1101
#define IDS_ERRReadConfig             1102
#define IDS_ERRCoInitialize           1103
#define IDS_ERRLoadRNADll1            1106
#define IDS_ERRLoadRNADll2            1107
#define IDS_ERRCreateConnectoid       1109
#define IDS_ERRLoadMAPIDll1           1110
#define IDS_ERRLoadMAPIDll2           1111
#define IDS_ERRInitMAPI               1112
#define IDS_ERRConfigureMail          1114
#define IDS_ERRConnectoidName95       1115
#define IDS_ERRSetPhoneNumber         1116
#define IDS_ERRWriteDNS               1119
#define IDS_ERRUninstallMSN           1120
#define IDS_ERREnumModem              1121
#define IDS_ERRConfigureProxy         1123
#define IDS_ERRLoadConfigDll1         1124
#define IDS_ERRLoadConfigDll2         1125
#define IDS_ERRCorruptConnection      1126
#define IDS_ERRCorruptAccount         1127
#define IDS_ERRDuplicateConnectoidName  1128

#define IDS_ERRNoDialOutModem         1134
#define IDS_ERRModifyCSLIP            1135
#define IDS_ERRProxyRequired        1136
#define IDS_ERRLoadConfigDllNT1       1137
#define IDS_ERRLoadConfigDllNT2       1138
#define IDS_ERRConnectoidNameNT       1139



#define IDS_WARN_EMPTY_USERNAME       1200
#define IDS_WARN_EMPTY_DNS            1201
#define IDS_WARN_EMPTY_PASSWORD       1203
#define IDS_WARN_SERVER_BOUND         1205
#define IDS_WARN_SERVER_BOUND1        1207
#define IDS_REMOVE_SERVER_BOUND       1208
#define IDS_REMOVE_SERVER_BOUND1      1209

#define IDS_WARNWillRemoveMSN         1221

#define IDS_OKTOCHANGECONFIG          1230
#define IDS_ABOUTTOCHANGECONFIG1      1231
#define IDS_ABOUTTOCHANGECONFIG2      1232
#define IDS_DEF_CONNECTION_NAME_1     1233
#define IDS_DEF_CONNECTION_NAME_2     1234
#define IDS_SYSTEM_ALREADY_CONFIGURED 1235
#define IDS_CONFIGAPIFAILED           1236
#define IDS_SERVICEDISABLED           1237

#define IDS_NEED_PHONENUMBER          1250
#define IDS_NEED_IPADDR               1251
#define IDS_NEED_ISPNAME              1252
#define IDS_NEED_PROFILENAME          1253
#define IDS_NEED_AREACODE             1254
#define IDS_DUPLICATE_PROFILENAME     1255

#define IDS_INVALID_PORTNUM           1260
#define IDS_INVALIDPHONE              1262


#define IDS_INVALID_IPADDR            1300
#define IDS_INSTALLING_FILES          1303

#define IDS_MODIFYCONNECTION          1320

// Normandy 11970 ChrisK - we need a different title if launched from
// mail or news configuration
#define IDS_BEGINMANUAL_ALTERNATE     1323

#define IDS_LOGINSCRIPTINVALID        1324

#define IDS_HOWTOCONNECT_DESC1        1400
#define IDS_HOWTOCONNECT_DESC2        1401
#define IDS_CONNECTION_DESC1          1402
#define IDS_CONNECTION_DESC2          1403


#define IDS_WANTTOREBOOT              1430

#define IDS_WAITCHECKING              1431
#define IDS_WAITCONNECT               1432

#define IDS_MODEM_WIZ_TITLE           1433
#define IDS_MODEM_CPL_TITLE           1434

#define IDS_SBCSONLY                  1435

#define IDS_CONNECTIONTO                  1436

#define IDS_RNAAP_TITLE             1437

#define IDS_CHOOSEMODEM_TITLE           1452
#define IDS_CONNECTION_TITLE            1453
#define IDS_MODIFYCONNECTION_TITLE      1454
#define IDS_CONNECTIONNAME_TITLE        1455
#define IDS_PHONENUMBER_TITLE           1456
#define IDS_NAMEANDPASSWORD_TITLE       1457   
#define IDS_ADVANCED_TITLE              1458   
#define IDS_CONNECTIONPROTOCOL_TITLE    1459
#define IDS_LOGINSCRIPT_TITLE           1460
#define IDS_USEPROXY_TITLE              1461
#define IDS_PROXYSERVERS_TITLE          1462
#define IDS_PROXYEXCEPTIONS_TITLE       1463
#define IDS_IPADDRESS_TITLE             1464
#define IDS_DNSADDRESS_TITLE            1465
#define IDS_LCPEXTENSIONS_TITLE         1467
#define IDS_HOWTOCONNECT_TITLE          1468
#define IDS_CONNECTEDOK_TITLE           1469
#define IDS_SETUP_PROXY_TITLE           1470
#define IDS_WIZ97_TITLE_FONT_FACE       1471
#define IDS_LAN_INETCFG_TITLE           1472
#define IDS_CONNECTION                  1473
#define IDS_ADDRESS                     1474
#define IDS_ADVANCE_PROPERTIES          1475
#define IDS_USEDIALRULES                1476
#define IDS_ADMIN_ACCESS_DENIED         1477
#define IDS_ADMIN_ACCESS_DENIED_TITLE   1478

// dialog page IDs
#define IDD_PAGE_HOWTOCONNECT               2001
#define IDD_PAGE_CHOOSEMODEM                2002
#define IDD_PAGE_CONNECTEDOK                2003
#define IDD_PAGE_CONNECTION                 2004
#define IDD_PAGE_CONNECTIONNAME             2005
#define IDD_PAGE_MODIFYCONNECTION           2006
#define IDD_PAGE_ADVANCED                   2007
#define IDD_PAGE_PHONENUMBER                2008
#define IDD_PAGE_NAMEANDPASSWORD            2009
#define IDD_PAGE_CONNECTIONPROTOCOL         2010
#define IDD_PAGE_LOGINSCRIPT                2011
#define IDD_PAGE_USEPROXY                   2012
#define IDD_PAGE_PROXYSERVERS               2013
#define IDD_PAGE_PROXYEXCEPTIONS            2014
#define IDD_PAGE_IPADDRESS                  2015
#define IDD_PAGE_DNSADDRESS                 2016
#define IDD_PAGE_SETUP_PROXY                2018

#define IDD_PAGE_HOWTOCONNECT97             2030
#define IDD_PAGE_CHOOSEMODEM97              2031
#define IDD_PAGE_CONNECTEDOK97              2032
#define IDD_PAGE_CONNECTION97               2033
#define IDD_PAGE_MODIFYCONNECTION97         2034
#define IDD_PAGE_CONNECTIONNAME97           2035
#define IDD_PAGE_PHONENUMBER97              2036
#define IDD_PAGE_NAMEANDPASSWORD97          2037
#define IDD_PAGE_USEPROXY97                 2043
#define IDD_PAGE_PROXYSERVERS97             2044
#define IDD_PAGE_PROXYEXCEPTIONS97          2045
#define IDD_PAGE_HOWTOCONNECT97FIRSTLAST    2047
#define IDD_PAGE_CONNECTEDOK97FIRSTLAST     2048
#define IDD_PAGE_SETUP_PROXY97              2049
#define IDD_ADVANCE_MANUAL                  2050
#define IDD_ADVANCE_TAB_CONN                2052
#define IDD_ADVANCE_TAB_ADDR                2053

#define IDD_NEWPROFILENAME            2020
#define IDD_SECURITY_CHECK            2021
#define IDD_DNS_WARNING               2022
#define IDD_NEEDDRIVERS               2023
#define IDD_CHOOSEMODEMNAME           2024
#define IDD_CHOOSEPROFILENAME         2025

#define IDS_MAPIERROR_BASE            3000

#ifdef IDC_HELP
#undef IDC_HELP
#endif

// dialog control IDs
#define IDC_UNUSED                    -1
#define IDC_BMPFRAME                  2100
#define IDC_CONNECT_BY_PHONE          2102
#define IDC_CONNECT_BY_LAN            2103
#define IDC_CONNECT_MANUAL            2104
#define IDC_AREACODE                  2108
#define IDC_PHONENUMBER               2109
#define IDC_USERNAME                  2110
#define IDC_PASSWORD                  2111
#define IDC_CONFIRMPASSWORD           2112
#define IDC_MODIFYCONNECTION          2113
#define IDC_NOMODIFYCONNECTION        2114
#define IDC_CONNECTIONNAME            2115
#define IDC_NEWCONNECTION             2116
#define IDC_EXISTINGCONNECTION        2117
#define IDC_LBLMODIFYCONNECTION       2118
#define IDC_MODIFYADVANCED            2119
#define IDC_NOMODIFYADVANCED          2120
#define IDC_ISPNAME                   2121
#define IDC_USE_DHCP                  2123
#define IDC_USE_IP                    2124
#define IDC_IPADDR                    2125
#define IDC_DNSADDR1                  2127
#define IDC_DNSADDR2                  2128
#define IDC_TX_IPADDR                 2129
#define IDC_AUTO_DNS                  2130
#define IDC_STATIC_DNS                2131
#define IDC_TX_DNSADDR1               2132
#define IDC_TX_DNSADDR2               2133
#define IDC_COUNTRYCODE               2136
#define IDC_MODEM                     2137
#define IDC_TX_STATUS                 2143
#define IDC_SETDEFAULT                2149
#define IDC_NEW_PROFILE               2150
#define IDC_PROFILE_LIST              2151
#define IDC_PROFILENAME               2152
#define IDC_DISABLE_CHECK             2153
#define IDC_GRP_SETTINGS              2154
#define IDC_HELP                      2155
#define IDC_DISABLE_WARNING           2156
#define IDC_USEDIALRULES              2157
#define IDC_PROTOCOLPPP               2158
#define IDC_PROTOCOLSLIP              2159
#define IDC_PROTOCOLCSLIP             2160
#define IDC_NOTERMINALAFTERDIAL       2161
#define IDC_TERMINALAFTERDIAL         2162
#define IDC_SCRIPT                    2163
#define IDC_BROWSE                    2164
#define IDC_SCRIPTFILE                2170
#define IDC_TX_PROXYBYPASS            2178
#define IDC_TX_PROXYSERVER            2179
#define IDC_TX_AREACODE               2180
#define IDC_TX_COUNTRYCODE            2181
#define IDC_TX_SEPARATOR              2182
#define IDC_LBLTITLE                  2183

#define IDC_TX_ACCOUNT                2198
#define IDC_TX_PASSWORD               2199

#define IDC_USEPROXY                  2200
#define IDC_NOUSEPROXY                2201
#define IDC_TX_PROXYTYPE              2202
#define IDC_TX_PROXYADDRESS           2203
#define IDC_TX_PROXYPORT              2204
#define IDC_TX_PROXYHTTP              2205
#define IDC_PROXYHTTP                 2206
#define IDC_PORTHTTP                  2207
#define IDC_TX_PROXYSECURE            2208
#define IDC_PROXYSECURE               2209
#define IDC_PORTSECURE                2210
#define IDC_TX_PROXYFTP               2211
#define IDC_PROXYFTP                  2212
#define IDC_PORTFTP                   2213
#define IDC_TX_PROXYGOPHER            2214
#define IDC_PROXYGOPHER               2215
#define IDC_PORTGOPHER                2216
#define IDC_TX_PROXYSOCKS             2217
#define IDC_PROXYSOCKS                2218
#define IDC_PORTSOCKS                 2219
#define IDC_PROXYSAME                 2220
#define IDC_TX_BYPASSPROXY            2222
#define IDC_BYPASSPROXY               2223
#define IDC_TX_USESEMICOLON           2224
#define IDC_BYPASSLOCAL               2225

#define IDC_INCOMINGMAILTYPE          2226

#define IDC_NEWACCT                   2230
#define IDC_EXISTINGACCT              2231
#define IDC_ACCTNAME                  2232
#define IDC_ACCTLIST                  2233
#define IDC_LBLMODIFYACCT             2234
#define IDC_MODIFYACCT                2235
#define IDC_NOMODIFYACCT              2236

#define IDC_CANCEL                    2240
#define IDC_DISABLELCP                2241
#define IDC_NODISABLELCP              2242

#define IDC_DESC                      2250
#define IDC_LOGONPLAIN                2252
#define IDC_LOGONSICILY               2253
#define IDC_LBLUSERNAME               2254
#define IDC_LBLPASSWORD               2255

#define IDC_NOTE                      2258
#define IDC_CONFIGSCRIPT              2259
#define IDC_MANUAL_PROXY              2260
#define IDC_CONFIG_ADDR               2261
#define IDC_AUTODISCOVER              2262
#define IDC_CONFIGADDR_TX             2263
#define IDC_GRP_AUTO                  2264
#define IDC_SCRIPT_LABEL              2266
#define IDC_DNS_USE_FOLLOW            2267
#define IDC_PRIM_LABEL                2268
#define IDC_SEC_LABEL                 2269
#define IDC_IP_ADDR_LABEL             2270

///fix for dup ids start at 4000
#define IDC_CONNECTEDOK97FIRSTLAST_TEXT1   4000
#define IDC_CONNECTEDOK97FIRSTLAST_TEXT2   4001
#define IDC_CONNECTEDOK97FIRSTLAST_TEXT3   4002
#define IDC_CONNECTIONNAME97_TEXT1         4003
#define IDC_CONNECTIONNAME97_TEXT2         4004
#define IDC_LBLCONNECTIONNAME              4005
#define IDC_PHONENUMBER97_TEXT1            4006
#define IDC_LBLPHONENUMBER                 4007
#define IDC_NAMEANDPASSWORD97_TEXT1        4008
#define IDC_NAMEANDPASSWORD97_TEXT2        4009
#define IDC_LOGINSCRIPT97_TEXT1            4010
#define IDC_LOGINSCRIPT97_TEXT2            4011
#define IDC_PROXYSERVERS97_TEXT1           4012
#define IDC_PROXYSERVERS97_TEXT2           4013
#define IDC_PROXYSERVERS97_TEXT3           4014
#define IDC_PROXYSERVERS97_TEXT4           4015
#define IDC_PROXYSERVERS97_TEXT5           4016
#define IDC_NEWPROFILENAME_TEXT1           4017
#define IDC_NEWPROFILENAME_TEXT2           4018
#define IDC_SECURITY_CHECK_TEXT1           4019
#define IDC_SECURITY_CHECK_TEXT2           4020
#define IDC_SECURITY_CHECK_TEXT3           4021
#define IDC_DNS_WARNING_TEXT1              4022
#define IDC_DNS_WARNING_TEXT2              4023
#define IDC_DNS_WARNING_TEXT3              4024
#define IDC_CONNECTEDOK97_TEXT1            4025 
#define IDC_CONNECTEDOK97_TEXT2            4026
#define IDC_CONNECTEDOK97_TEXT3            4027
#define IDC_CONNECTIONNAME_TEXT1           4025
#define IDC_CONNECTIONNAME_TEXT2           4026
#define IDC_CONNECTIONNAME_TEXT3           4027
#define IDC_CONNECTEDOK_TEXT1              4028
#define IDC_CONNECTEDOK_TEXT2              4029
#define IDC_CONNECTEDOK_TEXT3              4030
#define IDC_CHOOSEMODEM97_TEXT1            4031
#define IDC_CHOOSEMODEM97_TEXT2            4032
#define IDC_CHOOSEMODEM_TEXT1              4033
#define IDC_CHOOSEMODEM_TEXT2              4034
#define IDC_PHONENUMBER_TEXT1              4035
#define IDC_PHONENUMBER_TEXT2              4036
#define IDC_NAMEANDPASSWORD97_TEXT3        4037
#define IDC_NAMEANDPASSWORD_TEXT1          4038
#define IDC_NAMEANDPASSWORD_TEXT2          4039
#define IDC_NAMEANDPASSWORD_TEXT3          4040
#define IDC_PROXYSERVERS_TEXT1             4041
#define IDC_PROXYSERVERS_TEXT2             4042
#define IDC_PROXYSERVERS_TEXT3             4043
#define IDC_PROXYSERVERS_TEXT4             4044
#define IDC_PROXYSERVERS_TEXT5             4045
#define IDC_CHOOSEMODEMNAME_TEXT1          4046
#define IDC_CHOOSEMODEMNAME_TEXT2          4047
#define IDC_LOGINSCRIPT_TEXT1              4048
#define IDC_LOGINSCRIPT_TEXT2              4049
#define IDC_AUTODISCOVERY_TEXT             4050
#define IDS_SETUP_PROXY_INTRO              4051

// bitmap IDs
#define IDB_WATERMARK256                2290
#define IDB_WATERMARK16                 2291
#define IDB_BANNER256                   2292
#define IDB_BANNER16                    2293
#define IDB_BMP_WELCOME                 2294


// icon IDs
#define IDI_WORLD                     2300
#define IDI_MODEM                     2303

// Wait dialog constants
#define IDC_LBLWAITCFG                2375
#define IDA_WAITINGCONFIG             2376
#define IDD_CONFIGWAIT                2377
#define IDC_ANIMATE                   2378
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\imnext.h ===
/******************************************************

  IMNEXT.H 

  Contains external declarations for global variables
  used for Internet Mail and News setup as well as
  forward declarations for supporting functions.

  9/30/96	valdonb	Created

 ******************************************************/

#ifndef __IMNACT_H__
#define __IMNACT_H__

#include "imnact.h"

extern IICWApprentice	*gpImnApprentice;	// Mail/News account manager object

extern BOOL LoadAcctMgrUI( HWND hWizHWND, UINT uPrevDlgID, UINT uNextDlgID, DWORD dwFlags );

// in propmgr.cpp
extern BOOL DialogIDAlreadyInUse( UINT uDlgID );

// in icwaprtc.cpp
extern UINT	g_uExternUIPrev, g_uExternUINext;


/**
 * 
 *  No longer used after switch to wizard/apprentice model
 *
 * 4/23/97	jmazner	Olympus #3136
 *
extern IImnAccountManager	*gpImnAcctMgr;		// Mail/News account manager object
extern IImnEnumAccounts		*gpMailAccts;		// Enumerator object for mail accounts
extern IImnEnumAccounts		*gpNewsAccts;		// Enumerator object for news accounts
extern IImnEnumAccounts		*gpLDAPAccts;		// Enumerator object for news accounts


VOID InitAccountList(HWND hLB, IImnEnumAccounts *pAccts, ACCTTYPE accttype);
BOOL GetAccount(LPSTR szAcctName, ACCTTYPE accttype);
BOOL AccountNameExists(LPSTR szAcctName);
DWORD ValidateAccountName(LPSTR szAcctName, ACCTTYPE accttype);
BOOL SaveAccount(ACCTTYPE accttype, BOOL fSetAsDefault);
BOOL IsStringWhiteSpaceOnly(LPSTR szString);

**/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\imnext.cpp ===
/******************************************************

  IMNEXT.CPP 

  Contains definitions for global variables and
  functions used for Internet Mail and News setup.

 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1996
 *  All rights reserved


  9/30/96   valdonb Created

 ******************************************************/

#include "wizard.h"
#include "initguid.h"   // Make DEFINE_GUID declare an instance of each GUID
#include "icwextsn.h"
#include "imnext.h"
#include "inetcfg.h"
#include <icwcfg.h>


IICWApprentice  *gpImnApprentice = NULL;    // Mail/News account manager object

//+----------------------------------------------------------------------------
//
//  Function    LoadAcctMgrUI
//
//  Synopsis    Loads in the Account Manager's apprentice pages for configuring
//              accounts (mail, news, directory service/LDAP).
//
//              If the UI has previously been loaded, the function will simply
//              update the Next and Back pages for the apprentice.
//
//              Uses global variable g_fAcctMgrUILoaded.
//
//
//  Arguments   hWizHWND -- HWND of main property sheet
//              uPrevDlgID -- Dialog ID apprentice should go to when user leaves
//                            apprentice by clicking Back
//              uNextDlgID -- Dialog ID apprentice should go to when user leaves
//                            apprentice by clicking Next
//              dwFlags -- Flags variable that should be passed to
//                          IICWApprentice::AddWizardPages
//
//
//  Returns     TRUE if all went well
//              FALSE otherwise
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------

BOOL LoadAcctMgrUI( HWND hWizHWND, UINT uPrevDlgID, UINT uNextDlgID, DWORD dwFlags )
{
    HRESULT hResult = E_NOTIMPL;

    // If we should not run Internet Mail and New setup, then just return FALSE
    if (gpWizardState->dwRunFlags & RSW_NOIMN)
        return FALSE;
        
    if( g_fAcctMgrUILoaded )
    {
        ASSERT( g_pCICWExtension );
        ASSERT( gpImnApprentice );

        DEBUGMSG("LoadAcctMgrUI: UI already loaded, just reset first (%d) and last (%d) pages",
                uPrevDlgID, uNextDlgID);

        // If We are ICW, the Mail account manager is our last page.
        if (g_fIsICW) 
            uNextDlgID = g_uExternUINext;

        hResult = gpImnApprentice->SetPrevNextPage( uPrevDlgID, uNextDlgID );
        goto LoadAcctMgrUIExit;
    }


    if( !hWizHWND )
    {
        DEBUGMSG("LoadAcctMgrUI got a NULL hWizHWND!");
        return FALSE;
    }

    if( gpImnApprentice )
    {
        if( NULL == g_pCICWExtension )
        {
            DEBUGMSG("Instantiating ICWExtension and using it to initialize Acct Mgr's IICWApprentice");
            g_pCICWExtension = new( CICWExtension );
            g_pCICWExtension->AddRef();
            g_pCICWExtension->m_hWizardHWND = hWizHWND;
            gpImnApprentice->Initialize( g_pCICWExtension );
        }

        hResult = gpImnApprentice->AddWizardPages(dwFlags);

        if( !SUCCEEDED(hResult) )
        {
            goto LoadAcctMgrUIExit;
        }

        // If We are ICW, the Mail account manager is our last page.
        if (g_fIsICW) 
            uNextDlgID = g_uExternUINext;
        hResult = gpImnApprentice->SetPrevNextPage( uPrevDlgID, uNextDlgID );
    }


LoadAcctMgrUIExit:
    if( SUCCEEDED(hResult) )
    {
        g_fAcctMgrUILoaded = TRUE;
        return TRUE;
    }
    else
    {
        DEBUGMSG("LoadAcctMgrUI failed with (hex) hresult %x", hResult);
        return FALSE;
    }
}


/****
 *
 * The rest of the functions in this file are no longer used since switching to
 * the apprentice/wizard model
 *
 * 4/23/97 jmazner Olympus #3136

/*****************************************************************

  NAME:     InitAccountList

  SYNOPSIS: Fills a list box with the account names in the account list.

  PARAMETERS:

            hLB         HWND to the list box to be filled
            pEnumAccts  Pointer the the account list
            accttype    Type of accounts in the account list

  RETURN:   none

 *****************************************************************/
/**
VOID InitAccountList(HWND hLB, IImnEnumAccounts *pEnumAccts, ACCTTYPE accttype)
{
    IImnAccount *pAcct = NULL;
    CHAR szDefAcct[CCHMAX_ACCOUNT_NAME+1];
    CHAR szBuf[CCHMAX_ACCOUNT_NAME+1];
    HRESULT hr;
    DWORD index;
    BOOL fSelected = FALSE;

    ListBox_ResetContent(hLB);

    if (NULL == pEnumAccts)
        return;

    szDefAcct[0] = '\0';

    // Get the default so we can highlight it in the list
    gpImnAcctMgr->GetDefaultAccountName(accttype,szDefAcct,CCHMAX_ACCOUNT_NAME);
    
    // 2/20/97  jmazner Olympus #262
    // Reset back to the first acct. so that when we walk through the GetNext loop,
    // we're sure to get every account
    pEnumAccts->Reset();

    // Populate the account list box
    while (SUCCEEDED(pEnumAccts->GetNext(&pAcct)))
    {
        hr = pAcct->GetPropSz(AP_ACCOUNT_NAME,szBuf,sizeof(szBuf));
        if (SUCCEEDED(hr))
        {
            index = ListBox_AddString(hLB,szBuf);
            if (!lstrcmp(szBuf,szDefAcct))
            {
                fSelected = TRUE;
                ListBox_SetCurSel(hLB, index);
            }
        }
        pAcct->Release();
        pAcct = NULL;
    }

    // If nothing was selected as the default,
    // select the first in the list
    if (!fSelected)
        // oops, SetSel is for multiple choice list boxes
        // we want SetCurSel
        //ListBox_SetSel(hLB, TRUE, 0);
        ListBox_SetCurSel(hLB, 0);
}
**/
/*****************************************************************

  NAME:     GetAccount

  SYNOPSIS: Gets a mail or news account by name and sets the
            property information structure.

  PARAMETERS:

            szAcctName  Name of the account to load
            accttype    Type of account to load

  RETURN:   BOOL        TRUE if account was found and loaded
                        FALSE if not found

 *****************************************************************/
/**
BOOL GetAccount(LPSTR szAcctName, ACCTTYPE accttype)
{
    IImnAccount *pAcct = NULL;
    HRESULT hr;
    DWORD dwTemp = 0;
    DWORD dwServerTypes = 0;
    BOOL fRet = TRUE;

    if (NULL == gpImnAcctMgr)
        return FALSE;
    // Get the account information and move it into our
    // structure.
    hr = gpImnAcctMgr->FindAccount(AP_ACCOUNT_NAME,szAcctName,
                                     &pAcct);
    if (FAILED(hr) || !pAcct)
        return FALSE;

    // 12/3/96  jmazner Normandy #8504
    // 2/7/96   jmazner Athena changed things around a bit
    //pAcct->GetPropDw(AP_SERVER_TYPES, &dwServerTypes);
    pAcct->GetServerTypes( &dwServerTypes );

    // 2/17/96  jmazner Olympus #1063
    //                  need to clearAccount before loading new stuff
    ClearUserInfo( gpUserInfo, accttype);


    switch( accttype )
    {
        case ACCT_NEWS:
            // 12/16/96 jmazner  This is not a valid assert; sometimes we'll load
            //  in an account for mail, and later check whether it also has news
            //  Also, the macro causes a GPF in retail builds...
            //ASSERT( dwServerTypes & SRV_NNTP );

            // 2/12/97  jmazner Athena changed things around in their build 0511;
            //                  one of the changes is that now an account can only
            //                  hold one ACCT type  (see Normandy #13710)
            if( !(SRV_NNTP & dwServerTypes) )
            {
                fRet = FALSE;
                goto GetAccountExit;
            }

            pAcct->GetPropSz(AP_NNTP_DISPLAY_NAME, gpUserInfo->inc.szNNTPName, MAX_EMAIL_NAME);
            pAcct->GetPropSz(AP_NNTP_EMAIL_ADDRESS, gpUserInfo->inc.szNNTPAddress, MAX_EMAIL_ADDRESS);
            pAcct->GetPropSz(AP_NNTP_USERNAME, gpUserInfo->inc.szNNTPLogonName, MAX_LOGON_NAME);
            pAcct->GetPropSz(AP_NNTP_PASSWORD, gpUserInfo->inc.szNNTPLogonPassword, MAX_LOGON_PASSWORD);
            pAcct->GetPropSz(AP_NNTP_SERVER, gpUserInfo->inc.szNNTPServer, MAX_SERVER_NAME);
            // 12/17/96 jmazner Normandy 12871
            //pAcct->GetPropDw(AP_NNTP_USE_SICILY, &dwTemp);
            //gpUserInfo->fNewsAccount = !(BOOL)dwTemp;
            pAcct->GetPropDw(AP_NNTP_USE_SICILY, (DWORD *)&(gpUserInfo->inc.fNewsLogonSPA));
            gpUserInfo->fNewsLogon = (gpUserInfo->inc.fNewsLogonSPA || gpUserInfo->inc.szNNTPLogonName[0]);
            break;

        case ACCT_MAIL:
            if( !( (SRV_SMTP & dwServerTypes) ||
                   (SRV_POP3 & dwServerTypes) ||
                   (SRV_IMAP & dwServerTypes) ))
            {
                fRet = FALSE;
                goto GetAccountExit;
            }

            pAcct->GetPropSz(AP_SMTP_SERVER, gpUserInfo->inc.szSMTPServer, MAX_SERVER_NAME);
            pAcct->GetPropSz(AP_SMTP_DISPLAY_NAME, gpUserInfo->inc.szEMailName, MAX_EMAIL_NAME);
            pAcct->GetPropSz(AP_SMTP_EMAIL_ADDRESS, gpUserInfo->inc.szEMailAddress, MAX_EMAIL_ADDRESS);



            if( dwServerTypes & SRV_POP3 )
            {
                pAcct->GetPropSz(AP_POP3_USERNAME, gpUserInfo->inc.szIncomingMailLogonName, MAX_LOGON_NAME);
                pAcct->GetPropSz(AP_POP3_PASSWORD, gpUserInfo->inc.szIncomingMailLogonPassword, MAX_LOGON_PASSWORD);
                pAcct->GetPropSz(AP_POP3_SERVER, gpUserInfo->inc.szIncomingMailServer, MAX_SERVER_NAME);
                pAcct->GetPropDw(AP_POP3_USE_SICILY, (DWORD *)&(gpUserInfo->inc.fMailLogonSPA));

                gpUserInfo->inc.iIncomingProtocol = SRV_POP3;
            }
            else
            {
                pAcct->GetPropSz(AP_IMAP_USERNAME, gpUserInfo->inc.szIncomingMailLogonName, MAX_LOGON_NAME);
                pAcct->GetPropSz(AP_IMAP_PASSWORD, gpUserInfo->inc.szIncomingMailLogonPassword, MAX_LOGON_PASSWORD);
                pAcct->GetPropSz(AP_IMAP_SERVER, gpUserInfo->inc.szIncomingMailServer, MAX_SERVER_NAME);
                pAcct->GetPropDw(AP_IMAP_USE_SICILY, (DWORD *)&(gpUserInfo->inc.fMailLogonSPA));

                gpUserInfo->inc.iIncomingProtocol = SRV_IMAP;

            }
            break;

        case ACCT_DIR_SERV:
            if( !(SRV_LDAP & dwServerTypes) )
            {
                fRet = FALSE;
                goto GetAccountExit;
            }
            {
                DWORD dwLDAPAuth = 0;
                pAcct->GetPropDw(AP_LDAP_AUTHENTICATION, &dwLDAPAuth);
                switch( dwLDAPAuth )
                {
                    case LDAP_AUTH_ANONYMOUS:
                        gpUserInfo->inc.fLDAPLogonSPA = FALSE;
                        gpUserInfo->fLDAPLogon = FALSE;
                        break;
                    case LDAP_AUTH_MEMBER_SYSTEM:
                        gpUserInfo->inc.fLDAPLogonSPA = TRUE;
                        gpUserInfo->fLDAPLogon = TRUE;
                        break;
                    case LDAP_AUTH_PASSWORD:
                        gpUserInfo->inc.fLDAPLogonSPA = FALSE;
                        gpUserInfo->fLDAPLogon = TRUE;
                        pAcct->GetPropSz(AP_LDAP_USERNAME, gpUserInfo->inc.szLDAPLogonName, MAX_LOGON_NAME);
                        pAcct->GetPropSz(AP_LDAP_PASSWORD, gpUserInfo->inc.szLDAPLogonPassword, MAX_LOGON_PASSWORD);
                        break;
                }
            }



                pAcct->GetPropSz(AP_LDAP_SERVER, gpUserInfo->inc.szLDAPServer, MAX_SERVER_NAME);
                pAcct->GetPropDw(AP_LDAP_RESOLVE_FLAG, (DWORD *)&(gpUserInfo->inc.fLDAPResolve));
            break;

        default:
            fRet = FALSE;
            break;

    }

GetAccountExit:
    pAcct->Release();
    pAcct = NULL;

    return fRet;
}
**/
/*****************************************************************

  NAME:     ValidateAccountName

  SYNOPSIS: Validates that a string can be used as an account
            name.  It will also check if the account exists and
            load the information by calling GetAccount.

  PARAMETERS:

            szAcctName  String to use for the name of the account
            accttype    Type of account

  RETURN:   DWORD       0 if successful
                        Resource id of error string if an error
                        occurs.

 *****************************************************************/
/**
DWORD ValidateAccountName(LPSTR szAcctName, ACCTTYPE accttype)
{
    LPSTR sz = szAcctName;
    BOOL fBlank = TRUE;

    // Make sure the name is not blank and
    // does not contain a backslash
    while (*sz && '\\' != *sz)
    {
        if (' ' != *sz)
            fBlank = FALSE;
        sz++;
    }

    // 12/17/96 jmazner Normandy #12851
    // check for backslash first to correctly handle the string "\"
    if ('\\' == *sz)
        return IDS_ERRInvalidAcctName;
    if (fBlank)
        return IDS_NEED_ACCTNAME;

    // Check if this account already exists
    // 2/10/97  jmazner Normandy #13710
    //          If the account already exists, notify the user and force a new acct name.
    if ( AccountNameExists(szAcctName) )
    {
        return IDS_DUP_ACCTNAME;
    }

    return ERROR_SUCCESS;
}
**/
/*******************************************************************

  NAME:     SaveAccount

  SYNOPSIS: Save the changes to the mail or news account.

  PARAMETERS:

            accttype        Type of account to save (ACCT_SMTP or ACCT_NNTP)
            bSetAsDefault   Set this account to be the default

  RETURN:   BOOL    TRUE if changes saved
                    FALSE if an error occured

********************************************************************/
/**
BOOL SaveAccount(ACCTTYPE accttype, BOOL fSetAsDefault)
{
    IImnAccount *pAcct = NULL;
    LPSTR lpszAcctName = NULL;
    DWORD     dwConnectionType;
    BOOL fRet = FALSE;
    HRESULT hr;

    ASSERT (gpImnAcctMgr);
    if (NULL == gpImnAcctMgr)
        goto CommitAccountExit;

    dwConnectionType = gpUserInfo->fConnectOverLAN ? 0L : 2L;

    switch( accttype )
    {
        case ACCT_NEWS:
            lpszAcctName = gpUserInfo->szNewsAcctName;
            break;
        case ACCT_MAIL:
            lpszAcctName = gpUserInfo->szMailAcctName;
            break;
        case ACCT_DIR_SERV:
            lpszAcctName = gpUserInfo->szDirServiceName;
            break;
    }

    //  lpszAcctName = gpUserInfo->szNewsAcctName;
    //else
    //  lpszAcctName = gpUserInfo->szMailAcctName;

    // First try and get existing account info to change
    hr = gpImnAcctMgr->FindAccount(AP_ACCOUNT_NAME,
                                     lpszAcctName,
                                     &pAcct);
    if (FAILED(hr) || !pAcct)
    {
        // Create a new account
        hr = gpImnAcctMgr->CreateAccountObject(accttype, &pAcct);
        if (FAILED(hr) || !pAcct)
            goto CommitAccountExit;
    }

    // Fill in the account information that we have
    pAcct->SetPropSz(AP_ACCOUNT_NAME, lpszAcctName);
    //pAcct->SetPropSz(AP_RAS_CONNECTOID, gpUserInfo->szISPName);
    //pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, dwConnectionType);

    switch( accttype )
    {
        case ACCT_NEWS:
            pAcct->SetPropSz(AP_RAS_CONNECTOID, gpUserInfo->szISPName);
            pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, dwConnectionType);

            pAcct->SetPropSz(AP_NNTP_DISPLAY_NAME, gpUserInfo->inc.szNNTPName);
            pAcct->SetPropSz(AP_NNTP_EMAIL_ADDRESS, gpUserInfo->inc.szNNTPAddress);
            // 12/17/96 jmazner Normandy #12871
            //pAcct->SetPropDw(AP_NNTP_USE_SICILY, gpUserInfo->fNewsLogon && !gpUserInfo->fNewsAccount);
            pAcct->SetPropDw(AP_NNTP_USE_SICILY, gpUserInfo->inc.fNewsLogonSPA);
            if (gpUserInfo->fNewsLogon && !gpUserInfo->inc.fNewsLogonSPA)
            {
                pAcct->SetPropSz(AP_NNTP_USERNAME, gpUserInfo->inc.szNNTPLogonName);
                pAcct->SetPropSz(AP_NNTP_PASSWORD, gpUserInfo->inc.szNNTPLogonPassword);
            }
            else
            {
                // 1/15/96 jmazner Normandy #13162
                // clear out logon name and password, so that if we load in this account
                // in the future, we won't be confused about whether to set fNewsLogon
                pAcct->SetProp(AP_NNTP_USERNAME, NULL, 0);
                pAcct->SetProp(AP_NNTP_PASSWORD, NULL, 0);
            }


            pAcct->SetPropSz(AP_NNTP_SERVER, gpUserInfo->inc.szNNTPServer);
            break;

        case ACCT_MAIL:
            pAcct->SetPropSz(AP_RAS_CONNECTOID, gpUserInfo->szISPName);
            pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, dwConnectionType);

            pAcct->SetPropSz(AP_SMTP_SERVER, gpUserInfo->inc.szSMTPServer);
            pAcct->SetPropSz(AP_SMTP_DISPLAY_NAME, gpUserInfo->inc.szEMailName);
            pAcct->SetPropSz(AP_SMTP_EMAIL_ADDRESS, gpUserInfo->inc.szEMailAddress);

            // 12/3/96  jmazner Normandy #8504
            if( SRV_POP3 == gpUserInfo->inc.iIncomingProtocol )
            {
                pAcct->SetPropSz(AP_POP3_SERVER, gpUserInfo->inc.szIncomingMailServer);
                // 12/17/96 jmazner Normandy #12871
                pAcct->SetPropDw(AP_POP3_USE_SICILY, gpUserInfo->inc.fMailLogonSPA);
                if( !gpUserInfo->inc.fMailLogonSPA )
                {
                    pAcct->SetPropSz(AP_POP3_USERNAME, gpUserInfo->inc.szIncomingMailLogonName);
                    pAcct->SetPropSz(AP_POP3_PASSWORD, gpUserInfo->inc.szIncomingMailLogonPassword);
                }

                pAcct->SetProp(AP_IMAP_USERNAME, NULL, 0);
                pAcct->SetProp(AP_IMAP_SERVER, NULL, 0);
                pAcct->SetProp(AP_IMAP_PASSWORD, NULL, 0);

            }
            else
            {
                pAcct->SetPropSz(AP_IMAP_SERVER, gpUserInfo->inc.szIncomingMailServer);
                // 12/17/96 jmazner Normandy #12871
                pAcct->SetPropDw(AP_IMAP_USE_SICILY, gpUserInfo->inc.fMailLogonSPA);
                if( !gpUserInfo->inc.fMailLogonSPA )
                {
                    pAcct->SetPropSz(AP_IMAP_USERNAME, gpUserInfo->inc.szIncomingMailLogonName);
                    pAcct->SetPropSz(AP_IMAP_PASSWORD, gpUserInfo->inc.szIncomingMailLogonPassword);
                }

                pAcct->SetProp(AP_POP3_USERNAME, NULL, 0);
                pAcct->SetProp(AP_POP3_SERVER, NULL, 0);
                pAcct->SetProp(AP_POP3_PASSWORD, NULL, 0);
            }
            break;

        case ACCT_DIR_SERV:
            pAcct->SetPropSz(AP_LDAP_SERVER, gpUserInfo->inc.szLDAPServer);
            pAcct->SetPropDw(AP_LDAP_RESOLVE_FLAG, gpUserInfo->inc.fLDAPResolve);

            if( gpUserInfo->inc.szLDAPLogonName[0] && gpUserInfo->fLDAPLogon )
            {
                // if we have a user name, then we're using
                // LDAP_AUTH_PASSWORD
                ASSERT( !gpUserInfo->inc.fLDAPLogonSPA );
                pAcct->SetPropSz(AP_LDAP_USERNAME, gpUserInfo->inc.szLDAPLogonName);
                pAcct->SetPropSz(AP_LDAP_PASSWORD, gpUserInfo->inc.szLDAPLogonPassword);
                pAcct->SetPropDw(AP_LDAP_AUTHENTICATION, LDAP_AUTH_PASSWORD);
            }
            else
            {
                //we know there's no username/password, so clear out those fields
                pAcct->SetProp(AP_LDAP_USERNAME, NULL, 0);
                pAcct->SetProp(AP_LDAP_PASSWORD, NULL, 0);

                //now determine whether there's no logon required, or if we're using SPA
                if( gpUserInfo->inc.fLDAPLogonSPA )
                {
                    pAcct->SetPropDw(AP_LDAP_AUTHENTICATION, LDAP_AUTH_MEMBER_SYSTEM);
                }
                else
                {
                    pAcct->SetPropDw(AP_LDAP_AUTHENTICATION, LDAP_AUTH_ANONYMOUS);
                }
            }
            break;


    }

    // Save the changes
    hr = pAcct->SaveChanges();
    if (FAILED(hr))
        goto CommitAccountExit;

    if (fSetAsDefault)
    {
        // Set this account as the default
        // Ignore failure since it isn't fatal
        pAcct->SetAsDefault();
    }

    // If we need to return the settings, put them in the global struct
    if (gpMailNewsInfo && ( (ACCT_MAIL==accttype) || (ACCT_NEWS==accttype) ) )
    {
        ASSERT(sizeof(*gpMailNewsInfo) == gpMailNewsInfo->dwSize);
        
        if (ACCT_NEWS == accttype)
        {
            lstrcpy(gpMailNewsInfo->szAccountName, gpUserInfo->szNewsAcctName);
            lstrcpy(gpMailNewsInfo->szUserName, gpUserInfo->inc.szNNTPLogonName);
            lstrcpy(gpMailNewsInfo->szPassword, gpUserInfo->inc.szNNTPLogonPassword);
            lstrcpy(gpMailNewsInfo->szNNTPServer, gpUserInfo->inc.szNNTPServer);
            lstrcpy(gpMailNewsInfo->szDisplayName, gpUserInfo->inc.szNNTPName);
            lstrcpy(gpMailNewsInfo->szEmailAddress, gpUserInfo->inc.szNNTPAddress);

            // 12/17/96 jmazner Normandy #12871
            // fNewsLogon and fNewsAccount flags have been superceeded by fNewsLogonSPA
            //gpMailNewsInfo->fUseSicily = (gpUserInfo->fNewsLogon && !gpUserInfo->fNewsAccount);
            gpMailNewsInfo->fUseSicily = (gpUserInfo->inc.fNewsLogonSPA);
        }
        else
        {
            lstrcpy(gpMailNewsInfo->szAccountName, gpUserInfo->szMailAcctName);
            lstrcpy(gpMailNewsInfo->szUserName, gpUserInfo->inc.szIncomingMailLogonName);
            lstrcpy(gpMailNewsInfo->szPassword, gpUserInfo->inc.szIncomingMailLogonPassword);
            lstrcpy(gpMailNewsInfo->szSMTPServer, gpUserInfo->inc.szSMTPServer);

            if( SRV_POP3 == gpUserInfo->inc.iIncomingProtocol )
                lstrcpy(gpMailNewsInfo->szPOP3Server, gpUserInfo->inc.szIncomingMailServer);
            else
                lstrcpy(gpMailNewsInfo->szIMAPServer, gpUserInfo->inc.szIncomingMailServer);

            lstrcpy(gpMailNewsInfo->szDisplayName, gpUserInfo->inc.szEMailName);
            lstrcpy(gpMailNewsInfo->szEmailAddress, gpUserInfo->inc.szEMailAddress);

            gpMailNewsInfo->fUseSicily = (gpUserInfo->inc.fMailLogonSPA);
        }

        gpMailNewsInfo->dwConnectionType = dwConnectionType;
        lstrcpy(gpMailNewsInfo->szConnectoid, gpUserInfo->szISPName);
    }
    else if( gpDirServiceInfo && (ACCT_DIR_SERV == accttype) )
    {
        ASSERT(sizeof(*gpDirServiceInfo) == gpDirServiceInfo->dwSize);

        lstrcpy(gpDirServiceInfo->szServiceName, gpUserInfo->szDirServiceName);
        lstrcpy(gpDirServiceInfo->szUserName, gpUserInfo->inc.szLDAPLogonName);
        lstrcpy(gpDirServiceInfo->szPassword, gpUserInfo->inc.szLDAPLogonPassword);
        lstrcpy(gpDirServiceInfo->szLDAPServer, gpUserInfo->inc.szLDAPServer);
        gpDirServiceInfo->fUseSicily = (gpUserInfo->inc.fMailLogonSPA);
        gpDirServiceInfo->fLDAPResolve = (gpUserInfo->inc.fLDAPResolve);
    }


    fRet = TRUE;

CommitAccountExit:
    
    if (pAcct)
    {
        pAcct->Release();
        pAcct = NULL;
    }

    return fRet;
}
**/

/*****************************************************************

  NAME:     IsStringWhiteSpaceOnly

  SYNOPSIS: Checks whether a string has non space characters

  PARAMETERS:

            szString    String to check


  RETURN:   BOOL        TRUE if no characters other than ' '
                        FALSE otherwise

 *****************************************************************/
/**
BOOL IsStringWhiteSpaceOnly(LPSTR szString)
{
    LPSTR sz = szString;

    while (*sz)
    {
        if (' ' != *sz)
            return FALSE;
        sz++;
    }
    
    return TRUE;
}
**/

/*****************************************************************

  NAME:     AccountNameExists

  SYNOPSIS: Checks whether a given string is currently in use as
            an Account Manager (inetcomm) account name

  PARAMETERS:

            szAcctName  Name of the account to load

  RETURN:   BOOL        TRUE if account name is in use
                        FALSE if not

  HISTORY:  2/10/96     jmazner Created

 *****************************************************************/
/**
BOOL AccountNameExists(LPSTR szAcctName)
{
    IImnAccount *pAcct = NULL;
    HRESULT hr;

    if (NULL == gpImnAcctMgr)
        return FALSE;

    if (NULL == szAcctName)
        return FALSE;


    hr = gpImnAcctMgr->FindAccount(AP_ACCOUNT_NAME,szAcctName,
                                     &pAcct);
    if (FAILED(hr) || !pAcct)
    {
        return FALSE;
    }
    else
    {
        pAcct->Release();
        pAcct = NULL;
        return TRUE;
    }
}
**/
//+----------------------------------------------------------------------------
//
//  Function    ClearUserInfo
//
//  Synopsis    Sets the fields in a USERINFO struct to NULL.
//
//  Arguments   lpUserinfo - the struct to clear out.
//              accttype - determines whether Mail or News fields are cleared out
//
//  Returns     TRUE if all went well
//              FALSE otherwise
//
//  History     1/21/96 jmazner     created
//
//-----------------------------------------------------------------------------
/**
BOOL ClearUserInfo( USERINFO *lpUserInfo, ACCTTYPE accttype )
{
    if( NULL == lpUserInfo )
        return FALSE;

    switch( accttype ){
    case ACCT_NEWS:
        //lpUserInfo->szNewsAcctName[0] = '\0';
        lpUserInfo->inc.szNNTPLogonName[0] = '\0';
        lpUserInfo->inc.szNNTPLogonPassword[0] = '\0';
        lpUserInfo->inc.szNNTPServer[0] = '\0';
        lpUserInfo->inc.szNNTPName[0] = '\0';
        lpUserInfo->inc.szNNTPAddress[0] = '\0';
        lpUserInfo->inc.fNewsLogonSPA = FALSE;
        lpUserInfo->fNewsLogon = FALSE;
        return TRUE;
        break;
    case ACCT_MAIL:
        //lpUserInfo->szMailAcctName[0] = '\0';
        lpUserInfo->inc.szIncomingMailLogonName[0] = '\0';
        lpUserInfo->inc.szIncomingMailLogonPassword[0] = '\0';
        lpUserInfo->inc.szSMTPServer[0] = '\0';
        lpUserInfo->inc.iIncomingProtocol = SRV_POP3;
        lpUserInfo->inc.szIncomingMailServer[0] = '\0';
        lpUserInfo->inc.szEMailName[0] = '\0';
        lpUserInfo->inc.szEMailAddress[0] = '\0';
        lpUserInfo->inc.fMailLogonSPA = FALSE;
        return TRUE;
        break;
    case ACCT_DIR_SERV:
        //lpUserInfo->szDirServiceName[0] = '\0';
        lpUserInfo->inc.szLDAPLogonName[0] = '\0';
        lpUserInfo->inc.szLDAPLogonPassword[0] = '\0';
        lpUserInfo->inc.szLDAPServer[0] = '\0';
        lpUserInfo->inc.fLDAPResolve = FALSE;
        lpUserInfo->inc.fLDAPLogonSPA = FALSE;
        lpUserInfo->fLDAPLogon = FALSE;

    default:
        return FALSE;
        break;
    }
}
**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\ifcbase.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Sep 26 18:52:56 1996
 */
/* Compiler settings for c:\athena\compobj\idl\ifcbase.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, app_config, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ifcbase_h__
#define __ifcbase_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IPropertyContainer_FWD_DEFINED__
#define __IPropertyContainer_FWD_DEFINED__
typedef interface IPropertyContainer IPropertyContainer;
#endif 	/* __IPropertyContainer_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Sep 26 18:52:56 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {FD465484-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IPropertyContainer, 0xfd465484, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// --------------------------------------------------------------------------------
// Errors
// --------------------------------------------------------------------------------
#ifndef FACILITY_CONTROL
#define FACILITY_CONTROL 0xa
#endif
#ifndef HR_E
#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL, n)
#endif
#ifndef HR_S
#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_CONTROL, n)
#endif
#ifndef HR_CODE
#define HR_CODE(hr) (INT)(hr & 0xffff)
#endif

// --------------------------------------------------------------------------------
// General Errors
// --------------------------------------------------------------------------------
#define E_RegCreateKeyFailed         HR_E(101)
#define E_RegQueryInfoKeyFailed      HR_E(102)
#define E_UserCancel                 HR_E(103)
#define E_RegOpenKeyFailed           HR_E(104)
#define E_RegSetValueFailed          HR_E(105)
#define E_RegDeleteKeyFailed         HR_E(106)

// --------------------------------------------------------------------------------
// IPropertyContainer Errors
// --------------------------------------------------------------------------------
#define E_NoPropData                 HR_E(200)
#define E_BufferTooSmall             HR_E(201)
#define E_BadPropType                HR_E(202)
#define E_BufferSizeMismatch         HR_E(203)
#define E_InvalidBooleanValue        HR_E(204)
#define E_InvalidMinMaxValue         HR_E(205)
#define E_PropNotFound               HR_E(206)
#define E_InvalidPropTag             HR_E(207)
#define E_InvalidPropertySet         HR_E(208)
#define E_EnumFinished               HR_E(209)
#define PROPTAG_MASK                 ((ULONG)0x0000FFFF)
#define PROPTAG_TYPE(ulPropTag)	    (PROPTYPE)(((ULONG)(ulPropTag)) & PROPTAG_MASK)
#define PROPTAG_ID(ulPropTag)		(((ULONG)(ulPropTag))>>16)
#define PROPTAG(ulPropType,ulPropID)	((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define MAX_PROPID                   ((ULONG) 0xFFFF)


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IPropertyContainer_INTERFACE_DEFINED__
#define __IPropertyContainer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertyContainer
 * at Thu Sep 26 18:52:56 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [public] */ 
enum __MIDL_IPropertyContainer_0001
    {	TYPE_ERROR	= 1000,
	TYPE_DWORD	= TYPE_ERROR + 1,
	TYPE_LONG	= TYPE_DWORD + 1,
	TYPE_WORD	= TYPE_LONG + 1,
	TYPE_SHORT	= TYPE_WORD + 1,
	TYPE_BYTE	= TYPE_SHORT + 1,
	TYPE_CHAR	= TYPE_BYTE + 1,
	TYPE_FILETIME	= TYPE_CHAR + 1,
	TYPE_STRING	= TYPE_FILETIME + 1,
	TYPE_BINARY	= TYPE_STRING + 1,
	TYPE_FLAGS	= TYPE_BINARY + 1,
	TYPE_STREAM	= TYPE_FLAGS + 1,
	TYPE_WSTRING	= TYPE_STREAM + 1,
	TYPE_BOOL	= TYPE_WSTRING + 1,
	TYPE_LAST	= TYPE_BOOL + 1
    }	PROPTYPE;


EXTERN_C const IID IID_IPropertyContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPropertyContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HrGetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrGetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrGetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrSetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrSetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrSetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertyContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertyContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HrGetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HrGetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HrGetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HrSetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HrSetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HrSetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz);
        
        END_INTERFACE
    } IPropertyContainerVtbl;

    interface IPropertyContainer
    {
        CONST_VTBL struct IPropertyContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyContainer_HrGetProp(This,dwPropTag,pb,pcb)	\
    (This)->lpVtbl -> HrGetProp(This,dwPropTag,pb,pcb)

#define IPropertyContainer_HrGetPropDw(This,dwPropTag,pdw)	\
    (This)->lpVtbl -> HrGetPropDw(This,dwPropTag,pdw)

#define IPropertyContainer_HrGetPropSz(This,dwPropTag,psz,cchMax)	\
    (This)->lpVtbl -> HrGetPropSz(This,dwPropTag,psz,cchMax)

#define IPropertyContainer_HrSetProp(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> HrSetProp(This,dwPropTag,pb,cb)

#define IPropertyContainer_HrSetPropDw(This,dwPropTag,dw)	\
    (This)->lpVtbl -> HrSetPropDw(This,dwPropTag,dw)

#define IPropertyContainer_HrSetPropSz(This,dwPropTag,psz)	\
    (This)->lpVtbl -> HrSetPropSz(This,dwPropTag,psz)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyContainer_HrGetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPropertyContainer_HrGetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_HrGetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [out] */ DWORD __RPC_FAR *pdw);


void __RPC_STUB IPropertyContainer_HrGetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_HrGetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [ref][in] */ LPSTR psz,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IPropertyContainer_HrGetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_HrSetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB IPropertyContainer_HrSetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_HrSetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ DWORD dw);


void __RPC_STUB IPropertyContainer_HrSetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_HrSetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ LPSTR psz);


void __RPC_STUB IPropertyContainer_HrSetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyContainer_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\imnact.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Mar 27 05:46:37 1997
 */
/* Compiler settings for imnact.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imnact_h__
#define __imnact_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IImnAdviseAccount_FWD_DEFINED__
#define __IImnAdviseAccount_FWD_DEFINED__
typedef interface IImnAdviseAccount IImnAdviseAccount;
#endif 	/* __IImnAdviseAccount_FWD_DEFINED__ */


#ifndef __IImnAdviseMigrateServer_FWD_DEFINED__
#define __IImnAdviseMigrateServer_FWD_DEFINED__
typedef interface IImnAdviseMigrateServer IImnAdviseMigrateServer;
#endif 	/* __IImnAdviseMigrateServer_FWD_DEFINED__ */


#ifndef __IImnEnumAccounts_FWD_DEFINED__
#define __IImnEnumAccounts_FWD_DEFINED__
typedef interface IImnEnumAccounts IImnEnumAccounts;
#endif 	/* __IImnEnumAccounts_FWD_DEFINED__ */


#ifndef __IImnAccountManager_FWD_DEFINED__
#define __IImnAccountManager_FWD_DEFINED__
typedef interface IImnAccountManager IImnAccountManager;
#endif 	/* __IImnAccountManager_FWD_DEFINED__ */


#ifndef __IPropertyContainer_FWD_DEFINED__
#define __IPropertyContainer_FWD_DEFINED__
typedef interface IPropertyContainer IPropertyContainer;
#endif 	/* __IPropertyContainer_FWD_DEFINED__ */


#ifndef __IImnAccount_FWD_DEFINED__
#define __IImnAccount_FWD_DEFINED__
typedef interface IImnAccount IImnAccount;
#endif 	/* __IImnAccount_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 



//=--------------------------------------------------------------------------=
// Imnact.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Internet Mail and News Account Manager Interfaces.

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {8D4B04E1-1331-11d0-81B8-00C04FD85AB4}
DEFINE_GUID(CLSID_ImnAccountManager, 0x8d4b04e1, 0x1331, 0x11d0, 0x81, 0xb8, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {FD465484-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IPropertyContainer, 0xfd465484, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465481-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnAccountManager, 0xfd465481, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465482-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnAccount, 0xfd465482, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465483-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnEnumAccounts, 0xfd465483, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {8D0AED11-1638-11d0-81B9-00C04FD85AB4}
DEFINE_GUID(IID_IImnAdviseMigrateServer, 0x8d0aed11, 0x1638, 0x11d0, 0x81, 0xb9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {0A06BD31-166F-11d0-81B9-00C04FD85AB4}
DEFINE_GUID(IID_IImnAdviseAccount, 0xa06bd31, 0x166f, 0x11d0, 0x81, 0xb9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// --------------------------------------------------------------------------------
// Exported C Functions
// --------------------------------------------------------------------------------
#if !defined(_IMNACCT_)
#define IMNACCTAPI DECLSPEC_IMPORT HRESULT WINAPI
#else
#define IMNACCTAPI HRESULT WINAPI
#endif
#ifdef __cplusplus
extern "C" {
#endif

IMNACCTAPI HrCreateAccountManager(IImnAccountManager **ppAccountManager);
#ifdef __cplusplus
}
#endif

// --------------------------------------------------------------------------------
// Errors
// --------------------------------------------------------------------------------
#ifndef FACILITY_INTERNET
#define FACILITY_INTERNET 12
#endif
#ifndef HR_E
#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, n)
#endif
#ifndef HR_S
#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_INTERNET, n)
#endif
#ifndef HR_CODE
#define HR_CODE(hr) (INT)(hr & 0xffff)
#endif

// --------------------------------------------------------------------------------
// General Errors
// --------------------------------------------------------------------------------
#define E_RegCreateKeyFailed         HR_E(0xCD00)
#define E_RegQueryInfoKeyFailed      HR_E(0xCD01)
#define E_UserCancel                 HR_E(0xCD02)
#define E_RegOpenKeyFailed           HR_E(0xCD03)
#define E_RegSetValueFailed          HR_E(0xCD04)
#define E_RegDeleteKeyFailed         HR_E(0xCD05)
#define E_DuplicateAccountName       HR_E(0xCD06)
#define S_NonStandardValue           HR_S(0xCD07)
#define E_InvalidValue               HR_E(0xCD08)

// --------------------------------------------------------------------------------
// IPropertyContainer Errors
// --------------------------------------------------------------------------------
#define E_NoPropData                 HR_E(0xCDA0)
#define E_BufferTooSmall             HR_E(0xCDA1)
#define E_BadPropType                HR_E(0xCDA2)
#define E_BufferSizeMismatch         HR_E(0xCDA3)
#define E_InvalidBooleanValue        HR_E(0xCDA4)
#define E_InvalidMinMaxValue         HR_E(0xCDA5)
#define E_PropNotFound               HR_E(0xCDA6)
#define E_InvalidPropTag             HR_E(0xCDA7)
#define E_InvalidPropertySet         HR_E(0xCDA8)
#define E_EnumFinished               HR_E(0xCDA9)
#define S_NoSaveNeeded               HR_S(0xCDAA)
#define S_PasswordDeleted            HR_S(0xCDAB)
#define S_PasswordNotFound           HR_S(0xCDAC)

// --------------------------------------------------------------------------------
// ImnAccountManager errors
// --------------------------------------------------------------------------------
#define E_NoAccounts                 HR_E(0xCDD0)
#define E_BadFriendlyName            HR_E(0xCDD1)

// --------------------------------------------------------------------------------
// RAS Connection Types
// --------------------------------------------------------------------------------
#define CF_MAIL_DISCONNECT       FLAG01 // Disconnect after send and recv
#define CF_AUTO_CONNECT          FLAG02 // Automatically connect

// --------------------------------------------------------------------------------
// Property Macros
// --------------------------------------------------------------------------------
#define PROPTAG_MASK                 ((ULONG)0x0000FFFF)
#define PROPTAG_TYPE(ulPropTag)	    (PROPTYPE)(((ULONG)(ulPropTag)) & PROPTAG_MASK)
#define PROPTAG_ID(ulPropTag)		(((ULONG)(ulPropTag))>>16)
#define PROPTAG(ulPropType,ulPropID)	((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define MAX_PROPID                   ((ULONG) 0xFFFF)

// --------------------------------------------------------------------------------
// IImnAccount Properties
// --------------------------------------------------------------------------------
#define AP_FIRST                    0X1234
// per account properties
#define AP_ACCOUNT_NAME             PROPTAG(TYPE_STRING,    AP_FIRST+1)
#define AP_ACCOUNT_FIRST            AP_ACCOUNT_NAME
#define AP_TEMP_ACCOUNT             PROPTAG(TYPE_DWORD,     AP_FIRST+3)
#define AP_LAST_UPDATED             PROPTAG(TYPE_FILETIME,  AP_FIRST+4)
#define AP_RAS_CONNECTION_TYPE      PROPTAG(TYPE_DWORD,     AP_FIRST+5)
#define AP_RAS_CONNECTOID           PROPTAG(TYPE_STRING,    AP_FIRST+6)
#define AP_RAS_CONNECTION_FLAGS     PROPTAG(TYPE_DWORD,     AP_FIRST+7)
#define AP_RAS_CONNECTED            PROPTAG(TYPE_BOOL,      AP_FIRST+8)
#define AP_ACCOUNT_LAST             AP_RAS_CONNECTED

// IMAP properties
#define AP_IMAP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+100)
#define AP_IMAP_FIRST               AP_IMAP_SERVER
#define AP_IMAP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+101)
#define AP_IMAP_PASSWORD            PROPTAG(TYPE_PASS,     AP_FIRST+102)
#define AP_IMAP_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+104)
#define AP_IMAP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+105)
#define AP_IMAP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+106)
#define AP_IMAP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+107)
#define AP_IMAP_ROOT_FOLDER         PROPTAG(TYPE_STRING,    AP_FIRST+108)
#define AP_IMAP_DATA_DIR            PROPTAG(TYPE_STRING,    AP_FIRST+109)
#define AP_IMAP_SKIP                PROPTAG(TYPE_BOOL,      AP_FIRST+110)
#define AP_IMAP_LAST                AP_IMAP_SKIP

// LDAP properties
#define AP_LDAP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+200)
#define AP_LDAP_FIRST               AP_LDAP_SERVER
#define AP_LDAP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+201)
#define AP_LDAP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+202)
#define AP_LDAP_AUTHENTICATION      PROPTAG(TYPE_DWORD,     AP_FIRST+203)
#define AP_LDAP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+204)
#define AP_LDAP_SEARCH_RETURN       PROPTAG(TYPE_DWORD,     AP_FIRST+205)
#define AP_LDAP_SEARCH_BASE         PROPTAG(TYPE_STRING,    AP_FIRST+206)
#define AP_LDAP_SERVER_ID           PROPTAG(TYPE_DWORD,     AP_FIRST+207)
#define AP_LDAP_RESOLVE_FLAG        PROPTAG(TYPE_DWORD,     AP_FIRST+208)
#define AP_LDAP_URL                 PROPTAG(TYPE_STRING,    AP_FIRST+209)
#define AP_LDAP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+210)
#define AP_LDAP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+211)
#define AP_LDAP_LOGO                PROPTAG(TYPE_STRING,    AP_FIRST+212)
#define AP_LDAP_LAST                AP_LDAP_LOGO

// NNTP properties
#define AP_NNTP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+300)
#define AP_NNTP_FIRST               AP_NNTP_SERVER
#define AP_NNTP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+301)
#define AP_NNTP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+302)
#define AP_NNTP_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+304)
#define AP_NNTP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+305)
#define AP_NNTP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+306)
#define AP_NNTP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+307)
#define AP_NNTP_DISPLAY_NAME        PROPTAG(TYPE_STRING,    AP_FIRST+308)
#define AP_NNTP_ORG_NAME            PROPTAG(TYPE_STRING,    AP_FIRST+309)
#define AP_NNTP_EMAIL_ADDRESS       PROPTAG(TYPE_STRING,    AP_FIRST+310)
#define AP_NNTP_REPLY_EMAIL_ADDRESS PROPTAG(TYPE_STRING,    AP_FIRST+311)
#define AP_NNTP_SPLIT_MESSAGES      PROPTAG(TYPE_BOOL,      AP_FIRST+312)
#define AP_NNTP_SPLIT_SIZE          PROPTAG(TYPE_DWORD,     AP_FIRST+313)
#define AP_NNTP_USE_DESCRIPTIONS    PROPTAG(TYPE_BOOL,      AP_FIRST+314)
#define AP_NNTP_DATA_DIR            PROPTAG(TYPE_STRING,    AP_FIRST+315)
#define AP_NNTP_LAST                AP_NNTP_DATA_DIR

// POP3 properties
#define AP_POP3_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+400)
#define AP_POP3_FIRST               AP_POP3_SERVER
#define AP_POP3_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+401)
#define AP_POP3_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+402)
#define AP_POP3_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+404)
#define AP_POP3_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+405)
#define AP_POP3_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+406)
#define AP_POP3_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+407)
#define AP_POP3_LEAVE_ON_SERVER     PROPTAG(TYPE_BOOL,      AP_FIRST+408)
#define AP_POP3_REMOVE_DELETED      PROPTAG(TYPE_BOOL,      AP_FIRST+409)
#define AP_POP3_REMOVE_EXPIRED      PROPTAG(TYPE_BOOL,      AP_FIRST+410)
#define AP_POP3_EXPIRE_DAYS         PROPTAG(TYPE_DWORD,     AP_FIRST+411)
#define AP_POP3_SKIP                PROPTAG(TYPE_BOOL,      AP_FIRST+412)
#define AP_POP3_LAST                AP_POP3_SKIP

// SMTP properties
#define AP_SMTP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+500)
#define AP_SMTP_FIRST               AP_SMTP_SERVER
#define AP_SMTP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+501)
#define AP_SMTP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+502)
#define AP_SMTP_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+504)
#define AP_SMTP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+505)
#define AP_SMTP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+506)
#define AP_SMTP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+507)
#define AP_SMTP_DISPLAY_NAME        PROPTAG(TYPE_STRING,    AP_FIRST+508)
#define AP_SMTP_ORG_NAME            PROPTAG(TYPE_STRING,    AP_FIRST+509)
#define AP_SMTP_EMAIL_ADDRESS       PROPTAG(TYPE_STRING,    AP_FIRST+510)
#define AP_SMTP_REPLY_EMAIL_ADDRESS PROPTAG(TYPE_STRING,    AP_FIRST+511)
#define AP_SMTP_SPLIT_MESSAGES      PROPTAG(TYPE_BOOL,      AP_FIRST+512)
#define AP_SMTP_SPLIT_SIZE          PROPTAG(TYPE_DWORD,     AP_FIRST+513)
#define AP_SMTP_LAST                AP_SMTP_SPLIT_SIZE

// --------------------------------------------------------------------------------
// Account Flags
// --------------------------------------------------------------------------------
#define ACCT_FLAG_NEWS           ((DWORD)1)
#define ACCT_FLAG_MAIL           ((DWORD)2)
#define ACCT_FLAG_DIR_SERV       ((DWORD)4)
#define ACCT_FLAG_ALL            (ACCT_FLAG_NEWS | ACCT_FLAG_MAIL | ACCT_FLAG_DIR_SERV)

// --------------------------------------------------------------------------------
// Server Types
// --------------------------------------------------------------------------------
#define SRV_NNTP                 ((DWORD)1)
#define SRV_IMAP                 ((DWORD)2)
#define SRV_POP3                 ((DWORD)4)
#define SRV_SMTP                 ((DWORD)8)
#define SRV_LDAP                 ((DWORD)16)
#define SRV_MAIL                 ((DWORD)(SRV_IMAP | SRV_POP3 | SRV_SMTP))
#define SRV_ALL                  ((DWORD)(SRV_NNTP | SRV_IMAP | SRV_POP3 | SRV_SMTP | SRV_LDAP))

// --------------------------------------------------------------------------------
// LDAP Authentication Types
// --------------------------------------------------------------------------------
#define LDAP_AUTH_ANONYMOUS      ((DWORD)0)
#define LDAP_AUTH_PASSWORD       ((DWORD)1)
#define LDAP_AUTH_MEMBER_SYSTEM  ((DWORD)2)
#define LDAP_AUTH_MAX            ((DWORD)2)

// -----------------------------------------------------------------------------
// Account Manager Notification Types
// -----------------------------------------------------------------------------
#define AN_ACCOUNT_DELETED           WM_USER + 1
#define AN_ACCOUNT_ADDED             WM_USER + 2
#define AN_ACCOUNT_CHANGED           WM_USER + 3
#define AN_DEFAULT_CHANGED           WM_USER + 4
#define AN_SERVERTYPES_CHANGED       WM_USER + 5

// IImnAccountManager::AccountListDialog flags
// IImnAccount::ShowProperties flags
#define ACCTDLG_NO_IMAP          0x0001
#define ACCTDLG_NO_REMOVEDELETE  0x0002
#define ACCTDLG_NO_BREAKMESSAGES 0x0004
#define ACCTDLG_NO_REMOVEAFTER   0x0008
#define ACCTDLG_NO_SENDRECEIVE   0x0010
#define ACCTDLG_ALL              0x001f

// AP_RAS_CONNECTION_TYPE values
#define CONNECTION_TYPE_LAN      0
#define CONNECTION_TYPE_MANUAL   1
#define CONNECTION_TYPE_RAS      2

#define	CCHMAX_ORG_NAME	( 256 )

#define	CCHMAX_DISPLAY_NAME	( 256 )

#define	CCHMAX_ACCOUNT_NAME	( 256 )

#define	CCHMAX_SERVER_NAME	( 256 )

#define	CCHMAX_PASSWORD	( 256 )

#define	CCHMAX_USERNAME	( 256 )

#define	CCHMAX_EMAIL_ADDRESS	( 256 )

#define	CCHMAX_CONNECTOID	( 256 )

#define	CCHMAX_SEARCH_BASE	( 256 )



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IImnAdviseAccount_INTERFACE_DEFINED__
#define __IImnAdviseAccount_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAdviseAccount
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [public][public][public][public][public][public][public] */ 
enum __MIDL_IImnAdviseAccount_0001
    {	ACCT_NEWS	= 0,
	ACCT_MAIL	= ACCT_NEWS + 1,
	ACCT_DIR_SERV	= ACCT_MAIL + 1,
	ACCT_LAST	= ACCT_DIR_SERV + 1
    }	ACCTTYPE;


EXTERN_C const IID IID_IImnAdviseAccount;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IImnAdviseAccount : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseAccount( 
            /* [in] */ DWORD dwAdviseType,
            /* [in] */ ACCTTYPE AcctType,
            /* [in] */ LPTSTR pszAccountNameBefore,
            /* [in] */ LPTSTR pszAccountNameAfter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAdviseAccountVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAdviseAccount __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAdviseAccount __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAdviseAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AdviseAccount )( 
            IImnAdviseAccount __RPC_FAR * This,
            /* [in] */ DWORD dwAdviseType,
            /* [in] */ ACCTTYPE AcctType,
            /* [in] */ LPTSTR pszAccountNameBefore,
            /* [in] */ LPTSTR pszAccountNameAfter);
        
        END_INTERFACE
    } IImnAdviseAccountVtbl;

    interface IImnAdviseAccount
    {
        CONST_VTBL struct IImnAdviseAccountVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAdviseAccount_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAdviseAccount_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAdviseAccount_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAdviseAccount_AdviseAccount(This,dwAdviseType,AcctType,pszAccountNameBefore,pszAccountNameAfter)	\
    (This)->lpVtbl -> AdviseAccount(This,dwAdviseType,AcctType,pszAccountNameBefore,pszAccountNameAfter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAdviseAccount_AdviseAccount_Proxy( 
    IImnAdviseAccount __RPC_FAR * This,
    /* [in] */ DWORD dwAdviseType,
    /* [in] */ ACCTTYPE AcctType,
    /* [in] */ LPTSTR pszAccountNameBefore,
    /* [in] */ LPTSTR pszAccountNameAfter);


void __RPC_STUB IImnAdviseAccount_AdviseAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAdviseAccount_INTERFACE_DEFINED__ */


#ifndef __IImnAdviseMigrateServer_INTERFACE_DEFINED__
#define __IImnAdviseMigrateServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAdviseMigrateServer
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnAdviseMigrateServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IImnAdviseMigrateServer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MigrateServer( 
            /* [in] */ DWORD dwSrvType,
            /* [in] */ IImnAccount __RPC_FAR *pAccount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAdviseMigrateServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAdviseMigrateServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAdviseMigrateServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAdviseMigrateServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MigrateServer )( 
            IImnAdviseMigrateServer __RPC_FAR * This,
            /* [in] */ DWORD dwSrvType,
            /* [in] */ IImnAccount __RPC_FAR *pAccount);
        
        END_INTERFACE
    } IImnAdviseMigrateServerVtbl;

    interface IImnAdviseMigrateServer
    {
        CONST_VTBL struct IImnAdviseMigrateServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAdviseMigrateServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAdviseMigrateServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAdviseMigrateServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAdviseMigrateServer_MigrateServer(This,dwSrvType,pAccount)	\
    (This)->lpVtbl -> MigrateServer(This,dwSrvType,pAccount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAdviseMigrateServer_MigrateServer_Proxy( 
    IImnAdviseMigrateServer __RPC_FAR * This,
    /* [in] */ DWORD dwSrvType,
    /* [in] */ IImnAccount __RPC_FAR *pAccount);


void __RPC_STUB IImnAdviseMigrateServer_MigrateServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAdviseMigrateServer_INTERFACE_DEFINED__ */


#ifndef __IImnEnumAccounts_INTERFACE_DEFINED__
#define __IImnEnumAccounts_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnEnumAccounts
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnEnumAccounts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IImnEnumAccounts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SortByAccountName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnEnumAccountsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SortByAccountName )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        END_INTERFACE
    } IImnEnumAccountsVtbl;

    interface IImnEnumAccounts
    {
        CONST_VTBL struct IImnEnumAccountsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnEnumAccounts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnEnumAccounts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnEnumAccounts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnEnumAccounts_GetCount(This,pcItems)	\
    (This)->lpVtbl -> GetCount(This,pcItems)

#define IImnEnumAccounts_SortByAccountName(This)	\
    (This)->lpVtbl -> SortByAccountName(This)

#define IImnEnumAccounts_GetNext(This,ppAccount)	\
    (This)->lpVtbl -> GetNext(This,ppAccount)

#define IImnEnumAccounts_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnEnumAccounts_GetCount_Proxy( 
    IImnEnumAccounts __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IImnEnumAccounts_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_SortByAccountName_Proxy( 
    IImnEnumAccounts __RPC_FAR * This);


void __RPC_STUB IImnEnumAccounts_SortByAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_GetNext_Proxy( 
    IImnEnumAccounts __RPC_FAR * This,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnEnumAccounts_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_Reset_Proxy( 
    IImnEnumAccounts __RPC_FAR * This);


void __RPC_STUB IImnEnumAccounts_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnEnumAccounts_INTERFACE_DEFINED__ */


#ifndef __IImnAccountManager_INTERFACE_DEFINED__
#define __IImnAccountManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAccountManager
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnAccountManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IImnAccountManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
            /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAccountObject( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enumerate( 
            /* [in] */ DWORD dwSrvTypes,
            /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccountCount( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ ULONG __RPC_FAR *pcServers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindAccount( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPTSTR pszSearchData,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAccount( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAccountName( 
            /* [in] */ ACCTTYPE AcctType,
            /* [ref][in] */ LPTSTR pszAccount,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessNotification( 
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateDefaultSendAccount( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AccountListDialog( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwAcctFlags,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAccountManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAccountManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAccountManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
            /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAccountObject )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enumerate )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwSrvTypes,
            /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountCount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ ULONG __RPC_FAR *pcServers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindAccount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPTSTR pszSearchData,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultAccount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultAccountName )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [ref][in] */ LPTSTR pszAccount,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessNotification )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateDefaultSendAccount )( 
            IImnAccountManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AccountListDialog )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwAcctFlags,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IImnAccountManagerVtbl;

    interface IImnAccountManager
    {
        CONST_VTBL struct IImnAccountManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAccountManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAccountManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAccountManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAccountManager_Init(This,pAdviseMigrateServer,pAdviseAccount)	\
    (This)->lpVtbl -> Init(This,pAdviseMigrateServer,pAdviseAccount)

#define IImnAccountManager_CreateAccountObject(This,AcctType,ppAccount)	\
    (This)->lpVtbl -> CreateAccountObject(This,AcctType,ppAccount)

#define IImnAccountManager_Enumerate(This,dwSrvTypes,ppEnumAccounts)	\
    (This)->lpVtbl -> Enumerate(This,dwSrvTypes,ppEnumAccounts)

#define IImnAccountManager_GetAccountCount(This,AcctType,pcServers)	\
    (This)->lpVtbl -> GetAccountCount(This,AcctType,pcServers)

#define IImnAccountManager_FindAccount(This,dwPropTag,pszSearchData,ppAccount)	\
    (This)->lpVtbl -> FindAccount(This,dwPropTag,pszSearchData,ppAccount)

#define IImnAccountManager_GetDefaultAccount(This,AcctType,ppAccount)	\
    (This)->lpVtbl -> GetDefaultAccount(This,AcctType,ppAccount)

#define IImnAccountManager_GetDefaultAccountName(This,AcctType,pszAccount,cchMax)	\
    (This)->lpVtbl -> GetDefaultAccountName(This,AcctType,pszAccount,cchMax)

#define IImnAccountManager_ProcessNotification(This,uMsg,wParam,lParam)	\
    (This)->lpVtbl -> ProcessNotification(This,uMsg,wParam,lParam)

#define IImnAccountManager_ValidateDefaultSendAccount(This)	\
    (This)->lpVtbl -> ValidateDefaultSendAccount(This)

#define IImnAccountManager_AccountListDialog(This,hwnd,dwAcctFlags,dwFlags)	\
    (This)->lpVtbl -> AccountListDialog(This,hwnd,dwAcctFlags,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAccountManager_Init_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
    /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount);


void __RPC_STUB IImnAccountManager_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_CreateAccountObject_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_CreateAccountObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_Enumerate_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwSrvTypes,
    /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts);


void __RPC_STUB IImnAccountManager_Enumerate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetAccountCount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ ULONG __RPC_FAR *pcServers);


void __RPC_STUB IImnAccountManager_GetAccountCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_FindAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ LPTSTR pszSearchData,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_FindAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetDefaultAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_GetDefaultAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetDefaultAccountName_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [ref][in] */ LPTSTR pszAccount,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IImnAccountManager_GetDefaultAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_ProcessNotification_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IImnAccountManager_ProcessNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_ValidateDefaultSendAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This);


void __RPC_STUB IImnAccountManager_ValidateDefaultSendAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_AccountListDialog_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwAcctFlags,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccountManager_AccountListDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAccountManager_INTERFACE_DEFINED__ */


#ifndef __IPropertyContainer_INTERFACE_DEFINED__
#define __IPropertyContainer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertyContainer
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [public] */ 
enum __MIDL_IPropertyContainer_0001
    {	TYPE_ERROR	= 1000,
	TYPE_DWORD	= TYPE_ERROR + 1,
	TYPE_LONG	= TYPE_DWORD + 1,
	TYPE_WORD	= TYPE_LONG + 1,
	TYPE_SHORT	= TYPE_WORD + 1,
	TYPE_BYTE	= TYPE_SHORT + 1,
	TYPE_CHAR	= TYPE_BYTE + 1,
	TYPE_FILETIME	= TYPE_CHAR + 1,
	TYPE_STRING	= TYPE_FILETIME + 1,
	TYPE_BINARY	= TYPE_STRING + 1,
	TYPE_FLAGS	= TYPE_BINARY + 1,
	TYPE_STREAM	= TYPE_FLAGS + 1,
	TYPE_WSTRING	= TYPE_STREAM + 1,
	TYPE_BOOL	= TYPE_WSTRING + 1,
	TYPE_PASS	= TYPE_BOOL + 1,
	TYPE_LAST	= TYPE_PASS + 1
    }	PROPTYPE;


EXTERN_C const IID IID_IPropertyContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPropertyContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertyContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertyContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz);
        
        END_INTERFACE
    } IPropertyContainerVtbl;

    interface IPropertyContainer
    {
        CONST_VTBL struct IPropertyContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyContainer_GetProp(This,dwPropTag,pb,pcb)	\
    (This)->lpVtbl -> GetProp(This,dwPropTag,pb,pcb)

#define IPropertyContainer_GetPropDw(This,dwPropTag,pdw)	\
    (This)->lpVtbl -> GetPropDw(This,dwPropTag,pdw)

#define IPropertyContainer_GetPropSz(This,dwPropTag,psz,cchMax)	\
    (This)->lpVtbl -> GetPropSz(This,dwPropTag,psz,cchMax)

#define IPropertyContainer_SetProp(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> SetProp(This,dwPropTag,pb,cb)

#define IPropertyContainer_SetPropDw(This,dwPropTag,dw)	\
    (This)->lpVtbl -> SetPropDw(This,dwPropTag,dw)

#define IPropertyContainer_SetPropSz(This,dwPropTag,psz)	\
    (This)->lpVtbl -> SetPropSz(This,dwPropTag,psz)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyContainer_GetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPropertyContainer_GetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_GetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [out] */ DWORD __RPC_FAR *pdw);


void __RPC_STUB IPropertyContainer_GetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_GetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [ref][in] */ LPSTR psz,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IPropertyContainer_GetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB IPropertyContainer_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ DWORD dw);


void __RPC_STUB IPropertyContainer_SetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ LPSTR psz);


void __RPC_STUB IPropertyContainer_SetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyContainer_INTERFACE_DEFINED__ */


#ifndef __IImnAccount_INTERFACE_DEFINED__
#define __IImnAccount_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAccount
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnAccount;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IImnAccount : public IPropertyContainer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Exist( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAsDefault( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccountType( 
            /* [out] */ ACCTTYPE __RPC_FAR *pAcctType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerTypes( 
            /* [out] */ DWORD __RPC_FAR *pdwSrvTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowProperties( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateProperty( 
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAccountVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAccount __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropDw )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropSz )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropDw )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropSz )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Exist )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAsDefault )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveChanges )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountType )( 
            IImnAccount __RPC_FAR * This,
            /* [out] */ ACCTTYPE __RPC_FAR *pAcctType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerTypes )( 
            IImnAccount __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSrvTypes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowProperties )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateProperty )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        END_INTERFACE
    } IImnAccountVtbl;

    interface IImnAccount
    {
        CONST_VTBL struct IImnAccountVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAccount_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAccount_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAccount_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAccount_GetProp(This,dwPropTag,pb,pcb)	\
    (This)->lpVtbl -> GetProp(This,dwPropTag,pb,pcb)

#define IImnAccount_GetPropDw(This,dwPropTag,pdw)	\
    (This)->lpVtbl -> GetPropDw(This,dwPropTag,pdw)

#define IImnAccount_GetPropSz(This,dwPropTag,psz,cchMax)	\
    (This)->lpVtbl -> GetPropSz(This,dwPropTag,psz,cchMax)

#define IImnAccount_SetProp(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> SetProp(This,dwPropTag,pb,cb)

#define IImnAccount_SetPropDw(This,dwPropTag,dw)	\
    (This)->lpVtbl -> SetPropDw(This,dwPropTag,dw)

#define IImnAccount_SetPropSz(This,dwPropTag,psz)	\
    (This)->lpVtbl -> SetPropSz(This,dwPropTag,psz)


#define IImnAccount_Exist(This)	\
    (This)->lpVtbl -> Exist(This)

#define IImnAccount_SetAsDefault(This)	\
    (This)->lpVtbl -> SetAsDefault(This)

#define IImnAccount_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IImnAccount_SaveChanges(This)	\
    (This)->lpVtbl -> SaveChanges(This)

#define IImnAccount_GetAccountType(This,pAcctType)	\
    (This)->lpVtbl -> GetAccountType(This,pAcctType)

#define IImnAccount_GetServerTypes(This,pdwSrvTypes)	\
    (This)->lpVtbl -> GetServerTypes(This,pdwSrvTypes)

#define IImnAccount_ShowProperties(This,hwnd,dwFlags)	\
    (This)->lpVtbl -> ShowProperties(This,hwnd,dwFlags)

#define IImnAccount_ValidateProperty(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> ValidateProperty(This,dwPropTag,pb,cb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAccount_Exist_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_Exist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_SetAsDefault_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_SetAsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_Delete_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_SaveChanges_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_SaveChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_GetAccountType_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [out] */ ACCTTYPE __RPC_FAR *pAcctType);


void __RPC_STUB IImnAccount_GetAccountType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_GetServerTypes_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSrvTypes);


void __RPC_STUB IImnAccount_GetServerTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_ShowProperties_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccount_ShowProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_ValidateProperty_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB IImnAccount_ValidateProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAccount_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\interwiz.h ===
// Internet Setup Wizard Help ID; JeremyS

#define INTERNET_SETUP_MAIN       1000
#define INTERNET_SETUP_LAN        1001
#define INTERNET_SETUP_MSN        1002
#define INTERNET_SETUP_OTHERISP   1003
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\init.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  INIT.C - WinMain and initialization code for Internet setup/signup wizard
//

//  HISTORY:
//  
//  11/20/94  jeremys  Created.
//  96/03/07  markdu  Added gpEnumModem
//  96/03/09  markdu  Added gpRasEntry
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//  96/04/24  markdu  NASH BUG 19289 Added /NOMSN command line flag
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//

#include "wizard.h"
#include "icwextsn.h"
#include "imnext.h"

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

//
// The LaunchSignupWizard APIs have a PBOOL argument also which gets
// info to the calling APP whether they need to reboot
// MKarki (5/4/97) - Fix for Bug #3111
//
  VOID WINAPI LaunchSignupWizard(LPTSTR lpCmdLine,int nCmdShow, PBOOL pReboot);
  DWORD WINAPI LaunchSignupWizardEx(LPTSTR lpCmdLine,int nReserved, PBOOL pReboot);

#ifdef __cplusplus
}
#endif // __cplusplus

BOOL ParseCommandLine(LPTSTR lpszCommandLine,DWORD * pdwFlags);
TCHAR * GetTextToNextSpace(LPTSTR pszText,TCHAR * pszOutBuf,UINT cbOutBuf);

#pragma data_seg(".data")

WIZARDSTATE *     gpWizardState=NULL;   // pointer to global wizard state struct
USERINFO *        gpUserInfo=NULL;        // pointer to global user info struct
ENUM_MODEM *      gpEnumModem=NULL;  // pointer modem enumeration object
LPRASENTRY        gpRasEntry = NULL;  // pointer to RASENTRY struct to hold all data
DWORD             gdwRasEntrySize = 0;
BOOL              gfFirstNewConnection = TRUE;

//
// set the reboot flag to FALSE
// MKarki - 5/2/97 - Fix for Bug#3111
//
BOOL g_bReboot = FALSE;
BOOL g_bRebootAtExit = FALSE;
#pragma data_seg()

/*******************************************************************

  NAME:    LaunchSignupWizard

  SYNOPSIS:  Entry point for Internet Setup Wizard UI

********************************************************************/
extern "C" VOID WINAPI 
LaunchSignupWizard (
            LPTSTR lpCmdLine,
            int nCmdShow,
            PBOOL pReboot
            )
{
  BOOL fOK=TRUE;

  // allocate global structures
  gpWizardState = new WIZARDSTATE;
  gpUserInfo = new USERINFO;
  gdwRasEntrySize = sizeof(RASENTRY);
  gpRasEntry = (LPRASENTRY) GlobalAlloc(GPTR,gdwRasEntrySize);

  if (!gpWizardState ||
    !gpUserInfo ||
    !gpRasEntry)
  {
    // display an out of memory error
    MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
    fOK = FALSE;
    // fall through and clean up any successful allocs below
  }

  if (fOK) {
    DWORD dwFlags = 0;

    ParseCommandLine(lpCmdLine,&dwFlags);

    if (dwFlags & RSW_UNINSTALL) {
      // do uninstall if we got /uninstall on command line
      DoUninstall();  

    } else {

      RunSignupWizard(dwFlags);

    }
  }

  // free global structures
  if (gpWizardState) 
    delete gpWizardState;

  if (gpUserInfo)
    delete gpUserInfo;

  if (gpEnumModem)
    delete gpEnumModem;

  if (gpRasEntry)
    GlobalFree(gpRasEntry);

  //
  // pass back the info, that the app needs to reboot or not
  // MKarki - 5/2/97 - Fix for Bug#3111
  //
  *pReboot = g_bReboot;
  
    
} //end of LaunchSignupWizard API call

/*******************************************************************

  NAME:    LaunchSignupWizardEx

  SYNOPSIS:  Entry point for Internet Setup Wizard UI with back
			 capabilities.  It will retain previous information
			 if called multiple times.  The caller *MUST* call
			 FreeSignupWizard when done.

  PARAMETERS:
			lpCmdLine - Command line with instructions
			nReserved - Reserved for future use

  RETURNS:	ERROR_SUCCESS	Everything's okay, wizard finished
			ERROR_CONTINUE	User pressed back on first page
			ERROR_CANCELLED	User cancelled out of wizard
			<other>			Deadly error (message already displayed)
********************************************************************/
extern "C" DWORD WINAPI 
LaunchSignupWizardEx (
        LPTSTR   lpCmdLine,
        int     nReserved,
        PBOOL   pReboot
        )
{
	DWORD dwRet = ERROR_SUCCESS;
	BOOL fFirstTime = FALSE;

	// allocate global structures if needed
	if (!gpWizardState)
	{
		gpWizardState = new WIZARDSTATE;
		fFirstTime = TRUE;
	}
	else
	{
		gpWizardState->uCurrentPage = ORD_PAGE_HOWTOCONNECT;
		gpWizardState->uPagesCompleted = 0;
	}

	if (!gpUserInfo)
	{
		gpUserInfo = new USERINFO;
		fFirstTime = TRUE;
	}
	if (!gpRasEntry)
	{
		gdwRasEntrySize = sizeof(RASENTRY);
		gpRasEntry = (LPRASENTRY) GlobalAlloc(GPTR,gdwRasEntrySize);
		fFirstTime = TRUE;
	}

	if (!gpWizardState || !gpUserInfo || !gpRasEntry)
	{
		MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
		dwRet = ERROR_NOT_ENOUGH_MEMORY;
	}

	if (ERROR_SUCCESS == dwRet)
	{
	    DWORD dwFlags = 0;

		ParseCommandLine(lpCmdLine,&dwFlags);


		if (dwFlags & RSW_UNINSTALL)
		{
			// do uninstall if we got /uninstall on command line
			DoUninstall();  

		}
		else
		{
			gfUserFinished = FALSE;
			gfUserBackedOut = FALSE;
			gfUserCancelled = FALSE;
			gfQuitWizard = FALSE;

			// On the first call, don't free the globals, we
			// may be called again.  On subsequent calls, don't
			// initialize the globals either.
			dwFlags |= RSW_NOFREE;
			if (!fFirstTime)
				dwFlags |= RSW_NOINIT;

			RunSignupWizard(dwFlags);

			if (gfUserFinished)
				dwRet = ERROR_SUCCESS;
			else if (gfUserBackedOut)
				dwRet = ERROR_CONTINUE;
			else if (gfUserCancelled)
				dwRet = ERROR_CANCELLED;
			else
				dwRet = ERROR_GEN_FAILURE;
		}
	}

  //
  // pass back the info, that the app needs to reboot or not
  // MKarki (5/2/97) Fix for Bug #3111
  //
  *pReboot = g_bReboot;

	return dwRet;
} // end of LaunchSignupWizardEx API 

/****************************************************************************

  NAME:     FreeSignupWizard

  SYNOPSIS: Frees the global structures explicitely.  This must be called
			if LaunchSignupWizardEx is used.

****************************************************************************/
extern "C" VOID WINAPI FreeSignupWizard(VOID)
{
	if (gpWizardState)
	{
		delete gpWizardState;
		gpWizardState = NULL;
	}
	if (gpUserInfo)
	{
		delete gpUserInfo;
		gpUserInfo = NULL;
	}
	if (gpRasEntry)
	{
		GlobalFree(gpRasEntry);
		gpRasEntry = NULL;
		gdwRasEntrySize = 0;
	}
	if (gpEnumModem)
	{
		delete gpEnumModem;
		gpEnumModem = NULL;
	}
	if (gpImnApprentice)
	{
		gpImnApprentice->Release();
		gpImnApprentice = NULL;
	}
	if (gfOleInitialized)
		CoUninitialize();

}


/****************************************************************************

  NAME:     ParseCommandLine

  SYNOPSIS:  Parses command line 

****************************************************************************/
BOOL ParseCommandLine(LPTSTR lpszCommandLine,DWORD * pdwFlags)
{
  if (!lpszCommandLine || !*lpszCommandLine)
    return TRUE;  // nothing to do

  ASSERT(pdwFlags);
  *pdwFlags = 0;

  while (*lpszCommandLine) {
    TCHAR szCommand[SMALL_BUF_LEN+1];

    lpszCommandLine = GetTextToNextSpace(lpszCommandLine,
      szCommand,sizeof(szCommand));

    if (!lstrcmpi(szCommand,szNOREBOOT)) {
      DEBUGMSG("Got /NOREBOOT command line switch");
      *pdwFlags |= RSW_NOREBOOT;      
    }

    if (!lstrcmpi(szCommand,szUNINSTALL)) {
      DEBUGMSG("Got /UNINSTALL command line switch");
      *pdwFlags |= RSW_UNINSTALL;      
    }

    if (!lstrcmpi(szCommand,szNOMSN)) {
      DEBUGMSG("Got /NOMSN command line switch");
      *pdwFlags |= RSW_NOMSN;      
    }
    
    if (!lstrcmpi(szCommand,szNOIMN)) {
      DEBUGMSG("Got /NOIMN command line switch");
      *pdwFlags |= RSW_NOIMN;      
    }
    
  }

  return TRUE;
}

/****************************************************************************

  NAME:     GetTextToNextSpace

  SYNOPSIS:  Gets text up to next space or end of string, places in
        output buffer

****************************************************************************/
TCHAR * GetTextToNextSpace(LPTSTR pszText,TCHAR * pszOutBuf,UINT cbOutBuf)
{
  ASSERT(pszText);
  ASSERT(pszOutBuf);

  lstrcpy(pszOutBuf,szNull);
  
  if (!pszText)
    return NULL;

  // advance past spaces
  while (*pszText == ' ')
    pszText ++;

  while (*pszText && (*pszText != ' ') && cbOutBuf>1) {
    *pszOutBuf = *pszText;    
    pszOutBuf ++;
    cbOutBuf --;
    pszText ++;
   }

  if (cbOutBuf)
    *pszOutBuf = '\0';  // null-terminate

  while (*pszText == ' ')
    pszText++;      // advance past spaces

  return pszText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\introui.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  INTROUI.C - Functions for introductory Wizard pages
//

//  HISTORY:
//  
//  12/22/94  jeremys  Created.
//  96/03/07  markdu  Use global modem enum object (gpEnumModem) for
//            all modem stuff (only need to enum once unless we add a modem)
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/11  markdu  Check new CLIENTCONFIG flags before installing
//            RNA and TCP.
//  96/03/16  markdu  Use ReInit member function to re-enumerate modems.
//  96/03/22  markdu  Work around problem with fInstallMail to allow the
//            user to decide whether to install mail.
//  96/03/22  markdu  Always display both modem and LAN options, regardless
//            of what hardware is present.
//  96/03/22  markdu  Remove IP setup from LAN path.
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/24  markdu  Return error values from EnumerateModems().
//  96/03/25  markdu  If a fatal error occurs, set gfQuitWizard.
//  96/04/04  markdu  Added pfNeedsRestart to WarnIfServerBound
//  96/04/06  markdu  Moved CommitConfigurationChanges call to last page.
//  96/05/06  markdu  NASH BUG 15637 Removed unused code.
//  96/05/06  markdu  NASH BUG 21165 Reordered page logic.
//  96/05/14  markdu  NASH BUG 21704 Do not install TCP/IP on LAN path.
//  96/05/20  markdu  MSN  BUG 8551 Check for reboot when installing
//            PPPMAC and TCP/IP.
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.
//  96/09/13  valdonb Remove welcome dialog
//

#include "wizard.h"
#include "interwiz.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"

UINT GetModemPage(HWND hDlg);
VOID EnableWizard(HWND hDlg,BOOL fEnable);
HRESULT EnumerateModems(HWND hwndParent, ENUM_MODEM** ppEnumModem);
BOOL IsMoreThanOneModemInstalled(ENUM_MODEM* pEnumModem);
BOOL IsModemInstalled(ENUM_MODEM* pEnumModem);
extern ICFGINSTALLSYSCOMPONENTS     lpIcfgInstallInetComponents;
extern ICFGNEEDSYSCOMPONENTS        lpIcfgNeedInetComponents;
extern ICFGGETLASTINSTALLERRORTEXT  lpIcfgGetLastInstallErrorText;
BOOL FGetSystemShutdownPrivledge();
BOOL g_bSkipMultiModem = FALSE;
int  nCurrentModemSel = 0;

// from commctrl defines...
#define IDD_BACK    0x3023
#define IDD_NEXT    0x3024


//*******************************************************************
//
//    Function    GetDeviceSelectedByUser
//
//    Synopsis    Get the name of the RAS device that the user had
//                already picked
//
//    Arguements  szKey - name of sub key
//                szBuf - pointer to buffer
//                dwSize - size of buffer
//
//    Return      TRUE - success
//
//    History     10/21/96    VYung    Created
//*******************************************************************
BOOL GetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf, DWORD dwSize)
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    DWORD dwType = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,ISIGNUP_KEY,&hkey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,szKey,0,&dwType,
            (LPBYTE)szBuf,&dwSize))
            bRC = TRUE;
    }

    if (hkey)
        RegCloseKey(hkey);
    return bRC;
}

/*******************************************************************

  NAME:    HowToConnectInitProc

  SYNOPSIS:  Called when "How to Connect" page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK HowToConnectInitProc(HWND hDlg,BOOL fFirstInit)
{
  // If we were started by inetwiz.exe, there is nothing to
  // go back to, so only show the "next" button
  // (actually, this will only disable the back button, not hide it.)
  if (!(gpWizardState->dwRunFlags & (RSW_NOFREE | RSW_APPRENTICE) ))
    PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);

  if (fFirstInit)
  {
    // initialize radio buttons
    CheckDlgButton(hDlg,IDC_CONNECT_BY_PHONE,
                    CONNECT_RAS == gpUserInfo->uiConnectionType);
    CheckDlgButton(hDlg,IDC_CONNECT_BY_LAN,
                    CONNECT_LAN == gpUserInfo->uiConnectionType);
    CheckDlgButton(hDlg,IDC_CONNECT_MANUAL,
                    CONNECT_MANUAL == gpUserInfo->uiConnectionType);

    // Normandy 11970 ChrisK - we need a different title if launched from
    // mail or news configuration
    if ( (gpWizardState->dwRunFlags & RSW_APPRENTICE))
    {
        if (!g_fIsExternalWizard97)
        {
            TCHAR szTitle[MAX_RES_LEN+1];
            if (LoadSz(IDS_BEGINMANUAL_ALTERNATE,szTitle,sizeof(szTitle)))
                SetWindowText (GetDlgItem(hDlg,IDC_LBLTITLE), szTitle);
        }                
    }
    else
    {
        // if we're not here via the apprentice interface, hide the
        // manual connect option
        ASSERT( CONNECT_MANUAL != gpUserInfo->uiConnectionType );
        ShowWindow( GetDlgItem(hDlg,IDC_CONNECT_MANUAL), SW_HIDE);
    }

    // load in strings for the description paragraph
    TCHAR szWhole[ (2 * MAX_RES_LEN) + 1] = TEXT("\0");
    TCHAR szTemp[ MAX_RES_LEN + 1] = TEXT("nothing\0");
    LoadSz(IDS_HOWTOCONNECT_DESC1,szTemp,sizeof(szTemp));
    lstrcat( szWhole, szTemp ); 
    LoadSz(IDS_HOWTOCONNECT_DESC2,szTemp,sizeof(szTemp));
    lstrcat( szWhole, szTemp ); 

    SetWindowText (GetDlgItem(hDlg,IDC_DESC), szWhole);


  }

  // if we've travelled through external apprentice pages,
  // it's easy for our current page pointer to get munged,
  // so reset it here for sanity's sake.
  gpWizardState->uCurrentPage = ORD_PAGE_HOWTOCONNECT;


  return TRUE;
}

/*******************************************************************

  NAME:    HowToConnectOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from "How to
        Connect" page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK HowToConnectOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
  ASSERT(puNextPage);

  // read radio button state
  if( IsDlgButtonChecked(hDlg, IDC_CONNECT_BY_LAN) )
  {
      gpUserInfo->uiConnectionType = CONNECT_LAN;
  }
  else if( IsDlgButtonChecked(hDlg, IDC_CONNECT_BY_PHONE) )
  {
      gpUserInfo->uiConnectionType = CONNECT_RAS;
  }
  else if( IsDlgButtonChecked(hDlg, IDC_CONNECT_MANUAL) )
  {
      ASSERT( gpWizardState->dwRunFlags & RSW_APPRENTICE );
      gpUserInfo->uiConnectionType = CONNECT_MANUAL;
  }

  if (!fForward)
  {
    if ( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
    {
      // Hack to make back work...
      gpWizardState->uPagesCompleted = 1;
      gfUserBackedOut = TRUE;
      gfQuitWizard = TRUE;
    }

  }
  else
  {
    if ( (gpWizardState->dwRunFlags & RSW_APPRENTICE) && !g_fIsICW)
    {
        if ( !(CONNECT_RAS == gpUserInfo->uiConnectionType) )
        {
            // 12/20/96 jmazner Normandy #12945
            // don't go through proxy options.

            // we're about to jump back to the external wizard, and we don't want
            // this page to show up in our history list
            *pfKeepHistory = FALSE;

            *puNextPage = g_uExternUINext;

            //Notify the main Wizard that this was the last page
            ASSERT( g_pExternalIICWExtension )
            if (g_fIsExternalWizard97)
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_HOWTOCONNECT97);
            else
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_HOWTOCONNECT);
            
            g_fConnectionInfoValid = TRUE;


        }
        else
        {
            //
            // 12/20/96 jmazner Normandy #12948
            // Install a modem if neccesary
            //
            // 5/15/97 jmazner Olympus
            //DWORD dwfInstallOptions = INETCFG_INSTALLMODEM;
            DWORD dwfInstallOptions = (INETCFG_INSTALLRNA | INETCFG_INSTALLMODEM | INETCFG_INSTALLTCP);
            EnableWindow(GetParent(hDlg), FALSE);

            //
            // save state of fNeedReboot, becasuse
            // we might be calling InetCofigureSystem() 
            // again, and the ReBoot flag might get reset
            //  MKarki - Fix for Bug #404
            //
            BOOL bSaveState = gpWizardState->fNeedReboot;
            
            HRESULT hr = InetConfigSystem(GetParent(hDlg),dwfInstallOptions,&gpWizardState->fNeedReboot);

            //
            // we should choose to reboot -MKarki Bug #404
            //
            gpWizardState->fNeedReboot = 
                    bSaveState || gpWizardState->fNeedReboot;

            EnableWindow(GetParent(hDlg), TRUE);
            SetForegroundWindow(GetParent(hDlg));

            if (hr == ERROR_CANCELLED) 
            {
                // Stay on this page if the user cancelled
                gpWizardState->fNeedReboot = FALSE;
                return FALSE;
            }
            else if (hr != ERROR_SUCCESS)
            {
                MsgBox(GetParent(hDlg),IDS_CONFIGAPIFAILED,MB_ICONEXCLAMATION,MB_OK);
                gpWizardState->fNeedReboot = FALSE;
                gfQuitWizard = TRUE;
                return FALSE;
            } 
            else if (gpWizardState->fNeedReboot)
            {
                //
                // 5/27/97 jmazner Olympus #1134 and IE #32717
                // As per email from GeorgeH and GeoffR, force user to either
                // cancel or quit at this point.
                //
                if (IDYES == MsgBox(GetParent(hDlg),IDS_WANTTOREBOOT,MB_ICONQUESTION, MB_YESNO | MB_DEFBUTTON2))
                {
                    gpWizardState->fNeedReboot = TRUE;
                }
                else
                {
                    gpWizardState->fNeedReboot = FALSE;
                }
                gfQuitWizard = TRUE;
                return TRUE;
            }

            //
            // 7/16/97 jmazner Olympus #9571
            // if the configSystem call installed a modem for the first time on
            // the user's machine, then the TAPI information we initially read
            // in was bogus because the user had never filled it in.
            // Therefore re initialize the fields to make sure we have accurate info
            //
            InitRasEntry( gpRasEntry );

            
            *puNextPage = GetModemPage(hDlg);
        }
    }
    else
    {
        //Normandy# 4575 install TCP/IP on LAN path
        //Normandy# 8620 Do not install TCP/IP on LAN path
        DWORD dwfInstallOptions = 0;

        if (CONNECT_RAS == gpUserInfo->uiConnectionType)
            dwfInstallOptions |= (INETCFG_INSTALLRNA | INETCFG_INSTALLMODEM | INETCFG_INSTALLTCP);
        else if (CONNECT_LAN == gpUserInfo->uiConnectionType)
            dwfInstallOptions |= INETCFG_INSTALLTCP;
        
        //
        // Install and configure TCP/IP and RNA
        //

        //
        // save state of fNeedReboot, becasuse
        // we might be calling InetCofigureSystem() 
        // again, and the ReBoot flag might get reset
        //  MKarki - Fix for Bug #404
        //
        BOOL bSaveState = gpWizardState->fNeedReboot;

        HRESULT hr = InetConfigSystem(GetParent(hDlg),dwfInstallOptions,&gpWizardState->fNeedReboot);

        //
        // we should choose to reboot -MKarki Bug #404
        //
        gpWizardState->fNeedReboot = 
                bSaveState || gpWizardState->fNeedReboot;

        SetForegroundWindow(GetParent(hDlg));

        if (hr == ERROR_CANCELLED) {
            // Stay on this page if the user cancelled
            gpWizardState->fNeedReboot = FALSE;
            if (g_fIsICW)
            {
                g_pExternalIICWExtension->ExternalCancel( CANCEL_PROMPT );
            }
            return FALSE;
        } else if (hr != ERROR_SUCCESS) {
            MsgBox(GetParent(hDlg),IDS_CONFIGAPIFAILED,MB_ICONEXCLAMATION,MB_OK);
            gpWizardState->fNeedReboot = FALSE;
            //gfQuitWizard = TRUE;
            // 2/27/97  jmazner Olympus #299
            // don't quit, give the user a chance to choose LAN
            gpUserInfo->uiConnectionType = CONNECT_LAN;
            CheckDlgButton(hDlg,IDC_CONNECT_BY_PHONE,FALSE);
            CheckDlgButton(hDlg,IDC_CONNECT_BY_LAN,TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_CONNECT_BY_PHONE),FALSE);


            return FALSE;
        } else if (ERROR_SUCCESS == hr && gpWizardState->fNeedReboot && IsNT()) {

            //
            // we will let the EXE that called us POP up the dialog
            // box, asking users to reboot or not
            // MKarki (2/5/97) - Fix for Bug #3111
            //
            g_bReboot = TRUE;
            gfQuitWizard = TRUE;
            if (!g_fIsICW)
            {
                PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                SetPropSheetResult(hDlg,-1);
            }
            return (FALSE);
        }

        g_bRebootAtExit = gpWizardState->fNeedReboot;

        //
        // 7/16/97 jmazner Olympus #9571
        // if the configSystem call installed a modem for the first time on
        // the user's machine, then the TAPI information we initially read
        // in was bogus because the user had never filled it in.
        // Therefore re initialize the fields to make sure we have accurate info
        //
        InitRasEntry( gpRasEntry );



        if (dwfInstallOptions & INETCFG_INSTALLRNA)
        {
            if (ERROR_SUCCESS != InetStartServices())
            {


                // 
                // condition when
                // 1) user deliberately removes some file
                // 2) Did not reboot after installing RAS
                // MKarki - (5/7/97) - Fix for Bug #4004 
                //
                MsgBox(
                    GetParent(hDlg),
                    IDS_SERVICEDISABLED,
                    MB_ICONEXCLAMATION,MB_OK
                    );
                
                /*********
                //
                // Bug #12544 - VetriV
                // Check if user wants to exit ICW
                //
                if( (MsgBox(GetParent(hDlg), IDS_QUERYCANCEL, 
                                MB_APPLMODAL | MB_ICONQUESTION 
                                | MB_SETFOREGROUND | MB_DEFBUTTON2, 
                                MB_YESNO) == IDNO))
                {
                    goto StartService;
                }
                else
                {
                    gpWizardState->fNeedReboot = FALSE;
                    gfQuitWizard = TRUE;
                ****/

                // 2/27/97  jmazner Olympus #299
                // don't quit, give the user a chance to choose LAN
                gpUserInfo->uiConnectionType = CONNECT_LAN;
                CheckDlgButton(hDlg,IDC_CONNECT_BY_PHONE,FALSE);
                CheckDlgButton(hDlg,IDC_CONNECT_BY_LAN,TRUE);
                EnableWindow(GetDlgItem(hDlg,IDC_CONNECT_BY_PHONE),FALSE);
                return FALSE;
            }
        }

        // jmazner 11/11/96 Normandy #11320
        // Note: we are explicitly deferring the reboot until after the wizard
        //       has completed.
        //if( gpWizardState->fNeedReboot )
        //{
        //  gfQuitWizard = TRUE;
        //  return TRUE;
        //}

        if (CONNECT_LAN == gpUserInfo->uiConnectionType)
        {
            // Skip the use proxy page
            *puNextPage = ORD_PAGE_SETUP_PROXY; 
        }
        else
        {
            // get the next page based on number of modems.
            *puNextPage = GetModemPage(hDlg);
        }
    }
  }

  return TRUE;
}


/*******************************************************************

  NAME:    ChooseModemInitProc

  SYNOPSIS:  Called when "Choose Modem" page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ChooseModemInitProc(HWND hDlg,BOOL fFirstInit)
{
    ProcessDBCS(hDlg, IDC_MODEM);

    gpWizardState->uCurrentPage = ORD_PAGE_CHOOSEMODEM;

    // fill the combobox with available modems
    DWORD dwRet = InitModemList(GetDlgItem(hDlg,IDC_MODEM));
    if (ERROR_SUCCESS != dwRet)
    {
        DisplayErrorMessage(hDlg,IDS_ERREnumModem,dwRet,
          ERRCLS_STANDARD,MB_ICONEXCLAMATION);

        // set flag to indicate that wizard should exit now
        gfQuitWizard = TRUE;

        return FALSE;
    }
    if (-1 == ComboBox_SetCurSel(GetDlgItem(hDlg,IDC_MODEM), nCurrentModemSel))
        ComboBox_SetCurSel(GetDlgItem(hDlg,IDC_MODEM), 0);

    return TRUE;
}

/*******************************************************************

  NAME:    ChooseModemCmdProc

  SYNOPSIS:  Called when modem selected on page

  ENTRY:    hDlg - dialog window
        
********************************************************************/
BOOL CALLBACK ChooseModemCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam)
{   
  return TRUE;
}

/*******************************************************************

  NAME:    ChooseModemOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from "Choose Modem"
        page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ChooseModemOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
    if (fForward) 
    {
        // get modem name out of combo box
        ComboBox_GetText(GetDlgItem(hDlg,IDC_MODEM),
          gpRasEntry->szDeviceName,ARRAYSIZE(gpRasEntry->szDeviceName));
        NULL_TERM_TCHARS(gpRasEntry->szDeviceName);
        ASSERT(lstrlen(gpRasEntry->szDeviceName));

        // set next page to go to

        // jmazner 11/11/96 Normandy #8293
        //*puNextPage = ORD_PAGE_CONNECTION;


        // 10/05/98 Vincent Yung
        // Connectoid page is removed.
        /*
        ENUM_CONNECTOID EnumConnectoid;    // class object for enum
        // 3/21/97 jmazner Olympus #1948
        if( EnumConnectoid.NumEntries() )
        {
            *puNextPage = ORD_PAGE_CONNECTION;
        }
        else
        {
            // 5/8/97 jmazner Olympus #4108
            // move connectionName to the end
            //*puNextPage = ORD_PAGE_CONNECTIONNAME;
            *puNextPage = ORD_PAGE_PHONENUMBER;
        }*/


        *puNextPage = ORD_PAGE_PHONENUMBER;
    }

    // Store modem selection 
    nCurrentModemSel = ComboBox_GetCurSel(GetDlgItem(hDlg,IDC_MODEM));
    // clear the modem list
    ComboBox_ResetContent(GetDlgItem(hDlg,IDC_MODEM));

    return TRUE;
}


/*******************************************************************

  NAME:    EnableWizard

  SYNOPSIS:  Enables or disables the wizard buttons and the wizard
        page itself (so it can't receive focus)

********************************************************************/
VOID EnableWizard(HWND hDlg,BOOL fEnable)
{
  HWND hwndWiz = GetParent(hDlg);

  // disable/enable back, next, cancel and help buttons
  EnableWindow(GetDlgItem(hwndWiz,IDD_BACK),fEnable);
  EnableWindow(GetDlgItem(hwndWiz,IDD_NEXT),fEnable);
  EnableWindow(GetDlgItem(hwndWiz,IDCANCEL),fEnable);
  EnableWindow(GetDlgItem(hwndWiz,IDHELP),fEnable);

  // disable/enable wizard page
  EnableWindow(hwndWiz,fEnable);

  UpdateWindow(hwndWiz);
}



//*******************************************************************
//
//  FUNCTION:   GetModemPage
//
//  PURPOSE:    This is only called from a few places.  This same logic
//              would have otherwise had to be included several times, this
//              centralizes the logic.  The possible pages returned are the
//              "Need Modem" page, the "Choose Modem" page, and "Has ISP".
//
//  PARAMETERS: Parent window.
//
//  RETURNS:    returns the ordinal of the page to display next after
//              initial questions are asked.
//
//  HISTORY:
//  96/03/07  markdu  Created.
//  96/11/11  jmazner  updated to skip new/existing connectoid page
//                     if no connectoids exist.
//
//*******************************************************************

UINT GetModemPage(HWND hDlg)
{

/*** no reason to handle NT seperately -- jmazner
  if (TRUE == IsNT())
  {
      //TODO: Add call to NT enum modems
      return ORD_PAGE_CONNECTION;
  }
***/

  // Enumerate the modems
  DWORD dwRet = EnumerateModems(hDlg, &gpEnumModem);
  if (ERROR_SUCCESS != dwRet)
  {
    // set flag to indicate that wizard should exit now
    gfQuitWizard = TRUE;

    return FALSE;
  }

  if (IsMoreThanOneModemInstalled(gpEnumModem))
  {
    // Multiple modems installed.
    TCHAR szDeviceName[RAS_MaxDeviceName + 1] = TEXT("\0");
    TCHAR szDeviceType[RAS_MaxDeviceType + 1] = TEXT("\0"); // modems are installed

    // If we want to skip the choose modem dlg.
    // retrieve the device info from registry.
    if (g_bSkipMultiModem &&
        GetDeviceSelectedByUser(DEVICENAMEKEY, szDeviceName, sizeof(szDeviceName)) && 
        GetDeviceSelectedByUser(DEVICETYPEKEY, szDeviceType, sizeof(szDeviceType)) )
    {
        lstrcpy(gpRasEntry->szDeviceName, szDeviceName);
        lstrcpy(gpRasEntry->szDeviceType, szDeviceType);
        return ORD_PAGE_PHONENUMBER;
    }
    else
    {
        return ORD_PAGE_CHOOSEMODEM;
    }
  }
  else
  {
    // One modem installed.
    // Note:  this option will also be selected if modems could
    // not be enumerated due to an error.
    // connecting over modem and all drivers/files are in place, go
    // to "existing ISP" page
    // return ORD_PAGE_CONNECTION;

    ENUM_CONNECTOID EnumConnectoid;    // class object for enum

    if( EnumConnectoid.NumEntries() )
    {
        return ORD_PAGE_CONNECTION;
    }
    else
    {
        // 5/8/97 jmazner Olympus #4108
        // move connectionName to the end
        //return ORD_PAGE_CONNECTIONNAME;

        return ORD_PAGE_PHONENUMBER;
    }

  }

}


//*******************************************************************
//
//  FUNCTION:   EnumerateModems
//
//  PURPOSE:    This function assumes that RNA is installed,
//              then it uses RNA to enumerate the devices.
//              If an enum object exists, it is replaced.
//
//  PARAMETERS: Pointer to current enum object, if one exists.
//              In any case, must be a valid pointer.
//              Parent window handle for displaying error message.
//
//  RETURNS:    HRESULT code (ERROR_SUCCESS if no error occurred).
//
//  HISTORY:
//  96/03/07  markdu  Created.
//
//*******************************************************************

HRESULT EnumerateModems(HWND hwndParent, ENUM_MODEM** ppEnumModem)
{
  DWORD dwRet;

  // Should only get here if we want to connect by modem/ISDN
  ASSERT(CONNECT_RAS == gpUserInfo->uiConnectionType)

  // Load RNA if not already loaded
  dwRet = EnsureRNALoaded();
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  ENUM_MODEM* pEnumModem = *ppEnumModem;

  // Enumerate the modems.
  if (pEnumModem)
  {
    // Re-enumerate the modems to be sure we have the most recent changes  
    dwRet = pEnumModem->ReInit();
  }
  else
  {
    // The object does not exist, so create it.
    pEnumModem = new ENUM_MODEM;
    if (pEnumModem)
    {
      dwRet = pEnumModem->GetError();
    }
    else
    {
      dwRet = ERROR_NOT_ENOUGH_MEMORY;
    }
  }

  // Check for errors
  if (ERROR_SUCCESS != dwRet)
  {
    DisplayErrorMessage(hwndParent,IDS_ERREnumModem,dwRet,
      ERRCLS_STANDARD,MB_ICONEXCLAMATION);

    // Clean up
    if (pEnumModem)
    {
      delete pEnumModem;
    }
    pEnumModem = NULL;
  }

  *ppEnumModem = pEnumModem;
  return dwRet;
}


//*******************************************************************
//
//  FUNCTION:   IsModemInstalled
//
//  PURPOSE:    This function validates the ENUM_MODEM object, then
//              gets the modem count.
//
//  PARAMETERS: Modem enum object to use for check.
//
//  RETURNS:    This function returns TRUE if there is at least one
//              modem installed.
//
//  HISTORY:
//  96/03/07  markdu  Created.
//
//*******************************************************************

BOOL IsModemInstalled(ENUM_MODEM* pEnumModem)
{
  if (TRUE == IsNT())
  {
      BOOL bNeedModem = FALSE;
      DWORD dwRet;

        if (NULL == lpIcfgNeedModem)
            return FALSE;
        
        dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
        if (ERROR_SUCCESS == dwRet)
            return !bNeedModem;
        else
            return FALSE;
          
  }
  else
  {
    if (pEnumModem && pEnumModem->GetNumDevices() > 0)
    {
        return TRUE;
    }

    return FALSE;
  }
}
    

//*******************************************************************
//
//  FUNCTION:   IsMoreThanOneModemInstalled
//
//  PURPOSE:    This function validates the ENUM_MODEM object, then
//              gets the modem count.
//
//  PARAMETERS: Modem enum object to use for check.
//
//  RETURNS:    This function returns TRUE if there is more than one
//              modem installed.
//
//  HISTORY:
//  96/03/07  markdu  Created.
//
//*******************************************************************

BOOL IsMoreThanOneModemInstalled(ENUM_MODEM* pEnumModem)
{
  if (IsNT4SP3Lower())
  {
      // TODO: DO NT thing here
      return FALSE;
  }

  if (pEnumModem && pEnumModem->GetNumDevices() > 1)
  {
    return TRUE;
  }

  return FALSE;
}


//+----------------------------------------------------------------------------
//
//  Function:   FGetSystemShutdownPrivledge
//
//  Synopsis:   For windows NT the process must explicitly ask for permission
//              to reboot the system.
//
//  Arguements: none
//
//  Return:     TRUE - privledges granted
//              FALSE - DENIED
//
//  History:    8/14/96 ChrisK  Created
//
//  Note:       BUGBUG for Win95 we are going to have to softlink to these
//              entry points.  Otherwise the app won't even load.
//              Also, this code was originally lifted out of MSDN July96
//              "Shutting down the system"
//-----------------------------------------------------------------------------
BOOL FGetSystemShutdownPrivledge()
{
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;
 
    BOOL bRC = FALSE;

    if (IsNT())
    {
        // 
        // Get the current process token handle 
        // so we can get shutdown privilege. 
        //

        if (!OpenProcessToken(GetCurrentProcess(), 
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) 
                goto FGetSystemShutdownPrivledgeExit;

        //
        // Get the LUID for shutdown privilege.
        //

        ZeroMemory(&tkp,sizeof(tkp));
        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
                &tkp.Privileges[0].Luid); 

        tkp.PrivilegeCount = 1;  /* one privilege to set    */ 
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 

        //
        // Get shutdown privilege for this process.
        //

        AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
            (PTOKEN_PRIVILEGES) NULL, 0); 

        if (ERROR_SUCCESS == GetLastError())
            bRC = TRUE;
    }
    else
    {
        bRC = TRUE;
    }

FGetSystemShutdownPrivledgeExit:
    if (hToken) CloseHandle(hToken);
    return bRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\ispupgui.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ISPUPGUI.C - Functions for Wizard pages to use existing Internet Service Provider
//        (ISP) -- e.g. upgrade
//

//  HISTORY:
//  
//  1/6/95    jeremys  Created.
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/03/25  markdu  If a fatal error occurs, set gfQuitWizard.
//  96/03/26  markdu  Store values from UI even when back is pressed.
//  96/04/04  markdu  Added phonebook name param to ValidateConnectoidName.
//  96/04/07  markdu  NASH BUG 15645 Enable phone number controls based on
//            user's selection for dial-as-is checkbox.  Don't require an
//            area code when dial-as-is selected.
//  96/05/06  markdu  NASH BUG 15637 Removed unused code.
//

#include "wizard.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"
#include "pagefcns.h"

#define TAB_PAGES 2   
INT_PTR CALLBACK TabConnDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK TabAddrDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

VOID EnableWizard(HWND hDlg,BOOL fEnable);
VOID EnableConnectionControls(HWND hDlg);
VOID EnablePhoneNumberControls(HWND hDlg);
VOID EnableScriptControls(HWND hDlg);
DWORD BrowseScriptFile(HWND hDlg);
BOOL CALLBACK AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);

// This flag is used to indicate that gpRasEntry has been filled with
// data from a connectoid at some point.
BOOL  fEntryHasBeenLoaded = FALSE;
DWORD gdwDefCountryID = 0;

/*******************************************************************

  NAME:    ConnectionInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

        Note that code in HowToConnectOKProc ensures that if we make it
        here, there is at least one connectoid on the system

********************************************************************/
BOOL CALLBACK ConnectionInitProc(HWND hDlg,BOOL fFirstInit)
{
  if (fFirstInit)
  {
    // populate the connectoid list box with list of connectoids
    InitConnectoidList(GetDlgItem(hDlg,IDC_ISPNAME),gpUserInfo->szISPName);

    ProcessDBCS(hDlg, IDC_ISPNAME);

//  // Set fields
//  CheckDlgButton(hDlg,IDC_NEWCONNECTION,gpUserInfo->fNewConnection);
//  CheckDlgButton(hDlg,IDC_EXISTINGCONNECTION,!gpUserInfo->fNewConnection);

    // store a default selection in the listbox if there isn't
    // currently a default
    if( LB_ERR == ListBox_GetCurSel(GetDlgItem(hDlg,IDC_ISPNAME)) )
    {
        ListBox_SetCurSel(GetDlgItem(hDlg,IDC_ISPNAME), 0);

        //
        // ChrisK Olympus 7509 6/25/97
        // If the default was not set, then don't select Existing connection
        //
        // Set fields
        CheckDlgButton(hDlg,IDC_NEWCONNECTION,TRUE);
        CheckDlgButton(hDlg,IDC_EXISTINGCONNECTION,FALSE);
    }
    else
    {
        //
        // If there is a default already selected, then select "Use an
        // existing connection".
        //
        CheckDlgButton(hDlg,IDC_NEWCONNECTION,FALSE);
        CheckDlgButton(hDlg,IDC_EXISTINGCONNECTION,TRUE);
    }

    EnableConnectionControls(hDlg);

    // load in strings for the description paragraph
    TCHAR szWhole[ (2 * MAX_RES_LEN) + 1] = TEXT("\0");
    TCHAR szTemp[ MAX_RES_LEN + 1] = TEXT("nothing\0");
    LoadSz(IDS_CONNECTION_DESC1,szTemp,sizeof(szTemp));
    lstrcat( szWhole, szTemp ); 
    LoadSz(IDS_CONNECTION_DESC2,szTemp,sizeof(szTemp));
    lstrcat( szWhole, szTemp ); 

    SetWindowText (GetDlgItem(hDlg,IDC_DESC), szWhole);

  }
  
  // if we've travelled through external apprentice pages,
  // it's easy for our current page pointer to get munged,
  // so reset it here for sanity's sake.
  gpWizardState->uCurrentPage = ORD_PAGE_CONNECTION;


  return FALSE;
}

/*******************************************************************

  NAME:    ConnectionOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ConnectionOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
  ASSERT(puNextPage);

  if (fForward)
  {
    gpUserInfo->fNewConnection = IsDlgButtonChecked(hDlg, IDC_NEWCONNECTION);
    if (gpUserInfo->fNewConnection)
    {
        if (gfFirstNewConnection)
        {
            // The first time through we want to set everything to default
            // for the novice user.  If the user backs up and returns to
            // create new connection, we want to leave whatever was there
            // from before.
            gfFirstNewConnection = FALSE;

            // set the connectoid entries to their defaults
            InitRasEntry(gpRasEntry);
            gpUserInfo->fModifyConnection = FALSE;
            gpUserInfo->fModifyAdvanced = FALSE;
            gpUserInfo->fAutoDNS = TRUE;
            gpUserInfo->szISPName[0] = '\0';
        }
        // 5/8/97 jmazner Olympus #4108
        // move connectionName to the end
        //*puNextPage = ORD_PAGE_CONNECTIONNAME;

        *puNextPage = ORD_PAGE_PHONENUMBER;
    }
    else
    {
        // Copy the current name into a temp for comparison purposes
        TCHAR szISPNameTmp[MAX_ISP_NAME + 1];
        lstrcpy(szISPNameTmp, gpUserInfo->szISPName);

        // get ISP name from UI
        ListBox_GetText(GetDlgItem(hDlg,IDC_ISPNAME),
                        ListBox_GetCurSel(GetDlgItem(hDlg,IDC_ISPNAME)),
                        gpUserInfo->szISPName);

        // If the entry we pulled from the UI does NOT match our 
        // string, we want to process this entry name 
        // since we have not seen this entry yet.  
        // If we have already loaded the data for this entry, though,
        // we don't want to mess with it since the user may have gone ahead.
        // changed something, and then come back.
        // Note:  The first time through, the entry will match even
        // though we haven't yet loaded the data, so we have to check the flag.
        if ((FALSE == fEntryHasBeenLoaded) ||
          lstrcmp(gpUserInfo->szISPName, szISPNameTmp))
        {
          // Since we are going to either reinit the RASENTRY struct
          // or load an existing one over top, we need to store
          // all info we have collected so far
          TCHAR szDeviceNameTmp[RAS_MaxDeviceName + 1];
          TCHAR szDeviceTypeTmp[RAS_MaxDeviceType + 1];
          lstrcpy(szDeviceNameTmp, gpRasEntry->szDeviceName);
          lstrcpy(szDeviceTypeTmp, gpRasEntry->szDeviceType);

          // Get dialing params for this connectoid
          DWORD dwRet = GetEntry(&gpRasEntry, &gdwRasEntrySize, gpUserInfo->szISPName);
          if (ERROR_SUCCESS != dwRet)
          {
            // For some reason we failed, initialize back to defaults and
            // ask user to select a different one
            InitRasEntry(gpRasEntry);
            DisplayFieldErrorMsg(hDlg,IDC_ISPNAME,IDS_ERRCorruptConnection);
            return FALSE;
          }
        
          GetConnectoidUsername(gpUserInfo->szISPName,gpUserInfo->szAccountName,
              ARRAYSIZE(gpUserInfo->szAccountName),gpUserInfo->szPassword,
              ARRAYSIZE(gpUserInfo->szPassword));

          // Restore the data from temporary variables.
          lstrcpy(gpRasEntry->szDeviceName, szDeviceNameTmp);
          lstrcpy(gpRasEntry->szDeviceType, szDeviceTypeTmp);

          // Set the flag to indicate that we have done this once
          fEntryHasBeenLoaded = TRUE;
    }

        // set next page to go to
        if( gpWizardState->dwRunFlags & RSW_APPRENTICE )
        {
            // we're about to jump back to the external wizard, and we don't want
            // this page to show up in our history list
            *pfKeepHistory = FALSE;

            *puNextPage = g_uExternUINext;

            //Notify the main Wizard that this was the last page
            ASSERT( g_pExternalIICWExtension )
            if (g_fIsExternalWizard97)
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_CONNECTION97);
            else
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_CONNECTION);
            
            g_fConnectionInfoValid = TRUE;

        }
        else
            *puNextPage = ORD_PAGE_MODIFYCONNECTION;
    }
  }

  return TRUE;
}

/*******************************************************************

  NAME:    ConnectionCmdProc

  SYNOPSIS:  Called when dlg control pressed on page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
********************************************************************/
BOOL CALLBACK ConnectionCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam)
{   
  switch (GET_WM_COMMAND_ID(wParam, lParam))
  {
    case IDC_NEWCONNECTION:
    case IDC_EXISTINGCONNECTION:
        // if check box selected, enable controls appropriately
        EnableConnectionControls(hDlg);
        break;
  }

  return TRUE;
}

/*******************************************************************

  NAME:    EnableConnectionControls

  SYNOPSIS:  If "Use existing connection" is checked, enable controls
             existing connections.  If not, disable them.

********************************************************************/
VOID EnableConnectionControls(HWND hDlg)
{
    static int iSelection = -1;
    static BOOL bCurStateNew = FALSE;

    BOOL fNew = IsDlgButtonChecked(hDlg,IDC_NEWCONNECTION);
  
    // jmazner 11/9/96 Normandy #8469 and #8293
    if (fNew)
    {
        // if user uses the keybd arrows to go from "new" to "existing",
        // we get called _twice_ here; once when "new" is still checked,
        // and then again when we're expecting it.  This screws us up,
        // because in the first call, the list box is disabled and cur
        // sel is set to -1, and that gets written into iSelection,
        // obliterating the value we were saving.  So use the bCurStateNew
        // flag to prevent this.
        if( bCurStateNew )
          return;

        bCurStateNew = TRUE;
        // save, and then clear out current selection before disabling
        // note that if there's no selection, GetCurSel returns LB_ERR,
        // but we want to save -1, since that's what we use in SetCurSel
        // to remove all selections.
        iSelection = ListBox_GetCurSel(GetDlgItem(hDlg,IDC_ISPNAME));
        if( LB_ERR == iSelection )
          iSelection = -1;

        ListBox_SetCurSel(GetDlgItem(hDlg,IDC_ISPNAME), -1);
        EnableDlgItem(hDlg,IDC_ISPNAME,FALSE);
    }
    else
    {
        bCurStateNew = FALSE;
        EnableDlgItem(hDlg,IDC_ISPNAME,TRUE);
        ListBox_SetCurSel(GetDlgItem(hDlg,IDC_ISPNAME), iSelection);
    }
}

/*******************************************************************

  NAME:    ModifyConnectionInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ModifyConnectionInitProc(HWND hDlg,BOOL fFirstInit)
{
  static TCHAR szCurConnectoid[MAX_ISP_NAME + 1] = TEXT("");

  if (fFirstInit)
  {

    TCHAR szMsg[MAX_RES_LEN + MAX_ISP_NAME + 1];
    TCHAR szFmt[MAX_RES_LEN+1];
    LoadSz(IDS_MODIFYCONNECTION,szFmt,sizeof(szFmt));
    wsprintf(szMsg,szFmt,gpUserInfo->szISPName);

    ProcessDBCS(hDlg, IDC_LBLMODIFYCONNECTION);
    SetDlgItemText(hDlg,IDC_LBLMODIFYCONNECTION,szMsg);

    // keep track of current connectoid name for future compares
    lstrcpyn( szCurConnectoid, gpUserInfo->szISPName, MAX_ISP_NAME );

    CheckDlgButton(hDlg,IDC_MODIFYCONNECTION,gpUserInfo->fModifyConnection);
    CheckDlgButton(hDlg,IDC_NOMODIFYCONNECTION,!(gpUserInfo->fModifyConnection));
  }
  else
  {
    // jmazner 11/9/96 Normandy #10605
    // if the user changed connectoids, update the dialog text
    if( lstrcmp(szCurConnectoid, gpUserInfo->szISPName) )
    {
        TCHAR szMsg[MAX_RES_LEN + MAX_ISP_NAME + 1];
        TCHAR szFmt[MAX_RES_LEN+1];
        LoadSz(IDS_MODIFYCONNECTION,szFmt,sizeof(szFmt));
        wsprintf(szMsg,szFmt,gpUserInfo->szISPName);
        SetDlgItemText(hDlg,IDC_LBLMODIFYCONNECTION,szMsg);

        // store new connectoid name for future compares
        lstrcpyn( szCurConnectoid, gpUserInfo->szISPName, MAX_ISP_NAME );
    }
  }

    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_MODIFYCONNECTION;

  return TRUE;
}

/*******************************************************************

  NAME:    ModifyConnectionOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ModifyConnectionOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
  ASSERT(puNextPage);
  OSVERSIONINFO osver;

  if (fForward)
  {

      // we can not programatically alter a CSLIP connection.  So if they picked
      // one, do not allow them to continue down the "modify" path.
      if ( (RASFP_Slip == gpRasEntry->dwFramingProtocol) 
          && (RASEO_IpHeaderCompression & gpRasEntry->dwfOptions) &&
          IsDlgButtonChecked(hDlg, IDC_MODIFYCONNECTION))
      {
        ZeroMemory(&osver,sizeof(osver));
        osver.dwOSVersionInfoSize = sizeof(osver);
        GetVersionEx(&osver);
        if (VER_PLATFORM_WIN32_WINDOWS == osver.dwPlatformId)
        {
          MsgBox(hDlg,IDS_ERRModifyCSLIP,MB_ICONEXCLAMATION,MB_OK);
          return FALSE;
        }
      }

      gpUserInfo->fModifyConnection = IsDlgButtonChecked(hDlg, IDC_MODIFYCONNECTION);
      if (gpUserInfo->fModifyConnection)
      {
        *puNextPage = ORD_PAGE_PHONENUMBER;
      }
      else
      {
          if( gpWizardState->dwRunFlags & RSW_APPRENTICE )
          {
              // we're about to jump back to the external wizard, and we don't want
              // this page to show up in our history list
              *pfKeepHistory = FALSE;

              *puNextPage = g_uExternUINext;

            //Notify the main Wizard that this was the last page
            ASSERT( g_pExternalIICWExtension )
            if (g_fIsExternalWizard97)
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_MODIFYCONNECTION97);
            else                
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_MODIFYCONNECTION);

            g_fConnectionInfoValid = TRUE;


          }
          else if( LoadAcctMgrUI(GetParent(hDlg), 
                                 g_fIsWizard97 ? IDD_PAGE_MODIFYCONNECTION97 : IDD_PAGE_MODIFYCONNECTION, 
                                 g_fIsWizard97 ? IDD_PAGE_CONNECTEDOK97FIRSTLAST : IDD_PAGE_CONNECTEDOK, 
                                 g_fIsWizard97 ? WIZ_USE_WIZARD97 : 0) )
          {
              if( DialogIDAlreadyInUse( g_uAcctMgrUIFirst) )
              {
                  // we're about to jump into the external apprentice, and we don't want
                  // this page to show up in our history list
                  *pfKeepHistory = FALSE;

                  *puNextPage = g_uAcctMgrUIFirst;
              }
              else
              {
                  DEBUGMSG("hmm, the first acctMgr dlg id is supposedly %d, but it's not marked as in use!",
                            g_uAcctMgrUIFirst);
                  *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);
              }
          }
          else
          {
              DEBUGMSG("LoadAcctMgrUI returned false, guess we'd better skip over it!");
              *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);

          }
      }

  }
  
  return TRUE;
}

/*******************************************************************

  NAME:    ConnectionNameInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ConnectionNameInitProc(HWND hDlg,BOOL fFirstInit)
{
  if (fFirstInit)
  {
    // limit text fields appropriately
    SendDlgItemMessage(hDlg,IDC_CONNECTIONNAME,EM_LIMITTEXT,
      MAX_ISP_NAME,0L);

    ProcessDBCS(hDlg, IDC_CONNECTIONNAME);

  }

  // fill text fields
  //
  // 5/17/97 jmazner Olympus #4608 and 4108
  // do this in all cases to pick up any changes from the
  // PhoneNumber pae.
  //
  SetDlgItemText(hDlg,IDC_CONNECTIONNAME,gpUserInfo->szISPName);

  return TRUE;
}

/*******************************************************************

  NAME:    ConnectionNameOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ConnectionNameOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
  ASSERT(puNextPage);

  // 5/8/97 jmazner Olympus #4108
  // reworked this function to take into acct that this page is now
  // at the _end_ of the series of dialogs, so it shouln't try to
  // fill in defaults.

  //
  // get ISP name from UI
  //
  // 5/17/97 jmazner Olympus #4108 update (see also #4608)
  // Do this even if we're going backwards so that the default name code in
  // PhoneNumberOKProc will know if the user has changed the connectoid name.
  //
  GetDlgItemText(hDlg,IDC_CONNECTIONNAME,gpUserInfo->szISPName,
  ARRAYSIZE(gpUserInfo->szISPName));

 if (fForward)
  {
    // Copy the current name into a temp for comparison purposes
    //CHAR szISPNameTmp[MAX_ISP_NAME + 1];
    //lstrcpy(szISPNameTmp, gpUserInfo->szISPName);


    // make sure user typed a service provider name
    if (!lstrlen(gpUserInfo->szISPName))
    {
      DisplayFieldErrorMsg(hDlg,IDC_CONNECTIONNAME,IDS_NEED_ISPNAME);
      return FALSE;
    }

    // validate the ISP name, which will be used later as the
    // name of an RNA connectoid
    DWORD dwRet = ValidateConnectoidName(NULL, gpUserInfo->szISPName);
    if (dwRet == ERROR_ALREADY_EXISTS)
    {
        DisplayFieldErrorMsg(hDlg,IDC_CONNECTIONNAME,IDS_ERRDuplicateConnectoidName);
        return FALSE;
    }
    else if (dwRet != ERROR_SUCCESS)
    {
        // 12/19/96 jmazner Normandy #12890
        // Legal connectoid names are different under w95 and NT
        if( IsNT() )
        {
            MsgBoxParam(hDlg,IDS_ERRConnectoidNameNT,MB_ICONEXCLAMATION,MB_OK,
                gpUserInfo->szISPName);
        }
        else
        {
            MsgBoxParam(hDlg,IDS_ERRConnectoidName95,MB_ICONEXCLAMATION,MB_OK,
                gpUserInfo->szISPName);
        }

        // 12/17/96 jmazner Normandy #12851
        // if the validate failed, remove the name from the UserInfo struct
        gpUserInfo->szISPName[0] = '\0';

        // select ISP name in dialog and fail the OK command
        SetFocus(GetDlgItem(hDlg,IDC_CONNECTIONNAME));
        SendDlgItemMessage(hDlg,IDC_CONNECTIONNAME,EM_SETSEL,0,-1);
        return FALSE;
    }


    /**
    if ((FALSE == fEntryHasBeenLoaded) ||
      lstrcmp(gpUserInfo->szISPName, szISPNameTmp))
    {
      // Since we are going to either reinit the RASENTRY struct
      // or load an existing one over top, we need to store
      // all info we have collected so far
      TCHAR szDeviceNameTmp[RAS_MaxDeviceName + 1];
      TCHAR szDeviceTypeTmp[RAS_MaxDeviceType + 1];
      lstrcpy(szDeviceNameTmp, gpRasEntry->szDeviceName);
      lstrcpy(szDeviceTypeTmp, gpRasEntry->szDeviceType);

      // validate the ISP name, which will be used later as the
      // name of an RNA connectoid
      DWORD dwRet = ValidateConnectoidName(NULL, gpUserInfo->szISPName);

      if (dwRet == ERROR_ALREADY_EXISTS)
      {
        // this connectoid already exists.  Re-use it, and get
        // dialing params for this connectoid
        dwRet = GetEntry(&gpRasEntry, &gdwRasEntrySize, gpUserInfo->szISPName);
        if (ERROR_SUCCESS != dwRet)
        {
          // For some reason we failed, so just re-init to default
          InitRasEntry(gpRasEntry);
        }
        
        GetConnectoidUsername(gpUserInfo->szISPName,gpUserInfo->szAccountName,
          sizeof(gpUserInfo->szAccountName),gpUserInfo->szPassword,
          sizeof(gpUserInfo->szPassword));

      }
      else if (dwRet != ERROR_SUCCESS)
      {
        // 12/19/96 jmazner Normandy #12890
        // Legal connectoid names are different under w95 and NT
        if( IsNT() )
        {
            MsgBoxParam(hDlg,IDS_ERRConnectoidNameNT,MB_ICONEXCLAMATION,MB_OK,
                gpUserInfo->szISPName);
        }
        else
        {
            MsgBoxParam(hDlg,IDS_ERRConnectoidName95,MB_ICONEXCLAMATION,MB_OK,
                gpUserInfo->szISPName);
        }

        // 12/17/96 jmazner Normandy #12851
        // if the validate failed, remove the name from the UserInfo struct
        gpUserInfo->szISPName[0] = '\0';

        // select ISP name in dialog and fail the OK command
        SetFocus(GetDlgItem(hDlg,IDC_CONNECTIONNAME));
        SendDlgItemMessage(hDlg,IDC_CONNECTIONNAME,EM_SETSEL,0,-1);
        return FALSE;
      }
      else
      {
        // Normandy 13018 - ChrisK 1-9-97
        // Default username has been set to <blank>
        //// this connectoid doesn't exist yet.  Clear out connectoid-specifc
        //// information from user struct, because we might have
        //// info from other connectoids in struct if user chose a connectoid,
        //// then backed up and typed a different name
        //GetDefaultUserName(gpUserInfo->szAccountName,sizeof(gpUserInfo->szAccountName));
        gpUserInfo->szAccountName[0] = '\0';
        gpUserInfo->szPassword[0] = '\0';

        // initialize the rasentry structure
        InitRasEntry(gpRasEntry);
      }

      // Restore the data from temporary variables.
      lstrcpy(gpRasEntry->szDeviceName, szDeviceNameTmp);
      lstrcpy(gpRasEntry->szDeviceType, szDeviceTypeTmp);

      // Set the flag to indicate that we have done this once
      fEntryHasBeenLoaded = TRUE;
    }
    **/

    // set next page to go to
    //*puNextPage = ORD_PAGE_PHONENUMBER;
    if( gpWizardState->dwRunFlags & RSW_APPRENTICE )
    {
          // we're about to jump back to the external wizard, and we don't want
          // this page to show up in our history list
          *pfKeepHistory = FALSE;

          *puNextPage = g_uExternUINext;

            //Notify the main Wizard that this was the last page
            ASSERT( g_pExternalIICWExtension )
            if (g_fIsExternalWizard97)
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_CONNECTIONNAME97);
            else
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_CONNECTIONNAME);

            g_fConnectionInfoValid = TRUE;

    }
    else if( LoadAcctMgrUI(GetParent(hDlg), 
                           g_fIsWizard97 ? IDD_PAGE_CONNECTIONNAME97 : IDD_PAGE_CONNECTIONNAME, 
                           g_fIsWizard97 ? IDD_PAGE_CONNECTEDOK97FIRSTLAST : IDD_PAGE_CONNECTEDOK, 
                           g_fIsWizard97 ? WIZ_USE_WIZARD97 : 0) )
    {
          if( DialogIDAlreadyInUse( g_uAcctMgrUIFirst) )
          {
              // we're about to jump into the external apprentice, and we don't want
              // this page to show up in our history list
              *pfKeepHistory = FALSE;

              *puNextPage = g_uAcctMgrUIFirst;
          }
          else
          {
              DEBUGMSG("hmm, the first acctMgr dlg id is supposedly %d, but it's not marked as in use!",
                        g_uAcctMgrUIFirst);
              *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);
          }
      }
      else
      {
          DEBUGMSG("LoadAcctMgrUI returned false, guess we'd better skip over it!");
          *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);

    }

  }

  return TRUE;
}

/*******************************************************************

  NAME:    PhoneNumberInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK PhoneNumberInitProc(HWND hDlg,BOOL fFirstInit)
{
    if (IsNT5())
    {
        TCHAR szTemp[ MAX_RES_LEN + 1] = TEXT("\0");
        LoadSz(IDS_USEDIALRULES, szTemp, sizeof(szTemp));
        SetWindowText(GetDlgItem(hDlg, IDC_USEDIALRULES), szTemp);
    }

    if (fFirstInit)
    {
        // limit text fields appropriately
        SendDlgItemMessage(hDlg,IDC_AREACODE,EM_LIMITTEXT,
          MAX_UI_AREA_CODE,0L);
        SendDlgItemMessage(hDlg,IDC_PHONENUMBER,EM_LIMITTEXT,
          MAX_UI_PHONENUM,0L);

        // initialize text fields
        SetDlgItemText(hDlg,IDC_AREACODE,gpRasEntry->szAreaCode);
        SetDlgItemText(hDlg,IDC_PHONENUMBER,gpRasEntry->szLocalPhoneNumber);

        // initialize dial-as-is checkbox
        CheckDlgButton(hDlg,IDC_USEDIALRULES,
        gpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes);

    }
    else
    {

        ProcessDBCS(hDlg, IDC_COUNTRYCODE);

        //
        // 5/17/97 jmazner Olympus #4608
        // if user didn't have a modem when they started down the manual path,
        // then InitRasEntry couldn't fill in an area code.  If it looks
        // like that happened, try calling InitRasEntry again.
        //
        // 6/3/97 jmazner Olympus #5657
        // Ah, but if Dial-as-is is selected, there probably won't be an area
        // code.  So don't re-init in that case.
        //
        // 7/16/97 jmazner Olympus #9571
        // the saga continues -- there are some cases (eg: Kuwait) where it's
        // perfectly valid to have an empty area code but still use TAPI
        // dialing rules.  To make life easier, move this code into HowToConnectOKProc
        // so that we call it _before_ any user information has been entered into the
        // gpRasEntry struct.
        //
        //if( (NULL == gpRasEntry->szAreaCode[0]) &&
        //  (gpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes) )
        //{
        //  InitRasEntry( gpRasEntry );
        //}

        HWND hwndCB = GetDlgItem(hDlg,IDC_COUNTRYCODE);

        // put default RNA country code in combo box
        InitCountryCodeList(hwndCB);

        // Normandy 13097 - ChrisK 1/8/97
        // The default selection should be based on the Country ID not the code

        // select country ID if we already have a default

        if (gdwDefCountryID) 
        {
            gpRasEntry->dwCountryID = gdwDefCountryID;
            if (!SetCountryIDSelection(hwndCB, gdwDefCountryID)) 
            {
                // country code for default connectoid is not the same
                // as default RNA country code, fill in the listbox with
                // all country codes and then try selection again
                FillCountryCodeList(hwndCB);
                // if this one fails, then just give up
                BOOL fRet=SetCountryIDSelection(hwndCB, gdwDefCountryID);
                ASSERT(fRet);
            }
        }

        // enable controls appropriately
        EnablePhoneNumberControls(hDlg);
    }
    gpWizardState->uCurrentPage = ORD_PAGE_PHONENUMBER;

    return TRUE;
}

/*******************************************************************

  NAME:    PhoneNumberOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK PhoneNumberOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
  static TCHAR s_szPreviousDefaultName[MAX_ISP_NAME+1] = TEXT("\0uninitialized");
  TCHAR szNewDefaultName[MAX_ISP_NAME + 1] = TEXT("\0");

  ASSERT(puNextPage);

  // get area code and phone number out of dialog
  GetDlgItemText(hDlg,IDC_AREACODE,gpRasEntry->szAreaCode,
    ARRAYSIZE(gpRasEntry->szAreaCode));
  GetDlgItemText(hDlg,IDC_PHONENUMBER,gpRasEntry->szLocalPhoneNumber,
    ARRAYSIZE(gpRasEntry->szLocalPhoneNumber));

  // get selected country code from combo box
  LPCOUNTRYCODE lpCountryCode;
  GetCountryCodeSelection(GetDlgItem(hDlg,IDC_COUNTRYCODE),&lpCountryCode);

  // Store country code info in our struct
  gpRasEntry->dwCountryCode = lpCountryCode->dwCountryCode;
  gpRasEntry->dwCountryID =   lpCountryCode->dwCountryID;
  gdwDefCountryID = gpRasEntry->dwCountryID;

  // set the dial-as-is flag appropriately;
  if (IsDlgButtonChecked(hDlg,IDC_USEDIALRULES))
  {
    gpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;    
  }
  else
  {
    gpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;    
  }

  if (fForward)
  {
    // make sure user typed in a phone number
    if (!lstrlen(gpRasEntry->szLocalPhoneNumber))
    {
      DisplayFieldErrorMsg(hDlg,IDC_PHONENUMBER,IDS_NEED_PHONENUMBER);
      return FALSE;
    }

    // 11/11/96 jmazner Normandy #7623
    // make sure phone number has only valid chars
    //
    // 5/17/97  jmazner Olympus #137
    // that includes checking for DBCS chars.

#if !defined(WIN16)
    if (!IsSBCSString(gpRasEntry->szLocalPhoneNumber))
    {
        DisplayFieldErrorMsg(hDlg,IDC_PHONENUMBER,IDS_SBCSONLY);
        return FALSE;
    }
#endif
    if( !IsDialableString(gpRasEntry->szLocalPhoneNumber) )
    {
      DisplayFieldErrorMsg(hDlg,IDC_PHONENUMBER,IDS_INVALIDPHONE);
      return FALSE;
    }

    // 11/11/96 jmazner Normandy #7623
    // make sure area code has only valid chars
#if !defined(WIN16)
    if( gpRasEntry->szAreaCode[0] && !IsSBCSString(gpRasEntry->szAreaCode))
    {
        DisplayFieldErrorMsg(hDlg,IDC_AREACODE,IDS_SBCSONLY);
        return FALSE;
    }
#endif

    if( gpRasEntry->szAreaCode[0] && !IsDialableString(gpRasEntry->szAreaCode) )
    {
      DisplayFieldErrorMsg(hDlg,IDC_AREACODE,IDS_INVALIDPHONE);
      return FALSE;
    }
    // make sure user typed in an area code unless dial-as-is was chosen
/*    if ((!lstrlen(gpRasEntry->szAreaCode)) &&
      (!IsDlgButtonChecked(hDlg,IDC_DIALASIS)))
    {
      DisplayFieldErrorMsg(hDlg,IDC_AREACODE,IDS_NEED_AREACODE);
      return FALSE;
    }
*/

      // 5/8/97 jmazner Olympus #4108
      // prepopulate connectoid name with "Connection to xxx-xxxx"
      if( gpUserInfo->szISPName )
      {
          TCHAR szFmt[MAX_ISP_NAME + 1];
          ZeroMemory(&szFmt, MAX_ISP_NAME + 1);
          LoadSz(IDS_CONNECTIONTO,szFmt, MAX_ISP_NAME + 1);
          wsprintf(szNewDefaultName, szFmt, gpRasEntry->szLocalPhoneNumber );

          if( (NULL == gpUserInfo->szISPName[0]) ||
              (0 == lstrcmp(s_szPreviousDefaultName, gpUserInfo->szISPName)) )
          {
              lstrcpy( gpUserInfo->szISPName, szNewDefaultName );
              lstrcpy( s_szPreviousDefaultName, szNewDefaultName );
          }
      }

    *puNextPage = ORD_PAGE_NAMEANDPASSWORD;
  }

  // free country code list buffer
  DeInitCountryCodeList();

  return TRUE;
}

BOOL RunAdvDlg(HWND hDlg)
{
    HPROPSHEETPAGE  hWizPage[TAB_PAGES];  // array to hold handles to pages
    PROPSHEETPAGE   psPage;    // struct used to create prop sheet pages
    PROPSHEETHEADER psHeader;  // struct used to run wizard property sheet
    INT_PTR             iRet;
    TCHAR           szTemp[MAX_RES_LEN + 1];
    
    // zero out structures
    ZeroMemory(&hWizPage,sizeof(hWizPage));   // hWizPage is an array
    ZeroMemory(&psPage,sizeof(PROPSHEETPAGE));
    ZeroMemory(&psHeader,sizeof(PROPSHEETHEADER));

    // fill out common data property sheet page struct
    psPage.dwSize    = sizeof(PROPSHEETPAGE);
    psPage.hInstance = ghInstance;
    psPage.dwFlags = PSP_DEFAULT | PSP_USETITLE;

    // create a property sheet page for each page in the wizard
    // create a property sheet page for the connection tab 
    psPage.pszTemplate = MAKEINTRESOURCE(IDD_ADVANCE_TAB_CONN);
    LoadSz(IDS_CONNECTION, szTemp, MAX_RES_LEN);
    psPage.pszTitle = szTemp;
    psPage.pfnDlgProc = TabConnDlgProc;
    hWizPage[0] = CreatePropertySheetPage(&psPage);
   
    // create a property sheet page for the address tab 
    psPage.pszTemplate = MAKEINTRESOURCE(IDD_ADVANCE_TAB_ADDR);
    LoadSz(IDS_ADDRESS, szTemp, MAX_RES_LEN);
    psPage.pszTitle = szTemp;
    psPage.pfnDlgProc = TabAddrDlgProc;
    hWizPage[1] = CreatePropertySheetPage(&psPage);

    if (!hWizPage[1]) 
        DestroyPropertySheetPage(hWizPage[0]);

    // fill out property sheet header struct
    psHeader.dwSize = sizeof(psHeader);
    psHeader.dwFlags = PSH_NOAPPLYNOW;
    psHeader.hwndParent = hDlg;
    psHeader.hInstance = ghInstance;
    psHeader.nPages = TAB_PAGES;
    psHeader.phpage = hWizPage;
    LoadSz(IDS_ADVANCE_PROPERTIES, szTemp, MAX_RES_LEN);
    psHeader.pszCaption = szTemp;
    psHeader.nStartPage = 0;

    
    HINSTANCE hComCtl = LoadLibrary(TEXT("comctl32.dll"));
    if (hComCtl)
    {
        PFNInitCommonControlsEx pfnInitCommonControlsEx = NULL;

        if (pfnInitCommonControlsEx = (PFNInitCommonControlsEx)GetProcAddress(hComCtl,"InitCommonControlsEx"))
        {
            //register the Native font control so the dialog won't fail
            INITCOMMONCONTROLSEX iccex;
            iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
            iccex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
            if (!pfnInitCommonControlsEx(&iccex))
                return FALSE;
        }
        FreeLibrary(hComCtl);
    }

    // run the Wizard
    iRet = PropertySheet(&psHeader);

    return (iRet > 0);
}

/*******************************************************************

  NAME:    PhoneNumberCmdProc

  SYNOPSIS:  Called when dlg control pressed on page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
********************************************************************/
BOOL CALLBACK PhoneNumberCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam)
{   
  switch (GET_WM_COMMAND_ID(wParam, lParam)) {

    case IDC_USEDIALRULES:
      // if check box selected, enable controls appropriately
      EnablePhoneNumberControls(hDlg);
      break;

    case IDC_COUNTRYCODE:
      FillCountryCodeList(GetDlgItem(hDlg,IDC_COUNTRYCODE));
      break;

    case IDC_MODIFYADVANCED:
        // if check box selected, enable controls appropriately
        RASENTRY pRasEntry;
        // Store the current setting now.  If later user canceled we can reset them all back
        // We are doing this because at this moment we don't want to break up the
        // the verifying and saving code into 2 big steps because the verifcation and the saving
        // are self contained in 4 individual ok procs. ( originally in 4 different advance pages )
        // It is too much work to regroup them into
        // two separate operations.
        memcpy(&pRasEntry, gpRasEntry, sizeof(RASENTRY));
        if (!RunAdvDlg(hDlg))
        {
            memcpy(gpRasEntry, &pRasEntry, sizeof(RASENTRY));
        }
        break;
  }
  return TRUE;
}

/*******************************************************************

  NAME:    EnablePhoneNumberControls

  SYNOPSIS:  If "Don't use country code..." is checked, disable controls for
            area code and country code.  If not, enable them.

********************************************************************/
VOID EnablePhoneNumberControls(HWND hDlg)
{
  BOOL fUseDialRules = IsDlgButtonChecked(hDlg,IDC_USEDIALRULES);
  
  EnableDlgItem(hDlg,IDC_AREACODE,fUseDialRules);
  EnableDlgItem(hDlg,IDC_TX_AREACODE,fUseDialRules);
  EnableDlgItem(hDlg,IDC_TX_SEPARATOR,fUseDialRules);
  EnableDlgItem(hDlg,IDC_COUNTRYCODE,fUseDialRules);
  EnableDlgItem(hDlg,IDC_TX_COUNTRYCODE,fUseDialRules);
}
                                    
/*******************************************************************

  NAME:    NameAndPasswordInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK NameAndPasswordInitProc(HWND hDlg,BOOL fFirstInit)
{
  if (fFirstInit)
  {
    //
    // 7/30/97 jmazner Olympus 1111
    //
    ProcessDBCS( hDlg, IDC_USERNAME );

    // limit text fields appropriately
    SendDlgItemMessage(hDlg,IDC_USERNAME,EM_LIMITTEXT,
      MAX_ISP_USERNAME,0L);
    SendDlgItemMessage(hDlg,IDC_PASSWORD,EM_LIMITTEXT,
      MAX_ISP_PASSWORD,0L);
      SetDlgItemText(hDlg,IDC_USERNAME,gpUserInfo->szAccountName);
      SetDlgItemText(hDlg,IDC_PASSWORD,gpUserInfo->szPassword);
  }


  return TRUE;
}

/*******************************************************************

  NAME:    NameAndPasswordOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK NameAndPasswordOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
    ASSERT(puNextPage);

    // get user name and password from UI
    GetDlgItemText(hDlg,IDC_USERNAME,gpUserInfo->szAccountName,
    ARRAYSIZE(gpUserInfo->szAccountName));
    GetDlgItemText(hDlg,IDC_PASSWORD,gpUserInfo->szPassword,
    ARRAYSIZE(gpUserInfo->szPassword));

    if (fForward)
    {
        // warn (but allow user to proceed) if username is blank
        if (!lstrlen(gpUserInfo->szAccountName))
        {
          if (!WarnFieldIsEmpty(hDlg,IDC_USERNAME,IDS_WARN_EMPTY_USERNAME))
            return FALSE;  // stay on this page if user heeds warning
        } 

        //
        // 5/17/97  jmazner Olympus #248
        // warn if password is empty
        //
        if (!lstrlen(gpUserInfo->szPassword))
        {
          if (!WarnFieldIsEmpty(hDlg,IDC_PASSWORD,IDS_WARN_EMPTY_PASSWORD))
            return FALSE;  // stay on this page if user heeds warning
        } 


        // set next page to go to
        if (gpUserInfo->fNewConnection)
        {
            *puNextPage = ORD_PAGE_CONNECTIONNAME;
        }
        else if( gpWizardState->dwRunFlags & RSW_APPRENTICE )
        {
            // we're about to jump back to the external wizard, and we don't want
            // this page to show up in our history list
            *pfKeepHistory = FALSE;

            *puNextPage = g_uExternUINext;

            //Notify the main Wizard that this was the last page
            ASSERT( g_pExternalIICWExtension )
            if (g_fIsExternalWizard97)
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_NAMEANDPASSWORD97);
            else
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_NAMEANDPASSWORD);
            g_fConnectionInfoValid = TRUE;

        }
        else if( LoadAcctMgrUI(GetParent(hDlg), 
                             g_fIsWizard97 ? IDD_PAGE_NAMEANDPASSWORD97 : IDD_PAGE_NAMEANDPASSWORD, 
                             g_fIsWizard97 ? IDD_PAGE_CONNECTEDOK97FIRSTLAST : IDD_PAGE_CONNECTEDOK, 
                             g_fIsWizard97 ? WIZ_USE_WIZARD97 : 0) )
        {
            if( DialogIDAlreadyInUse( g_uAcctMgrUIFirst) )
            {
                // we're about to jump into the external apprentice, and we don't want
                // this page to show up in our history list
                *pfKeepHistory = FALSE;
                *puNextPage = g_uAcctMgrUIFirst;
            }
            else
            {
                DEBUGMSG("hmm, the first acctMgr dlg id is supposedly %d, but it's not marked as in use!",
                        g_uAcctMgrUIFirst);
                *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);
            }
        }
        else
        {
            DEBUGMSG("LoadAcctMgrUI returned false, guess we'd better skip over it!");
            *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);

        }
    }
    return TRUE;
}


/*******************************************************************

  NAME:    TabConnDlgProc

  SYNOPSIS:  Dialog proc for Connection advanced button

********************************************************************/
INT_PTR CALLBACK TabConnDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
    
    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            //Remove the system menu from the window's style
            LONG window_style = GetWindowLong(GetParent(hDlg), GWL_EXSTYLE);
            window_style &= ~WS_EX_CONTEXTHELP;
            //set the style attribute of the main frame window
            SetWindowLong(GetParent(hDlg), GWL_EXSTYLE, window_style);

            ConnectionProtocolInitProc(hDlg, TRUE);
            LoginScriptInitProc(hDlg, TRUE);

            break;
        }
        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case IDC_BROWSE:
                    BrowseScriptFile(hDlg);
                    break;
                case IDC_PROTOCOLPPP:
                case IDC_PROTOCOLSLIP:
                case IDC_PROTOCOLCSLIP:
                    // set next page to go to
                    EnableWindow(GetDlgItem(hDlg,IDC_DISABLELCP), FALSE);
                    if (IsDlgButtonChecked(hDlg, IDC_PROTOCOLPPP))
                    {
                        OSVERSIONINFO osver;
                        ZeroMemory(&osver,sizeof(osver));
                        osver.dwOSVersionInfoSize = sizeof(osver);
                        GetVersionEx(&osver);

                        // LCP extensions only effect PPP connections in NT
                        if (VER_PLATFORM_WIN32_NT == osver.dwPlatformId)
                            EnableWindow(GetDlgItem(hDlg,IDC_DISABLELCP), TRUE);
                    }
                    break;

                default:
                    LoginScriptCmdProc(hDlg, LOWORD(wParam));
                    break;
            }
            break;

        }
        case WM_NOTIFY:
        {
            NMHDR * lpnm = (NMHDR *) lParam;
            switch (lpnm->code) 
            { 
                case PSN_KILLACTIVE:
                {
                    if (!ConnectionProtocolOKProc(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        return TRUE;
                    }
                    if (!LoginScriptOKProc(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        return TRUE;
                    }
                }
            }
            break;
        }
    }
    
    return FALSE;
}


/*******************************************************************

  NAME:    TabConnDlgProc

  SYNOPSIS:  Dialog proc for Connection advanced button

********************************************************************/
INT_PTR CALLBACK TabAddrDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
    
    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            IPAddressInitProc(hDlg, TRUE);
            DNSAddressInitProc(hDlg, TRUE);
            break;
        }
        case WM_COMMAND:
        {
            IPAddressCmdProc(hDlg, LOWORD(wParam));
            DNSAddressCmdProc(hDlg, LOWORD(wParam));
            break;
        }
        case WM_NOTIFY:
        {
            NMHDR * lpnm = (NMHDR *) lParam;
            switch (lpnm->code) 
            { 
                case PSN_KILLACTIVE:
                {
                    if (!IPAddressOKProc(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        return TRUE;
                    }
                    if (!DNSAddressOKProc(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        return TRUE;
                    }
                }
            }
            break;
        }

    }
    return FALSE;
}


/*******************************************************************

  NAME:    ConnectionProtocolInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg        - dialog window
            fFirstInit  - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ConnectionProtocolInitProc(HWND hDlg,BOOL fFirstInit)
{
    if (fFirstInit)
    {
        OSVERSIONINFO osver;
        ZeroMemory(&osver,sizeof(osver));
        osver.dwOSVersionInfoSize = sizeof(osver);
        GetVersionEx(&osver);
        if (VER_PLATFORM_WIN32_WINDOWS == osver.dwPlatformId)
        {
            RECT    Rect;
            RECT    OriginalRect;
            ShowWindow(GetDlgItem(hDlg,IDC_PROTOCOLCSLIP),SW_HIDE);
            EnableWindow(GetDlgItem(hDlg,IDC_PROTOCOLCSLIP), FALSE);
            ShowWindow(GetDlgItem(hDlg,IDC_DISABLELCP),SW_HIDE);
            EnableWindow(GetDlgItem(hDlg,IDC_DISABLELCP), FALSE);

            GetWindowRect(GetDlgItem(hDlg,IDC_PROTOCOLSLIP), &Rect);
            GetWindowRect(GetDlgItem(hDlg,IDC_PROTOCOLCSLIP), &OriginalRect);

            // assume that if it's Japanese, and it's not NT, it must be win95J!
            RECT itemRect;
            POINT thePoint;
            HWND hwndItem = GetDlgItem(hDlg,IDC_PROTOCOLSLIP);

            GetWindowRect(hwndItem, &itemRect);

            // need to convert the coords from global to local client,
            // since MoveWindow below will expext client coords.

            thePoint.x = itemRect.left;
            thePoint.y = itemRect.top;
            ScreenToClient(hDlg, &thePoint );
            itemRect.left = thePoint.x;
            itemRect.top = thePoint.y;

            thePoint.x = itemRect.right;
            thePoint.y = itemRect.bottom;
            ScreenToClient(hDlg, &thePoint );
            itemRect.right = thePoint.x;
            itemRect.bottom = thePoint.y;

            MoveWindow(hwndItem,
	            itemRect.left,
	            itemRect.top - (OriginalRect.top - Rect.top),
	            (itemRect.right - itemRect.left),
	            (itemRect.bottom - itemRect.top), TRUE);
        }

        // initialize radio buttons, default to PPP
        CheckDlgButton(hDlg,IDC_PROTOCOLPPP,RASFP_Ppp == gpRasEntry->dwFramingProtocol);
        EnableWindow(GetDlgItem(hDlg,IDC_DISABLELCP), FALSE);
        if (IsDlgButtonChecked(hDlg, IDC_PROTOCOLPPP))
        {
            OSVERSIONINFO osver;
            ZeroMemory(&osver,sizeof(osver));
            osver.dwOSVersionInfoSize = sizeof(osver);
            GetVersionEx(&osver);
            if ((RASFP_Ppp == gpRasEntry->dwFramingProtocol) &&
                (VER_PLATFORM_WIN32_NT == osver.dwPlatformId))
            {
                // LCP extensions only effect PPP connections
                EnableWindow(GetDlgItem(hDlg,IDC_DISABLELCP), TRUE);
            }

        }
        CheckDlgButton(hDlg,IDC_DISABLELCP,(RASEO_DisableLcpExtensions & gpRasEntry->dwfOptions));

        CheckDlgButton(hDlg,IDC_PROTOCOLSLIP,(RASFP_Slip == gpRasEntry->dwFramingProtocol)
            && !(gpRasEntry->dwfOptions & RASEO_IpHeaderCompression));
        CheckDlgButton(hDlg,IDC_PROTOCOLCSLIP,(RASFP_Slip == gpRasEntry->dwFramingProtocol)
            && (gpRasEntry->dwfOptions & RASEO_IpHeaderCompression));
    }

    return TRUE;
}

/*******************************************************************

  NAME:    ConnectionProtocolOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ConnectionProtocolOKProc(HWND hDlg)
{
    ASSERT(puNextPage);

    // read radio button state
    if (IsDlgButtonChecked(hDlg, IDC_PROTOCOLPPP))
    {
        // Set entry for PPP
        gpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
        gpRasEntry->dwFramingProtocol = RASFP_Ppp;
        if (IsDlgButtonChecked(hDlg, IDC_DISABLELCP))
        {
            gpRasEntry->dwfOptions |= RASEO_DisableLcpExtensions;
        }
        else
        {
            gpRasEntry->dwfOptions &= ~(RASEO_DisableLcpExtensions);
        }
    }
    else if (IsDlgButtonChecked(hDlg, IDC_PROTOCOLSLIP))
    {
        // Set entry for SLIP
        gpRasEntry->dwfOptions &= ~RASEO_IpHeaderCompression;
        gpRasEntry->dwFramingProtocol = RASFP_Slip;
    }
    else if (IsDlgButtonChecked(hDlg, IDC_PROTOCOLCSLIP))
    {
        // Set entry for C-SLIP
        gpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
        gpRasEntry->dwFramingProtocol = RASFP_Slip;
    }

    return TRUE;
}

/*******************************************************************

  NAME:    LoginScriptInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK LoginScriptInitProc(HWND hDlg,BOOL fFirstInit)
{
  if (fFirstInit)
  {
    // Set limit on edit box
    SendDlgItemMessage(hDlg,IDC_SCRIPTFILE,EM_LIMITTEXT,
      MAX_PATH,0L);

    ProcessDBCS(hDlg, IDC_SCRIPTFILE);

    // If there is a script file, default to use script
    // If no script file, base selection on whether or not
    // a post-dial terminal window is desired.
    if (lstrlen(gpRasEntry->szScript))
    {
      CheckDlgButton(hDlg,IDC_NOTERMINALAFTERDIAL,FALSE);
      CheckDlgButton(hDlg,IDC_TERMINALAFTERDIAL,FALSE);
      CheckDlgButton(hDlg,IDC_SCRIPT,TRUE);

      SetDlgItemText(hDlg,IDC_SCRIPTFILE,gpRasEntry->szScript);

      // set focus to the script text field
      SetFocus(GetDlgItem(hDlg,IDC_SCRIPTFILE));
    }
    else
    {
      BOOL fTerminalWindow = (gpRasEntry->dwfOptions & RASEO_TerminalAfterDial);
      CheckDlgButton(hDlg,IDC_NOTERMINALAFTERDIAL,!fTerminalWindow);
      CheckDlgButton(hDlg,IDC_TERMINALAFTERDIAL,fTerminalWindow);
      CheckDlgButton(hDlg,IDC_SCRIPT,FALSE);
    }
  }
  
  // enable script controls appropriately
  EnableScriptControls(hDlg);

  return TRUE;
}

/*******************************************************************

  NAME:    LoginScriptOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK LoginScriptOKProc(HWND hDlg)
{
  ASSERT(puNextPage);

  // read radio button state
  if (IsDlgButtonChecked(hDlg, IDC_NOTERMINALAFTERDIAL))
  {
    // Set entry for no terminal window or script
    gpRasEntry->dwfOptions &= ~RASEO_TerminalAfterDial;
    lstrcpy(gpRasEntry->szScript, szNull);
  }
  else if (IsDlgButtonChecked(hDlg, IDC_TERMINALAFTERDIAL))
  {
    // Set entry for terminal window and no script
    gpRasEntry->dwfOptions |= RASEO_TerminalAfterDial;
    lstrcpy(gpRasEntry->szScript, szNull);
  }
  else if (IsDlgButtonChecked(hDlg, IDC_SCRIPT))
  {
    // Set entry for script, but no terminal window
    gpRasEntry->dwfOptions &= ~RASEO_TerminalAfterDial;
    GetDlgItemText(hDlg,IDC_SCRIPTFILE,gpRasEntry->szScript,
      ARRAYSIZE(gpRasEntry->szScript));
  }

  if(IsDlgButtonChecked(hDlg, IDC_SCRIPT))
  {
      if( 0xFFFFFFFF == GetFileAttributes(gpRasEntry->szScript))
      {
          DisplayFieldErrorMsg(hDlg,IDC_SCRIPTFILE,IDS_LOGINSCRIPTINVALID);
          return FALSE;
      }
  }

  return TRUE;
}

/*******************************************************************

  NAME:    LoginScriptCmdProc

  SYNOPSIS:  Called when dlg control pressed on page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
********************************************************************/
BOOL CALLBACK LoginScriptCmdProc(HWND hDlg,UINT uCtrlID)
{
  switch (uCtrlID)
  {

    case IDC_NOTERMINALAFTERDIAL:
    case IDC_TERMINALAFTERDIAL:
    case IDC_SCRIPT:
      // if radio buttons pushed, enable script controls appropriately
      EnableScriptControls(hDlg);
      break;

    case IDC_BROWSE:
      BrowseScriptFile(hDlg);
      break;
  }

  return TRUE;
}

/*******************************************************************

  NAME:    EnableScriptControls

  SYNOPSIS:  If "Use this script" is checked, enable controls for
            browsing.  If not, disable them.

********************************************************************/
VOID EnableScriptControls(HWND hDlg)
{
  BOOL fUseScript = IsDlgButtonChecked(hDlg,IDC_SCRIPT);
  
  EnableDlgItem(hDlg,IDC_SCRIPT_LABEL,fUseScript);
  EnableDlgItem(hDlg,IDC_SCRIPTFILE,fUseScript);
  EnableDlgItem(hDlg,IDC_BROWSE,fUseScript);
}

//****************************************************************************
// DWORD BrowseScriptFile (HWND)
//
// This function taken from RNA
//
// History:
//  Tue 08-Nov-1994 09:14:13  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD BrowseScriptFile(HWND hDlg)
{
  OPENFILENAME  ofn;
  LPTSTR        pszFiles, szFileName, szFilter;
  DWORD         dwRet;

  // Allocate filename buffer
  //
  if ((pszFiles = (LPTSTR)LocalAlloc(LPTR, 2*MAX_PATH*sizeof(TCHAR))) == NULL)
    return ERROR_OUTOFMEMORY;
  szFileName = pszFiles;
  szFilter   = szFileName+MAX_PATH;

  // Start file browser dialog
  //
  LoadString(ghInstance, IDS_SCRIPT_FILE_FILTER, szFilter, MAX_PATH);

  *szFileName     = '\0';
  ofn.lStructSize = sizeof(ofn);
  ofn.hwndOwner   = hDlg;
  ofn.hInstance   = ghInstance;
  ofn.lpstrFilter = szFilter;
  ofn.lpstrCustomFilter = NULL;
  ofn.nMaxCustFilter    = 0;
  ofn.nFilterIndex      = 2;
  ofn.lpstrFile         = szFileName;
  ofn.nMaxFile          = MAX_PATH;
  ofn.lpstrFileTitle    = NULL;
  ofn.nMaxFileTitle     = 0;
  ofn.lpstrInitialDir   = NULL;
  ofn.lpstrTitle        = NULL;
  ofn.Flags             = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
  ofn.nFileOffset       = 0;
  ofn.nFileExtension    = 0;
  ofn.lpstrDefExt       = NULL;
  ofn.lCustData         = 0;
  ofn.lpfnHook          = NULL;
  ofn.lpTemplateName    = NULL;

  if (GetOpenFileName(&ofn))
  {
    // Set the filename to a new name
    //
    SetDlgItemText(hDlg,IDC_SCRIPTFILE,szFileName);
    dwRet = ERROR_SUCCESS;
  }
  else
  {
    dwRet = ERROR_OPEN_FAILED;
  };

  LocalFree(pszFiles);
  return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\inetapi.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  INETAPI.C - APIs for external components to use to configure system
//      
//

//  HISTORY:
//  
//  3/9/95    jeremys  Created.
//  96/02/26  markdu  Moved ClearConnectoidIPParams functionality 
//            into CreateConnectoid, so SetPhoneNumber only makes the
//            call to CreateConnectoid
//  96/03/09  markdu  Added LPRASENTRY parameter to CreateConnectoid()
//            and SetPhoneNumber
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Copy phone number info into the RASENTRY struct
//            in SetPhoneNumber().
//  96/03/10  markdu  Set TCP/IP info and autodial info per-connectoid.
//  96/03/21  markdu  Set RASEO flags appropriately.
//  96/03/22  markdu  Validate pointers before using them.
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/03/24  markdu  Replaced lstrcpy with lstrcpyn where appropriate.
//  96/03/25  markdu  Replaced ApplyGlobalTcpInfo with ClearGlobalTcpInfo.
//            and replaced GetGlobalTcpInfo with IsThereGlobalTcpInfo.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//  96/03/26  markdu  Use MAX_ISP_NAME instead of RAS_MaxEntryName 
//            because of bug in RNA.
//  96/04/04  markdu  Added phonebook name param to CreateConnectoid.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/26  markdu  Use lpIcfgTurnOffFileSharing and lpIcfgIsFileSharingTurnedOn,
//            lpIsGlobalDNS and lpIcfgRemoveGlobalDNS.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.
//  96/06/04  markdu  OSR  BUG 7246 If no area code supplied, turn off
//            RASEO_UseCountryAndAreaCodes flag.
//

#include "wizard.h"

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  #include "inetapi.h"

  // avoid name mangling
  VOID WINAPI InetPerformSecurityCheck(HWND hWnd,BOOL * pfNeedRestart);


#define ERROR_ALREADY_DISPLAYED  -1

BOOL ConfigureSystemForInternet_W(LPINTERNET_CONFIG lpInternetConfig,
  BOOL fPromptIfConfigNeeded);

#ifdef __cplusplus
}
#endif // __cplusplus

DWORD SetPhoneNumber(LPTSTR pszEntryName,UINT cbEntryName,LPRASENTRY lpRasEntry,
  PHONENUM * pPhoneNum,
  LPCTSTR pszUserName,LPCTSTR pszPassword,UINT uDefNameID);
INT_PTR CALLBACK SecurityCheckDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL CenterWindow (HWND hwndChild, HWND hwndParent);
BOOL CALLBACK WarningDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
extern ICFGINSTALLSYSCOMPONENTS     lpIcfgInstallInetComponents;
extern ICFGNEEDSYSCOMPONENTS        lpIcfgNeedInetComponents;
extern ICFGISGLOBALDNS              lpIcfgIsGlobalDNS;
extern ICFGREMOVEGLOBALDNS          lpIcfgRemoveGlobalDNS;
extern ICFGTURNOFFFILESHARING       lpIcfgTurnOffFileSharing;
extern ICFGISFILESHARINGTURNEDON    lpIcfgIsFileSharingTurnedOn;
extern ICFGGETLASTINSTALLERRORTEXT  lpIcfgGetLastInstallErrorText;


typedef struct tagWARNINGDLGINFO {
  BOOL fResult;      // TRUE if user chose yes/OK to warning
  BOOL fDisableWarning;  // TRUE if user wants to disable warning in future
} WARNINGDLGINFO;

#ifdef UNICODE
PWCHAR ToUnicodeWithAlloc(LPCSTR);
#endif

/*******************************************************************

  NAME:    ConfigureSystemForInternet

  SYNOPSIS:  Performs all necessary configuration to set system up
        to use Internet.

  ENTRY:    lpInternetConfig - pointer to structure with configuration
        information.

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

        If the output flag ICOF_NEEDREBOOT is set, the caller
        must restart the system before continuing.

  NOTES:    Will install TCP/IP, RNA, PPPMAC as necessary; will
        create or modify an Internet RNA connectoid.

        This API displays error messages itself rather than
        passing back an error code because there is a wide range of
        possible error codes from different families, it is difficult
        for the caller to obtain text for all of them.

        Calls worker function ConfigureSystemForInternet_W.
    
********************************************************************/
#ifdef UNICODE
extern "C" BOOL WINAPI ConfigureSystemForInternetA
(
  LPINTERNET_CONFIGA lpInternetConfig
)
{
    HRESULT  hr;

    LPTSTR pszModemNameW = ToUnicodeWithAlloc(lpInternetConfig->pszModemName);
    LPTSTR pszUserNameW  = ToUnicodeWithAlloc(lpInternetConfig->pszUserName);
    LPTSTR pszPasswordW  = ToUnicodeWithAlloc(lpInternetConfig->pszPassword);
    LPTSTR pszEntryNameW = ToUnicodeWithAlloc(lpInternetConfig->pszEntryName);
    LPTSTR pszEntryName2W = ToUnicodeWithAlloc(lpInternetConfig->pszEntryName2);
    LPTSTR pszDNSServerW = ToUnicodeWithAlloc(lpInternetConfig->pszDNSServer);
    LPTSTR pszDNSServer2W = ToUnicodeWithAlloc(lpInternetConfig->pszDNSServer2);
    LPTSTR pszAutodialDllNameW = ToUnicodeWithAlloc(lpInternetConfig->pszAutodialDllName);
    LPTSTR pszAutodialFcnNameW = ToUnicodeWithAlloc(lpInternetConfig->pszAutodialFcnName);

    INTERNET_CONFIGW InternetConfigW;
    InternetConfigW.cbSize        = sizeof(INTERNET_CONFIGW);
    InternetConfigW.hwndParent    = lpInternetConfig->hwndParent;
    InternetConfigW.pszModemName  = pszModemNameW;
    InternetConfigW.pszUserName   = pszUserNameW;
    InternetConfigW.pszEntryName  = pszEntryNameW;
    InternetConfigW.pszEntryName2 = pszEntryName2W;
    InternetConfigW.pszDNSServer  = pszDNSServerW;
    InternetConfigW.pszDNSServer2 = pszDNSServer2W;
    InternetConfigW.pszAutodialDllName = pszAutodialDllNameW;
    InternetConfigW.pszAutodialFcnName = pszAutodialFcnNameW;
    InternetConfigW.dwInputFlags  = lpInternetConfig->dwInputFlags;
    InternetConfigW.dwOutputFlags = lpInternetConfig->dwOutputFlags;

    InternetConfigW.PhoneNum.dwCountryID = lpInternetConfig->PhoneNum.dwCountryID;
    InternetConfigW.PhoneNum.dwCountryCode = lpInternetConfig->PhoneNum.dwCountryCode;
    mbstowcs(InternetConfigW.PhoneNum.szAreaCode,
             lpInternetConfig->PhoneNum.szAreaCode,
             lstrlenA(lpInternetConfig->PhoneNum.szAreaCode)+1);
    mbstowcs(InternetConfigW.PhoneNum.szLocal,
             lpInternetConfig->PhoneNum.szLocal,
             lstrlenA(lpInternetConfig->PhoneNum.szLocal)+1);
    mbstowcs(InternetConfigW.PhoneNum.szExtension,
             lpInternetConfig->PhoneNum.szExtension,
             lstrlenA(lpInternetConfig->PhoneNum.szExtension)+1);

    InternetConfigW.PhoneNum2.dwCountryID = lpInternetConfig->PhoneNum2.dwCountryID;
    InternetConfigW.PhoneNum2.dwCountryCode = lpInternetConfig->PhoneNum2.dwCountryCode;
    mbstowcs(InternetConfigW.PhoneNum2.szAreaCode,
             lpInternetConfig->PhoneNum2.szAreaCode,
             lstrlenA(lpInternetConfig->PhoneNum2.szAreaCode)+1);
    mbstowcs(InternetConfigW.PhoneNum2.szLocal,
             lpInternetConfig->PhoneNum2.szLocal,
             lstrlenA(lpInternetConfig->PhoneNum2.szLocal)+1);
    mbstowcs(InternetConfigW.PhoneNum2.szExtension,
             lpInternetConfig->PhoneNum2.szExtension,
             lstrlenA(lpInternetConfig->PhoneNum2.szExtension)+1);

    hr = ConfigureSystemForInternetW(&InternetConfigW);

    // Free all allocated WCHAR.
    if(pszModemNameW)
        GlobalFree(pszModemNameW);
    if(pszUserNameW)
        GlobalFree(pszUserNameW);
    if(pszEntryNameW)
        GlobalFree(pszEntryNameW);
    if(pszEntryName2W)
        GlobalFree(pszEntryName2W);
    if(pszDNSServerW)
        GlobalFree(pszDNSServerW);
    if(pszDNSServer2W)
        GlobalFree(pszDNSServer2W);
    if(pszAutodialDllNameW)
        GlobalFree(pszAutodialDllNameW);
    if(pszAutodialFcnNameW)
        GlobalFree(pszAutodialFcnNameW);

    return hr;
}

extern "C" BOOL WINAPI ConfigureSystemForInternetW
#else
extern "C" BOOL WINAPI ConfigureSystemForInternetA
#endif
(
  LPINTERNET_CONFIG lpInternetConfig
)
{
  BOOL fRet;
  // call worker function
  fRet = ConfigureSystemForInternet_W(lpInternetConfig,FALSE);


  if (fRet)
  {
    // make sure "The Internet" icon on desktop points to web browser
    // (it may initially be pointing at internet wizard) (for versions < IE 4)
	
	//	//10/24/96 jmazner Normandy 6968
	//	//No longer neccessary thanks to Valdon's hooks for invoking ICW.
	// 11/21/96 jmazner Normandy 11812
	// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
	// ICW 1.1 needs to morph the IE 3 icon.

    SetDesktopInternetIconToBrowser();
  }

  return fRet;
}


/*******************************************************************

  NAME:    SetInternetPhoneNumber

  SYNOPSIS:  Sets the phone number used to auto-dial to the Internet.

        If the system is not fully configured when this API is called,
        this API will do the configuration after checking with the user.
        (This step is included for extra robustness, in case the user has
        removed something since the system was configured.)
  
  ENTRY:    lpPhonenumConfig - pointer to structure with configuration
        information.

        If the input flag ICIF_NOCONFIGURE is set, then if the system
        is not already configured properly, this API will display an
        error message and return FALSE.  (Otherwise this API will
        ask the user if it's OK to configure the system, and do it.)

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

        If the output flag ICOF_NEEDREBOOT is set, the caller
        must restart the system before continuing.  (

  NOTES:    Will create a new connectoid if a connectoid for the internet
        does not exist yet, otherwise modifies existing internet
        connectoid.

        This API displays error messages itself rather than
        passing back an error code because there is a wide range of
        possible error codes from different families, it is difficult
        for the caller to obtain text for all of them.

        Calls worker function ConfigureSystemForInternet_W.

********************************************************************/
#ifdef UNICODE
extern "C" BOOL WINAPI SetInternetPhoneNumberA
(
  LPINTERNET_CONFIGA lpInternetConfig
)
{
    HRESULT  hr;

    LPTSTR pszModemNameW = ToUnicodeWithAlloc(lpInternetConfig->pszModemName);
    LPTSTR pszUserNameW  = ToUnicodeWithAlloc(lpInternetConfig->pszUserName);
    LPTSTR pszPasswordW  = ToUnicodeWithAlloc(lpInternetConfig->pszPassword);
    LPTSTR pszEntryNameW = ToUnicodeWithAlloc(lpInternetConfig->pszEntryName);
    LPTSTR pszEntryName2W = ToUnicodeWithAlloc(lpInternetConfig->pszEntryName2);
    LPTSTR pszDNSServerW = ToUnicodeWithAlloc(lpInternetConfig->pszDNSServer);
    LPTSTR pszDNSServer2W = ToUnicodeWithAlloc(lpInternetConfig->pszDNSServer2);
    LPTSTR pszAutodialDllNameW = ToUnicodeWithAlloc(lpInternetConfig->pszAutodialDllName);
    LPTSTR pszAutodialFcnNameW = ToUnicodeWithAlloc(lpInternetConfig->pszAutodialFcnName);

    INTERNET_CONFIGW InternetConfigW;
    InternetConfigW.cbSize        = sizeof(INTERNET_CONFIGW);
    InternetConfigW.hwndParent    = lpInternetConfig->hwndParent;
    InternetConfigW.pszModemName  = pszModemNameW;
    InternetConfigW.pszUserName   = pszUserNameW;
    InternetConfigW.pszEntryName  = pszEntryNameW;
    InternetConfigW.pszEntryName2 = pszEntryName2W;
    InternetConfigW.pszDNSServer  = pszDNSServerW;
    InternetConfigW.pszDNSServer2 = pszDNSServer2W;
    InternetConfigW.pszAutodialDllName = pszAutodialDllNameW;
    InternetConfigW.pszAutodialFcnName = pszAutodialFcnNameW;
    InternetConfigW.dwInputFlags  = lpInternetConfig->dwInputFlags;
    InternetConfigW.dwOutputFlags = lpInternetConfig->dwOutputFlags;

    InternetConfigW.PhoneNum.dwCountryID = lpInternetConfig->PhoneNum.dwCountryID;
    InternetConfigW.PhoneNum.dwCountryCode = lpInternetConfig->PhoneNum.dwCountryCode;
    mbstowcs(InternetConfigW.PhoneNum.szAreaCode,
             lpInternetConfig->PhoneNum.szAreaCode,
             lstrlenA(lpInternetConfig->PhoneNum.szAreaCode)+1);
    mbstowcs(InternetConfigW.PhoneNum.szLocal,
             lpInternetConfig->PhoneNum.szLocal,
             lstrlenA(lpInternetConfig->PhoneNum.szLocal)+1);
    mbstowcs(InternetConfigW.PhoneNum.szExtension,
             lpInternetConfig->PhoneNum.szExtension,
             lstrlenA(lpInternetConfig->PhoneNum.szExtension)+1);

    InternetConfigW.PhoneNum2.dwCountryID = lpInternetConfig->PhoneNum2.dwCountryID;
    InternetConfigW.PhoneNum2.dwCountryCode = lpInternetConfig->PhoneNum2.dwCountryCode;
    mbstowcs(InternetConfigW.PhoneNum2.szAreaCode,
             lpInternetConfig->PhoneNum2.szAreaCode,
             lstrlenA(lpInternetConfig->PhoneNum2.szAreaCode)+1);
    mbstowcs(InternetConfigW.PhoneNum2.szLocal,
             lpInternetConfig->PhoneNum2.szLocal,
             lstrlenA(lpInternetConfig->PhoneNum2.szLocal)+1);
    mbstowcs(InternetConfigW.PhoneNum2.szExtension,
             lpInternetConfig->PhoneNum2.szExtension,
             lstrlenA(lpInternetConfig->PhoneNum2.szExtension)+1);

    hr = SetInternetPhoneNumberW(&InternetConfigW);

    // Free all allocated WCHAR.
    if(pszModemNameW)
        GlobalFree(pszModemNameW);
    if(pszUserNameW)
        GlobalFree(pszUserNameW);
    if(pszEntryNameW)
        GlobalFree(pszEntryNameW);
    if(pszEntryName2W)
        GlobalFree(pszEntryName2W);
    if(pszDNSServerW)
        GlobalFree(pszDNSServerW);
    if(pszDNSServer2W)
        GlobalFree(pszDNSServer2W);
    if(pszAutodialDllNameW)
        GlobalFree(pszAutodialDllNameW);
    if(pszAutodialFcnNameW)
        GlobalFree(pszAutodialFcnNameW);

    return hr;
}

extern "C" BOOL WINAPI SetInternetPhoneNumberW
#else
extern "C" BOOL WINAPI SetInternetPhoneNumberA
#endif
(
  LPINTERNET_CONFIG lpInternetConfig
)
{
  // call worker function
  return ConfigureSystemForInternet_W(lpInternetConfig,TRUE);
}

/*******************************************************************

  NAME:    ConfigureSystemForInternet_W

  SYNOPSIS:  worker function to do system configuration for Internet

  ENTRY:    lpInternetConfig - pointer to structure with configuration
          information.

        fPromptIfConfigNeeded - if TRUE, then if any system
          configuration is needed the user will be prompted and
          asked if it's OK to reconfigure the system

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

        If the output flag ICOF_NEEDREBOOT is set, the caller
        must restart the system before continuing.

  NOTES:    Will install TCP/IP, RNA, PPPMAC as necessary; will
        create or modify an Internet RNA connectoid.

        This API displays error messages itself rather than
        passing back an error code because there is a wide range of
        possible error codes from different families, it is difficult
        for the caller to obtain text for all of them.
    
********************************************************************/
BOOL ConfigureSystemForInternet_W(LPINTERNET_CONFIG lpInternetConfig,
  BOOL fPromptIfConfigNeeded)
{
  UINT   uErr=ERROR_SUCCESS,uErrMsgID=IDS_ERRSetPhoneNumber;
  DWORD dwErrCls = ERRCLS_STANDARD;
  BOOL  fNeedDrivers = FALSE;
  BOOL  fRet = FALSE;
  BOOL  fNeedReboot = FALSE;
  TCHAR szEntryName[MAX_ISP_NAME+1]=TEXT("");
  BOOL  fNeedToDeInitRNA = FALSE;
  DWORD dwfInstallOptions;

  DEBUGMSG("inetapi.c::ConfigureSystemForInternet_W()");

  // validate parameters
  ASSERT(lpInternetConfig);
  if (!lpInternetConfig)
    return FALSE;
  ASSERT(lpInternetConfig->cbSize == sizeof(INTERNET_CONFIG));
  if (lpInternetConfig->cbSize != sizeof(INTERNET_CONFIG))
    return FALSE;

  // clear output flags
  lpInternetConfig->dwOutputFlags = 0;

  HWND hwndParent = lpInternetConfig->hwndParent;

  WAITCURSOR WaitCursor;  // set an hourglass cursor

  // Also allocate a RASENTRY struct for connectoid data
  LPRASENTRY  pRasEntry = new RASENTRY;
  ASSERT(pRasEntry);

  if (!pRasEntry)
  {
    // out of memory!
    uErr = ERROR_NOT_ENOUGH_MEMORY;
    dwErrCls = ERRCLS_STANDARD;
    goto exit;
  }

  InitRasEntry(pRasEntry);

  // based on config and preferences, find out if we need to install 
  // drivers/files or not
  dwfInstallOptions = ICFG_INSTALLTCP | ICFG_INSTALLRAS;
  if (!(lpInternetConfig->dwInputFlags & ICIF_NOCONFIGURE))
  {
    uErr = lpIcfgNeedInetComponents(dwfInstallOptions, &fNeedDrivers);

    if (ERROR_SUCCESS != uErr)
    {
      TCHAR   szErrorText[MAX_ERROR_TEXT+1]=TEXT("");
      
      // Get the text of the error message and display it.
      if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
      {
        MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
        uErr = (UINT) ERROR_ALREADY_DISPLAYED;
      }
      goto exit;
    }
  }
  else
  {
    fNeedDrivers = FALSE;
  }

  if (fNeedDrivers && fPromptIfConfigNeeded) {
    // if this API is just getting called to set a new phone number,
    // we check the configuration anyway in case the user has accidentally
    // changed something.  Since we noticed we need to do something
    // to user's config and fPromptIfConfigNeeded is TRUE, we will ask
    // the user if it's OK to change the machine's config.

    if (MsgBox(hwndParent,IDS_OKTOCHANGECONFIG,MB_ICONQUESTION,MB_YESNO)
      != IDYES) {
      // user elected not to have us do necessary setup, so just set
      // fNeedDrivers flag to FALSE so we don't do setup.  We will
      // stil try to set internet phone # below... this may fail
      // if part of the required setup was to do something like install
      // RNA
      fNeedDrivers = FALSE;
    }
  }

  if (fNeedDrivers) {
    // yes, need to install some drivers

    // warn user that we're about to do stuff that may need win 95 disks.
    // also let user cancel this part

    // the message is long and takes up two string resources, allocate
    // memory to build the string
    BUFFER MsgBuf(MAX_RES_LEN*2+1),Msg1(MAX_RES_LEN),Msg2(MAX_RES_LEN);
    ASSERT(MsgBuf);
    ASSERT(Msg1);
    ASSERT(Msg2);
    if (!MsgBuf || !Msg1 || !Msg2) {
      // out of memory!
      uErr = ERROR_NOT_ENOUGH_MEMORY;
      dwErrCls = ERRCLS_STANDARD;
      goto exit;
    }
    LoadSz(IDS_ABOUTTOCHANGECONFIG1,Msg1.QueryPtr(),Msg1.QuerySize());
    LoadSz(IDS_ABOUTTOCHANGECONFIG2,Msg2.QueryPtr(),Msg2.QuerySize());
    wsprintf(MsgBuf.QueryPtr(),Msg1.QueryPtr(),Msg2.QueryPtr());

    if (MsgBoxSz(hwndParent,MsgBuf.QueryPtr(),MB_ICONINFORMATION,
      MB_OKCANCEL) != IDOK) {
      // user cancelled, stop
      uErr = (UINT) ERROR_ALREADY_DISPLAYED;
      goto exit;
    }

    WAITCURSOR WaitCursor;  // construct a wait cursor since MessageBox
                            // destroys the hourglass cursor

    // install the drivers we need
    uErr = lpIcfgInstallInetComponents(hwndParent, dwfInstallOptions, &fNeedReboot);
   
    if (ERROR_SUCCESS != uErr)
    {
      TCHAR   szErrorText[MAX_ERROR_TEXT+1]=TEXT("");
      
      // Get the text of the error message and display it.
      if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
      {
        MsgBoxSz(hwndParent,szErrorText,MB_ICONEXCLAMATION,MB_OK);
        uErr = (UINT) ERROR_ALREADY_DISPLAYED;
      }
      goto exit;
    }

    // set "need reboot" output flag if appropriate
    if (fNeedReboot)
      lpInternetConfig->dwOutputFlags |= ICOF_NEEDREBOOT;
  }

  // MSN dial-in points dynamically assign DNS (as of this writing)... if
  // DNS is set statically in registry, dynamic DNS assignment will not
  // work and user may be hosed.  Check, warn user and offer to remove if
  // set...

  if (!(lpInternetConfig->dwInputFlags & (ICIF_NOCONFIGURE | ICIF_NODNSCHECK))) {
    if (DoDNSCheck(lpInternetConfig->hwndParent,&fNeedReboot)) {
      // set "need reboot" output flag if appropriate
      if (fNeedReboot)
        lpInternetConfig->dwOutputFlags |= ICOF_NEEDREBOOT;
    }
  }

  // create or modify connectoid(s)
  // make sure RNA is loaded
  fRet = InitRNA(hwndParent);
  if (!fRet) {
    uErr = (UINT) ERROR_ALREADY_DISPLAYED;
    goto exit;
  }

  fNeedToDeInitRNA = TRUE;  // set a flag so we know to free RNA later

  // Copy the modem name into the rasentry struct
  if (lpInternetConfig->pszModemName)
  {
    lstrcpyn(pRasEntry->szDeviceName,lpInternetConfig->pszModemName,
      ARRAYSIZE(pRasEntry->szDeviceName));
  }

  // set autodial handler dll if specified by caller
  // only do anything if both DLL and function name are set
  if (lpInternetConfig && lpInternetConfig->pszAutodialDllName && 
    lpInternetConfig->pszAutodialFcnName &&
    lpInternetConfig->pszAutodialDllName[0] &&
    lpInternetConfig->pszAutodialFcnName[0])
  {
    lstrcpyn(pRasEntry->szAutodialDll,lpInternetConfig->pszAutodialDllName,
      ARRAYSIZE(pRasEntry->szAutodialDll));
    lstrcpyn(pRasEntry->szAutodialFunc,lpInternetConfig->pszAutodialFcnName,
      ARRAYSIZE(pRasEntry->szAutodialFunc));
  }

  // Default to not show terminal window after dial.  
  pRasEntry->dwfOptions &= ~RASEO_TerminalAfterDial;    

  // Don't use specific IP addresses.
  pRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;    

  // set DNS information if specified
  if (lpInternetConfig->pszDNSServer && lstrlen(lpInternetConfig->pszDNSServer))
  {
    IPADDRESS dwDNSAddr;
    if (IPStrToLong(lpInternetConfig->pszDNSServer,&dwDNSAddr))
    {
      CopyDw2Ia(dwDNSAddr, &pRasEntry->ipaddrDns);

      // Turn on Specific name servers
      pRasEntry->dwfOptions |= RASEO_SpecificNameServers;    
    }
  }
      
  if (lpInternetConfig->pszDNSServer2 && lstrlen(lpInternetConfig->pszDNSServer2))
  {
    IPADDRESS dwDNSAddr;
    if (IPStrToLong(lpInternetConfig->pszDNSServer2,&dwDNSAddr))
    {
      CopyDw2Ia(dwDNSAddr, &pRasEntry->ipaddrDnsAlt);
    }
  }

  // set first phone number
  // should always have a real phone number for first phone number
  ASSERT(lstrlen(lpInternetConfig->PhoneNum.szLocal));
  if (lstrlen(lpInternetConfig->PhoneNum.szLocal))
  {
    if (lpInternetConfig->pszEntryName)
    {
      lstrcpyn(szEntryName,lpInternetConfig->pszEntryName,
        ARRAYSIZE(szEntryName));
    }
    else
    {
      szEntryName[0] = '\0';
    }

    uErr = SetPhoneNumber(szEntryName,sizeof(szEntryName),pRasEntry,
      &lpInternetConfig->PhoneNum,lpInternetConfig->pszUserName,
      lpInternetConfig->pszPassword,IDS_DEF_CONNECTION_NAME_1);
    dwErrCls = ERRCLS_RNA;

    if (uErr == ERROR_SUCCESS)
    {
      if (!(lpInternetConfig->dwInputFlags & ICIF_DONTSETASINTERNETENTRY))
      {
        // set this number as the number used to autodial to the Internet
        //  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
        InetSetAutodial(TRUE, szEntryName);
      }
    }
  }

  // set 2nd (backup) phone number
  if ((uErr == ERROR_SUCCESS) && (lpInternetConfig->PhoneNum2.szLocal) &&
    (lstrlen(lpInternetConfig->PhoneNum2.szLocal)))
  {
    TCHAR   szEntryNameTmp[MAX_ISP_NAME+1];
    if (lpInternetConfig->pszEntryName2)
    {
      lstrcpyn(szEntryNameTmp,lpInternetConfig->pszEntryName2,
        ARRAYSIZE(szEntryNameTmp));
    }
    else
    {
      szEntryNameTmp[0] = '\0';
    }

    uErr = SetPhoneNumber(szEntryNameTmp,sizeof(szEntryNameTmp),
      pRasEntry,&lpInternetConfig->PhoneNum2,lpInternetConfig->pszUserName,
      lpInternetConfig->pszPassword,IDS_DEF_CONNECTION_NAME_2);
    dwErrCls = ERRCLS_RNA;

    if (uErr == ERROR_SUCCESS)
    {
      if (!(lpInternetConfig->dwInputFlags & ICIF_DONTSETASINTERNETENTRY))
      {
        // set this number as the backup number used to autodial to the Internet
        SetBackupInternetConnectoid(szEntryNameTmp);
      }
    }
  }


exit:
  // free memory
  if (pRasEntry)
    delete pRasEntry;

  // display error message if error occurred
  if (uErr != ERROR_SUCCESS && uErr != ERROR_ALREADY_DISPLAYED) {
    DisplayErrorMessage(hwndParent,uErrMsgID,uErr,dwErrCls,MB_ICONEXCLAMATION);
  }

  // free RNA if need be.  Note we must do this *after* the call to
  // DisplayErrorMessage, because DisplayErrorMessage needs to call RNA
  // to get error description if an RNA error was generated.
  if (fNeedToDeInitRNA) {
    DeInitRNA();
  }

  return (uErr == ERROR_SUCCESS);
}

/*******************************************************************

  NAME:    SetPhoneNumber

  SYNOPSIS:  Creates or modifies a connectoid with specified information

  ENTRY:    pszEntryName - name to use for the connectoid.  If empty, the
          default name stored in string resource specified by
          uDefNameID will be used.  On exit, this buffer is filled
          in with the actual name used.
        cbEntryName - size of buffer pointed to by szEntryName
        pPhoneNum - pointer to struct with phone number
        pszUserName - user name to populate connectoid with.  Ignored
          if NULL.
        pszPassword - password to populate connectoid with.  Ignored
          if NULL.
        uDefNameID - ID of string resource with default name to use
          if pszEntryName is NULL.

  EXIT:    returns an RNA error code

  NOTES:    This is a wrapper to call CreateConnectoid, to avoid duplicating
        code to load default name out of resource.

        Since the pszEntryName buffer is filled at exit with the
        actual name used, callers should be careful not to pass in buffers
        from API callers, since apps using API won't expect their own
        buffers to be modified.

********************************************************************/
DWORD SetPhoneNumber(LPTSTR pszEntryName,UINT cbEntryName,
  LPRASENTRY lpRasEntry, PHONENUM * pPhoneNum,
  LPCTSTR pszUserName,LPCTSTR pszPassword,UINT uDefNameID)
{
  ASSERT(pszEntryName);
  ASSERT(pPhoneNum);  
  ASSERT(lpRasEntry);  
  // (all other parameters may be  NULL)

  // if a connectoid name was specified, use it; if NULL, use a default
  // name.
  if (!lstrlen(pszEntryName))
  {
    LoadSz(uDefNameID,pszEntryName,cbEntryName);
  }

  // 96/06/04 markdu  OSR  BUG 7246
  // If no area code was specified, turn off area code flag
	if (lstrlen(pPhoneNum->szAreaCode))
	{
    lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
	}
  else
	{
    lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;
	}


  // copy the phone number data
  lpRasEntry->dwCountryID = pPhoneNum->dwCountryID;
  lpRasEntry->dwCountryCode = pPhoneNum->dwCountryCode;
  lstrcpyn (lpRasEntry->szAreaCode, pPhoneNum->szAreaCode,
     ARRAYSIZE(lpRasEntry->szAreaCode));
  lstrcpyn (lpRasEntry->szLocalPhoneNumber, pPhoneNum->szLocal,
     ARRAYSIZE(lpRasEntry->szLocalPhoneNumber));

  // create/update the connectoid
  DWORD dwRet = CreateConnectoid(NULL, pszEntryName,lpRasEntry,
    pszUserName,pszPassword);

  return dwRet;
}


/*******************************************************************

  NAME:    InetPerformSecurityCheck

  SYNOPSIS:  Checks to make sure win 95 file/print sharing is not
        bound to TCP/IP used for the internet

    ENTRY:    hWnd - parent window (if any)
        pfNeedRestart - on exit, set to TRUE if restart is needed.

  NOTES:    If we warn user about file/print sharing and user tells us
        to fix, then a reboot is necessary.  Caller is responsible
        for checking *pfNeedRestart on return and restarting system
        if necessary.

********************************************************************/
VOID WINAPI InetPerformSecurityCheck(HWND hWnd,BOOL * pfNeedRestart)
{
  ASSERT(pfNeedRestart);
  *pfNeedRestart = FALSE;

  // see if the server is bound to internet instance
  BOOL  fSharingOn;
  HRESULT hr = lpIcfgIsFileSharingTurnedOn(INSTANCE_PPPDRIVER, &fSharingOn);

  //
  // 5/12/97 jmazner Olympus #3442  IE #30886
  // TEMP TODO at the moment, icfgnt doesn't implement FileSharingTurnedOn
  // Until it does, assume that on NT file sharing is always off.
  //
  if( IsNT() )
  {
	  DEBUGMSG("Ignoring return code from IcfgIsFileSharingTurnedOn");
	  fSharingOn = FALSE;
  }


  if ((ERROR_SUCCESS == hr) && (TRUE == fSharingOn))
  {
    // ask user if we can disable file/print sharing on TCP/IP instance
    // to the Internet
    BOOL fRet=(BOOL)DialogBox(ghInstance,MAKEINTRESOURCE(IDD_SECURITY_CHECK),
      hWnd,SecurityCheckDlgProc);

    if (fRet) {
      // user OK'd it, go ahead and unbind the server from the instance
      // in question
      HRESULT hr = lpIcfgTurnOffFileSharing(INSTANCE_PPPDRIVER, hWnd);
      ASSERT(hr == ERROR_SUCCESS);

      if (hr == ERROR_SUCCESS) {
        // we need to restart for the changes to take effect
        *pfNeedRestart = TRUE;
      }
    }
  }
}

/*******************************************************************

  NAME:    SecurityCheckDlgProc

  SYNOPSIS:  Dialog proc for security check dialog

  NOTES:    This is basically just a yes/no dialog, so we could
        almost just use MessageBox, except we also need a "don't
        do this any more" checkbox.

********************************************************************/
INT_PTR CALLBACK SecurityCheckDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  switch (uMsg) {

    case WM_INITDIALOG:
      CenterWindow(hDlg,GetDesktopWindow());
      SetFocus(GetDlgItem(hDlg,IDOK));
      return TRUE;
      break;

    case WM_COMMAND:

      switch (wParam) {

        case IDOK:
          // dismiss the dialog
          EndDialog(hDlg,TRUE);

          break;

        case IDCANCEL:
          // if "don't display this in the future" is checked, then
          // turn off registry switch for security check
          if (IsDlgButtonChecked(hDlg,IDC_DISABLE_CHECK)) {
            RegEntry re(szRegPathInternetSettings,HKEY_CURRENT_USER);
            ASSERT(re.GetError() == ERROR_SUCCESS);
            if (re.GetError() == ERROR_SUCCESS) {
              re.SetValue(szRegValEnableSecurityCheck,
                (DWORD) 0 );
              ASSERT(re.GetError() == ERROR_SUCCESS);
            }
          }

          // dismiss the dialog          
          EndDialog(hDlg,FALSE);
          break;

        case IDC_DISABLE_CHECK:

          // if "don't do this in the future" is checked, then
          // disable 'OK' button
          EnableDlgItem(hDlg,IDOK,!IsDlgButtonChecked(hDlg,
            IDC_DISABLE_CHECK));

          break;

      }
      break;
      
  }

  return FALSE;
}

/****************************************************************************

  FUNCTION: CenterWindow (HWND, HWND)

  PURPOSE:  Center one window over another

  COMMENTS:

  Dialog boxes take on the screen position that they were designed at,
  which is not always appropriate. Centering the dialog over a particular
  window usually results in a better position.

****************************************************************************/
BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
  RECT    rChild, rParent;
  int     wChild, hChild, wParent, hParent;
  int     wScreen, hScreen, xNew, yNew;
  HDC     hdc;

  // Get the Height and Width of the child window
  GetWindowRect (hwndChild, &rChild);
  wChild = rChild.right - rChild.left;
  hChild = rChild.bottom - rChild.top;

  // Get the Height and Width of the parent window
  GetWindowRect (hwndParent, &rParent);
  wParent = rParent.right - rParent.left;
  hParent = rParent.bottom - rParent.top;

  // Get the display limits
  hdc = GetDC (hwndChild);
  wScreen = GetDeviceCaps (hdc, HORZRES);
  hScreen = GetDeviceCaps (hdc, VERTRES);
  ReleaseDC (hwndChild, hdc);

  // Calculate new X position, then adjust for screen
  xNew = rParent.left + ((wParent - wChild) /2);
  if (xNew < 0) {
    xNew = 0;
  } else if ((xNew+wChild) > wScreen) {
    xNew = wScreen - wChild;
  }

  // Calculate new Y position, then adjust for screen
  yNew = rParent.top  + ((hParent - hChild) /2);
  if (yNew < 0) {
    yNew = 0;
  } else if ((yNew+hChild) > hScreen) {
    yNew = hScreen - hChild;
  }

  // Set it, and return
  return SetWindowPos (hwndChild, NULL,
    xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}

/*******************************************************************

  NAME:    DoDNSCheck

  SYNOPSIS:  Checks to see if DNS is configured statically in the
        registry.  If it is, then displays a dialog offering
        to remove it, and removes it if user chooses.

  ENTRY:    hwndParent - parent window
        pfNeedRestart - filled in on exit with TRUE if restart
          is necessary, FALSE otherwise

  NOTES:    Need to do this to work around Win 95 bug where
        dynamically assigned DNS servers are ignored if static
        DNS servers are set.

        Note that the UI is MSN specific and contains MSN
        references!

********************************************************************/
BOOL DoDNSCheck(HWND hwndParent,BOOL * pfNeedRestart)
{
  ASSERT(pfNeedRestart);
  *pfNeedRestart = FALSE;

/******** ChrisK 10/24/96 Normandy 3722 - see bug for LONG discussion on this
  // see if this warning has already been disabled
  RegEntry re(szRegPathWarningFlags,HKEY_CURRENT_USER);
  if (re.GetError() == ERROR_SUCCESS) {
    if (re.GetNumber(szRegValDisableDNSWarning,0) > 0) {
      // user has asked for warning to be disabled, nothing to do
      return TRUE;
    }
  }

  // if there are DNS servers set statically (e.g. in net setup),
  // warn the user and ask if we should remove
  BOOL  fGlobalDNS;
  HRESULT hr = lpIcfgIsGlobalDNS(&fGlobalDNS);

  if ((ERROR_SUCCESS == hr) && (TRUE == fGlobalDNS))
  {
    WARNINGDLGINFO WarningDlgInfo;
    ZeroMemory(&WarningDlgInfo,sizeof(WARNINGDLGINFO));

    DialogBoxParam(ghInstance,MAKEINTRESOURCE(IDD_DNS_WARNING),
      hwndParent,WarningDlgProc,(LPARAM) &WarningDlgInfo);

    // one field or the other can be TRUE, but not both...
    ASSERT(!(WarningDlgInfo.fResult && WarningDlgInfo.fDisableWarning));
    if (WarningDlgInfo.fResult)
    {
      // remove static DNS servers from registry
      HRESULT hr = lpIcfgRemoveGlobalDNS();
      ASSERT(hr == ERROR_SUCCESS);
      if (hr != ERROR_SUCCESS)
      {
        DisplayErrorMessage(hwndParent,IDS_ERRWriteDNS,hr,
          ERRCLS_STANDARD,MB_ICONEXCLAMATION);
      }
      else
      {
        *pfNeedRestart = TRUE;
      }

    }
    else if (WarningDlgInfo.fDisableWarning)
    {
      // disable warning switch in registry
      re.SetValue(szRegValDisableDNSWarning,(DWORD) TRUE);
    }
  }
ChrisK 10/24/96 Normandy 3722 - see bug for LONG discussion on this ********/
  return TRUE;
}


/*******************************************************************

  NAME:    WarningDlgProc

  SYNOPSIS:  Dialog proc for DNS warning dialog

********************************************************************/
BOOL CALLBACK WarningDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  WARNINGDLGINFO * pWarningDlgInfo;

  switch (uMsg) {
    case WM_INITDIALOG:
      // center dialog on screen if we're not owned
      if (!GetParent(hDlg)) {
        CenterWindow(hDlg,GetDesktopWindow());
      }
      SetFocus(GetDlgItem(hDlg,IDOK));

      // lParam should point to WARNINGDLGINFO struct
      ASSERT(lParam);
      if (!lParam)
        return FALSE;
      // store pointer in window data
      SetWindowLongPtr(hDlg,DWLP_USER,lParam);
      return TRUE;
      break;

    case WM_COMMAND:

      pWarningDlgInfo = (WARNINGDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
      ASSERT(pWarningDlgInfo);

      switch (wParam) {

        case IDOK:
          pWarningDlgInfo->fResult=TRUE;
          pWarningDlgInfo->fDisableWarning=FALSE;
          EndDialog(hDlg,TRUE);
          break;


        case IDC_CANCEL:
          pWarningDlgInfo->fResult=FALSE;
          pWarningDlgInfo->fDisableWarning=
            IsDlgButtonChecked(hDlg,IDC_DISABLE_WARNING);
          EndDialog(hDlg,FALSE);
          break;


        case IDC_DISABLE_WARNING:
          // when 'disable warning' is checked, disable the 'yes'
          // button
          EnableDlgItem(hDlg,IDOK,!IsDlgButtonChecked(hDlg,
            IDC_DISABLE_WARNING));
          break;

      }
  }

  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\mailui.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  MAILUI.C - Functions for mail/newsgroup configuration UI
//      
//

//  HISTORY:
//  
//  1/9/95    jeremys  Created.
//  96/03/25  markdu  If a fatal error occurs, set gfQuitWizard.
//  96/03/26  markdu  Store values from UI even when back is pressed.
//  96/04/06  markdu  Moved CommitConfigurationChanges call to last page.
//  96/05/06  markdu  NASH BUG 15637 Removed unused code.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//

#include "wizard.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"

// Local types for parsing proxy settings
typedef enum {
    INTERNET_SCHEME_DEFAULT,
    INTERNET_SCHEME_FTP,
    INTERNET_SCHEME_GOPHER,
    INTERNET_SCHEME_HTTP,
    INTERNET_SCHEME_HTTPS,
    INTERNET_SCHEME_SOCKS,
    INTERNET_SCHEME_UNKNOWN
} INTERNET_SCHEME;

typedef enum {
    STATE_START,
    STATE_PROTOCOL,
    STATE_SCHEME,
    STATE_SERVER,
    STATE_PORT,
    STATE_END,
    STATE_ERROR
} PARSER_STATE;

typedef struct {
    LPTSTR SchemeName;
    DWORD SchemeLength;
    INTERNET_SCHEME SchemeType;
    DWORD dwControlId;
    DWORD dwPortControlId;
} URL_SCHEME;

const URL_SCHEME UrlSchemeList[] = {
    TEXT("http"),   4,  INTERNET_SCHEME_HTTP,   IDC_PROXYHTTP,  IDC_PORTHTTP,
    TEXT("https"),  5,  INTERNET_SCHEME_HTTPS,  IDC_PROXYSECURE,IDC_PORTSECURE,
    TEXT("ftp"),    3,  INTERNET_SCHEME_FTP,    IDC_PROXYFTP,   IDC_PORTFTP,
    TEXT("gopher"), 6,  INTERNET_SCHEME_GOPHER, IDC_PROXYGOPHER,IDC_PORTGOPHER,
    TEXT("socks"),  5,  INTERNET_SCHEME_SOCKS,  IDC_PROXYSOCKS, IDC_PORTSOCKS,
    NULL,           0,  INTERNET_SCHEME_DEFAULT,0,0
};

typedef struct tagNEWPROFILEDLGINFO
{
  HWND hwndCombo;    // hwnd of combo box on parent dialog
  TCHAR szNewProfileName[cchProfileNameMax+1];  // return buffer for chosen name
} NEWPROFILEDLGINFO;

const TCHAR cszLocalString[] = TEXT("<local>");

#define GET_TERMINATOR(string) \
    while(*string != '\0') string++

#define ERROR_SERVER_NAME 4440
#define ERROR_PORT_NUM    4441
#define INTERNET_MAX_PORT_LENGTH    sizeof(TEXT("123456789"))

VOID EnableProxyControls(HWND hDlg);
VOID ReplicatePROXYHTTP(HWND hDlg, BOOL bSaveOrig);
VOID ReplicatePORTHTTP(HWND hDlg, BOOL bSaveOrig);
BOOL ParseProxyInfo(HWND hDlg, LPTSTR lpszProxy);
BOOL ParseEditCtlForPort(
    IN OUT LPTSTR   lpszProxyName,
    IN HWND    hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId
    );
DWORD FormatOutProxyEditCtl(
    IN HWND    hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId,
    OUT LPTSTR      lpszOutputStr,
    IN OUT LPDWORD lpdwOutputStrSize,
    IN DWORD       dwOutputStrLength,
    IN BOOL    fDefaultProxy
    );
BOOL RemoveLocalFromExceptionList(LPTSTR lpszExceptionList);
INT_PTR CALLBACK NewProfileDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL NewProfileDlgInit(HWND hDlg,NEWPROFILEDLGINFO * pNewProfileDlgInfo);
BOOL NewProfileDlgOK(HWND hDlg,NEWPROFILEDLGINFO * pNewProfileDlgInfo);
BOOL DoNewProfileDlg(HWND hDlg);

TCHAR gszHttpProxy   [MAX_URL_STRING+1]               = TEXT("\0");
TCHAR gszHttpPort    [INTERNET_MAX_PORT_LENGTH+1]     = TEXT("\0");
TCHAR gszSecureProxy [MAX_URL_STRING+1]               = TEXT("\0");
TCHAR gszSecurePort  [INTERNET_MAX_PORT_LENGTH+1]     = TEXT("\0");
TCHAR gszFtpProxy    [MAX_URL_STRING+1]               = TEXT("\0");
TCHAR gszFtpPort     [INTERNET_MAX_PORT_LENGTH+1]     = TEXT("\0");
TCHAR gszGopherProxy [MAX_URL_STRING+1]               = TEXT("\0");
TCHAR gszGopherPort  [INTERNET_MAX_PORT_LENGTH+1]     = TEXT("\0");

/*******************************************************************

  NAME:    UseProxyInitProc

  SYNOPSIS:  Called when Use Proxy page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK UseProxyInitProc(HWND hDlg,BOOL fFirstInit)
{
    if (fFirstInit)
    {
        //
        // 6/6/97 jmazner Olympus #5413
        // tweak positioning to hack around win95 J display bug
        //
        Win95JMoveDlgItem( hDlg, GetDlgItem(hDlg,IDC_NOTE), 15 );

        CheckDlgButton(hDlg,IDC_USEPROXY,gpUserInfo->fProxyEnable);
        CheckDlgButton(hDlg,IDC_NOUSEPROXY,!gpUserInfo->fProxyEnable);
    }

    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_USEPROXY;

    return TRUE;
}
        
/*******************************************************************

  NAME:    UseProxyOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from Use Proxy page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK UseProxyOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
    ASSERT(puNextPage);

    gpUserInfo->fProxyEnable = IsDlgButtonChecked(hDlg,IDC_USEPROXY);

    if (fForward)
    {
        if (gpUserInfo->fProxyEnable)
            *puNextPage = ORD_PAGE_SETUP_PROXY;//ORD_PAGE_PROXYSERVERS;
        else
        {
              if( LoadAcctMgrUI(GetParent(hDlg), 
                                g_fIsWizard97 ? IDD_PAGE_USEPROXY97 : IDD_PAGE_USEPROXY, 
                                g_fIsWizard97 ? IDD_PAGE_CONNECTEDOK97FIRSTLAST : IDD_PAGE_CONNECTEDOK,
                                g_fIsWizard97 ? WIZ_USE_WIZARD97 : 0) )
              {
                  if( DialogIDAlreadyInUse( g_uAcctMgrUIFirst) )
                  {
                      // we're about to jump into the external apprentice, and we don't want
                      // this page to show up in our history list
                      *pfKeepHistory = FALSE;

                      *puNextPage = g_uAcctMgrUIFirst;
                  }
                  else
                  {
                      DEBUGMSG("hmm, the first acctMgr dlg id is supposedly %d, but it's not marked as in use!",
                                g_uAcctMgrUIFirst);
                      *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);
                  }
              }
              else
              {
                  DEBUGMSG("LoadAcctMgrUI returned false, guess we'd better skip over it!");
                  *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);

              }
        }

    }

    return TRUE;
}

/*******************************************************************

  NAME:    UseProxyCmdProc

  SYNOPSIS:  Called when dlg control pressed on page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
********************************************************************/
BOOL CALLBACK UseProxyCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam)
{
     switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
    {
        case BN_DBLCLK:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_USEPROXY: 
                case IDC_NOUSEPROXY:
                {
		            // somebody double-clicked a radio button
		            // auto-advance to the next page
		            PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                    break;
                }
            }
		    break;
        }
    }
    return TRUE;
}

/*******************************************************************

  NAME:    ProxyServersInitProc

  SYNOPSIS:  Called when proxy servers page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ProxyServersInitProc(HWND hDlg,BOOL fFirstInit)
{
    if (fFirstInit)
    {
        //
        // 6/6/97 jmazner Olympus #5413
        // tweak positioning to hack around win95 J display bug
        //

        // 15/09/98 vyung
        // Test team find that this introduces a tab order bug
        // The Win95 J bug is not repro, so this is removed
        // Win95JMoveDlgItem( hDlg, GetDlgItem(hDlg,IDC_NOTE), 15 );
        // Win95JMoveDlgItem( hDlg, GetDlgItem(hDlg,IDC_PROXYSAME), 160 );

        // limit text fields appropriately
        // 31/10/98 vyung 
        // IE CPL removes the text limit on the edit boxes, do so here.
        //
        /*
        SendDlgItemMessage(hDlg,IDC_PROXYHTTP,EM_LIMITTEXT,MAX_URL_STRING,0L);
        SendDlgItemMessage(hDlg,IDC_PROXYSECURE,EM_LIMITTEXT,MAX_URL_STRING,0L);
        SendDlgItemMessage(hDlg,IDC_PROXYFTP,EM_LIMITTEXT,MAX_URL_STRING,0L);
        SendDlgItemMessage(hDlg,IDC_PROXYGOPHER,EM_LIMITTEXT,MAX_URL_STRING,0L);
        SendDlgItemMessage(hDlg,IDC_PROXYSOCKS,EM_LIMITTEXT,MAX_URL_STRING,0L);

        SendDlgItemMessage(hDlg,IDC_PORTHTTP,EM_LIMITTEXT,INTERNET_MAX_PORT_LENGTH,0L);
        SendDlgItemMessage(hDlg,IDC_PORTSECURE,EM_LIMITTEXT,INTERNET_MAX_PORT_LENGTH,0L);
        SendDlgItemMessage(hDlg,IDC_PORTFTP,EM_LIMITTEXT,INTERNET_MAX_PORT_LENGTH,0L);
        SendDlgItemMessage(hDlg,IDC_PORTGOPHER,EM_LIMITTEXT,INTERNET_MAX_PORT_LENGTH,0L);
        SendDlgItemMessage(hDlg,IDC_PORTSOCKS,EM_LIMITTEXT,INTERNET_MAX_PORT_LENGTH,0L);
        */
        ParseProxyInfo(hDlg,gpUserInfo->szProxyServer);
    }

    EnableProxyControls(hDlg);

    return TRUE;
}

/*******************************************************************

  NAME:    ProxyServersOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from proxy server page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ProxyServersOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
    ASSERT(puNextPage);

    DWORD dwProxyServerLen;
    DWORD dwErr;

    TCHAR  szNewProxyString[MAX_REG_LEN+1];

    if (fForward)
    {
        // jmazner 11/9/96 Normandy #6937
        // clear out previous contents of gpUserInfo->szProxyServer
        // before we start filling in the new contents
        //
        // 7/10/97 jmazner Olympus #9365
        // we want to preserve the orginial proxy string, so use a copy for
        // the call to FormatOytProxyEditCtl
        //

        ZeroMemory(szNewProxyString,sizeof(szNewProxyString));

        if (IsDlgButtonChecked(hDlg, IDC_PROXYSAME))
        {
            dwProxyServerLen = 0;
            dwErr = FormatOutProxyEditCtl(hDlg,IDC_PROXYHTTP,IDC_PORTHTTP,
                szNewProxyString,
                &dwProxyServerLen,
                sizeof(szNewProxyString),
                TRUE);
            if (ERROR_SUCCESS != dwErr)
            {
                if (ERROR_PORT_NUM == dwErr)
                    DisplayFieldErrorMsg(hDlg,IDC_PORTHTTP,IDS_INVALID_PORTNUM);
                else 
                    DisplayFieldErrorMsg(hDlg,IDC_PROXYHTTP,IDS_ERRProxyRequired);
                return FALSE;
            }
        }
        else
        {
            dwProxyServerLen = 0;
            int i = 0;
            while (UrlSchemeList[i].SchemeLength)
            {
                dwErr = FormatOutProxyEditCtl(hDlg,
                    UrlSchemeList[i].dwControlId,
                    UrlSchemeList[i].dwPortControlId,
                    szNewProxyString,
                    &dwProxyServerLen,
                    sizeof(szNewProxyString),
                    FALSE);

                switch( dwErr )
                {
                    case ERROR_SUCCESS:
                    case ERROR_SERVER_NAME:
                        break;
                    case ERROR_PORT_NUM:
                        DisplayFieldErrorMsg(hDlg,UrlSchemeList[i].dwPortControlId,IDS_INVALID_PORTNUM);
                        return FALSE;
                    case ERROR_NOT_ENOUGH_MEMORY:
                        MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
                        return FALSE;
                }
                i++;
            }

            //
            // 6/2/97   jmazner Olympus #4411
            // Allow some proxy servers to be null.  Only warn if no server
            // names were entered.
            //
            if( 0 == lstrlen(szNewProxyString) )
            {
                DisplayFieldErrorMsg(hDlg,IDC_PROXYHTTP,IDS_ERRProxyRequired);
                return FALSE;
            }
        }

        //
        // if we made it this far, then the new proxy settings are valid, so
        // now copy them back into the main data structure.
        //
        lstrcpyn(gpUserInfo->szProxyServer, szNewProxyString, ARRAYSIZE(gpUserInfo->szProxyServer));

        *puNextPage = ORD_PAGE_PROXYEXCEPTIONS;
    }

    return TRUE;
}

/*******************************************************************

  NAME:    ProxyServersCmdProc

  SYNOPSIS:  Called when dlg control pressed on page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
********************************************************************/
BOOL CALLBACK ProxyServersCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam)
{   
  switch (GET_WM_COMMAND_ID(wParam, lParam))
  {
    case IDC_PROXYSAME:
      // checkbox state changed, enable controls appropriately
      EnableProxyControls(hDlg);
      break;
    case IDC_PROXYHTTP:
    case IDC_PORTHTTP:

      if ( GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS )
      {
          // if heckbox state enabled, populate info but don't save it
          if (IsDlgButtonChecked(hDlg,IDC_PROXYSAME))
          {
              ReplicatePROXYHTTP(hDlg, FALSE);
              ReplicatePORTHTTP(hDlg, FALSE);
          }
      }

      break;
  }

  return TRUE;
}

/*******************************************************************

  NAME:    SetupProxyInitProc

  SYNOPSIS:  Called when proxy servers page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK SetupProxyInitProc(HWND hDlg,BOOL fFirstInit)
{
    if (fFirstInit)
    {
        TCHAR szTemp[MAX_RES_LEN*2];
        LoadString(ghInstance, IDS_SETUP_PROXY_INTRO, szTemp, MAX_RES_LEN*2);
        SetWindowText(GetDlgItem(hDlg, IDC_AUTODISCOVERY_TEXT), szTemp);
        // Set the auto discovery check box
        if (gpUserInfo->bAutoDiscovery)
            CheckDlgButton(hDlg,IDC_AUTODISCOVER, BST_CHECKED);

        // Set the autoconfig URL text box
        SetWindowText(GetDlgItem(hDlg, IDC_CONFIG_ADDR),
                      gpUserInfo->szAutoConfigURL);

        // Set the Auto config URL checkbox
        CheckDlgButton(hDlg,IDC_CONFIGSCRIPT, gpUserInfo->bAutoConfigScript ? BST_CHECKED : BST_UNCHECKED);
        EnableWindow(GetDlgItem(hDlg, IDC_CONFIGADDR_TX), gpUserInfo->bAutoConfigScript);
        EnableWindow(GetDlgItem(hDlg, IDC_CONFIG_ADDR), gpUserInfo->bAutoConfigScript);
        
        // Set the manual checkbox
        CheckDlgButton(hDlg,IDC_MANUAL_PROXY,gpUserInfo->fProxyEnable);
    }
    gpWizardState->uCurrentPage = ORD_PAGE_SETUP_PROXY;
    return TRUE;
}


/*******************************************************************

  NAME:     SetupProxyOKProc

  SYNOPSIS: Called when Next or Back btns pressed from proxy server page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK SetupProxyOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
    ASSERT(puNextPage);
    if (fForward && gpUserInfo)
    {
        // modify setting, later write to registry
        gpUserInfo->bAutoDiscovery = IsDlgButtonChecked(hDlg, IDC_AUTODISCOVER);

        gpUserInfo->bAutoConfigScript = IsDlgButtonChecked(hDlg, IDC_CONFIGSCRIPT);
        if (gpUserInfo->bAutoConfigScript)
        {
            GetWindowText(GetDlgItem(hDlg, IDC_CONFIG_ADDR),
                          gpUserInfo->szAutoConfigURL,
                          MAX_URL_STRING+1);
        }

        gpUserInfo->fProxyEnable = IsDlgButtonChecked(hDlg, IDC_MANUAL_PROXY);
        if (gpUserInfo->fProxyEnable)
        {
            *puNextPage = ORD_PAGE_PROXYSERVERS;
        }
        else 
        {

            if( LoadAcctMgrUI(GetParent(hDlg), 
                                 g_fIsWizard97 ? IDD_PAGE_SETUP_PROXY97 : IDD_PAGE_SETUP_PROXY, 
                                 g_fIsWizard97 ? IDD_PAGE_CONNECTEDOK97FIRSTLAST : IDD_PAGE_CONNECTEDOK, 
                                 g_fIsWizard97 ? WIZ_USE_WIZARD97 : 0) )
            {
              if( DialogIDAlreadyInUse( g_uAcctMgrUIFirst) )
              {
                  // we're about to jump into the external apprentice, and we don't want
                  // this page to show up in our history list
                  *pfKeepHistory = FALSE;

                  *puNextPage = g_uAcctMgrUIFirst;
              }
              else
              {
                  DEBUGMSG("hmm, the first acctMgr dlg id is supposedly %d, but it's not marked as in use!",
                            g_uAcctMgrUIFirst);
                  *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);
              }
            }
            else
            {
              DEBUGMSG("LoadAcctMgrUI returned false, guess we'd better skip over it!");
              *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);

            }

        }
    }
    return TRUE;
}

/*******************************************************************

  NAME:    SetupProxyCmdProc

  SYNOPSIS:  Called when dlg control pressed on page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
********************************************************************/
BOOL CALLBACK SetupProxyCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam)
{   
  switch (GET_WM_COMMAND_ID(wParam, lParam))
  {
    case IDC_CONFIGSCRIPT:
        {
            BOOL bChecked = IsDlgButtonChecked(hDlg, IDC_CONFIGSCRIPT);
            EnableWindow(GetDlgItem(hDlg, IDC_CONFIGADDR_TX), bChecked);
            EnableWindow(GetDlgItem(hDlg, IDC_CONFIG_ADDR), bChecked);
        }
        break;
  }

  return TRUE;
}

/*******************************************************************

  NAME:    EnableProxyControls

  SYNOPSIS:  Enables edit controls on Proxy Server page depending on
        whether or not 'use proxy...' checkbox is checked.

********************************************************************/
VOID EnableProxyControls(HWND hDlg)
{
  static BOOL fDifferentProxies = TRUE;
  BOOL fChanged = TRUE;

  fChanged = ( fDifferentProxies != !IsDlgButtonChecked(hDlg,IDC_PROXYSAME) );
  fDifferentProxies = !IsDlgButtonChecked(hDlg,IDC_PROXYSAME);

  EnableDlgItem(hDlg,IDC_TX_PROXYSECURE,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PROXYSECURE,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PORTSECURE,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_TX_PROXYFTP,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PROXYFTP,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PORTFTP,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_TX_PROXYGOPHER,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PROXYGOPHER,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PORTGOPHER,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_TX_PROXYSOCKS,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PROXYSOCKS,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PORTSOCKS,fDifferentProxies);

  if( fChanged )
  {
      if( !fDifferentProxies )
      {
          //
          // 7/10/97 jmazner Olympus #9365
          // behave more like IE's proxy property sheet, copy the http
          // settings to all other fields except SOCKS, which should be empty.
          //
          ReplicatePROXYHTTP(hDlg, TRUE);
          ReplicatePORTHTTP(hDlg, TRUE);
      }
      else
      {
          //
          // reload the current settings for all protocols.  First, however,
          // make a copy of any changes the user has made to http, then write
          // that back in after reloading the defaults.
          //
          TCHAR szHttpProxy[MAX_URL_STRING+1];
          TCHAR szHttpPort[INTERNET_MAX_PORT_LENGTH+1];
          GetDlgItemText(hDlg, IDC_PROXYHTTP, szHttpProxy, MAX_URL_STRING);
          GetDlgItemText(hDlg, IDC_PORTHTTP, szHttpPort, INTERNET_MAX_PORT_LENGTH);

          //
          // ParseProxyInfo will only update the PORT field if port info is
          // currently stored in the string.  So clear out the PORT fields
          // ahead of time and let ParseProxyInfo fill them in as needed.
          //
          SetDlgItemText( hDlg, IDC_PORTSECURE, gszSecurePort );
          SetDlgItemText( hDlg, IDC_PORTFTP, gszFtpPort );
          SetDlgItemText( hDlg, IDC_PORTGOPHER, gszGopherPort );

          // 09/10/98 The behaviour of IE has changed.  IE's proxy property
          // sheet will blank all fields.
          SetDlgItemText( hDlg, IDC_PROXYSECURE, gszSecureProxy );
          SetDlgItemText( hDlg, IDC_PROXYFTP, gszFtpProxy );
          SetDlgItemText( hDlg, IDC_PROXYGOPHER, gszGopherProxy );

          ParseProxyInfo(hDlg,gpUserInfo->szProxyServer);

          SetDlgItemText( hDlg, IDC_PROXYHTTP, szHttpProxy );
          SetDlgItemText( hDlg, IDC_PORTHTTP, szHttpPort );

          //
          // ParseProxyInfo may also check the PROXYSAME, so disable it here
          // for good measure.
          //
          CheckDlgButton( hDlg, IDC_PROXYSAME, FALSE );
      }
  }

}

//+----------------------------------------------------------------------------
//
//  Function:   ReplicatePROXYHTTP
//
//  Synopsis:   copies the value in the IDC_PROXYHTTP edit box to the all other
//              proxy name fields except for IDC_SOCKS
//
//  Arguments:  hDlg -- handle to dialog window which owns the controls
//              bSaveOrig -- save original info 
//
//  Returns:    none
//
//  History:    7/10/97 jmazner created for Olympus #9365
//
//-----------------------------------------------------------------------------
void ReplicatePROXYHTTP( HWND hDlg, BOOL bSaveOrig)
{
    TCHAR szHttpProxy[MAX_URL_STRING];

    GetDlgItemText(hDlg, IDC_PROXYHTTP, szHttpProxy, MAX_URL_STRING);

    if (bSaveOrig)
    {
        GetDlgItemText(hDlg, IDC_PROXYSECURE, gszSecureProxy, MAX_URL_STRING);
        GetDlgItemText(hDlg, IDC_PROXYFTP, gszFtpProxy, MAX_URL_STRING);
        GetDlgItemText(hDlg, IDC_PROXYGOPHER, gszGopherProxy, MAX_URL_STRING);
    }

    SetDlgItemText( hDlg, IDC_PROXYSECURE, szHttpProxy );
    SetDlgItemText( hDlg, IDC_PROXYFTP, szHttpProxy );
    SetDlgItemText( hDlg, IDC_PROXYGOPHER, szHttpProxy );
    SetDlgItemText( hDlg, IDC_PROXYSOCKS, TEXT("\0") );
}

//+----------------------------------------------------------------------------
//
//  Function:   ReplicatePORTHTTP
//
//  Synopsis:   copies the value in the IDC_PORTHTTP edit box to the all other
//              proxy port fields except for IDC_SOCKS
//
//  Arguments:  hDlg -- handle to dialog window which owns the controls
//              bSaveOrig -- save original info 
//
//  Returns:    none
//
//  History:    7/10/97 jmazner created for Olympus #9365
//
//-----------------------------------------------------------------------------
void ReplicatePORTHTTP( HWND hDlg, BOOL bSaveOrig)
{
    TCHAR szHttpPort[INTERNET_MAX_PORT_LENGTH+1];

    GetDlgItemText(hDlg, IDC_PORTHTTP, szHttpPort, INTERNET_MAX_PORT_LENGTH);

    if (bSaveOrig)
    {
        GetDlgItemText(hDlg, IDC_PORTSECURE, gszSecurePort, MAX_URL_STRING);
        GetDlgItemText(hDlg, IDC_PORTFTP, gszFtpPort, MAX_URL_STRING);
        GetDlgItemText(hDlg, IDC_PORTGOPHER, gszGopherPort, MAX_URL_STRING);
    }

    SetDlgItemText( hDlg, IDC_PORTSECURE, szHttpPort );
    SetDlgItemText( hDlg, IDC_PORTFTP, szHttpPort );
    SetDlgItemText( hDlg, IDC_PORTGOPHER, szHttpPort );
    SetDlgItemText( hDlg, IDC_PORTSOCKS, TEXT("\0") );
}



/*******************************************************************

  NAME:    ProxyExceptionsInitProc

  SYNOPSIS:  Called when Proxy Exceptions page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ProxyExceptionsInitProc(HWND hDlg,BOOL fFirstInit)
{
    if (fFirstInit)
    {
        SendDlgItemMessage(hDlg,IDC_BYPASSPROXY,EM_LIMITTEXT,
          sizeof(gpUserInfo->szProxyOverride) - sizeof(cszLocalString),0L);

        BOOL fBypassLocal = RemoveLocalFromExceptionList(gpUserInfo->szProxyOverride);

        SetDlgItemText(hDlg,IDC_BYPASSPROXY,gpUserInfo->szProxyOverride);

        CheckDlgButton(hDlg,IDC_BYPASSLOCAL,fBypassLocal);
    }

    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_PROXYEXCEPTIONS;

    return TRUE;
}
        
/*******************************************************************

  NAME:    ProxyExceptionsOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from Proxy
                Exceptions page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ProxyExceptionsOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
    ASSERT(puNextPage);

    // get proxy server override from UI
    GetDlgItemText(hDlg,IDC_BYPASSPROXY,gpUserInfo->szProxyOverride,
                    ARRAYSIZE(gpUserInfo->szProxyOverride));

    if (IsDlgButtonChecked(hDlg, IDC_BYPASSLOCAL))
    {
        //
        // Add ; on the end if its NOT the first entry.
        //

        if ( gpUserInfo->szProxyOverride[0] != '\0' )
        {
            lstrcat(gpUserInfo->szProxyOverride, TEXT(";"));
        }


        //
        // Now Add <local> to end of string.
        //

        lstrcat(gpUserInfo->szProxyOverride,  cszLocalString);
    }

    if (fForward)
    {
      if(( gpWizardState->dwRunFlags & RSW_APPRENTICE ) && !g_fIsICW)
      {
          // we're about to jump back to the external wizard, and we don't want
          // this page to show up in our history list
          *pfKeepHistory = FALSE;

          *puNextPage = g_uExternUINext;

        //Notify the main Wizard that this was the last page
        ASSERT( g_pExternalIICWExtension )
        if (g_fIsExternalWizard97)
            g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_PROXYEXCEPTIONS97);
        else
            g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_PROXYEXCEPTIONS);

        g_fConnectionInfoValid = TRUE;

      }
      else if( LoadAcctMgrUI(GetParent(hDlg), 
                             g_fIsWizard97 ? IDD_PAGE_PROXYEXCEPTIONS97 : IDD_PAGE_PROXYEXCEPTIONS, 
                             g_fIsWizard97 ? IDD_PAGE_CONNECTEDOK97FIRSTLAST : IDD_PAGE_CONNECTEDOK, 
                             g_fIsWizard97 ? WIZ_USE_WIZARD97 : 0) )
      {
          if( DialogIDAlreadyInUse( g_uAcctMgrUIFirst) )
          {
              // we're about to jump into the external apprentice, and we don't want
              // this page to show up in our history list
              *pfKeepHistory = FALSE;

              *puNextPage = g_uAcctMgrUIFirst;
          }
          else
          {
              DEBUGMSG("hmm, the first acctMgr dlg id is supposedly %d, but it's not marked as in use!",
                        g_uAcctMgrUIFirst);
              *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);
          }
      }
      else
      {
          DEBUGMSG("LoadAcctMgrUI returned false, guess we'd better skip over it!");
          *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);

      }
    }

    return TRUE;
}


BOOL DoNewProfileDlg(HWND hDlg)
{
  // fill out structure to pass to dialog
  NEWPROFILEDLGINFO NewProfileDlgInfo;

  NewProfileDlgInfo.hwndCombo = GetDlgItem(hDlg,IDC_PROFILE_LIST);

  // create dialog to prompt for profile name
  BOOL fRet=(BOOL)DialogBoxParam(ghInstance,MAKEINTRESOURCE(IDD_NEWPROFILENAME),hDlg,
    NewProfileDlgProc,(LPARAM) &NewProfileDlgInfo);

  // if profile name chosen, add it to combo box
  if (fRet) {
    int iSel=ComboBox_AddString(NewProfileDlgInfo.hwndCombo,
      NewProfileDlgInfo.szNewProfileName);
    ASSERT(iSel >= 0);
    ComboBox_SetCurSel(NewProfileDlgInfo.hwndCombo,iSel);
  }

  return fRet;
}


/*******************************************************************
  NAME:    NewProfileDlgProc
  SYNOPSIS:  Dialog proc for choosing name for new profile
********************************************************************/
INT_PTR CALLBACK NewProfileDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  switch (uMsg) {

    case WM_INITDIALOG:
      // lParam contains pointer to NEWPROFILEDLGINFO struct, set it
      // in window data
      ASSERT(lParam);
      SetWindowLongPtr(hDlg,DWLP_USER,lParam);
      return NewProfileDlgInit(hDlg,(NEWPROFILEDLGINFO *) lParam);
            break;

    case WM_COMMAND:
      switch (LOWORD(wParam)) {
              case IDOK:
                  {
            NEWPROFILEDLGINFO * pNewProfileDlgInfo =
              (NEWPROFILEDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
            ASSERT(pNewProfileDlgInfo);
            BOOL fRet=NewProfileDlgOK(hDlg,pNewProfileDlgInfo);
            if (fRet) {
              EndDialog(hDlg,TRUE);
            }
                    }
                    break;

        case IDCANCEL:
                    EndDialog(hDlg,FALSE);
          break;                  

            }
          break;
    }

    return FALSE;
}

#define MAX_DEFAULT_PROFILE_INDEX  50
BOOL NewProfileDlgInit(HWND hDlg,NEWPROFILEDLGINFO * pNewProfileDlgInfo)
{
  BOOL fHaveDefaultName = TRUE;
  ASSERT(pNewProfileDlgInfo);

  // limit edit field
  Edit_LimitText(GetDlgItem(hDlg,IDC_PROFILENAME),cchProfileNameMax);

  TCHAR szDefaultName[SMALL_BUF_LEN+1];
  LoadSz(IDS_PROFILENAME,szDefaultName,sizeof(szDefaultName));

  // see if the default name already exists in the combo box of profiles
  if (ComboBox_FindStringExact(pNewProfileDlgInfo->hwndCombo,0,szDefaultName)
    >= 0) {
    fHaveDefaultName = FALSE;
    // yep, it exists, try making a default name that doesn't exist
    int iIndex = 2;  // start with "<default name> #2"
    TCHAR szBuf[SMALL_BUF_LEN+1];
    LoadSz(IDS_PROFILENAME1,szBuf,sizeof(szBuf));

    while (iIndex <  MAX_DEFAULT_PROFILE_INDEX) {
      // build a name a la "<default name> #<#>"
      wsprintf(szDefaultName,szBuf,iIndex);
      // is it in combo box already?
      if (ComboBox_FindStringExact(pNewProfileDlgInfo->hwndCombo,0,szDefaultName)
        < 0) {
        fHaveDefaultName = TRUE;
        break;
      }

      iIndex ++;
    }
  }

  if (fHaveDefaultName) {
    SetDlgItemText(hDlg,IDC_PROFILENAME,szDefaultName);
    Edit_SetSel(GetDlgItem(hDlg,IDC_PROFILENAME),0,-1);
  }

  SetFocus(GetDlgItem(hDlg,IDC_PROFILENAME));

  return TRUE;
}

BOOL NewProfileDlgOK(HWND hDlg,NEWPROFILEDLGINFO * pNewProfileDlgInfo)
{
  ASSERT(pNewProfileDlgInfo);

  // get new profile name out of edit control
  GetDlgItemText(hDlg,IDC_PROFILENAME,pNewProfileDlgInfo->szNewProfileName,
    ARRAYSIZE(pNewProfileDlgInfo->szNewProfileName));

  // name needs to be non-empty
  if (!lstrlen(pNewProfileDlgInfo->szNewProfileName)) {
    MsgBox(hDlg,IDS_NEED_PROFILENAME,MB_ICONINFORMATION,MB_OK);
    SetFocus(GetDlgItem(hDlg,IDC_PROFILENAME));
    return FALSE;
  }

  // name needs to be unique
  if (ComboBox_FindStringExact(pNewProfileDlgInfo->hwndCombo,
    0,pNewProfileDlgInfo->szNewProfileName) >= 0) {
    MsgBox(hDlg,IDS_DUPLICATE_PROFILENAME,MB_ICONINFORMATION,MB_OK);
    SetFocus(GetDlgItem(hDlg,IDC_PROFILENAME));
    Edit_SetSel(GetDlgItem(hDlg,IDC_PROFILENAME),0,-1);
    return FALSE;
  }

  return TRUE;
}

/*******************************************************************

  NAME:    NewProfileDlgProc

  Maps a scheme name/length to a scheme name type

  Arguments:

    lpszSchemeName  - pointer to name of scheme to map

    dwSchemeNameLength  - length of scheme (if -1, lpszSchemeName is ASCIZ)
 
  Return Value:

    INTERNET_SCHEME

********************************************************************/
INTERNET_SCHEME MapUrlSchemeName(LPTSTR lpszSchemeName, DWORD dwSchemeNameLength)
{
    if (dwSchemeNameLength == (DWORD)-1)
    {
        dwSchemeNameLength = (DWORD)lstrlen(lpszSchemeName);
    }

    int i = 0;
    do
    {
        if (UrlSchemeList[i].SchemeLength == dwSchemeNameLength)
        {
            TCHAR chBackup = lpszSchemeName[dwSchemeNameLength];
            lpszSchemeName[dwSchemeNameLength] = '\0';

            if(lstrcmpi(UrlSchemeList[i].SchemeName,lpszSchemeName) == 0)
            {
                lpszSchemeName[dwSchemeNameLength] = chBackup;
                return UrlSchemeList[i].SchemeType;
            }

            lpszSchemeName[dwSchemeNameLength] = chBackup;
        }
        i++;
    } while (UrlSchemeList[i].SchemeLength);

    return INTERNET_SCHEME_UNKNOWN;
}

/*******************************************************************

  NAME:    MapUrlSchemeTypeToCtlId

Routine Description:

    Maps a scheme to a dlg child control id.

Arguments:

    Scheme    - Scheme to Map

    fIdForPortCtl - If TRUE, means we really want the ID for a the PORT control
            not the ADDRESS control.

Return Value:

    DWORD

********************************************************************/
DWORD MapUrlSchemeTypeToCtlId(INTERNET_SCHEME SchemeType, BOOL fIdForPortCtl)
{
    int i = 0;
    while (UrlSchemeList[i].SchemeLength)
    {
        if (SchemeType == UrlSchemeList[i].SchemeType)
        {
            return (fIdForPortCtl ? UrlSchemeList[i].dwPortControlId :
                                    UrlSchemeList[i].dwControlId );
        }
        i++;
    }
    return 0;
}

/*******************************************************************

  NAME:    MapCtlIdUrlSchemeName


Routine Description:

    Maps a dlg child control id to String represnting
    the name of the scheme.

Arguments:

    dwEditCtlId   - Edit Control to Map Out.

    lpszSchemeOut - Scheme to Map Out.
            WARNING: ASSUMED to be size of largest scheme type.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

********************************************************************/
BOOL MapCtlIdUrlSchemeName(DWORD dwEditCtlId, LPTSTR lpszSchemeOut)
{
    ASSERT(lpszSchemeOut);

    int i = 0;
    while (UrlSchemeList[i].SchemeLength)
    {
        if (dwEditCtlId == UrlSchemeList[i].dwControlId )
        {
            lstrcpy(lpszSchemeOut, UrlSchemeList[i].SchemeName);
            return TRUE;
        }
        i++;
    }
    return FALSE;
}

/*******************************************************************

  NAME:    MapAddrCtlIdToPortCtlId

Routine Description:

    Maps a dlg child control id for addresses to
    a dlg control id for ports.

Arguments:

    dwEditCtlId   - Edit Control to Map Out.

Return Value:

    DWORD
    Success - Correctly mapped ID.

    Failure - 0.

********************************************************************/
DWORD MapAddrCtlIdToPortCtlId(DWORD dwEditCtlId)
{
    int i = 0;
    while (UrlSchemeList[i].SchemeLength)
    {
        if (dwEditCtlId == UrlSchemeList[i].dwControlId )
        {
            return UrlSchemeList[i].dwPortControlId ;
        }
        i++;
    }
    return FALSE;
}


/*******************************************************************

  NAME:    ParseProxyInfo

  Parses proxy server string and sets dialog fields appropriately

  Arguments:

    hDlg - Handle to dialog

    lpszProxy - Proxy server string

    lpszSchemeName  - pointer to name of scheme to map

    dwSchemeNameLength  - length of scheme (if -1, lpszSchemeName is ASCIZ)
 
  Return Value:

    INTERNET_SCHEME

********************************************************************/

BOOL ParseProxyInfo(HWND hDlg, LPTSTR lpszProxy)
{
    DWORD error = FALSE;
    DWORD entryLength = 0;
    LPTSTR protocolName = lpszProxy;
    DWORD protocolLength = 0;
    LPTSTR schemeName = NULL;
    DWORD schemeLength = 0;
    LPTSTR serverName = NULL;
    DWORD serverLength = 0;
    PARSER_STATE state = STATE_PROTOCOL;
    DWORD nSlashes = 0;
    UINT port = 0;
    BOOL done = FALSE;
    LPTSTR lpszList = lpszProxy;


    do
    {
        TCHAR ch = *lpszList++;

        if ((1 == nSlashes) && (ch != '/'))
        {
            state = STATE_ERROR;
            break;  // do ... while
        }

        switch (ch)
        {
        case '=':
            if ((state == STATE_PROTOCOL) && (entryLength != 0))
            {
                protocolLength = entryLength;
                entryLength = 0;
                state = STATE_SCHEME;
                schemeName = lpszList;
            }
            else
            {
                //
                // '=' can't legally appear anywhere else
                //
                state = STATE_ERROR;
            }
            break;

        case ':':
            switch (state)
            {
            case STATE_PROTOCOL:
                if (*lpszList == '/')
                {
                    schemeName = protocolName;
                    protocolName = NULL;
                    schemeLength = entryLength;
                    protocolLength = 0;
                    state = STATE_SCHEME;
                }
                else if (*lpszList != '\0')
                {
                    serverName = protocolName;
                    protocolName = NULL;
                    serverLength = entryLength;
                    protocolLength = 0;
                    state = STATE_PORT;
                }
                else
                {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SCHEME:
                if (*lpszList == '/')
                {
                    schemeLength = entryLength;
                }
                else if (*lpszList != '\0')
                {
                    serverName = schemeName;
                    serverLength = entryLength;
                    state = STATE_PORT;
                }
                else
                {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SERVER:
                serverLength = entryLength;
                state = STATE_PORT;
                entryLength = 0;
                break;

            default:
                state = STATE_ERROR;
                break;
            }
            break;

        case '/':
            if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0))
            {
                if (++nSlashes == 2)
                {
                    state = STATE_SERVER;
                    serverName = lpszList;
                }
            }
            else
            {
                state = STATE_ERROR;
            }
            break;

        case '\v':  // vertical tab, 0x0b
        case '\f':  // form feed, 0x0c
            if (!((state == STATE_PROTOCOL) && (entryLength == 0)))
            {
                //
                // can't have embedded whitespace
                //

                state = STATE_ERROR;
            }
            break;

        default:
            if (state != STATE_PORT)
            {
                ++entryLength;
            }
            else if (isdigit(ch))
            {
                // calculate in DWORD to prevent overflow
                DWORD dwPort = port * 10 + (ch - '0');

                if (dwPort <= 65535)
                    port = (UINT)dwPort;
                else
                    state = STATE_ERROR;
            }
            else
            {                   
                //
                // STATE_PORT && non-digit character - error
                //
                state = STATE_ERROR;
            }
            break;

        case '\0':
            done = TRUE;

        //
        // fall through
        //
        case ' ':
        case '\t':
        case '\n':
        case '\r':
        case ';':
        case ',':
            if (serverLength == 0)
            {
                serverLength = entryLength;
            }
            if (serverLength != 0)
            {
                if (serverName == NULL)
                {
                    serverName = (schemeName != NULL)
                                    ? schemeName : protocolName;
                }

                ASSERT(serverName != NULL);

                INTERNET_SCHEME protocol;

                if (protocolLength != 0)
                {
                    protocol = MapUrlSchemeName(protocolName, protocolLength);
                }
                else
                {
                    protocol = INTERNET_SCHEME_DEFAULT;
                }

                INTERNET_SCHEME scheme;

                if (schemeLength != 0)
                {
                    scheme = MapUrlSchemeName(schemeName, schemeLength);
                }
                else
                {
                    scheme = INTERNET_SCHEME_DEFAULT;
                }

                //
                // add an entry if this is a protocol we handle and we don't
                // already have an entry for it
                //

                if ((protocol != INTERNET_SCHEME_UNKNOWN)
                    && (scheme != INTERNET_SCHEME_UNKNOWN))
                {
                    DWORD dwCtlId = 0;
                    DWORD dwPortCtlId = 0;
                    TCHAR chBackup;

                    error = ERROR_SUCCESS;
                    //
                    // we can only currently handle CERN proxies (unsecure or
                    // secure) so kick out anything that wants to go via a different
                    // proxy scheme
                    //

                    if (protocol == INTERNET_SCHEME_DEFAULT)
                    {
                        CheckDlgButton( hDlg, IDC_PROXYSAME, TRUE );
                        dwCtlId     = IDC_PROXYHTTP;
                        dwPortCtlId = IDC_PORTHTTP;
                    }
                    else
                    {
                        dwCtlId     = MapUrlSchemeTypeToCtlId(protocol,FALSE);
                        dwPortCtlId = MapUrlSchemeTypeToCtlId(protocol,TRUE);
                    }

                    //
                    // Set the Field Entry.
                    //

                    LPTSTR lpszProxyNameText;

                    if (scheme != INTERNET_SCHEME_DEFAULT)
                    {
                        ASSERT(schemeLength != 0);
                        lpszProxyNameText = schemeName;
                    }
                    else
                        lpszProxyNameText = serverName;

                    chBackup = serverName[serverLength];
                    serverName[serverLength] = '\0';

                    SetDlgItemText( hDlg, dwCtlId, lpszProxyNameText );
                    if ( port )
                        SetDlgItemInt( hDlg, dwPortCtlId, port, FALSE );

                    serverName[serverLength] = chBackup;

                }

                else
                {                      
                    //
                    // bad/unrecognised protocol or scheme. Treat it as error
                    // for now
                    //
                    error = !ERROR_SUCCESS;
                }
            }

            entryLength = 0;
            protocolName = lpszList;
            protocolLength = 0;
            schemeName = NULL;
            schemeLength = 0;
            serverName = NULL;
            serverLength = 0;
            nSlashes = 0;
            port = 0;
            if (error == ERROR_SUCCESS)
            {
                state = STATE_PROTOCOL;
            }
            else
            {
                state = STATE_ERROR;
            }
        break;
        }

        if (state == STATE_ERROR)
        {
        break;
        }

    } while (!done);

    if (state == STATE_ERROR)
    {
        error = ERROR_INVALID_PARAMETER;
    }

    if ( error == ERROR_SUCCESS )
        error = TRUE;
    else
        error = FALSE;

    return error;
}

/*******************************************************************

  NAME:    ParseEditCtlForPort

Routine Description:

    Parses a Port Number off then end of a Proxy Server URL that is
    located either in the Proxy Name Edit Box, or passed in as
    a string pointer.

Arguments:

    lpszProxyName - (OPTIONAL) string pointer with Proxy Name to parse, and
            set into the Proxy Name edit ctl field.

    hDlg      - HWIN of the dialog to play with.

    dwProxyNameCtlId -  Res Ctl Id to play with.

    dwProxyPortCtlId -  Res Ctl Id of Port Number Edit Box.

Return Value:

    BOOL
    Success TRUE -

    Failure FALSE

********************************************************************/
BOOL ParseEditCtlForPort(
    IN OUT LPTSTR   lpszProxyName,
    IN HWND    hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId
    )
{
    TCHAR  szProxyUrl[MAX_URL_STRING+1];
    LPTSTR lpszPort;
    LPTSTR lpszProxyUrl;

    ASSERT(IsWindow(hDlg));

    if ( dwProxyPortCtlId == 0 )
    {
    dwProxyPortCtlId = MapAddrCtlIdToPortCtlId(dwProxyNameCtlId);
    ASSERT(dwProxyPortCtlId);
    }

    //
    // Get the Proxy String from the Edit Control
    //  (OR) from the Registry [passed in]
    //

    if ( lpszProxyName )
    lpszProxyUrl = lpszProxyName;
    else
    {
    //
    // Need to Grab it out of the edit control.
    //
        GetDlgItemText(hDlg,
            dwProxyNameCtlId,
            szProxyUrl,
            ARRAYSIZE(szProxyUrl));

    lpszProxyUrl = szProxyUrl;
    }

    //
    // Now find the port.
    //

    lpszPort = lpszProxyUrl;

    GET_TERMINATOR(lpszPort);

    lpszPort--;

    //
    // Walk backwards from the end of url looking
    //  for a port number sitting on the end like this
    //  http://proxy:1234
    //

    while ( (lpszPort > lpszProxyUrl) &&
        (*lpszPort != ':')         &&
        (isdigit(*lpszPort))  )
    {
    lpszPort--;
    }

    //
    // If we found a match for our rules
    //  then set the port, otherwise
    //  we assume the user knows what he's
    //  doing.
    //

    if ( *lpszPort == ':'   &&   isdigit(*(lpszPort+1)) )
    {
    *lpszPort = '\0';

    SetDlgItemText(hDlg, dwProxyPortCtlId, (lpszPort+1));
    }

    SetDlgItemText(hDlg, dwProxyNameCtlId, lpszProxyUrl);
    return TRUE;
}

/*******************************************************************

  NAME:    FormatOutProxyEditCtl

Routine Description:

    Combines Proxy URL components into a string that can be saved
    in the registry.  Can be called multiple times to build
    a list of proxy servers, or once to special case a "default"
    proxy.

Arguments:

    hDlg      - HWIN of the dialog to play with.

    dwProxyNameCtlId -  Res Ctl Id to play with.

    dwProxyPortCtlId -  Res Ctl Id of Port Number Edit Box.

    lpszOutputStr    -  The start of the output string to send
            the product of this function.

    lpdwOutputStrSize - The amount of used space in lpszOutputStr
            that is already used.  New output should
            start from (lpszOutputStr + *lpdwOutputStrSize)

    fDefaultProxy     - Default Proxy, don't add scheme= in front of the proxy
            just use plop one proxy into the registry.


Return Value:

    DWORD
    Success ERROR_SUCCESS

    Failure ERROR message

********************************************************************/
DWORD FormatOutProxyEditCtl(
    IN HWND    hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId,
    OUT LPTSTR      lpszOutputStr,
    IN OUT LPDWORD lpdwOutputStrSize,
    IN DWORD       dwOutputStrLength,
    IN BOOL    fDefaultProxy
    )
{
    LPTSTR lpszOutput;
    LPTSTR lpszEndOfOutputStr;

    ASSERT(IsWindow(hDlg));
    ASSERT(lpdwOutputStrSize);

    lpszOutput = lpszOutputStr + *lpdwOutputStrSize;
    lpszEndOfOutputStr = lpszOutputStr + dwOutputStrLength;

    ASSERT( lpszEndOfOutputStr > lpszOutput );

    if ( lpszEndOfOutputStr <= lpszOutput )
        return ERROR_NOT_ENOUGH_MEMORY; // bail out, ran out of space

    //
    // Plop ';' if we're not the first in this string buffer.
    //

    if (*lpdwOutputStrSize != 0  )
    {
        *lpszOutput = ';';

        lpszOutput++;

        if ( lpszEndOfOutputStr <= lpszOutput )
            return ERROR_NOT_ENOUGH_MEMORY; // bail out, ran out of space
    }

    //
    // Put the schemetype= into the string
    //  ex:  http=
    //

    if ( ! fDefaultProxy )
    {
        if ( lpszEndOfOutputStr <= (MAX_SCHEME_NAME_LENGTH + lpszOutput + 1) )
            return ERROR_NOT_ENOUGH_MEMORY; // bail out, ran out of space

        if (!MapCtlIdUrlSchemeName(dwProxyNameCtlId,lpszOutput))
            return ERROR_NOT_ENOUGH_MEMORY;

        lpszOutput += lstrlen(lpszOutput);

        *lpszOutput = '=';
        lpszOutput++;
    }

    //
    // Need to Grab ProxyUrl out of the edit control.
    //

    GetDlgItemText(hDlg, dwProxyNameCtlId, lpszOutput, (int)(lpszEndOfOutputStr - lpszOutput) / sizeof(TCHAR));

    if ( '\0' == *lpszOutput ) 
    {
        // Cancel out anything we may have added before returning
        *(lpszOutputStr + *lpdwOutputStrSize) = '\0';
        return ERROR_SERVER_NAME;
    }

    //
    // Now seperate out the port so we can save them seperately.
    //   But go past the Proxy Url while we're at it.
    //      ex: http=http://netscape-proxy
    //

    if (!ParseEditCtlForPort(lpszOutput, hDlg, dwProxyNameCtlId, dwProxyPortCtlId))
        return ERROR_PORT_NUM;

    lpszOutput += lstrlen(lpszOutput);

    //
    // Now, add in a ':" for the port number, if we don't
    //  have a port we'll remove it.
    //
    *lpszOutput = ':';

    lpszOutput++;

    if ( lpszEndOfOutputStr <= lpszOutput )
        return ERROR_NOT_ENOUGH_MEMORY; // bail out, ran out of space

    //
    // Grab Proxy Port if its around.
    //  Back out the ':' if its not.
    //

    GetDlgItemText(hDlg, dwProxyPortCtlId,lpszOutput, (int)(lpszEndOfOutputStr - lpszOutput) / sizeof(TCHAR));

    // jmazner 11/9/96 Normandy #6937
    // Don't accept non-numerical port numbers, since the Internet control panel
    // will not display them.

    int i;
    for( i=0; lpszOutput[i] != NULL; i++ )
    {
        if( !isdigit(lpszOutput[i]) )
        {
            //DisplayFieldErrorMsg(hDlg,dwProxyPortCtlId,IDS_INVALID_PORTNUM);
            return ERROR_PORT_NUM;
        }
    }


    if ( '\0' == *lpszOutput )
    {
        lpszOutput--;

        ASSERT(*lpszOutput == ':');

        *lpszOutput = '\0';
    }

    lpszOutput += lstrlen(lpszOutput);

    //
    // Now we're done return our final sizes.
    //

    *lpdwOutputStrSize = (DWORD)(lpszOutput - lpszOutputStr);

    return ERROR_SUCCESS;
}

/*******************************************************************

  NAME:    RemoveLocalFromExceptionList

Routine Description:

    Scans a delimited list of entries, and removed "<local>
    if found.  If <local> is found we return TRUE.

Arguments:

    lpszExceptionList - String List of proxy excepion entries.


Return Value:

    BOOL
    TRUE - If found <local>

    FALSE - If local was not found.

********************************************************************/
BOOL RemoveLocalFromExceptionList(LPTSTR lpszExceptionList)
{
    LPTSTR lpszLocalInstToRemove;
    BOOL  fFoundLocal;

    if ( !lpszExceptionList || ! *lpszExceptionList )
        return FALSE;

    fFoundLocal = FALSE;
    lpszLocalInstToRemove = lpszExceptionList;

    //
    // Loop looking "<local>" entries in the list.
    //

    do {

        lpszLocalInstToRemove = _tcsstr(lpszLocalInstToRemove,cszLocalString);

        if ( lpszLocalInstToRemove )
        {

            fFoundLocal = TRUE;

            //
            // Nuke <local> out of the string. <local>;otherstuff\0
            //  Dest is: '<'local>;otherstuff\0
            //     ??? (OR) ';'<local> if the ; is the first character.???
            //  Src  is: >'o'therstuff\0
            //  size is: sizeof(';otherstuff\0')
            //

            MoveMemory( lpszLocalInstToRemove,
                        (lpszLocalInstToRemove+(sizeof(cszLocalString)-sizeof('\0'))),
                        lstrlen(lpszLocalInstToRemove+(sizeof(cszLocalString)-sizeof('\0')))
                        + sizeof('\0')
                        );

        }

    } while (lpszLocalInstToRemove && *lpszLocalInstToRemove);

    //
    // If we produced a ; on the end, nuke it.
    //

    lpszLocalInstToRemove = lpszExceptionList;

    GET_TERMINATOR(lpszLocalInstToRemove);

    if ( lpszLocalInstToRemove != lpszExceptionList &&
        *(lpszLocalInstToRemove-1) == ';' )
    {
        *(lpszLocalInstToRemove-1) = '\0';
    }

    return fFoundLocal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\mapicall.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  MAPICALL.H - Header file for MAPI callout module
//      
//

//  HISTORY:
//  
//  1/27/95    jeremys  Created.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//

#ifndef _MAPICALL_H_
#define _MAPICALL_H_

#define MAPI_DIM  10

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  #include <mapidefs.h>
  #include <mapicode.h>
  #include <mspst.h>
  #include <mspab.h>
  #include <mapiwin.h>
  #include <mapitags.h>
  #include <mapiutil.h>
  #include <mapispi.h>
  #include <inetprop.h>

#ifdef DEBUG
  #undef Assert  // avoid multiple definitions
  #include <mapidbg.h>
#endif

#ifdef __cplusplus
}
#endif // __cplusplus

// prototype for function pointer for MAPI util function
typedef HRESULT (CALLBACK * LPHRQUERYALLROWS) (LPMAPITABLE,LPSPropTagArray,
  LPSRestriction,LPSSortOrderSet,LONG,LPSRowSet FAR *);
extern HINSTANCE hInstMAPIDll;    // handle to MAPI dll we load explicitly

// structure used in determining if a service is present in a MAPI profile,
// and to install the service
typedef struct tagMSGSERVICE {
  BOOL fPresent;        // TRUE if service is present
  UINT uIDServiceName;    // ID of str resource with service name (non-UI)
  UINT uIDServiceDescription;  // ID of str resource with service desc (for UI)

  BOOL fNeedConfig;      // TRUE if create-time config proc should be called
  UINT uIDStoreFilename;    // name to try for message store for
  UINT uIDStoreFilename1;    // name to use to generate other message store names
  UINT uPropID;        // prop val ID for message store property for this service
} MSGSERVICE;

#define NUM_SERVICES    3  // number of services in table of MSGSERVICEs

// class to aid in releasing interfaces.  When you obtain an OLE interface,
// you can contruct a RELEASE_ME_LATER object with the pointer to the interface.
// When the object is destructed, it will release the interface.
class RELEASE_ME_LATER
{
private:
  LPUNKNOWN _lpInterface;
public:
  RELEASE_ME_LATER(LPUNKNOWN lpInterface) { _lpInterface = lpInterface; }
  ~RELEASE_ME_LATER() { if (_lpInterface) _lpInterface->Release(); }
};

// defines needed by route 66 config DLL.  Note: don't change these!
#define CONNECT_TYPE_LAN        1
#define CONNECT_TYPE_REMOTE        2  
#define DOWNLOAD_OPTION_HEADERS      1
#define DOWNLOAD_OPTION_MAIL_DELETE     3

class ENUM_MAPI_PROFILE
{
private:
  LPSRowSet   _pProfileRowSet;
  UINT    _iRow;
  UINT    _nEntries;
public:
  ENUM_MAPI_PROFILE();
  ~ENUM_MAPI_PROFILE();
  BOOL Next(LPTSTR * ppProfileName,BOOL * pfDefault);
  UINT GetEntryCount()  { return _nEntries; }
  
};

class ENUM_MAPI_SERVICE
{
private:
  LPSRowSet   _pServiceRowSet;
  UINT    _iRow;
  UINT    _nEntries;
public:
  ENUM_MAPI_SERVICE(LPTSTR pszProfileName);
  ~ENUM_MAPI_SERVICE();
  BOOL Next(LPTSTR * ppServiceName);
  UINT GetEntryCount()  { return _nEntries; }
  
};

#endif // _MAPICALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\pagefcns.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  PAGEFCNS.H - Prototypes for wizard page handler functions
//

//  HISTORY:
//  
//  12/22/94  jeremys  Created.
//  96/03/23  markdu  Removed GatewayAddr__Proc functions
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//

#ifndef _PAGEFCNS_H_
#define _PAGEFCNS_H_

// Functions in INTROUI.C

BOOL CALLBACK HowToConnectInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK HowToConnectOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

BOOL CALLBACK ChooseModemInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ChooseModemCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam);
BOOL CALLBACK ChooseModemOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

// functions in ISPUPGUI.C
BOOL CALLBACK ConnectionInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ConnectionOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);
BOOL CALLBACK ConnectionCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam);
BOOL CALLBACK ModifyConnectionInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ModifyConnectionOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);
BOOL CALLBACK ConnectionNameInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ConnectionNameOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

BOOL CALLBACK PhoneNumberInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK PhoneNumberOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);
BOOL CALLBACK PhoneNumberCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK NameAndPasswordInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK NameAndPasswordOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

BOOL CALLBACK AdvancedInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK AdvancedOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

BOOL CALLBACK ConnectionProtocolInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ConnectionProtocolOKProc(HWND hDlg);

BOOL CALLBACK LoginScriptInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK LoginScriptOKProc(HWND hDlg);
BOOL CALLBACK LoginScriptCmdProc(HWND hDlg,UINT uCtrlID);

// functions in TCPUI.C
BOOL CALLBACK IPAddressInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK IPAddressOKProc(HWND hDlg);
BOOL CALLBACK IPAddressCmdProc(HWND hDlg,UINT uCtrlID);

BOOL CALLBACK DNSAddressInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK DNSAddressOKProc(HWND hDlg);
BOOL CALLBACK DNSAddressCmdProc(HWND hDlg,UINT uCtrlID);

// functions in MAILUI.C
BOOL CALLBACK UseProxyInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK UseProxyOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);
BOOL CALLBACK UseProxyCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK ProxyServersInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ProxyServersOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);
BOOL CALLBACK ProxyServersCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK SetupProxyInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK SetupProxyOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK SetupProxyCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK ProxyExceptionsInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ProxyExceptionsOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

// functions in ENDUI.C
BOOL CALLBACK ConnectedOKInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ConnectedOKOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

#endif // _PAGEFCNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\mapicall.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  MAPICALL.C - Functions to call MAPI for internet mail profile configuration
//      
//

//  HISTORY:
//  
//  1/25/95    jeremys    Created.
//  96/03/09  markdu    Added a wait cursor during loading of MAPI
//

#include "wizard.h"

/**********************************************************************

  Terminology:

  profile - a collection of settings for Exchange that determine
    the services that are used and the address book and message store
  service - a MAPI plug-in that talks to a mail back end
    (or address book or message store)

  There can be a number of profiles installed on a particular machine.
  Each profile contains a set of services.

  Stategy:

  To configure Microsoft Exchange, we need to do the following:

  1) Establish a profile to modify
    - If any profiles currently exist, find the default profile.
    Otherwise create a profile, which will be initially empty.

  2) Populate the profile with the required services.
    - The profile needs to contain the Internet Mail service, an
    address book and a message store.  If any of these items are
    not present, we add them to the profile.

  3) Configure the internet mail service for this profile.
    - stick in the user's email address, email server, etc.

**********************************************************************/

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)
HINSTANCE hInstMAPIDll=NULL;  // handle to MAPI dll we load explicitly
DWORD dwMAPIRefCount = 0;

// global function pointers for MAPI apis
LPMAPIINITIALIZE     lpMAPIInitialize     = NULL;
LPMAPIADMINPROFILES   lpMAPIAdminProfiles   = NULL;
LPMAPIUNINITIALIZE     lpMAPIUninitialize     = NULL;
LPMAPIALLOCATEBUFFER  lpMAPIAllocateBuffer  = NULL;
LPMAPIFREEBUFFER    lpMAPIFreeBuffer     = NULL;
LPHRQUERYALLROWS    lpHrQueryAllRows    = NULL;

#define NUM_MAPI_PROCS   6
// API table for function addresses to fetch
APIFCN MAPIApiList[NUM_MAPI_PROCS] = {
  { (PVOID *) &lpMAPIInitialize,szMAPIInitialize},
  { (PVOID *) &lpMAPIUninitialize,szMAPIUninitialize},
  { (PVOID *) &lpMAPIAdminProfiles,szMAPIAdminProfiles},
  { (PVOID *) &lpMAPIAllocateBuffer,szMAPIAllocateBuffer},
  { (PVOID *) &lpMAPIFreeBuffer,szMAPIFreeBuffer},
  { (PVOID *) &lpHrQueryAllRows,szHrQueryAllRows}};

#pragma data_seg(DATASEG_DEFAULT)

// function prototypes
HRESULT GetProfileList(LPPROFADMIN lpProfAdmin,LPSRowSet * ppRowSet);
HRESULT GetServicesList(LPSERVICEADMIN lpServiceAdmin, LPSRowSet *ppRowSet);
HRESULT CreateProfileIfNecessary(LPPROFADMIN lpProfAdmin,TCHAR * pszSelProfileName);
HRESULT InstallRequiredServices(LPSERVICEADMIN pServiceAdmin,
  LPSRowSet pServiceRowSet);
VOID FreeSRowSet(LPSRowSet prws);
BOOL ValidateProperty(LPSPropValue pval, ULONG cVal, ULONG ulPropTag);
BOOL DoesFileExist(TCHAR * pszPath,TCHAR * pszFileName);
HRESULT ConfigInternetService(MAILCONFIGINFO * pMailConfigInfo,
  LPSERVICEADMIN lpServiceAdmin);
HRESULT   GetServiceUID(TCHAR * pszName,LPSERVICEADMIN lpServiceAdmin,
  LPMAPIUID *ppMapiUID);
BOOL MakeUniqueFilename(UINT uIDFilename,UINT uIDAltFilename,
  TCHAR * pszFilename,DWORD cbFilename);
extern BOOL GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,
  UINT nApiProcs);
HRESULT ConfigNewService(LPSERVICEADMIN lpServiceAdmin,LPMAPIUID lpMapiUID,
  UINT uIDFilename,UINT uIDFilename1,UINT uPropValID);

// enums
enum { ivalDisplayName, ivalServiceName, ivalResourceFlags, ivalServiceDllName,
  ivalServiceEntryName, ivalServiceUID, ivalServiceSupportFiles,
  cvalMsgSrvMax };

/*******************************************************************

  NAME:    InitMAPI

  SYNOPSIS:  Loads the MAPI dll, gets proc addresses and initializes
        MAPI

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

  NOTES:    We load MAPI explicitly because the DLL may not be installed
        when we begin the wizard... we may have to install it and
        then load it.
        

********************************************************************/
BOOL InitMAPI(HWND hWnd)
{
  TCHAR szMAPIDll[SMALL_BUF_LEN+1];
  HRESULT hr;

  // load MAPI only if not already loaded... otherwise just increment
  // reference count

  if (!hInstMAPIDll) {

    // set an hourglass cursor
    WAITCURSOR WaitCursor;

    // get the filename (MAPI32.DLL) out of resource
    LoadSz(IDS_MAPIDLL_FILENAME,szMAPIDll,ARRAYSIZE(szMAPIDll));
    // load the MAPI dll
    DEBUGMSG("Loading MAPI DLL");
    hInstMAPIDll = LoadLibrary(szMAPIDll);
    if (!hInstMAPIDll) {
      UINT uErr = GetLastError();
      DisplayErrorMessage(hWnd,IDS_ERRLoadMAPIDll1,uErr,ERRCLS_STANDARD,
        MB_ICONSTOP,szMAPIDll);
      return FALSE;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    BOOL fSuccess = GetApiProcAddresses(hInstMAPIDll,MAPIApiList,NUM_MAPI_PROCS);

    if (!fSuccess) {
      MsgBoxParam(hWnd,IDS_ERRLoadMAPIDll2,MB_ICONSTOP,MB_OK,szMAPIDll);
      DeInitMAPI();
      return FALSE;
    }

    // initialize MAPI
    ASSERT(lpMAPIInitialize);
    hr = lpMAPIInitialize(NULL);
    if (HR_FAILED(hr)) {
       MsgBox(hWnd,IDS_ERRInitMAPI,MB_ICONSTOP,MB_OK);
      DeInitMAPI();
      return FALSE;
    }

    gpWizardState->fMAPIActive = TRUE;
  }

  dwMAPIRefCount ++;

   return TRUE;
}

/*******************************************************************

  NAME:    DeInitMAPI

  SYNOPSIS:  Uninitializes MAPI and unloads MAPI dlls

********************************************************************/
VOID DeInitMAPI(VOID)
{
  // decrease reference count
  if (dwMAPIRefCount) {
    dwMAPIRefCount--;
  }

  // shut down and unload MAPI if reference count hits zero
  if (!dwMAPIRefCount) {
    // uninitialize MAPI
    if (gpWizardState->fMAPIActive && lpMAPIUninitialize) {
      lpMAPIUninitialize();
      gpWizardState->fMAPIActive = FALSE;
    }

    // free the MAPI dll
    if (hInstMAPIDll) {
      DEBUGMSG("Unloading MAPI DLL");
      FreeLibrary(hInstMAPIDll);
      hInstMAPIDll = NULL;
    }
  
    // set function pointers to NULL
    for (UINT nIndex = 0;nIndex<NUM_MAPI_PROCS;nIndex++) 
      *MAPIApiList[nIndex].ppFcnPtr = NULL;
  }
}

/*******************************************************************

  NAME:    SetMailProfileInformation

  SYNOPSIS:  Sets up MAPI profile for internet mail and sets
        user information in profile.

  ENTRY:    pMailConfigInfo - pointer to struct with configuration info

  EXIT:    returns an HRESULT
  
  NOTES:    See strategy statement above
  
********************************************************************/
HRESULT SetMailProfileInformation(MAILCONFIGINFO * pMailConfigInfo)
{
  HRESULT hr;
  LPPROFADMIN   pProfAdmin=NULL;  // interface to administer profiles
  LPSERVICEADMIN  pServiceAdmin=NULL; // interface to administer services
  LPSRowSet    pServiceRowSet=NULL;
  TCHAR      szSelProfileName[cchProfileNameMax+1]=TEXT("");

  ASSERTSZ(gpWizardState->fMAPIActive,"MAPI not initialized!");
  ASSERT(pMailConfigInfo);

  // get a pointer to the interface to administer profiles
  ASSERT(lpMAPIAdminProfiles);
  hr = lpMAPIAdminProfiles(0,&pProfAdmin);
  if (HR_FAILED(hr)) {
    DEBUGMSG("MAPIAdminProfiles returned 0x%lx",hr);
    return (hr);
  }
  ASSERT(pProfAdmin);
  // release this interface when we leave the function
  RELEASE_ME_LATER ReleaseProfAdminLater(pProfAdmin);

  // get profile name from passed-in struct, if specified
  if (pMailConfigInfo->pszProfileName && lstrlen(pMailConfigInfo->pszProfileName)) {
    lstrcpy(szSelProfileName,pMailConfigInfo->pszProfileName);
  } else {
    // no profile specified, use default name
    LoadSz(IDS_DEFAULT_PROFILE_NAME,szSelProfileName,ARRAYSIZE(szSelProfileName));
  }

  // create profile if we need to
  hr = CreateProfileIfNecessary(pProfAdmin,szSelProfileName);
  if (HR_FAILED(hr))
    return hr;

  // set this profile as default if appropriate
  if (pMailConfigInfo->fSetProfileAsDefault) {
    hr = pProfAdmin->SetDefaultProfile(szSelProfileName,0);
    if (HR_FAILED(hr))
      return hr;
  }

  ASSERT(lstrlen(szSelProfileName));  // should have profile name at this point
  DEBUGMSG("Modifying MAPI profile: %s",szSelProfileName);

  // get a pointer to the interface to administer services for this profile
  hr = pProfAdmin->AdminServices(szSelProfileName,NULL,NULL,0,
    &pServiceAdmin);

  if (HR_FAILED(hr))
    return hr;
  ASSERT(pServiceAdmin);
  // release pServiceAdmin interface when done
  RELEASE_ME_LATER rlServiceAdmin(pServiceAdmin);  

  // get a list of services for this profile
  hr = GetServicesList(pServiceAdmin,&pServiceRowSet);
  if (HR_FAILED(hr))
    return hr;
  ASSERT(pServiceRowSet);

  // install any services we need which aren't already present in the profile
  hr = InstallRequiredServices(pServiceAdmin,pServiceRowSet);
    // done with profile row set, free the table
  FreeSRowSet(pServiceRowSet);
  pServiceRowSet = NULL;
  if (HR_FAILED(hr))
    return hr;

  // configure the internet mail service with the passed in email name,
  // server, etc.
  hr = ConfigInternetService(pMailConfigInfo,pServiceAdmin);
  if (HR_FAILED(hr)) {
    DEBUGMSG("ConfigInternetService returned 0x%x" , hr);
    return hr;
  }

  return hr;
}

/*******************************************************************

  NAME:    GetProfileList

  SYNOPSIS:  retrieves a list of MAPI profiles 

  ENTRY:    lpProfAdmin - pointer to profile admin interface
        ppRowSet - pointer to an SRowSet pointer that is filled in

  EXIT:    returns an HRESULT.  If successful, *ppRowSet contains
        pointer to SRowSet with profile list.

  NOTES:    Cloned from MAPI profile control panel code.
        Caller MUST call MAPIFreeBuffer to free *ppRowSet when done.
          
********************************************************************/
HRESULT GetProfileList(LPPROFADMIN lpProfAdmin,LPSRowSet * ppRowSet)
{
  HRESULT hr;
  LPMAPITABLE   pMapiTable=NULL;
  SPropTagArray   TagArray= {3,{PR_DISPLAY_NAME,
            PR_COMMENT,PR_DEFAULT_PROFILE}};

  ASSERT(lpProfAdmin);
  ASSERT(ppRowSet);

  // call the lpProfAdmin interface to get the MAPI profile table
  hr = lpProfAdmin->GetProfileTable(0,&pMapiTable);
  if (HR_FAILED(hr))
    return hr;
  ASSERT(pMapiTable);
  // release this interface when we leave the function
  RELEASE_ME_LATER ReleaseMapiTableLater(pMapiTable);

  // set properties of table columns
  hr = pMapiTable->SetColumns(&TagArray,0);
  if (!HR_FAILED(hr)) {
    // get row set information from table
    hr = pMapiTable->QueryRows(4000,0,ppRowSet);
  }

  return hr;
}

/*******************************************************************

  NAME:    GetServicesList

  SYNOPSIS:  retrieves a list of MAPI services in a profile

  ENTRY:    lpProfAdmin - pointer to service admin interface
        ppRowSet - pointer to an SRowSet pointer that is filled in

  EXIT:    returns an HRESULT.  If successful, *ppRowSet contains
        pointer to SRowSet with service list.

  NOTES:    Cloned from MAPI profile control panel code.
        Caller MUST call MAPIFreeBuffer to free *ppRowSet when done.
          
********************************************************************/
HRESULT GetServicesList(LPSERVICEADMIN lpServiceAdmin, LPSRowSet *ppRowSet)
{
  HRESULT      hr;
  ULONG      iRow;
  LPMAPITABLE    pMapiTable   = NULL;
  SCODE      sc    = S_OK;
  static SPropTagArray taga  = {7, { PR_DISPLAY_NAME,
                    PR_SERVICE_NAME,
                    PR_RESOURCE_FLAGS,
                    PR_SERVICE_DLL_NAME,
                    PR_SERVICE_ENTRY_NAME,
                    PR_SERVICE_UID,
                    PR_SERVICE_SUPPORT_FILES }};

  *ppRowSet = NULL;

  hr = lpServiceAdmin->GetMsgServiceTable(0, &pMapiTable);
  if (HR_FAILED(hr))
    return hr;
  // free this interface when function exits
  RELEASE_ME_LATER rlTable(pMapiTable);


  hr = pMapiTable->SetColumns(&taga, 0);
  if (!HR_FAILED(hr)) {
    // BUGBUG get rid of 'magic number' (appears in MAPI
    // ctrl panel code, need to find out what it is)  jeremys 1/30/95
    hr = pMapiTable->QueryRows(4000,0,ppRowSet);
  }
  if (HR_FAILED(hr))
    return hr;

  for(iRow = 0; iRow < (*ppRowSet)->cRows; iRow++)
  {
    // make sure properties are valid, if not then slam something in
    ValidateProperty((*ppRowSet)->aRow[iRow].lpProps, 0, PR_DISPLAY_NAME);
    ValidateProperty((*ppRowSet)->aRow[iRow].lpProps, 1, PR_SERVICE_NAME);
  }

  return hr;
}

/*******************************************************************

  NAME:    CreateProfileIfNecessary

  SYNOPSIS:  Creates profile if it doesn't already exist

  ENTRY:    lpProfAdmin - pointer to profile admin interface
        pszSelProfileName - name of profile to create

  EXIT:    returns an HRESULT. 

********************************************************************/
HRESULT CreateProfileIfNecessary(LPPROFADMIN pProfAdmin,TCHAR * pszSelProfileName)
{
  HRESULT hr = hrSuccess;
  LPTSTR lpProfileName=NULL;
  BOOL  fDefault;

  ASSERT(pProfAdmin);
  ASSERT(pszSelProfileName);

  ENUM_MAPI_PROFILE EnumMAPIProfile;

  // walk through the profile names, see if we have a match
  while (EnumMAPIProfile.Next(&lpProfileName,&fDefault)) {
    ASSERT(lpProfileName);

    if (!lstrcmpi(lpProfileName,pszSelProfileName)) {
      return hrSuccess;  // found a match, nothing to do
    }
  }

  // no match, need to create profile
  DEBUGMSG("Creating MAPI profile: %s",pszSelProfileName);
  // call MAPI to create the profile
  hr = pProfAdmin->CreateProfile(pszSelProfileName,
    NULL, (ULONG) 0, (ULONG) 0);

  return hr;
}


/*******************************************************************

  NAME:    InstallRequiredServices

  SYNOPSIS:  Installs the 3 services we need (message store,
        address book, internet mail) in the profile
        if they're not already present.  Calls functions to configure
        message store and address book (they both need a filename
        to use) if we're adding them.

  ENTRY:    lpServiceAdmin - pointer to service admin interface
        pServiceRowSet - MAPI table with list of installed services
        
  EXIT:    returns an HRESULT. 

  NOTES:    We deliberately don't configure internet mail service here--
        we do that in the main routine.  The reason is that we
        need to configure internet mail whether it's already installed
        or not, address book and message store we only need to configure
        if they're brand new.

********************************************************************/
HRESULT InstallRequiredServices(LPSERVICEADMIN pServiceAdmin,
  LPSRowSet pServiceRowSet)
{
  ULONG       iRow,iService;
  TCHAR       szServiceName[SMALL_BUF_LEN+1];
  LPMAPIUID     pMapiUID=NULL;
  HRESULT      hr=hrSuccess;

  // table for MAPI services we need to make sure are installed in profile
  MSGSERVICE MAPIServiceList[NUM_SERVICES] = {
    { FALSE, IDS_INTERNETMAIL_SERVICENAME, IDS_INTERNETMAIL_DESCRIPTION,FALSE, 0,0,0},
    { FALSE, IDS_MESSAGESTORE_SERVICENAME, IDS_MESSAGESTORE_DESCRIPTION,TRUE,
      IDS_MESSAGESTORE_FILENAME,IDS_MESSAGESTORE_FILENAME1,PR_PST_PATH},
    { FALSE, IDS_ADDRESSBOOK_SERVICENAME, IDS_ADDRESSBOOK_DESCRIPTION,TRUE,
      IDS_ADDRESSBOOK_FILENAME,IDS_ADDRESSBOOK_FILENAME1,PR_PAB_PATH}};

  // walk through the list of services
  for (iRow = 0;iRow < pServiceRowSet->cRows;iRow ++) {
    DEBUGMSG("Profile contains service: %s (%s)",
      pServiceRowSet->aRow[iRow].lpProps[ivalDisplayName].Value.LPSZ,
      pServiceRowSet->aRow[iRow].lpProps[ivalServiceName].Value.LPSZ);

    // for each service, walk through our array of required services,
    // and see if there's a match
    for (iService = 0;iService < NUM_SERVICES;iService ++) {
      // load the name for this service out of resource
      LoadSz(MAPIServiceList[iService].uIDServiceName,
        szServiceName,ARRAYSIZE(szServiceName));

      // compare it to the service name in the table of
      // installed services for this profile
      if (!lstrcmpi(szServiceName,
        pServiceRowSet->aRow[iRow].lpProps[ivalServiceName].Value.LPSZ)) {
         // this is a match!
        MAPIServiceList[iService].fPresent = TRUE;
        break;  // break the inner 'for' loop
      }
    }
  }


  // install any services we need which are not already present
  for (iService = 0;iService < NUM_SERVICES;iService ++) {

    if (!MAPIServiceList[iService].fPresent) {
      TCHAR szServiceDesc[MAX_RES_LEN+1];
      MSGSERVICE * pMsgService = &MAPIServiceList[iService];        

      // load the service name and description
      LoadSz(pMsgService->uIDServiceName,
        szServiceName,ARRAYSIZE(szServiceName));
      LoadSz(pMsgService->uIDServiceDescription,
        szServiceDesc,ARRAYSIZE(szServiceDesc));
      DEBUGMSG("Adding service: %s (%s)",
        szServiceDesc,szServiceName);

      // create the service
      hr = pServiceAdmin->CreateMsgService(szServiceName,
        szServiceDesc,0,0);
      if (HR_FAILED(hr))
        return hr;

      // call a creation-time config procedure if specified
      if (pMsgService->fNeedConfig) {

        // get the UID (identifier) for this service
        // based on service name, APIs downstream need this
        hr = GetServiceUID(szServiceName,pServiceAdmin,
          &pMapiUID);
        if (HR_FAILED(hr))
          return hr;
        ASSERT(pMapiUID);

        // call the proc to configure newly-created service
        hr = ConfigNewService(pServiceAdmin,pMapiUID,
          pMsgService->uIDStoreFilename,pMsgService->uIDStoreFilename1,
          pMsgService->uPropID);

        // free the buffer with the UID
        ASSERT(lpMAPIFreeBuffer);
        lpMAPIFreeBuffer(pMapiUID);
        pMapiUID = NULL;
      }
    }
  }

  return hr;
}

#define NUM_MAIL_PROPS   11
/*******************************************************************

  NAME:    ConfigInternetService

  SYNOPSIS:  Configures the Internet Mail service (route 66) with
        user's email name, email server, etc.

  ENTRY:    pMailConfigInfo - pointer to struct with configuration info
        pServiceAdmin - pointer to service admin interface

  EXIT:    returns an HRESULT

  NOTES:    will stomp any existing settings for properties that it
        sets.

********************************************************************/
HRESULT ConfigInternetService(MAILCONFIGINFO * pMailConfigInfo,
  LPSERVICEADMIN pServiceAdmin)
{
  HRESULT     hr;
  SPropValue  PropValue[NUM_MAIL_PROPS];
  TCHAR       szServiceName[SMALL_BUF_LEN+1];
  LPMAPIUID   pMapiUID=NULL;
  UINT        nProps = NUM_MAIL_PROPS;

  ASSERT(pMailConfigInfo);
  ASSERT(pServiceAdmin);

  // get service UID for internet mail service
  LoadSz(IDS_INTERNETMAIL_SERVICENAME,szServiceName,ARRAYSIZE(szServiceName));
  hr = GetServiceUID(szServiceName,pServiceAdmin,&pMapiUID);
  if (HR_FAILED(hr)) {
    return hr;
  }
  ASSERT(pMapiUID);


  // set the property value for each property.  Note that the order
  // of items in the array doesn't mattter. The ulPropTag member indicates
  // what property the PropValue item is for, and the lpszA, b or l member
  // contains the data for that property.

  // need to "encrypt" mail account password with xor bit mask.  Mail client
  // expects it to be thusly "encrypted" when it reads it out.  It's stored
  // in the registry in this securely "encrypted" format.  Somebody pretty
  // smart must have thought of this.

  // configure mail service properties
  PropValue[0].ulPropTag  = PR_CFG_EMAIL_ADDRESS;
  PropValue[0].Value.LPSZ = pMailConfigInfo->pszEmailAddress;
  PropValue[1].ulPropTag  = PR_CFG_EMAIL_DISPLAY_NAME;
  PropValue[1].Value.LPSZ = pMailConfigInfo->pszEmailDisplayName;
  PropValue[2].ulPropTag  = PR_CFG_SERVER_PATH;
  PropValue[2].Value.LPSZ = pMailConfigInfo->pszEmailServer;
  PropValue[3].ulPropTag  = PR_CFG_EMAIL_ACCOUNT;
  PropValue[3].Value.LPSZ = pMailConfigInfo->pszEmailAccountName;
  PropValue[4].ulPropTag  = PR_CFG_PASSWORD;
  PropValue[4].Value.LPSZ = (LPTSTR) szNull;
  PropValue[5].ulPropTag  = PR_CFG_REMEMBER;
  PropValue[5].Value.b    = (USHORT) TRUE;
  // configure for RNA or LAN as appropriate
  PropValue[6].ulPropTag  = PR_CFG_RNA_PROFILE;
  PropValue[7].ulPropTag  = PR_CFG_CONN_TYPE;
  PropValue[8].ulPropTag  = PR_CFG_DELIVERY_OPTIONS;
  if (pMailConfigInfo->pszConnectoidName &&
    lstrlen(pMailConfigInfo->pszConnectoidName)) {
    PropValue[6].Value.LPSZ = pMailConfigInfo->pszConnectoidName;
    PropValue[7].Value.l = (long) CONNECT_TYPE_REMOTE;
    // set transfer mode for "selective"..
    PropValue[8].Value.l = DOWNLOAD_OPTION_HEADERS;
  } else {
    PropValue[6].Value.LPSZ = (LPTSTR) szNull;
    PropValue[7].Value.l = (long) CONNECT_TYPE_LAN;
    // set automatic transfer mode... mail guys made up the weird
    // define name, not me!
    PropValue[8].Value.l = DOWNLOAD_OPTION_MAIL_DELETE;
  }
  PropValue[9].ulPropTag   = PR_CFG_REMOTE_USERNAME;
  PropValue[9].Value.LPSZ  = pMailConfigInfo->pszEmailAccountName;
  PropValue[10].ulPropTag  = PR_CFG_REMOTE_PASSWORD;
  PropValue[10].Value.LPSZ = pMailConfigInfo->pszEmailAccountPwd;

  // call the service admin interface to configure the service with these
  // properties
  hr = pServiceAdmin->ConfigureMsgService(pMapiUID,NULL,0,
    nProps,PropValue);
  if (HR_FAILED(hr)) {
    DEBUGMSG("ConfigureMsgService returned 0x%x", hr);
  }

  // free the buffer with the UID
  ASSERT(lpMAPIFreeBuffer);
  lpMAPIFreeBuffer(pMapiUID);
  pMapiUID = NULL;

  return hr;
}

/*******************************************************************

  NAME:    ConfigMessageStore

  SYNOPSIS:  Generates a unique filename and sets it as the
        message store

  ENTRY:    lpServiceAdmin - pointer to service admin interface
        lpMapiUID - UID for this service (message store)

  EXIT:    returns an HRESULT

  NOTES:    This code expects to be called only when the service is
        newly created.  Calling it on an existing service will
        cause it to stomp existing settings.
  
********************************************************************/
HRESULT ConfigNewService(LPSERVICEADMIN lpServiceAdmin,LPMAPIUID lpMapiUID,
  UINT uIDFilename,UINT uIDFilename1,UINT uPropValID)
{
  TCHAR szMsgStorePath[MAX_PATH+1];
  HRESULT hr=hrSuccess;

  ASSERT(lpServiceAdmin);
  ASSERT(lpMapiUID);

  // build a path for the message store
  if (!MakeUniqueFilename(uIDFilename,uIDFilename1,
    szMsgStorePath,sizeof(szMsgStorePath))) {
     DEBUGTRAP("Unable to create unique filename");
    return MAPI_E_COLLISION;
  }
  DEBUGMSG("Creating MAPI store %s",szMsgStorePath);

  // set this filename for the message store
  SPropValue PropVal;
  PropVal.ulPropTag = uPropValID;
  PropVal.Value.LPSZ = szMsgStorePath;
  hr = lpServiceAdmin->ConfigureMsgService(lpMapiUID,NULL,0,1,&PropVal);
  if (HR_FAILED(hr)) {
    DEBUGMSG("ConfigureMsgService returned 0x%x", hr);
  }

  return hr;
}

/*******************************************************************

  NAME:    FindInternetMailService

  SYNOPSIS:  Detects if internet mail is installed, returns
        email address and email server if it is.
  
********************************************************************/
BOOL FindInternetMailService(TCHAR * pszEmailAddress,DWORD cbEmailAddress,
  TCHAR * pszEmailServer, DWORD cbEmailServer)
{
  ASSERT(pszEmailAddress);
  ASSERT(pszEmailServer);

  if (!hInstMAPIDll && !InitMAPI(NULL))
    return FALSE;

  // look through all profiles.  For each profile, look through all
  // services.  If we find an instance of the internet mail service,
  // then return email address and password to caller.  If there is
  // more than one profile with the internet mail service, we
  // will return the first one we find.

  ENUM_MAPI_PROFILE EnumMAPIProfile;
  LPTSTR lpProfileName,lpServiceName;
  BOOL fDefault;
  // walk through the list of profiles...
  while (EnumMAPIProfile.Next(&lpProfileName,&fDefault)) {
    ASSERT(lpProfileName);

    DEBUGMSG("Found profile: %s",lpProfileName);
    
    // for each profile, walk through the list of services...
    ENUM_MAPI_SERVICE EnumMAPIService(lpProfileName);
    while (EnumMAPIService.Next(&lpServiceName)) {
      TCHAR szSmallBuf[SMALL_BUF_LEN+1];

      DEBUGMSG("Found service: %s",lpServiceName);

      if (!lstrcmpi(lpServiceName,LoadSz(IDS_INTERNETMAIL_SERVICENAME,
        szSmallBuf,ARRAYSIZE(szSmallBuf)))) {

//BUGBUG 21-May-1995 jeremys Get e-mail server & address from MAPI profile

        return TRUE;
      }
    }
  }

  return FALSE;
}               

ENUM_MAPI_PROFILE::ENUM_MAPI_PROFILE(VOID)
{
  LPPROFADMIN   pProfAdmin=NULL;  // interface to administer profiles
  HRESULT hr;

  ASSERTSZ(gpWizardState->fMAPIActive,"MAPI not initialized!");

  _pProfileRowSet = NULL;
  _nEntries = 0;
  _iRow = 0;

  // get a pointer to the interface to administer profiles
  ASSERT(lpMAPIAdminProfiles);
  hr = lpMAPIAdminProfiles(0,&pProfAdmin);
  if (HR_FAILED(hr)) {
    DEBUGMSG("MAPIAdminProfiles returned 0x%lx",hr);
    return;
  }
  ASSERT(pProfAdmin);
  // release this interface when we leave the function
  RELEASE_ME_LATER ReleaseProfAdminLater(pProfAdmin);

  // get the rows in the profile table
  hr = GetProfileList(pProfAdmin,&_pProfileRowSet);
  if (HR_FAILED(hr))
    return;
  ASSERT(_pProfileRowSet);

  _nEntries = _pProfileRowSet->cRows;

}

ENUM_MAPI_PROFILE::~ENUM_MAPI_PROFILE(VOID)
{
  if (_pProfileRowSet) {
    // done with profile row set, free the table
    FreeSRowSet(_pProfileRowSet);
    _pProfileRowSet = NULL;
  }
}

BOOL ENUM_MAPI_PROFILE::Next(LPTSTR * ppProfileName,BOOL * pfDefault)
{
  ASSERT(pfDefault);

  if (!_pProfileRowSet)
    return FALSE;

  if (_iRow < _pProfileRowSet->cRows) {
    LPSPropValue pPropVal = _pProfileRowSet->aRow[_iRow].lpProps;
    ASSERT(pPropVal);

    // get pointer to profile name
    *ppProfileName = pPropVal[0].Value.LPSZ;
    ASSERT(*ppProfileName);
    // set 'this profile is default' flag
    *pfDefault = pPropVal[2].Value.b;

    _iRow++;
    return TRUE;
  }
  
  return FALSE;
}

ENUM_MAPI_SERVICE::ENUM_MAPI_SERVICE(LPTSTR pszProfileName)
{
  LPPROFADMIN   pProfAdmin=NULL;  // interface to administer profiles
  LPSERVICEADMIN  pServiceAdmin=NULL;  // interface to administer services
  HRESULT hr;

  ASSERT(pszProfileName);
  ASSERTSZ(gpWizardState->fMAPIActive,"MAPI not initialized!");

  _pServiceRowSet = NULL;
  _nEntries = 0;
  _iRow = 0;

  // get a pointer to the interface to administer profiles
  ASSERT(lpMAPIAdminProfiles);
  hr = lpMAPIAdminProfiles(0,&pProfAdmin);
  if (HR_FAILED(hr)) {
    DEBUGMSG("MAPIAdminProfiles returned 0x%lx",hr);
    return;
  }
  ASSERT(pProfAdmin);
  // release this interface when we leave the function
  RELEASE_ME_LATER ReleaseProfAdminLater(pProfAdmin);

  // get a pointer to the interface to administer services for this profile
  hr = pProfAdmin->AdminServices(pszProfileName,NULL,NULL,0,
    &pServiceAdmin);
  if (HR_FAILED(hr)) {
    DEBUGMSG("AdminServices returned 0x%lx",hr);
    return;
  }
  // release this interface when we leave the function
  RELEASE_ME_LATER ReleaseServiceAdminLater(pServiceAdmin);

  // get the rows in the profile table
  hr = GetServicesList(pServiceAdmin,&_pServiceRowSet);
  if (HR_FAILED(hr))
    return;
  ASSERT(_pServiceRowSet);

  _nEntries = _pServiceRowSet->cRows;

}

ENUM_MAPI_SERVICE::~ENUM_MAPI_SERVICE(VOID)
{
  if (_pServiceRowSet) {
    // done with profile row set, free the table
    FreeSRowSet(_pServiceRowSet);
    _pServiceRowSet = NULL;
  }
}

BOOL ENUM_MAPI_SERVICE::Next(LPTSTR * ppServiceName)
{
  if (!_pServiceRowSet)
    return FALSE;

  if (_iRow < _pServiceRowSet->cRows) {
    LPSPropValue pPropVal = _pServiceRowSet->aRow[_iRow].lpProps;
    ASSERT(pPropVal);

    // get pointer to profile name
    *ppServiceName = pPropVal[ivalServiceName].Value.LPSZ;
    ASSERT(*ppServiceName);

    _iRow++;
    return TRUE;
  }
  
  return FALSE;
}

/*******************************************************************

  NAME:    MakeUniqueFilename

  SYNOPSIS:  Generates a filename in the Windows directory that
        does not already exist

  ENTRY:    uIDFilename - ID of string resource for desired name
          for the file
        uIDAltFilename - ID of string resource with template
          for filename to use if file with uIDFilename's name
          already exists.  Template should contain %u into
          which numbers will be inserted to make filename unique.
        pszFilename - buffer to return path and filename into
        cbFilename - size of pszFilename buffer

  EXIT:    returns TRUE if successful, FALSE if couldn't make
        unique filename within MAX_FILENAME_TRIES tries
  
********************************************************************/
// number of times we'll try to create a unique filename before giving up
#define MAX_MAKEFILENAME_TRIES  20
BOOL MakeUniqueFilename(UINT uIDFilename,UINT uIDAltFilename,
  TCHAR * pszFilename,DWORD cbFilename)
{
  TCHAR szFileName[SMALL_BUF_LEN+1];
  BOOL fSuccess = FALSE;

  ASSERT(pszFilename);

  // build a path for the filename
  UINT uRet=GetWindowsDirectory(pszFilename,cbFilename);
  ASSERTSZ(uRet,"GetWindowsDirectory failed");

  // choose a file name that doesn't already exist

  // first, try using the string resource specified by uIDFilename
  LoadSz(uIDFilename,szFileName,ARRAYSIZE(szFileName));
  if (DoesFileExist(pszFilename,szFileName)) {

    // if that file exists, then use the string resource uIDAltFilename
    // which has a replacable parameter.  We'll try adding numbers to
    // the filename to make it unique.
    
    TCHAR szFileFmt[SMALL_BUF_LEN+1];
    LoadSz(uIDAltFilename,szFileFmt,ARRAYSIZE(szFileFmt));

    for (UINT nIndex = 0; nIndex < MAX_MAKEFILENAME_TRIES; nIndex ++) {
      // make a name e.g. "mailbox4.pst"
      wsprintf(szFileName,szFileFmt,nIndex);
      if (!DoesFileExist(pszFilename,szFileName)) {
        // OK, found a filename that doesn't exist
        fSuccess = TRUE;
        break;
      }
    }
  } else {
    // first try succeeded  
    fSuccess = TRUE;
  }

  if (fSuccess) {
    // now we have unique filename, build the full path

    lstrcat(pszFilename,szSlash);
    lstrcat(pszFilename,szFileName);
  }

  return fSuccess;
}

/*******************************************************************

  NAME:    DoesFileExist

  SYNOPSIS:  Checks to see whether the specified file exists

  ENTRY:    pszPath - path to directory
        pszFilename - name of file

  EXIT:    returns TRUE if file exists, FALSE if it doesn't
  
********************************************************************/
BOOL DoesFileExist(TCHAR * pszPath,TCHAR * pszFileName)
{
  CHAR      szPath[MAX_PATH+1];
  OFSTRUCT  of;

  ASSERT(pszPath);
  ASSERT(pszFileName);

  // concatenate the path and file name
#ifdef UNICODE
  TCHAR     szTmp[MAX_PATH+1];

  lstrcpy(szTmp,pszPath);
  lstrcat(szTmp,szSlash);
  lstrcat(szTmp,pszFileName);
  
  wcstombs(szPath, szTmp, MAX_PATH+1);
#else
  lstrcpy(szPath,pszPath);
  lstrcat(szPath,szSlash);
  lstrcat(szPath,pszFileName);
#endif

  // find out if this file exists
  return (OpenFile(szPath,&of,OF_EXIST) != HFILE_ERROR);
}

/*******************************************************************

  NAME:    GetServiceUID

  SYNOPSIS:  Given a MAPI service name, gets the MAPIUID associated
        with it.

  ENTRY:    pszServiceName - name of MAPI service (e.g. "IMAIL","MSPST AB")
        lpServiceAdmin - pointer to service admin interface
        ppMapiUID - pointer to pointer for MAPIUID struct
  
  EXIT:    returns an HRESULT

  NOTES:    Cloned from MAPI profile wizard code, if you think this
        function is big and ugly now you should have seen it before
        I cleaned it up.

        This function allocates a MAPIUID, the caller is responsible
        for freeing this (use MAPIFreeBuffer) when done.
  
********************************************************************/
HRESULT   GetServiceUID(TCHAR * pszServiceName,LPSERVICEADMIN lpServiceAdmin,
  LPMAPIUID *ppMapiUID)
{
  HRESULT      hr =hrSuccess;
  LPSPropValue  pTblProp =NULL;
  DWORD         iRow,iColumn;
  LPMAPITABLE     pTable =NULL;
  LPSRowSet    pRowSet =NULL;
  LPSRow      pRow =NULL;
  int        nFound =0;
  LPMAPIUID    pMapiUID =NULL;
  BOOL      fContinue = TRUE;
  SizedSPropTagArray(2, Tbltaga) = { 2, { PR_SERVICE_NAME,
                      PR_SERVICE_UID }};

  ASSERT(pszServiceName);
  ASSERT(lpServiceAdmin);
  ASSERT(ppMapiUID);

  // get table of message services
  hr = lpServiceAdmin->GetMsgServiceTable(0, &pTable);
  if (HR_FAILED(hr))
  {
    DEBUGMSG("GetMsgServiceTable returned 0x%x", hr);
    return hr;
  }
  ASSERT(pTable);
  // release this table when we exit this function
  RELEASE_ME_LATER rlTable(pTable);

  ASSERT(lpHrQueryAllRows);
  hr = lpHrQueryAllRows(pTable, (LPSPropTagArray) &Tbltaga, NULL, NULL, 0, &pRowSet);
  if (HR_FAILED(hr))
  {
    DEBUGMSG("HrQueryAllRows returned 0x%x", hr);
    return hr;
  }
  ASSERT(pRowSet);

  iRow =0;
  while (fContinue && iRow< pRowSet->cRows)
  {
    pRow = &pRowSet->aRow[iRow];
    pTblProp = pRow->lpProps;
    nFound = 0;
    for (iColumn=0; iColumn<pRow->cValues; iColumn++)
    {   //Check each property
      if (pTblProp->ulPropTag ==PR_SERVICE_UID)
      {
        nFound++;
        ASSERT(lpMAPIAllocateBuffer);
        lpMAPIAllocateBuffer(pTblProp->Value.bin.cb, (LPVOID FAR *) &pMapiUID);
        if (!pMapiUID)
        {
          hr = MAPI_E_NOT_ENOUGH_MEMORY;
          fContinue = FALSE;
          break;
        }
        memcpy(pMapiUID, pTblProp->Value.bin.lpb, (size_t) pTblProp->Value.bin.cb);
        *ppMapiUID = pMapiUID;
      }
      else if ((pTblProp->ulPropTag ==PR_SERVICE_NAME) &&
           !lstrcmpi(pTblProp->Value.LPSZ, pszServiceName))
      {
        nFound++;
      }
      pTblProp++;

      if (nFound == 2) {
        // found it!
        fContinue = FALSE;
        break;
      }
    }
    iRow++;

    if (nFound < 2) {    
    // if one but not both items matched above, then deallocate buffer
      if (pMapiUID) {
        ASSERT(lpMAPIFreeBuffer);
        lpMAPIFreeBuffer(pMapiUID);
        pMapiUID =NULL;
      }
      if (*ppMapiUID)
        *ppMapiUID = NULL;
    }
  }

  if (HR_FAILED(hr) || nFound < 2) {
    // free buffer if we didn't find the UID
    if (pMapiUID) {
      ASSERT(lpMAPIFreeBuffer);
      lpMAPIFreeBuffer(pMapiUID);
    }
    if (*ppMapiUID)
      *ppMapiUID = NULL;
  }

  if (pRowSet)
    FreeSRowSet(pRowSet);

  return hr;
}

/*******************************************************************

  NAME:    FreeSRowSet

  SYNOPSIS:  Frees an SRowSet structure and the rows therein

  ENTRY:    prws - the row set to free

  NOTES:    Cloned from MAPI profile ctrl panel code

********************************************************************/
VOID FreeSRowSet(LPSRowSet prws)
{
  ULONG irw;

  if (!prws)
    return;

  ASSERT(lpMAPIFreeBuffer);

  // Free each row
  for (irw = 0; irw < prws->cRows; irw++)
    lpMAPIFreeBuffer(prws->aRow[irw].lpProps);

  // Free the top level structure
  lpMAPIFreeBuffer(prws);
}

/*
 *  ValidateProperty
 *
 *  Purpose:
 *    Given a string prop, make sure it contains a valid string.
 *
 *  Arguments:
 *    pval
 *    cVal
 *    ulPropTag
 *
 *  Returns:
 *    BOOL
 */
TCHAR szUnk[] = TEXT("???");
BOOL ValidateProperty(LPSPropValue pval, ULONG cVal, ULONG ulPropTag)
{
  if(pval[cVal].ulPropTag != ulPropTag)
  {
    // make sure we're not stomping on good properties.
    ASSERT(PROP_TYPE(pval[cVal].ulPropTag) == PT_ERROR);

    pval[cVal].ulPropTag = ulPropTag;
    pval[cVal].Value.LPSZ = szUnk;

    return TRUE;
  }

  return FALSE;
}

#pragma data_seg(DATASEG_READONLY)
// note: this array depends on errors in rc file being in this order
// starting with S_OK.  Don't rearrange one without rearranging the other.
static SCODE mpIdsScode[] =
{
    S_OK,
    MAPI_E_NO_ACCESS,
    E_NOINTERFACE,
    E_INVALIDARG,
    MAPI_E_CALL_FAILED,
    MAPI_E_NOT_FOUND,
    MAPI_E_NO_SUPPORT,
    MAPI_W_ERRORS_RETURNED,
    MAPI_W_PARTIAL_COMPLETION,
    MAPI_E_BAD_CHARWIDTH,
    MAPI_E_BAD_VALUE,
    MAPI_E_BUSY,
    MAPI_E_COLLISION,
    MAPI_E_COMPUTED,
    MAPI_E_CORRUPT_DATA,
    MAPI_E_CORRUPT_STORE,
    MAPI_E_DISK_ERROR,
    MAPI_E_HAS_FOLDERS,
    MAPI_E_HAS_MESSAGES,
    MAPI_E_INVALID_ENTRYID,
    MAPI_E_INVALID_OBJECT,
    MAPI_E_LOGON_FAILED,
    MAPI_E_NETWORK_ERROR,
    MAPI_E_NON_STANDARD,
    MAPI_E_NOT_ENOUGH_DISK,
    MAPI_E_NOT_ENOUGH_MEMORY,
    MAPI_E_NOT_ENOUGH_RESOURCES,
    MAPI_E_NOT_IN_QUEUE,
    MAPI_E_OBJECT_CHANGED,
    MAPI_E_OBJECT_DELETED,
    MAPI_E_STRING_TOO_LONG,
    MAPI_E_SUBMITTED,
    MAPI_E_TOO_BIG,
    MAPI_E_UNABLE_TO_ABORT,
    MAPI_E_UNCONFIGURED,
    MAPI_E_UNEXPECTED_TYPE,
    MAPI_E_UNKNOWN_FLAGS,
    MAPI_E_USER_CANCEL,
    MAPI_E_VERSION
};
#pragma data_seg()

/*******************************************************************

  NAME:    GetMAPIErrorText

  SYNOPSIS:  Gets text string corresponding to MAPI error code

  ENTRY:    uErr - MAPI error code
        pszErrText - buffer to retrieve error text description
        cbErrText - size of pszErrText buffer

  NOTES:    based on MapScodeSz from MAPI SDK.  There is, alas,
        no function built into MAPI to do this.  Every app
        must include all text strings for every error code,
        and will be broken on any error codes MAPI invents
        after the app ships.  Numbskulls.

********************************************************************/
VOID GetMAPIErrorText(UINT uErr,TCHAR * pszErrText,DWORD cbErrText)
{
  ASSERT(pszErrText);
  
  SCODE scErr = (SCODE) uErr;
  UINT nIndex,nMax;

  // get facility code, facility is bits 17-30 in scode
  DWORD dwFacility = (scErr >> 16) & (0x7FFF);

  // if this is a WIN32 code wrapped in an scode, call GetErrorDescription
  // to get the text, which will get the text out of Windows and do a much
  // better job than this crappy little function will
  if (dwFacility == FACILITY_WIN32) 
    GetErrorDescription(pszErrText,cbErrText,
      (scErr & 0xFFFF),ERRCLS_STANDARD);

    /* Linear search in mpIdsScode for scArg.  When found, index is IDS. */
    nMax = sizeof mpIdsScode / sizeof mpIdsScode[0];
    for (nIndex = 0; nIndex < nMax; nIndex++)
    {
        if (mpIdsScode[nIndex] == scErr)
            break;
    }

  if (nIndex < nMax) {
    // found the code in the table
    LoadSz(IDS_MAPIERROR_BASE + nIndex,pszErrText,cbErrText);
  } else {
    // didn't find the code in the table, make a generic string
    // with the error number
    TCHAR szFmt[SMALL_BUF_LEN+1];
    LoadSz(IDS_GENERIC_MAPI_ERROR,szFmt,ARRAYSIZE(szFmt));
    wsprintf(pszErrText,szFmt,scErr);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\pch.cpp ===
#include "wizard.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\propmgr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  PROPMGR.C - Sets up wizard property sheets and runs wizard
//

//  HISTORY:
//  
//  12/21/94  jeremys  Created.
//  96/03/07  markdu  Stop using CLIENTCONFIG modem enum stuff,
//            since we enum modems later with RNA.  This means that we
//            can't use modem count for any default setting determination
//            in InitUserInfo anymore.
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/03/25  markdu  If a page OK proc returns FALSE, check the state of
//            gfQuitWizard flag.  If TRUE, a fatal error has occured.
//  96/03/25  markdu  If a page init proc returns FALSE, check the state of
//            gfQuitWizard flag.  If TRUE, a fatal error has occured.
//  96/03/27  markdu  Added lots of new pages.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//  96/05/06  markdu  NASH BUG 15637 Removed unused code.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/27  markdu  Use lpIcfgNeedInetComponents.
//  96/05/28  markdu  Moved InitConfig and DeInitConfig to DllEntryPoint.
//
//    97/04/23  jmazner    Olympus #3136
//                        Ripped out all mail/news/ldap UI and gave it to
//                        the account manager folks.
//
//    01/01/20  chunhoc   Add MyRestartDialog
//                      
//

#include "wizard.h"
#define DONT_WANT_SHELLDEBUG
#include <shlobj.h>
#include <winuserp.h>
#include "pagefcns.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"
#include "inetcfg.h"
#include <icwcfg.h>
#if !defined(WIN16)
#include <helpids.h>
#endif // !WIN16

#define WIZ97_TITLE_FONT_PTS    12
#define OE_PATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\MSIMN.EXE")
#define NEWOEVERSION TEXT("5.00.0809\0")
#define MAX_VERSION_LEN 40
#define BITMAP_WIDTH  164
#define BITMAP_HEIGHT 458

#define RECTWIDTH(rc) ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)

//dlg IDs of first and last apprentice pages
UINT    g_uAcctMgrUIFirst, g_uAcctMgrUILast; 
CICWExtension *g_pCICWExtension = NULL;
BOOL    g_fAcctMgrUILoaded = FALSE;
BOOL    g_fIsWizard97 = FALSE;
BOOL    g_fIsExternalWizard97 = FALSE;
BOOL    g_fIsICW = FALSE;
INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
VOID InitWizardState(WIZARDSTATE * pWizardState, DWORD dwFlags);
VOID InitUserInfo(USERINFO * pUserInfo);
VOID InitIMNApprentice();
UINT GetDlgIDFromIndex(UINT uPageIndex);
BOOL SystemAlreadyConfigured(USERINFO * pUserInfo);
BOOL CALLBACK MiscInitProc(HWND hDlg, BOOL fFirstInit, UINT uDlgID);
BOOL GetShellNextFromReg( LPTSTR lpszCommand, LPTSTR lpszParams, DWORD dwStrLen );
void RemoveShellNextFromReg( void );


//in util.cpp
extern void GetCmdLineToken(LPTSTR *ppszCmd,LPTSTR pszOut);


extern ICFGNEEDSYSCOMPONENTS        lpIcfgNeedInetComponents;
extern ICFGGETLASTINSTALLERRORTEXT  lpIcfgGetLastInstallErrorText;

BOOL gfQuitWizard = FALSE;  // global flag used to signal that we
              // want to terminate the wizard ourselves
BOOL gfUserCancelled = FALSE;    // global flag used to signal that
                                // the user cancelled
BOOL gfUserBackedOut = FALSE;    // global flag used to signal that
                                // the user pressed Back on the
                                // first page
BOOL gfUserFinished = FALSE;    // global flag used to signal that
                                // the user pressed Finish on the
                                // final page
BOOL gfOleInitialized = FALSE;    // OLE has been initialized

//IImnAccount *g_pMailAcct = NULL;
//IImnAccount *g_pNewsAcct = NULL;
//IImnAccount *g_pDirServAcct = NULL;


BOOL AllocDialogIDList( void );
BOOL DialogIDAlreadyInUse( UINT uDlgID );
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse );
BOOL DeinitWizard(DWORD dwFlags );
DWORD *g_pdwDialogIDList = NULL;
DWORD g_dwDialogIDListSize = 0;

//
// Added to preserve the REBOOT state from conn1 -> manual and 
// manual -> conn1 - MKarki
//
static BOOL gfBackedUp = FALSE;
static BOOL gfReboot = FALSE;
//
// Table of data for each wizard page
//
// This includes the dialog template ID and pointers to functions for
// each page.  Pages need only provide pointers to functions when they
// want non-default behavior for a certain action (init,next/back,cancel,
// dlg ctrl).
//

PAGEINFO PageInfo[NUM_WIZARD_PAGES] =
{
  { IDD_PAGE_HOWTOCONNECT,       IDD_PAGE_HOWTOCONNECT97,         IDD_PAGE_HOWTOCONNECT97FIRSTLAST,HowToConnectInitProc,    HowToConnectOKProc,     NULL,                   NULL,ICW_SETUP_MANUAL,      0,                          0 },
  { IDD_PAGE_CHOOSEMODEM,        IDD_PAGE_CHOOSEMODEM97,          IDD_PAGE_CHOOSEMODEM97,          ChooseModemInitProc,     ChooseModemOKProc,      ChooseModemCmdProc,     NULL,ICW_CHOOSE_MODEM,      IDS_CHOOSEMODEM_TITLE,      0 },
  { IDD_PAGE_CONNECTEDOK,        IDD_PAGE_CONNECTEDOK97,          IDD_PAGE_CONNECTEDOK97FIRSTLAST, ConnectedOKInitProc,     ConnectedOKOKProc,      NULL,                   NULL,ICW_COMPLETE,          0,                          0 },
  { IDD_PAGE_CONNECTION,         IDD_PAGE_CONNECTION97,           IDD_PAGE_CONNECTION97,           ConnectionInitProc,      ConnectionOKProc,       ConnectionCmdProc,      NULL,ICW_DIALUP_CONNECTION, IDS_CONNECTION_TITLE,       0 },
  { IDD_PAGE_MODIFYCONNECTION,   IDD_PAGE_MODIFYCONNECTION97,     IDD_PAGE_MODIFYCONNECTION97,     ModifyConnectionInitProc,ModifyConnectionOKProc, NULL,                   NULL,ICW_DIALUP_SETTINGS,   IDS_MODIFYCONNECTION_TITLE, 0 },
  { IDD_PAGE_CONNECTIONNAME,     IDD_PAGE_CONNECTIONNAME97,       IDD_PAGE_CONNECTIONNAME97,       ConnectionNameInitProc,  ConnectionNameOKProc,   NULL,                   NULL,ICW_DIALUP_NAME,       IDS_CONNECTIONNAME_TITLE,   0 },
  { IDD_PAGE_PHONENUMBER,        IDD_PAGE_PHONENUMBER97,          IDD_PAGE_PHONENUMBER97,          PhoneNumberInitProc,     PhoneNumberOKProc,      PhoneNumberCmdProc,     NULL,ICW_PHONE_NUMBER,      IDS_PHONENUMBER_TITLE,      0 },
  { IDD_PAGE_NAMEANDPASSWORD,    IDD_PAGE_NAMEANDPASSWORD97,      IDD_PAGE_NAMEANDPASSWORD97,      NameAndPasswordInitProc, NameAndPasswordOKProc,  NULL,                   NULL,ICW_NAME_PASSWORD,     IDS_NAMEANDPASSWORD_TITLE,  0 },
  { IDD_PAGE_USEPROXY,           IDD_PAGE_USEPROXY97,             IDD_PAGE_USEPROXY97,             UseProxyInitProc,        UseProxyOKProc,         UseProxyCmdProc,        NULL,ICW_USE_PROXY,         IDS_LAN_INETCFG_TITLE,      0 },
  { IDD_PAGE_PROXYSERVERS,       IDD_PAGE_PROXYSERVERS97,         IDD_PAGE_PROXYSERVERS97,         ProxyServersInitProc,    ProxyServersOKProc,     ProxyServersCmdProc,    NULL,ICW_PROXY_SERVERS,     IDS_LAN_INETCFG_TITLE,      0 },
  { IDD_PAGE_PROXYEXCEPTIONS,    IDD_PAGE_PROXYEXCEPTIONS97,      IDD_PAGE_PROXYEXCEPTIONS97,      ProxyExceptionsInitProc, ProxyExceptionsOKProc,  NULL,                   NULL,ICW_PROXY_EXCEPTIONS,  IDS_LAN_INETCFG_TITLE,      0 },
  { IDD_PAGE_SETUP_PROXY,        IDD_PAGE_SETUP_PROXY97,          IDD_PAGE_SETUP_PROXY97,          SetupProxyInitProc,      SetupProxyOKProc,       SetupProxyCmdProc,      NULL,ICW_SETUP_PROXY,       IDS_LAN_INETCFG_TITLE,      0 }
};



BOOL CheckOEVersion()
{
    HRESULT hr;
    HKEY    hKey = 0;
    LPVOID  lpVerInfoBlock;
    LPVOID  lpTheVerInfo;
    UINT    uTheVerInfoSize;
    DWORD   dwVerInfoBlockSize, dwUnused, dwPathSize;
    TCHAR   szOELocalPath[MAX_PATH + 1] = TEXT("");
    TCHAR   szSUVersion[MAX_VERSION_LEN];
    DWORD   dwVerPiece;
    DWORD   dwType;
    int     nResult = -1;
    
    // get path to the IE executable
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, OE_PATHKEY,0, KEY_READ, &hKey);
    if (hr != ERROR_SUCCESS) return( FALSE );

    dwPathSize = sizeof (szOELocalPath);
    if (ERROR_SUCCESS == (hr = RegQueryValueEx(hKey, NULL, NULL, &dwType, (LPBYTE) szOELocalPath, &dwPathSize)))
    {
        if (REG_EXPAND_SZ == dwType)
        {
            TCHAR szTemp[MAX_PATH + 1] = TEXT("");
            ExpandEnvironmentStrings(szOELocalPath, szTemp, ARRAYSIZE(szTemp));
            lstrcpyn(szOELocalPath, szTemp, ARRAYSIZE(szOELocalPath));
        }
    }
    RegCloseKey( hKey );
    if (hr != ERROR_SUCCESS) return( FALSE );

    // now go through the convoluted process of digging up the version info
    dwVerInfoBlockSize = GetFileVersionInfoSize( szOELocalPath, &dwUnused );
    if ( 0 == dwVerInfoBlockSize ) return( FALSE );

    lpVerInfoBlock = GlobalAlloc( GPTR, dwVerInfoBlockSize );
    if( NULL == lpVerInfoBlock ) return( FALSE );

    if( !GetFileVersionInfo( szOELocalPath, NULL, dwVerInfoBlockSize, lpVerInfoBlock ) )
        return( FALSE );

    if( !VerQueryValue(lpVerInfoBlock, TEXT("\\\0"), &lpTheVerInfo, &uTheVerInfoSize) )
        return( FALSE );

    lpTheVerInfo = (LPVOID)((DWORD_PTR)lpTheVerInfo + sizeof(DWORD)*4);
    szSUVersion[0] = 0;
    dwVerPiece = (*((LPDWORD)lpTheVerInfo)) >> 16;
    wsprintf(szSUVersion,TEXT("%d."),dwVerPiece);

    dwVerPiece = (*((LPDWORD)lpTheVerInfo)) & 0x0000ffff;
    wsprintf(szSUVersion,TEXT("%s%02d."),szSUVersion,dwVerPiece);

    dwVerPiece = (((LPDWORD)lpTheVerInfo)[1]) >> 16;
    wsprintf(szSUVersion,TEXT("%s%04d."),szSUVersion,dwVerPiece);

    //dwVerPiece = (((LPDWORD)lpTheVerInfo)[1]) & 0x0000ffff;
    //wsprintf(szSUVersion,"%s%01d",szSUVersion,dwVerPiece);

    nResult = lstrcmp(szSUVersion, NEWOEVERSION);

    GlobalFree( lpVerInfoBlock );

    return( nResult >= 0 );
}

/*******************************************************************

  NAME:    RunSignupWizard

  SYNOPSIS:  Creates property sheet pages, initializes wizard
        property sheet and runs wizard

  ENTRY:    dwFlags - RSW_ flags for signup wizard
          RSW_NOREBOOT - inhibit reboot message.  Used if
          we are being run by some setup entity which needs
          to reboot anyway.

            hwndParent - The parent window of the wizard.

  EXIT:    returns TRUE if user runs wizard to completion,
        FALSE if user cancels or an error occurs

  NOTES:    Wizard pages all use one dialog proc (GenDlgProc).
        They may specify their own handler procs to get called
        at init time or in response to Next, Cancel or a dialog
        control, or use the default behavior of GenDlgProc.

********************************************************************/
BOOL InitWizard(DWORD dwFlags, HWND hwndParent /* = NULL */)
{
    HPROPSHEETPAGE hWizPage[NUM_WIZARD_PAGES];  // array to hold handles to pages
    PROPSHEETPAGE psPage;    // struct used to create prop sheet pages
    PROPSHEETHEADER psHeader;  // struct used to run wizard property sheet
    UINT nPageIndex;
    int iRet;
    HRESULT hr;

    ASSERT(gpWizardState);   // assert that global structs have been allocated
    ASSERT(gpUserInfo);

    // We are in Wizard 97 Mode
    g_fIsWizard97  = TRUE;
  
    //register the Native font control so the dialog won't fail
    //although it's registered in the exe this is a "just in case"
    HINSTANCE hComCtl = LoadLibrary(TEXT("comctl32.dll"));
    if (hComCtl)
    {
        
        PFNInitCommonControlsEx pfnInitCommonControlsEx = NULL;

        if (pfnInitCommonControlsEx = (PFNInitCommonControlsEx)GetProcAddress(hComCtl,"InitCommonControlsEx"))
        {
            //register the Native font control so the dialog won't fail
            INITCOMMONCONTROLSEX iccex;
            iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
            iccex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
            if (!pfnInitCommonControlsEx(&iccex))
                return FALSE;
        }
        FreeLibrary(hComCtl);
    }
    
    AllocDialogIDList();

    if( !gfOleInitialized )
    {
        // initialize OLE
        hr = CoInitialize(NULL);
        if (S_OK != hr && S_FALSE != hr)
        {
          DisplayErrorMessage(NULL,IDS_ERRCoInitialize,(UINT) hr,
            ERRCLS_STANDARD,MB_ICONEXCLAMATION);
          return FALSE;    
        }
        gfOleInitialized = TRUE;
    }

    // initialize mail/news set up options
    InitIMNApprentice();

    if (!(dwFlags & RSW_NOINIT))
    {

        // initialize the rasentry structure
        InitRasEntry(gpRasEntry);

        // initialize the app state structure
        InitWizardState(gpWizardState, dwFlags);

        // save flags away
        gpWizardState->dwRunFlags = dwFlags;

        // initialize user data structure
        InitUserInfo(gpUserInfo);

        //
        // 7/8/97 jmazner Olympus #9040
        // this init needs to happen every time, because whenever we
        // back out, we kill the apprentice. (see comment in RunSignupWizardExit)
        // initialize mail/news set up options
        //InitIMNApprentice();
        //

        // get proxy server config information
        hr = InetGetProxy(&gpUserInfo->fProxyEnable,
          gpUserInfo->szProxyServer, sizeof(gpUserInfo->szProxyServer),
          gpUserInfo->szProxyOverride, sizeof(gpUserInfo->szProxyOverride));

        // return value will be ERROR_FILE_NOT_FOUND if the entry does not exist
        // in the registry.  Allow this, since we have zerod the structure.
        if ((ERROR_SUCCESS != hr) && (ERROR_FILE_NOT_FOUND != hr))
        {
          DisplayErrorMessage(NULL,IDS_ERRReadConfig,(UINT) hr,
            ERRCLS_STANDARD,MB_ICONEXCLAMATION);
          iRet = 0;
          return FALSE;
        }

        // if we're in Plus! setup and the system seems to already be set up
        // for the internet, then pop up a message box asking if the user wants
        // to keep her current settings (and not run the wizard)
        if ( (dwFlags & RSW_NOREBOOT) && SystemAlreadyConfigured(gpUserInfo))
        {
          if (MsgBox(NULL,IDS_SYSTEM_ALREADY_CONFIGURED,MB_ICONQUESTION,MB_YESNO)
            == IDYES) {
              iRet = 0;
              return FALSE;
          }
        }
    }

    //
    // 6/4/97 jmazner Olympus #4245
    // Now that we're done with SystemAlreadyConfigured, clear out szISPName.
    // We don't want it to wind up as the default name for any new connectoids
    // the user creates.
    //
    gpUserInfo->szISPName[0] = '\0';
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function:    MyRestartDialog
//
//    Synopsis:    Supported RestartDialogEx in Whistler while maintaining
//                  backward compatibility
//
//    Arguments:   hwnd - handle to the owner window
//                  lpPrompt - additional string appear in the restart dialog
//                  dwReturn - restart type, prefixed by EWX_
//                  dwReasonCode - restart code defined in winuserp.h
//
//    Returns:    IDYES or IDNO
//
//    History:    chunhoc 20/01/2001
//
//-----------------------------------------------------------------------------
int WINAPI
MyRestartDialog(HWND hwnd, LPCTSTR lpPrompt,  DWORD dwReturn, DWORD dwReasonCode)
{

typedef int (WINAPI *PFNRestartDialog)(HWND hwnd, LPCTSTR lpPrompt, DWORD dwReturn);
typedef int (WINAPI *PFNRestartDialogEx)(HWND hwnd, LPCTSTR lpPrompt, DWORD dwReturn, DWORD dwReasonCode);

    const int RESTARTDIALOG_ORDINAL = 59;
    const int RESTARTDIALOGEX_ORDINAL = 730;
    
    int retval = IDNO;
    HINSTANCE hShell32 = NULL;

    hShell32 = LoadLibrary(TEXT("shell32.dll"));

    if (hShell32)
    {
        PFNRestartDialogEx pfnRestartDialogEx = NULL;
  
        pfnRestartDialogEx = (PFNRestartDialogEx) GetProcAddress(hShell32, (LPCSTR)(INT_PTR)RESTARTDIALOGEX_ORDINAL);

        if (pfnRestartDialogEx)
        {
            retval = pfnRestartDialogEx(hwnd, lpPrompt, dwReturn, dwReasonCode);
        }
        else
        {
            PFNRestartDialog   pfnRestartDialog = NULL;

            pfnRestartDialog   = (PFNRestartDialog) GetProcAddress(hShell32, (LPCSTR)(INT_PTR)RESTARTDIALOG_ORDINAL);

            if (pfnRestartDialog)
            {
                retval = pfnRestartDialog(hwnd, lpPrompt, dwReturn);                
            }
        }
        FreeLibrary(hShell32);
    }

    return retval;

}

BOOL DeinitWizard(DWORD dwFlags)
{
    // uninitialize RNA and unload it, if loaded
    DeInitRNA();

    // unintialize MAPI and unload it, if loaded
    DeInitMAPI();

    //
    // restart system if necessary, and only if we are not in
    // backup mode -MKarki Bug #404
    //

    // Note: 0x42 is the EW_RESTARTWINDOWS constant, however it is not defined
    // in the NT5 headers.
    if (gfBackedUp == FALSE)
    {
      if (gpWizardState->fNeedReboot && !(dwFlags & RSW_NOREBOOT) )
      {
        if ( g_bRebootAtExit ) 
        {
          MyRestartDialog(
            NULL,
            NULL,
            EW_RESTARTWINDOWS, 
            REASON_PLANNED_FLAG | REASON_SWINSTALL);
        }
      }
    }

    //
    // 7/8/97 jmazner Olympus #9040
    // When we back out of the manual path and into icwconn1, we kill inetcfg's
    // property sheet -- it gets rebuilt if the user re-enters the manual path
    // Because of this, we must unload the Apprentice when we exit, and then
    // reload the Apprentice if we return, so that it can re-add its pages to
    // the newly recreated property sheet.
    //
    //if (!(dwFlags & RSW_NOFREE))
    //{
    //

    if (gfOleInitialized)
        CoUninitialize();
    gfOleInitialized = FALSE;

    if( g_pdwDialogIDList )
    {
        GlobalFree(g_pdwDialogIDList);
        g_pdwDialogIDList = NULL;
    }

    g_fAcctMgrUILoaded = FALSE;

    if( g_pCICWExtension )
    {
        g_pCICWExtension->Release();
        g_pCICWExtension = NULL;
    }

    if (!(dwFlags & RSW_NOFREE))
    {
        RemoveShellNextFromReg();
    }

    return TRUE;
}

/*******************************************************************

  NAME:    RunSignupWizard

  SYNOPSIS:  Creates property sheet pages, initializes wizard
        property sheet and runs wizard

  ENTRY:    dwFlags - RSW_ flags for signup wizard
          RSW_NOREBOOT - inhibit reboot message.  Used if
          we are being run by some setup entity which needs
          to reboot anyway.

            hwndParent - The parent window of the wizard.

  EXIT:    returns TRUE if user runs wizard to completion,
        FALSE if user cancels or an error occurs

  NOTES:    Wizard pages all use one dialog proc (GenDlgProc).
        They may specify their own handler procs to get called
        at init time or in response to Next, Cancel or a dialog
        control, or use the default behavior of GenDlgProc.

********************************************************************/
BOOL RunSignupWizard(DWORD dwFlags, HWND hwndParent /* = NULL */)
{
    HPROPSHEETPAGE hWizPage[NUM_WIZARD_PAGES];  // array to hold handles to pages
    PROPSHEETPAGE psPage;    // struct used to create prop sheet pages
    PROPSHEETHEADER psHeader;  // struct used to run wizard property sheet
    UINT nPageIndex;
    BOOL bUse256ColorBmp = FALSE;
    INT_PTR iRet = 0;
    HRESULT hr;
    HDC hdc;

    if (!InitWizard(dwFlags, hwndParent))
    {
        goto RunSignupWizardExit;
    }

    // Compute the color depth we are running in
    hdc = GetDC(NULL);
    if(hdc)
    {
        if(GetDeviceCaps(hdc,BITSPIXEL) >= 8)
            bUse256ColorBmp = TRUE;
        ReleaseDC(NULL, hdc);
    }

    // zero out structures
    ZeroMemory(&hWizPage,sizeof(hWizPage));   // hWizPage is an array
    ZeroMemory(&psPage,sizeof(PROPSHEETPAGE));
    ZeroMemory(&psHeader,sizeof(PROPSHEETHEADER));

    // fill out common data property sheet page struct
    psPage.dwSize    = sizeof(PROPSHEETPAGE);
    psPage.hInstance = ghInstance;
    psPage.pfnDlgProc = GenDlgProc;

    // create a property sheet page for each page in the wizard
    for (nPageIndex = 0;nPageIndex < NUM_WIZARD_PAGES;nPageIndex++) {
      psPage.dwFlags = PSP_DEFAULT | PSP_HASHELP;
      psPage.pszTemplate = MAKEINTRESOURCE(PageInfo[nPageIndex].uDlgID97);
      // set a pointer to the PAGEINFO struct as the private data for this
      // page
      psPage.lParam = (LPARAM) &PageInfo[nPageIndex];
      if (PageInfo[nPageIndex].nIdTitle)
      {
          psPage.dwFlags |= PSP_USEHEADERTITLE;
          psPage.pszHeaderTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdTitle);
      }
              
      if (PageInfo[nPageIndex].nIdSubTitle)
      {
          psPage.dwFlags |= PSP_USEHEADERSUBTITLE;
          psPage.pszHeaderSubTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdSubTitle);
      }
      
      
      // Exceptions to the use HeaderTitle and Subtitle are the start and end pages
      if ((nPageIndex == ORD_PAGE_HOWTOCONNECT) || (nPageIndex  == ORD_PAGE_CONNECTEDOK))
      {
          psPage.dwFlags &= ~PSP_USEHEADERTITLE;
          psPage.dwFlags &= ~PSP_USEHEADERSUBTITLE;
          psPage.dwFlags |= PSP_HIDEHEADER;
      }
      
      hWizPage[nPageIndex] = CreatePropertySheetPage(&psPage);

      if (!hWizPage[nPageIndex]) {
        DEBUGTRAP("Failed to create property sheet page");

        // creating page failed, free any pages already created and bail
        MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
        UINT nFreeIndex;
        for (nFreeIndex=0;nFreeIndex<nPageIndex;nFreeIndex++)
          DestroyPropertySheetPage(hWizPage[nFreeIndex]);

          iRet = 0;
          goto RunSignupWizardExit;
      }
    }

    // fill out property sheet header struct
    psHeader.dwSize = sizeof(psHeader);
    psHeader.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_HASHELP | PSH_WATERMARK | PSH_HEADER | PSH_STRETCHWATERMARK;
    psHeader.hwndParent = hwndParent;
    psHeader.hInstance = ghInstance;
    psHeader.nPages = NUM_WIZARD_PAGES;
    psHeader.phpage = hWizPage;
    psHeader.nStartPage = ORD_PAGE_HOWTOCONNECT;

    gpWizardState->cmnStateData.hbmWatermark = (HBITMAP)LoadImage(ghInstance,
                    bUse256ColorBmp ? MAKEINTRESOURCE(IDB_WATERMARK256):MAKEINTRESOURCE(IDB_WATERMARK16),
                    IMAGE_BITMAP,
                    0,
                    0,
                    LR_CREATEDIBSECTION);

    psHeader.pszbmHeader = bUse256ColorBmp?MAKEINTRESOURCE(IDB_BANNER256):MAKEINTRESOURCE(IDB_BANNER16);

    //
    // set state of gpWizardState->fNeedReboot and
    // reset the state of Backup Flag here - MKarki Bug #404
    // 
    if (gfBackedUp == TRUE)
    {
        gpWizardState->fNeedReboot = gfReboot;
        gfBackedUp = FALSE;
    }

    // run the Wizard
    iRet = PropertySheet(&psHeader);

    if (iRet < 0) {
      // property sheet failed, most likely due to lack of memory
      MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
    }

RunSignupWizardExit:
    // Clean up allocated bitmaps that might exist from the branding case
    if (gpWizardState->cmnStateData.hbmWatermark)
        DeleteObject(gpWizardState->cmnStateData.hbmWatermark);
    gpWizardState->cmnStateData.hbmWatermark = NULL;

    // Release of gpImnApprentice is done here instead of in the DeinitWizard
    // because the Release() calls DeinitWizard when we are in ICW mode   
    if (gpImnApprentice)
    {
        gpImnApprentice->Release();  // DeinitWizard is called in Release() 
        gpImnApprentice = NULL;
    }
    if (!g_fIsICW)
    {
        DeinitWizard(dwFlags);    
    }
    return iRet > 0;
}


// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}


// ############################################################################
HRESULT MakeBold (HWND hwnd, BOOL fSize, LONG lfWeight)
{
    HRESULT hr = ERROR_SUCCESS;
    HFONT hfont = NULL;
    HFONT hnewfont = NULL;
    LOGFONT* plogfont = NULL;

    if (!hwnd) goto MakeBoldExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeBoldExit;
    }

    plogfont = (LOGFONT*)malloc(sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MakeBoldExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeBoldExit;
    }

    if (abs(plogfont->lfHeight) < 24 && fSize)
    {
        plogfont->lfHeight = plogfont->lfHeight + (plogfont->lfHeight / 4);
    }

    plogfont->lfWeight = (int) lfWeight;

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeBoldExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
    free(plogfont);
    
MakeBoldExit:
    //if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    // The answer is Yes. ChrisK 7/1/96
    return hr;
}

// ############################################################################
HRESULT MakeWizard97Title (HWND hwnd)
{
    HRESULT     hr = ERROR_SUCCESS;
    HFONT       hfont = NULL;
    HFONT       hnewfont = NULL;
    LOGFONT     *plogfont = NULL;
    HDC         hDC;
    
    if (!hwnd) goto MakeWizard97TitleExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    plogfont = (LOGFONT*)malloc(sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MakeWizard97TitleExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    // We want 12 PT Veranda for Wizard 97.
    hDC = GetDC(NULL);
    if(hDC)
    {
        plogfont->lfHeight = -MulDiv(WIZ97_TITLE_FONT_PTS, GetDeviceCaps(hDC, LOGPIXELSY), 72); 
        ReleaseDC(NULL, hDC);
    }        
    plogfont->lfWeight = (int) FW_BOLD;
    
    if (!LoadString(ghInstance, IDS_WIZ97_TITLE_FONT_FACE, plogfont->lfFaceName, LF_FACESIZE))
        lstrcpy(plogfont->lfFaceName, TEXT("Verdana"));

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
    free(plogfont);
    
MakeWizard97TitleExit:
    //if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    // The answer is Yes. ChrisK 7/1/96
    return hr;
}

/*******************************************************************
//
//    Function:    PaintWithPaletteBitmap
//
//    Arguments:   lprc is the target rectangle.
//                 cy is the putative dimensions of hbmpPaint.
//                 If the target rectangle is taller than cy, then 
//                 fill the rest with the pixel in the upper left 
//                 corner of the hbmpPaint.
//
//    Returns:     void
//
//    History:      10-29-98    Vyung    -  Stole from prsht.c
//
********************************************************************/
void PaintWithPaletteBitmap(HDC hdc, LPRECT lprc, int cy, HBITMAP hbmpPaint)
{
    HDC hdcBmp;

    hdcBmp = CreateCompatibleDC(hdc);
    SelectObject(hdcBmp, hbmpPaint);
    BitBlt(hdc, lprc->left, lprc->top, RECTWIDTH(*lprc), cy, hdcBmp, 0, 0, SRCCOPY);

    // StretchBlt does mirroring if you pass a negative height,
    // so do the stretch only if there actually is unpainted space
    if (RECTHEIGHT(*lprc) - cy > 0)
        StretchBlt(hdc, lprc->left, cy,
                   RECTWIDTH(*lprc), RECTHEIGHT(*lprc) - cy,
                   hdcBmp, 0, 0, 1, 1, SRCCOPY);

    DeleteDC(hdcBmp);
}
/*******************************************************************
//
//    Function:    Prsht_EraseWizBkgnd
//
//    Arguments:   Draw the background for wizard pages.
//                 hDlg is dialog handle.
//                 hdc is device context
//
//    Returns:     void
//
//    History:     10-29-98    Vyung   - Stole from prsht.c
//
********************************************************************/
LRESULT Prsht_EraseWizBkgnd(HWND hDlg, HDC hdc)
{
    
    HBRUSH hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    RECT rc;
    GetClientRect(hDlg, &rc);
    FillRect(hdc, &rc, hbrWindow);

    rc.right = BITMAP_WIDTH;
    rc.left = 0;

    PaintWithPaletteBitmap(hdc, &rc, BITMAP_HEIGHT, gpWizardState->cmnStateData.hbmWatermark);

    return TRUE;
}

/*******************************************************************

  NAME:    GenDlgProc

  SYNOPSIS:  Generic dialog proc for all wizard pages

  NOTES:    This dialog proc provides the following default behavior:
          init:    back and next buttons enabled
          next btn:  switches to page following current page
          back btn:  switches to previous page
          cancel btn: prompts user to confirm, and cancels the wizard
          dlg ctrl:   does nothing (in response to WM_COMMANDs)
        Wizard pages can specify their own handler functions
        (in the PageInfo table) to override default behavior for
        any of the above actions.

********************************************************************/
INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  static HCURSOR hcurOld = NULL;
  static BOOL bKilledSysmenu = FALSE;
  PAGEINFO *pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);

  switch (uMsg) {
        case WM_ERASEBKGND:
        {
            // Only paint the external page 
            if (!pPageInfo->nIdTitle && !g_fIsICW)
            {
                Prsht_EraseWizBkgnd(hDlg, (HDC) wParam);
                return TRUE;
            }                
            break;
        }
        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        {
            // Only paint the external page and except the ISP sel page
            if (!pPageInfo->nIdTitle && !g_fIsICW)
            {

                HBRUSH hbrWindow = GetSysColorBrush(COLOR_WINDOW);
                DefWindowProc(hDlg, uMsg, wParam, lParam);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (LRESULT)hbrWindow;
            }
            break;
        }
        
    case WM_INITDIALOG:


        //10/25/96 jmazner Normandy #9132
        if( !bKilledSysmenu && !g_fIsICW )
        {
            // Get the main frame window's style
            LONG window_style = GetWindowLong(GetParent(hDlg), GWL_STYLE);

            //Remove the system menu from the window's style
            window_style &= ~WS_SYSMENU;

            //set the style attribute of the main frame window
            SetWindowLong(GetParent(hDlg), GWL_STYLE, window_style);

            bKilledSysmenu = TRUE;
        }

      {
        // get propsheet page struct passed in
        LPPROPSHEETPAGE lpsp = (LPPROPSHEETPAGE) lParam;
        ASSERT(lpsp);
        // fetch our private page info from propsheet struct
        PAGEINFO * pPageInfo = (PAGEINFO *) lpsp->lParam;
        ASSERT(pPageInfo);

        // store pointer to private page info in window data for later
        SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM) pPageInfo);

        // initialize 'back' and 'next' wizard buttons, if
        // page wants something different it can fix in init proc below
        PropSheet_SetWizButtons(GetParent(hDlg),
          PSWIZB_NEXT | PSWIZB_BACK);

        // Make the title text bold
        if (g_fIsWizard97 ||  g_fIsExternalWizard97)
            MakeWizard97Title(GetDlgItem(hDlg,IDC_LBLTITLE));
        else
            MakeBold(GetDlgItem(hDlg,IDC_LBLTITLE),TRUE,FW_BOLD);

        // call init proc for this page if one is specified
        if (pPageInfo->InitProc)
        {
          if (!( pPageInfo->InitProc(hDlg,TRUE)))
          {
            // If a fatal error occured, quit the wizard.
            // Note: gfQuitWizard is also used to terminate the wizard
            // for non-error reasons, but in that case TRUE is returned
            // from the OK proc and the case is handled below.
            if (gfQuitWizard)
            {
              // Don't reboot if error occured.
              gpWizardState->fNeedReboot = FALSE;

              // send a 'cancel' message to ourselves (to keep the prop.
              // page mgr happy)
              //
              // ...Unless we're serving as an Apprentice.  In which case, let
              // the Wizard decide how to deal with this.

              if( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
              {
                  PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
              }
              else
              {
                  g_pExternalIICWExtension->ExternalCancel( CANCEL_SILENT );
              }
            }
          }
        }

        // 11/25/96    jmazner Normandy #10586 (copied from icwconn1)
        // Before we return, lets send another message to ourself so
        // we have a second chance of initializing stuff that the 
        // property sheet wizard doesn't normally let us do.
        PostMessage(hDlg, WM_MYINITDIALOG, 1, lParam);


        return TRUE;
      }
      break;  // WM_INITDIALOG

    // 11/25/96    jmazner Normandy #10586 (copied from icwconn1)
    case WM_MYINITDIALOG:
    {
        PAGEINFO * pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
        ASSERT(pPageInfo);

        // wParam tells whether this is the first initialization or not
        MiscInitProc(hDlg, (int)wParam, pPageInfo->uDlgID);
        return TRUE;
    }


    case WM_DESTROY:
        ReleaseBold(GetDlgItem(hDlg,IDC_LBLTITLE));
        // 12/18/96 jmazner Normandy #12923
        // bKilledSysmenu is static, so even if the window is killed and reopened later
        // (as happens when user starts in conn1, goes into man path, backs up
        //  to conn1, and then returns to man path), the value of bKilledSysmenu is preserved.
        // So when the window is about to die, set it to FALSE, so that on the next window
        // init we go through and kill the sysmenu again.
        bKilledSysmenu = FALSE;
        break;

    case WM_HELP:
    {
        if (!g_fIsICW)
        {
            DWORD dwData = ICW_OVERVIEW;
            if (pPageInfo->dwHelpID)
                dwData = pPageInfo->dwHelpID;
            WinHelp(hDlg,TEXT("connect.hlp>proc4"),HELP_CONTEXT, dwData);
        }
        break;
    }

    case WM_NOTIFY:
    {
        // get pointer to private page data out of window data
        PAGEINFO * pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
        ASSERT(pPageInfo);
        BOOL fRet,fKeepHistory=TRUE;
        NMHDR * lpnm = (NMHDR *) lParam;
#define NEXTPAGEUNITIALIZED -1
        int iNextPage = NEXTPAGEUNITIALIZED;
        switch (lpnm->code) {
          case PSN_SETACTIVE:
            // If a fatal error occured in first call to init proc
            // from WM_INITDIALOG, don't call init proc again.
            if (FALSE == gfQuitWizard)
            {
              // initialize 'back' and 'next' wizard buttons, if
              // page wants something different it can fix in init proc below
              PropSheet_SetWizButtons(GetParent(hDlg),
                PSWIZB_NEXT | PSWIZB_BACK);

            if (g_fIsICW && (pPageInfo->uDlgID == IDD_PAGE_HOWTOCONNECT))
            {
                iNextPage = g_uExternUIPrev;
                return TRUE;
            }

              // call init proc for this page if one is specified
              if (pPageInfo->InitProc)
              {
                pPageInfo->InitProc(hDlg,FALSE);
              }
            }

            // If we set the wait cursor, set the cursor back
            if (hcurOld)
            {
                SetCursor(hcurOld);
                hcurOld = NULL;
            }

            PostMessage(hDlg, WM_MYINITDIALOG, 0, lParam);


            return TRUE;
            break;

          case PSN_WIZNEXT:
          case PSN_WIZBACK:
          case PSN_WIZFINISH:
            // Change cursor to an hour glass
            hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

            // call OK proc for this page if one is specified
            if (pPageInfo->OKProc) 
              if (!pPageInfo->OKProc(hDlg,(lpnm->code != PSN_WIZBACK),
                (UINT*)&iNextPage,&fKeepHistory))
              {
                // If a fatal error occured, quit the wizard.
                // Note: gfQuitWizard is also used to terminate the wizard
                // for non-error reasons, but in that case TRUE is returned
                // from the OK proc and the case is handled below.
                if (gfQuitWizard)
                {
                  // Don't reboot if error occured.
                  gpWizardState->fNeedReboot = FALSE;

                  // send a 'cancel' message to ourselves (to keep the prop.
                  // page mgr happy)
                  //
                  // ...Unless we're serving as an Apprentice.  In which case, let
                  // the Wizard decide how to deal with this.

                  if( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
                  {
                      PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                  }
                  else
                  {
                      g_pExternalIICWExtension->ExternalCancel( CANCEL_SILENT );
                  }
                }

                // stay on this page
                SetPropSheetResult(hDlg,-1);
                return TRUE;
              }

            if (lpnm->code != PSN_WIZBACK) {
              // 'next' pressed
              ASSERT(gpWizardState->uPagesCompleted <
                NUM_WIZARD_PAGES);

              // save the current page index in the page history,
              // unless this page told us not to when we called
              // its OK proc above
              if (fKeepHistory) {
                gpWizardState->uPageHistory[gpWizardState->
                  uPagesCompleted] = gpWizardState->uCurrentPage;
                DEBUGMSG("propmgr: added page %d (IDD %d) to history list",
                    gpWizardState->uCurrentPage, GetDlgIDFromIndex(gpWizardState->uCurrentPage));
                gpWizardState->uPagesCompleted++;
              }
              else
              {
                  DEBUGMSG("propmgr: not adding %d (IDD: %d) to the history list",
                      gpWizardState->uCurrentPage, GetDlgIDFromIndex(gpWizardState->uCurrentPage));
              }


              // if no next page specified or no OK proc,
              // advance page by one
              if (0 > iNextPage)
                iNextPage = gpWizardState->uCurrentPage + 1;

            }
            else
            {
              if (( NEXTPAGEUNITIALIZED == iNextPage ) && (gpWizardState->uPagesCompleted > 0))
              {
                  // get the last page from the history list
                  gpWizardState->uPagesCompleted --;
                  iNextPage = gpWizardState->uPageHistory[gpWizardState->
                    uPagesCompleted];
                  DEBUGMSG("propmgr: extracting page %d (IDD %d) from history list",
                      iNextPage, GetDlgIDFromIndex(iNextPage));
              }
              else
              {
                  // 'back' pressed
                  switch( gpWizardState->uCurrentPage )
                  {
                    //case IDD_PAGE_CONNECTEDOK:  We should only use IDDs for external pages
                    case ORD_PAGE_HOWTOCONNECT:
                        if(( gpWizardState->dwRunFlags & RSW_APPRENTICE ) || g_fIsICW)
                        {
                            // we need to back out of the connection apprentice
                            iNextPage = g_uExternUIPrev;
                            DEBUGMSG("propmgr: backing into AcctMgr Wizard page IDD %d", g_uExternUIPrev);
                        }
                        break;
                    case ORD_PAGE_CONNECTEDOK:
                        if( g_fAcctMgrUILoaded )
                        {
                            // we need to back into the account apprentice
                            iNextPage = g_uAcctMgrUILast;
                            DEBUGMSG("propmgr: backing into AcctMgr UI page IDD %d", g_uAcctMgrUILast);
                        }
                        break;
                    case ORD_PAGE_USEPROXY:
                    case ORD_PAGE_CHOOSEMODEM:
                    case ORD_PAGE_CONNECTION:
                    case ORD_PAGE_PHONENUMBER:
                    case ORD_PAGE_SETUP_PROXY:
                        if (g_fIsICW )
                        {
                            // we need to back out of the connection apprentice
                            iNextPage = g_uExternUIPrev;
                            DEBUGMSG("propmgr: backing into AcctMgr Wizard page IDD %d", g_uExternUIPrev);
                        }
                        break;
                  }
              }


            }

            // if we need to exit the wizard now (e.g. launching
            // signup app and want to terminate the wizard), send
            // a 'cancel' message to ourselves (to keep the prop.
            // page mgr happy)
            if (gfQuitWizard) {
   
              //
              // if we are going from manual to conn1 then
              // then do not show the  REBOOT dialog but
              // still preserve the gpWizardState -MKarki Bug #404
              //
              if (lpnm->code ==  PSN_WIZBACK)
              {
                 gfBackedUp = TRUE;
                 gfReboot = gpWizardState->fNeedReboot;
              }

              // send a 'cancel' message to ourselves (to keep the prop.
              // page mgr happy)
              //
              // ...Unless we're serving as an Apprentice.  In which case, let
              // the Wizard decide how to deal with this.

              if( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
              {
                  PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
              }
              else
              {
                  //
                  // 5/27/97 jmazner Olympus #1134 and IE #32717
                  //
                  if( gpWizardState->fNeedReboot )
                  {
                      g_pExternalIICWExtension->ExternalCancel( CANCEL_REBOOT );
                  }
                  else
                  {
                      g_pExternalIICWExtension->ExternalCancel( CANCEL_SILENT );
                  }
              }

              SetPropSheetResult(hDlg,-1);
              return TRUE;
            }

            // set next page, only if 'next' or 'back' button
            // was pressed
            if (lpnm->code != PSN_WIZFINISH) {

              // set the next current page index
              gpWizardState->uCurrentPage = iNextPage;
              DEBUGMSG("propmgr: going to page %d (IDD %d)", iNextPage, GetDlgIDFromIndex(iNextPage));

              // tell the prop sheet mgr what the next page to
              // display is
              SetPropSheetResult(hDlg,GetDlgIDFromIndex(iNextPage));
              return TRUE;
            }
            else
            {
                //
                // Sanity check: there should be no way that our Apprentice
                // would ever reach this state, since the Apprentice always
                // defers cancels to the main wizard.
                //
                ASSERT(!(gpWizardState->dwRunFlags & RSW_APPRENTICE));
                //
                // run shellnext if it's there
                //
                // 8/12/97    jmazner    Olympus #12419
                // don't shell next if we're about to reboot anyways
                //
                TCHAR szCommand[MAX_PATH + 1] = TEXT("\0");
                TCHAR szParams[MAX_PATH + 1] = TEXT("\0");
                DWORD dwStrLen = MAX_PATH + 1;
                if( !(gpWizardState->fNeedReboot) && GetShellNextFromReg( szCommand, szParams, dwStrLen ) )
                {
                    ShellExecute(NULL,TEXT("open"),szCommand,szParams,NULL,SW_NORMAL);
                }
            }

            break;

            case PSN_HELP:
            {

#if defined(WIN16)
                DWORD dwData = 1000;
                WinHelp(hDlg,TEXT("connect.hlp"),HELP_CONTEXT, dwData);
#else
                // Normandy 12278 ChrisK 12/4/96
                DWORD dwData = ICW_OVERVIEW;
                if (pPageInfo->dwHelpID)
                    dwData = pPageInfo->dwHelpID;
                WinHelp(hDlg,TEXT("connect.hlp>proc4"),HELP_CONTEXT, dwData);
#endif
                break;
            }



          case PSN_QUERYCANCEL:

            // if global flag to exit is set, then this cancel
            // is us pretending to push 'cancel' so prop page mgr
            // will kill the wizard.  Let this through...
            if (gfQuitWizard) {
              SetWindowLongPtr(hDlg,DWLP_MSGRESULT,FALSE);
              return TRUE;
            }

            // if this page has a special cancel proc, call it
            if (pPageInfo->CancelProc)
              fRet = pPageInfo->CancelProc(hDlg);
            else {
              // default behavior: pop up a message box confirming
              // the cancel...
              // ... unless we're serving as an Apprentice, in which case
              // we should let the Wizard handle things
              if( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
              {
                  fRet = (MsgBox(hDlg,IDS_QUERYCANCEL,
                    MB_ICONQUESTION,MB_YESNO |
                    MB_DEFBUTTON2) == IDYES);
                  gfUserCancelled = fRet;
              }
              else
              {
                 gfUserCancelled = g_pExternalIICWExtension->ExternalCancel( CANCEL_PROMPT );
                 fRet = gfUserCancelled;
              }

            }

            // don't reboot if cancelling
            gpWizardState->fNeedReboot = FALSE;

            // return the value thru window data
            SetWindowLongPtr(hDlg,DWLP_MSGRESULT,!fRet);
            return TRUE;
            break;
        }
      }
      break;

    case WM_COMMAND:
      {
        // get pointer to private page data out of window data
        PAGEINFO * pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
        ASSERT(pPageInfo);

        // if this page has a command handler proc, call it
        if (pPageInfo->CmdProc) {
          pPageInfo->CmdProc(hDlg, wParam, lParam);
        }
      }

  }

  return FALSE;
}


/*******************************************************************

  NAME:    InitWizardState

  SYNOPSIS:  Initializes wizard state structure

********************************************************************/
VOID InitWizardState(WIZARDSTATE * pWizardState, DWORD dwFlags)
{
  ASSERT(pWizardState);

  // zero out structure
  ZeroMemory(pWizardState,sizeof(WIZARDSTATE));

  // set starting page
  pWizardState->uCurrentPage = ORD_PAGE_HOWTOCONNECT;

  pWizardState->fNeedReboot = FALSE;
}


/*******************************************************************

  NAME:    InitUserInfo

  SYNOPSIS:  Initializes user data structure

********************************************************************/
VOID InitUserInfo(USERINFO * pUserInfo)
{
  ASSERT(pUserInfo);

  // zero out structure
  ZeroMemory(pUserInfo,sizeof(USERINFO));

  // Set default to modem, even  though we haven't enumerated devices
  pUserInfo->uiConnectionType = CONNECT_RAS;

  // if there's a logged-on user, use that username as the default
  GetDefaultUserName(pUserInfo->szAccountName,
    sizeof(pUserInfo->szAccountName));

  // look in registry for settings left from previous installs
  // get modem/LAN preference from before, if there is one
  RegEntry re(szRegPathInternetSettings,HKEY_LOCAL_MACHINE);

  DWORD dwVal = re.GetNumber(szRegValAccessMedium,0);
  if (dwVal > 0) {
    pUserInfo->fPrevInstallFound = TRUE;
  }
  if (dwVal == USERPREF_LAN) {
    pUserInfo->uiConnectionType = CONNECT_LAN;
  } else if (dwVal == USERPREF_MODEM) {
    pUserInfo->uiConnectionType = CONNECT_RAS;
  }

  // get name of existing Internet connectoid, if there is one
  //  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
  BOOL  fTemp;
  DWORD dwRet = InetGetAutodial(&fTemp, pUserInfo->szISPName,
    sizeof(pUserInfo->szISPName));
  if ((ERROR_SUCCESS == dwRet) && lstrlen(pUserInfo->szISPName))
  {
    pUserInfo->fPrevInstallFound = TRUE;
  }

  pUserInfo->fNewConnection = TRUE;
  pUserInfo->fModifyConnection = FALSE;
  pUserInfo->fModifyAdvanced = FALSE;
  pUserInfo->fAutoDNS = TRUE;
}

/*******************************************************************

  NAME:    InitIMNApprentice

  SYNOPSIS:  Initializes global variables needed to add mail, news
             and LDAP account wizard pages from the Athena Acct Manager.

********************************************************************/
VOID InitIMNApprentice()
{
    HRESULT        hr;

    // Load the Account Manager OLE in-proc server
    if (!CheckOEVersion())
        return;

    hr = CoCreateInstance(CLSID_ApprenticeAcctMgr,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWApprentice,(LPVOID *)&gpImnApprentice);

    if ( !(SUCCEEDED(hr) && gpImnApprentice) )
    {
        g_fAcctMgrUILoaded = FALSE;
        DEBUGMSG("Unable to CoCreateInstance on IID_IICWApprentice!  hr = %x", hr);
    }
}


/*******************************************************************

  NAME:    InitLDAP

  SYNOPSIS:  Initializes global variables for LDAP options.

********************************************************************/
/**
VOID InitLDAP()
{
    TCHAR        szBuf[MAX_PATH+1];
    DWORD        size;
    HKEY        hKey;
    HRESULT        hr;

    // If we came in through the CreateDirService entry point, we
    // want to clear out the mail and news flags.
    if (gpWizardState->dwRunFlags & RSW_DIRSERVACCT)
    {
        gfGetNewsInfo = FALSE;
        gfGetMailInfo = FALSE;
        gpUserInfo->inc.dwFlags &= ~INETC_LOGONMAIL;
        gpUserInfo->inc.dwFlags &= ~INETC_LOGONNEWS;    
    }

    // Load the Internet Mail/News account configuration OLE in-proc server
    // if nobody else has already done so.


    gfGetLDAPInfo = FALSE;
    if( !gpImnAcctMgr )
    {
        hr = CoCreateInstance(CLSID_ImnAccountManager,NULL,CLSCTX_INPROC_SERVER,
                              IID_IImnAccountManager,(LPVOID *)&gpImnAcctMgr);
        if (SUCCEEDED(hr) && gpImnAcctMgr)
        {
            hr = gpImnAcctMgr->Init(NULL, NULL);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Get a list of the LDAP accounts
        hr = gpImnAcctMgr->Enumerate(SRV_LDAP,&gpLDAPAccts);
        // Only continue if there were no fatal errors
        if ( !( FAILED(hr) && (E_NoAccounts!=hr) ) )
            gfGetLDAPInfo = TRUE;
    }

    if (!gfGetLDAPInfo && !gfGetMailInfo && !gfGetNewsInfo && gpImnAcctMgr)
    {
        gpImnAcctMgr->Release();
        gpImnAcctMgr = NULL;
    }

    // If we have been given defaults, get those
    if (gpDirServiceInfo && gfUseDirServiceDefaults)
    {
        ASSERT(sizeof(*gpDirServiceInfo) == gpDirServiceInfo->dwSize);
        
        if (gpDirServiceInfo->szServiceName)
            lstrcpy(gpUserInfo->szDirServiceName, gpDirServiceInfo->szServiceName);
        if (gpDirServiceInfo->szLDAPServer)
            lstrcpy(gpUserInfo->inc.szLDAPServer, gpDirServiceInfo->szLDAPServer);
        gpUserInfo->inc.fLDAPResolve = gpDirServiceInfo->fLDAPResolve;
            
        if (gpDirServiceInfo->fUseSicily)
        {
            // 12/17/96 jmazner Normandy 12871
            //gpUserInfo->fNewsAccount = FALSE;
            gpUserInfo->inc.fLDAPLogonSPA = TRUE;
        }
        // 3/24/97 jmazner Olympus #2052
        else if (gpDirServiceInfo->szUserName && gpDirServiceInfo->szUserName[0])
        {
            lstrcpy(gpUserInfo->inc.szLDAPLogonName, gpDirServiceInfo->szUserName);
            if (gpMailNewsInfo->szPassword)
                lstrcpy(gpUserInfo->inc.szLDAPLogonPassword, gpDirServiceInfo->szPassword);
        }
        else
        {
            gpUserInfo->fLDAPLogon = FALSE;
        }

    }
    else
    {
        // let's make up our own defaults
        gpUserInfo->inc.fLDAPResolve = TRUE;
        gpUserInfo->fLDAPLogon = FALSE;
        gpUserInfo->inc.fLDAPLogonSPA = FALSE;
    }

}
**/

/*******************************************************************

  NAME:    GetDefaultUserName

  SYNOPSIS:  Gets user's login name if there is one (if network or
        user profiles are installed), otherwise sets
        user name to null string.

********************************************************************/
VOID GetDefaultUserName(TCHAR * pszUserName,DWORD cbUserName)
{
  ASSERT(pszUserName);
  *pszUserName = '\0';

  WNetGetUser(NULL,pszUserName,&cbUserName);
}

/*******************************************************************

  NAME:    GetDlgIDFromIndex

  SYNOPSIS:  For a given zero-based page index, returns the
        corresponding dialog ID for the page

  4/24/97    jmazner    When dealing with apprentice pages, we may call
                    this function with dialog IDs (IDD_PAGE_*), rather
                    than an index (ORD_PAGE*).  Added code to check
                    whether the number passed in is an index or dlgID.

********************************************************************/
UINT GetDlgIDFromIndex(UINT uPageIndex)
{
  if( uPageIndex <= MAX_PAGE_INDEX )
  {
    ASSERT(uPageIndex < NUM_WIZARD_PAGES);

    if (g_fIsWizard97)
        return PageInfo[uPageIndex].uDlgID97;
    else if(g_fIsExternalWizard97)
        return PageInfo[uPageIndex].uDlgID97External;
    else
        return PageInfo[uPageIndex].uDlgID;
  }
  else
  {
    return(uPageIndex);
  }
}


/*******************************************************************

  NAME:    SystemAlreadyConfigured

  SYNOPSIS:  Determines if the system is configured for Internet
        or not

  EXIT:    returns TRUE if configured, FALSE if more
        configuration is necessary

********************************************************************/
BOOL SystemAlreadyConfigured(USERINFO * pUserInfo)
{
  BOOL fRet = FALSE;  // assume not configured
  BOOL  fNeedSysComponents = FALSE;
  DWORD dwfInstallOptions = 0;
  
  if ( CONNECT_RAS == pUserInfo->uiConnectionType )
  {
    // If connecting over modem, we need TCP/IP and RNA.
    dwfInstallOptions = ICFG_INSTALLTCP | ICFG_INSTALLRAS;
  }

  // already configured if:
  //   - previous install was detected, and
  //   - we do not need any drivers or files based on existing config &
  // user preference, and
  //   - there is already an internet connectoid established (something
  //     is set for szISPName) or user has LAN for Internet access

  HRESULT hr = lpIcfgNeedInetComponents(dwfInstallOptions, &fNeedSysComponents);
  if (ERROR_SUCCESS != hr)
  {
    TCHAR   szErrorText[MAX_ERROR_TEXT+1]=TEXT("");
    
    // Get the text of the error message and display it.
    if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
    {
      MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
    }

    return FALSE;
  }

  if ( pUserInfo->fPrevInstallFound && !fNeedSysComponents &&
       (pUserInfo->szISPName[0] || (CONNECT_LAN==pUserInfo->uiConnectionType)) )
  {

    fRet = TRUE;
  }

  return fRet;
}


//-----------------------------------------------------------------------------
//  Function    MiscInitProc
//
//    Synopsis    Our generic dialog proc calls this in case any of the wizard
//                dialogs have to do any sneaky stuff.
//
//    Arguments:    hDlg - dialog window
//                fFirstInit - TRUE if this is the first time the dialog
//                    is initialized, FALSE if this InitProc has been called
//                    before (e.g. went past this page and backed up)
//
//    Returns:    TRUE
// 
//    History:    10/28/96    ValdonB    Created
//                11/25/96    Jmazner    copied from icwconn1\psheet.cpp
//                            Normandy #10586
//
//-----------------------------------------------------------------------------
BOOL CALLBACK MiscInitProc(HWND hDlg, BOOL fFirstInit, UINT uDlgID)
{
    switch( uDlgID )
    {
        case IDD_PAGE_PHONENUMBER:
        case IDD_PAGE_PHONENUMBER97:
            SetFocus(GetDlgItem(hDlg,IDC_PHONENUMBER));
            SendMessage(GetDlgItem(hDlg, IDC_PHONENUMBER),
                    EM_SETSEL,
                    (WPARAM) 0,
#ifdef WIN16
                    MAKELPARAM(0,-1));
#else
                    (LPARAM) -1);
#endif
            break;
    }


    return TRUE;
}


//+----------------------------------------------------------------------------
//
//    Function    AllocDialogIDList
//
//    Synopsis    Allocates memory for the g_pdwDialogIDList variable large enough
//                to maintain 1 bit for every valid external dialog ID
//
//    Arguments    None
//
//    Returns        TRUE if allocation succeeds
//                FALSE otherwise
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------

BOOL AllocDialogIDList( void )
{
    ASSERT( NULL == g_pdwDialogIDList );
    if( g_pdwDialogIDList )
    {
        DEBUGMSG("AllocDialogIDList called with non-null g_pdwDialogIDList!");
        return FALSE;
    }

    // determine maximum number of external dialogs we need to track
    UINT uNumExternDlgs = EXTERNAL_DIALOGID_MAXIMUM - EXTERNAL_DIALOGID_MINIMUM + 1;

    // we're going to need one bit for each dialogID.
    // Find out how many DWORDS it'll take to get this many bits.
    UINT uNumDWORDsNeeded = (uNumExternDlgs / ( 8 * sizeof(DWORD) )) + 1;

    // set global var with length of the array
    g_dwDialogIDListSize = uNumDWORDsNeeded;

    g_pdwDialogIDList = (DWORD *) GlobalAlloc(GPTR, uNumDWORDsNeeded * sizeof(DWORD));

    if( !g_pdwDialogIDList )
    {
        DEBUGMSG("AllocDialogIDList unable to allocate space for g_pdwDialogIDList!");
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function    DialogIDAlreadyInUse
//
//    Synopsis    Checks whether a given dialog ID is marked as in use in the
//                global array pointed to by g_pdwDialogIDList
//
//    Arguments    uDlgID -- Dialog ID to check
//
//    Returns        TRUE if    -- DialogID is out of range defined by EXTERNAL_DIALOGID_*
//                        -- DialogID is marked as in use
//                FALSE if DialogID is not marked as in use
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------

BOOL DialogIDAlreadyInUse( UINT uDlgID )
{
    if( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) ||
        (uDlgID > EXTERNAL_DIALOGID_MAXIMUM)     )
    {
        // this is an out-of-range ID, don't want to accept it.
        DEBUGMSG("DialogIDAlreadyInUse received an out of range DialogID, %d", uDlgID);
        return TRUE;
    }
    // find which bit we need
    UINT uBitToCheck = uDlgID - EXTERNAL_DIALOGID_MINIMUM;
    
    UINT bitsInADword = 8 * sizeof(DWORD);

    UINT baseIndex = uBitToCheck / bitsInADword;

    ASSERTSZ( (baseIndex < g_dwDialogIDListSize), "ASSERT Failed: baseIndex < g_dwDialogIDListSize");

    DWORD dwBitMask = 0x1 << uBitToCheck%bitsInADword;

    BOOL fBitSet = g_pdwDialogIDList[baseIndex] & (dwBitMask);

    //DEBUGMSG("DialogIDAlreadyInUse: ID %d is %s%s", uDlgID, (fBitSet)?"":"_not_ ", "already in use.");

    return( fBitSet );
}

//+----------------------------------------------------------------------------
//
//    Function    SetDialogIDInUse
//
//    Synopsis    Sets or clears the in use bit for a given DialogID
//
//    Arguments    uDlgID -- Dialog ID for which to change status
//                fInUse -- New value for the in use bit.
//
//    Returns        TRUE if status change succeeded.
//                FALSE if DialogID is out of range defined by EXTERNAL_DIALOGID_*
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse )
{
    if( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) ||
        (uDlgID > EXTERNAL_DIALOGID_MAXIMUM)     )
    {
        // this is an out-of-range ID, don't want to accept it.
        DEBUGMSG("SetDialogIDInUse received an out of range DialogID, %d", uDlgID);
        return FALSE;
    }
    // find which bit we need
    UINT uBitToCheck = uDlgID - EXTERNAL_DIALOGID_MINIMUM;
    
    UINT bitsInADword = 8 * sizeof(DWORD);

    UINT baseIndex = uBitToCheck / bitsInADword;

    ASSERTSZ( (baseIndex < g_dwDialogIDListSize), "ASSERT Failed: baseIndex < g_dwDialogIDListSize");

    DWORD dwBitMask = 0x1 << uBitToCheck%bitsInADword;


    if( fInUse )
    {
        g_pdwDialogIDList[baseIndex] |= (dwBitMask);
        //DEBUGMSG("SetDialogIDInUse: DialogID %d now marked as in use", uDlgID);
    }
    else
    {
        g_pdwDialogIDList[baseIndex] &= ~(dwBitMask);
        //DEBUGMSG("SetDialogIDInUse: DialogID %d now marked as not in use", uDlgID);
    }


    return TRUE;
}


//+---------------------------------------------------------------------------
//
//    Function:    ProcessDBCS
//
//    Synopsis:    Converts control to use DBCS compatible font
//                Use this at the beginning of the dialog procedure
//    
//                Note that this is required due to a bug in Win95-J that prevents
//                it from properly mapping MS Shell Dlg.  This hack is not needed
//                under winNT.
//
//    Arguments:    hwnd - Window handle of the dialog
//                cltID - ID of the control you want changed.
//
//    Returns:    ERROR_SUCCESS
// 
//    History:    4/31/97 a-frankh    Created
//                5/13/97    jmazner        Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
#if defined(WIN16)
    return;
#else
    HFONT hFont = NULL;

    if( IsNT() )
    {
        return;
    }

    hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
    if (hFont == NULL)
        hFont = (HFONT) GetStockObject(SYSTEM_FONT);
    if (hFont != NULL)
        SendMessage(GetDlgItem(hDlg,ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
#endif
}


//+---------------------------------------------------------------------------
//
//    Function:    IsSBCSString
//
//    Synopsis:    Walks through a string looking for DBCS characters
//
//    Arguments:    sz -- the string to check
//
//    Returns:    TRUE if no DBCS characters are found
//                FALSE otherwise
// 
//    History:    5/17/97    jmazner        Stole from conn1 to use here
//                                    (Olympus #137)
//----------------------------------------------------------------------------

#if !defined(WIN16)
BOOL IsSBCSString( TCHAR *sz )
{
    ASSERT(sz);

#ifdef UNICODE
    // Check if the string contains only ASCII chars.
    int attrib = IS_TEXT_UNICODE_ASCII16 | IS_TEXT_UNICODE_CONTROLS;
    // We need to count the NULL terminator in the second parameter because
    // 1. IsTextUnicode takes all the data into account, including the NULL
    // 2. IsTextUnicode interprets unicode string of length 1 as ascii string
    //    terminated by ascii null, e.g. L"1" is regarded as "1\0".
    return (BOOL)IsTextUnicode(sz, (1 + lstrlen(sz))*sizeof(TCHAR) , &attrib);
#else
    while( NULL != *sz )
    {
         if (IsDBCSLeadByte(*sz)) return FALSE;

         sz++;
    }

    return TRUE;
#endif
}
#endif

//+----------------------------------------------------------------------------
//
//    Function:    GetShellNextFromReg
//
//    Synopsis:    Reads the ShellNext key from the registry, and then parses it
//                into a command and parameter.  This key is set by
//                SetShellNext in inetcfg.dll in conjunction with
//                CheckConnectionWizard.
//
//    Arguments:    none
//
//    Returns:    none
//
//    History:    jmazner 7/9/97 Olympus #9170
//
//-----------------------------------------------------------------------------

BOOL GetShellNextFromReg( LPTSTR lpszCommand, LPTSTR lpszParams, DWORD dwStrLen )
{
    BOOL fRet = TRUE;
    LPTSTR lpszShellNextCmd = NULL;
    LPTSTR lpszTemp = NULL;
    DWORD dwShellNextSize = dwStrLen * sizeof(TCHAR);

    ASSERT( (MAX_PATH + 1) == dwStrLen );
    ASSERT( lpszCommand && lpszParams );

    if( !lpszCommand || !lpszParams )
    {
        return FALSE;
    }

    RegEntry re(szRegPathICWSettings,HKEY_CURRENT_USER);
    

    DWORD dwResult = re.GetError();
    if (ERROR_SUCCESS == dwResult)
    {
        lpszShellNextCmd = (LPTSTR)GlobalAlloc(GPTR, dwShellNextSize);
        if (!lpszShellNextCmd)
        {
            fRet = FALSE;
            goto GetShellNextFromRegExit;
        }
        
        ZeroMemory( lpszShellNextCmd, dwShellNextSize );
        if( re.GetString(szRegValShellNext, lpszShellNextCmd, dwShellNextSize) )
        {
            DEBUGMSG("GetShellNextFromReg read ShellNext = %s", lpszShellNextCmd);
        }
        else
        {
            DEBUGMSG("GetShellNextFromReg couldn't read a ShellNext value.");
            fRet = FALSE;
            goto GetShellNextFromRegExit;
        }
    }
    else
    {
        DEBUGMSG("GetShellNextFromReg couldn't open the %s reg key.", szRegPathICWSettings);
        fRet = FALSE;
        goto GetShellNextFromRegExit;
    }

    //
    // This call will parse the first token into lpszCommand, and set szShellNextCmd
    // to point to the remaining tokens (these will be the parameters).  Need to use
    // the pszTemp var because GetCmdLineToken changes the pointer's value, and we
    // need to preserve lpszShellNextCmd's value so that we can GlobalFree it later.
    //
    lpszTemp = lpszShellNextCmd;
    GetCmdLineToken( &lpszTemp, lpszCommand );

    lstrcpy( lpszParams, lpszTemp );

    //
    // it's possible that the shellNext command was wrapped in quotes for
    // parsing purposes.  But since ShellExec doesn't understand quotes,
    // we now need to remove them.
    //
    if( '"' == lpszCommand[0] )
    {
        //
        // get rid of the first quote
        // note that we're shifting the entire string beyond the first quote
        // plus the terminating NULL down by one byte.
        //
        memmove( lpszCommand, &(lpszCommand[1]), lstrlen(lpszCommand) );

        //
        // now get rid of the last quote
        //
        lpszCommand[lstrlen(lpszCommand) - 1] = '\0';
    }


    DEBUGMSG("GetShellNextFromReg got cmd = %s, params = %s",
        lpszCommand, lpszParams);

GetShellNextFromRegExit:

    if( lpszShellNextCmd )
    {
        GlobalFree( lpszShellNextCmd );
        lpszShellNextCmd = NULL;
        lpszTemp = NULL;
    }

    return fRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RemoveShellNextFromReg
//
//    Synopsis:    deletes the ShellNext reg key if present. This key is set by
//                SetShellNext in inetcfg.dll in conjunction with
//                CheckConnectionWizard.
//
//    Arguments:    none
//
//    Returns:    none
//
//    History:    jmazner 7/9/97 Olympus #9170
//
//-----------------------------------------------------------------------------
void RemoveShellNextFromReg( void )
{
    RegEntry re(szRegPathICWSettings,HKEY_CURRENT_USER);

    DWORD dwResult = re.GetError();
    if (ERROR_SUCCESS == dwResult)
    {
        DEBUGMSG("RemoveShellNextFromReg");
        re.DeleteValue(szRegValShellNext);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\registry.cpp ===
/****************************************************************************
 *
 *	REGISTRY.cpp
 *
 *	Microsoft Confidential
 *	Copyright (c) Microsoft Corporation 1992-1997
 *	All rights reserved
 *
 *	This module provides functionality for self-registering/unregistering via
 *  the regsvr32.exe
 *
 *  The code comes almost verbatim from Chapter 7 of Dale Rogerson's
 *  "Inside COM", and thus is minimally commented.
 *
 *	4/24/97	jmazner	Created
 *
 ***************************************************************************/

#include "wizard.h"

#include "registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
// 7/2/97 jmazner IE bug #41852
// need to choose a particular key name, so updated setKeyAndValue from
// chapter 12 of InsideCom.
/***
BOOL setKeyAndValue(const char* pszPath,
                    const char* szSubkey,
                    const char* szValue) ;
***/
BOOL setKeyAndValue(const TCHAR* pszPath,
                    const TCHAR* szSubkey,
                    const TCHAR* szValue,
                    const TCHAR* szName = NULL) ;
// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid, 
                 TCHAR* szCLSID,
                 int length) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const TCHAR* szFriendlyName, // Friendly Name
                       const TCHAR* szVerIndProgID, // Programmatic
                       const TCHAR* szProgID)       //   IDs
{
	// Get server location.
	TCHAR szModule[512] ;
	DWORD dwResult =
		::GetModuleFileName(hModule, 
		                    szModule,
		                    sizeof(szModule)/sizeof(TCHAR)) ;
	ASSERT(dwResult != 0) ;

	// Convert the CLSID into a char.
	TCHAR szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, CLSID_STRING_SIZE) ;

	// Build the key CLSID\\{...}
	TCHAR szKey[CLSID_STRING_SIZE + 10] ;
	lstrcpy(szKey, TEXT("CLSID\\")) ;
	lstrcat(szKey, szCLSID) ;
  
	// Add the CLSID to the registry.
	setKeyAndValue(szKey, NULL, szFriendlyName) ;

	// Add the server filename subkey under the CLSID key.
	setKeyAndValue(szKey, TEXT("InprocServer32"), szModule) ;

	// 7/2/97 jmazner IE bug #41852
	// Add Threading Model
	setKeyAndValue(szKey,
	               TEXT("InprocServer32"),
	               TEXT("Apartment"),
	               TEXT("ThreadingModel")) ; 

	// Add the ProgID subkey under the CLSID key.
	setKeyAndValue(szKey, TEXT("ProgID"), szProgID) ;

	// Add the version-independent ProgID subkey under CLSID key.
	setKeyAndValue(szKey, TEXT("VersionIndependentProgID"),
	               szVerIndProgID) ;

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szVerIndProgID, TEXT("CLSID"), szCLSID) ;
	setKeyAndValue(szVerIndProgID, TEXT("CurVer"), szProgID) ;

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szProgID, TEXT("CLSID"), szCLSID) ;

	return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid,         // Class ID
                      const TCHAR* szVerIndProgID, // Programmatic
                      const TCHAR* szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	TCHAR szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, CLSID_STRING_SIZE) ;

	// Build the key CLSID\\{...}
	TCHAR szKey[64] ;
	lstrcpy(szKey, TEXT("CLSID\\")) ;
	lstrcat(szKey, szCLSID) ;

	// Delete the CLSID Key - CLSID\{...}
	LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
	ASSERT((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the version-independent ProgID Key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
	ASSERT((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the ProgID key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
	ASSERT((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
void CLSIDtochar(const CLSID& clsid,
                 TCHAR* szCLSID,
                 int cch                // number of characters in szCLSID
                 )
{
	ASSERT(length >= CLSID_STRING_SIZE) ;
	// Get CLSID
	LPOLESTR wszCLSID = NULL ;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (SUCCEEDED(hr))
    {
	    // Covert from wide characters to non-wide.
#ifdef UNICODE
    	lstrcpyn(szCLSID, (TCHAR *)wszCLSID, cch) ;
#else
	    wcstombs(szCLSID, wszCLSID, cch) ;  // characters are 1 byte.
#endif

	    // Free memory.
	    CoTaskMemFree(wszCLSID) ;
    }
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const TCHAR* lpszKeyChild)  // Key to delete
{
	// Open the child.
	HKEY hKeyChild ;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild) ;
	if (lRes != ERROR_SUCCESS)
	{
		return lRes ;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time ;
	TCHAR szBuffer[256] ;
	DWORD dwSize = 256 ;
	while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
	                    NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild) ;
			return lRes;
		}
		dwSize = 256 ;
	}

	// Close the child.
	RegCloseKey(hKeyChild) ;

	// Delete this child.
	return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const TCHAR* szKey,
                    const TCHAR* szSubkey,
                    const TCHAR* szValue,
                    const TCHAR* szName)
{
	HKEY hKey;
	TCHAR szKeyBuf[1024] ;

	// Copy keyname into buffer.
	lstrcpy(szKeyBuf, szKey) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		lstrcat(szKeyBuf, TEXT("\\")) ;
		lstrcat(szKeyBuf, szSubkey ) ;
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
	                              szKeyBuf, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueEx(hKey, szName, 0, REG_SZ, 
		              (BYTE *)szValue, 
		              sizeof(TCHAR)*(lstrlen(szValue)+1)) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\rnacall.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  RNACALL.H - header file for RNA functions 
//

//  HISTORY:
//  
//  1/20/95   jeremys Created (mostly cloned from RNA UI code)
//  96/01/31  markdu  Renamed CONNENTDLG to OLDCONNENTDLG to avoid
//            conflicts with RNAP.H.
//  96/02/23  markdu  Replaced RNAValidateEntryName with
//            RASValidateEntryName
//  96/02/24  markdu  Re-wrote the definition of ENUM_MODEM to
//            use RASEnumDevices() instead of RNAEnumDevices().
//            Also removed RNAGetDeviceInfo().
//  96/02/24  markdu  Re-wrote the definition of ENUM_CONNECTOID to
//            use RASEnumEntries() instead of RNAEnumConnEntries().
//  96/02/26  markdu  Replaced all remaining internal RNA APIs.
//            Also copied two structures (tagPhoneNum and tapIPData)
//            from rnap.h and tagIAddr from rnaphint.h for internal use only.
//  96/03/07  markdu  Extend ENUM_MODEM class
//  96/03/08  markdu  Added ENUM_MODEM::VerifyDeviceNameAndType
//  96/03/09  markdu  Moved all function prototypes here from wizard.h
//  96/03/09  markdu  Added LPRASENTRY parameter to CreateConnectoid()
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//            Also no longer need GetConnectoidPhoneNumber function.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//            Moved tagPhoneNum to inetapi.h
//  96/03/11  markdu  Moved code to set username and password out of
//            CreateConnectoid into SetConnectoidUsername so it can be reused.
//  96/03/13  markdu  Change ValidateConncectoidName to take LPCSTR.
//  96/03/16  markdu  Added ReInit member function to re-enumerate modems.
//  96/03/25  markdu  Removed GetIPInfo and SetIPInfo.
//  96/04/04  markdu  Added phonebook name param to CreateConnectoid,
//            ValidateConnectoidName, and SetConnectoidUsername.
//  96/05/16  markdu  NASH BUG 21810 Added function for IP address validation.
//

#ifndef _RNACALL_H_
#define _RNACALL_H_

// function pointer typedefs for RNA apis from rnaph.dll and rasapi32.dll
typedef DWORD       (WINAPI * RASGETCOUNTRYINFO) (LPRASCTRYINFO, LPDWORD);
typedef DWORD       (WINAPI * RASENUMDEVICES) (LPRASDEVINFO, LPDWORD, LPDWORD);
typedef DWORD       (WINAPI * RASVALIDATEENTRYNAME) (LPCTSTR, LPTSTR);
typedef DWORD       (WINAPI * RASGETERRORSTRING) (UINT, LPTSTR, DWORD);
typedef DWORD       (WINAPI * RASGETENTRYDIALPARAMS) (LPCTSTR, LPRASDIALPARAMS, LPBOOL);
typedef DWORD       (WINAPI * RASSETENTRYDIALPARAMS) (LPCTSTR, LPRASDIALPARAMS, BOOL);
typedef DWORD       (WINAPI * RASSETENTRYPROPERTIES) (LPCTSTR, LPCTSTR, LPBYTE, DWORD, LPBYTE, DWORD);
typedef DWORD       (WINAPI * RASGETENTRYPROPERTIES) (LPTSTR, LPCTSTR, LPBYTE, LPDWORD, LPBYTE, LPDWORD);
typedef DWORD       (WINAPI * RASENUMENTRIES) (LPTSTR,LPTSTR,LPRASENTRYNAME,LPDWORD,LPDWORD);
typedef DWORD       (WINAPI * RASSETCREDENTIALS) (LPTSTR,LPTSTR,LPRASCREDENTIALS,BOOL);

typedef struct  tagCountryCode
{
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
}   COUNTRYCODE, *PCOUNTRYCODE, FAR* LPCOUNTRYCODE;

// Taken from rnap.h
typedef struct tagIPData   {
    DWORD     dwSize;
    DWORD     fdwTCPIP;
    DWORD     dwIPAddr;
    DWORD     dwDNSAddr;
    DWORD     dwDNSAddrAlt;
    DWORD     dwWINSAddr;
    DWORD     dwWINSAddrAlt;
}   IPDATA, *PIPDATA, FAR *LPIPDATA;

// start (taken from rnaphint.h)
// IP Addresses
#define MAX_IP_FIELDS     4
#define MIN_IP_FIELD1     1u  // min allowed value for field 1
#define MAX_IP_FIELD1   255u  // max allowed value for field 1
#define MIN_IP_FIELD2     0u  // min for field 2
#define MAX_IP_FIELD2   255u  // max for field 2
#define MIN_IP_FIELD3     0u  // min for field 3
#define MAX_IP_FIELD3   254u  // max for field 3
#define MIN_IP_FIELD4     1u  // 0 is reserved for broadcast
#define MAX_IP_FIELD4   254u  // max for field 4
#define MIN_IP_VALUE      0u  // default minimum allowable field value
#define MAX_IP_VALUE    255u  // default maximum allowable field value

// used to fix byte ordering
typedef struct tagIAddr {
  union {
  RASIPADDR ia;
  DWORD     dw;
  };
} IADDR;
typedef IADDR * PIADDR;
typedef IADDR * LPIADDR;

#define FValidIaOrZero(pia) ((((PIADDR) (pia))->dw == 0) || FValidIa(pia))
// end (taken from rnaphint.h)

#define MAX_COUNTRY             512
#define DEF_COUNTRY_INFO_SIZE   1024
#define MAX_COUNTRY_NAME        36
#define MAX_AREA_LIST           20
#define MAX_DISPLAY_NAME        36

class ENUM_MODEM
{
private:
  DWORD         m_dwError;
  DWORD         m_dwNumEntries;
  DWORD         m_dwIndex;
  LPRASDEVINFO  m_lpData;
public:
  ENUM_MODEM();
  ~ENUM_MODEM();
  DWORD ReInit();
  TCHAR * Next();
  TCHAR * GetDeviceTypeFromName(LPTSTR szDeviceName);
  TCHAR * GetDeviceNameFromType(LPTSTR szDeviceType);
  BOOL VerifyDeviceNameAndType(LPTSTR szDeviceName, LPTSTR szDeviceType);
  DWORD GetNumDevices() { return m_dwNumEntries; }
  DWORD GetError()  { return m_dwError; }
  void  ResetIndex() { m_dwIndex = 0; }
};

class ENUM_CONNECTOID
{
private:
  DWORD           m_dwError;
  DWORD           m_dwNumEntries;
  DWORD           m_dwIndex;
  LPRASENTRYNAME  m_lpData;
public:
  ENUM_CONNECTOID();
  ~ENUM_CONNECTOID();
  TCHAR * Next();
  DWORD NumEntries();
  DWORD GetError()  { return m_dwError; }
};


// function prototypes
DWORD CreateConnectoid(LPCTSTR pszPhonebook, LPCTSTR pszConnectionName,
  LPRASENTRY lpRasEntry, LPCTSTR pszUserName,LPCTSTR pszPassword);
BOOL InitRNA(HWND hWnd);
VOID DeInitRNA();
DWORD EnsureRNALoaded(VOID);
HRESULT InitModemList(HWND hCB);
VOID InitConnectoidList(HWND hCB, LPTSTR lpszSelect);
VOID InitCountryCodeList(HWND hLB);
VOID FillCountryCodeList(HWND hLB);
VOID GetCountryCodeSelection(HWND hLB,LPCOUNTRYCODE* plpCountryCode);
BOOL SetCountryIDSelection(HWND hwndCB,DWORD dwCountryCode);
VOID DeInitCountryCodeList(VOID);
DWORD ValidateConnectoidName(LPCTSTR pszPhonebook, LPCTSTR pszConnectoidName);
BOOL GetConnectoidUsername(TCHAR * pszConnectoidName,TCHAR * pszUserName,
  DWORD cbUserName,TCHAR * pszPassword,DWORD cbPassword);
DWORD SetConnectoidUsername(LPCTSTR pszPhonebook, LPCTSTR pszConnectoidName,
  LPCTSTR pszUserName, LPCTSTR pszPassword);
void  InitRasEntry(LPRASENTRY lpEntry);
DWORD GetEntry(LPRASENTRY *lplpEntry, LPDWORD lpdwEntrySize, LPCTSTR szEntryName);
VOID  CopyDw2Ia(DWORD dw, RASIPADDR* pia);
DWORD DwFromIa(RASIPADDR *pia);
BOOL FValidIa(RASIPADDR *pia);

#endif // _RNACALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\inetcfg;$(WINDOWS_INC_PATH);

MAJORCOMP=GETCONN
MINORCOMP=INETCFG

CHICAGO_PRODUCT=1

TARGETNAME=INETCFG
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=DllEntryPoint
DLLBASE=0x60000000
!if $(386)
!if defined(NOT_UNICODE)
DLLDEF=..\inetcfg.def
!else
DLLDEF=..\inetcfg2.def
!endif
!else
!if defined(NOT_UNICODE)
DLLDEF=..\inetrisc.def
!else
DLLDEF=..\inetris2.def
!endif
!endif

NOT_LEAN_AND_MEAN   =1
RCNOFONTMAP         =1
C_DEFINES           =-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT          = 1

BROWSER_INFO="yes"

# Make sure this is built before we continue
SYNCHRONIZE_BLOCK = 1

SOURCES= \
    ..\wizard.rc       \
    ..\callout.cpp     \
    ..\clsutil.cpp     \
    ..\endui.cpp       \
    ..\export.cpp      \
    ..\factory.cpp     \
    ..\icfgcall.cpp    \
    ..\iclient.cpp     \
    ..\icwaprtc.cpp    \
    ..\icwextsn.cpp    \
    ..\ienews.cpp      \
    ..\imnext.cpp      \
    ..\inetapi.cpp     \
    ..\init.cpp        \
    ..\introui.cpp     \
    ..\ispupgui.cpp    \
    ..\mailui.cpp      \
    ..\mapicall.cpp    \
    ..\propmgr.cpp     \
    ..\registry.cpp    \
    ..\rnacall.cpp     \
    ..\strings.cpp     \
    ..\tcpcfg.cpp      \
    ..\tcpui.cpp       \
    ..\uninstal.cpp    \
    ..\util.cpp        \
    ..\wizdll.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\comctl32.lib      \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib      \
    $(SDK_LIB_PATH)\mpr.lib           \
    $(SDK_LIB_PATH)\ole32.lib         \
    $(SDK_LIB_PATH)\uuid.lib          \
    $(SDK_LIB_PATH)\version.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\wizard.h
PRECOMPILED_PCH=wizard.pch
PRECOMPILED_OBJ=wizard.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\registry.h ===
/****************************************************************************
 *
 *	REGISTRY.h
 *
 *	Microsoft Confidential
 *	Copyright (c) Microsoft Corporation 1992-1997
 *	All rights reserved
 *
 *  The code comes almost verbatim from Chapter 7 of Dale Rogerson's
 *  "Inside COM", and thus is minimally commented.
 *
 *	4/24/97	jmazner	Created
 *
 ***************************************************************************/

#ifndef __Registry_H__
#define __Registry_H__
//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const TCHAR* szFriendlyName,
                       const TCHAR* szVerIndProgID,
                       const TCHAR* szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         const TCHAR* szVerIndProgID,
                         const TCHAR* szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\rnacall.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
//
//  RNACALL.C - functions to call RNA dll to create connectoid
//
//  HISTORY:
//  
//  1/18/95   jeremys Cloned from RNA UI code
//  96/01/31  markdu  Renamed CONNENTDLG to OLDCONNENTDLG to avoid
//            conflicts with RNAP.H.
//  96/02/23  markdu  Replaced RNAValidateEntryName with
//            RASValidateEntryName
//  96/02/24  markdu  Re-wrote the implementation of ENUM_MODEM to
//            use RASEnumDevices() instead of RNAEnumDevices().
//            Also eliminated IsValidDevice() and RNAGetDeviceInfo().
//  96/02/24  markdu  Re-wrote the implementation of ENUM_CONNECTOID to
//            use RASEnumEntries() instead of RNAEnumConnEntries().
//  96/02/26  markdu  Replaced all remaining internal RNA APIs.
//  96/03/07  markdu  Extend ENUM_MODEM class, and use global modem
//            enum object.
//  96/03/08  markdu  Do complete verification of device name and type
//            strings passed in to CreateConnectoid.
//  96/03/09  markdu  Moved generic RASENTRY initialization into
//            its own function (InitRasEntry).  Added a wait cursor
//            during loading of RNA.
//  96/03/09  markdu  Added LPRASENTRY parameter to CreateConnectoid()
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//            Also no longer need GetConnectoidPhoneNumber function.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//  96/03/11  markdu  Moved code to set username and password out of
//            CreateConnectoid into SetConnectoidUsername so it can be reused.
//  96/03/11  markdu  Added some flags in InitRasEntry.
//  96/03/13  markdu  Change ValidateConncectoidName to take LPCSTR.
//  96/03/16  markdu  Added ReInit member function to re-enumerate modems.
//  96/03/21  markdu  Work around RNA bug in ENUM_MODEM::ReInit().
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/03/24  markdu  Replaced lstrcpy with lstrcpyn where appropriate.
//  96/03/25  markdu  Removed GetIPInfo and SetIPInfo.
//  96/04/04  markdu  Added phonebook name param to CreateConnectoid,
//            ValidateConnectoidName, and SetConnectoidUsername.
//  96/04/07  markdu  NASH BUG 15645 Work around RNA bug where area code
//            string is required even though it is not being used.
//  96/04/26  markdu  NASH BUG 18605 Handle ERROR_FILE_NOT_FOUND return
//            from ValidateConnectoidName.
//  96/05/14  markdu  NASH BUG 22730 Work around RNA bug.  Flags for terminal
//            settings are swapped by RasSetEntryproperties.
//  96/05/16  markdu  NASH BUG 21810 Added function for IP address validation.
//  96/06/04  markdu  OSR  BUG 7246 Add RASEO_SwCompression and
//            RASEO_ModemLights to default RASENTRY.
//

#include "wizard.h"
#include "tapi.h"

#include "wininet.h"

// WARNING  This flag is defined if WINVER is >= 0x500, but we do not want to build with WINVER >= 0x500
// since we must be able to run on older platforms (Win 95, etc).  This is defined original in ras.h
#ifndef RASEO_ShowDialingProgress
#define RASEO_ShowDialingProgress       0x04000000
#endif
// WARNING  This flag is defined if WINVER is >= 401, but we do not want to build with WINVER >= 401
// since we must be able to run on older platforms (Win 95, etc)
#ifndef RASEO_SecureLocalFiles
#define RASEO_SecureLocalFiles          0x00010000
#endif

typedef BOOL (WINAPI * INTERNETSETOPTION) (IN HINTERNET hInternet OPTIONAL,IN DWORD dwOption,IN LPVOID lpBuffer,IN DWORD dwBufferLength);
static const TCHAR cszWininet[] = TEXT("WININET.DLL");
static const  CHAR cszInternetSetOption[] = "InternetSetOptionA";

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)

// Global variables
HINSTANCE ghInstRNADll=NULL; // handle to RNA dll we load explicitly
HINSTANCE ghInstRNAPHDll=NULL;  // handle to RNAPH dll we load explicitly
DWORD     dwRefCount=0;
BOOL      fRNALoaded=FALSE; // TRUE if RNA function addresses have been loaded
TCHAR *   gpCountryCodeBuf = NULL;  // global list of COUNTRYCODE structures

// global function pointers for RNA apis
RASGETCOUNTRYINFO       lpRasGetCountryInfo=NULL;
RASENUMDEVICES          lpRasEnumDevices=NULL;
RASVALIDATEENTRYNAME    lpRasValidateEntryName=NULL;
RASGETENTRYDIALPARAMS   lpRasGetEntryDialParams=NULL;
RASSETENTRYDIALPARAMS   lpRasSetEntryDialParams=NULL;
RASGETERRORSTRING       lpRasGetErrorString=NULL;
RASSETENTRYPROPERTIES   lpRasSetEntryProperties=NULL;
RASGETENTRYPROPERTIES   lpRasGetEntryProperties=NULL;
RASENUMENTRIES          lpRasEnumEntries=NULL;

// API table for function addresses to fetch
#define NUM_RNAAPI_PROCS   9
APIFCN RnaApiList[NUM_RNAAPI_PROCS] =
{
  { (PVOID *) &lpRasEnumDevices,szRasEnumDevices},
  { (PVOID *) &lpRasGetCountryInfo,szRasGetCountryInfo},
  { (PVOID *) &lpRasValidateEntryName,szRasValidateEntryName},
  { (PVOID *) &lpRasGetEntryDialParams,szRasGetEntryDialParams},
  { (PVOID *) &lpRasSetEntryDialParams,szRasSetEntryDialParams},
  { (PVOID *) &lpRasGetErrorString,szRasGetErrorString},
  { (PVOID *) &lpRasSetEntryProperties,szRasSetEntryProperties},
  { (PVOID *) &lpRasGetEntryProperties,szRasGetEntryProperties},
  { (PVOID *) &lpRasEnumEntries,szRasEnumEntries}
};
//BUGBUG 21-May-1995 bens use #define...sizeof() to define NUM_RNAAPI_PROCS

#pragma data_seg(DATASEG_DEFAULT)

VOID  ShortenName(LPTSTR szLongName, LPTSTR szShortName, DWORD cbShort);
BOOL  GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,UINT nApiProcs);
VOID  SwapDwBytes(LPDWORD lpdw);
void  SwapDWBits(LPDWORD lpdw, DWORD dwBit1, DWORD dwBit2);

#define NO_INTRO  0x00000080  // flag used by RNA wizard
#define US_COUNTRY_CODE    1  // US country code is 1
#define US_COUNTRY_ID      1  // US country ID is 1

/*******************************************************************

  NAME:    InitRNA

  SYNOPSIS:  Loads the RNA dll (RASAPI32), gets proc addresses,
        and loads RNA engine

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

  NOTES:    We load the RNA dll explicitly and get proc addresses
        because these are private APIs and not guaranteed to
        be supported beyond Windows 95.  This way, if the DLL
        isn't there or the entry points we expect aren't there,
        we can display a coherent message instead of the weird
        Windows dialog you get if implicit function addresses
        can't be resolved.

********************************************************************/
BOOL InitRNA(HWND hWnd)
{
  DEBUGMSG("rnacall.c::InitRNA()");

  // only actually do init stuff on first call to this function
  // (when reference count is 0), just increase reference count
  // for subsequent calls
  if (dwRefCount == 0) {

    TCHAR szRNADll[SMALL_BUF_LEN];

    DEBUGMSG("Loading RNA DLL");

    // set an hourglass cursor
    WAITCURSOR WaitCursor;

    // get the filename (RASAPI32.DLL) out of resource
    LoadSz(IDS_RNADLL_FILENAME,szRNADll,ARRAYSIZE(szRNADll));

    // load the RNA api dll
    ghInstRNADll = LoadLibrary(szRNADll);
    if (!ghInstRNADll) {
      UINT uErr = GetLastError();
      DisplayErrorMessage(hWnd,IDS_ERRLoadRNADll1,uErr,ERRCLS_STANDARD,
        MB_ICONSTOP);
      return FALSE;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    if (!GetApiProcAddresses(ghInstRNADll,RnaApiList,NUM_RNAAPI_PROCS)) {
      MsgBox(hWnd,IDS_ERRLoadRNADll2,MB_ICONSTOP,MB_OK);
      DeInitRNA();
      return FALSE;
    }

  }

  fRNALoaded = TRUE;

  dwRefCount ++;

  return TRUE;
}

/*******************************************************************

  NAME:    DeInitRNA

  SYNOPSIS:  Unloads RNA dll.

********************************************************************/
VOID DeInitRNA()
{
  DEBUGMSG("rnacall.c::DeInitRNA()");

  UINT nIndex;

  // decrement reference count
  if (dwRefCount)
    dwRefCount --;

  // when the reference count hits zero, do real deinitialization stuff
  if (dwRefCount == 0)
  {
    if (fRNALoaded)
    {
      // set function pointers to NULL
      for (nIndex = 0;nIndex<NUM_RNAAPI_PROCS;nIndex++) 
        *RnaApiList[nIndex].ppFcnPtr = NULL;

      fRNALoaded = FALSE;
    }

    // free the RNA dll
    if (ghInstRNADll)
    {
    DEBUGMSG("Unloading RNA DLL");
      FreeLibrary(ghInstRNADll);
      ghInstRNADll = NULL;
    }

    // free the RNAPH dll
    if (ghInstRNAPHDll)
    {
    DEBUGMSG("Unloading RNAPH DLL");
      FreeLibrary(ghInstRNAPHDll);
      ghInstRNAPHDll = NULL;
    }
  }
}

/*******************************************************************

  NAME:    CreateConnectoid

  SYNOPSIS:  Creates a connectoid (phone book entry) with specified
        name and phone number

  ENTRY:    pszConnectionName - name for the new connectoid
        pszUserName - optional.  If non-NULL, this will be set for the
          user name in new connectoid
        pszPassword - optional.  If non-NULL, this will be set for the
          password in new connectoid

  EXIT:    returns ERROR_SUCCESS if successful, or an RNA error code

  HISTORY:
  96/02/26  markdu    Moved ClearConnectoidIPParams functionality 
            into CreateConnectoid

********************************************************************/
DWORD CreateConnectoid(LPCTSTR pszPhonebook, LPCTSTR pszConnectionName,
  LPRASENTRY lpRasEntry, LPCTSTR pszUserName,LPCTSTR pszPassword)
{
  DEBUGMSG("rnacall.c::CreateConnectoid()");

  DWORD dwRet;

  ASSERT(pszConnectionName);

  // if we don't have a valid RasEntry, bail
  if ((NULL == lpRasEntry) || (sizeof(RASENTRY) != lpRasEntry->dwSize))
  {
    return ERROR_INVALID_PARAMETER;
  }

  // Load RNA if not already loaded
  dwRet = EnsureRNALoaded();
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  // Enumerate the modems.
  if (gpEnumModem)
  {
    // Re-enumerate the modems to be sure we have the most recent changes  
    dwRet = gpEnumModem->ReInit();
  }
  else
  {
    // The object does not exist, so create it.
    gpEnumModem = new ENUM_MODEM;
    if (gpEnumModem)
    {
      dwRet = gpEnumModem->GetError();
    }
    else
    {
      dwRet = ERROR_NOT_ENOUGH_MEMORY;
    }
  }
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  // Make sure there is at least one device
  if (0 == gpEnumModem->GetNumDevices())
  {
    return ERROR_DEVICE_DOES_NOT_EXIST;
  }

  // Validate the device if possible
  if (lstrlen(lpRasEntry->szDeviceName) && lstrlen(lpRasEntry->szDeviceType))
  {
    // Verify that there is a device with the given name and type
    if (!gpEnumModem->VerifyDeviceNameAndType(lpRasEntry->szDeviceName, 
      lpRasEntry->szDeviceType))
    {
      // There was no device that matched both name and type,
      // so try to get the first device with matching name.
      LPTSTR szDeviceType = 
        gpEnumModem->GetDeviceTypeFromName(lpRasEntry->szDeviceName);
      if (szDeviceType)
      {
        lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
      }
      else
      {
        // There was no device that matched the given name,
        // so try to get the first device with matching type.
        // If this fails, fall through to recovery case below.
        LPTSTR szDeviceName = 
          gpEnumModem->GetDeviceNameFromType(lpRasEntry->szDeviceType);
        if (szDeviceName)
        {
          lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
        }
        else
        {
          // There was no device that matched the given name OR
          // the given type.  Reset the values so they will be
          // replaced with the first device.
          lpRasEntry->szDeviceName[0] = '\0';
          lpRasEntry->szDeviceType[0] = '\0';
        }
      }
    }
  }
  else if (lstrlen(lpRasEntry->szDeviceName))
  {
    // Only the name was given.  Try to find a matching type.
    // If this fails, fall through to recovery case below.
    LPTSTR szDeviceType = 
      gpEnumModem->GetDeviceTypeFromName(lpRasEntry->szDeviceName);
    if (szDeviceType)
    {
      lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
    }
  }
  else if (lstrlen(lpRasEntry->szDeviceType))
  {
    // Only the type was given.  Try to find a matching name.
    // If this fails, fall through to recovery case below.
    LPTSTR szDeviceName = 
      gpEnumModem->GetDeviceNameFromType(lpRasEntry->szDeviceType);
    if (szDeviceName)
    {
      lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
    }
  }

  // If either name or type is missing, just get first device.
  // Since we already verified that there was at least one device,
  // we can assume that this will succeed.
  if(!lstrlen(lpRasEntry->szDeviceName) ||
     !lstrlen(lpRasEntry->szDeviceType))
  {
    lstrcpy (lpRasEntry->szDeviceName, gpEnumModem->Next());
    lstrcpy (lpRasEntry->szDeviceType,
      gpEnumModem->GetDeviceTypeFromName(lpRasEntry->szDeviceName));
    ASSERT(lstrlen(lpRasEntry->szDeviceName));
    ASSERT(lstrlen(lpRasEntry->szDeviceType));
  }

  // Verify the connectoid name
  dwRet = ValidateConnectoidName(pszPhonebook, pszConnectionName);
  if ((ERROR_SUCCESS != dwRet) &&
    (ERROR_ALREADY_EXISTS != dwRet))
  {
    DEBUGMSG("RasValidateEntryName returned %lu",dwRet);
    return dwRet;
  }

  // 99/04/13  vyung  NT5 BUG 279833
  // New features in NT5 to show progress while dialing. Enable it by default
  if (IsNT5())
  {
    // For NT 5 and greater, File sharing is disabled per connectoid by setting this RAS option.
    lpRasEntry->dwfOptions |= RASEO_SecureLocalFiles;  
    lpRasEntry->dwfOptions |= RASEO_ShowDialingProgress;
  }

  //  96/04/07  markdu  NASH BUG 15645
  // If there is no area code string, and RASEO_UseCountryAndAreaCodes is not
  // set, then the area code will be ignored so put in a default otherwise the
  // call to RasSetEntryProperties will fail due to an RNA bug.
  // if RASEO_UseCountryAndAreaCodes is set, then area code is required, so not
  // having one is an error.  Let RNA report the error.
  if (!lstrlen(lpRasEntry->szAreaCode) &&
    !(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes))
  {
    lstrcpy (lpRasEntry->szAreaCode, szDefaultAreaCode);
  }

  // 96/05/14 markdu  NASH BUG 22730 Work around RNA bug.  Flags for terminal
  // settings are swapped by RasSetEntryproperties, so we swap them before
  // the call.  
  if (IsWin95())
      SwapDWBits(&lpRasEntry->dwfOptions, RASEO_TerminalBeforeDial,
      RASEO_TerminalAfterDial);

  // call RNA to create the connectoid
  ASSERT(lpRasSetEntryProperties);
#ifdef UNICODE
  LPRASENTRY lpRasEntryTmp;

  lpRasEntryTmp = (LPRASENTRY)GlobalAlloc(GPTR, sizeof(RASENTRY) + 512);
  if(lpRasEntry)
    memcpy(lpRasEntryTmp, lpRasEntry, sizeof(RASENTRY));
  else
    lpRasEntryTmp = (LPRASENTRY)lpRasEntry;

  dwRet = lpRasSetEntryProperties(pszPhonebook, pszConnectionName,
    (LPBYTE)lpRasEntryTmp, sizeof(RASENTRY)+512, NULL, 0);

  if(lpRasEntryTmp && lpRasEntryTmp != (LPRASENTRY)lpRasEntry)
  {
    memcpy(lpRasEntry, lpRasEntryTmp, sizeof(RASENTRY));
    GlobalFree(lpRasEntryTmp);
  }

#else
  dwRet = lpRasSetEntryProperties(pszPhonebook, pszConnectionName,
    (LPBYTE)lpRasEntry, sizeof(RASENTRY), NULL, 0);
#endif

  // 96/05/14 markdu  NASH BUG 22730 Work around RNA bug.  Put the bits back
  // to the way they were originally,
  if (IsWin95())
    SwapDWBits(&lpRasEntry->dwfOptions, RASEO_TerminalBeforeDial,
    RASEO_TerminalAfterDial);

  // populate the connectoid with user's account name and password.
  if (dwRet == ERROR_SUCCESS)
  {
    if (pszUserName || pszPassword)
    {
      dwRet = SetConnectoidUsername(pszPhonebook, pszConnectionName,
        pszUserName, pszPassword);
    }
  }
  else
  {
    DEBUGMSG("RasSetEntryProperties returned %lu",dwRet);
  }

  if (dwRet == ERROR_SUCCESS)
  {
    // BUGBUG This prevents the make new connection wizard from being
    //        launched the first time the user opens the RNA folder.
    //        Now that we own the make new connection wizard, we
    //        have to decide whether to do this or not.
    // set a flag to tell RNA not to run the RNA wizard automatically
    // when the folder is opened (they set this flag from their wizard
    // whenever they create a new connectoid).  If this fails just
    // go on, not a critical error
    RegEntry reRNAFolder(szRegPathRNAWizard,HKEY_CURRENT_USER);
    ASSERT(reRNAFolder.GetError() == ERROR_SUCCESS);
    DWORD dwVal = NO_INTRO;
    RegSetValueEx(reRNAFolder.GetKey(),szRegValRNAWizard,
      0,REG_BINARY,(LPBYTE) &dwVal,sizeof(dwVal));


    // We don't use auto discovery for referral and signup connectoid
    if (!g_bUseAutoProxyforConnectoid)
    {
        // VYUNG 12/16/1998
        // REMOVE AUTO DISCOVERY FROM THE DIALUP CONNECTOID

        INTERNET_PER_CONN_OPTION_LISTA list;
        DWORD   dwBufSize = sizeof(list);

        // fill out list struct
        list.dwSize = sizeof(list);
        CHAR szConnectoid [RAS_MaxEntryName];
#ifdef UNICODE
        wcstombs(szConnectoid, pszConnectionName, RAS_MaxEntryName);
#else
        lstrcpyn(szConnectoid, pszConnectionName, lstrlen(pszConnectionName)+1);
#endif
        list.pszConnection = szConnectoid;         
        list.dwOptionCount = 1;                         // one option
        list.pOptions = new INTERNET_PER_CONN_OPTIONA[1];   

        if(list.pOptions)
        {
            // set flags
            list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
            list.pOptions[0].Value.dwValue = PROXY_TYPE_DIRECT;           // no proxy, autoconfig url, or autodiscovery

            // tell wininet
            HINSTANCE hInst = NULL;
            FARPROC fpInternetSetOption = NULL;

            dwRet = ERROR_SUCCESS;
    
            hInst = LoadLibrary(cszWininet);
            if (hInst)
            {
                fpInternetSetOption = GetProcAddress(hInst,cszInternetSetOption);
                if (fpInternetSetOption)
                {
                    if( !((INTERNETSETOPTION)fpInternetSetOption) (NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, dwBufSize) )
                    {
                        dwRet = GetLastError();
                        DEBUGMSG("INETCFG export.c::InetSetAutodial() InternetSetOption failed");
                    }
                }
                else
                    dwRet = GetLastError();
                FreeLibrary(hInst);
            }

            delete [] list.pOptions;
        }
    }

  }

  return dwRet;
}

/*******************************************************************

  NAME:    InitModemList

  SYNOPSIS:  Fills a combo box window with installed modems

  ENTRY:    hCB - combo box window to fill
  
********************************************************************/
HRESULT InitModemList (HWND hCB)
{
  DEBUGMSG("rnacall.c::InitModemList()");

  LPTSTR pNext;
  int   nIndex;
  DWORD dwRet;

  ASSERT(hCB);

  // Load RNA if not already loaded
  dwRet = EnsureRNALoaded();
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  // Enumerate the modems.
  if (gpEnumModem)
  {
    // Re-enumerate the modems to be sure we have the most recent changes  
    dwRet = gpEnumModem->ReInit();
  }
  else
  {
    // The object does not exist, so create it.
    gpEnumModem = new ENUM_MODEM;
    if (gpEnumModem)
    {
      dwRet = gpEnumModem->GetError();
    }
    else
    {
      dwRet = ERROR_NOT_ENOUGH_MEMORY;
    }
  }
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  // clear out the combo box
  ComboBox_ResetContent(hCB);

  while ( pNext = gpEnumModem->Next())
  {
    // Add the device to the combo box
    nIndex = ComboBox_AddString(hCB, pNext);
    ComboBox_SetItemData(hCB, nIndex, NULL);
  }

  // Select the default device
  ComboBox_SetCurSel(hCB, nIndex);

  return ERROR_SUCCESS;
}

/*******************************************************************

  NAME:    InitConnectoidList

  SYNOPSIS:  Fills a list box window with list of RNA connectoids

  ENTRY:    hLB - list box window to fill
            lpszSelect - The connectoid name to select as default
  
********************************************************************/
VOID InitConnectoidList(HWND hLB, LPTSTR lpszSelect)
{
  DEBUGMSG("rnacall.c::InitConnectoidList()");

  ASSERT(hLB);

  LPTSTR pNext;

  // Load RNA if not already loaded
  if (EnsureRNALoaded() != ERROR_SUCCESS)
    return;

  ENUM_CONNECTOID EnumConnectoid;    // class object for enum

  // clear out the list box
  ListBox_ResetContent(hLB);

  int index;
  BOOL fSelected = FALSE;

  // enumerate connectoids
  while ( pNext = EnumConnectoid.Next()) {
    // Add the connectoid to the combo box
    index = ListBox_AddString(hLB, pNext);
        if (!fSelected && !lstrcmpi(pNext, lpszSelect))
        {
                fSelected = TRUE;
                ListBox_SetCurSel(hLB, index);
        }
  }
  if (!fSelected)
          ListBox_SetSel(hLB, TRUE, 0);
}


/*******************************************************************

  NAME:     GetConnectoidUsername

  SYNOPSIS: Get the username and password strings from the phonebook
            entry name specified.

  ENTRY:    pszConnectoidName - phonebook entry name
            pszUserName - string to hold user name
            cbUserName - size of pszUserName buffer
            pszPassword - string to hold password
            cbPassword - size of pszPassword buffer

  EXIT:     TRUE if username and password were copied successfully

********************************************************************/

BOOL GetConnectoidUsername(TCHAR * pszConnectoidName,TCHAR * pszUserName,
  DWORD cbUserName,TCHAR * pszPassword,DWORD cbPassword)
{
  DEBUGMSG("rnacall.c::GetConnectoidUsername()");

  ASSERT(pszConnectoidName);
  ASSERT(pszUserName);
  ASSERT(pszPassword);

  BOOL fRet = FALSE;

  // Load RNA if not already loaded
  DWORD dwRet = EnsureRNALoaded();
  if (dwRet != ERROR_SUCCESS) {
    return FALSE;
  }

  RASDIALPARAMS RasDialParams;
  ZeroMemory(&RasDialParams,sizeof(RASDIALPARAMS));
  RasDialParams.dwSize = sizeof(RASDIALPARAMS);

  lstrcpyn(RasDialParams.szEntryName,pszConnectoidName,
    ARRAYSIZE(RasDialParams.szEntryName));

  // call RNA to get user name and password
  ASSERT(lpRasGetEntryDialParams);
  BOOL fPasswordSaved;
  dwRet = lpRasGetEntryDialParams(NULL,&RasDialParams,&fPasswordSaved);

  if (dwRet == ERROR_SUCCESS) {
    // copy user name and password to caller's buffers
    lstrcpyn(pszUserName,RasDialParams.szUserName,cbUserName);
    lstrcpyn(pszPassword,RasDialParams.szPassword,cbPassword);
    fRet = TRUE;
  }

  return fRet;
}


/*******************************************************************

  NAME:     SetConnectoidUsername

  SYNOPSIS: Set the username and password strings for the phonebook
            entry name specified.

  ENTRY:    pszConnectoidName - phonebook entry name
            pszUserName - string with user name
            pszPassword - string with password

  EXIT:     Return value of GetEntryDialParams or SetEntryDialParams

********************************************************************/

DWORD SetConnectoidUsername(LPCTSTR pszPhonebook, LPCTSTR pszConnectoidName,
  LPCTSTR pszUserName, LPCTSTR pszPassword)
{
  BOOL bSkipSetting;
  bSkipSetting = TRUE;

  DEBUGMSG("rnacall.c::SetConnectoidUsername()");

  ASSERT(pszConnectoidName);

  // allocate a struct to use to set dialing params
  LPRASDIALPARAMS pRASDialParams = new RASDIALPARAMS;
  if (!pRASDialParams)
    return ERROR_ALLOCATING_MEMORY;

  ZeroMemory(pRASDialParams,sizeof(RASDIALPARAMS));  // zero out structure
  pRASDialParams->dwSize = sizeof(RASDIALPARAMS);
  lstrcpyn(pRASDialParams->szEntryName,pszConnectoidName,
    ARRAYSIZE(pRASDialParams->szEntryName));

  // get the dialing params for this connectoid so we don't have
  // to reconstruct the fields in struct we aren't changing
  ASSERT(lpRasGetEntryDialParams);
  BOOL fPasswordSaved;
  DWORD dwRet = lpRasGetEntryDialParams(pszPhonebook,
    pRASDialParams,&fPasswordSaved);
  if (dwRet == ERROR_SUCCESS)
  {
    // set the user name and password fields in struct
    // user name and password are optional parameters to this function,
    // make sure pointer is valid
    if (0 != lstrcmp(pRASDialParams->szUserName,pszUserName))
                bSkipSetting = FALSE;
    if (0 != lstrcmp(pRASDialParams->szPassword,pszPassword))
                bSkipSetting = FALSE;

    if (pszUserName)
      lstrcpyn(pRASDialParams->szUserName,pszUserName,
        ARRAYSIZE(pRASDialParams->szUserName));
    if (pszPassword)
      lstrcpyn(pRASDialParams->szPassword,pszPassword,
        ARRAYSIZE(pRASDialParams->szPassword));

    // if no password is specified, then set fRemovePassword to TRUE
    // to remove any old password in the connectoid
    BOOL fRemovePassword = (pRASDialParams->szPassword[0] ?
      FALSE : TRUE);

        bSkipSetting = !fRemovePassword && bSkipSetting;

    // set these parameters for connectoid
    ASSERT(lpRasSetEntryDialParams);
        if (!bSkipSetting)
        {
                dwRet = lpRasSetEntryDialParams(pszPhonebook,pRASDialParams,
                  fRemovePassword);
                if (dwRet != ERROR_SUCCESS)
                {
                  DEBUGMSG("RasSetEntryDialParams returned %lu",dwRet);
                }
        }

// ChrisK 9-20-96   Normandy 6096
// For NT4.0 we also have to call RasSetCredentials

        // Check to see if we are running on NT.
        OSVERSIONINFO osver;
        FARPROC fp;
        fp = NULL;
        ZeroMemory(&osver,sizeof(osver));
        osver.dwOSVersionInfoSize = sizeof(osver);
        if (GetVersionEx(&osver))
        {
                if (VER_PLATFORM_WIN32_NT == osver.dwPlatformId)
                {
                        // fill in credential structure
                        RASCREDENTIALS rascred;
                        ZeroMemory(&rascred,sizeof(rascred));
                        rascred.dwSize = sizeof(rascred);
                        rascred.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain;
                        lstrcpyn(rascred.szUserName,pszUserName,UNLEN);
                        lstrcpyn(rascred.szPassword,pszPassword,PWLEN);
                        lstrcpyn(rascred.szDomain,TEXT(""),DNLEN);
                        ASSERT(ghInstRNADll);

                        // load API
                        fp = GetProcAddress(ghInstRNADll,szRasSetCredentials);

                        if (fp)
                        {
                                dwRet = ((RASSETCREDENTIALS)fp)(NULL,(LPTSTR)pszConnectoidName,&rascred,FALSE);
                                DEBUGMSG("RasSetCredentials returned, %lu",dwRet);
                        }
                        else
                        {
                                DEBUGMSG("RasSetCredentials api not found.");
                        }
                }
        }


  }
  else
  {
    DEBUGMSG("RasGetEntryDialParams returned %lu",dwRet);
  }

  delete pRASDialParams;

  return dwRet;
}


/*******************************************************************

  NAME:     ValidateConnectoidName

  SYNOPSIS: Validates the phonebook entry name specified.

  ENTRY:    pszConnectoidName - phonebook entry name

  EXIT:     Result of RasValidateEntryName

********************************************************************/

DWORD ValidateConnectoidName(LPCTSTR pszPhonebook, LPCTSTR pszConnectoidName)
{
  DEBUGMSG("rnacall.c::ValidateConnectoidName()");

  ASSERT(pszConnectoidName);

  // Load RNA if not already loaded
  DWORD dwRet = EnsureRNALoaded();
  if (dwRet != ERROR_SUCCESS) {
    return dwRet;
  }

  ASSERT(lpRasValidateEntryName);

  // Although we require a const char *, RasValidateEntryName will
  // accept it, so we have to cast.
  dwRet = lpRasValidateEntryName(pszPhonebook, (LPTSTR)pszConnectoidName);

  // If there are no previous entries, RasValidateEntryName may return
  // ERROR_CANNOT_OPEN_PHONEBOOK.  This is okay.
  if (ERROR_CANNOT_OPEN_PHONEBOOK == dwRet)
          dwRet = ERROR_SUCCESS;

  return dwRet;
}


/*******************************************************************

  NAME:     GetEntry

  SYNOPSIS: Gets the phonebook entry specified.  To get default
            entry, use "" as entry name. 

  ENTRY:    lpEntry - pointer to RASENTRY struct to fill
            szEntryName - phonebook entry name

  EXIT:     Result of RasGetEntryProperties

********************************************************************/

DWORD GetEntry(LPRASENTRY *lplpEntry, LPDWORD lpdwEntrySize, LPCTSTR szEntryName)
{
  DEBUGMSG("rnacall.c::GetEntry()");

  ASSERT(fRNALoaded);  // RNA should be loaded if we get here
  ASSERT(lplpEntry);
  ASSERT(szEntryName);

  // Allocate space if needed
  if (NULL == *lplpEntry)
  {
          *lpdwEntrySize = sizeof(RASENTRY);
          *lplpEntry = (LPRASENTRY) GlobalAlloc(GPTR,*lpdwEntrySize);
          if (NULL == *lplpEntry)
          {
                  *lpdwEntrySize = 0;
                  return ERROR_ALLOCATING_MEMORY;
          }
  }

  // get connectoid information from RNA
  DWORD dwSize = *lpdwEntrySize;
  (*lplpEntry)->dwSize = sizeof(RASENTRY);

  ASSERT(lpRasGetEntryProperties);
  DWORD dwRet = (lpRasGetEntryProperties) (NULL, szEntryName,
    (LPBYTE)*lplpEntry, &dwSize, NULL, NULL);

  // Allocate more space if needed
  if (ERROR_BUFFER_TOO_SMALL == dwRet)
  {
          LPRASENTRY lpNewEntry;

          lpNewEntry = (LPRASENTRY) GlobalReAlloc(*lplpEntry,dwSize,GMEM_MOVEABLE);
          if (NULL == lpNewEntry)
          {
                  return ERROR_ALLOCATING_MEMORY;
          }
          
          *lplpEntry = lpNewEntry;
          *lpdwEntrySize = dwSize;
          dwRet = (lpRasGetEntryProperties) (NULL, szEntryName,
                                                                                 (LPBYTE)*lplpEntry, &dwSize, NULL, NULL);
  }

  return dwRet;
}

VOID FAR PASCAL LineCallback(DWORD hDevice, DWORD dwMsg, 
    DWORD dwCallbackInstance, DWORD dwParam1, DWORD dwParam2, 
    DWORD dwParam3)
{
        return;
}
 
//+----------------------------------------------------------------------------
//
//      Function        GetTapiCountryID
//
//      Synopsis        Get the currenty country ID for the tapi settings
//
//      Arguments       none
//
//      Returns         pdwCountryID - contains address of country ID
//                              ERROR_SUCCESS - no errors
//
//      History         1/8/97  ChrisK Copied from icwconn1/dialerr.cpp
//
//-----------------------------------------------------------------------------
// Normandy 13097 - ChrisK 1/8/97
// NT returns the country ID not the country code
HRESULT GetTapiCountryID(LPDWORD pdwCountryID)
{
        HRESULT hr = ERROR_SUCCESS;
        HLINEAPP hLineApp = NULL;
        DWORD dwCurDev;
        DWORD cDevices;
        DWORD dwAPI;
        LONG lrc;
        LPLINETRANSLATECAPS pTC = NULL;
        LPVOID pv = NULL;
        LPLINELOCATIONENTRY plle = NULL;
        LINEEXTENSIONID leid;
        DWORD dwCurLoc;

        // Get CountryID from TAPI
        //

        *pdwCountryID = 0;

        // Get the handle to the line app
        //

        lineInitialize(&hLineApp,ghInstance,LineCallback," ",&cDevices);
        if (!hLineApp)
        {
                hr = GetLastError();
                goto GetTapiCountryIDExit;
        }

        if (cDevices)
        {

                // Get the TAPI API version
                //

                dwCurDev = 0;
                dwAPI = 0;
                lrc = -1;
                while (lrc && dwCurDev < cDevices)
                {
                        // NOTE: device ID's are 0 based
                        lrc = lineNegotiateAPIVersion(hLineApp,dwCurDev,0x00010004,0x00010004,&dwAPI,&leid);
                        dwCurDev++;
                }
                if (lrc)
                {
                        // TAPI and us can't agree on anything so nevermind...
                        hr = ERROR_GEN_FAILURE;
                        goto GetTapiCountryIDExit;
                }

                // Find the CountryID in the translate cap structure
                //

                pTC = (LINETRANSLATECAPS FAR *)GlobalAlloc(GPTR,sizeof(LINETRANSLATECAPS));
                if (!pTC)
                {
                        // we are in real trouble here, get out!
                        hr = ERROR_NOT_ENOUGH_MEMORY;
                        goto GetTapiCountryIDExit;
                }

                // Get the needed size
                //

                pTC->dwTotalSize = sizeof(LINETRANSLATECAPS);
                lrc = lineGetTranslateCaps(hLineApp,dwAPI,pTC);
                if(lrc)
                {
                        hr = lrc;
                        goto GetTapiCountryIDExit;
                }

                pv = (LPVOID) GlobalAlloc(GPTR,((size_t)pTC->dwNeededSize));
                if (!pv)
                {
                        hr = ERROR_NOT_ENOUGH_MEMORY;
                        goto GetTapiCountryIDExit;
                }
                ((LINETRANSLATECAPS FAR *)pv)->dwTotalSize = pTC->dwNeededSize;
                GlobalFree(pTC);
                pTC = (LINETRANSLATECAPS FAR *)pv;
                pv = NULL;
                lrc = lineGetTranslateCaps(hLineApp,dwAPI,pTC);
                if(lrc)
                {
                        hr = lrc;
                        goto GetTapiCountryIDExit;
                }
        
                plle = LPLINELOCATIONENTRY (LPTSTR(pTC) + pTC->dwLocationListOffset);
                for (dwCurLoc = 0; dwCurLoc < pTC->dwNumLocations; dwCurLoc++)
                {
                        *pdwCountryID = plle->dwPermanentLocationID;
                        if (pTC->dwCurrentLocationID == plle->dwPermanentLocationID)
                        {
                                        *pdwCountryID = plle->dwCountryID;
                                        break; // for loop
                        }
                        plle++;
                }
        }
GetTapiCountryIDExit:
        // 3/4/97       jmazner Olympus #1336
        if( hLineApp )
        {
                // we never call lineOpen, so no need to lineClose
                lineShutdown( hLineApp );
                hLineApp = NULL;
        }
        return hr;
}


/*******************************************************************

  NAME:     InitRasEntry

  SYNOPSIS: Initializes some parts of the RASENTRY struct.

  ENTRY:    lpEntry - pointer to RASENTRY struct to init

  NOTES:    Since this may be called before RNA is loaded, must not
            make any RNA calls.

  96/06/04  markdu  OSR  BUG 7246 Add RASEO_SwCompression and
            RASEO_ModemLights to default RASENTRY.

********************************************************************/

void InitRasEntry(LPRASENTRY lpEntry)
{
  DEBUGMSG("rnacall.c::InitRasEntry()");

  DWORD dwSize = sizeof(RASENTRY);
  ZeroMemory(lpEntry, dwSize);
  lpEntry->dwSize = dwSize;

  // default to use country code and area code
  lpEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;

  // default to use IP header compression
  lpEntry->dwfOptions |= RASEO_IpHeaderCompression;

  // default to use remote default gateway
  lpEntry->dwfOptions |= RASEO_RemoteDefaultGateway;

  // configure connectoid to not log on to network
  lpEntry->dwfOptions &= ~RASEO_NetworkLogon;    

  // default to use software compression
  lpEntry->dwfOptions |= RASEO_SwCompression;

  // default to use modem lights
  lpEntry->dwfOptions |= RASEO_ModemLights;

  // set connectoid for PPP
  lpEntry->dwFramingProtocol = RASFP_Ppp;

  // only use TCP/IP protocol
  lpEntry->dwfNetProtocols = RASNP_Ip;

  // default to use TAPI area code and country code
  TCHAR szCountryCode[8];       // 8 is from tapiGetLocationInfo documentation

  if (ERROR_SUCCESS == tapiGetLocationInfo(szCountryCode, lpEntry->szAreaCode))
  {
        // Normandy 13097 - ChrisK 1/8/97
        // NT returns the country ID not the country code
        if (szCountryCode[0])
        {
                if (IsNT())
                {
                        lpEntry->dwCountryID = myatoi(szCountryCode);
                        lpEntry->dwCountryCode = US_COUNTRY_CODE;

                        // Initialize data
                        LINECOUNTRYLIST FAR * lpLineCountryList;
                        DWORD dwSize;
                        dwSize = 0;
                        lpLineCountryList = (LINECOUNTRYLIST FAR *)
                                GlobalAlloc(GPTR,sizeof(LINECOUNTRYLIST));
                        if (NULL == lpLineCountryList)
                                return;
                        lpLineCountryList->dwTotalSize = sizeof(LINECOUNTRYENTRY);

                        // Get size of data structre
                        if(ERROR_SUCCESS != lineGetCountry(lpEntry->dwCountryID,0x10004,lpLineCountryList))
                        {
                                GlobalFree(lpLineCountryList);
                                return;
                        }
                        dwSize = lpLineCountryList->dwNeededSize;
                        GlobalFree(lpLineCountryList);
                        lpLineCountryList = (LINECOUNTRYLIST FAR *)GlobalAlloc(GPTR,dwSize);
                        if (NULL == lpLineCountryList)
                                return;
                        lpLineCountryList->dwTotalSize = dwSize;

                        // Get Country information for given ID
                        if(ERROR_SUCCESS != lineGetCountry(lpEntry->dwCountryID,0x10004,lpLineCountryList))
                        {
                                GlobalFree(lpLineCountryList);
                                return;
                        }
                
                        lpEntry->dwCountryCode = ((LINECOUNTRYENTRY FAR *)((DWORD_PTR)lpLineCountryList +
                                (DWORD)(lpLineCountryList->dwCountryListOffset)))->dwCountryCode;

                        GlobalFree(lpLineCountryList);
                        lpLineCountryList = NULL;

                }
                else
                {
                        lpEntry->dwCountryCode = myatoi(szCountryCode);
                        if (ERROR_SUCCESS != GetTapiCountryID(&lpEntry->dwCountryID))
                                lpEntry->dwCountryID = US_COUNTRY_ID;
                }
        }
  }
  else
  {
          lpEntry->dwCountryCode = US_COUNTRY_CODE;
  }
}


/*******************************************************************

  NAME:    InitCountryCodeList_w

  SYNOPSIS:  Worker function that fills a specified combo box with
        country code selections

  ENTRY:    hLB - HWND of combo box to fill
        dwSelectCountryID - if non-zero, the ID of country code
          to select as default
        fAll - if TRUE, all country codes are enumerated into
          combo box (potentially slow).  If FALSE, only
          the country code in dwSelectCountryID is enumerated.

  NOTES:    Cloned from RNA UI code

********************************************************************/
void InitCountryCodeList_w (HWND hLB, DWORD dwSelectCountryID,BOOL fAll)
{
  DEBUGMSG("rnacall.c::InitCountryCodeList_w()");

  LPRASCTRYINFO lpRasCtryInfo;
  LPCOUNTRYCODE pNext;
  DWORD cbSize;
  DWORD cbList;
  DWORD dwNextCountryID, dwRet;
  LPTSTR szCountryDesc;
  int   nIndex, iSelect;

  ASSERT(fRNALoaded);  // RNA should be loaded if we get here

  BUFFER Fmt(MAX_RES_LEN + SMALL_BUF_LEN);
  BUFFER CountryInfo(DEF_COUNTRY_INFO_SIZE);
  ASSERT(Fmt);
  ASSERT(CountryInfo);
  if (!Fmt || !CountryInfo) 
    return;

  // Load the display format
  LoadSz(IDS_COUNTRY_FMT,Fmt.QueryPtr(),SMALL_BUF_LEN);
  szCountryDesc = Fmt.QueryPtr()+SMALL_BUF_LEN;

  cbList = (DWORD)(fAll ? sizeof(COUNTRYCODE)*MAX_COUNTRY : sizeof(COUNTRYCODE));

  gpCountryCodeBuf = new TCHAR[cbList];
  ASSERT(gpCountryCodeBuf);
  if (!gpCountryCodeBuf)
    return;
  
  // Start enumerating the info from the first country
  dwNextCountryID   = (fAll || (dwSelectCountryID==0)) ?
                    1 : dwSelectCountryID;
  pNext = (LPCOUNTRYCODE) gpCountryCodeBuf;
  iSelect = 0;
  lpRasCtryInfo = (LPRASCTRYINFO) CountryInfo.QueryPtr();
  lpRasCtryInfo->dwSize = sizeof(RASCTRYINFO);
  ComboBox_ResetContent(hLB);

  // For each country
  while (dwNextCountryID != 0)
  {
    lpRasCtryInfo->dwCountryID  = dwNextCountryID;
    cbSize = CountryInfo.QuerySize();

    // Get the current country information
    ASSERT(lpRasGetCountryInfo);
    dwRet = lpRasGetCountryInfo(lpRasCtryInfo, &cbSize);
    if (ERROR_SUCCESS == dwRet)
    {
      TCHAR  szCountryDisp[MAX_COUNTRY_NAME+1];

      // Make a displayable name
      ShortenName((LPTSTR)(((LPBYTE)lpRasCtryInfo)+lpRasCtryInfo->dwCountryNameOffset),
        szCountryDisp, MAX_COUNTRY_NAME+1);

      // Add the country to the list
      wsprintf(szCountryDesc,Fmt.QueryPtr(), szCountryDisp, lpRasCtryInfo->dwCountryCode);
      nIndex = ComboBox_AddString(hLB, szCountryDesc);
      ASSERT(nIndex >= 0);

      // Copy the country information to our short list
      pNext->dwCountryID   = lpRasCtryInfo->dwCountryID;
      pNext->dwCountryCode = lpRasCtryInfo->dwCountryCode;
      dwNextCountryID      = lpRasCtryInfo->dwNextCountryID;
      ComboBox_SetItemData(hLB, nIndex, pNext);

      // If it is the specified country, make it a default one
      if (pNext->dwCountryID == dwSelectCountryID)
        ComboBox_SetCurSel(hLB, nIndex);

      // if need only one item, bail out
      //
      if (!fAll)
        break;

      // Advance to the next country
      pNext++;
    }
    else
    {
      // If the buffer is too small, reallocate a new one and retry
      if (dwRet == ERROR_BUFFER_TOO_SMALL)
      {
        BOOL fRet=CountryInfo.Resize(cbSize);
        ASSERT(fRet);
        if (!fRet || !CountryInfo)
          return;

        lpRasCtryInfo = (LPRASCTRYINFO) CountryInfo.QueryPtr();
      }
      else
      {
        break;
      }
    }
  }

  // Select the default device
  if ((dwRet == SUCCESS) && (ComboBox_GetCurSel(hLB) == CB_ERR))
    ComboBox_SetCurSel(hLB, 0);

  return;
}

/*******************************************************************

  NAME:    InitCountryCodeList

  SYNOPSIS:  Puts the (single) default country code in specified combo box

  ENTRY:    hLB - HWND of combo box to fill

  NOTES:    -Cloned from RNA UI code
        -Calls InitCountryCodeList_w to do work
        -Caller must call DeInitCountryCodeList when done to free buffer
        -Caller should call FillCountryCodeList when the combo box
          is touched to fill in the whole list of country codes

********************************************************************/
void InitCountryCodeList(HWND hLB)
{
  DEBUGMSG("rnacall.c::InitCountryCodeList()");

  DWORD dwCountryCodeID;

  // Load RNA if not already loaded
  if (EnsureRNALoaded() != ERROR_SUCCESS)
    return;

  // if there is a global rasentry, set default country code to
  // be the same as it... otherwise set default country code to US
  if (sizeof(RASENTRY) == gpRasEntry->dwSize)
  {
    dwCountryCodeID = gpRasEntry->dwCountryID;
  }
  else
  {
    dwCountryCodeID = US_COUNTRY_CODE;
  }

  InitCountryCodeList_w(hLB,dwCountryCodeID,FALSE);
}

/*******************************************************************

  NAME:    FillCountryCodeList

  SYNOPSIS:  Fills the country code listbox with list of all
        country codes

  ENTRY:    hLB - HWND of combo box to fill

  NOTES:    -Cloned from RNA UI code
        -May take a while!  (several seconds)  This shouldn't
          be called unless user plays with combo box
        -Assumes InitCountryCodeList has been called            
        -Caller must call DeInitCountryCodeList when done to free buffer

********************************************************************/
void FillCountryCodeList(HWND hLB)
{
  DEBUGMSG("rnacall.c::FillCountryCodeList()");

  LPCOUNTRYCODE lpcc;
  DWORD dwSelectID;

  ASSERT(fRNALoaded);  // RNA should be loaded if we get here

  // If we already complete the list, do nothing
  if (ComboBox_GetCount(hLB) > 1)
    return;

  // Get the currently selected country code
  if ((lpcc = (LPCOUNTRYCODE)ComboBox_GetItemData(hLB, 0)) != NULL)
  {
    dwSelectID = lpcc->dwCountryID;
  }
  else
  {
    dwSelectID = US_COUNTRY_CODE;
  }

  // free the country code buffer
  DeInitCountryCodeList();

  // set an hourglass cursor
  WAITCURSOR WaitCursor;

  // Enumerate full list of country codes
  InitCountryCodeList_w(hLB, dwSelectID, TRUE);
}

/*******************************************************************

  NAME:     GetCountryCodeSelection

  SYNOPSIS: Gets selected country code and ID based on combo box
        selection and fills them in in phone number struct

  ENTRY:    hLB - handle of combo box
            lpCountryCode - fill in with country code info

********************************************************************/
void GetCountryCodeSelection(HWND hLB,LPCOUNTRYCODE* plpCountryCode)
{
  DEBUGMSG("rnacall.c::GetCountryCodeSelection()");

  ASSERT(hLB);
  ASSERT(plpCountryCode);

  // get index of selected item in combo box
  int iSel = ComboBox_GetCurSel(hLB);

  ASSERT(iSel >= 0);  // should always be a selection
  if (iSel >= 0)
  {
    // get data for item, which is pointer to country code struct
    *plpCountryCode = (LPCOUNTRYCODE) ComboBox_GetItemData(hLB,iSel);
  }
}

/*******************************************************************

  NAME:    SetCountryIDSelection

  SYNOPSIS:  Sets selected country code in combo box

  EXIT:    returns TRUE if successful, FALSE if country code not
        in combo box

********************************************************************/
BOOL SetCountryIDSelection(HWND hwndCB,DWORD dwCountryID)
{
  DEBUGMSG("rnacall.c::SetCountryIDSelection()");

  BOOL fRet = FALSE;

  ASSERT(hwndCB);

  int iCount,iIndex;
  COUNTRYCODE * pcc;

  // search through items in combo box until we find one that
  // matches the specified country ID
  iCount = ComboBox_GetCount(hwndCB);
  for (iIndex = 0;iIndex < iCount;iIndex ++) {
    pcc = (COUNTRYCODE *) ComboBox_GetItemData(hwndCB,iIndex);
    if (pcc && pcc->dwCountryID == dwCountryID) {
      ComboBox_SetCurSel(hwndCB,iIndex);
      return TRUE;
    }
  }

  return FALSE;  // couldn't find country code in combo box
}

/*******************************************************************

  NAME:    DeInitCountryCodeList

  SYNOPSIS:  Frees buffer of country codes

  NOTES:    Call when done with combo box that displays country codes

********************************************************************/
void DeInitCountryCodeList(VOID)
{
  DEBUGMSG("rnacall.c::DeInitCountryCodeList()");

  // free the country code buffer
  ASSERT(gpCountryCodeBuf);
  if (gpCountryCodeBuf)
  {
    delete gpCountryCodeBuf;
    gpCountryCodeBuf = NULL;
  }
}

/*******************************************************************

  NAME:    ShortenName

  SYNOPSIS:  Copies a name to a (potentially shorter) buffer;
        if the name is too large it truncates it and adds "..."

  NOTES:    Cloned from RNA UI code

********************************************************************/
void ShortenName(LPTSTR szLongName, LPTSTR szShortName, DWORD cbShort)
{
//  DEBUGMSG("rnacall.c::ShortenName()");

  static BOOL    gfShortFmt  = FALSE;
  static TCHAR   g_szShortFmt[SMALL_BUF_LEN];
  static DWORD   gdwShortFmt = 0;

  ASSERT(szLongName);
  ASSERT(szShortName);

  // Get the shorten format
  if (!gfShortFmt)
  {
    gdwShortFmt  = LoadString(ghInstance, IDS_SHORT_FMT, g_szShortFmt,
      SMALL_BUF_LEN);
    gdwShortFmt -= 2;  // lstrlen("%s")
    gfShortFmt   = TRUE;
  };

  // Check the size of the long name
  if ((DWORD)lstrlen(szLongName)+1 <= cbShort)
  {
    // The name is shorter than the specified size, copy back the name
    lstrcpy(szShortName, szLongName);
  } else {
    BUFFER bufShorten(cbShort*2);
    ASSERT(bufShorten);

    if (bufShorten) {
      lstrcpyn(bufShorten.QueryPtr(), szLongName, cbShort-gdwShortFmt);
      wsprintf(szShortName, g_szShortFmt,bufShorten.QueryPtr());
    } else {
         lstrcpyn(szShortName, szLongName, cbShort);
    }
  }
}


/*******************************************************************

  NAME:    EnsureRNALoaded

  SYNOPSIS:  Loads RNA if not already loaded

********************************************************************/
DWORD EnsureRNALoaded(VOID)
{
  DEBUGMSG("rnacall.c::EnsureRNALoaded()");

  DWORD dwRet = ERROR_SUCCESS;

  // load RNA if necessary
  if (!fRNALoaded) {
    if (InitRNA(NULL))
      fRNALoaded = TRUE;
    else return ERROR_FILE_NOT_FOUND;
  }

  return dwRet;
}


/*******************************************************************

  NAME:    ENUM_MODEM::ENUM_MODEM

  SYNOPSIS:  Constructor for class to enumerate modems

  NOTES:    Useful to have a class rather than C functions for
        this, due to how the enumerators function

********************************************************************/
ENUM_MODEM::ENUM_MODEM() :
  m_dwError(ERROR_SUCCESS),m_lpData(NULL),m_dwIndex(0)
{
  DWORD cbSize = 0;

  // Use the reinit member function to do the work.
  this->ReInit();
}


/*******************************************************************

  NAME:     ENUM_MODEM::ReInit

  SYNOPSIS: Re-enumerate the modems, freeing the old memory.

********************************************************************/
DWORD ENUM_MODEM::ReInit()
{
  DWORD cbSize = 0;

  // Clean up the old list
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
  m_dwNumEntries = 0;
  m_dwIndex = 0;

  // call RasEnumDevices with no buffer to find out required buffer size
  ASSERT(lpRasEnumDevices);
  m_dwError = lpRasEnumDevices(NULL, &cbSize, &m_dwNumEntries);

  // Special case check to work around RNA bug where ERROR_BUFFER_TOO_SMALL
  // is returned even if there are no devices.
  // If there are no devices, we are finished.
  if (0 == m_dwNumEntries)
  {
    m_dwError = ERROR_SUCCESS;
    return m_dwError;
  }

  // Since we were just checking how much mem we needed, we expect
  // a return value of ERROR_BUFFER_TOO_SMALL, or it may just return
  // ERROR_SUCCESS (ChrisK  7/9/96).
  if (ERROR_BUFFER_TOO_SMALL != m_dwError && ERROR_SUCCESS != m_dwError)
  {
    return m_dwError;
  }

  // Allocate the space for the data
  m_lpData = (LPRASDEVINFO) new TCHAR[cbSize];
  if (NULL == m_lpData)
  {
    DEBUGTRAP("ENUM_MODEM: Failed to allocate device list buffer");
    m_dwError = ERROR_NOT_ENOUGH_MEMORY;
    return m_dwError;
  }
  m_lpData->dwSize = sizeof(RASDEVINFO);
  m_dwNumEntries = 0;

  // enumerate the modems into buffer
  m_dwError = lpRasEnumDevices(m_lpData, &cbSize,
    &m_dwNumEntries);

  if (ERROR_SUCCESS != m_dwError)
          return m_dwError;

    //
    // ChrisK Olympus 4560 do not include VPN's in the list
    //
    DWORD dwTempNumEntries;
    DWORD idx;
    LPRASDEVINFO lpNextValidDevice;

    dwTempNumEntries = m_dwNumEntries;
    lpNextValidDevice = m_lpData;

        //
        // Walk through the list of devices and copy non-VPN device to the first
        // available element of the array.
        //
        for (idx = 0;idx < dwTempNumEntries; idx++)
        {
        // We only want to show Modem and ISDN (or ADSL in future) device type
        // in this dialog.
        // 
        // char b[400];
        // wsprintf(b, "Type:%s, Name:%s", m_lpData[idx].szDeviceType, m_lpData[idx].szDeviceName);
        // MessageBox(0, b, "Devices", MB_OK);
        //
                if ((0 == lstrcmpi(TEXT("MODEM"),m_lpData[idx].szDeviceType)) ||
            (0 == lstrcmpi(TEXT("ISDN"),m_lpData[idx].szDeviceType)))
                {
                        if (lpNextValidDevice != &m_lpData[idx])
                        {
                                MoveMemory(lpNextValidDevice ,&m_lpData[idx],sizeof(RASDEVINFO));
                        }
                        lpNextValidDevice++;
                }
                else
                {
                        m_dwNumEntries--;
                }
        }
  
  return m_dwError;
}


/*******************************************************************

  NAME:    ENUM_MODEM::~ENUM_MODEM

  SYNOPSIS:  Destructor for class

********************************************************************/
ENUM_MODEM::~ENUM_MODEM()
{
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
}

/*******************************************************************

  NAME:     ENUM_MODEM::Next

  SYNOPSIS: Enumerates next modem 

  EXIT:     Returns a pointer to device info structure.  Returns
            NULL if no more modems or error occurred.  Call GetError
            to determine if error occurred.

********************************************************************/
TCHAR * ENUM_MODEM::Next()
{
  if (m_dwIndex < m_dwNumEntries)
  {
    return m_lpData[m_dwIndex++].szDeviceName;
  }

  return NULL;
}


/*******************************************************************

  NAME:     ENUM_MODEM::GetDeviceTypeFromName

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device type string for first
            device name that matches.  Returns
            NULL if no device with specified name is found

********************************************************************/

TCHAR * ENUM_MODEM::GetDeviceTypeFromName(LPTSTR szDeviceName)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return m_lpData[dwIndex].szDeviceType;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     ENUM_MODEM::GetDeviceNameFromType

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device name string for first
            device type that matches.  Returns
            NULL if no device with specified Type is found

********************************************************************/

TCHAR * ENUM_MODEM::GetDeviceNameFromType(LPTSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType))
    {
      return m_lpData[dwIndex].szDeviceName;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     ENUM_MODEM::VerifyDeviceNameAndType

  SYNOPSIS: Determines whether there is a device with the name
            and type given.

  EXIT:     Returns TRUE if the specified device was found, 
            FALSE otherwise.

********************************************************************/

BOOL ENUM_MODEM::VerifyDeviceNameAndType(LPTSTR szDeviceName, LPTSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType) &&
      !lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return TRUE;
    }
    dwIndex++;
  }

  return FALSE;
}


/*******************************************************************

  NAME:    ENUM_CONNECTOID::ENUM_CONNECTOID

  SYNOPSIS:  Constructor for class to enumerate connectoids

  NOTES:    Useful to have a class rather than C functions for
        this, due to how the enumerators function

********************************************************************/
ENUM_CONNECTOID::ENUM_CONNECTOID() :
  m_dwError(ERROR_SUCCESS),m_dwNumEntries(0),m_lpData(NULL),m_dwIndex(0)
{
  DWORD cbSize;
  RASENTRYNAME   rasEntryName;
  
  cbSize = sizeof(RASENTRYNAME);
  rasEntryName.dwSize = cbSize;

  // call RasEnumEntries with a temp structure.  this will not likely
  // be big enough, but cbSize will be filled with the required size
  ASSERT(lpRasEnumEntries);
  m_dwError = lpRasEnumEntries(NULL, NULL, &rasEntryName,
    &cbSize, &m_dwNumEntries);
  if ((ERROR_BUFFER_TOO_SMALL != m_dwError) &&
    (ERROR_SUCCESS != m_dwError))
  {
    return;
  }

  // Make sure that there is at least enough room for the structure
  // (RasEnumEntries will return 0 as cbSize if there are no entries)
  cbSize = (cbSize > sizeof(RASENTRYNAME)) ? cbSize : sizeof(RASENTRYNAME);

  // Allocate the space for the data
  m_lpData = (LPRASENTRYNAME) new TCHAR[cbSize];
  if (NULL == m_lpData)
  {
    DEBUGTRAP("ENUM_CONNECTOID: Failed to allocate connectoid list buffer");
    m_dwError = ERROR_NOT_ENOUGH_MEMORY;
    return;
  }
  m_lpData->dwSize = sizeof(RASENTRYNAME);

  m_dwNumEntries = 0;

  // enumerate the connectoids into buffer
  m_dwError = lpRasEnumEntries(NULL, NULL, m_lpData, &cbSize, &m_dwNumEntries);

  if (IsNT5())
  {
    DWORD dwNumEntries = 0;
  
    if (ERROR_SUCCESS == m_dwError && m_dwNumEntries) 
    {
      for(DWORD dwIndx=0; dwIndx < m_dwNumEntries; dwIndx++)
      {
          LPRASENTRY  lpRasEntry = NULL;
          DWORD       dwRasEntrySize = 0;
          if (GetEntry(&lpRasEntry, &dwRasEntrySize, m_lpData[dwIndx].szEntryName) == ERROR_SUCCESS)
          {
              // check connection type
              if ((0 != lstrcmpi(TEXT("MODEM"), lpRasEntry->szDeviceType)) &&
                 (0 != lstrcmpi(TEXT("ISDN"), lpRasEntry->szDeviceType)))
                    *(m_lpData[dwIndx].szEntryName) = 0;
              else
                  dwNumEntries++;
          }
          //
          // Release memory
          //
          if (NULL != lpRasEntry)
          {
              GlobalFree(lpRasEntry);
              lpRasEntry = NULL;
          }
      } // End for loop
      m_dwNumEntries = dwNumEntries;
    }
 
  }


}

/*******************************************************************

  NAME:    ENUM_CONNECTOID::~ENUM_CONNECTOID

  SYNOPSIS:  Destructor for class

********************************************************************/
ENUM_CONNECTOID::~ENUM_CONNECTOID()
{
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
}

/*******************************************************************

  NAME:    ENUM_CONNECTOID::Next

  SYNOPSIS:  Enumerates next connectoid

  EXIT:    Returns a pointer to connectoid name.  Returns NULL
        if no more connectoids or error occurred.  Call GetError
        to determine if error occurred.

********************************************************************/
TCHAR * ENUM_CONNECTOID::Next()
{
  while (m_dwIndex < m_dwNumEntries)
  {
      if (0 == *(m_lpData[m_dwIndex].szEntryName))
      {
          m_dwIndex++;
      }
      else
      {
         return m_lpData[m_dwIndex++].szEntryName;
      }
  }

  return NULL;
}

/*******************************************************************

  NAME:    ENUM_CONNECTOID::NumEntries

  SYNOPSIS:  returns number of connectoids stored in this instance

  EXIT:    Returns value of m_dwNumEntries

  HISTORY:      11/11/96        jmazner         Created.

********************************************************************/
DWORD ENUM_CONNECTOID::NumEntries()
{
        return m_dwNumEntries;
}

//+----------------------------------------------------------------------------
//      Function:       FRasValidatePatch
//
//      Synopsis:       With all of the other Ras functions there exists a common entry
//                              point for WinNT and Win95, usually the A version.  However,
//                              RasValidateEntryName only has an A and W version on WinNT and
//                              an unqualified version on Win95.  Therefore we have to do some
//                              special processing to try to find it
//
//      Input:          ppFP - Location to save function point to
//                              hInst1 - First DLL to check for entry point
//                              hInst2 - Second DLL to check for entry point
//                              lpszName - Name of the function (if it isn't RasValidateEntryName)
//                                      we just skip it and move on.
//
//      Return:         TRUE - success
//
//      History:        7/3/96          Created, ChrisK
//
//-----------------------------------------------------------------------------
BOOL FRasValidatePatch(PVOID *ppFP, HINSTANCE hInst1, HINSTANCE hInst2, LPCSTR lpszName)
{
        BOOL bRC = TRUE;

        //
        // Validate parameters
        //
        if (ppFP && hInst1 && lpszName)
        {

                //
                // Check that we are really looking for RasValidateEntryName
                //
                if (0 == lstrcmpA(lpszName,szRasValidateEntryName))
                {
                        //
                        // Find entry point with alternate name
                        //
                        *ppFP = GetProcAddress(hInst1,szRasValidateEntryName);
                        if (!*ppFP && hInst2)
                                *ppFP = GetProcAddress(hInst2,szRasValidateEntryName);
                        if (!*ppFP)
                        {
                                DEBUGMSG("INETCFG: FRasValidatePatch entry point not found is either DLL.\n");
                                bRC = FALSE;
                        }
                }
                else
                {
                        bRC = FALSE;
                }
        }
        else
        {
                DEBUGMSG("INETCFG: FRasValidatePatch invalid parameters.\n");
                bRC = FALSE;
        }

//FRasValidatePatchExit:
        return bRC;
}

/*******************************************************************

  NAME:    GetApiProcAddresses

  SYNOPSIS:  Gets proc addresses for a table of functions

  EXIT:    returns TRUE if successful, FALSE if unable to retrieve
        any proc address in table

  HISTORY: 
  96/02/28  markdu  If the api is not found in the module passed in,
            try the backup (RNAPH.DLL)

********************************************************************/
BOOL GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,UINT nApiProcs)
{
  DEBUGMSG("rnacall.c::GetApiProcAddresses()");

  UINT nIndex;
  // cycle through the API table and get proc addresses for all the APIs we
  // need
  for (nIndex = 0;nIndex < nApiProcs;nIndex++)
  {
    if (!(*pApiProcList[nIndex].ppFcnPtr = (PVOID) GetProcAddress(hModDLL,
      pApiProcList[nIndex].pszName)))
    {
      // Try to find the address in RNAPH.DLL.  This is useful in the
      // case thatRASAPI32.DLL did not contain the function that we
      // were trying to load.
      if (FALSE == IsNT())
          {
                  if (!ghInstRNAPHDll)
                  {
                        TCHAR szRNAPHDll[SMALL_BUF_LEN];

                        LoadSz(IDS_RNAPHDLL_FILENAME,szRNAPHDll,ARRAYSIZE(szRNAPHDll));
                        ghInstRNAPHDll = LoadLibrary(szRNAPHDll);
                  }

                  if ((!ghInstRNAPHDll) ||  !(*pApiProcList[nIndex].ppFcnPtr =
                        (PVOID) GetProcAddress(ghInstRNAPHDll,pApiProcList[nIndex].pszName)))
                  {
                          if (!FRasValidatePatch(pApiProcList[nIndex].ppFcnPtr, hModDLL,
                                  ghInstRNAPHDll, pApiProcList[nIndex].pszName))
                          {
                                DEBUGMSG("Unable to get address of function %s",
                                        pApiProcList[nIndex].pszName);

                                for (nIndex = 0;nIndex<nApiProcs;nIndex++)
                                        *pApiProcList[nIndex].ppFcnPtr = NULL;

                                return FALSE;
                          }
                  }
                }
        }
  }

  return TRUE;
}


/*******************************************************************

  NAME:    GetRNAErrorText

  SYNOPSIS:  Gets text string corresponding to RNA error code

  ENTRY:    uErr - RNA error code
        pszErrText - buffer to retrieve error text description
        cbErrText - size of pszErrText buffer

********************************************************************/

VOID GetRNAErrorText(UINT uErr,TCHAR * pszErrText,DWORD cbErrText)
{
  DEBUGMSG("rnacall.c::GetRNAErrorText()");

  ASSERT(pszErrText);

  ASSERT(lpRasGetErrorString);
  DWORD dwRet = lpRasGetErrorString(uErr,pszErrText,cbErrText);

  if (dwRet != ERROR_SUCCESS) {
    // if we couldn't get real error text, then make generic string
    // with the error number
    TCHAR szFmt[SMALL_BUF_LEN+1];
    LoadSz(IDS_GENERIC_RNA_ERROR,szFmt,ARRAYSIZE(szFmt));
    wsprintf(pszErrText,szFmt,uErr);
  }
}


/* S W A P  D W  B Y T E S Taken from rnaph.c */
/*----------------------------------------------------------------------------
  %%Function: SwapDwBytes

  Swap the bytes of a DWORD.
  (BSWAP isn't available on a 386)

----------------------------------------------------------------------------*/
VOID SwapDwBytes(LPDWORD lpdw)
{
  IADDR iaddr;

  iaddr.ia.a = ((PIADDR) lpdw)->ia.d;
  iaddr.ia.b = ((PIADDR) lpdw)->ia.c;
  iaddr.ia.c = ((PIADDR) lpdw)->ia.b;
  iaddr.ia.d = ((PIADDR) lpdw)->ia.a;

  *lpdw = iaddr.dw;
}

/* C O P Y  D W  2  I A   Taken from rnaph.c */
/*----------------------------------------------------------------------------
  %%Function: CopyDw2Ia

  Convert a DWORD to an Internet Address

----------------------------------------------------------------------------*/
VOID CopyDw2Ia(DWORD dw, RASIPADDR* pia)
{
  SwapDwBytes(&dw);
  *pia = ((PIADDR) &dw)->ia;
}

/* D W  F R O M  I A Taken from rnaph.c */
/*----------------------------------------------------------------------------
  %%Function: DwFromIa

  Convert an Internet Address to a DWORD

----------------------------------------------------------------------------*/
DWORD DwFromIa(RASIPADDR *pia)
{
  IADDR iaddr;

  iaddr.dw = * (LPDWORD) pia;
  SwapDwBytes(&iaddr.dw);  
  
  return iaddr.dw;
}

/* F  V A L I D  I A    Taken from rnaph.c */
/*----------------------------------------------------------------------------
  %%Function: FValidIa

  Return TRUE if the IP address is valid

----------------------------------------------------------------------------*/
BOOL FValidIa(RASIPADDR *pia)
{
  BYTE b;

  b = ((PIADDR) pia)->ia.a;
  if (b < MIN_IP_FIELD1 || b > MAX_IP_FIELD1 || b == 127)
    return FALSE;

  b = ((PIADDR) pia)->ia.d;
  if (b > MAX_IP_FIELD4)
    return FALSE;

  return TRUE;
}


/*******************************************************************

  NAME:     SwapDwBits

  SYNOPSIS: Swap the values of the specified bits

  ENTRY:    lpdw - address of DWORD with bits to be swapped
            dwBit1 - mask for first bit
            dwBit2 - mask for second bit

  HISTORY:
  96/05/14  markdu  NASH BUG 22730 Created to work around RNA bug.

********************************************************************/

void SwapDWBits(LPDWORD lpdw, DWORD dwBit1, DWORD dwBit2)
{
  ASSERT(lpdw);

  // Only need to swap if exactly one of the two bits is set since
  // otherwise the bits are identical.
  if (((*lpdw & dwBit1) &&
    !(*lpdw & dwBit2)) ||
    (!(*lpdw & dwBit1) &&
    (*lpdw & dwBit2)))
  {
    // Since only one of the two bits was set, we can simulate the swap
    // by flipping each bit.
    *lpdw ^= dwBit1;
    *lpdw ^= dwBit2;
  }
}

//+----------------------------------------------------------------------------
//
//      Function:       InitTAPILocation
//
//      Synopsis:       Ensure that TAPI location information is configured correctly;
//                              if not, prompt user to fill it in.
//
//      Arguments:      hwndParent -- parent window for TAPI dialog to use
//                                                      (_must_ be a valid window HWND, see note below)
//
//      Returns:        void
//
//      Notes:          The docs for lineTranslateDialog lie when they say that the
//                              fourth parameter (hwndOwner) can be null.  In fact, if this
//                              is null, the call will return with LINEERR_INVALPARAM.
//                              
//
//      History:        7/15/97 jmazner Created for Olympus #6294
//
//-----------------------------------------------------------------------------
BOOL InitTAPILocation(HWND hwndParent)
{
    HLINEAPP hLineApp=NULL;
    TCHAR szTempCountryCode[8];
    TCHAR szTempCityCode[8];
    BOOL bRetVal = TRUE;
    DWORD dwTapiErr = 0;
    DWORD cDevices=0;
    DWORD dwCurDevice = 0;


    ASSERT( IsWindow(hwndParent) );

    //
    // see if we can get location info from TAPI
    //
    dwTapiErr = tapiGetLocationInfo(szTempCountryCode,szTempCityCode);
    if( 0 != dwTapiErr )
    {
        // 
        // GetLocation failed.  let's try calling the TAPI mini dialog.  Note
        // that when called in this fashion, the dialog has _no_ cancel option,
        // the user is forced to enter info and hit OK.
        //
        DEBUGMSG("InitTAPILocation, tapiGetLocationInfo failed");
        
        dwTapiErr = lineInitialize(&hLineApp,ghInstance,LineCallback," ",&cDevices);
        if (dwTapiErr == ERROR_SUCCESS)
        {
            //
            // loop through all TAPI devices and try to call lineTranslateDialog
            // The call might fail for VPN devices, thus we want to try every
            // device until we get a success.
            //
            dwTapiErr = LINEERR_INVALPARAM;

            while( (dwTapiErr != 0) && (dwCurDevice < cDevices) )
            {
                BOOL bIsNT5 = IsNT5();
                if (bIsNT5)
                    EnableWindow(hwndParent, FALSE);
                dwTapiErr = lineTranslateDialog(hLineApp,dwCurDevice,0x10004,hwndParent,NULL);
                if (bIsNT5)
                    EnableWindow(hwndParent, TRUE);

                if( 0 != dwTapiErr )
                {
                    DEBUGMSG("InitTAPILocation, lineTranslateDialog on device %d failed with err = %d!",
                        dwCurDevice, dwTapiErr);
                    if (bIsNT5)
                    {
                        bRetVal = FALSE;
                        break;
                    }
                }
                dwCurDevice++;
            }
        }
        else
        {
            DEBUGMSG("InitTAPILocation, lineInitialize failed with err = %d", dwTapiErr);
        }

        dwTapiErr = tapiGetLocationInfo(szTempCountryCode,szTempCityCode);
        if( 0 != dwTapiErr )
        {
            DEBUGMSG("InitTAPILocation still failed on GetLocationInfo, bummer.");
        }
        else
        {
            DEBUGMSG("InitTAPILocation, TAPI location is initialized now");
        }
    }

    if( hLineApp )
    {
        lineShutdown(hLineApp);
        hLineApp = NULL;
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\strings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  STRINGS.H - Header file for hard-coded strings
//

//  HISTORY:
//  
//  12/22/94  jeremys Created.
//  96/02/23  markdu  Replaced RNAValidateEntryName with
//            RASValidateEntryName
//  96/02/24  markdu  Re-wrote the implementation of ENUM_MODEM to
//            use RASEnumDevices() instead of RNAEnumDevices().
//            Also removed RNAGetDeviceInfo().
//  96/02/24  markdu  Re-wrote the implementation of ENUM_CONNECTOID to
//            use RASEnumEntries() instead of RNAEnumConnEntries().
//  96/03/25  markdu  Removed szDefAreaCode.
//  96/04/24  markdu  NASH BUG 19289 Added /NOMSN command line flag
//

#ifndef _STRINGS_H_
#define _STRINGS_H_

// registry strings
extern const TCHAR szRegPathInternetSettings[];
extern const TCHAR szTCPGlobalKeyName[];
extern const TCHAR szRegValRNAWizard[];
extern const TCHAR szRegPathRNAWizard[];
extern const TCHAR szRegValHostName[];
extern const TCHAR szRegValInternetProfile[];
extern const TCHAR szRegValBkupInternetProfile[];
extern const TCHAR szRegValEnableAutodial[];
extern const TCHAR szRegValNoNetAutodial[];
extern const TCHAR szRegValEnableSecurityCheck[];
extern const TCHAR szRegValAccessMedium[];
extern const TCHAR szRegValAccessType[];
extern const TCHAR szRegPathWarningFlags[];
extern const TCHAR szRegValDisableDNSWarning[];
extern const TCHAR szRegValInstalledMSN105[];
extern const TCHAR szRegPathOptComponents[];
extern const TCHAR szRegPathMSNetwork105[];
extern const TCHAR szRegValInstalled[];

//	//10/24/96 jmazner Normandy 6968
//	//No longer neccessary thanks to Valdon's hooks for invoking ICW.
// 11/21/96 jmazner Normandy 11812
// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
// ICW 1.1 needs to morph the IE 3 icon.
extern const TCHAR szRegPathInternetIconCommand[];

extern const TCHAR szRegPathIexploreAppPath[];
extern const TCHAR szRegPathNameSpace[];
extern const TCHAR szRegKeyInternetIcon[];
extern const TCHAR szRegPathMailApp[];
extern const TCHAR szRegPathNewsApp[];
extern const TCHAR szRegPathICWSettings[];
extern const TCHAR szRegValICWCompleted[];
extern const TCHAR szRegValShellNext[];
extern const TCHAR szICWShellNextFlag[];

extern const TCHAR cszRegPathXInternetSignup[];
extern const TCHAR cszRegPathAppPaths[];
extern const TCHAR cszPath[];
extern const TCHAR cszInstallationDirectory[];

extern const TCHAR szICWSmartStartFlag[];

extern const TCHAR szFullICWFileName[];
extern const TCHAR szManualICWFileName[];
extern const TCHAR szISignupICWFileName[];

extern const TCHAR szRegIEAKSettings[];
extern const TCHAR szREgIEAKNeededKey[];
extern const TCHAR szPathSubKey[];
extern const TCHAR szIEAKSignupFilename[];


// mailnews api function names
extern const CHAR szSetDefaultMailHandler[];
extern const CHAR szSetDefaultNewsHandler[];

// MAPI api function names
extern const CHAR szMAPIInitialize[];
extern const CHAR szMAPIUninitialize[];
extern const CHAR szMAPIAdminProfiles[];
extern const CHAR szMAPIAllocateBuffer[];
extern const CHAR szMAPIFreeBuffer[];
extern const CHAR szHrQueryAllRows[];

// RNA api function names
extern const CHAR szRasGetCountryInfo[];
extern const CHAR szRasEnumDevices[];
extern const CHAR szRasValidateEntryName[];
extern const CHAR szRasValidateEntryNameA[];
extern const CHAR szRasGetErrorString[];
extern const CHAR szRasGetEntryDialParams[];
extern const CHAR szRasSetEntryDialParams[];
extern const CHAR szRasSetEntryProperties[];
extern const CHAR szRasGetEntryProperties[];
extern const CHAR szRasEnumEntries[];
extern const CHAR szRasSetCredentials[];

// Config api function names
extern const CHAR szDoGenInstall[];          
extern const CHAR szGetSETUPXErrorText[];    
extern const CHAR szIcfgSetInstallSourcePath[];  
extern const CHAR szIcfgInstallInetComponents[];        
extern const CHAR szIcfgNeedInetComponents[];           
extern const CHAR szIcfgIsGlobalDNS[];  
extern const CHAR szIcfgRemoveGlobalDNS[];    
extern const CHAR szIcfgTurnOffFileSharing[];  
extern const CHAR szIcfgIsFileSharingTurnedOn[];         
extern const CHAR szIcfgGetLastInstallErrorText[];         
extern const CHAR szIcfgStartServices[];
//
// Available only on NT icfg32.dll
//
extern const CHAR szIcfgNeedModem[];
extern const CHAR szIcfgInstallModem[];


// misc strings
extern const TCHAR sz0[];
extern const TCHAR sz1[];
extern const TCHAR szNull[];
extern const TCHAR szSlash[];
extern const TCHAR szNOREBOOT[];
extern const TCHAR szUNINSTALL[];
extern const TCHAR szNOMSN[];
extern const TCHAR szFmtAppendIntToString[];
extern const TCHAR szDefaultAreaCode[];
extern const TCHAR szNOIMN[];

#endif // _STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\tcpcmn.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  TCPCMN.H - central header file for TCP/IP structures and configuration
//         functions
//

//  HISTORY:
//  
//  12/6/94    jeremys  Created.
//  96/03/23  markdu  Removed Get/ApplyInstanceTcpInfo functions.
//  96/03/23  markdu  Removed TCPINFO struct and TCPINSTANCE struct.
//  96/03/25  markdu  Removed connectoid name parameter from 
//            Get/ApplyGlobalTcpInfo functions since they should not
//            be setting per-connectoid stuff anymore.
//            Renamed ApplyGlobalTcpInfo to ClearGlobalTcpInfo, and 
//            changed function to just clear the settings.
//            Renamed GetGlobalTcpInfo to IsThereGlobalTcpInfo, and
//            changed function to just get the settings.
//            Removed TCPGLOBAL struct,
//  96/04/04  markdu  Added pfNeedsRestart to WarnIfServerBound, and
//            added function RemoveIfServerBound.
//

#ifndef _TCPCMN_H_
#define _TCPCMN_H_

typedef DWORD IPADDRESS;

// same limits as in net setup UI
#define IP_ADDRESS_LEN          15    // big enough for www.xxx.yyy.zzz
#define MAX_GATEWAYS      8
#define MAX_DNSSERVER      3

// big enough for <ip>,<ip>,...
#define MAX_DNSSERVERLEN    MAX_DNSSERVER * (IP_ADDRESS_LEN+1)
#define MAX_GATEWAYLEN      MAX_GATEWAYS * (IP_ADDRESS_LEN+1)

// functions in TCPCFG.C
HRESULT WarnIfServerBound(HWND hDlg,DWORD dwCardFlags,BOOL* pfNeedsRestart);
HRESULT RemoveIfServerBound(HWND hDlg,DWORD dwCardFlags,BOOL* pfNeedsRestart);
BOOL IPStrToLong(LPCTSTR pszAddress,IPADDRESS * pipAddress);
BOOL IPLongToStr(IPADDRESS ipAddress,LPTSTR pszAddress,UINT cbAddress);

// dwGet/ApplyFlags bits for GetInstanceTCPInfo / ApplyInstanceTCPInfo:
// use INSTANCE_NETDRIVER, INSTANCE_PPPDRIVER, INSTANCE_ALL defined in wizglob.h

#define MAKEIPADDRESS(b1,b2,b3,b4)  ((LPARAM)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

// node type flags for _dwNodeFlags
#define NT_DRIVERNODE  0x0001
#define NT_ENUMNODE    0x0002

class ENUM_TCP_INSTANCE
{
private:
  DWORD       _dwCardFlags;  // INSTANCE_NETDRIVER, INSTANCE_PPPDRIVER, etc
  DWORD      _dwNodeFlags;  // NT_DRIVERNODE, NT_ENUMNODE, etc
  UINT       _error;
  HKEY       _hkeyTcpNode;
  VOID      CloseNode();
public:
  ENUM_TCP_INSTANCE(DWORD dwCardFlags,DWORD dwNodeFlags);
  ~ENUM_TCP_INSTANCE();
  HKEY Next();
  UINT GetError()  { return _error; }
};


#endif  // _TCPCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\strings.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  STRINGS.C - String literals for hard-coded strings
//

//  HISTORY:
//  
//  12/22/94  jeremys Created.
//  96/02/23  markdu  Replaced RNAValidateEntryName with
//            RASValidateEntryName
//  96/02/24  markdu  Re-wrote the implementation of ENUM_MODEM to
//            use RASEnumDevices() instead of RNAEnumDevices().
//            Also removed RNAGetDeviceInfo().
//  96/02/24  markdu  Re-wrote the implementation of ENUM_CONNECTOID to
//            use RASEnumEntries() instead of RNAEnumConnEntries().
//  96/03/25  markdu  Removed szDefAreaCode.
//  96/04/24  markdu  NASH BUG 19289 Added /NOMSN command line flag
//  96/07/02  ChrisK  Added A to Ras entry points for NT 4.0
//

#include "wizard.h"

#pragma data_seg(DATASEG_READONLY)

//////////////////////////////////////////////////////
// registry strings
//////////////////////////////////////////////////////

// "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
static const TCHAR szRegPathInternetSettings[] = REGSTR_PATH_INTERNET_SETTINGS;

// "System\\CurrentControlSet\\Services\\VxD\\MSTCP"
static const TCHAR szTCPGlobalKeyName[] =     REGSTR_PATH_VXD TEXT("\\MSTCP");

static const TCHAR szRegValRNAWizard[] =     TEXT("wizard");

// "RemoteAccess"
static const TCHAR szRegPathRNAWizard[] =     REGSTR_PATH_REMOTEACCESS;

static const TCHAR szRegValHostName[] =       TEXT("HostName");

// "InternetProfile"
static const TCHAR szRegValInternetProfile[] =   REGSTR_VAL_INTERNETPROFILE;

// "BackupInternetProfile"
static const TCHAR szRegValBkupInternetProfile[] =   REGSTR_VAL_BKUPINTERNETPROFILE;

// "EnableAutodial"
static const TCHAR szRegValEnableAutodial[] =  REGSTR_VAL_ENABLEAUTODIAL;

// "NoNetAutodial"
static const TCHAR szRegValNoNetAutodial[] =  REGSTR_VAL_NONETAUTODIAL;

// "EnableSecurityCheck"
static const TCHAR szRegValEnableSecurityCheck[] = REGSTR_VAL_ENABLESECURITYCHECK;

// "AccessMedium"
static const TCHAR szRegValAccessMedium[] =    REGSTR_VAL_ACCESSMEDIUM;

// "AccessType"
static const TCHAR szRegValAccessType[] =    REGSTR_VAL_ACCESSTYPE;

static const TCHAR szRegValInstalledMSN105[] =  TEXT("InstallData1");

static const TCHAR szRegPathWarningFlags[] =    TEXT("Software\\Microsoft\\MOS\\Connection");
static const TCHAR szRegValDisableDNSWarning[] = TEXT("NoDNSWarning");

// "Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents"
static const TCHAR szRegPathOptComponents[]=REGSTR_PATH_SETUP REGSTR_KEY_SETUP TEXT("\\OptionalComponents");

static const TCHAR szRegPathMSNetwork105[] =    TEXT("MSNetwork105");
static const TCHAR szRegValInstalled[] =     TEXT("Installed");

//    //10/24/96 jmazner Normandy 6968
//    //No longer neccessary thanks to Valdon's hooks for invoking ICW.
// 11/21/96 jmazner Normandy 11812
// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
// ICW 1.1 needs to morph the IE 3 icon.
static const TCHAR szRegPathInternetIconCommand[] = TEXT("CLSID\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}\\Shell\\Open\\Command");

static const TCHAR szRegPathIexploreAppPath[] =  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE");
static const TCHAR szPathSubKey[] = TEXT("Path");
static const TCHAR szRegPathNameSpace[] =    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace");
static const TCHAR szRegKeyInternetIcon[] =     TEXT("{FBF23B42-E3F0-101B-8488-00AA003E56F8}");

// Athena Mail and News
static const TCHAR szRegPathMailApp[] = TEXT("CLSID\\{89292102-4755-11cf-9DC2-00AA006C2B84}\\InProcServer32");
static const TCHAR szRegPathNewsApp[] = TEXT("CLSID\\{89292103-4755-11cf-9DC2-00AA006C2B84}\\InProcServer32");
static const  CHAR szSetDefaultMailHandler[] = "SetDefaultMailHandler";
static const  CHAR szSetDefaultNewsHandler[] = "SetDefaultNewsHandler";

// ICW settings
static const TCHAR szICWShellNextFlag[] = TEXT("/shellnext ");
// reg keys under HKCR
static const TCHAR cszRegPathXInternetSignup[] = TEXT("x-internet-signup\\Shell\\Open\\command");
// reg keys under HKCU
static const TCHAR szRegPathICWSettings[] = TEXT("Software\\Microsoft\\Internet Connection Wizard");
static const TCHAR szRegValICWCompleted[] = TEXT("Completed");
static const TCHAR szRegValShellNext[] = TEXT("ShellNext");
// reg keys under HKLM
static const TCHAR cszRegPathAppPaths[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths");
static const TCHAR cszPath[] = TEXT("Path");
static const TCHAR cszInstallationDirectory[] = TEXT("InstallationDirectory");

// IEAK values
static const TCHAR szRegIEAKSettings[] = TEXT("Software\\Microsoft\\IEAK");
static const TCHAR szREgIEAKNeededKey[] = TEXT("ISP Signup Required");
static const TCHAR szIEAKSignupFilename[] = TEXT("Signup\\Signup.htm");

//
// Smart start flag
//
static const TCHAR szICWSmartStartFlag[]    = TEXT("/smartstart ");

static const TCHAR szFullICWFileName[] = TEXT("ICWCONN1.EXE");
static const TCHAR szManualICWFileName[] = TEXT("INETWIZ.EXE");
static const TCHAR szISignupICWFileName[] = TEXT("ISIGNUP.EXE");


//////////////////////////////////////////////////////
// MAPI api function names
//////////////////////////////////////////////////////
static const CHAR szMAPIInitialize[] =       "MAPIInitialize";
static const CHAR szMAPIUninitialize[] =     "MAPIUninitialize";
static const CHAR szMAPIAdminProfiles[] =    "MAPIAdminProfiles";
static const CHAR szMAPIAllocateBuffer[] =   "MAPIAllocateBuffer";
static const CHAR szMAPIFreeBuffer[] =       "MAPIFreeBuffer";
static const CHAR szHrQueryAllRows[] =       "HrQueryAllRows@24";
                                               

//////////////////////////////////////////////////////
// RNA api function names
//////////////////////////////////////////////////////
static const CHAR szRasValidateEntryNamePlain[] =  "RasValidateEntryNameA";

#ifdef UNICODE
static const CHAR szRasGetCountryInfo[] =     "RasGetCountryInfoW";
static const CHAR szRasEnumDevices[] =        "RasEnumDevicesW";
static const CHAR szRasValidateEntryName[] = "RasValidateEntryNameW";
static const CHAR szRasGetErrorString[] =     "RasGetErrorStringW";
static const CHAR szRasGetEntryDialParams[] = "RasGetEntryDialParamsW";
static const CHAR szRasSetEntryDialParams[] = "RasSetEntryDialParamsW";
static const CHAR szRasSetEntryProperties[] = "RasSetEntryPropertiesW";
static const CHAR szRasGetEntryProperties[] = "RasGetEntryPropertiesW";
static const CHAR szRasEnumEntries[] =        "RasEnumEntriesW";
static const CHAR szRasSetCredentials[] =     "RasSetCredentialsW";
#else  // !UNICODE
static const CHAR szRasGetCountryInfo[] =     "RasGetCountryInfoA";
static const CHAR szRasEnumDevices[] =        "RasEnumDevicesA";
static const CHAR szRasValidateEntryName[] =  "RasValidateEntryNameA";
static const CHAR szRasGetErrorString[] =     "RasGetErrorStringA";
static const CHAR szRasGetEntryDialParams[] = "RasGetEntryDialParamsA";
static const CHAR szRasSetEntryDialParams[] = "RasSetEntryDialParamsA";
static const CHAR szRasSetEntryProperties[] = "RasSetEntryPropertiesA";
static const CHAR szRasGetEntryProperties[] = "RasGetEntryPropertiesA";
static const CHAR szRasEnumEntries[] =        "RasEnumEntriesA";
static const CHAR szRasSetCredentials[] =     "RasSetCredentialsA";
#endif // !UNICODE


//////////////////////////////////////////////////////
// Config api function names
//////////////////////////////////////////////////////
static const CHAR szDoGenInstall[] =                "DoGenInstall";
static const CHAR szGetSETUPXErrorText[] =          "GetSETUPXErrorText";
static const CHAR szIcfgSetInstallSourcePath[] =    "IcfgSetInstallSourcePath";
static const CHAR szIcfgInstallInetComponents[] =   "IcfgInstallInetComponents";
static const CHAR szIcfgNeedInetComponents[] =      "IcfgNeedInetComponents";
static const CHAR szIcfgIsGlobalDNS[] =             "IcfgIsGlobalDNS";
static const CHAR szIcfgRemoveGlobalDNS[] =         "IcfgRemoveGlobalDNS";
static const CHAR szIcfgTurnOffFileSharing[] =      "IcfgTurnOffFileSharing";
static const CHAR szIcfgIsFileSharingTurnedOn[] =   "IcfgIsFileSharingTurnedOn";
static const CHAR szIcfgGetLastInstallErrorText[] = "IcfgGetLastInstallErrorText";
static const CHAR szIcfgStartServices[] =           "IcfgStartServices";
//
// Available only on NT icfg32.dll
//
static const CHAR szIcfgNeedModem[] =               "IcfgNeedModem";
static const CHAR szIcfgInstallModem[] =            "IcfgInstallModem";



//////////////////////////////////////////////////////
// misc strings
//////////////////////////////////////////////////////
static const TCHAR sz0[]  =       TEXT("0");
static const TCHAR sz1[]  =        TEXT("1");
static const TCHAR szNull[] =       TEXT("");
static const TCHAR szSlash[] =       TEXT("\\");
static const TCHAR szNOREBOOT[] =    TEXT("/NOREBOOT");
static const TCHAR szUNINSTALL[] =     TEXT("/UNINSTALL");
static const TCHAR szNOMSN[] =    TEXT("/NOMSN");
static const TCHAR szFmtAppendIntToString[] =  TEXT("%s %d");
static const TCHAR szDefaultAreaCode[] = TEXT("555");
static const TCHAR szNOIMN[] =    TEXT("/NOIMN");

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\tcpui.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  TCPUI.C - Functions for Wizard TCP/IP pages
//      
//

//  HISTORY:
//  
//  1/9/95    jeremys    Created.
//  96/03/10  markdu    Made all TCP/IP stuff be per-connectoid.
//  96/03/11  markdu    Set RASEO_ flags for ip and dns addresses.
//  96/03/22  markdu  Remove IP setup from LAN path.
//  96/03/23  markdu  Remove all LAN path leftovers.
//  96/03/23  markdu  Removed ReadTCPIPSettings.
//  96/03/25  markdu  If a fatal error occurs, set gfQuitWizard.
//  96/03/26  markdu  Store values from UI even when back is pressed.
//  96/04/04  markdu  Added pfNeedsRestart to WarnIfServerBound
//  96/04/06  markdu  Moved CommitConfigurationChanges call to last page.
//  96/05/06  markdu  NASH BUG 15637 Removed unused code.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//  96/05/16  markdu  NASH BUG 21810 Perform same IP address validation as RNA.
//

#include "wizard.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"

VOID EnableDNSAddressControls(HWND hDlg);
VOID EnableIPControls(HWND hDlg);
VOID DisplayInvalidIPAddrMsg(HWND hDlg,UINT uCtrl,TCHAR * pszAddr);

/*******************************************************************

  NAME:    EnableIPControls

  SYNOPSIS:  If "Use DHCP" is checked, disables controls for
        specific IP selection; if not, enables them.

********************************************************************/
VOID EnableIPControls(HWND hDlg)
{
  BOOL fDHCP = IsDlgButtonChecked(hDlg,IDC_USE_DHCP);
  
  EnableDlgItem(hDlg,IDC_IP_ADDR_LABEL,!fDHCP);
  EnableDlgItem(hDlg,IDC_IPADDR,!fDHCP);
  EnableDlgItem(hDlg,IDC_TX_IPADDR,!fDHCP);
}


/*******************************************************************

  NAME:    IPAddressInitProc

  SYNOPSIS:  Called when IP address page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK IPAddressInitProc(HWND hDlg,BOOL fFirstInit)
{
  TCHAR szAddr[IP_ADDRESS_LEN+1];

  if (fFirstInit)
  {
    // limit IP address control text lengths
    SendDlgItemMessage(hDlg,IDC_IPADDR,EM_LIMITTEXT,IP_ADDRESS_LEN,0L);
  }

  // check either the "use DHCP" or "use specific IP" buttons.
  // if IP address is set to 0.0.0.0, that means use DHCP.
  // (The "0.0.0.0 == DHCP" convention is used by the TCP/IP
  // VxDs, we might as well play along.)
  BOOL fDHCP = (gpRasEntry->dwfOptions & RASEO_SpecificIpAddr) ? FALSE : TRUE;
  CheckDlgButton(hDlg,(IDC_USE_DHCP),fDHCP);
  CheckDlgButton(hDlg,(IDC_USE_IP),!fDHCP);

  // set the IP address in dialog control

  // 11/25/96	jmazner	Normandy #10222
  // don't use return value of DwFromIa as basis of deciding whether or
  // not to fill in IP address field; rely only on the SpecificIPAddr flag.
  //if ((gpRasEntry->dwfOptions & RASEO_SpecificIpAddr) &&
  //  DwFromIa(&gpRasEntry->ipaddr))

  if (gpRasEntry->dwfOptions & RASEO_SpecificIpAddr)
  {
    IPLongToStr(DwFromIa(&gpRasEntry->ipaddr),
      szAddr,sizeof(szAddr));
    SetDlgItemText(hDlg,IDC_IPADDR,szAddr);
  }
  else
  {
    SetDlgItemText(hDlg,IDC_IPADDR,szNull);
  }

  // enable IP address controls appropriately
  EnableIPControls(hDlg);

  return TRUE;
}

/*******************************************************************

  NAME:    IPAddressOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from IP address page

  ENTRY:    hDlg - dialog window

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK IPAddressOKProc(HWND hDlg)
{
  ASSERT(puNextPage);

  // check the radio buttons to determine if DHCP or not
  BOOL fDHCP = IsDlgButtonChecked(hDlg,IDC_USE_DHCP);

  if (fDHCP)
  {
    // for DHCP, set IP address to 0.0.0.0
    CopyDw2Ia(0, &gpRasEntry->ipaddr);

    // Turn off Specific IP address flag
    gpRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;    
  }
  else
  {
    TCHAR  szAddr[IP_ADDRESS_LEN+1];
    DWORD dwAddr;

    // get IP address
    GetDlgItemText(hDlg,IDC_IPADDR,szAddr,ARRAYSIZE(szAddr));
    if (!lstrlen(szAddr))
    {
      // IP address field is blank, warn user and stay on this page
      DisplayFieldErrorMsg(hDlg,IDC_IPADDR,IDS_NEED_IPADDR);
       return FALSE;
    }

	//
	// 5/17/97	jmazner Olympus #137
	// check for DBCS chars.
	//

#if !defined(WIN16)
	if (!IsSBCSString(szAddr))
	{
		DisplayFieldErrorMsg(hDlg,IDC_IPADDR,IDS_SBCSONLY);
		return FALSE;
	}
#endif


    // convert text to numeric address
    if (IPStrToLong(szAddr,&dwAddr))
    {
      CopyDw2Ia(dwAddr, &gpRasEntry->ipaddr);
      //  96/05/16  markdu  NASH BUG 21810 Perform same IP address validation as RNA.
/*    if (!FValidIa(&gpRasEntry->ipaddr))
      {
        // IP address field is invalid, warn user and stay on this page
        DisplayInvalidIPAddrMsg(hDlg,IDC_IPADDR,szAddr);
         return FALSE;
      }
*/
    }
    else
    {
       // conversion failed, the string is not valid
       DisplayInvalidIPAddrMsg(hDlg,IDC_IPADDR,szAddr);
       return FALSE;
    }
    
    // Turn on Specific IP address flag
    gpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;    
  }

  return TRUE;
}

/*******************************************************************

  NAME:    IPAddressCmdProc

  SYNOPSIS:  Called when dlg control pressed on IP address page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK IPAddressCmdProc(HWND hDlg,UINT uCtrlID)
{
  switch (uCtrlID) {

    case IDC_USE_DHCP:
    case IDC_USE_IP:
      // if radio buttons pushed, enable IP controls appropriately
      EnableIPControls(hDlg);
      break;
  }

  return TRUE;
}


/*******************************************************************

  NAME:    EnableDNSAddressControls

  SYNOPSIS:  If static DNS address is checked, enable controls to
            enter DNS addresses.  If not, disable them.

********************************************************************/
VOID EnableDNSAddressControls(HWND hDlg)
{
  BOOL fEnable = IsDlgButtonChecked(hDlg,IDC_STATIC_DNS);
  
  EnableDlgItem(hDlg,IDC_DNSADDR1,fEnable);
  EnableDlgItem(hDlg,IDC_DNSADDR2,fEnable);
  EnableDlgItem(hDlg,IDC_TX_DNSADDR1,fEnable);
  EnableDlgItem(hDlg,IDC_TX_DNSADDR2,fEnable);
  EnableDlgItem(hDlg,IDC_PRIM_LABEL,fEnable);
  EnableDlgItem(hDlg,IDC_SEC_LABEL,fEnable);
}


/*******************************************************************

  NAME:    DNSAddressInitProc

  SYNOPSIS:  Called when DNS page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK DNSAddressInitProc(HWND hDlg,BOOL fFirstInit)
{
  if (fFirstInit)
  {
    // if file server is bound to instance of TCP/IP that will be
    // used to access the internet, warn user and remove
    BOOL  fTemp;
    WarnIfServerBound(hDlg, INSTANCE_PPPDRIVER, &fTemp);
    if (TRUE == fTemp)
    {
      gpWizardState->fNeedReboot = TRUE;
    }

    // limit DNS address control text lengths
    SendDlgItemMessage(hDlg,IDC_DNSADDR1,EM_LIMITTEXT,IP_ADDRESS_LEN,0L);
    SendDlgItemMessage(hDlg,IDC_DNSADDR2,EM_LIMITTEXT,IP_ADDRESS_LEN,0L);

	// set radio buttons
	CheckDlgButton(hDlg,IDC_AUTO_DNS,gpUserInfo->fAutoDNS);
	CheckDlgButton(hDlg,IDC_STATIC_DNS,!gpUserInfo->fAutoDNS);
  }

  TCHAR szAddr[IP_ADDRESS_LEN+1];

  // set primary DNS server

  // 11/25/96	jmazner	Normandy #10222
  // don't use return value of DwFromIa as basis of deciding whether or
  // not to fill in IP address field; rely only on the SpecificNameServers flag.
  //if ((gpRasEntry->dwfOptions & RASEO_SpecificNameServers) &&
  //  DwFromIa(&gpRasEntry->ipaddrDns))

  if (gpRasEntry->dwfOptions & RASEO_SpecificNameServers)
  {
	  IPLongToStr(DwFromIa(&gpRasEntry->ipaddrDns),
       szAddr,sizeof(szAddr));
	  SetDlgItemText(hDlg,IDC_DNSADDR1,szAddr);
  }
  else
  {
    SetDlgItemText(hDlg,IDC_DNSADDR1,szNull);
  }

  // set backup DNS server
  // 11/25/96	jmazner	Normandy #10222
  //if ((gpRasEntry->dwfOptions & RASEO_SpecificNameServers) &&
  //  DwFromIa(&gpRasEntry->ipaddrDnsAlt))

  if (gpRasEntry->dwfOptions & RASEO_SpecificNameServers)
  {
     IPLongToStr(DwFromIa(&gpRasEntry->ipaddrDnsAlt),
       szAddr,sizeof(szAddr));
    SetDlgItemText(hDlg,IDC_DNSADDR2,szAddr);
  }
  else
  {
    SetDlgItemText(hDlg,IDC_DNSADDR2,szNull);
  }

  EnableDNSAddressControls(hDlg);

  return TRUE;
}

/*******************************************************************

  NAME:    DNSAddressOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from DNS address page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK DNSAddressOKProc(HWND hDlg)
{
  ASSERT(puNextPage);

  UINT uServers = 0;
  TCHAR szAddr[IP_ADDRESS_LEN+1];
  DWORD dwAddr;

  gpUserInfo->fAutoDNS = IsDlgButtonChecked(hDlg, IDC_AUTO_DNS);
  if (gpUserInfo->fAutoDNS)
  {
	  // Turn off Specific Name servers address flag
	  gpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
  }
  else
  {
	  // get primary DNS server address
	  GetDlgItemText(hDlg,IDC_DNSADDR1,szAddr,ARRAYSIZE(szAddr));
	  if (lstrlen(szAddr))
	  {
		//
		// 5/17/97	jmazner Olympus #137
		// check for DBCS chars.
		//

#if !defined(WIN16)
		if (!IsSBCSString(szAddr))
		{
			DisplayFieldErrorMsg(hDlg,IDC_DNSADDR1,IDS_SBCSONLY);
			return FALSE;
		}
#endif

		// convert text to numeric address
		if (IPStrToLong(szAddr,&dwAddr))
		{
		  CopyDw2Ia(dwAddr, &gpRasEntry->ipaddrDns);
		  //  96/05/16  markdu  NASH BUG 21810 Perform same IP address validation as RNA.
/*		  if (!FValidIaOrZero(&gpRasEntry->ipaddrDns))
		  {
			// DNS address field is invalid, warn user and stay on this page
			DisplayInvalidIPAddrMsg(hDlg,IDC_DNSADDR1,szAddr);
			 return FALSE;
		  }
*/
		}
		else
		{
			// conversion failed, the string is not valid
			DisplayInvalidIPAddrMsg(hDlg,IDC_DNSADDR1,szAddr);
			return FALSE;
		}
		uServers++;
	  }
	  else
	  {
		  CopyDw2Ia(0, &gpRasEntry->ipaddrDns);
	  }

	  // get alternate DNS server address
	  GetDlgItemText(hDlg,IDC_DNSADDR2,szAddr,ARRAYSIZE(szAddr));
	  if (lstrlen(szAddr))
	  {
		//
		// 5/17/97	jmazner Olympus #137
		// check for DBCS chars.
		//

#if !defined(WIN16)
		if (!IsSBCSString(szAddr))
		{
			DisplayFieldErrorMsg(hDlg,IDC_DNSADDR2,IDS_SBCSONLY);
			return FALSE;
		}
#endif

		// convert text to numeric address
		if (IPStrToLong(szAddr,&dwAddr))
		{
		  CopyDw2Ia(dwAddr, &gpRasEntry->ipaddrDnsAlt);
		  //  96/05/16  markdu  NASH BUG 21810 Perform same IP address validation as RNA.
/*		  if (!FValidIaOrZero(&gpRasEntry->ipaddrDnsAlt))
		  {
			// DNS address field is invalid, warn user and stay on this page
			DisplayInvalidIPAddrMsg(hDlg,IDC_DNSADDR2,szAddr);
			 return FALSE;
		  }
*/
		}
		else
		{
			// conversion failed, the string is not valid
			DisplayInvalidIPAddrMsg(hDlg,IDC_DNSADDR2,szAddr);
			return FALSE;
		}
		uServers++;
	  }
	  else
	  {
		  CopyDw2Ia(0, &gpRasEntry->ipaddrDnsAlt);
	  }
  
	  if (uServers)
	  {
		// Turn on Specific name servers
		gpRasEntry->dwfOptions |= RASEO_SpecificNameServers;    
	  }
	  else
	  {
		  // no DNS servers entered, warn user (but let her proceed if
		  // she really wants to)
		  if (!WarnFieldIsEmpty(hDlg,IDC_DNSADDR1,IDS_WARN_EMPTY_DNS))
			return FALSE;  // user heeded warning, stay on this page

		// Turn off Specific Name servers address flag
		gpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
	  }
  }

  return TRUE;
}

/*******************************************************************

  NAME:    DNSAddressCmdProc

  SYNOPSIS:  Called when dlg control pressed on DNS address page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK DNSAddressCmdProc(HWND hDlg,UINT uCtrlID)
{
  switch (uCtrlID) {

    case IDC_AUTO_DNS:
    case IDC_STATIC_DNS:
      // if radio buttons pushed, enable IP controls appropriately
      EnableDNSAddressControls(hDlg);
      break;
  }

  return TRUE;
}


/*******************************************************************

  NAME:    DisplayInvalidIPAddrMsg

  SYNOPSIS:  Displays a message that the address the user typed
        is invalid and adds a tip on who to contact if they
        don't know what address to type

********************************************************************/
VOID DisplayInvalidIPAddrMsg(HWND hDlg,UINT uCtrl,TCHAR * pszAddr)
{
  MsgBoxParam(hDlg,IDS_INVALID_IPADDR,MB_ICONINFORMATION,MB_OK,
    pszAddr);
  SetFocus(GetDlgItem(hDlg,uCtrl));
  SendDlgItemMessage(hDlg,uCtrl,EM_SETSEL,0,-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\tcpcfg.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  TCPCFG.C - Functions to read and set TCP/IP configuration
//

//  HISTORY:
//  
//  11/27/94  jeremys  Created.
//  96/02/29  markdu  Replaced call to RNAGetIPInfo with call to 
//            GetIPInfo in rnacall.c
//  96/03/23  markdu  Removed Get/ApplyInstanceTcpInfo functions.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/03/25  markdu  Removed connectoid name parameter from 
//            Get/ApplyGlobalTcpInfo functions since they should not
//            be setting per-connectoid stuff anymore.
//            Renamed ApplyGlobalTcpInfo to ClearGlobalTcpInfo, and 
//            changed function to just clear the settings.
//            Renamed GetGlobalTcpInfo to IsThereGlobalTcpInfo, and
//            changed function to just get the settings.
//  96/04/04  markdu  Added pfNeedsRestart to WarnIfServerBound, and
//            added function RemoveIfServerBound.
//  96/04/23  markdu  NASH BUG 18748 Initialize reboot variable before
//            returning.
//  96/05/26  markdu  Use lpTurnOffFileSharing and lpIsFileSharingTurnedOn.
//

#include "wizard.h"

extern ICFGTURNOFFFILESHARING     lpIcfgTurnOffFileSharing;
extern ICFGISFILESHARINGTURNEDON  lpIcfgIsFileSharingTurnedOn;

/*******************************************************************

  NAME:    WarnIfServerBound

  SYNOPSIS:  Checks to see if file server (VSERVER) is bound
        to TCP/IP instance used for Internet.  If so,
        warns the user and recommends that she let us
        remove the binding.  Removes the binding if user
        gives go-ahead.

  ENTRY:    hDlg - parent window
        dwCardFlags - an INSTANCE_xxx flag to specify what
          card type to check server-TCP/IP bindings for
          pfNeedsRestart - set to TRUE if we need a restart

  NOTES:    This is important because if we don't unbind server
        from instances of TCP/IP we install, user could be
        inadvertently sharing files over the Internet.

        Calls worker function DetectModifyTCPIPBindings to
        do work.

********************************************************************/
HRESULT WarnIfServerBound(HWND hDlg,DWORD dwCardFlags,BOOL* pfNeedsRestart)
{
  HRESULT err = ERROR_SUCCESS;

  //  96/04/23  markdu  NASH BUG 18748 Initialize reboot variable before
  //            returning.
  // Default to no restart.
  ASSERT(pfNeedsRestart);
  *pfNeedsRestart = FALSE;

  // this function may get called more than once (to guarantee we
  // call it regardless of how pages are navigated), set a flag
  // so we don't warn user more than once
  static BOOL fWarned = FALSE;
  if (fWarned)
  {
    return ERROR_SUCCESS;
  }
  
  // check to see if file server is bound to TCP/IP instance used
  // to connect to the internet
  BOOL  fSharingOn;
  HRESULT hr = lpIcfgIsFileSharingTurnedOn(INSTANCE_PPPDRIVER, &fSharingOn);

  //
  // 5/12/97 jmazner Olympus #3442  IE #30886
  // TEMP TODO at the moment, icfgnt doesn't implement FileSharingTurnedOn
  // Until it does, assume that on NT file sharing is always off.
  //
  if( IsNT() )
  {
	  DEBUGMSG("Ignoring return code from IcfgIsFileSharingTurnedOn");
	  fSharingOn = FALSE;
  }


  if ((ERROR_SUCCESS == hr) && (TRUE == fSharingOn))
  {
    // if so, warn the user and ask if we should remove it
    BUFFER Msg(MAX_RES_LEN+1);  // allocate buffer for part of message
    ASSERT(Msg);
    if (!Msg)
    {
      return ERROR_NOT_ENOUGH_MEMORY;  // out of memory
    }

    // message is long and takes 2 strings, so load the 2nd resource and
    // use it as an insertable parameter into the first string
    LoadSz(IDS_WARN_SERVER_BOUND1,Msg.QueryPtr(),Msg.QuerySize());
    if (MsgBoxParam(hDlg,IDS_WARN_SERVER_BOUND,MB_ICONEXCLAMATION,MB_YESNO,
      Msg.QueryPtr()) == IDYES)
    {
      // remove the binding
      err = lpIcfgTurnOffFileSharing(dwCardFlags, hDlg);
      ASSERT(err == ERROR_SUCCESS);
      if (ERROR_SUCCESS == err)
      {
        // We need to restart.
        *pfNeedsRestart = TRUE;
      }
    }
  }

  fWarned = TRUE;
  return err;
}

/*******************************************************************

  NAME:    RemoveIfServerBound

  SYNOPSIS:  Checks to see if file server (VSERVER) is bound
        to TCP/IP instance used for Internet.  If so,
        informs the user that we cannot continue unless we
        remove the binding.  Removes the binding if user
        gives go-ahead.

  ENTRY:    hDlg - parent window
        dwCardFlags - an INSTANCE_xxx flag to specify what
          card type to check server-TCP/IP bindings for
          pfNeedsRestart - set to TRUE if we need a restart

  NOTES:    This is important because if we don't unbind server
        from instances of TCP/IP we install, user could be
        inadvertently sharing files over the Internet.

        Calls worker function DetectModifyTCPIPBindings to
        do work.

********************************************************************/
HRESULT RemoveIfServerBound(HWND hDlg,DWORD dwCardFlags,BOOL* pfNeedsRestart)
{
  HRESULT err = ERROR_SUCCESS;

  // Default to no restart.
  ASSERT(pfNeedsRestart);
  *pfNeedsRestart = FALSE;

  // check to see if file server is bound to TCP/IP instance used
  // to connect to the internet
  BOOL  fSharingOn;
  HRESULT hr = lpIcfgIsFileSharingTurnedOn(INSTANCE_PPPDRIVER, &fSharingOn);

  if ((ERROR_SUCCESS == hr) && (TRUE == fSharingOn))
  {
    // if so, warn the user and ask if we should remove it
    BUFFER Msg(MAX_RES_LEN+1);  // allocate buffer for part of message
    ASSERT(Msg);
    if (!Msg)
    {
      return ERROR_NOT_ENOUGH_MEMORY;  // out of memory
    }

    // message is long and takes 2 strings, so load the 2nd resource and
    // use it as an insertable parameter into the first string
    LoadSz(IDS_REMOVE_SERVER_BOUND1,Msg.QueryPtr(),Msg.QuerySize());
    if (MsgBoxParam(hDlg,IDS_REMOVE_SERVER_BOUND,MB_ICONEXCLAMATION,MB_OKCANCEL,
      Msg.QueryPtr()) == IDOK)
    {
      // remove the binding
      err = lpIcfgTurnOffFileSharing(dwCardFlags, hDlg);
      ASSERT(err == ERROR_SUCCESS);
      if (ERROR_SUCCESS == err)
      {
        // We need to restart.
        *pfNeedsRestart = TRUE;
      }
    }
    else
    {
      // user cancelled.
      err = ERROR_CANCELLED;
    }
  }

  return err;
}


#define FIELD_LEN 3
#define NUM_FIELDS 4
/*******************************************************************

  NAME:    IPStrToLong

  SYNOPSIS:  Translates a text string to a numeric IPADDRESS

  ENTRY:    pszAddress - text string with ip address
        pipAddress - IPADDRESS to translate into

  EXIT:    TRUE if successful, FALSE if the string is invalid

  NOTES:    borrowed from net setup TCP/IP UI

********************************************************************/
BOOL IPStrToLong(LPCTSTR pszAddress,IPADDRESS * pipAddress)
{
    LPTSTR pch = (LPTSTR) pszAddress;
    TCHAR szField[FIELD_LEN+1];
    int nFields = 0;
    int nFieldLen = 0;
    BYTE nFieldVal[NUM_FIELDS];
    BOOL fContinue = TRUE;

  ASSERT(pszAddress);
  ASSERT(pipAddress);

    *pipAddress = (IPADDRESS) 0;

  // retrieve the numeric value for each of the four fields
    while (fContinue) {

        if (!(*pch)) fContinue = FALSE;

        if (*pch == '.' || !*pch) {
            if (nFields >= NUM_FIELDS) return FALSE;  // invalid pszAddress
            *(szField+nFieldLen) = '\0';    // null-terminate
      UINT uFieldVal = (UINT) myatoi(szField);  // convert string to int
      if (uFieldVal > 255)
        return FALSE;  // field is > 255, invalid
            nFieldVal[nFields] = (BYTE) uFieldVal;
            nFields++;
            nFieldLen = 0;
            pch++;
        } else {
      if (! ((*pch >= '0') && (*pch <= '9')) )
        return FALSE;  // non-numeric character, invalid pszAddress
            *(szField + nFieldLen) = *pch;
            nFieldLen++;
            pch++;
            if (nFieldLen > FIELD_LEN) return FALSE;    // invalid pszAddress
        }
    }

    if (nFields < NUM_FIELDS) return FALSE; // invalid szAddress

  // build an address from the fields
  *pipAddress = (IPADDRESS)MAKEIPADDRESS(nFieldVal[0],nFieldVal[1],nFieldVal[2],
        nFieldVal[3]);

    return TRUE;
}


/*******************************************************************

  NAME:    IPLongToStr

  SYNOPSIS:  Translates a single numeric IP address to a text string

  ENTRY:    ipAddress - numeric IP address to translate from
        pszAddress - buffer for translated string
        cbAddress - size of pszAddress buffer

  EXIT:    TRUE if successful, FALSE if the buffer is too short

  NOTES:    borrowed from net setup TCP/IP UI

********************************************************************/
BOOL IPLongToStr(IPADDRESS ipAddress,LPTSTR pszAddress,UINT cbAddress)
{
  ASSERT(pszAddress);

  if (cbAddress < IP_ADDRESS_LEN + 1)
    return FALSE;

    wsprintf(pszAddress,TEXT("%u.%u.%u.%u"),
        (BYTE) (ipAddress>>24),(BYTE) (ipAddress>>16),
        (BYTE) (ipAddress>>8), (BYTE) ipAddress);

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\wizthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  12/21/94  jeremys  Created.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//            Need to keep a modified SetInternetConnectoid to set the
//            MSN backup connectoid.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//

#include "wizard.h"
#if 0
#include "string.h"
#endif

#define MAX_MSG_PARAM     8


#include "winver.h"
BOOL GetIEVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS);
// IE 4 has major.minor version 4.71
// IE 3 golden has major.minor.release.build version # > 4.70.0.1155
// IE 2 has major.minor of 4.40
#define IE4_MAJOR_VERSION (UINT) 4
#define IE4_MINOR_VERSION (UINT) 71
#define IE4_VERSIONMS (DWORD) ((IE4_MAJOR_VERSION << 16) | IE4_MINOR_VERSION)


// function prototypes
VOID _cdecl FormatErrorMessage(TCHAR * pszMsg,DWORD cbMsg,TCHAR * pszFmt,LPTSTR szArg);
extern VOID GetRNAErrorText(UINT uErr,TCHAR * pszErrText,DWORD cbErrText);
extern VOID GetMAPIErrorText(UINT uErr,TCHAR * pszErrText,DWORD cbErrText);
extern GETSETUPXERRORTEXT lpGetSETUPXErrorText;
#ifdef WIN32
VOID Win95JMoveDlgItem( HWND hwndParent, HWND hwndItem, int iUp );
#endif

void GetCmdLineToken(LPTSTR *ppszCmd,LPTSTR pszOut);

#define NUMICWFILENAMES	4
TCHAR  *g_ppszICWFileNames[NUMICWFILENAMES] = { TEXT("ICWCONN1.EXE\0"),
						TEXT("ISIGNUP.EXE\0"),
						TEXT("INETWIZ.EXE\0"),
						TEXT("ICWCONN2.EXE\0") };



/*******************************************************************

  NAME:    MsgBox

  SYNOPSIS:  Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    TCHAR szMsgBuf[MAX_RES_LEN+1];
    TCHAR szSmallBuf[SMALL_BUF_LEN+1];

    LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));
    LoadSz(nMsgID,szMsgBuf,sizeof(szMsgBuf));

    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

/*******************************************************************

  NAME:    MsgBoxSz

  SYNOPSIS:  Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons)
{
    TCHAR szSmallBuf[SMALL_BUF_LEN+1];
  LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));

    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

/*******************************************************************

  NAME:    MsgBoxParam

  SYNOPSIS:  Displays a message box with the specified string ID

  NOTES:    //extra parameters are string pointers inserted into nMsgID.
			jmazner 11/6/96 For RISC compatability, we don't want
			to use va_list; since current source code never uses more than
			one string parameter anyways, just change function signature
			to explicitly include that one parameter.

********************************************************************/
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,LPTSTR szParam)
{
  BUFFER Msg(3*MAX_RES_LEN+1);  // nice n' big for room for inserts
  BUFFER MsgFmt(MAX_RES_LEN+1);
  //va_list args;

  if (!Msg || !MsgFmt) {
    return MsgBox(hWnd,IDS_ERROutOfMemory,MB_ICONSTOP,MB_OK);
  }

    LoadSz(nMsgID,MsgFmt.QueryPtr(),MsgFmt.QuerySize());

  //va_start(args,uButtons);
  //FormatErrorMessage(Msg.QueryPtr(),Msg.QuerySize(),
  //  MsgFmt.QueryPtr(),args);
	FormatErrorMessage(Msg.QueryPtr(),Msg.QuerySize(),
		MsgFmt.QueryPtr(),szParam);

  return MsgBoxSz(hWnd,Msg.QueryPtr(),uIcon,uButtons);
}

BOOL EnableDlgItem(HWND hDlg,UINT uID,BOOL fEnable)
{
    return EnableWindow(GetDlgItem(hDlg,uID),fEnable);
}

/*******************************************************************

  NAME:    LoadSz

  SYNOPSIS:  Loads specified string resource into buffer

  EXIT:    returns a pointer to the passed-in buffer

  NOTES:    If this function fails (most likely due to low
        memory), the returned buffer will have a leading NULL
        so it is generally safe to use this without checking for
        failure.

********************************************************************/
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
  ASSERT(lpszBuf);

  // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( ghInstance, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

/*******************************************************************

  NAME:    GetErrorDescription

  SYNOPSIS:  Retrieves the text description for a given error code
        and class of error (standard, setupx)

********************************************************************/
VOID GetErrorDescription(TCHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass)
{
  ASSERT(pszErrorDesc);

  // set a leading null in error description
  *pszErrorDesc = '\0';
  
  switch (uErrorClass) {

    case ERRCLS_STANDARD:

      if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,
        uError,0,pszErrorDesc,cbErrorDesc,NULL)) {
        // if getting system text fails, make a string a la
        // "error <n> occurred"
        TCHAR szFmt[SMALL_BUF_LEN+1];
        LoadSz(IDS_ERRFORMAT,szFmt,sizeof(szFmt));
        wsprintf(pszErrorDesc,szFmt,uError);
      }

      break;

    case ERRCLS_SETUPX:

      lpGetSETUPXErrorText(uError,pszErrorDesc,cbErrorDesc);
      break;

    case ERRCLS_RNA:

      GetRNAErrorText(uError,pszErrorDesc,cbErrorDesc);
      break;

    case ERRCLS_MAPI:

      GetMAPIErrorText(uError,pszErrorDesc,cbErrorDesc);
      break;

    default:

      DEBUGTRAP("Unknown error class %lu in GetErrorDescription",
        uErrorClass);

  }

}
  
/*******************************************************************

  NAME:    FormatErrorMessage

  SYNOPSIS:  Builds an error message by calling FormatMessage

  NOTES:    Worker function for DisplayErrorMessage

********************************************************************/
VOID _cdecl FormatErrorMessage(TCHAR * pszMsg,DWORD cbMsg,TCHAR * pszFmt,LPTSTR szArg)
{
  ASSERT(pszMsg);
  ASSERT(pszFmt);

  // build the message into the pszMsg buffer
  DWORD dwCount = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
    pszFmt,0,0,pszMsg,cbMsg,(va_list*) &szArg);
  ASSERT(dwCount > 0);
}

/*******************************************************************

  NAME:    DisplayErrorMessage

  SYNOPSIS:  Displays an error message for given error 

  ENTRY:    hWnd - parent window
        uStrID - ID of string resource with message format.
          Should contain %1 to be replaced by error text,
          additional parameters can be specified as well.
        uError - error code for error to display
        uErrorClass - ERRCLS_xxx ID of class of error that
          uError belongs to (standard, setupx)
        uIcon - icon to display
        //... - additional parameters to be inserted in string
        //  specified by uStrID
		jmazner 11/6/96 change to just one parameter for
		RISC compatability.

********************************************************************/
VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,LPTSTR szArg)
{
  // dynamically allocate buffers for messages
  BUFFER ErrorDesc(MAX_RES_LEN+1);
  BUFFER ErrorFmt(MAX_RES_LEN+1);
  BUFFER ErrorMsg(2*MAX_RES_LEN+1);  

  if (!ErrorDesc || !ErrorFmt || !ErrorMsg) {
    // if can't allocate buffers, display out of memory error
    MsgBox(hWnd,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
    return;
  }

  // get a text description based on the error code and the class
  // of error it is
  GetErrorDescription(ErrorDesc.QueryPtr(),
    ErrorDesc.QuerySize(),uError,uErrorClass);

  // load the string for the message format
  LoadSz(uStrID,ErrorFmt.QueryPtr(),ErrorFmt.QuerySize());

  //LPSTR args[MAX_MSG_PARAM];
  //args[0] = (LPSTR) ErrorDesc.QueryPtr();
  //memcpy(&args[1],((TCHAR *) &uIcon) + sizeof(uIcon),(MAX_MSG_PARAM - 1) * sizeof(LPSTR));

  //FormatErrorMessage(ErrorMsg.QueryPtr(),ErrorMsg.QuerySize(),
  //  ErrorFmt.QueryPtr(),(va_list) &args[0]);
  FormatErrorMessage(ErrorMsg.QueryPtr(),ErrorMsg.QuerySize(),
    ErrorFmt.QueryPtr(),ErrorDesc.QueryPtr());


  // display the message
  MsgBoxSz(hWnd,ErrorMsg.QueryPtr(),uIcon,MB_OK);

}

/*******************************************************************

  NAME:    WarnFieldIsEmpty

  SYNOPSIS:  Pops up a warning message if the user tries to leave
        a page without filling out a text field and asks if she
        wants to continue.
        
  ENTRY:    hDlg - parent windows
        uCtrlID - ID of control left blank
        uStrID - ID of string resource with warning message

  EXIT:    returns TRUE if user wants to continue anyway, FALSE
        if user wants to stay on same page.

********************************************************************/
BOOL WarnFieldIsEmpty(HWND hDlg,UINT uCtrlID,UINT uStrID)
{
  // warn the user
  if (MsgBox(hDlg,uStrID,MB_ICONEXCLAMATION,
    MB_YESNO | MB_DEFBUTTON2) == IDNO) {
    // user chose no, wants to stay on same page

    // set focus to control in question
    SetFocus(GetDlgItem(hDlg,uCtrlID));
    return FALSE;
  }

  return TRUE;
}

BOOL TweakAutoRun(BOOL bEnable)
{
    HKEY  hKey        = NULL;
    DWORD dwType      = 0;
    DWORD dwSize      = 0;
    DWORD dwVal       = 0;
    BOOL  bWasEnabled = FALSE;

    RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"), 0, KEY_ALL_ACCESS, &hKey);
    if (hKey)
    {
        RegQueryValueEx(hKey, (LPTSTR)TEXT("NoDriveTypeAutoRun"), 0, &dwType, (LPBYTE)&dwVal, &dwSize);
        RegQueryValueEx(hKey, (LPTSTR)TEXT("NoDriveTypeAutoRun"), 0, &dwType, (LPBYTE)&dwVal, &dwSize);

        if (dwVal & DRIVE_CDROM)
            bWasEnabled = TRUE;

        if (bEnable)
            dwVal |= DRIVE_CDROM;
        else
            dwVal &=~DRIVE_CDROM;
        
        RegSetValueEx(hKey, (LPTSTR)TEXT("NoDriveTypeAutoRun"), 0, dwType,  (LPBYTE)&dwVal, dwSize);

        CloseHandle(hKey);
    }
    return bWasEnabled;
}

/*******************************************************************

  NAME:    DisplayFieldErrorMsg

  SYNOPSIS:  Pops up a warning message about a field, sets focus to
        the field and selects any text in it.

  ENTRY:    hDlg - parent windows
        uCtrlID - ID of control left blank
        uStrID - ID of string resource with warning message

********************************************************************/
VOID DisplayFieldErrorMsg(HWND hDlg,UINT uCtrlID,UINT uStrID)
{
  MsgBox(hDlg,uStrID,MB_ICONEXCLAMATION,MB_OK);
  SetFocus(GetDlgItem(hDlg,uCtrlID));
  SendDlgItemMessage(hDlg,uCtrlID,EM_SETSEL,0,-1);
}

/*******************************************************************

  NAME:    SetBackupInternetConnectoid

  SYNOPSIS:  Sets the name of the backup connectoid used to autodial to the
        Internet

  ENTRY:    pszEntryName - name of connectoid to set.  If NULL,
          then the registry entry is removed.

  NOTES:    sets value in registry

********************************************************************/
VOID SetBackupInternetConnectoid(LPCTSTR pszEntryName)
{
  RegEntry re(szRegPathRNAWizard,HKEY_CURRENT_USER);
  if (re.GetError() == ERROR_SUCCESS)
  {
    if (pszEntryName)
    {
      re.SetValue(szRegValBkupInternetProfile,pszEntryName);
    }
    else
    {
       re.DeleteValue(szRegValBkupInternetProfile);
    }
  }
}

/*******************************************************************

  NAME:    myatoi

  SYNOPSIS:  Converts numeric string to numeric value

  NOTES:    implementation of atoi to avoid pulling in C runtime

********************************************************************/
UINT myatoi (TCHAR * szVal)
{
    TCHAR * lpch;
    WORD wDigitVal=1,wTotal=0;

    for (lpch = szVal + lstrlen(szVal)-1; lpch >= szVal ; lpch --,
        wDigitVal *= 10)
  if ( *lpch >= '0' && *lpch <= '9')
            wTotal += (*lpch - '0') * wDigitVal;

    return (UINT) wTotal;
}

/*******************************************************************

  NAME:    MsgWaitForMultipleObjectsLoop

  SYNOPSIS:  Blocks until the specified object is signaled, while
        still dispatching messages to the main thread.

********************************************************************/
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent)
{
    MSG msg;
    DWORD dwObject;
    while (1)
    {
        // NB We need to let the run dialog become active so we have to half handle sent
        // messages but we don't want to handle any input events or we'll swallow the
        // type-ahead.
        dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE,INFINITE, QS_ALLINPUT);
        // Are we done waiting?
        switch (dwObject) {
        case WAIT_OBJECT_0:
        case WAIT_FAILED:
            return dwObject;

        case WAIT_OBJECT_0 + 1:
      // got a message, dispatch it and wait again
      while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE)) {
        DispatchMessage(&msg);
      }
            break;
        }
    }
    // never gets here
}


/*******************************************************************

//	//10/24/96 jmazner Normandy 6968
//	//No longer neccessary thanks to Valdon's hooks for invoking ICW.
// 11/21/96 jmazner Normandy 11812
// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
// ICW 1.1 needs to morph the IE 3 icon.

  NAME:    SetDesktopInternetIconToBrowser

  SYNOPSIS:  "Points" The Internet desktop icon to web browser
        (Internet Explorer)

  NOTES:    For IE 3, the Internet icon may initially "point" at this wizard,
        we need to set it to launch web browser once we complete
        successfully.

********************************************************************/
BOOL SetDesktopInternetIconToBrowser(VOID)
{
  TCHAR szAppPath[MAX_PATH+1]=TEXT("");
  BOOL fRet = FALSE;

  	DWORD dwVerMS, dwVerLS;

	if( !GetIEVersion( &dwVerMS, &dwVerLS ) ) 
	{
		return( FALSE );
	}

	if( (dwVerMS >= IE4_VERSIONMS) )
	{
		// we're dealing with IE 4, don't touch the icon stuff
		return( TRUE );
	}

  // look in the app path section in registry to get path to internet
  // explorer

  RegEntry reAppPath(szRegPathIexploreAppPath,HKEY_LOCAL_MACHINE);
  ASSERT(reAppPath.GetError() == ERROR_SUCCESS);
  if (reAppPath.GetError() == ERROR_SUCCESS) {

    reAppPath.GetString(szNull,szAppPath,sizeof(szAppPath));
    ASSERT(reAppPath.GetError() == ERROR_SUCCESS);

  }

  // set the path to internet explorer as the open command for the 
  // internet desktop icon
  if (lstrlen(szAppPath)) {
    RegEntry reIconOpenCmd(szRegPathInternetIconCommand,HKEY_CLASSES_ROOT);
    ASSERT(reIconOpenCmd.GetError() == ERROR_SUCCESS);
    if (reIconOpenCmd.GetError() == ERROR_SUCCESS) {
      UINT uErr = reIconOpenCmd.SetValue(szNull,szAppPath);
      ASSERT(uErr == ERROR_SUCCESS);
      
      fRet = (uErr == ERROR_SUCCESS);
    }
  }

  return fRet;
}



//+----------------------------------------------------------------------------
//
//	Function	IsDialableString
//
//	Synopsis	Determines whether a string has any non dialable characters.
//
//	Arguments	szBuff - the string to check.
//
//	Returns		TRUE is no chars other than 0123456789ABCDabcdPpTtWw!@$-.()+*#,& and <space>
//				FALSE otherwise.
//
//	History		11/11/96	jmazner	created for Normandy #7623
//
//-----------------------------------------------------------------------------
BOOL IsDialableString(LPTSTR szBuff)
{
	LPTSTR szDialableChars = TEXT("0123456789ABCDabcdPpTtWw!@$-.()+*#,& ");

	int i = 0;

	for( i = 0; szBuff[i]; i++ )
	{
		if( !_tcschr(szDialableChars, szBuff[i]) )
			return FALSE;
	}

	return TRUE;
}


//+----------------------------------------------------------------------------
//
//	Function:	GetIEVersion
//
//	Synopsis:	Gets the major and minor version # of the installed copy of Internet Explorer
//
//	Arguments:	pdwVerNumMS - pointer to a DWORD;
//				  On succesful return, the top 16 bits will contain the major version number,
//				  and the lower 16 bits will contain the minor version number
//				  (this is the data in VS_FIXEDFILEINFO.dwProductVersionMS)
//				pdwVerNumLS - pointer to a DWORD;
//				  On succesful return, the top 16 bits will contain the release number,
//				  and the lower 16 bits will contain the build number
//				  (this is the data in VS_FIXEDFILEINFO.dwProductVersionLS)
//
//	Returns:	TRUE - Success.  *pdwVerNumMS and LS contains installed IE version number
//				FALSE - Failure. *pdVerNumMS == *pdVerNumLS == 0
//
//	History:	jmazner		Created		8/19/96	(as fix for Normandy #4571)
//				jmazner		updated to deal with release.build as well 10/11/96
//				jmazner		stolen from isign32\isignup.cpp 11/21/96
//							(for Normandy #11812)
//
//-----------------------------------------------------------------------------
BOOL GetIEVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS)
{
	HRESULT hr;
	HKEY hKey = 0;
	LPVOID lpVerInfoBlock;
	VS_FIXEDFILEINFO *lpTheVerInfo;
	UINT uTheVerInfoSize;
	DWORD dwVerInfoBlockSize, dwUnused, dwPathSize;
	TCHAR szIELocalPath[MAX_PATH + 1] = TEXT("");


	*pdwVerNumMS = 0;
	*pdwVerNumLS = 0;

	// get path to the IE executable
	hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPathIexploreAppPath,0, KEY_READ, &hKey);
	if (hr != ERROR_SUCCESS) return( FALSE );

	dwPathSize = sizeof (szIELocalPath);
	hr = RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szIELocalPath, &dwPathSize);
	RegCloseKey( hKey );
	if (hr != ERROR_SUCCESS) return( FALSE );

	// now go through the convoluted process of digging up the version info
    dwVerInfoBlockSize = GetFileVersionInfoSize( szIELocalPath, &dwUnused );
	if ( 0 == dwVerInfoBlockSize ) return( FALSE );

	lpVerInfoBlock = GlobalAlloc( GPTR, dwVerInfoBlockSize );
	if( NULL == lpVerInfoBlock ) return( FALSE );

	if( !GetFileVersionInfo( szIELocalPath, NULL, dwVerInfoBlockSize, lpVerInfoBlock ) )
		return( FALSE );

	if( !VerQueryValue(lpVerInfoBlock, TEXT("\\"), (void **)&lpTheVerInfo, &uTheVerInfoSize) )
		return( FALSE );

	*pdwVerNumMS = lpTheVerInfo->dwProductVersionMS;
	*pdwVerNumLS = lpTheVerInfo->dwProductVersionLS;


	GlobalFree( lpVerInfoBlock );

	return( TRUE );
}


//+----------------------------------------------------------------------------
//
//	Function:	Win95JMoveDlgItem
//
//	Synopsis:	Moves a particular dialog item on a non-localized ICW
//				up or down on Win 95 J systems
//				to work around a w95J rendering glitch that mis-sizes our
//				wizard window.
//
//	Arguments:	hwndParent - Handle to parent window which contains the hwndItem
//				hwndItem -- Handle to dlg item to move
//				iUp -- number of units upward the item should be shifted.  A
//						negative value here implies that the item should be shifted
//						downward.
//
//	Returns:	VOID
//
//	History:	6/6/97	jmazner	Created for Olympus #5413
//				6/29/97	jmazner	Updated to only do this on English ICW (Oly #5413)
//				
//
//-----------------------------------------------------------------------------
#ifdef WIN32
DWORD GetBuildLCID();
VOID Win95JMoveDlgItem( HWND hwndParent, HWND hwndItem, int iUp )
{
	LCID LangID = 0x409; // default to English
	// 0x411 is Japanese

	
	LangID = GetUserDefaultLCID();

	//
	// IE v 4.1 bug 37072 ChrisK 8/19/97
	// The fix for 5413 incorrectly compared the primary language ID with the
	// full LCID for the build.  The result was 9 != x409 when it should have
	// been equal.  This fix was to use the primary language id from the build
	// instead of the full LCID
	//
	if( (0x411 == LangID) && 
		!(IsNT()) &&
		(LANG_ENGLISH == PRIMARYLANGID(GetBuildLCID())))
	{
		// assume that if it's Japanese, and it's not NT, it must be win95J!
		RECT itemRect;
		POINT thePoint;

		GetWindowRect(hwndItem, &itemRect);

		// need to convert the coords from global to local client,
		// since MoveWindow below will expext client coords.

		thePoint.x = itemRect.left;
		thePoint.y = itemRect.top;
		ScreenToClient(hwndParent, &thePoint );
		itemRect.left = thePoint.x;
		itemRect.top = thePoint.y;
		
		thePoint.x = itemRect.right;
		thePoint.y = itemRect.bottom;
		ScreenToClient(hwndParent, &thePoint );
		itemRect.right = thePoint.x;
		itemRect.bottom = thePoint.y;

		MoveWindow(hwndItem,
			itemRect.left,
			itemRect.top - iUp,
			(itemRect.right - itemRect.left),
			(itemRect.bottom - itemRect.top), TRUE);
	}
}

//+----------------------------------------------------------------------------
//
//	Function:	GetBuildLCID
//
//	Synopsis:	return the LCID of the file that this function resides in
//
//	Arguments:	none
//
//	Returns:	DWORD - LCID of the file or 0 if it failed
//
//	History:	ChrisK	6/25/97	Created
//				jmazner	6/29/97	Ported from Conn1 for Olympus 5413
//
//-----------------------------------------------------------------------------
DWORD GetBuildLCID()
{
	DWORD dw = 0;
	HMODULE hMod = NULL;
	TCHAR szFileName[MAX_PATH +1] = TEXT("\0uninit");
	DWORD dwSize = 0;
	LPVOID lpv = NULL;
	LPVOID lpvVerValue = NULL;
	UINT uLen = 0;
	DWORD dwRC = 0;

	DEBUGMSG("INETCFG: GetBuildLCID.\n");

	//
	// Get the name of this file
	//

	hMod = GetModuleHandle(NULL);
	if (NULL == hMod)
	{
		goto GetBuildLCIDExit;
	}

	if (0 == GetModuleFileName(hMod, szFileName, MAX_PATH))
	{
		goto GetBuildLCIDExit;
	}

	//
	// Get size and value of version structure
	//
	dwSize = GetFileVersionInfoSize(szFileName,&dw);
	if (0 == dwSize )
	{
		goto GetBuildLCIDExit;
	}

	lpv = (LPVOID)GlobalAlloc(GPTR, dwSize);
	if (NULL == lpv)
	{
		goto GetBuildLCIDExit;
	}

	if ( FALSE == GetFileVersionInfo(szFileName,0,dwSize,lpv))
	{
		goto GetBuildLCIDExit;
	}

	if ( 0 == VerQueryValue(lpv,TEXT("\\VarFileInfo\\Translation"),&lpvVerValue,&uLen))
	{
		goto GetBuildLCIDExit;
	}

	//
	// separate version information from character set
	//
	dwRC = (LOWORD(*(DWORD*)lpvVerValue));

GetBuildLCIDExit:
	if (NULL != lpv)
	{
		GlobalFree(lpv);
		lpv = NULL;
	}

	return dwRC;
}
#endif

//+----------------------------------------------------------------------------
//
//	Function:	GetCmdLineToken
//
//	Synopsis:	Returns the first token in a string
//
//	Arguements:
//		ppszCmd [in] -- pointer to head of string
//		ppszCmd [out] -- pointer to second token in string
//		pszOut [out] -- contains the first token in the passed in string.
//
//	Returns:	None
//
//	Notes:		Considers the space character ' ' to delineate tokens, but
//				treats anything between double quotes as one token.
//				For example, the following consists of five tokens:
//					first second "this is the third token" fourth "fifth"
//
//	History:	7/9/97	jmazner	stolen from icwconn1\connmain.cpp for #9170
//
//-----------------------------------------------------------------------------
void GetCmdLineToken(LPTSTR *ppszCmd,LPTSTR pszOut)
{
	TCHAR *c;
	int i = 0;
	BOOL fInQuote = FALSE;
	
	c = *ppszCmd;

	pszOut[0] = *c;
	if (!*c) return;
	if (*c == ' ') 
	{
		pszOut[1] = '\0';
		*ppszCmd = c+1;
		return;
	}
	else if( '"' == *c )
	{
		fInQuote = TRUE;
	}

NextChar:
	i++;
	c++;
	if( !*c || (!fInQuote && (*c == ' ')) )
	{
		pszOut[i] = '\0';
		*ppszCmd = c;
		return;
	}
	else if( fInQuote && (*c == '"') )
	{
		fInQuote = FALSE;
		pszOut[i] = *c;
		
		i++;
		c++;
		pszOut[i] = '\0';
		*ppszCmd = c;
		return;
	}
	else
	{
		pszOut[i] = *c;
		goto NextChar;
	}


}

//+----------------------------------------------------------------------------
//
//	Function:	ValidateProductSuite
//
//	Synopsis:	Check registry for a particular Product Suite string
//
//	Arguments:	SuiteName - name of product suite to look for
//
//	Returns:	TRUE - the suite exists
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
BOOL 
ValidateProductSuite(LPTSTR SuiteName)
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPTSTR ProductSuite = NULL;
    LPTSTR p;

	DEBUGMSG("INETCFG: ValidateProductSuite\n");
	//
	// Determine the size required to read registry values
	//
    Rslt = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
        &hKey
        );
    if (Rslt != ERROR_SUCCESS)
	{
        goto ValidateProductSuiteExit;
    }

    Rslt = RegQueryValueEx(
        hKey,
        TEXT("ProductSuite"),
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) 
	{
        goto ValidateProductSuiteExit;
    }

    if (!Size) 
	{
        goto ValidateProductSuiteExit;
    }

    ProductSuite = (LPTSTR) GlobalAlloc( GPTR, Size );
    if (!ProductSuite) 
	{
        goto ValidateProductSuiteExit;
    }

	//
	// Read ProductSuite information
	//
    Rslt = RegQueryValueEx(
        hKey,
        TEXT("ProductSuite"),
        NULL,
        &Type,
        (LPBYTE) ProductSuite,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) 
	{
        goto ValidateProductSuiteExit;
    }

    if (Type != REG_MULTI_SZ) 
	{
        goto ValidateProductSuiteExit;
    }

	//
	// Look for a particular string in the data returned
	// Note: data is terminiated with two NULLs
	//
    p = ProductSuite;
    while (*p) {
        if (_tcsstr( p, SuiteName )) 
		{
            rVal = TRUE;
            break;
        }
        p += (lstrlen( p ) + 1);
    }

ValidateProductSuiteExit:
    if (ProductSuite) 
	{
        GlobalFree( ProductSuite );
    }

    if (hKey) 
	{
        RegCloseKey( hKey );
    }

    return rVal;
}


//+----------------------------------------------------------------------------
//
//	Function:	GetFileVersion
//
//	Synopsis:	Gets the major and minor version # of a file
//
//	Arguments:	pdwVerNumMS - pointer to a DWORD;
//				  On succesful return, the top 16 bits will contain the major version number,
//				  and the lower 16 bits will contain the minor version number
//				  (this is the data in VS_FIXEDFILEINFO.dwProductVersionMS)
//				pdwVerNumLS - pointer to a DWORD;
//				  On succesful return, the top 16 bits will contain the release number,
//				  and the lower 16 bits will contain the build number
//				  (this is the data in VS_FIXEDFILEINFO.dwProductVersionLS)
//
//	Returns:	TRUE - Success.  *pdwVerNumMS and LS contains version number
//				FALSE - Failure. *pdVerNumMS == *pdVerNumLS == 0
//
//	History:	jmazner		Created		8/19/96	(as fix for Normandy #4571)
//				jmazner		updated to deal with release.build as well 10/11/96
//				jmazner		7/22/97 ported from isign32 for bug 9903
//
//-----------------------------------------------------------------------------
BOOL GetFileVersion(LPTSTR lpszFilePath, PDWORD pdwVerNumMS, PDWORD pdwVerNumLS)
{
	HRESULT hr;
	HKEY hKey = 0;
	LPVOID lpVerInfoBlock;
	VS_FIXEDFILEINFO *lpTheVerInfo;
	UINT uTheVerInfoSize;
	DWORD dwVerInfoBlockSize, dwUnused, dwPathSize;
	DWORD fRet = TRUE;

	ASSERT( pdwVerNumMS );
	ASSERT( pdwVerNumLS );
	ASSERT( lpszFilePath );

	if( !pdwVerNumMS || !pdwVerNumLS || !lpszFilePath )
	{
		DEBUGMSG("GetFileVersion: invalid parameters!");
		return FALSE;
	}

	*pdwVerNumMS = 0;
	*pdwVerNumLS = 0;

	//
	// go through the convoluted process of digging up the version info
	//
    dwVerInfoBlockSize = GetFileVersionInfoSize( lpszFilePath, &dwUnused );
	if ( 0 == dwVerInfoBlockSize ) return( FALSE );

	lpVerInfoBlock = GlobalAlloc( GPTR, dwVerInfoBlockSize );
	if( NULL == lpVerInfoBlock ) return( FALSE );

	if( !GetFileVersionInfo( lpszFilePath, NULL, dwVerInfoBlockSize, lpVerInfoBlock ) )
	{
		fRet = FALSE;
		goto GetFileVersionExit;
	}

	if( !VerQueryValue(lpVerInfoBlock, TEXT("\\"), (void **)&lpTheVerInfo, &uTheVerInfoSize) )
	{
		fRet = FALSE;
		goto GetFileVersionExit;
	}

	*pdwVerNumMS = lpTheVerInfo->dwProductVersionMS;
	*pdwVerNumLS = lpTheVerInfo->dwProductVersionLS;

GetFileVersionExit:
	if( lpVerInfoBlock )
	{
		GlobalFree( lpVerInfoBlock );
		lpVerInfoBlock = NULL;
	}

	return( fRet );
}

//+----------------------------------------------------------------------------
//
//	Function:	ExtractFilenameFromPath
//
//	Synopsis:	Divides a full path into path and filename parts
//
//	Arguments:
//		szPath [in] -- fully qualified path and filename
//		lplpszFilename [in] -- pointer to a LPSTR.  On entry, the LPSTR
//							   to which it points should be NULL.
//		lplpszFilename [out] -- The LPSTR to which it points is set to the
//								first character of the filename in szPath.
//								
//
//	Returns:	FALSE - Parameters are invalid.
//				TRUE - Success.
//
//	History:	7/22/97	jmazner	Created for Olympus #9903
//
//-----------------------------------------------------------------------------
BOOL ExtractFilenameFromPath( TCHAR szPath[MAX_PATH + 1], LPTSTR *lplpszFilename )
{
	ASSERT( szPath[0] );
	ASSERT( lplpszFilename );
	ASSERT( *lplpszFilename == NULL );
	
	if( !szPath[0] || !lplpszFilename )
	{
		return FALSE;
	}

	//
	// extract the executable name from the full path
	//
	*lplpszFilename = &(szPath[ lstrlen(szPath) ]);
	while( ('\\' != **lplpszFilename) && (*lplpszFilename > szPath) )
	{

		*lplpszFilename = CharPrev( szPath, *lplpszFilename );
		
		ASSERT( *lplpszFilename > szPath );
	}

	
	//
	// now szFilename should point to the \, so do a char next.
	//
	if( '\\' == **lplpszFilename )
	{
		*lplpszFilename = CharNext( *lplpszFilename );
	}
	else
	{
		DEBUGMSG("ExtractFilenameFromPath: bogus path passed in, %s", szPath);
		return FALSE;
	}

	return TRUE;
}

//+----------------------------------------------------------------------------
//
//	Function:	IsParentICW10
//
//	Synopsis:	Determines whether the parent of this module is an ICW 1.0
//				executable (isignup, icwconn1, icwconn2 or inetwiz)
//
//	Arguments:	none
//
//	Returns:	TRUE - Parent module is an ICW 1.0 component
//				FALSE - Parent module is not an ICW 1.0 component, -or-
//						parent module could not be determined
//
//	History:	7/22/97	jmazner	Created for Olympus #9903
//
//-----------------------------------------------------------------------------
BOOL IsParentICW10( )
{
	HMODULE hParentModule = GetModuleHandle( NULL );
	LPTSTR lpszParentFullPath = NULL;
	LPTSTR lpszTemp = NULL;
	int	i = 0;
	BOOL fMatchFound = FALSE;
	BOOL fRet = FALSE;

	lpszParentFullPath = (LPTSTR)GlobalAlloc(GPTR, (MAX_PATH + 1)*sizeof(TCHAR));

	if( NULL == lpszParentFullPath )
	{
		DEBUGMSG("IsParentICW10 Out of memory!");
		goto IsParentICW10Exit;
	}

	GetModuleFileName( hParentModule, lpszParentFullPath, MAX_PATH );
	DEBUGMSG("IsParentICW10 parent module is %s", lpszParentFullPath);

	if( NULL == lpszParentFullPath[0] )
	{
		fRet = FALSE;
		goto IsParentICW10Exit;
	}

	ExtractFilenameFromPath( lpszParentFullPath, &lpszTemp );

	//
	// walk through the array of ICW binary names, see if anything matches
	//
	for( i = 0; i < NUMICWFILENAMES; i++ )
	{
		if ( 0 == lstrcmpi(g_ppszICWFileNames[i], lpszTemp) )
		{
			fMatchFound = TRUE;
			DEBUGMSG("IsParentICW10 Match found for %s", lpszTemp);
			break;
		}
	}

	if( !fMatchFound )
	{
		fRet = FALSE;
		goto IsParentICW10Exit;
	}
	else
	{
		//
		// we have one of the four binaries we're interested in; now check
		// its version number
		//
		DWORD dwMS = 0;
		DWORD dwLS = 0;
		GetFileVersion( lpszParentFullPath, &dwMS, &dwLS );
		DEBUGMSG("IsParentICW10: file version is %d.%d", HIWORD(dwMS), LOWORD(dwMS) );

		if( dwMS < ICW_MINIMUM_VERSIONMS )
		{
			fRet = TRUE;
		}
	}

IsParentICW10Exit:
	if( lpszParentFullPath )
	{
		GlobalFree( lpszParentFullPath );
		lpszParentFullPath = NULL;
	}

	return fRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	SetICWRegKeysToPath
//
//	Synopsis:	Sets all ICW reg keys to point to binaries in the given path
//
//	Arguments:	lpszICWPath -- pointer to a string containing the full path
//								to a directory containing ICW components
//
//	Returns:	void
//
//	Notes:		Sets the following reg keys:
//				HKCR\x-internet-signup\Shell\Open\command, (default)=[path]\isignup.exe %1
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWCONN1.EXE, (default) = [path]\ICWCONN1.EXE
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWCONN1.EXE, Path = [path];
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ISIGNUP.EXE, (default) = [path]\ISIGNUP.EXE
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ISIGNUP.EXE, Path = [path];
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\INETWIZ.EXE, (default) = [path]\INETWIZ.EXE
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\INETWIZ.EXE, Path = [path];
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWCONN2.EXE, (default) = [path]\ICWCONN2.EXE
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWCONN2.EXE, Path = [path];
//
//	History:	7/22/97	jmazner	Created for Olympus #9903
//
//-----------------------------------------------------------------------------
void SetICWRegKeysToPath( LPTSTR lpszICWPath )
{
	DWORD dwResult = ERROR_SUCCESS;
	TCHAR szBuffer[MAX_PATH + 4];
	TCHAR szAppPathsBuffer[MAX_PATH + 1];
	TCHAR szThePath[MAX_PATH + 2];
	UINT i=0;

	ASSERT( lpszICWPath );

	if( !lpszICWPath )
	{
		DEBUGMSG("SetICWRegKeysToPath: invalid parameter!!");
		return;
	}

	//
	// make sure last character is neither \ nor ;
	//
	switch( lpszICWPath[lstrlen(lpszICWPath) - 1] )
	{
		case '\\':
		case ';':
			ASSERTSZ(0, "Path given to SetICWRegKeysToPath is a bit malformed!");
			lpszICWPath[lstrlen(lpszICWPath) - 1] = '\0';
	}


	//
	// HKCR\x-internet-signup\Shell\Open\command, (default)=path\isignup.exe %1
	//
	DEBUGMSG("SetICWRegKeysToPath: setting %s", cszRegPathXInternetSignup);
	lstrcpy( szBuffer, lpszICWPath );
	lstrcat( szBuffer, TEXT("\\") );
	lstrcat( szBuffer, szISignupICWFileName );
	lstrcat( szBuffer, TEXT(" %1"));
	RegEntry re(cszRegPathXInternetSignup,HKEY_CLASSES_ROOT);
	dwResult = re.GetError();
	if (ERROR_SUCCESS == dwResult)
	{
		re.SetValue(NULL, szBuffer);
		DEBUGMSG("SetICWRegKeysToPath: set %s, %s = %s (error %d)",
				 cszRegPathXInternetSignup, "(default)", szBuffer, re.GetError());
	}
	else
	{
		DEBUGMSG("SetICWRegKeysToPath: FAILED with %d: %s, NULL = %s",
				 dwResult, cszRegPathXInternetSignup, szBuffer);
	}


	//
	// HKLM\software\microsoft\windows\currentVersion\App Paths
	//
	DEBUGMSG("SetICWRegKeysToPath: setting %s", cszRegPathAppPaths);

	lstrcpy( szThePath, lpszICWPath );
	lstrcat( szThePath, TEXT(";") );


	for( i=0; i<NUMICWFILENAMES; i++ )
	{
		lstrcpy( szAppPathsBuffer, cszRegPathAppPaths );
		lstrcat( szAppPathsBuffer, TEXT("\\"));
		lstrcat( szAppPathsBuffer, g_ppszICWFileNames[i] );

		lstrcpy( szBuffer, lpszICWPath );
		lstrcat( szBuffer, TEXT("\\") );
		lstrcat( szBuffer, g_ppszICWFileNames[i] );

		RegEntry re(szAppPathsBuffer,HKEY_LOCAL_MACHINE);
		dwResult = re.GetError();
		if (ERROR_SUCCESS == dwResult)
		{
			re.SetValue(NULL, szBuffer);
			DEBUGMSG("SetICWRegKeysToPath: set %s, %s = %s (error %d)",
					 szAppPathsBuffer, TEXT("(default)"), szBuffer, re.GetError());

			re.SetValue(cszPath, szThePath);
			DEBUGMSG("SetICWRegKeysToPath: set %s, %s = %s (error %d)",
					 szAppPathsBuffer, cszPath, szThePath, re.GetError());

		}
		else
		{
			DEBUGMSG("SetICWRegKeysToPath: FAILED with %d: %s, NULL = %s",
					 dwResult, szAppPathsBuffer, szBuffer);
		}
	}

}

//+----------------------------------------------------------------------------
//
//	Function:	GetICW11Path
//
//	Synopsis:	Finds the path to the ICW 1.1 installation directory
//
//	Arguments:
//		szPath [out] -- on succesfull exit, contains path to ICW 1.1
//						directory.  Path does _not_ terminate in \ or ;
//		fPathSetTo11 [out] -- indicates whether the App Paths\ICWCONN1.EXE
//							  currently points to the ICW 1.1 installation
//							  directory
//								
//	Returns:
//		Function results are determined by looking at both parameters
//		szPath: "", *fPathSetTo11: FALSE indicates App Paths\Icwconn1 does not
//			currently point to 1.1 files, and that a path to the 1.1
//			files could not be determined
//
//		szPath: non-empty, *fPathSetTo11: FALSE indicates App Paths\ICWCONN1
//			does not currently point to 1.1 files.  The path to the 1.1 files
//			is contained in szPath
//
//		szPath: non-empty, *fPathSetTo11: TRUE indicates that App Path\ICWCONN1
//			currently points to 1.1 files.  The path to the files is contained
//			in szPath
//		
//
//	History:	7/22/97	jmazner	Created for Olympus #9903
//
//-----------------------------------------------------------------------------
void GetICW11Path( TCHAR szPath[MAX_PATH + 1], BOOL *fPathSetTo11 )
{
	TCHAR szAppPathsBuffer[MAX_PATH + 1];
	LPTSTR lpszTemp = NULL;
	DWORD dwResult = ERROR_SUCCESS;
	DWORD dwMS = 0;
	DWORD dwLS = 0;

	ASSERT( fPathSetTo11 );
	ASSERT( szPath );

	if( !fPathSetTo11 || !szPath )
	{
		DEBUGMSG("GetICW11Path: invalid parameter!");
		return;
	}

	ZeroMemory( szPath, sizeof(szPath) );
	*fPathSetTo11 = FALSE;

	//
	// first let's check whether the App Path for ICW is currently pointing
	// to the 1.1 files
	//
	lstrcpy( szAppPathsBuffer, cszRegPathAppPaths );
	lstrcat( szAppPathsBuffer, TEXT("\\"));
	lstrcat( szAppPathsBuffer, g_ppszICWFileNames[0] );

	RegEntry reICWAppPath(szAppPathsBuffer, HKEY_LOCAL_MACHINE);
	dwResult = reICWAppPath.GetError();
	if (ERROR_SUCCESS == dwResult)
	{
		reICWAppPath.GetString(NULL, szPath, sizeof(TCHAR)*(MAX_PATH + 1));
	}

	if( szPath[0] )
	{
		GetFileVersion( szPath, &dwMS, &dwLS );
		DEBUGMSG("GetICW11Path: reg key %s = %s, which has file version %d.%d",
				 szAppPathsBuffer, szPath, HIWORD(dwMS), LOWORD(dwMS) );

		if( dwMS >= ICW_MINIMUM_VERSIONMS )
		{
			//
			// App Path is already pointing to 1.1 binaries!
			//
			*fPathSetTo11 = TRUE;

			//
			// for completness' sake, strip the .exe name out of
			// szPath so that it will in fact contain just the path
			// to the ICW 1.1 files.
			ExtractFilenameFromPath( szPath, &lpszTemp );
			szPath[lstrlen(szPath) - lstrlen(lpszTemp) - 1] = '\0';

			//
			// return values:
			// szPath = path to ICW 1.1 binaries, no terminating \ or ;
			// fPathSetTo11 = TRUE
			//
			return;
		}
	}
	else
	{
		DEBUGMSG("GetICW11Path: unable to read current AppPath key %s", szAppPathsBuffer);
	}


	//
	// look for the Installation Directory value in
	// HKLM\Software\Microsoft\Internet Connection Wizard
	// If it's there, it should point to the directory where the
	// 1.1 binaries are installed.
	//
	RegEntry re11Path(szRegPathICWSettings, HKEY_LOCAL_MACHINE);
	dwResult = re11Path.GetError();
	if (ERROR_SUCCESS == dwResult)
	{
		re11Path.GetString(cszInstallationDirectory, szPath, sizeof(TCHAR)*(MAX_PATH + 1));
	}

	if( NULL == szPath[0] )
	{
		DEBUGMSG("GetICW11Path: unable to read reg key %s", szRegPathICWSettings);

		//
		// return values:
		// szPath = ""
		// fPathSetTo11 = FALSE
		//
		return;
	}
	else
	{
		DEBUGMSG("GetICW11Path: %s, %s = %s",
				 szRegPathICWSettings, cszInstallationDirectory, szPath);

		//
		// okay, we got a path -- now let's make sure that the thing
		// it points to is in fact a 1.1 binary.
		//

		//
		// chop off the terminating semicolon if it's there
		//
		if( ';' == szPath[ lstrlen(szPath) ] )
		{
			szPath[ lstrlen(szPath) ] = '\0';
		}

		//
		// do we have a terminating \ now? if not, add it in
		//
		if( '\\' != szPath[ lstrlen(szPath) ] )
		{
			lstrcat( szPath, TEXT("\\") );
		}

		//
		// add in a binary filename to use for the version check
		// (just use whatever's first in our filename array)
		//
		lstrcat( szPath, g_ppszICWFileNames[0] );

		//
		// now check the version number of the file
		//
		GetFileVersion( szPath, &dwMS, &dwLS );
		DEBUGMSG("GetICW11Path: %s has file version %d.%d",
				 szPath, HIWORD(dwMS), LOWORD(dwMS) );

		if( dwMS >= ICW_MINIMUM_VERSIONMS )
		{
			//
			// Yes, this path is valid!
			// now hack off the filename so that we're back to just a
			// path with no terminating \ or ;
			//
			ExtractFilenameFromPath( szPath, &lpszTemp );
			szPath[lstrlen(szPath) - lstrlen(lpszTemp) - 1] = '\0';

			//
			// return values:
			// szPath = path to ICW 1.1 binaries, no terminating \ or ;
			// fPathSetTo11 = FALSE
			//
			return;
		}
		else
		{
			DEBUGMSG("GetICW11Path  %s doesn't actually point to a 1.1 binary!",
					 szPath);
			szPath[0] = '\0';

			//
			// return values:
			// szPath = ""
			// fPathSetTo11 = FALSE
			//
			return;
		}

	}
}

#ifdef UNICODE
PWCHAR ToUnicodeWithAlloc
(
    LPCSTR  lpszSrc
)
{
    PWCHAR  lpWChar;
    INT     iLength = 0;
    DWORD   dwResult;

    if (lpszSrc == NULL)
    {
        return NULL;
    }

    iLength = MultiByteToWideChar(  CP_ACP,
                                    0,
                                    lpszSrc,
                                    -1,
                                    NULL,
                                    0 );

    if(iLength == 0)
        return NULL;

    
    lpWChar = (WCHAR *) GlobalAlloc( GPTR, sizeof(WCHAR) * iLength );
    if(!lpWChar)
        return NULL;

    dwResult = MultiByteToWideChar(  CP_ACP,
                                     0,
                                     lpszSrc,
                                     -1,
                                     lpWChar,
                                     iLength );
    if(!dwResult)
    {
        GlobalFree(lpWChar);
        return NULL;
    }

    return lpWChar;
}

VOID ToAnsiClientInfo
(
    LPINETCLIENTINFOA lpInetClientInfoA,
    LPINETCLIENTINFOW lpInetClientInfoW
)
{
    if(lpInetClientInfoW == NULL || lpInetClientInfoA == NULL)
        return;

    lpInetClientInfoA->dwSize        = lpInetClientInfoW->dwSize;
    lpInetClientInfoA->dwFlags       = lpInetClientInfoW->dwFlags;
    lpInetClientInfoA->iIncomingProtocol = lpInetClientInfoW->iIncomingProtocol;
    lpInetClientInfoA->fMailLogonSPA = lpInetClientInfoW->fMailLogonSPA;
    lpInetClientInfoA->fNewsLogonSPA = lpInetClientInfoW->fNewsLogonSPA;
    lpInetClientInfoA->fLDAPLogonSPA = lpInetClientInfoW->fLDAPLogonSPA;
    lpInetClientInfoA->fLDAPResolve  = lpInetClientInfoW->fLDAPResolve;

    wcstombs(lpInetClientInfoA->szEMailName,
             lpInetClientInfoW->szEMailName,
             MAX_EMAIL_NAME+1);
    wcstombs(lpInetClientInfoA->szEMailAddress,
             lpInetClientInfoW->szEMailAddress,
             MAX_EMAIL_ADDRESS+1);
    wcstombs(lpInetClientInfoA->szPOPLogonName,
             lpInetClientInfoW->szPOPLogonName,
             MAX_LOGON_NAME+1);
    wcstombs(lpInetClientInfoA->szPOPLogonPassword,
             lpInetClientInfoW->szPOPLogonPassword,
             MAX_LOGON_PASSWORD+1);
    wcstombs(lpInetClientInfoA->szPOPServer,
             lpInetClientInfoW->szPOPServer,
             MAX_SERVER_NAME+1);
    wcstombs(lpInetClientInfoA->szSMTPServer,
             lpInetClientInfoW->szSMTPServer,
             MAX_SERVER_NAME+1);
    wcstombs(lpInetClientInfoA->szNNTPLogonName,
             lpInetClientInfoW->szNNTPLogonName,
             MAX_LOGON_NAME+1);
    wcstombs(lpInetClientInfoA->szNNTPLogonPassword,
             lpInetClientInfoW->szNNTPLogonPassword,
             MAX_LOGON_PASSWORD+1);
    wcstombs(lpInetClientInfoA->szNNTPServer,
             lpInetClientInfoW->szNNTPServer,
             MAX_SERVER_NAME+1);
    wcstombs(lpInetClientInfoA->szNNTPName,
             lpInetClientInfoW->szNNTPName,
             MAX_EMAIL_NAME+1);
    wcstombs(lpInetClientInfoA->szNNTPAddress,
             lpInetClientInfoW->szNNTPAddress,
             MAX_EMAIL_ADDRESS+1);
    wcstombs(lpInetClientInfoA->szIncomingMailLogonName,
             lpInetClientInfoW->szIncomingMailLogonName,
             MAX_LOGON_NAME+1);
    wcstombs(lpInetClientInfoA->szIncomingMailLogonPassword,
             lpInetClientInfoW->szIncomingMailLogonPassword,
             MAX_LOGON_PASSWORD+1);
    wcstombs(lpInetClientInfoA->szIncomingMailServer,
             lpInetClientInfoW->szIncomingMailServer,
             MAX_SERVER_NAME+1);
    wcstombs(lpInetClientInfoA->szLDAPLogonName,
             lpInetClientInfoW->szLDAPLogonName,
             MAX_LOGON_NAME+1);
    wcstombs(lpInetClientInfoA->szLDAPLogonPassword,
             lpInetClientInfoW->szLDAPLogonPassword,
             MAX_LOGON_PASSWORD+1);
    wcstombs(lpInetClientInfoA->szLDAPServer,
             lpInetClientInfoW->szLDAPServer,
             MAX_SERVER_NAME+1);
}

VOID ToUnicodeClientInfo
(
    LPINETCLIENTINFOW lpInetClientInfoW,
    LPINETCLIENTINFOA lpInetClientInfoA
)
{
    if(lpInetClientInfoW == NULL || lpInetClientInfoA == NULL)
        return;

    lpInetClientInfoW->dwSize        = lpInetClientInfoA->dwSize;
    lpInetClientInfoW->dwFlags       = lpInetClientInfoA->dwFlags;
    lpInetClientInfoW->iIncomingProtocol = lpInetClientInfoA->iIncomingProtocol;
    lpInetClientInfoW->fMailLogonSPA = lpInetClientInfoA->fMailLogonSPA;
    lpInetClientInfoW->fNewsLogonSPA = lpInetClientInfoA->fNewsLogonSPA;
    lpInetClientInfoW->fLDAPLogonSPA = lpInetClientInfoA->fLDAPLogonSPA;
    lpInetClientInfoW->fLDAPResolve  = lpInetClientInfoA->fLDAPResolve;

    mbstowcs(lpInetClientInfoW->szEMailName,
             lpInetClientInfoA->szEMailName,
             lstrlenA(lpInetClientInfoA->szEMailName)+1);
    mbstowcs(lpInetClientInfoW->szEMailAddress,
             lpInetClientInfoA->szEMailAddress,
             lstrlenA(lpInetClientInfoA->szEMailAddress)+1);
    mbstowcs(lpInetClientInfoW->szPOPLogonName,
             lpInetClientInfoA->szPOPLogonName,
             lstrlenA(lpInetClientInfoA->szPOPLogonName)+1);
    mbstowcs(lpInetClientInfoW->szPOPLogonPassword,
             lpInetClientInfoA->szPOPLogonPassword,
             lstrlenA(lpInetClientInfoA->szPOPLogonPassword)+1);
    mbstowcs(lpInetClientInfoW->szPOPServer,
             lpInetClientInfoA->szPOPServer,
             lstrlenA(lpInetClientInfoA->szPOPServer)+1);
    mbstowcs(lpInetClientInfoW->szSMTPServer,
             lpInetClientInfoA->szSMTPServer,
             lstrlenA(lpInetClientInfoA->szSMTPServer)+1);
    mbstowcs(lpInetClientInfoW->szNNTPLogonName,
             lpInetClientInfoA->szNNTPLogonName,
             lstrlenA(lpInetClientInfoA->szNNTPLogonName)+1);
    mbstowcs(lpInetClientInfoW->szNNTPLogonPassword,
             lpInetClientInfoA->szNNTPLogonPassword,
             lstrlenA(lpInetClientInfoA->szNNTPLogonPassword)+1);
    mbstowcs(lpInetClientInfoW->szNNTPServer,
             lpInetClientInfoA->szNNTPServer,
             lstrlenA(lpInetClientInfoA->szNNTPServer)+1);
    mbstowcs(lpInetClientInfoW->szNNTPName,
             lpInetClientInfoA->szNNTPName,
             lstrlenA(lpInetClientInfoA->szNNTPName)+1);
    mbstowcs(lpInetClientInfoW->szNNTPAddress,
             lpInetClientInfoA->szNNTPAddress,
             lstrlenA(lpInetClientInfoA->szNNTPAddress)+1);
    mbstowcs(lpInetClientInfoW->szIncomingMailLogonName,
             lpInetClientInfoA->szIncomingMailLogonName,
             lstrlenA(lpInetClientInfoA->szIncomingMailLogonName)+1);
    mbstowcs(lpInetClientInfoW->szIncomingMailLogonPassword,
             lpInetClientInfoA->szIncomingMailLogonPassword,
             lstrlenA(lpInetClientInfoA->szIncomingMailLogonPassword)+1);
    mbstowcs(lpInetClientInfoW->szIncomingMailServer,
             lpInetClientInfoA->szIncomingMailServer,
             lstrlenA(lpInetClientInfoA->szIncomingMailServer)+1);
    mbstowcs(lpInetClientInfoW->szLDAPLogonName,
             lpInetClientInfoA->szLDAPLogonName,
             lstrlenA(lpInetClientInfoA->szLDAPLogonName)+1);
    mbstowcs(lpInetClientInfoW->szLDAPLogonPassword,
             lpInetClientInfoA->szLDAPLogonPassword,
             lstrlenA(lpInetClientInfoA->szLDAPLogonPassword)+1);
    mbstowcs(lpInetClientInfoW->szLDAPServer,
             lpInetClientInfoA->szLDAPServer,
             lstrlenA(lpInetClientInfoA->szLDAPServer)+1);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\wizdll.h ===
#include <windows.h>
#include <wizglob.h>

#ifdef DEBUG
#define SZ_COMPNAME "INETCFG: "
#endif // DEBUG

#include <wizdebug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\uninstal.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UNINSTAL.C - code to uninstall MSN
//

//  HISTORY:
//  
//  6/22/95  jeremys    Created.
//

#include "wizard.h"

extern DOGENINSTALL lpDoGenInstall;

/*******************************************************************

  NAME:    DoUninstall

  SYNOPSIS:  Uninstalls MSN1.05 if we installed it in the past,
        and it's still installed

********************************************************************/
BOOL DoUninstall(VOID)
{
  BOOL fRet = TRUE;
  BOOL fNeedToRemoveMSN105 = FALSE;
  // check registry entry to see if we installed MSN1.05

  RegEntry re(szRegPathInternetSettings,HKEY_LOCAL_MACHINE);
  ASSERT(re.GetError() == ERROR_SUCCESS);

  if (re.GetError() == ERROR_SUCCESS) {

    if (re.GetNumber(szRegValInstalledMSN105,0) > 0) {

      // yes, we installed MSN1.05.  now see if it's still installed.

      RegEntry reSetup(szRegPathOptComponents,HKEY_LOCAL_MACHINE);
      ASSERT(reSetup.GetError() == ERROR_SUCCESS);
      reSetup.MoveToSubKey(szRegPathMSNetwork105);
      ASSERT(reSetup.GetError() == ERROR_SUCCESS);
      if (reSetup.GetError() == ERROR_SUCCESS) {
        TCHAR szInstalledVal[10];  // big enough for "1"
        if (reSetup.GetString(szRegValInstalled,szInstalledVal,
          sizeof(szInstalledVal))
          && !lstrcmpi(szInstalledVal,sz1)) {

          // yes, MSN1.05 is still installed.  we need to remove it.
          fNeedToRemoveMSN105 = TRUE;
        }
      }
    }
  }

  if (fNeedToRemoveMSN105) {
    // warn user that this will remove MSN!
    int iRet=MsgBox(NULL,IDS_WARNWillRemoveMSN,MB_ICONEXCLAMATION,MB_OKCANCEL);
    if (iRet == IDOK) {

      TCHAR szInfFilename[SMALL_BUF_LEN+1];
      TCHAR szInfSectionName[SMALL_BUF_LEN+1];

      DEBUGMSG("Uninstalling MSN 1.05");

      // load file name and section name out of resources
      LoadSz(IDS_MSN105_INF_FILE,szInfFilename,ARRAYSIZE(szInfFilename));
      LoadSz(IDS_MSN105_UNINSTALL_SECT,szInfSectionName,
        ARRAYSIZE(szInfSectionName));
      // call GenInstall to remove files, do registry edits, etc.
      RETERR err = lpDoGenInstall(NULL,szInfFilename,szInfSectionName);

      if (err == OK) {
        DEBUGMSG("Uninstalling MSN 1.0");

        // load file name and section name out of resources
        LoadSz(IDS_MSN100_INF_FILE,szInfFilename,ARRAYSIZE(szInfFilename));
        LoadSz(IDS_MSN100_UNINSTALL_SECT,szInfSectionName,
          ARRAYSIZE(szInfSectionName));
        // call GenInstall to remove files, do registry edits, etc.
        RETERR err = lpDoGenInstall(NULL,szInfFilename,szInfSectionName);
      }

      if (err != OK) {
        DisplayErrorMessage(NULL,IDS_ERRUninstallMSN,err,ERRCLS_SETUPX,
          MB_ICONEXCLAMATION);
        fRet = FALSE;
      } else {
        // remove our registry marker that we installed MSN 1.05
        re.DeleteValue(szRegValInstalledMSN105);
      }

    }
  }

  // remove the Internet icon from the desktop.  To do this, we have to
  // delete a registry key (not a value!).  Plus! setup won't
  // do this from their .inf file, they can only delete values.  So we
  // have to write some actual code here to remove the key.

  // open the name space key.  The key we want to remove is a subkey
  // of this key.

	//	//10/24/96 jmazner Normandy 6968
	//	//No longer neccessary thanks to Valdon's hooks for invoking ICW.
	// 11/21/96 jmazner Normandy 11812
	// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
	// ICW 1.1 needs to morph the IE 3 icon.

  RegEntry reNameSpace(szRegPathNameSpace,HKEY_LOCAL_MACHINE);
  ASSERT(reNameSpace.GetError() == ERROR_SUCCESS);
  if (reNameSpace.GetError() == ERROR_SUCCESS) {
    // delete the subkey that causes the internet icon to appear
    RegDeleteKey(reNameSpace.GetKey(),szRegKeyInternetIcon);
  }

  return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetwiz\ids.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// string resource IDs
#define IDS_WIZ_WINDOW_NAME				1000
#define IDS_WIZ_CLASS_NAME				1001
#define IDS_WANTTOREBOOT                1002
#define IDS_EXITFAILED                  1003
#define IDS_ADMIN_ACCESS_DENIED         1004
#define IDS_ADMIN_ACCESS_DENIED_TITLE   1005
#define IDS_IEAK_ACCESS_DENIED          1006
#define IDS_IEAK_ACCESS_DENIED_TITLE    1007
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\wizdef.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  WIZDEF.H -   data structures and constants for Internet setup/signup wizard
//

//  HISTORY:
//  
//  11/20/94  jeremys Created.
//  96/02/27  markdu  Changed RAS_MaxLocal to RAS_MaxPhoneNumber
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//  96/03/23  markdu  Remove unused IP LAN pages.
//  96/03/23  markdu  Removed TCPINFO struct from CLIENTINFO struct.
//  96/03/23  markdu  Since TCPINFO struct was removed from CLIENTINFO, 
//            CLIENTINFO contained only a CLIENTCONFIG.  So, CLIENTINFO
//            has been removed and all occurrences replaced with CLIENTCONFIG.
//  96/03/24  markdu  Changed all MAX_ISP_ defines to use the values used
//            by RASDIALPARAMS.  Note that since for some reason RNA won't
//            create an entry of length RAS_MaxEntryName even though 
//            RasValidateEntryName succeeds, we have to subtract one.
//  96/03/27  markdu  Added lots of new pages.
//  96/04/19  markdu  NASH BUG 13387 Changed RAS_MaxPhoneNumber.
//  96/05/06  markdu  NASH BUG 15637 Removed unused code.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//	96/09/05  valdonb NORMANDY BUG 6248 Added pages for mail and news set up
//

#ifndef _WIZDEF_H_
#define _WIZDEF_H_

#include "icwcmn.h"

// Defines
#define MAX_ISP_NAME        (RAS_MaxEntryName-1)  // internet service provider name
#define MAX_ISP_USERNAME    UNLEN  // max length of login username
#define MAX_ISP_PASSWORD    PWLEN  // max length of login password
#define MAX_PORT_LEN		5      // max length of proxy port number (max # = 65535)

#define MAX_SCHEME_NAME_LENGTH	sizeof("gopher")
#define MAX_URL_STRING (1024 + MAX_SCHEME_NAME_LENGTH + sizeof("://"))	// max length of URL

#define MAX_REG_LEN			2048	// max length of registry entries
#define MAX_RES_LEN         255 // max length of string resources
#define SMALL_BUF_LEN       48  // convenient size for small text buffers

#define MAX_UI_AREA_CODE    RAS_MaxAreaCode
// NASH BUG 13387 MAX_UI_PHONENUM should be defined as RAS_MaxPhoneNumber, since that
// what is used in RASENTRY, but internally RNA uses RAS_MaxLocal, which is 36.  There
// is a bug in RNA though:  it chops off the 36th character if you enter it.
#define MAX_UI_PHONENUM     35

// Keep in sync with CCHMAX_ACCOUNT_NAME in imnact.h.  This is used here because
// we can't include imnact.h in this file because using a precompiled header
// conflicts with the use of DEFINE_GUID.
#define MAX_ACCOUNT_NAME	256


// 11/23/96 jmazner Normandy #8504
#define MAX_SERVERPROTOCOL_NAME		16
#define NUM_MAILSERVERPROTOCOLS		2	/*  POP3
											IMAP
										*/

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

#ifndef NULL_TERM_TCHARS
#define NULL_TERM_TCHARS(sz);       {sz[ARRAYSIZE(sz)-1] = TEXT('\0');}
#endif

// Data structures

// we distinguish two kinds of phone numbers: "machine-readable"
// which are just the digits stored sequentially ("18003524060"), and
// "human readable" which is just text and may look like "(206) 352-9060
// ext. 910".  We will never parse "human readable" numbers.

// structure to hold information about the user
// The fixed-lengths fields are a little wasteful, but we only have one
// of these, it's dynamically allocated and it's much more convenient this way.
typedef struct tagUSERINFO {
  UINT cbStruct;                // == sizeof(USERINFO)

  // various choices made along the way...
  
  // 5/4/97	jmazner	Olympus #1347
  // Updated to allow for new Manual connection type. 
  //BOOL fConnectOverLAN;  // use LAN to connect, if user has both modem & LAN
  UINT uiConnectionType;

  // ISP (Internet Service Provider) information
  BOOL fNewConnection;
  BOOL fModifyConnection;
  BOOL fModifyAdvanced;
  BOOL fAutoDNS;
  TCHAR szISPName[MAX_ISP_NAME+1];
  TCHAR szAccountName[MAX_ISP_USERNAME+1];    // requested username
  TCHAR szPassword[MAX_ISP_PASSWORD+1];    // requested password

  // proxy server config information
  TCHAR  szAutoConfigURL[MAX_URL_STRING+1];
  BOOL  fProxyEnable;
  BOOL  bByPassLocal;
  BOOL  bAutoConfigScript;
  BOOL  bAutoDiscovery;
  TCHAR  szProxyServer[MAX_URL_STRING+1];
  TCHAR  szProxyOverride[MAX_URL_STRING+1];

  BOOL fPrevInstallFound;      // previous install was found

} USERINFO;

// structure used to pass information to mail profile config APIs.
// Most likely the pointers point into a USERINFO struct, 
typedef struct MAILCONFIGINFO {
  TCHAR * pszEmailAddress;          // user's email address
  TCHAR * pszEmailServer;          // user's email server path
  TCHAR * pszEmailDisplayName;        // user's name
  TCHAR * pszEmailAccountName;        // account name
  TCHAR * pszEmailAccountPwd;        // account password
  TCHAR * pszProfileName;          // name of profile to use
                      // (create or use default if NULL)
  BOOL fSetProfileAsDefault;        // set profile as default profile

  TCHAR * pszConnectoidName;        // name of connectoid to dial
  BOOL fRememberPassword;          // password cached if TRUE
} MAILCONFIGINFO;

#define NUM_WIZARD_PAGES	12    //39  // total number of pages in wizard

#define MAX_PAGE_INDEX	    11

// page index defines
#define ORD_PAGE_HOWTOCONNECT         0
#define ORD_PAGE_CHOOSEMODEM          1
#define ORD_PAGE_CONNECTEDOK          2
#define ORD_PAGE_CONNECTION           3
#define ORD_PAGE_MODIFYCONNECTION     4
#define ORD_PAGE_CONNECTIONNAME       5
#define ORD_PAGE_PHONENUMBER          6
#define ORD_PAGE_NAMEANDPASSWORD      7
#define ORD_PAGE_USEPROXY             8
#define ORD_PAGE_PROXYSERVERS         9
#define ORD_PAGE_PROXYEXCEPTIONS      10
#define ORD_PAGE_SETUP_PROXY          11


// structure to hold information about wizard state
typedef struct tagWIZARDSTATE  {

  UINT uCurrentPage;    // index of current page wizard is on

  // keeps a history of which pages were visited, so user can
  // back up and we know the last page completed in case of reboot.
  UINT uPageHistory[NUM_WIZARD_PAGES]; // array of page #'s we visited
  UINT uPagesCompleted;         // # of pages in uPageHistory

  BOOL fMAPIActive;    // MAPI initialized

  BOOL fNeedReboot;    // reboot needed at end

  DWORD dwRunFlags;    // flags passed to us
  
  // State data that is common to both sides of the WIZARD
  CMNSTATEDATA cmnStateData;
} WIZARDSTATE;



// handler proc for OK, cancel, etc button handlers
typedef BOOL (CALLBACK* INITPROC)(HWND,BOOL);
typedef BOOL (CALLBACK* OKPROC)(HWND,BOOL,UINT *,BOOL *);
typedef BOOL (CALLBACK* CANCELPROC)(HWND);
typedef BOOL (CALLBACK* CMDPROC)(HWND,WPARAM,LPARAM);

// structure with information for each wizard page
typedef struct tagPAGEINFO
{
  UINT       uDlgID;            // dialog ID to use for page
  UINT       uDlgID97External;  // dialog ID to use for pages given to an external Wizard 97
  UINT       uDlgID97;          // dialog ID to use for a Wizard 97 that we build
  // handler procedures for each page-- any of these can be
  // NULL in which case the default behavior is used
  INITPROC    InitProc;
  OKPROC      OKProc;
  CMDPROC     CmdProc;
  CANCELPROC  CancelProc;
  // Normandy 12278 ChrisK 12/4/96
#if !defined(WIN16)
  DWORD       dwHelpID;
#endif //!WIN16

  int       nIdTitle;
  int       nIdSubTitle;
  
} PAGEINFO;

#define SetPropSheetResult( hwnd, result ) SetWindowLongPtr(hwnd, DWLP_MSGRESULT, result)


#endif // _WIZDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\wizard.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  WIZARD.H - central header file for Internet setup/signup wizard
//

//  HISTORY:
//  
//  11/20/94  jeremys  Created.
//  96/02/24  markdu  Added RNAPH.H
//  96/02/27  markdu  Replaced internal RNA header files with RAS.H
//  96/03/07  markdu  Added gpEnumModem
//  96/03/09  markdu  Moved all rnacall function prototypes to rnacall.h
//  96/03/09  markdu  Added gpRasEntry
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//  96/04/24  markdu  NASH BUG 19289 Added /NOMSN command line flag
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//

#ifndef _WIZARD_H_
#define _WIZARD_H_

#define STRICT                      // Use strict handle types
#define _SHELL32_

#ifdef DEBUG
// component name for debug spew
#define SZ_COMPNAME "INETWIZ: "
#endif // DEBUG

#include <windows.h>                
#include <windowsx.h>
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include <inetreg.h>
#include <oharestr.h>

  // various RNA header files
#pragma pack(8)
  #include <ras.h>
  #include <ras2.h>
#pragma pack()
  #include <raserror.h>
//  #include <rnaph.h>
  #include "rnacall.h"

  #include <wizglob.h>
  #include <wizdebug.h>

  #include <shlobj.h>
//  #include <shsemip.h>

#undef DATASEG_READONLY  
#define DATASEG_READONLY  ".rdata"
#include <stdio.h>                

#include "icwunicd.h"

#include "inetcfg.h"
#include "cfgapi.h"
#include "clsutil.h"
#include "tcpcmn.h"
#include "mapicall.h"
#include "wizdef.h"
#include "icfgcall.h"
#include "ids.h"
#include "strings.h"
#include "icwcmn.h"

// Terminology: ISP - Internet Service Provider

// Globals

extern LPRASENTRY   gpRasEntry;     // pointer to RASENTRY struct to hold all data
extern DWORD        gdwRasEntrySize;// bytes allocated for gpRasEntry
extern ENUM_MODEM*  gpEnumModem;    // modem enumeration object
extern HINSTANCE    ghInstance;     // global module instance handle
extern USERINFO*    gpUserInfo;     // global user information 
extern WIZARDSTATE* gpWizardState;  // global wizard state
extern BOOL         gfQuitWizard;   // global flag used to signal that we
                                    // want to terminate the wizard ourselves
extern BOOL gfFirstNewConnection;	// first time the user selected new connection
extern BOOL gfUserFinished;			// user finished wizard
extern BOOL gfUserBackedOut;		// user click back on first page
extern BOOL gfUserCancelled;		// user cancalled wizard
extern BOOL gfOleInitialized;

extern BOOL g_fAcctMgrUILoaded;
//extern BOOL	g_MailUIAvailable, g_NewsUIAvailable, g_DirServUIAvailable;

extern BOOL    g_fIsExternalWizard97;
extern BOOL    g_fIsWizard97;
extern BOOL    g_fIsICW;

extern BOOL   g_bReboot;            //used to signify that we  should reboot  - MKarki 5/2/97 - Fix for Bug #3111
extern BOOL   g_bRebootAtExit;      //used to signify that we  should reboot when exit
extern BOOL   g_bSkipMultiModem;
extern BOOL   g_bUseAutoProxyforConnectoid;

// Defines

// error class defines for DisplayErrorMessage
#define ERRCLS_STANDARD 0x0001
#define ERRCLS_SETUPX   0x0002
#define ERRCLS_RNA      0x0003
#define ERRCLS_MAPI     0x0004

// flags for RunSignupWizard
#define RSW_NOREBOOT    0x0001
#define RSW_UNINSTALL   0x0002
#define RSW_NOMSN       0x0004
#define RSW_NOINIT      0x0008
#define RSW_NOFREE      0x0010
#define RSW_NOIMN       0x0020

//#define RSW_MAILACCT    0x0100
//#define RSW_NEWSACCT    0x0200
//#define	RSW_DIRSERVACCT	0x0400
#define	RSW_APPRENTICE	0x0100

#define OK        0    // success code for SETUPX class errors

// 11/25/96	jmazner Normandy #10586
#define WM_MYINITDIALOG	WM_USER

// Modem specific info
#define ISIGNUP_KEY TEXT("Software\\Microsoft\\ISIGNUP")
#define DEVICENAMEKEY TEXT("DeviceName")
#define DEVICETYPEKEY TEXT("DeviceType")

// functions in PROPMGR.C
BOOL InitWizard(DWORD dwFlags, HWND hwndParent = NULL);
BOOL DeinitWizard(DWORD dwFlags);
BOOL RunSignupWizard(DWORD dwFlags, HWND hwndParent = NULL);
VOID GetDefaultUserName(TCHAR * pszUserName,DWORD cbUserName);
void ProcessDBCS(HWND hDlg, int ctlID);
#if !defined(WIN16)
BOOL IsSBCSString( TCHAR *sz );
#endif

// functions in CALLOUT.C
UINT InvokeModemWizard(HWND hwndToHide);

// functions in UTIL.C
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons);
// jmazner 11/6/96	modified for RISC compatability
//int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...);
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons, LPTSTR szParam = NULL);

LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);
BOOL EnableDlgItem(HWND hDlg,UINT uID,BOOL fEnable);

// modified for RISC compatability
//VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
//  UINT uErrorClass,UINT uIcon,...);
VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,LPTSTR szArg = NULL);
BOOL WarnFieldIsEmpty(HWND hDlg,UINT uCtrlID,UINT uStrID);
BOOL TweakAutoRun(BOOL bEnable);
VOID DisplayFieldErrorMsg(HWND hDlg,UINT uCtrlID,UINT uStrID);
VOID GetErrorDescription(TCHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass);
VOID SetBackupInternetConnectoid(LPCTSTR pszEntryName);
UINT myatoi (TCHAR * szVal);
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent);
BOOL GetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf, DWORD dwSize);

//	//10/24/96 jmazner Normandy 6968
//	//No longer neccessary thanks to Valdon's hooks for invoking ICW.
// 11/21/96 jmazner Normandy 11812
// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
// ICW 1.1 needs to morph the IE 3 icon.
BOOL SetDesktopInternetIconToBrowser(VOID);

// 11/11/96 jmazner Normandy 7623
BOOL IsDialableString( LPTSTR szBuff );

//
// 6/6/97 jmazner Olympus #5413
//
#ifdef WIN32
VOID Win95JMoveDlgItem( HWND hwndParent, HWND hwndItem, int iUp );
#endif

// functions in MAPICALL.C
BOOL InitMAPI(HWND hWnd);
VOID DeInitMAPI(VOID);
HRESULT SetMailProfileInformation(MAILCONFIGINFO * pMailConfigInfo);
BOOL FindInternetMailService(TCHAR * pszEmailAddress,DWORD cbEmailAddress,
  TCHAR * pszEmailServer, DWORD cbEmailServer);

// functions in INETAPI.C
BOOL DoDNSCheck(HWND hwndParent,BOOL * pfNeedRestart);

// functions in UNINSTALL.C
BOOL DoUninstall(VOID);

// structure for getting proc addresses of api functions
typedef struct APIFCN {
  PVOID * ppFcnPtr;
  LPCSTR pszName;   // Proc name. Don't be wide char.
} APIFCN;

// user preference defines for registry
#define USERPREF_MODEM      0x0001
#define USERPREF_LAN      0x0002

#define ACCESSTYPE_MSN      0x0001
#define ACCESSTYPE_OTHER_ISP  0x0002

#undef  DATASEG_PERINSTANCE
#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT    DATASEG_SHARED

inline BOOL IsNT(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}

inline BOOL IsNT5(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return ((VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId) && (OsVersionInfo.dwMajorVersion >= 5));
}

inline BOOL IsWin95(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return ((VER_PLATFORM_WIN32_WINDOWS == OsVersionInfo.dwPlatformId) && (0 == OsVersionInfo.dwMinorVersion));
}

inline BOOL IsNT4SP3Lower(void)
{
	OSVERSIONINFO os;
	os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		
	GetVersionEx(&os);

	if(os.dwPlatformId != VER_PLATFORM_WIN32_NT)
        return FALSE;

    // Exclude NT5 or higher
    if(os.dwMajorVersion > 4)
        return FALSE;

	if(os.dwMajorVersion < 4)
        return TRUE;

	// version 4.0
	if ( os.dwMinorVersion > 0)
        return FALSE;		// assume that sp3 is not needed for nt 4.1 or higher

	int nServicePack;
	if(_stscanf(os.szCSDVersion, TEXT("Service Pack %d"), &nServicePack) != 1)
        return TRUE;

	if(nServicePack < 4)
        return TRUE;
	return FALSE;
}

//
// 7/21/97 jmazner Olympus #9903
// we only want this version of inetcfg to work with the corresponding
// version of other icwconn1 components.  If an older icw component tries to
// load this dll, we should fail -- gracefully
#define ICW_MINIMUM_MAJOR_VERSION (UINT) 4
#define ICW_MINIMUM_MINOR_VERSION (UINT) 71
#define ICW_MINIMUM_VERSIONMS (DWORD) ((ICW_MINIMUM_MAJOR_VERSION << 16) | ICW_MINIMUM_MINOR_VERSION)

//
// in util.cpp
//
extern BOOL GetFileVersion(LPTSTR lpszFilePath, PDWORD pdwVerNumMS, PDWORD pdwVerNumLS);
extern BOOL IsParentICW10( void );
extern void SetICWRegKeysToPath( LPTSTR lpszICWPath );
extern void GetICW11Path( TCHAR szPath[MAX_PATH + 1], BOOL *fPathSetTo11 );

typedef BOOL (WINAPI *PFNInitCommonControlsEx)(LPINITCOMMONCONTROLSEX);

#endif // _WIZARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetcfg\wizdll.cpp ===
/*****************************************************************/
/**          Microsoft Windows for Workgroups        **/
/**          Copyright (C) Microsoft Corp., 1991-1992      **/
/*****************************************************************/ 

//
//  WIZDLL.C - 32-bit stubs for functions that call into 16-bit DLL
//

//  HISTORY:
//  
//  11/20/94  jeremys  Created.
//  96/03/13  markdu  Added IcfgSetInstallSourcePath().
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//  96/05/28  markdu  InitConfig and DeInitConfig in DllEntryPoint.
//

#include "wizard.h"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)
HINSTANCE ghInstance=NULL;
#pragma data_seg(DATASEG_DEFAULT)

typedef UINT RETERR;

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#ifdef __cplusplus
}
#endif // __cplusplus

/*******************************************************************

  NAME:    DllEntryPoint

  SYNOPSIS:  Entry point for DLL.

  NOTES:    Initializes thunk layer to WIZ16.DLL

********************************************************************/
BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
  if( fdwReason == DLL_PROCESS_ATTACH )
  {
    ghInstance = hInstDll;

	//
	// 7/22/97 jmazner Olympus #9903
	//
	TCHAR szPath[MAX_PATH + 1];
	BOOL fPathAlreadySet = FALSE;

	GetICW11Path( szPath, &fPathAlreadySet );

	if( !fPathAlreadySet && szPath[0] )
	{
		SetICWRegKeysToPath( szPath );
	}

	if( IsParentICW10() )
	{
		DEBUGMSG("DllEntryPoint, INETCFG called from old component, bailing out!");
		return FALSE;
	}


	// load the config dll proc addresses
    BOOL fRet = InitConfig(NULL);
    if (FALSE == fRet)
    {
      // Error message was already displayed in InitConfig.
      return FALSE;
    }
  }

  if( fdwReason == DLL_PROCESS_DETACH )
  {
    DeInitConfig();
  }

  return TRUE;
}


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

void __cdecl main() {};

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetwiz\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

MAJORCOMP=GETCONN
MINORCOMP=INETWIZ

TARGETNAME=INETWIZ
TARGETTYPE=PROGRAM
TARGETPATH=obj
UMTYPE=windows
UMENTRY=winmain
NOT_LEAN_AND_MEAN=1
RCNOFONTMAP=1
C_DEFINES=-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

# PASS0_SOURCEDIR=.

# only build after the inetcfg lib is done
SYNCHRONIZE_DRAIN = 1

USE_MSVCRT40=1

SOURCES=            \
	..\inetwiz.rc   \
	..\init.cpp     \
    ..\reboot.cpp

TARGETLIBS=                                         \
!if defined(NOT_UNICODE)
    $(GETCONN_DIR)\inetcfg\ansi\$O\inetcfg.lib      \
!else
    $(GETCONN_DIR)\inetcfg\unicode\$O\inetcfg.lib   \
!endif
    $(SDK_LIB_PATH)\user32.lib	                    \
    $(SDK_LIB_PATH)\shell32.lib	                    \
    $(SDK_LIB_PATH)\kernel32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetwiz\init.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//	INIT.C - WinMain and initialization code for Internet setup/signup wizard
//

//	HISTORY:
//	
//	11/20/94	jeremys	Created.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//

#include "wizard.h"

#ifdef WIN32
#include "..\inc\semaphor.h"
#endif

#define IEAK_RESTRICTION_REGKEY        TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define IEAK_RESTRICTION_REGKEY_VALUE  TEXT("Connwiz Admin Lock")

// superceded by definition in semaphor.h
//#define SEMAPHORE_NAME "Internet Connection Wizard INETWIZ.EXE"

HINSTANCE ghInstance=NULL;

LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

	VOID WINAPI LaunchSignupWizard(LPTSTR lpCmdLine,int nCmdShow, PBOOL pReboot);

#ifdef __cplusplus
}
#endif // __cplusplus

BOOL DoesUserHaveAdminPrivleges(HINSTANCE hInstance)
{
    HKEY hKey = NULL;
    BOOL bRet = FALSE;

    if (!IsNT())
        return TRUE;

    // BUGBUG: We should allow NT5 to run in all user groups
    // except normal users.
    if (IsNT5())
        return TRUE;

    //
    // Ensure caller is an administrator on this machine.
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      (TCHAR*)TEXT("SYSTEM\\CurrentControlSet"),
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hKey))
    {
        bRet = TRUE;
        CloseHandle(hKey);
    }
    else
    {
        TCHAR szAdminDenied      [MAX_PATH] = TEXT("\0");
        TCHAR szAdminDeniedTitle [MAX_PATH] = TEXT("\0");
        LoadString(hInstance, IDS_ADMIN_ACCESS_DENIED, szAdminDenied, MAX_PATH);
        LoadString(hInstance, IDS_ADMIN_ACCESS_DENIED_TITLE, szAdminDeniedTitle, MAX_PATH);
        MessageBox(NULL, szAdminDenied, szAdminDeniedTitle, MB_OK | MB_ICONSTOP);
    }

    return bRet;
}

BOOL CheckForIEAKRestriction(HINSTANCE hInstance)
{
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,
        IEAK_RESTRICTION_REGKEY,&hkey))
    {
        dwSize = sizeof(dwData);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,IEAK_RESTRICTION_REGKEY_VALUE,0,&dwType,
            (LPBYTE)&dwData,&dwSize))
        {
            if (dwData)
            {   
                TCHAR szIEAKDenied[MAX_PATH];
                TCHAR szIEAKDeniedTitle[MAX_PATH];
                LoadString(hInstance, IDS_IEAK_ACCESS_DENIED, szIEAKDenied, MAX_PATH);
                LoadString(hInstance, IDS_IEAK_ACCESS_DENIED_TITLE, szIEAKDeniedTitle, MAX_PATH);
                MessageBox(NULL, szIEAKDenied, szIEAKDeniedTitle, MB_OK | MB_ICONSTOP);
                bRC = TRUE;
            }
        }
   }

   if (hkey)
        RegCloseKey(hkey);

    return bRC;
}

/*******************************************************************

	NAME:		WinMain

	SYNOPSIS:	App entry point

********************************************************************/
int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,
	LPSTR lpCmdLine,int nCmdShow)
{
    BOOL bReboot = FALSE;
    
#ifdef UNICODE
    // Initialize the C runtime locale to the system locale.
    setlocale(LC_ALL, "");
#endif

	// only allow one instance of wizard
	// note: hPrevInstance is always NULL for Win32 apps, so need to look
	// for existing window

    HANDLE hSemaphore = NULL;
	hSemaphore = CreateSemaphore(NULL, 1, 1, ICW_ELSE_SEMAPHORE);
	DWORD dwErr = GetLastError();
	if ( ERROR_ALREADY_EXISTS == dwErr )
	{
		IsAnotherComponentRunning32( FALSE );
		// every instance should close its own semaphore handle
		goto WinMainExit;
	}
	else
	{
		if( IsAnotherComponentRunning32( TRUE ) )
			goto WinMainExit;
	}

    //
    // remove the batch files if we are running of NT and
    // started of 1
    //
    if (IsNT ())
        DeleteStartUpCommand();

    if (!DoesUserHaveAdminPrivleges(hInstance))
        //no, bail.
        goto WinMainExit;

    if (CheckForIEAKRestriction(hInstance))
        //yes, bail.
        goto WinMainExit;

    //
	// call our DLL to run the wizard
    //
#ifdef UNICODE
        TCHAR szCmdLine[MAX_PATH+1];
        mbstowcs(szCmdLine, lpCmdLine, MAX_PATH+1);
	LaunchSignupWizard(szCmdLine, nCmdShow, &bReboot);
#else
	LaunchSignupWizard(lpCmdLine, nCmdShow, &bReboot);
#endif

    //
    // we should reboot, if the flag is set
    //
    if (TRUE == bReboot)
    {
        //
        // as the user if we would like to reboot at this time
        //
        TCHAR szMessage[256];
        TCHAR szTitle[256];
        LoadSz (IDS_WANTTOREBOOT, szMessage, sizeof (szMessage));
        LoadSz (IDS_WIZ_WINDOW_NAME, szTitle, sizeof (szTitle));

	    if (IDYES == MessageBox(NULL, szMessage, szTitle, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2))

		{
            SetRunOnce ();
		    if (!FGetSystemShutdownPrivledge() ||
					!ExitWindowsEx(EWX_REBOOT,0))
	        {
                
                TCHAR szFailMessage[256];
                LoadSz (IDS_EXITFAILED, szFailMessage, sizeof (szFailMessage));
	            MessageBox(NULL, szFailMessage, szTitle, MB_ICONERROR | MB_OK);

		    }

			//
			// ChrisK Olympus 4212, Allow Inetwiz to exit on restart
			//
            //else
            //{
            //    //      
            //    //  We will wait for the System to release all
            //    //  resources, 5 minutes should be more than 
            //    //  enough for this 
            //    //  - MKarki (4/22/97)  Fix for Bug #3109
            //    //
            //    Sleep (300000);
            //}
		}
    }


WinMainExit:
	if( hSemaphore ) 
		CloseHandle(hSemaphore);

	return 0;

}

/*******************************************************************

	NAME:		LoadSz

	SYNOPSIS:	Loads specified string resource into buffer

	EXIT:		returns a pointer to the passed-in buffer

	NOTES:		If this function fails (most likely due to low
				memory), the returned buffer will have a leading NULL
				so it is generally safe to use this without checking for
				failure.

********************************************************************/
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
	ASSERT(lpszBuf);

	// Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( ghInstance, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}



#ifdef WIN32
//+---------------------------------------------------------------------------
//
//  Function:   IsAnotherComponentRunning32()
//
//  Synopsis:   Checks if there's another ICW component already
//				running.  If so, it will set focus to that component's window.
//
//				This functionality is needed by all of our .exe's.  However,
//				the actual components to check for differ between .exe's.
//				The comment COMPONENT SPECIFIC designates lines of code
//				that vary between components' source code.
//
//				For ICWCONN1, we return FALSE if the following are already running:
//				  another instance of ICWCONN1, any other component
//
//  Arguments:  bCreatedSemaphore --
//					--	if TRUE, then this component has successfully created
//						it's semaphore, and we want to check whether other
//						components are running
//					--	if FALSE, then this component could not create
//						it's semaphore, and we want to find the already
//						running instance of this component
//
//	Returns:	TRUE if another component is already running
//				FALSE otherwise
//
//  History:    12/3/96	jmazner		Created, with help from IsAnotherInstanceRunning
//									in icwconn1\connmain.cpp
//
//----------------------------------------------------------------------------
BOOL IsAnotherComponentRunning32(BOOL bCreatedSemaphore)
{

	HWND hWnd = NULL;
	HANDLE hSemaphore = NULL;
	DWORD dwErr = 0;

	TCHAR szWindowName[SMALL_BUF_LEN+1];
	
	if( !bCreatedSemaphore )
	{
		// something other than conn1 is running,
		// let's find it!
		// COMPONENT SPECIFIC
		LoadSz(IDS_WIZ_WINDOW_NAME,szWindowName,sizeof(szWindowName));
		hWnd = FindWindow(DIALOG_CLASS_NAME, szWindowName);

		if( hWnd )
		{
			SetFocus(hWnd);
			SetForegroundWindow(hWnd);
		}

		// regardless of whether we found the window, return TRUE
		// since bCreatedSemaphore tells us this component was already running.
		return TRUE;
	}
	else
	{
		// check whether CONN1 is running
	    // The particular semaphores we look for are
		// COMPONENT SPECIFIC

		// is conn1 running?
		hSemaphore = CreateSemaphore(NULL, 1, 1, ICWCONN1_SEMAPHORE);
		dwErr = GetLastError();

		// close the semaphore right away since we have no use for it.
		if( hSemaphore )
			CloseHandle(hSemaphore);
		
		if( ERROR_ALREADY_EXISTS == dwErr )
		{
			// conn1 is running.
			// Bring the running instance's window to the foreground
			LoadSz(IDS_WIZ_WINDOW_NAME,szWindowName,sizeof(szWindowName));
			hWnd = FindWindow(DIALOG_CLASS_NAME, szWindowName);
			
			if( hWnd )
			{
				SetFocus(hWnd);
				SetForegroundWindow(hWnd);
			}

			return( TRUE );
		}

		// didn't find any other running components!
		return( FALSE );
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\autodial.h ===
#define IDI_WARN                        4001

#define IDC_ERROR                       4101
#define IDC_STATUS                      4102
#define IDC_CONNECT                     4103
#define IDC_PHONENUMBER                 4104

#define IDS_CONNECTING_TO               4401
#define IDS_STATUS                      4402
#define IDS_RETRY                       4403
#define IDS_REDIAL                      4404
#define IDS_BUSYREDIAL                  4405
#define IDS_REDIALCANCEL                4406
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\autodial.cpp ===
#include "isignup.h"

#include "dialutil.h"
#include "autodial.h"

#define NUMRETRIES      3

#define MAXHANGUPDELAY  20
#define ONE_SECOND      1000
#define TIMER_ID        0

#define SMALLBUFLEN 80

static HRASCONN g_hRasConn = NULL;
static UINT g_cDialAttempts = 0;
static UINT g_cHangupDelay = 0;
static TCHAR g_szEntryName[RAS_MaxEntryName + 1] = TEXT("");

static const TCHAR szBrowserClass1[] = TEXT("IExplorer_Frame");
static const TCHAR szBrowserClass2[] = TEXT("Internet Explorer_Frame");
static const TCHAR szBrowserClass3[] = TEXT("IEFrame");

static DWORD AutoDialConnect(HWND hDlg, LPRASDIALPARAMS lpDialParams);
static BOOL AutoDialEvent(HWND hDlg, RASCONNSTATE state, LPDWORD lpdwError);
static VOID SetDialogTitle(HWND hDlg, LPCTSTR pszConnectoidName);
static HWND FindBrowser(void);
static UINT RetryMessage(HWND hDlg, DWORD dwError);

#ifdef WIN16
extern "C" BOOL CALLBACK __export AutoDialDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
extern "C" BOOL CALLBACK __export PhoneNumberDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
extern "C" BOOL CALLBACK __export RetryDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
#else
INT_PTR CALLBACK AutoDialDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
INT_PTR CALLBACK PhoneNumberDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
INT_PTR CALLBACK RetryDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
#endif

#ifdef UNICODE
BOOL WINAPI AutoDialSignupW(HWND, LPCTSTR, DWORD, LPDWORD);
BOOL WINAPI AutoDialSignupA
(
    HWND    hwndParent,	
    LPCSTR  lpszEntry,
    DWORD   dwFlags,
    LPDWORD pdwRetCode
)
{
    TCHAR szEntry[RAS_MaxEntryName + 1];

    mbstowcs(szEntry, lpszEntry, lstrlenA(lpszEntry)+1);
    return AutoDialSignupW(hwndParent, szEntry, dwFlags, pdwRetCode);
}

BOOL WINAPI AutoDialSignupW
#else
BOOL WINAPI AutoDialSignupA
#endif
(
    HWND    hwndParent,	
    LPCTSTR lpszEntry,
    DWORD   dwFlags,
    LPDWORD pdwRetCode
)
{
    LoadRnaFunctions(hwndParent);

    lstrcpyn(g_szEntryName,  lpszEntry, SIZEOF_TCHAR_BUFFER(g_szEntryName));

    if (DialogBoxParam(
        ghInstance,
        TEXT("AutoDial"),
        hwndParent,
        AutoDialDlgProc,
        (DWORD_PTR)pdwRetCode) == -1)
    {
        *pdwRetCode = ERROR_CANCELLED;
    }

    if (ERROR_SUCCESS != *pdwRetCode)
    {
        HWND hwndBrowser;

        hwndBrowser = FindBrowser();

        if (NULL != hwndBrowser)
        {
            SendMessage(hwndBrowser, WM_CLOSE, 0, 0);
        }
    }

    UnloadRnaFunctions();

    return TRUE;
}

#ifdef WIN16
extern "C" BOOL CALLBACK __export AutoDialDlgProc(
#else
INT_PTR CALLBACK AutoDialDlgProc(
#endif
    HWND  hDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    static LPDWORD lpdwRet;
    static UINT uEventMsg;
    static LPRASDIALPARAMS lpDialParams = NULL;
    BOOL fPassword;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            lpdwRet = (LPDWORD)lParam;

            SetWindowPos(
                hDlg,
                HWND_TOPMOST,
                0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE);

            g_cDialAttempts = 0;

            SetDialogTitle(hDlg, g_szEntryName);

            CenterWindow(hDlg, GetParent(hDlg));

            uEventMsg = RegisterWindowMessageA( RASDIALEVENT );
            if (0 == uEventMsg)
            {
                uEventMsg =  WM_RASDIALEVENT;
            }

            g_hRasConn = NULL;

            lpDialParams = (LPRASDIALPARAMS)LocalAlloc(LPTR, sizeof(RASDIALPARAMS));

            if (NULL == lpDialParams)
            {
                *lpdwRet = ERROR_OUTOFMEMORY;
                return FALSE;
            }

            lpDialParams->dwSize = sizeof(RASDIALPARAMS);
            lstrcpyn(lpDialParams->szEntryName,  g_szEntryName, SIZEOF_TCHAR_BUFFER(lpDialParams->szEntryName));
            *lpdwRet = lpfnRasGetEntryDialParams(
                NULL,
                lpDialParams,
                &fPassword);
            if (ERROR_SUCCESS == *lpdwRet)
            {
                lstrcpyn(lpDialParams->szPassword, GetPassword(),
                    SIZEOF_TCHAR_BUFFER(lpDialParams->szPassword));

                GetPhoneNumber(g_szEntryName, lpDialParams->szPhoneNumber);

                if (DialogBoxParam(
                    ghInstance,
                    TEXT("PhoneNumber"),
                    hDlg,
                    PhoneNumberDlgProc,
                    (LPARAM)GetDisplayPhone(lpDialParams->szPhoneNumber)) != IDOK)
                {
                    *lpdwRet = ERROR_USER_DISCONNECTION;
                    EndDialog(hDlg, 0);
                }
                else
                {
                    PostMessage(hDlg, WM_COMMAND, IDC_CONNECT, 0);
                    *lpdwRet = ERROR_SUCCESS;
                }
            }

            if (ERROR_SUCCESS != *lpdwRet)
            {
                if (NULL != lpDialParams)
                {
                    LocalFree(lpDialParams);
                    lpDialParams = NULL;
                }
                EndDialog(hDlg, 0);
            }
            return TRUE;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDC_CONNECT:
                    ++g_cDialAttempts;

                    ShowWindow(hDlg, SW_NORMAL);
                    *lpdwRet = lpfnRasDial(
                        NULL,
                        NULL,
                        lpDialParams,
                        (DWORD) -1,
                        (LPVOID)hDlg,
                        &g_hRasConn);

                    if (ERROR_SUCCESS != *lpdwRet)
                    {
                        EndDialog(hDlg, 0);
                    }
                    return TRUE;
                    
                case IDCANCEL:
                    if (NULL != g_hRasConn)
                    {
                        lpfnRasHangUp(g_hRasConn);
                        g_hRasConn = NULL;
                    }
                    *lpdwRet = ERROR_USER_DISCONNECTION;
                    EndDialog(hDlg, 0);
                    return TRUE;

                case IDOK:
                    ShowWindow(hDlg, SW_HIDE);
                    if (MinimizeRNAWindow(g_szEntryName))
                    {
                        EndDialog(hDlg, 0);
                    }
                    else
                    {
                        // try again later
                        SetTimer(hDlg, TIMER_ID, ONE_SECOND, NULL);
                    }
                    return TRUE;
                default:
                    break;
            }

        case WM_TIMER:
            if (ERROR_SUCCESS == *lpdwRet)
            {
                // try to minimize one more time
                MinimizeRNAWindow(g_szEntryName);
                EndDialog(hDlg, 0);
            }
            else if (NULL != g_hRasConn)
            {
                DWORD dwRet;
                RASCONNSTATUS status;

                status.dwSize = sizeof(RASCONNSTATUS);
                dwRet = lpfnRasGetConnectStatus(g_hRasConn, &status);
                if (ERROR_INVALID_HANDLE != dwRet)
                {
                    if (0 == --g_cHangupDelay)
                    {
                        // wait no longer
                        EndDialog(hDlg, 0);
                    }
                    return TRUE;
                }
                // hang up is complete
                g_hRasConn = NULL;
                PostMessage(hDlg, WM_COMMAND, IDC_CONNECT, 0);
            }
            KillTimer(hDlg, TIMER_ID);
            return TRUE;

        case WM_DESTROY:
            if (NULL != lpDialParams)
            {
                LocalFree(lpDialParams);
                lpDialParams = NULL;
            }
            return TRUE;

        default:
            if (uMsg == uEventMsg)
            {
                *lpdwRet = (DWORD)lParam;
                // AutoDialEvent returns TRUE if complete
                if (AutoDialEvent(hDlg, (RASCONNSTATE)wParam, lpdwRet))
                {
                    if (ERROR_SUCCESS == *lpdwRet)
                    {
                        // we can't just exit, if we do we won't minimize window
                        PostMessage(hDlg, WM_COMMAND, IDOK, 0);
                    }
                    else
                    {
                        EndDialog(hDlg, 0);
                    }
                }
                return TRUE;
            }
    }

    return FALSE;
}



static BOOL AutoDialEvent(HWND hDlg, RASCONNSTATE state, LPDWORD lpdwError)
{

    TCHAR szMessage[SMALLBUFLEN + 1];

    _RasGetStateString(state, szMessage, SIZEOF_TCHAR_BUFFER(szMessage));
    SetDlgItemText(hDlg, IDC_STATUS, szMessage);

    if (ERROR_SUCCESS == *lpdwError)
    {
        if (state & RASCS_DONE)
        {
            // we're done dialing
            return TRUE;
        }
    }
    else
    {
        // looks like we got an error
        // if we haven't hungup already, hangup
        if (NULL != g_hRasConn)
        {
            g_cHangupDelay = MAXHANGUPDELAY;
            lpfnRasHangUp(g_hRasConn);
        }

        if ((ERROR_LINE_BUSY == *lpdwError) && (g_cDialAttempts < NUMRETRIES))
        {
            LoadString(ghInstance, IDS_BUSYREDIAL, szMessage, SIZEOF_TCHAR_BUFFER(szMessage));
            SetDlgItemText(hDlg, IDC_STATUS, szMessage);

            SetTimer(hDlg, TIMER_ID, ONE_SECOND, NULL);
        }
        else
        {
            TCHAR szError[160];
            TCHAR szFmt[80];
            TCHAR szMessage[240];

            ShowWindow(hDlg, SW_HIDE);

#if 1 
            lpfnRasGetErrorString(
                (int)*lpdwError,
                szError,
                sizeof(szError));

            LoadString(ghInstance, IDS_RETRY, szFmt, SIZEOF_TCHAR_BUFFER(szFmt));
            
            wsprintf(szMessage, szFmt, szError);
            if (MessageBox(
                    hDlg,
                    szMessage,
                    g_szEntryName,
                    MB_ICONEXCLAMATION |
                    MB_RETRYCANCEL) == IDRETRY)
#else
            if (DialogBoxParam(
                  ghInstance,
                  TEXT("Retry"),
                  hDlg,
                  RetryDlgProc,
                  (LPARAM)*lpdwError) == IDRETRY)
#endif
            {
                ShowWindow(hDlg, SW_SHOW);
                LoadString(ghInstance, IDS_REDIAL, szMessage, SIZEOF_TCHAR_BUFFER(szMessage));
                SetDlgItemText(hDlg, IDC_STATUS, szMessage);

                g_cDialAttempts = 0;

                SetTimer(hDlg, TIMER_ID, ONE_SECOND, NULL);
            }
            else
            {
                // user cancelled
                *lpdwError = ERROR_USER_DISCONNECTION;
                return TRUE;
            }
        }
    }

    // keep dialing
    return FALSE;
}


static VOID SetDialogTitle(HWND hDlg, LPCTSTR lpszConnectoidName)
{
	TCHAR szFmt[SMALLBUFLEN + 1];
	TCHAR szTitle[RAS_MaxEntryName + SMALLBUFLEN + 1];

    // load the title format ("connecting to <connectoid name>" from resource
    LoadString(ghInstance, IDS_CONNECTING_TO, szFmt, SIZEOF_TCHAR_BUFFER(szFmt));
    // build the title
    wsprintf(szTitle, szFmt, lpszConnectoidName);

    SetWindowText(hDlg, szTitle);
}



static HWND FindBrowser(void)
{
    HWND hwnd;

    //look for all the microsoft browsers under the sun

    if ((hwnd = FindWindow(szBrowserClass1, NULL)) == NULL)
    {
        if ((hwnd = FindWindow(szBrowserClass2, NULL)) == NULL)
        {
            hwnd = FindWindow(szBrowserClass3, NULL);
        }
    }

    return hwnd;
}
#ifdef WIN16
extern "C" BOOL CALLBACK __export RetryDlgProc(
#else
INT_PTR CALLBACK RetryDlgProc( 
#endif
    HWND  hDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            TCHAR szMessage[SMALLBUFLEN + 1];
            lpfnRasGetErrorString(
                (int)lParam,
                szMessage,
                sizeof(szMessage));

            SetDlgItemText(hDlg, IDC_ERROR, szMessage);

            SetWindowText(hDlg, g_szEntryName);

            CenterWindow(hDlg, GetParent(hDlg));

            return TRUE;
        }

        case WM_COMMAND:
            switch (wParam)
            {
                case IDRETRY:
                case IDCANCEL:
                    EndDialog(hDlg, wParam);
                    return TRUE;

                default:
                    break;
            }

        default:
            break;
    }

    return FALSE;
}


#ifdef WIN16
extern "C" BOOL CALLBACK __export PhoneNumberDlgProc(
#else
INT_PTR CALLBACK PhoneNumberDlgProc(
#endif
    HWND  hDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    static LPTSTR lpszPhone;

    switch (uMsg)
    {
        case WM_INITDIALOG:

            lpszPhone = (LPTSTR)lParam;
            
            SetDlgItemText(
                hDlg,
                IDC_PHONENUMBER,
                lpszPhone);

            SetWindowText(hDlg, g_szEntryName);

            CenterWindow(hDlg, GetParent(hDlg));

            return TRUE;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDOK:
                    GetDlgItemText(
                        hDlg,
                        IDC_PHONENUMBER,
                        lpszPhone,
                        RAS_MaxPhoneNumber - 5);
                case IDCANCEL:
                    EndDialog(hDlg, wParam);
                    return TRUE;

                default:
                    break;
            }

        default:
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetwiz\wizard.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//	WIZARD.H - central header file for Internet setup/signup wizard
//

//	HISTORY:
//	
//	11/20/94	jeremys	Created.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//

#ifndef _WIZARD_H_
#define _WIZARD_H_

#define STRICT                      // Use strict handle types
#define _SHELL32_

#ifdef DEBUG
// component name for debug spew
#define SZ_COMPNAME "INETWIZ: "
#endif // DEBUG

#include <windows.h>                
#include <windowsx.h>
#include <locale.h>

#include "..\inc\wizdebug.h"
#include "ids.h"

#ifdef WIN32

extern VOID
ProcessCmdLine (
        LPCTSTR lpszCmd
        );
//
// here the function declaration for the reboot functionality
//
extern 
DWORD 
SetRunOnce (
  VOID
  );

extern BOOL
SetStartUpCommand (
        LPTSTR lpCmd
        );

extern VOID
DeleteStartUpCommand (
        VOID
        );

extern BOOL 
FGetSystemShutdownPrivledge (
        VOID
        );

extern BOOL 
IsNT (
    VOID
    );

extern BOOL 
IsNT5 (
    VOID
    );

#endif // ifdef WIN32

#define SMALL_BUF_LEN	48

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

#ifndef NULL_TERM_TCHARS
#define NULL_TERM_TCHARS(sz);       {sz[ARRAYSIZE(sz)-1] = TEXT('\0');}
#endif

#endif // _WIZARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inetwiz\reboot.cpp ===
#include "wizard.h"
#define REGSTR_PATH_RUNONCE	TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")

#if !defined (WIN16)


#include  <shlobj.h>

static const TCHAR cszICW_StartFileName[] = TEXT("ICWStart.bat");
static const TCHAR cszICW_StartCommand[] = TEXT("@start ");
static const TCHAR cszICW_DummyWndName[] = TEXT("\"ICW\" ");
static const TCHAR cszICW_ExitCommand[] = TEXT("\r\n@exit");

static TCHAR g_cszAppName[257] = TEXT("inetwiz");

//+----------------------------------------------------------------------------
//
//	Function	SetRunOnce
//
//	Synopsis	Before we reboot we have to make sure this
//              executable is automatically run after startup
//
//	Arguments	none
//
//	Returns:    DWORD - status
//				
//  History:
//              MKarki      modified    - for INETWIZ.EXE
//
//-----------------------------------------------------------------------------
DWORD SetRunOnce (
        VOID
        )
{
    TCHAR szTemp[MAX_PATH + MAX_PATH + 1];
	TCHAR szTemp2[MAX_PATH + 1];
    DWORD dwRet = ERROR_CANTREAD;
    HKEY hKey;
	LPTSTR lpszFilePart;


    //
    // get the name of the executable
    //
    if (GetModuleFileName(NULL,szTemp2,ARRAYSIZE(szTemp2)) != 0)
    
    {

        NULL_TERM_TCHARS(szTemp2);
        GetShortPathName (szTemp2, szTemp, ARRAYSIZE(szTemp)); 
        NULL_TERM_TCHARS(szTemp);
      
        //
		// Determine Version of the OS we are runningon
        //
		OSVERSIONINFO osvi;
		ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
		osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
 		if (!GetVersionEx(&osvi))
		{
			ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
		}

        
		if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
		{
            //
            // if running on NT than copy the command into a
            //  batch file to be run after reboot
            //
			dwRet = SetStartUpCommand (szTemp);
		}
		else
		{
            //
            // in case of Win95 we can safely put our path
            // in the RUNONCE registry key
            //
			dwRet = RegCreateKey (
				        HKEY_LOCAL_MACHINE,
				        REGSTR_PATH_RUNONCE,
				        &hKey
                        );
			if (ERROR_SUCCESS == dwRet)
			{
				dwRet = RegSetValueEx (
					        hKey,
					        g_cszAppName,
					        0L,
					        REG_SZ,
					        (LPBYTE)szTemp,
					        sizeof(szTemp)
                            );
				RegCloseKey (hKey);
			}
		}
    }

    return (dwRet);

}   //  end of SetRunOnce function
//+----------------------------------------------------------------------------
//
//	Function	SetStartUpCommand
//
//	Synopsis	On an NT machine the RunOnce method is not reliable.  Therefore
//				we will restart the ICW by placing a .BAT file in the common
//				startup directory.
//
//	Arguments	lpCmd - command line used to restart the ICW
//
//	Returns:    BOOL - success/failure	
//				
//
//	History		1-10-97	ChrisK	Created
//              5/2/97  MKarki  modified  for INETWIZ
//
//-----------------------------------------------------------------------------
BOOL
SetStartUpCommand (
        LPTSTR lpCmd
        )
{
	BOOL bRC = FALSE;
	HANDLE hFile = INVALID_HANDLE_VALUE ;
	DWORD dwWLen;	// dummy variable used to make WriteFile happy
	TCHAR szCommandLine[MAX_PATH + 1];
	LPITEMIDLIST lpItemDList = NULL;
	HRESULT hr = ERROR_SUCCESS;
    BOOL    bRetVal = FALSE;
    IMalloc *pMalloc = NULL;

    //
	// build full filename
    //
	hr = SHGetSpecialFolderLocation(NULL,CSIDL_COMMON_STARTUP,&lpItemDList);
	if (ERROR_SUCCESS != hr)
		goto SetStartUpCommandExit;

	if (FALSE == SHGetPathFromIDList(lpItemDList, szCommandLine))
		goto SetStartUpCommandExit;

    
    //
    // Free up the memory allocated for LPITEMIDLIST
    // because seems like we are clobberig something later
    // by not freeing this
    //
    hr = SHGetMalloc (&pMalloc);
    if (SUCCEEDED (hr))
    {
        pMalloc->Free (lpItemDList);
        pMalloc->Release ();
    }

    //
	// make sure there is a trailing \ character
    //
	if ('\\' != szCommandLine[lstrlen(szCommandLine)-1])
		lstrcat(szCommandLine,TEXT("\\"));
	lstrcat(szCommandLine,cszICW_StartFileName);

    //
	// Open file
    //
	hFile = CreateFile (
                szCommandLine,
                GENERIC_WRITE,
                0,
                0,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                NULL
                );
	if (INVALID_HANDLE_VALUE == hFile)
		goto SetStartUpCommandExit;

    //
	// Write the restart commands to the file
    //
    
	bRetVal = WriteFile(
                      hFile,
                      cszICW_StartCommand,
                      lstrlen(cszICW_StartCommand),
                      &dwWLen,
                      NULL
                      );
    if (FALSE == bRetVal)
		goto SetStartUpCommandExit;

    //
	// 1/20/96	jmazner Normandy #13287
	// Start command considers the first thing it sees 
    // in quotes to be a window title
	// So, since our path is in quotes, put in a fake window title
    //
	bRetVal = WriteFile (
                    hFile,
                    cszICW_DummyWndName,
                    lstrlen(cszICW_DummyWndName),
                    &dwWLen,NULL
                    );
    if (FALSE == bRetVal)
		goto SetStartUpCommandExit;

    //
    // write the path name of the executable now
    //
    bRetVal = WriteFile (
                    hFile,
                    lpCmd,
                    lstrlen(lpCmd),
                    &dwWLen,
                    NULL
                    );
    if (FALSE == bRetVal)
		goto SetStartUpCommandExit;

    //
    // write the exit command in the next line
    //
    bRetVal = WriteFile (
                    hFile,
                    cszICW_ExitCommand,
                    lstrlen (cszICW_ExitCommand),
                    &dwWLen,
                    NULL
                    );
    if (FALSE == bRetVal)
		goto SetStartUpCommandExit;

	bRC = TRUE;

SetStartUpCommandExit:

    //
	// Close handle and exit
    //
	if (INVALID_HANDLE_VALUE != hFile)
		CloseHandle(hFile);

	return bRC;

}  // end of SetStartUpCommand function

//+----------------------------------------------------------------------------
//
//	Function:	DeleteStartUpCommand
//
//	Synopsis:	After restart the ICW we need to delete the .bat file from
//				the common startup directory
//
//	Arguements: None
//
//	Returns:	None
//
//	History:	1-10-97	ChrisK	Created
//
//-----------------------------------------------------------------------------
VOID DeleteStartUpCommand (
        VOID
        )
{
	TCHAR szStartUpFile[MAX_PATH + 1];
	LPITEMIDLIST lpItemDList = NULL;
	HRESULT hr = ERROR_SUCCESS;
    IMalloc *pMalloc = NULL;

    //
    // Sleep for 10 seconds
    //


	// build full filename
    //
	hr = SHGetSpecialFolderLocation(NULL,CSIDL_COMMON_STARTUP,&lpItemDList);
	if (ERROR_SUCCESS != hr)
		goto DeleteStartUpCommandExit;

	if (FALSE == SHGetPathFromIDList(lpItemDList, szStartUpFile))
		goto DeleteStartUpCommandExit;

    //
    // Free up the memory allocated for LPITEMIDLIST
    // because seems like we are clobberig something later
    // by not freeing this
    //
    hr = SHGetMalloc (&pMalloc);
    if (SUCCEEDED (hr))
    {
        pMalloc->Free (lpItemDList);
        pMalloc->Release ();
    }

    //
	// make sure there is a trailing \ character
    //
	if ('\\' != szStartUpFile[lstrlen(szStartUpFile)-1])
		lstrcat(szStartUpFile,TEXT("\\"));
	lstrcat(szStartUpFile,cszICW_StartFileName);

    //
    //  we dont care if the file does not exist
    //
	DeleteFile(szStartUpFile);

DeleteStartUpCommandExit:

	return;

}   //  end of DeleteStartUpCommand function

#endif // !defined (WIN16)

//+----------------------------------------------------------------------------
//
//	Function:	FGetSystemShutdownPrivledge
//
//	Synopsis:	For windows NT the process must explicitly ask for permission
//				to reboot the system.
//
//	Arguements:	none
//
//	Return:		TRUE - privledges granted
//				FALSE - DENIED
//
//	History:	8/14/96	ChrisK	Created
//
//	Note:		BUGBUG for Win95 we are going to have to softlink to these
//				entry points.  Otherwise the app won't even load.
//				Also, this code was originally lifted out of MSDN July96
//				"Shutting down the system"
//-----------------------------------------------------------------------------
BOOL 
FGetSystemShutdownPrivledge (
        VOID
        )
{
	HANDLE hToken = NULL;
	TOKEN_PRIVILEGES tkp;
 
	BOOL bRC = FALSE;

	if (IsNT())
	{
		// 
		// Get the current process token handle 
		// so we can get shutdown privilege. 
		//

		if (!OpenProcessToken(GetCurrentProcess(), 
				TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) 
				goto FGetSystemShutdownPrivledgeExit;

		//
		// Get the LUID for shutdown privilege.
		//

		ZeroMemory(&tkp,sizeof(tkp));
		LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
				&tkp.Privileges[0].Luid); 

		tkp.PrivilegeCount = 1;  /* one privilege to set    */ 
		tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 

		//
		// Get shutdown privilege for this process.
		//

		AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
			(PTOKEN_PRIVILEGES) NULL, 0); 

		if (ERROR_SUCCESS == GetLastError())
			bRC = TRUE;
	}
	else
	{
		bRC = TRUE;
	}

FGetSystemShutdownPrivledgeExit:
	if (hToken) CloseHandle(hToken);
	return bRC;
}

//+-------------------------------------------------------------------
//
//	Function:	IsNT
//
//	Synopsis:	findout If we are running on NT
//
//	Arguements:	none
//
//	Return:		TRUE -  Yes
//				FALSE - No
//
//--------------------------------------------------------------------
BOOL 
IsNT (
    VOID
    )
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);

}  //end of IsNT function call

//+-------------------------------------------------------------------
//
//	Function:	IsNT5
//
//	Synopsis:	findout If we are running on NT5
//
//	Arguements:	none
//
//	Return:		TRUE -  Yes
//				FALSE - No
//
//--------------------------------------------------------------------
BOOL 
IsNT5 (
    VOID
    )
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return ((VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId) && (OsVersionInfo.dwMajorVersion >= 5));

}  //end of IsNT function call
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\autodial.inc ===
/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_WARN                ICON    DISCARDABLE     "warning.ico"
//IDI_PHONE               ICON    DISCARDABLE     "phone.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

AUTODIAL DIALOG DISCARDABLE  0, 0, 200, 60
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION ""
FONT 8, "MS Shell Dlg"
BEGIN
    ICON            IDI_PHONE,IDC_STATIC,7,7,21,20
    LTEXT           "Status:",IDC_STATIC,37,7,23,12
    LTEXT           "Preparing to dial",IDC_STATUS,64,7,129,12
    PUSHBUTTON      "Cancel Signup",IDCANCEL,70,39,60,14
END

RETRY DIALOG DISCARDABLE  0, 0, 200, 60
STYLE DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
FONT 8, "MS Shell Dlg"
BEGIN
    ICON            IDI_WARN,IDC_STATIC,7,7,21,20,WS_GROUP
    LTEXT           "Static",IDC_ERROR,37,7,156,10
    LTEXT           "Would you like to redial or cancel signup?",IDC_STATIC,
                    37,19,156,10
    DEFPUSHBUTTON   "Redial",IDRETRY,36,39,60,14,WS_GROUP
    PUSHBUTTON      "Cancel Signup",IDCANCEL,108,39,60,14
END

PHONENUMBER DIALOG DISCARDABLE  0, 0, 200, 90
STYLE DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
FONT 8, "MS Shell Dlg"
BEGIN
    ICON            IDI_PHONE,IDC_STATIC,7,7,21,20,WS_GROUP
    LTEXT           "Please verify that the number below is correct for dialing.  If you need to dial a special number to get an outside line make sure that it is there.",
                    IDC_STATIC,40,7,153,34
    EDITTEXT        IDC_PHONENUMBER,40,40,88,14,ES_AUTOHSCROLL
    DEFPUSHBUTTON   "Dial Now",IDOK,32,69,60,14,WS_GROUP
    PUSHBUTTON      "Cancel Signup",IDCANCEL,108,69,60,14
END

/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_CONNECTING_TO       "Connecting to %s"
    IDS_STATUS              "Status: %s"
    IDS_RETRY               "%s\n\nWould you like to retry dialing or cancel signup?"
    IDS_REDIAL              "Preparing For Redial"
    IDS_BUSYREDIAL          "Line is busy - Preparing For Redial"
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\dialutil.h ===
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   dialutil.h
//
//  PURPOSE:  contains dialutil declarations
//


#ifndef _DIALUTIL_H
#define _DIALUTIL_H

#define IDS_RASCS                    100
#define IDS_OPENPORT                 IDS_RASCS+ 0
#define IDS_PORTOPENED               IDS_RASCS+ 1
#define IDS_CONNECTDEVICE            IDS_RASCS+ 2
#define IDS_DEVICECONNECTED          IDS_RASCS+ 3
#define IDS_ALLDEVICESCONNECTED      IDS_RASCS+ 4
#define IDS_AUTHENTICATE             IDS_RASCS+ 5
#define IDS_AUTHNOTIFY               IDS_RASCS+ 6
#define IDS_AUTHRETRY                IDS_RASCS+ 7
#define IDS_AUTHCALLBACK             IDS_RASCS+ 8
#define IDS_AUTHCHANGEPASSWORD       IDS_RASCS+ 9
#define IDS_AUTHPROJECT              IDS_RASCS+10
#define IDS_AUTHLINKSPEED            IDS_RASCS+11
#define IDS_AUTHACK                  IDS_RASCS+12
#define IDS_REAUTHENTICATE           IDS_RASCS+13
#define IDS_AUTHENTICATED            IDS_RASCS+14
#define IDS_PREPAREFORCALLBACK       IDS_RASCS+15
#define IDS_WAITFORMODEMRESET        IDS_RASCS+16
#define IDS_WAITFORCALLBACK          IDS_RASCS+17
#define IDS_INTERACTIVE              IDS_RASCS+18
#define IDS_RETRYAUTHENTICATION      IDS_RASCS+19
#define IDS_CALLBACKSETBYCALLER      IDS_RASCS+20
#define IDS_PASSWORDEXPIRED          IDS_RASCS+21
#define IDS_CONNECTED                IDS_RASCS+22
#define IDS_DISCONNECTED             IDS_RASCS+23
#define IDS_RASCS_END                IDS_DISCONNECTED
#define IDS_UNDEFINED_ERROR          IDS_RASCS_END+1

#define IDS_CONNECTED_TO             200


BOOL MinimizeRNAWindow(LPTSTR pszConnectoidName);
DWORD GetPhoneNumber(LPTSTR lpszEntryName, LPTSTR lpszPhoneNumber);
LPTSTR NEAR PASCAL GetDisplayPhone(LPTSTR szPhoneNum);
DWORD _RasGetStateString(RASCONNSTATE state, LPTSTR lpszState, DWORD cb);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\custom.cpp ===
//****************************************************************************
//
//  Module:     ISIGNUP.EXE
//  File:       custom.c
//  Content:    This file contains all the functions that handle importing
//              connection information.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//          some of this code started its life in ixport.c in RNAUI.DLL
//          my thanks to viroont
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "isignup.h"


#pragma data_seg(".rdata")

static const TCHAR cszCustomSection[]      = TEXT("Custom");
static const TCHAR cszFileName[]           = TEXT("Custom_File");
static const TCHAR cszRun[]                = TEXT("Run");
static const TCHAR cszArgument[]           = TEXT("Argument");
static const TCHAR cszCustomFileSection[]  = TEXT("Custom_File");

static const TCHAR cszNull[] = TEXT("");

#pragma data_seg()

//****************************************************************************
// DWORD NEAR PASCAL ImportCustomFile(LPSTR szImportFile)
//
// This function imports the custom file
//
// History:
//  Mon 21-Mar-1996 12:40:00  -by-  Mark MacLin [mmaclin]
// Created.
//****************************************************************************

DWORD ImportCustomFile(LPCTSTR lpszImportFile)
{
  TCHAR   szFile[_MAX_PATH];
  TCHAR   szTemp[_MAX_PATH];

  // If a custom file name does not exist, do nothing
  //
  if (GetPrivateProfileString(cszCustomSection,
                              cszFileName,
                              cszNull,
                              szTemp,
                              _MAX_PATH,
                              lpszImportFile) == 0)
  {
    return ERROR_SUCCESS;
  };

  GetWindowsDirectory(szFile, _MAX_PATH);
  if (*CharPrev(szFile, szFile + lstrlen(szFile)) != '\\')
  {
    lstrcat(szFile, TEXT("\\"));
  }
  lstrcat(szFile, szTemp);
  
  return (ImportFile(lpszImportFile, cszCustomFileSection, szFile));

}

DWORD ImportCustomInfo(
        LPCTSTR lpszImportFile,
        LPTSTR lpszExecutable,
        DWORD cbExecutable,
        LPTSTR lpszArgument,
        DWORD cbArgument)
{
    GetPrivateProfileString(cszCustomSection,
                              cszRun,
                              cszNull,
                              lpszExecutable,
                              (int)cbExecutable,
                              lpszImportFile);

    GetPrivateProfileString(cszCustomSection,
                              cszArgument,
                              cszNull,
                              lpszArgument,
                              (int)cbArgument,
                              lpszImportFile);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\dialutil.cpp ===
#ifdef WIN16 
typedef int WCHAR;
#include <memory.h>
#include <ietapi.h>
#endif
#include "isignup.h"
#include <tapi.h>
#include "dialutil.h"

#define CANONICAL_CAP      TEXT("+%d (%s) %s")
#define CANONICAL_CXP      TEXT("+%d %s")

#define TAPI_VERSION        0x00010004

#define SMALLBUFLEN 80
#define ASSERT(c)
#define TRACE_OUT(c)

#define lstrnicmp(sz1, sz2, cch)          (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, sz1, cch, sz2, cch) - 2)
#define lstrncmp(sz1, sz2, cch)           (CompareString(LOCALE_USER_DEFAULT, 0, sz1, cch, sz2, cch) - 2)

static const TCHAR szRnaAppWindowClass[] = TEXT("#32770");	// hard coded dialog class name

#ifdef WIN16

#define NORM_IGNORECASE         0x00000001  /* ignore case */ 
#define LOCALE_USER_DEFAULT		0

int CompareString(
    LCID Locale,	// locale identifier 
    DWORD dwCmpFlags,	// comparison-style options 
    LPCTSTR lpString1,	// pointer to first string 
    int cchCount1,	// size, in bytes or characters, of first string 
    LPCTSTR lpString2,	// pointer to second string 
    int cchCount2 	// size, in bytes or characters, of second string  
   )
{ 
	//
	// This is kind of tricky, but it should work.  We'll save the
	// characters at the end of the strings, put a NULL in their
	// place, use lstrcmp and lstrcmpi, and then replace the
	// characters.
	//
	TCHAR cSave1, cSave2;    
	int iRet;
	
	cSave1 = lpString1[cchCount1];
	lpString1[cchCount1] = '\0';
	cSave2 = lpString2[cchCount2];
	lpString2[cchCount2] = '\0';
	
	if (dwCmpFlags & NORM_IGNORECASE)
		iRet = lstrcmpi(lpString1, lpString2) + 2;
	else
		iRet = lstrcmp(lpString1, lpString2) + 2;
	
	lpString1[cchCount1] = cSave1;
	lpString2[cchCount2] = cSave2;
                                 
	return iRet;
}
#endif

void CALLBACK LineCallbackProc (DWORD handle, DWORD dwMsg, DWORD dwInst,
                                DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);

static HWND hwndFound = NULL;

static BOOL CALLBACK MyEnumWindowsProc(HWND hwnd, LPARAM lparam)
{
	TCHAR szTemp[SMALLBUFLEN+2];
	LPTSTR pszTitle;
	UINT uLen1, uLen2;

	if(!IsWindowVisible(hwnd))
		return TRUE;
	if(GetClassName(hwnd, szTemp, SMALLBUFLEN)==0)
		return TRUE; // continue enumerating
	if(lstrcmp(szTemp, szRnaAppWindowClass)!=0)
		return TRUE;
	if(GetWindowText(hwnd, szTemp, SMALLBUFLEN)==0)
		return TRUE;
	szTemp[SMALLBUFLEN] = 0;
	uLen1 = lstrlen(szTemp);
	if (uLen1 > 5)
		uLen1 -= 5; // skip last 5 chars of title (avoid "...")
	pszTitle = (LPTSTR)lparam;
	ASSERT(pszTitle);
	uLen2 = lstrlen(pszTitle);
	TRACE_OUT(("Title=(%s), len=%d, Window=(%s), len=%d\r\n", pszTitle, uLen2, szTemp, uLen1));
	if(uLen2 < uLen1)
		return TRUE;
	if(lstrnicmp(pszTitle, szTemp, uLen1)!=0)
		return TRUE;
	hwndFound = hwnd;
	return FALSE;
}

static HWND MyFindRNAWindow(LPTSTR pszTitle)
{
	DWORD dwRet;
	hwndFound = NULL;
	dwRet = EnumWindows((WNDENUMPROC)(&MyEnumWindowsProc), (LPARAM)pszTitle);
	TRACE_OUT(("EnumWindows returned %d\r\n", dwRet));
	return hwndFound;
}


/*******************************************************************

	NAME:		MinimizeRNAWindow

	SYNOPSIS:	Finds and minimizes the annoying RNA window

    ENTRY:		pszConnectoidName - name of connectoid launched

********************************************************************/
BOOL MinimizeRNAWindow(LPTSTR pszConnectoidName)
{
	HWND hwndRNAApp;
	TCHAR szFmt[SMALLBUFLEN + 1];
	TCHAR szTitle[RAS_MaxEntryName + SMALLBUFLEN + 1];
	
	// load the title format ("connected to <connectoid name>" from resource
	LoadString(ghInstance, IDS_CONNECTED_TO, szFmt, SIZEOF_TCHAR_BUFFER(szFmt));
	// build the title
	wsprintf(szTitle, szFmt, pszConnectoidName);

	hwndRNAApp=MyFindRNAWindow((LPTSTR)szTitle);
	if(hwndRNAApp)
	{
		// minimize the RNA window
		ShowWindow(hwndRNAApp,SW_MINIMIZE);
        return TRUE;
	}
    return FALSE;
}

//****************************************************************************
// static LPTSTR NEAR PASCAL GetDisplayPhone (LPTSTR)
//
// This function returns the pointer to displayable phone number. It stripped
//   all the prefixes we do not want to show to the user.
//
// History:
//  Tue 26-Jul-1994 16:07:00  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

LPTSTR NEAR PASCAL GetDisplayPhone (LPTSTR szPhoneNum)
{
  // Check whether the first string is the know prefix
  //
  if ((*szPhoneNum == 'T') || (*szPhoneNum == 'P'))
  {
    // It is the prefix
    //
    szPhoneNum++;

    // The first displayable number is not white space after prefix
    //
    while ((*szPhoneNum == ' ') || (*szPhoneNum == '\t'))
      szPhoneNum++;
  };
  return szPhoneNum;
}

void CALLBACK LineCallbackProc (DWORD handle, DWORD dwMsg, DWORD dwInst,
                                DWORD dwParam1, DWORD dwParam2, DWORD dwParam3)
{
}

//****************************************************************************
// TranslateCanonicalAddress()
//
// Function: This function translate a canonical address to a dialable address.
//
// Returns:  SUCCESS or an error code
//
//****************************************************************************

static DWORD NEAR PASCAL TranslateCanonicalAddress(DWORD dwID, LPTSTR szCanonical,
                                            LPTSTR szDialable, DWORD cb)
{
  DWORD dwRet;

#ifdef WIN16

	char szBuffer[1024];
	LPLINETRANSLATEOUTPUT lpLine;
	
	memset(&szBuffer[0], 0, sizeof(szBuffer));
	lpLine = (LPLINETRANSLATEOUTPUT) & szBuffer[0];
	lpLine->dwTotalSize = sizeof(szBuffer);
	dwRet = IETapiTranslateAddress(NULL, szCanonical, 0L, 0L, lpLine);
	if (0 == dwRet)
		lstrcpy(szDialable, &szBuffer[lpLine->dwDialableStringOffset+3]);
		
#else //WIN16

  LINETRANSLATEOUTPUT lto, FAR* lplto;
  DWORD cDevices;
  HLINEAPP hApp;
  
  if ((dwRet = lineInitialize(&hApp, ghInstance,
                                (LINECALLBACK)LineCallbackProc,
                                NULL, &cDevices)) == SUCCESS)
  {

    // Get the actual buffer size
    lto.dwTotalSize = sizeof(lto);
    if ((dwRet = lineTranslateAddress(hApp, dwID,
                                      TAPI_VERSION, szCanonical, 0,
                                      LINETRANSLATEOPTION_CANCELCALLWAITING,
                                      &lto)) == SUCCESS)
    {
      // Allocate the dialable number buffer
      if ((lplto = (LPLINETRANSLATEOUTPUT)LocalAlloc(LMEM_FIXED, lto.dwNeededSize))
          != NULL)
      {
        // Translate the phone number
        lplto->dwTotalSize = lto.dwNeededSize;
        if ((dwRet = lineTranslateAddress(hApp, dwID,
                                          TAPI_VERSION, szCanonical, 0,
                                          LINETRANSLATEOPTION_CANCELCALLWAITING,
                                          lplto)) == SUCCESS)
        {
          LPTSTR szPhone;

          szPhone = (LPTSTR)(((LPBYTE)lplto)+lplto->dwDialableStringOffset);
          lstrcpyn(szDialable, szPhone, (int)cb);
        }
        else
          dwRet = ERROR_TAPI_CONFIGURATION;


        LocalFree(lplto);
      }
      else
        dwRet = ERROR_OUTOFMEMORY;
    }
    else
      dwRet = ERROR_TAPI_CONFIGURATION;
  }
  else
    dwRet = ERROR_TAPI_CONFIGURATION;

  lineShutdown(hApp);
  
#endif	// #ifdef WIN16 ... #else ...

  return dwRet;
}

//****************************************************************************
// DWORD NEAR PASCAL BuildPhoneString (LPBYTE, LPPHONENUM)
//
// This function builds a phone number string from the phone number struct
//
// History:
//  Mon 14-Mar-1994 13:10:44  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

static DWORD NEAR PASCAL BuildPhoneString (LPTSTR szPhoneNum, LPRASENTRY lpRasEntry)
{
  if (*lpRasEntry->szAreaCode != '\0')
  {
    wsprintf(szPhoneNum, CANONICAL_CAP, lpRasEntry->dwCountryCode,
             lpRasEntry->szAreaCode, lpRasEntry->szLocalPhoneNumber);
  }
  else
  {
    wsprintf(szPhoneNum, CANONICAL_CXP, lpRasEntry->dwCountryCode,
             lpRasEntry->szLocalPhoneNumber);
  };
  return SUCCESS;
};

//****************************************************************************
// BOOL NEAR PASCAL TranslatePhoneNumber(LPTSTR, LPPHONENUM, LPTSTR)
//
// Translate phone number into a dialble string.
//
// Returns TRUE if successful, FALSE if use default.
//
// History:
//   Fri 17-Jun-1994 08:42:49  -by-  Viroon  Touranachun [viroont]
// Created
//****************************************************************************

static BOOL NEAR PASCAL TranslatePhoneNumber(LPRASENTRY lpRasEntry, LPTSTR szPhoneNumber)
{
  TCHAR    szOrgPhone[RAS_MaxPhoneNumber+1];

  // Do we need to use the addrees book phone number?
  //
  if (lpRasEntry != NULL)
  {
    // Yes! Do we need to translate anything?
    //
    if (lpRasEntry->dwCountryID == 0)
    {
      // No! we dial as is.
      //
      lstrcpyn(szOrgPhone, lpRasEntry->szLocalPhoneNumber, SIZEOF_TCHAR_BUFFER(szOrgPhone));
    }
    else
    {
      // Yes! build the phone number
      //
      BuildPhoneString (szOrgPhone, lpRasEntry);
    };
  }
  else
  {
    // No! we have a overwritten phone number
    //
    ASSERT(lstrlen(szPhoneNumber) != 0);
    lstrcpyn(szOrgPhone, szPhoneNumber, SIZEOF_TCHAR_BUFFER(szOrgPhone));
  };

  // Attempt address translation
  //
  if (TranslateCanonicalAddress(0, szOrgPhone,
                            szPhoneNumber, RAS_MaxPhoneNumber+1)
  != ERROR_SUCCESS)
  {
    // Translation fails, use default phone number
    //
    if (lpRasEntry != NULL)
    {
      // Use entry's local phone number
      //
      lstrcpy(szPhoneNumber, lpRasEntry->szLocalPhoneNumber);
    }
    else
    {
      // Restore the original phone number
      //
      lstrcpy(szPhoneNumber, szOrgPhone);
    };
    return FALSE;
  };

  return TRUE;
}


DWORD GetPhoneNumber(LPTSTR lpszEntryName, LPTSTR lpszPhoneNumber)
{
    DWORD dwEntrySize = 0;
    DWORD dwSize = 0;
    DWORD dwRet;
    LPRASENTRY lpRasEntry = NULL;

    // get size needed for RASENTRY struct
    lpfnRasGetEntryProperties(
        NULL,
        lpszEntryName,
	    NULL,
        &dwEntrySize,
        NULL,
        &dwSize);

    lpRasEntry = (LPRASENTRY)LocalAlloc(LPTR, dwEntrySize + dwSize);

    if (NULL == lpRasEntry)
    {
        dwRet = ERROR_OUTOFMEMORY;
    }
    else
    {
        lpRasEntry->dwSize = dwEntrySize;

        dwRet = lpfnRasGetEntryProperties(
            NULL,
            lpszEntryName,
	        (LPBYTE)lpRasEntry,
            &dwEntrySize,
            ((LPBYTE)lpRasEntry) + dwEntrySize,
            &dwSize);

        if (ERROR_SUCCESS == dwRet)
        {
            TranslatePhoneNumber(lpRasEntry, lpszPhoneNumber);
        }

        LocalFree(lpRasEntry);
    }

    return dwRet;
}

DWORD _RasGetStateString(RASCONNSTATE state, LPTSTR lpszState, DWORD cb)
{
    UINT idString;

    switch(state)
    {
        case RASCS_OpenPort:
            idString  = IDS_OPENPORT;
            break;
        case RASCS_PortOpened:
            idString = IDS_PORTOPENED;            
            break;
        case RASCS_ConnectDevice:
            idString = IDS_CONNECTDEVICE;        
            break;
        case RASCS_DeviceConnected:
            idString = IDS_DEVICECONNECTED;       
            break;
        case RASCS_AllDevicesConnected:
            idString = IDS_ALLDEVICESCONNECTED;   
            break;
        case RASCS_Authenticate:
            idString = IDS_AUTHENTICATE;          
            break;
        case RASCS_AuthNotify:
            idString = IDS_AUTHNOTIFY;            
            break;
        case RASCS_AuthRetry:
            idString = IDS_AUTHRETRY;             
            break;
        case RASCS_AuthCallback:
            idString = IDS_AUTHCALLBACK;          
            break;
        case RASCS_AuthChangePassword:
            idString = IDS_AUTHCHANGEPASSWORD;    
            break;
        case RASCS_AuthProject:
            idString = IDS_AUTHPROJECT;           
            break;
        case RASCS_AuthLinkSpeed:
            idString = IDS_AUTHLINKSPEED;         
            break;
        case RASCS_AuthAck: 
            idString = IDS_AUTHACK;               
            break;
        case RASCS_ReAuthenticate:
            idString = IDS_REAUTHENTICATE;        
            break;
        case RASCS_Authenticated:
            idString = IDS_AUTHENTICATED;         
            break;
        case RASCS_PrepareForCallback:
            idString = IDS_PREPAREFORCALLBACK;    
            break;
        case RASCS_WaitForModemReset:
            idString = IDS_WAITFORMODEMRESET;     
            break;
        case RASCS_WaitForCallback:
            idString = IDS_WAITFORCALLBACK;       
            break;
        case RASCS_Interactive:
            idString = IDS_INTERACTIVE;           
            break;
        case RASCS_RetryAuthentication: 
            idString = IDS_RETRYAUTHENTICATION;            
            break;
        case RASCS_CallbackSetByCaller: 
            idString = IDS_CALLBACKSETBYCALLER;   
            break;
        case RASCS_PasswordExpired:
            idString = IDS_PASSWORDEXPIRED;       
            break;
        case RASCS_Connected:
            idString = IDS_CONNECTED;            
            break;
        case RASCS_Disconnected:
            idString = IDS_DISCONNECTED;          
            break;
        default:
            idString = IDS_UNDEFINED_ERROR;
            break;
    }
    if (LoadString(ghInstance, idString, lpszState, (int)cb))
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\enumodem.h ===
// jmazner  pinched from inetcfg\rnacall.h class ENUM_MODEM

class CEnumModem
{
private:
  DWORD         m_dwError;
  DWORD         m_dwNumEntries;
  DWORD         m_dwIndex;
  LPRASDEVINFO  m_lpData;
public:
  CEnumModem();
  ~CEnumModem();
  DWORD ReInit();
  TCHAR * Next();
  TCHAR * GetDeviceTypeFromName(LPTSTR szDeviceName);
  TCHAR * GetDeviceNameFromType(LPTSTR szDeviceType);
  BOOL VerifyDeviceNameAndType(LPTSTR szDeviceName, LPTSTR szDeviceType);
  DWORD GetNumDevices() { return m_dwNumEntries; }
  DWORD GetError()  { return m_dwError; }
  void  ResetIndex() { m_dwIndex = 0; }
};

// from inetcfg\export.cpp
// structure to pass data back from IDD_CHOOSEMODEMNAME handler
typedef struct tagCHOOSEMODEMDLGINFO
{
  TCHAR szModemName[RAS_MaxDeviceName + 1];
} CHOOSEMODEMDLGINFO, * PCHOOSEMODEMDLGINFO;

INT_PTR CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL ChooseModemDlgInit(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);
BOOL ChooseModemDlgOK(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);


//rnacall.cpp
HRESULT InitModemList(HWND hCB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\enumodem.cpp ===
/*-----------------------------------------------------------------------------
	enumodem.cpp

	Holds code that deals with the "Choose a modem" dialog needed when user has
	multiple modems installed

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		jmazner Jeremy Mazner

	History:
		10/19/96        jmazner Created, cloned almost verbatim from 
							INETCFG's rnacall.cpp and export.cpp    

-----------------------------------------------------------------------------*/


#include "isignup.h"
#include "enumodem.h"

#include <WINDOWSX.H>

//+---------------------------------------------------------------------------
//
//      Function:       ProcessDBCS
//
//      Synopsis:       Converts control to use DBCS compatible font
//                              Use this at the beginning of the dialog procedure
//      
//                              Note that this is required due to a bug in Win95-J that prevents
//                              it from properly mapping MS Shell Dlg.  This hack is not needed
//                              under winNT.
//
//      Arguments:      hwnd - Window handle of the dialog
//                              cltID - ID of the control you want changed.
//
//      Returns:        ERROR_SUCCESS
// 
//      History:        4/31/97 a-frankh        Created
//                              5/13/97 jmazner         Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
#if defined(WIN16)
	return;
#else
	HFONT hFont = NULL;

	if( IsNT() )
	{
		return;
	}

	hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
	if (hFont == NULL)
		hFont = (HFONT) GetStockObject(SYSTEM_FONT);
	if (hFont != NULL)
		SendMessage(GetDlgItem(hDlg,ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
#endif
}


/*******************************************************************

  NAME:    CEnumModem::CEnumModem

  SYNOPSIS:  Constructor for class to enumerate modems

  NOTES:    Useful to have a class rather than C functions for
	this, due to how the enumerators function

********************************************************************/
CEnumModem::CEnumModem() :
  m_dwError(ERROR_SUCCESS),m_lpData(NULL),m_dwIndex(0)
{
  DWORD cbSize = 0;

  if (!LoadRnaFunctions(NULL))
	  m_dwError = GetLastError();
  else
	  // Use the reinit member function to do the work.
	  this->ReInit();
}


/*******************************************************************

  NAME:     CEnumModem::ReInit

  SYNOPSIS: Re-enumerate the modems, freeing the old memory.

********************************************************************/
DWORD CEnumModem::ReInit()
{
  DWORD cbSize = 0;

  // Clean up the old list
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
  m_dwNumEntries = 0;
  m_dwIndex = 0;

  // call RasEnumDevices with no buffer to find out required buffer size
  m_dwError = (lpfnRasEnumDevices)(NULL, &cbSize, &m_dwNumEntries);

  // Special case check to work around RNA bug where ERROR_BUFFER_TOO_SMALL
  // is returned even if there are no devices.
  // If there are no devices, we are finished.
  if (0 == m_dwNumEntries)
  {
    m_dwError = ERROR_SUCCESS;
    return m_dwError;
  }

  // Since we were just checking how much mem we needed, we expect
  // a return value of ERROR_BUFFER_TOO_SMALL, or it may just return
  // ERROR_SUCCESS (ChrisK  7/9/96).
  if (ERROR_BUFFER_TOO_SMALL != m_dwError && ERROR_SUCCESS != m_dwError)
  {
    return m_dwError;
  }

  // Allocate the space for the data
  m_lpData = (LPRASDEVINFO) new TCHAR[cbSize];
  if (NULL == m_lpData)
  {
	  DebugOut("ICWCONN1: CEnumModem: Failed to allocate device list buffer\n");
	  m_dwError = ERROR_NOT_ENOUGH_MEMORY;
	  return m_dwError;
  }
  m_lpData->dwSize = sizeof(RASDEVINFO);
  m_dwNumEntries = 0;

  // enumerate the modems into buffer
  m_dwError = (lpfnRasEnumDevices)(m_lpData, &cbSize,
    &m_dwNumEntries);

  if (ERROR_SUCCESS != m_dwError)
	  return m_dwError;
    
    //
    // ChrisK Olympus 4560 do not include VPN's in the list
    //
    DWORD dwTempNumEntries;
    DWORD idx;
    LPRASDEVINFO lpNextValidDevice;

    dwTempNumEntries = m_dwNumEntries;
    lpNextValidDevice = m_lpData;

	//
	// Walk through the list of devices and copy non-VPN device to the first
	// available element of the array.
	//
	for (idx = 0;idx < dwTempNumEntries; idx++)
	{
		if (0 != lstrcmpi(TEXT("VPN"),m_lpData[idx].szDeviceType))
		{
			if (lpNextValidDevice != &m_lpData[idx])
			{
				MoveMemory(lpNextValidDevice ,&m_lpData[idx],sizeof(RASDEVINFO));
			}
			lpNextValidDevice++;
		}
		else
		{
			m_dwNumEntries--;
		}
	}

	return m_dwError;
}


/*******************************************************************

  NAME:    CEnumModem::~CEnumModem

  SYNOPSIS:  Destructor for class

********************************************************************/
CEnumModem::~CEnumModem()
{
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
}

/*******************************************************************

  NAME:     CEnumModem::Next

  SYNOPSIS: Enumerates next modem 

  EXIT:     Returns a pointer to device info structure.  Returns
	    NULL if no more modems or error occurred.  Call GetError
	    to determine if error occurred.

********************************************************************/
TCHAR * CEnumModem::Next()
{
  if (m_dwIndex < m_dwNumEntries)
  {
    return m_lpData[m_dwIndex++].szDeviceName;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceTypeFromName

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device type string for first
	    device name that matches.  Returns
	    NULL if no device with specified name is found

********************************************************************/

TCHAR * CEnumModem::GetDeviceTypeFromName(LPTSTR szDeviceName)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return m_lpData[dwIndex].szDeviceType;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceNameFromType

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device name string for first
	    device type that matches.  Returns
	    NULL if no device with specified Type is found

********************************************************************/

TCHAR * CEnumModem::GetDeviceNameFromType(LPTSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType))
    {
      return m_lpData[dwIndex].szDeviceName;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::VerifyDeviceNameAndType

  SYNOPSIS: Determines whether there is a device with the name
	    and type given.

  EXIT:     Returns TRUE if the specified device was found, 
	    FALSE otherwise.

********************************************************************/

BOOL CEnumModem::VerifyDeviceNameAndType(LPTSTR szDeviceName, LPTSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType) &&
      !lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return TRUE;
    }
    dwIndex++;
  }

  return FALSE;
}





/*******************************************************************

  NAME:     ChooseModemDlgProc

  SYNOPSIS: Dialog proc for choosing modem

********************************************************************/

INT_PTR CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
	BOOL fRet;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			// lParam contains pointer to CHOOSEMODEMDLGINFO struct, set it
			// in window data
			//Assert(lParam);
			SetWindowLongPtr(hDlg,DWLP_USER,lParam);
			fRet = ChooseModemDlgInit(hDlg,(PCHOOSEMODEMDLGINFO) lParam);
			if (!fRet)
			{
				// An error occured.
				EndDialog(hDlg,FALSE);
			}
#if !defined(WIN16)
			SetForegroundWindow(hDlg);
#endif
			return fRet;
			break;
		
		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
			case IDC_CMDOK:
				{
					// get data pointer from window data
					PCHOOSEMODEMDLGINFO pChooseModemDlgInfo =
						(PCHOOSEMODEMDLGINFO) GetWindowLongPtr(hDlg,DWLP_USER);
					//Assert(pChooseModemDlgInfo);

					// pass the data to the OK handler
					fRet=ChooseModemDlgOK(hDlg,pChooseModemDlgInfo);
					if (fRet)
					{
						EndDialog(hDlg,TRUE);
					}
				}
				break;

			case IDC_CMDCANCEL:
				SetLastError(ERROR_CANCELLED);
				EndDialog(hDlg,FALSE);
				break;                  
			}
			break;
	}

	return FALSE;
}


/*******************************************************************

  NAME:    ChooseModemDlgInit

  SYNOPSIS: proc to handle initialization of dialog for choosing modem

********************************************************************/

BOOL ChooseModemDlgInit(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo)
{
	//Assert(pChooseModemDlgInfo);

	// put the dialog in the center of the screen
	//RECT rc;
	//GetWindowRect(hDlg, &rc);
	//SetWindowPos(hDlg, NULL,
	//      ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
	//      ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
	//      0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

	// fill the combobox with available modems
	ProcessDBCS(hDlg,IDC_MODEM);
	DWORD dwRet = InitModemList(GetDlgItem(hDlg,IDC_MODEM));
	if (ERROR_SUCCESS != dwRet)
	{
		DebugOut("ICWCONN1: ChooseModemDlgInit: Error initializing modem list!\n");

		SetLastError(dwRet);
		return FALSE;
	}

	return TRUE;
}

/*******************************************************************

  NAME:    ChooseModemDlgOK

  SYNOPSIS:  OK handler for dialog for choosing modem

********************************************************************/

BOOL ChooseModemDlgOK(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo)
{
	//Assert(pChooseModemDlgInfo);

	// should always have a selection in combo box if we get here
	//Assert(ComboBox_GetCurSel(GetDlgItem(hDlg,IDC_MODEM)) >= 0);

	// get modem name out of combo box
	ComboBox_GetText(GetDlgItem(hDlg,IDC_MODEM),
		pChooseModemDlgInfo->szModemName,
		SIZEOF_TCHAR_BUFFER(pChooseModemDlgInfo->szModemName));
	//Assert(lstrlen(pChooseModemDlgInfo->szModemName));
    
	// clear the modem list
	ComboBox_ResetContent(GetDlgItem(hDlg,IDC_MODEM));
	
	return TRUE;
}


/*******************************************************************

  NAME:    InitModemList

  SYNOPSIS:  Fills a combo box window with installed modems

  ENTRY:    hCB - combo box window to fill
  
********************************************************************/
HRESULT InitModemList (HWND hCB)
{
	DebugOut("ICWCONN1::enumodem.cpp  InitModemList()\n");

	LPTSTR pNext;
	int   nIndex;
	DWORD dwRet;

	//Assert(hCB);

	CEnumModem cEnumModem;

	// clear out the combo box
	ComboBox_ResetContent(hCB);

	while ( pNext = cEnumModem.Next() )
	{
		// Add the device to the combo box
		nIndex = ComboBox_AddString(hCB, pNext);
		ComboBox_SetItemData(hCB, nIndex, NULL);
	}

	// Select the default device
	ComboBox_SetCurSel(hCB, nIndex);

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\dialutil.inc ===
/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_OPENPORT            "Opening Port"
    IDS_PORTOPENED          "Port Opened"
    IDS_CONNECTDEVICE       "Connecting Device"
    IDS_DEVICECONNECTED     "Device Connected"
    IDS_ALLDEVICESCONNECTED "All Devices Connected"
    IDS_AUTHENTICATE        "Starting Authentication"
    IDS_AUTHNOTIFY          "Authentication Notify"
    IDS_AUTHRETRY           "Authentication Retry"
    IDS_AUTHCALLBACK        "Callback Requested"
    IDS_AUTHCHANGEPASSWORD  "Change Password Requested"
    IDS_AUTHPROJECT         "Projection Phase Started"
    IDS_AUTHLINKSPEED       "Link Speed Calculation"
    IDS_AUTHACK             "Authentication Acknowledged"
    IDS_REAUTHENTICATE      "Reauthentication Started"
    IDS_AUTHENTICATED       "Authenticated"
    IDS_PREPAREFORCALLBACK  "Preparation For Callback"
    IDS_WAITFORMODEMRESET   "Waiting For Modem Reset"
    IDS_WAITFORCALLBACK     "Waiting For Callback"
    IDS_INTERACTIVE         "Interactive"
    IDS_RETRYAUTHENTICATION "Retry Authentication"
    IDS_CALLBACKSETBYCALLER "Callback Set By Caller"
    IDS_PASSWORDEXPIRED     "Password Expired"
    IDS_CONNECTED           "Connected"
    IDS_DISCONNECTED        "Disconnected"
    IDS_UNDEFINED_ERROR     "Undefine Error Code"
    IDS_CONNECTED_TO        "Connected to %s"
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\client.cpp ===
//****************************************************************************
//
//  Module:     ISIGNUP.EXE
//  File:       client.c
//  Content:    This file contains all the functions that handle importing
//              client information.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "isignup.h"

HRESULT PopulateNTAutodialAddress(LPCTSTR pszFileName, LPCTSTR pszEntryName);
LPTSTR MoveToNextAddress(LPTSTR lpsz);
#define TAPI_CURRENT_VERSION 0x00010004
#include <tapi.h>

#pragma data_seg(".rdata")

// "INI" file constants
static const TCHAR cszEMailSection[] =       TEXT("Internet_Mail");
static const TCHAR cszEMailName[] =          TEXT("EMail_Name");
static const TCHAR cszEMailAddress[] =       TEXT("EMail_Address");
static const TCHAR cszPOPLogonName[] =       TEXT("POP_Logon_Name");
static const TCHAR cszPOPLogonPassword[] =   TEXT("POP_Logon_Password");
static const TCHAR cszPOPServer[] =          TEXT("POP_Server");
static const TCHAR cszSMTPServer[] =         TEXT("SMTP_Server");
static const TCHAR cszNewsSection[] =        TEXT("Internet_News");
static const TCHAR cszNNTPLogonName[] =      TEXT("NNTP_Logon_Name");
static const TCHAR cszNNTPLogonPassword[] =  TEXT("NNTP_Logon_Password");
static const TCHAR cszNNTPServer[] =         TEXT("NNTP_Server");
static const TCHAR cszUseExchange[] =        TEXT("Use_MS_Exchange");
static const TCHAR cszUserSection[] =        TEXT("User");
static const TCHAR cszDisplayPassword[] =    TEXT("Display_Password");
static const TCHAR cszNull[] = TEXT("");
static const TCHAR cszYes[] = TEXT("yes");
static const TCHAR cszNo[] = TEXT("no");
static const TCHAR cszCMHeader[] =           TEXT("Connection Manager CMS 0");
static const TCHAR cszEntrySection[] =       TEXT("Entry");
static const TCHAR cszEntryName[]    =       TEXT("Entry_Name");

TCHAR FAR cszCMCFG_DLL[] = TEXT("CMCFG32.DLL\0");
CHAR  FAR cszCMCFG_CONFIGURE[] = "CMConfig\0";
CHAR  FAR cszCMCFG_CONFIGUREEX[] = "CMConfigEx\0"; // Proc address

typedef BOOL (WINAPI * CMCONFIGUREEX)(LPCSTR lpszINSFile);
typedef BOOL (WINAPI * CMCONFIGURE)(LPCSTR lpszINSFile, LPCSTR lpszConnectoidNams);
CMCONFIGURE   lpfnCMConfigure;
CMCONFIGUREEX lpfnCMConfigureEx;

#define CLIENT_OFFSET(elem)    ((DWORD)(DWORD_PTR)&(((LPINETCLIENTINFO)(NULL))->elem))
#define CLIENT_SIZE(elem)      sizeof(((LPINETCLIENTINFO)(NULL))->elem)
#define CLIENT_ENTRY(section, value, elem) \
    {section, value, CLIENT_OFFSET(elem), CLIENT_SIZE(elem)}

typedef struct
{
    LPCTSTR  lpszSection;
    LPCTSTR  lpszValue;
    UINT    uOffset;
    UINT    uSize;
} CLIENT_TABLE, FAR *LPCLIENT_TABLE;

CLIENT_TABLE iniTable[] =
{
    CLIENT_ENTRY(cszEMailSection, cszEMailName,         szEMailName),
    CLIENT_ENTRY(cszEMailSection, cszEMailAddress,      szEMailAddress),
    CLIENT_ENTRY(cszEMailSection, cszPOPLogonName,      szPOPLogonName),
    CLIENT_ENTRY(cszEMailSection, cszPOPLogonPassword,  szPOPLogonPassword),
    CLIENT_ENTRY(cszEMailSection, cszPOPServer,         szPOPServer),
    CLIENT_ENTRY(cszEMailSection, cszSMTPServer,        szSMTPServer),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPLogonName,     szNNTPLogonName),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPLogonPassword, szNNTPLogonPassword),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPServer,        szNNTPServer),
    {NULL, NULL, 0, 0}
};

#pragma data_seg()

//
// 5/19/97	jmazner	Olympus #3663
// The branding DLL (IEDKCS32.DLL) is responsible for all
// proxy configuration.
//
/****
DWORD ImportProxySettings(LPCTSTR lpszFile)
{
    TCHAR szServer[MAX_SERVER_NAME + 1];
    TCHAR szOverride[1024];
    LPTSTR lpszServer = NULL;
    LPTSTR lpszOverride = NULL;
    BOOL fEnable = FALSE;

    if (GetPrivateProfileString(cszProxySection,
            cszProxyServer,
            cszNull,
            szServer,
            sizeof(szServer),
            lpszFile) != 0)
    {
        fEnable = TRUE;
        lpszServer = szServer;

        GetPrivateProfileString(cszProxySection,
                cszProxyOverride,
                cszNull,
                szOverride,
                sizeof(szOverride),
                lpszFile);

        lpszOverride = szOverride;
    }
    
    return lpfnInetSetProxy(fEnable, lpszServer, lpszOverride);
}
****/

DWORD ReadClientInfo(LPCTSTR lpszFile, LPINETCLIENTINFO lpClientInfo, LPCLIENT_TABLE lpClientTable)
{
    LPCLIENT_TABLE lpTable;

    for (lpTable = lpClientTable; NULL != lpTable->lpszSection; ++lpTable)
    {
        GetPrivateProfileString(lpTable->lpszSection,
                lpTable->lpszValue,
                cszNull,
                (LPTSTR)((LPBYTE)lpClientInfo + lpTable->uOffset),
                lpTable->uSize / sizeof(TCHAR),
                lpszFile);
    }

    lpClientInfo->dwFlags = 0;
    if (*lpClientInfo->szPOPLogonName)
    {
        lpClientInfo->dwFlags |= INETC_LOGONMAIL;
    }
    if ((*lpClientInfo->szNNTPLogonName) || (*lpClientInfo->szNNTPServer))
    {
        lpClientInfo->dwFlags |= INETC_LOGONNEWS;
    }

    return ERROR_SUCCESS;
}

BOOL WantsExchangeInstalled(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszEMailSection,
            cszUseExchange,
            cszNo,
            szTemp,
            10,
            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}


//+----------------------------------------------------------------------------
//
//    Function:    CallCMConfig
//
//    Synopsis:    Call into the Connection Manager dll's Configure function to allow CM to
//                process the .ins file as needed.
//
//    Arguements: lpszINSFile -- full path to the .ins file
//
//    Returns:    TRUE if a CM profile is created, FALSE otherwise
//
//    History:    09/02/98    DONALDM
//
//-----------------------------------------------------------------------------
BOOL CallCMConfig(LPCTSTR lpszINSFile)
{
    HINSTANCE   hCMDLL = NULL;
    BOOL        bRet = FALSE;

    // Load DLL and entry point
    hCMDLL = LoadLibrary(cszCMCFG_DLL);
    if (NULL != hCMDLL)
    {
        
        // To determine whether we should call CMConfig or CMConfigEx
        // Loop to find the appropriate buffer size to retieve the ins to memory
        ULONG ulBufferSize = 1024*10;
        // Parse the ISP section in the INI file to find query pair to append
        TCHAR *pszKeys = NULL;
        PTSTR pszKey = NULL;
        ULONG ulRetVal     = 0;
        BOOL  bEnumerate = TRUE;
        BOOL  bUseEx = FALSE;
 
        PTSTR pszBuff = NULL;
        ulRetVal = 0;

        pszKeys = new TCHAR [ulBufferSize];
        if (pszKeys)
        {
            while (ulRetVal < (ulBufferSize - 2))
            {

                ulRetVal = ::GetPrivateProfileString(NULL, NULL, _T(""), pszKeys, ulBufferSize, lpszINSFile);
                if (0 == ulRetVal)
                   bEnumerate = FALSE;

                if (ulRetVal < (ulBufferSize - 2))
                {
                    break;
                }
                delete [] pszKeys;
                ulBufferSize += ulBufferSize;
                pszKeys = new TCHAR [ulBufferSize];
                if (!pszKeys)
                {
                    bEnumerate = FALSE;
                }

            }

            if (bEnumerate)
            {
                pszKey = pszKeys;
                if (ulRetVal != 0) 
                {
                    while (*pszKey)
                    {
                        if (!lstrcmpi(pszKey, cszCMHeader)) 
                        {
                            bUseEx = TRUE;
                            break;
                        }
                        pszKey += lstrlen(pszKey) + 1;
                    }
                }
            }

            if (pszKeys)
                delete [] pszKeys;
        }

        TCHAR   szConnectoidName[RAS_MaxEntryName];
        // Get the connectoid name from the [Entry] Section
        GetPrivateProfileString(cszEntrySection,
                                    cszEntryName,
                                    cszNull,
                                    szConnectoidName,
                                    RAS_MaxEntryName,
                                    lpszINSFile);
        if (bUseEx)
        {
            // Call CMConfigEx
            lpfnCMConfigureEx = (CMCONFIGUREEX)GetProcAddress(hCMDLL,cszCMCFG_CONFIGUREEX);
            if( lpfnCMConfigureEx )
            {
#ifdef UNICODE
                CHAR szFile[_MAX_PATH + 1];

                wcstombs(szFile, lpszINSFile, _MAX_PATH + 1);

                bRet = lpfnCMConfigureEx(szFile);    
#else
                bRet = lpfnCMConfigureEx(lpszINSFile);    
#endif
            }
        }
        else
        {
            // Call CMConfig
            lpfnCMConfigure = (CMCONFIGURE)GetProcAddress(hCMDLL,cszCMCFG_CONFIGURE);
            if( lpfnCMConfigure )
            {

#ifdef UNICODE
                CHAR szEntry[RAS_MaxEntryName];
                CHAR szFile[_MAX_PATH + 1];

                wcstombs(szEntry, szConnectoidName, RAS_MaxEntryName);
                wcstombs(szFile, lpszINSFile, _MAX_PATH + 1);

                bRet = lpfnCMConfigure(szFile, szEntry);  
#else
                bRet = lpfnCMConfigure(lpszINSFile, szConnectoidName);  
#endif
            }
        }

        if (bRet)
        {
            // restore original autodial settings
            lpfnInetSetAutodial(TRUE, szConnectoidName);
        }     
    }

    // Cleanup
    if( hCMDLL )
        FreeLibrary(hCMDLL);
    if( lpfnCMConfigure )
        lpfnCMConfigure = NULL;

    return bRet;
}

BOOL DisplayPassword(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszUserSection,
            cszDisplayPassword,
            cszNo,
            szTemp,
            10,
            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

DWORD ImportClientInfo(
    LPCTSTR lpszFile,
    LPINETCLIENTINFO lpClientInfo)
{
    DWORD dwRet;

    lpClientInfo->dwSize = sizeof(INETCLIENTINFO);

    dwRet = ReadClientInfo(lpszFile, lpClientInfo, iniTable);

    return dwRet;
}

DWORD ConfigureClient(
    HWND hwnd,
    LPCTSTR lpszFile,
    LPBOOL lpfNeedsRestart,
    LPBOOL lpfConnectoidCreated,
    BOOL fHookAutodial,
    LPTSTR szConnectoidName,
    DWORD dwConnectoidNameSize   
    )
{
    LPICONNECTION pConn;
    LPINETCLIENTINFO pClientInfo;
    DWORD dwRet = ERROR_SUCCESS;
    UINT cb = sizeof(ICONNECTION) + sizeof(INETCLIENTINFO);
    DWORD dwfOptions = INETCFG_INSTALLTCP | INETCFG_WARNIFSHARINGBOUND;
    LPRASENTRY pRasEntry = NULL;

	//
	// ChrisK Olympus 4756 5/25/97
	// Do not display busy animation on Win95
	//
	if (IsNT())
	{
		dwfOptions |=  INETCFG_SHOWBUSYANIMATION;
	}

    // Allocate a buffer for connection and clientinfo objects
    //
    if ((pConn = (LPICONNECTION)LocalAlloc(LPTR, cb)) == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }
    
    if (WantsExchangeInstalled(lpszFile))
    {
        dwfOptions |= INETCFG_INSTALLMAIL;
    }

    // Create either a CM profile, or a connectoid
    if (CallCMConfig(lpszFile))
    {
        *lpfConnectoidCreated = TRUE;       // A dialup connection was created
    }
    else
    {

        dwRet = ImportConnection(lpszFile, pConn);
        if (ERROR_SUCCESS == dwRet)
        {
            pRasEntry = &pConn->RasEntry;
            dwfOptions |= INETCFG_SETASAUTODIAL |
                        INETCFG_INSTALLRNA |
                        INETCFG_INSTALLMODEM;
        }
        else if (ERROR_NO_MATCH == dwRet)
        {
            // 10/07/98 vyung IE bug#32882 hack.
            // If we do not detect the [Entry] section in the ins file,
            // we will assume it is an OE ins file.  Then we will assume
            // we have a autodial connection and pass the INS to OE.
            return dwRet;
        }
        else if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY != dwRet)
        {
            return dwRet;
        } 

        if (DisplayPassword(lpszFile))
        {
            if (*pConn->szPassword || *pConn->szUserName)
            {
                TCHAR szFmt[128];
                TCHAR szMsg[384];

                LoadString(ghInstance,IDS_PASSWORD,szFmt,SIZEOF_TCHAR_BUFFER(szFmt));
                wsprintf(szMsg, szFmt, pConn->szUserName, pConn->szPassword);

                MessageBox(hwnd,szMsg,cszAppName,MB_ICONINFORMATION | MB_OK);
            }
        }

        if (fHookAutodial &&
            ((0 == *pConn->RasEntry.szAutodialDll) ||
            (0 == *pConn->RasEntry.szAutodialFunc)))
        {
            lstrcpy(pConn->RasEntry.szAutodialDll, TEXT("isign32.dll"));
            lstrcpy(pConn->RasEntry.szAutodialFunc, TEXT("AutoDialLogon"));
        }
 
        if (ERROR_SUCCESS != dwRet)
        {
            pClientInfo = NULL;

        }

        // humongous hack for ISBU
        dwRet = lpfnInetConfigClient(hwnd,
                                     NULL,
                                     pConn->szEntryName,
                                     pRasEntry,
                                     pConn->szUserName,
                                     pConn->szPassword,
                                     NULL,
                                     NULL,
                                     dwfOptions & ~INETCFG_INSTALLMAIL,
                                     lpfNeedsRestart);
        lstrcpy(szConnectoidName, pConn->szEntryName);

        LclSetEntryScriptPatch(pRasEntry->szScript,pConn->szEntryName);
	    BOOL fEnabled = TRUE;
	    DWORD dwResult = 0xba;
	    dwResult = lpfnInetGetAutodial(&fEnabled, pConn->szEntryName, RAS_MaxEntryName+1);
	    if ((ERROR_SUCCESS == dwRet) && lstrlen(pConn->szEntryName))
	    {
		    *lpfConnectoidCreated = (NULL != pRasEntry);
            PopulateNTAutodialAddress( lpszFile, pConn->szEntryName );
	    }
	    else
	    {
		    DebugOut("ISIGNUP: ERROR: InetGetAutodial failed, will not be able to set NT Autodial\n");
	    }
    }

    if (ERROR_SUCCESS == dwRet)
    {
        // Get the mail client info
        INETCLIENTINFO pClientInfo;

        ImportClientInfo(lpszFile, &pClientInfo);
   
        dwRet = lpfnInetConfigClient(
                hwnd,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                &pClientInfo,
                dwfOptions & INETCFG_INSTALLMAIL,
                lpfNeedsRestart);
    }

    LocalFree(pConn);

    return dwRet;
 }


//+----------------------------------------------------------------------------
//
//	Function:	PopulateNTAutodialAddress
//
//	Synopsis:	Take Internet addresses from INS file and load them into the
//				autodial database
//
//	Arguments:	pszFileName - pointer to INS file name
//
//	Returns:	Error code (ERROR_SUCCESS == success)
//
//	History:	8/29/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
#define AUTODIAL_ADDRESS_BUFFER_SIZE 2048
#define AUTODIAL_ADDRESS_SECTION_NAME TEXT("Autodial_Addresses_for_NT")
HRESULT PopulateNTAutodialAddress(LPCTSTR pszFileName, LPCTSTR pszEntryName)
{
	HRESULT hr = ERROR_SUCCESS;
	LONG lRC = 0;
	LPLINETRANSLATECAPS lpcap = NULL;
	LPLINETRANSLATECAPS lpTemp = NULL;
	LPLINELOCATIONENTRY lpLE = NULL;
	LPRASAUTODIALENTRY rADE;
	INT idx = 0;
	LPTSTR lpszBuffer = NULL;
	LPTSTR lpszNextAddress = NULL;
	rADE = NULL;

	//RNAAPI *pRnaapi = NULL;

	// jmazner  10/8/96  this function is NT specific
	if( !IsNT() )
	{
		DebugOut("ISIGNUP: Bypassing PopulateNTAutodialAddress for win95.\r\n");
		return( ERROR_SUCCESS );
	}

	//Assert(pszFileName && pszEntryName);
	//dprintf("ISIGNUP: PopulateNTAutodialAddress "%s %s.\r\n",pszFileName, pszEntryName);
	DebugOut(pszFileName);
	DebugOut(", ");
	DebugOut(pszEntryName);
	DebugOut(".\r\n");

	// allocate this guy for making softlink calls to Ras functions
	//pRnaapi = new RNAAPI;
	//if( !pRnaapi )
	//{
		//hr = ERROR_NOT_ENOUGH_MEMORY;
		//goto PopulateNTAutodialAddressExit;
	//}

	//
	// Get list of TAPI locations
	//

	lpcap = (LPLINETRANSLATECAPS)GlobalAlloc(GPTR,sizeof(LINETRANSLATECAPS));
	if (!lpcap)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto PopulateNTAutodialAddressExit;
	}
	lpcap->dwTotalSize = sizeof(LINETRANSLATECAPS);
	lRC = lineGetTranslateCaps(0,0x10004,lpcap);
	if (SUCCESS == lRC)
	{
		lpTemp = (LPLINETRANSLATECAPS)GlobalAlloc(GPTR,lpcap->dwNeededSize);
		if (!lpTemp)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto PopulateNTAutodialAddressExit;
		}
		lpTemp->dwTotalSize = lpcap->dwNeededSize;
		GlobalFree(lpcap);
		lpcap = (LPLINETRANSLATECAPS)lpTemp;
		lpTemp = NULL;
		lRC = lineGetTranslateCaps(0,0x10004,lpcap);
	}

	if (SUCCESS != lRC)
	{
		hr = (HRESULT)lRC; // REVIEW: not real sure about this.
		goto PopulateNTAutodialAddressExit;
	}

	//
	// Create an array of RASAUTODIALENTRY structs
	//
	
	rADE = (LPRASAUTODIALENTRY)GlobalAlloc(GPTR,
		sizeof(RASAUTODIALENTRY)*lpcap->dwNumLocations);
	if (!rADE)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto PopulateNTAutodialAddressExit;
	}
	

	//
	// Enable autodialing for all locations
	//
	idx = lpcap->dwNumLocations;
	lpLE = (LPLINELOCATIONENTRY)((DWORD_PTR)lpcap + (DWORD)lpcap->dwLocationListOffset);
	while (idx)
	{
		idx--;
		lpfnRasSetAutodialEnable(lpLE[idx].dwPermanentLocationID,TRUE);

		//
		// fill in array values
		//
		rADE[idx].dwSize = sizeof(RASAUTODIALENTRY);
		rADE[idx].dwDialingLocation = lpLE[idx].dwPermanentLocationID;
		lstrcpyn(rADE[idx].szEntry,pszEntryName,RAS_MaxEntryName);
	}

	//
	// Get list of addresses
	//
	lpszBuffer = (LPTSTR)GlobalAlloc(GPTR,AUTODIAL_ADDRESS_BUFFER_SIZE);
	if (!lpszBuffer)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto PopulateNTAutodialAddressExit;
	}

	if((AUTODIAL_ADDRESS_BUFFER_SIZE-2) == GetPrivateProfileSection(AUTODIAL_ADDRESS_SECTION_NAME,
		lpszBuffer, AUTODIAL_ADDRESS_BUFFER_SIZE / sizeof(TCHAR), pszFileName))
	{
		//AssertSz(0,"Autodial address section bigger than buffer.\r\n");
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto PopulateNTAutodialAddressExit;
	}

	//
	// Walk list of addresses and set autodialing for each one
	//
	lpszNextAddress = lpszBuffer;
	do
	{
		lpszNextAddress = MoveToNextAddress(lpszNextAddress);
		if (!(*lpszNextAddress))
			break;	// do-while
		lpfnRasSetAutodialAddress(lpszNextAddress,0,rADE,
			sizeof(RASAUTODIALENTRY)*lpcap->dwNumLocations,lpcap->dwNumLocations);
		lpszNextAddress = lpszNextAddress + lstrlen(lpszNextAddress);
	} while(1);

PopulateNTAutodialAddressExit:
	if (lpcap) 
		GlobalFree(lpcap);
	lpcap = NULL;
	if (rADE)
		GlobalFree(rADE);
	rADE = NULL;
	if (lpszBuffer)
		GlobalFree(lpszBuffer);
	lpszBuffer = NULL;
	//if( pRnaapi )
	//	delete pRnaapi;
	//pRnaapi = NULL;
	return hr;
}



//+----------------------------------------------------------------------------
//
//	Function:	MoveToNextAddress
//
//	Synopsis:	Given a pointer into the data bufffer, this function will move
//				through the buffer until it points to the begining of the next
//				address or it reaches the end of the buffer.
//
//	Arguements:	lpsz - pointer into buffer
//
//	Returns:	Pointer to the next address, return value will point to NULL
//				if there are no more addresses
//
//	History:	8/29/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
LPTSTR MoveToNextAddress(LPTSTR lpsz)
{
	BOOL fLastCharWasNULL = FALSE;

	//AssertSz(lpsz,"MoveToNextAddress: NULL input\r\n");

	//
	// Look for an = sign
	//
	do
	{
		if (fLastCharWasNULL && '\0' == *lpsz)
			break; // are we at the end of the data?

		if ('\0' == *lpsz)
			fLastCharWasNULL = TRUE;
		else
			fLastCharWasNULL = FALSE;

		if ('=' == *lpsz)
			break;

		if (*lpsz)
			lpsz = CharNext(lpsz);
		else
			lpsz++;
	} while (1);
	
	//
	// Move to the first character beyond the = sign.
	//
	if (*lpsz)
		lpsz = CharNext(lpsz);

	return lpsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\exdispid.h ===
#ifndef EXDISPID_H_
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: exdispid.h
//
//--------------------------------------------------------------------------


//
// Dispatch IDS for IExplorer Dispatch Events.
//
#define DISPID_BEFORENAVIGATE     100   // this is sent before navigation to give a chance to abort
#define DISPID_NAVIGATECOMPLETE   101   // in async, this is sent when we have enough to show
#define DISPID_STATUSTEXTCHANGE   102
#define DISPID_QUIT               103
#define DISPID_DOWNLOADCOMPLETE   104
#define DISPID_COMMANDSTATECHANGE 105
#define DISPID_DOWNLOADBEGIN      106
#define DISPID_NEWWINDOW          107   // sent when a new window should be created
#define DISPID_PROGRESSCHANGE     108   // sent when download progress is updated
#define DISPID_WINDOWMOVE         109   // sent when main window has been moved
#define DISPID_WINDOWRESIZE       110   // sent when main window has been sized
#define DISPID_WINDOWACTIVATE     111   // sent when main window has been activated
#define DISPID_PROPERTYCHANGE     112   // sent when the PutProperty method is called
#define DISPID_TITLECHANGE        113   // sent when the document title changes

#define DISPID_FRAMEBEFORENAVIGATE    200
#define DISPID_FRAMENAVIGATECOMPLETE  201
#define DISPID_FRAMENEWWINDOW         204


#define EXDISPID_H_
#endif // EXDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\icw.h ===
#ifndef __ICW_H
#define __ICW_H

BOOL UseICWForIEAK(TCHAR* szIEAKFileName);
void RunICWinIEAKMode(TCHAR* szIEAKFileName);

#endif //__ICW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\extfunc.h ===
typedef DWORD (WINAPI * RASENUMCONNECTIONS)
        (LPRASCONN lpRasConn, LPDWORD lpcb, LPDWORD lpcConnections);
extern RASENUMCONNECTIONS  lpfnRasEnumConnections;

typedef DWORD (WINAPI * RASHANGUP)
        (HRASCONN hRasConn);
extern RASHANGUP  lpfnRasHangUp;

typedef DWORD (WINAPI * RASGETENTRYDIALPARAMS)
        (LPTSTR, LPRASDIALPARAMS, LPBOOL );
extern RASGETENTRYDIALPARAMS lpfnRasGetEntryDialParams;

typedef DWORD (WINAPI * RASSETENTRYDIALPARAMS)
		(LPTSTR, LPRASDIALPARAMS, BOOL);
extern RASSETENTRYDIALPARAMS lpfnRasSetEntryDialParams;

typedef DWORD (WINAPI * RASDIAL)
        (LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD, LPVOID, LPHRASCONN );
extern RASDIAL lpfnRasDial;

typedef DWORD (WINAPI * RASGETCONECTSTATUS)
        (HRASCONN, LPRASCONNSTATUS );
extern RASGETCONECTSTATUS lpfnRasGetConnectStatus;

typedef DWORD (WINAPI * RASGETERRORSTRING)
        ( UINT, LPTSTR, DWORD );
extern RASGETERRORSTRING lpfnRasGetErrorString;

typedef DWORD (WINAPI * RASVALIDATEENTRYNAME)
        (LPTSTR lpszPhonebook, LPTSTR szEntry);
extern RASVALIDATEENTRYNAME  lpfnRasValidateEntryName;

typedef DWORD (WINAPI * RASRENAMEENTRY)
        (LPTSTR lpszPhonebook, LPTSTR szEntryOld, LPTSTR szEntryNew);
extern RASRENAMEENTRY lpfnRasRenameEntry;

typedef DWORD (WINAPI * RASDELETEENTRY)
        (LPTSTR lpszPhonebook, LPTSTR szEntry);
extern RASDELETEENTRY lpfnRasDeleteEntry;

typedef DWORD (WINAPI * RASGETENTRYPROPERTIES)
        (LPTSTR lpszPhonebook, LPTSTR szEntry, LPBYTE lpbEntry,
        LPDWORD lpdwEntrySize, LPBYTE lpb, LPDWORD lpdwSize);
extern RASGETENTRYPROPERTIES lpfnRasGetEntryProperties;

typedef DWORD (WINAPI * RASSETENTRYPROPERTIES)
        (LPTSTR lpszPhonebook, LPTSTR szEntry, LPBYTE lpbEntry,
        DWORD dwEntrySize, LPBYTE lpb, DWORD dwSize);
extern RASSETENTRYPROPERTIES lpfnRasSetEntryProperties;

typedef DWORD (WINAPI * RASGETCOUNTRYINFO)
        (LPRASCTRYINFO lpCtryInfo, LPDWORD lpdwSize);
extern RASGETCOUNTRYINFO lpfnRasGetCountryInfo;

typedef DWORD (WINAPI * RASENUMDEVICES)
    (LPRASDEVINFO lpBuff, LPDWORD lpcbSize, LPDWORD lpcDevices);
extern RASENUMDEVICES lpfnRasEnumDevices;

#if !defined(WIN16)
typedef DWORD (WINAPI * RASSETAUTODIALENABLE)
    (DWORD dwDialingLocation, BOOL fEnabled);
extern RASSETAUTODIALENABLE lpfnRasSetAutodialEnable;

typedef DWORD (WINAPI * RASSETAUTODIALADDRESS)
	(LPTSTR lpszAddress,DWORD dwReserved,LPRASAUTODIALENTRY lpAutoDialEntries,
	DWORD dwcbAutoDialEntries,DWORD dwcAutoDialEntries);
extern RASSETAUTODIALADDRESS lpfnRasSetAutodialAddress;
#endif

typedef DWORD (WINAPI *INETCONFIGSYSTEM)
    (HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart);
extern INETCONFIGSYSTEM lpfnInetConfigSystem;

typedef DWORD (WINAPI *INETCONFIGCLIENT)
    (HWND hwndParent, LPCTSTR lpszPhoneBook,
    LPCTSTR lpszEntryName, LPRASENTRY lpRasEntry,
    LPCTSTR lpszUserName, LPCTSTR lpszPassword,
    LPCTSTR lpszProfile, LPINETCLIENTINFO lpClientInfo,
    DWORD dwfOptions, LPBOOL lpfNeedsRestart);
extern INETCONFIGCLIENT lpfnInetConfigClient;

typedef DWORD (WINAPI *INETGETAUTODIAL)
    (LPBOOL lpfEnable, LPCTSTR lpszEntryName, DWORD cbEntryNameSize);
extern INETGETAUTODIAL lpfnInetGetAutodial;

typedef DWORD (WINAPI *INETSETAUTODIAL)
    (BOOL fEnable, LPCTSTR lpszEntryName);
extern INETSETAUTODIAL lpfnInetSetAutodial;

typedef DWORD (WINAPI *INETGETCLIENTINFO)
    (LPCTSTR lpszProfile, LPINETCLIENTINFO lpClientInfo);
extern INETGETCLIENTINFO lpfnInetGetClientInfo;

typedef DWORD (WINAPI *INETSETCLIENTINFO)
    (LPCTSTR lpszProfile, LPINETCLIENTINFO lpClientInfo);
extern INETSETCLIENTINFO lpfnInetSetClientInfo;

typedef DWORD (WINAPI *INETGETPROXY)
    (LPBOOL lpfEnable, LPCTSTR lpszServer, DWORD cbServer,
    LPCTSTR lpszOverride, DWORD cbOverride);
extern INETGETPROXY lpfnInetGetProxy;

typedef DWORD (WINAPI *INETSETPROXY)
    (BOOL fEnable, LPCTSTR lpszServer, LPCTSTR lpszOverride);
extern INETSETPROXY lpfnInetSetProxy;

typedef BOOL (WINAPI *BRANDME)
  (LPCTSTR pszIns, LPCTSTR pszPath);
extern BRANDME  lpfnBrandMe;

typedef BOOL (WINAPI *BRANDICW)
  (LPCSTR pszIns, LPCSTR pszPath, DWORD dwFlags, LPCSTR pszConnectoid);
extern BRANDICW  lpfnBrandICW;

extern BOOL LoadRnaFunctions(HWND hwndParent);
extern BOOL LoadInetFunctions(HWND hwndParent);
extern BOOL LoadBrandingFunctions(void);
extern void UnloadRnaFunctions(void);
extern void UnloadInetFunctions(void);
extern void UnloadBrandingFunctions(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\extfunc.cpp ===
//****************************************************************************
//
//  Module:     ISIGNUP.EXE
//  File:       extfunc.c
//  Content:    This file contains all the functions that handle 
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "isignup.h"


static const TCHAR cszRnaPhDLL[] = TEXT("RNAPH.DLL");
#ifdef WIN32
static const TCHAR cszRasDLL[] = TEXT("RASAPI32.DLL");
static const TCHAR cszBrandingDLL[] = TEXT("IEDKCS32.DLL");
#else
static const CHAR cszRasDLL[] = "RASC16IE.DLL";
static const CHAR cszBrandingDLL[] = "IEDKCS16.DLL";
#endif

RASENUMCONNECTIONS    lpfnRasEnumConnections    = NULL;
RASHANGUP             lpfnRasHangUp             = NULL;
RASDELETEENTRY        lpfnRasDeleteEntry        = NULL;
RASGETENTRYDIALPARAMS lpfnRasGetEntryDialParams = NULL;
RASDIAL               lpfnRasDial               = NULL;
RASGETCONECTSTATUS    lpfnRasGetConnectStatus   = NULL;
RASGETERRORSTRING     lpfnRasGetErrorString     = NULL;
RASGETENTRYPROPERTIES lpfnRasGetEntryProperties = NULL;
RASENUMDEVICES        lpfnRasEnumDevices        = NULL;
RASSETENTRYPROPERTIES lpfnRasSetEntryProperties = NULL;
RASSETENTRYDIALPARAMS lpfnRasSetEntryDialParams = NULL;

#ifdef WIN32
// these two should only be used on NT, and _not_ on Win95
RASSETAUTODIALENABLE  lpfnRasSetAutodialEnable	= NULL;
RASSETAUTODIALADDRESS lpfnRasSetAutodialAddress	= NULL;
#endif

#ifdef UNUSED
RASVALIDATEENTRYNAME  lpfnRasValidateEntryName  = NULL;
RASRENAMEENTRY        lpfnRasRenameEntry        = NULL;
RASGETCOUNTRYINFO     lpfnRasGetCountryInfo     = NULL;
#endif

#ifdef WIN32
INETCONFIGSYSTEM  lpfnInetConfigSystem  = NULL;
INETGETPROXY      lpfnInetGetProxy      = NULL;
#endif
INETCONFIGCLIENT  lpfnInetConfigClient  = NULL;
INETGETAUTODIAL   lpfnInetGetAutodial   = NULL;
INETSETAUTODIAL   lpfnInetSetAutodial   = NULL;
INETSETCLIENTINFO lpfnInetSetClientInfo = NULL;
INETSETPROXY      lpfnInetSetProxy      = NULL;
#ifdef UNUSED
INETGETCLIENTINFO lpfnInetGetClientInfo = NULL;
#endif

#ifdef WIN32
BRANDICW  lpfnBrandICW  = NULL;
#else
BRANDME  lpfnBrandMe  = NULL;
#endif

typedef struct tagApiFcn {
    LPVOID FAR* lplpfn;
    LPCSTR   szApiName;
} APIFCN;


#ifdef UNICODE
APIFCN RasProcList[] = {
    { (LPVOID *) &lpfnRasEnumConnections,   "RasEnumConnectionsW"},
    { (LPVOID *) &lpfnRasHangUp,            "RasHangUpW"},
    { (LPVOID *) &lpfnRasGetEntryDialParams,"RasGetEntryDialParamsW"},
    { (LPVOID *) &lpfnRasDial,              "RasDialW"},
    { (LPVOID *) &lpfnRasGetConnectStatus,  "RasGetConnectStatusW"},
    { (LPVOID *) &lpfnRasGetErrorString,    "RasGetErrorStringW"},
    { (LPVOID *) &lpfnRasSetEntryDialParams,"RasSetEntryDialParamsW"},
};
#else  // UNICODE
APIFCN RasProcList[] = {
    { (LPVOID *) &lpfnRasEnumConnections,   "RasEnumConnectionsA"},
    { (LPVOID *) &lpfnRasHangUp,            "RasHangUpA"},
    { (LPVOID *) &lpfnRasGetEntryDialParams,"RasGetEntryDialParamsA"},
    { (LPVOID *) &lpfnRasDial,              "RasDialA"},
    { (LPVOID *) &lpfnRasGetConnectStatus,  "RasGetConnectStatusA"},
    { (LPVOID *) &lpfnRasGetErrorString,    "RasGetErrorStringA"},
    { (LPVOID *) &lpfnRasSetEntryDialParams,"RasSetEntryDialParamsA"},
};
#endif // UNICODE

#define cRasProc (sizeof(RasProcList) / sizeof(RasProcList[0]))

#ifdef WIN32
#ifdef UNICODE
APIFCN RasProcListNT[] = {
    { (LPVOID *) &lpfnRasEnumConnections,   "RasEnumConnectionsW"},
    { (LPVOID *) &lpfnRasHangUp,            "RasHangUpW"},
    { (LPVOID *) &lpfnRasGetEntryDialParams,"RasGetEntryDialParamsW"},
    { (LPVOID *) &lpfnRasDial,              "RasDialW"},
    { (LPVOID *) &lpfnRasGetConnectStatus,  "RasGetConnectStatusW"},
    { (LPVOID *) &lpfnRasGetErrorString,    "RasGetErrorStringW"},
    { (LPVOID *) &lpfnRasSetAutodialEnable, "RasSetAutodialEnableW"},
    { (LPVOID *) &lpfnRasSetAutodialAddress,"RasSetAutodialAddressW"},
    { (LPVOID *) &lpfnRasSetEntryDialParams,"RasSetEntryDialParamsW"},
};
#else // UNICODE
APIFCN RasProcListNT[] = {
    { (LPVOID *) &lpfnRasEnumConnections,   "RasEnumConnectionsA"},
    { (LPVOID *) &lpfnRasHangUp,            "RasHangUpA"},
    { (LPVOID *) &lpfnRasGetEntryDialParams,"RasGetEntryDialParamsA"},
    { (LPVOID *) &lpfnRasDial,              "RasDialA"},
    { (LPVOID *) &lpfnRasGetConnectStatus,  "RasGetConnectStatusA"},
    { (LPVOID *) &lpfnRasGetErrorString,    "RasGetErrorStringA"},
    { (LPVOID *) &lpfnRasSetAutodialEnable, "RasSetAutodialEnableA"},
    { (LPVOID *) &lpfnRasSetAutodialAddress,"RasSetAutodialAddressA"},
    { (LPVOID *) &lpfnRasSetEntryDialParams,"RasSetEntryDialParamsA"},
};
#endif // UNICODE

#define cRasProcNT (sizeof(RasProcListNT) / sizeof(RasProcListNT[0]))
#endif


APIFCN RnaPhProcList[] = {
#ifdef UNICODE
    { (LPVOID *) &lpfnRasDeleteEntry,       "RasDeleteEntryW"},
    { (LPVOID *) &lpfnRasGetEntryProperties,"RasGetEntryPropertiesW"},
    { (LPVOID *) &lpfnRasEnumDevices,       "RasEnumDevicesW"},
    { (LPVOID *) &lpfnRasSetEntryProperties,"RasSetEntryPropertiesW"},
#else
    { (LPVOID *) &lpfnRasDeleteEntry,       "RasDeleteEntryA"},
    { (LPVOID *) &lpfnRasGetEntryProperties,"RasGetEntryPropertiesA"},
    { (LPVOID *) &lpfnRasEnumDevices,       "RasEnumDevicesA"},
    { (LPVOID *) &lpfnRasSetEntryProperties,"RasSetEntryPropertiesA"},
#endif

#ifdef UNUSED
    { (LPVOID *) &lpfnRasValidateEntryName, "RasValidateEntryName"},
    { (LPVOID *) &lpfnRasRenameEntry,       "RasRenameEntry"},
    { (LPVOID *) &lpfnRasGetCountryInfo,    "RasGetCountryInfo"},
#endif
};

#define cRnaPhProc (sizeof(RnaPhProcList) / sizeof(RnaPhProcList[0]))

APIFCN InetProcList[] = {
#ifdef WIN32
    { (LPVOID *) &lpfnInetConfigSystem,  "InetConfigSystem"},
#ifdef UNICODE
    { (LPVOID *) &lpfnInetGetProxy,      "InetGetProxyW"},
#else
    { (LPVOID *) &lpfnInetGetProxy,      "InetGetProxy"},
#endif // UNICODE
#endif // WIN32
#ifdef UNICODE
    { (LPVOID *) &lpfnInetConfigClient,  "InetConfigClientW"},
    { (LPVOID *) &lpfnInetGetAutodial,   "InetGetAutodialW"},
    { (LPVOID *) &lpfnInetSetAutodial,   "InetSetAutodialW"},
    { (LPVOID *) &lpfnInetSetClientInfo, "InetSetClientInfoW"},
    { (LPVOID *) &lpfnInetSetProxy,      "InetSetProxyW"},
#else 
    { (LPVOID *) &lpfnInetConfigClient,  "InetConfigClient"},
    { (LPVOID *) &lpfnInetGetAutodial,   "InetGetAutodial"},
    { (LPVOID *) &lpfnInetSetAutodial,   "InetSetAutodial"},
    { (LPVOID *) &lpfnInetSetClientInfo, "InetSetClientInfo"},
    { (LPVOID *) &lpfnInetSetProxy,      "InetSetProxy"},
#endif // UNICODE

#ifdef UNUSED
#ifdef UNICODE
    { (LPVOID *) &lpfnInetGetClientInfo, "InetGetClientInfoW"},
#else
    { (LPVOID *) &lpfnInetGetClientInfo, "InetGetClientInfo"},
#endif
#endif
};

#define cInetProc (sizeof(InetProcList) / sizeof(InetProcList[0]))

APIFCN BrandingProcList[] = {
#ifdef WIN32
    { (LPVOID *) &lpfnBrandICW,   "BrandICW2"},
#else
    { (LPVOID *) &lpfnBrandMe,   "BrandMe"},
#endif
};

#define cBrandingProc (sizeof(BrandingProcList) / sizeof(BrandingProcList[0]))

static HINSTANCE ghRas = NULL;
static HINSTANCE ghRnaPh = NULL;
static HINSTANCE ghInet = NULL;
static HINSTANCE ghBranding = NULL;

#ifndef WIN32
static int iRasRefs = 0;
static int iInetRefs = 0;
static int iBrandingRefs = 0;
#endif

HINSTANCE InitLpfn(LPCTSTR szDllName, APIFCN *pProcList, int cProcs);

BOOL LoadRnaFunctions(HWND hwndParent)
{
#if !defined(WIN16)
	if (!IsRASReady())
	{
		DebugOut("ISIGN32: Attempted to load RAS API's however, the system isn't ready for it.\r\n");
		return FALSE;
	}
#endif
    if (ghRas == NULL)
    {
        if (RAS_MaxEntryName != 256)
        {
        //      MessageBox(NULL, "Invalid header used for compile", szAppName, MB_OK);
            return FALSE;
        }

#ifdef WIN32
		// 1/7/96 jmazner	Normandy #12930
		// init different proc lists based on whether we're in NT or not.
		if( IsNT() )
		{
			if ((ghRas = InitLpfn(cszRasDLL, RasProcListNT, cRasProcNT)) == NULL)
			{
				ErrorMsg(hwndParent, IDS_MISSINGRNADLL);
				return FALSE;
			}
		}
		else
		{
#endif
			if ((ghRas = InitLpfn(cszRasDLL, RasProcList, cRasProc)) == NULL)
			{
				ErrorMsg(hwndParent, IDS_MISSINGRNADLL);
				return FALSE;
			}
#ifdef WIN32
		}
#endif


        if ((ghRnaPh = InitLpfn(cszRasDLL, RnaPhProcList, cRnaPhProc)) == NULL)
        {
#ifdef WIN32
			//
			// we only load RNAPH.DLL if it is not NT
			// MKarki (5/4/97) - Fix for Bug #3378
			//
			 if (FALSE == IsNT ())
			{
#endif
				if ((ghRnaPh = InitLpfn(cszRnaPhDLL, RnaPhProcList, cRnaPhProc)) == NULL)
				{
					FreeLibrary(ghRas);
					ghRas = NULL;
					ErrorMsg(hwndParent, IDS_WRONGRNADLLVER);
					return FALSE;
				}
#ifdef WIN32
			}
			else
			{
					FreeLibrary(ghRas);
					ghRas = NULL;
					ErrorMsg(hwndParent, IDS_WRONGRNADLLVER);
					return FALSE;
				
			}
#endif
        }
    }

#ifndef WIN32
    ++iRasRefs;
#endif
    return TRUE;
}

BOOL LoadInetFunctions(HWND hwndParent)
{
    if (ghInet == NULL)
    {
        if ((ghInet = InitLpfn(TEXT("INETCFG.DLL"), InetProcList, cInetProc)) == NULL)
        {
            ErrorMsg(hwndParent, IDS_MISSINGCFGDLL);
            return FALSE;
        }
    }

#ifndef WIN32
    ++iInetRefs;
#endif
    return TRUE;
}

BOOL LoadBrandingFunctions(void)
{
    if (ghBranding == NULL)
    {
        if ((ghBranding = InitLpfn(cszBrandingDLL, BrandingProcList, cBrandingProc)) == NULL)
        {
            return FALSE;
        }
    }

#ifndef WIN32
    ++iBrandingRefs;
#endif
    return TRUE;
}

HINSTANCE InitLpfn(LPCTSTR szDllName, APIFCN *pProcList, int cProcs)
{
    int i;
    HINSTANCE hLib;
    hLib = LoadLibrary(szDllName);

    if (hLib != NULL)
    {
        for (i = 0; i < cProcs; i++)
        {
            *pProcList[i].lplpfn = (LPVOID) GetProcAddress(hLib, pProcList[i].szApiName);
            if (*pProcList[i].lplpfn == NULL)
            {
#if 0
                CHAR szMsg[256];

                wsprintf(szMsg,
                        "Could not find %s in %s",
                        pProcList[i].szApiName,
                        szDllName);
                MessageBox(NULL, szMsg, "Internet Signup", MB_OK);
#endif
                FreeLibrary(hLib);
                return NULL;
            }
        }
    }
#if 0
    else
    {
        wsprintf(szMsg,
                "Could not load %s",
                szDllName);
        MessageBox(NULL, szMsg, "Internet Signup", MB_OK);
    }
#endif

    return hLib;
}


void UnloadRnaFunctions(void)
{
#ifndef WIN32
    if (0 != --iRasRefs)
    {
        return;
    }
#endif

    // need to unload libraries 
    if (NULL != ghRas)
    {
        FreeLibrary(ghRas);
        ghRas = NULL;
    }
    if (NULL != ghRnaPh)
    {
        FreeLibrary(ghRnaPh);
        ghRas = NULL;
    }
}

void UnloadInetFunctions(void)
{
#ifndef WIN32
    if (0 != --iInetRefs)
    {
        return;
    }
#endif

    if (NULL != ghInet)
    {
        FreeLibrary(ghInet);
        ghInet = NULL;
    }
}

void UnloadBrandingFunctions(void)
{
#ifndef WIN32
    if (0 != --iBrandingRefs)
    {
        return;
    }
#endif

    if (NULL != ghBranding)
    {
        FreeLibrary(ghBranding);
        ghBranding = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\icw.cpp ===
#include "isignup.h"
#include "icw.h"
#include "appdefs.h"

BOOL UseICWForIEAK(TCHAR* szIEAKFileName)
{
    TCHAR szUseICW[2] = TEXT("\0");
    //If we can't find this section it the isp file we'll assume "no".
    GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_USEICW, TEXT("0"), szUseICW, 2, szIEAKFileName);
    return (BOOL)_ttoi(szUseICW);
}

void LocateICWFromReigistry(TCHAR* pszICWLocation, size_t size)
{
    HKEY hKey = NULL;

    TCHAR    szICWPath[MAX_PATH] = TEXT("");
    DWORD   dwcbPath = sizeof(szICWPath); 

    //Look fo the ICW in the app paths 
    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE, ICW50_PATHKEY, 0, KEY_QUERY_VALUE, &hKey)) == ERROR_SUCCESS)
    {
        //get the default for the key
        RegQueryValueEx(hKey, NULL , NULL, NULL, (BYTE *)szICWPath, (DWORD *)&dwcbPath);
    }        
    if (hKey) 
        RegCloseKey(hKey);

    lstrcpyn(pszICWLocation, szICWPath, size / sizeof(pszICWLocation[0]));
}

void RunICWinIEAKMode(TCHAR* pszIEAKFileName)
{
    //this must be big enough to hold the path to the icw as well as
    //the ieak file
    TCHAR szCmdLine[MAX_PATH * 4 + 8];
    TCHAR szICWPath[MAX_PATH + 1] = TEXT("");
   
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    MSG                 msg;
    DWORD               iWaitResult = 0;
    BOOL                bRetVal     = FALSE;

    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));
    
    //Get the path to the icw
    LocateICWFromReigistry(szICWPath, sizeof(szICWPath));

    if (szICWPath[0] != TEXT('\0'))
    {
        if ((szICWPath[0] != TEXT('\"')) ||
            (szICWPath[lstrlen(szICWPath) - 1] != TEXT('\"')))
        {
            //use quotes in case there are spaces
            lstrcpy(szCmdLine, TEXT("\""));
            lstrcat(szCmdLine, szICWPath);
            lstrcat(szCmdLine, TEXT("\" "));
        }
        else
        {
            lstrcpy(szCmdLine, szICWPath);
            lstrcat(szCmdLine, TEXT(" "));
        }
        
        //set the IEAK switch, pass in the path to the file
        //used to invoke isign32
        lstrcat(szCmdLine, ICW_IEAK_CMD);
        lstrcat(szCmdLine, TEXT(" \""));
        lstrcat(szCmdLine, pszIEAKFileName);
        lstrcat(szCmdLine, TEXT("\""));
       
        if(CreateProcess(NULL, 
                         szCmdLine, 
                         NULL, 
                         NULL, 
                         TRUE, 
                         0, 
                         NULL, 
                         NULL, 
                         &si, 
                         &pi))
        {
            // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
            while((iWaitResult=MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
            {
                // read all of the messages in this next loop
                // removing each message as we read it
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    // how to handle quit message?
                    if (msg.message == WM_QUIT)
                    {
                        CloseHandle(pi.hThread);
                        CloseHandle(pi.hProcess);
                    }
                    else
                        DispatchMessage(&msg);
                }
            }
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\icwerr.cpp ===
/*-----------------------------------------------------------------------------
	icwerr.cpp

	Maps RAS and downloading errors to string resource indices

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "isignup.h"
#include "..\inc\icwerr.h"

#define RAS_BOGUS_AUTHFAILCODE_1	84
#define RAS_BOGUS_AUTHFAILCODE_2	74389484

// ############################################################################
WORD RasErrorToIDS(DWORD dwErr)
{
	if(dwErr==RAS_BOGUS_AUTHFAILCODE_1 || dwErr==RAS_BOGUS_AUTHFAILCODE_2)
	{
		return IDS_PPPRANDOMFAILURE;
	}

	if((dwErr>=653 && dwErr<=663) || (dwErr==667) || (dwErr>=669 && dwErr<=675))
	{
		OutputDebugString(TEXT("Got random RAS MEDIA error!\r\n"));
		return IDS_MEDIAINIERROR;
	}
	
	switch(dwErr)
	{
	default:
		return IDS_PPPRANDOMFAILURE;

	case SUCCESS:
		return 0;
		
	case ERROR_LINE_BUSY:
		return IDS_PHONEBUSY;

	case ERROR_NO_ANSWER:
		return IDS_NOANSWER;
		
	case ERROR_VOICE_ANSWER:
	case ERROR_NO_CARRIER:
		return IDS_RASNOCARRIER;
		
	case ERROR_NO_DIALTONE:
		return IDS_NODIALTONE;

	case ERROR_HARDWARE_FAILURE:	// modem turned off
	case ERROR_PORT_ALREADY_OPEN:	// procomm/hypertrm/RAS has COM port
	case ERROR_PORT_OR_DEVICE:	// got this when hypertrm had the device open -- jmazner

		return IDS_NODEVICE;

	case ERROR_USER_DISCONNECTION:
		return IDS_USERCANCELEDDIAL;

	case ERROR_BUFFER_INVALID:				// bad/empty rasdilap struct
	case ERROR_BUFFER_TOO_SMALL:			// ditto?
	case ERROR_CANNOT_FIND_PHONEBOOK_ENTRY:	// if connectoid name in registry is wrong
		return IDS_TCPINSTALLERROR;

    case ERROR_AUTHENTICATION_FAILURE:		// get this on actual CHAP reject
		return IDS_PPPRANDOMFAILURE;

	case ERROR_PPP_TIMEOUT:		// get this on CHAP timeout
		return IDS_PPPRANDOMFAILURE;

	case ERROR_REMOTE_DISCONNECTION:		// Ascend drops connection on auth-fail
		return IDS_PPPRANDOMFAILURE;

	case ERROR_AUTH_INTERNAL:				// got this on random POP failure
	case ERROR_PROTOCOL_NOT_CONFIGURED:		// get this if LCP fails
	case ERROR_PPP_NO_PROTOCOLS_CONFIGURED:	// get this if IPCP addr download gives garbage
		return IDS_PPPRANDOMFAILURE;

	case ERROR_USERCANCEL:
		return IDS_USERCANCELEDDIAL;

/******
    case ERROR_CHANGING_PASSWORD:
    case ERROR_PASSWD_EXPIRED:
        ev = EVENT_INVALIDPASSWORD; break;

    case ERROR_ACCT_DISABLED:
    case ERROR_ACCT_EXPIRED:
		ev = EVENT_LOCKEDACCOUNT; break;

    case ERROR_NO_DIALIN_PERMISSION:
    case ERROR_RESTRICTED_LOGON_HOURS:
    case ERROR_AUTHENTICATION_FAILURE:
		ev = EVENT_RAS_AUTH_FAILED; break;

	case ERROR_ALREADY_DISCONNECTING:
	case ERROR_DISCONNECTION:
		ev = EVENT_CONNECTION_DROPPED; break;

	case PENDING: 
	case ERROR_INVALID_PORT_HANDLE:
	case ERROR_CANNOT_SET_PORT_INFO:
	case ERROR_PORT_NOT_CONNECTED:
	case ERROR_DEVICE_DOES_NOT_EXIST:
	case ERROR_DEVICETYPE_DOES_NOT_EXIST:
	case ERROR_PORT_NOT_FOUND:
	case ERROR_DEVICENAME_TOO_LONG:
	case ERROR_DEVICENAME_NOT_FOUND:
	 	ev=EVENT_BAD_MODEM_CONFIG; break;

	case ERROR_TAPI_CONFIGURATION:
		ev=EVENT_BAD_TAPI_CONFIG; break;
	
		ev=EVENT_MODEM_BUSY; break;
	
	case ERROR_BUFFER_TOO_SMALL:
	case ERROR_WRONG_INFO_SPECIFIED:
	case ERROR_EVENT_INVALID:
	case ERROR_BUFFER_INVALID:
	case ERROR_ASYNC_REQUEST_PENDING:
	case ERROR_CANNOT_OPEN_PHONEBOOK:
	case ERROR_CANNOT_LOAD_PHONEBOOK:
	case ERROR_CANNOT_WRITE_PHONEBOOK:
	case ERROR_CORRUPT_PHONEBOOK:
	case ERROR_CANNOT_LOAD_STRING:
	case ERROR_OUT_OF_BUFFERS:
	case ERROR_MACRO_NOT_FOUND:
	case ERROR_MACRO_NOT_DEFINED:
	case ERROR_MESSAGE_MACRO_NOT_FOUND:
	case ERROR_DEFAULTOFF_MACRO_NOT_FOUND:
	case ERROR_FILE_COULD_NOT_BE_OPENED:
	case ERROR_PORT_NOT_OPEN:
	case ERROR_PORT_DISCONNECTED:
	case ERROR_NO_ENDPOINTS:
	case ERROR_KEY_NOT_FOUND:
	case ERROR_INVALID_SIZE:
	case ERROR_PORT_NOT_AVAILABLE:
	case ERROR_UNKNOWN:
	case ERROR_WRONG_DEVICE_ATTACHED:
	case ERROR_BAD_STRING:
	case ERROR_BAD_USAGE_IN_INI_FILE:
	case ERROR_READING_SECTIONNAME:
	case ERROR_READING_DEVICETYPE:
	case ERROR_READING_DEVICENAME:
	case ERROR_READING_USAGE:
	case ERROR_READING_MAXCONNECTBPS:
	case ERROR_READING_MAXCARRIERBPS:
	case ERROR_IN_COMMAND:
	case ERROR_WRITING_SECTIONNAME:
	case ERROR_WRITING_DEVICETYPE:
	case ERROR_WRITING_DEVICENAME:
	case ERROR_WRITING_MAXCONNECTBPS:
	case ERROR_WRITING_MAXCARRIERBPS:
	case ERROR_WRITING_USAGE:
	case ERROR_WRITING_DEFAULTOFF:
	case ERROR_READING_DEFAULTOFF:
	case ERROR_EMPTY_INI_FILE:
	case ERROR_FROM_DEVICE:
	case ERROR_UNRECOGNIZED_RESPONSE:
	case ERROR_NO_RESPONSES:
	case ERROR_NO_COMMAND_FOUND:
	case ERROR_WRONG_KEY_SPECIFIED:
	case ERROR_UNKNOWN_DEVICE_TYPE:
	case ERROR_ALLOCATING_MEMORY:
	case ERROR_PORT_NOT_CONFIGURED:
	case ERROR_DEVICE_NOT_READY:
	case ERROR_READING_INI_FILE:
	case ERROR_NO_CONNECTION:
	case ERROR_PORT_OR_DEVICE:
	case ERROR_NOT_BINARY_MACRO:
	case ERROR_DCB_NOT_FOUND:
	case ERROR_STATE_MACHINES_NOT_STARTED:
	case ERROR_STATE_MACHINES_ALREADY_STARTED:
	case ERROR_PARTIAL_RESPONSE_LOOPING:
	case ERROR_UNKNOWN_RESPONSE_KEY:
	case ERROR_RECV_BUF_FULL:
	case ERROR_CMD_TOO_LONG:
	case ERROR_UNSUPPORTED_BPS:
	case ERROR_UNEXPECTED_RESPONSE:
	case ERROR_INTERACTIVE_MODE:
	case ERROR_BAD_CALLBACK_NUMBER:
	case ERROR_INVALID_AUTH_STATE:
	case ERROR_WRITING_INITBPS:
	case ERROR_X25_DIAGNOSTIC:
	case ERROR_OVERRUN:
	case ERROR_RASMAN_CANNOT_INITIALIZE:
	case ERROR_BIPLEX_PORT_NOT_AVAILABLE:
	case ERROR_NO_ACTIVE_ISDN_LINES:
	case ERROR_NO_ISDN_CHANNELS_AVAILABLE:
	case ERROR_TOO_MANY_LINE_ERRORS:
		ev=EVENT_INTERNAL_ERROR; break;
	
	case ERROR_ROUTE_NOT_AVAILABLE:
	case ERROR_ROUTE_NOT_ALLOCATED:
	case ERROR_INVALID_COMPRESSION_SPECIFIED:
	case ERROR_CANNOT_PROJECT_CLIENT:
	case ERROR_CANNOT_GET_LANA:
	case ERROR_NETBIOS_ERROR:
	case ERROR_NAME_EXISTS_ON_NET:
		ev=EVENT_BAD_NET_CONFIG; break;
	
	case ERROR_REQUEST_TIMEOUT:
	case ERROR_SERVER_OUT_OF_RESOURCES:
	case ERROR_SERVER_GENERAL_NET_FAILURE:
	case WARNING_MSG_ALIAS_NOT_ADDED:
	case ERROR_SERVER_NOT_RESPONDING:
		ev=EVENT_GENERAL_NET_ERROR; break;
		
	case ERROR_IP_CONFIGURATION:
	case ERROR_NO_IP_ADDRESSES:
	case ERROR_PPP_REMOTE_TERMINATED:
	case ERROR_PPP_NO_RESPONSE:
	case ERROR_PPP_INVALID_PACKET:
	case ERROR_PHONE_NUMBER_TOO_LONG:
	case ERROR_IPXCP_NO_DIALOUT_CONFIGURED:
	case ERROR_IPXCP_NO_DIALIN_CONFIGURED:
	case ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE:
	case ERROR_ACCESSING_TCPCFGDLL:
	case ERROR_NO_IP_RAS_ADAPTER:
	case ERROR_SLIP_REQUIRES_IP:
	case ERROR_PROJECTION_NOT_COMPLETE:
	case ERROR_PPP_NOT_CONVERGING:
	case ERROR_PPP_CP_REJECTED:
	case ERROR_PPP_LCP_TERMINATED:
	case ERROR_PPP_REQUIRED_ADDRESS_REJECTED:
	case ERROR_PPP_NCP_TERMINATED:
	case ERROR_PPP_LOOPBACK_DETECTED:
	case ERROR_PPP_NO_ADDRESS_ASSIGNED:
	case ERROR_CANNOT_USE_LOGON_CREDENTIALS:
	case ERROR_NO_LOCAL_ENCRYPTION:
	case ERROR_NO_REMOTE_ENCRYPTION:
	case ERROR_REMOTE_REQUIRES_ENCRYPTION:
	case ERROR_IPXCP_NET_NUMBER_CONFLICT:
		ev = EVENT_PPP_FAILURE; break;
***********/
	}
	return (0xFFFF);
}


// ############################################################################
	
HRESULT LoadDialErrorString(HRESULT hrIN, LPTSTR lpszBuff, DWORD dwBufferSize)
{
	if (lpszBuff && dwBufferSize)
	{
		WORD wSID = 0;
		wSID = RasErrorToIDS(hrIN);
		if (0xFFFF != wSID)
		{
			if (0 != LoadString(ghInstance,wSID,lpszBuff,(int)dwBufferSize))
				return ERROR_SUCCESS;
		}
	}
	return ERROR_INVALID_PARAMETER;
}

HRESULT WINAPI StatusMessageCallback(DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize)
{
	WORD iIDS = 0;

	switch(dwStatus)
	{
		case RASCS_OpenPort:
			iIDS = IDS_RAS_OPENPORT;
			break;
		case RASCS_PortOpened:
			iIDS = IDS_RAS_PORTOPENED;
			break;
		case RASCS_ConnectDevice:
			iIDS = IDS_RAS_DIALING;
			break;
		case RASCS_DeviceConnected:
			iIDS = IDS_RAS_CONNECTED;
			break;
#if (WINVER >= 0x400) 
		case RASCS_StartAuthentication:
		case RASCS_LogonNetwork:
			iIDS = IDS_RAS_LOCATING;
			break;
//		case RASCS_CallbackComplete:
//			iIDS = IDS_RAS_CONNECTED;
//			break;
#endif 

/* ETC...
				RASCS_AllDevicesConnected, 
				RASCS_Authenticate, 
				RASCS_AuthNotify, 
				RASCS_AuthRetry, 
				RASCS_AuthCallback, 
				RASCS_AuthChangePassword, 
				RASCS_AuthProject, 
				RASCS_AuthLinkSpeed, 
				RASCS_AuthAck, 
				RASCS_ReAuthenticate, 
				RASCS_Authenticated, 
				RASCS_PrepareForCallback, 
				RASCS_WaitForModemReset, 
				RASCS_WaitForCallback,
				RASCS_Projected, 
 
 
				RASCS_Interactive = RASCS_PAUSED, 
				RASCS_RetryAuthentication, 
				RASCS_CallbackSetByCaller, 
				RASCS_PasswordExpired, 
 */
		case RASCS_Connected:
			break;

		case RASCS_Disconnected:
			break;
	}
	if (iIDS && 0 != LoadString(ghInstance,iIDS,pszBuffer,(int)dwBufferSize))
		return ERROR_SUCCESS;
	else
		return ERROR_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\impfile.cpp ===
//****************************************************************************
// DWORD NEAR PASCAL ImportFile(LPCSTR szImportFile)
//
// This function imports a file from the given section
//
// History:
//  Mon 21-Mar-1996 12:40:00  -by-  Mark MacLin [mmaclin]
// Created.
//****************************************************************************

#include "isignup.h"

#define MAXLONGLEN      80

#define SIZE_ReadBuf    0x00008000    // 32K buffer size

#pragma data_seg(".rdata")

static TCHAR szNull[] = TEXT("");

#pragma data_seg()

//int atoi (LPCSTR szBuf)
//{
//  int   iRet = 0;
//
//  while ((*szBuf >= '0') && (*szBuf <= '9'))
//  {
//    iRet = (iRet*10)+(int)(*szBuf-'0');
//    szBuf++;
//  };
//  return iRet;
//}


DWORD ImportFile(LPCTSTR lpszImportFile, LPCTSTR lpszSection, LPCTSTR lpszOutputFile)
{
  HFILE hFile;
  LPTSTR  pszLine, pszFile;
  int    i, iMaxLine;
  UINT   cbSize, cbRet;
  DWORD  dwRet = ERROR_SUCCESS;

  // Allocate a buffer for the file
  //
  if ((pszFile = (LPTSTR)LocalAlloc(LMEM_FIXED, SIZE_ReadBuf * sizeof(TCHAR)))
       == NULL)
  {
    return ERROR_OUTOFMEMORY;
  }

  // Look for script
  //
  if (GetPrivateProfileString(lpszSection,
                              NULL,
                              szNull,
                              pszFile,
                              SIZE_ReadBuf,
                              lpszImportFile) != 0)
  {
    // Get the maximum line number
    //
    pszLine = pszFile;
    iMaxLine = -1;
    while (*pszLine)
    {
      i = _ttoi(pszLine);
      iMaxLine = max(iMaxLine, i);
      pszLine += lstrlen(pszLine)+1;
    };

    // If we have at least one line, we will import the script file
    //
    if (iMaxLine >= 0)
    {
      // Create the script file
      //
#ifdef UNICODE
      CHAR szTmp[MAX_PATH+1];
      wcstombs(szTmp, lpszOutputFile, MAX_PATH+1);
      hFile = _lcreat(szTmp, 0);
#else
      hFile = _lcreat(lpszOutputFile, 0);
#endif

      if (hFile != HFILE_ERROR)
      {
        TCHAR   szLineNum[MAXLONGLEN+1];

        // From The first line to the last line
        //
        for (i = 0; i <= iMaxLine; i++)
        {
          // Read the script line
          //
          wsprintf(szLineNum, TEXT("%d"), i);
          if ((cbSize = GetPrivateProfileString(lpszSection,
                                                szLineNum,
                                                szNull,
                                                pszLine,
                                                SIZE_ReadBuf,
                                                lpszImportFile)) != 0)
          {
            // Write to the script file
            //
            lstrcat(pszLine, TEXT("\x0d\x0a"));
#ifdef UNICODE
            wcstombs(szTmp, pszLine, MAX_PATH+1);
            cbRet=_lwrite(hFile, szTmp, cbSize+2);
#else
            cbRet=_lwrite(hFile, pszLine, cbSize+2);
#endif
          };
        };

        _lclose(hFile);
      }
      else
      {
        dwRet = ERROR_PATH_NOT_FOUND;
      };
    }
    else
    {
      dwRet = ERROR_PATH_NOT_FOUND;
    };
  }
  else
  {
    dwRet = ERROR_PATH_NOT_FOUND;
  };
  LocalFree(pszFile);

  return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\iedde.cpp ===
/*----------------------------------------------------------------------------
	iedde.cpp

	Sends URL open command to IE using DDE

	Copyright (C) 1995-96 Microsoft Corporation
	All right reserved

  Authors:
	VetriV		Vellore T. Vetrivelkumaran
	jmazner		Jeremy Mazner

  History:
	8/29/96   jmazner  created, with minor changes for 32 bit world, from
	                   VetriV's ie16dde.cpp
----------------------------------------------------------------------------*/
#include "isignup.h"

#if defined(WIN16)
  #include <windows.h>
#endif

#include <ddeml.h>
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

static FARPROC lpfnDDEProc;
static HCONV hConv = (HCONV) NULL;
static HSZ hszMosaicService = (HSZ) NULL;
static HSZ hszTopic = (HSZ) NULL;
static HSZ hszItem = (HSZ) NULL;
static DWORD g_dwInstance = 0;




//+---------------------------------------------------------------------------
//
//  Function:   Dprintf
//
//  Synopsis:   Prints the values contained in the variable number of 
//				arguments in the specified format 
//
//  Arguments:  [pcsz - Format string]
//
//	Returns:	Nothing
//
//  History:    8/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
void Dprintf(LPCSTR pcsz, ...)
{
#ifdef DEBUG
	va_list	argp;
	char	szBuf[1024];
	
	va_start(argp, pcsz);

	wvsprintf(szBuf, pcsz, argp);

	OutputDebugString(szBuf);
	va_end(argp);
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   DdeCallback
//
//  Synopsis:   Callback function used in DDEIntialize
//
//  Arguments:  [Please see DdeInitialize documentation]
//
//	Returns:	Nothing
//
//  History:    8/9/96     VetriV    Created
//              8/29/96    jmazner   minor change in signature for 32 bit world
//
//----------------------------------------------------------------------------
#if defined(WIN16)
extern "C" 
HDDEDATA CALLBACK _export DdeCallBack(UINT uType,    // transaction type
#else
HDDEDATA CALLBACK DdeCallBack(UINT uType,    // transaction type
#endif

										UINT uFmt,   // clipboard data format
										HCONV hconv, // handle of the conversation
										HSZ hsz1,    // handle of a string	
										HSZ hsz2,    // handle of a string
										HDDEDATA hdata, // handle of a global memory object	
										DWORD dwData1,  // transaction-specific data
										DWORD dwData2)  // transaction-specific data
{
	return 0;
}






//+---------------------------------------------------------------------------
//
//  Function:   OpenURL
//
//  Synopsis:   Opens the given URL use DDE.
//				Warning: This function uses global static variables and hence
//						 it is not re-entrant.
//
//  Arguments:  [lpsszURL - URL to be opened]
//
//	Returns:	Nothing
//
//  History:    8/9/96     VetriV    Created
//				9/3/96	   jmazner	 Minor tweaks; moved string handle code in from DdeInit
//
//----------------------------------------------------------------------------
int OpenURL(LPCTSTR lpcszURL)
{
	TCHAR szOpenURL[] = TEXT("WWW_OpenURL");
	TCHAR szRemainingParams[] = TEXT("\"\",-1,0,\"\",\"\",\"\"");
	TCHAR szArg[1024];
	HDDEDATA trans_ret;
	long long_result;

	
	if ((NULL == lpcszURL) || ('\0' == lpcszURL[0]))
		goto ErrorOpenURL;
                   
	//
	// Create String handle for the Operation WWW_OpenURL
	//
	if (hszTopic)
		DdeFreeStringHandle(g_dwInstance, hszTopic);
	hszTopic = DdeCreateStringHandle(g_dwInstance, szOpenURL, CP_WINANSI);
	
	if (!hszTopic)
	{
		Dprintf("DdeCreateStringHandle for %s failed with %u\r\n", 
					szOpenURL, DdeGetLastError(g_dwInstance));
		goto ErrorOpenURL;
	}

	
	//
	// Compose the argument string
	//
	if (lstrlen(lpcszURL) + lstrlen(szRemainingParams) > 1020)
		goto ErrorOpenURL;
	memset(szArg, 0, sizeof(szArg));
	wsprintf(szArg, TEXT("\"%s\",%s"), lpcszURL, szRemainingParams);

	
	//
	// Create String Handle for the Arguments
	//
	if (hszItem)
		DdeFreeStringHandle(g_dwInstance, hszItem);
	hszItem = DdeCreateStringHandle(g_dwInstance, szArg, CP_WINANSI);
						
	if (!hszItem)
	{
		Dprintf("DdeCreateStringHandle for %s failed with %u\r\n", 
					szArg, DdeGetLastError(g_dwInstance));
		goto ErrorOpenURL;
	}

	//
	// Connect to DDE Server
	//
	hConv = DdeConnect(g_dwInstance, hszMosaicService, hszTopic, NULL);
	if (!hConv)
	{
		Dprintf("DdeConnect failed with %u\r\n", 
					DdeGetLastError(g_dwInstance));
		goto ErrorOpenURL;
	}
	
	//
	// Request
	//
	trans_ret = DdeClientTransaction(NULL, 0, hConv, hszItem, CF_TEXT, 
										XTYP_REQUEST, 60000, NULL);
	
	
	//
	// long integer return value
	//
	if (trans_ret != DDE_FNOTPROCESSED)
	{
		DdeGetData(trans_ret, (LPBYTE) &long_result, sizeof(long_result), 0);
		DdeFreeDataHandle(trans_ret);
		return 0;					// Successfully started opening the URL
	}
	else
	{
		Dprintf("DdeClientTransaction failed with %u\r\n", 
					DdeGetLastError(g_dwInstance));
		goto ErrorOpenURL;
	}



ErrorOpenURL:
	if (hConv)
	{
		DdeDisconnect(hConv);
		hConv = (HCONV) NULL;
	}
	if (hszTopic)
	{
		DdeFreeStringHandle(g_dwInstance, hszTopic);
		hszTopic = NULL;
	}
	if (hszItem)
	{
		DdeFreeStringHandle(g_dwInstance, hszItem);
		hszItem = NULL;
	}

	return -1;
}



//+---------------------------------------------------------------------------
//
//  Function:   DDEClose
//
//  Synopsis:   Shutsdown DDE and releases string handles
//				Warning: This function uses global static variables and hence
//						 it is not re-entrant.
//
//  Arguments:  None
//
//	Returns:	Nothing
//
//  History:    8/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
void DDEClose(void)
{
	Dprintf("DDEClose called\r\n");
	
	if (0 != g_dwInstance)
	{
		if (hConv)
		{
			DdeDisconnect(hConv);
			hConv = (HCONV) NULL;
		}
		
		if (hszTopic)
		{
			DdeFreeStringHandle(g_dwInstance, hszTopic);
			hszTopic = NULL;
		}
		if (hszItem)
		{
			DdeFreeStringHandle(g_dwInstance, hszItem);
			hszItem = NULL;
		}
		if (hszMosaicService)
		{
			DdeFreeStringHandle(g_dwInstance, hszMosaicService);
			hszMosaicService = NULL;
		}

		DdeUninitialize(g_dwInstance);
		g_dwInstance = 0;
	}

	return;
}





//+---------------------------------------------------------------------------
//
//  Function:   DDEinit
//
//  Synopsis:   Intializes DDE, creates string handles for service 
//				and registers the names.
//				Warning: This function uses global static variables and hence
//						 it is not re-entrant.
//
//  Arguments:  [hInst - Instance handle]
//
//	Returns:	0 if successful
//				Negative values, otherwise
//
//  History:    8/9/96     VetriV    Created
//              8/29/96    jmazner	 Removed calls to make us a DDE server,
//									 moved string handle code to openUrl
//
//----------------------------------------------------------------------------
int DDEInit(HINSTANCE hInst)
{
	UINT uiRetValue;

	Dprintf("DDEInit called with %u\r\n", hInst);

	if (g_dwInstance == 0)
	{
		lpfnDDEProc = MakeProcInstance((FARPROC) DdeCallBack, hInst);
		if (NULL == lpfnDDEProc)
		{
			Dprintf("MakeProcInstance failed");
			return -1;
		}

		uiRetValue = DdeInitialize(&g_dwInstance, (PFNCALLBACK) lpfnDDEProc, 
										APPCLASS_STANDARD, 0);
		if (DMLERR_NO_ERROR != uiRetValue)
		{
			Dprintf("DdeInitialize failed with %u\r\n", uiRetValue);
			g_dwInstance = 0;
			return -2;
		}
	}
	

	
	hszMosaicService = DdeCreateStringHandle(g_dwInstance, TEXT("IEXPLORE"), CP_WINANSI);
	if (NULL == hszMosaicService)
	{
		Dprintf("DdeCreateStringHandle for IEXPLORE failed with %u\r\n", 
					DdeGetLastError(g_dwInstance));
	}



	return( TRUE );
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\isignole.h ===
//****************************************************************************
//
//  File:       isignole.h
//
//  Content:    This is the include file with the Ole Automation stuff needed by
//				isignup.cpp and sink.cpp.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//
//  Copyright (c) Microsoft Corporation 1996
//
//****************************************************************************

//WIN32 wrappers for these?


#include <objbase.h>

#include <exdisp.h>
#include <exdispid.h>

#include <olectl.h>
#include <ocidl.h>



extern IConnectionPoint * GetConnectionPoint(void);
extern HRESULT InitOle( void );
extern HRESULT KillOle( void );
extern HRESULT IENavigate( TCHAR *szURL );


class CDExplorerEvents : public DWebBrowserEvents
{
    private:
        ULONG       m_cRef;     //Reference count
        //PAPP        m_pApp;     //For calling Message
        //UINT        m_uID;      //Sink identifier

    public:
        //Connection key, public for CApp's usage
        DWORD       m_dwCookie;

    public:
        CDExplorerEvents( void );
        ~CDExplorerEvents(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, VOID * *);
        STDMETHODIMP_(DWORD) AddRef(void);
        STDMETHODIMP_(DWORD) Release(void);

        /* IDispatch methods */
        STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

        STDMETHOD(GetTypeInfo)(UINT itinfo,LCID lcid,ITypeInfo FAR* FAR* pptinfo);

        STDMETHOD(GetIDsOfNames)(REFIID riid,OLECHAR FAR* FAR* rgszNames,UINT cNames,
              LCID lcid, DISPID FAR* rgdispid);

        STDMETHOD(Invoke)(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                  DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\import.cpp ===
//****************************************************************************
//
//  Module:     ISIGNUP.EXE
//  File:       import.c
//  Content:    This file contains all the functions that handle importing
//              connection information.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//          this code started its life as ixport.c in RNAUI.DLL
//          my thanks to viroont
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "isignup.h"

#define MAXNAME         80
#define MAXIPADDRLEN    20
#define SIZE_ReadBuf    0x00008000    // 32K buffer size

//#pragma data_seg(".rdata")

static const TCHAR cszEntrySection[] = TEXT("Entry");
static const TCHAR cszEntryName[]    = TEXT("Entry_Name");
static const TCHAR cszAlias[]        = TEXT("Import_Name");
static const TCHAR cszML[]           = TEXT("Multilink");

static const TCHAR cszPhoneSection[] = TEXT("Phone");
static const TCHAR cszDialAsIs[]     = TEXT("Dial_As_Is");
static const TCHAR cszPhone[]        = TEXT("Phone_Number");
static const TCHAR cszAreaCode[]     = TEXT("Area_Code");
static const TCHAR cszCountryCode[]  = TEXT("Country_Code");
static const TCHAR cszCountryID[]    = TEXT("Country_ID");

static const TCHAR cszDeviceSection[] = TEXT("Device");
static const TCHAR cszDeviceType[]    = TEXT("Type");
static const TCHAR cszDeviceName[]    = TEXT("Name");
static const TCHAR cszDevCfgSize[]    = TEXT("Settings_Size");
static const TCHAR cszDevCfg[]        = TEXT("Settings");

static const TCHAR cszServerSection[] = TEXT("Server");
static const TCHAR cszServerType[]    = TEXT("Type");
static const TCHAR cszSWCompress[]    = TEXT("SW_Compress");
static const TCHAR cszPWEncrypt[]     = TEXT("PW_Encrypt");
static const TCHAR cszNetLogon[]      = TEXT("Network_Logon");
static const TCHAR cszSWEncrypt[]     = TEXT("SW_Encrypt");
static const TCHAR cszNetBEUI[]       = TEXT("Negotiate_NetBEUI");
static const TCHAR cszIPX[]           = TEXT("Negotiate_IPX/SPX");
static const TCHAR cszIP[]            = TEXT("Negotiate_TCP/IP");
static TCHAR cszDisableLcp[]          = TEXT("Disable_LCP");

static const TCHAR cszIPSection[]     = TEXT("TCP/IP");
static const TCHAR cszIPSpec[]        = TEXT("Specify_IP_Address");
static const TCHAR cszIPAddress[]     = TEXT("IP_address");
static const TCHAR cszServerSpec[]    = TEXT("Specify_Server_Address");
static const TCHAR cszDNSAddress[]    = TEXT("DNS_address");
static const TCHAR cszDNSAltAddress[] = TEXT("DNS_Alt_address");
static const TCHAR cszWINSAddress[]   = TEXT("WINS_address");
static const TCHAR cszWINSAltAddress[]= TEXT("WINS_Alt_address");
static const TCHAR cszIPCompress[]    = TEXT("IP_Header_Compress");
static const TCHAR cszWanPri[]        = TEXT("Gateway_On_Remote");

static const TCHAR cszMLSection[]     = TEXT("Multilink");
static const TCHAR cszLinkIndex[]     = TEXT("Line_%s");

static const TCHAR cszScriptingSection[] = TEXT("Scripting");
static const TCHAR cszScriptName[]    = TEXT("Name");

static const TCHAR cszScriptSection[] = TEXT("Script_File");

#if !defined(WIN16)
static const TCHAR cszCustomDialerSection[] = TEXT("Custom_Dialer");
static const TCHAR cszAutoDialDLL[] = TEXT("Auto_Dial_DLL");
static const TCHAR cszAutoDialFunc[] = TEXT("Auto_Dial_Function");
#endif //!WIN16

static const TCHAR cszYes[]           = TEXT("yes");
static const TCHAR cszNo[]            = TEXT("no");

static const TCHAR cszUserSection[]   = TEXT("User");
static const TCHAR cszUserName[]      = TEXT("Name");
static const TCHAR cszPassword[]      = TEXT("Password");

static const TCHAR cszNull[] = TEXT("");

struct {
    TCHAR *szType;
    DWORD dwType;
    DWORD dwfOptions;
} aServerTypes[] =
{ 
    {TEXT("PPP"),     RASFP_Ppp,  0},
    {TEXT("SLIP"),    RASFP_Slip, 0},
    {TEXT("CSLIP"),   RASFP_Slip, RASEO_IpHeaderCompression},
    {TEXT("RAS"),     RASFP_Ras,  0}
};

//#pragma data_seg()

#define myisdigit(ch) (((ch) >= '0') && ((ch) <= '9'))

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//	Function:	ImportCustomDialer
//
//	Synopsis:	Import custom dialer information from the specified file
//				and save the information in the RASENTRY
//
//	Arguments:	lpRasEntry - pointer to a valid RASENTRY structure
//				szFileName - text file (in .ini file format) containing the
//				Custom Dialer information
//
//	Returns:	ERROR_SUCCESS - success otherwise a Win32 error
//
//	History:	ChrisK	Created		7/11/96
//			8/12/96	ChrisK	Ported from \\trango
//
//-----------------------------------------------------------------------------
DWORD ImportCustomDialer(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{

	// If there is an error reading the information from the file, or the entry
	// missing or blank, the default value (cszNull) will be used.
	GetPrivateProfileString(cszCustomDialerSection,
	                        cszAutoDialDLL,
	                        cszNull,
	                        lpRasEntry->szAutodialDll,
	                        MAX_PATH,
	                        szFileName);

	GetPrivateProfileString(cszCustomDialerSection,
	                        cszAutoDialFunc,
	                        cszNull,
	                        lpRasEntry->szAutodialFunc,
	                        MAX_PATH,
	                        szFileName);

	return ERROR_SUCCESS;
}
#endif //!WIN16

//****************************************************************************
// DWORD NEAR PASCAL StrToip (LPTSTR szIPAddress, LPDWORD lpdwAddr)
//
// This function converts a IP address string to an IP address structure.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Cloned from SMMSCRPT.
//****************************************************************************

LPCTSTR NEAR PASCAL StrToSubip (LPCTSTR szIPAddress, LPBYTE pVal)
{
  LPCTSTR pszIP = szIPAddress;
  BYTE val = 0;

  // skip separators (non digits)
  while (*pszIP && !myisdigit(*pszIP))
  {
      ++pszIP;
  }

  while (myisdigit(*pszIP))
  {
      val = (val * 10) + (BYTE)(*pszIP - '0');
      ++pszIP;
  }
   
  *pVal = val;

  return pszIP;
}


DWORD NEAR PASCAL StrToip (LPCTSTR szIPAddress, RASIPADDR *ipAddr)
{
  LPCTSTR pszIP = szIPAddress;

  pszIP = StrToSubip(pszIP, &ipAddr->a);
  pszIP = StrToSubip(pszIP, &ipAddr->b);
  pszIP = StrToSubip(pszIP, &ipAddr->c);
  pszIP = StrToSubip(pszIP, &ipAddr->d);

  return ERROR_SUCCESS;
}


//****************************************************************************
// DWORD NEAR PASCAL ImportPhoneInfo(PPHONENUM ppn, LPCTSTR szFileName)
//
// This function imports the phone number.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szYesNo[MAXNAME];

  if (GetPrivateProfileString(cszPhoneSection,
                              cszPhone,
                              cszNull,
                              lpRasEntry->szLocalPhoneNumber,
                              RAS_MaxPhoneNumber,
                              szFileName) == 0)
  {
    return ERROR_BAD_PHONE_NUMBER;
  };

  lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

  GetPrivateProfileString(cszPhoneSection,
                          cszDialAsIs,
                          cszNo,
                          szYesNo,
                          MAXNAME,
                          szFileName);

  // Do we have to get country code and area code?
  //
  if (!lstrcmpi(szYesNo, cszNo))
  {

    // If we cannot get the country ID or it is zero, default to dial as is
    //
    if ((lpRasEntry->dwCountryID = GetPrivateProfileInt(cszPhoneSection,
                                                 cszCountryID,
                                                 0,
                                                 szFileName)) != 0)
    {
      lpRasEntry->dwCountryCode = GetPrivateProfileInt(cszPhoneSection,
                                                cszCountryCode,
                                                1,
                                                szFileName);

      GetPrivateProfileString(cszPhoneSection,
                              cszAreaCode,
                              cszNull,
                              lpRasEntry->szAreaCode,
                              RAS_MaxAreaCode,
                              szFileName);

      lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;

    }
  }
#ifdef WIN32
  else
  {
      // bug in RasSetEntryProperties still checks area codes
      // even when RASEO_UseCountryAndAreaCodes is not set
      lstrcpy(lpRasEntry->szAreaCode, TEXT("805"));
      lpRasEntry->dwCountryID = 1;
      lpRasEntry->dwCountryCode = 1;
  }
#endif
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportServerInfo(PSMMINFO psmmi, LPTSTR szFileName)
//
// This function imports the server type name and settings.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportServerInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szYesNo[MAXNAME];
  TCHAR   szType[MAXNAME];
  DWORD  i;

  // Get the server type name
  //
  GetPrivateProfileString(cszServerSection,
                          cszServerType,
                          cszNull,
                          szType,
                          MAXNAME,
                          szFileName);

  // need to convert the string into
  // one of the following values
  //   RASFP_Ppp
  //   RASFP_Slip  Note CSLIP is SLIP with IP compression on
  //   RASFP_Ras

  for (i = 0; i < sizeof(aServerTypes)/sizeof(aServerTypes[0]); ++i)
  {
    if (!lstrcmpi(aServerTypes[i].szType, szType))
    {
       lpRasEntry->dwFramingProtocol = aServerTypes[i].dwType;
       lpRasEntry->dwfOptions |= aServerTypes[i].dwfOptions;
       break;
    }
  }

  // Get the server type settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszSWCompress,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_SwCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_SwCompression;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszPWEncrypt,
                              cszNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireEncryptedPw;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszNetLogon,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_NetworkLogon;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_NetworkLogon;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszSWEncrypt,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireDataEncryption;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
    };
  };

  // Get the protocol settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszNetBEUI,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfNetProtocols &= ~RASNP_NetBEUI;
    }
    else
    {
      lpRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIPX,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfNetProtocols &= ~RASNP_Ipx;
    }
    else
    {
      lpRasEntry->dwfNetProtocols |= RASNP_Ipx;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIP,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfNetProtocols &= ~RASNP_Ip;
    }
    else
    {
      lpRasEntry->dwfNetProtocols |= RASNP_Ip;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszDisableLcp,
							  cszNull,
							  szYesNo,
							  MAXNAME,
							  szFileName))
  {
	if (!lstrcmpi(szYesNo, cszYes))
	{
		lpRasEntry->dwfOptions |= RASEO_DisableLcpExtensions;
	}
	else
	{
		lpRasEntry->dwfOptions &= ~RASEO_DisableLcpExtensions;
	}
  };

  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportIPInfo(LPTSTR szEntryName, LPTSTR szFileName)
//
// This function imports the TCP/IP information
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportIPInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szIPAddr[MAXIPADDRLEN];
  TCHAR   szYesNo[MAXNAME];

  // Import IP address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPSpec,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has IP address specified, get the IP address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
      if (GetPrivateProfileString(cszIPSection,
                                  cszIPAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddr);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;
    };
  };

  // Import Server address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszServerSpec,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has server address specified, get the server address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDns);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAltAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDnsAlt);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWins);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAltAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWinsAlt);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
    };
  };

  // Header compression and the gateway settings
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPCompress,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_IpHeaderCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
    };
  };

  if (GetPrivateProfileString(cszIPSection,
                              cszWanPri,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RemoteDefaultGateway;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
    };
  };

  return ERROR_SUCCESS;
}

DWORD NEAR PASCAL ImportScriptFile(
    LPCTSTR lpszImportFile,
    LPTSTR szScriptFile,
    UINT cbScriptFile)
{
    TCHAR szTemp[_MAX_PATH];
    DWORD dwRet = ERROR_SUCCESS;
    
    // Get the script filename
    //
    if (GetPrivateProfileString(cszScriptingSection,
                                cszScriptName,
                                cszNull,
                                szTemp,
                                _MAX_PATH,
                                lpszImportFile) != 0)
    {
 
//!!! commonize this code
//!!! make it DBCS compatible
//!!! check for overruns
//!!! check for absolute path name
        GetWindowsDirectory(szScriptFile, cbScriptFile);
        if (*CharPrev(szScriptFile, szScriptFile + lstrlen(szScriptFile)) != '\\')
        {
            lstrcat(szScriptFile, TEXT("\\"));
        }
        lstrcat(szScriptFile, szTemp);
  
        dwRet =ImportFile(lpszImportFile, cszScriptSection, szScriptFile);
    }

    return dwRet;
}
 
//****************************************************************************
// DWORD WINAPI RnaValidateImportEntry (LPTSTR)
//
// This function is called to validate an importable file
//
// History:
//  Wed 03-Jan-1996 09:45:01  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD WINAPI RnaValidateImportEntry (LPCTSTR szFileName)
{
  TCHAR  szTmp[MAX_PATH+1];

  // Get the alias entry name
  //
  // 12/4/96	jmazner	Normandy #12373
  // If no such key, don't return ERROR_INVALID_PHONEBOOK_ENTRY,
  // since ConfigureClient always ignores that error code.

  return (GetPrivateProfileString(cszEntrySection,
                                  cszEntryName,
                                  cszNull,
                                  szTmp,
                                  MAX_PATH,
                                  szFileName) > 0 ?
          ERROR_SUCCESS : ERROR_NO_MATCH);
}

//****************************************************************************
// DWORD WINAPI RnaImportEntry (LPTSTR, LPBYTE, DWORD)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD ImportRasEntry (LPCTSTR szFileName, LPRASENTRY lpRasEntry)
{
    DWORD         dwRet;

    dwRet = ImportPhoneInfo(lpRasEntry, szFileName);
    if (ERROR_SUCCESS == dwRet)
    {
        // Get device type
        //
        GetPrivateProfileString(cszDeviceSection,
                              cszDeviceType,
                              cszNull,
                              lpRasEntry->szDeviceType,
                              RAS_MaxDeviceType,
                              szFileName);
        
        // Get Server Type settings
        //
        dwRet = ImportServerInfo(lpRasEntry, szFileName);
        if (ERROR_SUCCESS == dwRet)
        {
            // Get IP address
            //
            dwRet = ImportIPInfo(lpRasEntry, szFileName);
        }
    }

    return dwRet;
}


//****************************************************************************
// DWORD WINAPI RnaImportEntry (LPTSTR, LPBYTE, DWORD)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD ImportConnection (LPCTSTR szFileName, LPICONNECTION lpConn)
{
    DWORD   dwRet;

    lpConn->RasEntry.dwSize = sizeof(RASENTRY);

    dwRet = RnaValidateImportEntry(szFileName);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    GetPrivateProfileString(cszEntrySection,
                          cszEntryName,
                          cszNull,
                          lpConn->szEntryName,
                          RAS_MaxEntryName,
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszUserName,
                          cszNull,
                          lpConn->szUserName,
                          UNLEN,
                          szFileName);
  
    GetPrivateProfileString(cszUserSection,
                          cszPassword,
                          cszNull,
                          lpConn->szPassword,
                          PWLEN,
                          szFileName);
  
    dwRet = ImportRasEntry(szFileName, &lpConn->RasEntry);
#if !defined(WIN16)
    if (ERROR_SUCCESS == dwRet)
    {
        dwRet = ImportCustomDialer(&lpConn->RasEntry, szFileName);
    }
#endif //!WIN16

    if (ERROR_SUCCESS == dwRet)
    {
        // Import the script file
        //
        dwRet = ImportScriptFile(szFileName,
                lpConn->RasEntry.szScript,
                sizeof(lpConn->RasEntry.szScript)/sizeof(TCHAR));
    }

#if !defined(WIN16)
	dwRet = ConfigRasEntryDevice(&lpConn->RasEntry);
	switch( dwRet )
	{
		case ERROR_SUCCESS:
			break;
		case ERROR_CANCELLED:
			InfoMsg(NULL, IDS_SIGNUPCANCELLED);
			// Fall through
		default:
			goto ImportConnectionExit;
	}

#endif

ImportConnectionExit:
  return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\isignup.h ===
//****************************************************************************
//
//  Module:     ISIGNUP.EXE
//  File:       isignup.h
//  Content:    This is the "main" include file for the internet signup "wizard".
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#ifndef ISIGNUP_H
#define ISIGNUP_H


#ifdef DEBUG

#define DebugOut(sz)    OutputDebugString(sz)

void _ISIGN32_Assert(LPCTSTR, unsigned);

#define ISIGN32_ASSERT(f)        \
    if (f)                  \
        {}                  \
    else                    \
        _ISIGN32_Assert(TEXT(__FILE__), __LINE__)

#else

#define DebugOut(sz)

#define ISIGN32_ASSERT(f)

#endif

#include <windows.h>

#ifdef WIN32
#include <regstr.h>
#endif

#ifdef WIN32
#include <ras.h>
#include <raserror.h>
//#include <rnaph.h>
#include "ras2.h"
#else
#include <rasc.h>
#include <raserr.h>
#endif        

#ifdef WIN32
#define EXPORT
#else
//typedef DWORD HRESULT;
#include <shellapi.h>
#include <ctype.h>
#include <win16def.h>
#define CharPrev(start, current) (((LPTSTR)(current)) - 1)
#define CharNext(current) (((LPTSTR)(current)) + 1)
#define LocalAlloc(flag, size)	MyLocalAlloc(flag, size)
#define LocalFree(lpv) MyLocalFree(lpv)
//#define ERROR_PATH_NOT_FOUND    ERROR_CANTOPEN
#define EXPORT _export
#endif

#include "icwunicd.h"
#include "..\inc\inetcfg.h"
#include "extfunc.h"
#include "rsrc.h"

#define WM_PROCESSISP WM_USER + 1 //used by IE OLE Automation

// 8/19/96 jmazner  Normandy #4571
#ifdef WIN32
// Note that bryanst and marcl have confirmed that this key will work for IE 3 and IE 4
#define IE_PATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE")

#define ICW20_PATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE")

// Lowest IE we want to work with is IE 3,
//     which has major.minor.release.build version # > 4.70.0.1155
// (note that IE 2 has major.minor of 4.40)
//
// The HUMAN_READABLE string will be inserted into the IDS_IELOWVERSION string. Keep it in sync
// with the major.minor version numbers
#define IE_MINIMUM_VERSION_HUMAN_READABLE TEXT("3.0") 
#define IE_MINIMUM_MAJOR_VERSION (UINT) 4
#define IE_MINIMUM_MINOR_VERSION (UINT) 70
#define IE_MINIMUM_RELEASE_VERSION (UINT) 0
#define IE_MINIMUM_BUILD_VERSION (UINT) 1155
#define IE_MINIMUM_VERSIONMS (DWORD) ((IE_MINIMUM_MAJOR_VERSION << 16) | IE_MINIMUM_MINOR_VERSION)
#define IE_MINIMUM_VERSIONLS (DWORD) ((IE_MINIMUM_RELEASE_VERSION << 16) | IE_MINIMUM_BUILD_VERSION)

#define ICW20_MINIMUM_VERSION_HUMAN_READABLE TEXT("4.0") 
#define ICW20_MINIMUM_MAJOR_VERSION (UINT) 4
#define ICW20_MINIMUM_MINOR_VERSION (UINT) 72
#define ICW20_MINIMUM_RELEASE_VERSION (UINT) 0
#define ICW20_MINIMUM_BUILD_VERSION (UINT) 3012
#define ICW20_MINIMUM_VERSIONMS (DWORD) ((ICW20_MINIMUM_MAJOR_VERSION << 16) | ICW20_MINIMUM_MINOR_VERSION)
#define ICW20_MINIMUM_VERSIONLS (DWORD) ((ICW20_MINIMUM_RELEASE_VERSION << 16) | ICW20_MINIMUM_BUILD_VERSION)

#endif

#define ACCTMGR_PATHKEY TEXT("SOFTWARE\\Microsoft\\Internet Account Manager")
#define ACCTMGR_DLLPATH TEXT("DllPath")


#define MAX_URL     1024
//#define REGSTR_PATH_IEXPLORER           "Software\\Microsoft\\Internet Explorer"
//#define REGSTR_PATH_IE_MAIN             REGSTR_PATH_IEXPLORER "\\Main"

#define SIZEOF_TCHAR_BUFFER(buf)    ((sizeof(buf) / sizeof(TCHAR)))
#define NULL_TERM_TCHAR_BUFFER(buf); {buf[SIZEOF_TCHAR_BUFFER(buf)-1] = TEXT('\0');}

typedef struct
{
    TCHAR          szEntryName[RAS_MaxEntryName+1];
    TCHAR          szUserName[UNLEN+1];
    TCHAR          szPassword[PWLEN+1];
    TCHAR          szScriptFile[_MAX_PATH+1];
    RASENTRY       RasEntry;
} ICONNECTION, FAR * LPICONNECTION;

 
extern DWORD ConfigureClient(
    HWND hwnd,
    LPCTSTR lpszFile,
    LPBOOL lpfNeedsRestart,
    LPBOOL fConnectiodCreated,
    BOOL fHookAutodial,
    LPTSTR szConnectoidName,
    DWORD dwConnectoidNameSize   
    );
extern DWORD ImportFile (
    LPCTSTR lpszImportFile,
    LPCTSTR lpszSection,
    LPCTSTR lpszOutputFile);
extern DWORD ImportConnection (
    LPCTSTR szFileName,
    LPICONNECTION lpConnection);
extern DWORD ImportClientInfo (
    LPCTSTR lpszFileName,
    LPINETCLIENTINFO lpClientInfo);
extern DWORD ImportCustomInfo (
    LPCTSTR lpszImportFile,
    LPTSTR lpszExecutable,
    DWORD cbExecutable,
    LPTSTR lpszArgument,
    DWORD cbArgument);
extern DWORD ImportCustomFile (LPCTSTR lpszFileName);
extern DWORD ImportFavorites (LPCTSTR lpszFileName);
extern DWORD ImportBrandingInfo (LPCTSTR pszIns, LPCTSTR lpszConnectoidName);
#ifdef WIN32
extern DWORD CallSBSConfig(HWND hwnd, LPCTSTR lpszINSFile);
#endif
//extern DWORD ImportProxySettings(LPCTSTR lpszFile);
extern BOOL WantsExchangeInstalled(LPCTSTR lpszFile);

extern BOOL ProcessISP(HWND hwnd, LPCTSTR lpszFile);


extern BOOL WarningMsg(HWND hwnd, UINT uId);
extern void ErrorMsg(HWND hwnd, UINT uId);
extern void ErrorMsg1(HWND hwnd, UINT uId, LPCTSTR lpszArg);
extern void InfoMsg(HWND hwnd, UINT uId);
extern BOOL PromptRestart(HWND hwnd);
extern BOOL PromptRestartNow(HWND hwnd);
extern VOID CenterWindow(HWND hwndChild, HWND hwndParent);

// 8/16/96 jmazner  Normandy #4593   This is what puts up the huge background "screen o death"
//extern HWND SplashInit(HWND hwnd);

extern HWND ProgressInit(HWND hwnd);

extern DWORD SignupLogon(HWND hwndParent);

extern TCHAR FAR cszWndClassName[];
extern TCHAR FAR cszAppName[];
extern HINSTANCE ghInstance;

#ifdef WIN16

CHAR*  GetPassword();

#else

TCHAR* GetPassword();
BOOL  IsRASReady();

#endif

HWND GetHwndMain();

BOOL IsCurrentlyProcessingISP();

BOOL NeedBackupSecurity();

extern HRESULT WINAPI StatusMessageCallback(DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize);
extern HRESULT LoadDialErrorString(HRESULT hrIN,LPTSTR lpszBuff, DWORD dwBufferSize);

#ifdef WIN16
extern LPVOID MyLocalAlloc(DWORD flag, DWORD size);
extern LPVOID MyLocalFree(LPVOID lpv);
#endif

int DDEInit(HINSTANCE);
void DDEClose(void);
int OpenURL(LPCTSTR);

#if !defined(WIN16)
extern BOOL LclSetEntryScriptPatch(LPTSTR lpszScript,LPTSTR lpszEntry);
extern DWORD ConfigRasEntryDevice( LPRASENTRY lpRasEntry );

extern BOOL IsNT(void);

inline BOOL IsNT(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}

#endif //!win16

typedef enum
{
    UNKNOWN_FILE,
    INS_FILE,
    ISP_FILE,
    HTML_FILE
}  INET_FILETYPE;


#define HARDCODED_IEAK_ISP_FILENAME TEXT("signup.isp")

#endif /* ISIGNUP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\isignole.cpp ===
/*----------------------------------------------------------------------------
	isignole.cpp

	Contains the functions that control IE OLE Automation for ISIGN32

	Copyright (C) 1995-96 Microsoft Corporation
	All right reserved

  Authors:
	jmazner		Jeremy Mazner

  History:
	9/27/96		jmazner		Created.  Most of this code is stolen from josephh's CONNECT.EXE
							source code at \\josephh8\connect\sink.cpp.
							He in turn stole most of the code from examples in Brockshmidt's
							"Inside OLE, 2nd edition"

							Comments from CDExplorerEvents functions are from josephh
----------------------------------------------------------------------------*/

#include "isignup.h"

#ifdef WIN32
#define INITGUID

#include "isignole.h"
// 4-29-97 ChrisK Olympus 131
#include <urlmon.h>


EXTERN_C const GUID DIID_DWebBrowserEvents;

EXTERN_C const GUID IID_IWebBrowserApp;

#endif


extern INET_FILETYPE GetInetFileType(LPCTSTR lpszFile);

extern IWebBrowserApp FAR * g_iwbapp;
extern CDExplorerEvents * g_pMySink;
extern IConnectionPoint	*g_pCP;
extern TCHAR	g_szISPPath[MAX_URL + 1];

extern BOOL CreateSecurityPatchBackup( void );




/*****************************************************
**
** Function: CDExplorerEvents::CDExplorerEvents
**
** Description: Constructor for CDExplorerEvents
**
** Because we stole this code from a sample app, we
** need to decide if we should do reference counts.
** It works ok without it in simple senerios, but
** we should probably research this area, and update
** the code to handle this properly.
**
** Parameters:
**
**
** Returns: Not
**
**
******************************************************/

CDExplorerEvents::CDExplorerEvents( void )
    {
	DebugOut("CDExplorerEvents:: constructor.\n");
    m_cRef=0;
    m_dwCookie=0;
    return;
    }

/*****************************************************
**
** Function: CDExplorerEvents::~CDExplorerEvents
**
** Description: Destructor for CDExplorerEvents
**
** Parameters: Not
**
** Returns: Not
**
**
******************************************************/

CDExplorerEvents::~CDExplorerEvents(void)
	{
	DebugOut("CDExplorerEvents:: destructor.\n");
    return;
	}



/*****************************************************
**
** Function: CDExplorerEvents::QueryInterface
**
** Description: Is called to QueryInterface for DExplorerEvents.
**
** Parameters:
**
** REFIID riid,  //Reference ID
** LPVOID FAR* ppvObj //Pointer to this object
**
** Returns:
** S_OK if interface supported
** E_NOINTERFACE if not
**
******************************************************/

STDMETHODIMP CDExplorerEvents::QueryInterface (
   REFIID riid,  //Reference ID
   LPVOID FAR* ppvObj //Pointer to this object
   )
{
    if (IsEqualIID(riid, IID_IDispatch)
           )
    {
        *ppvObj = (DWebBrowserEvents *)this;
        AddRef();
        DebugOut("CDExplorerEvents::QueryInterface IID_IDispatch returned S_OK\r\n");
        return S_OK;
    }

    if (
    IsEqualIID(riid, DIID_DWebBrowserEvents)
           )
    {
        *ppvObj = (DWebBrowserEvents *)this;
        AddRef();
        DebugOut("CDExplorerEvents::QueryInterface DIID_DExplorerEvents returned S_OK\r\n");
        return S_OK;
    }

    if (
    IsEqualIID(riid, IID_IUnknown)
           )
    {
        *ppvObj = (DWebBrowserEvents *)this;
        AddRef();
        DebugOut("CDExplorerEvents::QueryInterface IID_IUnknown returned S_OK\r\n");
        return S_OK;
    }


    DebugOut("CDExplorerEvents::QueryInterface returned E_NOINTERFACE\r\n");
    return E_NOINTERFACE;
}

/*****************************************************
**
** Function: CDExplorerEvents::AddRef
**
** Description: Increments the Reference Count for this
** object.
**
** Parameters: Not
**
** Returns: New Reference Count
**
******************************************************/


STDMETHODIMP_(ULONG) CDExplorerEvents::AddRef(void)
    {
	DebugOut("CDExplorerEvents:: AddRef.\n");
    return ++m_cRef;
    }

/*****************************************************
**
** Function: CDExplorerEvents::Release
**
** Description: Decrements the reference count, frees
** the object if zero.
**
** Parameters: not
**
** Returns: decremented reference count
**
******************************************************/

STDMETHODIMP_(ULONG) CDExplorerEvents::Release(void)
    {
	DebugOut("CDExplorerEvents:: Release.\n");
    if (0!=--m_cRef)
        return m_cRef;

    delete this;
    return 0;
    }


/*****************************************************
**
** Function: CDExplorerEvents::GetTypeInfoCount
**
** Description: GetTypeInfoCount is required, but STUBBED
**
** Parameters: Not used
**
** Returns: E_NOTIMPL
**
******************************************************/


STDMETHODIMP  CDExplorerEvents::GetTypeInfoCount (UINT FAR* pctinfo)
{
    return E_NOTIMPL;
}

/*****************************************************
**
** Function: CDExplorerEvents::GetTypeInfo
**
** Description: GetTypeInfo is required, but STUBBED
**
** Parameters: Not used
**
** Returns: E_NOTIMPL
**
******************************************************/

STDMETHODIMP CDExplorerEvents::GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo FAR* FAR* pptinfo)
{
    return E_NOTIMPL;
}

/*****************************************************
**
** Function: CDExplorerEvents::GetIDsOfNames
**
** Description: GetIDsOfNames is required, but STUBBED
**
** Parameters: Not used
**
** Returns: E_NOTIMPL
**
******************************************************/

STDMETHODIMP CDExplorerEvents::GetIDsOfNames (REFIID riid,OLECHAR FAR* FAR* rgszNames,UINT cNames,
      LCID lcid, DISPID FAR* rgdispid)
{
    return E_NOTIMPL;
}


/*****************************************************
**
** Function: CDExplorerEvents::Invoke
**
** Description: This is the callback for our IE event sink.
**
**				jmazner -- we only handle two events:
**					BEFORENAVIGATE: check whether the UEL is an .isp file.
**									if so, cancel the navigation and signal processISP
**									Otherwise, allow the navigation to continue
**									(note  that this means .ins files are handled by IE
**									 execing another instance of isignup)
**					QUIT: we want to release our hold on IWebBrowserApp; if we send the quit
**							ourselves, this is actually done in KillOle, but if IE quits of
**							its own accord, we have to handle it here.
**
** Parameters:  Many
**
** Returns: S_OK
**
******************************************************/

STDMETHODIMP CDExplorerEvents::Invoke (
   DISPID dispidMember,
   REFIID riid,
   LCID lcid,
   WORD wFlags,
   DISPPARAMS FAR* pdispparams,
   VARIANT FAR* pvarResult,
   EXCEPINFO FAR* pexcepinfo,
   UINT FAR* puArgErr
   )
{
	INET_FILETYPE fileType;
	DWORD dwresult;
	HRESULT hresult;
	DWORD szMultiByteLength;
	TCHAR *szTheURL = NULL;

	static fAlreadyBackedUpSecurity = FALSE;

	switch (dispidMember)
    {	
	case DISPID_BEFORENAVIGATE:
		DebugOut("CDExplorerEvents::Invoke (DISPID_NAVIGATEBEGIN) called\r\n");
		//Assert( pdispparams->cArgs == 6 )
	//TODO UNDONE what's the right way to figure out which arg is which???
#ifndef UNICODE
		szMultiByteLength = WideCharToMultiByte(
			CP_ACP,
			NULL,
			pdispparams->rgvarg[5].bstrVal, // first arg is URL
			-1, //NUll terminated?  I hope so!
			NULL, //tell us how long the string needs to be
			0,
			NULL,
			NULL);

		if( 0 == szMultiByteLength )
		{
			DebugOut("ISIGNUP: CDExplorerEvents::Invoke couldn't determine ASCII URL length\r\n");
			dwresult = GetLastError();
			hresult = HRESULT_FROM_WIN32( dwresult );
			return( hresult );
		}

		szTheURL = (CHAR *) GlobalAlloc( GPTR, sizeof(CHAR) * szMultiByteLength );

		if( !szTheURL )
		{
			DebugOut("ISIGNUP: CDExplorerEvents::Invoke couldn't allocate szTheURL\r\n");
			hresult = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
			return( hresult );
		}

		dwresult = WideCharToMultiByte(
			CP_ACP,
			NULL,
			pdispparams->rgvarg[5].bstrVal, // first arg is URL
			-1, //NUll terminated?  I hope so!
			szTheURL,
			szMultiByteLength,
			NULL,
			NULL);

		if( 0 == dwresult )
		{
			DebugOut("ISIGNUP: CDExplorerEvents::Invoke WideCharToMultiByte failed\r\n");
			dwresult = GetLastError();
			hresult = HRESULT_FROM_WIN32( dwresult );
			return( hresult );
		}
#else  // UNICODE
		szTheURL = (TCHAR *) GlobalAlloc( GPTR, sizeof(TCHAR) * (lstrlen(pdispparams->rgvarg[5].bstrVal)+1) );
        if (!szTheURL)
		{
			hresult = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
			return( hresult );
		}
                lstrcpy(szTheURL, pdispparams->rgvarg[5].bstrVal);
#endif // UNICODE


		fileType = GetInetFileType(szTheURL);

		DebugOut("ISIGNUP: BEFORENAVIGATE got '");
		DebugOut(szTheURL);
		DebugOut("'\r\n");

		if( ISP_FILE != fileType)
		{
			// let IE process as normal
			return( S_OK );
		}
		else
		{
			// cancel the navigation
			//TODO UNDONE BUG  what's the right way to find which argument is cancel flag?
			
			// jmazner 11/6/96 alpha build
			// Alpha doesn't like pbool field, but pboolVal seems to work
			// Should make no difference, it's just one big union
			//*(pdispparams->rgvarg[0].pbool) = TRUE;
			*(pdispparams->rgvarg[0].pboolVal) = TRUE;

			if (!IsCurrentlyProcessingISP())
			{
				lstrcpy( g_szISPPath, szTheURL );
			}
			GlobalFree( szTheURL );

			PostMessage(GetHwndMain(), WM_PROCESSISP, 0, 0);

		}
		break;

	case DISPID_NAVIGATECOMPLETE:
		DebugOut("CDExplorerEvents::Invoke (DISPID_NAVIGATECOMPLETE) called\r\n");
		if( NeedBackupSecurity() && !fAlreadyBackedUpSecurity )
		{
			if( !CreateSecurityPatchBackup() )
			{
				DebugOut("ISIGN32: CreateSecurityPatchBackup Failed!!\r\n");
			}

			fAlreadyBackedUpSecurity = TRUE;
		}
		break;

	case DISPID_STATUSTEXTCHANGE:
		DebugOut("CDExplorerEvents::Invoke (DISPID_STATUSTEXTCHANGE) called\r\n");
		break;

	case DISPID_QUIT:
		DebugOut("CDExplorerEvents::Invoke (DISPID_QUIT) called\r\n");

		// browser is about to cloes itself down, so g_iwbapp is about to become invalid
		if( g_pCP && g_pMySink)
		{

			hresult = g_pCP->Unadvise(g_pMySink->m_dwCookie);
			if ( FAILED( hresult ) )
			{
				DebugOut("ISIGNUP: KillSink unadvise failed\r\n");
			}

			g_pMySink->m_dwCookie = 0;
			
			g_pCP->Release();
			
			g_pCP = NULL;
		}

		if( g_iwbapp )
		{
			g_iwbapp->Release();
			g_iwbapp = NULL;
		}

	    PostMessage(GetHwndMain(), WM_CLOSE, 0, 0);
		break;

	case DISPID_DOWNLOADCOMPLETE :
		DebugOut("CDExplorerEvents::Invoke (DISPID_DOWNLOADCOMPLETE) called\r\n");
		break;

	case DISPID_COMMANDSTATECHANGE:
		DebugOut("CDExplorerEvents::Invoke (DISPID_COMMANDSTATECHANGE) called\r\n");
		break;

	case DISPID_DOWNLOADBEGIN:
		DebugOut("CDExplorerEvents::Invoke (DISPID_DOWNLOADBEGIN) called\r\n");
		break;

	case DISPID_NEWWINDOW:
		DebugOut("CDExplorerEvents::Invoke (DISPID_NEWWINDOW) called\r\n");
		break;

	case DISPID_PROGRESSCHANGE:
		DebugOut("CDExplorerEvents::Invoke (DISPID_PROGRESS) called\r\n");
		break;

	case DISPID_WINDOWMOVE       :
		DebugOut("CDExplorerEvents::Invoke (DISPID_WINDOWMOVE) called\r\n");
		break;

	case DISPID_WINDOWRESIZE     :
		DebugOut("CDExplorerEvents::Invoke (DISPID_WINDOWRESIZE) called\r\n");
		break;

	case DISPID_WINDOWACTIVATE   :
		DebugOut("CDExplorerEvents::Invoke (DISPID_WINDOWACTIVATE) called\r\n");
		break;
		
	case DISPID_PROPERTYCHANGE   :
		DebugOut("CDExplorerEvents::Invoke (DISPID_PROPERTYCHANGE) called\r\n");
		break;

	case DISPID_TITLECHANGE:
		DebugOut("CDExplorerEvents::Invoke (DISPID_TITLECHANGE) called\r\n");
		break;

	default:
		DebugOut("CDExplorerEvents::Invoke (Unkwown) called\r\n");
		break;
	}
	
	return S_OK;
}

//+---------------------------------------------------------------------------
//
//	Function:	GetConnectionPoint
//
//	Synopsis:	Gets a connection point from IE so that we can become an event sync
//
//	Arguments:	none
//
//	Returns:	pointer to connection point; returns NULL if couldn't connect
//
//	History:	9/27/96	jmazner	created; mostly stolen from josephh who stole from Inside OLE
//----------------------------------------------------------------------------
IConnectionPoint * GetConnectionPoint(void)
{
    HRESULT                     hr;
    IConnectionPointContainer  *pCPCont = NULL;
    IConnectionPoint           *pCP = NULL;



    if (!g_iwbapp)
      return (NULL);

    hr = g_iwbapp->QueryInterface(IID_IConnectionPointContainer, (VOID * *)&pCPCont);

    if ( FAILED(hr) )
    {
        DebugOut("ISIGNUP: GetConnectionPoint unable to QI for IConnectionPointContainter:IWebBrowserApp\r\n");
        return NULL;
    }

    hr=pCPCont->FindConnectionPoint(
      DIID_DWebBrowserEvents,
      &pCP
      );


    if ( FAILED(hr) )
    {
        DebugOut("ISIGNUP: GetConnectionPoint failed on FindConnectionPoint:IWebBrowserApp\r\n");
        pCPCont->Release();
        return NULL;
    }

    hr = pCPCont->Release();
	if ( FAILED(hr) )
    {
        DebugOut("ISIGNUP: WARNING: GetConnectionPoint failed on pCPCont->Release()\r\n");
    }

    return pCP;
}


//+---------------------------------------------------------------------------
//
//	Function:	KillOle
//
//	Synopsis:	Cleans up all the OLE pointers and references that we used
//
//	Arguments:	none
//
//	Returns:	hresult of any operation that failed; if nothing fails, then returns
//				a SUCCESS hresult
//
//	History:	9/27/96	jmazner	created;
//----------------------------------------------------------------------------

HRESULT KillOle( void )
{

	HRESULT hresult = S_OK;
	BOOL	bAlreadyDead = TRUE;

	if( g_iwbapp )
	{
		bAlreadyDead = FALSE;
		hresult = g_iwbapp->Release();
		if ( FAILED( hresult ) )
		{
			DebugOut("ISIGNUP: g_iwbapp->Release() unadvise failed\r\n");
		}


		g_iwbapp = NULL;
	}

	if( g_pCP && !bAlreadyDead && g_pMySink)
	{

		hresult = g_pCP->Unadvise(g_pMySink->m_dwCookie);
		if ( FAILED( hresult ) )
		{
			DebugOut("ISIGNUP: KillSink unadvise failed\r\n");
		}

		g_pMySink->m_dwCookie = 0;
		
		if (g_pCP) g_pCP->Release();
		
		g_pCP = NULL;
	}

	if( g_pMySink )
	{
		//delete (g_pMySink);
		//
		// 5/10/97 ChrisK Windows NT Bug 82032
		//
		g_pMySink->Release();

		g_pMySink = NULL;
	}

	CoUninitialize();

	return( hresult );
}


//+---------------------------------------------------------------------------
//
//	Function:	InitOle
//
//	Synopsis:	Fire up the OLE bits that we'll need, establish the Interface pointer to IE
//
//	Arguments:	none
//
//	Returns:	hresult of any operation that failed; if nothing fails, then returns
//				a SUCCESS hresult
//
//	History:	9/27/96	jmazner	created; mostly stolen from josephh who stole from Inside OLE
//----------------------------------------------------------------------------


HRESULT InitOle( void )
{
	IUnknown FAR * punk;
	HRESULT hresult;


	hresult = CoInitialize( NULL );
	if( FAILED(hresult) )
	{
		DebugOut("ISIGNUP: CoInitialize failed\n");
		return( hresult );		
	}

	hresult = CoCreateInstance (
        CLSID_InternetExplorer,
        NULL, //Not part of an agregate object
        CLSCTX_LOCAL_SERVER, //I hope...
        IID_IUnknown,
        (void FAR * FAR*) & punk
        );

	if( FAILED(hresult) )
	{
		DebugOut("ISIGNUP: CoCreateInstance failed\n");
		return( hresult );		
	}


    hresult = punk->QueryInterface(IID_IWebBrowserApp,
									(void FAR* FAR*)&(g_iwbapp) );
	if( FAILED(hresult) )
	{
		DebugOut("ISIGNUP: punk->QueryInterface on IID_IWebBrowserApp failed\n");
		return( hresult );		

	}


	//UNDONE TODO BUG do we need to do this?
	g_iwbapp->AddRef();

	punk->Release();
	punk = NULL;

	return( hresult );
}

typedef HRESULT (WINAPI *URLDOWNLOADTOCACHEFILE)(LPUNKNOWN,LPCWSTR,LPWSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
#define ICWSETTINGSPATH TEXT("Software\\Microsoft\\Internet Connection Wizard")
#define ICWENABLEURLDOWNLOADTOCACHEFILE TEXT("URLDownloadToCacheFileW")
//+----------------------------------------------------------------------------
// This is a temporary work around to allow the testing team to continue
// testing while allowing the IE team to debug a problem with
// URLDownloadToCacheFileW
// UNDONE : BUGBUG
//-----------------------------------------------------------------------------
BOOL EnableURLDownloadToCacheFileW()
{

	HKEY hkey = NULL;
	BOOL bRC = FALSE;
	DWORD dwType = 0;
	DWORD dwData = 0;
	DWORD dwSize = sizeof(dwData);

	if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,ICWSETTINGSPATH,&hkey))
		goto EnableURLDownloadToCacheFileWExit;

	if (ERROR_SUCCESS != RegQueryValueEx(hkey,
		ICWENABLEURLDOWNLOADTOCACHEFILE,0,&dwType,(LPBYTE)&dwData,&dwSize))
		goto EnableURLDownloadToCacheFileWExit;

	bRC = (dwData != 0);
EnableURLDownloadToCacheFileWExit:
	if (NULL != hkey)
		RegCloseKey(hkey);
	hkey = NULL;

	if (bRC)
		DebugOut("ISIGNUP: URLDownloadToCacheFileW ENABLED.\n");
	else
		DebugOut("ISIGNUP: URLDownloadToCacheFileW disabled.\n");

	return bRC;
}

//+---------------------------------------------------------------------------
//
//	Function:	IENavigate
//
//	Synopsis:	Converts ASCII URL to Unicode and tells IE to navigate to it
//
//	Arguments:	CHAR * szURL -- ASCII URL to navigate to
//
//	Returns:	hresult of any operation that failed; if nothing fails, then returns
//				a SUCCESS hresult
//
//	History:	9/27/96	jmazner	created; mostly stolen from josephh who stole from Inside OLE
//----------------------------------------------------------------------------

HRESULT IENavigate( TCHAR *szURL )
{
	HRESULT hresult;
	DWORD		dwresult;
	BSTR bstr = NULL;
	WCHAR * szWide = NULL;  // Used to store unicode version of URL to open
	int	iWideSize = 0;
	HINSTANCE hUrlMon = NULL;
	FARPROC fp = NULL;
	WCHAR szCacheFile[MAX_PATH];
	
#ifndef UNICODE
	iWideSize = MultiByteToWideChar( CP_ACP,
						MB_PRECOMPOSED,
						szURL,
						-1,
						NULL,
						0);

	if( 0 == iWideSize )
	{
		DebugOut("ISIGNUP: IENavigate couldn't determine size for szWide");
		dwresult = GetLastError();
		hresult = HRESULT_FROM_WIN32( dwresult );
		goto IENavigateExit;
	}

	szWide = (WCHAR *) GlobalAlloc( GPTR, sizeof(WCHAR) * iWideSize );

	if( !szWide )
	{
		DebugOut("ISIGNUP: IENavigate couldn't alloc memory for szWide");
		hresult = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
		goto IENavigateExit;
	}


	dwresult = MultiByteToWideChar( CP_ACP,
						MB_PRECOMPOSED,
						szURL,
						-1,
						szWide,
						iWideSize);

	if( 0 == dwresult )
	{
		DebugOut("ISIGNUP: IENavigate couldn't convert ANSI URL to Unicdoe");
		GlobalFree( szWide );
		szWide = NULL;
		dwresult = GetLastError();
		hresult = HRESULT_FROM_WIN32( dwresult );
		goto IENavigateExit;
	}
#endif

	// 4/15/97 - ChrisK Olympus 131
	// Download the initial URL in order to see if the page is available
	if (NULL == (hUrlMon = LoadLibrary(TEXT("URLMON.DLL"))))
	{
		hresult = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
		goto IENavigateExit;
	}

	if (NULL == (fp = GetProcAddress(hUrlMon,"URLDownloadToCacheFileW")))
	{
		hresult = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
		goto IENavigateExit;
	}

	if (FALSE != EnableURLDownloadToCacheFileW())
	{
//		iBSC = new CBindStatusCallback(NULL, NULL, NULL, NULL);
#ifdef UNICODE
		hresult = ((URLDOWNLOADTOCACHEFILE)fp)(NULL, szURL, szCacheFile, sizeof(szCacheFile), 0, NULL);
#else
		hresult = ((URLDOWNLOADTOCACHEFILE)fp)(NULL, szWide, szCacheFile, sizeof(szCacheFile), 0, NULL);
#endif
		if (S_OK != hresult)
			goto IENavigateExit;
	}

#ifdef UNICODE
	bstr = SysAllocString(szURL);
#else
	bstr = SysAllocString(szWide);
#endif
	if( !bstr )
	{
		DebugOut("ISIGNUP: IENavigate couldn't alloc memory for bstr");
		hresult = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
		goto IENavigateExit;
	}


	VARIANT vFlags          ;
	VARIANT vTargetFrameName;
	VARIANT vPostData       ;
	VARIANT vHeaders        ;

	VariantInit (&vFlags);
	VariantInit (&vTargetFrameName);
	VariantInit (&vPostData);
	VariantInit (&vHeaders);
	V_VT(&vFlags) = VT_ERROR;
	V_ERROR(&vFlags) = DISP_E_PARAMNOTFOUND;
	V_VT(&vTargetFrameName) = VT_ERROR;
	V_ERROR(&vTargetFrameName) = DISP_E_PARAMNOTFOUND;
	V_VT(&vPostData) = VT_ERROR;
	V_ERROR(&vPostData) = DISP_E_PARAMNOTFOUND;
	V_VT(&vHeaders) = VT_ERROR;
	V_ERROR(&vHeaders) = DISP_E_PARAMNOTFOUND;

	hresult = g_iwbapp->Navigate(
								bstr,
								&vFlags,			//Flags
								&vTargetFrameName,  //TargetFrameName
								&vPostData,			//PostData,
								&vHeaders);         // Headers,
IENavigateExit:
#ifndef UNICODE
	if( szWide )
	{
		GlobalFree( szWide );
		szWide = NULL;
	}
#endif

	if (NULL != hUrlMon)
		FreeLibrary(hUrlMon);

	if (NULL != bstr)
		SysFreeString( bstr );

	return( hresult );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\logon.cpp ===
#include "isignup.h"

typedef DWORD (WINAPI *WNETGETUSER)
        (LPCTSTR  lpName, LPTSTR  lpUserName,  LPDWORD  lpnLength);

typedef DWORD (WINAPI * WNETLOGON)
		(LPCTSTR lpProvider, HWND hwndOwner);

#ifdef WIN16
#define MB_SETFOREGROUND            0

#define NO_ERROR	ERROR_SUCCESS

//
// MessageId: ERROR_NO_NETWORK
//
// MessageText:
//
//  The network is not present or not started.
//
#define ERROR_NO_NETWORK                 1222L

//
// MessageId: ERROR_NOT_LOGGED_ON
//
// MessageText:
//
//  The operation being requested was not performed because the user
//  has not logged on to the network.
//  The specified service does not exist.
//
#define ERROR_NOT_LOGGED_ON              1245L

//
// MessageId: ERROR_NOT_CONNECTED
//
// MessageText:
//
//  This network connection does not exist.
//
#define ERROR_NOT_CONNECTED              2250L

#endif

#ifdef UNICODE
BOOL WINAPI AutoDialLogonW(HWND, LPCTSTR, DWORD, LPDWORD);
BOOL WINAPI AutoDialLogonA
(
    HWND    hwndParent,	
    LPCSTR  lpszEntry,
    DWORD   dwFlags,
    LPDWORD pdwRetCode
)
{
    TCHAR szEntry[RAS_MaxEntryName + 1];

    mbstowcs(szEntry, lpszEntry, lstrlenA(lpszEntry)+1);
    return AutoDialLogonW(hwndParent, szEntry, dwFlags, pdwRetCode);
}

BOOL WINAPI AutoDialLogonW
#else
BOOL WINAPI AutoDialLogonA
#endif
(
    HWND    hwndParent,	
    LPCTSTR lpszEntry,
    DWORD   dwFlags,
    LPDWORD pdwRetCode
)
{   
    DWORD dwRet;
    TCHAR szUser[80];
    DWORD size;
    HINSTANCE hLib;
    WNETLOGON lpfnWNetLogon;
    WNETGETUSER lpfnWNetGetUser;

    hLib = LoadLibrary(TEXT("mpr.dll"));
    if ((HINSTANCE)32 >= hLib)
    {
        return 0;
    }

#ifdef UNICODE
    lpfnWNetLogon = (WNETLOGON) GetProcAddress(hLib, "WNetLogonW");
    lpfnWNetGetUser = (WNETGETUSER) GetProcAddress(hLib, "WNetGetUserW");
#else
    lpfnWNetLogon = (WNETLOGON) GetProcAddress(hLib, "WNetLogonA");
    lpfnWNetGetUser = (WNETGETUSER) GetProcAddress(hLib, "WNetGetUserA");
#endif
	if (NULL == lpfnWNetLogon || NULL == lpfnWNetGetUser)
	{
		FreeLibrary(hLib);
		return 0;
	}

    size = sizeof(szUser);
    dwRet = lpfnWNetGetUser(NULL, szUser, &size);
    if (NO_ERROR != dwRet)
    {
        LPTSTR lpszErr;
        TCHAR szMsg[256];
        TCHAR szCaption[256];
        
        dwRet = GetLastError();

        LoadString(
                ghInstance,
                IDS_LOGONMESSAGE,
                szMsg,
                SIZEOF_TCHAR_BUFFER(szMsg));

        LoadString(
                ghInstance,
                IDS_LOGONCAPTION,
                szCaption,
                SIZEOF_TCHAR_BUFFER(szCaption));

        switch (dwRet)
        {
            case ERROR_NOT_LOGGED_ON:
                while (1)
                {
                    dwRet = lpfnWNetLogon(NULL, NULL);

                    if (WN_CANCEL != dwRet)
                    {
                        break;
                    }
                    if (MessageBox(
                            hwndParent,
                            szMsg,
                            szCaption,
                            MB_SETFOREGROUND | 
                            MB_ICONWARNING |
                            MB_RETRYCANCEL) == IDCANCEL)
                    {
                        break;
                    }
                }
                break;

            case ERROR_NO_NETWORK:
                lpszErr = TEXT("No Network");
                break;

            case ERROR_NOT_CONNECTED:
                lpszErr = TEXT("Not Connected");
                break;
            
            default:
                lpszErr = TEXT("Who knows?");
                break;
        }

        MessageBox(NULL, lpszErr, TEXT("WNetGetUser returned"), MB_OK);
    }

    FreeLibrary(hLib);

    *pdwRetCode = ERROR_SUCCESS;
    return FALSE;
}


DWORD SignupLogon(
    HWND hwndParent	
)
{   
    DWORD dwRet;
    TCHAR szUser[80];
    DWORD size;
    HINSTANCE hLib;
    WNETLOGON lpfnWNetLogon;
    WNETGETUSER lpfnWNetGetUser;

    hLib = LoadLibrary(TEXT("mpr.dll"));
    if ((HINSTANCE)32 >= hLib)
    {
        return GetLastError();
    }

#ifdef UNICODE
    lpfnWNetLogon = (WNETLOGON) GetProcAddress(hLib, "WNetLogonW");
    lpfnWNetGetUser = (WNETGETUSER) GetProcAddress(hLib, "WNetGetUserW");
#else
    lpfnWNetLogon = (WNETLOGON) GetProcAddress(hLib, "WNetLogonA");
    lpfnWNetGetUser = (WNETGETUSER) GetProcAddress(hLib, "WNetGetUserA");
#endif
	if (NULL == lpfnWNetLogon || NULL == lpfnWNetGetUser)
	{
		FreeLibrary(hLib);
		return ERROR_SUCCESS;
	}

    size = sizeof(szUser);
    dwRet = lpfnWNetGetUser(NULL, szUser, &size);
    if (NO_ERROR != dwRet)
    {
        TCHAR szMsg[256];

        dwRet = GetLastError();

        LoadString(
                ghInstance,
                IDS_SIGNUPLOGON,
                szMsg,
                SIZEOF_TCHAR_BUFFER(szMsg));

        if (ERROR_NOT_LOGGED_ON == dwRet)
        {
            while (1)
            {
                dwRet = lpfnWNetLogon(NULL, NULL);

                if (WN_CANCEL != dwRet)
                {
                    dwRet = ERROR_SUCCESS;
                    break;
                }
                if (MessageBox(
                        hwndParent,
                        szMsg,
                        cszAppName,
                        MB_SETFOREGROUND | 
                        MB_ICONWARNING |
                        MB_RETRYCANCEL) == IDCANCEL)
                {
                    dwRet = ERROR_CANCELLED;
                    break;
                }
            }
        }
    }

    FreeLibrary(hLib);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\progress.cpp ===
#include "isignup.h"

LRESULT FAR PASCAL ProgressProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

HWND ProgressInit(HWND hwndParent)
{
    HWND        hwnd;
    WNDCLASS    wndclass ;

    wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
    wndclass.lpfnWndProc   = ProgressProc ;
    wndclass.cbClsExtra    = 0 ;
    wndclass.cbWndExtra    = DLGWINDOWEXTRA ;
    wndclass.hInstance     = ghInstance ;
    wndclass.hIcon         = NULL ;
    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
    wndclass.hbrBackground = (HBRUSH)COLOR_APPWORKSPACE ;
    wndclass.lpszMenuName  = NULL ;
    wndclass.lpszClassName = TEXT("Internet Signup Progress");

    RegisterClass (&wndclass) ;

    hwnd = CreateDialog (ghInstance, TEXT("Progress"), hwndParent, NULL);

    ShowWindow (hwnd, SW_NORMAL);

    return hwnd;
}

LONG_PTR FAR PASCAL ProgressProc (
        HWND hwnd,
        UINT message,
        WPARAM wParam,
        LPARAM lParam)
{
    switch (message)
    {
        case WM_MOUSEACTIVATE:
            return MA_NOACTIVATEANDEAT;

        default:
            break;
    }

    return DefWindowProc (hwnd, message, wParam, lParam) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\rsrc.h ===
#define     IDI_PHONE       100
#define     IDB_ARROW       101
#define     IDB_LOGO        102
#define     IDC_LOGO        103
#define     IDC_STEP1       201
#define     IDC_STEP2       202
#define     IDC_STEP3       203
#define     IDC_PCTARROW1   301
#define     IDC_PCTARROW2   302
#define     IDC_PCTARROW3   303
#define     IDC_LBLSTEPS    400
#define     IDC_PHONE1        401
#define     IDC_INSTRUCT_TEXT 402
#define     IDC_ONE_TEXT      403
#define     IDC_SETUP_TEXT    404
#define     IDC_TWO_TEXT      405
#define     IDC_SIGNUP_TEXT   406
#define     IDC_THREE_TEXT    407
#define     IDC_REQ_TEXT      408
#define     IDC_FRAME         409
#define     IDC_PHONE2        410
#define     IDC_MODEM_TEXT    411

#define     IDS_INVALIDCMDLINE  1001
#define     IDS_INVALIDFILETYPE 1002
#define     IDS_CANNOTPROCESSINS  1003
#define     IDS_SIGNUPCANCELLED 1004
#define     IDS_LAUNCHFAILED    1005
#define     IDS_INSTALLFAILED   1006
#define     IDS_BADSETTINGS     1007
#define     IDS_RESTART         1008
#define     IDS_RESTARTNOW      1009
#define     IDS_SETTINGCHANGE   1010
#define     IDS_SIGNUPCOMPLETE  1011
#define     IDS_EXECFAILED      1012
#define     IDS_INSFILEWARNING  1013
#define     IDS_BADSIGNUPFILE   1014
#define     IDS_MISSINGCFGDLL   1015
#define     IDS_MISSINGRNADLL   1016
#define     IDS_WRONGRNADLLVER  1017
#define     IDS_PASSWORD        1018
#define     IDS_LOGONMESSAGE    1019
#define     IDS_LOGONCAPTION    1020
#define     IDS_SIGNUPLOGON     1021
#define     IDS_BROWSERTERMINATED 1022
#define     IDS_BROWSERNEVERFOUND 1023
#define     IDS_INVALIDURL      1024
#define     IDS_MAILFAILED      1025
#define     IDS_ISP_DIAL_MESSAGE 1026
#define		IDS_MISSINGIE		1027
#define		IDS_IELOWVERSION	1028
#define		IDS_SBSCFGERROR		1029
#define		IDS_NOCMDLINE       1030
#define     IDS_ISPBROWSEFAIL   1031
#define		IDS_INVALIDNOURL	1032

#define     IDS_APP_TITLE       1101
#define     IDS_VERSION         1102
#define     IDS_DESCRIPTION     1103

#define     IDS_DEFAULT_SCP             1201
#define     IDS_INI_SCRIPT_DIR          1202
#define     IDS_INI_SCRIPT_SHORTDIR     1203

#define		IDS_SERVICEDISABLED 1210
#define		IDS_RECONNECT_QUERY 1211

#define		IDD_CHOOSEMODEMNAME	1250
#define		IDC_MODEM			1251
#define		IDC_CMDOK			1252
#define		IDC_CMDCANCEL		1253
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\isign32

MAJORCOMP=GETCONN
MINORCOMP=ISIGN32

TARGETNAME=ISIGN32
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=LibMain
DLLBASE=$(DEFBASEADDR)
!if defined(NOT_UNICODE)
DLLDEF=..\isignup.def
!else
DLLDEF=..\isignup2.def
!endif
NOT_LEAN_AND_MEAN=1
RCNOFONTMAP=1
# PASS0_SOURCEDIR=.
C_DEFINES = -DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT40=1

386_STDCALL     = 0

MSC_WARNING_LEVEL=/W3 /WX

SOURCES= \
    ..\isignup.rc   \
    ..\iedde.cpp    \
    ..\autodial.cpp \
    ..\client.cpp   \
    ..\custom.cpp   \
    ..\dialutil.cpp \
    ..\extfunc.cpp  \
    ..\icwerr.cpp   \
    ..\impfile.cpp  \
    ..\import.cpp   \
    ..\isignup.cpp  \
    ..\logon.cpp    \
    ..\progress.cpp \
    ..\utils.cpp    \
    ..\enumodem.cpp \
    ..\icw.cpp      \
    ..\isignole.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib      \
    $(SDK_LIB_PATH)\comctl32.lib      \
    $(SDK_LIB_PATH)\version.lib       \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\oleaut32.lib      \
    $(SDK_LIB_PATH)\uuid.lib          \
    $(SDK_LIB_PATH)\hlink.lib         \
    $(SDK_LIB_PATH)\ole32.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\isignup.h
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\isignup.cpp ===
/*----------------------------------------------------------------------------
    isignup.cpp

    This is the "main" file for the internet signup "wizard".

    Copyright (C) 1995-96 Microsoft Corporation
    All right reserved

  Authors:
    MMaclin        Mark Maclin

  History:
    Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
    8/2/96    ChrisK    Ported to Win32
    9/27/96    jmazner    Modified to use OLE Automation to control IE
----------------------------------------------------------------------------*/
#include "isignup.h"
#include "icw.h"

#ifdef WIN32
#include "icwacct.h"
#include "isignole.h"
#include "enumodem.h"
#include "..\inc\semaphor.h"
#include <shlobj.h>
#include <math.h>
#include <stdlib.h>
#endif

#include "..\inc\icwdial.h"

#ifndef WIN32
#include <string.h>
#include <direct.h>
#include <time.h>
#include <io.h>

DWORD GetFullPathName(
    LPCTSTR lpFileName,
    DWORD nBufferLength,
    LPTSTR lpBuffer,
    LPTSTR FAR *lpFilePart);

BOOL SetCurrentDirectory(
    LPCTSTR  lpPathName);

BOOL ShutDownIEDial(HWND hWnd);

#endif


const TCHAR g_szICWCONN1[] = TEXT("ICWCONN1.EXE");
const TCHAR g_szRestoreDesktop[] = TEXT("/restoredesktop");

#ifdef WIN32
#define SETUPSTACK      1
#endif

// Signup Entry Flags

#define SEF_RUNONCE            0x0001
#define SEF_PROGRESS           0x0002
#define SEF_SPLASH             0x0004

// 3/14/97 jmazner TEMP
// temporary hack until we can work with IE for a better solution
#define SEF_NOSECURITYBACKUP   0x0008


// Signup eXit Flags

#define SXF_RESTOREAUTODIAL    0x0001
#define SXF_RUNEXECUTABLE      0x0002
#define SXF_WAITEXECUTABLE     0x0004
#define SXF_KEEPCONNECTION     0x0008
#define SXF_KEEPBROWSER        0x0010
#define SXF_RESTOREDEFCHECK    0x0020
// 8/21/96 jmazner Normandy 4592
#define SXF_RESTOREIEWINDOWPLACEMENT    0x0040

extern void Dprintf(LPCSTR pcsz, ...);

/*** moved to isignup.h
typedef enum
{
    UNKNOWN_FILE,
    INS_FILE,
    ISP_FILE,
    HTML_FILE
}  INET_FILETYPE;
*/

#define WAIT_TIME   20   // time in seconds to wait after exec'ing browser
            // before checking if it has gone away.

#define MAX_RETRIES 3 // number of times the dialer with attempt automatic redials

#pragma data_seg(".rdata")

static const TCHAR szBrowserClass1[] = TEXT("IExplorer_Frame");
static const TCHAR szBrowserClassIE4[] = TEXT("CabinetWClass");
static const TCHAR szBrowserClass2[] = TEXT("Internet Explorer_Frame");
static const TCHAR szBrowserClass3[] = TEXT("IEFrame");

static const TCHAR cszURLSection[] = TEXT("URL");
static const TCHAR cszSignupURL[] =  TEXT("Signup");

static const TCHAR cszExtINS[] = TEXT(".ins");
static const TCHAR cszExtISP[] = TEXT(".isp");
static const TCHAR cszExtHTM[] = TEXT(".htm");
static const TCHAR cszExtHTML[] = TEXT(".html");

static const TCHAR cszEntrySection[]     = TEXT("Entry");
static const TCHAR cszEntryName[]    = TEXT("Entry_Name");
static const TCHAR cszCancel[]           = TEXT("Cancel");
static const TCHAR cszHangup[]           = TEXT("Hangup");
static const TCHAR cszRun[]              = TEXT("Run");
static const TCHAR cszArgument[]         = TEXT("Argument");

static const TCHAR cszConnect2[]         = TEXT("icwconn2.exe");
static const TCHAR cszClientSetupSection[]  = TEXT("ClientSetup");

static const TCHAR cszUserSection[]    = TEXT("User");
static const TCHAR cszRequiresLogon[]  = TEXT("Requires_Logon");

static const TCHAR cszCustomSection[]  = TEXT("Custom");
static const TCHAR cszKeepConnection[] = TEXT("Keep_Connection");
static const TCHAR cszKeepBrowser[]    = TEXT("Keep_Browser");

static const TCHAR cszBrandingSection[]  = TEXT("Branding");
static const TCHAR cszBrandingFlags[] = TEXT("Flags");
static const TCHAR cszBrandingServerless[] = TEXT("Serverless");

static const TCHAR cszHTTPS[] = TEXT("https:");
// code relies on these two being the same length
static const TCHAR cszHTTP[] = TEXT("http:");
static const TCHAR cszFILE[] = TEXT("file:");

#if defined(WIN16)
// "-d" disables the security warnings
static const TCHAR cszKioskMode[] = TEXT("-d -k ");
#else
static const CHAR cszKioskMode[] = "-k ";
#endif
static const TCHAR cszOpen[] = TEXT("open");
static const TCHAR cszBrowser[] = TEXT("iexplore.exe");
static const TCHAR szNull[] = TEXT("");

static const TCHAR cszYes[]           = TEXT("yes");
static const TCHAR cszNo[]            = TEXT("no");

// UNDONE: finish porting warnings disable
static const TCHAR cszDEFAULT_BROWSER_KEY[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
static const TCHAR cszDEFAULT_BROWSER_VALUE[] = TEXT("check_associations");
// 8/21/96 jmazner  Normandy #4592
static const TCHAR cszIEWINDOW_PLACEMENT[] = TEXT("Window_Placement");

// Registry keys which will contain News and Mail settings
//#define MAIL_KEY        "SOFTWARE\\Microsoft\\Internet Mail and News\\Mail"
//#define MAIL_POP3_KEY    "SOFTWARE\\Microsoft\\Internet Mail and News\\Mail\\POP3\\"
//#define MAIL_SMTP_KEY    "SOFTWARE\\Microsoft\\Internet Mail and News\\Mail\\SMTP\\"
//#define NEWS_KEY        "SOFTWARE\\Microsoft\\Internet Mail and News\\News"
//#define MAIL_NEWS_INPROC_SERVER32 "CLSID\\{89292102-4755-11cf-9DC2-00AA006C2B84}\\InProcServer32"
#define ICWSETTINGSPATH TEXT("Software\\Microsoft\\Internet Connection Wizard")
#define ICWCOMPLETEDKEY TEXT("Completed")
#define ICWDESKTOPCHANGED TEXT("DesktopChanged")

//typedef HRESULT (WINAPI *PFNSETDEFAULTNEWSHANDLER)(void);

//
// TEMP TEMP TEMP TEMP TEMP
// 6/4/97 jmazner
// these typedefs live in icwacct.h, but we can't include icwacct.h in 16 bit builds
// just yet because the OLE stuff is all goofy.  So, for now, copy these in here to
// make 16 bit build correctly.
#ifdef WIN16
typedef enum
    {
    CONNECT_LAN = 0,
    CONNECT_MANUAL,
    CONNECT_RAS
    };

typedef struct tagCONNECTINFO
    {
    DWORD   cbSize;
    DWORD   type;
    TCHAR   szConnectoid[MAX_PATH];
    } CONNECTINFO;
#endif

typedef HRESULT (WINAPI *PFNCREATEACCOUNTSFROMFILEEX)(LPTSTR szFile, CONNECTINFO *pCI, DWORD dwFlags);


// These are the field names from an INS file that will
// determine the mail and news settings
//static const CHAR cszMailSection[]    = "Internet_Mail";
//static const CHAR cszEmailName[]    = "Email_Name";
//static const CHAR cszEmailAddress[] = "Email_Address";
//static const CHAR cszEntryName[]    = "Entry_Name";
//static const CHAR cszPOPServer[]    = "POP_Server";
//static const CHAR cszPOPServerPortNumber[]    = "POP_Server_Port_Number";
//static const CHAR cszPOPLogonName[]            = "POP_Logon_Name";
//static const CHAR cszPOPLogonPassword[]        = "POP_Logon_Password";
//static const CHAR cszSMTPServer[]            = "SMTP_Server";
//static const CHAR cszSMTPServerPortNumber[]    = "SMTP_Server_Port_Number";
//static const CHAR cszNewsSection[]            = "Internet_News";
//static const CHAR cszNNTPServer[]            = "NNTP_Server";
//static const CHAR cszNNTPServerPortNumber[]    = "NNTP_Server_Port_Number";
// 8/19/96 jmazner Normandy #4601
//static const CHAR cszNNTPLogonRequired[]    = "Logon_Required";
//static const CHAR cszNNTPLogonName[]        = "NNTP_Logon_Name";
//static const CHAR cszNNTPLogonPassword[]    = "NNTP_Logon_Password";
//static const CHAR cszUseMSInternetMail[]    = "Install_Mail";
//static const CHAR cszUseMSInternetNews[]    = "Install_News";

// These are the value names where the INS settings will be saved
// into the registry
/****
static const TCHAR cszMailSenderName[]        = TEXT("Sender Name");
static const TCHAR cszMailSenderEMail[]        = TEXT("Sender EMail");
static const TCHAR cszMailRASPhonebookEntry[]= TEXT("RAS Phonebook Entry");
static const TCHAR cszMailConnectionType[]    = TEXT("Connection Type");
static const TCHAR cszDefaultPOP3Server[]    = TEXT("Default POP3 Server");
static const TCHAR cszDefaultSMTPServer[]    = TEXT("Default SMTP Server");
static const TCHAR cszPOP3Account[]            = TEXT("Account");
static const TCHAR cszPOP3Password[]            = TEXT("Password");
static const TCHAR cszPOP3Port[]                = TEXT("Port");
static const TCHAR cszSMTPPort[]                = TEXT("Port");
static const TCHAR cszNNTPSenderName[]        = TEXT("Sender Name");
static const TCHAR cszNNTPSenderEMail[]        = TEXT("Sender EMail");
static const TCHAR cszNNTPDefaultServer[]    = TEXT("DefaultServer"); // NOTE: NO space between "Default" and "Server".
static const TCHAR cszNNTPAccountName[]        = TEXT("Account Name");
static const TCHAR cszNNTPPassword[]            = TEXT("Password");
static const TCHAR cszNNTPPort[]                = TEXT("Port");
static const TCHAR cszNNTPRasPhonebookEntry[]= TEXT("RAS Phonebook Entry");
static const TCHAR cszNNTPConnectionType[]    = TEXT("Connection Type");
****/

static const TCHAR arBase64[] = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U',
            'V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',
            'q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/','='};

#pragma data_seg()

#define BRAND_FAVORITES 1
#define BRAND_STARTSEARCH 2
#define BRAND_TITLE 4
#define BRAND_BITMAPS 8
#define BRAND_MAIL 16
#define BRAND_NEWS 32

#define BRAND_DEFAULT (BRAND_FAVORITES | BRAND_TITLE | BRAND_BITMAPS)

//********* Start of Memory Map File for Share Data ************

#define SCF_SIGNUPCOMPLETED         0x00000001
#define SCF_SYSTEMCONFIGURED        0x00000002
#define SCF_BROWSERLAUNCHED         0x00000004
#define SCF_AUTODIALSAVED           0x00000008
#define SCF_AUTODIALENABLED         0x00000010
#define SCF_PROXYENABLED            0x00000020
#define SCF_LOGONREQUIRED           0x00000040

#if !defined(WIN16)

#define SCF_SAFESET                 0x00000080
#define SCF_NEEDBACKUPSECURITY      0x00000100
#define SCF_ISPPROCESSING           0x00000200
#define SCF_RASREADY                0x00000400
#define SCF_RECONNECTTHREADQUITED   0x00000800
#define SCF_HANGUPEXPECTED          0x00001000
#define SCF_ICWCOMPLETEDKEYRESETED  0x00002000

#endif

#define SCF_CANCELINSPROCESSED      0x00004000
#define SCF_HANGUPINSPROCESSED      0x00008000
#define SCF_SILENT                  0x00010000


typedef struct tagISign32Share
{
    DWORD   dwControlFlags;
    DWORD   dwExitFlags;
    DWORD   dwBrandFlags;
    
    TCHAR   szAutodialConnection[RAS_MaxEntryName + 1];
    TCHAR   szSignupConnection[RAS_MaxEntryName + 1];
    TCHAR   szPassword[PWLEN + 1];
    TCHAR   szCheckAssociations[20];

#if !defined(WIN16)

    TCHAR   szFile[MAX_PATH + 1];
    TCHAR   szISPFile[MAX_PATH + 1];
    HANDLE  hReconnectEvent;

#endif
    
    TCHAR   szRunExecutable[_MAX_PATH + 1];
    TCHAR   szRunArgument[_MAX_PATH + 1];
    
    BYTE    pbIEWindowPlacement[_MAX_PATH];
    DWORD   dwIEWindowPlacementSize;
    
    HWND    hwndMain;
    HWND    hwndBrowser;
    HWND    hwndLaunch;
    
} ISIGN32SHARE, *PISIGN32SHARE;

static PISIGN32SHARE pDynShare = NULL;

inline BOOL TestControlFlags(DWORD filter)
{
    return ((pDynShare->dwControlFlags & filter) != 0);
}

inline void SetControlFlags(DWORD filter)
{
    pDynShare->dwControlFlags |= filter;
}

inline void ClearControlFlags(DWORD filter)
{
    pDynShare->dwControlFlags &= (~filter);
}

inline BOOL TestExitFlags(DWORD filter)
{
    return (pDynShare->dwExitFlags & (filter)) != 0;
}

inline void SetExitFlags(DWORD filter)
{
    pDynShare->dwExitFlags |= (filter);
}
    
inline void ClearExitFlags(DWORD filter)
{
    pDynShare->dwExitFlags &= (~filter);
}

BOOL LibShareEntry(BOOL fInit)
{
    static TCHAR    szSharedMemName[] = TEXT("ISIGN32_SHAREMEMORY");
    static HANDLE   hSharedMem = 0;

    BOOL    retval = FALSE;
    
    if (fInit)
    {
        DWORD   dwErr = ERROR_SUCCESS;
        
        SetLastError(0);

        hSharedMem = CreateFileMapping(
            INVALID_HANDLE_VALUE,
            NULL,
            PAGE_READWRITE,
            0,
            sizeof(ISIGN32SHARE),
            szSharedMemName);

        dwErr = GetLastError();
            
        switch (dwErr)
        {
        case ERROR_ALREADY_EXISTS:
        case ERROR_SUCCESS:
            pDynShare = (PISIGN32SHARE) MapViewOfFile(
                hSharedMem,
                FILE_MAP_WRITE,
                0,
                0,
                0);
            if (pDynShare != NULL)
            {
                if (dwErr == ERROR_SUCCESS)
                {
                    pDynShare->dwControlFlags = 0;
                    pDynShare->dwBrandFlags = BRAND_DEFAULT;
                    pDynShare->dwExitFlags = 0;

                    pDynShare->szAutodialConnection[0] = (TCHAR)0;
                    pDynShare->szCheckAssociations[0] = (TCHAR)0;

                    #if !defined(WIN16)
                    
                    pDynShare->szISPFile[0] = (TCHAR)0;
                    lstrcpyn(
                        pDynShare->szFile,
                        TEXT("uninited\0"),
                        SIZEOF_TCHAR_BUFFER(pDynShare->szFile));
                    pDynShare->hReconnectEvent = NULL;

                    SetControlFlags(SCF_NEEDBACKUPSECURITY);

                    #endif
                    
                    pDynShare->szSignupConnection[0] = (TCHAR)0;
                    pDynShare->szPassword[0] = (TCHAR)0;
                    pDynShare->szRunExecutable[0] = (TCHAR)0;
                    pDynShare->szRunArgument[0] = (TCHAR)0;

                    pDynShare->pbIEWindowPlacement[0] = (TCHAR)0;
                    pDynShare->dwIEWindowPlacementSize = 0;

                    pDynShare->hwndBrowser = NULL;
                    pDynShare->hwndMain = NULL;
                    pDynShare->hwndLaunch = NULL;
                }
                else    // dwErr == ERROR_ALREADY_EXISTS
                {

                }

                retval = TRUE;
                
            }
            else
            {
                Dprintf("MapViewOfFile failed: 0x%08lx", GetLastError());
                CloseHandle(hSharedMem);
                hSharedMem = 0;
                retval = FALSE;
            }
            break;
            
        default:
            Dprintf("CreateFileMapping failed: 0x08lx", dwErr);
            hSharedMem = 0;
            retval = FALSE;
            
        }
        
    }
    else
    {
        if (pDynShare)
        {
            UnmapViewOfFile(pDynShare);
            pDynShare = NULL;
        }

        if (hSharedMem)
        {
            CloseHandle(hSharedMem);
            hSharedMem = NULL;
        }

        retval = TRUE;
    }

    return retval;
    
}


//************ End of Memory Map File for Share Data ************



TCHAR FAR cszWndClassName[] = TEXT("Internet Signup\0");
TCHAR FAR cszAppName[MAX_PATH + 1] = TEXT("");
TCHAR FAR cszICWDIAL_DLL[] = TEXT("ICWDIAL.DLL\0");
CHAR  FAR cszICWDIAL_DIALDLG[] = "DialingDownloadDialog\0";
CHAR  FAR cszICWDIAL_ERRORDLG[] = "DialingErrorDialog\0";


HINSTANCE ghInstance;


#ifdef WIN32
// NOT shared
IWebBrowserApp FAR * g_iwbapp = NULL;
CDExplorerEvents * g_pMySink = NULL;
IConnectionPoint    *g_pCP = NULL;

//BOOL    g_bISPWaiting = FALSE;
TCHAR    g_szISPPath[MAX_URL + 1] = TEXT("not initialized\0");

// For single instance checking.
HANDLE g_hSemaphore = NULL;

//
// ChrisK Olympus 6198 6/10/97
//
#define REG_ZONE3_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\3")
#define REG_ZONE1601_KEY TEXT("1601")
DWORD g_dwZone_1601 = 0;
BOOL  g_fReadZone = FALSE;

#endif

static DWORD dwConnectedTime = 0;

static BOOL ProcessCommandLine(LPCTSTR lpszCmdLine, LPDWORD lpdwFlags, LPTSTR lpszFile, DWORD cb);
//static INET_FILETYPE GetInetFileType(LPCTSTR lpszFile);
INET_FILETYPE GetInetFileType(LPCTSTR lpszFile);

static BOOL ProcessHTML(HWND hwnd, LPCTSTR lpszFile);
static BOOL ProcessINS(HWND hwnd, LPCTSTR lpszFile, BOOL fSignup);
//static BOOL ProcessISP(HWND hwnd, LPCTSTR lpszFile);
static DWORD SetRunOnce(LPCTSTR lpszFileName);
static BOOL GetURL(LPCTSTR lpszFile,LPCTSTR lpszKey, LPTSTR lpszURL, DWORD cb);
static void DoExit();
static HWND MainInit(void);
static void SaveAutoDial(void);
static void RestoreAutoDial(void);
static DWORD RunExecutable(BOOL bWait);
static DWORD CreateConnection(LPCTSTR lpszFile);
static DWORD KillConnection(void);
static BOOL ExecBrowser(HWND hwnd,  LPCTSTR lpszURL);
VOID RemoveQuotes (LPTSTR pCommandLine);            //MKarki -(5/1/97) Fix forBug #4049

#if !defined(WIN16)
// 8/19/96 jmazner Normandy #4571
static BOOL IEInstalled(void);
static BOOL GetAppVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS, LPTSTR lpszAppName);
// 8/21/96 jmazner Normandy #4592
static BOOL RestoreIEWindowPlacement( void );
static BOOL SaveIEWindowPlacement( void );
// 10-9-96 Chrisk 8782
static void InstallScripter(void);
// 10-15-96 ChrisK
static BOOL FGetSystemShutdownPrivledge();
// 10-17-96 ChrisK
static BOOL VerifyRasServicesRunning(HWND hwnd);

// 1/20/97 jmazner Normandy #9403
static BOOL SetStartUpCommand(LPTSTR lpCmd);
static void DeleteStartUpCommand( void );

// 1/28/97 jmazner Normandy #13454
static BOOL GetICWCompleted( DWORD *pdwCompleted );
static BOOL SetICWCompleted( DWORD dwCompleted );

// 2/19/97 jmazner Olympus #1106 -- SAM/SBS integration
TCHAR FAR cszSBSCFG_DLL[] = TEXT("SBSCFG.DLL\0");
CHAR  FAR cszSBSCFG_CONFIGURE[] = "Configure\0";
typedef DWORD (WINAPI * SBSCONFIGURE) (HWND hwnd, LPTSTR lpszINSFile, LPTSTR szConnectoidName);
SBSCONFIGURE  lpfnConfigure;

// 8/7/97 jmazner Olympus #6059
BOOL CreateSecurityPatchBackup( void );

// 3/11/97 jmazner Olympus #1545
VOID RestoreSecurityPatch( void );

#endif

static HWND FindBrowser(void);
static void KillBrowser(void);
static DWORD ImportBrandingInfo(LPCTSTR lpszFile);
static DWORD MassageFile(LPCTSTR lpszFile);
static HWND LaunchInit(HWND hwndParent);
static HRESULT DialConnection(LPCTSTR lpszFile);
static DWORD ImportMailAndNewsInfo(LPCTSTR lpszFile, BOOL fConnectPhone);
//static HRESULT WriteMailAndNewsKey(HKEY hKey, LPCTSTR lpszSection, LPCTSTR lpszValue, LPTSTR lpszBuff, DWORD dwBuffLen,LPCTSTR lpszSubKey, DWORD dwType, LPCTSTR lpszFile);
static HRESULT PreparePassword(LPTSTR szBuff, DWORD dwBuffLen);
//static BOOL FIsAthenaPresent();
static BOOL FTurnOffBrowserDefaultChecking();
static BOOL FRestoreBrowserDefaultChecking();
static HRESULT DeleteFileKindaLikeThisOne(LPCTSTR lpszFileName);

/*
#ifdef DEBUG
#define DebugOut(sz)    OutputDebugString(sz)
#else
#define DebugOut(sz)
#endif
*/

LRESULT FAR PASCAL WndProc (HWND, UINT, WPARAM, LPARAM) ;

#if !defined(ERROR_USERCANCEL)
#    define ERROR_USERCANCEL 32767
#endif
#if !defined(ERROR_USERBACK)
#    define ERROR_USERBACK 32766
#endif
#if !defined(ERROR_USERNEXT)
#    define ERROR_USERNEXT 32765
#endif

#define MAX_ERROR_MESSAGE 1024
typedef HRESULT (WINAPI*PFNDIALDLG)(PDIALDLGDATA pDD);
typedef HRESULT (WINAPI*PFNERRORDLG)(PERRORDLGDATA pED);


//
// WIN32 only function prototypes
//
#define DEVICENAMEKEY TEXT("DeviceName")
#define DEVICETYPEKEY TEXT("DeviceType")

static BOOL     DeleteUserDeviceSelection(LPTSTR szKey);
VOID   WINAPI   RasDial1Callback(HRASCONN,    UINT, RASCONNSTATE, DWORD, DWORD);
DWORD  WINAPI   StartNTReconnectThread (HRASCONN hrasconn);
DWORD           ConfigRasEntryDevice( LPRASENTRY lpRasEntry );
TCHAR           g_szDeviceName[RAS_MaxDeviceName + 1] = TEXT("\0"); //holds the user's modem choice when multiple
TCHAR           g_szDeviceType[RAS_MaxDeviceType + 1] = TEXT("\0"); // modems are installed
BOOL            IsSingleInstance(BOOL bProcessingINS);
void            ReleaseSingleInstance();

#define ISIGNUP_KEY TEXT("Software\\Microsoft\\ISIGNUP")

#if !defined(WIN16)
// There are other headers that contain copies of this structure (AUTODIAL).
// so if you change anything here, you have to go hunt down the other copies.
//
#pragma pack(2)
#define MAX_PROMO       64
#define MAX_OEMNAME     64
#define MAX_AREACODE    RAS_MaxAreaCode
#define MAX_EXCHANGE    8
#define MAX_VERSION_LEN 40

typedef struct tagGATHEREDINFO
{
    LCID    lcid;
    DWORD   dwOS;
    DWORD   dwMajorVersion;
    DWORD   dwMinorVersion;
    WORD    wArchitecture;
    TCHAR   szPromo[MAX_PROMO];
    TCHAR   szOEM[MAX_OEMNAME];
    TCHAR   szAreaCode[MAX_AREACODE+1];
    TCHAR   szExchange[MAX_EXCHANGE+1];
    DWORD   dwCountry;
    TCHAR   szSUVersion[MAX_VERSION_LEN];
    WORD    wState;
    BYTE    fType;
    BYTE    bMask;
    TCHAR   szISPFile[MAX_PATH+1];
    TCHAR   szAppDir[MAX_PATH+1];
} GATHEREDINFO, *PGATHEREDINFO;
#pragma pack()
#endif //!WIN16

#ifdef  DEBUG

void _ISIGN32_Assert(LPCTSTR strFile, unsigned uLine)
{
    TCHAR   buf[512];
    
    wsprintf(buf, TEXT("Assertion failed: %s, line %u"),
        strFile, uLine);
    
    OutputDebugString(buf);    
}

#endif


#ifdef WIN32
/*******************************************************************

    NAME:       DllEntryPoint

    SYNOPSIS:   Entry point for DLL.

    NOTES:

********************************************************************/
extern "C" BOOL APIENTRY LibMain(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpvReserved)
{
    BOOL retval = TRUE;
    
    if( fdwReason == DLL_PROCESS_ATTACH )
    {
        ghInstance = hInstDll;
        LoadString(ghInstance, IDS_APP_TITLE, cszAppName, SIZEOF_TCHAR_BUFFER(cszAppName));

        retval = LibShareEntry(TRUE);
    }
    else if ( fdwReason == DLL_PROCESS_DETACH )
    {
        retval = LibShareEntry(FALSE);
    }

    return retval;
}

#else
/*******************************************************************

    NAME:       LibMain

    SYNOPSIS:   Used to trace NDI messages

    ENTRY:      hinst - handle of library instance
        wDataSeg - library data segment
        cbHeapSize - default heap size
        lpszCmdLine - command-line arguments

    EXIT:       returns 1

    NOTES:

********************************************************************/
int CALLBACK LibMain(
    HINSTANCE hinst,    /* handle of library instance   */
    WORD  wDataSeg,     /* library data segment */
    WORD  cbHeapSize,   /* default heap size    */
    LPTSTR  lpszCmdLine  /* command-line arguments   */
  )
{
    ghInstance = hinst;
    LoadString(ghInstance, IDS_APP_TITLE, cszAppName, SIZEOF_TCHAR_BUFFER(cszAppName));
    return LibShareEntry(TRUE);
}
#endif

int EXPORT WINAPI Signup
(
    HANDLE hInstance,
    HANDLE hPrevInstance,
    LPTSTR lpszCmdLine,
    int nCmdShow
)
{
    HWND        hwnd = NULL;
    BOOL        fRet;
    DWORD       dwFlags;
    TCHAR        szFileName[_MAX_PATH + 1];
    int         iRet = 0;
    INET_FILETYPE fileType;
    HWND hwndProgress = NULL;
    HKEY hKey = NULL;
    TCHAR szTemp[4];
    BOOL bISetAsSAFE = FALSE;

    if (!LoadInetFunctions(pDynShare->hwndMain))
    {
        return 0;
    }

    if (!ProcessCommandLine(lpszCmdLine, &dwFlags, szFileName, sizeof(szFileName)))
    {            
        if (0 == lstrlen(lpszCmdLine))
        {
            ErrorMsg(pDynShare->hwndMain, IDS_NOCMDLINE);
        }
        else
        {
            ErrorMsg1(pDynShare->hwndMain, IDS_INVALIDCMDLINE,
                lpszCmdLine ? lpszCmdLine : TEXT("\0"));
        }
        
        goto exit;
    }

    if (dwFlags & SEF_RUNONCE)
    { 
        SetControlFlags(SCF_SYSTEMCONFIGURED);
    }

    fileType = GetInetFileType(szFileName);
    switch (fileType)
    {
    case INS_FILE:
        DebugOut("ISIGNUP: Process INS\n");

        IsSingleInstance( TRUE );

        ProcessINS(pDynShare->hwndMain, szFileName, NULL != pDynShare->hwndMain);

        if (NULL == pDynShare->hwndMain)
        {
            DoExit();
        }
        goto exit;

    case HTML_FILE:
    case ISP_FILE:
    {
        if (!IsSingleInstance(FALSE))
            return FALSE;

        TCHAR szDrive [_MAX_DRIVE]    = TEXT("\0");
        TCHAR szDir   [_MAX_DIR]      = TEXT("\0");
        TCHAR szTemp  [_MAX_PATH + 1] = TEXT("\0");

        _tsplitpath(szFileName, szDrive, szDir, NULL, NULL);
        _tmakepath (szTemp, szDrive, szDir, HARDCODED_IEAK_ISP_FILENAME, NULL);

        //Examine the isp or htm file to see if they want to run the ICW
        if ((GetFileAttributes(szTemp) != 0xFFFFFFFF) && (UseICWForIEAK(szTemp)))
        {
            //they do .. let's do it.
            RunICWinIEAKMode(szTemp);
        }
        else //else RUN IEXPLORE Kiosk
        {
            // 8/19/96 jmazner Normandy #4571 and #10293
            // Check to ensure that the right version IE is installed before trying to exec it
            if ( !IEInstalled() )
            {
                ErrorMsg( hwnd, IDS_MISSINGIE );
                return(FALSE);
            }

            DWORD dwVerMS, dwVerLS;

            if( !GetAppVersion( &dwVerMS, &dwVerLS,IE_PATHKEY ) )
            {
                ErrorMsg( hwnd, IDS_MISSINGIE );
                return (FALSE);
            }

            if( !( (dwVerMS >= IE_MINIMUM_VERSIONMS) && (dwVerLS >= IE_MINIMUM_VERSIONLS) ) )
            {
                Dprintf("ISIGN32: user has IE version %d.%d.%d.%d; min ver is %d.%d.%d.%d\n",
                    HIWORD(dwVerMS), LOWORD(dwVerMS), HIWORD(dwVerLS), LOWORD(dwVerLS),
                    HIWORD(IE_MINIMUM_VERSIONMS),LOWORD(IE_MINIMUM_VERSIONMS),
                    HIWORD(IE_MINIMUM_VERSIONLS),LOWORD(IE_MINIMUM_VERSIONLS));
                ErrorMsg1( hwnd, IDS_IELOWVERSION, IE_MINIMUM_VERSION_HUMAN_READABLE );
                return(FALSE);
            }

            // 8/21/96  jmazner Normandy #4592
           
            if( !TestControlFlags(SCF_BROWSERLAUNCHED) )
            {
                if ( SaveIEWindowPlacement() )
                {
                    SetExitFlags(SXF_RESTOREIEWINDOWPLACEMENT);
                }
            }

            // check to see if we are the first window
            if (NULL == pDynShare->hwndMain)
            {
                DebugOut("ISIGNUP: First Window\n");

                hwnd = pDynShare->hwndMain = MainInit(); 
                
                if (dwFlags & SEF_SPLASH)
                {
                    pDynShare->hwndLaunch = LaunchInit(NULL); 
                }
                if (dwFlags & SEF_PROGRESS)
                {
                    // 8/16/96 jmazner Normandy #4593  pass NULL as ProgressInit's parent window
                    hwndProgress = ProgressInit(NULL);
                }
            }

            // 3/11/97 jmazner Olympus #1545
    // -------------------------------------------------------------------------
    // The entire section between here and the #endif was added to fix a security
    // hole in IE3.01.  The problem was based around .INS files being marked as
    // safe when in fact they could be used to launch any application if you knew
    // the right incantation, and someone figured it out.
    //
    //
            if (FALSE == TestControlFlags(SCF_SAFESET))
            {
    #define ISIGNUP_PATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ISIGNUP.EXE")
                hKey = NULL;
                //szPath[0] = '\0';
                //hSecureRegFile = INVALID_HANDLE_VALUE;

                Dprintf("ISIGN32: Adjusting EditFlags settings\n");

                //
                // ChrisK Olympus 6198 6/10/97
                // Allow HTML form submissions from ICW
                //
                if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,REG_ZONE3_KEY,&hKey))
                {
                    DWORD dwZoneData;
                    DWORD dwType;
                    DWORD dwSize;
                    g_dwZone_1601 = 0;
                    dwSize = sizeof(g_dwZone_1601);
                    dwType = 0;
                    //
                    // Read current setting for zone3 1601
                    //
                    if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                        REG_ZONE1601_KEY,
                                                        NULL,
                                                        &dwType,
                                                        (LPBYTE)&g_dwZone_1601,
                                                        &dwSize))
                    {
                        DebugOut("ISIGN32: Read zone settings succesfully.\n");
                        g_fReadZone = TRUE;
                    }
                    else
                    {
                        DebugOut("ISIGN32: Read zone settings failed.\n");
                    }
                    RegCloseKey(hKey);
                    hKey = NULL;
                }

                //
                // 8/7/97    jmazner Olympus #6059
                // Due to the way IE 4 shell deals with RunOnce processing,
                // don't add any thing to RunOnce until the browser is
                // completely initialized (we get a DISPID_NAVIGATECOMPLETE event.)
                //
                if (!(SEF_NOSECURITYBACKUP & dwFlags))
                {
                    SetControlFlags(SCF_NEEDBACKUPSECURITY);
                }
                else
                {
                    ClearControlFlags(SCF_NEEDBACKUPSECURITY);
                } 

                // Fix security hole for malious .isp/.ins file combinations
                BYTE szBytes[4];
                szBytes[0] = (BYTE)0;
                szBytes[1] = (BYTE)0;
                szBytes[2] = (BYTE)1;
                szBytes[3] = (BYTE)0;
                // Mark various registry entries as safe.
                if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT,TEXT("x-internet-signup"),&hKey))
                {
                    RegSetValueEx(hKey,TEXT("EditFlags"),(DWORD)NULL,(DWORD)REG_BINARY,(BYTE*)&szBytes[0],(DWORD)4);
                    RegCloseKey(hKey);
                    hKey = NULL;
                }
                if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT,TEXT(".ins"),&hKey))
                {
                    RegSetValueEx(hKey,TEXT("EditFlags"),(DWORD)NULL,(DWORD)REG_BINARY,(BYTE*)&szBytes[0],(DWORD)4);
                    RegCloseKey(hKey);
                    hKey = NULL;
                }
                if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT,TEXT(".isp"),&hKey))
                {
                    RegSetValueEx(hKey,TEXT("EditFlags"),(DWORD)NULL,(DWORD)REG_BINARY,(BYTE*)&szBytes[0],(DWORD)4);
                    RegCloseKey(hKey);
                    hKey = NULL;
                }
                bISetAsSAFE=TRUE;

                SetControlFlags(SCF_SAFESET); 

                //
                // ChrisK Olympus 6198 6/10/97
                // Allow HTML form submissions from ICW
                //
                if (g_fReadZone &&
                    ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,REG_ZONE3_KEY,&hKey))
                {
                    DWORD dwZoneData;

                    //
                    // Set value for zone to 0, therefore opening security window
                    //
                    dwZoneData = 0;
                    RegSetValueEx(hKey,
                                    REG_ZONE1601_KEY,
                                    NULL,
                                    REG_DWORD,
                                    (LPBYTE)&dwZoneData,
                                    sizeof(dwZoneData));
                    RegCloseKey(hKey);
                    hKey = NULL;
                }
            }
    //EndOfSecurityHandling:

            // jmazner 11/5/96 Normandy #8717
            // save autodial and clear out proxy _before_ bringing up the
            // IE instance.
            SaveAutoDial();
            SetExitFlags(SXF_RESTOREAUTODIAL);

            if (HTML_FILE == fileType)
            {
                DebugOut("ISIGNUP: Process HTML\n");
                
                fRet = ProcessHTML(pDynShare->hwndMain, szFileName);
            }
            else
            {
                DebugOut("ISIGNUP: Process ISP\n");

                if (TestControlFlags(SCF_ISPPROCESSING))
                {
                    SetForegroundWindow(pDynShare->hwndMain);
                    ReleaseSingleInstance();
                    return FALSE;
                }
                else
                { 
                    SetControlFlags(SCF_ISPPROCESSING);
                }

                fRet = ProcessISP(pDynShare->hwndMain, szFileName);
                
                SetControlFlags(SCF_ISPPROCESSING);
                
            }
        }//end else RUN IEXPLORE Kiosk
        break;
    }
    default:
        
        if (IsSingleInstance(FALSE))
        {
            ErrorMsg1(pDynShare->hwndMain, IDS_INVALIDFILETYPE, szFileName);
        }
        if (NULL != pDynShare->hwndMain)
        {
            PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
        }
        
        break;
    }

    // if we are the first window
    if ((hwnd == pDynShare->hwndMain) && (NULL != hwnd))
    {
        if (fRet)
        {
            MSG   msg;

            SetTimer(hwnd, 0, 1000, NULL);

            DebugOut("ISIGNUP: Message loop\n");

            while (GetMessage (&msg, NULL, 0, 0))
            {
                TranslateMessage (&msg) ;
                DispatchMessage  (&msg) ;
            }
            iRet = (int)msg.wParam ;
        }

        DoExit();

        if (NULL != hwndProgress)
        {
            DestroyWindow(hwndProgress);
            hwndProgress = NULL;
        }

        if (NULL != pDynShare->hwndLaunch)
        {
            DestroyWindow(pDynShare->hwndLaunch);
            pDynShare->hwndLaunch = NULL;
        }
        
        if (pDynShare->hwndMain)
        {
            DeleteUserDeviceSelection(DEVICENAMEKEY);
            DeleteUserDeviceSelection(DEVICETYPEKEY);
        }

        pDynShare->hwndMain = NULL;
         

    }

exit:

    // 3/11/97    jmazner    Olympus #1545
    if (TRUE == bISetAsSAFE)
    {
        RestoreSecurityPatch();
        ClearControlFlags(SCF_SAFESET); 
    }
    UnloadInetFunctions();
    ReleaseSingleInstance();
    return iRet;
}

HWND MainInit()
{
    HWND        hwnd ;
    WNDCLASS    wndclass ;

    wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
    wndclass.lpfnWndProc   = WndProc ;
    wndclass.cbClsExtra    = 0 ;
    wndclass.cbWndExtra    = 0 ;
    wndclass.hInstance     = ghInstance ;
    wndclass.hIcon         = LoadIcon (ghInstance, TEXT("ICO_APP")) ;
    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
    wndclass.hbrBackground = (HBRUSH)GetStockObject (WHITE_BRUSH) ;
    wndclass.lpszMenuName  = NULL ;
    wndclass.lpszClassName = cszWndClassName;

    RegisterClass (&wndclass) ;

    hwnd = CreateWindow (cszWndClassName,       // window class name
          cszAppName,              // window caption
          WS_POPUP,                // window style
          CW_USEDEFAULT,           // initial x position
          CW_USEDEFAULT,           // initial y position
          CW_USEDEFAULT,           // initial x size
          CW_USEDEFAULT,           // initial y size
          NULL,                    // parent window handle
          NULL,                    // window menu handle
          ghInstance,              // program instance handle
          NULL) ;                  // creation parameters

    return hwnd;
}

LRESULT EXPORT FAR PASCAL WndProc (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
#ifdef WIN32
    case WM_PROCESSISP:
        DebugOut("ISIGNUP: Message loop got WM_PROCESSISP");

        if (TestControlFlags(SCF_ISPPROCESSING))
        {
            DebugOut("ISIGNUP: Received another WM_PROCESSISP message with gbCurrentlyProcessingISP = TRUE\r\n");

            SetForegroundWindow(pDynShare->hwndMain);
            // that's it, don't do anything else!
        }
        else
        { 
            SetControlFlags(SCF_ISPPROCESSING);
            
            if ( !ProcessISP(pDynShare->hwndMain, g_szISPPath) )
            {
                PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
            }
        }

        break;
#endif
    case WM_TIMER:
        {
            
        HWND hwndTemp = FindBrowser();

        if (NULL == hwndTemp)
        {
            
            if (!TestControlFlags(SCF_SIGNUPCOMPLETED))
            {
                ++dwConnectedTime;
 
                if (pDynShare->hwndBrowser != NULL)
                {
                    // browser went away
                    KillTimer(hwnd, 0);
                    KillConnection();
                    InfoMsg(hwnd, IDS_BROWSERTERMINATED);
                    PostQuitMessage(0);
                }
                else if (dwConnectedTime > WAIT_TIME)
                {
                    KillTimer(hwnd, 0);

                    if (NULL != pDynShare->hwndLaunch)
                    {
                        ShowWindow(pDynShare->hwndLaunch, SW_HIDE);
                    }
                    InfoMsg(hwnd, IDS_BROWSERNEVERFOUND);
                    PostQuitMessage(0);
                }
            }
        }
        else
        {
            
#ifdef WIN32 // don't do this with OLE automation; we're already full screen, and this causes flicker
            //if (NULL == hwndBrowser)
            //{
            //first time browser has been detected
            //    ShowWindow(hwndTemp, SW_MAXIMIZE);
            //}
            
#endif
  
            if ((NULL != pDynShare->hwndLaunch) && IsWindowVisible(hwndTemp))
            {
                ShowWindow(pDynShare->hwndLaunch, SW_HIDE);
            }
        }
        pDynShare->hwndBrowser = hwndTemp;         
        }
        break;

    case WM_DESTROY:
        
#if !defined(WIN16)
 
        if (pDynShare->hReconnectEvent)
        {
            DebugOut("ISIGN32: Set event to end reconnect thread.\r\n"); 

            SetControlFlags(SCF_RECONNECTTHREADQUITED);
            SetEvent(pDynShare->hReconnectEvent);
            CloseHandle(pDynShare->hReconnectEvent);
            pDynShare->hReconnectEvent = NULL;
        }
#endif

        PostQuitMessage(0);
        return 0 ;
    }

    return DefWindowProc (hwnd, message, wParam, lParam) ;
}

void DoExit(void)
{

    if (TestExitFlags(SXF_RESTOREDEFCHECK))
    {
        // restore IE check for default browser
        FRestoreBrowserDefaultChecking();
    }

    if (!TestExitFlags(SXF_KEEPCONNECTION))
    {
        // make sure the connection is closed
        KillConnection();
    }

    if (!TestExitFlags(SXF_KEEPBROWSER))
    {
        // make sure the browser is closed
        KillBrowser();
    }

    if (TestExitFlags(SXF_RESTOREAUTODIAL))
    {
        // restore original autodial settings
        RestoreAutoDial();
    }

#if !defined(WIN16)
    // 8/21/96  jmazner Normandy #4592
    if ( TestExitFlags( SXF_RESTOREIEWINDOWPLACEMENT ))
    {
        RestoreIEWindowPlacement();
    }
#endif

    if (TestExitFlags(SXF_RUNEXECUTABLE))
    {
        BOOL fWait;

        fWait = TestExitFlags(SXF_WAITEXECUTABLE);

        if (RunExecutable(fWait) != ERROR_SUCCESS)
        {
            // clean up left overs
            if (TestExitFlags(SXF_KEEPCONNECTION))
            {
                // make sure the connection is closed
                KillConnection();
            }

            if (TestExitFlags(SXF_KEEPBROWSER))
            {
                // make sure the browser is closed
                KillBrowser();
            }
             
            ErrorMsg1(NULL, IDS_EXECFAILED, pDynShare->szRunExecutable);
            
            return;
        }
    }

}


BOOL HasPrefix(LPCTSTR lpszURL)
{
    TCHAR szTemp[sizeof(cszHTTPS)];

    //
    // Check is the prefix is https
    //
    lstrcpyn(szTemp, lpszURL, lstrlen(cszHTTPS) + 1);
    if (lstrcmp(szTemp, cszHTTPS) == 0)
        return TRUE;
    else
    {
        TCHAR szTemp[sizeof(cszHTTP)];
        lstrcpyn(szTemp, lpszURL, lstrlen(cszHTTP) + 1);
        return ((lstrcmp(szTemp, cszHTTP) == 0) || (lstrcmp(szTemp, cszFILE) == 0));
    }
}


#ifdef WIN32
DWORD FixUpLocalURL(LPCTSTR lpszURL, LPTSTR lpszFullURL, DWORD cb)
{
    TCHAR szLong[MAX_URL];
    TCHAR szShort[MAX_URL];
    DWORD dwSize;

    if (GetFullPathName(
            lpszURL,
            MAX_URL,
            szLong,
            NULL) != 0)
    {
        NULL_TERM_TCHAR_BUFFER(szLong);
        if (GetShortPathName(
                szLong,
                szShort,
                SIZEOF_TCHAR_BUFFER(szShort)) != 0)
            {
            NULL_TERM_TCHAR_BUFFER(szShort);
            dwSize = sizeof(cszFILE) + lstrlen(szShort);

            if (dwSize < cb)
            {
                lpszFullURL[0] = '\0';
// Do not prepend file: for local files
// IE3.0 hack for bug :MSN Systems Bugs #9280
//                lstrcpy(lpszFullURL, cszFILE);
                lstrcat(lpszFullURL, szShort);
                return dwSize;
            }
        }
    }
    return 0;
}
#else
DWORD FixUpLocalURL(LPCTSTR lpszURL, LPTSTR lpszFullURL, DWORD cb)
{
    TCHAR szPath[MAX_URL];
    DWORD dwSize;

    if (GetFullPathName(
            lpszURL,
            MAX_URL,
            szPath,
            NULL) != 0)
    {
        dwSize = sizeof(cszFILE) + lstrlen(szPath);

        if (dwSize < cb)
        {
            lstrcpy(lpszFullURL, cszFILE);
            lstrcat(lpszFullURL, szPath);
            return dwSize;
        }
    }
    return 0;
}
#endif



DWORD FixUpURL(LPCTSTR lpszURL, LPTSTR lpszFullURL, DWORD cb)
{
    DWORD dwSize;

    if (HasPrefix(lpszURL))
    {
    dwSize = lstrlen(lpszURL);

    if (dwSize < cb)
    {
        lstrcpyn(lpszFullURL, lpszURL, (int)cb);
        return dwSize;
    }
    else
    {
        return 0;
    }
    }
    else
    {
    return (FixUpLocalURL(lpszURL, lpszFullURL, cb));
    }
}


BOOL GetURL(LPCTSTR lpszFile, LPCTSTR lpszKey, LPTSTR lpszURL, DWORD cb)
{
    return (GetPrivateProfileString(cszURLSection,
                  lpszKey,
                  szNull,
                  lpszURL,
                  (int)cb,
                  lpszFile) != 0);
}

LPTSTR mystrrchr(LPCTSTR lpString, TCHAR ch)
{
    LPCTSTR lpTemp = lpString;
    LPTSTR lpLast = NULL;

    while (*lpTemp)
    {
    if (*lpTemp == ch)
    {
        lpLast = (LPTSTR)lpTemp;
    }
    lpTemp = CharNext(lpTemp);
    }
    return lpLast;
}

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//    Function    CopyUntil
//
//    Synopsis    Copy from source until destination until running out of source
//                or until the next character of the source is the chend character
//
//    Arguments    dest - buffer to recieve characters
//                src - source buffer
//                lpdwLen - length of dest buffer
//                chend - the terminating character
//
//    Returns        FALSE - ran out of room in dest buffer
//
//    Histroy        10/25/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL CopyUntil(LPTSTR *dest, LPTSTR *src, LPDWORD lpdwLen, TCHAR chend)
{
    while (('\0' != **src) && (chend != **src) && (0 != *lpdwLen))
    {
        **dest = **src;
        (*lpdwLen)--;
        (*dest)++;
        (*src)++;
    }
    return (0 != *lpdwLen);
}

//+----------------------------------------------------------------------------
//    Function    ConvertToLongFilename
//
//    Synopsis    convert a file to the full long file name
//                ie. c:\progra~1\icw-in~1\isignup.exe becomes
//                c:\program files\icw-internet connection wizard\isignup.exe
//
//    Arguments    szOut - output buffer
//                szIn - filename to be converted
//                dwSize - size of the output buffer
//
//    Returns        TRUE - success
//
//    History        10/25/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL ConvertToLongFilename(LPTSTR szOut, LPTSTR szIn, DWORD dwSize)
{
    BOOL bRC = FALSE;
    LPTSTR pCur = szIn;
    LPTSTR pCurOut = szOut;
    LPTSTR pCurOutFilename = NULL;
    WIN32_FIND_DATA fd;
    DWORD dwSizeTemp;
    LPTSTR pTemp = NULL;

    ZeroMemory(pCurOut,dwSize);

    //
    // Validate parameters
    //
    if (NULL != pCurOut && NULL != pCur && 0 != dwSize)
    {

        //
        // Copy drive letter
        //
        if (!CopyUntil(&pCurOut,&pCur,&dwSize,'\\'))
            goto ConvertToLongFilenameExit;
        pCurOut[0] = '\\';
        dwSize--;
        pCur++;
        pCurOut++;
        pCurOutFilename = pCurOut;

        while (*pCur)
        {
            //
            // Copy over possibly short name
            //
            pCurOut = pCurOutFilename;
            dwSizeTemp = dwSize;
            if (!CopyUntil(&pCurOut,&pCur,&dwSize,'\\'))
                goto ConvertToLongFilenameExit;

            ZeroMemory(&fd, sizeof(fd));
            //
            // Get long filename
            //
            if (INVALID_HANDLE_VALUE != FindFirstFile(szOut,&fd))
            {
                //
                // Replace short filename with long filename
                //
                dwSize = dwSizeTemp;
                pTemp = &(fd.cFileName[0]);
                if (!CopyUntil(&pCurOutFilename,&pTemp,&dwSize,'\0'))
                    goto ConvertToLongFilenameExit;
                if (*pCur)
                {
                    //
                    // If there is another section then we just copied a directory
                    // name.  Append a \ character;
                    //
                    pTemp = (LPTSTR)memcpy(TEXT("\\X"),TEXT("\\X"),0);
                    if (!CopyUntil(&pCurOutFilename,&pTemp,&dwSize,'X'))
                        goto ConvertToLongFilenameExit;
                    pCur++;
                }
            }
            else
            {
                break;
            }
        }
        //
        // Did we get to the end (TRUE) or fail before that (FALSE)?
        //

        bRC = ('\0' == *pCur);
    }
ConvertToLongFilenameExit:
    return bRC;
}
#endif //!WIN16

INET_FILETYPE GetInetFileType(LPCTSTR lpszFile)
{
    LPTSTR lpszExt;
    INET_FILETYPE ft = UNKNOWN_FILE;

    lpszExt = mystrrchr(lpszFile, '.');
    if (NULL != lpszExt)
    {
    if (!lstrcmpi(lpszExt, cszExtINS))
    {
        ft = INS_FILE;
    }
    else if (!lstrcmpi(lpszExt, cszExtISP))
    {
        ft = ISP_FILE;
    }
    else if (!lstrcmpi(lpszExt, cszExtHTM))
    {
        ft = HTML_FILE;
    }
    else if (!lstrcmpi(lpszExt, cszExtHTML))
    {
        ft = HTML_FILE;
    }
    }

    return ft;
}

#ifdef SETUPSTACK
DWORD SetRunOnce(LPCTSTR lpszFileName)
{
    TCHAR szTemp[MAX_PATH + MAX_PATH + 1];
    TCHAR szTemp2[MAX_PATH + 1];
    DWORD dwRet = ERROR_CANTREAD;
    HKEY hKey;
    LPTSTR lpszFilePart;


    if (GetModuleFileName(NULL,szTemp2,SIZEOF_TCHAR_BUFFER(szTemp2)) != 0)
    {
        NULL_TERM_TCHAR_BUFFER(szTemp2);
        //
        // Will not convert the ShortPathName into LongPathName even in
        // case of NT/Win-95 as START.EXE parses long file names incorrectly
        // on NT (short path names will work fine from Win-95's RUNONCE registry
        // entry too. MKarki - Fix for Bug #346(OLYMPUS) 4/21/97
        //
#if 0   //!defined(WIN16)
        // szTemp2 contains the module name in short format
        ConvertToLongFilename(szTemp,szTemp2,MAX_PATH);
        // add quotes
        wsprintf(szTemp2,TEXT("\"%s\""),szTemp);
        // copy back into szTemp
        lstrcpy(szTemp,szTemp2);
#else
        GetShortPathName (szTemp2, szTemp, SIZEOF_TCHAR_BUFFER(szTemp));
        NULL_TERM_TCHAR_BUFFER(szTemp);
          //lstrcpy(szTemp,szTemp2);
#endif

        // Determine Version
        OSVERSIONINFO osvi;
        ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
         if (!GetVersionEx(&osvi))
        {
            ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
        }

        // 1/20/96 jmazner Normandy #9403
        // For NT only, use the startup menu
        if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
        {
            // 3/14/97 jmazner TEMP
            // temporary hack until we can work with IE for a better solution
            //lstrcat(szTemp, " -r ");

            //
            // adding a -b switch so that when we start again we
            // know that we are starting of a batch file
            // MKarki (5/1/97) -Fix for Bug #4049
            //
            lstrcat(szTemp, TEXT(" -b -r -h "));

            //
            // adding extra quote at the front and end of file
            // as we dont want start.exe to parse the filename
            // MKarki (5/1/97) -Fix for Bug #4049
            //
            lstrcat (szTemp,TEXT("\""));
            lstrcat(szTemp, lpszFileName);
            lstrcat (szTemp,TEXT("\""));
            SetStartUpCommand( szTemp );
        }
        else
        {
            //
            // 3/14/97 jmazner TEMP
            // temporary hack until we can work with IE for a better solution
            //
            // 8/8/97 jmazner Olympus #6059
            // Well, we have a somewhat better solution.  The problem here was that
            // isignup without the -h sticks the backup security into the RunOnce key.
            // But if Isignup itself was started from a RunOnce entry, there was a
            // chance that RunOnce would also then execute the backup plan.  For 6059
            // the backup plan RunOnce entry has been defered, so it's okay to get
            // rid of the -h now
            //
            lstrcat(szTemp, TEXT(" -r "));
            //lstrcat(szTemp, TEXT(" -r -h "));
            lstrcat(szTemp, lpszFileName);

            dwRet = RegCreateKey(
                HKEY_LOCAL_MACHINE,
                REGSTR_PATH_RUNONCE,
                &hKey);

            if (ERROR_SUCCESS == dwRet)
            {
                dwRet = RegSetValueEx(
                    hKey,
                    cszAppName,
                    0L,
                    REG_SZ,
                    (LPBYTE)szTemp,
                    MAX_PATH + MAX_PATH + 1);

                RegCloseKey(hKey);
            }
        }
    }

    return dwRet;
}
#endif

static BOOL ProcessCommandLine(
                               LPCTSTR lpszCmdLine,
                               LPDWORD lpdwfOptions,
                               LPTSTR lpszFile,
                               DWORD cb)
{
    LPTSTR lpszCmd = NULL;
    TCHAR szCommandLine[MAX_PATH +1];
    TCHAR szTemp[_MAX_PATH + 1] = TEXT("");
    LPTSTR lpszFilePart = NULL;
    LPTSTR lpszConn = NULL;
    BOOL fEnabled;


    //
    // need to copy the command line into our own buffers
    // as it might be modified
    // MKarki (5/1/97) - Fix for Bug#4049
    //
    CopyMemory (szCommandLine, lpszCmdLine, MAX_PATH);
    lpszCmd = szCommandLine;

    *lpdwfOptions = SEF_SPLASH;

#ifdef WIN32
    // Determine Version
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
     if (!GetVersionEx(&osvi))
    {
        ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
    }
#endif


    // check to see if invoked from run once
    while ((*lpszCmd == '-') || (*lpszCmd == '/'))
    {
        ++lpszCmd;  // skip '-' or '/'

        switch (*lpszCmd)
        {

        case 'b':       // we are running off a batch file
            ++lpszCmd;  // skip 'b'
#ifdef WIN32
            //
            // another thing specific to WINNT is to remove the
            // quotes from front and end of the file name, these
            // have been put so that start.exe does not act smart
            // and start parsing it and find things like & as special
            // chars
            // MKarki (5/1/97) - Fix for Bug #4049
            if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
            {
                RemoveQuotes (lpszCmd);
            }
#endif

        case 'r':
            ++lpszCmd;  // skip 'r'
            *lpdwfOptions |= SEF_RUNONCE;
#ifdef WIN32
            // 1/20/96 jmazner Normandy #9403
            // clean up the .bat file if we did a run once under NT
            if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
            {
                DeleteStartUpCommand();
            }
#endif
            break;

        case 'a':
            ++lpszCmd;  // skip 'a'

            *lpdwfOptions &= ~SEF_SPLASH;
             
            SetControlFlags(SCF_AUTODIALSAVED);
            
            SetExitFlags(SXF_RESTOREAUTODIAL);

            // get the name of the ISBU referal server, we may need it later.
            lpfnInetGetAutodial(
                &fEnabled,
                pDynShare->szSignupConnection,
                sizeof(pDynShare->szSignupConnection));
 
            if (*lpszCmd++ == '1')
            { 
                SetControlFlags(SCF_AUTODIALENABLED);
            }
            break;

        case 'p':
            ++lpszCmd;  // skip 'p'

            if (*lpszCmd++ == '1')
            { 
                SetControlFlags(SCF_PROXYENABLED);
            }
            break;

        case 'c':
            ++lpszCmd;  // skip 'c'
            if (*lpszCmd++ != '"')
            {
                return FALSE;
            }

            lpszConn = pDynShare->szAutodialConnection;
            
            while(*lpszCmd)
            {
                if (*lpszCmd == '"')
                {
                    ++lpszCmd;  // skip '"'
                    break;
                }
                *lpszConn++ = *lpszCmd++;
            }
            *lpszConn = 0;  // terminate string
            break;

        case 'x':
            ++lpszCmd;  // skip 'x'
            *lpdwfOptions |= SEF_PROGRESS;
            break;

#if !defined(WIN16)
        case 's':
            ++lpszCmd;  // skip 's'
 
            SetControlFlags(SCF_SILENT);
            
            break;
#endif
            // 3/14/97 jmazner TEMP
            // temporary hack until we can work with IE for a better solution
            case 'h':
                ++lpszCmd; // skip 'h'
                *lpdwfOptions |= SEF_NOSECURITYBACKUP;
                break;

        default:
            break;
        }

        // strip away spaces
        while(*lpszCmd == ' ')
        {
            ++lpszCmd;
        }
    }

    if (0 == GetFullPathName(lpszCmd, _MAX_PATH + 1, szTemp, &lpszFilePart))
    {
        return FALSE;
    }

    // 11/26/96 jmazner Normandy #12142
    // GetFullPathName called with lpszCmd == "c:" will return successfully, but
    // lpszFilePart will be NULL.  Check for that case.
    if( !lpszFilePart )
        return FALSE;

    if (lstrlen(szTemp) >= (int)cb)
    {
        return FALSE;
    }

    lstrcpy(lpszFile, szTemp);

    *lpszFilePart = '\0';

    // set the current directory
    // so that relative path will work
    if (!SetCurrentDirectory(szTemp))
    {
        return FALSE;
    }

    return TRUE;
}

static BOOL KeepBrowser(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszCustomSection,
        cszKeepBrowser,
        cszNo,
        szTemp,
        10,
        lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

static BOOL KeepConnection(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszCustomSection,
        cszKeepConnection,
        cszNo,
        szTemp,
        10,
        lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

#if defined(WIN16)
static int CopyFile(LPCTSTR lpcszSrcFile, LPCTSTR lpcszDestFile)
{
    HFILE hSrcFile, hDestFile;
    UINT uiBytesRead = 0;
    TCHAR szBuf[2048];


    hSrcFile = _lopen(lpcszSrcFile, READ);
    if (HFILE_ERROR == hSrcFile)
        return -1;

    //
    // Create new file or if the file esists truncate it
    //
    hDestFile = _lcreat(lpcszDestFile, 0);
    if (HFILE_ERROR == hDestFile)
    {
        _lclose(hSrcFile);
        return -1;
    }


    do
    {
        uiBytesRead = _lread(hSrcFile, &szBuf[0], 2048);
        if (HFILE_ERROR == uiBytesRead)
            break;
        _lwrite(hDestFile, &szBuf[0], uiBytesRead);

    }  while (0 != uiBytesRead);


    _lclose(hSrcFile);
    _lclose(hDestFile);

    return 0;
}
#endif

#if defined(WIN16)
//+----------------------------------------------------------------------------
//
//    Function:    BackUpINSFile
//
//    Synopsis:    The 3.1 version of IE2.01 will delete the .ins file too soon
//                therefore the ICW will make a backup of the ins file for use
//                later.
//
//    Arguments:    lpszFile - name of INS file
//
//    Returns:    TRUE - success
//                FALSE - failure
//
//    History:    3/19/97 ChrisK    extracted from ProcessINS
//-----------------------------------------------------------------------------
BOOL BackUpINSFile(LPCTSTR lpszFile)
{
    LPTSTR lpszTemp;
    TCHAR szNewFileName[MAX_PATH+2];
    BOOL bRC = FALSE;
    HWND hwnd = NULL;

    ZeroMemory(&szNewFileName[0], MAX_PATH+1);

    //
    // Check if the last character in prefix is 'a'
    // If it is, change it to 'b' in the new file name
    // otherwise, change it to 'a' in the new file name
    // Eg.: C:\iexplore\vetriv.ins --> C:\iexplore\vetria.ins
    // Eg.: C:\iexplore\aaaaa.ins --> C:\iexplore\aaaab.ins
    //
    lpszTemp = strrchr(lpszFile, '.');
    if (NULL == lpszTemp)
    {
      ErrorMsg(hwnd, IDS_CANNOTPROCESSINS);
      goto BackUpINSFileExit;
    }

    lstrcpyn(szNewFileName, lpszFile, lpszTemp - lpszFile);
    if ((*(lpszTemp - 1)) == 'a')
        lstrcat(szNewFileName, TEXT("b.INS"));
    else
        lstrcat(szNewFileName, TEXT("a.INS"));

    //
    // Copy the contents
    //
    if (0 != CopyFile(lpszFile, szNewFileName))
    {
      ErrorMsg(hwnd, IDS_CANNOTPROCESSINS);
      goto BackUpINSFileExit;
    }
    else
    {
        lpszFile = &szNewFileName[0];
    }

    bRC = TRUE;
BackUpINSFileExit:
    return bRC;
}
#endif // WIN16

//+----------------------------------------------------------------------------
//
//    Function:    IsCancelINSFile
//
//    Synopsis:    This function will determine if the ins file is a cancel
//                file, and if it is this function will handle it accordingly
//
//    Arguments:    lpszFile - name of ins file
//                fSignup - TRUE if part of the signup process
//
//    Returns:    TRUE - ins file is a cancel file
//
//    History:    3/19/97    ChrisK    separated from process INS
//-----------------------------------------------------------------------------
BOOL IsCancelINSFile(LPCTSTR lpszFile,BOOL fSignup)
{
    TCHAR szTemp[_MAX_PATH] = TEXT("XX");
    BOOL bRC = FALSE;
    HWND hwndMsg;
    if (GetPrivateProfileString(cszEntrySection,
                                    cszCancel,
                                    szNull,
                                    szTemp,
                                    _MAX_PATH,
                                    lpszFile) != 0)
    {
        bRC = TRUE;
         
        if (fSignup && !TestControlFlags(SCF_CANCELINSPROCESSED))
        {
            // If this instance is part of a signup process
            
#if !defined(WIN16)

            SetControlFlags(SCF_HANGUPEXPECTED);

#endif // !WIN16

            SetControlFlags(SCF_CANCELINSPROCESSED);
            
            KillConnection();
 
            // jmazner 4/17/97 Olympus #2471
            // kill IE window here to prevent user from clicking on cancel.ins link
            // multiple times.
            PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);

            InfoMsg(NULL, IDS_SIGNUPCANCELLED);

            //PostMessage(hwndMain, WM_CLOSE, 0, 0);
        }
        else if (TestControlFlags(SCF_CANCELINSPROCESSED))
        {
            // Bring the ISIGNUP widows to the front
            hwndMsg = FindWindow(TEXT("#32770"),cszAppName);
            if (hwndMsg)
            {
                
#if !defined(WIN16)
                SetForegroundWindow (hwndMsg);
#else // !WIN16
                SetFocus (hwndMsg);
#endif // !WIN16

            }
            
        }

    }
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    IsHangupINSFile
//
//    Synopsis:    This function will determine if the ins file is a hangup
//                file, and if it is this function will handle it accordingly
//
//    Arguments:    lpszFile - name of ins file
//                fSignup - TRUE if part of the signup process
//
//    Returns:    TRUE - ins file is a hangup file
//
//    History:    3/19/97    donaldm
//-----------------------------------------------------------------------------
BOOL IsHangupINSFile(LPCTSTR lpszFile,BOOL fSignup)
{
    TCHAR szTemp[_MAX_PATH] = TEXT("XX");
    BOOL bRC = FALSE;
    HWND hwndMsg;
    if (GetPrivateProfileString(cszEntrySection,
                                    cszHangup,
                                    szNull,
                                    szTemp,
                                    _MAX_PATH,
                                    lpszFile) != 0)
    {
        bRC = TRUE; 
        
        if (fSignup && !TestControlFlags(SCF_HANGUPINSPROCESSED))
        {
            // If this instance is part of a signup process

#if !defined(WIN16)

            SetControlFlags(SCF_HANGUPEXPECTED);

#endif // !WIN16

            SetControlFlags(SCF_HANGUPINSPROCESSED);
            
            KillConnection();
 
            // jmazner 4/17/97 Olympus #2471
            // kill IE window here to prevent user from clicking on cancel.ins link
            // multiple times.
            PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
            
        }
        else if (TestControlFlags(SCF_HANGUPINSPROCESSED))
        {
            // Bring the ISIGNUP widows to the front
            hwndMsg = FindWindow(TEXT("#32770"),cszAppName);
            if (hwndMsg)
            {
                
#if !defined(WIN16)
                SetForegroundWindow (hwndMsg);
#else // !WIN16
                SetFocus (hwndMsg);
#endif // !WIN16

            }
            
        }

    }
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    ProcessINS
//
//    Synopsis:    This function will process the contents of an .INS file
//
//    Arguments:    hwnd - pointer to parent window for all UI elements
//                lpszFile - name of .INS file
//                fSignup - if TRUE then this INS file is being processed as
//                    part a signup
//
//    Returns:    TRUE - success
//                FALSE - failure
//
//    History:    3/19/97    ChrisK    Reworked the function considerbly to clean up
//                    a lot of problem with deleting INS files.
//-----------------------------------------------------------------------------
BOOL ProcessINS(HWND hwnd, LPCTSTR lpszFile, BOOL fSignup)
{
    BOOL fNeedsRestart = FALSE;
    LPRASENTRY lpRasEntry = NULL;
    BOOL fConnectoidCreated = FALSE;
    DWORD dwRet = 0xFF;
    TCHAR szTemp[MAX_PATH] = TEXT("XX");
    TCHAR szConnectoidName[RAS_MaxEntryName*2] = TEXT("");
    BOOL fClientSetup = FALSE;
    BOOL bRC = FALSE;
    BOOL fErrMsgShown = FALSE;
#if !defined(WIN16)
    DWORD dwSBSRet = ERROR_SUCCESS;
#endif // WIN16

    HKEY    hKey = NULL;
    DWORD   dwSize = sizeof(DWORD);
    DWORD   dwDesktopChanged = 0;


    // 3/11/97 jmazner Olympus #1545
    // close up the security hole ASAP.  This will unfortunately also
    // prevent a clever .ins file from bringing the user back to the
    // referall page to choose a different ISP
#if !defined (WIN16)
    RestoreSecurityPatch();
#endif // !WIN16

    //
    // Insure that the contents of the file are formatted correctly so
    // that the GetPrivateProfile calls can parse the contents.
    //
    dwRet = MassageFile(lpszFile);
    if (ERROR_SUCCESS != dwRet)
    {
        ErrorMsg(hwnd, IDS_CANNOTPROCESSINS);
        goto ProcessINSExit;
    }

    //
    // Determine if the .INS file is a "cancel" file
    //
    if (FALSE != IsCancelINSFile(lpszFile,fSignup))
        goto ProcessINSExit;

    //
    // Determine if the .INS file is a "hangup" file
    //
    if (FALSE != IsHangupINSFile(lpszFile,fSignup))
        goto ProcessINSExit;

    //
    // Make sure that the RAS services are running before calling any RAS APIs.
    // This only applies to NT, but the function is smart enough to figure that
    // out
    //
#if !defined(WIN16)
    if (!VerifyRasServicesRunning(hwnd))
        goto ProcessINSExit;
#endif // !WIN16 

    //
    // If we are no in the signup process, warn the user before changing there
    // settings
    //
    if (!fSignup && !TestControlFlags(SCF_SILENT))
    {
        if (!WarningMsg(NULL, IDS_INSFILEWARNING))
        {
            goto ProcessINSExit;
        }
    }
    else
    {
#if !defined (WIN16)
        // If there is a ClientSetup section, then we know that icwconn2
        // will have to be run after isignup in order to handle the
        // settings
        if (GetPrivateProfileSection(cszClientSetupSection,
            szTemp,
            MAX_PATH,
            lpszFile) != 0)
            fClientSetup = TRUE;
#endif // !WIN16

        if (fClientSetup || KeepConnection(lpszFile))
            SetExitFlags(SXF_KEEPCONNECTION);

        if (KeepBrowser(lpszFile))
            SetExitFlags(SXF_KEEPBROWSER);

        if (!TestExitFlags(SXF_KEEPCONNECTION))
            KillConnection();
    }

    //
    // Import various information from INS file
    //

    // Import name of executable to be launched after isignup
    ImportCustomInfo(
        lpszFile,
        pDynShare->szRunExecutable,
        SIZEOF_TCHAR_BUFFER(pDynShare->szRunExecutable),
        pDynShare->szRunArgument,
        SIZEOF_TCHAR_BUFFER(pDynShare->szRunArgument));

    // Import RAS log-on script file
    ImportCustomFile(lpszFile);
 
    
    // Import network connection settings information and configure client
    // pieces to use them.
    dwRet = ConfigureClient(
        hwnd,
        lpszFile,
        &fNeedsRestart,
        &fConnectoidCreated,
        TestControlFlags(SCF_LOGONREQUIRED),
        szConnectoidName,
        RAS_MaxEntryName);

    //
    // 6/2/97 jmazner Olympus #4573
    // display an appropriate error msg
    //
    if( ERROR_SUCCESS != dwRet )
    {
        // 10/07/98 vyung IE bug#32882 hack.
        // If we do not detect the [Entry] section in the ins file,
        // we will assume it is an OE ins file.  Then we will assume
        // we have a autodial connection and pass the INS to OE.
        if (ERROR_NO_MATCH == dwRet)
        {
            ImportMailAndNewsInfo(lpszFile, TRUE);
            return TRUE;
        }
        else
        {
            ErrorMsg(hwnd, IDS_INSTALLFAILED);
            fErrMsgShown = TRUE;
        }
    }

    // Import information used to brand the broswer
    ImportBrandingInfo(lpszFile, szConnectoidName);

#if !defined(WIN16)
    // If we created a connectoid, tell the world that ICW
    // has left the building...
    SetICWCompleted( (DWORD)1 );
    
    ClearControlFlags(SCF_ICWCOMPLETEDKEYRESETED);

    // 2/19/97 jmazner    Olympus 1106
    // For SBS/SAM integration.
    dwSBSRet = CallSBSConfig(hwnd, lpszFile);
    switch( dwSBSRet )
    {
        case ERROR_SUCCESS:
            break;
        case ERROR_MOD_NOT_FOUND:
        case ERROR_DLL_NOT_FOUND:
            Dprintf("ISIGN32: SBSCFG DLL not found, I guess SAM ain't installed.\n");
            break;
        default:
            ErrorMsg(hwnd, IDS_SBSCFGERROR);
    }
#endif // !WIN16

#if defined(WIN16)

    //
    // Since IE 21 deletes the file from cache, we have to make
    // a private copy of it, if we are going to run a 3rd EXE
    //    
    if (*(pDynShare->szRunExecutable))
    {
        if (FALSE == BackUpINSFile(lpszFile))
          goto ProcessINSExit;
    }
    
#endif // WIN16

#if !defined (WIN16)
    //
    // If the INS file contains the ClientSetup section, build the commandline
    // arguments for ICWCONN2.exe.
    //
    if (fClientSetup)
    {
        // Check to see if a REBOOT is needed and tell the next application to
        // handle it.
        if (fNeedsRestart)
        {
            wsprintf(pDynShare->szRunArgument,TEXT(" /INS:\"%s\" /REBOOT"),lpszFile);
            fNeedsRestart = FALSE;
        }
        else
        {
            wsprintf(pDynShare->szRunArgument,TEXT(" /INS:\"%s\""),lpszFile);
        }

    }
#else // !WIN16

    wsprintf(szRunArgument," /INS:\"%s\"",lpszFile);

#endif // !WIN16

    SetControlFlags(SCF_SIGNUPCOMPLETED);
    
    if (!TestExitFlags(SXF_KEEPBROWSER))
        KillBrowser();

#ifdef WIN32
    // humongous hack for ISBU
    if (ERROR_SUCCESS != dwRet && fConnectoidCreated)
    {
        InfoMsg(hwnd, IDS_MAILFAILED);
        dwRet = ERROR_SUCCESS;
    }
#endif

    //
    // Import settings for mail and new read from INS file (ChrisK, 7/1/96)
    //
    if (ERROR_SUCCESS == dwRet)
        ImportMailAndNewsInfo(lpszFile, fConnectoidCreated);

    //
    // Close up final details and clean up
    //
    if (ERROR_SUCCESS == dwRet)
    {
        // if the connectoid was created, do not restore the old autodial settings
        if (fConnectoidCreated)
            ClearExitFlags(SXF_RESTOREAUTODIAL);

#ifdef SETUPSTACK
        // Is it necessary to reboot for configuration to take effect?
        if (fNeedsRestart)
        {
            // what do we do if we need to run executable and
            // we need the link or the browser  BARF!!
            if (PromptRestart(hwnd))
            {
                // 3/13/97 jmazner Olympus #1682
                // technically, shouldn't need this here since we did it at the start
                // of processINS, but better safe...
                RestoreSecurityPatch();

                FGetSystemShutdownPrivledge();
                ExitWindowsEx(EWX_REBOOT, 0);
                //
                //  We will wait for the System to release all
                //  resources, 5 minutes should be more than
                //  enough for this
                //  - MKarki (4/22/97) - MKarki
                //  Fix for Bug #3109
                //
                // 7/8/97 jmazner Olympus 4212
                // No, sleeping for 5 minutes turns out not to be such a good idea.
                //Sleep (300000);
                //
            }
        }
        else
#endif
        {
 
            if (*(pDynShare->szRunExecutable))
            {
                SetExitFlags(SXF_RUNEXECUTABLE | SXF_WAITEXECUTABLE);
            }
            else
            {
                 
                if (!TestControlFlags(SCF_SILENT))
                    InfoMsg(hwnd, IDS_SIGNUPCOMPLETE);
                
            }
        }
    }
    else
    {
        // In case of an error with network or connection settings
        ClearExitFlags(~SXF_RESTOREAUTODIAL);

        if( !fErrMsgShown )
        {
            ErrorMsg(hwnd, IDS_BADSETTINGS);
            fErrMsgShown = TRUE;
        }
    }

    // If this is part of signup process, then signal the first instance
    // to close
    if (fSignup)
    {
         
        PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
    }

    // Restore the desktop icons if we have the newer version of ICWCONN1.EXE,
    // and we previsouly munged them.
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,ICWSETTINGSPATH,&hKey))
    {
        RegQueryValueEx(hKey,
                        ICWDESKTOPCHANGED,
                        0,
                        NULL,
                        (BYTE*)&dwDesktopChanged,
                        &dwSize);
        RegCloseKey(hKey);
    }

    if (dwDesktopChanged)
    {
        DWORD dwVerMS, dwVerLS;
        if( GetAppVersion( &dwVerMS, &dwVerLS, ICW20_PATHKEY ) )
        {
//        if( ( (dwVerMS >= ICW20_MINIMUM_VERSIONMS) && (dwVerLS >= ICW20_MINIMUM_VERSIONLS) ) )
            if(dwVerMS >= ICW20_MINIMUM_VERSIONMS)
            {
                ShellExecute(NULL, cszOpen, g_szICWCONN1, g_szRestoreDesktop, NULL, SW_HIDE);
            }
        }
    }

    bRC = TRUE;
ProcessINSExit: 

    // 3/11/97 jmazner Olympus #1233, 252
    // if no 3rd exe, and this instance is part of a signup process and
    // SERVERLESS flag is not set for IEAK, then delete the .ins file
    if ( (fSignup) &&
         (('\0' == pDynShare->szRunExecutable[0]) || (ERROR_SUCCESS != dwRet)) )
    {
        if (1 != GetPrivateProfileInt(
            cszBrandingSection,
            cszBrandingServerless,
            0,
            lpszFile))
        {
            DeleteFileKindaLikeThisOne(lpszFile);
        }
        else
        {
            Dprintf("ISIGN32: Preserving .ins file for SERVERLESS flag\n");
        }
    }
    return bRC;
}

static BOOL RequiresLogon(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszUserSection,
        cszRequiresLogon,
        cszNo,
        szTemp,
        10,
        lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}


static UINT GetBrandingFlags(LPCTSTR lpszFile)
{
    return GetPrivateProfileInt(
        cszBrandingSection,
        cszBrandingFlags,
        BRAND_DEFAULT,
        lpszFile);
}

//+----------------------------------------------------------------------------
//
//    Function:    SetGlobalOffline
//
//    Synopsis:    Set IE4 into online or offline mode
//
//    Arguments:    fOffline - TRUE to set OFFLINE mode
//                            FALSE to set ONLINE mode
//
//    Returns:    none
//
//    History:    7/15/97    ChrisK imported from DarrenMi's email
//
//-----------------------------------------------------------------------------

typedef struct {
    DWORD dwConnectedState;
    DWORD dwFlags;
} INTERNET_CONNECTED_INFO, * LPINTERNET_CONNECTED_INFO;

//
// the following can be indicated in a state change notification:
//

#define INTERNET_STATE_CONNECTED                0x00000001  // connected state (mutually exclusive with disconnected)
#define INTERNET_STATE_DISCONNECTED             0x00000002  // disconnected from network
#define INTERNET_STATE_DISCONNECTED_BY_USER     0x00000010  // disconnected by user request
#define INTERNET_STATE_IDLE                     0x00000100  // no network requests being made (by Wininet)
#define INTERNET_STATE_BUSY                     0x00000200  // network requests being made (by Wininet)

#define ISO_FORCE_DISCONNECTED  0x00000001

#define INTERNET_OPTION_CONNECTED_STATE         50

typedef BOOL (WINAPI *PFNSETINTERNETOPTIONA)(LPVOID, DWORD, LPVOID, DWORD);

void SetGlobalOffline(BOOL fOffline)
{
    DebugOut("ISIGN32: SetGlobalOffline.\n");
    INTERNET_CONNECTED_INFO ci;
    HMODULE hMod = LoadLibrary(TEXT("wininet.dll"));
    FARPROC fp = NULL;
    BOOL bRC = FALSE;

    ZeroMemory(&ci, sizeof(ci));

    if (NULL == hMod)
    {
        Dprintf("ISIGN32: Wininet.dll did not load.  Error:%d.\n",GetLastError());
        goto InternetSetOptionExit;
    }

#ifdef UNICODE
    if (NULL == (fp = GetProcAddress(hMod,"InternetSetOptionW")))
#else
    if (NULL == (fp = GetProcAddress(hMod,"InternetSetOptionA")))
#endif
    {
        Dprintf("ISIGN32: InternetSetOptionA did not load.  Error:%d.\n",GetLastError());
        goto InternetSetOptionExit;
    }

    if(fOffline) {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    DebugOut("ISIGN32: Setting offline\\online.\n");
    bRC = ((PFNSETINTERNETOPTIONA)fp) (NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
#ifdef DEBUG
    if (bRC)
    {
        DebugOut("ISIGN32: GetGlobalOffline returned TRUE.\n");
    }
    else
    {
        DebugOut("ISIGN32: GetGlobalOffline returned FALSE.\n");
    }
#endif
InternetSetOptionExit:
    DebugOut("ISIGN32: Exit SetGlobalOffline.\n");
    return;
}

BOOL ProcessISP(HWND hwnd, LPCTSTR lpszFile)
{

    TCHAR  szSignupURL[MAX_URL + 1];
#if !defined(WIN16)
    HKEY hKey;
    GATHEREDINFO gi;
#endif //!WIN16

    //
    // 4/30/97    jmazner    Olympus 3969
    // For security reasons, do not process the [Custom] Run= command in an .isp
    // file!
    //
 #if DEBUG
   if (GetPrivateProfileString(
        cszEntrySection,
        cszRun,
        szNull,
        pDynShare->szRunExecutable,
        SIZEOF_TCHAR_BUFFER(pDynShare->szRunExecutable),
        lpszFile) != 0)
    {
        //
        // 4/30/97    jmazner    Olympus 3969
        // For security reasons, do not process the [Custom] Run= command in an .isp
        // file!
        //
        lstrcpyn(pDynShare->szRunExecutable, TEXT("\0"), 1);
        
        ClearExitFlags(SXF_RUNEXECUTABLE | SXF_WAITEXECUTABLE);
        
        Dprintf("ISIGN32: The file %s has the [Custom] Run= command!", lpszFile);
        MessageBox( hwnd,
                    TEXT("The .isp file you're running contains the [Custom] Run= command.\n\nThis functionality has been removed."),
                    TEXT("DEBUG information msgBox -- this is NOT a bug"),
                    MB_OK );
/*****
        dwExitFlags |= (SXF_RUNEXECUTABLE | SXF_WAITEXECUTABLE);

        GetPrivateProfileString(cszEntrySection,
            cszArgument,
            szNull,
            szRunArgument,
            sizeof(szRunArgument),
            lpszFile);

        PostMessage(hwnd, WM_CLOSE, 0, 0);
        return FALSE;
******/
    }
#endif

#if !defined(WIN16)
    // Make sure the isp file exists before setting up stack.
    if (0xFFFFFFFF == GetFileAttributes(lpszFile))
    {
        DWORD dwFileErr = GetLastError();
        Dprintf("ISIGN32: ProcessISP couldn't GetAttrib for %s, error = %d",
                lpszFile, dwFileErr);
        if( ERROR_FILE_NOT_FOUND == dwFileErr )
        {
            ErrorMsg1(hwnd, IDS_INVALIDCMDLINE, lpszFile);
        }

        ErrorMsg(hwnd, IDS_BADSIGNUPFILE);
        return FALSE;
    }
#endif

    // Register file extensions if not already registered

    // Configure stack if not already configured.
    // This may required a restart. If so warn the user.
    // We may want to check to see if the user is calling
    // us again without restarting after configuring the stack.

#ifdef SETUPSTACK
 
    if (!TestControlFlags(SCF_SYSTEMCONFIGURED))
    {
        DWORD dwRet;
        BOOL  fNeedsRestart = FALSE;

        //
        // ChrisK Olympus 4756 5/25/97
        // Do not display busy animation on Win95
        //
        dwRet = lpfnInetConfigSystem(
            hwnd,
            INETCFG_INSTALLRNA |
            INETCFG_INSTALLTCP |
            INETCFG_INSTALLMODEM |
            (IsNT()?INETCFG_SHOWBUSYANIMATION:0) |
            INETCFG_REMOVEIFSHARINGBOUND,
            &fNeedsRestart);

        if (ERROR_SUCCESS == dwRet)
        {            
            SetControlFlags(SCF_SYSTEMCONFIGURED);
            
            InstallScripter();

            if (fNeedsRestart)
            {
            if (PromptRestartNow(hwnd))
            {
                SetRunOnce(lpszFile);

                // 3/13/97 jmazner Olympus #1682
                RestoreSecurityPatch();

                FGetSystemShutdownPrivledge();
                ExitWindowsEx(EWX_REBOOT, 0);
                //
                //  We will wait for the System to release all
                //  resources, 5 minutes should be more than
                //  enough for this
                //  - MKarki (4/22/97) - MKarki
                //  Fix for Bug #3109
                //
                // 7/8/97 jmazner Olympus 4212
                // No, sleeping for 5 minutes turns out not to be such a good idea.
                //Sleep (300000);
                //
            }
            return FALSE;
            }
        }
        else
        {
            ErrorMsg(hwnd, IDS_INSTALLFAILED);

            return FALSE;
        }
    }

    if (!VerifyRasServicesRunning(hwnd))
        return FALSE;
#endif

/******** 11/5/96 jmazner    Normandy #8717
    // if the original autodial settings have not been saved
    SaveAutoDial();
    dwExitFlags |= SXF_RESTOREAUTODIAL;
********/

    // kill the old connection
    KillConnection();

    // Create a new connectoid and set the autodial
    DWORD dwRC;
    dwRC = CreateConnection(lpszFile);
    if (ERROR_SUCCESS != dwRC)
    {
        //
        //    ChrisK Olympus 6083 6/10/97
        //    If the user canceled, we have already acknowledged it.
        //
        if (ERROR_CANCELLED != dwRC)
        {
            ErrorMsg(hwnd, IDS_BADSIGNUPFILE);
        }
        return FALSE;
    }

#ifndef WIN16
    //
    // Dial connectoid
    //
    if (ERROR_USERNEXT != DialConnection(lpszFile))
    {
        
        SetControlFlags(SCF_BROWSERLAUNCHED);
        
        KillBrowser();
        return FALSE;
    }

    lstrcpyn(
        pDynShare->szISPFile,
        lpszFile,
        SIZEOF_TCHAR_BUFFER(pDynShare->szISPFile));

    //
    // Tell IE that it is OK to make a connection to the Internet and do not
    // display the dialog asking if the user wants to go online.
    //
    SetGlobalOffline(FALSE);

#endif

    // Get the URL that we need for signup
    GetURL(lpszFile,
        cszSignupURL,
        szSignupURL,
        MAX_URL + 1);

#ifdef WIN32
    if (RequiresLogon(lpszFile))
    {
        SetControlFlags(SCF_LOGONREQUIRED);

        if (ERROR_CANCELLED == SignupLogon(hwnd))
        {
            InfoMsg(NULL, IDS_SIGNUPCANCELLED); 
            PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
            return FALSE;
        }
    }

    // OSR 10582
    // We need to pass the name of the ISP file to the autodialer, so that the
    // autodialer can extract the password that may be included
    ZeroMemory(&gi,sizeof(gi));
    hKey = NULL;
    lstrcpyn(gi.szISPFile,lpszFile,MAX_PATH);
    if (ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE,
        ISIGNUP_KEY,&hKey))
    {
        RegSetValueEx(hKey,TEXT("UserInfo"),0,REG_BINARY,(LPBYTE)&gi,sizeof(gi));
        RegCloseKey(hKey);
        hKey = NULL;
    }
#endif

    pDynShare->dwBrandFlags = GetBrandingFlags(lpszFile);

    return (ExecBrowser(hwnd, szSignupURL));
}



//+---------------------------------------------------------------------------
//
//    Function:    WaitForConnectionTermination
//
//    Synopsis:    Waits for the given Ras Connection to complete termination
//
//    Arguments:    hConn - Connection handle of the RAS connection being terminated
//
//    Returns:    TRUE if wait till connection termination was successful
//                FALSE otherwise
//
//    History:    6/30/96    VetriV    Created
//                8/29/96    VetriV    Added code to sleep for a second on WIN 3.1
//----------------------------------------------------------------------------
// Normandy #12547 Chrisk 12-18-96
#define MAX_TIME_FOR_TERMINATION 5
BOOL WaitForConnectionTermination(HRASCONN hConn)
{
    RASCONNSTATUS RasConnStatus;
    DWORD dwRetCode;
// Normandy #12547 Chrisk 12-18-96
#if !defined(WIN16)
    INT cnt = 0;
#endif

    //
    // Get Connection status for hConn in a loop until
    // RasGetConnectStatus returns ERROR_INVALID_HANDLE
    //
    do
    {
        //
        // Intialize RASCONNSTATUS struct
        // GetConnectStatus API will fail if dwSize is not set correctly!!
        //
        ZeroMemory(&RasConnStatus, sizeof(RASCONNSTATUS));

        RasConnStatus.dwSize = sizeof(RASCONNSTATUS);

        //
        // Sleep for a second and then get the connection status
        //
#if defined(WIN16)
        time_t StartTime = time(NULL);

        do
        {
            MSG msg;


            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            //
            // Check if we have waited atleast 1 second and less than 2 seconds
            //
        }
        while ((time(NULL) - StartTime) <= 1);
#else
        Sleep(1000L);
        // Normandy #12547 Chrisk 12-18-96
        cnt++;
#endif

        if (NULL == lpfnRasGetConnectStatus)
            return FALSE;

        dwRetCode = lpfnRasGetConnectStatus(hConn, &RasConnStatus);
        if (0 != dwRetCode)
            return FALSE;


#if defined(WIN16)
    } while (RASCS_Disconnected != RasConnStatus.rasconnstate);
#else
    // Normandy #12547 Chrisk 12-18-96
    } while ((ERROR_INVALID_HANDLE != RasConnStatus.dwError) && (cnt < MAX_TIME_FOR_TERMINATION));
#endif

    return TRUE;
}




BOOL ProcessHTML(HWND hwnd, LPCTSTR lpszFile)
{
    BOOL  fNeedsRestart = FALSE;
#if SETUPSTACK
    DWORD dwRet;
     
    if (!TestControlFlags(SCF_SYSTEMCONFIGURED))
    {
        //
        // ChrisK Olympus 4756 5/25/97
        // Do not display busy animation on Win95
        //
        dwRet = lpfnInetConfigSystem(
            hwnd,
            INETCFG_INSTALLRNA |
            INETCFG_INSTALLTCP |
            INETCFG_INSTALLMODEM |
            (IsNT()?INETCFG_SHOWBUSYANIMATION:0) |
            INETCFG_REMOVEIFSHARINGBOUND,
            &fNeedsRestart);

        if (ERROR_SUCCESS == dwRet)
        {

            SetControlFlags(SCF_SYSTEMCONFIGURED);
            
            InstallScripter();

            if (fNeedsRestart)
            {
            if (PromptRestart(hwnd))
            {
                SetRunOnce(lpszFile);

                // 3/13/97 jmazner Olympus #1682
                RestoreSecurityPatch();

                FGetSystemShutdownPrivledge();
                ExitWindowsEx(EWX_REBOOT, 0);
                //
                //  We will wait for the System to release all
                //  resources, 5 minutes should be more than
                //  enough for this
                //  - MKarki (4/22/97) - MKarki
                //  Fix for Bug #3109
                //
                // 7/8/97 jmazner Olympus 4212
                // No, sleeping for 5 minutes turns out not to be such a good idea.
                //Sleep (300000);
                //
            }
            return FALSE;
            }
        }
        else
        {
            ErrorMsg(hwnd, IDS_INSTALLFAILED);

            return FALSE;
        }
    }

    if (!VerifyRasServicesRunning(hwnd))
        return FALSE;

#endif

    return (ExecBrowser(hwnd, lpszFile));
}

#ifdef WIN32
DWORD RunExecutable(BOOL fWait)
{
    DWORD dwRet;
    SHELLEXECUTEINFO sei;
 
    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = cszOpen;
    sei.lpFile = pDynShare->szRunExecutable;
    sei.lpParameters = pDynShare->szRunArgument;
    sei.lpDirectory = NULL;
    sei.nShow = SW_SHOWNORMAL;
    sei.hInstApp = NULL;
    // Optional members
    sei.hProcess = NULL;

    if (ShellExecuteEx(&sei))
    {
    if (fWait)
    {
//          WaitForSingleObject(sei.hProcess, INFINITE);
        DWORD iWaitResult = 0;
        // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
        while((iWaitResult=MsgWaitForMultipleObjects(1, &sei.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
        {
           MSG msg ;
           // read all of the messages in this next loop
           // removing each message as we read it
           while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
           {
           // how to handle quit message?
           if (msg.message == WM_QUIT)
           {
               CloseHandle(sei.hProcess);
               return NO_ERROR;
           }
           else
               DispatchMessage(&msg);
        }
       }
    }
    CloseHandle(sei.hProcess);
    dwRet = ERROR_SUCCESS;
    }
    else
    {
    dwRet = GetLastError();
    }

    return dwRet;
}
#else

DWORD RunExecutable(BOOL fWait)
{
    DWORD dwRet;
 
    dwRet = (DWORD)ShellExecute(
        NULL,
        cszOpen,
        pDynShare->szRunExecutable,
        pDynShare->szRunArgument,
        NULL,
        SW_SHOWNORMAL);

    if (32 < dwRet)
    {
    dwRet = ERROR_SUCCESS;
    }
    else if (0 == dwRet)
    {
    dwRet = ERROR_OUTOFMEMORY;
    }

    return dwRet;
}
#endif

void SaveAutoDial(void)
{
    // if the original autodial settings have not been saved
     
    if (!TestControlFlags(SCF_AUTODIALSAVED))
    {
        // save the current autodial settings
        BOOL fEnabled;
        
        lpfnInetGetAutodial(
            &fEnabled,
            pDynShare->szAutodialConnection,
            sizeof(pDynShare->szAutodialConnection));

        if (fEnabled)
        {
            SetControlFlags(SCF_AUTODIALENABLED);
        }
        else
        {
            ClearControlFlags(SCF_AUTODIALENABLED);
        }            

#ifdef WIN32
        lpfnInetGetProxy(
            &fEnabled,
            NULL, 0,
            NULL, 0);

        if (fEnabled)
        {
            SetControlFlags(SCF_PROXYENABLED);
        }
        else
        {
            ClearControlFlags(SCF_PROXYENABLED);
        }
        // turn off proxy
        lpfnInetSetProxy(FALSE, NULL, NULL);
#endif
        SetControlFlags(SCF_AUTODIALSAVED);
        
    }
}

void RestoreAutoDial(void)
{
     
    if (TestControlFlags(SCF_AUTODIALSAVED))
    {
        // restore original autodial settings
         
        lpfnInetSetAutodial(
            TestControlFlags(SCF_AUTODIALENABLED),
            pDynShare->szAutodialConnection);
        
        
#ifdef WIN32
         lpfnInetSetProxy(TestControlFlags(SCF_PROXYENABLED), NULL, NULL);
#endif
        ClearControlFlags(SCF_AUTODIALSAVED);
    }
}

DWORD CreateConnection(LPCTSTR lpszFile)
{
    DWORD dwRet;
    LPICONNECTION pConn;

    // Allocate a buffer for connection object
    //
    pConn = (LPICONNECTION)LocalAlloc(LPTR, sizeof(ICONNECTION));
    if (NULL == pConn)
    {
    return ERROR_OUTOFMEMORY;
    };

    dwRet = ImportConnection(lpszFile, pConn);
    if (ERROR_SUCCESS == dwRet)
    {
        
#ifdef WIN32
        if ((0 == *pConn->RasEntry.szAutodialDll) ||
            (0 == *pConn->RasEntry.szAutodialFunc))
        {
            lstrcpy(pConn->RasEntry.szAutodialDll, TEXT("ICWDIAL.dll"));
            lstrcpy(pConn->RasEntry.szAutodialFunc, TEXT("AutoDialHandler"));

            // save the password in case it doesn't get cached
            lstrcpyn(
                pDynShare->szPassword,
                pConn->szPassword,
                SIZEOF_TCHAR_BUFFER(pDynShare->szPassword));

        }
#endif

        dwRet = lpfnInetConfigClient(
            NULL,
            NULL,
            pConn->szEntryName,
            &pConn->RasEntry,
            pConn->szUserName,
            pConn->szPassword,
            NULL,
            NULL,
            INETCFG_SETASAUTODIAL |
            INETCFG_OVERWRITEENTRY |
            INETCFG_TEMPPHONEBOOKENTRY,
            NULL);

#if !defined(WIN16)
        LclSetEntryScriptPatch(pConn->RasEntry.szScript,pConn->szEntryName);
#endif

        if (ERROR_SUCCESS == dwRet)
        {
            lstrcpyn(
                pDynShare->szSignupConnection,
                pConn->szEntryName,
                RAS_MaxEntryName + 1);
            
        }
    }

    LocalFree(pConn);

    return dwRet;
}

DWORD DeleteConnection(void)
{
     
    if (*(pDynShare->szSignupConnection))
    {
        // delete the signup entry
        lpfnRasDeleteEntry(NULL, pDynShare->szSignupConnection);
        pDynShare->szSignupConnection[0] = (TCHAR)'\0';
    }

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//    Function:    KillThisConnection
//
//    Synopsis:    Disconnects the connectoid named in lpzConnectoid and waits
//                until the connection is completely torn down.  Then the
//                connectoid is deleted.
//
//    Arguments:    lpzConnectoid - name of connection to disconnect
//
//    Returns:    (return) - win32 error code
//
//    History:    4/27/97    Chrisk    Created
//-----------------------------------------------------------------------------
DWORD KillThisConnection(LPTSTR lpzConnectoid)
{
    LPRASCONN pRasConn=NULL;
    DWORD dwSize = sizeof(RASCONN);
    DWORD dwSizeRasConn = dwSize;
    DWORD dwRet = ERROR_SUCCESS;

    if ('\0' == *lpzConnectoid)
        return ERROR_NO_CONNECTION;

    // OK were ready for Rna now
    if (!LoadRnaFunctions(pDynShare->hwndMain))
        return ERROR_NO_CONNECTION;

    if ((pRasConn = (LPRASCONN)LocalAlloc(LPTR, (int)dwSize)) == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    pRasConn->dwSize = dwSize;
    dwRet = lpfnRasEnumConnections(pRasConn, &dwSize, &dwSizeRasConn);
    if (ERROR_SUCCESS != dwRet)
    {
        dwRet = ERROR_NO_CONNECTION;
        goto KillThisConnectionExit;
    }

    // check entry name to see if
    // its ours
#ifndef WIN32
    //
    // Workaround for WIN16 RAS Bug - it sometimes truncates
    // the name of the connectoid
    //
    if (!strncmp(pRasConn->szEntryName, lpzConnectoid,
                    lstrlen(pRasConn->szEntryName)))
#else
    if (!lstrcmp(pRasConn->szEntryName, lpzConnectoid))
#endif
    {
        // Normandy 12642 ChrisK 12-18-9
        // We don't want the user to reconnect here.
#if !defined(WIN16)

        SetControlFlags(SCF_HANGUPEXPECTED);

#endif
        // then hangup
        lpfnRasHangUp(pRasConn->hrasconn);
        WaitForConnectionTermination(pRasConn->hrasconn);
    }

    // delete the signup entry
    lpfnRasDeleteEntry(NULL, lpzConnectoid);

KillThisConnectionExit:
    if (pRasConn)
        LocalFree(pRasConn);

    return dwRet;
}

//+----------------------------------------------------------------------------
//    Function:    KillConnection
//
//    Synopsis:    Calls KillThisConnection and passes in the name of the signup
//                connection that is saved in szSignupConnection
//
//    Arguments:    none
//
//    Returns:    (return) - win32 error code
//
//    History:    4/27/97    Chrisk    modified to call KillThisConnection
//-----------------------------------------------------------------------------
DWORD KillConnection(void)
{
    DWORD dwRet;
     
    dwRet = KillThisConnection(pDynShare->szSignupConnection);

#if defined(WIN16)
    ShutDownIEDial(pDynShare->hwndMain);
#endif // WIN16

    pDynShare->szSignupConnection[0] = (TCHAR)'\0';
    UnloadRnaFunctions();

    return dwRet;
}

BOOL ExecBrowser(HWND hwnd, LPCTSTR lpszURL)
{

    HRESULT hresult;
    TCHAR szFullURL[MAX_URL + 1];


    if (!FixUpURL(lpszURL, szFullURL, MAX_URL + 1))
    {
        //
        // ChrisK Olympus 4002 5/26/97
        // If the URL is empty, this error message doesn't make
        // a lot of sense.  So use a different message.
        //
        if (lstrlen(lpszURL))
        {
            ErrorMsg1(hwnd, IDS_INVALIDURL, lpszURL);
        }
        else
        {
            ErrorMsg(hwnd, IDS_INVALIDNOURL);
        }
        return FALSE;
    }
 
    if (TestControlFlags(SCF_BROWSERLAUNCHED))
    {
#ifdef WIN32
        // No assert macro defined for isign32????
        //Assert(g_iwbapp);
        if( !g_iwbapp )
        {
            DebugOut("ISIGNUP: fatal err, fBrowserLaunched disagrees with g_iwbapp\n");

            return( FALSE );
        }

        // TODO find out what the result codes should be!
        hresult = IENavigate( szFullURL );

        if( FAILED(hresult) )
        {
            DebugOut("ISIGNUP: second Navigate _failed_, hresult was failure\n");
            return FALSE;
        }
        else
        {
            DebugOut("ISIGNUP: second Navigate success!, hresult was success\n");
        }

        //g_iwbapp->put_Visible( TRUE );



#else

        DDEInit(ghInstance);
        OpenURL(szFullURL);
        DDEClose();
#endif

    }
    else
    {
        TCHAR szTemp[MAX_URL + sizeof(cszKioskMode)/sizeof(TCHAR)];
        HWND hwndTemp;
        HANDLE hBrowser;
#ifndef WIN32
        time_t start;
#endif
 
        if (NULL != pDynShare->hwndLaunch)
        {
            ShowWindow(pDynShare->hwndLaunch, SW_SHOW);
            UpdateWindow(pDynShare->hwndLaunch);
        }

// for OLE Autmoation we only want to pass in the URL (no "-k") and then call FullScreen,
// so only -k for win16
#ifndef WIN32

        lstrcpy(szTemp, cszKioskMode);
        lstrcat(szTemp, szFullURL);

        // no point in doing this for IE4, which may have lots of windows already open
        hwndTemp = FindBrowser();

        if (NULL != hwndTemp)
        {
            PostMessage(hwndTemp, WM_CLOSE, 0, 0L);
        }
#endif


#ifdef WIN32
        // 8/19/96 jmazner Normandy #4571
        // Check to ensure that the right version IE is installed before trying to exec it
/******** Normandy #10293, do this verification before going through the whole
          dialing process

        if ( !IEInstalled() )
        {
            ErrorMsg( hwnd, IDS_MISSINGIE );
            return(FALSE);
        }

        DWORD dwVerMS, dwVerLS;

        if( !GetAppVersion( &dwVerMS, &dwVerLS,IE_PATHKEY ) )
            return (FALSE);

        if( !( (dwVerMS >= IE_MINIMUM_VERSIONMS) && (dwVerLS >= IE_MINIMUM_VERSIONLS) ) )
        {
            Dprintf("ISIGN32: user has IE version %d.%d.%d.%d; min ver is %d.%d.%d.%d\n",
                HIWORD(dwVerMS), LOWORD(dwVerMS), HIWORD(dwVerLS), LOWORD(dwVerLS),
                HIWORD(IE_MINIMUM_VERSIONMS),LOWORD(IE_MINIMUM_VERSIONMS),
                HIWORD(IE_MINIMUM_VERSIONLS),LOWORD(IE_MINIMUM_VERSIONLS));
            ErrorMsg1( hwnd, IDS_IELOWVERSION, IE_MINIMUM_VERSION_HUMAN_READABLE );
            return(FALSE);
        }
***********/


        if (FTurnOffBrowserDefaultChecking())
        {
            SetExitFlags(SXF_RESTOREDEFCHECK);
        }
/*
        hBrowser = ShellExecute(
            NULL,
            cszOpen,
            cszBrowser,
            szTemp,
            NULL,
            SW_SHOWNORMAL);
*/

        // 1/20/97 jmazner Normandy #13454
        // need make sure the ICW completed reg key is set before trying
        // to browse to an html page with IE
        DWORD dwICWCompleted = 0;

        GetICWCompleted(&dwICWCompleted);
        if( 1 != dwICWCompleted )
        {

            SetControlFlags(SCF_ICWCOMPLETEDKEYRESETED);
            
            SetICWCompleted( 1 );
        }

        hresult = InitOle();

        if( FAILED(hresult) )
        {
            DebugOut("ISIGNUP: InitOle failed\n");
            ErrorMsg(hwnd, IDS_LAUNCHFAILED);
            return FALSE;
        }

        SetControlFlags(SCF_BROWSERLAUNCHED);

        //
        // we want to hook up the event sink before doing that first navigate!
        //
/******************* SINK code starts here ***********/

        if (!g_iwbapp)
            return (NULL);

        g_pMySink = new CDExplorerEvents;

        //
        // 5/10/97 ChrisK Windows NT Bug 82032
        //
        g_pMySink->AddRef();

        if ( !g_pMySink )
        {
            DebugOut("Unable to allocate g_pMySink\r\n");
            return FALSE;
        }


        g_pCP = GetConnectionPoint();

        if ( !g_pCP )
        {
            DebugOut("Unable to GetConnectionPoint\r\n");
            return FALSE;
        }

        hresult = g_pCP->Advise(g_pMySink, &(g_pMySink->m_dwCookie));

        if ( FAILED(hresult) )
        {
            DebugOut("Unable to Advise for IConnectionPointContainter:IWebBrowserApp\r\n");
            return FALSE;
        }


/***************  SINK code ends here         *****************/

        // TODO figure out result codes
        hresult = IENavigate( szFullURL );

        if( FAILED(hresult) )
        {
            DebugOut("ISIGNUP: first Navigate _failed_, hresult was failure\n");
            ErrorMsg(hwnd, IDS_LAUNCHFAILED);
            return FALSE;
        }
        else
        {
            DebugOut("ISIGNUP: first Navigate success!, hresult was success\n");
        }

        g_iwbapp->put_FullScreen( TRUE );
        g_iwbapp->put_Visible( TRUE );

        // IE 4 for win95 isn't bringing us up as the foreground window!
        g_iwbapp->get_HWND( (LONG_PTR *)&(pDynShare->hwndBrowser) );
        SetForegroundWindow( pDynShare->hwndBrowser );

#else
        start = time(NULL);


        if (NULL != hwndTemp)
        {
            MSG   msg;

            SetTimer(hwnd, 0, 1000, NULL);
            DebugOut("ISIGNUP: Timer message loop\n");

            while (GetMessage (&msg, NULL, 0, 0))
            {
                if (WM_TIMER == msg.message)
                {
                    DebugOut("ISIGNUP: Got timer message\n");
                    if (NULL == FindBrowser())
                    {
                        DebugOut("ISIGNUP: Browser is gone\n");
                        break;
                    }
                }
                TranslateMessage (&msg) ;
                DispatchMessage  (&msg) ;
            }

            KillTimer(hwnd, 0);
        }


        while (((hBrowser = ShellExecute(
            NULL,
            cszOpen,
            cszBrowser,
            szTemp,
            NULL,
            SW_SHOWNORMAL)) == 16) && ((time(NULL) - start) < 180))
        {
            DebugOut("ISIGNUP: Yielding\n");
            Yield();
        }
#endif

        DebugOut("ISIGNUP: I am back!!\n");         
        if (NULL != pDynShare->hwndLaunch)
        {
            ShowWindow(pDynShare->hwndLaunch, SW_HIDE);
        }

#ifdef WIN16
        if (hBrowser <= (HANDLE)32)
        {
            ErrorMsg(hwnd, IDS_LAUNCHFAILED);

            return FALSE;
        }
#endif

        SetControlFlags(SCF_BROWSERLAUNCHED);
        
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function:    IEInstalled
//
//    Synopsis:    Tests whether a version of Internet Explorer is installed via registry keys
//
//    Arguments:    None
//
//    Returns:    TRUE - Found the IE executable
//                FALSE - No IE executable found
//
//    History:    jmazner        Created        8/19/96    (as fix for Normandy #4571)
//
//-----------------------------------------------------------------------------

#if !defined(WIN16)

BOOL IEInstalled(void)
{
    HRESULT hr;
    HKEY hKey = 0;
    HANDLE hFindResult;
    TCHAR szIELocalPath[MAX_PATH + 1] = TEXT("");
    DWORD dwPathSize;
    WIN32_FIND_DATA foundData;

    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, IE_PATHKEY,0, KEY_READ, &hKey);
    if (hr != ERROR_SUCCESS) return( FALSE );

    dwPathSize = sizeof (szIELocalPath);
    hr = RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szIELocalPath, &dwPathSize);
    RegCloseKey( hKey );
    if (hr != ERROR_SUCCESS) return( FALSE );

    hFindResult = FindFirstFile( szIELocalPath, &foundData );
    FindClose( hFindResult );
    if (INVALID_HANDLE_VALUE == hFindResult) return( FALSE );

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//    Function:    GetAppVersion
//
//    Synopsis:    Gets the major and minor version # of the installed copy of Internet Explorer
//
//    Arguments:    pdwVerNumMS - pointer to a DWORD;
//                  On succesful return, the top 16 bits will contain the major version number,
//                  and the lower 16 bits will contain the minor version number
//                  (this is the data in VS_FIXEDFILEINFO.dwProductVersionMS)
//                pdwVerNumLS - pointer to a DWORD;
//                  On succesful return, the top 16 bits will contain the release number,
//                  and the lower 16 bits will contain the build number
//                  (this is the data in VS_FIXEDFILEINFO.dwProductVersionLS)
//
//    Returns:    TRUE - Success.  *pdwVerNumMS and LS contains installed IE version number
//                FALSE - Failure. *pdVerNumMS == *pdVerNumLS == 0
//
//    History:    jmazner        Created        8/19/96    (as fix for Normandy #4571)
//                jmazner        updated to deal with release.build as well 10/11/96
//
//-----------------------------------------------------------------------------
BOOL GetAppVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS, LPTSTR lpszApp)
{
    HRESULT hr;
    HKEY hKey = 0;
    LPVOID lpVerInfoBlock;
    VS_FIXEDFILEINFO *lpTheVerInfo;
    UINT uTheVerInfoSize;
    DWORD dwVerInfoBlockSize, dwUnused, dwPathSize;
    TCHAR szIELocalPath[MAX_PATH + 1] = TEXT("");


    *pdwVerNumMS = 0;
    *pdwVerNumLS = 0;

    // get path to the IE executable
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszApp,0, KEY_READ, &hKey);
    if (hr != ERROR_SUCCESS) return( FALSE );

    dwPathSize = sizeof (szIELocalPath);
    hr = RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szIELocalPath, &dwPathSize);
    RegCloseKey( hKey );
    if (hr != ERROR_SUCCESS) return( FALSE );

    // now go through the convoluted process of digging up the version info
    dwVerInfoBlockSize = GetFileVersionInfoSize( szIELocalPath, &dwUnused );
    if ( 0 == dwVerInfoBlockSize ) return( FALSE );

    lpVerInfoBlock = GlobalAlloc( GPTR, dwVerInfoBlockSize );
    if( NULL == lpVerInfoBlock ) return( FALSE );

    if( !GetFileVersionInfo( szIELocalPath, NULL, dwVerInfoBlockSize, lpVerInfoBlock ) )
        return( FALSE );

    if( !VerQueryValue(lpVerInfoBlock, TEXT("\\"), (void **)&lpTheVerInfo, &uTheVerInfoSize) )
        return( FALSE );

    *pdwVerNumMS = lpTheVerInfo->dwProductVersionMS;
    *pdwVerNumLS = lpTheVerInfo->dwProductVersionLS;


    GlobalFree( lpVerInfoBlock );

    return( TRUE );
}
#endif // !defined(WIN16)


HWND FindBrowser(void)
{
    HWND hwnd;

    if ((hwnd = FindWindow(szBrowserClass1, NULL)) == NULL)
    {
        if ((hwnd = FindWindow(szBrowserClass2, NULL)) == NULL)
        {
            if( (hwnd = FindWindow(szBrowserClass3, NULL)) == NULL )
            {
                hwnd = FindWindow(szBrowserClassIE4, NULL);
            }
        }
    }

    return hwnd;
}

void KillBrowser(void)
{
#ifdef WIN32

    if( TestControlFlags(SCF_ICWCOMPLETEDKEYRESETED) )
    {
        SetICWCompleted( 0 );
    }

    if( g_iwbapp )
    {
        g_iwbapp->Quit();
    }

    KillOle();

    return;

#else
    // if we launched the browser
 
    if (TestControlFlags(SCF_BROWSERLAUNCHED))
    {
        HWND hwndBrowser;

        // find it and close it
        hwndBrowser = FindBrowser();

        if (NULL != hwndBrowser)
        {
            PostMessage(hwndBrowser, WM_CLOSE, 0, 0L);
        }
        
        SetControlFlags(SCF_BROWSERLAUNCHED);
    }
    
#endif

}

DWORD ImportBrandingInfo(LPCTSTR lpszFile, LPCTSTR lpszConnectoidName)
{
    TCHAR szPath[_MAX_PATH + 1];

    GetWindowsDirectory(szPath, _MAX_PATH + 1);

    // Load the branding library.
    // Note: if we cannot load the library we just fail quietly and assume
    // we cannot brand
    if (LoadBrandingFunctions())
    {
#ifdef WIN32
        
#ifdef UNICODE

        CHAR szEntry[RAS_MaxEntryName];
        CHAR szFile[_MAX_PATH + 1];
        CHAR szAsiPath[_MAX_PATH + 1];
 
        wcstombs(szEntry, lpszConnectoidName, RAS_MaxEntryName);
        wcstombs(szFile, lpszFile, _MAX_PATH + 1);
        wcstombs(szAsiPath, szPath, _MAX_PATH + 1);

        lpfnBrandICW(szFile, szAsiPath, pDynShare->dwBrandFlags, szEntry);
        
#else
 
        lpfnBrandICW(lpszFile, szPath, pDynShare->dwBrandFlags, lpszConnectoidName);

#endif

#else

        lpfnBrandMe(lpszFile, szPath);

#endif

      UnloadBrandingFunctions();
    }

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//    Function:    CallSBSConfig
//
//    Synopsis:    Call into the SBSCFG dll's Configure function to allow SBS to
//                process the .ins file as needed
//
//    Arguements: hwnd -- hwnd of parent, in case sbs wants to put up messages
//                lpszINSFile -- full path to the .ins file
//
//    Returns:    windows error code that sbscfg returns.
//
//    History:    2/19/97    jmazner    Created for Olympus #1106
//
//-----------------------------------------------------------------------------
#if defined(WIN32)
DWORD CallSBSConfig(HWND hwnd, LPCTSTR lpszINSFile)
{
    HINSTANCE hSBSDLL = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    TCHAR lpszConnectoidName[RAS_MaxEntryName] = TEXT("nogood\0");

    //
    // Get name of connectoid we created by looking in autodial
    // We need to pass this name into SBSCFG
    // 5/14/97    jmazner    Windosw NT Bugs #87209
    //
    BOOL fEnabled = FALSE;

    if( NULL == lpfnInetGetAutodial )
    {
        Dprintf("lpfnInetGetAutodial is NULL!!!!");
        return ERROR_INVALID_FUNCTION;
    }

    dwRet = lpfnInetGetAutodial(&fEnabled,lpszConnectoidName,RAS_MaxEntryName);

    Dprintf("ISIGN32: Calling LoadLibrary on %s\n", cszSBSCFG_DLL);
    hSBSDLL = LoadLibrary(cszSBSCFG_DLL);

    // Load DLL and entry point
    if (NULL != hSBSDLL)
    {
        Dprintf("ISIGN32: Calling GetProcAddress on %s\n", cszSBSCFG_CONFIGURE);
        lpfnConfigure = (SBSCONFIGURE)GetProcAddress(hSBSDLL,cszSBSCFG_CONFIGURE);
    }
    else
    {
        // 4/2/97    ChrisK    Olympus 2759
        // If the DLL can't be loaded, pick a specific error message to return.
        dwRet = ERROR_DLL_NOT_FOUND;
        goto CallSBSConfigExit;
    }

    // Call function
    if( hSBSDLL && lpfnConfigure )
    {
        Dprintf("ISIGN32: Calling the Configure entry point: %s, %s\n", lpszINSFile, lpszConnectoidName);
        dwRet = lpfnConfigure(hwnd, (TCHAR *)lpszINSFile, lpszConnectoidName);
    }
    else
    {
        Dprintf("ISIGN32: Unable to call the Configure entry point\n");
        dwRet = GetLastError();
    }

CallSBSConfigExit:
    if( hSBSDLL )
        FreeLibrary(hSBSDLL);
    if( lpfnConfigure )
        lpfnConfigure = NULL;

    Dprintf("ISIGN32: CallSBSConfig exiting with error code %d \n", dwRet);
    return dwRet;
}
#endif


#if defined(WIN16)
#define FILE_BUFFER_SIZE 8092
#else
#define FILE_BUFFER_SIZE 65534
#endif

#ifndef FILE_BEGIN
#define FILE_BEGIN  0
#endif


DWORD MassageFile(LPCTSTR lpszFile)
{
    LPBYTE  lpBufferIn;
    LPBYTE  lpBufferOut;
    HFILE   hfile;
    DWORD   dwRet = ERROR_SUCCESS;

#ifdef WIN32
    if (!SetFileAttributes(lpszFile, FILE_ATTRIBUTE_NORMAL))
    {
        return GetLastError();
    }
#endif

    lpBufferIn = (LPBYTE) LocalAlloc(LPTR, 2 * FILE_BUFFER_SIZE);
    if (NULL == lpBufferIn)
    {
    return ERROR_OUTOFMEMORY;
    }
    lpBufferOut = lpBufferIn + FILE_BUFFER_SIZE;

#ifdef UNICODE
    CHAR szTmp[MAX_PATH+1];
    wcstombs(szTmp, lpszFile, MAX_PATH+1);
    hfile = _lopen(szTmp, OF_READWRITE);
#else
    hfile = _lopen(lpszFile, OF_READWRITE);
#endif
    if (HFILE_ERROR != hfile)
    {
    BOOL    fChanged = FALSE;
    UINT    uBytesOut = 0;
    UINT    uBytesIn = _lread(hfile, lpBufferIn, (UINT)(FILE_BUFFER_SIZE - 1));

    // Note:  we asume, in our use of lpCharIn, that the file is always less than
    // FILE_BUFFER_SIZE
    if (HFILE_ERROR != uBytesIn)
    {
        LPBYTE  lpCharIn = lpBufferIn;
        LPBYTE  lpCharOut = lpBufferOut;

        while ((*lpCharIn) && (FILE_BUFFER_SIZE - 2 > uBytesOut))
        {
          *lpCharOut++ = *lpCharIn;
          uBytesOut++;
          if ((0x0d == *lpCharIn) && (0x0a != *(lpCharIn + 1)))
          {
        fChanged = TRUE;

        *lpCharOut++ = 0x0a;
        uBytesOut++;
          }
          lpCharIn++;
        }

        if (fChanged)
        {
        if (HFILE_ERROR != _llseek(hfile, 0, FILE_BEGIN))
        {
            if (HFILE_ERROR ==_lwrite(hfile, (LPCSTR)lpBufferOut, uBytesOut))
            {
#ifdef WIN32
            dwRet = GetLastError();
#else
            dwRet = ERROR_CANTWRITE;
#endif
            }
        }
        else
        {
#ifdef WIN32
            dwRet = GetLastError();
#else
            dwRet = ERROR_CANTWRITE;
#endif
        }
        }
    }
    else
    {
#ifdef WIN32
        dwRet = GetLastError();
#else
        dwRet = ERROR_CANTREAD;
#endif
    }
    _lclose(hfile);
    }
    else
    {
#ifdef WIN32
    dwRet = GetLastError();
#else
    dwRet = ERROR_CANTOPEN;
#endif
    }

    LocalFree(lpBufferIn);

    return dwRet;
}

#ifndef WIN32
// This function only handle formats like
//      drive:\file, drive:\dir1\file, drive:\dir1\dir2\file, etc
//      file, dir1\file, dir1\dir2\file, etc.
// It does not currently handle
//      drive:file, drive:dir\file, etc.
//      \file, \dir\file, etc.
//      ..\file, ..\dir\file, etc.

DWORD MakeFullPathName(
    LPCTSTR lpDir,
    LPCTSTR lpFileName,
    DWORD nBufferLength,
    LPTSTR lpBuffer)
{
    DWORD dwSize;

    // check for unsupported format
    if ('.' == *lpFileName)
    {
    return 0;
    }

    // check for full path name
    // assuming full path if ":" is in path
    if (strchr(lpFileName, ':') != NULL)
    {
    dwSize = lstrlen(lpFileName);
    if (dwSize > nBufferLength)
    {
        return dwSize;
    }
    lstrcpy(lpBuffer, lpFileName);
    }
    else
    {
    lstrcpy(lpBuffer, lpDir);

    // make sure the directory ends in back slash
    if (lpBuffer[lstrlen(lpBuffer) - 1] != '\\')
    {
        lstrcat(lpBuffer, TEXT("\\"));
    }

    dwSize = lstrlen(lpBuffer) + lstrlen(lpFileName);
    if (dwSize > nBufferLength)
    {
        return dwSize;
    }
    lstrcat(lpBuffer, lpFileName);
    }

    return dwSize;
}


// This function only handle formats like
//      drive:\file, drive:\dir1\file, drive:\dir1\dir2\file, etc
//      file, dir1\file, dir1\dir2\file, etc.
// It does not currently handle
//      drive:file, drive:dir\file, etc.
//      \file, \dir\file, etc.
//      ..\file, ..\dir\file, etc.

DWORD GetFullPathName(
    LPCTSTR lpFileName,
    DWORD nBufferLength,
    LPTSTR lpBuffer,
    LPTSTR FAR *lpFilePart)
{
    DWORD dwSize;
    TCHAR szDir[_MAX_PATH + 1];

    if (_getcwd(szDir, _MAX_PATH + 1) == NULL)
    {
    return 0;
    }

    dwSize = MakeFullPathName(
        szDir,
        lpFileName,
        nBufferLength,
        lpBuffer);

    if ((0 != dwSize) && (NULL != lpFilePart))
    {
    // find last back slash
    *lpFilePart = strrchr(lpBuffer, '\\');
    if (NULL == *lpFilePart)
    {
        // must have been in the unsupported format of drive:file
        return 0;
    }

    // point to the filename
    *lpFilePart += 1;
    }

    return dwSize;
}

BOOL SetCurrentDirectory(
    LPCTSTR  lpPathName)
{
    TCHAR szTemp[_MAX_PATH];
    TCHAR FAR* lpChar;

    lstrcpy(szTemp, lpPathName);

    lpChar = szTemp + lstrlen(szTemp) - 1;

    if (*lpChar == '\\' && *(lpChar - 1) != ':')
    {
    *lpChar = '\0';
    }

    return (0 == _chdir(szTemp));
}
#endif

#ifdef WIN16
extern "C" BOOL CALLBACK __export LaunchDlgProc(
#else
INT_PTR CALLBACK LaunchDlgProc(
#endif
    HWND  hDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam);

HWND LaunchInit(HWND hwndParent)
{
    HWND        hwnd;

    hwnd = CreateDialog (ghInstance, TEXT("Launch"), NULL, LaunchDlgProc);
    if (NULL != hwnd)
    {
    CenterWindow(hwnd, NULL);
    }

    return hwnd;
}

#ifdef WIN16
extern "C" BOOL CALLBACK __export LaunchDlgProc(
#else
INT_PTR CALLBACK LaunchDlgProc(
#endif
    HWND  hDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    return FALSE;
}

//+----------------------------------------------------------------------------
//    Function:    ReleaseConnectionStructures
//
//    Synopsis:    Free memory allocated for dialing and error dialogs
//
//    Arguments:    pDDD - pointer to dialing dialog data
//                pEDD - pointer to error dialog data
//
//    Returns:    HRESULT - ERROR_SUCCESS indicates success
//
//    History:
//            7/23/96        ChrisK        Created
//
//-----------------------------------------------------------------------------
HRESULT ReleaseConnectionStructures(LPDIALDLGDATA pDDD, LPERRORDLGDATA pEDD)
{
    DebugOut("ISIGN32:ReleaseConnectionStructures()\r\n");
    if (pDDD->pszMessage)
        LocalFree(pDDD->pszMessage);

    if (pDDD->pszDunFile)
        LocalFree(pDDD->pszDunFile);

    if (pDDD->pszRasEntryName)
        LocalFree(pDDD->pszRasEntryName);

    if (pEDD->pszRasEntryName)
        LocalFree(pEDD->pszRasEntryName);

    if (pEDD->pszMessage)
        LocalFree(pEDD->pszMessage);

    ZeroMemory(pDDD,sizeof(DIALDLGDATA));
    ZeroMemory(pEDD,sizeof(ERRORDLGDATA));

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//    Function:    FillConnectionStructures
//
//    Synopsis:    Fills in structures for dialing and error dialogs
//
//    Arguments:    lpszFile - ISP file name
//                pDDD - pointer to dialing dialog data
//                pEDD - pointer to error dialog data
//
//    Returns:    HRESULT - ERROR_SUCCESS indicates success
//
//    History:
//            7/23/96        ChrisK        Created
//
//-----------------------------------------------------------------------------
static HRESULT FillConnectionStructures(LPCTSTR lpszFile,LPDIALDLGDATA pDDD, LPERRORDLGDATA pEDD)
{
    HRESULT hr = ERROR_SUCCESS;

    DebugOut("ISIGN32:FillConnectionStructures()\r\n");
    //
    // Initialize DDD structure
    //

    ZeroMemory(pDDD,sizeof(DIALDLGDATA));
    pDDD->dwSize = sizeof(DIALDLGDATA);
    pDDD->hInst = ghInstance;
    pDDD->pfnStatusCallback = StatusMessageCallback;

    //
    // Set DUN file, in this case the ISP file contains the contents of a DUN file
    //

    pDDD->pszDunFile = (LPTSTR)LocalAlloc(LPTR,(lstrlen(lpszFile)+1)* sizeof(TCHAR));
    if (0 == pDDD->pszDunFile)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto FillConnectionStructuresExit;
    }
    lstrcpy(pDDD->pszDunFile,lpszFile);

    //
    // Load message string
    //

    pDDD->pszMessage = (LPTSTR)LocalAlloc(LPTR,1024* sizeof(TCHAR));
    if (0 == pDDD->pszMessage)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto FillConnectionStructuresExit;
    }

    if (0 == LoadString(ghInstance,IDS_ISP_DIAL_MESSAGE,
        pDDD->pszMessage,1024))
    {
        hr = GetLastError();
        goto FillConnectionStructuresExit;
    }

    //
    // Get Connectoid name
    //

    pDDD->pszRasEntryName = (LPTSTR)LocalAlloc(LPTR, (RAS_MaxEntryName + 1)*sizeof(TCHAR));
    if (0 == pDDD->pszRasEntryName)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto FillConnectionStructuresExit;
    }
    if( 0 == GetPrivateProfileString(cszEntrySection,cszEntryName,szNull,
        pDDD->pszRasEntryName,RAS_MaxEntryName,lpszFile))
    {
        hr = ERROR_INVALID_PARAMETER;
        goto FillConnectionStructuresExit;
    }

    //
    // Hook in reconnect mechanism
    //
#if !defined(WIN16)
    pDDD->pfnRasDialFunc1 = RasDial1Callback;
#endif

    //
    // Initialize EDD structure
    //
    ZeroMemory(pEDD,sizeof(ERRORDLGDATA));
    pEDD->dwSize = sizeof(ERRORDLGDATA);

    //
    // Copy common fields to Error dialog data
    //
    pEDD->hInst = pDDD->hInst;
    pEDD->pszRasEntryName = (LPTSTR)LocalAlloc(LPTR,(lstrlen(pDDD->pszRasEntryName)+1)*sizeof(TCHAR));
    if (NULL == pEDD->pszRasEntryName)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto FillConnectionStructuresExit;
    }
    lstrcpy(pEDD->pszRasEntryName,pDDD->pszRasEntryName);

    //
    // Allocate buffer for error messages
    //
    pEDD->pszMessage = (LPTSTR)LocalAlloc(LPTR,MAX_ERROR_MESSAGE*sizeof(TCHAR));
    if (NULL == pEDD->pszMessage)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto FillConnectionStructuresExit;
    }

FillConnectionStructuresExit:
    return hr;
}

//+----------------------------------------------------------------------------
//    Function    FShouldRetry
//
//    Synopsis    Given a RAS error should the dialer automatically retry
//
//    Arguments    dwErr - RAS error value
//
//    Returns        TRUE - the dialer should automatically retry
//
//    Histroy        10/16/96    ChrisK    Ported from icwconn1
//
//-----------------------------------------------------------------------------
static BOOL FShouldRetry(DWORD dwErr)
{
    BOOL bRC;

    if (dwErr == ERROR_LINE_BUSY ||
        dwErr == ERROR_VOICE_ANSWER ||
        dwErr == ERROR_NO_ANSWER ||
        dwErr == ERROR_NO_CARRIER ||
        dwErr == ERROR_AUTHENTICATION_FAILURE ||
        dwErr == ERROR_PPP_TIMEOUT ||
        dwErr == ERROR_REMOTE_DISCONNECTION ||
        dwErr == ERROR_AUTH_INTERNAL ||
        dwErr == ERROR_PROTOCOL_NOT_CONFIGURED ||
        dwErr == ERROR_PPP_NO_PROTOCOLS_CONFIGURED)
    {
        bRC = TRUE;
    } else {
        bRC = FALSE;
    }

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    RepairDeviceInfo
//
//    Synopsis:    In some win95 configurations, RasSetEntryProperties will create
//                a connectoid with invalid information about the modem.  This
//                function attempts to correct the problem by reading and
//                rewriting the connectoid.
//
//    Arguments:    lpszEntry - name of connectoid
//
//    Returns:    none
//
//    History:    ChrisK 7/25/97    Created
//
//-----------------------------------------------------------------------------
#if !defined(WIN16)
BOOL RepairDeviceInfo(LPTSTR lpszEntry)
{
    DWORD dwEntrySize = 0;
    DWORD dwDeviceSize = 0;
    LPRASENTRY lpRasEntry = NULL;
    LPBYTE    lpbDevice = NULL;
    OSVERSIONINFO osver;
    TCHAR szTemp[1024];
    BOOL bRC = FALSE;
    RASDIALPARAMS rasdialp;
    BOOL bpassword = FALSE;

    //
    // Validate parameters
    //
    if (NULL == lpszEntry)
    {
        DebugOut("ISIGN32: RepairDevice invalid parameter.\n");
        goto RepairDeviceInfoExit;
    }

    //
    // This fix only applies to golden win95 build 950
    //
    osver.dwOSVersionInfoSize = sizeof(osver);
    GetVersionEx(&osver);
    if (VER_PLATFORM_WIN32_WINDOWS != osver.dwPlatformId ||
        4 != osver.dwMajorVersion ||
        0 != osver.dwMinorVersion ||
        950 != LOWORD(osver.dwBuildNumber))
    {
        DebugOut("ISIGN32: RepairDevice wrong platform.\n");
        wsprintf(szTemp,TEXT("ISIGN32: %d.%d.%d.\n"),
            osver.dwMajorVersion,
            osver.dwMinorVersion,
            LOWORD(osver.dwBuildNumber));
        DebugOut(szTemp);
        goto RepairDeviceInfoExit;
    }

    //
    // Get the RAS Entry
    //
    lpfnRasGetEntryProperties(NULL,
                                lpszEntry,
                                NULL,
                                &dwEntrySize,
                                NULL,
                                &dwDeviceSize);

    lpRasEntry = (LPRASENTRY)LocalAlloc(LPTR, dwEntrySize);
    lpbDevice = (LPBYTE)LocalAlloc(LPTR,dwDeviceSize);

    if (NULL == lpRasEntry || NULL == lpbDevice)
    {
        DebugOut("ISIGN32: RepairDevice Out of memory.\n");
        goto RepairDeviceInfoExit;
    }

    if (sizeof(RASENTRY) != dwEntrySize)
    {
        DebugOut("ISIGN32: RepairDevice Entry size is not equal to sizeof(RASENTRY).\n");
    }

    lpRasEntry->dwSize = sizeof(RASENTRY);

    if (ERROR_SUCCESS != lpfnRasGetEntryProperties(NULL,
                                                    lpszEntry,
                                                    (LPBYTE)lpRasEntry,
                                                    &dwEntrySize,
                                                    lpbDevice,
                                                    &dwDeviceSize))
    {
        DebugOut("ISIGN32: RepairDevice can not read entry.\n");
        goto RepairDeviceInfoExit;
    }

    //
    // Get the connectoid's user ID and password
    //
    ZeroMemory(&rasdialp,sizeof(rasdialp));
    rasdialp.dwSize = sizeof(rasdialp);
    lstrcpyn(rasdialp.szEntryName,lpszEntry,RAS_MaxEntryName);

    if (ERROR_SUCCESS != lpfnRasGetEntryDialParams(NULL,
                                                    &rasdialp,
                                                    &bpassword))
    {
        DebugOut("ISIGN32: RepairDevice can not read dial params.\n");
        goto RepairDeviceInfoExit;
    }

    //
    // Delete the existing entry
    //
    if (ERROR_SUCCESS != lpfnRasDeleteEntry(NULL,lpszEntry))
    {
        DebugOut("ISIGN32: RepairDevice can not delete entry.\n");
        goto RepairDeviceInfoExit;
    }

    //
    // Rewrite entry with "fixed" device size
    //
    if (ERROR_SUCCESS != lpfnRasSetEntryProperties(NULL,
                                                    lpszEntry,
                                                    (LPBYTE)lpRasEntry,
                                                    dwEntrySize,
                                                    NULL,
                                                    0))
    {
        DebugOut("ISIGN32: RepairDevice can not write entry.\n");
        goto RepairDeviceInfoExit;
    }

    //
    // Clear unnecessary values
    //
    rasdialp.szPhoneNumber[0] = '\0';
    rasdialp.szCallbackNumber[0] = '\0';

    //
    // Save connectoid's username and password
    //
    if (ERROR_SUCCESS != lpfnRasSetEntryDialParams(NULL,
                                                    &rasdialp,
                                                    FALSE))
    {
        DebugOut("ISIGN32: RepairDevice can not write dial params.\n");
        goto RepairDeviceInfoExit;
    }


    bRC = TRUE;
RepairDeviceInfoExit:
    if (lpRasEntry)
    {
        LocalFree(lpRasEntry);
    }
    if (lpbDevice)
    {
        LocalFree(lpbDevice);
    }
    return bRC;
}
#endif

//+----------------------------------------------------------------------------
//    Function:    DialConnection
//
//    Synopsis:    Dials connectoin created for ISP file
//
//    Arguments:    lpszFile - ISP file name
//
//    Returns:    HRESULT - ERROR_SUCCESS indicates success
//
//    History:
//            7/22/96        ChrisK        Created
//
//-----------------------------------------------------------------------------
static HRESULT DialConnection(LPCTSTR lpszFile)
{
    HRESULT hr = ERROR_SUCCESS;
    DIALDLGDATA dddISPDialDlg;
    ERRORDLGDATA eddISPDialDlg;
    HINSTANCE hDialDLL = NULL;
    PFNDIALDLG pfnDial = NULL;
    PFNERRORDLG pfnError = NULL;
    INT iRetry;

    DebugOut("ISIGNUP:DialConnection()\r\n");
    //
    // Initize data structures
    //

    hr = FillConnectionStructures(lpszFile,&dddISPDialDlg, &eddISPDialDlg);
    if (ERROR_SUCCESS != hr)
        goto DialConnectionExit;

    //
    // Load functions
    //
    TCHAR szBuffer[MAX_PATH];
    if (GetSystemDirectory(szBuffer,MAX_PATH))
    {
        lstrcat(szBuffer, TEXT("\\"));
        lstrcat(szBuffer, cszICWDIAL_DLL);
        hDialDLL = LoadLibrary(szBuffer);
    }
    
    if (!hDialDLL)
        hDialDLL = LoadLibrary(cszICWDIAL_DLL);
    if (NULL != hDialDLL)
    {
        pfnDial = (PFNDIALDLG)GetProcAddress(hDialDLL,cszICWDIAL_DIALDLG);
        if (NULL != pfnDial)
            pfnError = (PFNERRORDLG)GetProcAddress(hDialDLL,cszICWDIAL_ERRORDLG);
    }

    if(!(hDialDLL && pfnDial && pfnError))
    {
        hr = GetLastError();
        goto DialConnectionExit;
    }

    //
    // Dial connection
    //
    iRetry = 0;
DialConnectionDial:
    hr = pfnDial(&dddISPDialDlg);
    if (1 == hr)
    {
        // This is a special case when the user has killed the browser
        // out from behind the dialer.  In this case, shut down and exit
        // as cleanly as possible.
        goto DialConnectionExit;
    }
    else if (ERROR_USERNEXT != hr)
    {
        if ((iRetry < MAX_RETRIES) && FShouldRetry(hr))
        {
            iRetry++;
            goto DialConnectionDial;
        }
        else
        {
#if !defined(WIN16)
            if (0 == iRetry && ERROR_WRONG_INFO_SPECIFIED == hr)
            {
                DebugOut("ISIGN32: Attempt device info repair.\n");
                if (RepairDeviceInfo(dddISPDialDlg.pszRasEntryName))
                {
                    iRetry++;
                    goto DialConnectionDial;
                }
            }
#endif
            iRetry = 0;
            hr = LoadDialErrorString(hr,eddISPDialDlg.pszMessage,MAX_ERROR_MESSAGE);
            hr = pfnError(&eddISPDialDlg);
            if (ERROR_USERCANCEL == hr)
                goto DialConnectionExit;
            else if (ERROR_USERNEXT == hr)
                goto DialConnectionDial;
            else
                goto DialConnectionExit;
        }
    }

DialConnectionExit:
    ReleaseConnectionStructures(&dddISPDialDlg, &eddISPDialDlg);
    if (hDialDLL)
    {
        FreeLibrary(hDialDLL);
        hDialDLL = NULL;
        pfnDial = NULL;
        pfnError = NULL;
    }
    return hr;
}

#ifdef WIN16
LPVOID MyLocalAlloc(DWORD flag, DWORD size)
{
    LPVOID lpv;

    lpv = calloc(1, (INT)size);

    return lpv;
}

LPVOID MyLocalFree(LPVOID lpv)
{
    free(lpv);

    return NULL;
}
#endif

// ############################################################################
//
//    Name:    ImportMailAndNewsInfo
//
//    Description:    Import information from INS file and set the associated
//                        registry keys for Internet Mail and News (Athena)
//
//    Input:    lpszFile - Fully qualified filename of INS file
//
//    Return:    Error value
//
//    History:        6/27/96        Created
//                    5/12/97        Updated to use the new CreateAccountsFromFile
//                                in Athena's inetcomm.dll.  This function was
//                                created expresly for us to use here.
//                                (See Olympus #266)  -- jmazner
//
// ############################################################################

static DWORD ImportMailAndNewsInfo(LPCTSTR lpszFile, BOOL fConnectPhone)
{
    DWORD dwRet = ERROR_SUCCESS;
#ifndef WIN16
    TCHAR szAcctMgrPath[MAX_PATH + 1] = TEXT("");
    TCHAR szExpandedPath[MAX_PATH + 1] = TEXT("");
    DWORD dwAcctMgrPathSize = 0;
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    HINSTANCE hInst = NULL;
    CONNECTINFO connectInfo;
    TCHAR szConnectoidName[RAS_MaxEntryName] = TEXT("nogood\0");
    PFNCREATEACCOUNTSFROMFILEEX fp = NULL;


    // get path to the AcctMgr dll
    dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ACCTMGR_PATHKEY,0, KEY_READ, &hKey);
    if ( (dwRet != ERROR_SUCCESS) || (NULL == hKey) )
    {
        Dprintf("ImportMailAndNewsInfo couldn't open reg key %s\n", ACCTMGR_PATHKEY);
        return( dwRet );
    }

    dwAcctMgrPathSize = sizeof (szAcctMgrPath);
    dwRet = RegQueryValueEx(hKey, ACCTMGR_DLLPATH, NULL, NULL, (LPBYTE) szAcctMgrPath, &dwAcctMgrPathSize);


    RegCloseKey( hKey );

    if ( dwRet != ERROR_SUCCESS )
    {
        Dprintf("ImportMailAndNewsInfo: RegQuery failed with error %d\n", dwRet);
        return( dwRet );
    }

    // 6/18/97 jmazner Olympus #6819
    Dprintf("ImportMailAndNewsInfo: read in DllPath of %s\n", szAcctMgrPath);
    ExpandEnvironmentStrings( szAcctMgrPath, szExpandedPath, MAX_PATH + 1 );

    //
    // 6/4/97 jmazner
    // if we created a connectoid, then get its name and use that as the
    // connection type.  Otherwise, assume we're supposed to connect via LAN
    //
    connectInfo.cbSize = sizeof(CONNECTINFO);
    connectInfo.type = CONNECT_LAN;

    if( fConnectPhone && lpfnInetGetAutodial )
    {
        BOOL fEnabled = FALSE;

        dwRet = lpfnInetGetAutodial(&fEnabled,szConnectoidName,RAS_MaxEntryName);

        if( ERROR_SUCCESS==dwRet && szConnectoidName[0] )
        {
            connectInfo.type = CONNECT_RAS;
#ifdef UNICODE
            wcstombs(connectInfo.szConnectoid, szConnectoidName, MAX_PATH);
#else
            lstrcpyn( connectInfo.szConnectoid, szConnectoidName, MAX_PATH );
#endif 
            Dprintf("ImportMailAndNewsInfo: setting connection type to RAS with %s\n", szConnectoidName);
        }
    }

    if( CONNECT_LAN == connectInfo.type )
    {
        Dprintf("ImportMailAndNewsInfo: setting connection type to LAN\n");
#ifdef UNICODE
        wcstombs(connectInfo.szConnectoid, TEXT("I said CONNECT_LAN!"), MAX_PATH);
#else
        lstrcpy( connectInfo.szConnectoid, TEXT("I said CONNECT_LAN!") );
#endif
    }



    hInst = LoadLibrary(szExpandedPath);
    if (hInst)
    {
        fp = (PFNCREATEACCOUNTSFROMFILEEX) GetProcAddress(hInst,"CreateAccountsFromFileEx");
        if (fp)
            hr = fp( (TCHAR *)lpszFile, &connectInfo, NULL );
    }
    else
    {
        Dprintf("ImportMailAndNewsInfo unable to LoadLibrary on %s\n", szAcctMgrPath);
    }

    //
    // Clean up and release resourecs
    //
    if( hInst)
    {
        FreeLibrary(hInst);
        hInst = NULL;
    }

    if( fp )
    {
        fp = NULL;
    }


//ImportMailAndNewsInfoExit:
#endif
    return dwRet;
}

// ############################################################################
//
//    Name:    WriteMailAndNewsKey
//
//    Description:    Read a string value from the given INS file and write it
//                    to the registry
//
//    Input:    hKey - Registry key where the data will be written
//            lpszSection - Section name inside of INS file where data is read
//                from
//            lpszValue -    Name of value to read from INS file
//            lpszBuff - buffer where data will be read into
//            dwBuffLen - size of lpszBuff
//            lpszSubKey - Value name where information will be written to
//            dwType - data type (Should always be REG_SZ)
//            lpszFileName - Fully qualified filename to INS file
//
//    Return:    Error value
//
//    Histroy:        6/27/96            Created
//                    5/12/97            Commented out -- no longer needed
//                                    (See Olympus #266)
//
// ############################################################################
/***
static HRESULT WriteMailAndNewsKey(HKEY hKey, LPCTSTR lpszSection, LPCTSTR lpszValue,
                            LPTSTR lpszBuff, DWORD dwBuffLen,LPCTSTR lpszSubKey,
                            DWORD dwType, LPCTSTR lpszFile)
{
#ifndef WIN16
    ZeroMemory(lpszBuff,dwBuffLen);
    GetPrivateProfileString(lpszSection,lpszValue,TEXT(""),lpszBuff,dwBuffLen,lpszFile);
    if (lstrlen(lpszBuff))
    {
        return RegSetValueEx(hKey,lpszSubKey,0,dwType,(CONST BYTE*)lpszBuff,
            sizeof(TCHAR)*(lstrlen(lpszBuff)+1));
    }
    else
    {
        DebugOut("ISIGNUP: WriteMailAndNewsKey, missing value in INS file\n");
        return ERROR_NO_MORE_ITEMS;
    }
#else
    return ERROR_GEN_FAILURE;
#endif
}
***/


// ############################################################################
//
//    Name:    PreparePassword
//
//    Description:    Encode given password and return value in place.  The
//                    encoding is done right to left in order to avoid having
//                    to allocate a copy of the data.  The encoding uses base64
//                    standard as specified in RFC 1341 5.2
//
//    Input:    szBuff - Null terminated data to be encoded
//            dwBuffLen - Full length of buffer, this should exceed the length of
//                the input data by at least 1/3
//
//    Return:    Error value
//
//    Histroy:        6/27/96            Created
//
// ############################################################################
static HRESULT PreparePassword(LPTSTR szBuff, DWORD dwBuffLen)
{
    DWORD dw;
    LPTSTR szOut = NULL;
    LPTSTR szNext = NULL;
    HRESULT hr = ERROR_SUCCESS;
    BYTE bTemp = 0;
    DWORD dwLen = 0;

    dwLen = lstrlen(szBuff);
    if (!dwLen)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto PreparePasswordExit;
    }

    // Calculate the size of the buffer that will be needed to hold
    // encoded data
    //

    szNext = &szBuff[dwLen-1];
    dwLen = (((dwLen % 3 ? (3-(dwLen%3)):0) + dwLen) * 4 / 3);

    if (dwBuffLen < dwLen+1)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto PreparePasswordExit;
    }

    szOut = &szBuff[dwLen];
    *szOut-- = '\0';

    // Add padding = characters
    //

    switch (lstrlen(szBuff) % 3)
    {
    case 0:
        // no padding
        break;
    case 1:
        *szOut-- = 64;
        *szOut-- = 64;
        *szOut-- = (*szNext & 0x3) << 4;
        *szOut-- = (*szNext-- & 0xFC) >> 2;
        break;
    case 2:
        *szOut-- = 64;
        *szOut-- = (*szNext & 0xF) << 2;
        *szOut = ((*szNext-- & 0xF0) >> 4);
        *szOut-- |= ((*szNext & 0x3) << 4);
        *szOut-- = (*szNext-- & 0xFC) >> 2;
    }

    // Encrypt data into indicies
    //

    while (szOut > szNext && szNext >= szBuff)
    {
        *szOut-- = *szNext & 0x3F;
        *szOut = ((*szNext-- & 0xC0) >> 6);
        *szOut-- |= ((*szNext & 0xF) << 2);
        *szOut = ((*szNext-- & 0xF0) >> 4);
        *szOut-- |= ((*szNext & 0x3) << 4);
        *szOut-- = (*szNext-- & 0xFC) >> 2;
    }

    // Translate indicies into printable characters
    //

    szNext = szBuff;

    // BUG OSR#10435--if there is a 0 in the generated string of base-64
    // encoded digits (this can happen if the password is "Willypassword"
    // for example), then instead of encoding the 0 to 'A', we just quit
    // at this point, produces an invalid base-64 string.

    // while (*szNext)
    for(dw=0; dw<dwLen; dw++)
        *szNext = arBase64[*szNext++];

PreparePasswordExit:
    return hr;
}

// ############################################################################
//
//    Name: FIsAthenaPresent
//
//    Description:    Determine if Microsoft Internet Mail And News client (Athena)
//                    is installed
//
//    Input:    none
//
//    Return:    TRUE - Athena is installed
//            FALSE - Athena is NOT installed
//
//    History:        7/1/96            Created
//                    5/14/97            No longer needed after work for Olympus #266
//
// ############################################################################
/****
static BOOL FIsAthenaPresent()
{
#ifndef WIN16
    TCHAR szBuff[MAX_PATH + 1];
    HRESULT hr = ERROR_SUCCESS;
    HINSTANCE hInst = NULL;
    LONG lLen = 0;

    // Get path to Athena client
    //

    lLen = MAX_PATH;
    hr = RegQueryValue(HKEY_CLASSES_ROOT,MAIL_NEWS_INPROC_SERVER32,szBuff,&lLen);
    if (hr == ERROR_SUCCESS)
    {
        // Attempt to load client
        //

        hInst = LoadLibrary(szBuff);
        if (!hInst)
        {
            DebugOut("ISIGNUP: Internet Mail and News server didn't load.\n");
            hr = ERROR_FILE_NOT_FOUND;
        } else {
            FreeLibrary(hInst);
        }
        hInst = NULL;
    }

    return (hr == ERROR_SUCCESS);
#else
    return FALSE;
#endif // win16
}
*****/

// ############################################################################
//
//    Name:    FTurnOffBrowserDefaultChecking
//
//    Description:    Turn Off IE checking to see if it is the default browser
//
//    Input:    none
//
//    Output:    TRUE - success
//            FALSE - failed
//
//    History:        7/2/96            Created
//
// ############################################################################
static BOOL FTurnOffBrowserDefaultChecking()
{
    BOOL bRC = TRUE;
#ifndef WIN16
    HKEY hKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;

    //
    // Open IE settings registry key
    //
    if (RegOpenKey(HKEY_CURRENT_USER,cszDEFAULT_BROWSER_KEY,&hKey))
    {
        bRC = FALSE;
        goto FTurnOffBrowserDefaultCheckingExit;
    }

    //
    // Read current settings for check associations
    //
    dwType = 0;
    dwSize = sizeof(pDynShare->szCheckAssociations);
    ZeroMemory(pDynShare->szCheckAssociations, dwSize);
    RegQueryValueEx(hKey,
                    cszDEFAULT_BROWSER_VALUE,
                    0,
                    &dwType,
                    (LPBYTE)pDynShare->szCheckAssociations,
                    &dwSize);
    
    // ignore return value, even if the calls fails we are going to try
    // to change the setting to "NO"

    //
    // Set value to "no" to turn off checking
    //
    if (RegSetValueEx(hKey,
                      cszDEFAULT_BROWSER_VALUE,
                      0,
                      REG_SZ,
                      (LPBYTE)cszNo,
                      sizeof(TCHAR)*(lstrlen(cszNo)+1)))
    {
        bRC = FALSE;
        goto FTurnOffBrowserDefaultCheckingExit;
    }

    //
    // Clean up and return
    //
FTurnOffBrowserDefaultCheckingExit:
    if (hKey)
        RegCloseKey(hKey);
    if (bRC)
        SetExitFlags(SXF_RESTOREDEFCHECK);
    hKey = NULL;
#endif
    return bRC;
}

// ############################################################################
//
//    Name:    FRestoreBrowserDefaultChecking
//
//    Description:    Restore IE checking to see if it is the default browser
//
//    Input:    none
//
//    Output:    TRUE - success
//            FALSE - failed
//
//    History:        7/2/96            Created
//
// ############################################################################
static BOOL FRestoreBrowserDefaultChecking()
{
    BOOL bRC = TRUE;
#ifndef WIN16
    HKEY hKey = NULL;

    //
    // Open IE settings registry key
    //
    if (RegOpenKey(HKEY_CURRENT_USER,cszDEFAULT_BROWSER_KEY,&hKey))
    {
        bRC = FALSE;
        goto FRestoreBrowserDefaultCheckingExit;
    }
         
    //
    // Set value to original value
    //
    if (RegSetValueEx(hKey,
                      cszDEFAULT_BROWSER_VALUE,
                      0,
                      REG_SZ,
                      (LPBYTE)pDynShare->szCheckAssociations,
                      sizeof(TCHAR)*(lstrlen(pDynShare->szCheckAssociations)+1)))
    {
        bRC = FALSE;
        goto FRestoreBrowserDefaultCheckingExit;
    }

FRestoreBrowserDefaultCheckingExit:
    if (hKey)
        RegCloseKey(hKey);
    hKey = NULL;
#endif
    return bRC;
}


#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//    Function:     SaveIEWindowPlacement
//
//    Synopsis:    Saves the registry value for IE window placement into a global for later restoration
//                Should only be called once in the signup process.
//
//    Arguments:    None, but uses global pbIEWindowPlacement, which it expects to be NULL
//
//    Returns:      TRUE - The value was read and stored
//                  FALSE - function failed.
//
//    History:      8/21/96     jmazner        Created    (as fix for Normandy #4592)
//                  10/11/96    jmazner        updated to dynamicaly determine size of the key
//
//-----------------------------------------------------------------------------
BOOL SaveIEWindowPlacement( void )
{
    HKEY    hKey = NULL;
    //DWORD dwSize = 0;
    LONG    lQueryErr = 0xEE; // initialize to something strange
    DWORD   dwIEWindowPlacementSize = 0;
    PBYTE   pbIEWindowPlacement = NULL;
    
    // Argh, no Assert defined in isign32!
    if ( pDynShare->dwIEWindowPlacementSize != 0 )
    {
#if DEBUG
        DebugOut("ISIGN32: SaveIEWindowPlacement called a second time!\n");
        MessageBox(
            hwndMain,
            TEXT("ISIGN32 ERROR: Window_Placement global var is not null --jmazner\n"),
            cszAppName,
            MB_SETFOREGROUND |
            MB_ICONEXCLAMATION |
            MB_OKCANCEL);
#endif
        DebugOut("ISIGN32: SaveIEWindowPlacement called a second time!\n");
        goto SaveIEWindowPlacementErrExit;
    }
    
    //
    // Open IE settings registry key
    //
    if ( ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
                                       cszDEFAULT_BROWSER_KEY,
                                       NULL,
                                       KEY_READ,
                                       &hKey) )
        goto SaveIEWindowPlacementErrExit;


    // Determine size of buffer needed to hold the window_placement key


     lQueryErr = RegQueryValueEx(hKey,
                          cszIEWINDOW_PLACEMENT,
                          NULL,
                          NULL,
                          NULL,
                          &dwIEWindowPlacementSize);

    // for unknown reasons, lQueryErr is ending up as ERROR_SUCCESS after this call!
//    if( ERROR_MORE_DATA != lQueryErr )
//        goto SaveIEWindowPlacementErrExit;


    ISIGN32_ASSERT(sizeof(pDynShare->pbIEWindowPlacement) >= dwIEWindowPlacementSize);
    
    pbIEWindowPlacement = pDynShare->pbIEWindowPlacement;
    
    //
    // Read current settings for window_placement
    //
    //dwSize = sizeof(pbIEWindowPlacement);
    //ZeroMemory(pbIEWindowPlacement,dwSize);
    lQueryErr = RegQueryValueEx(hKey,
                          cszIEWINDOW_PLACEMENT,
                          NULL,
                          NULL,
                          (LPBYTE)pbIEWindowPlacement,
                          &dwIEWindowPlacementSize);

    if (ERROR_SUCCESS != lQueryErr)
    {
#ifdef DEBUG
        MessageBox(
            hwndMain,
            TEXT("ISIGNUP ERROR: Window_Placement reg key is longer than expected! --jmazner\n"),
            cszAppName,
            MB_SETFOREGROUND |
            MB_ICONEXCLAMATION |
            MB_OKCANCEL);
#endif
        DebugOut("ISIGN32 ERROR: SaveIEWindowPlacement RegQueryValue failed\n");
        goto SaveIEWindowPlacementErrExit;
    }

    RegCloseKey( hKey );

    pDynShare->dwIEWindowPlacementSize = dwIEWindowPlacementSize;    

    return( TRUE );

SaveIEWindowPlacementErrExit:
    if ( hKey ) RegCloseKey( hKey );
    return( FALSE );

}

// note we're still in #if !defined(WIN16)

//+----------------------------------------------------------------------------
//
//    Function:    RestoreIEWindowPlacement
//
//    Synopsis:    Restores the registry value for IE window placement from a global
//                 NOTE:  compatability with Nashville/IE 4?
//
//    Arguments:   None
//
//    Returns:     TRUE - The value was restored
//                 FALSE - function failed.
//
//    History:     jmazner        Created        8/21/96    (as fix for Normandy #4592)
//
//-----------------------------------------------------------------------------
BOOL RestoreIEWindowPlacement( void )
{
    HKEY hKey = NULL;
     
    if ( pDynShare->dwIEWindowPlacementSize == 0 )
    {
        DebugOut("ISIGN32: RestoreIEWindowPlacement called with null global!\n");
        return( FALSE );
    }

    //
    // Open IE settings registry key
    //
    if ( ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
                                       cszDEFAULT_BROWSER_KEY,
                                       NULL,
                                       KEY_SET_VALUE,
                                       &hKey) )
        return( FALSE );

    //
    // Write saved settings for window_placement
    //
    if (ERROR_SUCCESS != RegSetValueEx(hKey,
                          cszIEWINDOW_PLACEMENT,
                          NULL,
                          REG_BINARY,
                          (LPBYTE)pDynShare->pbIEWindowPlacement,
                          pDynShare->dwIEWindowPlacementSize) )
    {
        RegCloseKey( hKey );
        return( FALSE );
    }

    RegCloseKey( hKey );

    pDynShare->pbIEWindowPlacement[0] = (TCHAR) 0;
    pDynShare->dwIEWindowPlacementSize = 0;
    
    return( TRUE );
}
#endif //(!defined win16)


//+----------------------------------------------------------------------------
//
//    Function:    DeleteFileKindaLikeThisOne
//
//  Synopsis:    This function serve the single function of cleaning up after
//                IE3.0, because IE3.0 will issue multiple POST and get back
//                multiple .INS files.  These files contain sensative data that
//                we don't want lying around, so we are going out, guessing what
//                their names are, and deleting them.
//
//    Arguments:    lpszFileName - the full name of the file to delete
//
//    Returns:    error code, ERROR_SUCCESS == success
//
//    History:    7/96    ChrisK    Created
//                7/96    ChrisK    Bug fix for long filenames
//                8/2/96    ChrisK    Port to Win32
//-----------------------------------------------------------------------------

static HRESULT DeleteFileKindaLikeThisOne(LPCTSTR lpszFileName)
{
    HRESULT hr = ERROR_SUCCESS;
#ifndef WIN16
    LPCTSTR lpNext = NULL;
    WORD wRes = 0;
    HANDLE hFind = NULL;
    WIN32_FIND_DATA sFoundFile;
    TCHAR szPath[MAX_PATH];
    TCHAR szSearchPath[MAX_PATH + 1];
    LPTSTR lpszFilePart = NULL;

    // Validate parameter
    //

    if (!lpszFileName || lstrlen(lpszFileName) <= 4)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto DeleteFileKindaLikeThisOneExit;
    }

    // Determine the directory name where the INS files are located
    //

    ZeroMemory(szPath,MAX_PATH);
    if (GetFullPathName(lpszFileName,MAX_PATH,szPath,&lpszFilePart))
    {
        *lpszFilePart = '\0';
    } else {
        hr = GetLastError();
        goto DeleteFileKindaLikeThisOneExit;
    };

    // Munge filename into search parameters
    //

    lpNext = &lpszFileName[lstrlen(lpszFileName)-4];

    if (CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE,lpNext,4,TEXT(".INS"),4) != 2) goto DeleteFileKindaLikeThisOneExit;

    ZeroMemory(szSearchPath,MAX_PATH + 1);
    lstrcpyn(szSearchPath,szPath,MAX_PATH);
    lstrcat(szSearchPath,TEXT("*.INS"));

    // Start wiping out files
    //

    ZeroMemory(&sFoundFile,sizeof(sFoundFile));
    hFind = FindFirstFile(szSearchPath,&sFoundFile);
    if (hFind)
    {
        do {
            lstrcpy(lpszFilePart,sFoundFile.cFileName);
            SetFileAttributes(szPath,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szPath);
            ZeroMemory(&sFoundFile,sizeof(sFoundFile));
        } while (FindNextFile(hFind,&sFoundFile));
        FindClose(hFind);
    }

    hFind = NULL;

DeleteFileKindaLikeThisOneExit:
#endif
    return hr;
}


#if defined(WIN16)

#define MAIN_WNDCLASS_NAME      "IE_DialerMainWnd"
#define IEDIAL_REGISTER_MSG     "IEDialQueryPrevInstance"
#define IEDIALMSG_QUERY            (0)
#define IEDIALMSG_SHUTDOWN        (1)
#define    IEDIAL_SHUTDOWN_TIMER    1001

//+---------------------------------------------------------------------------
//
//  Function:   ShutDownIEDial()
//
//  Synopsis:   Shutdown the instance IEDial if it running and
//                in disconnected state - otherwise it interfers with dialing
//                from icwconn2
//
//  Arguments:  [hWnd - Window handle (used for creating timer)
//
//    Returns:    TRUE if successful shutdown or instance does not exist
//                FALSE otherwise
//
//  History:    8/24/96        VetriV        Created
//
//----------------------------------------------------------------------------
BOOL ShutDownIEDial(HWND hWnd)
{
    HINSTANCE hInstance;
    static UINT WM_IEDIAL_INSTANCEQUERY = 0;
    UINT uiAttempts = 0;
    MSG   msg;

    //
    // Check if IEDial is running
    //
    hInstance = FindWindow(MAIN_WNDCLASS_NAME, NULL);
    if (NULL != hInstance)
    {
        if (0 == WM_IEDIAL_INSTANCEQUERY)
            WM_IEDIAL_INSTANCEQUERY= RegisterWindowMessage(IEDIAL_REGISTER_MSG);


        //
        // Check if it is in connected state
        //
        if (SendMessage(hInstance, WM_IEDIAL_INSTANCEQUERY,
                            IEDIALMSG_QUERY, 0))
        {
            //
            // Not connected - Send quit message
            //
            SendMessage(hInstance, WM_IEDIAL_INSTANCEQUERY,
                            IEDIALMSG_SHUTDOWN, 0);
            return TRUE;
        }


        //
        // If IEDIAL is in connected state try for another 3 seconds
        // waiting for 1 second between tries
        // We have to do this because, IEDIAL can take upto 2 seconds
        // to realize it lost the connection!!
        //
        SetTimer(hWnd, IEDIAL_SHUTDOWN_TIMER, 1000, NULL);
        DebugOut("ISIGNUP: IEDIAL Timer message loop\n");

        while (GetMessage (&msg, NULL, 0, 0))
        {
            if (WM_TIMER == msg.message)
            {
                //
                // Check if it is in connected state
                //
                if (SendMessage(hInstance, WM_IEDIAL_INSTANCEQUERY,
                                    IEDIALMSG_QUERY, 0))
                {
                    //
                    // Not connected - Send quit message
                    //
                    SendMessage(hInstance, WM_IEDIAL_INSTANCEQUERY,
                                    IEDIALMSG_SHUTDOWN, 0);
                    break;
                }

                //
                // If we have tried thrice - get out
                //
                if (++uiAttempts > 3)
                    break;
            }
            else
            {
                TranslateMessage (&msg) ;
                DispatchMessage  (&msg) ;
            }
        }
        KillTimer(hWnd, IEDIAL_SHUTDOWN_TIMER);

        if (uiAttempts > 3)
            return FALSE;
    }

    return TRUE;
}

#endif // WIN16

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//    Function    LclSetEntryScriptPatch
//
//    Synopsis    Softlink to RasSetEntryPropertiesScriptPatch
//
//    Arguments    see RasSetEntryPropertiesScriptPatch
//
//    Returns        see RasSetEntryPropertiesScriptPatch
//
//    Histroy        10/3/96    ChrisK Created
//
//-----------------------------------------------------------------------------
typedef BOOL (WINAPI* LCLSETENTRYSCRIPTPATCH)(LPTSTR, LPTSTR);
BOOL LclSetEntryScriptPatch(LPTSTR lpszScript,LPTSTR lpszEntry)
{
    HINSTANCE hinst = NULL;
    LCLSETENTRYSCRIPTPATCH fp = NULL;
    BOOL bRC = FALSE;

    hinst = LoadLibrary(TEXT("ICWDIAL.DLL"));
    if (hinst)
    {
        fp = (LCLSETENTRYSCRIPTPATCH)GetProcAddress(hinst,"RasSetEntryPropertiesScriptPatch");
        if (fp)
            bRC = (fp)(lpszScript,lpszEntry);
        FreeLibrary(hinst);
        hinst = NULL;
        fp = NULL;
    }
    return bRC;
}
#endif //!WIN16


#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//    Function    IsMSDUN12Installed
//
//    Synopsis    Check if MSDUN 1.2 or higher is installed
//
//    Arguments    none
//
//    Returns        TRUE - MSDUN 1.2 is installed
//
//    History        5/28/97 ChrisK created for Olympus Bug 4392
//
//-----------------------------------------------------------------------------

//
// 8/5/97 jmazner Olympus #11404
//
//#define DUN_12_Version (1.2e0f)
#define DUN_12_Version ((double)1.2)
BOOL IsMSDUN12Installed()
{
    TCHAR szBuffer[MAX_PATH] = {TEXT("\0")};
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(szBuffer);
    FLOAT flVersion = 0e0f;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Services\\RemoteAccess"),
        &hkey))
    {
        goto IsMSDUN12InstalledExit;
    }

    if (ERROR_SUCCESS != RegQueryValueEx(hkey,
        TEXT("Version"),
        NULL,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize))
    {
        goto IsMSDUN12InstalledExit;
    }

#ifdef UNICODE
    CHAR szTmp[MAX_PATH];
    wcstombs(szTmp, szBuffer, MAX_PATH);
    szTmp[MAX_PATH-1] = '\0';
    bRC = DUN_12_Version <= atof(szTmp);
#else
    bRC = DUN_12_Version <= atof(szBuffer);
#endif
IsMSDUN12InstalledExit:
    if (hkey != NULL)
    {
        RegCloseKey(hkey);
        hkey = NULL;
    }
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    IsScriptingInstalled
//
//    Synopsis    Check to see if scripting is already installed
//
//    Arguments    none
//
//    Returns        TRUE - scripting has been installed
//
//    History        10/14/96    ChrisK    Creaed
//
//-----------------------------------------------------------------------------
static BOOL IsScriptingInstalled()
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    LONG lrc = 0;
    HINSTANCE hInst = NULL;
    TCHAR szData[MAX_PATH+1];
    OSVERSIONINFO osver;
    //
    //    Check version information
    //
    ZeroMemory(&osver,sizeof(osver));
    osver.dwOSVersionInfoSize = sizeof(osver);
    GetVersionEx(&osver);

    //
    // check for SMMSCRPT.DLL being present
    //

    if (VER_PLATFORM_WIN32_NT == osver.dwPlatformId)
    {
        bRC = TRUE;
    }
    else if (IsMSDUN12Installed())
    {
        bRC = TRUE;
    }
    else
    {
        //
        // Verify scripting by checking for smmscrpt.dll in RemoteAccess registry key
        //
        if (1111 <= (osver.dwBuildNumber & 0xFFFF))
        {
            bRC = TRUE;
        }
        else
        {
            bRC = FALSE;
            hkey = NULL;
            lrc=RegOpenKey(HKEY_LOCAL_MACHINE,TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\SMM_FILES\\PPP"),&hkey);
            if (ERROR_SUCCESS == lrc)
            {
                dwSize = sizeof(TCHAR)*MAX_PATH;
                lrc = RegQueryValueEx(hkey,TEXT("Path"),0,&dwType,(LPBYTE)szData,&dwSize);
                if (ERROR_SUCCESS == lrc)
                {
                    if (0 == lstrcmpi(szData,TEXT("smmscrpt.dll")))
                        bRC = TRUE;
                }
            }
            if (hkey)
                RegCloseKey(hkey);
            hkey = NULL;
        }

        //
        // Verify that the DLL can be loaded
        //
        if (bRC)
        {
            hInst = LoadLibrary(TEXT("smmscrpt.dll"));
            if (hInst)
                FreeLibrary(hInst);
            else
                bRC = FALSE;
            hInst = NULL;
        }
    }
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    InstallScripter
//
//    Synopsis    Install scripting on win95 950.6 builds (not on OSR2)
//
//    Arguments    none
//
//    Returns        none
//
//    History        10/9/96    ChrisK    Copied from mt.cpp in \\trango sources
//
//-----------------------------------------------------------------------------
static void InstallScripter(void)
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    MSG                    msg ;
    DWORD                iWaitResult = 0;
    HINSTANCE            hInst = LoadLibrary(TEXT("smmscrpt.dll"));

    DebugOut("ISIGN32: Install Scripter.\r\n");
    //
    // Check if we need to install scripting
    //
    if (!IsScriptingInstalled())
    {
        TCHAR szCommandLine[] = TEXT("\"icwscrpt.exe\"");
        
        memset(&pi, 0, sizeof(pi));
        memset(&si, 0, sizeof(si));
        if(!CreateProcess(NULL, szCommandLine, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        {
            DebugOut("ISIGN32: Cant find ICWSCRPT.EXE\r\n");
        }
        else
        {
            DebugOut("ISIGN32: Launched ICWSCRPT.EXE. Waiting for exit.\r\n");
            //
            // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
            //
            while((iWaitResult=MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
            {
                //
                // read all of the messages in this next loop
                   // removing each message as we read it
                //
                   while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                   {
                    DebugOut("ISIGN32: Got msg\r\n");
                    //
                    // how to handle quit message?
                    //
                    if (msg.message == WM_QUIT)
                    {
                        DebugOut("ISIGN32: Got quit msg\r\n");
                        goto done;
                    }
                    else
                        DispatchMessage(&msg);
                }
            }
        done:
             CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
            DebugOut("ISIGN32: ICWSCRPT.EXE done\r\n");
        }
    }
}

//+----------------------------------------------------------------------------
//
//    Function:    FGetSystemShutdownPrivledge
//
//    Synopsis:    For windows NT the process must explicitly ask for permission
//                to reboot the system.
//
//    Arguements:    none
//
//    Return:        TRUE - privledges granted
//                FALSE - DENIED
//
//    History:    8/14/96    ChrisK    Created
//
//    Note:        BUGBUG for Win95 we are going to have to softlink to these
//                entry points.  Otherwise the app won't even load.
//                Also, this code was originally lifted out of MSDN July96
//                "Shutting down the system"
//-----------------------------------------------------------------------------
static BOOL FGetSystemShutdownPrivledge()
{
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;
    BOOL bRC = FALSE;
    OSVERSIONINFO osver;

    ZeroMemory(&osver,sizeof(osver));
    osver.dwOSVersionInfoSize = sizeof(osver);
    if (!GetVersionEx(&osver))
        goto FGetSystemShutdownPrivledgeExit;

    if (VER_PLATFORM_WIN32_NT == osver.dwPlatformId)
    {
        //
        // Get the current process token handle
        // so we can get shutdown privilege.
        //

        if (!OpenProcessToken(GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
                goto FGetSystemShutdownPrivledgeExit;

        //
        // Get the LUID for shutdown privilege.
        //

        ZeroMemory(&tkp,sizeof(tkp));
        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME,
                &tkp.Privileges[0].Luid);

        tkp.PrivilegeCount = 1;  /* one privilege to set    */
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        //
        // Get shutdown privilege for this process.
        //

        AdjustTokenPrivileges(hToken, FALSE, &tkp, 0,
            (PTOKEN_PRIVILEGES) NULL, 0);

        if (ERROR_SUCCESS == GetLastError())
            bRC = TRUE;
    }
    else
    {
        bRC = TRUE;
    }

FGetSystemShutdownPrivledgeExit:
    if (hToken) CloseHandle(hToken);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Function    VerifyRasServicesRunning
//
//    Synopsis    Make sure that the RAS services are enabled and running
//
//    Arguments    HWND - parent window
//
//    Return        FALSE - if the services couldn't be started
//
//    History        10/16/96    ChrisK    Created
//-----------------------------------------------------------------------------
typedef HRESULT (WINAPI *PFINETSTARTSERVICES)(void);
#define MAX_STRING 256
static BOOL VerifyRasServicesRunning(HWND hwnd)
{
    HINSTANCE hInst = NULL;
    FARPROC fp = NULL;
    BOOL bRC = FALSE;
    HRESULT hr = ERROR_SUCCESS;

    hInst = LoadLibrary(TEXT("INETCFG.DLL"));
    if (hInst)
    {
        fp = GetProcAddress(hInst, "InetStartServices");
        if (fp)
        {
            //
            // Check Services
            //
            hr = ((PFINETSTARTSERVICES)fp)();
            if (ERROR_SUCCESS == hr)
            {
                bRC = TRUE;
            }
            else
            {
                //
                // Report the erorr
                //
                TCHAR szMsg[MAX_STRING + 1];

                    LoadString(
                        ghInstance,
                        IDS_SERVICEDISABLED,
                        szMsg,
                        SIZEOF_TCHAR_BUFFER(szMsg));

                //
                // we reach here in the condition when
                // 1) user deliberately removes some file
                // 2) Did not reboot after installing RAS
                // MKarki - (5/7/97) - Fix for Bug #4004
                //
                MessageBox(
                    hwnd,
                    szMsg,
                    cszAppName,
                    MB_OK| MB_ICONERROR | MB_SETFOREGROUND
                    );
                bRC = FALSE;
            }
        }
        FreeLibrary(hInst);
    }
    
#if !defined(WIN16)

    if (bRC)
    {
        SetControlFlags(SCF_RASREADY);
    }
    else
    {
        ClearControlFlags(SCF_RASREADY);
    }

#endif
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    GetDeviceSelectedByUser
//
//    Synopsis    Get the name of the RAS device that the user had already picked
//
//    Arguements    szKey - name of sub key
//                szBuf - pointer to buffer
//                dwSize - size of buffer
//
//    Return        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL GetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf, DWORD dwSize)
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    DWORD dwType = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
        ISIGNUP_KEY,&hkey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,szKey,0,&dwType,
            (LPBYTE)szBuf,&dwSize))
            bRC = TRUE;
    }

    if (hkey)
        RegCloseKey(hkey);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Function    SetDeviceSelectedByUser
//
//    Synopsis    Write user's device selection to registry
//
//    Arguments    szKey - name of key
//                szBuf - data to write to key
//
//    Returns        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL SetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf)
{
    BOOL bRC = FALSE;
    HKEY hkey = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
        ISIGNUP_KEY,&hkey))
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkey,szKey,0,REG_SZ,
            (LPBYTE)szBuf,sizeof(TCHAR)*lstrlen(szBuf)))
            bRC = TRUE;
    }

    if (hkey)
        RegCloseKey(hkey);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Funciton    DeleteUserDeviceSelection
//
//    Synopsis    Remove registry keys with device selection
//
//    Arguments    szKey - name of value to remove
//
//    Returns        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL DeleteUserDeviceSelection(LPTSTR szKey)
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
        ISIGNUP_KEY,&hkey))
    {
        bRC = (ERROR_SUCCESS == RegDeleteValue(hkey,szKey));
        RegCloseKey(hkey);
    }
    return bRC;
}
//+---------------------------------------------------------------------------
//
//  Function:   ConfigRasEntryDevice()
//
//  Synopsis:   Checks whether user has already specified a modem to use;
//                If so, verifies that modem is valid.
//                If not, or if modem is invalid, presents user a dialog
//                to choose which modem to use (if only one modem is installed,
//                it automaticaly selects that device and bypasses the dialog)
//
//  Arguments:  lpRasEntry - Pointer to the RasEntry whose szDeviceName and
//                             szDeviceType members you wish to verify/configure
//
//    Returns:    ERROR_CANCELLED - Had to bring up "Choose Modem" dialog, and
//                                  and user hit its "Cancel" button
//                Otherwise returns any error code encountered.
//                ERROR_SUCCESS indicates success.
//
//  History:    5/18/96     VetriV    Created
//
//----------------------------------------------------------------------------
DWORD ConfigRasEntryDevice( LPRASENTRY lpRasEntry )
{
    DWORD    dwRet = ERROR_SUCCESS;
    CEnumModem  EnumModem;

    GetDeviceSelectedByUser(DEVICENAMEKEY, g_szDeviceName, sizeof(g_szDeviceName));
    GetDeviceSelectedByUser(DEVICETYPEKEY, g_szDeviceType, sizeof(g_szDeviceType));

    dwRet = EnumModem.GetError();
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }


    // If there are no modems, we're horked
    if (0 == EnumModem.GetNumDevices())
    {
        DebugOut("ISIGN32: import.cpp: ConfigRasEntryDevice: ERROR: No modems installed!\n");

        //
        // ChrisK Olympus 6796 6/24/97
        // If there is no modem currently configured, there will be by the time the
        // connectoid is created.
        //
        return ERROR_SUCCESS;
    }


    // Validate the device if possible
    if ( lpRasEntry->szDeviceName[0] && lpRasEntry->szDeviceType[0] )
    {
        // Verify that there is a device with the given name and type
        if (!EnumModem.VerifyDeviceNameAndType(lpRasEntry->szDeviceName,
                                                lpRasEntry->szDeviceType))
        {
            // There was no device that matched both name and type,
            // so reset the strings and bring up the choose modem UI.
            lpRasEntry->szDeviceName[0] = '\0';
            lpRasEntry->szDeviceType[0] = '\0';
        }
    }
    else if ( lpRasEntry->szDeviceName[0] )
    {
        // Only the name was given.  Try to find a matching type.
        // If this fails, fall through to recovery case below.
        LPTSTR szDeviceType =
            EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName);
        if (szDeviceType)
        {
            lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
        }
    }
    else if ( lpRasEntry->szDeviceType[0] )
    {
        // Only the type was given.  Try to find a matching name.
        // If this fails, fall through to recovery case below.
        LPTSTR szDeviceName =
            EnumModem.GetDeviceNameFromType(lpRasEntry->szDeviceType);
        if (szDeviceName)
        {
            lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
        }
    }

    // If either name or type is missing, check whether the user has already made a choice.
    // if not, bring up choose modem UI if there
    // are multiple devices, else just get first device.
    // Since we already verified that there was at least one device,
    // we can assume that this will succeed.

    if( !(lpRasEntry->szDeviceName[0]) ||
        !(lpRasEntry->szDeviceType[0]) )
    {
        DebugOut("ISIGN32: ConfigRasEntryDevice: no valid device passed in\n");

        if( g_szDeviceName[0] )
        {
            // it looks like we have already stored the user's choice.
            // store the DeviceName in lpRasEntry, then call GetDeviceTypeFromName
            // to confirm that the deviceName we saved actually exists on the system
            lstrcpy(lpRasEntry->szDeviceName, g_szDeviceName);

            if( 0 == lstrcmp(EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName),
                              g_szDeviceType) )
            {
                //DebugOut("ISIGN32: ConfigRasEntryDevice using previously stored choice, '%s'\n",
                //        g_szDeviceName);
                lstrcpy(lpRasEntry->szDeviceType, g_szDeviceType);
                return ERROR_SUCCESS;
            }
            else
            {
                // whatever we previously stored has somehow gone bad; fall through to code below
                //DebugOut("ISIGN32: ConfigRasEntryDevice: previously stored choice '%s' is not valid\n",
                //        g_szDeviceName);
            }
        }


        if (1 == EnumModem.GetNumDevices())
        {
            // There is just one device installed, so copy the name
            DebugOut("ISIGN32: import.cpp: ConfigRasEntryDevice: only one modem installed, using it\n");
            lstrcpy (lpRasEntry->szDeviceName, EnumModem.Next());
        }
        else
        {
            DebugOut("ISIGN32: import.cpp: ConfigRasEntryDevice: multiple modems detected\n");

            // structure to pass to dialog to fill out
            CHOOSEMODEMDLGINFO ChooseModemDlgInfo;
             
            // Display a dialog and allow the user to select modem
            // TODO:  is g_hWndMain the right thing to use for parent?
            int iRet = (int)DialogBoxParam(
                GetModuleHandle(TEXT("ISIGN32.DLL")),
                MAKEINTRESOURCE(IDD_CHOOSEMODEMNAME),
                pDynShare->hwndMain,
                ChooseModemDlgProc,
                (LPARAM) &ChooseModemDlgInfo);
            
            if (0 == iRet)
            {
                // user cancelled
                dwRet = ERROR_CANCELLED;
            }
            else if (-1 == iRet)
            {
                // an error occurred.
                dwRet = GetLastError();
                if (ERROR_SUCCESS == dwRet)
                {
                    // Error occurred, but the error code was not set.
                    dwRet = ERROR_INETCFG_UNKNOWN;
                }
            }

            // Copy the modem name string
            lstrcpy (lpRasEntry->szDeviceName, ChooseModemDlgInfo.szModemName);
        }

        // Now get the type string for this modem
        lstrcpy (lpRasEntry->szDeviceType,
            EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName));
        //Assert(lstrlen(lpRasEntry->szDeviceName));
        //Assert(lstrlen(lpRasEntry->szDeviceType));
    }

    lstrcpy(g_szDeviceName, lpRasEntry->szDeviceName);
    lstrcpy(g_szDeviceType, lpRasEntry->szDeviceType);

    // Save data in registry
    SetDeviceSelectedByUser(DEVICENAMEKEY, g_szDeviceName);
    SetDeviceSelectedByUser (DEVICETYPEKEY, g_szDeviceType);

    return dwRet;
}

//+----------------------------------------------------------------------------
//    Function    RasDial1Callback
//
//    Synopsis    This function will be called with RAS status information.
//                For most message this function will simply pass the data on to
//                the hwnd in the dialer.  However, if the connection is dropped
//                unexpectedly then the function will allow the user to
//                reconnect.  Note, the reconnection only applies to NT since
//                win95 machines will automatically handle this.
//
//    Arguments    hrasconn,    // handle to RAS connection
//                unMsg,    // type of event that has occurred
//                rascs,    // connection state about to be entered
//                dwError,    // error that may have occurred
//                dwExtendedError    // extended error information for some errors
//                (See RasDialFunc for more details)
//
//    Returns        none
//
//    History        10/28/96    ChrisK    Created
//-----------------------------------------------------------------------------
VOID WINAPI RasDial1Callback(
    HRASCONN hrasconn,    // handle to RAS connection
    UINT unMsg,    // type of event that has occurred
    RASCONNSTATE rascs,    // connection state about to be entered
    DWORD dwError,    // error that may have occurred
    DWORD dwExtendedError    // extended error information for some errors
   )
{
    static BOOL fIsConnected = FALSE;
    static HWND    hwndDialDlg = NULL;
    static DWORD dwPlatformId = 0xFFFFFFFF;
    static UINT unRasMsg = 0;
    OSVERSIONINFO osver;
    HANDLE hThread = INVALID_HANDLE_VALUE;
    DWORD dwTID = 0;

    //
    // Initial registration
    //
    if (WM_RegisterHWND == unMsg)
    {
        //
        // dwError actually contains an HWND in this case.
        //
        if (hwndDialDlg)
        {
            DebugOut("ISIGN32: ERROR hwndDialDlg is not NULL.\r\n");
        }
        if (fIsConnected)
        {
            DebugOut("ISIGN32: ERROR fIsConnected is not FALSE.\r\n");
        }
        if (0xFFFFFFFF != dwPlatformId)
        {
            DebugOut("ISIGN32: ERROR dwPlatformId is not initial value.\r\n");
        }
        //
        // Remember HWND value
        //
        hwndDialDlg = (HWND)UlongToPtr(dwError);

        //
        // Determine the current platform
        //
        ZeroMemory(&osver,sizeof(osver));
        osver.dwOSVersionInfoSize = sizeof(osver);
        if (GetVersionEx(&osver))
            dwPlatformId = osver.dwPlatformId;

        //
        // Figure out ras event value
        //
        unRasMsg = RegisterWindowMessageA(RASDIALEVENT);
        if (unRasMsg == 0) unRasMsg = WM_RASDIALEVENT;


        //
        // Don't call into the HWND if this is the initial call
        //
        goto RasDial1CallbackExit;
    }

    //
    // Remember if the connection was successfull
    //
    if (RASCS_Connected == rascs)
    {
        fIsConnected = TRUE;
        if (VER_PLATFORM_WIN32_NT == dwPlatformId)
        {
            hThread = CreateThread(NULL,0,
                (LPTHREAD_START_ROUTINE)StartNTReconnectThread,
                (LPVOID)hrasconn,0,&dwTID);
            if (hThread)
                CloseHandle(hThread);
            else
                DebugOut("ISIGN32: Failed to start reconnect thread.\r\n");
        }
    }

    //
    // Pass the message on to the Dialing dialog
    //
    if (IsWindow(hwndDialDlg))
    {
        if (WM_RASDIALEVENT == unMsg)
        {
            if (0 == unRasMsg)
            {
                DebugOut("ISIGN32: ERROR we are about to send message 0.  Very bad...\r\n");
            }
            SendMessage(hwndDialDlg,unRasMsg,(WPARAM)rascs,(LPARAM)dwError);
        }
        else
        {
            SendMessage(hwndDialDlg,unMsg,(WPARAM)rascs,(LPARAM)dwError);
        }
    }
RasDial1CallbackExit:
    return;
}

//+----------------------------------------------------------------------------
//    Function    SLRasConnectionNotification
//
//    Synopsis    Soft link to RasConnectionNotification
//
//    Arguments    hrasconn - handle to connection
//                hEvent - handle to event
//                dwFlags - flags to determine the type of notification
//
//    Returns        ERROR_SUCCESS - if successful
//
//    History        10/29/96    ChrisK    Created
//-----------------------------------------------------------------------------
typedef DWORD (APIENTRY *PFNRASCONNECTIONNOTIFICATION)( HRASCONN, HANDLE, DWORD );
// 1/7/96 jmazner  already defined in ras2.h
//#define RASCN_Disconnection 2
#define CONNECT_CHECK_INTERVAL 500

static DWORD SLRasConnectionNotification(HRASCONN hrasconn, HANDLE hEvent, DWORD dwFlags)
{
    DWORD dwRC = ERROR_DLL_NOT_FOUND;
    FARPROC fp = NULL;
    HINSTANCE hinst = NULL;

    if(hinst = LoadLibrary(TEXT("RASAPI32.DLL")))
#ifdef UNICODE
        if (fp = GetProcAddress(hinst,"RasConnectionNotificationW"))
#else
        if (fp = GetProcAddress(hinst,"RasConnectionNotificationA"))
#endif
            dwRC = ((PFNRASCONNECTIONNOTIFICATION)fp)(hrasconn, hEvent, dwFlags);

    if (hinst)
        FreeLibrary(hinst);

    return dwRC;
}

//+----------------------------------------------------------------------------
//    Function    IsConnectionClosed
//
//    Synopsis    Given a particular connection handle, determine if the
//                connection is still valid
//
//    Arguments    hrasconn - handle to the connection to be checked
//
//    Returns        TRUE - if the connection is closed
//
//    History        10/29/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL IsConnectionClosed(HRASCONN hrasconn)
{
    BOOL bRC = FALSE;
    LPRASCONN lprasconn = NULL;
    DWORD dwSize = 0;
    DWORD cConnections = 0;
    DWORD dwRet = 0;

    //
    // Make sure the DLL is loaded
    //
    if (!lpfnRasEnumConnections)
        if (!LoadRnaFunctions(NULL))
            goto IsConnectionClosedExit;

    //
    // Get list of current connections
    //
    lprasconn = (LPRASCONN)GlobalAlloc(GPTR,sizeof(RASCONN));
    if (!lprasconn)
        goto IsConnectionClosedExit;
    lprasconn->dwSize = dwSize = sizeof(RASCONN);
    cConnections = 0;

    dwRet = lpfnRasEnumConnections(lprasconn, &dwSize, &cConnections);
    if (ERROR_BUFFER_TOO_SMALL == dwRet)
    {
        GlobalFree(lprasconn);
        lprasconn = (LPRASCONN)GlobalAlloc(GPTR,dwSize);
        if (!lprasconn)
            goto IsConnectionClosedExit;
        lprasconn->dwSize = dwSize;
        dwRet = lpfnRasEnumConnections(lprasconn, &dwSize, &cConnections);
    }

    if (ERROR_SUCCESS != dwRet)
        goto IsConnectionClosedExit;

    //
    // Check to see if the handle matches
    //

    while (cConnections)
    {
        if (lprasconn[cConnections-1].hrasconn == hrasconn)
            goto IsConnectionClosedExit; // The connection is still open
        cConnections--;
    }
    bRC = TRUE;

IsConnectionClosedExit:
    if (lprasconn)
        GlobalFree(lprasconn);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Function    StartNTReconnectThread
//
//    Synopsis    This function will detect when the connection has been dropped
//                unexpectedly and it will then offer the user a chance to
//                reconnect
//
//    Arguments    hrasconn - the connection to be watched
//
//    Returns        none
//
//    History        10/29/96    ChrisK    Created
//-----------------------------------------------------------------------------
DWORD WINAPI StartNTReconnectThread (HRASCONN hrasconn)
{
    TCHAR szEntryName[RAS_MaxEntryName + 1];
    DWORD dwRC = 0;

    //
    // Validate state
    //
    if (NULL == hrasconn)
        goto StartNTReconnectThreadExit;
    if (TestControlFlags(SCF_RECONNECTTHREADQUITED) != FALSE)
        goto StartNTReconnectThreadExit;
    if (NULL != pDynShare->hReconnectEvent)
        goto StartNTReconnectThreadExit;

    //
    // Register Event
    //
    pDynShare->hReconnectEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    
    if (NULL  == pDynShare->hReconnectEvent)
        goto StartNTReconnectThreadExit;
    if (0 != SLRasConnectionNotification(hrasconn, pDynShare->hReconnectEvent,RASCN_Disconnection))
        goto StartNTReconnectThreadExit;

    //
    // Wait for event
    //
    do {
        dwRC = WaitForSingleObject(pDynShare->hReconnectEvent,CONNECT_CHECK_INTERVAL);
        if (WAIT_FAILED == dwRC)
        {
            DebugOut("ISIGN32: Quitting reconnect thread because wait failed.\r\n");
            goto StartNTReconnectThreadExit;
        }
    } while ((WAIT_TIMEOUT == dwRC) && !IsConnectionClosed(hrasconn));

    //
    // Clear values
    //
    hrasconn = NULL;

    CloseHandle(pDynShare->hReconnectEvent);
    pDynShare->hReconnectEvent = NULL;
    
    //
    //    Determine if we should offer to reconnect
    //
    if (FALSE != TestControlFlags(SCF_RECONNECTTHREADQUITED))
    {
        DebugOut("ISIGN32: Quitting reconnect thread because app is quitting.\r\n");
        goto StartNTReconnectThreadExit;
    }
    else if (FALSE == TestControlFlags(SCF_HANGUPEXPECTED))
    {
        DebugOut("ISIGN32: Reconnect thread will ask about reconnecting.\r\n");
        TCHAR szMsg[MAX_STRING + 1];

        //
        // Prompt user
        //
        LoadString(ghInstance,IDS_RECONNECT_QUERY,szMsg,SIZEOF_TCHAR_BUFFER(szMsg));
        if (IDYES == MessageBox(
                pDynShare->hwndMain,
                szMsg,
                cszAppName,
                MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_YESNO))
        {
            //
            // Reconnect
            //
             
            if (ERROR_USERNEXT != DialConnection(pDynShare->szISPFile))
            {
                DebugOut("ISIGN32: Quitting reconnect thread because user canceled dialing.\r\n");
                KillConnection();
                InfoMsg(NULL, IDS_SIGNUPCANCELLED);
                PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
                goto StartNTReconnectThreadExit;
            }

        }
        else
        {
            //
            // Forget it, we're out of here (close down signup)
            //
            KillConnection();
            InfoMsg(NULL, IDS_SIGNUPCANCELLED);
            PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
            DebugOut("ISIGN32: Quitting reconnect thread because user doesn't want to reconnect.\r\n");
            goto StartNTReconnectThreadExit;

        }
    }
StartNTReconnectThreadExit:
    return 1;
}

//+----------------------------------------------------------------------------
//    Function    IsSingleInstance and ReleaseSingleInstance
//
//    Synopsis    These two function check to see if another instance of isignup
//                is already running.  ISign32 does have to allow mutliple instances
//                to run in order to handle the .INS files, but in other instances
//                there should only be one copy running at a time
//
//    Arguments    bProcessingINS -- are we in the .ins path?
//
//    Returns        IsSingleInstance - TRUE - this is the first instance
//                ReleaseSingleInstance - none
//
//    History        11/1/96    ChrisK    Created
//                12/3/96    jmazner    Modified to allow the processINS path to create
//                                a semaphore (to prevent others from running),
//                                but to not check whether the create succeeded.
//-----------------------------------------------------------------------------

// superceded by definition in semaphor.h
//#define SEMAPHORE_NAME "Internet Connection Wizard ISIGNUP.EXE"
BOOL IsSingleInstance(BOOL bProcessingINS)
{
    g_hSemaphore = CreateSemaphore(NULL, 1, 1, ICW_ELSE_SEMAPHORE);
    DWORD dwErr = GetLastError();
    if( ERROR_ALREADY_EXISTS == dwErr )
    {
        g_hSemaphore = NULL;
        if( !bProcessingINS )
            IsAnotherComponentRunning32( NULL );
        return FALSE;
    }

    return TRUE;
}

void ReleaseSingleInstance()
{
    if (g_hSemaphore)
    {
        CloseHandle(g_hSemaphore);
        g_hSemaphore = NULL;
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsAnotherComponentRunning32()
//
//  Synopsis:   Checks if there's another ICW component already
//              running.  If so, it will set focus to that component's window.
//
//              This functionality is needed by all of our .exe's.  However,
//              the actual components to check for differ between .exe's.
//              The comment COMPONENT SPECIFIC designates lines of code
//              that vary between components' source code.
//
//              For ISIGN32, this function only gets called if we couldn't create
//              the ICW_ELSE semaphore, so all we need to do here is find the
//              other running ICW_ELSE component and bring it to the foreground.
//
//  Arguments:  bUnused -- not used in this component
//
//  Returns:    TRUE if another component is already running
//              FALSE otherwise
//
//  History:    12/3/96    jmazner    Created, with help from IsAnotherInstanceRunning
//                                    in icwconn1\connmain.cpp
//
//----------------------------------------------------------------------------
BOOL IsAnotherComponentRunning32(BOOL bUnused)
{

    HWND hWnd = NULL;
    HANDLE hSemaphore = NULL;
    DWORD dwErr = 0; 

    // for isignup, we only get here if we failed to create the ICW_ELSE semaphore
    // try and bring focus to the IE window if we have one
    if( pDynShare->hwndBrowser )
    {
        SetFocus(pDynShare->hwndBrowser);
        SetForegroundWindow(pDynShare->hwndBrowser);
    }
    else
    {
        // if that didn't work, try finding a conn2 or inetwiz instance
        // Bring the running instance's window to the foreground
        // if conn1 is running, we may accidentaly bring it to the foreground,
        // since it shares a window name with conn2 and inetwiz.  oh well.
        hWnd = FindWindow(DIALOG_CLASS_NAME, cszAppName);

        if( hWnd )
        {
            SetFocus(hWnd);
            SetForegroundWindow(hWnd);
        }
    }

    return TRUE;

/**
    if( hWnd || hwndBrowser )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
**/
}


#endif //!WIN16


#if !defined(WIN16)

//+----------------------------------------------------------------------------
//
//    Function    SetStartUpCommand
//
//    Synopsis    On an NT machine the RunOnce method is not reliable.  Therefore
//                we will restart the ICW by placing a .BAT file in the common
//                startup directory.
//
//    Arguments    lpCmd - command line used to restart the ICW
//
//    Returns        TRUE if it worked
//                FALSE otherwise.
//
//    History        1-10-97    ChrisK    Created
//
//-----------------------------------------------------------------------------
static const TCHAR cszICW_StartFileName[] = TEXT("ICWStart.bat");
static const TCHAR cszICW_StartCommand[] = TEXT("@start ");
static const TCHAR cszICW_DummyWndName[] = TEXT("\"ICW\" ");
static const TCHAR cszICW_ExitCommand[] = TEXT("\r\n@exit");

BOOL SetStartUpCommand(LPTSTR lpCmd)
{
    BOOL bRC = FALSE;
    HANDLE hFile = INVALID_HANDLE_VALUE ;
    DWORD dwWLen;    // dummy variable used to make WriteFile happy
    TCHAR szCommandLine[MAX_PATH + 1];
    LPITEMIDLIST lpItemDList = NULL;
    HRESULT hr = ERROR_SUCCESS;
    IMalloc *pMalloc = NULL;

    // build full filename
    // NOTE: the memory allocated for lpItemDList is leaked.  We are not real
    // concerned about this since this code is only run once and then the
    // system is restarted.  In order to free the memory appropriately
    // this code would have to call SHGetMalloc to retrieve the shell's IMalloc
    // implementation and then free the memory.
    hr = SHGetSpecialFolderLocation(NULL,CSIDL_COMMON_STARTUP,&lpItemDList);
    if (ERROR_SUCCESS != hr)
        goto SetStartUpCommandExit;

    if (FALSE == SHGetPathFromIDList(lpItemDList, szCommandLine))
        goto SetStartUpCommandExit;


    //
    // Free up the memory allocated for LPITEMIDLIST
    // because seems like we are clobberig something later
    // by not freeing this
    //
    hr = SHGetMalloc (&pMalloc);
    if (SUCCEEDED (hr))
    {
        pMalloc->Free (lpItemDList);
        pMalloc->Release ();
    }

    // make sure there is a trailing \ character
    if ('\\' != szCommandLine[lstrlen(szCommandLine)-1])
        lstrcat(szCommandLine,TEXT("\\"));
    lstrcat(szCommandLine,cszICW_StartFileName);

    // Open file
    hFile = CreateFile(szCommandLine,GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL |
        FILE_FLAG_WRITE_THROUGH,NULL);

    if (INVALID_HANDLE_VALUE == hFile)
        goto SetStartUpCommandExit;

    // Write the restart commands to the file
    if (FALSE == WriteFile(hFile,cszICW_StartCommand,lstrlen(cszICW_StartCommand),&dwWLen,NULL))
        goto SetStartUpCommandExit;
    // 1/20/96    jmazner Normandy #13287
    // Start command considers the first thing it sees in quotes to be a window title
    // So, since our path is in quotes, put in a fake window title
    if (FALSE == WriteFile(hFile,cszICW_DummyWndName,lstrlen(cszICW_DummyWndName),&dwWLen,NULL))
        goto SetStartUpCommandExit;
    if (FALSE == WriteFile(hFile,lpCmd,lstrlen(lpCmd),&dwWLen,NULL))
        goto SetStartUpCommandExit;
    if (FALSE == WriteFile(hFile,cszICW_ExitCommand,lstrlen(cszICW_ExitCommand),&dwWLen,NULL))
        goto SetStartUpCommandExit;

    bRC = TRUE;
SetStartUpCommandExit:
    // Close handle and exit
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    DeleteStartUpCommand
//
//    Synopsis:    After restart the ICW we need to delete the .bat file from
//                the common startup directory
//
//    Arguements: None
//
//    Returns:    None
//
//    History:    1-10-97    ChrisK    Created
//
//-----------------------------------------------------------------------------
void DeleteStartUpCommand ()
{
    TCHAR szStartUpFile[MAX_PATH + 1];
    LPITEMIDLIST lpItemDList = NULL;
    HRESULT hr = ERROR_SUCCESS;
    IMalloc *pMalloc = NULL;

    // build full filename
    // NOTE: the memory allocated for lpItemDList is leaked.  We are not real
    // concerned about this since this code is only run once and then the
    // system is restarted.  In order to free the memory appropriately
    // this code would have to call SHGetMalloc to retrieve the shell's IMalloc
    // implementation and then free the memory.
    hr = SHGetSpecialFolderLocation(NULL,CSIDL_COMMON_STARTUP,&lpItemDList);
    if (ERROR_SUCCESS != hr)
        goto DeleteStartUpCommandExit;

    if (FALSE == SHGetPathFromIDList(lpItemDList, szStartUpFile))
        goto DeleteStartUpCommandExit;

    //
    // Free up the memory allocated for LPITEMIDLIST
    // because seems like we are clobberig something later
    // by not freeing this
    //
    hr = SHGetMalloc (&pMalloc);
    if (SUCCEEDED (hr))
    {
        pMalloc->Free (lpItemDList);
        pMalloc->Release ();
    }


    // make sure there is a trailing \ character
    if ('\\' != szStartUpFile[lstrlen(szStartUpFile)-1])
        lstrcat(szStartUpFile,TEXT("\\"));
    lstrcat(szStartUpFile,cszICW_StartFileName);

    DeleteFile(szStartUpFile);
DeleteStartUpCommandExit:
    return;
}

#endif //!Win16

#ifdef WIN32
BOOL GetICWCompleted( DWORD *pdwCompleted )
{
    HKEY hKey = NULL;
    DWORD dwSize = sizeof(DWORD);

    HRESULT hr = RegOpenKey(HKEY_CURRENT_USER,ICWSETTINGSPATH,&hKey);
    if (ERROR_SUCCESS == hr)
    {
        hr = RegQueryValueEx(hKey, ICWCOMPLETEDKEY, 0, NULL,
                    (BYTE*)pdwCompleted, &dwSize);
        RegCloseKey(hKey);
    }

    if( ERROR_SUCCESS == hr )
        return TRUE;
    else
        return FALSE;

}

BOOL SetICWCompleted( DWORD dwCompleted )
{
    HKEY hKey = NULL;

    HRESULT hr = RegCreateKey(HKEY_CURRENT_USER,ICWSETTINGSPATH,&hKey);
    if (ERROR_SUCCESS == hr)
    {
        hr = RegSetValueEx(hKey, ICWCOMPLETEDKEY, 0, REG_DWORD,
                    (CONST BYTE*)&dwCompleted, sizeof(dwCompleted));
        RegCloseKey(hKey);
    }

    if( ERROR_SUCCESS == hr )
        return TRUE;
    else
        return FALSE;

}
#endif


#ifdef WIN32
//+----------------------------------------------------------------------------
//
//    Function:    CreateSecurityPatchBackup
//
//    Synopsis:    Creates a .reg file to restore security settings, and installs
//                the filenmae into the RunOnce reg keys.
//
//    Arguements: None
//
//    Returns:    None
//
//    History:    8/7/97    jmazner    Created for Olympus #6059
//
//-----------------------------------------------------------------------------
BOOL CreateSecurityPatchBackup( void )
{
    Dprintf("ISIGN32: CreateSecurityPatchBackup\n");

    HKEY hKey = NULL;
    TCHAR szPath[MAX_PATH + 1] = TEXT("\0");
    HANDLE hSecureRegFile = INVALID_HANDLE_VALUE;
    TCHAR szRegText[1024];
    TCHAR szRunOnceEntry[1024];
    DWORD dwBytesWritten = 0;


    if (0 == GetTempPath(MAX_PATH,szPath))
    {
        //
        // if GetTempPath Failed, use the current directory
        //
        if (0 == GetCurrentDirectory (MAX_PATH, szPath))
        {
            Dprintf("ISIGN32: unable to get temp path or current directory!\n");
            return FALSE;
        }
    }

    //
    // Get the name of the temporary file
    //
    if (0 == GetTempFileName(szPath, TEXT("hyjk"), 0, pDynShare->szFile))
    {
        //
        // If we failed, probably, the TMP directory does not
        // exist, we should use the current directory
        // MKarki (4/27/97) - Fix for Bug #3504
        //
        if (0 == GetCurrentDirectory (MAX_PATH, szPath))
        {
            return FALSE;
        }

        //
        // try getting the temp file name again
        //
        if (0 == GetTempFileName(szPath, TEXT("hyjk"), 0, pDynShare->szFile))
        {
            return FALSE;
        }
    }

    hSecureRegFile = CreateFile(pDynShare->szFile,
                                GENERIC_WRITE,
                                0, //no sharing
                                NULL, //no inheritance allowed
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                                NULL //no template file
                                );

    if (INVALID_HANDLE_VALUE == hSecureRegFile)
    {
        Dprintf("ISIGN32: unable to createFile secureRegFile %s\n", pDynShare->szFile);
        return FALSE;
    }
    else
    {
        Dprintf("ISIGN32: writing secureRegFile %s\n",pDynShare->szFile );
        ZeroMemory( szRegText, 1023 );
        dwBytesWritten = 0;
        lstrcpy(szRegText, TEXT("REGEDIT4\n\n"));
        lstrcat(szRegText, TEXT("[HKEY_CLASSES_ROOT\\.ins]\n"));
        lstrcat(szRegText, TEXT("\"EditFlags\"=hex:00,00,00,00\n\n"));
        lstrcat(szRegText, TEXT("[HKEY_CLASSES_ROOT\\.isp]\n"));
        lstrcat(szRegText, TEXT("\"EditFlags\"=hex:00,00,00,00\n\n"));
        lstrcat(szRegText, TEXT("[HKEY_CLASSES_ROOT\\x-internet-signup]\n"));
        lstrcat(szRegText, TEXT("\"EditFlags\"=hex:00,00,00,00\n\n"));

        //
        // ChrisK Olympus 6198 6/10/97
        //
        lstrcat(szRegText, TEXT("[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\3]\n"));
        lstrcat(szRegText, TEXT("\"1601\"=dword:"));
        TCHAR szZoneSetting[16];
        wsprintf(szZoneSetting,TEXT("%08x\n\n"),g_dwZone_1601);
        lstrcat(szRegText, szZoneSetting);

        WriteFile(hSecureRegFile, (LPVOID) &szRegText[0], lstrlen(szRegText),
                    &dwBytesWritten, NULL );

        CloseHandle(hSecureRegFile);
        hSecureRegFile = INVALID_HANDLE_VALUE;

        Dprintf("ISIGN32: installing security RunOnce entry\n");
        ZeroMemory(szRunOnceEntry, 1023 );
        wsprintf(szRunOnceEntry, TEXT("regedit /s \"%s\""), pDynShare->szFile);
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),&hKey))
        {
            RegSetValueEx(hKey,TEXT("hyjk"),(DWORD)NULL,(DWORD)REG_SZ,
                            (BYTE*)szRunOnceEntry,sizeof(TCHAR)*lstrlen(szRunOnceEntry));
            RegCloseKey(hKey);
            hKey = NULL;
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function:    RestoreSecurityPatch
//
//    Synopsis:    Reset the EditFlags for our file types to indicate that these
//                files are not safe.  Remove the runOnce we set as a backup.
//
//    Arguements: None
//
//    Returns:    None
//
//    History:    3/11/97    jmazner     created for Olympus #1545
//
//-----------------------------------------------------------------------------
VOID RestoreSecurityPatch( void )
{
    HKEY hKey = NULL;
    TCHAR szTemp[4];

    hKey = NULL;
    szTemp[0] = (TCHAR)0;
    szTemp[1] = (TCHAR)0;
    szTemp[2] = (TCHAR)0;
    szTemp[3] = (TCHAR)0;

    Dprintf("ISIGN32: Restoring EditFlags settings\n");

    // Mark various registry entries as unsafe.
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT,TEXT("x-internet-signup"),&hKey))
    {
        RegSetValueEx(hKey,TEXT("EditFlags"),(DWORD)NULL,(DWORD)REG_BINARY,(BYTE*)&szTemp[0],(DWORD)4);
        RegCloseKey(hKey);
    }
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT,TEXT(".ins"),&hKey))
    {
        RegSetValueEx(hKey,TEXT("EditFlags"),(DWORD)NULL,(DWORD)REG_BINARY,(BYTE*)&szTemp[0],(DWORD)4);
        RegCloseKey(hKey);
    }
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT,TEXT(".isp"),&hKey))
    {
        RegSetValueEx(hKey,TEXT("EditFlags"),(DWORD)NULL,(DWORD)REG_BINARY,(BYTE*)&szTemp[0],(DWORD)4);
        RegCloseKey(hKey);
    }

    //
    // ChrisK Olympus 6198 6/10/97
    // replace HTML form submission value.
    //
    if (g_fReadZone &&
        ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,REG_ZONE3_KEY,&hKey))
    {
        //
        // Set value for zone to initial value.
        //
        RegSetValueEx(hKey,
                        REG_ZONE1601_KEY,
                        NULL,
                        REG_DWORD,
                        (LPBYTE)&g_dwZone_1601,
                        sizeof(g_dwZone_1601));
        RegCloseKey(hKey);
    }

    // Remove run once key
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,TEXT("Software\\microsoft\\Windows\\CurrentVersion\\RunOnce"),&hKey))
    {
        RegDeleteValue(hKey,TEXT("hyjk"));
        RegCloseKey(hKey);
    }
     
    // Remove reg file
    DeleteFile(pDynShare->szFile);

}
#endif

#ifdef WIN32
//++--------------------------------------------------------------
//
//  Function:   RemoveQuotes
//
//  Synopsis:   This  Function strips the file name in the command
//              line of its quote
//              Fix For Bug #4049
//
//  Arguments:  [IN] PTSTR - pointer to command line
//
//  Returns:    VOID
//
//  Called By:  Signup Function
//
//  History:    MKarki      Created     5/1/97
//
//----------------------------------------------------------------
VOID
RemoveQuotes (
    LPTSTR   pCommandLine
    )
{
    const TCHAR  QUOTE = '"';
    const TCHAR  SPACE = ' ';
    const TCHAR  NIL   = '\0';
    TCHAR * pTemp =  NULL;


    if (NULL == pCommandLine)
        return;

    //
    //  find the starting quote first
    //  do we care for MBCS/UNICODE ?
    //
    pTemp = _tcschr  (pCommandLine, QUOTE);
    if (NULL != pTemp)
    {
        //
        //  replace the quote with a space
        //
        *pTemp = SPACE;

        //
        //  search for the ending quote now
        //
        pTemp = _tcsrchr (pCommandLine, QUOTE);
        if (NULL != pTemp)
        {
            //
            // end the string here
            //
            *pTemp = NIL;
        }

    }

    return;

}   // end of RemoveQuotes function

#endif


//++--------------------------------------------------------------
//
//  Function:   IEAKProcessISP
//
//  Synopsis:   A hacked version of ProcessISP, intended for use
//                by the IEAK folks.  The function will create a
//                connectoid and establish a connection in the same
//                manner as ProcsesISP.  However, once the connection
//                is established, we will execute the command in the
//                [Entry] Run= section and exit
//
//                This function does _not_ wait around for the
//                .exe that it launches, and thus does _not_ kill the
//                dial-up connection.  It's up to the calling app to
//                worry about that.
//
//  Arguments:  [IN] hwnd - handle of parent window
//                [IN] LPCTSTR - pointer to path to .isp file
//
//  Returns:    TRUE if able to create the connectoid and dial
//                FALSE otherwise
//
//
//  History:    5/23/97    jmazner    Created for Olympus #4679
//
//----------------------------------------------------------------

#ifdef WIN16
extern "C" BOOL WINAPI __export IEAKProcessISP(HWND hwnd, LPCTSTR lpszFile)
#else
#ifdef UNICODE
BOOL EXPORT WINAPI IEAKProcessISPW(HWND, LPCTSTR);
BOOL EXPORT WINAPI IEAKProcessISPA
(
    HWND hwnd,
    LPCSTR lpszFile
)
{
    TCHAR szFile[MAX_PATH+1];

    mbstowcs(szFile, lpszFile, lstrlenA(lpszFile)+1);
    return IEAKProcessISPW(hwnd, szFile);
}

BOOL EXPORT WINAPI IEAKProcessISPW
#else
BOOL EXPORT WINAPI IEAKProcessISPA
#endif
(
    HWND hwnd,
    LPCTSTR lpszFile
)
#endif
{

    TCHAR  szSignupURL[MAX_URL + 1];
#if !defined(WIN16)
    HKEY hKey;
    GATHEREDINFO gi;
#endif //!WIN16

#if !defined(WIN16)
        if (!IsSingleInstance(FALSE))
            return FALSE;
#endif

    if (!LoadInetFunctions(hwnd))
    {
        Dprintf("ISIGN32: IEAKProcessISP couldn't load INETCFG.DLL!");

        return FALSE;
    }


#if !defined(WIN16)
    // Make sure the isp file exists before setting up stack.
    if (0xFFFFFFFF == GetFileAttributes(lpszFile))
    {
        DWORD dwFileErr = GetLastError();
        Dprintf("ISIGN32: ProcessISP couldn't GetAttrib for %s, error = %d",
            lpszFile, dwFileErr);
        if( ERROR_FILE_NOT_FOUND == dwFileErr )
        {
            ErrorMsg1(hwnd, IDS_INVALIDCMDLINE, lpszFile);
        }

        ErrorMsg(hwnd, IDS_BADSIGNUPFILE);
        return FALSE;
    }
#endif

    // Configure stack if not already configured.
    // If this requires a restart, we're in trouble, so
    // just return FALSE.

#ifdef SETUPSTACK
 
    if (!TestControlFlags(SCF_SYSTEMCONFIGURED))
    {
        DWORD dwRet;
        BOOL  fNeedsRestart = FALSE;

        dwRet = lpfnInetConfigSystem(
            hwnd,
            INETCFG_INSTALLRNA |
            INETCFG_INSTALLTCP |
            INETCFG_INSTALLMODEM |
            INETCFG_SHOWBUSYANIMATION |
            INETCFG_REMOVEIFSHARINGBOUND,
            &fNeedsRestart);

        if (ERROR_SUCCESS == dwRet)
        {
            SetControlFlags(SCF_SYSTEMCONFIGURED);
            
            InstallScripter();

            if (fNeedsRestart)
            {
                Dprintf("ISIGN32: IEAKProcessISP needs to restart!");
                return FALSE;
            }
        }
        else
        {
            ErrorMsg(hwnd, IDS_INSTALLFAILED);

            return FALSE;
        }
    }

    if (!VerifyRasServicesRunning(hwnd))
        return FALSE;
#endif

    // kill the old connection
    KillConnection();

    // Create a new connectoid and set the autodial
    if (ERROR_SUCCESS != CreateConnection(lpszFile))
    {
        ErrorMsg(hwnd, IDS_BADSIGNUPFILE);
        return FALSE;
    }

#ifndef WIN16
    //
    // Dial connectoid
    //
    if (ERROR_USERNEXT != DialConnection(lpszFile))
    {
        Dprintf("ISIGN32: IEAKProcessISP unable to DialConnection!");
        return FALSE;
    }
#endif

    if (GetPrivateProfileString(cszEntrySection,
                                cszRun,
                                szNull,
                                pDynShare->szRunExecutable,
                                SIZEOF_TCHAR_BUFFER(pDynShare->szRunExecutable),
                                lpszFile) != 0)
    {
        
        GetPrivateProfileString(cszEntrySection,
                                cszArgument,
                                szNull,
                                pDynShare->szRunArgument,
                                SIZEOF_TCHAR_BUFFER(pDynShare->szRunArgument),
                                lpszFile);

        if (RunExecutable(FALSE) != ERROR_SUCCESS)
        {
            // make sure the connection is closed
            KillConnection();
            ErrorMsg1(NULL, IDS_EXECFAILED, pDynShare->szRunExecutable);
            return FALSE;
        }
    }


    DeleteConnection();

    UnloadInetFunctions();
    
#if !defined(WIN16)
    ReleaseSingleInstance();
#endif

    return( TRUE );
}

#ifdef WIN16

CHAR* GetPassword()
{
     
    return pDynShare->szPassword;
    
}

#else

TCHAR* GetPassword()
{ 
    return pDynShare->szPassword;
}

BOOL IsRASReady()
{ 
    return TestControlFlags(SCF_RASREADY);
}

#endif


BOOL IsCurrentlyProcessingISP()
{
#if !defined(WIN16)
    return TestControlFlags(SCF_ISPPROCESSING);
#else
    return FALSE;
#endif
}

BOOL NeedBackupSecurity()
{
#if !defined(WIN16)
    return TestControlFlags(SCF_NEEDBACKUPSECURITY);
#else
    return FALSE;
#endif
}

HWND GetHwndMain()
{
    return pDynShare->hwndMain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\splash.cpp ===
/**************
 *
 * THIS ENTIRE FILE HAS BEEN COMMENTED OUT
 *
 * 8/16/96 jmazner Normandy #4593
 * The sole purpose of this file is to stick up a full screen window with the background color.
 * It was (apparently) originaly intended to eliminate any desktop icons/clutter, but has since
 * become known as the screen o' death and RAIDed as a bug.
 *
    

#include "isignup.h"

static char cszSplash[] = "Internet Signup Splash";

long EXPORT FAR PASCAL SplashProc (HWND, UINT, UINT, LONG) ;

HWND SplashInit(HWND hwndParent)
{
    HWND        hwnd ;
    WNDCLASS    wndclass ;
#ifdef WIN32
    RECT        rect ;
#endif

    wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
    wndclass.lpfnWndProc   = SplashProc ;
    wndclass.cbClsExtra    = 0 ;
    wndclass.cbWndExtra    = 0 ;
    wndclass.hInstance     = ghInstance ;
    wndclass.hIcon         = NULL ;
    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
    wndclass.hbrBackground = (HBRUSH)(COLOR_BACKGROUND + 1);
    wndclass.lpszMenuName  = NULL ;
    wndclass.lpszClassName = cszSplash ;

    RegisterClass (&wndclass) ;

    hwnd = CreateWindow (cszSplash,        // window class name
                  cszAppName,              // window caption
                  WS_POPUP,                // window style
                  CW_USEDEFAULT,           // initial x position
                  CW_USEDEFAULT,           // initial y position
                  CW_USEDEFAULT,           // initial x size
                  CW_USEDEFAULT,           // initial y size
                  hwndParent,              // parent window handle
                  NULL,                    // window menu handle
                  ghInstance,              // program instance handle
                  NULL) ;                  // creation parameters


#ifdef WIN32
    // these were added as per ChrisK's instructions
    SystemParametersInfo(SPI_GETWORKAREA,0,(PVOID)&rect,0);
    MoveWindow(hwnd,rect.left,rect.top,rect.right-rect.left,rect.bottom-rect.top,FALSE);
    ShowWindow(hwnd,SW_NORMAL);
#else
    ShowWindow(hwnd,SW_MAXIMIZE);
#endif

    UpdateWindow(hwnd);

    return hwnd;
}

long EXPORT FAR PASCAL SplashProc (
        HWND hwnd,
        UINT message,
        UINT wParam,
        LONG lParam)
{
    switch (message)
    {
        case WM_MOUSEACTIVATE:
            return MA_NOACTIVATEANDEAT;

        default:
            break;
    }

    return DefWindowProc (hwnd, message, wParam, lParam) ;
}


*
*
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isignup\isignup.h ===
#include <windows.h>
#include <locale.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isignup\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

MAJORCOMP=GETCONN
MINORCOMP=ISIGNUP

TARGETNAME=ISIGNUP
TARGETTYPE=PROGRAM
TARGETPATH=obj
UMTYPE=windows
UMENTRY=winmain

NOT_LEAN_AND_MEAN=1
RCNOFONTMAP=1
C_DEFINES = -DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT40=1

SOURCES= \
    ..\isignup.rc   \
    ..\isignupx.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\kernel32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isignup\isignupx.cpp ===
//****************************************************************************
//
//  Module:     ISIGNUP.EXE
//  File:       isignupx.c
//  Content:    This is the "main" file for the internet signup "wizard".
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "isignup.h"

#ifndef EXPORT
#ifdef WIN32
#define EXPORT
#else
#define EXPORT _export
#endif
#endif


typedef int (WINAPI * SIGNUP)
        (HANDLE hInstance, HANDLE hPrevInstance,
        LPTSTR lpszCmdLine, int nCmdShow);

CHAR szSignup[] = "Signup";
#ifdef WIN32
TCHAR szSignupDll[] = TEXT("isign32.dll");
#else
char szSignupDll[] = "isign16.dll";
#endif

int EXPORT WINAPI Signup(HANDLE hInstance, HANDLE hPrevInstance,
                   LPTSTR lpszCmdLine, int nCmdShow);

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpszCmdLine, int nCmdShow)
{
    HINSTANCE hLib;
    SIGNUP lpfnSignup;
    int iRet = 0;
    
#ifdef UNICODE
    // Initialize the C runtime locale to the system locale.
    setlocale(LC_ALL, "");
#endif

    hLib = LoadLibrary(szSignupDll);
    if (NULL != hLib)
    {
        lpfnSignup = (SIGNUP)GetProcAddress(hLib, szSignup);
        if (NULL != lpfnSignup)
        {
#ifdef UNICODE
            TCHAR szCmdLineTmp[256];
            if(lpszCmdLine)
                mbstowcs(szCmdLineTmp, lpszCmdLine, 256);
            iRet = lpfnSignup(hInstance, hPrevInstance, szCmdLineTmp, nCmdShow);
#else
            iRet = lpfnSignup(hInstance, hPrevInstance, lpszCmdLine, nCmdShow);
#endif
        }
        FreeLibrary(hLib);
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\utils.cpp ===
#include "isignup.h"

#ifndef MB_ICONERROR
#define MB_ICONERROR        MB_ICONHAND
#endif
#ifndef MB_SETFOREGROUND
#define MB_SETFOREGROUND    0
#endif
#define MAX_STRING      256
                             
static const HWND hwndNil = NULL;

BOOL WarningMsg(HWND hwnd, UINT uId)
{
    TCHAR szMsg[MAX_STRING + 1];

    LoadString(
            ghInstance,
            uId,
            szMsg,
            SIZEOF_TCHAR_BUFFER(szMsg));

    return (MessageBox(
            hwnd,
            szMsg,
            cszAppName,
            MB_SETFOREGROUND |
            MB_ICONEXCLAMATION |
            MB_OKCANCEL) == IDOK);
}

void ErrorMsg(HWND hwnd, UINT uId)
{
    TCHAR szMsg[MAX_STRING + 1];

    LoadString(
            ghInstance,
            uId,
            szMsg,
            SIZEOF_TCHAR_BUFFER(szMsg));

    MessageBox(
            hwnd,
            szMsg,
            cszAppName,
            MB_SETFOREGROUND |
            MB_ICONERROR |
            MB_OK);
}

void ErrorMsg1(HWND hwnd, UINT uId, LPCTSTR lpszArg)
{
    TCHAR szTemp[MAX_STRING + 1];
    TCHAR szMsg[MAX_STRING + 1];

    LoadString(
            ghInstance,
            uId,
            szTemp,
            SIZEOF_TCHAR_BUFFER(szTemp));

    wsprintf(szMsg, szTemp, lpszArg);

    MessageBox(
            hwnd,
            szMsg,
            cszAppName,
            MB_SETFOREGROUND |
            MB_ICONERROR |
            MB_OK);
}

void InfoMsg(HWND hwnd, UINT uId)
{
    TCHAR szMsg[MAX_STRING];

    LoadString(
            ghInstance,
            uId,
            szMsg,
            SIZEOF_TCHAR_BUFFER(szMsg));

    MessageBox(
            hwnd,
            szMsg,
            cszAppName,
            MB_SETFOREGROUND |
            MB_ICONINFORMATION |
            MB_OK);
}

int PromptR(HWND hwnd, UINT uId, UINT uType)
{
    TCHAR szMsg[MAX_STRING + 1];
    TCHAR szCaption[MAX_STRING + 1];

    LoadString(
            ghInstance,
            uId,
            szMsg,
            SIZEOF_TCHAR_BUFFER(szMsg));

    LoadString(
            ghInstance,
            IDS_SETTINGCHANGE,
            szCaption,
            SIZEOF_TCHAR_BUFFER(szCaption));

    return MessageBox(
            hwnd,
            szMsg,
            szCaption,
            uType);
}

 

BOOL PromptRestart(HWND hwnd)
{
    return (PromptR(
            hwnd,
            IDS_RESTART,
            MB_SETFOREGROUND |
            MB_ICONQUESTION |
            MB_YESNO) == IDYES);
}

BOOL PromptRestartNow(HWND hwnd)
{
    return (PromptR(
            hwnd,
            IDS_RESTARTNOW,
            MB_SETFOREGROUND |
            MB_ICONINFORMATION |
            MB_OKCANCEL) == IDOK);
}

/*  C E N T E R  W I N D O W */
/*-------------------------------------------------------------------------
    %%Function: CenterWindow

    Center a window over another window.
-------------------------------------------------------------------------*/
VOID CenterWindow(HWND hwndChild, HWND hwndParent)
{
    int   xNew, yNew;
    int   cxChild, cyChild;
    int   cxParent, cyParent;
    int   cxScreen, cyScreen;
    RECT  rcChild, rcParent;
    HDC   hdc;

    // Get the Height and Width of the child window
    GetWindowRect(hwndChild, &rcChild);
    cxChild = rcChild.right - rcChild.left;
    cyChild = rcChild.bottom - rcChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect(hwndParent, &rcParent);
    cxParent = rcParent.right - rcParent.left;
    cyParent = rcParent.bottom - rcParent.top;

    // Get the display limits
    hdc = GetDC(hwndChild);
    if (hdc == NULL) {
        // major problems - move window to 0,0
        xNew = yNew = 0;
    } else {
        cxScreen = GetDeviceCaps(hdc, HORZRES);
        cyScreen = GetDeviceCaps(hdc, VERTRES);
        ReleaseDC(hwndChild, hdc);

        if (hwndParent == hwndNil) {
            cxParent = cxScreen;
            cyParent = cyScreen;
            SetRect(&rcParent, 0, 0, cxScreen, cyScreen);
        }

        // Calculate new X position, then adjust for screen
        xNew = rcParent.left + ((cxParent - cxChild) / 2);
        if (xNew < 0) {
            xNew = 0;
        } else if ((xNew + cxChild) > cxScreen) {
            xNew = cxScreen - cxChild;
        }

        // Calculate new Y position, then adjust for screen
        yNew = rcParent.top  + ((cyParent - cyChild) / 2);
        if (yNew < 0) {
            yNew = 0;
        } else if ((yNew + cyChild) > cyScreen) {
            yNew = cyScreen - cyChild;
        }

    }

    SetWindowPos(hwndChild, NULL, xNew, yNew,   0, 0,
        SWP_NOSIZE | SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\isign32\strings.inc ===
STRINGTABLE
BEGIN
	IDS_APP_TITLE       "Internet Connection Wizard"
	IDS_VERSION         "Internet Connection Wizard (Version 0.1)"
	IDS_DESCRIPTION     "Internet Connection Wizard Application"
END

STRINGTABLE
BEGIN
	IDS_INVALIDCMDLINE  "Invalid command line '%s'."
	IDS_NOCMDLINE       "The sign-up portion of the Internet Connection Wizard cannot be started using  'ISIGNUP.EXE'. To start the Internet Connection Wizard, click the Connection Wizard icon on the Start menu."
	IDS_INVALIDFILETYPE "'%s' is not a file type that can be processed by the Internet Connection Wizard."
	IDS_CANNOTPROCESSINS "Unable to process the Internet Signup file."
    IDS_SIGNUPCANCELLED "Internet Signup has been canceled."
    IDS_LAUNCHFAILED    "Could not launch Internet Explorer.\n\nPlease verify that Internet Explorer is installed."
    IDS_INSTALLFAILED   "The Internet Connection Wizard could not configure your computer for the Internet.\n\nYou will need to manually set up your own TCP/IP protocols, Dial-Up Networking, and modem, ISDN line, or other device you use to dial out from your computer."
    IDS_BADSETTINGS     "Received corrupted Internet Signup parameters.  Internet Signup has been canceled."
    IDS_RESTART         "You must restart your computer before the new settings will take effect.\n\nDo you want to restart your computer now?"
    IDS_RESTARTNOW      "You must restart your computer now for the new settings to take effect.\n\nIf you select Cancel, the signup process will be terminated."
    IDS_SETTINGCHANGE   "Systems Setting Change"
#ifdef WIN32
    IDS_SIGNUPCOMPLETE  "You are ready to connect to the Internet.\n\nTo continue, double click the Internet Explorer icon on your desktop."
#else
    IDS_SIGNUPCOMPLETE  "You are ready to connect to the Internet.\n\nTo continue, double click the Internet Explorer icon in the Program Manager."
#endif
    IDS_EXECFAILED      "Failed to execute %s.\n\nInternet Signup has been canceled."
	IDS_INSFILEWARNING	"Warning you are about to change your Internet settings.\n\nIf you wish to continue click OK, else click Cancel."
	IDS_BADSIGNUPFILE   "Internet Signup file is corrupt.  Signup aborted."
    IDS_MISSINGCFGDLL   "Unable to load the Internet Configuration library (INETCFG.DLL)."
    IDS_MISSINGRNADLL   "Unable to load the Remote Network Access library (RASAPI32.DLL)."
    IDS_WRONGRNADLLVER  "The Remote Network Access library (RASAPI32) is not the correct version. You may need a different version of Windows."
	IDS_PASSWORD		"Please record the following information for future use.\n\nAccount Name:  %s\nPassword:  %s"
	IDS_LOGONMESSAGE    "You must logon to retrieve your cached Internet password."
	IDS_LOGONCAPTION    "User Logon"
	IDS_SIGNUPLOGON     "You must logon to continue with the signup process."
    IDS_BROWSERTERMINATED "Internet Signup has been canceled."
    IDS_BROWSERNEVERFOUND "Internet Explorer window can not be found.\n\nInternet Signup has been canceled."
	IDS_INVALIDURL		"%s is not a valid URL or does not exist."
	IDS_INVALIDNOURL	"The specified URL is empty."
	IDS_MAILFAILED		"Could not install Windows Messaging and Internet Mail. You will need to install this before you can use Internet Mail services. Please contact your provider for assistance."
	IDS_ISP_DIAL_MESSAGE	"The Internet Connection Wizard will now connect to your Internet service provider."
	IDS_MISSINGIE		"The Internet Connection Wizard cannot continue because Internet Explorer is not properly installed.\n\nPlease install Internet Explorer and try again."

	IDS_IELOWVERSION	"The Internet Connection Wizard cannot continue because the version of Internet Explorer installed on your machine is not supported.\n\nPlease install Internet Explorer version %s or greater."
	// Localizers, please also see the corresponding version number string defined as IE_MINIMUM_VERSION_HUMAN_READABLE in isign32/isignup.h	
	IDS_SERVICEDISABLED "The Internet Connection Wizard could not start the RAS services and therefore cannot continue.  Please check the services control panel to make sure these services were installed properly and they are not disabled."
	IDS_RECONNECT_QUERY	"The modem connection has been interrupted.  The Internet Connection Wizard cannot proceed without this connection.  Do you want to reconnect?"

	IDS_SBSCFGERROR "Your small business server cannot process your Internet service information.  Contact your Internet service provider for help."
	IDS_ISPBROWSEFAIL   "The signup up for the service provider is temporarily unavailable.  Try again later or select a different service provider."
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\lib\debug.c ===
//
// Debug squirty functions
//

#include "proj.h"
#pragma  hdrstop

#if defined(DEBUG) || defined(PRODUCT_PROF)
// (c_szCcshellIniFile and c_szCcshellIniSecDebug are declared in debug.h)
extern CHAR const FAR c_szCcshellIniFile[];
extern CHAR const FAR c_szCcshellIniSecDebug[];

/*----------------------------------------------------------
Purpose: Special verion of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *piRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number

Cond:    --
*/
static
BOOL
MyStrToIntExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
    {
    #define IS_DIGIT(ch)    InRange(ch, '0', '9')

    BOOL bRet;
    int n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == ' ' || *psz == '\n' || *psz == '\t'; psz = CharNextA(psz))
        ;

    // Determine possible explicit signage
    //
    if (*psz == '+' || *psz == '-')
        {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz++;
        }

    // Or is this hexadecimal?
    //
    pszAdj = CharNextA(psz);
    if ((STIF_SUPPORT_HEX & dwFlags) &&
        *psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
        {
        // Yes

        // (Never allow negative sign with hexadecimal numbers)
        bNeg = FALSE;
        psz = CharNextA(pszAdj);

        pszAdj = psz;

        // Do the conversion
        //
        for (n = 0; ; psz = CharNextA(psz))
            {
            if (IS_DIGIT(*psz))
                n = 0x10 * n + *psz - '0';
            else
                {
                CHAR ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }
    else
        {
        // No
        pszAdj = psz;

        // Do the conversion
        for (n = 0; IS_DIGIT(*psz); psz = CharNextA(psz))
            n = 10 * n + *psz - '0';

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }

    *piRet = bNeg ? -n : n;

    return bRet;
    }

#endif

#ifdef DEBUG

DWORD g_dwDumpFlags     = 0;        // DF_*
#ifdef FULL_DEBUG
DWORD g_dwBreakFlags    = BF_ONVALIDATE;        // BF_*
#else
DWORD g_dwBreakFlags    = 0;        // BF_*
#endif
DWORD g_dwTraceFlags    = 0;        // TF_*
DWORD g_dwPrototype     = 0;        
DWORD g_dwFuncTraceFlags = 0;       // FTF_*

// TLS slot used to store depth for CcshellFuncMsg indentation

static DWORD g_tlsStackDepth = TLS_OUT_OF_INDEXES;

// Hack stack depth counter used when g_tlsStackDepth is not available

static DWORD g_dwHackStackDepth = 0;

static char g_szIndentLeader[] = "                                                                                ";

static WCHAR g_wszIndentLeader[] = L"                                                                                ";


#pragma data_seg(DATASEG_READONLY)

static CHAR const FAR c_szNewline[] = "\r\n";   // (Deliberately CHAR)
static WCHAR const FAR c_wszNewline[] = TEXTW("\r\n");

#pragma data_seg()

extern CHAR const FAR c_szTrace[];              // (Deliberately CHAR)
extern CHAR const FAR c_szErrorDbg[];           // (Deliberately CHAR)
extern CHAR const FAR c_szWarningDbg[];         // (Deliberately CHAR)
extern WCHAR const FAR c_wszTrace[];
extern WCHAR const FAR c_wszErrorDbg[]; 
extern WCHAR const FAR c_wszWarningDbg[];

extern const CHAR  FAR c_szAssertMsg[];
extern CHAR const FAR c_szAssertFailed[];
extern const WCHAR  FAR c_wszAssertMsg[];
extern WCHAR const FAR c_wszAssertFailed[];


void
SetPrefixStringA(
    OUT LPSTR pszBuf,
    IN  DWORD dwFlags)
{
    if (TF_ALWAYS == dwFlags)
        lstrcpyA(pszBuf, c_szTrace);
    else if (IsFlagSet(dwFlags, TF_WARNING))
        lstrcpyA(pszBuf, c_szWarningDbg);
    else if (IsFlagSet(dwFlags, TF_ERROR))
        lstrcpyA(pszBuf, c_szErrorDbg);
    else
        lstrcpyA(pszBuf, c_szTrace);
}


void
SetPrefixStringW(
    OUT LPWSTR pszBuf,
    IN  DWORD  dwFlags)
{
    if (TF_ALWAYS == dwFlags)
        lstrcpyW(pszBuf, c_wszTrace);
    else if (IsFlagSet(dwFlags, TF_WARNING))
        lstrcpyW(pszBuf, c_wszWarningDbg);
    else if (IsFlagSet(dwFlags, TF_ERROR))
        lstrcpyW(pszBuf, c_wszErrorDbg);
    else
        lstrcpyW(pszBuf, c_wszTrace);
}


// Hack!  The MSDEV debugger has some smarts where if it sees
// an ASSERT (all caps) in the source, and there is a debug break,
// then it sticks up a sorta friendly assert message box.
// For the debug function below where the break occurs inside,
// we add a nop ASSERT line in here to fake MSDEV to give us
// a friendly message box.

#undef ASSERT
#define ASSERT(f)   DEBUG_BREAK



// BUGBUG (scotth): Use the Ccshell functions.  _AssertMsg and
// _DebugMsg are obsolete.  They will be removed once all the 
// components don't have TEXT() wrapping their debug strings anymore.


void 
WINCAPI 
_AssertMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyA(ach, c_szAssertMsg);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);

        wvsprintfA(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
            ASSERT(0);
    }
}

void 
WINCAPI 
_AssertMsgW(
    BOOL f, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyW(ach, c_wszAssertMsg);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        wvsprintfW(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringW(ach);

        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
            ASSERT(0);
    }
}

void 
_AssertStrLenW(
    LPCWSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenW(pszStr))
    {                                           
        ASSERT(0);
    }
}

void 
_AssertStrLenA(
    LPCSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenA(pszStr))
    {                                           
        ASSERT(0);
    }
}

void 
WINCAPI 
_DebugMsgA(
    DWORD flag, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        SetPrefixStringA(ach, flag);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);

        try
        {
            wvsprintfA(&ach[cch], pszMsg, vArgs);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringA(pszMsg);
        }

        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            DEBUG_BREAK;
        }
    }
}

void 
WINCAPI 
_DebugMsgW(
    DWORD flag, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        SetPrefixStringW(ach, flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        try
        {
            wvsprintfW(&ach[cch], pszMsg, vArgs);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringW(pszMsg);
        }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            DEBUG_BREAK;
        }
    }
}


//
//  Smart debug functions
//



/*----------------------------------------------------------
Purpose: Displays assertion string.

Returns: TRUE to debugbreak
Cond:    --
*/
BOOL
CDECL
CcshellAssertFailedA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];

    // Strip off path info from filename string, if present.
    //
    for (psz = pszFile + lstrlenA(pszFile); psz != pszFile; psz=CharPrevA(pszFile, psz))
    {
        if ((CharPrevA(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
            break;
    }
    wsprintfA(ach, c_szAssertFailed, psz, line, pszEval);
    OutputDebugStringA(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
    {
        if (bBreakInside)
        {
            // See the hack we have above about redefining ASSERT
            ASSERT(0);
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays assertion string.

Returns: --
Cond:    --
*/
BOOL
CDECL
CcshellAssertFailedW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[256];

    // Strip off path info from filename string, if present.
    //
    for (psz = pszFile + lstrlenW(pszFile); psz && (psz != pszFile); psz=CharPrevW(pszFile, psz))
    {
        if ((CharPrevW(pszFile, psz)!= (psz-2)) && *(psz - 1) == TEXT('\\'))
            break;
    }

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  We can get this
    // if we get an assert in some of the W functions in shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellAssertFailedA(szFile, line, szEval, bBreakInside);
    }

    wsprintfW(ach, c_wszAssertFailed, psz, line, pszEval);
    OutputDebugStringW(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
    {
        if (bBreakInside)
        {
            // See the hack we have above about redefining ASSERT
            ASSERT(0);
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Keep track of the stack depth for function call trace
         messages.

Returns: --
Cond:    --
*/
void
CcshellStackEnter(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = (DWORD)((DWORD_PTR)TlsGetValue(g_tlsStackDepth));

        TlsSetValue(g_tlsStackDepth, (LPVOID)((DWORD_PTR)dwDepth + 1));
        }
    else
        {
        g_dwHackStackDepth++;
        }
    }


/*----------------------------------------------------------
Purpose: Keep track of the stack depth for functionc all trace
         messages.

Returns: --
Cond:    --
*/
void
CcshellStackLeave(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = (DWORD)((DWORD_PTR)TlsGetValue(g_tlsStackDepth));

        if (EVAL(0 < dwDepth))
            {
            EVAL(TlsSetValue(g_tlsStackDepth, (LPVOID)((DWORD_PTR)dwDepth - 1)));
            }
        }
    else
        {
        if (EVAL(0 < g_dwHackStackDepth))
            {
            g_dwHackStackDepth--;
            }
        }
    }


/*----------------------------------------------------------
Purpose: Return the stack depth.

Returns: see above
Cond:    --
*/
static
DWORD
CcshellGetStackDepth(void)
    {
    DWORD dwDepth;

    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        dwDepth = (DWORD)((DWORD_PTR)TlsGetValue(g_tlsStackDepth));
        }
    else
        {
        dwDepth = g_dwHackStackDepth;
        }

    return dwDepth;
    }


/*----------------------------------------------------------
Purpose: This function converts a multi-byte string to a
         wide-char string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszWide will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszAnsi is NULL, then *ppszWide will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

Cond:    --
*/
BOOL
UnicodeFromAnsi(
    LPWSTR * ppwszWide,
    LPCSTR pszAnsi,           // NULL to clean up
    LPWSTR pwszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pszAnsi)
        {
        // Yes; determine the converted string length
        int cch;
        LPWSTR pwsz;
        int cchAnsi = lstrlenA(pszAnsi)+1;

        cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, NULL, 0);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pwszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            pwsz = (LPWSTR)LocalAlloc(LPTR, CbFromCchW(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            pwsz = pwszBuf;
            }

        if (pwsz)
            {
            // Convert the string
            cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, pwsz, cchBuf);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppwszWide = pwsz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppwszWide && pwszBuf != *ppwszWide)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppwszWide);
            *ppwszWide = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellAssertMsgA
Returns: --
Cond:    --
*/
void
CDECL
CcshellAssertMsgW(
    BOOL f,
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
        {
        int cch;
#if 0
        WCHAR wszBuf[1024];
        LPWSTR pwsz;
#endif

        lstrcpyW(ach, c_wszAssertMsg);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

#if 0
        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }
#endif
        // This is a W version of CcshellDebugMsg.
        // Don't need to call UnicodeFromAnsi
        wvsprintfW(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
            ASSERT(0);
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellDebugMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

Returns: --
Cond:    --
*/
void
CDECL
CcshellDebugMsgW(
    DWORD flag,
    LPCWSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;
#if 0
        WCHAR wszBuf[1024];
        LPWSTR pwsz;
#endif

        SetPrefixStringW(ach, flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

#if 0
        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
        {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }
#endif
        // This is a W version of CcshellDebugMsg.
        // Don't need to call UnicodeFromAnsi
        wvsprintfW(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            DEBUG_BREAK;
        }
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellFuncMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

Returns: --
Cond:    --
*/
void
CDECL
CcshellFuncMsgW(
    DWORD flag,
    LPCWSTR pszMsg, ...)         // (this is deliberately CHAR)
    {
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_dwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
#if 0
        WCHAR wszBuf[1024];
        LPWSTR pwsz;
#endif
        DWORD dwStackDepth;
        LPWSTR pszLeaderEnd;
        WCHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < SIZECHARS(g_szIndentLeader))
            {
            pszLeaderEnd = &g_wszIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_wszIndentLeader[SIZECHARS(g_wszIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        wsprintfW(ach, L"%s %s", c_wszTrace, g_wszIndentLeader);
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

#if 0
        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }
#endif
        // This is a W version of CcshellDebugMsg.
        // Don't need to call UnicodeFromAnsi
        wvsprintfW(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);
        }
    }


/*----------------------------------------------------------
Purpose: Assert failed message only
Returns: --
Cond:    --
*/
void
CDECL
CcshellAssertMsgA(
    BOOL f,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyA(ach, c_szAssertMsg);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
            ASSERT(0);
    }
}


/*----------------------------------------------------------
Purpose: Debug spew
Returns: --
Cond:    --
*/
void
CDECL
CcshellDebugMsgA(
    DWORD flag,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        SetPrefixStringA(ach, flag);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            DEBUG_BREAK;
        }
    }
}


/*----------------------------------------------------------
Purpose: Debug spew for function trace calls
Returns: --
Cond:    --
*/
void
CDECL
CcshellFuncMsgA(
    DWORD flag,
    LPCSTR pszMsg, ...)
    {
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_dwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
        DWORD dwStackDepth;
        LPSTR pszLeaderEnd;
        CHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < sizeof(g_szIndentLeader))
            {
            pszLeaderEnd = &g_szIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_szIndentLeader[sizeof(g_szIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        wsprintfA(ach, "%s %s", c_szTrace, g_szIndentLeader);
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);
        }
    }


//
//  Debug .ini functions
//


#pragma data_seg(DATASEG_READONLY)

// (These are deliberately CHAR)
CHAR const FAR c_szNull[] = "";
CHAR const FAR c_szZero[] = "0";
CHAR const FAR c_szIniKeyBreakFlags[] = "BreakFlags";
CHAR const FAR c_szIniKeyTraceFlags[] = "TraceFlags";
CHAR const FAR c_szIniKeyFuncTraceFlags[] = "FuncTraceFlags";
CHAR const FAR c_szIniKeyDumpFlags[] = "DumpFlags";
CHAR const FAR c_szIniKeyProtoFlags[] = "Prototype";

#pragma data_seg()


// Some of the .ini processing code was pimped from the sync engine.
//

typedef struct _INIKEYHEADER
    {
    LPCTSTR pszSectionName;
    LPCTSTR pszKeyName;
    LPCTSTR pszDefaultRHS;
    } INIKEYHEADER;

typedef struct _BOOLINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    DWORD dwFlag;
    } BOOLINIKEY;

typedef struct _INTINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    } INTINIKEY;


#define PutIniIntCmp(idsSection, idsKey, nNewValue, nSave) \
    if ((nNewValue) != (nSave)) PutIniInt(idsSection, idsKey, nNewValue)

#define WritePrivateProfileInt(szApp, szKey, i, lpFileName) \
    {CHAR sz[7]; \
    WritePrivateProfileString(szApp, szKey, SzFromInt(sz, i), lpFileName);}


#ifdef BOOL_INI_VALUES
/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszTrue[] =
    {
    TEXT("1"),
    TEXT("On"),
    TEXT("True"),
    TEXT("Y"),
    TEXT("Yes")
    };

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszFalse[] =
    {
    TEXT("0"),
    TEXT("Off"),
    TEXT("False"),
    TEXT("N"),
    TEXT("No")
    };
#endif


#ifdef BOOL_INI_VALUES
/*----------------------------------------------------------
Purpose: Determines whether a string corresponds to a boolean
          TRUE value.
Returns: The boolean value (TRUE or FALSE)
Cond:    --
*/
BOOL
PRIVATE
IsIniYes(
    LPCTSTR psz)
    {
    int i;
    BOOL bNotFound = TRUE;
    BOOL bResult;

    Assert(psz);

    /* Is the value TRUE? */

    for (i = 0; i < ARRAYSIZE(s_rgpszTrue); i++)
        {
        if (IsSzEqual(psz, s_rgpszTrue[i]))
            {
            bResult = TRUE;
            bNotFound = FALSE;
            break;
            }
        }

    /* Is the value FALSE? */

    if (bNotFound)
        {
        for (i = 0; i < ARRAYSIZE(s_rgpszFalse); i++)
            {
            if (IsSzEqual(psz, s_rgpszFalse[i]))
                {
                bResult = FALSE;
                bNotFound = FALSE;
                break;
                }
            }

        /* Is the value a known string? */

        if (bNotFound)
            {
            /* No.  Whine about it. */

            TraceMsg(TF_WARNING, "IsIniYes() called on unknown Boolean RHS '%s'.", psz);
            bResult = FALSE;
            }
        }

    return bResult;
    }


/*----------------------------------------------------------
Purpose: Process keys with boolean RHSs.
Returns: --
Cond:    --
*/
void
PRIVATE
ProcessBooleans(void)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(s_rgbik); i++)
        {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAX_BUF];
        BOOLINIKEY * pbik = &(s_rgbik[i]);
        LPCTSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(pbik->ikh.pszSectionName,
                                   pbik->ikh.pszKeyName, TEXT(""), szRHS,
                                   SIZECHARS(szRHS), c_szCcshellIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = pbik->ikh.pszDefaultRHS;

        if (IsIniYes(lpcszRHS))
            {
            if (IsFlagClear(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s set in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            SetFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        else
            {
            if (IsFlagSet(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s cleared in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            ClearFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        }
    }
#endif


#ifdef UNICODE

/*----------------------------------------------------------
Purpose: This function converts a wide-char string to a multi-byte
         string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszAnsi will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszWide is NULL, then *ppszAnsi will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

Cond:    --
*/
static
BOOL
MyAnsiFromUnicode(
    LPSTR * ppszAnsi,
    LPCWSTR pwszWide,        // NULL to clean up
    LPSTR pszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pwszWide)
        {
        // Yes; determine the converted string length
        int cch;
        LPSTR psz;

        cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, NULL, 0, NULL, NULL);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            psz = (LPSTR)LocalAlloc(LPTR, CbFromCchA(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            Assert(pszBuf);
            psz = pszBuf;
            }

        if (psz)
            {
            // Convert the string
            cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, psz, cchBuf, NULL, NULL);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppszAnsi = psz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppszAnsi && pszBuf != *ppszAnsi)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppszAnsi);
            *ppszAnsi = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Wide-char wrapper for StrToIntExA.

Returns: see StrToIntExA
Cond:    --
*/
static
BOOL
MyStrToIntExW(
    LPCWSTR   pwszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
    {
    // Most strings will simply use this temporary buffer, but AnsiFromUnicode
    // will allocate a buffer if the supplied string is bigger.
    CHAR szBuf[MAX_PATH];

    LPSTR pszString;
    BOOL bRet = MyAnsiFromUnicode(&pszString, pwszString, szBuf, SIZECHARS(szBuf));

    if (bRet)
        {
        bRet = MyStrToIntExA(pszString, dwFlags, piRet);
        MyAnsiFromUnicode(&pszString, NULL, szBuf, 0);
        }
    return bRet;
    }
#endif // UNICODE


#ifdef UNICODE
#define MyStrToIntEx        MyStrToIntExW
#else
#define MyStrToIntEx        MyStrToIntExA
#endif



/*----------------------------------------------------------
Purpose: This function reads a .ini file to determine the debug
         flags to set.  The .ini file and section are specified
         by the following manifest constants:

                SZ_DEBUGINI
                SZ_DEBUGSECTION

         The debug variables that are set by this function are
         g_dwDumpFlags, g_dwTraceFlags, g_dwBreakFlags, and
         g_dwFuncTraceFlags, g_dwPrototype.

Returns: TRUE if initialization is successful
Cond:    --
*/
BOOL
PUBLIC
CcshellGetDebugFlags(void)
    {
    CHAR szRHS[MAX_PATH];
    int val;

    // BUGBUG (scotth): Yes, COMCTL32 exports StrToIntEx, but I
    //  don't want to cause a dependency delta and force everyone
    //  to get a new comctl32 just because they built debug.
    //  So use a local version of StrToIntEx.

    // Trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwTraceFlags = (DWORD)val;

    TraceMsgA(TF_GENERAL, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyTraceFlags, g_dwTraceFlags);

    // Function trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyFuncTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwFuncTraceFlags = (DWORD)val;

    TraceMsgA(TF_GENERAL, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyFuncTraceFlags, g_dwFuncTraceFlags);

    // Dump Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyDumpFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwDumpFlags = (DWORD)val;

    TraceMsgA(TF_GENERAL, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyDumpFlags, g_dwDumpFlags);

    // Break Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyBreakFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwBreakFlags = (DWORD)val;

    TraceMsgA(TF_GENERAL, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyBreakFlags, g_dwBreakFlags);

    // Prototype Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyProtoFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwPrototype = (DWORD)val;

    TraceMsgA(TF_GENERAL, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyProtoFlags, g_dwPrototype);

    return TRUE;
    }


#endif // DEBUG

#ifdef PRODUCT_PROF

DWORD g_dwProfileCAP = 0;        

BOOL PUBLIC CcshellGetDebugFlags(void)
{
    CHAR szRHS[MAX_PATH];
    int val;

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            "Profile",
                            "",
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwProfileCAP = (DWORD)val;

    return TRUE;
}
#endif // PRODUCT_PROF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\lib\proj.h ===
//
// proj.h:      Main header
//
//


#ifndef __PROJ_H__
#define __PROJ_H__

#define STRICT

#if defined(WINNT) || defined(WINNT_ENV)

//
// NT uses DBG=1 for its debug builds, but the Win95 shell uses
// DEBUG.  Do the appropriate mapping here.
//
#if DBG
#define DEBUG 1
#endif

#endif  // WINNT

#include <windows.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <shlobj.h>
#include <port32.h>
#include <ccstock.h>
#include "..\inc\debug.h"

#include <shlobj.h>        // for _ILNext

#endif // __PROJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\lib\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     =  ..\..

!include $(GETCONN_DIR)\common.inc

# Make sure this is built before we continue
SYNCHRONIZE_BLOCK = 1

SOURCES_USED    = $(SOURCES_USED) $(GETCONN_DIR)\common.inc

TARGETNAME      = stocklib
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\debug.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\inetprop.h ===
#ifndef _INETPROP_H
#define _INETPROP_H

//---[ INETPROP.H ]--------------------------------------------------------
//
//  Definitions used by the the Inet transports, address books
//  and other Inet providers for service entry calls.
//
//  $$REVIEW This was stolen from Blade's MSFS.H (stolen from somewhere else)
//
//  The following INET-defined properties are settable in service entry
//  calls.  They are grouped by function. I've tried to maintain as much compatibility
//  with the Blade proptags, just to keep things easy.
//
//-------------------------------------------------------------------------

// $$REVIEW: What is this RAS_MaxEntryName doing in here?

#ifdef WIN32
#include <ras.h>
#else
#define RAS_MaxEntryName    20
#endif

#define MAIL_PROP_COUNT     42   // Not including the sess one.
#define NEWS_PROP_COUNT     19   // Not including the sess one.

//---[ Generic Connection Properties ]-------------------------------------
#define PR_CFG_SERVER_PATH              PROP_TAG (PT_TSTRING,   0x6600)
#define PR_CFG_CONN_TYPE                PROP_TAG (PT_LONG,      0x6601)
#define PR_CFG_SESSION_LOG              PROP_TAG (PT_LONG, 		0x6602)
#define PR_CFG_SESSION_LOG_FILE         PROP_TAG (PT_TSTRING,   0x6603)
#define PR_CFG_SESSION_LOG_FILTER_INDEX	PROP_TAG (PT_LONG,		0x6604)

//---[ IMail Connection Properties ]---------------------------------------
#define PR_CFG_EMAIL_ADDRESS            PROP_TAG (PT_TSTRING,   0x6605)
#define PR_CFG_EMAIL_ACCOUNT            PROP_TAG (PT_TSTRING,   0x6606)
#define PR_CFG_EMAIL_DISPLAY_NAME       PROP_TAG (PT_TSTRING,   0x6607)
//#define PR_CFG_PASSWORD                 PROP_TAG (PT_TSTRING,   0x6608)
#define PR_CFG_PASSWORD                 PROP_TAG (PT_TSTRING,   PROP_ID_SECURE_MIN)
#define PR_CFG_REMEMBER                 PROP_TAG (PT_BOOLEAN,   0x6610)
#define PR_CFG_OUTBOUND_MAIL_HOST       PROP_TAG (PT_TSTRING,   0x6611)

//---[ INews Connection Properties ]---------------------------------------
#define PR_CFG_NEWS_EMAIL_ADDRESS		PROP_TAG (PT_TSTRING,	0x6600)
#define PR_CFG_NEWS_DISPLAY_NAME		PROP_TAG (PT_TSTRING,	0x6601)
#define PR_CFG_NEWS_SERVER_NAME			PROP_TAG (PT_TSTRING,	0x6610)
#define PR_CFG_CONNECTION_TYPE			PROP_TAG (PT_LONG,		0x6603)
#define PR_CFG_CONNECTION_PROFILE		PROP_TAG (PT_TSTRING,	0x6604)

//---[ Advanced Properties ]-----------------------------------------------
 
#define PR_CFG_BODY_FORMAT              PROP_TAG (PT_LONG,      0x6620)
#define PR_CFG_TEXT_CHAR_SET            PROP_TAG (PT_TSTRING,   0x6621)
#define PR_CFG_MIME_CHAR_SET            PROP_TAG (PT_TSTRING,   0x6622)
#define PR_CFG_ENCODING_MINIMUM         PROP_TAG (PT_LONG,      0x6623)
#define PR_CFG_ENCODE_LINES             PROP_TAG (PT_BOOLEAN,   0x6624)
 
//---[ Remote Config Properties ]------------------------------------------

#define PR_CFG_SESSION_START_TYPE       PROP_TAG (PT_LONG,      0x6630)
#define PR_CFG_RNA_PROFILE              PROP_TAG (PT_TSTRING,   0x6631)
#define PR_CFG_RNA_PROFILE_ALWAYS       PROP_TAG (PT_BOOLEAN,   0x6632)
#define PR_CFG_RNA_CONFIRM              PROP_TAG (PT_LONG,      0x6633)
#define PR_CFG_REMOTE_CONNECT_TIMEOUT	PROP_TAG (PT_LONG,		0x6634)
#define PR_CFG_REMOTE_USERNAME			PROP_TAG (PT_TSTRING,	0x6635)
//#define PR_CFG_REMOTE_PASSWORD			PROP_TAG (PT_TSTRING,	0x6636)
#define PR_CFG_REMOTE_PASSWORD		PROP_TAG (PT_TSTRING,	PROP_ID_SECURE_MIN+1)

#define PR_CFG_NEWS_REMOTE_USERNAME		PROP_TAG (PT_TSTRING,	0x6620)
#define PR_CFG_NEWS_REMOTE_PASSWORD		PROP_TAG (PT_TSTRING, 	0x6621)   

//---[ Generic Delivery Options ]------------------------------------------

#define PR_CFG_DELIVERY_OPTIONS         PROP_TAG (PT_LONG,      0x6640)
#define PR_CFG_MSG_CHECK_WAIT           PROP_TAG (PT_LONG,      0x6641)

//---[ News Delivery Options ]---------------------------------------------

#define PR_CFG_NEW_GROUP_NOTIFY         PROP_TAG (PT_BOOLEAN,   0x6642)
#define PR_CFG_DEAD_GROUP_NOTIFY        PROP_TAG (PT_BOOLEAN,   0x6643)
#define PR_CFG_NEW_MESSAGE_NOTIFY       PROP_TAG (PT_BOOLEAN,   0x6644)
 
//---[ Other data ]--------------------------------------------------------

#define PR_CFG_SMTP_PORT                PROP_TAG (PT_LONG,   	0x6650)
#define PR_CFG_POP3_PORT                PROP_TAG (PT_LONG,   	0x6651)

#define PR_CFG_SMTP_TIMEOUT_CONNECT     PROP_TAG (PT_LONG,   	0x6660)
#define PR_CFG_SMTP_TIMEOUT_HELO        PROP_TAG (PT_LONG,   	0x6661)
#define PR_CFG_SMTP_TIMEOUT_MAILFROM    PROP_TAG (PT_LONG,   	0x6662)
#define PR_CFG_SMTP_TIMEOUT_RCPT        PROP_TAG (PT_LONG,   	0x6663)
#define PR_CFG_SMTP_TIMEOUT_DATAINIT    PROP_TAG (PT_LONG,   	0x6664)
#define PR_CFG_SMTP_TIMEOUT_DATABLOK    PROP_TAG (PT_LONG,   	0x6665)
#define PR_CFG_SMTP_TIMEOUT_RSET        PROP_TAG (PT_LONG,   	0x6666)
#define PR_CFG_SMTP_TIMEOUT_QUIT        PROP_TAG (PT_LONG,   	0x6667)
#define PR_CFG_SMTP_TIMEOUT_CLOSE       PROP_TAG (PT_LONG,   	0x6668)
#define PR_CFG_POP3_TIMEOUT_CONNECT     PROP_TAG (PT_LONG,   	0x6669)
#define PR_CFG_POP3_TIMEOUT_SEND        PROP_TAG (PT_LONG,   	0x6670)
#define PR_CFG_POP3_TIMEOUT_RECEIVE     PROP_TAG (PT_LONG,   	0x6671)
#define PR_CFG_SMTP_TIMEOUT_DATAACPT    PROP_TAG (PT_LONG,   	0x6672)

//---[ Remote Header Cache Props ]-----------------------------------------

#define PR_CFG_REMOTE_CACHE_TIMEOUT		PROP_TAG (PT_LONG,		0x6673)
#define PR_CFG_REMOTE_CACHE_NAME		PROP_TAG (PT_TSTRING,	0x6674)

//---[ INews PST Properties ]----------------------------------------------
#define PR_CFG_PST_PATH                 PROP_TAG (PT_TSTRING,   0x6680)

//---[ IMail Message Class String ]----------------------------------------

// The strings themselves are defined in mapiopt.h

extern CHAR lpstrMsgClassRFC822[];
extern CHAR lpstrMsgClassRFCMIME[];

#endif // _INETPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\mapiguid.h ===
/*
 *  M A P I G U I D . H
 *
 *  Master definitions of all GUID's for MAPI.
 *
 *  When included without INITGUID defined, this header file
 *  defines symbols that reference IIDs elsewhere.
 *
 *  When included with INITGUID defined and a "USES_IID_I..."
 *  statement for each IID used by the subsystem, it generates the
 *  bytes for those actual IIDs into the associated object file.
 *
 *  This range of 256 GUIDs reserved by OLE for MAPI use October 5, 1992.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

/*
 *  List of GUIDS allocated by MAPI
 *  
 *  0x00020300  IID_IMAPISession
 *  0x00020301  IID_IMAPITable
 *  0x00020302  IID_IMAPIAdviseSink
 *  0x00020303  IID_IMAPIProp
 *  0x00020304  IID_IProfSect
 *  0x00020305  IID_IMAPIStatus
 *  0x00020306  IID_IMsgStore
 *  0x00020307  IID_IMessage
 *  0x00020308  IID_IAttachment
 *  0x00020309  IID_IAddrBook
 *  0x0002030A  IID_IMailUser
 *  0x0002030B  IID_IMAPIContainer
 *  0x0002030C  IID_IMAPIFolder
 *  0x0002030D  IID_IABContainer
 *  0x0002030E  IID_IDistList
 *  0x0002030F  IID_IMAPISup
 *  0x00020310  IID_IMSProvider
 *  0x00020311  IID_IABProvider
 *  0x00020312  IID_IXPProvider
 *  0x00020313  IID_IMSLogon
 *  0x00020314  IID_IABLogon
 *  0x00020315  IID_IXPLogon
 *  0x00020316  IID_IMAPITableData
 *  0x00020317  IID_IMAPISpoolerInit
 *  0x00020318  IID_IMAPISpoolerSession
 *  0x00020319  IID_ITNEF
 *  0x0002031A  IID_IMAPIPropData
 *  0x0002031B  IID_IMAPIControl
 *  0x0002031C  IID_IProfAdmin
 *  0x0002031D  IID_IMsgServiceAdmin
 *  0x0002031E  IID_IMAPISpoolerService
 *  0x0002031F  IID_IMAPIProgress
 *  0x00020320  IID_ISpoolerHook
 *  0x00020321  IID_IMAPIViewContext
 *  0x00020322  IID_IMAPIFormMgr
 *  0x00020323  IID_IEnumMAPIFormProp
 *  0x00020324  IID_IMAPIFormInfo
 *  0x00020325  IID_IProviderAdmin
 *  0x00020327  IID_IMAPIForm
 *  0x00020328  PS_MAPI
 *  0x00020329  PS_PUBLIC_STRINGS
 *  0x0002032A  IID_IPersistMessage
 *  0x0002032B  IID_IMAPIViewAdviseSink
 *  0x0002032C  IID_IStreamDocfile
 *  0x0002032D  IID_IMAPIFormProp
 *  0x0002032E  IID_IMAPIFormContainer
 *  0x0002032F  IID_IMAPIFormAdviseSink
 *  0x00020330  IID_IStreamTnef
 *  0x00020370  IID_IMAPIMessageSite
 *  
 *  The remaining GUIDs from 0x00020300 to 0x000203FF are reserved by
 *  MAPI for future use.  The current maximum used by MAPI is 0x00020370
 *
 */

#ifndef MAPIGUID_H
#ifdef  INITGUID
#define MAPIGUID_H
#endif

/* Derive from IUnknown */
#if !defined(INITGUID) || defined(USES_IID_IMAPISession)
DEFINE_OLEGUID(IID_IMAPISession,    0x00020300, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPITable)
DEFINE_OLEGUID(IID_IMAPITable,      0x00020301, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIAdviseSink)
DEFINE_OLEGUID(IID_IMAPIAdviseSink, 0x00020302, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIControl)
DEFINE_OLEGUID(IID_IMAPIControl,    0x0002031B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfAdmin)
DEFINE_OLEGUID(IID_IProfAdmin,      0x0002031C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgServiceAdmin)
DEFINE_OLEGUID(IID_IMsgServiceAdmin,0x0002031D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProviderAdmin)
DEFINE_OLEGUID(IID_IProviderAdmin,  0x00020325, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIProgress)
DEFINE_OLEGUID(IID_IMAPIProgress,   0x0002031F, 0, 0);
#endif

/* MAPIProp or derive from MAPIProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIProp)
DEFINE_OLEGUID(IID_IMAPIProp,       0x00020303, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfSect)
DEFINE_OLEGUID(IID_IProfSect,       0x00020304, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIStatus)
DEFINE_OLEGUID(IID_IMAPIStatus,         0x00020305, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgStore)
DEFINE_OLEGUID(IID_IMsgStore,       0x00020306, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMessage)
DEFINE_OLEGUID(IID_IMessage,        0x00020307, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAttachment)
DEFINE_OLEGUID(IID_IAttachment,     0x00020308, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAddrBook)
DEFINE_OLEGUID(IID_IAddrBook,       0x00020309, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMailUser)
DEFINE_OLEGUID(IID_IMailUser,       0x0002030A, 0, 0);
#endif

/* MAPIContainer or derive from MAPIContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIContainer)
DEFINE_OLEGUID(IID_IMAPIContainer,  0x0002030B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFolder)
DEFINE_OLEGUID(IID_IMAPIFolder,     0x0002030C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABContainer)
DEFINE_OLEGUID(IID_IABContainer,    0x0002030D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IDistList)
DEFINE_OLEGUID(IID_IDistList,       0x0002030E, 0, 0);
#endif

/* MAPI Support Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISup)
DEFINE_OLEGUID(IID_IMAPISup,        0x0002030F, 0, 0);
#endif

/* Provider INIT objects */
#if !defined(INITGUID) || defined(USES_IID_IMSProvider)
DEFINE_OLEGUID(IID_IMSProvider,     0x00020310, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABProvider)
DEFINE_OLEGUID(IID_IABProvider,     0x00020311, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPProvider)
DEFINE_OLEGUID(IID_IXPProvider,     0x00020312, 0, 0);
#endif

/* Provider LOGON Objects */
#if !defined(INITGUID) || defined(USES_IID_IMSLogon)
DEFINE_OLEGUID(IID_IMSLogon,        0x00020313, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABLogon)
DEFINE_OLEGUID(IID_IABLogon,        0x00020314, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPLogon)
DEFINE_OLEGUID(IID_IXPLogon,        0x00020315, 0, 0);
#endif

/* IMAPITable-in-memory Table Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPITableData)
DEFINE_OLEGUID(IID_IMAPITableData,  0x00020316, 0, 0);
#endif

/* MAPI Spooler Init Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerInit)
DEFINE_OLEGUID(IID_IMAPISpoolerInit,    0x00020317, 0, 0);
#endif

/* MAPI Spooler Session Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerSession)
DEFINE_OLEGUID(IID_IMAPISpoolerSession, 0x00020318, 0, 0);
#endif

/* MAPI TNEF Object Interface */
#if !defined(INITGUID) || defined(USES_IID_ITNEF)
DEFINE_OLEGUID(IID_ITNEF,           0x00020319, 0, 0);
#endif

/* IMAPIProp-in-memory Property Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPIPropData)
DEFINE_OLEGUID(IID_IMAPIPropData,   0x0002031A, 0, 0);
#endif

/* MAPI Spooler Hook Object */
#if !defined(INITGUID) || defined(USES_IID_ISpoolerHook)
DEFINE_OLEGUID(IID_ISpoolerHook,    0x00020320, 0, 0);
#endif

/* MAPI Spooler Service Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerService)
DEFINE_OLEGUID(IID_IMAPISpoolerService, 0x0002031E, 0, 0);
#endif

/* MAPI forms, form manager, etc. */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewContext)
DEFINE_OLEGUID(IID_IMAPIViewContext,    0x00020321, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormMgr)
DEFINE_OLEGUID(IID_IMAPIFormMgr,    0x00020322, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IEnumMAPIFormProp)
DEFINE_OLEGUID(IID_IEnumMAPIFormProp,   0x00020323, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormInfo)
DEFINE_OLEGUID(IID_IMAPIFormInfo,   0x00020324, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIForm)
DEFINE_OLEGUID(IID_IMAPIForm,   0x00020327, 0, 0);
#endif


/* Well known guids for name<->id mappings */

/*  The name of MAPI's property set  */
#if !defined(INITGUID) || defined(USES_PS_MAPI)
DEFINE_OLEGUID(PS_MAPI, 0x00020328, 0, 0);
#endif

/*  The name of the set of public strings  */
#if !defined(INITGUID) || defined(USES_PS_PUBLIC_STRINGS)
DEFINE_OLEGUID(PS_PUBLIC_STRINGS,   0x00020329, 0, 0);
#endif

/* MAPI forms, form manager, (cont) */
#if !defined(INITGUID) || defined(USES_IID_IPersistMessage)
DEFINE_OLEGUID(IID_IPersistMessage, 0x0002032A, 0, 0);
#endif

/* IMAPIViewAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewAdviseSink)
DEFINE_OLEGUID(IID_IMAPIViewAdviseSink, 0x0002032B, 0, 0);
#endif

/* Message Store OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamDocfile)
DEFINE_OLEGUID(IID_IStreamDocfile, 0x0002032C, 0, 0);
#endif

/* IMAPIFormProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormProp)
DEFINE_OLEGUID(IID_IMAPIFormProp,   0x0002032D, 0, 0);
#endif

/* IMAPIFormContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormContainer)
DEFINE_OLEGUID(IID_IMAPIFormContainer, 0x0002032E, 0, 0);
#endif

/* IMAPIFormAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormAdviseSink)
DEFINE_OLEGUID(IID_IMAPIFormAdviseSink, 0x0002032F, 0, 0);
#endif

/* TNEF OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamTnef)
DEFINE_OLEGUID(IID_IStreamTnef, 0x00020330, 0, 0);
#endif

/* IMAPIMessageSite */
#if !defined(INITGUID) || defined(USES_IID_IMAPIMessageSite)
DEFINE_OLEGUID(IID_IMAPIMessageSite, 0x00020370, 0, 0);
#endif

#endif  /* MAPIGUID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\mapidefs.h ===
/*
 *  M A P I D E F S . H
 *
 *  Definitions used by MAPI clients and service providers.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIDEFS_H
#define MAPIDEFS_H

#ifdef WIN32    /* Must include WINDOWS.H on Win32 */
#ifndef _WINDOWS_
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Daytona; Chicago needs it */
#define _INC_OLE /* Chicago will include OLE1 without this */
#include <windows.h>
#endif
#ifndef _OLEERROR_H_
#include <objerror.h>
#endif
#ifndef _OBJBASE_H_
#include <objbase.h>
#endif
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16) || defined (MAC)
#ifndef _COMPOBJ_H_
#include <compobj.h>
#endif
#endif

#ifndef _INC_STDDEF
#include <stddef.h>
#endif

/* Array dimension for structures with variable-sized arrays at the end. */

#ifndef MAPI_DIM
#define MAPI_DIM    1
#endif

/* Provider init type. Force to cdecl always */

#ifndef STDMAPIINITCALLTYPE
#if !defined (_MAC) && defined (WIN32)
#define STDMAPIINITCALLTYPE     __cdecl
#else
#define STDMAPIINITCALLTYPE     STDMETHODCALLTYPE
#endif
#define STDINITMETHODIMP        HRESULT STDMAPIINITCALLTYPE
#define STDINITMETHODIMP_(type) type STDMAPIINITCALLTYPE
#endif

#ifdef  __cplusplus
extern "C" {
#endif

/* Simple data types */

#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short      WCHAR;
#else
typedef wchar_t WCHAR;
#endif

#ifdef UNICODE
typedef WCHAR               TCHAR;
#else
typedef char                TCHAR;
#endif

typedef WCHAR FAR *         LPWSTR;
typedef const WCHAR FAR *   LPCWSTR;
typedef TCHAR FAR *         LPTSTR;
typedef const TCHAR FAR *   LPCTSTR;
typedef BYTE FAR *          LPBYTE;
typedef ULONG FAR *         LPULONG;

#ifndef __LHANDLE
#define __LHANDLE
typedef unsigned long   LHANDLE, FAR * LPLHANDLE;
#endif

#if defined(WIN32) && !defined(_WINNT_)
typedef struct {
    DWORD   LowPart;
    LONG    HighPart;
} LARGE_INTEGER;
#endif

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME;
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 *  This flag is used in many different MAPI calls to signify that
 *  the object opened by the call should be modifiable (MAPI_MODIFY).
 *  If the flag MAPI_MAX_ACCESS is set, the object returned should be
 *  returned at the maximum access level allowed.  An additional
 *  property available on the object (PR_ACCESS_LEVEL) uses the same
 *  MAPI_MODIFY flag to say just what this new access level is.
 */

#define MAPI_MODIFY             ((ULONG) 0x00000001)

/*
 *  The following flags are used to indicate to the client what access
 *  level is permissible in the object. They appear in PR_ACCESS in
 *  message and folder objects as well as in contents and associated
 *  contents tables
 */

#define MAPI_ACCESS_MODIFY                  ((ULONG) 0x00000001)
#define MAPI_ACCESS_READ                    ((ULONG) 0x00000002)
#define MAPI_ACCESS_DELETE                  ((ULONG) 0x00000004)
#define MAPI_ACCESS_CREATE_HIERARCHY        ((ULONG) 0x00000008)
#define MAPI_ACCESS_CREATE_CONTENTS         ((ULONG) 0x00000010)
#define MAPI_ACCESS_CREATE_ASSOCIATED       ((ULONG) 0x00000020)

/*
 *  The MAPI_UNICODE flag is used in many different MAPI calls to signify
 *  that strings passed through the interface are in Unicode (a 16-bit
 *  character set). The default is an 8-bit character set.
 *
 *  The value fMapiUnicode can be used as the 'normal' value for
 *  that bit, given the application's default character set.
 */

#define MAPI_UNICODE            ((ULONG) 0x80000000)

#ifdef UNICODE
#define fMapiUnicode            MAPI_UNICODE
#else
#define fMapiUnicode            0
#endif

/* successful HRESULT */
#define hrSuccess               0



/* Recipient types */
#ifndef MAPI_ORIG               /* also defined in mapi.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_P1     0x10000000  /* Recipient is a P1 resend recipient       */
#define MAPI_SUBMITTED 0x80000000 /* Recipient is already processed         */
/* #define MAPI_AUTHORIZE 4        recipient is a CMC authorizing user      */
/*#define MAPI_DISCRETE 0x10000000 Recipient is a P1 resend recipient       */
#endif

/* Bit definitions for abFlags[0] of ENTRYID */
#define MAPI_SHORTTERM          0x80
#define MAPI_NOTRECIP           0x40
#define MAPI_THISSESSION        0x20
#define MAPI_NOW                0x10
#define MAPI_NOTRESERVED        0x08

/* Bit definitions for abFlags[1] of ENTRYID */
#define MAPI_COMPOUND           0x80

/* ENTRYID */
typedef struct
{
    BYTE    abFlags[4];
    BYTE    ab[MAPI_DIM];
} ENTRYID, FAR *LPENTRYID;

#define CbNewENTRYID(_cb)       (offsetof(ENTRYID,ab) + (_cb))
#define CbENTRYID(_cb)          (offsetof(ENTRYID,ab) + (_cb))
#define SizedENTRYID(_cb, _name) \
    struct _ENTRYID_ ## _name \
{ \
    BYTE    abFlags[4]; \
    BYTE    ab[_cb]; \
} _name

/* Byte-order-independent version of GUID (world-unique identifier) */
typedef struct _MAPIUID
{
    BYTE ab[16];
} MAPIUID, FAR * LPMAPIUID;

/* Note:  need to include C run-times (memory.h) to use this macro */

#define IsEqualMAPIUID(lpuid1, lpuid2)  (!memcmp(lpuid1, lpuid2, sizeof(MAPIUID)))


/* Object type */

#define MAPI_STORE      ((ULONG) 0x00000001)    /* Message Store */
#define MAPI_ADDRBOOK   ((ULONG) 0x00000002)    /* Address Book */
#define MAPI_FOLDER     ((ULONG) 0x00000003)    /* Folder */
#define MAPI_ABCONT     ((ULONG) 0x00000004)    /* Address Book Container */
#define MAPI_MESSAGE    ((ULONG) 0x00000005)    /* Message */
#define MAPI_MAILUSER   ((ULONG) 0x00000006)    /* Individual Recipient */
#define MAPI_ATTACH     ((ULONG) 0x00000007)    /* Attachment */
#define MAPI_DISTLIST   ((ULONG) 0x00000008)    /* Distribution List Recipient */
#define MAPI_PROFSECT   ((ULONG) 0x00000009)    /* Profile Section */
#define MAPI_STATUS     ((ULONG) 0x0000000A)    /* Status Object */
#define MAPI_SESSION    ((ULONG) 0x0000000B)    /* Session */
#define MAPI_FORMINFO   ((ULONG) 0x0000000C)    /* Form Information */

/* Property Types */

#define MV_FLAG         0x1000          /* Multi-value flag */

#define PT_UNSPECIFIED  ((ULONG)  0)    /* (Reserved for interface use) type doesn't matter to caller */
#define PT_NULL         ((ULONG)  1)    /* NULL property value */
#define PT_I2           ((ULONG)  2)    /* Signed 16-bit value */
#define PT_LONG         ((ULONG)  3)    /* Signed 32-bit value */
#define PT_R4           ((ULONG)  4)    /* 4-byte floating point */
#define PT_DOUBLE       ((ULONG)  5)    /* Floating point double */
#define PT_CURRENCY     ((ULONG)  6)    /* Signed 64-bit int (decimal w/    4 digits right of decimal pt) */
#define PT_APPTIME      ((ULONG)  7)    /* Application time */
#define PT_ERROR        ((ULONG) 10)    /* 32-bit error value */
#define PT_BOOLEAN      ((ULONG) 11)    /* 16-bit boolean (non-zero true) */
#define PT_OBJECT       ((ULONG) 13)    /* Embedded object in a property */
#define PT_I8           ((ULONG) 20)    /* 8-byte signed integer */
#define PT_STRING8      ((ULONG) 30)    /* Null terminated 8-bit character string */
#define PT_UNICODE      ((ULONG) 31)    /* Null terminated Unicode string */
#define PT_SYSTIME      ((ULONG) 64)    /* FILETIME 64-bit int w/ number of 100ns periods since Jan 1,1601 */
#define PT_CLSID        ((ULONG) 72)    /* OLE GUID */
#define PT_BINARY       ((ULONG) 258)   /* Uninterpreted (counted byte array) */
/* Changes are likely to these numbers, and to their structures. */

/* Alternate property type names for ease of use */
#define PT_SHORT    PT_I2
#define PT_I4       PT_LONG
#define PT_FLOAT    PT_R4
#define PT_R8       PT_DOUBLE
#define PT_LONGLONG PT_I8

/*
 *  The type of a MAPI-defined string property is indirected, so
 *  that it defaults to Unicode string on a Unicode platform and to
 *  String8 on an ANSI or DBCS platform.
 *
 *  Macros are defined here both for the property type, and for the
 *  field of the property value structure which should be
 *  dereferenced to obtain the string pointer.
 */

#ifdef  UNICODE
#define PT_TSTRING          PT_UNICODE
#define PT_MV_TSTRING       (MV_FLAG|PT_UNICODE)
#define LPSZ                lpszW
#define LPPSZ               lppszW
#define MVSZ                MVszW
#else
#define PT_TSTRING          PT_STRING8
#define PT_MV_TSTRING       (MV_FLAG|PT_STRING8)
#define LPSZ                lpszA
#define LPPSZ               lppszA
#define MVSZ                MVszA
#endif


/* Property Tags
 *
 * By convention, MAPI never uses 0 or FFFF as a property ID.
 * Use as null values, initializers, sentinels, or what have you.
 */

#define PROP_TYPE_MASK          ((ULONG)0x0000FFFF) /* Mask for Property type */
#define PROP_TYPE(ulPropTag)    (((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag)      (((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID)   ((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL            0
#define PROP_ID_INVALID         0xFFFF
#define PR_NULL                 PROP_TAG( PT_NULL, PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType) \
                        (((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)


/* Multi-valued Property Types */

#define PT_MV_I2        (MV_FLAG|PT_I2)
#define PT_MV_LONG      (MV_FLAG|PT_LONG)
#define PT_MV_R4        (MV_FLAG|PT_R4)
#define PT_MV_DOUBLE    (MV_FLAG|PT_DOUBLE)
#define PT_MV_CURRENCY  (MV_FLAG|PT_CURRENCY)
#define PT_MV_APPTIME   (MV_FLAG|PT_APPTIME)
#define PT_MV_SYSTIME   (MV_FLAG|PT_SYSTIME)
#define PT_MV_STRING8   (MV_FLAG|PT_STRING8)
#define PT_MV_BINARY    (MV_FLAG|PT_BINARY)
#define PT_MV_UNICODE   (MV_FLAG|PT_UNICODE)
#define PT_MV_CLSID     (MV_FLAG|PT_CLSID)
#define PT_MV_I8        (MV_FLAG|PT_I8)

/* Alternate property type names for ease of use */
#define PT_MV_SHORT     PT_MV_I2
#define PT_MV_I4        PT_MV_LONG
#define PT_MV_FLOAT     PT_MV_R4
#define PT_MV_R8        PT_MV_DOUBLE
#define PT_MV_LONGLONG  PT_MV_I8

/*
 *  Property type reserved bits
 *
 *  MV_INSTANCE is used as a flag in table operations to request
 *  that a multi-valued property be presented as a single-valued
 *  property appearing in multiple rows.
 */

#define MV_INSTANCE     0x2000
#define MVI_FLAG        (MV_FLAG | MV_INSTANCE)
#define MVI_PROP(tag)   ((tag) | MVI_FLAG)

/* --------------- */
/* Data Structures */
/* --------------- */

/* Property Tag Array */

typedef struct _SPropTagArray
{
    ULONG   cValues;
    ULONG   aulPropTag[MAPI_DIM];
} SPropTagArray, FAR * LPSPropTagArray;

#define CbNewSPropTagArray(_ctag) \
    (offsetof(SPropTagArray,aulPropTag) + (_ctag)*sizeof(ULONG))
#define CbSPropTagArray(_lparray) \
    (offsetof(SPropTagArray,aulPropTag) + \
    (UINT)((_lparray)->cValues)*sizeof(ULONG))
/*  SPropTagArray */
#define SizedSPropTagArray(_ctag, _name) \
struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name

/* -------------- */
/* Property Value */
/* -------------- */

typedef struct _SPropValue  SPropValue;

#if !defined(VB_VERSION) && !defined(_OLEAUTO_H_)
/* Don't redefine CURRENCY if Visual Basic or
OLE automation headers are included already */
typedef struct
{
    LONG Lo;
    LONG Hi;
} CURRENCY;
#endif

typedef struct _SBinary
{
    ULONG       cb;
    LPBYTE      lpb;
} SBinary, FAR *LPSBinary;

typedef struct _SShortArray
{
    ULONG       cValues;
    short int   FAR *lpi;
} SShortArray;

typedef struct _SGuidArray
{
    ULONG       cValues;
    GUID        FAR *lpguid;
} SGuidArray;

typedef struct _SRealArray
{
    ULONG       cValues;
    float       FAR *lpflt;
} SRealArray;

typedef struct _SLongArray
{
    ULONG       cValues;
    LONG        FAR *lpl;
} SLongArray;

typedef struct _SLargeIntegerArray
{
    ULONG       cValues;
    LARGE_INTEGER   FAR *lpli;
} SLargeIntegerArray;

typedef struct _SDateTimeArray
{
    ULONG       cValues;
    FILETIME    FAR *lpft;
} SDateTimeArray;

typedef struct _SAppTimeArray
{
    ULONG       cValues;
    double      FAR *lpat;
} SAppTimeArray;

typedef struct _SCurrencyArray
{
    ULONG       cValues;
    CURRENCY    FAR *lpcur;
} SCurrencyArray;

typedef struct _SBinaryArray
{
    ULONG       cValues;
    SBinary     FAR *lpbin;
} SBinaryArray;

typedef struct _SDoubleArray
{
    ULONG       cValues;
    double      FAR *lpdbl;
} SDoubleArray;

typedef struct _SWStringArray
{
    ULONG       cValues;
    LPWSTR      FAR *lppszW;
} SWStringArray;

typedef struct _SLPSTRArray
{
    ULONG       cValues;
    LPSTR       FAR *lppszA;
} SLPSTRArray;

typedef union _PV
{
    short int           i;          /* case PT_I2 */
    LONG                l;          /* case PT_LONG */
    ULONG               ul;         /* alias for PT_LONG */
    float               flt;        /* case PT_R4 */
    double              dbl;        /* case PT_DOUBLE */
    unsigned short int  b;          /* case PT_BOOLEAN */
    CURRENCY            cur;        /* case PT_CURRENCY */
    double              at;         /* case PT_APPTIME */
    FILETIME            ft;         /* case PT_SYSTIME */
    LPSTR               lpszA;      /* case PT_STRING8 */
    SBinary             bin;        /* case PT_BINARY */
    LPWSTR              lpszW;      /* case PT_UNICODE */
    LPGUID              lpguid;     /* case PT_CLSID */
    LARGE_INTEGER       li;         /* case PT_I8 */
    SShortArray         MVi;        /* case PT_MV_I2 */
    SLongArray          MVl;        /* case PT_MV_LONG */
    SRealArray          MVflt;      /* case PT_MV_R4 */
    SDoubleArray        MVdbl;      /* case PT_MV_DOUBLE */
    SCurrencyArray      MVcur;      /* case PT_MV_CURRENCY */
    SAppTimeArray       MVat;       /* case PT_MV_APPTIME */
    SDateTimeArray      MVft;       /* case PT_MV_SYSTIME */
    SBinaryArray        MVbin;      /* case PT_MV_BINARY */
    SLPSTRArray         MVszA;      /* case PT_MV_STRING8 */
    SWStringArray       MVszW;      /* case PT_MV_UNICODE */
    SGuidArray          MVguid;     /* case PT_MV_CLSID */
    SLargeIntegerArray  MVli;       /* case PT_MV_I8 */
    SCODE               err;        /* case PT_ERROR */
    LONG                x;          /* case PT_NULL, PT_OBJECT (no usable value) */
} __UPV;

typedef struct _SPropValue
{
    ULONG       ulPropTag;
    ULONG       dwAlignPad;
    union _PV   Value;
} SPropValue, FAR * LPSPropValue;


/* --------------------------------------------- */
/* Property Problem and Property Problem Arrays */
/* --------------------------------------------- */

typedef struct _SPropProblem
{
    ULONG   ulIndex;
    ULONG   ulPropTag;
    SCODE   scode;
} SPropProblem, FAR * LPSPropProblem;

typedef struct _SPropProblemArray
{
    ULONG           cProblem;
    SPropProblem    aProblem[MAPI_DIM];
} SPropProblemArray, FAR * LPSPropProblemArray;

#define CbNewSPropProblemArray(_cprob) \
    (offsetof(SPropProblemArray,aProblem) + (_cprob)*sizeof(SPropProblem))
#define CbSPropProblemArray(_lparray) \
    (offsetof(SPropProblemArray,aProblem) + \
    (UINT) ((_lparray)->cProblem*sizeof(SPropProblem)))
#define SizedSPropProblemArray(_cprob, _name) \
struct _SPropProblemArray_ ## _name \
{ \
    ULONG           cProblem; \
    SPropProblem    aProblem[_cprob]; \
} _name

/*
 *  ENTRYLIST
 */

typedef SBinaryArray ENTRYLIST, FAR *LPENTRYLIST;

/*
 *  FLATENTRYLIST
 *  MTSID
 *  FLATMTSIDLIST
 */

typedef struct {
    ULONG cb;
    BYTE abEntry[MAPI_DIM];
} FLATENTRY, FAR *LPFLATENTRY;

typedef struct {
    ULONG       cEntries;
    ULONG       cbEntries;
    BYTE        abEntries[MAPI_DIM];
} FLATENTRYLIST, FAR *LPFLATENTRYLIST;

typedef struct {
    ULONG       cb;
    BYTE        ab[MAPI_DIM];
} MTSID, FAR *LPMTSID;

typedef struct {
    ULONG       cMTSIDs;
    ULONG       cbMTSIDs;
    BYTE        abMTSIDs[MAPI_DIM];
} FLATMTSIDLIST, FAR *LPFLATMTSIDLIST;

#define CbNewFLATENTRY(_cb)     (offsetof(FLATENTRY,abEntry) + (_cb))
#define CbFLATENTRY(_lpentry)   (offsetof(FLATENTRY,abEntry) + (_lpentry)->cb)
#define CbNewFLATENTRYLIST(_cb) (offsetof(FLATENTRYLIST,abEntries) + (_cb))
#define CbFLATENTRYLIST(_lplist) (offsetof(FLATENTRYLIST,abEntries) + (_lplist)->cbEntries)
#define CbNewMTSID(_cb)         (offsetof(MTSID,ab) + (_cb))
#define CbMTSID(_lpentry)       (offsetof(MTSID,ab) + (_lpentry)->cb)
#define CbNewFLATMTSIDLIST(_cb) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_cb))
#define CbFLATMTSIDLIST(_lplist) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_lplist)->cbMTSIDs)
/* No SizedXXX macros for these types. */

/* ------------------------------ */
/* ADRENTRY, ADRLIST */

typedef struct _ADRENTRY
{
    ULONG           ulReserved1;    /* Never used */
    ULONG           cValues;
    LPSPropValue    rgPropVals;
} ADRENTRY, FAR * LPADRENTRY;

typedef struct _ADRLIST
{
    ULONG           cEntries;
    ADRENTRY        aEntries[MAPI_DIM];
} ADRLIST, FAR * LPADRLIST;

#define CbNewADRLIST(_centries) \
    (offsetof(ADRLIST,aEntries) + (_centries)*sizeof(ADRENTRY))
#define CbADRLIST(_lpadrlist) \
    (offsetof(ADRLIST,aEntries) + (UINT)(_lpadrlist)->cEntries*sizeof(ADRENTRY))
#define SizedADRLIST(_centries, _name) \
struct _ADRLIST_ ## _name \
{ \
    ULONG           cEntries; \
    ADRENTRY        aEntries[_centries]; \
} _name

/* ------------------------------ */
/* SRow, SRowSet */

typedef struct _SRow
{
    ULONG           ulAdrEntryPad;  /* Pad so SRow's can map to ADRENTRY's */
    ULONG           cValues;        /* Count of property values */
    LPSPropValue    lpProps;        /* Property value array */
} SRow, FAR * LPSRow;

typedef struct _SRowSet
{
    ULONG           cRows;          /* Count of rows */
    SRow            aRow[MAPI_DIM]; /* Array of rows */
} SRowSet, FAR * LPSRowSet;

#define CbNewSRowSet(_crow)     (offsetof(SRowSet,aRow) + (_crow)*sizeof(SRow))
#define CbSRowSet(_lprowset)    (offsetof(SRowSet,aRow) + \
                                    (UINT)((_lprowset)->cRows*sizeof(SRow)))
#define SizedSRowSet(_crow, _name) \
struct _SRowSet_ ## _name \
{ \
    ULONG           cRows; \
    SRow            aRow[_crow]; \
} _name

/* MAPI Allocation Routines ------------------------------------------------ */

typedef SCODE (STDMETHODCALLTYPE ALLOCATEBUFFER)(
    ULONG           cbSize,
    LPVOID FAR *    lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE ALLOCATEMORE)(
    ULONG           cbSize,
    LPVOID          lpObject,
    LPVOID FAR *    lppBuffer
);

typedef ULONG (STDAPICALLTYPE FREEBUFFER)(
    LPVOID          lpBuffer
);

typedef ALLOCATEBUFFER FAR *LPALLOCATEBUFFER;
typedef ALLOCATEMORE FAR *  LPALLOCATEMORE;
typedef FREEBUFFER FAR *    LPFREEBUFFER;

/* MAPI Component Object Model Macros -------------------------------------- */

#if defined(MAPI_IF) && (!defined(__cplusplus) || defined(CINTERFACE))
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface;            \
        struct iface##Vtbl
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_MAPI_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface, FAR * FAR * piface;
#else
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        DECLARE_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_INTERFACE_(iface, baseiface)
#ifdef __cplusplus
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        interface iface; typedef iface FAR * piface
#else
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef interface iface iface, FAR * piface
#endif
#endif

#define MAPIMETHOD(method)              MAPIMETHOD_(HRESULT, method)
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)
#define MAPIMETHOD_DECLARE(type, method, prefix) \
        STDMETHODIMP_(type) prefix##method
#define MAPIMETHOD_TYPEDEF(type, method, prefix) \
        typedef type (STDMETHODCALLTYPE prefix##method##_METHOD)

#define MAPI_IUNKNOWN_METHODS(IPURE)                                    \
    MAPIMETHOD(QueryInterface)                                          \
        (THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;                 \
    MAPIMETHOD_(ULONG,AddRef)  (THIS) IPURE;                            \
    MAPIMETHOD_(ULONG,Release) (THIS) IPURE;                            \

#undef  IMPL
#define IMPL

/* Pointers to MAPI Interfaces --------------------------------------------- */

typedef const IID FAR * LPCIID;

DECLARE_MAPI_INTERFACE_PTR(IMsgStore,       LPMDB);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFolder,     LPMAPIFOLDER);
DECLARE_MAPI_INTERFACE_PTR(IMessage,        LPMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IAttach,         LPATTACH);
DECLARE_MAPI_INTERFACE_PTR(IAddrBook,       LPADRBOOK);
DECLARE_MAPI_INTERFACE_PTR(IABContainer,    LPABCONT);
DECLARE_MAPI_INTERFACE_PTR(IMailUser,       LPMAILUSER);
DECLARE_MAPI_INTERFACE_PTR(IDistList,       LPDISTLIST);
DECLARE_MAPI_INTERFACE_PTR(IMAPIStatus,     LPMAPISTATUS);
DECLARE_MAPI_INTERFACE_PTR(IMAPITable,      LPMAPITABLE);
DECLARE_MAPI_INTERFACE_PTR(IProfSect,       LPPROFSECT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProp,       LPMAPIPROP);
DECLARE_MAPI_INTERFACE_PTR(IMAPIContainer,  LPMAPICONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIAdviseSink, LPMAPIADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProgress,   LPMAPIPROGRESS);
DECLARE_MAPI_INTERFACE_PTR(IProviderAdmin,  LPPROVIDERADMIN);

/* Extended MAPI Error Information ----------------------------------------- */

typedef struct _MAPIERROR
{
    ULONG   ulVersion;
    LPTSTR  lpszError;
    LPTSTR  lpszComponent;
    ULONG   ulLowLevelError;
    ULONG   ulContext;

} MAPIERROR, FAR * LPMAPIERROR;


/* IMAPIAdviseSink Interface ----------------------------------------------- */

/*
 *  Notification event types. The event types can be combined in a bitmask
 *  for filtering. Each one has a parameter structure associated with it:
 *
 *      fnevCriticalError       ERROR_NOTIFICATION
 *      fnevNewMail             NEWMAIL_NOTIFICATION
 *      fnevObjectCreated       OBJECT_NOTIFICATION
 *      fnevObjectDeleted       OBJECT_NOTIFICATION
 *      fnevObjectModified      OBJECT_NOTIFICATION
 *      fnevObjectCopied        OBJECT_NOTIFICATION
 *      fnevSearchComplete      OBJECT_NOTIFICATION
 *      fnevTableModified       TABLE_NOTIFICATION
 *      fnevStatusObjectModified ?
 *
 *      fnevExtended            EXTENDED_NOTIFICATION
 */

#define fnevCriticalError           ((ULONG) 0x00000001)
#define fnevNewMail                 ((ULONG) 0x00000002)
#define fnevObjectCreated           ((ULONG) 0x00000004)
#define fnevObjectDeleted           ((ULONG) 0x00000008)
#define fnevObjectModified          ((ULONG) 0x00000010)
#define fnevObjectMoved             ((ULONG) 0x00000020)
#define fnevObjectCopied            ((ULONG) 0x00000040)
#define fnevSearchComplete          ((ULONG) 0x00000080)
#define fnevTableModified           ((ULONG) 0x00000100)
#define fnevStatusObjectModified    ((ULONG) 0x00000200)
#define fnevReservedForMapi         ((ULONG) 0x40000000)
#define fnevExtended                ((ULONG) 0x80000000)

/* TABLE_NOTIFICATION event types passed in ulTableEvent */

#define TABLE_CHANGED       1
#define TABLE_ERROR         2
#define TABLE_ROW_ADDED     3
#define TABLE_ROW_DELETED   4
#define TABLE_ROW_MODIFIED  5
#define TABLE_SORT_DONE     6
#define TABLE_RESTRICT_DONE 7
#define TABLE_SETCOL_DONE   8
#define TABLE_RELOAD        9

/* Event Structures */

typedef struct _ERROR_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;
    SCODE       scode;
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPMAPIERROR lpMAPIError;        /* Detailed error information */
} ERROR_NOTIFICATION;

typedef struct _NEWMAIL_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;          /* identifies the new message */
    ULONG       cbParentID;
    LPENTRYID   lpParentID;         /* identifies the folder it lives in */
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPTSTR      lpszMessageClass;   /* message class (UNICODE or string8) */
    ULONG       ulMessageFlags;     /* copy of PR_MESSAGE_FLAGS */
} NEWMAIL_NOTIFICATION;

typedef struct _OBJECT_NOTIFICATION
{
    ULONG               cbEntryID;
    LPENTRYID           lpEntryID;      /* EntryID of object */
    ULONG               ulObjType;      /* Type of object */
    ULONG               cbParentID;
    LPENTRYID           lpParentID;     /* EntryID of parent object */
    ULONG               cbOldID;
    LPENTRYID           lpOldID;        /* EntryID of old object */
    ULONG               cbOldParentID;
    LPENTRYID           lpOldParentID;  /* EntryID of old parent */
    LPSPropTagArray     lpPropTagArray;
} OBJECT_NOTIFICATION;

typedef struct _TABLE_NOTIFICATION
{
    ULONG               ulTableEvent;   /* Identifies WHICH table event */
    HRESULT             hResult;        /* Value for TABLE_ERROR */
    SPropValue          propIndex;      /* This row's "index property" */
    SPropValue          propPrior;      /* Preceding row's "index property" */
    SRow                row;            /* New data of added/modified row */
    ULONG               ulPad;          /* Force to 8-byte boundary */
} TABLE_NOTIFICATION;

typedef struct _EXTENDED_NOTIFICATION
{
    ULONG       ulEvent;                    /* extended event code */
    ULONG       cb;                         /* size of event parameters */
    LPBYTE      pbEventParameters;          /* event parameters */
} EXTENDED_NOTIFICATION;

typedef struct
{
    ULONG           cbEntryID;
    LPENTRYID       lpEntryID;
    ULONG           cValues;
    LPSPropValue    lpPropVals;
} STATUS_OBJECT_NOTIFICATION;

typedef struct _NOTIFICATION
{
    ULONG   ulEventType;        /* notification type, i.e. fnevSomething */
    ULONG   ulAlignPad;         /* Force to 8-byte boundary */
    union
    {
        ERROR_NOTIFICATION          err;
        NEWMAIL_NOTIFICATION        newmail;
        OBJECT_NOTIFICATION         obj;
        TABLE_NOTIFICATION          tab;
        EXTENDED_NOTIFICATION       ext;
        STATUS_OBJECT_NOTIFICATION  statobj;
    } info;
} NOTIFICATION, FAR * LPNOTIFICATION;


/* Interface used for registering and issuing notification callbacks. */

#define MAPI_IMAPIADVISESINK_METHODS(IPURE)                             \
    MAPIMETHOD_(ULONG, OnNotify)                                        \
        (THIS_  ULONG                       cNotif,                     \
                LPNOTIFICATION              lpNotifications) IPURE;     \

#undef       INTERFACE
#define      INTERFACE  IMAPIAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIADVISESINK_METHODS(PURE)
};

/* Callback function type for MAPIAllocAdviseSink */

typedef long (STDAPICALLTYPE NOTIFCALLBACK) (
    LPVOID          lpvContext,
    ULONG           cNotification,
    LPNOTIFICATION  lpNotifications);
typedef NOTIFCALLBACK FAR * LPNOTIFCALLBACK;

/*
 *  Message name for the 16-bit MAPI notififcation engine.
 *  This can be used in 16-bit applications to force processing
 *  of notification callbacks.
 */

#ifdef  WIN16
#define szMAPINotificationMsg "MAPI Notify window message"
#endif


/* IMAPIProgress Interface ------------------------------------------------- */

/* Flag values for the progress indicator */

#define MAPI_TOP_LEVEL      ((ULONG) 0x00000001)

#define MAPI_IMAPIPROGRESS_METHODS(IPURE)                               \
    MAPIMETHOD(Progress)                                                \
        (THIS_  ULONG                       ulValue,                    \
                ULONG                       ulCount,                    \
                ULONG                       ulTotal) IPURE;             \
    MAPIMETHOD(GetFlags)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(GetMax)                                                  \
        (THIS_  ULONG FAR *                 lpulMax) IPURE;             \
    MAPIMETHOD(GetMin)                                                  \
        (THIS_  ULONG FAR *                 lpulMin) IPURE;             \
    MAPIMETHOD(SetLimits)                                               \
        (THIS_  LPULONG                     lpulMin,                    \
                LPULONG                     lpulMax,                    \
                LPULONG                     lpulFlags) IPURE;           \

#undef      INTERFACE
#define     INTERFACE   IMAPIProgress
DECLARE_MAPI_INTERFACE_(IMAPIProgress, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROGRESS_METHODS(PURE)
};


/* IMAPIProp Interface ----------------------------------------------------- */

/* GetLastError */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/*
 *  Version:
 */
#define MAPI_ERROR_VERSION      0x00000000L

/* GetPropList */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetProps */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* SaveChanges */

#define KEEP_OPEN_READONLY      ((ULONG) 0x00000001)
#define KEEP_OPEN_READWRITE     ((ULONG) 0x00000002)
#define FORCE_SAVE              ((ULONG) 0x00000004)
/* define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) below */

/* OpenProperty  - ulFlags */
/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
#define MAPI_CREATE             ((ULONG) 0x00000002)
#define STREAM_APPEND           ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* OpenProperty  - ulInterfaceOptions, IID_IMAPITable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* CopyTo, CopyProps */

#define MAPI_MOVE               ((ULONG) 0x00000001)
#define MAPI_NOREPLACE          ((ULONG) 0x00000002)
#define MAPI_DECLINE_OK         ((ULONG) 0x00000004)

#ifndef MAPI_DIALOG             /* also defined in mapi.h */
#define MAPI_DIALOG             ((ULONG) 0x00000008)
#endif

#ifndef MAPI_USE_DEFAULT        /* also defined in mapi.h */
#define MAPI_USE_DEFAULT        0x00000040  /* Use default profile in logon */
#endif

/* Flags used in GetIDsFromNames  */
/****** MAPI_CREATE             ((ULONG) 0x00000002) above */

/* Flags used in GetNamesFromIDs  (bit fields) */
#define MAPI_NO_STRINGS         ((ULONG) 0x00000001)
#define MAPI_NO_IDS             ((ULONG) 0x00000002)

/*  Union discriminator  */
#define MNID_ID                 0
#define MNID_STRING             1
typedef struct _MAPINAMEID
{
    LPGUID lpguid;
    ULONG ulKind;
    union {
        LONG lID;
        LPWSTR lpwstrName;
    } Kind;

} MAPINAMEID, FAR * LPMAPINAMEID;

#define MAPI_IMAPIPROP_METHODS(IPURE)                                   \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(SaveChanges)                                             \
        (THIS_ ULONG                        ulFlags) IPURE;             \
    MAPIMETHOD(GetProps)                                                \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppPropArray) IPURE;        \
    MAPIMETHOD(GetPropList)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTagArray) IPURE;     \
    MAPIMETHOD(OpenProperty)                                            \
        (THIS_  ULONG                       ulPropTag,                  \
                LPCIID                      lpiid,                      \
                ULONG                       ulInterfaceOptions,         \
                ULONG                       ulFlags,                    \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetProps)                                                \
        (THIS_  ULONG                       cValues,                    \
                LPSPropValue                lpPropArray,                \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DeleteProps)                                             \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyTo)                                                  \
        (THIS_  ULONG                       ciidExclude,                \
                LPCIID                      rgiidExclude,               \
                LPSPropTagArray             lpExcludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyProps)                                               \
        (THIS_  LPSPropTagArray             lpIncludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(GetNamesFromIDs)                                         \
        (THIS_  LPSPropTagArray FAR *       lppPropTags,                \
                LPGUID                      lpPropSetGuid,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcPropNames,               \
                LPMAPINAMEID FAR * FAR *    lpppPropNames) IPURE;       \
    MAPIMETHOD(GetIDsFromNames)                                         \
        (THIS_  ULONG                       cPropNames,                 \
                LPMAPINAMEID FAR *          lppPropNames,               \
                ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTags) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IMAPIProp
DECLARE_MAPI_INTERFACE_(IMAPIProp, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
};

/* IMAPITable Interface ---------------------------------------------------- */

/* Table status */

#define TBLSTAT_COMPLETE            ((ULONG) 0)
#define TBLSTAT_QCHANGED            ((ULONG) 7)
#define TBLSTAT_SORTING             ((ULONG) 9)
#define TBLSTAT_SORT_ERROR          ((ULONG) 10)
#define TBLSTAT_SETTING_COLS        ((ULONG) 11)
#define TBLSTAT_SETCOL_ERROR        ((ULONG) 13)
#define TBLSTAT_RESTRICTING         ((ULONG) 14)
#define TBLSTAT_RESTRICT_ERROR      ((ULONG) 15)


/* Table Type */

#define TBLTYPE_SNAPSHOT            ((ULONG) 0)
#define TBLTYPE_KEYSET              ((ULONG) 1)
#define TBLTYPE_DYNAMIC             ((ULONG) 2)


/* Sort order */

/* bit 0: set if descending, clear if ascending */

#define TABLE_SORT_ASCEND       ((ULONG) 0x00000000)
#define TABLE_SORT_DESCEND      ((ULONG) 0x00000001)
#define TABLE_SORT_COMBINE      ((ULONG) 0x00000002)


/* Data structures */

typedef struct _SSortOrder
{
    ULONG   ulPropTag;          /* Column to sort on */
    ULONG   ulOrder;            /* Ascending, descending, combine to left */
} SSortOrder, FAR * LPSSortOrder;

typedef struct _SSortOrderSet
{
    ULONG           cSorts;     /* Number of sort columns in aSort below*/
    ULONG           cCategories;    /* 0 for non-categorized, up to cSorts */
    ULONG           cExpanded;      /* 0 if no categories start expanded, */
                                    /*      up to cExpanded */
    SSortOrder      aSort[MAPI_DIM];    /* The sort orders */
} SSortOrderSet, FAR * LPSSortOrderSet;

#define CbNewSSortOrderSet(_csort) \
    (offsetof(SSortOrderSet,aSort) + (_csort)*sizeof(SSortOrder))
#define CbSSortOrderSet(_lpset) \
    (offsetof(SSortOrderSet,aSort) + \
    (UINT)((_lpset)->cSorts*sizeof(SSortOrder)))
#define SizedSSortOrderSet(_csort, _name) \
struct _SSortOrderSet_ ## _name \
{ \
    ULONG           cSorts;         \
    ULONG           cCategories;    \
    ULONG           cExpanded;      \
    SSortOrder      aSort[_csort];  \
} _name

typedef ULONG       BOOKMARK;

#define BOOKMARK_BEGINNING  ((BOOKMARK) 0)      /* Before first row */
#define BOOKMARK_CURRENT    ((BOOKMARK) 1)      /* Before current row */
#define BOOKMARK_END        ((BOOKMARK) 2)      /* After last row */

/* Fuzzy Level */

#define FL_FULLSTRING       ((ULONG) 0x00000000)
#define FL_SUBSTRING        ((ULONG) 0x00000001)
#define FL_PREFIX           ((ULONG) 0x00000002)

#define FL_IGNORECASE       ((ULONG) 0x00010000)
#define FL_IGNORENONSPACE   ((ULONG) 0x00020000)
#define FL_LOOSE            ((ULONG) 0x00040000)

/* Restrictions */

typedef struct _SRestriction    FAR * LPSRestriction;

/* Restriction types */

#define RES_AND             ((ULONG) 0x00000000)
#define RES_OR              ((ULONG) 0x00000001)
#define RES_NOT             ((ULONG) 0x00000002)
#define RES_CONTENT         ((ULONG) 0x00000003)
#define RES_PROPERTY        ((ULONG) 0x00000004)
#define RES_COMPAREPROPS    ((ULONG) 0x00000005)
#define RES_BITMASK         ((ULONG) 0x00000006)
#define RES_SIZE            ((ULONG) 0x00000007)
#define RES_EXIST           ((ULONG) 0x00000008)
#define RES_SUBRESTRICTION  ((ULONG) 0x00000009)
#define RES_COMMENT         ((ULONG) 0x0000000A)

/* Relational operators. These apply to all property comparison restrictions. */

#define RELOP_LT        ((ULONG) 0)     /* <  */
#define RELOP_LE        ((ULONG) 1)     /* <= */
#define RELOP_GT        ((ULONG) 2)     /* >  */
#define RELOP_GE        ((ULONG) 3)     /* >= */
#define RELOP_EQ        ((ULONG) 4)     /* == */
#define RELOP_NE        ((ULONG) 5)     /* != */
#define RELOP_RE        ((ULONG) 6)     /* LIKE (Regular expression) */

/* Bitmask operators, for RES_BITMASK only. */

#define BMR_EQZ     ((ULONG) 0)     /* ==0 */
#define BMR_NEZ     ((ULONG) 1)     /* !=0 */

/* Subobject identifiers for RES_SUBRESTRICTION only. See MAPITAGS.H. */

/* #define PR_MESSAGE_RECIPIENTS  PROP_TAG(PT_OBJECT,0x0E12) */
/* #define PR_MESSAGE_ATTACHMENTS PROP_TAG(PT_OBJECT,0x0E13) */

typedef struct _SAndRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SAndRestriction;

typedef struct _SOrRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SOrRestriction;

typedef struct _SNotRestriction
{
    ULONG           ulReserved;
    LPSRestriction  lpRes;
} SNotRestriction;

typedef struct _SContentRestriction
{
    ULONG           ulFuzzyLevel;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SContentRestriction;

typedef struct _SBitMaskRestriction
{
    ULONG           relBMR;
    ULONG           ulPropTag;
    ULONG           ulMask;
} SBitMaskRestriction;

typedef struct _SPropertyRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SPropertyRestriction;

typedef struct _SComparePropsRestriction
{
    ULONG           relop;
    ULONG           ulPropTag1;
    ULONG           ulPropTag2;
} SComparePropsRestriction;

typedef struct _SSizeRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    ULONG           cb;
} SSizeRestriction;

typedef struct _SExistRestriction
{
    ULONG           ulReserved1;
    ULONG           ulPropTag;
    ULONG           ulReserved2;
} SExistRestriction;

typedef struct _SSubRestriction
{
    ULONG           ulSubObject;
    LPSRestriction  lpRes;
} SSubRestriction;

typedef struct _SCommentRestriction
{
    ULONG           cValues; /* # of properties in lpProp */
    LPSRestriction  lpRes;
    LPSPropValue    lpProp;
} SCommentRestriction;

typedef struct _SRestriction
{
    ULONG   rt;         /* Restriction type */
    union
    {
        SComparePropsRestriction    resCompareProps;    /* first */
        SAndRestriction             resAnd;
        SOrRestriction              resOr;
        SNotRestriction             resNot;
        SContentRestriction         resContent;
        SPropertyRestriction        resProperty;
        SBitMaskRestriction         resBitMask;
        SSizeRestriction            resSize;
        SExistRestriction           resExist;
        SSubRestriction             resSub;
        SCommentRestriction         resComment;
    } res;
} SRestriction;

/* SComparePropsRestriction is first in the union so that */
/* static initializations of 3-value restriction work.    */

/* Flags of the methods of IMAPITable */

/* QueryColumn */

#define TBL_ALL_COLUMNS     ((ULONG) 0x00000001)

/* QueryRows */
/* Possible values for PR_ROW_TYPE (for categorization) */

#define TBL_LEAF_ROW            ((ULONG) 1)
#define TBL_EMPTY_CATEGORY      ((ULONG) 2)
#define TBL_EXPANDED_CATEGORY   ((ULONG) 3)
#define TBL_COLLAPSED_CATEGORY  ((ULONG) 4)

/* Table wait flag */

#define TBL_NOWAIT          ((ULONG) 0x00000001)
/* alternative name for TBL_NOWAIT */
#define TBL_ASYNC           ((ULONG) 0x00000001)
#define TBL_BATCH           ((ULONG) 0x00000002)

/* FindRow */

#define DIR_BACKWARD        ((ULONG) 0x00000001)

/* Table cursor states */

#define TBL_NOADVANCE       ((ULONG) 0x00000001)

#define MAPI_IMAPITABLE_METHODS(IPURE)                                  \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(GetStatus)                                               \
        (THIS_  ULONG FAR *                 lpulTableStatus,            \
                ULONG FAR *                 lpulTableType) IPURE;       \
    MAPIMETHOD(SetColumns)                                              \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QueryColumns)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lpPropTagArray) IPURE;      \
    MAPIMETHOD(GetRowCount)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulCount) IPURE;           \
    MAPIMETHOD(SeekRow)                                                 \
        (THIS_  BOOKMARK                    bkOrigin,                   \
                LONG                        lRowCount,                  \
                LONG FAR *                  lplRowsSought) IPURE;       \
    MAPIMETHOD(SeekRowApprox)                                           \
        (THIS_  ULONG                       ulNumerator,                \
                ULONG                       ulDenominator) IPURE;       \
    MAPIMETHOD(QueryPosition)                                           \
        (THIS_  ULONG FAR *                 lpulRow,                    \
                ULONG FAR *                 lpulNumerator,              \
                ULONG FAR *                 lpulDenominator) IPURE;     \
    MAPIMETHOD(FindRow)                                                 \
        (THIS_  LPSRestriction              lpRestriction,              \
                BOOKMARK                    bkOrigin,                   \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(Restrict)                                                \
        (THIS_  LPSRestriction              lpRestriction,              \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateBookmark)                                          \
        (THIS_  BOOKMARK FAR *              lpbkPosition) IPURE;        \
    MAPIMETHOD(FreeBookmark)                                            \
        (THIS_  BOOKMARK                    bkPosition) IPURE;          \
    MAPIMETHOD(SortTable)                                               \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QuerySortOrder)                                          \
        (THIS_  LPSSortOrderSet FAR *       lppSortCriteria) IPURE;     \
    MAPIMETHOD(QueryRows)                                               \
        (THIS_  LONG                        lRowCount,                  \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows) IPURE;             \
    MAPIMETHOD(Abort) (THIS) IPURE;                                     \
    MAPIMETHOD(ExpandRow)                                               \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulRowCount,                 \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows,                    \
                ULONG FAR *                 lpulMoreRows) IPURE;        \
    MAPIMETHOD(CollapseRow)                                             \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulRowCount) IPURE;        \
    MAPIMETHOD(WaitForCompletion)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       ulTimeout,                  \
                ULONG FAR *                 lpulTableStatus) IPURE;     \
    MAPIMETHOD(GetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbInstanceKey,              \
                LPBYTE                      lpbInstanceKey,             \
                ULONG FAR *                 lpcbCollapseState,          \
                LPBYTE FAR *                lppbCollapseState) IPURE;   \
    MAPIMETHOD(SetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbCollapseState,            \
                LPBYTE                      pbCollapseState,            \
                BOOKMARK FAR *              lpbkLocation) IPURE;        \

#undef       INTERFACE
#define      INTERFACE  IMAPITable
DECLARE_MAPI_INTERFACE_(IMAPITable, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPITABLE_METHODS(PURE)
};

/* IProfSect Interface ----------------------------------------------------- */

/* Standard section for public profile properties */

#define PS_PROFILE_PROPERTIES_INIT \
{   0x98, 0x15, 0xAC, 0x08, 0xAA, 0xB0, 0x10, 0x1A, \
    0x8C, 0x93, 0x08, 0x00, 0x2B, 0x2A, 0x56, 0xC2  }


#define MAPI_IPROFSECT_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IProfSect
DECLARE_MAPI_INTERFACE_(IProfSect, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IPROFSECT_METHODS(PURE)
};

/* IMAPIStatus Interface --------------------------------------------------- */

/* Values for PR_RESOURCE_TYPE, _METHODS, _FLAGS */

#define MAPI_STORE_PROVIDER     ((ULONG) 33)    /* Message Store */
#define MAPI_AB                 ((ULONG) 34)    /* Address Book */
#define MAPI_AB_PROVIDER        ((ULONG) 35)    /* Address Book Provider */
#define MAPI_TRANSPORT_PROVIDER ((ULONG) 36)    /* Transport Provider */
#define MAPI_SPOOLER            ((ULONG) 37)    /* Message Spooler */
#define MAPI_PROFILE_PROVIDER   ((ULONG) 38)    /* Profile Provider */
#define MAPI_SUBSYSTEM          ((ULONG) 39)    /* Overall Subsystem Status */
#define MAPI_HOOK_PROVIDER      ((ULONG) 40)    /* Spooler Hook */

#define STATUS_VALIDATE_STATE   ((ULONG) 0x00000001)
#define STATUS_SETTINGS_DIALOG  ((ULONG) 0x00000002)
#define STATUS_CHANGE_PASSWORD  ((ULONG) 0x00000004)
#define STATUS_FLUSH_QUEUES     ((ULONG) 0x00000008)

#define STATUS_DEFAULT_OUTBOUND ((ULONG) 0x00000001)
#define STATUS_DEFAULT_STORE    ((ULONG) 0x00000002)
#define STATUS_PRIMARY_IDENTITY ((ULONG) 0x00000004)
#define STATUS_SIMPLE_STORE     ((ULONG) 0x00000008)
#define STATUS_XP_PREFER_LAST   ((ULONG) 0x00000010)
#define STATUS_NO_PRIMARY_IDENTITY ((ULONG) 0x00000020)
#define STATUS_NO_DEFAULT_STORE ((ULONG) 0x00000040)
#define STATUS_TEMP_SECTION     ((ULONG) 0x00000080)
#define STATUS_OWN_STORE        ((ULONG) 0x00000100)
/****** HOOK_INBOUND            ((ULONG) 0x00000200) Defined in MAPIHOOK.H */
/****** HOOK_OUTBOUND           ((ULONG) 0x00000400) Defined in MAPIHOOK.H */
#define STATUS_NEED_IPM_TREE    ((ULONG) 0x00000800)


/*
 * PR_STATUS_CODE bit. Low 16 bits for common values; High 16 bits
 * for provider type-specific values. (DCR 304)
 */

#define STATUS_AVAILABLE        ((ULONG) 0x00000001)
#define STATUS_OFFLINE          ((ULONG) 0x00000002)
#define STATUS_FAILURE          ((ULONG) 0x00000004)

/* Transport values of PR_STATUS_CODE */

#define STATUS_INBOUND_ENABLED  ((ULONG) 0x00010000)
#define STATUS_INBOUND_ACTIVE   ((ULONG) 0x00020000)
#define STATUS_INBOUND_FLUSH    ((ULONG) 0x00040000)
#define STATUS_OUTBOUND_ENABLED ((ULONG) 0x00100000)
#define STATUS_OUTBOUND_ACTIVE  ((ULONG) 0x00200000)
#define STATUS_OUTBOUND_FLUSH   ((ULONG) 0x00400000)
#define STATUS_REMOTE_ACCESS    ((ULONG) 0x00800000)

/* ValidateState flags */

#define SUPPRESS_UI                 ((ULONG) 0x00000001)
#define REFRESH_XP_HEADER_CACHE     ((ULONG) 0x00010000)
#define PROCESS_XP_HEADER_CACHE     ((ULONG) 0x00020000)
#define FORCE_XP_CONNECT            ((ULONG) 0x00040000)
#define FORCE_XP_DISCONNECT         ((ULONG) 0x00080000)
#define CONFIG_CHANGED              ((ULONG) 0x00100000)
#define ABORT_XP_HEADER_OPERATION   ((ULONG) 0x00200000)
#define SHOW_XP_SESSION_UI          ((ULONG) 0x00400000)

/* SettingsDialog flags */

#define UI_READONLY     ((ULONG) 0x00000001)

/* FlushQueues flags */

#define FLUSH_UPLOAD        ((ULONG) 0x00000002)
#define FLUSH_DOWNLOAD      ((ULONG) 0x00000004)
#define FLUSH_FORCE         ((ULONG) 0x00000008)
#define FLUSH_NO_UI         ((ULONG) 0x00000010)

#define MAPI_IMAPISTATUS_METHODS(IPURE)                                 \
    MAPIMETHOD(ValidateState)                                           \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SettingsDialog)                                          \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ChangePassword)                                          \
        (THIS_  LPTSTR                      lpOldPass,                  \
                LPTSTR                      lpNewPass,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(FlushQueues)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       cbTargetTransport,          \
                LPENTRYID                   lpTargetTransport,          \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMAPIStatus
DECLARE_MAPI_INTERFACE_(IMAPIStatus, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPISTATUS_METHODS(PURE)
};

/* IMAPIContainer Interface ------------------------------------------------ */

/* Flags for OpenEntry() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
#define MAPI_BEST_ACCESS        ((ULONG) 0x00000010)

/* GetContentsTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED         ((ULONG) 0x00000040) below */

/* GetHierarchyTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define CONVENIENT_DEPTH        ((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* GetSearchCriteria */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define SEARCH_RUNNING          ((ULONG) 0x00000001)
#define SEARCH_REBUILD          ((ULONG) 0x00000002)
#define SEARCH_RECURSIVE        ((ULONG) 0x00000004)
#define SEARCH_FOREGROUND       ((ULONG) 0x00000008)

/* SetSearchCriteria */
#define STOP_SEARCH             ((ULONG) 0x00000001)
#define RESTART_SEARCH          ((ULONG) 0x00000002)
#define RECURSIVE_SEARCH        ((ULONG) 0x00000004)
#define SHALLOW_SEARCH          ((ULONG) 0x00000008)
#define FOREGROUND_SEARCH       ((ULONG) 0x00000010)
#define BACKGROUND_SEARCH       ((ULONG) 0x00000020)

#define MAPI_IMAPICONTAINER_METHODS(IPURE)                              \
    MAPIMETHOD(GetContentsTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(GetHierarchyTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetSearchCriteria)                                       \
        (THIS_  LPSRestriction              lpRestriction,              \
                LPENTRYLIST                 lpContainerList,            \
                ULONG                       ulSearchFlags) IPURE;       \
    MAPIMETHOD(GetSearchCriteria)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRestriction FAR *        lppRestriction,             \
                LPENTRYLIST FAR *           lppContainerList,           \
                ULONG FAR *                 lpulSearchState)IPURE;      \

#undef       INTERFACE
#define      INTERFACE  IMAPIContainer
DECLARE_MAPI_INTERFACE_(IMAPIContainer, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
};

/* IABContainer Interface -------------------------------------------------- */

/*
 *  IABContainer PR_CONTAINER_FLAGS values
 *  If AB_UNMODIFIABLE and AB_MODIFIABLE are both set, it means the container
 *  doesn't know if it's modifiable or not, and the client should
 *  try to modify the contents but we won't expect it to work.
 *  If the AB_RECIPIENTS flag is set and neither AB_MODIFIABLE or AB_UNMODIFIABLE
 *  bits are set, it is an error.
 */

typedef struct _flaglist
{
    ULONG cFlags;
    ULONG ulFlag[MAPI_DIM];
} FlagList, FAR * LPFlagList;


/*
 *  Container flags
 */
#define AB_RECIPIENTS           ((ULONG) 0x00000001)
#define AB_SUBCONTAINERS        ((ULONG) 0x00000002)
#define AB_MODIFIABLE           ((ULONG) 0x00000004)
#define AB_UNMODIFIABLE         ((ULONG) 0x00000008)
#define AB_FIND_ON_OPEN         ((ULONG) 0x00000010)

/* CreateEntry() */

#define CREATE_CHECK_DUP_STRICT ((ULONG) 0x00000001)
#define CREATE_CHECK_DUP_LOOSE  ((ULONG) 0x00000002)
#define CREATE_REPLACE          ((ULONG) 0x00000004)

/* ResolveNames() - ulFlags */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* ResolveNames() - rgulFlags */
#define MAPI_UNRESOLVED         ((ULONG) 0x00000000)
#define MAPI_AMBIGUOUS          ((ULONG) 0x00000001)
#define MAPI_RESOLVED           ((ULONG) 0x00000002)


#define MAPI_IABCONTAINER_METHODS(IPURE)                                \
    MAPIMETHOD(CreateEntry)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulCreateFlags,              \
                LPMAPIPROP FAR  *           lppMAPIPropEntry) IPURE;    \
    MAPIMETHOD(CopyEntries)                                             \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteEntries)                                           \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ResolveNames)                                            \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                LPADRLIST                   lpAdrList,                  \
                LPFlagList                  lpFlagList) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IABContainer
DECLARE_MAPI_INTERFACE_(IABContainer, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IABCONTAINER_METHODS(PURE)
};

/* IMailUser Interface ----------------------------------------------------- */

/* Values of PR_NDR_DIAG_CODE */

#define MAPI_DIAG(_code)    ((LONG) _code)

#define MAPI_DIAG_NO_DIAGNOSTIC                     MAPI_DIAG( -1 )
#define MAPI_DIAG_OR_NAME_UNRECOGNIZED              MAPI_DIAG( 0 )
#define MAPI_DIAG_OR_NAME_AMBIGUOUS                 MAPI_DIAG( 1 )
#define MAPI_DIAG_MTS_CONGESTED                     MAPI_DIAG( 2 )
#define MAPI_DIAG_LOOP_DETECTED                     MAPI_DIAG( 3 )
#define MAPI_DIAG_RECIPIENT_UNAVAILABLE             MAPI_DIAG( 4 )
#define MAPI_DIAG_MAXIMUM_TIME_EXPIRED              MAPI_DIAG( 5 )
#define MAPI_DIAG_EITS_UNSUPPORTED                  MAPI_DIAG( 6 )
#define MAPI_DIAG_CONTENT_TOO_LONG                  MAPI_DIAG( 7 )
#define MAPI_DIAG_IMPRACTICAL_TO_CONVERT            MAPI_DIAG( 8 )
#define MAPI_DIAG_PROHIBITED_TO_CONVERT             MAPI_DIAG( 9 )
#define MAPI_DIAG_CONVERSION_UNSUBSCRIBED           MAPI_DIAG( 10 )
#define MAPI_DIAG_PARAMETERS_INVALID                MAPI_DIAG( 11 )
#define MAPI_DIAG_CONTENT_SYNTAX_IN_ERROR           MAPI_DIAG( 12 )
#define MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD         MAPI_DIAG( 13 )
#define MAPI_DIAG_NUMBER_CONSTRAINT_VIOLATD         MAPI_DIAG( 14 )
#define MAPI_DIAG_CONTENT_TYPE_UNSUPPORTED          MAPI_DIAG( 15 )
#define MAPI_DIAG_TOO_MANY_RECIPIENTS               MAPI_DIAG( 16 )
#define MAPI_DIAG_NO_BILATERAL_AGREEMENT            MAPI_DIAG( 17 )
#define MAPI_DIAG_CRITICAL_FUNC_UNSUPPORTED         MAPI_DIAG( 18 )
#define MAPI_DIAG_CONVERSION_LOSS_PROHIB            MAPI_DIAG( 19 )
#define MAPI_DIAG_LINE_TOO_LONG                     MAPI_DIAG( 20 )
#define MAPI_DIAG_PAGE_TOO_LONG                     MAPI_DIAG( 21 )
#define MAPI_DIAG_PICTORIAL_SYMBOL_LOST             MAPI_DIAG( 22 )
#define MAPI_DIAG_PUNCTUATION_SYMBOL_LOST           MAPI_DIAG( 23 )
#define MAPI_DIAG_ALPHABETIC_CHARACTER_LOST         MAPI_DIAG( 24 )
#define MAPI_DIAG_MULTIPLE_INFO_LOSSES              MAPI_DIAG( 25 )
#define MAPI_DIAG_REASSIGNMENT_PROHIBITED           MAPI_DIAG( 26 )
#define MAPI_DIAG_REDIRECTION_LOOP_DETECTED         MAPI_DIAG( 27 )
#define MAPI_DIAG_EXPANSION_PROHIBITED              MAPI_DIAG( 28 )
#define MAPI_DIAG_SUBMISSION_PROHIBITED             MAPI_DIAG( 29 )
#define MAPI_DIAG_EXPANSION_FAILED                  MAPI_DIAG( 30 )
#define MAPI_DIAG_RENDITION_UNSUPPORTED             MAPI_DIAG( 31 )
#define MAPI_DIAG_MAIL_ADDRESS_INCORRECT            MAPI_DIAG( 32 )
#define MAPI_DIAG_MAIL_OFFICE_INCOR_OR_INVD         MAPI_DIAG( 33 )
#define MAPI_DIAG_MAIL_ADDRESS_INCOMPLETE           MAPI_DIAG( 34 )
#define MAPI_DIAG_MAIL_RECIPIENT_UNKNOWN            MAPI_DIAG( 35 )
#define MAPI_DIAG_MAIL_RECIPIENT_DECEASED           MAPI_DIAG( 36 )
#define MAPI_DIAG_MAIL_ORGANIZATION_EXPIRED         MAPI_DIAG( 37 )
#define MAPI_DIAG_MAIL_REFUSED                      MAPI_DIAG( 38 )
#define MAPI_DIAG_MAIL_UNCLAIMED                    MAPI_DIAG( 39 )
#define MAPI_DIAG_MAIL_RECIPIENT_MOVED              MAPI_DIAG( 40 )
#define MAPI_DIAG_MAIL_RECIPIENT_TRAVELLING         MAPI_DIAG( 41 )
#define MAPI_DIAG_MAIL_RECIPIENT_DEPARTED           MAPI_DIAG( 42 )
#define MAPI_DIAG_MAIL_NEW_ADDRESS_UNKNOWN          MAPI_DIAG( 43 )
#define MAPI_DIAG_MAIL_FORWARDING_UNWANTED          MAPI_DIAG( 44 )
#define MAPI_DIAG_MAIL_FORWARDING_PROHIB            MAPI_DIAG( 45 )
#define MAPI_DIAG_SECURE_MESSAGING_ERROR            MAPI_DIAG( 46 )
#define MAPI_DIAG_DOWNGRADING_IMPOSSIBLE            MAPI_DIAG( 47 )


#define MAPI_IMAILUSER_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IMailUser
DECLARE_MAPI_INTERFACE_(IMailUser, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAILUSER_METHODS(PURE)
};

/* IDistList Interface ----------------------------------------------------- */

#define MAPI_IDISTLIST_METHODS(IPURE)                                   \
    MAPIMETHOD(CreateEntry)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulCreateFlags,              \
                LPMAPIPROP FAR  *           lppMAPIPropEntry) IPURE;    \
    MAPIMETHOD(CopyEntries)                                             \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteEntries)                                           \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ResolveNames)                                            \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                LPADRLIST                   lpAdrList,                  \
                LPFlagList                  lpFlagList) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IDistList
DECLARE_MAPI_INTERFACE_(IDistList, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IDISTLIST_METHODS(PURE)
};

/* IMAPIFolder Interface --------------------------------------------------- */

/* IMAPIFolder folder type (enum) */

#define FOLDER_ROOT             ((ULONG) 0x00000000)
#define FOLDER_GENERIC          ((ULONG) 0x00000001)
#define FOLDER_SEARCH           ((ULONG) 0x00000002)

/* CreateMessage */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED         ((ULONG) 0x00000040) below */

/* CopyMessages */

#define MESSAGE_MOVE            ((ULONG) 0x00000001)
#define MESSAGE_DIALOG          ((ULONG) 0x00000002)
/****** MAPI_DECLINE_OK         ((ULONG) 0x00000004) above */

/* CreateFolder */

#define OPEN_IF_EXISTS          ((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* DeleteFolder */

#define DEL_MESSAGES            ((ULONG) 0x00000001)
#define FOLDER_DIALOG           ((ULONG) 0x00000002)
#define DEL_FOLDERS             ((ULONG) 0x00000004)

/* EmptyFolder */
#define DEL_ASSOCIATED          ((ULONG) 0x00000008)

/* CopyFolder */

#define FOLDER_MOVE             ((ULONG) 0x00000001)
/****** FOLDER_DIALOG           ((ULONG) 0x00000002) above */
/****** MAPI_DECLINE_OK         ((ULONG) 0x00000004) above */
#define COPY_SUBFOLDERS         ((ULONG) 0x00000010)
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */


/* SetReadFlags */

/****** SUPPRESS_RECEIPT        ((ULONG) 0x00000001) below */
/****** MESSAGE_DIALOG          ((ULONG) 0x00000002) above */
/****** CLEAR_READ_FLAG         ((ULONG) 0x00000004) below */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
#define GENERATE_RECEIPT_ONLY   ((ULONG) 0x00000010)


/* GetMessageStatus */

#define MSGSTATUS_HIGHLIGHTED   ((ULONG) 0x00000001)
#define MSGSTATUS_TAGGED        ((ULONG) 0x00000002)
#define MSGSTATUS_HIDDEN        ((ULONG) 0x00000004)
#define MSGSTATUS_DELMARKED     ((ULONG) 0x00000008)

/* Bits for remote message status */

#define MSGSTATUS_REMOTE_DOWNLOAD   ((ULONG) 0x00001000)
#define MSGSTATUS_REMOTE_DELETE     ((ULONG) 0x00002000)

/* SaveContentsSort */

#define RECURSIVE_SORT          ((ULONG) 0x00000002)

/* PR_STATUS property */

#define FLDSTATUS_HIGHLIGHTED   ((ULONG) 0x00000001)
#define FLDSTATUS_TAGGED        ((ULONG) 0x00000002)
#define FLDSTATUS_HIDDEN        ((ULONG) 0x00000004)
#define FLDSTATUS_DELMARKED     ((ULONG) 0x00000008)

#define MAPI_IMAPIFOLDER_METHODS(IPURE)                                 \
    MAPIMETHOD(CreateMessage)                                           \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMESSAGE FAR *             lppMessage) IPURE;          \
    MAPIMETHOD(CopyMessages)                                            \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestFolder,               \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteMessages)                                          \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateFolder)                                            \
        (THIS_  ULONG                       ulFolderType,               \
                LPTSTR                      lpszFolderName,             \
                LPTSTR                      lpszFolderComment,          \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMAPIFOLDER FAR *          lppFolder) IPURE;           \
    MAPIMETHOD(CopyFolder)                                              \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestFolder,               \
                LPTSTR                      lpszNewFolderName,          \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteFolder)                                            \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetReadFlags)                                            \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetMessageStatus)                                        \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulMessageStatus) IPURE;   \
    MAPIMETHOD(SetMessageStatus)                                        \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulNewStatus,                \
                ULONG                       ulNewStatusMask,            \
                ULONG FAR *                 lpulOldStatus) IPURE;       \
    MAPIMETHOD(SaveContentsSort)                                        \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(EmptyFolder)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMAPIFolder
DECLARE_MAPI_INTERFACE_(IMAPIFolder, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IMAPIFOLDER_METHODS(PURE)
};

/* IMsgStore Interface ----------------------------------------------------- */

/*  PR_STORE_SUPPORT_MASK bits */
#define STORE_ENTRYID_UNIQUE    ((ULONG) 0x00000001)
#define STORE_READONLY          ((ULONG) 0x00000002)
#define STORE_SEARCH_OK         ((ULONG) 0x00000004)
#define STORE_MODIFY_OK         ((ULONG) 0x00000008)
#define STORE_CREATE_OK         ((ULONG) 0x00000010)
#define STORE_ATTACH_OK         ((ULONG) 0x00000020)
#define STORE_OLE_OK            ((ULONG) 0x00000040)
#define STORE_SUBMIT_OK         ((ULONG) 0x00000080)
#define STORE_NOTIFY_OK         ((ULONG) 0x00000100)
#define STORE_MV_PROPS_OK       ((ULONG) 0x00000200)
#define STORE_CATEGORIZE_OK     ((ULONG) 0x00000400)
#define STORE_RTF_OK            ((ULONG) 0x00000800)
#define STORE_RESTRICTION_OK    ((ULONG) 0x00001000)
#define STORE_SORT_OK           ((ULONG) 0x00002000)


/* OpenEntry() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
/****** MAPI_BEST_ACCESS        ((ULONG) 0x00000010) above */

/* SetReceiveFolder() */

/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetReceiveFolder() */

/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetReceiveFolderTable() */

/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* StoreLogoff() */

#define LOGOFF_NO_WAIT          ((ULONG) 0x00000001)
#define LOGOFF_ORDERLY          ((ULONG) 0x00000002)
#define LOGOFF_PURGE            ((ULONG) 0x00000004)
#define LOGOFF_ABORT            ((ULONG) 0x00000008)
#define LOGOFF_QUIET            ((ULONG) 0x00000010)

#define LOGOFF_COMPLETE         ((ULONG) 0x00010000)
#define LOGOFF_INBOUND          ((ULONG) 0x00020000)
#define LOGOFF_OUTBOUND         ((ULONG) 0x00040000)
#define LOGOFF_OUTBOUND_QUEUE   ((ULONG) 0x00080000)

/* SetLockState() */

#define MSG_LOCKED              ((ULONG) 0x00000001)
#define MSG_UNLOCKED            ((ULONG) 0x00000000)

/* Flag bits for PR_VALID_FOLDER_MASK */

#define FOLDER_IPM_SUBTREE_VALID        ((ULONG) 0x00000001)
#define FOLDER_IPM_INBOX_VALID          ((ULONG) 0x00000002)
#define FOLDER_IPM_OUTBOX_VALID         ((ULONG) 0x00000004)
#define FOLDER_IPM_WASTEBASKET_VALID    ((ULONG) 0x00000008)
#define FOLDER_IPM_SENTMAIL_VALID       ((ULONG) 0x00000010)
#define FOLDER_VIEWS_VALID              ((ULONG) 0x00000020)
#define FOLDER_COMMON_VIEWS_VALID       ((ULONG) 0x00000040)
#define FOLDER_FINDER_VALID             ((ULONG) 0x00000080)

#define MAPI_IMSGSTORE_METHODS(IPURE)                                   \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetReceiveFolder)                                        \
        (THIS_  LPTSTR                      lpszMessageClass,           \
                ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(GetReceiveFolder)                                        \
        (THIS_  LPTSTR                      lpszMessageClass,           \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID,                 \
                LPTSTR FAR *                lppszExplicitClass) IPURE;  \
    MAPIMETHOD(GetReceiveFolderTable)                                   \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(StoreLogoff)                                             \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(AbortSubmit)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetOutgoingQueue)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(SetLockState)                                            \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                ULONG                       ulLockState) IPURE;         \
    MAPIMETHOD(FinishedMsg)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(NotifyNewMail)                                           \
        (THIS_  LPNOTIFICATION              lpNotification) IPURE;      \

#undef       INTERFACE
#define      INTERFACE  IMsgStore
DECLARE_MAPI_INTERFACE_(IMsgStore, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMSGSTORE_METHODS(PURE)
};

/* IMessage Interface ------------------------------------------------------ */

/* SubmitMessage */

#define FORCE_SUBMIT                ((ULONG) 0x00000001)

/* Flags defined in PR_MESSAGE_FLAGS */

#define MSGFLAG_READ            ((ULONG) 0x00000001)
#define MSGFLAG_UNMODIFIED      ((ULONG) 0x00000002)
#define MSGFLAG_SUBMIT          ((ULONG) 0x00000004)
#define MSGFLAG_UNSENT          ((ULONG) 0x00000008)
#define MSGFLAG_HASATTACH       ((ULONG) 0x00000010)
#define MSGFLAG_FROMME          ((ULONG) 0x00000020)
#define MSGFLAG_ASSOCIATED      ((ULONG) 0x00000040)
#define MSGFLAG_RESEND          ((ULONG) 0x00000080)

/* Flags defined in PR_SUBMIT_FLAGS */

#define SUBMITFLAG_LOCKED       ((ULONG) 0x00000001)
#define SUBMITFLAG_PREPROCESS   ((ULONG) 0x00000002)

/* GetAttachmentTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetRecipientTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* ModifyRecipients */

/* ((ULONG) 0x00000001 is not a valid flag on ModifyRecipients. */
#define MODRECIP_ADD            ((ULONG) 0x00000002)
#define MODRECIP_MODIFY         ((ULONG) 0x00000004)
#define MODRECIP_REMOVE         ((ULONG) 0x00000008)

/* SetReadFlag */

#define SUPPRESS_RECEIPT        ((ULONG) 0x00000001)
#define CLEAR_READ_FLAG         ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** GENERATE_RECEIPT_ONLY   ((ULONG) 0x00000010) above */

/* DeleteAttach */

#define ATTACH_DIALOG           ((ULONG) 0x00000001)

/* PR_SECURITY values */
#define SECURITY_SIGNED         ((ULONG) 0x00000001)
#define SECURITY_ENCRYPTED      ((ULONG) 0x00000002)

/* PR_PRIORITY values */
#define PRIO_URGENT             ((long)  1)
#define PRIO_NORMAL             ((long)  0)
#define PRIO_NONURGENT          ((long) -1)

/* PR_SENSITIVITY values */
#define SENSITIVITY_NONE                    ((ULONG) 0x00000000)
#define SENSITIVITY_PERSONAL                ((ULONG) 0x00000001)
#define SENSITIVITY_PRIVATE                 ((ULONG) 0x00000002)
#define SENSITIVITY_COMPANY_CONFIDENTIAL    ((ULONG) 0x00000003)

/* PR_IMPORTANCE values */
#define IMPORTANCE_LOW          ((long) 0)
#define IMPORTANCE_NORMAL       ((long) 1)
#define IMPORTANCE_HIGH         ((long) 2)

#define MAPI_IMESSAGE_METHODS(IPURE)                                    \
    MAPIMETHOD(GetAttachmentTable)                                      \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenAttach)                                              \
        (THIS_  ULONG                       ulAttachmentNum,            \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPATTACH FAR *              lppAttach) IPURE;           \
    MAPIMETHOD(CreateAttach)                                            \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulAttachmentNum,          \
                LPATTACH FAR *              lppAttach) IPURE;           \
    MAPIMETHOD(DeleteAttach)                                            \
        (THIS_  ULONG                       ulAttachmentNum,            \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetRecipientTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(ModifyRecipients)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPADRLIST                   lpMods) IPURE;              \
    MAPIMETHOD(SubmitMessage)                                           \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetReadFlag)                                             \
        (THIS_  ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMessage
DECLARE_MAPI_INTERFACE_(IMessage, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMESSAGE_METHODS(PURE)
};

/* IAttach Interface ------------------------------------------------------- */

/* IAttach attachment methods: PR_ATTACH_METHOD values */

#define NO_ATTACHMENT           ((ULONG) 0x00000000)
#define ATTACH_BY_VALUE         ((ULONG) 0x00000001)
#define ATTACH_BY_REFERENCE     ((ULONG) 0x00000002)
#define ATTACH_BY_REF_RESOLVE   ((ULONG) 0x00000003)
#define ATTACH_BY_REF_ONLY      ((ULONG) 0x00000004)
#define ATTACH_EMBEDDED_MSG     ((ULONG) 0x00000005)
#define ATTACH_OLE              ((ULONG) 0x00000006)

#define MAPI_IATTACH_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IAttach
DECLARE_MAPI_INTERFACE_(IAttach, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IATTACH_METHODS(PURE)
};

/* --------------------------------- */
/* Address Book interface definition */

/* ADRPARM ulFlags - top 4 bits used for versioning */

#define GET_ADRPARM_VERSION(ulFlags)  (((ULONG)ulFlags) & 0xF0000000)
#define SET_ADRPARM_VERSION(ulFlags, ulVersion)  (((ULONG)ulVersion) | (((ULONG)ulFlags) & 0x0FFFFFFF))

/*  Current versions of ADRPARM  */
#define ADRPARM_HELP_CTX        ((ULONG) 0x00000000)


/*  ulFlags   - bit fields */
#define DIALOG_MODAL            ((ULONG) 0x00000001)
#define DIALOG_SDI              ((ULONG) 0x00000002)
#define DIALOG_OPTIONS          ((ULONG) 0x00000004)
#define ADDRESS_ONE             ((ULONG) 0x00000008)
#define AB_SELECTONLY           ((ULONG) 0x00000010)
#define AB_RESOLVE              ((ULONG) 0x00000020)

/* --------------------------------- */
/*  PR_DISPLAY_TYPEs                 */
/*
 *  These standard display types are
 *  by default handled by MAPI.
 *  They have default icons associated
 *  with them.
 */

/*  For address book contents tables */
#define DT_MAILUSER         ((ULONG) 0x00000000)
#define DT_DISTLIST         ((ULONG) 0x00000001)
#define DT_FORUM            ((ULONG) 0x00000002)
#define DT_AGENT            ((ULONG) 0x00000003)
#define DT_ORGANIZATION     ((ULONG) 0x00000004)
#define DT_PRIVATE_DISTLIST ((ULONG) 0x00000005)
#define DT_REMOTE_MAILUSER  ((ULONG) 0x00000006)

/*  For address book hierarchy tables */
#define DT_MODIFIABLE       ((ULONG) 0x00010000)
#define DT_GLOBAL           ((ULONG) 0x00020000)
#define DT_LOCAL            ((ULONG) 0x00030000)
#define DT_WAN              ((ULONG) 0x00040000)
#define DT_NOT_SPECIFIC     ((ULONG) 0x00050000)

/*  For folder hierarchy tables */
#define DT_FOLDER           ((ULONG) 0x01000000)
#define DT_FOLDER_LINK      ((ULONG) 0x02000000)

/*  Accelerator callback for DIALOG_SDI form of AB UI */
typedef BOOL (STDMETHODCALLTYPE ACCELERATEABSDI)(ULONG ulUIParam,
                                                LPVOID lpvmsg);
typedef ACCELERATEABSDI FAR * LPFNABSDI;

/*  Callback to application telling it that the DIALOG_SDI form of the */
/*  AB UI has been dismissed.  This is so that the above LPFNABSDI     */
/*  function doesn't keep being called.                                */
typedef void (STDMETHODCALLTYPE DISMISSMODELESS)(ULONG ulUIParam,
                                                LPVOID lpvContext);
typedef DISMISSMODELESS FAR * LPFNDISMISS;

/*
 * Prototype for the client function hooked to an optional button on
 * the address book dialog
 */

typedef SCODE (STDMETHODCALLTYPE FAR * LPFNBUTTON)(
    ULONG               ulUIParam,
    LPVOID              lpvContext,
    ULONG               cbEntryID,
    LPENTRYID           lpSelection,
    ULONG               ulFlags
);


/* Parameters for the address book dialog */
typedef struct _ADRPARM
{
    ULONG           cbABContEntryID;
    LPENTRYID       lpABContEntryID;
    ULONG           ulFlags;

    LPVOID          lpReserved;
    ULONG           ulHelpContext;
    LPTSTR          lpszHelpFileName;

    LPFNABSDI       lpfnABSDI;
    LPFNDISMISS     lpfnDismiss;
    LPVOID          lpvDismissContext;
    LPTSTR          lpszCaption;
    LPTSTR          lpszNewEntryTitle;
    LPTSTR          lpszDestWellsTitle;
    ULONG           cDestFields;
    ULONG           nDestFieldFocus;
    LPTSTR FAR *    lppszDestTitles;
    ULONG FAR *     lpulDestComps;
    LPSRestriction  lpContRestriction;
    LPSRestriction  lpHierRestriction;
} ADRPARM, FAR * LPADRPARM;


/* ------------ */
/* Random flags */

/* Flag for deferred error */
#define MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008)

/* Flag for creating and using Folder Associated Information Messages */
#define MAPI_ASSOCIATED         ((ULONG) 0x00000040)

/* Flags for OpenMessageStore() */

#define MDB_NO_DIALOG           ((ULONG) 0x00000001)
#define MDB_WRITE               ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) above */
/****** MAPI_BEST_ACCESS        ((ULONG) 0x00000010) above */
#define MDB_TEMPORARY           ((ULONG) 0x00000020)
#define MDB_NO_MAIL             ((ULONG) 0x00000080)

/* Flags for OpenAddressBook */

#define AB_NO_DIALOG            ((ULONG) 0x00000001)

/* IMAPIControl Interface -------------------------------------------------- */

/* Interface used in controls (particularly the button) defined by */
/* Display Tables. */

/*  Flags for GetState */

#define  MAPI_ENABLED       ((ULONG) 0x00000000)
#define  MAPI_DISABLED      ((ULONG) 0x00000001)

#define MAPI_IMAPICONTROL_METHODS(IPURE)                                \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Activate)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       ulUIParam) IPURE;           \
    MAPIMETHOD(GetState)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulState) IPURE;           \

#undef       INTERFACE
#define      INTERFACE  IMAPIControl
DECLARE_MAPI_INTERFACE_(IMAPIControl, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPICONTROL_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPIControl, LPMAPICONTROL);

/* Display Tables ---------------------------------------------------------- */

/* Flags used in display tables - that is, PR_CONTROL_FLAGS */

#define DT_MULTILINE        ((ULONG) 0x00000001)
#define DT_EDITABLE         ((ULONG) 0x00000002)
#define DT_REQUIRED         ((ULONG) 0x00000004)
#define DT_SET_IMMEDIATE    ((ULONG) 0x00000008)
#define DT_PASSWORD_EDIT    ((ULONG) 0x00000010)
#define DT_ACCEPT_DBCS      ((ULONG) 0x00000020)
#define DT_SET_SELECTION    ((ULONG) 0x00000040)

/* Display Table structures */

#define DTCT_LABEL          ((ULONG) 0x00000000)
#define DTCT_EDIT           ((ULONG) 0x00000001)
#define DTCT_LBX            ((ULONG) 0x00000002)
#define DTCT_COMBOBOX       ((ULONG) 0x00000003)
#define DTCT_DDLBX          ((ULONG) 0x00000004)
#define DTCT_CHECKBOX       ((ULONG) 0x00000005)
#define DTCT_GROUPBOX       ((ULONG) 0x00000006)
#define DTCT_BUTTON         ((ULONG) 0x00000007)
#define DTCT_PAGE           ((ULONG) 0x00000008)
#define DTCT_RADIOBUTTON    ((ULONG) 0x00000009)
#define DTCT_INKEDIT        ((ULONG) 0x0000000A)
#define DTCT_MVLISTBOX      ((ULONG) 0x0000000B)
#define DTCT_MVDDLBX        ((ULONG) 0x0000000C)

/* Labels */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLLABEL
{
    ULONG ulbLpszLabelName;
    ULONG ulFlags;
} DTBLLABEL, FAR * LPDTBLLABEL;
#define SizedDtblLabel(n,u) \
struct _DTBLLABEL_ ## u \
{ \
    DTBLLABEL   dtbllabel; \
    TCHAR       lpszLabelName[n]; \
} u


/*  Simple Text Edits  */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLEDIT
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPropTag;
} DTBLEDIT, FAR * LPDTBLEDIT;
#define SizedDtblEdit(n,u) \
struct _DTBLEDIT_ ## u \
{ \
    DTBLEDIT    dtbledit; \
    TCHAR       lpszCharsAllowed[n]; \
} u

/*  Ink Aware Edits  */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLINKEDIT
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulTextPropTag;
    ULONG ulInkDataPropTag;
} DTBLINKEDIT, FAR * LPDTBLINKEDIT;
#define SizedDtblInkEdit(n,u) \
struct _DTBLINKEDIT_ ## u \
{ \
    DTBLINKEDIT dtblinkedit; \
    TCHAR       lpszCharsAllowed[n]; \
} u


/*  List Box  */
/* Valid ulFlags:
 */
#define MAPI_NO_HBAR        ((ULONG) 0x00000001)
#define MAPI_NO_VBAR        ((ULONG) 0x00000002)

typedef struct _DTBLLBX
{
    ULONG ulFlags;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
} DTBLLBX, FAR * LPDTBLLBX;


/*  Combo Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCOMBOBOX
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPRPropertyName;
    ULONG ulPRTableName;
} DTBLCOMBOBOX, FAR * LPDTBLCOMBOBOX;
#define SizedDtblComboBox(n,u) \
struct _DTBLCOMBOBOX_ ## u \
{ \
    DTBLCOMBOBOX    dtblcombobox; \
    TCHAR           lpszCharsAllowed[n]; \
} u


/*  Drop Down   */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLDDLBX
{
    ULONG ulFlags;
    ULONG ulPRDisplayProperty;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
} DTBLDDLBX, FAR * LPDTBLDDLBX;


/*  Check Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCHECKBOX
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRPropertyName;
} DTBLCHECKBOX, FAR * LPDTBLCHECKBOX;
#define SizedDtblCheckBox(n,u) \
struct _DTBLCHECKBOX_ ## u \
{ \
    DTBLCHECKBOX    dtblcheckbox; \
    TCHAR       lpszLabel[n]; \
} u



/*  Group Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLGROUPBOX
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
} DTBLGROUPBOX, FAR * LPDTBLGROUPBOX;
#define SizedDtblGroupBox(n,u) \
struct _DTBLGROUPBOX_ ## u \
{ \
    DTBLGROUPBOX    dtblgroupbox; \
    TCHAR           lpszLabel[n]; \
} u

/*  Button control   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLBUTTON
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRControl;
} DTBLBUTTON, FAR * LPDTBLBUTTON;
#define SizedDtblButton(n,u) \
struct _DTBLBUTTON_ ## u \
{ \
    DTBLBUTTON  dtblbutton; \
    TCHAR       lpszLabel[n]; \
} u

/*  Pages   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLPAGE
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulbLpszComponent;
    ULONG ulContext;
} DTBLPAGE, FAR * LPDTBLPAGE;
#define SizedDtblPage(n,n1,u) \
struct _DTBLPAGE_ ## u \
{ \
    DTBLPAGE    dtblpage; \
    TCHAR       lpszLabel[n]; \
    TCHAR       lpszComponent[n1]; \
} u

/*  Radio button   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLRADIOBUTTON
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulcButtons;
    ULONG ulPropTag;
    long lReturnValue;
} DTBLRADIOBUTTON, FAR * LPDTBLRADIOBUTTON;
#define SizedDtblRadioButton(n,u) \
struct _DTBLRADIOBUTTON_ ## u \
{ \
    DTBLRADIOBUTTON dtblradiobutton; \
    TCHAR           lpszLabel[n]; \
} u


/*  MultiValued listbox */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVLISTBOX
{
    ULONG ulFlags;
    ULONG ulMVPropTag;
} DTBLMVLISTBOX, FAR * LPDTBLMVLISTBOX;


/*  MultiValued dropdown */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVDDLBX
{
    ULONG ulFlags;
    ULONG ulMVPropTag;
} DTBLMVDDLBX, FAR * LPDTBLMVDDLBX;





/* IProviderAdmin Interface ---------------------------------------------- */

/* Flags for ConfigureMsgService */

#define UI_SERVICE                  0x00000002
#define SERVICE_UI_ALWAYS           0x00000002      /* Duplicate UI_SERVICE for consistency and compatibility */
#define SERVICE_UI_ALLOWED          0x00000010
#define UI_CURRENT_PROVIDER_FIRST   0x00000004
/* MSG_SERVICE_UI_READ_ONLY         0x00000008 - in MAPISPI.H */

/* GetProviderTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define MAPI_IPROVIDERADMIN_METHODS(IPURE)                              \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetProviderTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(CreateProvider)                                          \
        (THIS_  LPTSTR                      lpszProvider,               \
                ULONG                       cValues,                    \
                LPSPropValue                lpProps,                    \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                MAPIUID FAR *               lpUID) IPURE;               \
    MAPIMETHOD(DeleteProvider)                                          \
        (THIS_  LPMAPIUID                   lpUID) IPURE;               \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfSect) IPURE;         \


#undef       INTERFACE
#define      INTERFACE  IProviderAdmin
DECLARE_MAPI_INTERFACE_(IProviderAdmin, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IPROVIDERADMIN_METHODS(PURE)
};



#ifdef  __cplusplus
}       /*  extern "C" */
#endif

#endif /* MAPIDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\mapicode.h ===
/*
 *  M A P I C O D E . H
 *
 *  Status Codes returned by MAPI routines
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPICODE_H
#define MAPICODE_H

/* Define S_OK and ITF_* */

#ifdef WIN32
#include <objerror.h>
#endif

/*
 *  MAPI Status codes follow the style of OLE 2.0 sCodes as defined in the
 *  OLE 2.0 Programmer's Reference and header file scode.h (Windows 3.x)
 *  or objerror.h (Windows NT 3.5 and Windows 4.0).
 *
 */

/*  On Windows 3.x, status codes have 32-bit values as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+---------------------+-------+-------------------------------+
 *  |S|       Context       | Facil |               Code            |
 *  +-+---------------------+-------+-------------------------------+
 *
 *  where
 *
 *      S - is the severity code
 *
 *          0 - SEVERITY_SUCCESS
 *          1 - SEVERITY_ERROR
 *
 *      Context - context info
 *
 *      Facility - is the facility code
 *
 *          0x0 - FACILITY_NULL     generally useful errors ([SE]_*)
 *          0x1 - FACILITY_RPC      remote procedure call errors (RPC_E_*)
 *          0x2 - FACILITY_DISPATCH late binding dispatch errors
 *          0x3 - FACILITY_STORAGE  storage errors (STG_E_*)
 *          0x4 - FACILITY_ITF      interface-specific errors
 *
 *      Code - is the facility's status code
 *
 *
 */

/*
 *  On Windows NT 3.5 and Windows 4.0, scodes are 32-bit values
 *  laid out as follows:
 *  
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *  
 *   where
 *  
 *      S - Severity - indicates success/fail
 *  
 *          0 - Success
 *          1 - Fail (COERROR)
 *  
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *  
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *  
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *  
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *  
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *  
 *      Code - is the facility's status code
 *  
 */




/*
 *  We can't use OLE 2.0 macros to build sCodes because the definition has
 *  changed and we wish to conform to the new definition.
 */
#define MAKE_MAPI_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/* The following two macros are used to build OLE 2.0 style sCodes */

#define MAKE_MAPI_E( err )  (MAKE_MAPI_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_MAPI_S( warn ) (MAKE_MAPI_SCODE( 0, FACILITY_ITF, warn ))

#ifdef  SUCCESS_SUCCESS
#undef  SUCCESS_SUCCESS
#endif
#define SUCCESS_SUCCESS     0L

/* General errors (used by more than one MAPI object) */

#define MAPI_E_CALL_FAILED                              E_FAIL
#define MAPI_E_NOT_ENOUGH_MEMORY                        E_OUTOFMEMORY
#define MAPI_E_INVALID_PARAMETER                        E_INVALIDARG
#define MAPI_E_INTERFACE_NOT_SUPPORTED                  E_NOINTERFACE
#define MAPI_E_NO_ACCESS                                E_ACCESSDENIED

#define MAPI_E_NO_SUPPORT                               MAKE_MAPI_E( 0x102 )
#define MAPI_E_BAD_CHARWIDTH                            MAKE_MAPI_E( 0x103 )
#define MAPI_E_STRING_TOO_LONG                          MAKE_MAPI_E( 0x105 )
#define MAPI_E_UNKNOWN_FLAGS                            MAKE_MAPI_E( 0x106 )
#define MAPI_E_INVALID_ENTRYID                          MAKE_MAPI_E( 0x107 )
#define MAPI_E_INVALID_OBJECT                           MAKE_MAPI_E( 0x108 )
#define MAPI_E_OBJECT_CHANGED                           MAKE_MAPI_E( 0x109 )
#define MAPI_E_OBJECT_DELETED                           MAKE_MAPI_E( 0x10A )
#define MAPI_E_BUSY                                     MAKE_MAPI_E( 0x10B )
#define MAPI_E_NOT_ENOUGH_DISK                          MAKE_MAPI_E( 0x10D )
#define MAPI_E_NOT_ENOUGH_RESOURCES                     MAKE_MAPI_E( 0x10E )
#define MAPI_E_NOT_FOUND                                MAKE_MAPI_E( 0x10F )
#define MAPI_E_VERSION                                  MAKE_MAPI_E( 0x110 )
#define MAPI_E_LOGON_FAILED                             MAKE_MAPI_E( 0x111 )
#define MAPI_E_SESSION_LIMIT                            MAKE_MAPI_E( 0x112 )
#define MAPI_E_USER_CANCEL                              MAKE_MAPI_E( 0x113 )
#define MAPI_E_UNABLE_TO_ABORT                          MAKE_MAPI_E( 0x114 )
#define MAPI_E_NETWORK_ERROR                            MAKE_MAPI_E( 0x115 )
#define MAPI_E_DISK_ERROR                               MAKE_MAPI_E( 0x116 )
#define MAPI_E_TOO_COMPLEX                              MAKE_MAPI_E( 0x117 )
#define MAPI_E_BAD_COLUMN                               MAKE_MAPI_E( 0x118 )
#define MAPI_E_EXTENDED_ERROR                           MAKE_MAPI_E( 0x119 )
#define MAPI_E_COMPUTED                                 MAKE_MAPI_E( 0x11A )
#define MAPI_E_CORRUPT_DATA                             MAKE_MAPI_E( 0x11B )
#define MAPI_E_UNCONFIGURED                             MAKE_MAPI_E( 0x11C )
#define MAPI_E_FAILONEPROVIDER                          MAKE_MAPI_E( 0x11D )

/* MAPI base function and status object specific errors and warnings */

#define MAPI_E_END_OF_SESSION                           MAKE_MAPI_E( 0x200 )
#define MAPI_E_UNKNOWN_ENTRYID                          MAKE_MAPI_E( 0x201 )
#define MAPI_E_MISSING_REQUIRED_COLUMN                  MAKE_MAPI_E( 0x202 )
#define MAPI_W_NO_SERVICE                               MAKE_MAPI_S( 0x203 )

/* Property specific errors and warnings */

#define MAPI_E_BAD_VALUE                                MAKE_MAPI_E( 0x301 )
#define MAPI_E_INVALID_TYPE                             MAKE_MAPI_E( 0x302 )
#define MAPI_E_TYPE_NO_SUPPORT                          MAKE_MAPI_E( 0x303 )
#define MAPI_E_UNEXPECTED_TYPE                          MAKE_MAPI_E( 0x304 )
#define MAPI_E_TOO_BIG                                  MAKE_MAPI_E( 0x305 )
#define MAPI_E_DECLINE_COPY                             MAKE_MAPI_E( 0x306 )
#define MAPI_E_UNEXPECTED_ID                            MAKE_MAPI_E( 0x307 )

#define MAPI_W_ERRORS_RETURNED                          MAKE_MAPI_S( 0x380 )

/* Table specific errors and warnings */

#define MAPI_E_UNABLE_TO_COMPLETE                       MAKE_MAPI_E( 0x400 )
#define MAPI_E_TIMEOUT                                  MAKE_MAPI_E( 0x401 )
#define MAPI_E_TABLE_EMPTY                              MAKE_MAPI_E( 0x402 )
#define MAPI_E_TABLE_TOO_BIG                            MAKE_MAPI_E( 0x403 )

#define MAPI_E_INVALID_BOOKMARK                         MAKE_MAPI_E( 0x405 )

#define MAPI_W_POSITION_CHANGED                         MAKE_MAPI_S( 0x481 )
#define MAPI_W_APPROX_COUNT                             MAKE_MAPI_S( 0x482 )

/* Transport specific errors and warnings */

#define MAPI_E_WAIT                                     MAKE_MAPI_E( 0x500 )
#define MAPI_E_CANCEL                                   MAKE_MAPI_E( 0x501 )
#define MAPI_E_NOT_ME                                   MAKE_MAPI_E( 0x502 )

#define MAPI_W_CANCEL_MESSAGE                           MAKE_MAPI_S( 0x580 )

/* Message Store, Folder, and Message specific errors and warnings */

#define MAPI_E_CORRUPT_STORE                            MAKE_MAPI_E( 0x600 )
#define MAPI_E_NOT_IN_QUEUE                             MAKE_MAPI_E( 0x601 )
#define MAPI_E_NO_SUPPRESS                              MAKE_MAPI_E( 0x602 )
#define MAPI_E_COLLISION                                MAKE_MAPI_E( 0x604 )
#define MAPI_E_NOT_INITIALIZED                          MAKE_MAPI_E( 0x605 )
#define MAPI_E_NON_STANDARD                             MAKE_MAPI_E( 0x606 )
#define MAPI_E_NO_RECIPIENTS                            MAKE_MAPI_E( 0x607 )
#define MAPI_E_SUBMITTED                                MAKE_MAPI_E( 0x608 )
#define MAPI_E_HAS_FOLDERS                              MAKE_MAPI_E( 0x609 )
#define MAPI_E_HAS_MESSAGES                             MAKE_MAPI_E( 0x60A )
#define MAPI_E_FOLDER_CYCLE                             MAKE_MAPI_E( 0x60B )

#define MAPI_W_PARTIAL_COMPLETION                       MAKE_MAPI_S( 0x680 )

/* Address Book specific errors and warnings */

#define MAPI_E_AMBIGUOUS_RECIP                          MAKE_MAPI_E( 0x700 )

/* The range 0x0800 to 0x08FF is reserved */

/* Obsolete typing shortcut that will go away eventually. */
#ifndef MakeResult
#define MakeResult(_s)  ResultFromScode(_s)
#endif

/* We expect these to eventually be defined by OLE, but for now,
 * here they are.  When OLE defines them they can be much more
 * efficient than these, but these are "proper" and don't make
 * use of any hidden tricks.
 */
#ifndef HR_SUCCEEDED
#define HR_SUCCEEDED(_hr) SUCCEEDED((SCODE)(_hr))
#define HR_FAILED(_hr) FAILED((SCODE)(_hr))
#endif

#endif  /* MAPICODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\mapidbg.h ===
/*
 *  M A P I D B G . H
 *
 *  Debugging support for MAPI service providers.
 *  Support functions are implemented in MAPIDBG.C.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef __MAPIDBG_H_
#define __MAPIDBG_H_

/*
 * Debugging Macros -------------------------------------------------------
 *
 *      IFDBG(x)        Results in the expression x if DEBUG is defined, or
 *                      to nothing if DEBUG is not defined
 *  
 *      IFNDBG(x)       Results in the expression x if DEBUG is not defined,
 *                      or to nothing if DEBUG is defined
 *  
 *      Unreferenced(a) Causes a to be referenced so that the compiler
 *                      doesn't issue warnings about unused local variables
 *                      which exist but are reserved for future use (eg
 *                      ulFlags in many cases)
 */

#if defined(DEBUG)
#define IFDBG(x)            x
#define IFNDBG(x)
#else
#define IFDBG(x)
#define IFNDBG(x)           x
#endif

#ifdef __cplusplus
#define EXTERN_C_BEGIN      extern "C" {
#define EXTERN_C_END        }
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif

#define dimensionof(a)      (sizeof(a)/sizeof(*(a)))

#define Unreferenced(a)     ((void)(a))

typedef long SCODE;
typedef unsigned long ULONG;
typedef unsigned long DWORD;

/*
 *   Assert Macros ---------------------------------------------------------
 *  
 *      Assert(a)       Displays a message indicating the file and line number
 *                      of this Assert() if a == 0.  OK'ing an assert traps
 *                      into the debugger.
 *  
 *      AssertSz(a,sz)  Works like an Assert(), but displays the string sz
 *                      along with the file and line number.
 *  
 *      Side asserts    A side assert works like an Assert(), but evaluates
 *                      'a' even when asserts are not enabled.
 *  
 *      NF asserts      A NF (Non-Fatal) assert works like an Assert(), but
 *                      continues instead of trapping into the debugger when
 *                      OK'ed.
 */

#if defined(DEBUG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)           x
#else
#define IFTRAP(x)           0
#endif

#define Trap()                                          IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Trap"))
#define TrapSz(psz)                                     IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz))
#define TrapSz1(psz,a1)                                 IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1))
#define TrapSz2(psz,a1,a2)                              IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2))
#define TrapSz3(psz,a1,a2,a3)                           IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3))
#define TrapSz4(psz,a1,a2,a3,a4)                        IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4))
#define TrapSz5(psz,a1,a2,a3,a4,a5)                     IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5))
#define TrapSz6(psz,a1,a2,a3,a4,a5,a6)                  IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6))
#define TrapSz7(psz,a1,a2,a3,a4,a5,a6,a7)               IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7))
#define TrapSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)            IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TrapSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)         IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

#define Assert(t)                                       IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define AssertSz(t,psz)                                 IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz),0))
#define AssertSz1(t,psz,a1)                             IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1),0))
#define AssertSz2(t,psz,a1,a2)                          IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2),0))
#define AssertSz3(t,psz,a1,a2,a3)                       IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define AssertSz4(t,psz,a1,a2,a3,a4)                    IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define AssertSz5(t,psz,a1,a2,a3,a4,a5)                 IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define AssertSz6(t,psz,a1,a2,a3,a4,a5,a6)              IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define AssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)           IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define AssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)        IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define AssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)     IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define SideAssert(t)                                   ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define SideAssertSz(t,psz)                             ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz)),0)
#define SideAssertSz1(t,psz,a1)                         ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1)),0)
#define SideAssertSz2(t,psz,a1,a2)                      ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2)),0)
#define SideAssertSz3(t,psz,a1,a2,a3)                   ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define SideAssertSz4(t,psz,a1,a2,a3,a4)                ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define SideAssertSz5(t,psz,a1,a2,a3,a4,a5)             ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define SideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)          ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define SideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)       ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define SideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)    ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define SideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9) ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

#define NFAssert(t)                                     IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define NFAssertSz(t,psz)                               IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz),0))
#define NFAssertSz1(t,psz,a1)                           IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1),0))
#define NFAssertSz2(t,psz,a1,a2)                        IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2),0))
#define NFAssertSz3(t,psz,a1,a2,a3)                     IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define NFAssertSz4(t,psz,a1,a2,a3,a4)                  IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define NFAssertSz5(t,psz,a1,a2,a3,a4,a5)               IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define NFAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)            IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define NFAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)         IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define NFAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)      IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define NFAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)   IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define NFSideAssert(t)                                 ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define NFSideAssertSz(t,psz)                           ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz)),0)
#define NFSideAssertSz1(t,psz,a1)                       ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1)),0)
#define NFSideAssertSz2(t,psz,a1,a2)                    ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2)),0)
#define NFSideAssertSz3(t,psz,a1,a2,a3)                 ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define NFSideAssertSz4(t,psz,a1,a2,a3,a4)              ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define NFSideAssertSz5(t,psz,a1,a2,a3,a4,a5)           ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define NFSideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)        ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define NFSideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)     ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define NFSideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)  ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define NFSideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)   ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

/*
 *   Trace Macros ------------------------------------------------------------
 *  
 *      DebugTrace          Use for arbitrary formatted output. It
 *                          takes exactly the same arguments as the
 *                          Windows wsprintf() function.
 *      DebugTraceResult    Shorthand for error tracing with an
 *                          HRESULT. Arguments are the name of the
 *                          function (not quoted) and the HRESULT.
 *      DebugTraceSc        Shorthand for error tracing with an
 *                          SCODE. Arguments are the name of the
 *                          function (not quoted) and the SCODE.
 *      DebugTraceArg       Shorthand for invalid parameter
 *                          tracing. Arguments are the name of the
 *                          function (not quoted) and a quoted
 *                          string describing the bad parameter.
 */

#if defined(DEBUG) || defined(TRACES_ENABLED)
#define IFTRACE(x)          x
#define DebugTrace          DebugTraceFn
#else
#define IFTRACE(x)          0
#define DebugTrace          1?0:DebugTraceFn
#endif

#define DebugTraceResult(f,hr)                          IFTRACE(((hr) ? DebugTraceFn(#f " returns 0x%08lX %s\n", GetScode(hr), SzDecodeScode(GetScode(hr))) : 0))
#define DebugTraceSc(f,sc)                              IFTRACE(((sc) ? DebugTraceFn(#f " returns 0x%08lX %s\n", sc, SzDecodeScode(sc)) : 0))
#define DebugTraceArg(f,s)                              IFTRACE(DebugTraceFn(#f ": bad parameter: " s "\n"))
#define DebugTraceLine()                                IFTRACE(DebugTraceFn("File %s, Line %i  \n",__FILE__,__LINE__))
#define DebugTraceProblems(sz, rgprob)                  IFTRACE(DebugTraceProblemsFn(sz, rgprob))

#define TraceSz(psz)                                    IFTRACE(DebugTraceFn("~" psz))
#define TraceSz1(psz,a1)                                IFTRACE(DebugTraceFn("~" psz,a1))
#define TraceSz2(psz,a1,a2)                             IFTRACE(DebugTraceFn("~" psz,a1,a2))
#define TraceSz3(psz,a1,a2,a3)                          IFTRACE(DebugTraceFn("~" psz,a1,a2,a3))
#define TraceSz4(psz,a1,a2,a3,a4)                       IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4))
#define TraceSz5(psz,a1,a2,a3,a4,a5)                    IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5))
#define TraceSz6(psz,a1,a2,a3,a4,a5,a6)                 IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6))
#define TraceSz7(psz,a1,a2,a3,a4,a5,a6,a7)              IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7))
#define TraceSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)           IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TraceSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)        IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

/* Debugging Functions ---------------------------------------------------- */

EXTERN_C_BEGIN

#ifdef WIN16
#define EXPORTDBG   __export
#else
#define EXPORTDBG
#endif

int EXPORTDBG __cdecl       DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
int EXPORTDBG __cdecl       DebugTraceFn(char *pszFormat, ...);
void EXPORTDBG __cdecl      DebugTraceProblemsFn(char *sz, void *rgprob);
char * EXPORTDBG __cdecl    SzDecodeScodeFn(SCODE sc);
char * EXPORTDBG __cdecl    SzDecodeUlPropTypeFn(unsigned long ulPropType);
char * EXPORTDBG __cdecl    SzDecodeUlPropTagFn(unsigned long ulPropTag);
unsigned long EXPORTDBG __cdecl UlPropTagFromSzFn(char *psz);
SCODE EXPORTDBG __cdecl     ScodeFromSzFn(char *psz);
void * EXPORTDBG __cdecl    DBGMEM_EncapsulateFn(void * pmalloc, char *pszSubsys, int fCheckOften);
void EXPORTDBG __cdecl      DBGMEM_ShutdownFn(void * pmalloc);
void EXPORTDBG __cdecl      DBGMEM_CheckMemFn(void * pmalloc, int fReportOrphans);
void EXPORTDBG __cdecl      DBGMEM_NoLeakDetectFn(void * pmalloc, void *pv);
void EXPORTDBG __cdecl      DBGMEM_SetFailureAtFn(void * pmalloc, ULONG ulFailureAt);
SCODE EXPORTDBG __cdecl     ScCheckScFn(SCODE, SCODE *, char *, char *, int);
void                        GetCallStack(DWORD *, int, int);
void *                      VMAlloc(ULONG);
void *                      VMAllocEx(ULONG, ULONG);
void *                      VMRealloc(void *, ULONG);
void *                      VMReallocEx(void *, ULONG, ULONG);
ULONG                       VMGetSize(void *);
ULONG                       VMGetSizeEx(void *, ULONG);
void                        VMFree(void *);
void                        VMFreeEx(void *, ULONG);

EXTERN_C_END

/*
 *  Debugging Macros -------------------------------------------------------
 *  
 *      SzDecodeScode           Returns the string name of an SCODE
 *      SzDecodeUlPropTag       Returns the string name of a property
 *                              tag
 *      UlPropTagFromSz         Given a property tag's name, returns
 *                              its value
 *      ScodeFromSz             Given an SCODE's name, returns its
 *                              value
 *  
 *      DBGMEM_Encapsulate      Given an IMalloc interface, adds heap-
 *                              checking functionality and returns a
 *                              wrapped interface
 *      DBGMEM_Shutdown         Undoes DBGMEM_Encapsulate, and prints
 *                              out information on any allocations made
 *                              since the interface was encapsulated
 *                              that have not yet been released.
 *      DBGMEM_CheckMem         Checks all memory allocated on the heap,
 *                              and optionally reports leaked blocks.
 *      DBGMEM_NoLeakDetect     Prevents a block from appearing on the leak
 *                              report.  Pass NULL for pv to inhibit leak
 *                              reports at all from this heap.
 */

#ifdef DEBUG

#define SzDecodeScode(_sc)              SzDecodeScodeFn(_sc)
#define SzDecodeUlPropType(_ulPropType) SzDecodeUlPropTypeFn(_ulPropType)
#define SzDecodeUlPropTag(_ulPropTag)   SzDecodeUlPropTagFn(_ulPropTag)
#define UlPropTagFromSz(_sz)            UlPropTagFromSzFn(_sz)
#define ScodeFromSz(_sz)                ScodeFromSzFn(_sz)
#define DBGMEM_Encapsulate(pm, psz, f)  DBGMEM_EncapsulateFn(pm, psz, f)
#define DBGMEM_Shutdown(pm)             DBGMEM_ShutdownFn(pm)
#define DBGMEM_CheckMem(pm, f)          DBGMEM_CheckMemFn(pm, f)
#define DBGMEM_NoLeakDetect(pm, pv)     DBGMEM_NoLeakDetectFn(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)     DBGMEM_SetFailureAtFn(pm, ul)

#else

#define SzDecodeScode(_sc)              (0)
#define SzDecodeUlPropType(_ulPropType) (0)
#define SzDecodeUlPropTag(_ulPropTag)   (0)
#define UlPropTagFromSz(_sz)            (0)
#define ScodeFromSz(_sz)                (0)

#if defined(__cplusplus) && !defined(CINTERFACE)
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
    ((pmalloc)->AddRef(), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
    ((pmalloc)->Release())
#else
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
    ((pmalloc)->lpVtbl->AddRef(pmalloc), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
    ((pmalloc)->lpVtbl->Release(pmalloc))
#endif
#define DBGMEM_CheckMem(pm, f)
#define DBGMEM_NoLeakDetect(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)

#endif

/*
 *  SCODE maps -------------------------------------------------------------
 *  
 *      ScCheckSc       Given an SCODE and method name, verifies
 *                      that the SCODE can legally be returned from
 *                      thet method. Prints out a debug string if
 *                      it cannot.
 *      HrCheckHr       As ScCheckSc, for functions that return
 *                      HRESULT.
 */

#if defined(DEBUG) && !defined(DOS)
#define ScCheckSc(sc,fn)                ScCheckScFn(sc,fn##_Scodes,#fn,__FILE__, __LINE__)
#define HrCheckHr(hr,fn)                HrCheckSc(GetScode(hr),fn)
#else
#define ScCheckSc(sc,fn)                (sc)
#define HrCheckHr(hr,fn)                (hr)
#endif

#define HrCheckSc(sc,fn)                ResultFromScode(ScCheckSc(sc,fn))

#if defined(DEBUG) && !defined(DOS)
extern SCODE Common_Scodes[];
extern SCODE MAPILogon_Scodes[];
extern SCODE MAPIAllocateBuffer_Scodes[];
extern SCODE MAPIAllocateMore_Scodes[];
extern SCODE MAPIFreeBuffer_Scodes[];

extern SCODE IUnknown_QueryInterface_Scodes[];
extern SCODE IUnknown_AddRef_Scodes[];
extern SCODE IUnknown_Release_Scodes[];
extern SCODE IUnknown_GetLastError_Scodes[];

extern SCODE IMAPIProp_CopyTo_Scodes[];
extern SCODE IMAPIProp_CopyProps_Scodes[];
extern SCODE IMAPIProp_DeleteProps_Scodes[];
extern SCODE IMAPIProp_GetIDsFromNames_Scodes[];
extern SCODE IMAPIProp_GetLastError_Scodes[];
extern SCODE IMAPIProp_GetNamesFromIDs_Scodes[];
extern SCODE IMAPIProp_GetPropList_Scodes[];
extern SCODE IMAPIProp_GetProps_Scodes[];
extern SCODE IMAPIProp_OpenProperty_Scodes[];
extern SCODE IMAPIProp_SetProps_Scodes[];
extern SCODE IMAPIProp_SaveChanges_Scodes[];

extern SCODE IStream_Read_Scodes[];
extern SCODE IStream_Write_Scodes[];
extern SCODE IStream_Seek_Scodes[];
extern SCODE IStream_SetSize_Scodes[];
extern SCODE IStream_Tell_Scodes[];
extern SCODE IStream_LockRegion_Scodes[];
extern SCODE IStream_UnlockRegion_Scodes[];
extern SCODE IStream_Clone_Scodes[];
extern SCODE IStream_CopyTo_Scodes[];
extern SCODE IStream_Revert_Scodes[];
extern SCODE IStream_Stat_Scodes[];
extern SCODE IStream_Commit_Scodes[];

extern SCODE IMAPITable_GetLastError_Scodes[];
extern SCODE IMAPITable_Advise_Scodes[];
extern SCODE IMAPITable_Unadvise_Scodes[];
extern SCODE IMAPITable_GetStatus_Scodes[];
extern SCODE IMAPITable_SetColumns_Scodes[];
extern SCODE IMAPITable_QueryColumns_Scodes[];
extern SCODE IMAPITable_GetRowCount_Scodes[];
extern SCODE IMAPITable_SeekRow_Scodes[];
extern SCODE IMAPITable_SeekRowApprox_Scodes[];
extern SCODE IMAPITable_QueryPosition_Scodes[];
extern SCODE IMAPITable_FindRow_Scodes[];
extern SCODE IMAPITable_Restrict_Scodes[];
extern SCODE IMAPITable_CreateBookmark_Scodes[];
extern SCODE IMAPITable_FreeBookmark_Scodes[];
extern SCODE IMAPITable_SortTable_Scodes[];
extern SCODE IMAPITable_QuerySortOrder_Scodes[];
extern SCODE IMAPITable_QueryRows_Scodes[];
extern SCODE IMAPITable_Abort_Scodes[];
extern SCODE IMAPITable_ExpandRow_Scodes[];
extern SCODE IMAPITable_CollapseRow_Scodes[];
extern SCODE IMAPITable_WaitForCompletion_Scodes[];
extern SCODE IMAPITable_GetCollapseState_Scodes[];
extern SCODE IMAPITable_SetCollapseState_Scodes[];

extern SCODE IMAPISession_LogOff_Scodes[];
extern SCODE IMAPISession_Release_Scodes[];
extern SCODE IMAPISession_GetLastError_Scodes[];
extern SCODE IMAPISession_GetMsgStoresTable_Scodes[];
extern SCODE IMAPISession_GetStatusTable_Scodes[];
extern SCODE IMAPISession_OpenMsgStore_Scodes[];
extern SCODE IMAPISession_OpenAddressBook_Scodes[];
extern SCODE IMAPISession_OpenEntry_Scodes[];
extern SCODE IMAPISession_OpenProfileSection_Scodes[];
extern SCODE IMAPISession_Advise_Scodes[];
extern SCODE IMAPISession_Unadvise_Scodes[];
extern SCODE IMAPISession_CompareEntryIDs_Scodes[];
extern SCODE IMAPISession_MessageOptions_Scodes[];
extern SCODE IMAPISession_QueryDefaultMessageOpt_Scodes[];
extern SCODE IMAPISession_EnumAdrTypes_Scodes[];
extern SCODE IMAPISession_QueryIdentity_Scodes[];
extern SCODE IMAPISession_OpenProfileSection_Scodes[];
extern SCODE IMAPISession_GetStatusTable_Scodes[];

extern SCODE IMsgStore_Advise_Scodes[] ;
extern SCODE IMsgStore_Unadvise_Scodes[] ;
extern SCODE IMsgStore_CompareEntryIDs_Scodes[] ;
extern SCODE IMsgStore_OpenEntry_Scodes[] ;
extern SCODE IMsgStore_SetReceiveFolder_Scodes[];
extern SCODE IMsgStore_GetReceiveFolder_Scodes[];
extern SCODE IMsgStore_GetReceiveFolderTable_Scodes[];
extern SCODE IMsgStore_StoreLogoff_Scodes[];
extern SCODE IMsgStore_AbortSubmit_Scodes[];
extern SCODE IMsgStore_GetOutgoingQueue_Scodes[] ;
extern SCODE IMsgStore_SetLockState_Scodes[] ;
extern SCODE IMsgStore_FinishedMsg_Scodes[] ;
extern SCODE IMsgStore_NotifyNewMail_Scodes[];

extern SCODE IMAPIFolder_GetContentsTable_Scodes[];
extern SCODE IMAPIFolder_GetHierarchyTable_Scodes[];
extern SCODE IMAPIFolder_SaveContentsSort_Scodes[];
extern SCODE IMAPIFolder_OpenEntry_Scodes[];
extern SCODE IMAPIFolder_CreateMessage_Scodes[];
extern SCODE IMAPIFolder_CopyMessages_Scodes[];
extern SCODE IMAPIFolder_DeleteMessages_Scodes[];
extern SCODE IMAPIFolder_CreateFolder_Scodes[];
extern SCODE IMAPIFolder_CopyFolder_Scodes[];
extern SCODE IMAPIFolder_DeleteFolder_Scodes[];
extern SCODE IMAPIFolder_SetSearchCriteria_Scodes[];
extern SCODE IMAPIFolder_GetSearchCriteria_Scodes[];
extern SCODE IMAPIFolder_SetReadFlags_Scodes[];
extern SCODE IMAPIFolder_GetMessageStatus_Scodes[];
extern SCODE IMAPIFolder_SetMessageStatus_Scodes[];
extern SCODE IMAPIFolder_EmptyFolder_Scodes[];

extern SCODE IMessage_SaveChanges_Scodes[];
extern SCODE IMessage_GetAttachmentTable_Scodes[];
extern SCODE IMessage_OpenAttach_Scodes[];
extern SCODE IMessage_CreateAttach_Scodes[];
extern SCODE IMessage_DeleteAttach_Scodes[];
extern SCODE IMessage_GetRecipientTable_Scodes[];
extern SCODE IMessage_ModifyRecipients_Scodes[];
extern SCODE IMessage_SubmitMessage_Scodes[];
extern SCODE IMessage_SetReadFlag_Scodes[];

extern SCODE IAttach_SaveChanges_Scodes[];

extern SCODE IAddrBook_OpenEntry_Scodes[];
extern SCODE IAddrBook_CompareEntryIDs_Scodes[];
extern SCODE IAddrBook_CreateOneOff_Scodes[];
extern SCODE IAddrBook_ResolveName_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_Details_Scodes[];
extern SCODE IAddrBook_RecipOptions_Scodes[];
extern SCODE IAddrBook_QueryDefaultRecipOpt_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_ButtonPress_Scodes[];

extern SCODE IABContainer_GetContentsTable_Scodes[];
extern SCODE IABContainer_GetHierarchyTable_Scodes[];

extern SCODE INotifObj_ChangeEvMask_Scodes[];

extern SCODE IMAPIStatus_ChangePassword_Scodes[];
extern SCODE IMAPIStatus_FlushQueues_Scodes[];
extern SCODE IMAPIStatus_SettingsDialog_Scodes[];
extern SCODE IMAPIStatus_ValidateState_Scodes[];

extern SCODE IMSProvider_Logon_Scodes[];
extern SCODE IMSProvider_Deinit_Scodes[];
extern SCODE IMSProvider_Init_Scodes[];
extern SCODE IMSProvider_SpoolerLogon_Scodes[];
extern SCODE IMSProvider_Shutdown_Scodes[];

extern SCODE SMAPI_MAPILogon_Scodes[];
extern SCODE SMAPI_MAPILogoff_Scodes[];
extern SCODE SMAPI_MAPIFreeBuffer_Scodes[];
extern SCODE SMAPI_MAPISendMail_Scodes[];
extern SCODE SMAPI_MAPISendDocuments_Scodes[];
extern SCODE SMAPI_MAPIFindNext_Scodes[];
extern SCODE SMAPI_MAPIReadMail_Scodes[];
extern SCODE SMAPI_MAPISaveMail_Scodes[];
extern SCODE SMAPI_MAPIDeleteMail_Scodes[];
extern SCODE SMAPI_MAPIAddress_Scodes[];
extern SCODE SMAPI_MAPIResolveName_Scodes[];
extern SCODE SMAPI_MAPIDetails_Scodes[];

extern SCODE IMSLogon_OpenEntry_Scodes[];
extern SCODE IMSLogon_OpenStatusEntry_Scodes[];
extern SCODE IMSLogon_CompareEntryIDs_Scodes[];
extern SCODE IMSLogon_Advise_Scodes[];
extern SCODE IMSLogon_Unadvise_Scodes[];
extern SCODE IMSLogon_Logoff_Scodes[];
#endif

/* ------------------------------------------------------------------------ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\mapinls.h ===
/*
 *  M A P I N L S . H
 *
 *  Internationalization Support Utilities
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPINLS_H_
#define _MAPINLS_H_

#ifdef __cplusplus
extern "C" {
#endif

/* We don't want to include windows.h in case that conflicts with an */
/* earlier inclusion of compobj.h */

#if !defined(WINAPI)
    #if defined(WIN32) && (_MSC_VER >= 800)
        #define WINAPI              __stdcall
    #elif defined(WIN16)
        #define WINAPI              _far _pascal
    #else
        #define WINAPI              _far _pascal
    #endif
#endif

#if defined(DOS) || defined(MAC)
#include <string.h>
#endif

#ifndef FAR
#define FAR
#endif

typedef unsigned char                   BYTE;
typedef unsigned short                  WORD;
typedef unsigned long                   DWORD;
typedef unsigned int                    UINT;
typedef int                             BOOL;

#ifndef __CHAR_DEFINED__
typedef char                            CHAR;
#endif

#ifdef UNICODE
typedef WCHAR                           TCHAR;
#else
typedef char                            TCHAR;
#endif

#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short                  WCHAR;
#else
typedef wchar_t WCHAR;
#endif

typedef WCHAR FAR *                     LPWSTR;
typedef const WCHAR FAR *               LPCWSTR;
typedef CHAR FAR *                      LPSTR;
typedef const CHAR FAR *                LPCSTR;
typedef TCHAR FAR *                     LPTSTR;
typedef const TCHAR FAR *               LPCTSTR;
typedef DWORD                           LCID;
typedef const void FAR *                LPCVOID;

#ifndef LPOLESTR
#ifndef WIN32

#define LPOLESTR        LPSTR
#define LPCOLESTR       LPCSTR
#define OLECHAR         char
#define OLESTR(str) str

#else  /* Win32 */

#define LPOLESTR        LPWSTR
#define LPCOLESTR       LPCWSTR
#define OLECHAR         WCHAR
#define OLESTR(str)     L##str

#endif /* !WIN32 */
#endif /* LPOLESTR */

#define NORM_IGNORECASE                 0x00000001     /* ignore case */
#define NORM_IGNORENONSPACE             0x00000002     /* ignore diacritics */
#define NORM_IGNORESYMBOLS              0x00000004     /* ignore symbols */
#define NORM_IGNOREKANATYPE             0x00010000     /* ignore kanatype */
#define NORM_IGNOREWIDTH                0x00020000     /* ignore width */

#if defined(WIN16)

#define lstrcpyA                        lstrcpy
#define lstrlenA                        lstrlen
#define lstrcmpA                        lstrcmp
#define lstrcmpiA                       lstrcmpi
#define LoadStringA                     LoadString
#define IsBadStringPtrA(a1, a2)         IsBadStringPtr(a1, a2)
#define wvsprintfA                      wvsprintf
#define MessageBoxA                     MessageBox
#define GetModuleHandleA                GetModuleHandle
#define CreateWindowA                   CreateWindow
#define RegisterClassA                  RegisterClass
#define CharToOemBuff                   AnsiToOemBuff
#define CharToOem                       AnsiToOem
#define CharUpperBuff                   AnsiUpperBuff
#define CharUpper                       AnsiUpper

#elif defined(DOS) || defined(MAC)

#define IsBadReadPtr(lp, cb)            (FALSE)
#define IsBadWritePtr(lp, cb)           (FALSE)
#define IsBadHugeReadPtr(lp, cb)        (FALSE)
#define IsBadHugeWritePtr(lp, cb)       (FALSE)
#define IsBadCodePtr(lpfn)              (FALSE)
#define IsBadStringPtr(lpsz, cchMax)    (FALSE)
#define IsBadStringPtrA(lpsz, cchMax)   (FALSE)

#if defined(DOS)

#define lstrcpyA                        strcpy
#define lstrlenA                        strlen
#define lstrcmpA                        strcmp
#define lstrcmp                         strcmp
#define lstrcmpi                        strcmpi
#define lstrcpy                         strcpy
#define lstrcat                         strcat
#define lstrlen                         strlen
#define wsprintf                        sprintf

#endif
#endif

#if defined(DOS) || defined(WIN16)
#define TEXT(x)     x
#endif

#define CP_ACP      0       /* default to ANSI code page */
#define CP_OEMCP    1       /* default to OEM  code page */

LCID    WINAPI  MNLS_GetUserDefaultLCID(void);
UINT    WINAPI  MNLS_GetACP(void);
int     WINAPI  MNLS_CompareStringA(LCID Locale, DWORD dwCmpFlags,
                    LPCSTR lpString1, int cchCount1, LPCSTR lpString2,
                    int cchCount2);
int     WINAPI  MNLS_CompareStringW(LCID Locale, DWORD dwCmpFlags,
                    LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2,
                    int cchCount2);
int     WINAPI  MNLS_MultiByteToWideChar(UINT uCodePage, DWORD dwFlags,
                    LPCSTR lpMultiByteStr, int cchMultiByte,
                    LPWSTR lpWideCharStr, int cchWideChar);
int     WINAPI  MNLS_WideCharToMultiByte(UINT uCodePage, DWORD dwFlags,
                    LPCWSTR lpWideCharStr, int cchWideChar,
                    LPSTR lpMultiByteStr, int cchMultiByte,
                    LPCSTR lpDefaultChar, BOOL FAR *lpfUsedDefaultChar);
int     WINAPI  MNLS_lstrlenW(LPCWSTR lpString);
int     WINAPI  MNLS_lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
LPWSTR  WINAPI  MNLS_lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
BOOL    WINAPI  MNLS_IsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);

#if defined(WIN32) && !defined(NT) && !defined(CHICAGO) && !defined(_MAC)
#define NT
#endif

#if !defined(NT) && !defined(CHICAGO)
#define GetUserDefaultLCID      MNLS_GetUserDefaultLCID
#define GetACP                  MNLS_GetACP
#define MultiByteToWideChar     MNLS_MultiByteToWideChar
#define WideCharToMultiByte     MNLS_WideCharToMultiByte
#define CompareStringA          MNLS_CompareStringA
#endif

#if !defined(NT)
#define lstrlenW                MNLS_lstrlenW
#define lstrcmpW                MNLS_lstrcmpW
#define lstrcpyW                MNLS_lstrcpyW
#define CompareStringW          MNLS_CompareStringW

#if defined(WIN16) || defined(CHICAGO)
#define IsBadStringPtrW         MNLS_IsBadStringPtrW
#elif defined(MAC)
#define IsBadStringPtrW(lpsz, cchMax)           (FALSE)
#else
#define IsBadStringPtrW         (FALSE)
#endif

#endif

#ifdef __cplusplus
}
#endif

#endif /* _MAPINLS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\mapispi.h ===
/*
 *  M A P I S P I . H
 *
 *  Defines the calls and structures exchanged between MAPI or the spooler
 *  and the MAPI service providers
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPISPI_H
#define MAPISPI_H
/* Include common MAPI header files if they haven't been already. */
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPICODE_H
#include <mapicode.h>
#endif
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPITAGS_H
#include <mapitags.h>
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16)
#include <storage.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*  The MAPI SPI has a version number.  MAPIX.DLL knows and supports
 *  one or more versions of the SPI.  Each provider supports one or
 *  more versions of the SPI.  Checks are performed in both MAPIX.DLL
 *  and in the provider to ensure that they agree to use exactly one
 *  version of the MAPI SPI.
 *
 *  The SPI version number is composed of a major (8-bit) version,
 *  minor (8-bit) version, and micro (16-bit) version.  The first
 *  retail ship of MAPI 1.0 is expected to be version 1.0.0.
 *  The major version number changes rarely.
 *  The minor version number changes opon each retail ship of
 *  MAPI if the SPI has been modified.
 *  The micro version number changes internally at Microsoft
 *  during development of MAPI.
 *
 *  The version of the SPI documented by this set of header files
 *  is ALWAYS known as "CURRENT_SPI_VERSION".  If you write a
 *  service provider, and get a new set of header files, and update
 *  your code to the new interface, you'll be at the "current" version.
 */
#define CURRENT_SPI_VERSION 0x00010010L

/*  Here are some well-known SPI version numbers:
 *  (These will eventually be useful for provider-writers who
 *  might choose to make provider DLLs that support more than
 *  one version of the MAPI SPI.
 */
#define PDK1_SPI_VERSION    0x00010000L /* 0.1.0  MAPI PDK1 Spring 1993 */

#define PDK2_SPI_VERSION    0x00010008L /* 0.1.8  MAPI PDK2 Spring 1994 */

#define PDK3_SPI_VERSION    0x00010010L /* 0.1.16 MAPI PDK3 Fall 1994   */

/*
 *  Maximum length of profile names and passwords.
 */
#define cchProfileNameMax   64
#define cchProfilePassMax   64

/*
 * Forward declaration of interface pointers specific to the service
 * provider interface.
 */
DECLARE_MAPI_INTERFACE_PTR(IMAPISupport, LPMAPISUP);

/* IMAPISupport Interface -------------------------------------------------- */

/* Notification key structure for the MAPI notification engine */

typedef struct
{
    ULONG       cb;             /* How big the key is */
    BYTE        ab[MAPI_DIM];   /* Key contents */
} NOTIFKEY, FAR * LPNOTIFKEY;

#define CbNewNOTIFKEY(_cb)      (offsetof(NOTIFKEY,ab) + (_cb))
#define CbNOTIFKEY(_lpkey)      (offsetof(NOTIFKEY,ab) + (_lpkey)->cb)
#define SizedNOTIFKEY(_cb, _name) \
    struct _NOTIFKEY_ ## _name \
{ \
    ULONG       cb; \
    BYTE        ab[_cb]; \
} _name


/* For Subscribe() */

#define NOTIFY_SYNC             ((ULONG) 0x40000000)

/* For Notify() */

#define NOTIFY_CANCELED         ((ULONG) 0x80000000)


/* From the Notification Callback function (well, this is really a ulResult) */

#define CALLBACK_DISCONTINUE    ((ULONG) 0x80000000)

/* For Transport's SpoolerNotify() */

#define NOTIFY_NEWMAIL          ((ULONG) 0x00000001)
#define NOTIFY_READYTOSEND      ((ULONG) 0x00000002)
#define NOTIFY_SENTDEFERRED     ((ULONG) 0x00000004)
#define NOTIFY_CRITSEC          ((ULONG) 0x00001000)
#define NOTIFY_NONCRIT          ((ULONG) 0x00002000)
#define NOTIFY_CONFIG_CHANGE    ((ULONG) 0x00004000)
#define NOTIFY_CRITICAL_ERROR   ((ULONG) 0x10000000)

/* For Message Store's SpoolerNotify() */

#define NOTIFY_NEWMAIL_RECEIVED ((ULONG) 0x20000000)

/* For ModifyStatusRow() */

#define STATUSROW_UPDATE        ((ULONG) 0x10000000)

/* For IStorageFromStream() */

#define STGSTRM_RESET           ((ULONG) 0x00000000)
#define STGSTRM_CURRENT         ((ULONG) 0x10000000)
#define STGSTRM_MODIFY          ((ULONG) 0x00000002)
#define STGSTRM_CREATE          ((ULONG) 0x00001000)

/* For GetOneOffTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/* For CreateOneOff() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/* For ReadReceipt() */
#define MAPI_NON_READ           ((ULONG) 0x00000001)

/* For DoConfigPropSheet() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/* Preprocessor calls: */

/* PreprocessMessage, first ordinal in RegisterPreprocessor(). */

typedef HRESULT (STDMETHODCALLTYPE PREPROCESSMESSAGE)(
                    LPMESSAGE lpMessage,
                    LPADRBOOK lpAdrBook,
                    LPMAPIFOLDER lpFolder,
                    LPALLOCATEBUFFER AllocateBuffer,
                    LPALLOCATEMORE AllocateMore,
                    LPFREEBUFFER FreeBuffer,
                    ULONG FAR *lpcOutbound,
                    LPMESSAGE FAR * FAR *lpppMessage,
                    LPADRLIST FAR *lppRecipList);

/* RemovePreprocessInfo, second ordinal in RegisterPreprocessor(). */

typedef HRESULT (STDMETHODCALLTYPE REMOVEPREPROCESSINFO)(LPMESSAGE lpMessage);

/* Function pointer for GetReleaseInfo */

#define MAPI_IMAPISUPPORT_METHODS1(IPURE)                               \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetMemAllocRoutines)                                     \
        (THIS_  LPALLOCATEBUFFER FAR *      lpAllocateBuffer,           \
                LPALLOCATEMORE FAR *        lpAllocateMore,             \
                LPFREEBUFFER FAR *          lpFreeBuffer) IPURE;        \
    MAPIMETHOD(Subscribe)                                               \
        (THIS_  LPNOTIFKEY                  lpKey,                      \
                ULONG                       ulEventMask,                \
                ULONG                       ulFlags,                    \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unsubscribe)                                             \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(Notify)                                                  \
        (THIS_  LPNOTIFKEY                  lpKey,                      \
                ULONG                       cNotification,              \
                LPNOTIFICATION              lpNotifications,            \
                ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(ModifyStatusRow)                                         \
        (THIS_  ULONG                       cValues,                    \
                LPSPropValue                lpColumnVals,               \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUid,                      \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfileObj) IPURE;       \
    MAPIMETHOD(RegisterPreprocessor)                                    \
        (THIS_  LPMAPIUID                   lpMuid,                     \
                LPTSTR                      lpszAdrType,                \
                LPTSTR                      lpszDLLName,                \
                LPSTR   /* String8! */      lpszPreprocess,             \
                LPSTR   /* String8! */      lpszRemovePreprocessInfo,   \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(NewUID)                                                  \
        (THIS_  LPMAPIUID                   lpMuid) IPURE;              \
    MAPIMETHOD(MakeInvalid)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPVOID                      lpObject,                   \
                ULONG                       ulRefCount,                 \
                ULONG                       cMethods) IPURE;            \

#define MAPI_IMAPISUPPORT_METHODS2(IPURE)                               \
    MAPIMETHOD(SpoolerYield)                                            \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SpoolerNotify)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPVOID                      lpvData) IPURE;             \
    MAPIMETHOD(CreateOneOff)                                            \
        (THIS_  LPTSTR                      lpszName,                   \
                LPTSTR                      lpszAdrType,                \
                LPTSTR                      lpszAddress,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(SetProviderUID)                                          \
        (THIS_  LPMAPIUID                   lpProviderID,               \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntry1,                   \
                LPENTRYID                   lpEntry1,                   \
                ULONG                       cbEntry2,                   \
                LPENTRYID                   lpEntry2,                   \
                ULONG                       ulCompareFlags,             \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(OpenTemplateID)                                          \
        (THIS_  ULONG                       cbTemplateID,               \
                LPENTRYID                   lpTemplateID,               \
                ULONG                       ulTemplateFlags,            \
                LPMAPIPROP                  lpMAPIPropData,             \
                LPCIID                      lpInterface,                \
                LPMAPIPROP FAR *            lppMAPIPropNew,             \
                LPMAPIPROP                  lpMAPIPropSibling) IPURE;   \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulOpenFlags,                \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(GetOneOffTable)                                          \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(Address)                                                 \
        (THIS_  ULONG FAR *                 lpulUIParam,                \
                LPADRPARM                   lpAdrParms,                 \
                LPADRLIST FAR *             lppAdrList) IPURE;          \
    MAPIMETHOD(Details)                                                 \
        (THIS_  ULONG FAR *                 lpulUIParam,                \
                LPFNDISMISS                 lpfnDismiss,                \
                LPVOID                      lpvDismissContext,          \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPFNBUTTON                  lpfButtonCallback,          \
                LPVOID                      lpvButtonContext,           \
                LPTSTR                      lpszButtonText,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(NewEntry)                                                \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                ULONG                       cbEIDContainer,             \
                LPENTRYID                   lpEIDContainer,             \
                ULONG                       cbEIDNewEntryTpl,           \
                LPENTRYID                   lpEIDNewEntryTpl,           \
                ULONG FAR *                 lpcbEIDNewEntry,            \
                LPENTRYID FAR *             lppEIDNewEntry) IPURE;      \
    MAPIMETHOD(DoConfigPropsheet)                                       \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPTSTR                      lpszTitle,                  \
                LPMAPITABLE                 lpDisplayTable,             \
                LPMAPIPROP                  lpCOnfigData,               \
                ULONG                       ulTopPage) IPURE;           \
    MAPIMETHOD(CopyMessages)                                            \
        (THIS_  LPCIID                      lpSrcInterface,             \
                LPVOID                      lpSrcFolder,                \
                LPENTRYLIST                 lpMsgList,                  \
                LPCIID                      lpDestInterface,            \
                LPVOID                      lpDestFolder,               \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CopyFolder)                                              \
        (THIS_  LPCIID                      lpSrcInterface,             \
                LPVOID                      lpSrcFolder,                \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpDestInterface,            \
                LPVOID                      lpDestFolder,               \
                LPTSTR                      lszNewFolderName,           \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \

#define MAPI_IMAPISUPPORT_METHODS3(IPURE)                               \
    MAPIMETHOD(DoCopyTo)                                                \
        (THIS_  LPCIID                      lpSrcInterface,             \
                LPVOID                      lpSrcObj,                   \
                ULONG                       ciidExclude,                \
                LPCIID                      rgiidExclude,               \
                LPSPropTagArray             lpExcludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpDestInterface,            \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DoCopyProps)                                             \
        (THIS_  LPCIID                      lpSrcInterface,             \
                LPVOID                      lpSrcObj,                   \
                LPSPropTagArray             lpIncludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpDestInterface,            \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DoProgressDialog)                                        \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPMAPIPROGRESS FAR *        lppProgress) IPURE;         \
    MAPIMETHOD(ReadReceipt)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpReadMessage,              \
                LPMESSAGE FAR *             lppEmptyMessage) IPURE;     \
    MAPIMETHOD(PrepareSubmit)                                           \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(ExpandRecips)                                            \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(UpdatePAB)                                               \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpMessage) IPURE;           \
    MAPIMETHOD(DoSentMail)                                              \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpMessage) IPURE;           \
    MAPIMETHOD(OpenAddressBook)                                         \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPADRBOOK FAR *             lppAdrBook) IPURE;          \
    MAPIMETHOD(Preprocess)                                              \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(CompleteMsg)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(StoreLogoffTransports)                                   \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(StatusRecips)                                            \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                LPADRLIST                   lpRecipList) IPURE;         \
    MAPIMETHOD(WrapStoreEntryID)                                        \
        (THIS_  ULONG                       cbOrigEntry,                \
                LPENTRYID                   lpOrigEntry,                \
                ULONG FAR *                 lpcbWrappedEntry,           \
                LPENTRYID FAR *             lppWrappedEntry) IPURE;     \
    MAPIMETHOD(ModifyProfile)                                           \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(IStorageFromStream)                                      \
        (THIS_  LPUNKNOWN                   lpUnkIn,                    \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPSTORAGE FAR *             lppStorageOut) IPURE;       \
    MAPIMETHOD(GetSvcConfigSupportObj)                                  \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPISUP FAR *             lppSvcSupport) IPURE;       \

#undef       INTERFACE
#define      INTERFACE  IMAPISupport
DECLARE_MAPI_INTERFACE_(IMAPISupport, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPISUPPORT_METHODS1(PURE)
    MAPI_IMAPISUPPORT_METHODS2(PURE)
    MAPI_IMAPISUPPORT_METHODS3(PURE)
};


/********************************************************************/
/*                                                                  */
/*                          ADDRESS BOOK SPI                        */
/*                                                                  */
/********************************************************************/

/* Address Book Provider ------------------------------------------------- */

/* OpenTemplateID() */
#define FILL_ENTRY              ((ULONG) 0x00000001)

/* For Logon() */

/*#define AB_NO_DIALOG          ((ULONG) 0x00000001) in mapidefs.h */
/*#define MAPI_UNICODE          ((ULONG) 0x80000000) in mapidefs.h */



DECLARE_MAPI_INTERFACE_PTR(IABProvider, LPABPROVIDER);
DECLARE_MAPI_INTERFACE_PTR(IABLogon,    LPABLOGON);

#define MAPI_IABPROVIDER_METHODS(IPURE)                                 \
    MAPIMETHOD(Shutdown)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(Logon)                                                   \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulpcbSecurity,            \
                LPBYTE FAR *                lppbSecurity,               \
                LPMAPIERROR FAR *           lppMAPIError,               \
                LPABLOGON FAR *             lppABLogon) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IABProvider
DECLARE_MAPI_INTERFACE_(IABProvider, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IABPROVIDER_METHODS(PURE)
};

/* For GetOneOffTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

#define MAPI_IABLOGON_METHODS(IPURE)                                    \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Logoff)                                                  \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                       lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPMAPISTATUS FAR *          lppEntry) IPURE;            \
    MAPIMETHOD(OpenTemplateID)                                          \
        (THIS_  ULONG                       cbTemplateID,               \
                LPENTRYID                   lpTemplateID,               \
                ULONG                       ulTemplateFlags,            \
                LPMAPIPROP                  lpMAPIPropData,             \
                LPCIID                       lpInterface,                \
                LPMAPIPROP FAR *            lppMAPIPropNew,             \
                LPMAPIPROP                  lpMAPIPropSibling) IPURE;   \
    MAPIMETHOD(GetOneOffTable)                                          \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(PrepareRecips)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray             lpPropTagArray,             \
                LPADRLIST                   lpRecipList) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IABLogon
DECLARE_MAPI_INTERFACE_(IABLogon, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IABLOGON_METHODS(PURE)
};

typedef HRESULT (STDMAPIINITCALLTYPE ABPROVIDERINIT)(
    HINSTANCE           hInstance,
    LPMALLOC            lpMalloc,
    LPALLOCATEBUFFER    lpAllocateBuffer,
    LPALLOCATEMORE      lpAllocateMore,
    LPFREEBUFFER        lpFreeBuffer,
    ULONG               ulFlags,
    ULONG               ulMAPIVer,
    ULONG FAR *         lpulProviderVer,
    LPABPROVIDER FAR *  lppABProvider
);

ABPROVIDERINIT ABProviderInit;



/********************************************************************/
/*                                                                  */
/*                          TRANSPORT SPI                           */
/*                                                                  */
/********************************************************************/

/* For DeinitTransport */

#define DEINIT_NORMAL               ((ULONG) 0x00000001)
#define DEINIT_HURRY                ((ULONG) 0x80000000)

/* For TransportLogon */

/* Flags that the Spooler may pass to the transport: */

#define LOGON_NO_DIALOG             ((ULONG) 0x00000001)
#define LOGON_NO_CONNECT            ((ULONG) 0x00000004)
#define LOGON_NO_INBOUND            ((ULONG) 0x00000008)
#define LOGON_NO_OUTBOUND           ((ULONG) 0x00000010)
/*#define MAPI_UNICODE              ((ULONG) 0x80000000) in mapidefs.h */

/* Flags that the transport may pass to the Spooler: */

#define LOGON_SP_IDLE               ((ULONG) 0x00010000)
#define LOGON_SP_POLL               ((ULONG) 0x00020000)
#define LOGON_SP_RESOLVE            ((ULONG) 0x00040000)


DECLARE_MAPI_INTERFACE_PTR(IXPProvider, LPXPPROVIDER);
DECLARE_MAPI_INTERFACE_PTR(IXPLogon, LPXPLOGON);

#define MAPI_IXPPROVIDER_METHODS(IPURE)                                 \
    MAPIMETHOD(Shutdown)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(TransportLogon)                                          \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG FAR *                 lpulFlags,                  \
                LPMAPIERROR FAR *           lppMAPIError,               \
                LPXPLOGON FAR *             lppXPLogon) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IXPProvider
DECLARE_MAPI_INTERFACE_(IXPProvider, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IXPPROVIDER_METHODS(PURE)
};

/* OptionData returned from call to RegisterOptions */

#define OPTION_TYPE_RECIPIENT       ((ULONG) 0x00000001)
#define OPTION_TYPE_MESSAGE         ((ULONG) 0x00000002)

typedef struct _OPTIONDATA
{
    ULONG           ulFlags;        /* MAPI_RECIPIENT, MAPI_MESSAGE */
    LPGUID          lpRecipGUID;    /* Same as returned by AddressTypes() */
    LPTSTR          lpszAdrType;    /* Same as returned by AddressTypes() */
    LPTSTR          lpszDLLName;    /* Options DLL */
    ULONG           ulOrdinal;      /* Ordinal in that DLL */
    ULONG           cbOptionsData;  /* Count of bytes in lpbOptionsData */
    LPBYTE          lpbOptionsData; /* Providers per [recip|message] option data */
    ULONG           cOptionsProps;  /* Count of Options default prop values */
    LPSPropValue    lpOptionsProps; /* Default Options property values */
} OPTIONDATA, FAR *LPOPTIONDATA;

typedef SCODE (STDMAPIINITCALLTYPE OPTIONCALLBACK)(
            HINSTANCE           hInst,
            LPMALLOC            lpMalloc,
            ULONG               ulFlags,
            ULONG               cbOptionData,
            LPBYTE              lpbOptionData,
            LPMAPISUP           lpMAPISup,
            LPMAPIPROP          lpDataSource,
            LPMAPIPROP FAR *    lppWrappedSource,
            LPMAPIERROR FAR *   lppMAPIError);

/* For XP_AddressTypes */

/*#define MAPI_UNICODE              ((ULONG) 0x80000000) in mapidefs.h */

/* For XP_RegisterRecipOptions */

/*#define MAPI_UNICODE              ((ULONG) 0x80000000) in mapidefs.h */

/* For XP_RegisterMessageOptions */

/*#define MAPI_UNICODE              ((ULONG) 0x80000000) in mapidefs.h */

/* For TransportNotify */

#define NOTIFY_ABORT_DEFERRED       ((ULONG) 0x40000000)
#define NOTIFY_CANCEL_MESSAGE       ((ULONG) 0x80000000)
#define NOTIFY_BEGIN_INBOUND        ((ULONG) 0x00000001)
#define NOTIFY_END_INBOUND          ((ULONG) 0x00010000)
#define NOTIFY_BEGIN_OUTBOUND       ((ULONG) 0x00000002)
#define NOTIFY_END_OUTBOUND         ((ULONG) 0x00020000)
#define NOTIFY_BEGIN_INBOUND_FLUSH  ((ULONG) 0x00000004)
#define NOTIFY_END_INBOUND_FLUSH    ((ULONG) 0x00040000)
#define NOTIFY_BEGIN_OUTBOUND_FLUSH ((ULONG) 0x00000008)
#define NOTIFY_END_OUTBOUND_FLUSH   ((ULONG) 0x00080000)

/* For TransportLogoff */

#define LOGOFF_NORMAL               ((ULONG) 0x00000001)
#define LOGOFF_HURRY                ((ULONG) 0x80000000)

/* For SubmitMessage */

#define BEGIN_DEFERRED              ((ULONG) 0x00000001)

/* For EndMessage */

/* Flags that the Spooler may pass to the Transport: */

/* Flags that the transport may pass to the Spooler: */

#define END_RESEND_NOW              ((ULONG) 0x00010000)
#define END_RESEND_LATER            ((ULONG) 0x00020000)
#define END_DONT_RESEND             ((ULONG) 0x00040000)

#define MAPI_IXPLOGON_METHODS(IPURE)                                    \
    MAPIMETHOD(AddressTypes)                                            \
        (THIS_  ULONG FAR *                 lpulFlags,                  \
                ULONG FAR *                 lpcAdrType,                 \
                LPTSTR FAR * FAR *          lpppAdrTypeArray,           \
                ULONG FAR *                 lpcMAPIUID,                 \
                LPMAPIUID FAR * FAR *       lpppUIDArray) IPURE;        \
    MAPIMETHOD(RegisterOptions)                                         \
        (THIS_  ULONG FAR *                 lpulFlags,                  \
                ULONG FAR *                 lpcOptions,                 \
                LPOPTIONDATA FAR *          lppOptions) IPURE;          \
    MAPIMETHOD(TransportNotify)                                         \
        (THIS_  ULONG FAR *                 lpulFlags,                  \
                LPVOID FAR *                lppvData) IPURE;            \
    MAPIMETHOD(Idle)                                                    \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(TransportLogoff)                                         \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SubmitMessage)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulMsgRef,                 \
                ULONG FAR *                 lpulReturnParm) IPURE;      \
    MAPIMETHOD(EndMessage)                                              \
        (THIS_  ULONG                       ulMsgRef,                   \
                ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(Poll)                                                    \
        (THIS_  ULONG FAR *                 lpulIncoming) IPURE;        \
    MAPIMETHOD(StartMessage)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulMsgRef) IPURE;          \
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPMAPISTATUS FAR *          lppEntry) IPURE;            \
    MAPIMETHOD(ValidateState)                                           \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(FlushQueues)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       cbTargetTransport,          \
                LPENTRYID                   lpTargetTransport,          \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IXPLogon
DECLARE_MAPI_INTERFACE_(IXPLogon, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IXPLOGON_METHODS(PURE)
};


/* Transport Provider Entry Point */

typedef HRESULT (STDMAPIINITCALLTYPE XPPROVIDERINIT)(
    HINSTANCE           hInstance,
    LPMALLOC            lpMalloc,
    LPALLOCATEBUFFER    lpAllocateBuffer,
    LPALLOCATEMORE      lpAllocateMore,
    LPFREEBUFFER        lpFreeBuffer,
    ULONG               ulFlags,
    ULONG               ulMAPIVer,
    ULONG FAR *         lpulProviderVer,
    LPXPPROVIDER FAR *  lppXPProvider);

XPPROVIDERINIT XPProviderInit;

/********************************************************************/
/*                                                                  */
/*                          MESSAGE STORE SPI                       */
/*                                                                  */
/********************************************************************/

/* Flags and enums */

/* For Logon() */

/*#define MAPI_UNICODE          ((ULONG) 0x80000000) in mapidefs.h */
/*#define MDB_NO_DIALOG         ((ULONG) 0x00000001) in mapidefs.h */
/*#define MDB_WRITE             ((ULONG) 0x00000004) in mapidefs.h */
/*#define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) in mapidefs.h */
/*#define MDB_TEMPORARY         ((ULONG) 0x00000020) in mapidefs.h */
/*#define MDB_NO_MAIL           ((ULONG) 0x00000080) in mapidefs.h */

/* For SpoolerLogon() */

/*#define MAPI_UNICODE          ((ULONG) 0x80000000) in mapidefs.h */
/*#define MDB_NO_DIALOG         ((ULONG) 0x00000001) in mapidefs.h */
/*#define MDB_WRITE             ((ULONG) 0x00000004) in mapidefs.h */
/*#define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) in mapidefs.h */

/* GetCredentials, SetCredentials */

#define LOGON_SP_TRANSPORT      ((ULONG) 0x00000001)
#define LOGON_SP_PROMPT         ((ULONG) 0x00000002)
#define LOGON_SP_NEWPW          ((ULONG) 0x00000004)
#define LOGON_CHANGED           ((ULONG) 0x00000008)

/* CopyMessages */

#define MESSAGE_NOMARK          ((ULONG) 0x00000008)

/* DoMCDialog */

#define DIALOG_FOLDER           ((ULONG) 0x00000001)
#define DIALOG_MESSAGE          ((ULONG) 0x00000002)
#define DIALOG_PROP             ((ULONG) 0x00000004)
#define DIALOG_ATTACH           ((ULONG) 0x00000008)

#define DIALOG_MOVE             ((ULONG) 0x00000010)
#define DIALOG_COPY             ((ULONG) 0x00000020)
#define DIALOG_DELETE           ((ULONG) 0x00000040)

#define DIALOG_ALLOW_CANCEL     ((ULONG) 0x00000080)
#define DIALOG_CONFIRM_CANCEL   ((ULONG) 0x00000100)

/* ExpandRecips */

#define NEEDS_PREPROCESSING     ((ULONG) 0x00000001)

/* PrepareSubmit */

#define CHECK_SENDER            ((ULONG) 0x00000001)
#define NON_STANDARD            ((ULONG) 0x00010000)


DECLARE_MAPI_INTERFACE_PTR(IMSLogon, LPMSLOGON);
DECLARE_MAPI_INTERFACE_PTR(IMSProvider, LPMSPROVIDER);

/* Message Store Provider Interface (IMSPROVIDER) */

#define MAPI_IMSPROVIDER_METHODS(IPURE)                                 \
    MAPIMETHOD(Shutdown)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(Logon)                                                   \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags,                    \
                LPCIID                      lpInterface,                \
                ULONG FAR *                 lpcbSpoolSecurity,          \
                LPBYTE FAR *                lppbSpoolSecurity,          \
                LPMAPIERROR FAR *           lppMAPIError,               \
                LPMSLOGON FAR *             lppMSLogon,                 \
                LPMDB FAR *                 lppMDB) IPURE;              \
    MAPIMETHOD(SpoolerLogon)                                            \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags,                    \
                LPCIID                      lpInterface,                \
                ULONG                       cbSpoolSecurity,            \
                LPBYTE                      lpbSpoolSecurity,           \
                LPMAPIERROR FAR *           lppMAPIError,               \
                LPMSLOGON FAR *             lppMSLogon,                 \
                LPMDB FAR *                 lppMDB) IPURE;              \
    MAPIMETHOD(CompareStoreIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IMSProvider
DECLARE_MAPI_INTERFACE_(IMSProvider, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMSPROVIDER_METHODS(PURE)
};

/* The MSLOGON object is returned by the Logon() method of the
 * MSPROVIDER interface.  This object is for use by MAPIX.DLL.
 */
#define MAPI_IMSLOGON_METHODS(IPURE)                                    \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Logoff)                                                  \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPVOID FAR *                lppEntry) IPURE;            \

#undef       INTERFACE
#define      INTERFACE  IMSLogon
DECLARE_MAPI_INTERFACE_(IMSLogon, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMSLOGON_METHODS(PURE)
};

/* Message Store Provider Entry Point */

typedef HRESULT (STDMAPIINITCALLTYPE MSPROVIDERINIT)(
    HINSTANCE               hInstance,
    LPMALLOC                lpMalloc,           /* AddRef() if you keep it */
    LPALLOCATEBUFFER        lpAllocateBuffer,   /* -> AllocateBuffer */
    LPALLOCATEMORE          lpAllocateMore,     /* -> AllocateMore   */
    LPFREEBUFFER            lpFreeBuffer,       /* -> FreeBuffer     */
    ULONG                   ulFlags,
    ULONG                   ulMAPIVer,
    ULONG FAR *             lpulProviderVer,
    LPMSPROVIDER FAR *      lppMSProvider
);

MSPROVIDERINIT MSProviderInit;


/********************************************************************/
/*                                                                  */
/*                    MESSAGE SERVICE CONFIGURATION                 */
/*                                                                  */
/********************************************************************/

/* Flags for service configuration entry point */

/* #define UI_SERVICE                0x00000002 */
/* #define UI_CURRENT_PROVIDER_FIRST 0x00000004 */
#define MSG_SERVICE_UI_READ_ONLY     0x00000008 /* display parameters only */

/* Contexts for service configuration entry point */

#define MSG_SERVICE_INSTALL         0x00000001
#define MSG_SERVICE_CREATE          0x00000002
#define MSG_SERVICE_CONFIGURE       0x00000003
#define MSG_SERVICE_DELETE          0x00000004
#define MSG_SERVICE_UNINSTALL       0x00000005
#define MSG_SERVICE_PROVIDER_CREATE 0x00000006
#define MSG_SERVICE_PROVIDER_DELETE 0x00000007

/* Prototype for service configuration entry point */

typedef HRESULT (STDAPICALLTYPE MSGSERVICEENTRY)(
    HINSTANCE       hInstance,
    LPMALLOC        lpMalloc,
    LPMAPISUP       lpMAPISup,
    ULONG           ulUIParam,
    ULONG           ulFlags,
    ULONG           ulContext,
    ULONG           cValues,
    LPSPropValue    lpProps,
    LPPROVIDERADMIN lpProviderAdmin,
    LPMAPIERROR FAR *lppMapiError
);
typedef MSGSERVICEENTRY FAR *LPMSGSERVICEENTRY;


#ifdef __cplusplus
}
#endif

#endif /* MAPISPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\mapiutil.h ===
/*
 *  M A P I U T I L . H
 *
 *  Definitions and prototypes for utility functions provided by MAPI
 *  in MAPIU[xx].DLL.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPIUTIL_H_
#define _MAPIUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MAPIX_H
#include <mapix.h>
#endif

#ifdef WIN16
#include <storage.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif


/* IMAPITable in memory */

/* ITableData Interface ---------------------------------------------------- */

DECLARE_MAPI_INTERFACE_PTR(ITableData, LPTABLEDATA);

typedef void (STDAPICALLTYPE CALLERRELEASE)(
    ULONG       ulCallerData,
    LPTABLEDATA lpTblData,
    LPMAPITABLE lpVue
);

#define MAPI_ITABLEDATA_METHODS(IPURE)                                  \
    MAPIMETHOD(HrGetView)                                               \
        (THIS_  LPSSortOrderSet             lpSSortOrderSet,            \
                CALLERRELEASE FAR *         lpfCallerRelease,           \
                ULONG                       ulCallerData,               \
                LPMAPITABLE FAR *           lppMAPITable) IPURE;        \
    MAPIMETHOD(HrModifyRow)                                             \
        (THIS_  LPSRow) IPURE;                                          \
    MAPIMETHOD(HrDeleteRow)                                             \
        (THIS_  LPSPropValue                lpSPropValue) IPURE;        \
    MAPIMETHOD(HrQueryRow)                                              \
        (THIS_  LPSPropValue                lpsPropValue,               \
                LPSRow FAR *                lppSRow,                    \
                ULONG FAR *                 lpuliRow) IPURE;            \
    MAPIMETHOD(HrEnumRow)                                               \
        (THIS_  ULONG                       ulRowNumber,                \
                LPSRow FAR *                lppSRow) IPURE;             \
    MAPIMETHOD(HrNotify)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cValues,                    \
                LPSPropValue                lpSPropValue) IPURE;        \
    MAPIMETHOD(HrInsertRow)                                             \
        (THIS_  ULONG                       uliRow,                     \
                LPSRow                      lpSRow) IPURE;              \
    MAPIMETHOD(HrModifyRows)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRowSet                   lpSRowSet) IPURE;           \
    MAPIMETHOD(HrDeleteRows)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRowSet                   lprowsetToDelete,           \
                ULONG FAR *                 cRowsDeleted) IPURE;        \

#undef       INTERFACE
#define      INTERFACE  ITableData
DECLARE_MAPI_INTERFACE_(ITableData, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_ITABLEDATA_METHODS(PURE)
};


/* Entry Point for in memory ITable */


/*  CreateTable()
 *      Creates the internal memory structures and object handle
 *      to bring a new table into existence.
 *
 *  lpInterface
 *      Interface ID of the TableData object (IID_IMAPITableData)
 *
 *  lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *      Function addresses are provided by the caller so that
 *      this DLL allocates/frees memory appropriately.
 *  lpvReserved
 *      Reserved.  Should be NULL.
 *  ulTableType
 *      TBLTYPE_DYNAMIC, etc.  Visible to the calling application
 *      as part of the GetStatus return data on its views
 *  ulPropTagIndexColumn
 *      Index column for use when changing the data
 *  lpSPropTagArrayColumns
 *      Column proptags for the minimum set of columns in the table
 *  lppTableData
 *      Address of the pointer which will receive the TableData object
 */

STDAPI_(SCODE)
CreateTable( LPCIID                 lpInterface,
             ALLOCATEBUFFER FAR *   lpAllocateBuffer,
             ALLOCATEMORE FAR *     lpAllocateMore,
             FREEBUFFER FAR *       lpFreeBuffer,
             LPVOID                 lpvReserved,
             ULONG                  ulTableType,
             ULONG                  ulPropTagIndexColumn,
             LPSPropTagArray        lpSPropTagArrayColumns,
             LPTABLEDATA FAR *      lppTableData );

/*  HrGetView()
 *      This function obtains a new view on the underlying data
 *      which supports the IMAPITable interface.  All rows and columns
 *      of the underlying table data are initially visible
 *  lpSSortOrderSet
 *      if specified, results in the view being sorted
 *  lpfCallerRelease
 *      pointer to a routine to be called when the view is released, or
 *      NULL.
 *  ulCallerData
 *      arbitrary data the caller wants saved with this view and returned in
 *      the Release callback.
 */

/*  HrModifyRows()
 *      Add or modify a set of rows in the table data
 *  ulFlags
 *      Must be zero
 *  lpSRowSet
 *      Each row in the row set contains all the properties for one row
 *      in the table.  One of the properties must be the index column.  Any
 *      row in the table with the same value for its index column is
 *      replaced, or if there is no current row with that value the
 *      row is added.
 *      Each row in LPSRowSet MUST have a unique Index column!
 *      If any views are open, the view is updated as well.
 *      The properties do not have to be in the same order as the
 *      columns in the current table
 */

/*  HrModifyRow()
 *      Add or modify one row in the table
 *  lpSRow
 *      This row contains all the properties for one row in the table.
 *      One of the properties must be the index column.  Any row in
 *      the table with the same value for its index column is
 *      replaced, or if there is no current row with that value the
 *      row is added
 *      If any views are open, the view is updated as well.
 *      The properties do not have to be in the same order as the
 *      columns in the current table
 */

/*  HrDeleteRows()
 *      Delete a row in the table.
 *  ulFlags
 *      TAD_ALL_ROWS - Causes all rows in the table to be deleted
 *                     lpSRowSet is ignored in this case.
 *  lpSRowSet
 *      Each row in the row set contains all the properties for one row
 *      in the table.  One of the properties must be the index column.  Any
 *      row in the table with the same value for its index column is
 *      deleted.
 *      Each row in LPSRowSet MUST have a unique Index column!
 *      If any views are open, the view is updated as well.
 *      The properties do not have to be in the same order as the
 *      columns in the current table
 */
#define TAD_ALL_ROWS    1

/*  HrDeleteRow()
 *      Delete a row in the table.
 *  lpSPropValue
 *      This property value specifies the row which has this value
 *      for its index column
 */

/*  HrQueryRow()
 *      Returns the values of a specified row in the table
 *  lpSPropValue
 *      This property value specifies the row which has this value
 *      for its index column
 *  lppSRow
 *      Address of where to return a pointer to an SRow
 *  lpuliRow
 *    Address of where to return the row number. This can be NULL
 *    if the row number is not required.
 *
 */

/*  HrEnumRow()
 *      Returns the values of a specific (numbered) row in the table
 *  ulRowNumber
 *      Indicates row number 0 to n-1
 *  lppSRow
 *      Address of where to return a pointer to a SRow
 */

/*  HrInsertRow()
 *      Inserts a row into the table.
 *  uliRow
 *      The row number before which this row will be inserted into the table.
 *      Row numbers can be from 0 to n where o to n-1 result in row insertion
 *    a row number of n results in the row being appended to the table.
 *  lpSRow
 *      This row contains all the properties for one row in the table.
 *      One of the properties must be the index column.  Any row in
 *      the table with the same value for its index column is
 *      replaced, or if there is no current row with that value the
 *      row is added
 *      If any views are open, the view is updated as well.
 *      The properties do not have to be in the same order as the
 *      columns in the current table
 */


/* IMAPIProp in memory */

/* IPropData Interface ---------------------------------------------------- */


#define MAPI_IPROPDATA_METHODS(IPURE)                                   \
    MAPIMETHOD(HrSetObjAccess)                                          \
        (THIS_  ULONG                       ulAccess) IPURE;            \
    MAPIMETHOD(HrSetPropAccess)                                         \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG FAR *                 rgulAccess) IPURE;          \
    MAPIMETHOD(HrGetPropAccess)                                         \
        (THIS_  LPSPropTagArray FAR *       lppPropTagArray,            \
                ULONG FAR * FAR *           lprgulAccess) IPURE;        \
    MAPIMETHOD(HrAddObjProps)                                           \
        (THIS_  LPSPropTagArray             lppPropTagArray,            \
                LPSPropProblemArray FAR *   lprgulAccess) IPURE;


#undef       INTERFACE
#define      INTERFACE  IPropData
DECLARE_MAPI_INTERFACE_(IPropData, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IPROPDATA_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IPropData, LPPROPDATA);


/* Entry Point for in memory IMAPIProp */


/*  CreateIProp()
 *      Creates the internal memory structures and object handle
 *      to bring a new property interface into existance.
 *
 *  lpInterface
 *      Interface ID of the TableData object (IID_IMAPIPropData)
 *
 *  lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *      Function addresses are provided by the caller so that
 *      this DLL allocates/frees memory appropriately.
 *  lppPropData
 *      Address of the pointer which will receive the IPropData object
 *  lpvReserved
 *      Reserved.  Should be NULL.
 */

STDAPI_(SCODE)
CreateIProp( LPCIID                 lpInterface,
             ALLOCATEBUFFER FAR *   lpAllocateBuffer,
             ALLOCATEMORE FAR *     lpAllocateMore,
             FREEBUFFER FAR *       lpFreeBuffer,
             LPVOID                 lpvReserved,
             LPPROPDATA FAR *       lppPropData );

/*
 *  Defines for prop/obj access
 */
#define IPROP_READONLY      ((ULONG) 0x00000001)
#define IPROP_READWRITE     ((ULONG) 0x00000002)
#define IPROP_CLEAN         ((ULONG) 0x00010000)
#define IPROP_DIRTY         ((ULONG) 0x00020000)

/*
 -  HrSetPropAccess
 -
 *  Sets access right attributes on a per-property basis.  By default,
 *  all properties are read/write.
 *
 */

/*
 -  HrSetObjAccess
 -
 *  Sets access rights for the object itself.  By default, the object has
 *  read/write access.
 *
 */


/* IDLE Engine */

#ifndef NOIDLEENGINE

/* Idle time scheduler */

/*
 *  PRI
 *
 *  Priority.  Idle function priority where 0 is the priority of
 *  a "user event" (mouse click, WM_PAINT, etc).  Idle routines
 *  can have priorities greater than or less than 0, but not
 *  equal to 0.  Priorities greater than zero are background
 *  tasks that have a higher priority than user events and are
 *  dispatched as part of the standard message pump loop.  Priorities
 *  less than zero are idle tasks that only run during message pump
 *  idle time.  The priorities are sorted and the one with the higher
 *  value runs first.  For negative priorities, for example, -3 is
 *  higher than -5.  Within a priority level, the functions are called
 *  round-robin.
 *
 *  Example priorities (subject to change):
 *
 *  Foreground submission        1
 *  Power Edit char insertion   -1
 *  Autoscrolling               -1
 *  Background redraw           -2
 *  Misc FW fixups              -2
 *  Clock                       -2
 *  Download new mail           -3
 *  Background submission       -4
 *  Poll for MTA back up        -4
 *  Poll for new mail           -4
 *  ISAM buffer flush           -5
 *  MS compaction               -6
 *
 */

#define PRILOWEST   -32768
#define PRIHIGHEST  32767
#define PRIUSER     0

/*
 *  SCH
 *
 *  Idle Scheduler state.  This is the state of the system when the
 *  idle routine dispatcher, FDoNextIdleTask() is called.
 *  This is a combined bit mask consisting of individual fsch's.
 *  Listed below are the possible bit flags.
 *
 *      fschUserEvent   - FDoNextIdleTask() is being called while in
 *                        the user event loop, i.e. not during idle
 *                        time.  This is to allow background routines
 *                        to run that have a higher priority than user
 *                        events.
 */

#define SCHNULL         ((USHORT) 0x0000)
#define FSCHUSEREVENT   ((USHORT) 0x0008)

/*
 *  IRO
 *
 *  Idle routine options.  This is a combined bit mask consisting of
 *  individual firo's.  Listed below are the possible bit flags.
 *
 *      The following two flags are considered mutually exclusive:
 *      If neither of the flags are specified, the default action
 *      is to ignore the time parameter of the idle function and
 *      call it as often as possible if firoPerBlock is not set;
 *      otherwise call it one time only during the idle block
 *      once the time constraint has been set.  Note that firoInterval
 *      is incompatible with firoPerBlock.
 *
 *      firoWait        - time given is minimum idle time before calling
 *                        for the first time in the block of idle time,
 *                        afterwhich call as often as possible.
 *      firoInterval    - time given is minimum interval between each
 *                        successive call
 *
 *      firoPerBlock    - called only once per contiguous block of idle
 *                        time
 *
 *      firoDisabled    - initially disabled when registered, the
 *                        default is to enable the function when registered.
 *      firoOnceOnly    - called only one time by the scheduler and then
 *                        deregistered automatically.
 */

#define IRONULL         ((USHORT) 0x0000)
#define FIROWAIT        ((USHORT) 0x0001)
#define FIROINTERVAL    ((USHORT) 0x0002)
#define FIROPERBLOCK    ((USHORT) 0x0004)
#define FIRODISABLED    ((USHORT) 0x0020)
#define FIROONCEONLY    ((USHORT) 0x0040)

/*
 *  CSEC
 *
 *  Hundreths of a second.  Used in specifying idle function parameters.
 *  Each idle function has a time associated with it.  This time can
 *  represent the minimum length of user idle time that must elapse
 *  before the function is called, after which it is called as often as
 *  possible (firoWait option).  Alternatively, the time can represent
 *  the minimum interval between calls to the function (firoInterval
 *  option).  Finally, the time can be ignored, in which case the
 *  function will be called as often as possible.
 *
 */

#define csecNull            ((ULONG) 0x00000000)

/*
 *  IRC
 *
 *  Idle routine change options.  This is a combined bit mask consisting of
 *  individual firc's.  Listed below are the possible bit flags.
 *
 */

#define IRCNULL         ((USHORT) 0x0000)
#define FIRCPFN         ((USHORT) 0x0001)   /* change function pointer */
#define FIRCPV          ((USHORT) 0x0002)   /* change parameter block  */
#define FIRCPRI         ((USHORT) 0x0004)   /* change priority         */
#define FIRCCSEC        ((USHORT) 0x0008)   /* change time             */
#define FIRCIRO         ((USHORT) 0x0010)   /* change routine options  */

/*
 *  Type definition for idle functions.  An idle function takes one
 *  parameter, an PV, and returns a BOOL value.
 */

typedef BOOL (STDAPICALLTYPE FNIDLE) (LPVOID);
typedef FNIDLE          *PFNIDLE;

/*
 *  FTG
 *
 *  Function Tag.  Used to identify a registered idle function.
 *
 */

typedef void far *FTG, **PFTG;
#define FTGNULL         ((FTG) NULL)

/*
 *
 *  What follows is declarations for the idle engine functions in mapiu.dll,
 *  with some description of each function
 *
 */

/*
 -  Idle_InitDLL
 -
 *  Purpose:
 *      Initialises the idle engine
 *      If the initialisation succeded, returns 0, else returns -1
 *
 *  Arguments:
 *      pMemAlloc   Pointer to memory allocator to be used by the DLL for
 *                  maintaining it's data structures of registered callbacks.
 *                  Only the first such memory allocator is accepted. Multiple
 *                  calls to Idle_InitDLL result in the first call returning
 *                  success and subsequent calls failing.
 */

STDAPI_(LONG)
Idle_InitDLL (LPMALLOC pMemAlloc);

STDAPI_(VOID)
Idle_DeInitDLL (VOID);

STDAPI_(VOID)
InstallFilterHook (BOOL);


/*
 *  FtgRegisterIdleRoutine
 *
 *  Purpose:
 *      Registers the function pfn of type PFNIDLE, i.e., (BOOL (*)(LPVOID))
 *      as an idle function.  Resorts the idle table based on the priority of
 *      the newly registered routine.
 *
 *      It will be called with the parameter pv by the scheduler
 *      FDoNextIdleTask().  The function has initial priority priIdle,
 *      associated time csecIdle, and options iroIdle.
 *
 *  Arguments:
 *      pfnIdle     Pointer to the idle loop routine.  The routine
 *                  will be called with the argument pvIdleParam (which
 *                  is initially given at registration) and must return a
 *                  BOOL. The function should always return FALSE
 *                  unless the idle routine is being called via
 *                  IdleExit() instead of the scheduler FDoNextIdleTask().
 *                  In this case, the global flag fIdleExit will be set
 *                  and the idle function should return TRUE if it
 *                  is ready to quit the application; else it should
 *                  return FALSE.  IdleExit() will repeatedly call the
 *                  idle function until it returns TRUE.
 *
 *      pvIdleParam Every time the idle function is called, this value
 *                  is passed as the idle function's parameter.  The
 *                  routine can use this as a pointer to a state buffer
 *                  for length operations.  This pointer can be changed
 *                  via a call to ChangeIdleRoutine().
 *
 *      priIdle     Initial priority of the idle routine.  This can be
 *                  changed via a call to ChangeIdleRoutine().
 *
 *      csecIdle    Initial time value associated with idle routine.
 *                  This can be changed via ChangeIdleRoutine().
 *
 *      iroIdle     Initial options associated with idle routine.  This
 *                  can be changed via ChangeIdleRoutine().
 *
 *  Returns:
 *      FTG identifying the routine.
 *      If the function could not be registered, perhaps due to
 *      memory problems, then ftgNull is returned.
 *
 */

STDAPI_(FTG)
FtgRegisterIdleRoutine (PFNIDLE pfnIdle, LPVOID pvIdleParam,
    short priIdle, ULONG csecIdle, USHORT iroIdle);

/*
 *  DeregisterIdleRoutine
 *
 *  Purpose:
 *      Removes the given routine from the list of idle routines.
 *      The routine will not be called again.  It is the responsibility
 *      of the caller to clean up any data structures pointed to by the
 *      pvIdleParam parameter; this routine does not free the block.
 *
 *      An idle routine is only deregistered if it is not currently
 *      active.  Thus if an idle routine directly or indirectly calls
 *      DeregisterIdleRoutine(), then the flag fDeregister is set, and
 *      the idle routine will be deregistered after it finishes.
 *      There are no checks made to make sure that the idle routine is in
 *      an exitable state.
 *
 *  Parameters:
 *      ftg     Identifies the routine to deregister.
 *
 *  Returns:
 *      void
 *
 */

STDAPI_(void)
DeregisterIdleRoutine (FTG ftg);

/*
 *  EnableIdleRoutine
 *
 *  Purpose:
 *      Enables or disables an idle routine.  Disabled routines are
 *      not called during the idle loop.
 *
 *  Parameters:
 *      ftg         Identifies the idle routine to be disabled.
 *      fEnable     TRUE if routine should be enabled, FALSE if
 *                  routine should be disabled.
 *
 *  Returns:
 *      void
 *
 */

STDAPI_(void)
EnableIdleRoutine (FTG ftg, BOOL fEnable);

/*
 *  ChangeIdleRoutine
 *
 *  Purpose:
 *      Changes some or all of the characteristics of the given idle
 *      function.  The changes to make are indicated with flags in the
 *      ircIdle parameter.  If the priority of an idle function is
 *      changed, the pInst->pftgIdle table is re-sorted.
 *
 *  Arguments:
 *      ftg         Identifies the routine to change
 *      pfnIdle     New idle function to call
 *      pvIdleParam New parameter block to use
 *      priIdle     New priority for idle function
 *      csecIdle    New time value for idle function
 *      iroIdle     New options for idle function
 *      ircIdle     Change options
 *
 *  Returns:
 *      void
 *
 */

STDAPI_(void)
ChangeIdleRoutine (FTG ftg, PFNIDLE pfnIdle, LPVOID pvIdleParam,
    short priIdle, ULONG csecIdle, USHORT iroIdle, USHORT ircIdle);

/*
 *  FDoNextIdleTask
 *
 *  Purpose:
 *      Calls the highest priority, registered, enabled, "eligible",
 *      idle routine.  Eligibility is determined by calling,
 *      FEligibleIdle()
 *      If all enabled routines of the highest priority level are not
 *      "eligible" at this time, the routines that are one notch lower
 *      in priority are checked next.  This continues until either a
 *      routine is actually run, or no routines are left to run.
 *      Routines of equal priority are called in a round-robin fashion.
 *      If an idle routine is actually dispatched, the function returns
 *      TRUE; else FALSE.
 *
 *  Returns:
 *      TRUE if an eligible routine is dispatched; else FALSE.
 *
 */

STDAPI_(BOOL) FDoNextIdleTask (void);

/*
 *  FIsIdleExit
 *
 *  Purpose:
 *      Returns state of fIdleExit flag, which is TRUE while
 *      IdleExit() is being called, so that idle routines can
 *      check the flag.  See IdleExit() for description of flag
 *
 *  Arguments:
 *      void
 *
 *  Returns:
 *      State of the fIdleExit flag.
 *
 */

STDAPI_(BOOL)
FIsIdleExit (void);

#ifdef  DEBUG

/*
 *  DumpIdleTable
 *
 *  Purpose:
 *      Used for debugging only.  Writes information in the PGD(hftgIdle)
 *      table to COM1.
 *
 *  Parameters:
 *      none
 *
 *  Returns:
 *      void
 *
 */

STDAPI_(void)
DumpIdleTable (void);

#endif

#endif  /* ! NOIDLEENGINE */


/* IMalloc Utilities */

STDAPI_(LPMALLOC) MAPIGetDefaultMalloc();


/* StreamOnFile (SOF) */

/*
 *  Methods and #define's for implementing an OLE 2.0 storage stream
 *  (as defined in the OLE 2.0 specs) on top of a system file.
 */

#define SOF_UNIQUEFILENAME  ((ULONG) 0x80000000)

STDMETHODIMP OpenStreamOnFile(
    LPALLOCATEBUFFER    lpAllocateBuffer,
    LPFREEBUFFER        lpFreeBuffer,
    ULONG               ulFlags,
    LPTSTR              szFileName,
    LPTSTR              szPrefix,
    LPSTREAM FAR *      lppStream);

typedef HRESULT (STDMETHODCALLTYPE FAR * LPOPENSTREAMONFILE) (
    LPALLOCATEBUFFER    lpAllocateBuffer,
    LPFREEBUFFER        lpFreeBuffer,
    ULONG               ulFlags,
    LPTSTR              szFileName,
    LPTSTR              szPrefix,
    LPSTREAM FAR *      lppStream);

#ifdef  WIN32
#define OPENSTREAMONFILE "OpenStreamOnFile"
#endif
#ifdef  WIN16
#define OPENSTREAMONFILE "_OPENSTREAMONFILE"
#endif


/* Property interface utilities */

/*
 *  Copies a single SPropValue from Src to Dest.  Handles all the various
 *  types of properties and will link its allocations given the master
 *  allocation object and an allocate more function.
 */
STDAPI_(SCODE)
PropCopyMore( LPSPropValue      lpSPropValueDest,
              LPSPropValue      lpSPropValueSrc,
              ALLOCATEMORE *    lpfAllocMore,
              LPVOID            lpvObject );

/*
 *  Returns the size in bytes of structure at lpSPropValue, including the
 *  Value.
 */
STDAPI_(ULONG)
UlPropSize( LPSPropValue    lpSPropValue );


STDAPI_(BOOL)
FEqualNames( LPMAPINAMEID lpName1, LPMAPINAMEID lpName2 );

#if defined(WIN32) && !defined(NT) && !defined(CHICAGO) && !defined(_MAC)
#define NT
#endif

STDAPI_(void)
GetInstance(LPSPropValue pvalMv, LPSPropValue pvalSv, ULONG uliInst);

STDAPI_(BOOL)
FRKFindSubpb( LPSPropValue lpSPropValueDst, LPSPropValue lpsPropValueSrc );

extern char rgchCsds[];
extern char rgchCids[];
extern char rgchCsdi[];
extern char rgchCidi[];

STDAPI_(BOOL)
FRKFindSubpsz( LPSPropValue lpSPropValueDst, LPSPropValue lpsPropValueSrc,
        ULONG ulFuzzyLevel );

STDAPI_(BOOL)
FPropContainsProp( LPSPropValue lpSPropValueDst,
                   LPSPropValue lpSPropValueSrc,
                   ULONG        ulFuzzyLevel );

STDAPI_(BOOL)
FPropCompareProp( LPSPropValue  lpSPropValue1,
                  ULONG         ulRelOp,
                  LPSPropValue  lpSPropValue2 );

STDAPI_(LONG)
LPropCompareProp( LPSPropValue  lpSPropValueA,
                  LPSPropValue  lpSPropValueB );

STDAPI_(HRESULT)
HrAddColumns(   LPMAPITABLE         lptbl,
                LPSPropTagArray     lpproptagColumnsNew,
                LPALLOCATEBUFFER    lpAllocateBuffer,
                LPFREEBUFFER        lpFreeBuffer);

STDAPI_(HRESULT)
HrAddColumnsEx( LPMAPITABLE         lptbl,
                LPSPropTagArray     lpproptagColumnsNew,
                LPALLOCATEBUFFER    lpAllocateBuffer,
                LPFREEBUFFER        lpFreeBuffer,
                void                (FAR *lpfnFilterColumns)(LPSPropTagArray ptaga));


/* Notification utilities */

/*
 *  Function that creates an advise sink object given a notification
 *  callback function and context.
 */

STDAPI
HrAllocAdviseSink( LPNOTIFCALLBACK lpfnCallback,
                   LPVOID lpvContext,
                   LPMAPIADVISESINK FAR *lppAdviseSink );


/*
 *  Wraps an existing advise sink with another one which guarantees
 *  that the original advise sink will be called in the thread on
 *  which it was created.
 */

STDAPI
HrThisThreadAdviseSink( LPMAPIADVISESINK lpAdviseSink,
                        LPMAPIADVISESINK FAR *lppAdviseSink);

/*
 *  Structure and functions for maintaining a list of advise sinks,
 *  together with the keys used to release them.
 */

typedef struct
{
    LPMAPIADVISESINK    lpAdvise;
    ULONG               ulConnection;
    ULONG               ulType;
    LPUNKNOWN           lpParent;
} ADVISEITEM, FAR *LPADVISEITEM;

typedef struct
{
    ULONG               cItemsMac;
    ULONG               cItemsMax;
    LPMALLOC            pmalloc;
    #if defined(WIN32) && !defined(MAC)
    CRITICAL_SECTION    cs;
    #endif
    ADVISEITEM          rgItems[1];
} ADVISELIST, FAR *LPADVISELIST;

#define CbNewADVISELIST(_citems) \
    (offsetof(ADVISELIST, rgItems) + (_citems) * sizeof(ADVISEITEM))
#define CbADVISELIST(_plist) \
    (offsetof(ADVISELIST, rgItems) + (_plist)->cItemsMax * sizeof(ADVISEITEM))


STDAPI_(SCODE)
ScAddAdviseList(    LPMALLOC pmalloc,
                    LPADVISELIST FAR *lppList,
                    LPMAPIADVISESINK lpAdvise,
                    ULONG ulConnection,
                    ULONG ulType,
                    LPUNKNOWN lpParent);
STDAPI_(SCODE)
ScDelAdviseList(    LPADVISELIST lpList,
                    ULONG ulConnection);
STDAPI_(SCODE)
ScFindAdviseList(   LPADVISELIST lpList,
                    ULONG ulConnection,
                    LPADVISEITEM FAR *lppItem);
STDAPI_(void)
DestroyAdviseList(  LPADVISELIST FAR *lppList);


/* Service Provider Utilities */

/*
 *  Structures and utility function for building a display table
 *  from resources.
 */

typedef struct {
    ULONG           ulCtlType;          /* DTCT_LABEL, etc. */
    ULONG           ulCtlFlags;         /* DT_REQUIRED, etc. */
    LPBYTE          lpbNotif;           /*  pointer to notification data */
    ULONG           cbNotif;            /* count of bytes of notification data */
    LPTSTR          lpszFilter;         /* character filter for edit/combobox */
    ULONG           ulItemID;           /* to validate parallel dlg template entry */
    union {                             /* ulCtlType discriminates */
        LPVOID          lpv;            /* Initialize this to avoid warnings */
        LPDTBLLABEL     lplabel;
        LPDTBLEDIT      lpedit;
        LPDTBLLBX       lplbx;
        LPDTBLCOMBOBOX  lpcombobox;
        LPDTBLDDLBX     lpddlbx;
        LPDTBLCHECKBOX  lpcheckbox;
        LPDTBLGROUPBOX  lpgroupbox;
        LPDTBLBUTTON    lpbutton;
        LPDTBLRADIOBUTTON lpradiobutton;
        LPDTBLINKEDIT   lpinkedit;
        LPDTBLMVLISTBOX lpmvlbx;
        LPDTBLMVDDLBX   lpmvddlbx;
        LPDTBLPAGE      lppage;
    } ctl;
} DTCTL, FAR *LPDTCTL;

typedef struct {
    ULONG           cctl;
    LPTSTR          lpszResourceName;   /* as usual, may be an integer ID */
    union {                             /* as usual, may be an integer ID */
        LPTSTR          lpszComponent;
        ULONG           ulItemID;
    };
    LPDTCTL         lpctl;
} DTPAGE, FAR *LPDTPAGE;



STDAPI
BuildDisplayTable(  LPALLOCATEBUFFER    lpAllocateBuffer,
                    LPALLOCATEMORE      lpAllocateMore,
                    LPFREEBUFFER        lpFreeBuffer,
                    LPMALLOC            lpMalloc,
                    HINSTANCE           hInstance,
                    UINT                cPages,
                    LPDTPAGE            lpPage,
                    ULONG               ulFlags,
                    LPMAPITABLE *       lppTable,
                    LPTABLEDATA *       lppTblData );


/*
 *  Function that initializes a progress indicator object. If an
 *  original indicator object is suppiiied, it is wrapped and the
 *  new object forwards update calls to the original.
 */

STDAPI
WrapProgress(   LPMAPIPROGRESS lpProgressOrig,
                ULONG ulMin,
                ULONG ulMax,
                ULONG ulFlags,
                LPMAPIPROGRESS FAR *lppProgress );


/* MAPI structure validation/copy utilities */

/*
 *  Validate, copy, and adjust pointers in MAPI structures:
 *      notification
 *      property value array
 *      option data
 */

STDAPI_(SCODE)
ScCountNotifications(int cntf, LPNOTIFICATION rgntf,
        ULONG FAR *pcb);

STDAPI_(SCODE)
ScCopyNotifications(int cntf, LPNOTIFICATION rgntf, LPVOID pvDst,
        ULONG FAR *pcb);

STDAPI_(SCODE)
ScRelocNotifications(int cntf, LPNOTIFICATION rgntf,
        LPVOID pvBaseOld, LPVOID pvBaseNew, ULONG FAR *pcb);

#ifdef MAPISPI_H

STDAPI_(SCODE)
ScCountOptionData(LPOPTIONDATA lpOption, ULONG FAR *pcb);

STDAPI_(SCODE)
ScCopyOptionData(LPOPTIONDATA lpOption, LPVOID pvDst, ULONG FAR *pcb);

STDAPI_(SCODE)
ScRelocOptionData(LPOPTIONDATA lpOption,
        LPVOID pvBaseOld, LPVOID pvBaseNew, ULONG FAR *pcb);

#endif  /* MAPISPI_H */

STDAPI_(SCODE)
ScCountProps(int cprop, LPSPropValue rgprop, ULONG FAR *pcb);

STDAPI_(LPSPropValue)
LpValFindProp(ULONG ulPropTag, ULONG cprop, LPSPropValue rgprop);

STDAPI_(SCODE)
ScCopyProps(int cprop, LPSPropValue rgprop, LPVOID pvDst,
        ULONG FAR *pcb);

STDAPI_(SCODE)
ScRelocProps(int cprop, LPSPropValue rgprop,
        LPVOID pvBaseOld, LPVOID pvBaseNew, ULONG FAR *pcb);

STDAPI_(SCODE)
ScDupPropset(int cprop, LPSPropValue rgprop,
        LPALLOCATEBUFFER lpAllocateBuffer, LPSPropValue FAR *prgprop);


/* General utility functions */

/* Related to the OLE Component object model */

STDAPI_(ULONG)          UlAddRef(LPVOID punk);
STDAPI_(ULONG)          UlRelease(LPVOID punk);

/* Related to the MAPI interface */

STDAPI                  HrGetOneProp(LPMAPIPROP pmp, ULONG ulPropTag,
                        LPSPropValue FAR *ppprop);
STDAPI                  HrSetOneProp(LPMAPIPROP pmp, LPSPropValue pprop);
STDAPI_(BOOL)           FPropExists(LPMAPIPROP pobj, ULONG ulPropTag);
STDAPI_(LPSPropValue)   PpropFindProp(LPSPropValue rgprop, ULONG cprop, ULONG ulPropTag);
STDAPI_(void)           FreePadrlist(LPADRLIST padrlist);
STDAPI_(void)           FreeProws(LPSRowSet prows);
STDAPI                  HrQueryAllRows(LPMAPITABLE ptable, 
                        LPSPropTagArray ptaga, LPSRestriction pres,
                        LPSSortOrderSet psos, LONG crowsMax,
                        LPSRowSet FAR *pprows);

/* Create or validate the IPM folder tree in a message store */

#define MAPI_FORCE_CREATE   1
#define MAPI_FULL_IPM_TREE  2

STDAPI                  HrValidateIPMSubtree(LPMDB pmdb, ULONG ulFlags,
                        ULONG FAR *pcValues, LPSPropValue FAR *prgprop,
                        LPMAPIERROR FAR *pperr);

/* Encoding and decoding strings */

STDAPI_(BOOL)           FBinFromHex(LPTSTR sz, LPBYTE pb);
STDAPI_(SCODE)          ScBinFromHexBounded(LPTSTR sz, LPBYTE pb, ULONG cb);
STDAPI_(void)           HexFromBin(LPBYTE pb, int cb, LPTSTR sz);
STDAPI_(ULONG)          UlFromSzHex(LPCTSTR sz);
STDAPI_(void)           EncodeID(LPBYTE, ULONG, LPTSTR);
STDAPI_(BOOL)           FDecodeID(LPTSTR, LPBYTE, ULONG *);
STDAPI_(ULONG)          CchOfEncoding(ULONG);
STDAPI_(ULONG)          CbOfEncoded(LPTSTR);
STDAPI_(int)            CchEncodedLine(int);

/* Encoding and decoding entry IDs */
STDAPI                  HrEntryIDFromSz(LPTSTR sz, ULONG FAR *pcb,
                        LPENTRYID FAR *ppentry);
STDAPI                  HrSzFromEntryID(ULONG cb, LPENTRYID pentry,
                        LPTSTR FAR *psz);
STDAPI                  HrComposeEID(LPMAPISESSION psession,
                        ULONG cbStoreSearchKey, LPBYTE pStoreSearchKey,
                        ULONG cbMsgEID, LPENTRYID pMsgEID,
                        ULONG FAR *pcbEID, LPENTRYID FAR *ppEID);
STDAPI                  HrDecomposeEID(LPMAPISESSION psession,
                        ULONG cbEID, LPENTRYID pEID,
                        ULONG FAR *pcbStoreEID, LPENTRYID FAR *ppStoreEID,
                        ULONG FAR *pcbMsgEID, LPENTRYID FAR *ppMsgEID);
STDAPI                  HrComposeMsgID(LPMAPISESSION psession,
                        ULONG cbStoreSearchKey, LPBYTE pStoreSearchKey,
                        ULONG cbMsgEID, LPENTRYID pMsgEID,
                        LPTSTR FAR *pszMsgID);
STDAPI                  HrDecomposeMsgID(LPMAPISESSION psession,
                        LPTSTR szMsgID,
                        ULONG FAR *pcbStoreEID, LPENTRYID FAR *ppStoreEID,
                        ULONG FAR *pcbMsgEID, LPENTRYID FAR *ppMsgEID);

/* C runtime substitutes */

typedef int (__cdecl FNSGNCMP)(const void FAR *pv1, const void FAR *pv2);
typedef FNSGNCMP FAR *PFNSGNCMP;

STDAPI_(LPTSTR)         SzFindCh(LPCTSTR sz, USHORT ch);            /* strchr */
STDAPI_(LPTSTR)         SzFindLastCh(LPCTSTR sz, USHORT ch);        /* strrchr */
STDAPI_(LPTSTR)         SzFindSz(LPCTSTR sz, LPCTSTR szKey);
STDAPI_(unsigned int)   UFromSz(LPCTSTR sz);                        /* atoi */
STDAPI_(void)           ShellSort(LPVOID pv, UINT cv,           /* qsort */
                        LPVOID pvT, UINT cb, PFNSGNCMP fpCmp);

FNSGNCMP                SgnCmpPadrentryByType;

STDAPI_(SCODE)          ScUNCFromLocalPath(LPSTR szLocal, LPSTR szUNC,
                        UINT cchUNC);
STDAPI_(SCODE)          ScLocalPathFromUNC(LPSTR szUNC, LPSTR szLocal,
                        UINT cchLocal);

/* 64-bit arithmetic with times */

STDAPI_(FILETIME)       FtAddFt(FILETIME Addend1, FILETIME Addend2);
STDAPI_(FILETIME)       FtMulDwDw(DWORD Multiplicand, DWORD Multiplier);
STDAPI_(FILETIME)       FtMulDw(DWORD Multiplier, FILETIME Multiplicand);
STDAPI_(FILETIME)       FtSubFt(FILETIME Minuend, FILETIME Subtrahend);
STDAPI_(FILETIME)       FtNegFt(FILETIME ft);


STDAPI WrapStoreEntryID (ULONG ulFlags, LPTSTR szDLLName, ULONG cbOrigEntry,
    LPENTRYID lpOrigEntry, ULONG *lpcbWrappedEntry, LPENTRYID *lppWrappedEntry);

/* RTF Sync Utilities */

#define RTF_SYNC_RTF_CHANGED    ((ULONG) 0x00000001)
#define RTF_SYNC_BODY_CHANGED   ((ULONG) 0x00000002)

STDAPI_(HRESULT)
RTFSync (LPMESSAGE lpMessage, ULONG ulFlags, BOOL FAR * lpfMessageUpdated);

STDAPI_(HRESULT)
WrapCompressedRTFStream (LPSTREAM lpCompressedRTFStream,
        ULONG ulFlags, LPSTREAM FAR * lpUncompressedRTFStream);

/* Storage on Stream */

#if defined(WIN32) || defined(WIN16)
STDAPI_(HRESULT)
HrIStorageFromStream (LPUNKNOWN lpUnkIn,
    LPCIID lpInterface, ULONG ulFlags, LPSTORAGE FAR * lppStorageOut);
#endif


#ifdef __cplusplus
}
#endif

#endif /* _MAPIUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\mapiwin.h ===
/*
 *  M A P I W I N . H
 *
 *  Definitions used by the MAPI Development Team to aid in
 *  developing single-source service providers that run on
 *  both WIN32 and WIN16 platforms.
 *  There are three sections.
 *
 *  The first section defines how to call something that
 *  is available by different methods in WIN16 vs. WIN32.
 *  As such, they are totally new mechanisms.
 *
 *  The second section establishes things that are available
 *  AS-IS in one environment but we have to define for the
 *  other environment.
 *
 *  The third section simply defines a few conventions
 *  (simplifications) for common operations.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

/*
 *  Routines are included in the first section to manage per-instance
 *  global variables for DLLs. They assume that all of the DLL's
 *  per-instance global variables live in a single block of memory.
 *  Functions are provided to install and retrieve the correct block of
 *  memory for the current instance.
 *
 *  There are only two functions:
 *
 *      PvGetInstanceGlobals    Call this to get the address of the
 *                              per-instance globals structure.
 *      ScSetinstanceGlobals    Call this to install the
 *                              per-instance globals structure. It
 *                              may fail if the number of instances
 *                              exceeds a certain limit.
 *
 *  The caller is free to choose the name, size, and allocation
 *  method of the per-instance global variables structure.
 *
 *  The WIN32 implementation uses a pointer in the DLL's data
 *  segment. This assumes that the DLL gets a separate instance
 *  of the default data segment per calling process.
 *
 *  The WIN16 implementation uses a fixed array of pointers and a
 *  matching fixed array of keys unique to the calling process.
 */

/*
 *  The second section consists largely of Win32 file I/O functions
 *  that are not supported under Win16. These functions are
 *  implemented in mapiwin.c, using DOS calls. Most have limitations
 *  relative to their Win32 counterparts, which are spelled out in
 *  the comments to the source code.
 */

#ifndef __MAPIWIN_H__
#define __MAPIWIN_H__

#include "mapinls.h"

#ifdef __cplusplus
extern "C" {
#endif


/********************************/
/*  Our conventions for things  */
/*  we choose to do differently */
/*  on WIN16 vs. WIN32.         */
/********************************/

#ifdef  WIN16

#define MULDIV(x,y,z)               MulDiv32(x,y,z)
#define IsBadReadPtr(lp,cb)         FBadReadPtr(lp,cb)

#define cInstMax                    50
LPVOID FAR PASCAL   PvGetInstanceGlobals(void);
LONG FAR PASCAL     ScSetInstanceGlobals(LPVOID pv);
LONG FAR PASCAL     ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid);
LPVOID FAR PASCAL   PvGetVerifyInstanceGlobals(DWORD dwPid);
LPVOID FAR PASCAL   PvSlowGetInstanceGlobals(DWORD dwPid);
BOOL __export FAR PASCAL FCleanupInstanceGlobals(WORD, DWORD);

#elif defined(MAC)  /* !WIN16 */

#define MULDIV(x,y,z)               MulDiv(x,y,z)

LPVOID FAR PASCAL   PvGetInstanceGlobals(WORD wDataSet);
LONG FAR PASCAL     ScSetInstanceGlobals(LPVOID pv, WORD wDataSet);
LONG FAR PASCAL     ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid,
                        WORD wDataSet);
LPVOID FAR PASCAL   PvGetVerifyInstanceGlobals(DWORD dwPid, DWORD wDataSet);
LPVOID FAR PASCAL   PvSlowGetInstanceGlobals(DWORD dwPid, DWORD wDataSet);
BOOL FAR PASCAL     FCleanupInstanceGlobals(WORD, DWORD);

#else   /* !WIN16 */

#define MULDIV(x,y,z)               MulDiv(x,y,z)

extern LPVOID pinstX;
#define PvGetInstanceGlobals()                  pinstX
#define ScSetInstanceGlobals(_pv)               (pinstX = _pv, 0)
#define PvGetVerifyInstanceGlobals(_pid)        pinstX
#define ScSetVerifyInstanceGlobals(_pv,_pid)    (pinstX = _pv, 0)
#define PvSlowGetInstanceGlobals(_pid)          pinstX

#endif  /* WIN16 */

#if defined(CHICAGO)
#define szMAPIDLLSuffix     "32"
#elif defined(WIN32) && !defined(MAC)
#define szMAPIDLLSuffix     "32"
#elif defined(WIN16) || defined(DOS) || defined(MAC)
#define szMAPIDLLSuffix     ""
#else
#error "Don't know the suffix for DLLs on this platform"
#endif

/********************************/
/*  Things missing from one     */
/*  system-provided environment */
/*  or the other.               */
/********************************/

#if !defined(WIN32) 
#define ZeroMemory(pb,cb)           memset((pb),0,(cb))
#define FillMemory(pb,cb,b)         memset((pb),(b),(cb))
#define CopyMemory(pbDst,pbSrc,cb)  do                              \
                                    {                               \
                                        size_t _cb = (size_t)(cb);  \
                                        if (_cb)                    \
                                            memcpy(pbDst,pbSrc,_cb);\
                                    } while (FALSE)
#define MoveMemory(pbDst,pbSrc,cb)  memmove((pbDst),(pbSrc),(cb))
#endif

#if defined(WIN16) || defined(MAC)

#ifndef MAC
#include <error.h>              /*  for GetLastError() */
#endif

typedef int                 INT;
typedef unsigned long       ULONG;
typedef short               SHORT;
typedef unsigned short      USHORT;
typedef double              LONGLONG;
typedef double              DWORDLONG;
typedef unsigned char       UCHAR;
typedef unsigned char FAR*  PUCHAR;
typedef int                 BOOL;


#ifndef MAC
typedef char                BOOLEAN;

#ifndef _FILETIME_
#define _FILETIME_
typedef struct tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif      /* _FILETIME */

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, FAR *LPSYSTEMTIME;

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    CHAR StandardName[ 32 ];        /* was WCHAR */
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    CHAR DaylightName[ 32 ];        /* was WCHAR */
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, FAR *LPTIME_ZONE_INFORMATION;


#define TEXT(quote)     quote


#define APIENTRY        WINAPI

#define SetForegroundWindow         SetActiveWindow

#define wsprintfA                   wsprintf
#define GetWindowsDirectoryA        GetWindowsDirectory
#define GetSystemDirectoryA         GetSystemDirectory
#define GetPrivateProfileStringA    GetPrivateProfileString
#define GetPrivateProfileIntA       GetPrivateProfileInt
#define GetProfileStringA           GetProfileString
#define GetModuleFileNameA          GetModuleFileName
#define CharUpperBuffA              CharUpperBuff
#define LoadLibraryA                LoadLibrary
#define lstrcatA                    lstrcat
#define RegisterWindowMessageA      RegisterWindowMessage
#define MAKEINTRESOURCEA            MAKEINTRESOURCE

#define WNDCLASSA                   WNDCLASS                                    

#endif  /* !MAC */

/* Synchronization */
#define InterlockedIncrement(plong) (++(*(plong)))
#define InterlockedDecrement(plong) (--(*(plong)))

#ifndef CreateMutex
#define CreateMutexA    CreateMutex
#define CreateMutexW    CreateMutex
#define CreateMutex(pv, bool, sz)   (INVALID_HANDLE_VALUE)
#endif

#define WaitForSingleObject(hObj, dw)   ((void)0)
#define ReleaseMutex(hObj)              ((BOOL)1)
#define CloseMutexHandle(hObj)          TRUE

#define CRITICAL_SECTION            ULONG
#define InitializeCriticalSection(_pcs) ((void)0)
#define DeleteCriticalSection(_pcs)     ((void)0)
#define EnterCriticalSection(_pcs)      ((void)0)
#define LeaveCriticalSection(_pcs)      ((void)0)

#define MAX_PATH                    260

#ifndef MAC
/*
 *  File Access Modes
 *
 *  The possible combination of file access modes as passed into
 *  the CreateFile() api map to OpenFile() as follows:
 *
 *   GENERIC_READ                       OPEN_ACCESS_READONLY
 *   GENERIC_WRITE                      OPEN_ACCESS_WRITEONLY
 *   GENERIC_READ | GENERIC_WRITE       OPEN_ACCESS_READWRITE
 *
 *   0                                  OPEN_SHARE_DENYREADWRITE
 *   FILE_SHARE_READ                    OPEN_SHARE_DENYWRITE
 *   FILE_SHARE_WRITE                   OPEN_SHARE_DENYREAD
 *   FILE_SHARE_READ | FILE_SHARE_WRITE OPEN_SHARE_DENYNONE
 *
 *  Due to the mappings we cannot pass them through directly,
 *  so we will have to use a conversion within APIs that test
 *  these bits.  It would be best to use the WIN32 #defines
 *  for these flags and convert as needed in the APIs.
 */
#define GENERIC_READ                (0x80000000) /* from WINNT.H */
#define GENERIC_WRITE               (0x40000000) /* from WINNT.H */
#define FILE_SHARE_READ             (0x00000001) /* from WINNT.H */
#define FILE_SHARE_WRITE            (0x00000002) /* from WINNT.H */
#endif  /* MAC */

#define FILE_FLAG_SEQUENTIAL_SCAN   0x08000000

#define CREATE_NEW          1
#define CREATE_ALWAYS       2
#define OPEN_EXISTING       3
#define OPEN_ALWAYS         4
#define TRUNCATE_EXISTING   5

#ifndef MAC
#define INVALID_HANDLE_VALUE        ((HANDLE)(-1))
#define DELETE                      0x00010000L

#define FILE_BEGIN                  0
#define FILE_CURRENT                1
#define FILE_END                    2
#endif

#define FILE_ATTRIBUTE_READONLY         0x00000001
#define FILE_ATTRIBUTE_HIDDEN           0x00000002
#define FILE_ATTRIBUTE_SYSTEM           0x00000004
#define FILE_ATTRIBUTE_DIRECTORY        0x00000010
#define FILE_ATTRIBUTE_ARCHIVE          0x00000020
#define FILE_ATTRIBUTE_NORMAL           0x00000080
#define FILE_ATTRIBUTE_TEMPORARY        0x00000100

#define FILE_FLAG_WRITE_THROUGH     0x80000000
#define FILE_FLAG_RANDOM_ACCESS     0x10000000

#ifndef MAC
typedef struct _WIN32_FIND_DATA {
    DWORD       dwFileAttributes;
    FILETIME    ftCreationTime;
    FILETIME    ftLastAccessTime;
    FILETIME    ftLastWriteTime;
    DWORD       nFileSizeHigh;
    DWORD       nFileSizeLow;
    DWORD       dwReserved0;
    DWORD       dwReserved1;
    CHAR        cFileName[ MAX_PATH ];
    CHAR        cAlternateFileName[ 16 ];
} WIN32_FIND_DATA, *PWIN32_FIND_DATA, *LPWIN32_FIND_DATA;

#define TIME_ZONE_ID_INVALID        0xFFFFFFFF
#endif
#define TIME_ZONE_ID_UNKNOWN        0
#define TIME_ZONE_ID_STANDARD       1
#define TIME_ZONE_ID_DAYLIGHT       2



DWORD WINAPI    GetLastError(void);
DWORD WINAPI    GetFileAttributes(LPCSTR lpFileName);
DWORD WINAPI    GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
BOOL WINAPI     GetFileTime(HANDLE hFile, FILETIME FAR *lpftCreation,
                FILETIME FAR *lpftLastAccess, FILETIME FAR *lpftLastWrite);
#ifndef MAC
HANDLE WINAPI   CreateFile(LPCSTR lpFileName, DWORD dwDesiredAccess,
                DWORD dwShareMode, LPVOID lpSecurityAttributes,
                DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes,
                HANDLE hTemplateFile);
BOOL WINAPI     ReadFile(HANDLE hFile, LPVOID lpBuffer,
                DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead,
                LPVOID lpOverlapped);
BOOL WINAPI     WriteFile(HANDLE hFile, LPCVOID lpBuffer,
                DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten,
                LPVOID lpOverlapped);
#endif
DWORD WINAPI    SetFilePointer(HANDLE hFile, LONG lDistanceToMove,
                LONG FAR *lpDistanceToMoveHigh, DWORD dwMoveMethod);
BOOL WINAPI     SetEndOfFile(HANDLE hFile);
BOOL WINAPI     CloseHandle(HANDLE hObject);
DWORD WINAPI    GetTempPath(DWORD nBufferLength, LPSTR lpBuffer);
UINT WINAPI     GetTempFileName32 (LPCSTR lpPathName, LPCSTR lpPrefixString,
                UINT uUnique, LPSTR lpTempFileName);
BOOL WINAPI     DeleteFile(LPCSTR lpFileName);
#ifndef MAC
BOOL WINAPI     CreateDirectory(LPCSTR lpPathName, LPVOID lpSecurityAttributes);
#endif
BOOL WINAPI     RemoveDirectory(LPCSTR lpPathName);
BOOL WINAPI     CopyFile(LPCSTR szSrc, LPCSTR szDst, BOOL fFailIfExists);
BOOL WINAPI     MoveFile(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
HANDLE WINAPI   FindFirstFile(LPCSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData);
BOOL WINAPI     FindNextFile(HANDLE hFindFile, LPWIN32_FIND_DATA lpFindFileData);
BOOL WINAPI     FindClose(HANDLE hFindFile);
DWORD WINAPI    GetFullPathName(LPCSTR lpFileName, DWORD nBufferLength,
                LPSTR lpBuffer, LPSTR *lpFilePart);
void WINAPI     Sleep(DWORD dwMilliseconds);
LONG WINAPI     CompareFileTime(const FILETIME FAR *, const FILETIME FAR *);
BOOL WINAPI     LocalFileTimeToFileTime(const FILETIME FAR *, FILETIME FAR *);
BOOL WINAPI     FileTimeToLocalFileTime(const FILETIME FAR *, FILETIME FAR *);
BOOL WINAPI     FileTimeToSystemTime(const FILETIME FAR *, SYSTEMTIME FAR *);
BOOL WINAPI     SystemTimeToFileTime(const SYSTEMTIME FAR *, FILETIME FAR *);
void WINAPI     GetSystemTime(SYSTEMTIME FAR *);
void WINAPI     GetLocalTime(SYSTEMTIME FAR *);
BOOL WINAPI     FileTimeToDosDateTime(const FILETIME FAR * lpFileTime,
                WORD FAR *lpFatDate, WORD FAR *lpFatTime);
BOOL WINAPI     DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime,
                FILETIME FAR * lpFileTime);
DWORD WINAPI    GetTimeZoneInformation(
                LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
BOOL WINAPI     SetTimeZoneInformation(
                const TIME_ZONE_INFORMATION FAR *lpTimeZoneInformation);

DWORD WINAPI    GetCurrentProcessId(void);
long WINAPI     MulDiv32(long, long, long);
#ifndef MAC
BOOL WINAPI     FBadReadPtr(const void FAR* lp, UINT cb);
#endif

#else   /* !WIN16 */

/* Remaps GetTempFileName32() to the real 32bit version */

#define GetTempFileName32(_szPath,_szPfx,_n,_lpbuf) GetTempFileName(_szPath,_szPfx,_n,_lpbuf)

#define CloseMutexHandle    CloseHandle

#endif  /* !WIN16 */


#ifdef MAC
#define CRITICAL_SECTION            ULONG
#define InitializeCriticalSection(_pcs) ((void)0)
#define DeleteCriticalSection(_pcs)     ((void)0)
#define EnterCriticalSection(_pcs)      ((void)0)
#define LeaveCriticalSection(_pcs)      ((void)0)
#endif

/********************************/
/*  Our private conventions     */
/*  (common to WIN16/WIN32)     */
/********************************/

#define Cbtszsize(_a)   ((lstrlen(_a)+1)*sizeof(TCHAR))
#define CbtszsizeA(_a)  ((lstrlenA(_a) + 1))
#define CbtszsizeW(_a)  ((lstrlenW(_a) + 1) * sizeof(WCHAR))
#define HexCchOf(_s)    (sizeof(_s)*2+1)
#define HexSizeOf(_s)   (HexCchOf(_s)*sizeof(TCHAR))

BOOL WINAPI IsBadBoundedStringPtr(const void FAR* lpsz, UINT cchMax);

/* FUTURE - obsolete. OLE2 no longer contains these */
#define GetSCode                    GetScode
#define ReportResult(_a,_b,_c,_d)   ResultFromScode(_b)

#ifdef __cplusplus
}
#endif

#endif /* __MAPIWIN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\mapix.h ===
/*
 *  M A P I X . H
 *  
 *  Definitions of objects/flags, etc used by Extended MAPI.
 *  
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIX_H
#define MAPIX_H

/* Include common MAPI header files if they haven't been already. */
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPICODE_H
#include <mapicode.h>
#endif
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPITAGS_H
#include <mapitags.h>
#endif

#ifdef  __cplusplus
extern "C" {
#endif  

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/* Forward interface declarations */

DECLARE_MAPI_INTERFACE_PTR(IProfAdmin,          LPPROFADMIN);
DECLARE_MAPI_INTERFACE_PTR(IMsgServiceAdmin,    LPSERVICEADMIN);

/* ------------------------------------------------------ */
/* shared with simple mapi */

typedef ULONG       FLAGS;

/* MAPILogon() flags.       */

#define MAPI_LOGON_UI           0x00000001  /* Display logon UI                 */
#define MAPI_NEW_SESSION        0x00000002  /* Don't use shared session         */
#define MAPI_ALLOW_OTHERS       0x00000008  /* Make this a shared session       */
#define MAPI_EXPLICIT_PROFILE   0x00000010  /* Don't use default profile        */
#define MAPI_EXTENDED           0x00000020  /* Extended MAPI Logon              */
#define MAPI_FORCE_DOWNLOAD     0x00001000  /* Get new mail before return       */
#define MAPI_SERVICE_UI_ALWAYS  0x00002000  /* Do logon UI in all providers     */
#define MAPI_NO_MAIL            0x00008000  /* Do not activate transports       */
#define MAPI_NT_SERVICE         0x00010000  /* Allow logon from an NT service   */
#ifndef MAPI_PASSWORD_UI
#define MAPI_PASSWORD_UI        0x00020000  /* Display password UI only         */
#endif
#define MAPI_TIMEOUT_SHORT      0x00100000  /* Minimal wait for logon resources */

#define MAPI_SIMPLE_DEFAULT (MAPI_LOGON_UI | MAPI_FORCE_DOWNLOAD | MAPI_ALLOW_OTHERS)
#define MAPI_SIMPLE_EXPLICIT (MAPI_NEW_SESSION | MAPI_FORCE_DOWNLOAD | MAPI_EXPLICIT_PROFILE)

/* Structure passed to MAPIInitialize(), and its ulFlags values */

typedef struct
{
    ULONG           ulVersion;
    ULONG           ulFlags;
} MAPIINIT_0, FAR *LPMAPIINIT_0;

typedef MAPIINIT_0 MAPIINIT;
typedef MAPIINIT FAR *LPMAPIINIT;

#define MAPI_INIT_VERSION               0

#define MAPI_MULTITHREAD_NOTIFICATIONS  0x00000001
/* #define MAPI_NT_SERVICE              0x00010000  Use from NT service */

/* MAPI base functions */

typedef HRESULT (STDAPICALLTYPE MAPIINITIALIZE)(
    LPVOID          lpvReserved
);
typedef MAPIINITIALIZE FAR *LPMAPIINITIALIZE;

typedef void (STDAPICALLTYPE MAPIUNINITIALIZE)(void);
typedef MAPIUNINITIALIZE FAR *LPMAPIUNINITIALIZE;

MAPIINITIALIZE      MAPIInitialize;
MAPIUNINITIALIZE    MAPIUninitialize;

#ifndef MAPILogon

typedef ULONG (FAR PASCAL MAPILOGONA)(
    ULONG ulUIParam,
    LPSTR lpszProfileName,
    LPSTR lpszPassword,
    FLAGS flFlags,
    ULONG ulReserved,
    LPLHANDLE lplhSession
);
typedef MAPILOGONA FAR *LPMAPILOGONA;

typedef ULONG (FAR PASCAL MAPILOGONW)(
    ULONG ulUIParam,
    LPWSTR lpszProfileName,
    LPWSTR lpszPassword,
    FLAGS flFlags,
    ULONG ulReserved,
    LPLHANDLE lplhSession
);
typedef MAPILOGONW FAR *LPMAPILOGONW;

MAPILOGONA MAPILogonA;
MAPILOGONW MAPILogonW;

#ifdef UNICODE
#define MAPILogon MAPILogonW
#else
#define MAPILogon MAPILogonA
#endif

#endif  /* MAPILogon */

typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEBUFFER)(
    ULONG           cbSize,
    LPVOID FAR *    lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEMORE)(
    ULONG           cbSize,
    LPVOID          lpObject,
    LPVOID FAR *    lppBuffer
);

typedef ULONG (STDAPICALLTYPE MAPIFREEBUFFER)(
    LPVOID          lpBuffer
);

typedef MAPIALLOCATEBUFFER FAR  *LPMAPIALLOCATEBUFFER;
typedef MAPIALLOCATEMORE FAR    *LPMAPIALLOCATEMORE;
typedef MAPIFREEBUFFER FAR      *LPMAPIFREEBUFFER;

MAPIALLOCATEBUFFER MAPIAllocateBuffer;
MAPIALLOCATEMORE MAPIAllocateMore;
MAPIFREEBUFFER MAPIFreeBuffer;

typedef HRESULT (STDMETHODCALLTYPE MAPIADMINPROFILES)(
    ULONG ulFlags,
    LPPROFADMIN FAR *lppProfAdmin
);

typedef MAPIADMINPROFILES FAR *LPMAPIADMINPROFILES;

MAPIADMINPROFILES MAPIAdminProfiles;

/* IMAPISession Interface -------------------------------------------------- */

/* Flags for OpenEntry and others */

/*#define MAPI_MODIFY               ((ULONG) 0x00000001) */

/* Flags for Logoff */

#define MAPI_LOGOFF_SHARED      0x00000001  /* Close all shared sessions    */
#define MAPI_LOGOFF_UI          0x00000002  /* It's OK to present UI        */

/* Flags for SetDefaultStore. They are mutually exclusive. */

#define MAPI_DEFAULT_STORE          0x00000001  /* for incoming messages */
#define MAPI_SIMPLE_STORE_TEMPORARY 0x00000002  /* for simple MAPI and CMC */
#define MAPI_SIMPLE_STORE_PERMANENT 0x00000003  /* for simple MAPI and CMC */

/* Flags for ShowForm. */

#define MAPI_POST_MESSAGE       0x00000001  /* Selects post/send semantics */
#define MAPI_NEW_MESSAGE        0x00000002  /* Governs copying during submission */

/*  MessageOptions */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/*  QueryDefaultMessageOpt */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

#define MAPI_IMAPISESSION_METHODS(IPURE)                                \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetMsgStoresTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenMsgStore)                                            \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMDB FAR *                 lppMDB) IPURE;              \
    MAPIMETHOD(OpenAddressBook)                                         \
        (THIS_  ULONG                       ulUIParam,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPADRBOOK FAR *             lppAdrBook) IPURE;          \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfSect) IPURE;         \
    MAPIMETHOD(GetStatusTable)                                          \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;  \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(MessageOptions)                                          \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPTSTR                      lpszAdrType,                \
                LPMESSAGE                   lpMessage) IPURE;           \
    MAPIMETHOD(QueryDefaultMessageOpt)                                  \
        (THIS_  LPTSTR                      lpszAdrType,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppOptions) IPURE;          \
    MAPIMETHOD(EnumAdrTypes)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcAdrTypes,                \
                LPTSTR FAR * FAR *          lpppszAdrTypes) IPURE;      \
    MAPIMETHOD(QueryIdentity)                                           \
        (THIS_  ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(Logoff)                                                  \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                ULONG                       ulReserved) IPURE;          \
    MAPIMETHOD(SetDefaultStore)                                         \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(AdminServices)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSERVICEADMIN FAR *        lppServiceAdmin) IPURE;     \
    MAPIMETHOD(ShowForm)                                                \
        (THIS_  ULONG                       ulUIParam,                  \
                LPMDB                       lpMsgStore,                 \
                LPMAPIFOLDER                lpParentFolder,             \
                LPCIID                      lpInterface,                \
                ULONG                       ulMessageToken,             \
                LPMESSAGE                   lpMessageSent,              \
                ULONG                       ulFlags,                    \
                ULONG                       ulMessageStatus,            \
                ULONG                       ulMessageFlags,             \
                ULONG                       ulAccess,                   \
                LPSTR                       lpszMessageClass) IPURE;    \
    MAPIMETHOD(PrepareForm)                                             \
        (THIS_  LPCIID                      lpInterface,                \
                LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulMessageToken) IPURE;    \


#undef       INTERFACE
#define      INTERFACE  IMAPISession
DECLARE_MAPI_INTERFACE_(IMAPISession, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPISESSION_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPISession, LPMAPISESSION);

/* IAddrBook Interface ----------------------------------------------------- */

/*  RecipOptions */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/*  QueryDefaultRecipOpt */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/*  GetSearchPath */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */


#define MAPI_IADDRBOOK_METHODS(IPURE)                                   \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;  \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(CreateOneOff)                                            \
        (THIS_  LPTSTR                      lpszName,                   \
                LPTSTR                      lpszAdrType,                \
                LPTSTR                      lpszAddress,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(NewEntry)                                                \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                ULONG                       cbEIDContainer,             \
                LPENTRYID                   lpEIDContainer,             \
                ULONG                       cbEIDNewEntryTpl,           \
                LPENTRYID                   lpEIDNewEntryTpl,           \
                ULONG FAR *                 lpcbEIDNewEntry,            \
                LPENTRYID FAR *             lppEIDNewEntry) IPURE;      \
    MAPIMETHOD(ResolveName)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPTSTR                      lpszNewEntryTitle,          \
                LPADRLIST                   lpAdrList) IPURE;           \
    MAPIMETHOD(Address)                                                 \
        (THIS_  ULONG FAR *                 lpulUIParam,                \
                LPADRPARM                   lpAdrParms,                 \
                LPADRLIST FAR *             lppAdrList) IPURE;          \
    MAPIMETHOD(Details)                                                 \
        (THIS_  ULONG FAR *                 lpulUIParam,                \
                LPFNDISMISS                 lpfnDismiss,                \
                LPVOID                      lpvDismissContext,          \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPFNBUTTON                  lpfButtonCallback,          \
                LPVOID                      lpvButtonContext,           \
                LPTSTR                      lpszButtonText,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(RecipOptions)                                            \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPADRENTRY                  lpRecip) IPURE;             \
    MAPIMETHOD(QueryDefaultRecipOpt)                                    \
        (THIS_  LPTSTR                      lpszAdrType,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppOptions) IPURE;          \
    MAPIMETHOD(GetPAB)                                                  \
        (THIS_  ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(SetPAB)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(GetDefaultDir)                                           \
        (THIS_  ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(SetDefaultDir)                                           \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(GetSearchPath)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppSearchPath) IPURE;       \
    MAPIMETHOD(SetSearchPath)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRowSet                   lpSearchPath) IPURE;        \
    MAPIMETHOD(PrepareRecips)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray             lpPropTagArray,             \
                LPADRLIST                   lpRecipList) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IAddrBook
DECLARE_MAPI_INTERFACE_(IAddrBook, IMAPIProp)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IADDRBOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IAddrBook, LPADRBOOK);

/* IProfAdmin Interface ---------------------------------------------------- */

/* Flags for CreateProfile */
#define MAPI_DEFAULT_SERVICES           0x00000001

/* GetProfileTable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

#define MAPI_IPROFADMIN_METHODS(IPURE)                                  \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetProfileTable)                                         \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(CreateProfile)                                           \
        (THIS_  LPTSTR                      lpszProfileName,            \
                LPTSTR                      lpszPassword,               \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteProfile)                                           \
        (THIS_  LPTSTR                      lpszProfileName,            \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ChangeProfilePassword)                                   \
        (THIS_  LPTSTR                      lpszProfileName,            \
                LPTSTR                      lpszOldPassword,            \
                LPTSTR                      lpszNewPassword,            \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CopyProfile)                                             \
        (THIS_  LPTSTR                      lpszOldProfileName,         \
                LPTSTR                      lpszOldPassword,            \
                LPTSTR                      lpszNewProfileName,         \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(RenameProfile)                                           \
        (THIS_  LPTSTR                      lpszOldProfileName,         \
                LPTSTR                      lpszOldPassword,            \
                LPTSTR                      lpszNewProfileName,         \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetDefaultProfile)                                       \
        (THIS_  LPTSTR                      lpszProfileName,            \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(AdminServices)                                           \
        (THIS_  LPTSTR                      lpszProfileName,            \
                LPTSTR                      lpszPassword,               \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPSERVICEADMIN FAR *        lppServiceAdmin) IPURE;     \


#undef       INTERFACE
#define      INTERFACE  IProfAdmin
DECLARE_MAPI_INTERFACE_(IProfAdmin, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IPROFADMIN_METHODS(PURE)
};

/* IMsgServiceAdmin Interface ---------------------------------------------- */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define SERVICE_DEFAULT_STORE       0x00000001
#define SERVICE_SINGLE_COPY         0x00000002
#define SERVICE_CREATE_WITH_STORE   0x00000004
#define SERVICE_PRIMARY_IDENTITY    0x00000008
#define SERVICE_NO_PRIMARY_IDENTITY 0x00000020

/*  GetMsgServiceTable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/*  GetProviderTable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

#define MAPI_IMSGSERVICEADMIN_METHODS(IPURE)                            \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetMsgServiceTable)                                      \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(CreateMsgService)                                        \
        (THIS_  LPTSTR                      lpszService,                \
                LPTSTR                      lpszDisplayName,            \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteMsgService)                                        \
        (THIS_  LPMAPIUID                   lpUID) IPURE;               \
    MAPIMETHOD(CopyMsgService)                                          \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPTSTR                      lpszDisplayName,            \
                LPCIID                      lpInterfaceToCopy,          \
                LPCIID                      lpInterfaceDst,             \
                LPVOID                      lpObjectDst,                \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(RenameMsgService)                                        \
        (THIS_  LPMAPIUID                   lpUID,                      \
                ULONG                       ulFlags,                    \
                LPTSTR                      lpszDisplayName) IPURE;     \
    MAPIMETHOD(ConfigureMsgService)                                     \
        (THIS_  LPMAPIUID                   lpUID,                      \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                ULONG                       cValues,                    \
                LPSPropValue                lpProps) IPURE;             \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfSect) IPURE;         \
    MAPIMETHOD(MsgServiceTransportOrder)                                \
        (THIS_  ULONG                       cUID,                       \
                LPMAPIUID                   lpUIDList,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(AdminProviders)                                          \
        (THIS_  LPMAPIUID                   lpUID,                      \
                ULONG                       ulFlags,                    \
                LPPROVIDERADMIN FAR *       lppProviderAdmin) IPURE;    \
    MAPIMETHOD(SetPrimaryIdentity)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetProviderTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \


#undef       INTERFACE
#define      INTERFACE  IMsgServiceAdmin
DECLARE_MAPI_INTERFACE_(IMsgServiceAdmin, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMSGSERVICEADMIN_METHODS(PURE)
};

#ifdef  __cplusplus
}       /*  extern "C" */
#endif  

#endif /* MAPIX_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\mspab.h ===
/*
 *  M S P A B . H
 *  
 *  Public definitions for the Microsoft Personal Address Book
 *  
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

/*
 *  Microsoft Personal Address Book Provider ID
 *  -------------------------------------------
 */

#define PAB_PROVIDER_ID     \
{                           \
    0xB5, 0x3b, 0xc2, 0xc0, \
    0x2c, 0x77, 0x10, 0x1a, \
    0xa1, 0xbc, 0x08, 0x00, \
    0x2b, 0x2a, 0x56, 0xc2  \
}


/*
 *  Messaging Service Properties
 *  ----------------------------
 *
 *  The following properties are required to completely configure
 *  the Microsoft Personal Address Book messaging service with
 *  IMsgServiceAdmin::ConfigureMsgService() if UI is not requested
 *  by passing the UI_SERVICE flag.
 */

/*
 *      Fully qualified pathname of .PAB file to use
 */
#define     PR_PAB_PATH                     PROP_TAG( PT_TSTRING,   0x6600 )
#define     PR_PAB_PATH_W                   PROP_TAG( PT_UNICODE,   0x6600 )
#define     PR_PAB_PATH_A                   PROP_TAG( PT_STRING8,   0x6600 )

/*
 *  The following additional properties may also be passed to
 *  customize the configuration.
 */

/*
 *      PR_DISPLAY_NAME
 *          The display name to be used for the PAB in the address
 *          book hierarchy.
 *
 *      PR_COMMENT
 *          A comment to be associated with the PAB.
 *
 *      PR_PAB_DET_DIR_VIEW_BY
 *          Determines how names of entries in the PAB with separate first
 *          and last names are displayed.
 *
 *          Possible values are:
 *
 *          PAB_DIR_VIEW_FIRST_THEN_LAST    First name followed by last name
 *          (default)                       (e.g. "Dave Olsen").
 *
 *          PAB_DIR_VIEW_LAST_THEN_FIRST    Last name followed by separator
 *                                          followed by first name
 *                                          (e.g. "Olsen, Dave").
 *
 *      PR_PAB_SORT_ORDER
 *          Determines order in which entries in the PAB are displayed.
 *          The value is a binary which is a SSortOrderSet.  The default
 *          sort order is ascending by PR_DISPLAY_NAME.
 */
#define     PR_PAB_DET_DIR_VIEW_BY          PROP_TAG( PT_LONG,      0x6601 )
#define     PR_PAB_DIR_SORT_ORDER           PROP_TAG( PT_BINARY,    0x6603 )

#define     PAB_DIR_VIEW_FIRST_THEN_LAST    0
#define     PAB_DIR_VIEW_LAST_THEN_FIRST    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\mapitags.h ===
/*
 *  M A P I T A G S . H
 *
 *  Property tag definitions for standard properties of MAPI
 *  objects.
 *
 *  The following ranges should be used for all property IDs. Note that
 *  property IDs for objects other than messages and recipients should
 *  all fall in the range 0x3000 to 0x3FFF:
 *
 *  From    To      Kind of property
--------------------------------
 *  0001    0BFF    MAPI_defined envelope property
 *  0C00    0DFF    MAPI_defined per-recipient property
 *  0E00    0FFF    MAPI_defined non-transmittable property
 *  1000    2FFF    MAPI_defined message content property
 *
 *  3000    3FFF    MAPI_defined property (usually not message or recipient)
 *
 *  4000    57FF    Transport-defined envelope property
 *  5800    5FFF    Transport-defined per-recipient property
 *  6000    65FF    User-defined non-transmittable property
 *  6600    67FF    Provider-defined internal non-transmittable property
 *  6800    7BFF    Message class-defined content property
 *  7C00    7FFF    Message class-defined non-transmittable
 *                  property
 *
 *  8000    FFFE    User-defined Name-to-id mapped property
 *
 *  The 3000-3FFF range is further subdivided as follows:
 *
 *  From    To      Kind of property
--------------------------------
 *  3000    33FF    Common property such as display name, entry ID
 *  3400    35FF    Message store object
 *  3600    36FF    Folder or AB container
 *  3700    38FF    Attachment
 *  3900    39FF    Address book object
 *  3A00    3BFF    Mail user
 *  3C00    3CFF    Distribution list
 *  3D00    3DFF    Profile section
 *  3E00    3FFF    Status object
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPITAGS_H
#define MAPITAGS_H

/* Determine if a property is transmittable. */

#define FIsTransmittable(ulPropTag) \
    ((PROP_ID (ulPropTag) <  (ULONG)0x0E00) || \
    (PROP_ID (ulPropTag)  >= (ULONG)0x8000) || \
    ((PROP_ID (ulPropTag) >= (ULONG)0x1000) && (PROP_ID (ulPropTag) < (ULONG)0x6000)) || \
    ((PROP_ID (ulPropTag) >= (ULONG)0x6800) && (PROP_ID (ulPropTag) < (ULONG)0x7C00)))

/*
 *  Message envelope properties
 */

#define PR_ACKNOWLEDGEMENT_MODE                     PROP_TAG( PT_LONG,      0x0001)
#define PR_ALTERNATE_RECIPIENT_ALLOWED              PROP_TAG( PT_BOOLEAN,   0x0002)
#define PR_AUTHORIZING_USERS                        PROP_TAG( PT_BINARY,    0x0003)
#define PR_AUTO_FORWARD_COMMENT                     PROP_TAG( PT_TSTRING,   0x0004)
#define PR_AUTO_FORWARD_COMMENT_W                   PROP_TAG( PT_UNICODE,   0x0004)
#define PR_AUTO_FORWARD_COMMENT_A                   PROP_TAG( PT_STRING8,   0x0004)
#define PR_AUTO_FORWARDED                           PROP_TAG( PT_BOOLEAN,   0x0005)
#define PR_CONTENT_CONFIDENTIALITY_ALGORITHM_ID     PROP_TAG( PT_BINARY,    0x0006)
#define PR_CONTENT_CORRELATOR                       PROP_TAG( PT_BINARY,    0x0007)
#define PR_CONTENT_IDENTIFIER                       PROP_TAG( PT_TSTRING,   0x0008)
#define PR_CONTENT_IDENTIFIER_W                     PROP_TAG( PT_UNICODE,   0x0008)
#define PR_CONTENT_IDENTIFIER_A                     PROP_TAG( PT_STRING8,   0x0008)
#define PR_CONTENT_LENGTH                           PROP_TAG( PT_LONG,      0x0009)
#define PR_CONTENT_RETURN_REQUESTED                 PROP_TAG( PT_BOOLEAN,   0x000A)



#define PR_CONVERSATION_KEY                         PROP_TAG( PT_BINARY,    0x000B)

#define PR_CONVERSION_EITS                          PROP_TAG( PT_BINARY,    0x000C)
#define PR_CONVERSION_WITH_LOSS_PROHIBITED          PROP_TAG( PT_BOOLEAN,   0x000D)
#define PR_CONVERTED_EITS                           PROP_TAG( PT_BINARY,    0x000E)
#define PR_DEFERRED_DELIVERY_TIME                   PROP_TAG( PT_SYSTIME,   0x000F)
#define PR_DELIVER_TIME                             PROP_TAG( PT_SYSTIME,   0x0010)
#define PR_DISCARD_REASON                           PROP_TAG( PT_LONG,      0x0011)
#define PR_DISCLOSURE_OF_RECIPIENTS                 PROP_TAG( PT_BOOLEAN,   0x0012)
#define PR_DL_EXPANSION_HISTORY                     PROP_TAG( PT_BINARY,    0x0013)
#define PR_DL_EXPANSION_PROHIBITED                  PROP_TAG( PT_BOOLEAN,   0x0014)
#define PR_EXPIRY_TIME                              PROP_TAG( PT_SYSTIME,   0x0015)
#define PR_IMPLICIT_CONVERSION_PROHIBITED           PROP_TAG( PT_BOOLEAN,   0x0016)
#define PR_IMPORTANCE                               PROP_TAG( PT_LONG,      0x0017)
#define PR_IPM_ID                                   PROP_TAG( PT_BINARY,    0x0018)
#define PR_LATEST_DELIVERY_TIME                     PROP_TAG( PT_SYSTIME,   0x0019)
#define PR_MESSAGE_CLASS                            PROP_TAG( PT_TSTRING,   0x001A)
#define PR_MESSAGE_CLASS_W                          PROP_TAG( PT_UNICODE,   0x001A)
#define PR_MESSAGE_CLASS_A                          PROP_TAG( PT_STRING8,   0x001A)
#define PR_MESSAGE_DELIVERY_ID                      PROP_TAG( PT_BINARY,    0x001B)





#define PR_MESSAGE_SECURITY_LABEL                   PROP_TAG( PT_BINARY,    0x001E)
#define PR_OBSOLETED_IPMS                           PROP_TAG( PT_BINARY,    0x001F)
#define PR_ORIGINALLY_INTENDED_RECIPIENT_NAME       PROP_TAG( PT_BINARY,    0x0020)
#define PR_ORIGINAL_EITS                            PROP_TAG( PT_BINARY,    0x0021)
#define PR_ORIGINATOR_CERTIFICATE                   PROP_TAG( PT_BINARY,    0x0022)
#define PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED     PROP_TAG( PT_BOOLEAN,   0x0023)
#define PR_ORIGINATOR_RETURN_ADDRESS                PROP_TAG( PT_BINARY,    0x0024)



#define PR_PARENT_KEY                               PROP_TAG( PT_BINARY,    0x0025)
#define PR_PRIORITY                                 PROP_TAG( PT_LONG,      0x0026)



#define PR_ORIGIN_CHECK                             PROP_TAG( PT_BINARY,    0x0027)
#define PR_PROOF_OF_SUBMISSION_REQUESTED            PROP_TAG( PT_BOOLEAN,   0x0028)
#define PR_READ_RECEIPT_REQUESTED                   PROP_TAG( PT_BOOLEAN,   0x0029)
#define PR_RECEIPT_TIME                             PROP_TAG( PT_SYSTIME,   0x002A)
#define PR_RECIPIENT_REASSIGNMENT_PROHIBITED        PROP_TAG( PT_BOOLEAN,   0x002B)
#define PR_REDIRECTION_HISTORY                      PROP_TAG( PT_BINARY,    0x002C)
#define PR_RELATED_IPMS                             PROP_TAG( PT_BINARY,    0x002D)

#define PR_LANGUAGES                                PROP_TAG( PT_TSTRING,   0x002F)
#define PR_LANGUAGES_W                              PROP_TAG( PT_UNICODE,   0x002F)
#define PR_LANGUAGES_A                              PROP_TAG( PT_STRING8,   0x002F)
#define PR_REPLY_TIME                               PROP_TAG( PT_SYSTIME,   0x0030)
#define PR_REPORT_TAG                               PROP_TAG( PT_BINARY,    0x0031)
#define PR_REPORT_TIME                              PROP_TAG( PT_SYSTIME,   0x0032)
#define PR_RETURNED_IPM                             PROP_TAG( PT_BOOLEAN,   0x0033)
#define PR_SECURITY                                 PROP_TAG( PT_LONG,      0x0034)
#define PR_INCOMPLETE_COPY                          PROP_TAG( PT_BOOLEAN,   0x0035)
#define PR_SENSITIVITY                              PROP_TAG( PT_LONG,      0x0036)
#define PR_SUBJECT                                  PROP_TAG( PT_TSTRING,   0x0037)
#define PR_SUBJECT_W                                PROP_TAG( PT_UNICODE,   0x0037)
#define PR_SUBJECT_A                                PROP_TAG( PT_STRING8,   0x0037)
#define PR_SUBJECT_IPM                              PROP_TAG( PT_BINARY,    0x0038)
#define PR_CLIENT_SUBMIT_TIME                       PROP_TAG( PT_SYSTIME,   0x0039)
#define PR_REPORT_NAME                              PROP_TAG( PT_TSTRING,   0x003A)
#define PR_REPORT_NAME_W                            PROP_TAG( PT_UNICODE,   0x003A)
#define PR_REPORT_NAME_A                            PROP_TAG( PT_STRING8,   0x003A)
#define PR_SENT_REPRESENTING_SEARCH_KEY             PROP_TAG( PT_BINARY,    0x003B)
#define PR_X400_CONTENT_TYPE                        PROP_TAG( PT_BINARY,    0x003C)
#define PR_NON_RECEIPT_REASON                       PROP_TAG( PT_LONG,      0x003E)
#define PR_RECEIVED_BY_ENTRYID                      PROP_TAG( PT_BINARY,    0x003F)
#define PR_RECEIVED_BY_NAME                         PROP_TAG( PT_TSTRING,   0x0040)
#define PR_RECEIVED_BY_NAME_W                       PROP_TAG( PT_UNICODE,   0x0040)
#define PR_RECEIVED_BY_NAME_A                       PROP_TAG( PT_STRING8,   0x0040)
#define PR_SENT_REPRESENTING_ENTRYID                PROP_TAG( PT_BINARY,    0x0041)
#define PR_SENT_REPRESENTING_NAME                   PROP_TAG( PT_TSTRING,   0x0042)
#define PR_SENT_REPRESENTING_NAME_W                 PROP_TAG( PT_UNICODE,   0x0042)
#define PR_SENT_REPRESENTING_NAME_A                 PROP_TAG( PT_STRING8,   0x0042)
#define PR_RCVD_REPRESENTING_ENTRYID                PROP_TAG( PT_BINARY,    0x0043)
#define PR_RCVD_REPRESENTING_NAME                   PROP_TAG( PT_TSTRING,   0x0044)
#define PR_RCVD_REPRESENTING_NAME_W                 PROP_TAG( PT_UNICODE,   0x0044)
#define PR_RCVD_REPRESENTING_NAME_A                 PROP_TAG( PT_STRING8,   0x0044)
#define PR_REPORT_ENTRYID                           PROP_TAG( PT_BINARY,    0x0045)
#define PR_READ_RECEIPT_ENTRYID                     PROP_TAG( PT_BINARY,    0x0046)
#define PR_MESSAGE_SUBMISSION_ID                    PROP_TAG( PT_BINARY,    0x0047)
#define PR_PROVIDER_SUBMIT_TIME                     PROP_TAG( PT_SYSTIME,   0x0048)
#define PR_ORIGINAL_SUBJECT                         PROP_TAG( PT_TSTRING,   0x0049)
#define PR_ORIGINAL_SUBJECT_W                       PROP_TAG( PT_UNICODE,   0x0049)
#define PR_ORIGINAL_SUBJECT_A                       PROP_TAG( PT_STRING8,   0x0049)
#define PR_DISC_VAL                                 PROP_TAG( PT_BOOLEAN,   0x004A)
#define PR_ORIG_MESSAGE_CLASS                       PROP_TAG( PT_TSTRING,   0x004B)
#define PR_ORIG_MESSAGE_CLASS_W                     PROP_TAG( PT_UNICODE,   0x004B)
#define PR_ORIG_MESSAGE_CLASS_A                     PROP_TAG( PT_STRING8,   0x004B)
#define PR_ORIGINAL_AUTHOR_ENTRYID                  PROP_TAG( PT_BINARY,    0x004C)
#define PR_ORIGINAL_AUTHOR_NAME                     PROP_TAG( PT_TSTRING,   0x004D)
#define PR_ORIGINAL_AUTHOR_NAME_W                   PROP_TAG( PT_UNICODE,   0x004D)
#define PR_ORIGINAL_AUTHOR_NAME_A                   PROP_TAG( PT_STRING8,   0x004D)
#define PR_ORIGINAL_SUBMIT_TIME                     PROP_TAG( PT_SYSTIME,   0x004E)
#define PR_REPLY_RECIPIENT_ENTRIES                  PROP_TAG( PT_BINARY,    0x004F)
#define PR_REPLY_RECIPIENT_NAMES                    PROP_TAG( PT_TSTRING,   0x0050)
#define PR_REPLY_RECIPIENT_NAMES_W                  PROP_TAG( PT_UNICODE,   0x0050)
#define PR_REPLY_RECIPIENT_NAMES_A                  PROP_TAG( PT_STRING8,   0x0050)

#define PR_RECEIVED_BY_SEARCH_KEY                   PROP_TAG( PT_BINARY,    0x0051)
#define PR_RCVD_REPRESENTING_SEARCH_KEY             PROP_TAG( PT_BINARY,    0x0052)
#define PR_READ_RECEIPT_SEARCH_KEY                  PROP_TAG( PT_BINARY,    0x0053)
#define PR_REPORT_SEARCH_KEY                        PROP_TAG( PT_BINARY,    0x0054)
#define PR_ORIGINAL_DELIVERY_TIME                   PROP_TAG( PT_SYSTIME,   0x0055)
#define PR_ORIGINAL_AUTHOR_SEARCH_KEY               PROP_TAG( PT_BINARY,    0x0056)

#define PR_MESSAGE_TO_ME                            PROP_TAG( PT_BOOLEAN,   0x0057)
#define PR_MESSAGE_CC_ME                            PROP_TAG( PT_BOOLEAN,   0x0058)
#define PR_MESSAGE_RECIP_ME                         PROP_TAG( PT_BOOLEAN,   0x0059)

#define PR_ORIGINAL_SENDER_NAME                     PROP_TAG( PT_TSTRING,   0x005A)
#define PR_ORIGINAL_SENDER_NAME_W                   PROP_TAG( PT_UNICODE,   0x005A)
#define PR_ORIGINAL_SENDER_NAME_A                   PROP_TAG( PT_STRING8,   0x005A)
#define PR_ORIGINAL_SENDER_ENTRYID                  PROP_TAG( PT_BINARY,    0x005B)
#define PR_ORIGINAL_SENDER_SEARCH_KEY               PROP_TAG( PT_BINARY,    0x005C)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME          PROP_TAG( PT_TSTRING,   0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME_W        PROP_TAG( PT_UNICODE,   0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME_A        PROP_TAG( PT_STRING8,   0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_ENTRYID       PROP_TAG( PT_BINARY,    0x005E)
#define PR_ORIGINAL_SENT_REPRESENTING_SEARCH_KEY    PROP_TAG( PT_BINARY,    0x005F)

#define PR_START_DATE                               PROP_TAG( PT_SYSTIME,   0x0060)
#define PR_END_DATE                                 PROP_TAG( PT_SYSTIME,   0x0061)
#define PR_OWNER_APPT_ID                            PROP_TAG( PT_LONG,      0x0062)
#define PR_RESPONSE_REQUESTED                       PROP_TAG( PT_BOOLEAN,   0x0063)

#define PR_SENT_REPRESENTING_ADDRTYPE               PROP_TAG( PT_TSTRING,   0x0064)
#define PR_SENT_REPRESENTING_ADDRTYPE_W             PROP_TAG( PT_UNICODE,   0x0064)
#define PR_SENT_REPRESENTING_ADDRTYPE_A             PROP_TAG( PT_STRING8,   0x0064)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS          PROP_TAG( PT_TSTRING,   0x0065)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS_W        PROP_TAG( PT_UNICODE,   0x0065)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS_A        PROP_TAG( PT_STRING8,   0x0065)

#define PR_ORIGINAL_SENDER_ADDRTYPE                 PROP_TAG( PT_TSTRING,   0x0066)
#define PR_ORIGINAL_SENDER_ADDRTYPE_W               PROP_TAG( PT_UNICODE,   0x0066)
#define PR_ORIGINAL_SENDER_ADDRTYPE_A               PROP_TAG( PT_STRING8,   0x0066)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS            PROP_TAG( PT_TSTRING,   0x0067)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS_W          PROP_TAG( PT_UNICODE,   0x0067)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS_A          PROP_TAG( PT_STRING8,   0x0067)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE      PROP_TAG( PT_TSTRING,   0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_W    PROP_TAG( PT_UNICODE,   0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_A    PROP_TAG( PT_STRING8,   0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS PROP_TAG( PT_TSTRING,   0x0069)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_W   PROP_TAG( PT_UNICODE,   0x0069)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_A   PROP_TAG( PT_STRING8,   0x0069)

#define PR_CONVERSATION_TOPIC                       PROP_TAG( PT_TSTRING,   0x0070)
#define PR_CONVERSATION_TOPIC_W                     PROP_TAG( PT_UNICODE,   0x0070)
#define PR_CONVERSATION_TOPIC_A                     PROP_TAG( PT_STRING8,   0x0070)
#define PR_CONVERSATION_INDEX                       PROP_TAG( PT_BINARY,    0x0071)


/*
 *  Message content properties
 */

#define PR_BODY                                     PROP_TAG( PT_TSTRING,   0x1000)
#define PR_BODY_W                                   PROP_TAG( PT_UNICODE,   0x1000)
#define PR_BODY_A                                   PROP_TAG( PT_STRING8,   0x1000)
#define PR_REPORT_TEXT                              PROP_TAG( PT_TSTRING,   0x1001)
#define PR_REPORT_TEXT_W                            PROP_TAG( PT_UNICODE,   0x1001)
#define PR_REPORT_TEXT_A                            PROP_TAG( PT_STRING8,   0x1001)
#define PR_ORIGINATOR_AND_DL_EXPANSION_HISTORY      PROP_TAG( PT_BINARY,    0x1002)
#define PR_REPORTING_DL_NAME                        PROP_TAG( PT_BINARY,    0x1003)
#define PR_REPORTING_MTA_CERTIFICATE                PROP_TAG( PT_BINARY,    0x1004)

/*  Removed PR_REPORT_ORIGIN_AUTHENTICATION_CHECK with DCR 3865, use PR_ORIGIN_CHECK */

#define PR_RTF_SYNC_BODY_CRC                        PROP_TAG( PT_LONG,      0x1006)
#define PR_RTF_SYNC_BODY_COUNT                      PROP_TAG( PT_LONG,      0x1007)
#define PR_RTF_SYNC_BODY_TAG                        PROP_TAG( PT_TSTRING,   0x1008)
#define PR_RTF_SYNC_BODY_TAG_W                      PROP_TAG( PT_UNICODE,   0x1008)
#define PR_RTF_SYNC_BODY_TAG_A                      PROP_TAG( PT_STRING8,   0x1008)
#define PR_RTF_COMPRESSED                           PROP_TAG( PT_BINARY,    0x1009)
#define PR_RTF_SYNC_PREFIX_COUNT                    PROP_TAG( PT_LONG,      0x1010)
#define PR_RTF_SYNC_TRAILING_COUNT                  PROP_TAG( PT_LONG,      0x1011)
#define PR_ORIGINALLY_INTENDED_RECIP_ENTRYID        PROP_TAG( PT_BINARY,    0x1012)
#define PR_PREPROCESS                               PROP_TAG( PT_BINARY,    0x1013)

/*
 *  Message recipient properties
 */

#define PR_CONTENT_INTEGRITY_CHECK                  PROP_TAG( PT_BINARY,    0x0C00)
#define PR_EXPLICIT_CONVERSION                      PROP_TAG( PT_LONG,      0x0C01)
#define PR_IPM_RETURN_REQUESTED                     PROP_TAG( PT_BOOLEAN,   0x0C02)
#define PR_MESSAGE_TOKEN                            PROP_TAG( PT_BINARY,    0x0C03)
#define PR_NDR_REASON_CODE                          PROP_TAG( PT_LONG,      0x0C04)
#define PR_NDR_DIAG_CODE                            PROP_TAG( PT_LONG,      0x0C05)
#define PR_NON_RECEIPT_NOTIFICATION_REQUESTED       PROP_TAG( PT_BOOLEAN,   0x0C06)

#define PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED PROP_TAG( PT_BOOLEAN,   0x0C08)
#define PR_ORIGINATOR_REQUESTED_ALTERNATE_RECIPIENT PROP_TAG( PT_BINARY,    0x0C09)
#define PR_PHYSICAL_DELIVERY_BUREAU_FAX_DELIVERY    PROP_TAG( PT_BOOLEAN,   0x0C0A)
#define PR_PHYSICAL_DELIVERY_MODE                   PROP_TAG( PT_LONG,      0x0C0B)
#define PR_PHYSICAL_DELIVERY_REPORT_REQUEST         PROP_TAG( PT_LONG,      0x0C0C)
#define PR_PHYSICAL_FORWARDING_ADDRESS              PROP_TAG( PT_BINARY,    0x0C0D)
#define PR_PHYSICAL_FORWARDING_ADDRESS_REQUESTED    PROP_TAG( PT_BOOLEAN,   0x0C0E)
#define PR_PHYSICAL_FORWARDING_PROHIBITED           PROP_TAG( PT_BOOLEAN,   0x0C0F)
#define PR_PHYSICAL_RENDITION_ATTRIBUTES            PROP_TAG( PT_BINARY,    0x0C10)
#define PR_PROOF_OF_DELIVERY                        PROP_TAG( PT_BINARY,    0x0C11)
#define PR_PROOF_OF_DELIVERY_REQUESTED              PROP_TAG( PT_BOOLEAN,   0x0C12)
#define PR_RECIPIENT_CERTIFICATE                    PROP_TAG( PT_BINARY,    0x0C13)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE              PROP_TAG( PT_TSTRING,   0x0C14)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE_W            PROP_TAG( PT_UNICODE,   0x0C14)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE_A            PROP_TAG( PT_STRING8,   0x0C14)
#define PR_RECIPIENT_TYPE                           PROP_TAG( PT_LONG,      0x0C15)
#define PR_REGISTERED_MAIL_TYPE                     PROP_TAG( PT_LONG,      0x0C16)
#define PR_REPLY_REQUESTED                          PROP_TAG( PT_BOOLEAN,   0x0C17)
#define PR_REQUESTED_DELIVERY_METHOD                PROP_TAG( PT_LONG,      0x0C18)
#define PR_SENDER_ENTRYID                           PROP_TAG( PT_BINARY,    0x0C19)
#define PR_SENDER_NAME                              PROP_TAG( PT_TSTRING,   0x0C1A)
#define PR_SENDER_NAME_W                            PROP_TAG( PT_UNICODE,   0x0C1A)
#define PR_SENDER_NAME_A                            PROP_TAG( PT_STRING8,   0x0C1A)
#define PR_SUPPLEMENTARY_INFO                       PROP_TAG( PT_TSTRING,   0x0C1B)
#define PR_SUPPLEMENTARY_INFO_W                     PROP_TAG( PT_UNICODE,   0x0C1B)
#define PR_SUPPLEMENTARY_INFO_A                     PROP_TAG( PT_STRING8,   0x0C1B)
#define PR_TYPE_OF_MTS_USER                         PROP_TAG( PT_LONG,      0x0C1C)
#define PR_SENDER_SEARCH_KEY                        PROP_TAG( PT_BINARY,    0x0C1D)
#define PR_SENDER_ADDRTYPE                          PROP_TAG( PT_TSTRING,   0x0C1E)
#define PR_SENDER_ADDRTYPE_W                        PROP_TAG( PT_UNICODE,   0x0C1E)
#define PR_SENDER_ADDRTYPE_A                        PROP_TAG( PT_STRING8,   0x0C1E)
#define PR_SENDER_EMAIL_ADDRESS                     PROP_TAG( PT_TSTRING,   0x0C1F)
#define PR_SENDER_EMAIL_ADDRESS_W                   PROP_TAG( PT_UNICODE,   0x0C1F)
#define PR_SENDER_EMAIL_ADDRESS_A                   PROP_TAG( PT_STRING8,   0x0C1F)

/*
 *  Message non-transmittable properties
 */

/*
 * The two tags, PR_MESSAGE_RECIPIENTS and PR_MESSAGE_ATTACHMENTS,
 * are to be used in the exclude list passed to
 * IMessage::CopyTo when the caller wants either the recipients or attachments
 * of the message to not get copied.  It is also used in the ProblemArray
 * return from IMessage::CopyTo when an error is encountered copying them
 */

#define PR_CURRENT_VERSION                          PROP_TAG( PT_I8,        0x0E00)
#define PR_DELETE_AFTER_SUBMIT                      PROP_TAG( PT_BOOLEAN,   0x0E01)
#define PR_DISPLAY_BCC                              PROP_TAG( PT_TSTRING,   0x0E02)
#define PR_DISPLAY_BCC_W                            PROP_TAG( PT_UNICODE,   0x0E02)
#define PR_DISPLAY_BCC_A                            PROP_TAG( PT_STRING8,   0x0E02)
#define PR_DISPLAY_CC                               PROP_TAG( PT_TSTRING,   0x0E03)
#define PR_DISPLAY_CC_W                             PROP_TAG( PT_UNICODE,   0x0E03)
#define PR_DISPLAY_CC_A                             PROP_TAG( PT_STRING8,   0x0E03)
#define PR_DISPLAY_TO                               PROP_TAG( PT_TSTRING,   0x0E04)
#define PR_DISPLAY_TO_W                             PROP_TAG( PT_UNICODE,   0x0E04)
#define PR_DISPLAY_TO_A                             PROP_TAG( PT_STRING8,   0x0E04)
#define PR_PARENT_DISPLAY                           PROP_TAG( PT_TSTRING,   0x0E05)
#define PR_PARENT_DISPLAY_W                         PROP_TAG( PT_UNICODE,   0x0E05)
#define PR_PARENT_DISPLAY_A                         PROP_TAG( PT_STRING8,   0x0E05)
#define PR_MESSAGE_DELIVERY_TIME                    PROP_TAG( PT_SYSTIME,   0x0E06)
#define PR_MESSAGE_FLAGS                            PROP_TAG( PT_LONG,      0x0E07)
#define PR_MESSAGE_SIZE                             PROP_TAG( PT_LONG,      0x0E08)
#define PR_PARENT_ENTRYID                           PROP_TAG( PT_BINARY,    0x0E09)
#define PR_SENTMAIL_ENTRYID                         PROP_TAG( PT_BINARY,    0x0E0A)
#define PR_CORRELATE                                PROP_TAG( PT_BOOLEAN,   0x0E0C)
#define PR_CORRELATE_MTSID                          PROP_TAG( PT_BINARY,    0x0E0D)
#define PR_DISCRETE_VALUES                          PROP_TAG( PT_BOOLEAN,   0x0E0E)
#define PR_RESPONSIBILITY                           PROP_TAG( PT_BOOLEAN,   0x0E0F)
#define PR_SPOOLER_STATUS                           PROP_TAG( PT_LONG,      0x0E10)
#define PR_TRANSPORT_STATUS                         PROP_TAG( PT_LONG,      0x0E11)
#define PR_MESSAGE_RECIPIENTS                       PROP_TAG( PT_OBJECT,    0x0E12)
#define PR_MESSAGE_ATTACHMENTS                      PROP_TAG( PT_OBJECT,    0x0E13)
#define PR_SUBMIT_FLAGS                             PROP_TAG( PT_LONG,      0x0E14)
#define PR_RECIPIENT_STATUS                         PROP_TAG( PT_LONG,      0x0E15)
#define PR_TRANSPORT_KEY                            PROP_TAG( PT_LONG,      0x0E16)
#define PR_MSG_STATUS                               PROP_TAG( PT_LONG,      0x0E17)
#define PR_MESSAGE_DOWNLOAD_TIME                    PROP_TAG( PT_LONG,      0x0E18)
#define PR_CREATION_VERSION                         PROP_TAG( PT_I8,        0x0E19)
#define PR_MODIFY_VERSION                           PROP_TAG( PT_I8,        0x0E1A)
#define PR_HASATTACH                                PROP_TAG( PT_BOOLEAN,   0x0E1B)
#define PR_BODY_CRC                                 PROP_TAG( PT_LONG,      0x0E1C)
#define PR_NORMALIZED_SUBJECT                       PROP_TAG( PT_TSTRING,   0x0E1D)
#define PR_NORMALIZED_SUBJECT_W                     PROP_TAG( PT_UNICODE,   0x0E1D)
#define PR_NORMALIZED_SUBJECT_A                     PROP_TAG( PT_STRING8,   0x0E1D)
#define PR_RTF_IN_SYNC                              PROP_TAG( PT_BOOLEAN,   0x0E1F)
#define PR_ATTACH_SIZE                              PROP_TAG( PT_LONG,      0x0E20)
#define PR_ATTACH_NUM                               PROP_TAG( PT_LONG,      0x0E21)
#define PR_ORIGINAL_DISPLAY_BCC                     PROP_TAG( PT_TSTRING,   0x0E22)
#define PR_ORIGINAL_DISPLAY_BCC_W                   PROP_TAG( PT_UNICODE,   0x0E22)
#define PR_ORIGINAL_DISPLAY_BCC_A                   PROP_TAG( PT_STRING8,   0x0E22)
#define PR_ORIGINAL_DISPLAY_CC                      PROP_TAG( PT_TSTRING,   0x0E23)
#define PR_ORIGINAL_DISPLAY_CC_W                    PROP_TAG( PT_UNICODE,   0x0E23)
#define PR_ORIGINAL_DISPLAY_CC_A                    PROP_TAG( PT_STRING8,   0x0E23)
#define PR_ORIGINAL_DISPLAY_TO                      PROP_TAG( PT_TSTRING,   0x0E24)
#define PR_ORIGINAL_DISPLAY_TO_W                    PROP_TAG( PT_UNICODE,   0x0E24)
#define PR_ORIGINAL_DISPLAY_TO_A                    PROP_TAG( PT_STRING8,   0x0E24)
#define PR_ORIGINATING_MTA_CERTIFICATE              PROP_TAG( PT_BINARY,    0x0E25)
#define PR_PROOF_OF_SUBMISSION                      PROP_TAG( PT_BINARY,    0x0E26)


/*
 * The range of non-message and non-recipient property IDs (0x3000