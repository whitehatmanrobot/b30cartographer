NextFilter) {
                count++;
                pTemp2 = pTemp2->pNextFilter;
            }
            ppTemp2 = &pTemp2->pNextFilter;
        }
        else {
            switch (IsConstFilterType(*ppTemp2)) {
            // Check for a true or false filter, which can be optimized
            case FI_CHOICE_TRUE:
                // A true element can simply be ignored.  Free the filter we got
                // back from the recursive call.  Note we don't increment the count.
                THFreeEx(pTHS, *ppTemp2);
                *ppTemp2 = NULL;
                break;

            case FI_CHOICE_FALSE:
                // A false element can be returned in place of the AND

                // First, free the linked list of filter elements already hanging
                // off the AND filter (if there is such a list).
                dbFreeFilter(pDB, pOutFil->FilterTypes.And.pFirstFilter);

                // Now, turn the AND filter into a FALSE item filter.
                pOutFil->choice = FILTER_CHOICE_ITEM;
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;

                *ppOutFil = pOutFil;
                // OK, return
                return ERROR_SUCCESS;
                break;

            case FI_CHOICE_UNDEFINED:
                // an undefined element, cannot be ignored, but we are interested
                // in knowing how many undefines we have so as to take appropriate action
                undefined++;
                // fall through
            default:
                // Normal case.  Inc the count, advance the pointer in the output
                // filter we are constructing.
                ppTemp2 = &(*ppTemp2)->pNextFilter;
                count++;
                break;
            }
        }
        pTemp = pTemp->pNextFilter;
    }

    if(count == 0) {
        // We must have trimmed away a bunch of TRUEs. Return a TRUE.
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_TRUE;
        *ppOutFil = pOutFil;
        return ERROR_SUCCESS;
    }

    if(count == 1) {
        // Only one object.  Cut the AND out completely
        *ppOutFil = pOutFil->FilterTypes.And.pFirstFilter;
        THFreeEx(pTHS, pOutFil);
        return ERROR_SUCCESS;
    }

    if(undefined > 0 && iLevel == 0) {
        // if this AND term contains an undefined term then we know that the
        // only possible results for this term for each object are undefined
        // and false.  therefore, if this AND term is the topmost term then we
        // immediately know that no object will satisfy the filter so we can
        // convert it into a single undefined term.  however, if the AND term
        // is contained by another term then it is still possible for the
        // entire filter to be satisfied for objects where this AND term
        // evaluates to false so we cannot do this optimization
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
        *ppOutFil = pOutFil;
        return ERROR_SUCCESS;
    }

    // Returning a normal AND filter
    pOutFil->FilterTypes.And.count = count;
    *ppOutFil = pOutFil;


    // We check to see if we have an AND - OR case.
    // If so, we convert the AND - OR to an OR with multiple ANDs
    //
    //
    //          AND                                OR
    //         /  \                               /  \
    //        /    \         ======>             /    \
    //       A     OR                         AND      AND
    //             /\                        / \       / \
    //            /  \                      /   \     /   \
    //           B    C                    A     B   A     C
    //
    //
    //  The above transformation is done only if:
    //  a) A is optimizable, or
    //  b) B AND C are optimizable.
    //
    if (gfUseANDORFilterOptimizations) {
        FILTER **ppTemp;             // last memory location of pTemp
        FILTER *pTempFirstFilter;    // first Filter under AND
        FILTER *pTempOr;             // the first OR filter under AND
        FILTER *pTempNextFilter;     // the next filter from found OR
        FILTER *pTempOr1, *pTempOr2; // break OR apart so as to clone
        FILTER *pTempNewAnd;         // the newly created AND filter
        FILTER *pTempCount;          // used to count filters
        USHORT  count2;

        BOOL    bANDpartOptimizable = FALSE;

        // pTemp walks along the elements of the filter passed out.
        pTempFirstFilter = pTemp = pOutFil->FilterTypes.And.pFirstFilter;

        // ppTemp keeps the last memory pos of pTemp
        ppTemp = &pOutFil->FilterTypes.And.pFirstFilter;

        bANDpartOptimizable = dbCheckOptimizableOneItem(pDB, pTempFirstFilter);

        while (pTemp) {

            if (pTemp->choice == FILTER_CHOICE_OR) {

                DPRINT1 (1, "Found AND-OR case. Breaking filter apart: 0x%x\n", pOutFil);
                pTempOr = pTemp;

                // check to see if all parts of the OR filter are optimizable,
                // or at least one of the rest of the AND parts of the AND filter
                // since we don't want to end up with a worst filter

                if (!bANDpartOptimizable ||
                    !dbCheckOptimizableAllItems (pDB, pTempOr->FilterTypes.Or.pFirstFilter) ) {

                    DPRINT1 (1, "found AND-OR case, but one part is not optimizable (AND=%d). skipping.\n", bANDpartOptimizable);

                    break;
                }

                // make previous filter point to next filter
                pTempNextFilter = pTempOr->pNextFilter;
                *ppTemp = pTempNextFilter;

                // make Or filter standalone
                pTempOr->pNextFilter = NULL;

                // get the start of the AND filter, since it might have been rearranged
                pTempFirstFilter = pOutFil->FilterTypes.And.pFirstFilter;

                // now we have two filters that we want to rearrange
                // the OR filter: pTempOr
                // the rest of the filter: pTempFirstFilter

                // we convert the starting AND filter to an OR
                pOutFil->choice = FILTER_CHOICE_OR;
                pOutFil->FilterTypes.And.pFirstFilter = NULL;
                pOutFil->FilterTypes.Or.pFirstFilter = NULL;

                // for each filter in the OR, we concatenate one of the
                // items in OR with all the items in pTempFirstFilter under
                // a new AND filter and we add this AND filter
                // under the OR filter
                //
                pTempOr1 = pTempOr->FilterTypes.Or.pFirstFilter;
                for (count =0; count < pTempOr->FilterTypes.Or.count; count++) {
                    pTempNewAnd = THAllocEx(pTHS, sizeof(FILTER));
                    pTempNewAnd->choice = FILTER_CHOICE_AND;

                    // break link list
                    pTempOr2 = pTempOr1->pNextFilter;
                    pTempOr1->pNextFilter = NULL;

                    if (err = dbConcatenateFilters (
                                     pDB,
                                     pTempFirstFilter,
                                     pTempOr1,
                                     &pTempNewAnd->FilterTypes.And.pFirstFilter)) {
                        dbFreeFilter(pDB, pOutFil);
                        dbFreeFilter(pDB, pTempFirstFilter);
                        THFreeEx(pTHS, pTempNewAnd);
                        *ppOutFil = NULL;
                        return err;
                    }

                    // add AND filter to OR
                    pTempNewAnd->pNextFilter = pOutFil->FilterTypes.Or.pFirstFilter;
                    pOutFil->FilterTypes.Or.pFirstFilter = pTempNewAnd;

                    // count filters under newly created AND
                    count2 = 0;
                    pTempCount = pTempNewAnd->FilterTypes.And.pFirstFilter;
                    while (pTempCount) {
                        count2++;
                        pTempCount = pTempCount->pNextFilter;
                    }
                    pTempNewAnd->FilterTypes.And.count = count2;

                    DPRINT1 (1, "AND sub-part: 0x%x\n", pTempNewAnd);

                    // restore link list
                    pTempOr1->pNextFilter = pTempOr2;
                    pTempOr1 = pTempOr2;
                }
                pOutFil->FilterTypes.Or.count = count;

                DPRINT1 (1, "Final part: 0x%x\n", pOutFil);

                dbFreeFilter (pDB, pTempOr->pNextFilter);
                dbFreeFilter (pDB, pTempFirstFilter);

                // we can't do the same optimization again. so we exit.
                // we let the caller detect that the filter type changed,
                // so as to call again
                break;
            }

            ppTemp = &pTemp->pNextFilter;
            pTemp = pTemp->pNextFilter;
        }
    }

    return ERROR_SUCCESS;
}

#define SET_ERR_ATTR_TYP(x) if(pErrAttrTyp) {*pErrAttrTyp = (x);}

DWORD
dbFlattenItemFilter (
        DBPOS *pDB,
        FILTER *pFil,
        size_t iLevel,
        FILTER **ppOutFil,
        ATTRTYP *pErrAttrTyp
        )
{
    THSTATE       *pTHS=pDB->pTHS;
    ATTCACHE      *pAC;
    USHORT        count;
    ANYSTRINGLIST *pAS, *pNewAS;
    PFILTER       pOutFil;
    SUBSTRING     *pIn;
    SUBSTRING     *pOut;

    ULONG         objCls;
    CLASSCACHE    *pCC;
    ATTRVAL       attrVal;

    Assert(VALID_DBPOS(pDB));

    // Assume failure.
    *ppOutFil = NULL;

    // These are already flat.  copy to THAlloced Memory
    pOutFil = THAllocEx(pTHS, sizeof(FILTER));
    pOutFil->choice = pFil->choice;
    pOutFil->FilterTypes.Item.choice = pFil->FilterTypes.Item.choice;

    switch(pFil->FilterTypes.Item.choice) {
    case FI_CHOICE_SUBSTRING:
        // Readability hack.
        pIn = pFil->FilterTypes.Item.FilTypes.pSubstring;

        if(pIn->type == ATT_ANR) {
            *ppOutFil = pOutFil;
            // NTRAID#NTRAID-569714-2002/03/07-andygo:  ANR filter construction has no error checking
            // REVIEW:  there is no error check on dbMakeANRFilter (it needs to return an error)
            dbMakeANRFilter(pDB, pFil, ppOutFil);
            return ERROR_SUCCESS;
        }

        if(pIn->type == ATT_CREATE_TIME_STAMP) {
            pIn->type = ATT_WHEN_CREATED;
        }
        else if (pIn->type == ATT_MODIFY_TIME_STAMP) {
            pIn->type = ATT_WHEN_CHANGED;
        }

        if (!(pAC = SCGetAttById(pTHS, pIn->type))) {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, pIn->type);
        }

        // we don't support constructed attributes in filters.
        if (pAC->bIsConstructed) {
            SET_ERR_ATTR_TYP(pAC->id);
            dbFreeFilter(pDB, pOutFil);
            return ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS;
        }

        // Make sure this is a valid operation on this syntax.
        if(!FLegalOperator(pAC->syntax, pFil->FilterTypes.Item.choice)) {
            // Nope, not legal.  Make a UNDEFINED filter.
            pOutFil->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
            *ppOutFil = pOutFil;
            return ERROR_SUCCESS;
        }

        pOut = THAllocEx(pTHS, sizeof(SUBSTRING));
        pOutFil->FilterTypes.Item.FilTypes.pSubstring = pOut;

        pOut->type = pIn->type;
        pOut->initialProvided = pIn->initialProvided;
        pOut->finalProvided = pIn->finalProvided;

        // convert initial and final substrings
        if ((pIn->initialProvided &&
             MakeInternalValue(pDB, pAC->syntax,
                               &pIn->InitialVal,
                               &pOut->InitialVal))  ||
            (pIn->finalProvided &&
             MakeInternalValue(pDB, pAC->syntax,
                               &pIn->FinalVal,
                               &pOut->FinalVal))) {
            // Failed to translate to internal.  Turn this into a FALSE, since
            // that means that we will never be able to find something with the
            // specified values.
            THFreeEx(pTHS, pOut->InitialVal.pVal);
            THFreeEx(pTHS, pOut);
            pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
            *ppOutFil = pOutFil;
            return ERROR_SUCCESS;
        }

        if(count = pIn->AnyVal.count) {
            // There are medial values.
            pOut->AnyVal.count = count;

            // Do the first value, since it's special.
            if (MakeInternalValue(pDB, pAC->syntax,
                                  &pIn->AnyVal.FirstAnyVal.AnyVal,
                                  &pOut->AnyVal.FirstAnyVal.AnyVal)) {
                // Failed to translate to internal.  Turn this into a FALSE
                THFreeEx(pTHS, pOut->InitialVal.pVal);
                THFreeEx(pTHS, pOut->FinalVal.pVal);
                THFreeEx(pTHS, pOut);
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                *ppOutFil = pOutFil;
                return ERROR_SUCCESS;
            }
            // Dealt with the first one.
            count--;
            pOut->AnyVal.FirstAnyVal.pNextAnyVal = NULL;

            // Any more?
            if(count) {
                // Allocate some medial value holders.  Note that we only do
                // this if there are more than one medial values, since a
                // SUBSTRING has room in it for the first medial value.
                pOut->AnyVal.FirstAnyVal.pNextAnyVal =
                    THAllocEx(pTHS, count * sizeof(ANYSTRINGLIST));
                // Note we depend on zero filled memory allocatedy by THAlloc.

                pAS = pIn->AnyVal.FirstAnyVal.pNextAnyVal;
                pNewAS = pOut->AnyVal.FirstAnyVal.pNextAnyVal;
                for(;count;count--) {

                    if (MakeInternalValue(pDB, pAC->syntax,
                                          &pAS->AnyVal,
                                          &pNewAS->AnyVal)) {
                        // Free up any values.
                        for(pAS =  &pOut->AnyVal.FirstAnyVal;
                            pAS;
                            pAS = pAS->pNextAnyVal) {
                            THFreeEx(pTHS, pAS->AnyVal.pVal);
                        }
                        // Now, free the ANYSTRINGs we allocated
                        THFreeEx(pTHS, pOut->AnyVal.FirstAnyVal.pNextAnyVal);

                        // Now, free the substring filter structure
                        THFreeEx(pTHS, pOut->InitialVal.pVal);
                        THFreeEx(pTHS, pOut->FinalVal.pVal);
                        THFreeEx(pTHS, pOut);

                        // Finally, turn the filter into a FALSE;
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;

                        *ppOutFil = pOutFil;
                        return ERROR_SUCCESS;
                    }

                    pAS = pAS->pNextAnyVal;
                    if(count > 1) {
                        pNewAS->pNextAnyVal = &pNewAS[1];
                        pNewAS = pNewAS->pNextAnyVal;
                    }
                    else {
                        // NULL terminate the linked list
                        pNewAS->pNextAnyVal = NULL;
                    }
                }
            }
        }
        else {
            pOut->AnyVal.count = 0;
            pOut->AnyVal.FirstAnyVal.pNextAnyVal = NULL;
        }

        break;

    case FI_CHOICE_PRESENT:

        if(pFil->FilterTypes.Item.FilTypes.present == ATT_CREATE_TIME_STAMP) {
            pFil->FilterTypes.Item.FilTypes.present = ATT_WHEN_CREATED;
        }
        else if (pFil->FilterTypes.Item.FilTypes.present == ATT_MODIFY_TIME_STAMP) {
            pFil->FilterTypes.Item.FilTypes.present = ATT_WHEN_CHANGED;
        }

        if(dbFIsAlwaysPresent(pFil->FilterTypes.Item.FilTypes.present)) {
            // We believe that this attribute is always present.  So, turn this
            // into a TRUE filter
            pOutFil->FilterTypes.Item.choice = FI_CHOICE_TRUE;
        }
        else {
            if(pFil->FilterTypes.Item.FilTypes.present == ATT_ANR) {
                // Present on ANR?  Huh?  That's always false.
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
            }
            else {
                pOutFil->FilterTypes.Item.FilTypes.present =
                    pFil->FilterTypes.Item.FilTypes.present;
            }
        }

        // the only constructed attr we we accept presence on is ANR
        if (pFil->FilterTypes.Item.FilTypes.present != ATT_ANR) {
            if (!(pAC = SCGetAttById(pTHS, pFil->FilterTypes.Item.FilTypes.present))) {
                DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, pFil->FilterTypes.Item.FilTypes.present);
            }

            // we don't support constructed attributes in filters.
            if (pAC->bIsConstructed) {
                SET_ERR_ATTR_TYP(pAC->id);
                dbFreeFilter(pDB, pOutFil);
                return ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS;
            }
        }
        break;

    case FI_CHOICE_TRUE:
    case FI_CHOICE_FALSE:
    case FI_CHOICE_UNDEFINED:
        // These don't require conversion
        break;

    default:
        // all others are AVAs

        if(pFil->FilterTypes.Item.FilTypes.ava.type == ATT_ANR) {
            *ppOutFil = pOutFil;
            // NTRAID#NTRAID-569714-2002/03/07-andygo:  ANR filter construction has no error checking
            // REVIEW:  there is no error check on dbMakeANRFilter (it needs to return an error)
            dbMakeANRFilter(pDB, pFil, ppOutFil);
            return ERROR_SUCCESS;
        }

        if(pFil->FilterTypes.Item.FilTypes.ava.type == ATT_CREATE_TIME_STAMP) {
            pFil->FilterTypes.Item.FilTypes.ava.type = ATT_WHEN_CREATED;
        }
        else if (pFil->FilterTypes.Item.FilTypes.ava.type == ATT_MODIFY_TIME_STAMP) {
            pFil->FilterTypes.Item.FilTypes.ava.type = ATT_WHEN_CHANGED;
        }

        // Once upon  time, we turned all filters of (objectClass=FOO) into
        // (objectCategory = BAR).  For a variety of reasons (i.e. incorrect
        // search results, weird results when you have different READ privileges
        // on objectClass and objectCategory, cases where exact objectClass is
        // necessary, so is done on the client, and deleted objects where
        // objectCategory is removed)  we are no longer doing this.  The code
        // that did this was right here.

        if (!(pAC = SCGetAttById(pTHS,
                                 pFil->FilterTypes.Item.FilTypes.ava.type))) {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA,
                      pFil->FilterTypes.Item.FilTypes.ava.type);
        }

        // we don't support constructed attributes in filters.
        if (pAC->bIsConstructed) {

// NOTICE-2002/03/06-andygo:  unreviewed code
// REVIEW:  dead code not reviewed for security
#if 0 // do not allow filters containing EntryTTL

// Originally added for TAPI, this partial filter capability is no longer
// needed. The test group is concerned that the partial filter capability
// on this one constructed attribute, EntryTTL, will cause more problems
// than it solves for users. I have commented it out instead of removing
// the code because it is a useful starting point if this type of
// functionality is needed again.

            // unless it is an EntryTTL, so we convert it
            if (pAC->id == ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId) {

                ATTRVAL newValue;
                LONG ttl=0;
                DSTIME newTime=0, *pNewTime;

                newValue.pVal=NULL;
                newValue.valLen=0;

                // Make sure this is a valid operation on this syntax.
                if(!FLegalOperator(pAC->syntax, pFil->FilterTypes.Item.choice)) {
                    // Nope, not legal.  Make a UNDEFINED filter.
                    pOutFil->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
                    *ppOutFil = pOutFil;
                    return ERROR_SUCCESS;
                }

                pOutFil->FilterTypes.Item.FilTypes.ava.type = ATT_MS_DS_ENTRY_TIME_TO_DIE;

                if(MakeInternalValue(
                         pDB,
                         pAC->syntax,
                         &pFil->FilterTypes.Item.FilTypes.ava.Value,
                         &newValue)) {

                    // Failed to convert the right hand side.  Turn this into an
                    // appropriate filter.
                    switch(pFil->FilterTypes.Item.choice) {
                    case FI_CHOICE_EQUALITY:
                        // They wanted equal, but we sure don't have this in the
                        // DS. Turn it into a false filter
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                        break;
                    case FI_CHOICE_NOT_EQUAL:
                        // They wanted not equal, and we sure don't have this in the
                        // DS. Turn it into a TRUE filter
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_PRESENT;
                        pOutFil->FilterTypes.Item.FilTypes.present = ATT_MS_DS_ENTRY_TIME_TO_DIE;
                        break;
                    default:
                        // Don't know what they want.  Well, we have to do
                        // something, so set it to UNDEFINED.
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
                        break;
                    }

                    *ppOutFil = pOutFil;
                    return ERROR_SUCCESS;
                }

                ttl = *(LONG *)(newValue.pVal);

                // entryTTL is a constructed attribute. It is constructed
                // by subtracting NOW from msDS-Entry-Time-To-Die and mapping
                // the answer to 0 if it is <0. Adjust Item.choice to
                // compensate for this construction.
                if (ttl==0) {
                    switch(pFil->FilterTypes.Item.choice) {
                    case FI_CHOICE_NOT_EQUAL:
                        // search for objects that haven't expired (>= 1)
                        ttl = 1;
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
                        break;
                    case FI_CHOICE_GREATER_OR_EQ:
                        // Find all objects
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_PRESENT;
                        pOutFil->FilterTypes.Item.FilTypes.present = ATT_MS_DS_ENTRY_TIME_TO_DIE;
                        break;
                    case FI_CHOICE_LESS_OR_EQ:
                        // This is okay as is
                        break;
                    case FI_CHOICE_EQUALITY:
                        // search for expired objects (<= 0)
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_LESS_OR_EQ;
                        break;
                    default:
                        // Don't know what they want.  Well, we have to do
                        // something, so set it to FALSE.
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                        *ppOutFil = pOutFil;
                        return ERROR_SUCCESS;
                    }
                } else if (ttl<0) {
                    // entryttl cannot be negative (see rangeLower)
                    switch(pFil->FilterTypes.Item.choice) {
                    case FI_CHOICE_NOT_EQUAL:
                    case FI_CHOICE_GREATER_OR_EQ:
                        // Find all objects
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_PRESENT;
                        pOutFil->FilterTypes.Item.FilTypes.present = ATT_MS_DS_ENTRY_TIME_TO_DIE;
                        break;
                    default:
                        // Find no objects
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                        *ppOutFil = pOutFil;
                        return ERROR_SUCCESS;
                    }
                }

                newTime = DBTime() + ttl;
                THFreeEx (pTHS, newValue.pVal);

                pOutFil->FilterTypes.Item.FilTypes.ava.Value.pVal =
                            THAllocEx (pTHS, sizeof (DSTIME));
                pOutFil->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof (DSTIME);

                pNewTime = (DSTIME *)pOutFil->FilterTypes.Item.FilTypes.ava.Value.pVal;
                *pNewTime = newTime;

                *ppOutFil = pOutFil;
                return ERROR_SUCCESS;
            }
            else {
                SET_ERR_ATTR_TYP(pAC->id);
                return ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS;
            }
#else 0 // do not allow filters containing EntryTTL
            SET_ERR_ATTR_TYP(pAC->id);
            dbFreeFilter(pDB, pOutFil);
            return ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS;
#endif 0 // do not allow filters containing EntryTTL
        }

        // Make sure this is a valid operation on this syntax.
        if(!FLegalOperator(pAC->syntax, pFil->FilterTypes.Item.choice)) {
            // Nope, not legal.  Make a UNDEFINED filter.
            pOutFil->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
            *ppOutFil = pOutFil;
            return ERROR_SUCCESS;
        }

        pOutFil->FilterTypes.Item.FilTypes.ava.type =
            pFil->FilterTypes.Item.FilTypes.ava.type;
        if(MakeInternalValue(
                pDB,
                pAC->syntax,
                &pFil->FilterTypes.Item.FilTypes.ava.Value,
                &(pOutFil->FilterTypes.Item.FilTypes.ava.Value))) {

            // Failed to convert the right hand side.  Turn this into an
            // appropriate filter.
            switch(pFil->FilterTypes.Item.choice) {
            case FI_CHOICE_EQUALITY:
                // They wanted equal, but we sure don't have this in the
                // DS. Turn it into a false filter
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                break;
            case FI_CHOICE_NOT_EQUAL:
                // They wanted not equal, and we sure don't have this in the
                // DS. Turn it into a TRUE filter
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_TRUE;
                break;
            default:
                // Don't know what they want.  Well, we have to do
                // something, so set it to UNDEFINED.
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
                break;
            }
            break;
        }
    }

    *ppOutFil = pOutFil;

    return ERROR_SUCCESS;
}

DWORD
dbFlattenNotFilter (
        DBPOS *pDB,
        FILTER *pFil,
        size_t iLevel,
        FILTER **ppOutFil,
        ATTRTYP *pErrAttrTyp
        )
{
    THSTATE *pTHS=pDB->pTHS;
    PFILTER  pOutFil = NULL;
    DWORD err;

    Assert(VALID_DBPOS(pDB));

    // Presume failure.
    *ppOutFil = NULL;

    pOutFil = THAllocEx(pTHS, sizeof(FILTER));

    pOutFil->choice = pFil->choice;

    // First, recursively flatten the element of the NOT
    if ((err = dbFlattenFilter(pDB,
                    pFil->FilterTypes.pNot,
                    iLevel + 1,
                    &pOutFil->FilterTypes.pNot,
                    pErrAttrTyp)) != ERROR_SUCCESS) {
        dbFreeFilter(pDB, pOutFil);
        return err;
    }

    // Now, if it ended up being NOT of a TRUE or FALSE, flatten again
    // Note that we can't flatten things like !(name>"foo") to be (name<="foo").
    // That really flattens to (|(name<="foo")(name ! Exists.)),
    // i.e. !(name>"foo") also needs to get things that have no value for name
    // at all.

    switch(IsConstFilterType(pOutFil->FilterTypes.pNot)) {
    case FI_CHOICE_TRUE:
        // Yep, we should flatten
        dbFreeFilter(pDB, pOutFil->FilterTypes.pNot);
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
        break;
    case FI_CHOICE_FALSE:
        dbFreeFilter(pDB, pOutFil->FilterTypes.pNot);
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_TRUE;
        break;
    case FI_CHOICE_UNDEFINED:
        dbFreeFilter(pDB, pOutFil->FilterTypes.pNot);
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
        break;
    default:
        // No, nothing more to do.
        break;
    }

    // return a NOT filter
    *ppOutFil = pOutFil;
    return ERROR_SUCCESS;
}


// NTRAID#NTRAID-560446-2002/02/28-andygo:  SECURITY:  a really wide AND/OR term in a filter can be used to consume all resources on a DC
// REVIEW:  we need to check for the search time limit in dbFlattenFilter and/or its children so
// REVIEW:  that a huge filter cannot consume an LDAP thread forever during the optimization phase

DWORD
dbFlattenFilter (
        DBPOS *pDB,
        FILTER *pFil,
        size_t iLevel,
        FILTER **ppOutFil,
        ATTRTYP *pErrAttrTyp
        )
{
    DWORD err;
    Assert(VALID_DBPOS(pDB));

    if(!pFil) {
        // This is as flat as possible
        return ERROR_SUCCESS;
    }

    switch(pFil->choice) {
    case FILTER_CHOICE_OR:
        return dbFlattenOrFilter(pDB, pFil, iLevel, ppOutFil, pErrAttrTyp);
        break;

    case FILTER_CHOICE_AND:
        err = dbFlattenAndFilter(pDB, pFil, iLevel, ppOutFil, pErrAttrTyp);
        // PERFHINT: IF this Filter was converted to an OR
        // it might be a good idea flatten the filter again
        // since it might help lowering the number of nesting
        return err;
        break;

    case FILTER_CHOICE_NOT:
        return dbFlattenNotFilter(pDB, pFil, iLevel, ppOutFil, pErrAttrTyp);
        break;

    case FILTER_CHOICE_ITEM:
        return dbFlattenItemFilter(pDB, pFil, iLevel, ppOutFil, pErrAttrTyp);
        break;
    default:
        // what is this?  return an error.
        *ppOutFil = pFil;
        return ERROR_INVALID_DATA;
        break;
    }

    return ERROR_SUCCESS;
}


DWORD
DBMakeFilterInternal (
        DBPOS FAR *pDB,
        FILTER *pFil,
        PFILTER *pOutFil,
        ATTRTYP *pErrAttrTyp
        )
/*++
Routine Description:

    Calls routines to create an internal version of the passed in filter.
    Passes the internal version back to the caller.

Arguments:

    pDB - DBPOS to use.

    pFil - Filter to internalize

    pOutFil - Place to holde Filter to return.

    pErrAttrTyp - If there is an attribute related error the attribute type
                  will be save here.  May be set to NULL if the caller isn't
                  interested in this info.

Return Value:

    ERROR_SUCCESS - if the filter is valid
    errorCode - otherwise
              - ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS: Filter uses constructed attribute
              - ERROR_DS_INAPPROPRIATE_MATCHING: There was an incompatibility between an
                                                 attribute and a matching rule used in the
                                                 filter.


    We always turn the filter into the best internal version we can, or
    we throw an exception during memory allocation.

--*/
{
    DPRINT(2, "DBMakeFilterInternal entered\n");

    Assert(VALID_DBPOS(pDB));

    if(pFil == NULL){
        DPRINT(2,"No filter..return\n");
        return ERROR_SUCCESS;
    }

    return dbFlattenFilter(pDB, pFil, 0, pOutFil, pErrAttrTyp);
}/* DBMakeFilterInternal*/



DWORD dbCloneItemFilter(
    DBPOS *pDB,
    FILTER *pFil,
    FILTER **ppOutFil)
{
    THSTATE       *pTHS=pDB->pTHS;
    ATTCACHE      *pAC;
    USHORT        count;
    ANYSTRINGLIST *pAS, *pNewAS;
    PFILTER       pOutFil;
    SUBSTRING     *pIn;
    SUBSTRING     *pOut;

    ULONG         objCls;
    CLASSCACHE    *pCC;
    ATTRVAL       attrVal, *pAttrValIn;
    AVA           *pAVA, *pAVAdst;

    DPRINT (2, "dbCloneItemFilter \n");

    Assert(VALID_DBPOS(pDB));

    // Presume failure.
    *ppOutFil = NULL;

    // These are already flat.  copy to THAlloced Memory
    pOutFil = THAllocEx(pTHS, sizeof(FILTER));
    pOutFil->choice = pFil->choice;
    pOutFil->FilterTypes.Item.choice = pFil->FilterTypes.Item.choice;

    switch(pFil->FilterTypes.Item.choice) {
    case FI_CHOICE_SUBSTRING:
        // Readability hack.
        pIn = pFil->FilterTypes.Item.FilTypes.pSubstring;

        pOut = THAllocEx(pTHS, sizeof(SUBSTRING));
        pOutFil->FilterTypes.Item.FilTypes.pSubstring = pOut;

        pOut->type = pIn->type;
        pOut->initialProvided = pIn->initialProvided;
        pOut->finalProvided = pIn->finalProvided;

        // convert initial and final substrings
        if (pIn->initialProvided && pIn->InitialVal.valLen) {
            pOut->InitialVal.valLen = pIn->InitialVal.valLen;
            pOut->InitialVal.pVal = THAllocEx(pTHS, pOut->InitialVal.valLen);
            memcpy(pOut->InitialVal.pVal, pIn->InitialVal.pVal, pOut->InitialVal.valLen);
        }
        if (pIn->finalProvided && pIn->FinalVal.valLen) {
            pOut->FinalVal.valLen = pIn->FinalVal.valLen;
            pOut->FinalVal.pVal = THAllocEx(pTHS, pOut->FinalVal.valLen);
            memcpy(pOut->FinalVal.pVal, pIn->FinalVal.pVal, pOut->FinalVal.valLen);
        }

        if(count = pIn->AnyVal.count) {
            // There are medial values.
            pOut->AnyVal.count = count;

            // Do the first value, since it's special.
            pAttrValIn = &pIn->AnyVal.FirstAnyVal.AnyVal;
            if (pAttrValIn->valLen) {
                ATTRVAL *pAttrValOut = &pOut->AnyVal.FirstAnyVal.AnyVal;
                pAttrValOut->valLen = pAttrValIn->valLen;
                pAttrValOut->pVal = THAllocEx(pTHS, pAttrValOut->valLen);
                memcpy(pAttrValOut->pVal, pAttrValIn->pVal, pAttrValOut->valLen);
            }
            // Dealt with the first one.
            count--;
            pOut->AnyVal.FirstAnyVal.pNextAnyVal = NULL;

            // Any more?
            if(count) {
                // Allocate some medial value holders.  Note that we only do
                // this if there are more than one medial values, since a
                // SUBSTRING has room in it for the first medial value.
                pOut->AnyVal.FirstAnyVal.pNextAnyVal =
                    THAllocEx(pTHS, count * sizeof(ANYSTRINGLIST));
                // Note we depend on zero filled memory allocatedy by THAlloc.

                pAS = pIn->AnyVal.FirstAnyVal.pNextAnyVal;
                pNewAS = pOut->AnyVal.FirstAnyVal.pNextAnyVal;
                for(;count;count--) {

                    if (pAS->AnyVal.valLen) {
                        pNewAS->AnyVal.valLen = pAS->AnyVal.valLen;
                        pNewAS->AnyVal.pVal = THAllocEx(pTHS, pAS->AnyVal.valLen);
                        memcpy(pNewAS->AnyVal.pVal, pAS->AnyVal.pVal, pAS->AnyVal.valLen);
                    }
                    pAS = pAS->pNextAnyVal;
                    if(count > 1) {
                        pNewAS->pNextAnyVal = &pNewAS[1];
                        pNewAS = pNewAS->pNextAnyVal;
                    }
                    else {
                        // NULL terminate the linked list
                        pNewAS->pNextAnyVal = NULL;
                    }
                }
            }
        }
        else {
            pOut->AnyVal.count = 0;
            pOut->AnyVal.FirstAnyVal.pNextAnyVal = NULL;
        }
        break;

    case FI_CHOICE_PRESENT:
        pOutFil->FilterTypes.Item.FilTypes.present =
                    pFil->FilterTypes.Item.FilTypes.present;
        break;

    case FI_CHOICE_TRUE:
    case FI_CHOICE_FALSE:
        // These don't require conversion
        break;

    default:
        // all others are AVAs
        pAVA = &pFil->FilterTypes.Item.FilTypes.ava;
        pAVAdst = &pOutFil->FilterTypes.Item.FilTypes.ava;

        pAVAdst->type = pAVA->type;

        if (pAVA->Value.valLen) {
            pAVAdst->Value.valLen = pAVA->Value.valLen;
            pAVAdst->Value.pVal = THAllocEx(pTHS, pAVAdst->Value.valLen);
            memcpy(pAVAdst->Value.pVal, pAVA->Value.pVal, pAVAdst->Value.valLen);
        }
    }
    *ppOutFil = pOutFil;

    return ERROR_SUCCESS;
}

DWORD dbCloneAndOrFilter (
    DBPOS *pDB,
    FILTER *pFil,
    FILTER **ppOutFil)
{
    THSTATE *pTHS=pDB->pTHS;
    FILTER  *pOutFil;
    FILTER  *pTemp;
    FILTER  **ppTemp;
    DWORD    err;

    // Presume failure.
    *ppOutFil = NULL;

    pOutFil = THAllocEx(pTHS, sizeof(FILTER));
    pOutFil->choice = pFil->choice;

    switch(pFil->choice) {
    case FILTER_CHOICE_OR:
        DPRINT (2, "dbCloneORFilter \n");
        pOutFil->FilterTypes.Or.count = pFil->FilterTypes.Or.count;

        pTemp = pFil->FilterTypes.Or.pFirstFilter;
        ppTemp = &pOutFil->FilterTypes.Or.pFirstFilter;
        break;

    case FILTER_CHOICE_AND:
        DPRINT (2, "dbCloneAndFilter \n");
        pOutFil->FilterTypes.And.count = pFil->FilterTypes.And.count;

        pTemp = pFil->FilterTypes.And.pFirstFilter;
        ppTemp = &pOutFil->FilterTypes.And.pFirstFilter;
        break;

    default:
        Assert (!"dbCloneAndOrFilter: Not an AND or OR filter");
        dbFreeFilter(pDB, pOutFil);
        return ERROR_INVALID_DATA;
    }

    while (pTemp) {
        if (err = dbCloneFilter (pDB, pTemp, ppTemp)) {
            dbFreeFilter(pDB, pOutFil);
            return err;
        }

        pTemp = pTemp->pNextFilter;
        ppTemp = &(*ppTemp)->pNextFilter;
    }

    *ppOutFil = pOutFil;

    return ERROR_SUCCESS;
}

DWORD dbCloneNotFilter (
    DBPOS *pDB,
    FILTER *pFil,
    FILTER **ppOutFil)
{
    THSTATE *pTHS=pDB->pTHS;
    FILTER  *pOutFil;
    FILTER  *pTemp;
    FILTER  **ppTemp;
    DWORD    err;

    // Presume failure.
    *ppOutFil = NULL;

    pOutFil = THAllocEx(pTHS, sizeof(FILTER));
    pOutFil->choice = pFil->choice;

    pTemp = pFil->FilterTypes.pNot;
    ppTemp = &pOutFil->FilterTypes.pNot;

    if (err = dbCloneFilter (pDB, pTemp, ppTemp)) {
        dbFreeFilter(pDB, pOutFil);
        return err;
    }

    *ppOutFil = pOutFil;

    return ERROR_SUCCESS;
}


DWORD dbCloneFilter (
    DBPOS *pDB,
    FILTER *pFil,
    FILTER **ppOutFil)
{
    DWORD err;
    *ppOutFil = NULL;

    if(!pFil) {
        // This is as flat as possible. can't clone
        return ERROR_SUCCESS;
    }

    DPRINT (2, "dbCloneFilter \n");

    switch(pFil->choice) {
    case FILTER_CHOICE_OR:
    case FILTER_CHOICE_AND:
        err = dbCloneAndOrFilter(pDB, pFil, ppOutFil);
        break;

    case FILTER_CHOICE_NOT:
        err = dbCloneNotFilter(pDB, pFil, ppOutFil);
        break;

    case FILTER_CHOICE_ITEM:
        err = dbCloneItemFilter(pDB, pFil, ppOutFil);
        break;

    default:
        // what is this?  return an error.
        *ppOutFil = NULL;
        err = ERROR_INVALID_DATA;
        break;
    }

    if (!err && pFil->pNextFilter) {
        err = dbCloneFilter (pDB, pFil->pNextFilter, & (*ppOutFil)->pNextFilter);
    }

    return err;
}

WCHAR *szFilterItemDescFormat[] = {
    L"=",      // FI_CHOICE_EQUALITY
    L"=",      // FI_CHOICE_SUBSTRING
    L">",      // FI_CHOICE_GREATER
    L">=",     // FI_CHOICE_GREATER_OR_EQ
    L"<",      // FI_CHOICE_LESS
    L"<=",     // FI_CHOICE_LESS_OR_EQ
    L"!=",     // FI_CHOICE_NOT_EQUAL
    L"=*",     // FI_CHOICE_PRESENT
    L"TRUE",     // FI_CHOICE_TRUE
    L"FALSE",    // FI_CHOICE_FALSE
    L"&",      // FI_CHOICE_BIT_AND
    L"|"       // FI_CHOICE_BIT_OR
};

typedef struct {
    DWORD dwLength;
    DWORD dwCount;
    PWCHAR pszBuf;
} WCHAR_BUFFER;

VOID WStrCatBufferLen(THSTATE* pTHS, WCHAR_BUFFER* pBuff, PWCHAR wstr, DWORD strLen) {
    if (pBuff->dwCount + strLen + 1 > pBuff->dwLength) {
        // need more space in the buffer
        if (pBuff->dwLength == 0) {
            pBuff->dwLength = max(100, strLen+1);
            pBuff->pszBuf = (PWCHAR)THAllocEx(pTHS, pBuff->dwLength*sizeof(WCHAR));
        }
        else {
            pBuff->dwLength += max(100, strLen+1);
            pBuff->pszBuf = (PWCHAR)THReAllocEx(pTHS, pBuff->pszBuf, pBuff->dwLength*sizeof(WCHAR));
        }
    }
    Assert(pBuff->dwCount + strLen + 1 <= pBuff->dwLength);
    // append the string
    memcpy(pBuff->pszBuf + pBuff->dwCount, wstr, strLen*sizeof(WCHAR));
    // dwCount does not include the final '\0'
    pBuff->dwCount += strLen;
    pBuff->pszBuf[pBuff->dwCount] = L'\0';
}

// Append a WCHAR string to the buffer
VOID WStrCatBuffer(THSTATE* pTHS, WCHAR_BUFFER* pBuff, PWCHAR wstr) {
    WStrCatBufferLen(pTHS, pBuff, wstr, wcslen(wstr));
}

VOID StrCatBufferLen(THSTATE* pTHS, WCHAR_BUFFER* pBuff, PCHAR str, DWORD strLen) {
    PWCHAR wstr;

    wstr = (PWCHAR)THAllocEx(pTHS, strLen*sizeof(WCHAR));
    if (!MultiByteToWideChar(CP_ACP, 0, str, strLen, wstr, strLen)) {
        Assert("!Failed to convert char string to wchar");
        // REVIEW:  on conversion failure, we need to do something so we don't log empty strings

        THFreeEx(pTHS, wstr);
        return;
    }
    WStrCatBufferLen(pTHS, pBuff, wstr, strLen);
    THFreeEx(pTHS, wstr);
}

// Append a CHAR string to the buffer
VOID StrCatBuffer(THSTATE* pTHS, WCHAR_BUFFER* pBuff, PCHAR str) {
    StrCatBufferLen(pTHS, pBuff, str, strlen(str));
}


// Imported from ldapcore.cxx
DWORD DirAttrValToString(THSTATE *pTHS, ATTCACHE *pAC, ATTRVAL *pValue, PCHAR* pszVal);

// Append a Value to the buffer
VOID ValueCatBuffer(
    THSTATE* pTHS,
    WCHAR_BUFFER* pBuff,
    ATTRTYP attrTyp,
    ATTRVAL* attrVal,
    BOOL fFilterIsInternal)
{
    PCHAR strVal;
    DWORD err;
    ATTCACHE* pAC;
    unsigned syntax;
    WCHAR hexVal[4];
    DWORD i;
    PWCHAR pszVal;
    ATTRVAL extVal;

    pAC = SCGetAttById(pTHS, attrTyp);
    if (pAC) {
        syntax = pAC->syntax;
    }
    else {
        // pAC not found? default to octet_string
        syntax = SYNTAX_OCTET_STRING_TYPE;
    }

    if (fFilterIsInternal) {
        // the value is in internal form. Convert to external first.
        err = gDBSyntax[syntax].IntExt(pTHS->pDB,
                                       DBSYN_INQ,
                                       attrVal->valLen,
                                       attrVal->pVal,
                                       &extVal.valLen,
                                       &extVal.pVal,
                                       0,
                                       0,
                                       0);
        if (err) {
            // failed to convert the value
            DPRINT2(0, "Failed to convert value to external, pAC=%s, err=%d\n", pAC ? pAC->name:"???", err);
            WStrCatBuffer(pTHS, pBuff, L"<val>");
            return;
        }
        attrVal = &extVal;
    }


    switch (syntax) {
    case SYNTAX_UNICODE_TYPE:
        // just append the unicode string (note: attrVal is not NULL-terminated)
        // We do not want to use DirAttrValToString because it converts Unicode to
        // UTF8.
        WStrCatBufferLen(pTHS, pBuff, (PWCHAR)attrVal->pVal, attrVal->valLen/sizeof(WCHAR));
        break;

    default:
        err = DirAttrValToString(pTHS, pAC, attrVal, &strVal);
        if (err == 0) {
            StrCatBuffer(pTHS, pBuff, strVal);
            THFreeEx(pTHS, strVal);
            break;
        }
        // else fall through to octet encoding

    case SYNTAX_OCTET_STRING_TYPE:
    case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
    case SYNTAX_SID_TYPE:
        // We need to hex-encode the value. DirAttrValToString leaves the value as is,
        // thus we can not use it.
        for (i = 0; i < attrVal->valLen; i++) {
            swprintf(hexVal, L"\\%02x", attrVal->pVal[i]);
            WStrCatBuffer(pTHS, pBuff, hexVal);
        }
        break;
    }
}

VOID AttrNameCatBuffer(THSTATE* pTHS, WCHAR_BUFFER* pBuff, ATTRTYP attrTyp) {
    ATTCACHE* pAC;

    pAC = SCGetAttById(pTHS, attrTyp);
    if (pAC && pAC->name) {
        StrCatBuffer(pTHS, pBuff, pAC->name);
    }
    else {
        WCHAR tmpStr[20];
        swprintf(tmpStr, L"attr(%d)", attrTyp);
        WStrCatBuffer(pTHS, pBuff, tmpStr);
    }
}

void dbCreateSearchPerfLogFilterInt (
    DBPOS*  pDB,
    FILTER* pFilter,
    BOOL    fFilterIsInternal,
    WCHAR_BUFFER* pBuff)
{
    THSTATE *pTHS = pDB->pTHS;
    BOOL bogus = FALSE;
    ATTCACHE *pAC = NULL;
    unsigned choice;
    ATTRTYP type;
    int i;
    ANYSTRINGLIST* pAnyVal;

    for (; pFilter != NULL; pFilter = pFilter->pNextFilter) {
        switch ( pFilter->choice )
        {
        case FILTER_CHOICE_ITEM:

            WStrCatBuffer(pTHS, pBuff, L" (");

            choice = pFilter->FilterTypes.Item.choice;

            switch ( choice )
            {
            case FI_CHOICE_EQUALITY:
            case FI_CHOICE_GREATER:
            case FI_CHOICE_GREATER_OR_EQ:
            case FI_CHOICE_LESS:
            case FI_CHOICE_LESS_OR_EQ:
            case FI_CHOICE_NOT_EQUAL:
            case FI_CHOICE_BIT_AND:
            case FI_CHOICE_BIT_OR:
            case FI_CHOICE_PRESENT:
            case FI_CHOICE_SUBSTRING:

                if ( choice == FI_CHOICE_PRESENT ) {
                    type = pFilter->FilterTypes.Item.FilTypes.present;
                } else if ( choice == FI_CHOICE_SUBSTRING ) {
                    type = pFilter->FilterTypes.Item.FilTypes.pSubstring->type;
                } else {
                    type = pFilter->FilterTypes.Item.FilTypes.ava.type;
                }

                AttrNameCatBuffer(pTHS, pBuff, type);

                // operation sign
                WStrCatBuffer(pTHS, pBuff, szFilterItemDescFormat[choice]);
                switch (choice) {
                case FI_CHOICE_PRESENT:
                    // * already appended
                    break;

                case FI_CHOICE_SUBSTRING:
                    if (pFilter->FilterTypes.Item.FilTypes.pSubstring->initialProvided) {
                        ValueCatBuffer(pTHS, pBuff,
                                       pFilter->FilterTypes.Item.FilTypes.pSubstring->type,
                                       &pFilter->FilterTypes.Item.FilTypes.pSubstring->InitialVal,
                                       fFilterIsInternal);
                    }
                    WStrCatBuffer(pTHS, pBuff, L"*");
                    for (i = 0, pAnyVal = &pFilter->FilterTypes.Item.FilTypes.pSubstring->AnyVal.FirstAnyVal;
                         i < pFilter->FilterTypes.Item.FilTypes.pSubstring->AnyVal.count;
                         i++, pAnyVal = pAnyVal->pNextAnyVal)
                    {
                        ValueCatBuffer(pTHS, pBuff,
                                       pFilter->FilterTypes.Item.FilTypes.pSubstring->type,
                                       &pAnyVal->AnyVal,
                                       fFilterIsInternal);
                        WStrCatBuffer(pTHS, pBuff, L"*");
                    }
                    if (pFilter->FilterTypes.Item.FilTypes.pSubstring->finalProvided) {
                        ValueCatBuffer(pTHS, pBuff,
                                       pFilter->FilterTypes.Item.FilTypes.pSubstring->type,
                                       &pFilter->FilterTypes.Item.FilTypes.pSubstring->FinalVal,
                                       fFilterIsInternal);
                    }
                    break;

                default:
                    // regular AVA
                    ValueCatBuffer(pTHS, pBuff,
                                   pFilter->FilterTypes.Item.FilTypes.ava.type,
                                   &pFilter->FilterTypes.Item.FilTypes.ava.Value,
                                   fFilterIsInternal);
                }

                break;

            case FI_CHOICE_TRUE:
            case FI_CHOICE_FALSE:
                WStrCatBuffer(pTHS, pBuff, szFilterItemDescFormat[choice]);
                break;

            default:
                WStrCatBuffer (pTHS, pBuff, L"<UNKNOWN>");
                break;
            }

            WStrCatBuffer(pTHS, pBuff, L") ");

            break;

        case FILTER_CHOICE_AND:
            WStrCatBuffer(pTHS, pBuff, L" ( & ");
            dbCreateSearchPerfLogFilterInt(
                pDB,
                pFilter->FilterTypes.And.pFirstFilter,
                fFilterIsInternal,
                pBuff);
            WStrCatBuffer(pTHS, pBuff, L") ");
            break;

        case FILTER_CHOICE_OR:
            WStrCatBuffer(pTHS, pBuff, L" ( | ");
            dbCreateSearchPerfLogFilterInt(
                pDB,
                pFilter->FilterTypes.Or.pFirstFilter,
                fFilterIsInternal,
                pBuff);
            WStrCatBuffer(pTHS, pBuff, L") ");
            break;

        case FILTER_CHOICE_NOT:
            WStrCatBuffer(pTHS, pBuff, L"( ! ");
            dbCreateSearchPerfLogFilterInt(
                pDB,
                pFilter->FilterTypes.pNot,
                fFilterIsInternal,
                pBuff);
            WStrCatBuffer(pTHS, pBuff, L") ");
            break;

        default:
            WStrCatBuffer(pTHS, pBuff, L"<UNKNOWN>");
            bogus = TRUE;
            break;
        }

        if (bogus) {
            break;
        }
    }
}



//
// Given a filter (pFilter) and a buffer ptr (pBuff),
// creates a printable form of the filter to be used for performance
// logging. The memory returned in pBuff is THAllocEx'ed
//
void
DBCreateSearchPerfLogData (
    DBPOS*      pDB,
    FILTER*     pFilter,
    BOOL        fFilterIsInternal,
    ENTINFSEL*  pSelection,
    COMMARG*    pCommArg,
    PWCHAR*     pszFilter,
    PWCHAR*     pszRequestedAttributes,
    PWCHAR*     pszCommArg)
{
    WCHAR_BUFFER buff;
    DWORD i;
    THSTATE* pTHS = pDB->pTHS;

    if (pszFilter) {
        buff.dwCount = buff.dwLength = 0;
        buff.pszBuf = NULL;
        WStrCatBuffer(pTHS, &buff, L"");
        if (pFilter) {
            dbCreateSearchPerfLogFilterInt(pDB, pFilter, fFilterIsInternal, &buff);
            // REVIEW:  we should try to put something in this buffer if the conversion fails
        }
        *pszFilter = buff.pszBuf;
    }
    if (pszRequestedAttributes) {
        buff.dwCount = buff.dwLength = 0;
        buff.pszBuf = NULL;
        WStrCatBuffer(pTHS, &buff, L"");

        if (pSelection) {
            switch (pSelection->attSel) {
            case EN_ATTSET_ALL:
                WStrCatBuffer(pTHS, &buff, L"[all]"); break;

            case EN_ATTSET_ALL_WITH_LIST:
                WStrCatBuffer(pTHS, &buff, L"[all_with_list]"); break;

            case EN_ATTSET_LIST:
                // this is the default, don't append anything
                // WStrCatBuffer(pTHS, &buff, L"[list]");
                break;

            case EN_ATTSET_LIST_DRA:
                WStrCatBuffer(pTHS, &buff, L"[list_dra]"); break;

            case EN_ATTSET_ALL_DRA:
                WStrCatBuffer(pTHS, &buff, L"[all_dra]"); break;

            case EN_ATTSET_LIST_DRA_EXT:
                WStrCatBuffer(pTHS, &buff, L"[list_dra_ext]"); break;

            case EN_ATTSET_ALL_DRA_EXT:
                WStrCatBuffer(pTHS, &buff, L"[all_dra_ext]"); break;

            case EN_ATTSET_LIST_DRA_PUBLIC:
                WStrCatBuffer(pTHS, &buff, L"[list_dra_public]"); break;

            case EN_ATTSET_ALL_DRA_PUBLIC:
                WStrCatBuffer(pTHS, &buff, L"[all_dra_public]"); break;

            default:
                WStrCatBuffer(pTHS, &buff, L"[???]"); break;
            }

            switch(pSelection->infoTypes) {
            case EN_INFOTYPES_TYPES_ONLY:
                WStrCatBuffer(pTHS, &buff, L"[types_only]"); break;
            case EN_INFOTYPES_TYPES_MAPI:
                WStrCatBuffer(pTHS, &buff, L"[types_mapi]"); break;
            case EN_INFOTYPES_TYPES_VALS:
                // this is the default, don't append anything
                // WStrCatBuffer(pTHS, &buff, L"[types_vals]");
                break;
            case EN_INFOTYPES_SHORTNAMES:
                WStrCatBuffer(pTHS, &buff, L"[shortnames]"); break;
            case EN_INFOTYPES_MAPINAMES:
                WStrCatBuffer(pTHS, &buff, L"[mapinames]"); break;
            }

            if (pSelection->AttrTypBlock.attrCount > 0) {
                for (i = 0; i < pSelection->AttrTypBlock.attrCount; i++) {
                    if (i > 0) {
                        WStrCatBuffer(pTHS, &buff, L",");
                    }
                    AttrNameCatBuffer(pTHS, &buff, pSelection->AttrTypBlock.pAttr[i].attrTyp);
                }
            }
        }
        *pszRequestedAttributes = buff.pszBuf;
    }

    if (pszCommArg) {
        // decode some interesting common args
        buff.dwCount = buff.dwLength = 0;
        buff.pszBuf = NULL;
        // initialize string
        WStrCatBuffer(pTHS, &buff, L"");

        if (pCommArg) {
            if (pCommArg->SortType != SORT_NEVER) {
                WStrCatBuffer(pTHS, &buff, L"sort:");
                AttrNameCatBuffer(pTHS, &buff, pCommArg->SortAttr);
                WStrCatBuffer(pTHS, &buff, L";");
            }

            if (pCommArg->ASQRequest.fPresent) {
                WStrCatBuffer(pTHS, &buff, L"ASQ:");
                AttrNameCatBuffer(pTHS, &buff, pCommArg->ASQRequest.attrType);
                WStrCatBuffer(pTHS, &buff, L";");
            }

            if (pCommArg->VLVRequest.fPresent) {
                WStrCatBuffer(pTHS, &buff, L"VLV;");
            }

            if (pCommArg->Svccntl.makeDeletionsAvail) {
                WStrCatBuffer(pTHS, &buff, L"return_deleted;");
            }

            if (pCommArg->Svccntl.pGCVerifyHint) {
                WStrCatBuffer(pTHS, &buff, L"GCVerifyHint:");
                WStrCatBuffer(pTHS, &buff, pCommArg->Svccntl.pGCVerifyHint);
                WStrCatBuffer(pTHS, &buff, L";");
            }

            #define SDFLAGS_DEFAULT \
                        (SACL_SECURITY_INFORMATION \
                        | OWNER_SECURITY_INFORMATION \
                        | GROUP_SECURITY_INFORMATION \
                        | DACL_SECURITY_INFORMATION)

            if (pCommArg->Svccntl.SecurityDescriptorFlags != SDFLAGS_DEFAULT) {
                WCHAR tmp[20];
                swprintf(tmp, L"SDflags:0x%x;", pCommArg->Svccntl.SecurityDescriptorFlags);
                WStrCatBuffer(pTHS, &buff, tmp);
            }
            #undef SDFLAGS_DEFAULT
        }

        *pszCommArg = buff.pszBuf;
    }
}

//
// creates the logging info for the particular filter used / indexes
// and stores that info on the pTHS->searchLogging datastructure
//
void DBGenerateLogOfSearchOperation (DBPOS *pDB)
{
    KEY_INDEX *tmp_index;
    DWORD count, size, buffSize;
    PCHAR buff, pCur;
    char szIndexName [MAX_RDN_SIZE+32];

    DBCreateSearchPerfLogData (pDB,
                               pDB->Key.pFilter,                    // filter to stringize
                               TRUE,                                // internal filter
                               NULL,                                // selection data
                               NULL,                                // commarg
                               &pDB->pTHS->searchLogging.pszFilter, // filter string
                               NULL,                                // selection string
                               NULL);                               // controls string

    size = sizeof (szIndexName);
    count = 0;
    for (tmp_index = pDB->Key.pIndex; tmp_index; tmp_index = tmp_index->pNext) {
        count++;
        if (tmp_index->pAC && tmp_index->pAC->name) {
            size+=strlen (tmp_index->pAC->name);
        }
        else if (tmp_index->szIndexName) {
            size+=strlen (tmp_index->szIndexName);
        }
    }

    buffSize = size + count * 32;
    buff = THAllocEx(pDB->pTHS, buffSize);
    buff[0] = '\0';
    pCur = buff;

    if (count) {
        for (tmp_index = pDB->Key.pIndex; tmp_index; tmp_index = tmp_index->pNext) {
            if (tmp_index->pAC && tmp_index->pAC->ulLinkID) {

                sprintf(szIndexName, "idx_%s:%d:L;",
                       tmp_index->pAC->name,
                       tmp_index->ulEstimatedRecsInRange );

            } else if (tmp_index->pAC && tmp_index->pAC->name) {

                sprintf (szIndexName, "idx_%s:%d:%c;",
                     tmp_index->pAC->name,
                     tmp_index->ulEstimatedRecsInRange,
                     tmp_index->tblIntersection ? 'I' :
                        tmp_index->bIsTupleIndex ? 'T' :
                            tmp_index->bIsPDNTBased ? 'P' : 'N');

            } else if (tmp_index->szIndexName) {

                sprintf (szIndexName, "%s:%d:%c;",
                     tmp_index->szIndexName,
                     tmp_index->ulEstimatedRecsInRange,
                     tmp_index->tblIntersection ? 'I' :
                        tmp_index->bIsTupleIndex ? 'T' :
                            tmp_index->bIsPDNTBased ? 'P' : 'N');

            }
            else {
                continue;
            }
            Assert(pCur - buff + strlen(szIndexName) + 1 <= buffSize);
            strcpy(pCur, szIndexName);
            pCur += strlen(szIndexName);
        }
    }
    else {
        if (pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE) {
            strcpy(buff, "TEMPORARY_SORT_INDEX");
        }
        else if (pDB->Key.indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE) {
            strcpy(buff, "INMEMORY_INDEX");
        }
    }
    pDB->pTHS->searchLogging.pszIndexes = buff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbjetex.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbjetex.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <dsatools.h>                   // For pTHStls
#include <attids.h>
#include <mdlocal.h>                    // For DsaIsSingleUserMode()

// Logging headers.
#include <dsexcept.h>

// Assorted DSA headers
#include <dsevent.h>
#include   "debug.h"         /* standard debugging header */
#define DEBSUB "DBJETEX:" /* define the subsystem for debugging        */

// DBLayer includes
#include "dbintrnl.h"


#include <fileno.h>
#define  FILENO FILENO_DBJETEX

#ifdef DBG
BOOL  gfInjectJetFailures = FALSE;
// Error injection rate:
// If zero, then the error is not injected
// If the value X>0, then one out of X calls will fail on average
// I.e. if X==1, then every call will fail with this error.
// Currently, the following (writing) functions use write failure injection:
//    JetDeleteEx, JetUpdateEx, JetEscrowUpdateEx, JetPrepareUpdateEx
// Also, all functions use shutdown failure injection
DWORD gdwInjectJetWriteConflictRate = 8;     // one out of 8 calls will fail on average
DWORD gdwInjectJetOutOfVersionStoreRate = 0; // disabled by default
DWORD gdwInjectJetLogWriteFailureRate = 0;   // disabled by default
DWORD gdwInjectJetOutOfMemoryRate = 0;       // disabled by default
DWORD gdwInjectJetShutdownRate = 0;          // disabled by default
BOOL  fRandomized = FALSE;

#define INJECT_JET_WRITE_FAILURE(err, JetCall) { \
    if (gfInjectJetFailures) { \
        if (!fRandomized) { srand(GetTickCount()); fRandomized = TRUE; } \
        if (gdwInjectJetWriteConflictRate != 0 && rand() % gdwInjectJetWriteConflictRate == 0) err = JET_errWriteConflict; \
        else if (gdwInjectJetOutOfVersionStoreRate != 0 && rand() % gdwInjectJetOutOfVersionStoreRate == 0) err = JET_errVersionStoreOutOfMemory; \
        else if (gdwInjectJetLogWriteFailureRate != 0 && rand() % gdwInjectJetLogWriteFailureRate == 0) err = JET_errLogWriteFail; \
        else if (gdwInjectJetOutOfMemoryRate != 0 && rand() % gdwInjectJetOutOfMemoryRate == 0) err = JET_errOutOfMemory; \
        else if (gdwInjectJetShutdownRate != 0 && rand() % gdwInjectJetShutdownRate == 0) err = JET_errClientRequestToStopJetService; \
        else err = (JetCall); \
    } \
    else err = (JetCall); \
}

#define INJECT_JET_GENERIC_FAILURE(err, JetCall) { \
    if (gfInjectJetFailures) { \
        if (!fRandomized) { srand(GetTickCount()); fRandomized = TRUE; } \
        if (gdwInjectJetShutdownRate != 0 && rand() % gdwInjectJetShutdownRate == 0) err = JET_errClientRequestToStopJetService; \
        else err = (JetCall); \
    } \
    else err = (JetCall); \
}

#else
#define INJECT_JET_WRITE_FAILURE(err, JetCall) err = (JetCall)
#define INJECT_JET_GENERIC_FAILURE(err, JetCall) err = (JetCall)
#endif

BOOL gfLogWriteConflicts = FALSE;

void
LogWriteConflict(
    IN  char*       szJetAPI,
    IN  JET_SESID   sesid,
    IN  JET_TABLEID tableid
    )
{
    char*   szTrace     = NULL;
    char*   szTrxInfo   = NULL;
    DBPOS*  pDB         = NULL;
    char*   szDN        = NULL;
    char*   szDN2       = NULL;

    if (!gfLogWriteConflicts) {
        return;
    }

    __try {
        char szTableName[JET_cbNameMost+1] = {0};

        //  get a new DBPOS to perform DNT to DSNAME mappings

        DBOpen2(FALSE, &pDB);

        //  get a trace buffer large enough to handle anything

        szTrace = THAllocEx(pDB->pTHS, 4096);
        szTrxInfo = THAllocEx(pDB->pTHS, 4096);

        //  get transaction information for this conflict from the THSTATE

        sprintf(szTrxInfo,
                " [Trx %08X%s%s%s%s%s]",
                pDB->pTHS->JetCache.cTickTransLevel1Started,
                pDB->pTHS->fSDP ? " SDP" : "",
                pDB->pTHS->fDRA ? " DRA" : "",
                pDB->pTHS->fDSA ? " DSA" : "",
                pDB->pTHS->fSAM ? " SAM" : "",
                pDB->pTHS->fLsa ? " LSA" : "" );

        //  determine what table caused the conflict

        if (JetGetTableInfo(sesid, tableid, szTableName, JET_cbNameMost, JET_TblInfoName)) {
            __leave;
        }
        if (!szTableName[0]) {
            __leave;
        }

        //  dump conflict info by table

        if (!_stricmp(SZDATATABLE, szTableName)) {

            ULONG   dnt;

            if (JetRetrieveColumn(sesid, tableid, dntid, &dnt, sizeof(dnt), NULL, JET_bitRetrieveCopy, NULL)) {
                __leave;
            }

            szDN = DBGetExtDnFromDnt(pDB, dnt);

            sprintf(szTrace,
                    "DSA:  write conflict during %s on %s%s\r\n",
                    szJetAPI,
                    szDN,
                    szTrxInfo);

        } else if (!_stricmp(SZLINKTABLE, szTableName)) {

            ULONG       ulLinkBase;
            ULONG       dntLink;
            ULONG       dntBlink = 0;
            ATTCACHE*   pAC;
            ATTCACHE*   pAC2;

            if (JetRetrieveColumn(sesid, tableid, linkbaseid, &ulLinkBase, sizeof(ulLinkBase), NULL, JET_bitRetrieveCopy, NULL)) {
                __leave;
            }
            if (JetRetrieveColumn(sesid, tableid, linkdntid, &dntLink, sizeof(dntLink), NULL, JET_bitRetrieveCopy, NULL)) {
                __leave;
            }
            if (JetRetrieveColumn(sesid, tableid, backlinkdntid, &dntBlink, sizeof(dntBlink), NULL, JET_bitRetrieveCopy, NULL) < JET_errSuccess) {
                __leave;
            }

            pAC = SCGetAttByLinkId(pDB->pTHS, MakeLinkId(ulLinkBase));
            pAC2 = SCGetAttByLinkId(pDB->pTHS, MakeBacklinkId(ulLinkBase));

            szDN = DBGetExtDnFromDnt(pDB, dntLink);
            if (dntBlink) {
                szDN2 = DBGetExtDnFromDnt(pDB, dntBlink);
            }

            if (pAC2) {
                sprintf(szTrace,
                        "DSA:  write conflict during %s on linked attribute %s/%s (Link: %s, Backlink: %s)%s\r\n",
                        szJetAPI,
                        pAC->name,
                        pAC2->name,
                        szDN,
                        szDN2,
                        szTrxInfo);
            } else {
                sprintf(szTrace,
                        "DSA:  write conflict during %s on linked attribute %s (Value: %s)%s\r\n",
                        szJetAPI,
                        pAC->name,
                        szDN,
                        szTrxInfo);
            }

        } else if (!_stricmp(SZSDTABLE, szTableName)) {

            SDID sdid;

            if (JetRetrieveColumn(sesid, tableid, sdidid, &sdid, sizeof(sdid), NULL, JET_bitRetrieveCopy, NULL)) {
                __leave;
            }

            sprintf(szTrace,
                    "DSA:  write conflict during %s on SD %I64X%s\r\n",
                    szJetAPI,
                    sdid,
                    szTrxInfo);

        } else if (!_stricmp(SZHIDDENTABLE, szTableName)) {

            sprintf(szTrace,
                    "DSA:  write conflict during %s on the hidden record%s\r\n",
                    szJetAPI,
                    szTrxInfo);

        } else {

            sprintf(szTrace,
                    "DSA:  write conflict during %s on table %s (no code for further details)%s\r\n",
                    szJetAPI,
                    szTableName,
                    szTrxInfo);

        }

        //  dump the trace info to the debugger

        OutputDebugStringA(szTrace);

    } __finally {
        if (pDB) {
            THFreeEx(pDB->pTHS, szDN);
            THFreeEx(pDB->pTHS, szDN2);
            THFreeEx(pDB->pTHS, szTrxInfo);
            THFreeEx(pDB->pTHS, szTrace);
            DBClose(pDB, FALSE);
        }
    }
}


JET_ERR
JetBeginSessionException(JET_INSTANCE instance, JET_SESID  *psesid,
    const char  *szUserName, const char  *szPassword, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetBeginSession(instance, psesid, szUserName, szPassword));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetDupSessionException(JET_SESID sesid, JET_SESID  *psesid, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetDupSession(sesid, psesid));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetEndSessionException(JET_SESID sesid, JET_GRBIT grbit, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetEndSession(sesid, grbit));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR JetEndSessionWithErr_(
	JET_SESID		sesid,
	JET_ERR			err,
	const BOOL		fHandleException,
	const USHORT	usFile,
	const INT		lLine )
	{
	//	sesid should have already been pre-validated by caller
	//
	Assert( JET_sesidNil != sesid );

	//	if no other errors, trap EndSession error, otherwise ignore it
	//
	if ( JET_errSuccess == err && fHandleException )
		{
		err = JetEndSessionException( sesid, NO_GRBIT, usFile, lLine );
		}
	else
		{
		const JET_ERR	errT	= JetEndSession( sesid, NO_GRBIT );

		//	should not normally fail
		//
		Assert( JET_errSuccess == errT );

		if ( JET_errSuccess != errT
			&& JET_errSuccess == err )
			{
			Assert( !fHandleException );
			err = errT;

	        DPRINT2( 0, "'JetEndSession' failed with error %d (dsid 0x%x).\n", err, DSID( usFile, lLine ) );
			LogUnhandledError( err );
			}
		}

	return err;
	}

JET_ERR
JetGetTableColumnInfoException(JET_SESID sesid, JET_TABLEID tableid,
    const char  *szColumnName, void  *pvResult, unsigned long cbMax,
    unsigned long InfoLevel, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetGetTableColumnInfo(sesid, tableid, szColumnName, pvResult, cbMax, InfoLevel));

    switch (err)
    {
    case JET_errSuccess:
    case JET_errColumnNotFound:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetBeginTransactionException(JET_SESID sesid, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetBeginTransaction(sesid));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetCommitTransactionException(JET_SESID sesid, JET_GRBIT grbit, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetCommitTransaction(sesid, grbit));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetRollbackException(JET_SESID sesid, JET_GRBIT grbit, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetRollback(sesid, grbit));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetCloseDatabaseException(JET_SESID sesid, JET_DBID dbid,
    JET_GRBIT grbit, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetCloseDatabase(sesid, dbid, grbit));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR JetCloseDatabaseWithErr_(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_ERR			err,
	const BOOL		fHandleException,
	const USHORT	usFile,
	const INT		lLine )
	{
	//	dbid should have already been pre-validated by caller
	//
	Assert( JET_dbidNil != dbid );

	//	if no other errors, trap CloseDatabase error, otherwise ignore it
	//
	if ( JET_errSuccess == err && fHandleException )
		{
		err = JetCloseDatabaseException( sesid, dbid, NO_GRBIT, usFile, lLine );
		}
	else
		{
		const JET_ERR	errT	= JetCloseDatabase( sesid, dbid, NO_GRBIT );

		//	should not normally fail
		//
		Assert( JET_errSuccess == errT );

		if ( JET_errSuccess != errT
			&& JET_errSuccess == err )
			{
			Assert( !fHandleException );
			err = errT;

	        DPRINT2( 0, "'JetCloseDatabase' failed with error %d (dsid 0x%x).\n", err, DSID( usFile, lLine ) );
			LogUnhandledError( err );
			}
		}

	return err;
	}

JET_ERR
JetCloseTableException(JET_SESID sesid, JET_TABLEID tableid, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetCloseTable(sesid, tableid));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR JetCloseTableWithErr_(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_ERR			err,
	const BOOL		fHandleException,
	const USHORT	usFile,
	const INT		lLine )
	{
	//	tableid should have already been pre-validated by caller
	//
	Assert( JET_tableidNil != tableid );

	//	if no other errors, trap CloseTable error, otherwise ignore it
	//
	if ( JET_errSuccess == err && fHandleException )
		{
		err = JetCloseTableException( sesid, tableid, usFile, lLine );
		}
	else
		{
		const JET_ERR	errT	= JetCloseTable( sesid, tableid );

		//	should not normally fail
		//
		Assert( JET_errSuccess == errT );

		if ( JET_errSuccess != errT
			&& JET_errSuccess == err )
			{
			Assert( !fHandleException );
			err = errT;

	        DPRINT2( 0, "'JetCloseTable' failed with error %d (dsid 0x%x).\n", err, DSID( usFile, lLine ) );
			LogUnhandledError( err );
			}
		}

	return err;
	}

JET_ERR
JetOpenDatabaseException(JET_SESID sesid, const char  *szFilename,
    const char  *szConnect, JET_DBID  *pdbid, JET_GRBIT grbit, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetOpenDatabase(sesid, szFilename, szConnect, pdbid, grbit));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetOpenTableException(JET_SESID sesid, JET_DBID dbid,
              const char  *szTableName, const void  *pvParameters,
              unsigned long cbParameters, JET_GRBIT grbit,
              JET_TABLEID  *ptableid, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetOpenTable(sesid, dbid, szTableName, pvParameters,
               cbParameters, grbit, ptableid));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        *ptableid = 0;
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0,
                  usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetSetTableSequentialException(JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetSetTableSequential(sesid, tableid, grbit));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetResetTableSequentialException(JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetResetTableSequential(sesid, tableid, grbit));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetDeleteException(JET_SESID sesid, JET_TABLEID tableid, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    INJECT_JET_WRITE_FAILURE(err, JetDelete(sesid, tableid));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    case JET_errWriteConflict:
        LogWriteConflict("JetDelete", sesid, tableid);
        Assert(!DsaIsSingleUserMode());
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_EXTENSIVE);

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetUpdateException(JET_SESID sesid, JET_TABLEID tableid,
    void  *pvBookmark, unsigned long cbBookmark,
    unsigned long  *pcbActual, JET_GRBIT grbit, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_WRITE_FAILURE(err, JetUpdate2(sesid, tableid, pvBookmark, cbBookmark, pcbActual, grbit));

    switch (err) {
      case JET_errSuccess:
        return err;

      case JET_errWriteConflict:
        LogWriteConflict("JetUpdate", sesid, tableid);
        Assert(!DsaIsSingleUserMode());
      case JET_errKeyDuplicate:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                       DS_EVENT_SEV_EXTENSIVE);

      default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                       DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetEscrowUpdateException(JET_SESID sesid,
                         JET_TABLEID tableid,
                         JET_COLUMNID columnid,
                         void *pvDelta,
                         unsigned long cbDeltaMax,
                         void *pvOld,
                         unsigned long cbOldMax,
                         unsigned long *pcbOldActual,
                         JET_GRBIT grbit,
                         DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_WRITE_FAILURE(err, JetEscrowUpdate(sesid, tableid, columnid, pvDelta, cbDeltaMax, pvOld, cbOldMax, pcbOldActual, grbit));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    case JET_errWriteConflict:
        LogWriteConflict("JetEscrowUpdate", sesid, tableid);
        Assert(!DsaIsSingleUserMode());
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_EXTENSIVE);

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetRetrieveColumnException(JET_SESID sesid, JET_TABLEID tableid,
    JET_COLUMNID columnid, void  *pvData, unsigned long cbData,
    unsigned long  *pcbActual, JET_GRBIT grbit, JET_RETINFO  *pretinfo,
    BOOL fExceptOnWarning, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetRetrieveColumn(sesid, tableid, columnid, pvData, cbData,
        pcbActual, grbit, pretinfo));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    case JET_errColumnNotFound:
        // The column wasn't found.  If we weren't trying to read this
        // column from the index, return this as an error.  If we were
        // reading from the index, treat this as a warning.
        if(!(grbit & JET_bitRetrieveFromIndex)) {
            RaiseDsaExcept(DSA_DB_EXCEPTION,
                           (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
        }
        // fall through

    case JET_wrnColumnNull:
    case JET_wrnBufferTruncated:
        if (!fExceptOnWarning)
        return err;

        // fall through
    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetRetrieveColumnsException( JET_SESID sesid, JET_TABLEID tableid,
    JET_RETRIEVECOLUMN *pretrievecolumn, unsigned long cretrievecolumn,
    BOOL fExceptOnWarning, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetRetrieveColumns(sesid, tableid, pretrievecolumn, cretrievecolumn));

    // JetRetrieveColumns can only return a fatal error or JET_wrnBufferTruncated.
    // JET_wrnColumnNull is never returned. To check for NULL values, examine
    // individual JET_RETRIEVECOLUMN.err values

    switch (err)
    {
    case JET_errSuccess:
        return err;

    case JET_wrnBufferTruncated:
        if (!fExceptOnWarning)
        return err;

        // fall through
    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;

}

JET_ERR
JetEnumerateColumnsException(
    JET_SESID           sesid,
    JET_TABLEID         tableid,
    ULONG               cEnumColumnId,
    JET_ENUMCOLUMNID*   rgEnumColumnId,
    ULONG*              pcEnumColumn,
    JET_ENUMCOLUMN**    prgEnumColumn,
    JET_PFNREALLOC      pfnRealloc,
    void*               pvReallocContext,
    ULONG               cbDataMost,
    JET_GRBIT           grbit,
    DWORD               dsid )
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetEnumerateColumns(
        sesid,
        tableid,
        cEnumColumnId,
        rgEnumColumnId,
        pcEnumColumn,
        prgEnumColumn,
        pfnRealloc,
        pvReallocContext,
        cbDataMost,
        grbit ));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;

}

JET_ERR
JetSetColumnException(
        JET_SESID sesid, JET_TABLEID tableid,
        JET_COLUMNID columnid, const void  *pvData, unsigned long cbData,
        JET_GRBIT grbit, JET_SETINFO  *psetinfo,
        BOOL fExceptOnWarning, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetSetColumn(sesid, tableid, columnid, pvData, cbData, grbit,
                                                 psetinfo));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    case JET_errMultiValuedDuplicate:
    case JET_errMultiValuedDuplicateAfterTruncation:
        if(!fExceptOnWarning)
            return err;

        // fall through

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetSetColumnsException(JET_SESID sesid, JET_TABLEID tableid,
    JET_SETCOLUMN *psetcolumn, unsigned long csetcolumn , DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetSetColumns(sesid, tableid, psetcolumn, csetcolumn ));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetPrepareUpdateException(JET_SESID sesid, JET_TABLEID tableid,
    unsigned long prep, DWORD dsid)
{
    JET_ERR err;

#if DBG
    if (prep != JET_prepCancel) {
        INJECT_JET_WRITE_FAILURE(err, JetPrepareUpdate(sesid, tableid, prep));
    }
    else
#endif
    INJECT_JET_GENERIC_FAILURE(err, JetPrepareUpdate(sesid, tableid, prep));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    case JET_errWriteConflict:
        LogWriteConflict("JetPrepareUpdate", sesid, tableid);
        Assert(!DsaIsSingleUserMode());
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_EXTENSIVE);

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetGetRecordPositionException(JET_SESID sesid, JET_TABLEID tableid,
    JET_RECPOS  *precpos, unsigned long cbRecpos, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetGetRecordPosition(sesid, tableid, precpos, cbRecpos));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetGotoPositionException(JET_SESID sesid, JET_TABLEID tableid,
    JET_RECPOS *precpos, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetGotoPosition(sesid, tableid, precpos ));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetDupCursorException(JET_SESID sesid, JET_TABLEID tableid,
    JET_TABLEID  *ptableid, JET_GRBIT grbit, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetDupCursor(sesid, tableid, ptableid, grbit));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetGetCurrentIndexException(JET_SESID sesid, JET_TABLEID tableid,
    char  *szIndexName, unsigned long cchIndexName, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetGetCurrentIndex(sesid, tableid, szIndexName, cchIndexName));

    switch (err)
    {
    case JET_errSuccess:
    case JET_wrnBufferTruncated:
    case JET_errNoCurrentIndex:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR JetSetCurrentIndex2Exception( JET_SESID sesid, JET_TABLEID tableid,
    const char *szIndexName, JET_GRBIT grbit, BOOL fReturnErrors,
        DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetSetCurrentIndex2(sesid, tableid, szIndexName, grbit));

    switch( err) {
    case JET_errSuccess:
        return err;

    case JET_errIndexNotFound:
    case JET_errNoCurrentRecord:
        if( fReturnErrors)
        return err;

        /* else fall through */
    default:
    RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                       DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetSetCurrentIndex4Exception(JET_SESID sesid,
                             JET_TABLEID tableid,
                             const char *szIndexName,
                             struct tagJET_INDEXID *pidx,
                             JET_GRBIT grbit,
                             BOOL fReturnErrors,
                             DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetSetCurrentIndex4(sesid, tableid, szIndexName, pidx, grbit, 0));

    switch( err) {
    case JET_errSuccess:
        return err;

    case JET_errInvalidIndexId:
        // REVIEW:  we should do this outside the case statement because if we
        // REVIEW:  get any error after this block and fReturnErrors then we will
        // REVIEW:  return that error even if we should have excepted instead
        // Refresh the hint
        if (NULL != pidx) {
            // Ignore errors. Retry at a later failure
            err = JetGetTableIndexInfo(sesid,
                                       tableid,
                                       szIndexName,
                                       pidx,
                                       sizeof(*pidx),
                                       JET_IdxInfoIndexId);
        }
        // And set the index w/o the hint
        err = JetSetCurrentIndex2(sesid, tableid, szIndexName, grbit);
        if (JET_errSuccess == err) {
            return err;
        }

        /* else fall through */

    case JET_errIndexNotFound:
    case JET_errNoCurrentRecord:
        if( fReturnErrors)
        return err;

        /* else fall through */
    default:
    RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                       DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetMoveException(JET_SESID sesid, JET_TABLEID tableid,
    long cRow, JET_GRBIT grbit, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetMove(sesid, tableid, cRow, grbit));

    switch (err)
    {
    case JET_errSuccess:
    case JET_errNoCurrentRecord:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetMakeKeyException(JET_SESID sesid, JET_TABLEID tableid,
    const void  *pvData, unsigned long cbData, JET_GRBIT grbit,
                    DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetMakeKey(sesid, tableid, pvData, cbData, grbit));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetSeekException(JET_SESID sesid, JET_TABLEID tableid,
    JET_GRBIT grbit, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetSeek(sesid, tableid, grbit));

    switch (err)
    {
    case JET_errSuccess:
    case JET_errRecordNotFound:
    case JET_wrnSeekNotEqual:
		return err;

    case JET_wrnUniqueKey:
		ASSERT( grbit & JET_bitCheckUniqueness );
	    return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetGetBookmarkException(JET_SESID sesid, JET_TABLEID tableid,
    void  *pvBookmark, unsigned long cbMax,
    unsigned long  *pcbActual, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetGetBookmark(sesid, tableid, pvBookmark, cbMax, pcbActual));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetGotoBookmarkException(JET_SESID sesid, JET_TABLEID tableid,
    void  *pvBookmark, unsigned long cbBookmark, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetGotoBookmark(sesid, tableid, pvBookmark, cbBookmark));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR JetGetSecondaryIndexBookmarkException(
    JET_SESID       sesid,
    JET_TABLEID     tableid,
    VOID *          pvSecondaryKey,
    const ULONG     cbSecondaryKeyMax,
    ULONG *         pcbSecondaryKeyActual,
    VOID *          pvPrimaryBookmark,
    const ULONG     cbPrimaryBookmarkMax,
    ULONG *         pcbPrimaryBookmarkActual,
    const DWORD     dsid )
    {
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetGetSecondaryIndexBookmark(
                                        sesid,
                                        tableid,
                                        pvSecondaryKey,
                                        cbSecondaryKeyMax,
                                        pcbSecondaryKeyActual,
                                        pvPrimaryBookmark,
                                        cbPrimaryBookmarkMax,
                                        pcbPrimaryBookmarkActual,
                                        NO_GRBIT ));
    switch ( err )
        {
        case JET_errSuccess:
        case JET_errNoCurrentIndex:     //  called this function on a primary index
            return err;

        default:
            RaiseDsaExcept(
                    DSA_DB_EXCEPTION,
                    (ULONG)err,
                    0,
                    dsid,
                    DS_EVENT_SEV_MINIMAL );
        }

    return err;
    }

JET_ERR JetGotoSecondaryIndexBookmarkException(
    JET_SESID       sesid,
    JET_TABLEID     tableid,
    VOID *          pvSecondaryKey,
    const ULONG     cbSecondaryKey,
    VOID *          pvPrimaryBookmark,
    const ULONG     cbPrimaryBookmark,
    const JET_GRBIT grbit,
    const DWORD     dsid )
    {
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetGotoSecondaryIndexBookmark(
                                        sesid,
                                        tableid,
                                        pvSecondaryKey,
                                        cbSecondaryKey,
                                        pvPrimaryBookmark,
                                        cbPrimaryBookmark,
                                        grbit ));
    switch ( err )
        {
        case JET_errSuccess:
            return err;

        case JET_errRecordDeleted:
            if ( grbit & JET_bitBookmarkPermitVirtualCurrency )
                return err;

        default:
            RaiseDsaExcept(
                    DSA_DB_EXCEPTION,
                    (ULONG)err,
                    0,
                    dsid,
                    DS_EVENT_SEV_MINIMAL );
        }

    return err;
    }

JET_ERR
JetComputeStatsException(JET_SESID sesid, JET_TABLEID tableid, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetComputeStats(sesid, tableid));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetOpenTempTableException(JET_SESID sesid,
    const JET_COLUMNDEF  *prgcolumndef, unsigned long ccolumn,
    JET_GRBIT grbit, JET_TABLEID  *ptableid,
    JET_COLUMNID  *prgcolumnid, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetOpenTempTable(sesid, prgcolumndef, ccolumn, grbit, ptableid, prgcolumnid));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetIntersectIndexesException(JET_SESID sesid,
    JET_INDEXRANGE * rgindexrange, unsigned long cindexrange,
    JET_RECORDLIST * precordlist, JET_GRBIT grbit, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetIntersectIndexes(sesid, rgindexrange, cindexrange, precordlist, grbit));

    switch (err)
    {
    case JET_errSuccess:
    case JET_errNoCurrentRecord:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetSetIndexRangeException(JET_SESID sesid,
    JET_TABLEID tableidSrc, JET_GRBIT grbit, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetSetIndexRange(sesid, tableidSrc, grbit));

    switch (err)
    {
    case JET_errNoCurrentRecord:
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetIndexRecordCountException(JET_SESID sesid,
    JET_TABLEID tableid, unsigned long  *pcrec, unsigned long crecMax ,
        DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetIndexRecordCount(sesid, tableid, pcrec, crecMax ));

    switch (err)
    {
    case JET_errSuccess:
    case JET_errNoCurrentRecord:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetRetrieveKeyException(JET_SESID sesid,
                        JET_TABLEID tableid, void  *pvData, unsigned long cbMax,
                        unsigned long  *pcbActual, JET_GRBIT grbit ,
                        BOOL fExceptOnWarning, DWORD dsid)
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetRetrieveKey(sesid, tableid, pvData, cbMax, pcbActual, grbit ));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    case JET_wrnBufferTruncated:
        if(!fExceptOnWarning) {
            return err;
        }
        // fall through.

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}


JET_ERR
JetGetTableIndexInfoException (
    JET_SESID       sesid,
    JET_TABLEID     tableid,
    const char      *szIndexName,
    void            *pvResult,
    unsigned long   cbResult,
    unsigned long   InfoLevel,
    DWORD           dsid
    )
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetGetTableIndexInfo(sesid, tableid, szIndexName, pvResult, cbResult, InfoLevel));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG)err, 0, dsid, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetDeleteIndexException (
    JET_SESID       sesid,
    JET_TABLEID     tableid,
    const char      *szIndexName,
    DWORD           dsid
    )
{
    JET_ERR err;

    INJECT_JET_GENERIC_FAILURE(err, JetDeleteIndex(sesid, tableid, szIndexName));

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG)err, 0, dsid, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetGetLockException(
    JET_SESID       sesid,
    JET_TABLEID     tableid,
    JET_GRBIT       grbit,
    DWORD           dsid
    )
{
    JET_ERR err;

    INJECT_JET_WRITE_FAILURE(err, JetGetLock(sesid, tableid, grbit));

    switch (err) {
      case JET_errSuccess:
        return err;

      case JET_errWriteConflict:
        if (grbit == JET_bitReadLock) {
            LogWriteConflict("JetGetLock(JET_bitReadLock)", sesid, tableid);
        } else {
            Assert(grbit == JET_bitWriteLock);
            LogWriteConflict("JetGetLock(JET_bitWriteLock)", sesid, tableid);
        }
        Assert(!DsaIsSingleUserMode());
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                       DS_EVENT_SEV_EXTENSIVE);

      default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                       DS_EVENT_SEV_MINIMAL);
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbisam.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbisam.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <mdlocal.h>
#include <dsatools.h>                   // For pTHS

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>

// Assorted DSA headers
#include <hiertab.h>
#include "anchor.h"
#include <dsevent.h>
#include <filtypes.h>                   // Def of FI_CHOICE_???
#include "objids.h"                     // Hard-coded Att-ids and Class-ids
#include "usn.h"
#include "drameta.h"
#include "quota.h"
#include "debug.h"                      // standard debugging header
#include "dstaskq.h"                    /* task queue stuff */
#define DEBSUB "DBISAM:"                // define the subsystem for debugging

// DBLayer includes
#include "dbintrnl.h"

// perfmon header
#include "ntdsctr.h"

#include <fileno.h>
#define  FILENO FILENO_DBISAM

typedef enum _DB_CHECK_ACTION {
    DB_CHECK_ERROR = 0,
    DB_CHECK_DELETE_OBJECT,
    DB_CHECK_HAS_DELETED_CHILDREN,
    DB_CHECK_LIVE_CHILD
} DB_CHECK_ACTION;

BOOL gfDoingABRef = FALSE;

/* Column IDs for static (key) columns */

JET_COLUMNID insttypeid;
JET_COLUMNID objclassid;
JET_COLUMNID ntsecdescid;
JET_COLUMNID dscorepropinfoid;
JET_COLUMNID dntid;
JET_COLUMNID pdntid;
JET_COLUMNID ancestorsid;
JET_COLUMNID objid;
JET_COLUMNID rdnid;
JET_COLUMNID rdntypid;
JET_COLUMNID cntid;
JET_COLUMNID abcntid;
JET_COLUMNID deltimeid;
JET_COLUMNID usnid;
JET_COLUMNID usnchangedid;
JET_COLUMNID dsaid;
JET_COLUMNID ncdntid;
JET_COLUMNID isdeletedid;
JET_COLUMNID IsVisibleInABid;
JET_COLUMNID iscriticalid;
JET_COLUMNID cleanid;
// Link table
JET_COLUMNID linkdntid;
JET_COLUMNID backlinkdntid;
JET_COLUMNID linkbaseid;
JET_COLUMNID linkdataid;
JET_COLUMNID linkndescid;
// Link Value Replication
JET_COLUMNID linkdeltimeid;
JET_COLUMNID linkusnchangedid;
JET_COLUMNID linkncdntid;
JET_COLUMNID linkmetadataid;
// Link Value Replication

JET_COLUMNID guidid;
JET_COLUMNID distnameid;
JET_COLUMNID sidid;
JET_COLUMNID orderid;
JET_COLUMNID begindntid;
JET_COLUMNID trimmableid;
JET_COLUMNID clientidid;
JET_COLUMNID sdpropflagsid;
JET_COLUMNID sdpropcheckpointid;

JET_COLUMNID ShowInid;
JET_COLUMNID mapidnid;

// SD table
JET_COLUMNID sdidid;
JET_COLUMNID sdhashid;
JET_COLUMNID sdvalueid;
JET_COLUMNID sdrefcountid;

JET_INDEXID idxDnt;
JET_INDEXID idxDraUsn;
JET_INDEXID idxDraUsnCritical;
JET_INDEXID idxDsaUsn;
JET_INDEXID idxMapiDN;
JET_INDEXID idxNcAccTypeName;
JET_INDEXID idxNcAccTypeSid;
JET_INDEXID idxPdnt;
JET_INDEXID idxPhantom;
JET_INDEXID idxProxy;
JET_INDEXID idxRdn;
JET_INDEXID idxSid;
JET_INDEXID idxDel;
JET_INDEXID idxGuid;
JET_INDEXID idxIsDel;
JET_INDEXID idxClean;
JET_INDEXID idxAncestors;
JET_INDEXID idxInvocationId;

// Link Value Replication
JET_INDEXID idxLink;
JET_INDEXID idxBackLink;
JET_INDEXID idxLinkDel;
JET_INDEXID idxLinkDraUsn;
JET_INDEXID idxLinkLegacy;
JET_INDEXID idxLinkAttrUsn;
// Link Value Replication

// Lingering Object Removal
JET_INDEXID idxNcGuid;

// SD table indices
JET_INDEXID idxSDId;
JET_INDEXID idxSDHash;


// These are the usns used by the DSA and tloadobj. gusnec is the running
// usn which is incremented every time it's used and is the one used to
// stamp usns on updates. gusninit is a copy of the usn in the hidden
// record. We read gusnec from disk, and set gusninit as USN_DELTA more.
// We write gusninit back to the hidden record, and then when gusnec grows
// past gusninit, we increment gusninit again and update the disk copy.
// The update code is in dbrepl.

USN gusnEC = 1; // tloadobj needs a start point
USN gusnInit = 1; // make same as gusnEC, so that mkdit doesn't assert on first
                  // object add (since it doesn't call InitDsaInfo)

// A saved copy of the usn from DSA start.
USN gusnDSAStarted = 0;

// We also keep track of the lowest usn that has not been committed. We do
// this because otherwise, when the DRA searches in another session in
// getncchanges it may find a higher usn that *has* been committed,
// and return that usn, in which case the DRA would start its next search
// past the uncommitted usn and never find it.

USN gusnLowestUncommitted = MAXLONGLONG;

// This is the array of all the lowest uncommitted usns allocated by the
// threads in  the system. there is one per session. The number of sessions
// is configurable from the registry, so the array is dynamically allocated
// at initialization.

USN *UncUsn;

// This is the critical section that guards access to the uncommitted
// usn array and the global uncommitted usn value.

CRITICAL_SECTION csUncUsn;

SYNTAX_JET syntax_jet[] = {
    {SYNTAX_UNDEFINED_TYPE,     JET_coltypUnsignedByte,0,CP_NON_UNICODE_FOR_JET,
     IndexTypeNone},
    {SYNTAX_DISTNAME_TYPE,      JET_coltypLong,        0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_OBJECT_ID_TYPE,     JET_coltypLong,        0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_CASE_STRING_TYPE,   JET_coltypLongBinary,    0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_NOCASE_STRING_TYPE, JET_coltypLongText,    0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_PRINT_CASE_STRING_TYPE, JET_coltypLongBinary,0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_NUMERIC_STRING_TYPE, JET_coltypBinary,      0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_DISTNAME_BINARY_TYPE, JET_coltypLongBinary,  0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_BOOLEAN_TYPE,       JET_coltypLong,        0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_INTEGER_TYPE,       JET_coltypLong,        0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_OCTET_STRING_TYPE,  JET_coltypLongBinary,  0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_TIME_TYPE,          JET_coltypCurrency,        0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_UNICODE_TYPE ,      JET_coltypLongText,    0,CP_WINUNICODE,
     IndexTypeSingleColumn},
    {SYNTAX_ADDRESS_TYPE,       JET_coltypText,      255,CP_NON_UNICODE_FOR_JET,
     IndexTypeNone},
    {SYNTAX_DISTNAME_STRING_TYPE, JET_coltypLongBinary, 0,CP_NON_UNICODE_FOR_JET,
     IndexTypeNone},
    {SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE,  JET_coltypLongBinary,  0,
     CP_NON_UNICODE_FOR_JET,  IndexTypeSingleColumn},
    {SYNTAX_I8_TYPE,            JET_coltypCurrency,    0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_SID_TYPE,           JET_coltypLongBinary,  0,CP_NON_UNICODE_FOR_JET,     IndexTypeSingleColumn},
    {ENDSYNTAX,                 0,                     0,CP_NON_UNICODE_FOR_JET,
     IndexTypeNone }
};



// This is a list of attribute IDs that have indices based on them
// that must not ever be removed.  You get into this list by having a hardcoded
// index named "INDEX_%08X" or "INDEX_P_%08X", where %08X is the attribute id
// the index indexes on. The list is terminated with a 0x7FFFFFFF.  If you ever
// create an index like this, or remove one that is named like this, you must
// change this  list.  The actual #defines which make these index names are in
// dbintrnl.h, so if you ever think something funny having to do with this list
// is going on, or you are just bored, you my cross reference this list with
// that file.
//
// NOTE: We used to keep this list ordered which required entry of numeric
//       attids which then would not track changes to schema.ini.  So we
//       now use ATT_* manifest constants and sort the list at init time.
//
// The indexType value shows the index type (fATTINdex or fPDNTATTINDEX or
// both, the values are 0x1, 0x2, or bitwise OR, defined in scache.h) that
// these attributes should have. They are taken from their defined values
// in schema.ini. If you change the index type for these in schema.ini
// you should change the value here too.
//
// We also define an end marker which ComparAttrtypInIndexInfo will
// not interpret as a negative number.

#define ATT_END_MARKER 0x7fffffff


INDEX_INFO IndicesToKeep[] = {

   { ATT_ALT_SECURITY_IDENTITIES,  SYNTAX_UNICODE_TYPE,         fATTINDEX },  // lookup by alternate credentials
   { ATT_DISPLAY_NAME,             SYNTAX_UNICODE_TYPE,         fATTINDEX | fANR },   // name cracking
   { ATT_DNS_ROOT,                 SYNTAX_UNICODE_TYPE,         fATTINDEX },   // name cracking
   { ATT_FLAT_NAME,                SYNTAX_UNICODE_TYPE,         fATTINDEX },   // used by LSA for trust lookups
   { ATT_FSMO_ROLE_OWNER,          SYNTAX_DISTNAME_TYPE,        fATTINDEX },   // so UI can find owners quickly
   { ATT_GIVEN_NAME,               SYNTAX_UNICODE_TYPE,         fATTINDEX | fANR },  // MAPI
   { ATT_GROUP_TYPE,               SYNTAX_INTEGER_TYPE,         fATTINDEX },   // needed by object picker and other UI
   { ATT_INVOCATION_ID,            SYNTAX_OCTET_STRING_TYPE,    fATTINDEX },   // find NTDS-DSA efficiently

   // This used to be SZDNTDELINDEX, but the DNT was dropped from the index
   // key, leaving just the attribute, so we moved this from FixedIndices
   // to IndicesToKeep.  In addition, this index never used to have
   // JET_bitIndexIgnoreAnyNull, which it should have, because we're
   // not interested in non-deleted objects with this index.
   // NOTE: this index is different than SZDELTIMEINDEX
   //
   { ATT_IS_DELETED,               SYNTAX_BOOLEAN_TYPE,         fATTINDEX },   // this is SZISDELINDEX

   { ATT_LDAP_DISPLAY_NAME,        SYNTAX_UNICODE_TYPE,         fATTINDEX },   // efficient schema lookup
   { ATT_LEGACY_EXCHANGE_DN,       SYNTAX_NOCASE_STRING_TYPE,   fATTINDEX | fANR },   // MAPI support?
   { ATT_NETBIOS_NAME,             SYNTAX_UNICODE_TYPE,         fATTINDEX },   // name cracking
   { ATT_OBJECT_CATEGORY,          SYNTAX_DISTNAME_TYPE,        fATTINDEX },   // efficient "object class" search
   { ATT_OBJECT_GUID,              SYNTAX_OCTET_STRING_TYPE,    fATTINDEX },   // efficient SAM, other lookups
   { ATT_OBJECT_SID,               SYNTAX_SID_TYPE,             fATTINDEX },   // efficient SAM lookups
   { ATT_PRIMARY_GROUP_ID,         SYNTAX_INTEGER_TYPE,         fATTINDEX },   // SAM primary group optimization
   { ATT_PROXIED_OBJECT_NAME,      SYNTAX_DISTNAME_BINARY_TYPE, fATTINDEX },   // cross domain move & replay
   { ATT_PROXY_ADDRESSES,          SYNTAX_UNICODE_TYPE,         fATTINDEX | fANR },   // MAPI support?

   //  SZRDNINDEX has been moved from FixedIndices to IndicesToKeep
   //
   { ATT_RDN,                      SYNTAX_UNICODE_TYPE,         fATTINDEX },   // this is SZRDNINDEX

   { ATT_SAM_ACCOUNT_NAME,         SYNTAX_UNICODE_TYPE,         fATTINDEX | fANR },   // name cracking
   { ATT_SAM_ACCOUNT_TYPE,         SYNTAX_INTEGER_TYPE,         fATTINDEX },   // needed by object picker and other UI
   { ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME, SYNTAX_UNICODE_TYPE,fATTINDEX },
   { ATT_MS_DS_CREATOR_SID,        SYNTAX_SID_TYPE,             fATTINDEX },
   { ATT_SERVICE_PRINCIPAL_NAME,   SYNTAX_UNICODE_TYPE,         fATTINDEX },   // name cracking
   { ATT_SID_HISTORY,              SYNTAX_SID_TYPE,             fATTINDEX },   // name cracking
   { ATT_SURNAME,                  SYNTAX_UNICODE_TYPE,         fATTINDEX | fANR }, // MAPI
   { ATT_TRUST_PARTNER,            SYNTAX_UNICODE_TYPE,         fATTINDEX },   // used by LSA for trust lookups
   { ATT_USER_ACCOUNT_CONTROL,     SYNTAX_INTEGER_TYPE,         fATTINDEX },   // for efficient SAM searches
   { ATT_USER_PRINCIPAL_NAME,      SYNTAX_UNICODE_TYPE,         fATTINDEX },   // name cracking
   { ATT_USN_CHANGED,              SYNTAX_I8_TYPE,              fATTINDEX },   // efficient find of changed objects
   { ATT_END_MARKER,               0,  0  },         // must be last in list
};

DWORD cIndicesToKeep = sizeof(IndicesToKeep) / sizeof(IndicesToKeep[0]);

int __cdecl
CompareAttrtypInIndexInfo(
        const void * pv1,
        const void * pv2
        )
/*
 * Cheap function needed by qsort for sorting IndexInfo structures by attrType
 */
{
    return ( CompareAttrtyp(&((INDEX_INFO *)pv1)->attrType,
                            &((INDEX_INFO *)pv2)->attrType) );
}

/*
 * Small helper routine to find if an attribute is in the
 * indices-to-keep table
*/

BOOL
AttInIndicesToKeep(ULONG id)
{
    INDEX_INFO * pIndexToKeep = IndicesToKeep;

    while( pIndexToKeep->attrType < id) {
       pIndexToKeep++;
    }

    if( pIndexToKeep->attrType == id) {
       // found it
       return TRUE;
    }

    return FALSE;
}

INDEX_INFO * PindexinfoAttInIndicesToKeep( const ULONG attid )
    {
    INDEX_INFO  indexinfoT  = { attid, 0, 0 };

    return (INDEX_INFO *)bsearch(
                            (void *)&indexinfoT,
                            (void *)IndicesToKeep,
                            cIndicesToKeep,
                            sizeof(INDEX_INFO),
                            CompareAttrtypInIndexInfo );
    }

VOID
dbInitIndicesToKeep()
{

    // sort by attrType field

    qsort((void *) IndicesToKeep,
          (size_t) cIndicesToKeep,
          (size_t) sizeof(IndicesToKeep[0]),
          CompareAttrtypInIndexInfo);
    // Verify ascending order.
    Assert(IndicesToKeep[1].attrType > IndicesToKeep[0].attrType);
    // Verify end marker.
    Assert(ATT_END_MARKER == IndicesToKeep[cIndicesToKeep-1].attrType);
}

/* Internal functions */

DWORD WriteRoot(DBPOS FAR *pDB);
BOOL  FObjHasDisplayName(DBPOS *pDB);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* AddUncUsn - Record this usn as uncommitted

   Called when a thread takes a usn.

   If we have no uncommitted usn in this thread, then this is the
   lowest uncommitted usn and we save it in the thread state.
   If we have no system-wide uncommitted usn, then this is the
   lowest system-wide uncommitted usn and we save it in the global variable.
*/
void AddUncUsn (USN usn)
{
    THSTATE *pTHS = pTHStls;
   unsigned i;

   // If there is no existing lowest usn for this thread, use new one.

   if (pTHS->UnCommUsn == 0) {
        pTHS->UnCommUsn  = usn ;

        // If there's no existing lowest system wide, use this one.

        if (gusnLowestUncommitted  == USN_MAX ) {
            gusnLowestUncommitted  = usn ;
        } else {

            // Ok there is already a lowest (which must be lower),
            // so just add this thread's lowest usn to array

            for (i=0;i< gcMaxJetSessions;i++) {
                if (UncUsn[i]  == USN_MAX ) {
                    UncUsn[i]  = usn ;
                    break;
                }
            }
            Assert(i < gcMaxJetSessions);
        }
    }
}
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* dbFlushUncUsns - Remove this thread's usns from uncommitted.

   Called when a thread has committed (or rolled back) all its usns, which
   will include its lowest uncommitted usn. Find new lowest and clear this
   thread's lowest from thread storage and array.

*/
#if defined(_M_IA64)
#if _MSC_FULL_VER== 13008973
#pragma optimize("", off)
#endif
#endif
void dbFlushUncUsns (void)
{
    THSTATE *pTHS=pTHStls;
    USN usnThread;
    unsigned i;
    USN usnHighestCommitted;

    usnThread  = pTHS->UnCommUsn ;

    // If this thread had a lowest usn ...

    if (usnThread !=0) {

        EnterCriticalSection (&csUncUsn);
        __try {

            // If it's the system-wide lowest replace it with next lowest

            if (usnThread  == gusnLowestUncommitted ) {

                USN usnTemp  = USN_MAX ;
                unsigned IndexLowest = gcMaxJetSessions;

                // Find lowest usn in array.

                for (i=0;i < gcMaxJetSessions;i++) {
                    if (UncUsn[i]  < usnTemp ) {
                        usnTemp  = UncUsn[i] ;
                        IndexLowest = i;
                    }
                }
                // If we found a lowest, put that in global and clear that entry.
                // Else set global usn to max.

                if (IndexLowest != gcMaxJetSessions) {
                    gusnLowestUncommitted  = UncUsn[IndexLowest] ;
                    UncUsn[IndexLowest]  = USN_MAX ;
                } else {
                    gusnLowestUncommitted  = USN_MAX ;
                }

            } else {

                // Or just remove it from the array.

                for (i=0;i < gcMaxJetSessions;i++) {
                    if (UncUsn[i]  == usnThread ) {
                        UncUsn[i]  = USN_MAX ;
                        break;
                    }
                }
                Assert(i < gcMaxJetSessions);
            }
            // Finally indicate no lowest usn in this thread.

            pTHS->UnCommUsn  = 0;

            // update perfmon counters
            usnHighestCommitted = ((USN_MAX == gusnLowestUncommitted) ?
                                    (gusnEC - 1) : (gusnLowestUncommitted -1));

            ISET(pcHighestUsnCommittedLo, LODWORD(usnHighestCommitted));
            ISET(pcHighestUsnCommittedHi, HIDWORD(usnHighestCommitted));

        }
        __finally {
            LeaveCriticalSection (&csUncUsn);
        }
    }
}
#if defined( _M_IA64)
#if _MSC_FULL_VER== 13008973
#pragma optimize("", on)
#endif
#endif


/*++
  DBFindBestMatch

Routine Description:

    Find the closest real object match of the object specified by DSNAME.  This
    match can be either an object by the same name but a different GUID, or the
    nearest real object parent.  If no real object parent is available, returns
    the dsname of the ROOT.

    1 - Re-initialize the DB object
    2 - Look the DN up in the subject table and get the tag of the best match.
    3 - use the DNT DN index to find the object index record.
    4 - look at the object found and its parents until we find the root or a
        real object.

Returns:

      0

--*/

DWORD APIENTRY
DBFindBestMatch(DBPOS *pDB, DSNAME *pDN, DSNAME **pParent)
{
    THSTATE         *pTHS=pDB->pTHS;
    DWORD            dwError;
    ULONG            ulDNT;
    ULONG            cbActual;
    JET_ERR          err;

    // NOTE This routine may reposition currency in the object table.

    Assert(VALID_DBPOS(pDB));

    // Since we are moving currency, we need to assure that we are not
    // in the middle of an init rec.  If we were, then whatever update
    // we were doing would be lost, because you can't change currency
    // inside of an update.


    Assert(pDB->JetRetrieveBits == 0);

    // There's been some confusion about the meaning of NameLen and whether
    // or not the trailing null is included.  The answer is: there should
    // be NameLen non-null characters in the name, but enough space should
    // be allocated in the structure to hold one extra null.  The following
    // asserts make sure that misallocated names are caught.
    Assert(pDN->StringName[pDN->NameLen] == L'\0');
    Assert(pDN->NameLen == 0 || pDN->StringName[pDN->NameLen-1] != L'\0');
    Assert(pDN->structLen >= DSNameSizeFromLen(pDN->NameLen));

    dbInitpDB(pDB);

    // Find the object by name.
    dwError = sbTableGetTagFromDSName(pDB, pDN, 0, &ulDNT, NULL);

    if ( 0 == dwError ) {
        // It's a real object.  Just copy the name to an output buffer.
        *pParent = THAllocEx(pTHS, pDN->structLen);
        memcpy(*pParent, pDN, pDN->structLen);
        return 0;
    }

    // NOTICE-2002/03/15-andygo:  redundant code
    // REVIEW:  the following code (up to FindFirstObjVisibleBySecurity) is redundant
    // REVIEW:  to the code in FindFirstObjVisibleBySecurity and should be removed

    // We bailed, but ulDNT was the last good tag.  Go there.
    DBFindDNT(pDB, ulDNT);

    // We've placed currency.  Now, while currency is NOT on a real object, set
    // currency to the parent.
    while (pDB->DNT != ROOTTAG && !DBCheckObj(pDB)) {
        DBFindDNT(pDB, pDB->PDNT);
    }
    // Now find the object nearest this one, that is visible
    // to the client
    FindFirstObjVisibleBySecurity(pTHS, pDB->DNT, pParent);

    return 0;
}

/*++DBFindDSName
 *
 * Find the object specified by DSNAME.
 *
 * 1 - Re-initialize the DB object
 * 2 - Look the DN up in the subject table and get its tag.
 * 3 - use the DNT DN index to find the object index record.
 * 4 - initialize some object flags.
 *
 * Returns:
 *
 *      DIRERR_NOT_AN_OBJECT if the object is found but a phantom.
 *      DIRERR_OBJ_NOT_FOUND if the object is not found.
 *      Miscellaneous sbTableGetTagFromDSName errors.
 *
 */

DWORD APIENTRY
DBFindDSName(DBPOS FAR *pDB, const DSNAME *pDN)
{
    DWORD   dwError;
    ULONG   ulSaveDnt;
    JET_ERR err;

    Assert(VALID_DBPOS(pDB));

    // There's been some confusion about the meaning of NameLen and whether
    // or not the trailing null is included.  The answer is: there should
    // be NameLen non-null characters in the name, but enough space should
    // be allocated in the structure to hold one extra null.  The following
    // asserts make sure that misallocated names are caught.
    Assert(pDN->NameLen == 0 || pDN->StringName[pDN->NameLen] == L'\0');
    Assert(pDN->structLen >= DSNameSizeFromLen(pDN->NameLen));

    // Since we are moving currency, we need to assure that we are not
    // in the middle of an init rec.  If we were, then whatever update
    // we were doing would be lost, because you can't change currency
    // inside of an update.
    Assert(pDB->JetRetrieveBits == 0);

    // Initialize a new object

    dbInitpDB(pDB);

    dwError = sbTableGetTagFromDSName(pDB, (DSNAME*)pDN,
                  SBTGETTAG_fUseObjTbl | SBTGETTAG_fMakeCurrent, NULL, NULL);

    return dwError;
}

// NOTICE-2002/03/15-andygo:  dead code
// REVIEW:  this function is dead code and has not been reviewed for security

DWORD APIENTRY
DBFindDSNameAnyRDNType(DBPOS FAR *pDB, const DSNAME *pDN)
// This routine is the same as DBFindDSName except it doesn't check the type of
// the RDN of the object (although it does enforce type equality for all other
// components of the DN)
{
    DWORD   dwError;
    ULONG   ulSaveDnt;
    JET_ERR err;

    Assert(VALID_DBPOS(pDB));

    // There's been some confusion about the meaning of NameLen and whether
    // or not the trailing null is included.  The answer is: there should
    // be NameLen non-null characters in the name, but enough space should
    // be allocated in the structure to hold one extra null.  The following
    // asserts make sure that misallocated names are caught.
    Assert(pDN->NameLen == 0 || pDN->StringName[pDN->NameLen] == L'\0');
    Assert(pDN->NameLen == 0 || pDN->StringName[pDN->NameLen-1] != L'\0');
    Assert(pDN->structLen >= DSNameSizeFromLen(pDN->NameLen));

    // Since we are moving currency, we need to assure that we are not
    // in the middle of an init rec.  If we were, then whatever update
    // we were doing would be lost, because you can't change currency
    // inside of an update.
    Assert(pDB->JetRetrieveBits == 0);

    // Initialize a new object

    dbInitpDB(pDB);

    dwError = sbTableGetTagFromDSName(pDB,
                                      (DSNAME*)pDN,
                                      (SBTGETTAG_fAnyRDNType  |
                                       SBTGETTAG_fUseObjTbl   |
                                       SBTGETTAG_fMakeCurrent   ),
                                      NULL,
                                      NULL);

    return dwError;
}

/*++DBFindGuid
 *
 * Find the object specified by its GUID. The name and SID parts of the DSNAME are ignored.
 *
 * Returns:
 *
 *      0 - successfully found a record -- may be phantom or object.
 *      DIRERR_OBJ_NOT_FOUND if the object is not found.
 *      Miscellaneous sbTableGetTagFromDSName errors.
 *
 */

DWORD APIENTRY
DBFindGuid(DBPOS FAR *pDB, const DSNAME *pDN)
{
    DWORD   dwError;
    ULONG   ulSaveDnt;
    JET_ERR err;

    Assert(VALID_DBPOS(pDB));

    // Since we are moving currency, we need to assure that we are not
    // in the middle of an init rec.  If we were, then whatever update
    // we were doing would be lost, because you can't change currency
    // inside of an update.
    Assert(pDB->JetRetrieveBits == 0);

    if (fNullUuid(&pDN->Guid)) {
        // null GUIDs are not allowed.
        // sbTableGetTagFromDSName asserts on a null GUID.
        return DIRERR_OBJ_NOT_FOUND;
    }

    // Initialize a new object

    dbInitpDB(pDB);

    dwError = sbTableGetTagFromDSName(pDB,
                                      (DSNAME*)pDN,
                                      (SBTGETTAG_fUseObjTbl |
                                       SBTGETTAG_fMakeCurrent |
                                       SBTGETTAG_fSearchByGuidOnly),
                                      NULL,
                                      NULL);

    return dwError;
}


/*++DBFindObjectWithSid
 *
 *     Given a DS Name Specifying  a SID and an DWORD specifying the
 *     ith object, this routine finds that object.
 *
 *
 *     Returns
 *          0                       - Found the Object Successfully
 *          DIRERR_OBJECT_NOT_FOUND - If the Object Was not found
 *          DIRERR_NOT_AN_OBJECT    - If the Object is a Phantom
 *
 --*/
DWORD APIENTRY
DBFindObjectWithSid(DBPOS FAR *pDB, DSNAME * pDN, DWORD iObject)
{

    DWORD err;
    ULONG cbSid;
    NT4SID* pSid;
    ULONG cbActual;

    Assert(VALID_DBPOS(pDB));

    err = DBSetCurrentIndex(pDB, Idx_Sid, NULL, FALSE);
    Assert(err == 0);       // the index must always be there

    // Convert the Sid to Internal Representation
    if (gDBSyntax[SYNTAX_SID_TYPE].ExtInt(pDB,
                                          DBSYN_INQ,
                                          pDN->SidLen,
                                          (UCHAR*)&pDN->Sid,
                                          &cbSid,
                                          (UCHAR**)&pSid,
                                          0,
                                          0,
                                          0)) {
        return DIRERR_OBJ_NOT_FOUND;
    }

    // Make a Jet Key
    JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl, pSid, cbSid, JET_bitNewKey);

    err = JetSeekEx(pDB->JetSessID,
                    pDB->JetObjTbl,
                    JET_bitSeekEQ|JET_bitSetIndexRange);
    if ( 0 == err )  {
#ifndef JET_BIT_SET_INDEX_RANGE_SUPPORT_FIXED
        JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl, pSid, cbSid, JET_bitNewKey);

        JetSetIndexRangeEx(pDB->JetSessID, pDB->JetObjTbl,
                           (JET_bitRangeUpperLimit | JET_bitRangeInclusive ));
#endif
        //
        // Ok We found the object. Keep Moving Forward Until either the SID does
        // not Match or we reached the given object
        //

        if((0==err) && (iObject>0)) {
            err = JetMoveEx(
                    pDB->JetSessID,
                    pDB->JetObjTbl,
                    iObject,
                    0);
        }

        if (0==err) {
            // Establish currency on the object found, which also checks
            // the object flag.
            err = dbMakeCurrent(pDB, NULL);

            if (err) {
                DPRINT1(1,
                        "DBFindObjectWithSid: success, DNT=%ld of non object\n",
                        (pDB)->DNT);
            }
        }
        else {
            err = DIRERR_OBJ_NOT_FOUND;
        }
    }
    else {
        err = DIRERR_OBJ_NOT_FOUND;
    }

    return err;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check that the object portion of the record exists.
     return: !0  present.
             0   not present or failure.
*/
char APIENTRY
DBCheckObj(DBPOS FAR *pDB)
{
    JET_ERR  dwError;
    char     objval;
    long     actuallen;

    Assert(VALID_DBPOS(pDB));

    switch (dwError = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                                                objid,
                                                &objval, sizeof(objval),
                                                &actuallen,
                                                pDB->JetRetrieveBits, NULL)) {
    case JET_errSuccess:
        return objval;
    case JET_wrnColumnNull:
        return 0;
    default:
        DsaExcept(DSA_DB_EXCEPTION, dwError, 0);
    }
    return 0;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add a new object to the database.
     1 - Set the create date to the current time.
     2 - Add the attribute fields to the record.
     3 - Get the RDN of the object if it isn't a root object.

   NOTE:
     This function assumes that the object class, DN and RDN attributes
     have already been set.
*/

DWORD APIENTRY
dbReplAdd(DBPOS FAR *pDB, USN usn, DWORD fFlags)
{
    THSTATE    *pTHS=pDB->pTHS;
    SYNTAX_TIME  time;
    char         objval = 1;
    SYNTAX_TIME  timeDeleted = 0;
    ULONG       actuallen;
    UCHAR       syntax;
    ULONG       len;
    UCHAR       *pVal;

    Assert(VALID_DBPOS(pDB));

    if (fFlags & DBREPL_fRESET_DEL_TIME)
    {
        // all we need to do is reset the deletion time

        JetSetColumnEx(pDB->JetSessID,
                       pDB->JetObjTbl,
                       deltimeid,
                       &timeDeleted,
                       0,
                       0,
                       NULL);

        return 0;
    }


    /* Add the when created attribute, unless it already exists */

    if (DBGetSingleValue(pDB, ATT_WHEN_CREATED, &time, sizeof(time),NULL)) {

        time = DBTime();
        DBResetAtt(pDB, ATT_WHEN_CREATED, sizeof(time),
                   &time, SYNTAX_TIME_TYPE);
    }

    /* Add the usn created attribute */

    DBResetAtt(pDB, ATT_USN_CREATED, sizeof(usn), &usn, SYNTAX_I8_TYPE);

    if (fFlags & DBREPL_fROOT)
        return(WriteRoot(pDB));

    /* Update OBJ flag to indicate that object portion exists */

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, objid, &objval,
                   sizeof(objval), 0, NULL);

    // Update del time field to be missing. It could have been set
    // by promoting a non-object to an object

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, deltimeid, &timeDeleted, 0,
                   0, NULL);
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, dntid,
                             &(pDB->DNT), sizeof(pDB->DNT), &actuallen,
                             pDB->JetRetrieveBits, NULL);

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, ncdntid, &pDB->NCDNT,
                   sizeof(pDB->NCDNT), 0, NULL);

    pDB->JetNewRec = FALSE;
    return 0;
}

void
dbSetIsVisibleInAB(
        DBPOS *pDB,
        BOOL bCurrentVisibility
        )
/*++

  Description:
    Helper routine to DBRepl.  Sets ATT_SHOW_IN_ADDRESS_BOOK appropriately and
    tracks the abcnt refcount.

  Parameters:
    bCurrentVisibility: current value of ATT_SHOW_IN_ADDRESS_BOOK on object.

  Return Values:
    None.
    Raises exception on error

--*/
{
    THSTATE            *pTHS = pDB->pTHS;
    DWORD               index, cOrigShowIn;
    BYTE                bVisible = 1;
    JET_RETRIEVECOLUMN  InputCol;
    JET_RETRIEVECOLUMN *pOutCols = NULL;
    DWORD               cNewShowIn;

    if(DBIsObjDeleted(pDB) || !FObjHasDisplayName(pDB)) {
        if(bCurrentVisibility) {
            // Object was visible, but it is now invisible. Set the value of
            // IsVisibleInAB to NULL
            JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl,
                           IsVisibleInABid, NULL, 0,
                           0, NULL);

            if(gfDoingABRef) {
                // We are tracking the show-in values as refcounts.  Decrement
                // the count of objects in the AB containers that it was
                // originally in.

                // Read the values of ATT_SHOW_IN_ADDRESS_BOOK from the original
                memset(&InputCol, 0, sizeof(InputCol));
                cOrigShowIn = 0;
                InputCol.columnid = ShowInid;
                dbGetMultipleColumns(pDB,
                                     &pOutCols,
                                     &cOrigShowIn,
                                     &InputCol,
                                     1,
                                     TRUE,
                                     TRUE);
                for(index=0;index<cOrigShowIn;index++) {
                    // Raises exception on error
                    DBAdjustABRefCount(pDB,
                                       *((DWORD *)(pOutCols[index].pvData)),
                                       -1);

                    THFreeEx(pTHS, pOutCols[index].pvData);
                }
                THFreeEx(pTHS, pOutCols);
            }
        }
    }
    else {
        // Object is now visible.
        if(!bCurrentVisibility) {
            // This object went from invisible to visible.  Set the new
            // value of the IsVisible column

            JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, IsVisibleInABid,
                           &bVisible, sizeof(bVisible), 0, NULL);

            if(gfDoingABRef) {
                // We are tracking the show-in values as refcounts.  Increment
                // the count of objects in the AB containers that it is now in.


                // Read the values of ATT_SHOW_IN_ADDRESS_BOOK from the copy
                memset(&InputCol, 0, sizeof(InputCol));
                cNewShowIn = 0;
                InputCol.columnid = ShowInid;
                dbGetMultipleColumns(pDB,
                                     &pOutCols,
                                     &cNewShowIn,
                                     &InputCol,
                                     1,
                                     TRUE,
                                     FALSE);
                for(index=0;index<cNewShowIn;index++) {
                    // Raises exception on error
                    DBAdjustABRefCount(pDB,
                                       *((DWORD *)(pOutCols[index].pvData)),
                                       1);
                    THFreeEx(pTHS, pOutCols[index].pvData);
                }
                THFreeEx(pTHS, pOutCols);
            }
        }
        else {
            // Was visible, is still visible.
            if(gfDoingABRef &&
               dbIsModifiedInMetaData(pDB, ATT_SHOW_IN_ADDRESS_BOOK)) {
                // However, the metadata shows that some changed happened to
                // the list of AB containers.  We need to decrement the count in
                // the containers it used to be in and increment in the
                // containers it now is in. We can achieve this by decrementing
                // the count of objects in the AB containers we used to be in
                // and incrementing the count in the containers we are now in.

                memset(&InputCol, 0, sizeof(InputCol));
                cNewShowIn = 0;
                InputCol.columnid = ShowInid;
                dbGetMultipleColumns(pDB,
                                     &pOutCols,
                                     &cNewShowIn,
                                     &InputCol,
                                     1,
                                     TRUE,
                                     FALSE);
                for(index=0;index<cNewShowIn;index++) {
                    // Raises exception on error
                    DBAdjustABRefCount(pDB,
                                       *((DWORD *)(pOutCols[index].pvData)),
                                       1);
                    THFreeEx(pTHS, pOutCols[index].pvData);
                }
                THFreeEx(pTHS, pOutCols);

                // Read the values of ATT_SHOW_IN_ADDRESS_BOOK from the original
                memset(&InputCol, 0, sizeof(InputCol));
                cOrigShowIn = 0;
                InputCol.columnid = ShowInid;
                dbGetMultipleColumns(pDB,
                                     &pOutCols,
                                     &cOrigShowIn,
                                     &InputCol,
                                     1,
                                     TRUE,
                                     TRUE);
                for(index=0;index<cOrigShowIn;index++) {
                    // Raises exception on error
                    DBAdjustABRefCount(pDB,
                                       *((DWORD *)(pOutCols[index].pvData)),
                                       -1);
                    THFreeEx(pTHS, pOutCols[index].pvData);
                }
                THFreeEx(pTHS, pOutCols);
            }
        }
    }

    return;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add or modify an object in the database.
*/
DWORD APIENTRY
DBRepl(DBPOS FAR *pDB, BOOL fDRA, DWORD fAddFlags,
       PROPERTY_META_DATA_VECTOR *pMetaDataVecRemote,
       DWORD dwMetaDataFlags)
{
    THSTATE  *pTHS=pDB->pTHS;
    USN    usn;
    ULONG len;
    JET_ERR err;
    DWORD pdnt, ncdnt, it;
    BYTE   bCurrentVisibility;
    JET_RETRIEVECOLUMN jCol[4];
    DWORD *pAncestors, cAncestors, cbAncestorsBuff;

    memset(jCol, 0, sizeof(jCol));
    DPRINT1(1, "DBRepl begin DNT:%ld\n", (pDB)->DNT);

    Assert(VALID_DBPOS(pDB));

    dbInitRec(pDB);

    // Retrieve the local USN to stamp on changed properties.
    usn = DBGetNewUsn();

    if ((fAddFlags & DBREPL_fADD) ||
        (fAddFlags & DBREPL_fROOT) ||
        (fAddFlags & DBREPL_fRESET_DEL_TIME))
    {
        err = dbReplAdd(pDB, usn, fAddFlags);
        if ((fAddFlags & DBREPL_fROOT) || err)
          return err;
    }

    memset(jCol, 0, sizeof(jCol));
    // get some info about this object - it'll be used in several places later
    jCol[0].columnid = pdntid;
    jCol[0].pvData = &pdnt;
    jCol[0].cbData = sizeof(pdnt);
    jCol[0].cbActual = sizeof(pdnt);
    jCol[0].grbit = pDB->JetRetrieveBits;
    jCol[0].itagSequence = 1;

    jCol[1].columnid = ncdntid;
    jCol[1].pvData = &ncdnt;
    jCol[1].cbData = sizeof(ncdnt);
    jCol[1].cbActual = sizeof(ncdnt);
    jCol[1].grbit = pDB->JetRetrieveBits;
    jCol[1].itagSequence = 1;

    jCol[2].columnid = insttypeid;
    jCol[2].pvData = &it;
    jCol[2].cbData = sizeof(it);
    jCol[2].cbActual = sizeof(it);
    jCol[2].grbit = pDB->JetRetrieveBits;
    jCol[2].itagSequence = 1;

    jCol[3].columnid = IsVisibleInABid;
    jCol[3].pvData = &bCurrentVisibility;
    jCol[3].cbData = sizeof(bCurrentVisibility);
    jCol[3].cbActual = sizeof(bCurrentVisibility);
    jCol[3].grbit = pDB->JetRetrieveBits;
    jCol[3].itagSequence = 1;

    JetRetrieveColumnsWarnings(pDB->JetSessID,
                               pDB->JetObjTbl,
                               jCol,
                               4);

    Assert(jCol[0].err == JET_errSuccess);

    // Determine the NCDNT of the object, remembering that NC_HEAD objects
    // are marked with their parent's NCDNT, which we don't want.
    if (jCol[2].err) {
        ncdnt = 0;
    }
    else if (it & IT_NC_HEAD) {
        ncdnt = pdnt;
    }

    // Use the current AB visibility status for computing the delta to
    // address book indices.

    switch (jCol[3].err)
    {
        case JET_errSuccess:
            break;

        case JET_wrnColumnNull:
            bCurrentVisibility = 0;
            break;

        default:
            DsaExcept(DSA_DB_EXCEPTION, jCol[3].err, 0);
    }

    // set the IsVisibleInAB field based if the object is not hidden and
    // not deleted

    dbSetIsVisibleInAB(pDB, bCurrentVisibility);

    // Update per-property meta data for all modified properties and merge
    // the replicated meta data (if any).  Writes updated meta data vector,
    // object changed time, and object changed USN to the record.
    dbFlushMetaDataVector(pDB, usn, pMetaDataVecRemote, dwMetaDataFlags);

    /* Update the permanent record from the copy buffer */

    DBUpdateRec(pDB);

    // Now that we're not insude the JetPrepareUpdate we can feel safe
    // to go and fetch the ancestors, confident that all our support
    // routines will work. (Prior to this point the record we're reading
    // is unseekable.)

    cbAncestorsBuff = sizeof(DWORD) * 12;
    pAncestors = THAllocEx(pDB->pTHS, cbAncestorsBuff);
    DBGetAncestors(pDB,
                   &cbAncestorsBuff,
                   &pAncestors,
                   &cAncestors);

    // Unless we have been told not to awaken waiters, update the list of
    // modified DNTs and their PDNTs on the DBPos structure

    dbTrackModifiedDNTsForTransaction(pDB,
                                      ncdnt,
                                      cAncestors,
                                      pAncestors,
                                      !(fAddFlags & DBREPL_fKEEP_WAIT),
                                      MODIFIED_OBJ_modified);

    // NOTE: We are no longer are in a JetPrepareUpdate
    // ...and therefore have lost currency if we just inserted a new record.

    DBFindDNT(pDB, (pDB)->DNT);

    return 0;
}                       /*DBRepl*/

//
// DBGetNewUsn
//
// Gets the next usn within a mutex. If we are up to the usn on disk
// in the hidden record, increment the disk usn and rewrite it.
#if defined(_M_IA64)
#if _MSC_FULL_VER== 13008973
#pragma optimize("", off)
#endif
#endif
USN DBGetNewUsn (void)

{
    USN usn;

    EnterCriticalSection (&csUncUsn);
    Assert(gusnEC <= gusnInit);
    __try  {

        // Increment the USN and if we're up to the usn on disk, increment
        // the master usn and update the disk copy.

        usn = gusnEC;

        if (usn+1 > gusnInit) {
            DBReplaceHiddenUSN(gusnInit + USN_DELTA_INIT);

            // Note that we increment the global here -- after the hidden table
            // has been updated, if need be -- such that DBGetNewUsn() will not
            // cause gusnInit to go out of its valid range if the hidden table
            // update fails.
            gusnInit += USN_DELTA_INIT;
        }

        // Note that we increment the global here -- after the hidden table has
        // been updated, if need be -- such that DBGetNewUsn() will not cause
        // gusnEC to go out of its valid range if the hidden table update fails.
        gusnEC++;

        // We have allocated a usn that has not yet been committed, keep
        // track of this.  Note that we do this after the hidden table has been
        // updated so that we do not pass out duplicate USNs on a failure.
        AddUncUsn (usn);

        // update perfmon counters
        ISET(pcHighestUsnIssuedLo, LODWORD(usn));
        ISET(pcHighestUsnIssuedHi, HIDWORD(usn));
    } __finally {
        LeaveCriticalSection (&csUncUsn);
    }
    return usn;
}
#if defined( _M_IA64)
#if _MSC_FULL_VER== 13008973
#pragma optimize("", on)
#endif
#endif

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* If the root already exists, return error.  Else copy the new record to
   the update buffer for the root record, and update it.
*/
DWORD
WriteRoot(DBPOS FAR *pDB)
{
    THSTATE     *pTHS=pDB->pTHS;
    DWORD        dberr = 0;
    JET_ERR      err;
    ULONG        tag = ROOTTAG;
    JET_RETINFO  retinfo;
    JET_SETINFO  setinfo;
    char         CurObjVal;
    char         *buf;
    ULONG        cbBuf;
    ULONG        actuallen;
    char         objval = 1;
    ULONG        CurrRecOccur;

    Assert(VALID_DBPOS(pDB));

    /* Position SearchTbl on the root record */

    DPRINT(2, "WriteRoot entered\n");
    JetSetCurrentIndexSuccess(
                pDB->JetSessID,
                pDB->JetSearchTbl,
                NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, &tag, sizeof(tag), JET_bitNewKey);

    if (err = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ))
    {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, DS_JET_PREPARE_FOR_REPLACE);
    /* Get the OBJ flag. If its set, the root exists and the new record is bogus */

    __try {
        if (JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetSearchTbl, objid, &CurObjVal,
            sizeof(CurObjVal), &actuallen, JET_bitRetrieveCopy,
            NULL) == JET_errSuccess)
        {
            if (CurObjVal)
            {
                DPRINT(1, "WriteRoot: Root exists\n");
                dberr = DB_ERR_DATABASE_ERROR;
                __leave;
            }
        }

        /* Copy new rec attributes from ObjTbl to SearchTbl */

        CurrRecOccur = 1;
        retinfo.cbStruct = sizeof(retinfo);
        retinfo.ibLongValue = 0;
        retinfo.itagSequence = CurrRecOccur;
        retinfo.columnidNextTagged = 0;
        setinfo.cbStruct = sizeof(setinfo);
        setinfo.ibLongValue = 0;
        setinfo.itagSequence = 0;    // New tag value

        cbBuf = DB_INITIAL_BUF_SIZE;
        buf = dbAlloc(cbBuf);

        while (((err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl, 0, buf, cbBuf,
            &actuallen, pDB->JetRetrieveBits, &retinfo)) == JET_errSuccess) ||
                                            (err == JET_wrnBufferTruncated))
        {
            if (err == JET_errSuccess)
            {
                JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl,
                    retinfo.columnidNextTagged, buf, actuallen, 0, &setinfo);

                retinfo.itagSequence = ++CurrRecOccur;
                retinfo.columnidNextTagged = 0;
            }
            else
            {
                cbBuf = actuallen;
                dbFree(buf);
                buf = dbAlloc(cbBuf);
            }
        }
        dbFree(buf);

        DBCancelRec(pDB);

        /* Update OBJ flag to indicate that root exists */

        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, objid, &objval, sizeof(objval), 0, NULL);

        JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);
    } __finally {
        JetPrepareUpdate(pDB->JetSessID, pDB->JetSearchTbl, JET_prepCancel);
    }

    DBFindDNT(pDB, ROOTTAG);

    return dberr;
}

VOID
DBResetAtt (
        DBPOS FAR *pDB,
        ATTRTYP type,
        ULONG len,
        void *pVal,
        UCHAR syntax
        )
/*++
Routine Description:
    Replace an existing attribute with a new value.

Arguments:
    pDB        - DBPOS to use.
    type       - Attribute to replace.
    len        - length of new value.
    pVal       - pointer to new value.
    syntax     - syntax of Attribute.

Return Values:
    None.  Suceeds or throws an exception.

--*/
{
    JET_SETINFO  setinfo;
    JET_COLUMNID colID;
    ATTCACHE * pAC = NULL;
    JET_GRBIT grbit = 0;

    Assert(VALID_DBPOS(pDB));

    dbInitRec(pDB);

    // Ensure that this is a valid attribute

    switch(type) {
    case FIXED_ATT_ANCESTORS:
        colID = ancestorsid;
        // This messes with cached info.  flush the dnread cache
        dbFlushDNReadCache(pDB, pDB->DNT);
        break;
    case FIXED_ATT_NCDNT:
        colID = ncdntid;
        // This messes with cached info.  flush the dnread cache
        dbFlushDNReadCache(pDB, pDB->DNT);
        break;
    case FIXED_ATT_DEL_TIME:
        colID = deltimeid;
        break;
    default:
        if(!(pAC = SCGetAttById(pDB->pTHS, type))) {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, 0);
        }
        if (dbNeedToFlushDNCacheOnUpdate(pAC->id)) {
            // This messes with cached info.  flush the dnread cache
            dbFlushDNReadCache(pDB, pDB->DNT);
        }
        colID = pAC->jColid;
        break;
    }

    if (SYNTAX_OCTET_STRING_TYPE == syntax)
    {
        // we are writing a binary blob;
        // set the appropriate grbits so that the blob is
        // overwritten on the current value instead of the
        // default behavior of jet (which is to delete, and insert
        // the new binary value). Overwriting would also cause jet
        // to write out only the diff into the log instead of writing
        // the entire binary values.
        grbit = JET_bitSetOverwriteLV | JET_bitSetSizeLV;
    }

    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 1;

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, colID,
                   pVal, len, grbit, &setinfo);

    if (NULL != pAC) {
        // Is not a fixed attribute; touch its replication meta data.
        // DBTouchMetaData succeeds or excepts.
        DBTouchMetaData(pDB, pAC);
    }

    // If code is added to call this function for any of the following
    // attributes, we'll need to conditionally force a flush of this DNT from
    // the read cache on update (i.e., set pDB->fFlushCacheOnUpdate = TRUE).
    // REVIEW:  these cases are handled by the default case above
    Assert((rdnid != colID) && (sidid != colID) && (guidid != colID));

    return;

}/*DBResetAtt*/


// Overwrite only a portion of the given long valued attribute and thus
// optimize the Jet write
DWORD
DBResetAttLVOptimized (
    DBPOS FAR *pDB,
    ATTRTYP type,
    ULONG ulOffset,
    ULONG lenSegment,
    void *pValSegment,
    UCHAR syntax
    )
{
    JET_SETINFO  setinfo;
    JET_COLUMNID colID;
    ATTCACHE * pAC = NULL;

    Assert(VALID_DBPOS(pDB));
    Assert(SYNTAX_OCTET_STRING_TYPE == syntax);

    dbInitRec(pDB);

    // Ensure that this is a valid attribute
    if(!(pAC = SCGetAttById(pDB->pTHS, type))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, 0);
    }
    colID = pAC->jColid;

    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = ulOffset;
    setinfo.itagSequence = 1;

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, colID,
                   pValSegment, lenSegment, JET_bitSetOverwriteLV, &setinfo);

    // touch its replication meta data (this is a no-op for
    // ATT_REPL_PROPERTY_META_DATA, but needed if others start using
    // DBResetAttLVOptimized()
    DBTouchMetaData(pDB, pAC);

    return 0;

}/*DBResetAttLVOptimized*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Determine if the object has a display name*/
BOOL
FObjHasDisplayName(DBPOS *pDB)
{
    Assert(VALID_DBPOS(pDB));

    if (!DBHasValues(pDB, ATT_DISPLAY_NAME))
      return FALSE;

   return TRUE;

}/*FObjHasDisplayName*/



DB_CHECK_ACTION
DBCheckToGarbageCollect(
    DBPOS *pDBold,
    ATTCACHE *pAC
    )

    /* we check to see if this object has any children that are real objects.
     * if it has children that are real objects (and they are in the same NC)
     *   we advance the deltime to that of the child + 1, so as to first
     *   delete the children and then the parent. The time is only adjusted
     *   if pAC is not set. If pAC is set, then we aren't sure if the
     *   time can be adjusted. Eg, if pAC is for EntryTTL then the time
     *   cannot be adjusted because that would break the RFC.
     *   In this case it returns FALSE
     *
     * if it doesn't have children or the children are from another NC,
     *   we can safely delete the object.
     *   in this case it returns TRUE
     *
     * The operations in this function are done in a separate transaction
     * as a result we don't move the cursor
     *
     */
{
    DB_CHECK_ACTION action = DB_CHECK_DELETE_OBJECT; // assume success
    BOOL updateObject = FALSE;

    INDEX_VALUE  IV[1];
    DWORD  ParentDNT;
    ULONG  actuallen;
    DSTIME child_deltime;
    DSTIME deltime;
    DWORD  it;
    DWORD  err;
    ULONG  dwException, ulErrorCode, dsid;
    PVOID  dwEA;
    DBPOS *pDB;
    DWORD  fCommit = FALSE;
    JET_COLUMNID jDelColid;

    #if DBG
    PDSNAME parentName, childName;
    #endif


     __try {
        // If no attribute is specified, use the fixed index deltimeid (whenDeleted)
        jDelColid = (pAC) ? pAC->jColid : deltimeid;
        DBOpen2 (FALSE, &pDB);
        __try {

            ParentDNT = pDBold->DNT;
            IV[0].pvData = &ParentDNT;
            IV[0].cbData = sizeof(ParentDNT);

            // position to node
            DBFindDNT(pDB, ParentDNT);


            /* Retrieve DEL time from parent record */
            err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                        jDelColid, &deltime, sizeof(deltime), &actuallen,
                        0, NULL);

            if (err) {
                // Do not delete
                action = DB_CHECK_ERROR;
                _leave;
            }

            #if DBG
            parentName = DBGetCurrentDSName(pDB);

            DPRINT3(3, "DBCheckToGarbageCollect: Parent: DNT(%x) %ws Deltime: %I64x\n",
                            ParentDNT, parentName->StringName, deltime);
            THFree (parentName);
            #endif


            // Set to the PDNT index
            JetSetCurrentIndex4Success(
                        pDB->JetSessID,
                        pDB->JetObjTbl,
                        SZPDNTINDEX,
                        &idxPdnt,
                        JET_bitMoveFirst);

            // Now, set an index range in the PDNT index to get all the children.
            // Use GE because this is a compound index.
            err = DBSeek(pDB, IV, 1, DB_SeekGE);


            if((!err || err == JET_wrnSeekNotEqual) && (pDB->PDNT == ParentDNT)) {
                // OK, we're GE. Set an indexRange.

                err = DBSetIndexRange(pDB, IV, 1);

                // Now, walk the index.
                while(!err) {
                    // First, see if this is a real object

                    if (DBCheckObj(pDB)) {
                        // Yep, it's a real object.

                        #if DBG
                        childName = DBGetCurrentDSName(pDB);
                        DPRINT2 (3, "DBCheckToGarbageCollect: Child DNT(%x) %ws\n",
                                            pDB->DNT, childName->StringName );
                        THFree (childName);
                        #endif

                        // Get the instance type
                        err = DBGetSingleValue(pDB,
                                           ATT_INSTANCE_TYPE,
                                           &it,
                                           sizeof(it),
                                           NULL);


                        // found child that is on the same NC, so we try to find the
                        // maximum deltime so as to change this object's deltime
                        // and then we skip deletion of this object
                        if (! (it & IT_NC_HEAD)) {

                            // parent has children, don't garbage collect
                            action = DB_CHECK_HAS_DELETED_CHILDREN;

                            /* Retrieve DEL time from child record */
                            err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                                           pDB->JetObjTbl,
                                                           jDelColid,
                                                           &child_deltime,
                                                           sizeof(child_deltime),
                                                           &actuallen,
                                                           0,
                                                           NULL);

                            // the child object does not have a deltime,
                            // so we should not garbagecollect the parent
                            if (err) {
                                action = DB_CHECK_LIVE_CHILD;
                                __leave;
                            }

                            // child's time is greater than parent's time; adjust
                            if (child_deltime >= deltime) {
                                updateObject = TRUE;
                                // set parent's time to > child's time
                                deltime = child_deltime + 1;
                                // we are ok if we find at least one
                                break;
                            }
                        }
                    }
                    err = DBMove(pDB, FALSE, DB_MoveNext);
                }
            }


            // reset delete time
            if (updateObject) {
                JET_SETINFO setinfo;

                // restore currency to parent object
                DBFindDNT(pDB, ParentDNT);

                DPRINT1(2, "DBCheckToGarbageCollect: skipping deletion of DNT: %x\n", ParentDNT);

                // Set Del time index field & update record
                setinfo.cbStruct = sizeof(setinfo);
                setinfo.ibLongValue = 0;
                setinfo.itagSequence = 1;

                JetPrepareUpdate(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
                JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, jDelColid,
                           &deltime, sizeof(deltime), 0, &setinfo);
                JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);

                fCommit = TRUE;
            }
        }
        __finally {
            DBClose(pDB, fCommit);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                                        &dwException,
                                        &dwEA,
                                        &ulErrorCode,
                                        &dsid)) {

          DPRINT1 (0, "DBCheckToGarbageCollect: Exception: %d\n", ulErrorCode);

          // Do not delete
          action = DB_CHECK_ERROR;
    }

    return action;
}



/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Physically delete an object
 *
 * if fGarbCollectASAP is TRUE,
 *     the object is garbage collected ASAP.
 *     most of the other attributes, EXCLUDING backlinks are stripped.
 *
 * if fGarbCollectASAP is FALSE,
 *     the object is garbage collected if it has no children, or
 *     the children are not real objects
 *
 * pACDel is the index being scanned. Eg, msDS-Entry-Time-To-Die
 *
 *  Returns
 *        ERROR_SUCCESS            - Object was deleted, demoted or skipped
 *        ERROR_DS_CANT_DELETE     - Object could not be deleted
 *        ERROR_DS_CHILDREN_EXIST  - At least one live child exists
 *        <other non-zero error>   - Exception was raised
 *
*/
extern DWORD APIENTRY
DBPhysDel(
    DBPOS FAR   *pDB,
    BOOL        fGarbCollectASAP,
    ATTCACHE    *pACDel
    )
{
    ULONG     cnt;
    char      objval = 0;
    BOOL      fObject;
    DWORD     dwStatus = ERROR_SUCCESS;
    DWORD     dwException;
    ULONG     ulErrorCode;
    ULONG     dsid;
    PVOID     dwEA;
    ATTR      *pAttr;
    DWORD     ncdnt;
    SYNTAX_INTEGER insttype;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ULONG     cbSD;
    BOOL      fWasTombstoned = FALSE;
    ULONG     attrCount,i,j, err;
    JET_SETINFO setinfo;
    BYTE bClean;
    DB_CHECK_ACTION action;

    Assert(VALID_DBPOS(pDB));

    __try {
        /* Retrieve count from record */

        DPRINT1(4, "DBPhysDel entered DNT:%ld\n", (pDB)->DNT);

        fObject = DBCheckObj(pDB);

        DBCancelRec(pDB);


        /* we treat objects and non objects differently: If a record is an
         * object we remove all its attributes to free references to other
         * objects.  We then check the object's reference count and if it's
         * still greater than 1, we mark this as a non-object and return.
         * If the record was a non-object to begin with we just test the
         * reference count and if it's still greater than 1 we just return.
         * In both cases, if the reference count is zero we physically
         * delete the record.
         */

        if (fObject) {

            // if this object has children that are real objects and
            // their time of deletion is
            // in the future (regarding the parent), we are not going to
            // delete this object, but we are going to change the deletion time
            // of this object.

            if ( (fGarbCollectASAP == FALSE) &&
                 ((action = DBCheckToGarbageCollect (pDB, pACDel)) != DB_CHECK_DELETE_OBJECT) ) {

                PDSNAME pDelObj = DBGetCurrentDSName(pDB);

                LogEvent8(DS_EVENT_CAT_GARBAGE_COLLECTION,
                          DS_EVENT_SEV_BASIC,
                          DIRLOG_GC_FAILED_TO_REMOVE_OBJECT,
                          szInsertDN( pDelObj ),
                          szInsertInt(ERROR_DS_CHILDREN_EXIST),
                          szInsertHex(DSID(FILENO, __LINE__)),
                          szInsertWin32Msg(ERROR_DS_CHILDREN_EXIST),
                          NULL, NULL, NULL, NULL );

                THFree (pDelObj);

                switch (action) {
                case DB_CHECK_LIVE_CHILD:
                    // Return a special indication to the caller
                    dwStatus = ERROR_DS_CHILDREN_EXIST;
                    break;
                default:
                    // An error occurred during the check, or deleted children
                    // were found, DBCheckToGarbageCollect() adjusted the object's
                    // deletion time.  This object is already deleted, so we can
                    // skip this object and return success.
                    Assert( dwStatus == ERROR_SUCCESS ); // fObject shouldn't be TRUE otherwise.
                    break;
                }

                // and bail out
                goto ExitTry;
            }

            /*
             * Loop through all attributes , releasing any references to other
             * objects.  This code parallels similar code in mddel.c:SetDelAtt
             * which treats linked attributes as special and removes them at the
             * end.
             */

            dbInitRec(pDB);

            // we don't track quota for non-writable
            // or uninstantiated objects
            //
            JetRetrieveColumnSuccess(
                        pDB->JetSessID,
                        pDB->JetObjTbl,
                        insttypeid,
                        &insttype,
                        sizeof(insttype),
                        NULL,       // pcbActual
                        pDB->JetRetrieveBits,
                        NULL );     // pretinfo

            if ( FQuotaTrackObject( insttype ) ) {
                // QUOTA_UNDONE: I can't tell if what's in the DBPOS
                // is valid, so I'm re-retrieving the NCDNT, which
                // we'll need later to update quota counts
                //
                JetRetrieveColumnSuccess(
                            pDB->JetSessID,
                            pDB->JetObjTbl,
                            ( insttype & IT_NC_HEAD ? dntid : ncdntid ),
                            &ncdnt,
                            sizeof(ncdnt),
                            NULL,       // pcbActual
                            pDB->JetRetrieveBits,
                            NULL );     // pretinfo

                // object must have an SD, which we'll need
                // later to update quota counts
                //
                dwStatus = DBGetAttVal(
                                pDB,
                                1,
                                ATT_NT_SECURITY_DESCRIPTOR,
                                0,
                                0,
                                &cbSD,
                                (UCHAR **)&pSD );
                if ( 0 != dwStatus ) {
                    DPRINT2( 0, "Failed retrieving SD with db error %d (0x%x).\n", dwStatus, dwStatus );
			        DBCancelRec(pDB);
                    SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, dwStatus );
                    goto ExitTry;
                }
                Assert( NULL != pSD );
           	}


            DBGetMultipleAtts(pDB, 0,NULL, NULL, NULL, &attrCount, &pAttr, 0, 0);
            for(i=0;i<attrCount;i++) {
                ATTCACHE *pAC = NULL;

                pAC = SCGetAttById(pDB->pTHS, pAttr[i].attrTyp);

                // We leave the USN_CHANGED on the object because we use this
                // attribute later in the code that updates stale phantoms, and
                // this deletion may be making a phantom.

                switch(pAttr[i].attrTyp) {
                case ATT_RDN:
                case ATT_OBJECT_GUID:
                case ATT_USN_CHANGED:
                case ATT_OBJECT_SID:
                    // These have no extra work to do, we never remove them
                    // here.
                    break;
                // Now a few attrs which we want to be very explicit about
                // removing so no one is in doubt.
                case ATT_PROXIED_OBJECT_NAME:           // for cross dom move
                    DBRemAtt(pDB, pAttr[i].attrTyp);
                    break;

                case ATT_IS_DELETED:
#ifdef DBG            
                    // if Tombstoned attribute present, then it should always be TRUE
                    //
                    Assert( !fWasTombstoned );
                    JetRetrieveColumnSuccess(
                            pDB->JetSessID,
                            pDB->JetObjTbl,
                            isdeletedid,
                            &fWasTombstoned,
                            sizeof(fWasTombstoned),
                            NULL,       // pcbActual
                            pDB->JetRetrieveBits,
                            NULL );     // pretinfo
                    Assert( fWasTombstoned );
#endif
                    fWasTombstoned = TRUE;

                    // FALL THROUGH

                default:
                    if (!pAC || (pAC->ulLinkID == 0)) {
                        // not a special attribute, not a link. kill it.
                        if (!pACDel || (pACDel != pAC)) {
                            // not the index being garbage collected. kill it.
                            DBRemAtt(pDB, pAttr[i].attrTyp);
                        }
                    }
                    break;
                }
                // Free at least some of what we allocated...
                // REVIEW: [jliem - 07/20/02]
                //   DBGetMultipleAtts above is called such that
                //   no attributes are actually fetched, so
                //   we should never actually enter this loop
                Assert( 0 == pAttr[i].AttrVal.valCount );
                for (j=0; j<pAttr[i].AttrVal.valCount; j++) {
                    THFreeEx(pDB->pTHS, pAttr[i].AttrVal.pAVal[j].pVal);
                }
                THFreeEx(pDB->pTHS, pAttr[i].AttrVal.pAVal);
            }
            THFreeEx(pDB->pTHS, pAttr);


            // Physically delete forward links. Not backlinks. See below.
            // Removing all forward links in one pass should make the loop below
            // faster.  Also, when operating in the new linked value mode, the
            // DBRemAtt call would not actually remove links, only marks them.

            // Don't remove backlinks; treat them just like non-link
            // references from other objects.  If this object was deleted
            // by a user, backlinks have already been removed by SetDelAtt()
            // in LocalRemove().  Otherwise, we're removing this object
            // as a part of tearing down a read-only NC, in which case we
            // don't want to delete forward links to this object from
            // objects in other NCs.

            // N.B. PhantomizeObject depends on the !FIsBacklink
            // behavior and the fact that reference count changes
            // aren't visible until the transaction goes back to level
            // zero.  I.e. We expect that no object on whom DBPhysDel
            // is called will immediately be nuked (even if it has
            // no references and ATT_OBJ_DIST_NAME is removed in
            // this loop) because the later "if (cnt)" test will always
            // evaluate to TRUE.

            DBRemoveAllLinks( pDB, (pDB->DNT), FALSE /* use forward link */ );

            // The backlinks have not been removed because the caller
            // is garbage collecting expired dynamic objects (entryTTL == 0).
            // Remove them now.
            if (pACDel && pACDel->id == ATT_MS_DS_ENTRY_TIME_TO_DIE) {
                DBRemoveAllLinks( pDB, (pDB->DNT), TRUE /* use back link */ );
            }

            // update quotas for the object deletion if necessary
            //
            if ( NULL != pSD ) {
                Assert( FQuotaTrackObject( insttype ) );
                dwStatus = ErrQuotaDeleteObject( pDB, ncdnt, pSD, fWasTombstoned );

                // no further need for SD, so free it regardless of whether we
                // succeeded or not
                //
                THFreeEx( pDB->pTHS, pSD );
            }

            if ( 0 != dwStatus ) {
		        DBCancelRec(pDB);
                goto ExitTry;
            }

            /*
             * If this object still has references we're not going to
             * physically delete it but at least we stripped its attributes
             * and we're going to mark it as a non-object.
             */

            memset(&setinfo, 0, sizeof(setinfo));
            setinfo.cbStruct = sizeof(setinfo);
            setinfo.itagSequence = 1;

            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, cntid,
                                     &cnt, sizeof(cnt), NULL,
                                     pDB->JetRetrieveBits, NULL);

            if (cnt)  {
                JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, ncdntid,
                               NULL, 0, 0, &setinfo);

                JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, objid,
                               &objval, sizeof(objval), 0, NULL);

                // Flush entry out of the read cache, since we changed its
                // object flag.
                pDB->fFlushCacheOnUpdate = TRUE;

                DBUpdateRec(pDB);

                goto ExitTry;
            	}
        } else {
            /* not an object */
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, cntid,
                                     &cnt, sizeof(cnt), NULL,
                                     pDB->JetRetrieveBits, NULL);

            if (cnt) {
                // The caller is garbage collecting objects by scanning
                // an index that was created by adding an indexed attribute
                // to the schema. Unfortunately, an index created in this
                // way isn't guaranteed to have unique entries. Tell the
                // caller that this entry should be "skipped" because
                // repeated calls to DBPhysDel will not succeed in
                // removing the object at this time.
                if (pACDel) {
                    dwStatus = ERROR_DS_CANT_DELETE;
                }
                /* still has references */
                goto ExitTry;
            }
        }

#if DBG
        // Sanity check.
        err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                                        cleanid, &bClean, sizeof(bClean),
                                        NULL,pDB->JetRetrieveBits,NULL);
        // The cleaning column must be NULL or present == 0
        Assert( err || (!bClean) );
#endif
        /* Delete record. */

        DPRINT1(2, "DBPhysDel: removing DNT:%ld\n", (pDB)->DNT);

        // Clear pDB->JetRetrieveBits as a side effect of even a failed
        // JetDelete is to cancel a prepared update.

        pDB->JetRetrieveBits = 0;
        JetDeleteEx(pDB->JetSessID, pDB->JetObjTbl);

        // Flush entry out of the read cache.
        dbFlushDNReadCache( pDB, pDB->DNT );

        /* if parent is not root, decrement its reference count */

        if ((pDB)->PDNT != ROOTTAG) {
            DBAdjustRefCount(pDB, pDB->PDNT, -1);
        }
      ExitTry:
        ;
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        DBCancelRec(pDB);
        Assert(ulErrorCode);
        dwStatus = ERROR_DS_CANT_DELETE;
    }

    Assert(0 == pDB->JetRetrieveBits);
    return dwStatus;
}/*DBPhysDel*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Returns name of next entry in deletion index. Search status is kept in
   *pbSecondaryKey and *pbPrimaryBookmark. We use the SZDELTIMEINDEX to position
   and read the current record in sequence. JetGet/GotoSecondaryIndexBookmark
   allows us to remember where we left off in the index and resume the
   next invocation of this function from that point.
*/

DWORD DBGetNextDelRecord(
    DBPOS FAR *     pDB,
    DSTIME          ageOutDate,
    DSNAME **       ppRetBuf,
    BYTE *          pbSecondaryKey,
    const ULONG     cbSecondaryKey,
    BYTE *          pbPrimaryBookmark,
    const ULONG     cbPrimaryBookmark,
    BOOL *          pfObject )
{
    JET_ERR         err;
    ULONG           actuallen;
    DSTIME          time;
    DSTIME          newDeltime      = DBTime();
    BOOL            HasDeleted;
    BOOL            Deleted;
    DWORD           RefCount;
    DSNAME *        pDNTmp          = NULL;
    JET_SETINFO     setinfo;
#if DBG
    ULONG           cbSecondaryKeyActual;
    ULONG           cbPrimaryBookmarkActual;
#endif

    DPRINT1( 2, "DBGetNextDelRec entered: ageOutDate [0x%I64x]\n", ageOutDate );
    Assert(VALID_DBPOS(pDB));
    Assert(0 == pDB->JetRetrieveBits);

    DBSetCurrentIndex(pDB, Idx_Del, NULL, FALSE);

    //  move to where we last left off from
    //
    JetGotoSecondaryIndexBookmarkEx(
                pDB->JetSessID,
                pDB->JetObjTbl,
                pbSecondaryKey,
                cbSecondaryKey,
                pbPrimaryBookmark,
                cbPrimaryBookmark,
                JET_bitBookmarkPermitVirtualCurrency );

    // Phantoms are created with a delete time set and they do not have
    // a ref-count for themselves - see comments in sbTableAddRefHelp().
    // So we need to iterate over the index and return only those items
    // which either have ATT_IS_DELETED set (real object case) or don't
    // have an ATT_IS_DELETED property and a ref count of 0 (phantom case).
    // We can't do this test in Garb_Collect() as it is above the dblayer
    // and the cnt_col is not visible.

    while ( TRUE )
    {
        //  currency should now be on the last record processed, so
        //  must move to the next record
        //
        err = JetMoveEx( pDB->JetSessID, pDB->JetObjTbl, JET_MoveNext, NO_GRBIT );
        if ( JET_errNoCurrentRecord == err )
            {
            DPRINT(5, "GetNextDelRecord search complete");
            return DB_ERR_NO_MORE_DEL_RECORD;
            }

        /* Retrieve DEL time from record */

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl,
                    deltimeid, &time, sizeof(time), &actuallen,
                    JET_bitRetrieveFromIndex, NULL);

        /* if time greater than target, there are no more eligible records */

        if (time > ageOutDate)
        {
            DPRINT(5, "GetNextDelRecord search complete");
            return DB_ERR_NO_MORE_DEL_RECORD;
        }

        //  save off the bookmark so we can resume later
        //
#if DBG
        err = JetGetSecondaryIndexBookmarkEx(
                        pDB->JetSessID,
                        pDB->JetObjTbl,
                        pbSecondaryKey,
                        cbSecondaryKey,
                        &cbSecondaryKeyActual,
                        pbPrimaryBookmark,
                        cbPrimaryBookmark,
                        &cbPrimaryBookmarkActual );
        Assert( JET_errSuccess == err );
        Assert( cbPrimaryBookmark == cbPrimaryBookmarkActual );
        Assert( cbSecondaryKey == cbSecondaryKeyActual );
#else
        err = JetGetSecondaryIndexBookmarkEx(
                        pDB->JetSessID,
                        pDB->JetObjTbl,
                        pbSecondaryKey,
                        cbSecondaryKey,
                        NULL,               //  key length should be fixed, so don't need to retrieve actual length
                        pbPrimaryBookmark,
                        cbPrimaryBookmark,
                        NULL );             //  key length should be fixed, so don't need to retrieve actual length
#endif

        if ( JET_errSuccess != err ) {
            //  all errors except JET_errNoCurrentIndex are trapped
            //  by the function wrapper, but it should be
            //  impossible to get this error here because we
            //  should be on the SZDELTIMEINDEX
            //
            Assert( FALSE );
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }

        /* Get the name */

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, dntid,
                    &(pDB)->DNT, sizeof((pDB)->DNT),
                    &actuallen, JET_bitRetrieveFromPrimaryBookmark, NULL);

        if (sbTableGetDSName(pDB, (pDB)->DNT, &pDNTmp,0)) {
            DPRINT( 1, "DBGetNextDelRecord: Failed looking up DN name.\n" );
            return  DB_ERR_DSNAME_LOOKUP_FAILED;
        }

        /* Get the parent since we will need to de-ref it later */

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, pdntid,
                    &(pDB)->PDNT, sizeof((pDB)->PDNT),
                    &actuallen, 0, NULL);

        // Check real object and phantom conditions.

        err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                   isdeletedid, &Deleted, sizeof(Deleted), &actuallen, 0, NULL);

        if (!err) {
            HasDeleted = TRUE;
        }
        else {
            // Record has deletion time but no "is deleted" attribute -- it must
            // be a phantom.
            Assert(JET_wrnColumnNull == err);
            HasDeleted = FALSE;
        }

        if ( HasDeleted )
        {
            if ( !Deleted )
            {
                DPRINT1(0,"Yikes! Tried to physically remove live object %ws\n",
                        pDNTmp->StringName);
                goto TryAgain;
            }
            else
            {
                DPRINT1(2,"Real object garbage candidate %ws\n",
                        pDNTmp->StringName);
            }
        }
        else
        {
            // Assume it's a phantom.
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, cntid,
                        &RefCount, sizeof(RefCount),
                        &actuallen, 0, NULL);

            if ( 0 != RefCount )
            {
                // Skip phantoms which are still in use.
                DPRINT1(2,"Skipping in-use phantom %ws\n",
                        pDNTmp->StringName);

                // But first modify their delete times to current time so that
                // they would not be looked at again during this tombstone
                // lifetime by the garbage collector

                setinfo.cbStruct = sizeof(setinfo);
                setinfo.ibLongValue = 0;
                setinfo.itagSequence = 1;

                JetPrepareUpdate(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
                JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, deltimeid,
                               &newDeltime, sizeof(newDeltime), 0, &setinfo);
                JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);

                // We don't commit here, it will be committed by the
                // calling function (Garb_Collect)

                // go to the next entry
                goto TryAgain;
            }
            else
            {
                DPRINT1(2,"Phantom garbage candidate %ws\n",
                        pDNTmp->StringName);
            }
        }

        pDB->JetNewRec = FALSE;
        pDB->fFlushCacheOnUpdate = FALSE;

        *pfObject = DBCheckObj(pDB);

        DPRINT1(2, "DBGetNextDelRecord DNT to delete:%ld.\n", (pDB)->DNT);

        *ppRetBuf = pDNTmp;
        Assert(0 == pDB->JetRetrieveBits);
        return 0;

      TryAgain:
        Assert(0 == pDB->JetRetrieveBits);
        if (pDNTmp) {
            THFreeEx(pDB->pTHS, pDNTmp);
            pDNTmp = NULL;
        }
    }
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Returns next entry in ms-DS-Entry-Time-To-Die (EntryTTL) index.
   Search status is kept in *pulLastTime. The index is in ascending order.
*/

DWORD DBGetNextEntryTTLRecord(
    IN  DBPOS       *pDB,
    IN  DSTIME      ageOutDate,
    IN  ATTCACHE    *pAC,
    IN  ULONG       ulNoDelDnt,
    OUT DSNAME      **ppRetBuf,
    OUT DSTIME      *pulLastTime,
    OUT BOOL        *pfObject,
    OUT ULONG       *pulNextSecs
    )
{
    JET_ERR     err;
    ULONG       actuallen;
    DSTIME      time;
    DSNAME      *pDNTmp = NULL;
    BOOL        SkippedNoDelRecord;

    DPRINT1( 2, "DBGetNextEntryTTLRec entered: ageOutDate [0x%I64x]\n", ageOutDate );
    Assert(VALID_DBPOS(pDB));
    Assert(0 == pDB->JetRetrieveBits);

    // set index to ms-DS-Entry-Time-To-Die
    err = DBSetCurrentIndex(pDB, 0, pAC, FALSE);
    if (err) {
        DPRINT1(0, "DBSetCurrentIndex(msDS-Entry-Time-To-Die); %08x\n", err);
        return DB_ERR_NO_MORE_DEL_RECORD;
    }

    // Seek to the next (or first) record
    JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
                pulLastTime, sizeof(*pulLastTime), JET_bitNewKey);
    err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekGE);
    if (err != JET_errSuccess && err != JET_wrnSeekNotEqual) {
        return DB_ERR_NO_MORE_DEL_RECORD;
    }

    //
    // If necessary, skip over an undeletable record.
    // Eg, a record may be undeletable if it has children.
    //

    SkippedNoDelRecord = (ulNoDelDnt == INVALIDDNT);
NextRecord:
    // Retrieve the time-to-die from the record
    if ((err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                                         pAC->jColid,
                                         &time, sizeof(time), &actuallen,
                                         0, NULL)) != JET_errSuccess) {
        return DB_ERR_NO_MORE_DEL_RECORD;
    }

    // Not expired; done
    if (time > ageOutDate) {
        *pulNextSecs = (ULONG)(time - ageOutDate);
        return DB_ERR_NO_MORE_DEL_RECORD;
    }

    // Get the dnt
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, dntid,
                &(pDB)->DNT, sizeof((pDB)->DNT), &actuallen, 0, NULL);

    // If there is a record we can't delete, find it and skip it
    if (!SkippedNoDelRecord && time == *pulLastTime) {
        // Found it!
        if (ulNoDelDnt == pDB->DNT) {
            SkippedNoDelRecord = TRUE;
        }
        // Next record
        if ((err = JetMoveEx(pDB->JetSessID,
                             pDB->JetObjTbl,
                             JET_MoveNext, 0)) != JET_errSuccess) {
            return DB_ERR_NO_MORE_DEL_RECORD;
        }
        goto NextRecord;
    }

    //
    // Found a record to delete; gather more info about it
    //

    // Get the record's name
    if (sbTableGetDSName(pDB, (pDB)->DNT, &pDNTmp,0)) {
        DPRINT( 1, "DBGetNextEntryTTLRecord: Failed looking up DN name.\n" );
        return  DB_ERR_DSNAME_LOOKUP_FAILED;
    }

    // Get the parent since we will need to de-ref it later
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, pdntid,
                &(pDB)->PDNT, sizeof((pDB)->PDNT),
                &actuallen, 0, NULL);


    pDB->JetNewRec = FALSE;
    pDB->fFlushCacheOnUpdate = FALSE;

    // is this an object?
    *pfObject = DBCheckObj(pDB);

    // return object's DSNAME and TimeToDie
    *ppRetBuf = pDNTmp;
    *pulLastTime = time;

    DPRINT2(2,"Garbage candidate (EntryTTL) %08x %ws\n",
            pDB->DNT, pDNTmp->StringName);

    Assert(0 == pDB->JetRetrieveBits);
    return 0;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add an entry to the delete index.  The delete index is based on the
   delete time field which is created NULL in records.  This function
   moves the current ATT_WHEN_CHANGED value to the delete time field.
   It is the caller's responsibility to ensure that the last change was
   to add the ISDELETTED attribute.

   The exception to this rule is if fGarbCollectASAP is set, which implies
   that this object should be marked with a delete time such that garbage
   collection will process it as soon as possible.  This is typically used
   when removing a read-only NC, in which case we want to clean out the
   removed objects immediately.
*/
DWORD
DBAddDelIndex( DBPOS FAR *pDB, BOOL fGarbCollectASAP )
{
    DSTIME      time;
    JET_SETINFO setinfo;

    /* make sure record is in copy buffer */

    DPRINT1(2, "DBAddDelIndex entered DNT:%ld\n", (pDB)->DNT);
    Assert(VALID_DBPOS(pDB));

    DBFindDNT(pDB, (pDB)->DNT);

    if ( fGarbCollectASAP ) {
        // Choose a deletion time far in the past.

        time = 1;
    }
    else {
        // The deletion time is the time at which is-deleted was set.

        PROPERTY_META_DATA_VECTOR * pMetaDataVec;
        PROPERTY_META_DATA * pMetaData;
        ULONG cb;
        int i;

        if (   ( 0 != DBGetAttVal(pDB, 1, ATT_REPL_PROPERTY_META_DATA,
                                  0, 0, &cb, (LPBYTE *) &pMetaDataVec) )
            || ( NULL == ( pMetaData = ReplLookupMetaData(
                                            ATT_IS_DELETED,
                                            pMetaDataVec,
                                            NULL
                                            )
                         )
               )
           )
        {
            Assert( !"Cannot retrieve deletion time!" );
            return DB_ERR_CANT_ADD_DEL_KEY;
        }

        time = pMetaData->timeChanged;

        THFreeEx(pDB->pTHS,  pMetaDataVec );
    }

    DPRINT2(5, "DBAddDelIndex time:%lx DNT:%ld\n", time, (pDB)->DNT);

    /* Set Del time index field & update record */

    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 1;

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, deltimeid, (char*)&time,
                   sizeof(time), 0, &setinfo);
    JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);

    return 0;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Find the first, next or specific object in the data table . Uses DNT index
   NOTE: THIS ROUTINE FOR DEBUG ONLY
*/
extern DWORD APIENTRY
DBDump(DBPOS FAR *pDB, long tag)
{
    JET_ERR  err=0;
    ULONG    actuallen;

    DPRINT(2, "DBDump start\n");
    Assert(VALID_DBPOS(pDB));

    switch (tag)
    {
        case 0:
            DPRINT(5, "DBDump: Initialize dump\n");
            DBCancelRec(pDB);
            DBSetCurrentIndex(pDB, Idx_Dnt, NULL, FALSE);

            if ((err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveFirst, 0)) != JET_errSuccess)
            {
                DPRINT1(1, "JetMove (First) error: %d\n", err);
                return 1;
            }

            if ((err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveNext, 0)) != JET_errSuccess)
            {
                DPRINT1(1, "JetMove (rec2) error: %d\n", err);
                return 1;
            }

        case 1:
            DPRINT(5, "DBDump: record\n");
            if ((err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveNext, 0))
                                                           != JET_errSuccess)
            {
                DPRINT1(1, "JetMove (Next) error: %d\n", err);
                return 1;
            }

            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, dntid,
                                   &(pDB)->DNT, sizeof((pDB)->DNT), &actuallen,
                                   0, NULL);
            break;

        case -1:
            DPRINT(5, "DBDump: ROOT record\n");

            __try
            {
                DBFindDNT(pDB, ROOTTAG);
            }
            __except(HandleMostExceptions(GetExceptionCode()))
            {
                DPRINT1(1, "FindDNT error:%d ROOT\n", err);
                return 1;
            }
            break;

        default:
            DPRINT(5, "DBDump: Specific record\n");
            __try
            {
                DBFindDNT(pDB, tag);
            }
            __except(HandleMostExceptions(GetExceptionCode()))
            {
                DPRINT2(1, "FindDNT error:%d tag:ld\n", err, tag);
                return 1;
            }
            break;
   }

   DPRINT(2, "DBDump Sucessful\n");
   return 0;

}/*DBDump*/

/*++

Routine Description:

    Given an attribute type and a syntax, create an index over that type.  The
    name of the index encodes the type.  The syntax is used to decide whether to
    tack the DNT column onto the end of the index to avoid an index over values
    which take small ranges (e.g. booleans), which are very inneficient in Jet.
    Requires opening a complete new session to Jet to get to transaction level
    0.

    We can make indices where the first column is the attribute or the first
    column is the PDNT followed by the attribute.

    This is one of the three routines in the DS that can create indices.
    General purpose indices over single columns in the datatable are created
    and destroyed by the schema cache by means of DB{Add|Del}ColIndex.
    Localized indices over a small fixed set of columns and a variable set
    of languages, for use in tabling support for NSPI clients, are handled
    in dbCheckLocalizedIndices.  Lastly, a small fixed set of indices that
    should always be present are guaranteed by DBRecreateRequiredIndices.

Arguments:

    aid - the attribute type of the column to index.

    syntax - the syntax of the column.

    eSearchFlags - flags describing what kind of index to create (just the
    attribute or PDNT then the attribute.)

    CommonGrbit - grbits that should be enabled when creating an
    index. Eg, there is no need to scan the rows looking for keys when
    when creating a new indexed attribute, so the grbits should be:
        (JET_bitIndexIgnoreAnyNull | JET_bitIndexEmpty)
    but when changing the searchflags on an existing attribute to be "indexed":
        (JET_bitIndexIgnoreAnyNull)

Return Values:

    Returns 0 if all went well, a Jet error code otherwise.

--*/
int
DBAddColIndex (
        ATTCACHE *pAC,
        DWORD eSearchFlags,
        JET_GRBIT CommonGrbit
        )
{
    char        szColname[16];

    char        szIndexName[MAX_INDEX_NAME];
    BYTE        rgbIndexDef[128];
    ULONG       cb = 0;      //initialized to avoid C4701

    char        szPDNTIndexName[MAX_INDEX_NAME];
    BYTE        rgbPDNTIndexDef[128];
    ULONG       cbPDNT = 0;  //initialized to avoid C4701

    char        szTupleIndexName[MAX_INDEX_NAME];
    BYTE        rgbTupleIndexDef[128];
    ULONG       cbTuple = 0;  //initialized to avoid C4701

    BYTE        *pb;
    JET_ERR     err, retCode = 0;
    JET_SESID   newSesid;
    JET_TABLEID newTblid;
    JET_DBID      newDbid;
    JET_INDEXCREATE  indexCreate;
    JET_UNICODEINDEX unicodeIndexData;
    JET_CONDITIONALCOLUMN condColumn;
    ATTRTYP     aid = pAC->id;
    unsigned    syntax = pAC->syntax;

    // Create an index, if the syntax will stand for it.

    if (syntax_jet[syntax].ulIndexType) {
        sprintf(szColname, "ATTa%d", aid);
        szColname[3] += (CHAR)syntax;

        if(eSearchFlags & fATTINDEX) {
            // An attribute index over the whole database has been requested.
            DBGetIndexName (pAC, fATTINDEX, DS_DEFAULT_LOCALE,
                            szIndexName, MAX_INDEX_NAME);

            memset(rgbIndexDef, 0, sizeof(rgbIndexDef));
            strcpy(rgbIndexDef, "+");
            strcat(rgbIndexDef, szColname);
            cb = strlen(rgbIndexDef) + 1;

            cb +=1;
        }
        if(eSearchFlags & fTUPLEINDEX) {
            // An attribute index over the whole database has been requested.
            Assert(syntax == SYNTAX_UNICODE_TYPE);
            DBGetIndexName (pAC, fTUPLEINDEX, DS_DEFAULT_LOCALE,
                            szTupleIndexName, MAX_INDEX_NAME);

            memset(rgbTupleIndexDef, 0, sizeof(rgbTupleIndexDef));
            strcpy(rgbTupleIndexDef, "+");
            strcat(rgbTupleIndexDef, szColname);
            cbTuple = strlen(rgbTupleIndexDef) + 1;

            cbTuple +=1;
        }
        if(eSearchFlags & fPDNTATTINDEX) {
            PCHAR pTemp = rgbPDNTIndexDef;

            // An attribute index over the PDNT field  has been requested.
            DBGetIndexName (pAC, fPDNTATTINDEX, DS_DEFAULT_LOCALE,
                            szPDNTIndexName, sizeof (szPDNTIndexName));

            memset(rgbPDNTIndexDef, 0, sizeof(rgbPDNTIndexDef));
            strcpy(pTemp, "+");
            strcat(pTemp, SZPDNT);
            cbPDNT = strlen(pTemp) + 1;
            pTemp = &rgbPDNTIndexDef[cbPDNT];
            strcpy(pTemp, "+");
            strcat(pTemp, szColname);
            cbPDNT += strlen(pTemp) + 1;
            pTemp = &rgbPDNTIndexDef[cbPDNT];
            cbPDNT++;
        }

        // We need to open an entirely new session, etc.  in order to be at
        // transaction level 0 (it's a requirement of Jet.)
        err = JetBeginSession(jetInstance, &newSesid, szUser, szPassword);
        if(!err) {
            err = JetOpenDatabase(newSesid, szJetFilePath, "", &newDbid, 0);
            if(!err) {
                err = JetOpenTable(newSesid, newDbid, SZDATATABLE, NULL, 0, 0,
                                   &newTblid);
                if(!err) {
                    if(eSearchFlags & fPDNTATTINDEX) {

                        // we already have an index for RDN
                        // don't bother creating a new one.
                        // do this only for different langs
                        if (aid != ATT_RDN) {

                            // Emit message so people know why startup is slow.
                            DPRINT2(0, "Creating index '%s' with common grbits %08x ...\n",
                                    szPDNTIndexName, CommonGrbit);

                            memset(&indexCreate, 0, sizeof(indexCreate));
                            indexCreate.cbStruct = sizeof(indexCreate);
                            indexCreate.szIndexName = szPDNTIndexName;
                            indexCreate.szKey = rgbPDNTIndexDef;
                            indexCreate.cbKey = cbPDNT;
                            indexCreate.grbit = CommonGrbit;
                            indexCreate.ulDensity = GENERIC_INDEX_DENSITY;
                            if(syntax != SYNTAX_UNICODE_TYPE) {
                                indexCreate.lcid = DS_DEFAULT_LOCALE;
                            }
                            else {
                                indexCreate.grbit |= JET_bitIndexUnicode;
                                indexCreate.pidxunicode = &unicodeIndexData;

                                memset(&unicodeIndexData, 0,
                                       sizeof(unicodeIndexData));
                                unicodeIndexData.lcid = DS_DEFAULT_LOCALE;
                                unicodeIndexData.dwMapFlags =
                                    (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                                     LCMAP_SORTKEY);
                            }

                            err = JetCreateIndex2(newSesid,
                                                  newTblid,
                                                  &indexCreate,
                                                  1);

                            if ( err ) {
                                if (err != JET_errIndexDuplicate) {
                                    DPRINT1(0, "Error %d creating index\n", err);
                                }
                            }
                            else {
                                DBGetIndexHint(indexCreate.szIndexName,
                                               &pAC->pidxPdntIndex);
                                DPRINT(0, "Index successfully created\n");
                            }
                        }
                        else {
                            DPRINT (0, "Skipping creating of index for PDNTRDN\n");
                        }

                        // now do the language specific PDNT index creations
                        if (gAnchor.ulNumLangs) {
                            DWORD j;

                            for(j=1; j<=gAnchor.ulNumLangs; j++) {

                                // we don't want to create an index for a language same as our default
                                if (gAnchor.pulLangs[j] == DS_DEFAULT_LOCALE) {
                                    continue;
                                }

                                DBGetIndexName (pAC,
                                                fPDNTATTINDEX,
                                                gAnchor.pulLangs[j],
                                                szPDNTIndexName,
                                                sizeof (szPDNTIndexName));

                                if (JetSetCurrentIndex(newSesid,
                                                       newTblid,
                                                       szPDNTIndexName)) {

                                    // Didn't already find the index.  Try to create it.
                                    // Emit debugger message so people know why startup is slow.
                                    DPRINT2(0, "Creating localized index '%s' with common grbits %08x ...\n",
                                            szPDNTIndexName, CommonGrbit);

                                    memset(&indexCreate, 0, sizeof(indexCreate));
                                    indexCreate.cbStruct = sizeof(indexCreate);
                                    indexCreate.szIndexName = szPDNTIndexName;
                                    indexCreate.szKey = rgbPDNTIndexDef;
                                    indexCreate.cbKey = cbPDNT;
                                    indexCreate.grbit = (CommonGrbit | JET_bitIndexUnicode);
                                    indexCreate.ulDensity = GENERIC_INDEX_DENSITY;
                                    indexCreate.pidxunicode = &unicodeIndexData;

                                    memset(&unicodeIndexData, 0, sizeof(unicodeIndexData));
                                    unicodeIndexData.lcid = gAnchor.pulLangs[j];
                                    unicodeIndexData.dwMapFlags =
                                        (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                                         LCMAP_SORTKEY);

                                    retCode = JetCreateIndex2(newSesid,
                                                          newTblid,
                                                          &indexCreate,
                                                          1);

                                    switch(retCode) {
                                    case JET_errIndexDuplicate:
                                    case 0:
                                        break;

                                    default:
                                        LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                                 DS_EVENT_SEV_ALWAYS,
                                                 DIRLOG_LOCALIZED_CREATE_INDEX_FAILED,
                                                 szInsertUL(pAC->id),
                                                 szInsertSz(pAC->name),
                                                 szInsertInt(gAnchor.pulLangs[j]),
                                                 szInsertInt(retCode),
                                                 szInsertJetErrMsg(retCode),
                                                 NULL, NULL, NULL);

                                        if (!err) {
                                            err = retCode;
                                        }
                                        break;
                                    }
                                }
                                else {
                                    DPRINT1(1, "Index '%s' verified\n", szPDNTIndexName);
                                }
                            }
                        }
                    }


                    if(eSearchFlags & fATTINDEX) {
                        // Emit message so people know why startup is slow.
                        DPRINT2(0, "Creating index '%s' with common grbits %08x ...\n",
                                szIndexName, CommonGrbit);
                        memset(&indexCreate, 0, sizeof(indexCreate));
                        indexCreate.cbStruct = sizeof(indexCreate);
                        indexCreate.szIndexName = szIndexName;
                        indexCreate.szKey = rgbIndexDef;
                        indexCreate.cbKey = cb;
                        indexCreate.grbit = CommonGrbit;
                        indexCreate.ulDensity = GENERIC_INDEX_DENSITY;
                        if(syntax != SYNTAX_UNICODE_TYPE) {
                            indexCreate.lcid = DS_DEFAULT_LOCALE;
                        }
                        else {
                            indexCreate.pidxunicode = &unicodeIndexData;
                            indexCreate.grbit |= JET_bitIndexUnicode;

                            memset(&unicodeIndexData, 0,
                                   sizeof(unicodeIndexData));
                            unicodeIndexData.lcid = DS_DEFAULT_LOCALE;
                            unicodeIndexData.dwMapFlags =
                                (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                                 LCMAP_SORTKEY);
                        }

                        retCode = JetCreateIndex2(newSesid,
                                               newTblid,
                                               &indexCreate,
                                               1);
                        if ( retCode ) {
                            DPRINT1(0, "Error %d creating index\n", retCode);
                        }
                        else {
                            DBGetIndexHint(indexCreate.szIndexName,
                                           &pAC->pidxIndex);
                            DPRINT(0, "Index successfully created\n");
                        }
                    }
                    if(eSearchFlags & fTUPLEINDEX) {
                        // Emit message so people know why startup is slow.
                        DPRINT2(0, "Creating index '%s' with common grbits %08x ...\n",
                                szTupleIndexName, CommonGrbit);
                        memset(&indexCreate, 0, sizeof(indexCreate));
                        indexCreate.cbStruct = sizeof(indexCreate);
                        indexCreate.szIndexName = szTupleIndexName;
                        indexCreate.szKey = rgbTupleIndexDef;
                        indexCreate.cbKey = cbTuple;
                        indexCreate.grbit = CommonGrbit | JET_bitIndexTuples | JET_bitIndexUnicode;
                        indexCreate.ulDensity = GENERIC_INDEX_DENSITY;
                        indexCreate.pidxunicode = &unicodeIndexData;
                        indexCreate.rgconditionalcolumn = &condColumn;
                        indexCreate.cConditionalColumn = 1;

                        // Only index substrings if this object isn't deleted.
                        condColumn.cbStruct = sizeof(condColumn);
                        condColumn.szColumnName = SZISDELETED;
                        condColumn.grbit = JET_bitIndexColumnMustBeNull;

                        memset(&unicodeIndexData, 0,
                               sizeof(unicodeIndexData));
                        unicodeIndexData.lcid = DS_DEFAULT_LOCALE;
                        unicodeIndexData.dwMapFlags =
                            (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                             LCMAP_SORTKEY);

                        retCode = JetCreateIndex2(newSesid,
                                               newTblid,
                                               &indexCreate,
                                               1);
                        if ( retCode ) {
                            DPRINT1(0, "Error %d creating index\n", retCode);
                            DPRINT1(0, "indexCreate @ %p\n", &indexCreate);
                        }
                        else {
                            DBGetIndexHint(indexCreate.szIndexName,
                                           &pAC->pidxTupleIndex);
                            DPRINT(0, "Index successfully created\n");
                        }
                    }
                    if(!err)
                        err = retCode;
                }
            }
            JetEndSession(newSesid, 0);
        }
    }
    else
        err = 1;

    return err;
}


/*++

Routine Description:

    Given an attribute type, delete an index over that attribute.  The name of
    the index encodes the type.  Requires opening a complete new session
    to Jet to get to transaction level 0.

Arguments:

    aid - the attribute type of the column to quit indexing.

    eSearchFlags - the search flags describing which kind of index to destroy

Return Values:

    Returns 0 if all went well, a Jet error code otherwise.

--*/
int
DBDeleteColIndex (
        ATTRTYP aid,
        DWORD eSearchFlags
        )
{
    char        szIndexName[MAX_INDEX_NAME];
    char        szPDNTIndexName[MAX_INDEX_NAME];
    char        szTupleIndexName[MAX_INDEX_NAME];
    JET_ERR     err, err2=0;
    JET_SESID     newSesid;
    JET_TABLEID   newTblid;
    JET_DBID      newDbid;

    // Delete an index.
    if(eSearchFlags & fPDNTATTINDEX)
        sprintf(szPDNTIndexName, SZATTINDEXPREFIX"%c_%08X", CHPDNTATTINDEX_PREFIX, aid);
    if(eSearchFlags & fATTINDEX)
        sprintf(szIndexName, SZATTINDEXPREFIX"%08X", aid);
    if(eSearchFlags & fTUPLEINDEX)
        sprintf(szTupleIndexName, SZATTINDEXPREFIX"%c_%08X", CHTUPLEATTINDEX_PREFIX, aid);

    err = JetBeginSession(jetInstance, &newSesid, szUser, szPassword);
    if(!err) {
        err = JetOpenDatabase(newSesid, szJetFilePath, "", &newDbid, 0);
        if(!err) {
            err = JetOpenTable(newSesid, newDbid, SZDATATABLE, NULL, 0, 0,
                               &newTblid);
            if(!err) {
                if(eSearchFlags & fATTINDEX)
                    err = JetDeleteIndex(newSesid, newTblid, szIndexName);
                if(eSearchFlags & fPDNTATTINDEX)
                    err2 = JetDeleteIndex(newSesid, newTblid, szPDNTIndexName);
                if(!err)
                    err = err2;

                if(eSearchFlags & fTUPLEINDEX)
                    err2 = JetDeleteIndex(newSesid, newTblid, szTupleIndexName);
                if(!err)
                    err = err2;
            }

        }
        // JET_bitDbForceClose not supported in Jet600.
        // REVIEW:  this is no longer necessary
        JetCloseDatabase(newSesid, newDbid, 0);
    }
    // REVIEW:  JET_bitForceSessionClosed is no longer necessary
    JetEndSession(newSesid, JET_bitForceSessionClosed);


    return err;
}

/*++

Routine Description:

    Given an attribute type and a syntax, create a column in the database.  The
    name of the column encodes the type and syntax.  Requires opening a complete
    new session to Jet to get to transaction level 0.

    Returns the Jet column id of the newly created column.

    Also, if asked we will create an index over the newly formed column.

Arguments:

    aid - the attribute type of the column to create.

    syntax - the syntax of the column to create.

    pjCol - place to drop the Jet columnid of the newly created column.

    fCreateIndex - Should we also create an index for the column?

Return Values:

    Returns 0 if all went well, a Jet error code otherwise.

--*/
int
DBAddCol (
        ATTCACHE *pAC
        )
{
    char        szColname[16];
    JET_COLUMNDEF coldef;
    JET_SESID     newSesid;
    JET_TABLEID   newTblid;
    JET_DBID      newDbid;
    JET_ERR       err;

    sprintf(szColname, "ATTa%d", pAC->id);
    szColname[3] += (UCHAR)pAC->syntax;

    coldef.cbStruct = sizeof(coldef);
    coldef.columnid = 0;
    coldef.cp = syntax_jet[pAC->syntax].cp;
    coldef.coltyp = syntax_jet[pAC->syntax].coltype;
    coldef.wCountry = 0;
    coldef.wCollate = 0;
    coldef.langid = GetUserDefaultLangID();
    coldef.cbMax = syntax_jet[pAC->syntax].colsize;
    coldef.grbit = JET_bitColumnTagged | JET_bitColumnMultiValued;

    // We need to open an entirely new session, etc.  in order to be at
    // transaction level 0 (it's a requirement of Jet.)
    err = JetBeginSession(jetInstance, &newSesid, szUser, szPassword);
    if(!err) {
        err = JetOpenDatabase(newSesid, szJetFilePath, "", &newDbid, 0);
        if(!err) {
            err = JetOpenTable(newSesid, newDbid, SZDATATABLE, NULL, 0, 0,
                               &newTblid);
            if(!err)
                err = JetAddColumn(newSesid, newTblid, szColname, &coldef, NULL,
                                   0,&pAC->jColid);
            // JET_bitDbForceClose not supported in Jet600.
            // REVIEW:  this is no longer necessary
            JetCloseDatabase(newSesid, newDbid, 0);
        }
        // REVIEW:  JET_bitForceSessionClosed is no longer necessary
        JetEndSession(newSesid, JET_bitForceSessionClosed);
    }
    // Create an empty index for the new tagged column. An empty index is
    // created because there can't be rows with columns for this index.
    // It is, after all, a new column.
    if (!err && (pAC->fSearchFlags & (fATTINDEX | fPDNTATTINDEX | fTUPLEINDEX))) {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SCHEMA_CREATING_INDEX,
                 szInsertUL(pAC->id), pAC->name, 0);
        err = DBAddColIndex(pAC,
                            pAC->fSearchFlags,
                            (JET_bitIndexIgnoreAnyNull | JET_bitIndexEmpty));
        if(err) {
            LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_SCHEMA_CREATE_INDEX_FAILED,
                      szInsertUL(pAC->id),
                      szInsertSz(pAC->name),
                      szInsertJetErrCode(err),
                      szInsertJetErrMsg(err),
                      NULL,
                      NULL,
                      NULL,
                      NULL );

        } else {
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_SCHEMA_INDEX_CREATED,
                     szInsertUL(pAC->id), szInsertSz(pAC->name), 0);
        }
    }

    return err;
}

/*++

Routine Description:

    Given an attribute type and a syntax, destroy a column in the database.  The
    name of the column encodes the type and syntax.  Requires opening a complete
    new session to Jet to get to transaction level 0.

Arguments:

    aid - the attribute type of the column to create.

    syntax - the syntax of the column to create.

Return Values:

    Returns 0 if all went well, a Jet error code otherwise.

--*/
int
DBDeleteCol (
        ATTRTYP aid,
        unsigned syntax
        )
{
    JET_SESID     newSesid;
    JET_TABLEID   newTblid;
    JET_DBID      newDbid;
    JET_ERR       err;
    char        szColname[16];

    sprintf(szColname, "ATTa%d", aid);
    szColname[3] += (CHAR)syntax;

    // We need to open an entirely new session, etc.  in order to be at
    // transaction level 0 (it's a requirement of Jet.)
    if(!(err = JetBeginSession(jetInstance, &newSesid, szUser, szPassword))) {
        if(!(err = JetOpenDatabase(newSesid, szJetFilePath, "", &newDbid, 0))) {
            if(!(err = JetOpenTable(newSesid,
                                    newDbid,
                                    SZDATATABLE,
                                    NULL,
                                    0,
                                    0,
                                    &newTblid))) {
                err = JetDeleteColumn(newSesid, newTblid, szColname);
            }
            // JET_bitDbForceClose not supported in Jet600.
            // REVIEW:  this is no longer necessary
            JetCloseDatabase(newSesid, newDbid, 0);
        }
        // REVIEW:  JET_bitForceSessionClosed is no longer necessary
        JetEndSession(newSesid, JET_bitForceSessionClosed);
    }
    return err;
}



USN
DBGetLowestUncommittedUSN (
        )
/*++

Routine Description:

    Return the lowest uncommitted usn.
    NOTE: If there are no outstanding transactions, will return USN_MAX.

Arguments:

    None.

Return Values:

    The lowest uncommited USN.

--*/
{
    USN usnLowest = 0;
    EnterCriticalSection (&csUncUsn);
    __try {
        usnLowest = gusnLowestUncommitted;
    }
    __finally {
        LeaveCriticalSection (&csUncUsn);
    }

    return usnLowest;
}

USN
DBGetHighestCommittedUSN (
        )
/*++

Routine Description:

    Return the highest committed usn.

Arguments:

    None.

Return Values:

    The highest commited USN.

--*/
{
    USN usnHighestCommitted = 0;

    EnterCriticalSection( &csUncUsn );

    __try
    {
        if ( USN_MAX != gusnLowestUncommitted )
        {
            // there are threads with uncommitted transactions
            usnHighestCommitted = gusnLowestUncommitted - 1;
        }
        else
        {
            // no transactions outstanding; highest committed is
            // just what the next USN to be given out is, minus 1
            usnHighestCommitted = gusnEC - 1;
        }
    }
    __finally
    {
        LeaveCriticalSection( &csUncUsn );
    }

    return usnHighestCommitted;
}

DWORD
DBGetIndexHint(
               IN  char *pszIndexName,
               OUT struct tagJET_INDEXID **ppidxHint)
{
    DWORD   err     = DB_ERR_DATABASE_ERROR;
    DBPOS*  pDBtmp  = NULL;

    *ppidxHint = NULL;

    __try {
        JET_INDEXID     indexInfo   = { 0 };
        DBPOS*          pDBClose    = NULL;

        DBOpen2(FALSE, &pDBtmp);

        JetGetTableIndexInfoEx(pDBtmp->JetSessID,
                               pDBtmp->JetObjTbl,
                               pszIndexName,
                               &indexInfo,
                               sizeof(indexInfo),
                               JET_IdxInfoIndexId);

        *ppidxHint = malloc(sizeof(indexInfo));
        if (*ppidxHint) {
            **ppidxHint = indexInfo;
        }
        else {
            err = DB_ERR_BUFFER_INADEQUATE;
        }

        pDBClose = pDBtmp;
        pDBtmp = NULL;
        DBClose(pDBClose, FALSE);
    } __except(HandleMostExceptions(GetExceptionCode())) {
        if (pDBtmp) {
            DBClose(pDBtmp, FALSE);
        }
    }

    //  WARNING! WARNING! WARNING!
    //  No one corrently traps the error returned by this function,
    //  so if it fails, the failure will go unnoticed and the
    //  benefits of the index hint will be lost
    //
    return err;
}


DWORD
DBGetNextObjectNeedingCleaning(
    DBPOS FAR *pDB
    )

/*++

Routine Description:

    Find the next object on the SZCLEANINDEX.
    An object needed cleaning will have the cleaning column set non-NULL.
    After cleaning, an object the caller should have the cleaning column
    set NULL.

    An object on this index may be deleted.
    An object on this index may also be a phantom.

Arguments:

    pDB - database position
    pulTag - IN - Last position on index. Set to zero initially.
             OUT - DNT of object found
    The purpose of pulTag is to act as an enumeration context. It holds the
    last position found after each iteration.  This style of routine is similar
    to GetNextDelRecord and GetNextDelLinkVal.  The reason we cannot use pDB->DNT
    as this context is that the caller may lose currency as part of a
    DBTransOut/DBTransIn sequence between calls to this routine.


Return Value:

    DWORD - 0 found
         On success, DBPOS is also made current for the found record.
         pDB->DNT == *pulTag

         DB_ERR_NO_DEL_RECORD - no more

--*/

{
    DWORD err, actuallen, dnt;
    BYTE bClean;

    Assert(VALID_DBPOS(pDB));
    Assert(0 == pDB->JetRetrieveBits);

    DBSetCurrentIndex(pDB, Idx_Clean, NULL, FALSE);

    //  As objects are cleaned, SZCLEAN is set to null, which implicitly
    //  removes the object from SZCLEANINDEX.  Thus, all we ever need to
    //  do to find the next object to clean is just to go to the first
    //  entry in SZCLEANINDEX
    //
    err = JetMoveEx( pDB->JetSessID, pDB->JetObjTbl, JET_MoveFirst, NO_GRBIT );
    if ( JET_errSuccess != err )
        {
        //  index must be empty
        //
        Assert( JET_errNoCurrentRecord == err );
        DPRINT(5, "GetNextCleanRecord search complete");
        return DB_ERR_NO_MORE_DEL_RECORD;
        }

#if DBG
    // Column must be present, by definition of index
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl,
                             cleanid, &bClean, sizeof(bClean),
                             &actuallen,JET_bitRetrieveFromIndex,NULL);
    // Verify that clean_col has proper non-zero value
    Assert(bClean);
#endif

    // This routine will return DIRERR_NOT_AN_OBJECT for phantoms.
    // This is a possible outcome for this code.
    dbMakeCurrent( pDB, NULL );

    DPRINT1( 1, "Object %s needs cleaning.\n", DBGetExtDnFromDnt( pDB, pDB->DNT ) );

    return 0;
} /* DBGetNextObjectNeedingCleaning */


VOID
DBSetObjectNeedsCleaning(
    DBPOS *pDB,
    BOOL fNeedsCleaning
    )

/*++

Routine Description:

Set the special column for this record to indicate that the object cleaner
must work on it.

This routine may be called from within a prepared update or not.

Arguments:

    pDB - database position
    fNeedsCleaning - State to set

Return Value:

    None

--*/

{
// Delay cleaner by one minute to allow current transaction to finish
#define LINK_CLEANER_START_DELAY 60
    BYTE bClean = 1;
    BOOL fSuccess = FALSE;
    BOOL fInUpdate = (JET_bitRetrieveCopy == pDB->JetRetrieveBits);

    Assert(VALID_DBPOS(pDB));

    // Set clean index field & update record

    if (!fInUpdate) {
        dbInitRec(pDB);
    }

    // We are in a prepared update
    Assert(JET_bitRetrieveCopy == pDB->JetRetrieveBits);

    __try {
        if (fNeedsCleaning) {
            JET_SETINFO setinfo;

            setinfo.cbStruct = sizeof(setinfo);
            setinfo.ibLongValue = 0;
            setinfo.itagSequence = 1;

            JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, cleanid,
                           &bClean, sizeof(bClean), 0, &setinfo);

            // Add a reference to the object to indicate that the cleaner
            // still needs to run on it.  This is to account for the case of
            // an object in a read only nc with lots of forward links. When
            // the nc is torn down, only some of the forward links can be
            // removed immediately. If the object didn't have any backlinks
            // there would be nothing to keep the object from disappearing.

            DBAdjustRefCount(pDB, pDB->DNT, 1);
        } else {
            JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, cleanid,
                           NULL, 0, 0, NULL);

            // Remove the reference now that the cleaner is done.
            DBAdjustRefCount(pDB, pDB->DNT, -1);
        }

        fSuccess = TRUE;
    } __finally {

        if (!fInUpdate) {
            if (fSuccess) {
                DBUpdateRec(pDB);
            } else {
                DBCancelRec(pDB);
            }
            // No longer in a prepared update
            Assert(0 == pDB->JetRetrieveBits);
        }
    }

    if ( fNeedsCleaning && fSuccess) {
        // Reschedule Link cleanup to start ASAP
        InsertInTaskQueue(TQ_LinkCleanup, NULL, LINK_CLEANER_START_DELAY);
    }

    DPRINT2( 2, "Object %s set to cleaning state %d\n",
             GetExtDN( pDB->pTHS, pDB ), fNeedsCleaning );

} /* DBSetRecordNeedsCleaning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dblink.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dblink.c

Abstract:

    Link table routines

    This module was split off from dbobj.c to contain all the functions relating
    to operations on values in the link table.

Author:

    Many authors contributed to this code.

Notes:

Revision History:

    Split off into separate file by Will Lees (wlees) 13-Jan-2000


--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <dsatools.h>                   // For pTHStls
#include <mdlocal.h>                    // IsRoot
#include <ntseapi.h>
#include <xdommove.h>
#include <drameta.h>                    // ReplInsertMetaData

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>
#include "ntdsctr.h"

// Assorted DSA headers
#include "dsevent.h"
#include "dstaskq.h"
#include "objids.h"        /* needed for ATT_MEMBER and ATT_IS_MEMBER_OFDL */
#include <dsexcept.h>
#include <filtypes.h>      /* Def of FI_CHOICE_???                  */
#include <anchor.h>
#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DBLINK:" /* define the subsystem for debugging */
#include <dsutil.h>

// DBLayer includes
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBLINK

DWORD gcLinksProcessedImmediately = DB_COUNT_LINKS_PROCESSED_IMMEDIATELY;

void
dbGetLinkTableData (
        PDBPOS           pDB,
        BOOL             bIsBackLink,
        BOOL             bWarnings,
        DWORD           *pulObjectDnt,
        DWORD           *pulValueDnt,
        DWORD           *pulRecLinkBase
        )
{
    JET_RETRIEVECOLUMN attList[3];
    JET_COLUMNID       objectdntid;
    JET_COLUMNID       valuedntid;
    DWORD              cAtt = 0;
    DWORD              grbit;
    CHAR               szIndexName[JET_cbNameMost];

    if(bIsBackLink) {
        objectdntid = backlinkdntid;
        valuedntid = linkdntid;
    }
    else {
        valuedntid = backlinkdntid;
        objectdntid = linkdntid;
    }

    // Use RetrieveFromIndex only when we are using an index that
    // contains ALL the items desired.  There are other indexes,
    // notably LINKATTRUSNINDEX and LINKDELINDEX, which have some
    // link data components, but we currently optimize either all
    // or none.

    grbit = pDB->JetRetrieveBits;
    JetGetCurrentIndexEx( pDB->JetSessID, pDB->JetLinkTbl,
                          szIndexName, sizeof( szIndexName ) );
    if ( (!strcmp( szIndexName, SZLINKALLINDEX )) ||
         (!strcmp( szIndexName, SZLINKINDEX )) ||
         (!strcmp( szIndexName, SZLINKLEGACYINDEX )) ||
         (!strcmp( szIndexName, SZBACKLINKALLINDEX )) ||
         (!strcmp( szIndexName, SZBACKLINKINDEX )) ) {
        grbit |= JET_bitRetrieveFromIndex;
    }

    memset(attList,0,sizeof(attList));
    // First, try to retrieve everything from the index.
    if(pulObjectDnt) {
        attList[cAtt].pvData = pulObjectDnt;
        attList[cAtt].columnid = objectdntid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }
    if(pulValueDnt) {
        attList[cAtt].pvData = pulValueDnt;
        attList[cAtt].columnid = valuedntid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }
    if(pulRecLinkBase) {
        attList[cAtt].pvData = pulRecLinkBase;
        attList[cAtt].columnid = linkbaseid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }

    if(!bWarnings) {
        JetRetrieveColumnsSuccess(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  attList,
                                  cAtt);
    }
    else {
        DWORD err;
        err = JetRetrieveColumns(pDB->JetSessID,
                                 pDB->JetLinkTbl,
                                 attList,
                                 cAtt);
        switch(err) {
        case JET_errSuccess:
            break;

        case JET_errNoCurrentRecord:
            if(pulObjectDnt) {
                *pulObjectDnt = INVALIDDNT;
            }
            if(pulValueDnt) {
                *pulValueDnt = INVALIDDNT;
            }
            if(pulRecLinkBase) {
                *pulRecLinkBase = 0xFFFFFFFF;
            }
            break;

        default:
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
            break;
        }
    }


    return;
}


void
DBGetLinkTableData(
    PDBPOS           pDB,
    DWORD           *pulObjectDnt,
    DWORD           *pulValueDnt,
    DWORD           *pulRecLinkBase
    )

/*++

Routine Description:

This is a public wrapper function for dbGetLinkTableData.

It assumes we are positioned on a link table entry.

Arguments:

    pDB - 
    pulObjectDnt - 

Return Value:

    None

--*/

{
    dbGetLinkTableData( pDB, FALSE, FALSE,
                        pulObjectDnt, pulValueDnt, pulRecLinkBase );
} /* DBGetLinkTableData */

void
DBGetLinkTableDataDel (
        PDBPOS           pDB,
        DSTIME          *ptimeDeleted
        )

/*++

Routine Description:

This routine is a companion to DbGetLinkTableData. It returns secondary
info such as deletion time.

Metadata is obtained using DBGetLinkValueMetadata

Arguments:

    pDB - 
    ptimeDeleted - 

Return Value:

    None

--*/

{
    JET_RETRIEVECOLUMN attList[1];
    DWORD err;

// TODO: When we implement absent value garbage collection, expand this routine
// to retrieve by index when using the SZLINKDELINDEX. Also return LINKDNT from that
// index if useful.

    Assert( ptimeDeleted );

    // linkdeltimeid is not on LINKINDEX, but is on LINKDELINDEX
    memset(attList,0,sizeof(attList));
    attList[0].pvData = ptimeDeleted;
    attList[0].columnid = linkdeltimeid;
    attList[0].cbData = sizeof(DSTIME);
    attList[0].grbit = pDB->JetRetrieveBits;
    attList[0].itagSequence = 1;
    // Add additional columns here if needed

    // Some columns may legitimately not be present
    // Jliem writes: In general, if the error from the function return is 0, then
    // you're guaranteed the individual column errors are >= 0 (ie. no errors,
    // but possibly warnings).  FYI, the most common warning to get from individual
    // columns is JET_wrnColumnNull.

    err = JetRetrieveColumns(pDB->JetSessID,
                             pDB->JetLinkTbl,
                             attList,
                             1);
    if (err == JET_errColumnNotFound) {
        *ptimeDeleted = 0;
    } else if (err) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    } else if (attList[0].err) {
        *ptimeDeleted = 0;
    }

#if DBG
    if (*ptimeDeleted == 0) {
        DPRINT( 4, "DbGetLinkTableDataDel, deltime = (not deleted)\n" );
    } else {
        CHAR szTime[SZDSTIME_LEN];
        DPRINT1( 4, "DbGetLinkTableDataDel, deltime = %s\n",
                 DSTimeToDisplayString(*ptimeDeleted, szTime) );
    }
#endif

    return;
} /* DBGetLinkTableDataDel  */

void
DBGetLinkTableDataUsn (
    PDBPOS           pDB,
    DWORD           *pulNcDnt,
    USN             *pusnChanged,
    DWORD           *pulDnt
    )

/*++

Routine Description:

    Return the fields from the link table dra usn index.

    You must be positioned on SZLINKDRAUSNINDEX in order for this to work.

Arguments:

    pDB - 
    pulNcDnt - 
    pusnChanged - 

Return Value:

    None

--*/

{
    JET_RETRIEVECOLUMN attList[3];
    DWORD              cAtt = 0;
    DWORD              grbit;

    // Always retrieve from index
    grbit = pDB->JetRetrieveBits | JET_bitRetrieveFromIndex;

    memset(attList,0,sizeof(attList));

    if(pulNcDnt) {
        attList[cAtt].pvData = pulNcDnt;
        attList[cAtt].columnid = linkncdntid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }
    if(pusnChanged) {
        attList[cAtt].pvData = pusnChanged;
        attList[cAtt].columnid = linkusnchangedid;
        attList[cAtt].cbData = sizeof(USN);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }
    if(pulDnt) {
        attList[cAtt].pvData = pulDnt;
        attList[cAtt].columnid = linkdntid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }
    JetRetrieveColumnsSuccess(pDB->JetSessID,
                              pDB->JetLinkTbl,
                              attList,
                              cAtt);
    return;
} /* DBGetLinkTableDataUsn  */


BOOL
dbPositionOnExactLinkValue(
    IN DBPOS *pDB,
    IN ULONG ulLinkDnt,
    IN ULONG ulLinkBase,
    IN ULONG ulBacklinkDnt,
    IN PVOID pvData,
    IN ULONG cbData,
    IN BOOL *pfPresent
    )

/*++

Routine Description:

This function will look up the value in the named index and position on it.

This routine should work regardless of tracking of metadata for values. What
it means to be present or absent may change, but we can still locate values
efficiently using the index this way.  This routine does not touch or depend
on value metadata.

This function you tell you if the value actually exists in the database. It is
more efficient than the DbGetNextLinkVal kinds of functions because it seeks
exactly to the row.

The index attributes enforce that (linkdnt,linkid,backlinkdnt,data) are unique.
(linkdnt,linkid,backlinkdnt) is itself unique, but since the index includes data,
there can be many records with the same first three segments, but different data.
Don wrote the following: The uniqifying entity is the combo of DN+data, and performance
will be shot if the data is not unique within the first ~240 bytes.  No work,
either in code or design, went in to supporting extremely large binary values.

I think we are ok. As long as Jet enforces the uniqueness of dn+data:1-240 in
the index, and also truncates seek keys in the same way, a record will either
be found or not. 

Arguments:

    pDB - DBPOS, to be positioned
    ulDnt - dnt of link row
    ulLinkBase - link base of link row
    ulBacklinkDnt - backlink of link row
    pvData - optional, pointer to data
    cbData - optional, data length
    fPresent - Returned present state

Return Value:

    BOOL - true if found, false if not found

--*/

{
    JET_ERR err;
    ULONG ulObjectDnt, ulValueDnt, ulNewLinkBase;
    DSTIME timeDeletion;
    DWORD count;

    Assert(VALID_DBPOS(pDB));

    // This index sees all links, present or absent
    JetSetCurrentIndex2Success(
                pDB->JetSessID,
                pDB->JetLinkTbl,
                NULL,     // OPTIMISATION: pass NULL when switching to primary index (SZLINKALLINDEX)
                JET_bitMoveFirst );

    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl, &(ulLinkDnt),
                 sizeof(ulLinkDnt), JET_bitNewKey);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 &ulLinkBase, sizeof(ulLinkBase), 0);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 &ulBacklinkDnt, sizeof(ulBacklinkDnt), 0);
    err = JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                       pvData, cbData, 0 );
    Assert( !err );

    // Warnings are returned for this call
    err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekEQ);
    if (err) {
        DPRINT6( 2, "dbPosLinkValue, dnt = %d, base = %d, back = %d, cb = %d => %s err %d\n",
                 ulLinkDnt, ulLinkBase, ulBacklinkDnt, cbData,
                 "DOES NOT EXIST", err );
        return FALSE;  // Not found
    }

    if (pfPresent) {
        err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                        pDB->JetLinkTbl,
                                        linkdeltimeid,
                                        &timeDeletion, sizeof(timeDeletion),
                                        &count, 0, NULL);
        *pfPresent = (err != JET_errSuccess);

        DPRINT5( 2, "dbPosLinkValue, dnt = %d, base = %d, back = %d, cb = %d => %s\n",
                 ulLinkDnt, ulLinkBase, ulBacklinkDnt, cbData,
                 *pfPresent ? "PRESENT" : "ABSENT" );
    }

#if DBG
    // Verify that we found the right record
    {
        BYTE *rgb = NULL;
        ULONG cb;
        THSTATE *pTHS=pDB->pTHS;

        // test to verify that we found a qualifying record
        // Note, we don't retrieve from index because the index
        // truncates the data.
        dbGetLinkTableData( pDB,
                            FALSE, /*not backlink*/
                            FALSE, /*no warnings,must succeed*/
                            &ulObjectDnt,
                            &ulValueDnt,
                            &ulNewLinkBase );

        Assert( (ulObjectDnt == ulLinkDnt) &&
                (ulNewLinkBase == ulLinkBase) &&
                (ulValueDnt == ulBacklinkDnt) );

        if (JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                      linkdataid,
                                      NULL, 0, &cb, 0, NULL) ==
            JET_wrnBufferTruncated) {
            // data portion of the OR name exists -allocate space and read it

            rgb = THAllocEx( pTHS, cb);
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                     linkdataid, rgb, cb,
                                     &cb, 0, NULL);
        }
        else {
            cb = 0;
        }
        // compare pvdata with rgb
        Assert( (cb == cbData) &&
                ( (rgb != NULL) == (pvData != NULL) ) );
        Assert( (pvData == NULL) ||
                (memcmp( rgb, pvData, cb ) == 0) );
        if (rgb) {
            THFreeEx( pTHS, rgb );
        }
    }
#endif

    return TRUE;
} /* dbPositionOnExactLinkValue */


void
dbSetLinkValuePresent(
    IN DBPOS *pDB,
    IN DWORD dwEventCode,
    IN ATTCACHE *pAC,
    IN BOOL fResetDelTime,
    IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
    )

/*++

Routine Description:

    Make the value present.
    This function may also be used to "touch" the metadata.

    This code assumes that the value exists, but may be absent.

    This function is a no-op when not tracking value metadata.  The reason
    for this is that value metadata always trumps attribute metadata. This
    means that if we are applying an attribute level update and the
    row already exists, nothing more can or should be done.  If the row
    exists in the absent state, a attribute level update cannot change it.

    If this routine is used by fDRA, we must not optimize out the updating
    of the metadata if the value is already present.

    From the LVR spec, section on "Originating Writes"

If the originating write is an add, and the corresponding row is absent,
that row becomes present: its deletion timestamp is set to NULL.

Arguments:

    pDB - dbpos with link cursor on value to be checked
    dwEventCode - Message describing operation, to be logged
    pAC - attcache of attribute to be checked
    fResetDelTime - true if deletion time should be reset
    pMetaDataRemote - remote metadata to be applied
Return Value:

    None

--*/

{
    VALUE_META_DATA metaDataLocal;
    BOOL fSuccess = FALSE;
    BOOL fTrackingValueMetadata;

    Assert(VALID_DBPOS(pDB));

    fTrackingValueMetadata = TRACKING_VALUE_METADATA( pDB );

    // See if we can skip this function
    if (!fTrackingValueMetadata) {
        return;
    }

    DPRINT1( 2, "dbSetLinkValuePresent, deltimereset = %d\n", fResetDelTime );

    JetPrepareUpdateEx(pDB->JetSessID,
                       pDB->JetLinkTbl, DS_JET_PREPARE_FOR_REPLACE );

    __try {
        // Set LINKDELTIMEID
        // By the magic of condition columns, the value will reappear in
        // the link and backlink indexes
        if (fResetDelTime) {
            JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                           linkdeltimeid, NULL, 0, 0, 0);
        }

        Assert(fTrackingValueMetadata);

        // PERF NOTE. The local metadata is not needed when the remote metadata
        // is present. The only thing DbSet needs to know in that case is whether
        // the record already exists. If we pass that in, we could eliminate this
        // read.
        DBGetLinkValueMetaData( pDB, pAC, &metaDataLocal );

        dbSetLinkValueMetaData( pDB, dwEventCode, pAC,
                                &metaDataLocal,
                                pMetaDataRemote, /* remotemetadata */
                                NULL /* time changed */ );

        JetUpdateEx( pDB->JetSessID, pDB->JetLinkTbl, NULL, 0, 0 );

        fSuccess = TRUE;

    } __finally {

        if (!fSuccess) {
            JetPrepareUpdate(pDB->JetSessID, pDB->JetLinkTbl, JET_prepCancel);
        }

    }

} /* dbSetLinkValuePresent */


#if DBG
BOOL
dbgIsAttValDeletedObject(
    DBPOS    *pDB,
    ATTCACHE *pAC,
    PUCHAR   pVal,
    ULONG    valLen
    )

/*++

Routine Description:

    Check whether the record referenced by the given internal value is a deleted object

    Does not affect currency.

Arguments:

    pDB - 
    pAC - 
    pVal - 
    valLen - 

Return Value:

    BOOL - 

--*/

{
    DWORD tag, err, actuallen;
    BOOL Deleted = FALSE;

    switch(pAC->syntax) {
        // These are DNTvalued attributes.  We need to adjust the
        // refcount.
    case SYNTAX_DISTNAME_BINARY_TYPE:
    case SYNTAX_DISTNAME_STRING_TYPE:
        tag = ((INTERNAL_SYNTAX_DISTNAME_STRING *)pVal)->tag;
        break;
    case SYNTAX_DISTNAME_TYPE:
        // Deref the object referenced by the property value being
        // removed.
        tag =  *((DWORD *)pVal);
        break;
    default:
        Assert( !"unexpected syntax" );
        return FALSE;
        break;
    }

    // Position on the tag in the search table

    JetSetCurrentIndexSuccess(pDB->JetSessID,
                              pDB->JetSearchTbl,
                              NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)
        
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, &tag, sizeof(tag),
                 JET_bitNewKey);

    err = JetSeek(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
    if (err) {
        DsaExcept(DSA_DB_EXCEPTION, err, tag);
    }

    // We are positioned on a record. May be object or phantom.

    // We have a record with this dtn.  Switch to DNT+isDeleted index,
    // preserving currency on the record we just found.
    err = JetSetCurrentIndex4Warnings(
        pDB->JetSessID,
        pDB->JetSearchTbl,
        SZISDELINDEX,
        &idxIsDel,
        JET_bitNoMove );
    if (err == JET_errNoCurrentRecord) {
        //  no entry in the index for this record, so it must be live or phantom
        //
        DPRINT1( 1, "dnt %d does not have a deleted attribute\n", tag );
        return FALSE;
    }
    if (err != JET_errSuccess) {
        DsaExcept( DSA_DB_EXCEPTION, err, 0 );
    }

    // Read the deletion state of the record.  Note that only objects
    // have an isDeleted attribute; phantoms have a deletion *time* but
    // no isDeleted attribute.
    // Guaranteed to return a value because if the column was NULL,
    // it would not have been included in the index
    //
    JetRetrieveColumnSuccess(
        pDB->JetSessID,
        pDB->JetSearchTbl,
        isdeletedid,
        &Deleted,
        sizeof(Deleted),
        &actuallen,
        JET_bitRetrieveFromIndex,
        NULL );
    if ( !Deleted )
    {
        // Record is a not deleted object.
        //
        DPRINT1( 0, "dnt %d has del att, but it is FALSE\n", tag );
        return FALSE;
    }

    // See if object needs cleaning
    err = JetSetCurrentIndex4Warnings(
        pDB->JetSessID,
        pDB->JetSearchTbl,
        SZCLEANINDEX,
        &idxClean,
        JET_bitNoMove );
    if (err == JET_errNoCurrentRecord) {
        //  no entry in the index for this record, so doesn't need cleaning
        //
        return TRUE;
    }
    if (err != JET_errSuccess) {
        DsaExcept( DSA_DB_EXCEPTION, err, 0 );
    }

    // If an object needs cleaning, it is ok that all its links are not cleaned up yet

    DPRINT1( 0, "dnt %d is deleted and needs cleaning.\n", tag );
    return FALSE;

} /* dbgIsAttValDeletedObject */
#endif


void
dbSetLinkValueAbsent(
    IN DBPOS *pDB,
    IN DWORD dwEventCode,
    IN ATTCACHE *pAC,
    IN PUCHAR pVal,
    IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
    )

/*++

Routine Description:

Mark an existing value as being absent.
The value must exist already, either present or absent.

    NOTE! NOTE! NOTE!
    If this routine is used by fDRA, we must not optimize out the updating
    of the metadata if the value is already absent.  This is true for the
    caller as well. The caller must look up the value in such a way that
    absent values are found.  Finding it absent, it must still touch the
    metadata.

    From the LVR Spec, section on "Originating Writes"

If the originating write is a deletion, the immediate effect is to change the
row into an absent value. (Later on the absent value may be garbage collected;
how that works is not part of this description.) An absent value has a non-NULL
deletion timestamp. During the originating write that performs the deletion,
the deletion timestamp is set to max(creation timestamp, current time). This
guarantees that the creation timestamp for a row is always <= the deletion
timestamp for that row.  This deletion timestamp is used as the update timestamp
for the originating write.

Arguments:

    pDB - database position
    dwEventCode - message id to log
    pAC - which attribute the linked value belongs
    pVal - The contents of the link
    pMetaDataRemote - Remote metadata to be applied

Return Value:

    None

--*/

{
    DSTIME timeCurrent, timeCreated, timeDeleted;
    VALUE_META_DATA metaDataLocal;
    BOOL fSuccess = FALSE, fTrackingValueMetadata;

    Assert(VALID_DBPOS(pDB));

    DPRINT( 2, "dbSetLinkValueAbsent\n" );

    fTrackingValueMetadata = TRACKING_VALUE_METADATA( pDB );

    // If not tracking value metadata, perform old behavior
    if (!fTrackingValueMetadata) {

#if DBG
        // I believe its the case that we should never attempt to remove a
        // row with metadata. This is because when we are not tracking metadata,
        // we use a special index which hides metadata-ful rows, and thus it
        // should never be a candidate for removal. Still, let's be paranoid.
        DBGetLinkValueMetaData( pDB, pAC, &metaDataLocal );
        Assert( IsLegacyValueMetaData( &metaDataLocal ) );

#endif
        // There should be no links to deleted objects in the link table
        Assert( !dbgIsAttValDeletedObject( pDB, pAC, pVal, sizeof(DWORD) ) );

        dbAdjustRefCountByAttVal(pDB, pAC, pVal, sizeof(DWORD), -1);

        JetDeleteEx(pDB->JetSessID, pDB->JetLinkTbl);

        return;
    }

    JetPrepareUpdateEx(pDB->JetSessID,
                       pDB->JetLinkTbl, DS_JET_PREPARE_FOR_REPLACE );

    __try {
        DBGetLinkValueMetaData( pDB, pAC, &metaDataLocal );

        timeCurrent = DBTime();

        if (pMetaDataRemote) {
            // Use the incoming time of deletion
            timeDeleted = pMetaDataRemote->MetaData.timeChanged;
        } else {
            // Set to maximum of timeCurrent and creationTime

            timeCreated = metaDataLocal.timeCreated;
            if (timeCreated > timeCurrent) {
                timeDeleted = timeCreated;
            } else {
                timeDeleted = timeCurrent;
            }
        }

        // We unconditionally mark the value absent, even it it happens to have
        // been marked before.  This keeps the deletion time approximately in
        // sync with the meta data time changed.

        // Set LINKDELTIMEID
        // By the magic of condition columns, the value will cease to appear in
        // the link and backlink indexes
        JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                       linkdeltimeid, &timeDeleted, sizeof(timeDeleted), 0, 0);

#if DBG
        {
            CHAR szTime[SZDSTIME_LEN];
            DPRINT1( 4, "deltime = %s\n",
                     DSTimeToDisplayString(timeDeleted, szTime) );
        }
#endif

        dbSetLinkValueMetaData( pDB, dwEventCode, pAC,
                                &metaDataLocal,
                                pMetaDataRemote,
                                &timeCurrent /* time changed*/ );

        JetUpdateEx( pDB->JetSessID, pDB->JetLinkTbl, NULL, 0, 0 );

        fSuccess = TRUE;

    } __finally {

        if (!fSuccess) {
            JetPrepareUpdate(pDB->JetSessID, pDB->JetLinkTbl, JET_prepCancel);
        }

    }
} /* dbSetLinkValueAbsent */

/*++
    Description:
      Walks forward over N rows in the link table, then verifies that we are
      still on the attribute passed in.  If we are, we return the value.  Note
      that we DO NOT verify that we are on the correct attribute in the first
      place.

      The main difference between this routine and dbGetLinkVal is that the
      offset here is relative to current position, the offset in dbGetLinkVal is
      an absolute offset from the first value of the attribute.
--*/
DWORD
dbGetNthNextLinkVal(
        DBPOS * pDB,
        ULONG sequence,
        ATTCACHE **ppAC,
        DWORD Flags,
        ULONG InBuffSize,
        PUCHAR *ppVal,
        ULONG *pul
        )
{
    THSTATE     *pTHS=pDB->pTHS;
    BYTE        *rgb = NULL;
    INTERNAL_SYNTAX_DISTNAME_STRING *pBlob;
    JET_ERR     err;
    ULONG       ulValueDnt = 0;
    ULONG       ulRecLinkBase = 0;
    ULONG       cb;
    ULONG       ulObjectDnt = 0;
    ULONG       targetDNT;
    ATTCACHE    *pAC;
    BOOL        fIsBacklink;

    Assert( ppAC );
    pAC = *ppAC; // pAC may now be NULL

    if(Flags & DBGETATTVAL_fUSESEARCHTABLE) {
        targetDNT = pDB->SDNT;
    }
    else {
        targetDNT = pDB->DNT;
    }


    Assert(VALID_DBPOS(pDB));

    if(sequence) {
        // not the first value - move to the next value
        if (JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, sequence, 0)) {
            return DB_ERR_NO_VALUE;
        }
    }

    fIsBacklink = pAC ? FIsBacklink(pAC->ulLinkID) : FALSE;

    // test to verify that we found a qualifying record
    dbGetLinkTableData (pDB,
                        fIsBacklink,
                        FALSE,
                        &ulObjectDnt,
                        &ulValueDnt,
                        &ulRecLinkBase);

    if (ulObjectDnt != targetDNT) {
        DPRINT(2, "dbGetNthNextLinkVal: no values\n");
        return DB_ERR_NO_VALUE;
    }
    if (pAC) {
        ULONG ulLinkBase = MakeLinkBase(pAC->ulLinkID);
        if (ulLinkBase != ulRecLinkBase) {
            DPRINT(2, "dbGetNthNextLinkVal: no values\n");
            return DB_ERR_NO_VALUE;
        }
    } else {
        ULONG ulNewLinkID = MakeLinkId(ulRecLinkBase);

        pAC = SCGetAttByLinkId(pDB->pTHS, ulNewLinkID);
        if (!pAC) {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, ulNewLinkID);
        }
        *ppAC = pAC;  // Return new pAC to caller
    }

    // found a valid record - return a value

    switch (pAC->syntax) {
    case SYNTAX_DISTNAME_TYPE:
        if(Flags & DBGETATTVAL_fCONSTANT) {
            // Existing buffer, better be room.  We'll check later.
        }
        else if(Flags & DBGETATTVAL_fREALLOC) {
            if(InBuffSize < sizeof(ulValueDnt)) {
                // Reallocable buffer,
                *ppVal = THReAllocEx(pTHS, *ppVal, sizeof(ulValueDnt));
                InBuffSize = sizeof(ulValueDnt);
            }
        }
        else {
            // No buffer.
            *ppVal = THAllocEx(pTHS, sizeof(ulValueDnt));
            InBuffSize = sizeof(ulValueDnt);
        }

        if(InBuffSize < sizeof(ulValueDnt))
            return DB_ERR_BUFFER_INADEQUATE;

        *pul = sizeof(ulValueDnt);
        *((ULONG *)(*ppVal)) = ulValueDnt;
        // There should be no links to deleted objects in the link table
        Assert( !dbgIsAttValDeletedObject( pDB, pAC, *ppVal, *pul ) );
        return 0;


    case SYNTAX_DISTNAME_BINARY_TYPE:
    case SYNTAX_DISTNAME_STRING_TYPE:
        // Build an internal version of this data type
        // Note, we don't retrieve from index because the index
        // truncates the data.
        if (JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                      linkdataid,
                                      NULL, 0, &cb, 0, NULL) ==
            JET_wrnBufferTruncated) {
            // data portion of the OR name exists -allocate space and read it

            rgb = THAllocEx(pTHS,cb);
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                     linkdataid, rgb, cb,
                                     &cb, 0, NULL);
        }
        else {
            cb = 0;
        }

        // How much buffer we gonna need?
        *pul = sizeof(ulValueDnt) + cb;

        if(Flags & DBGETATTVAL_fCONSTANT) {
            // Existing buffer, better be room.  We'll check later.
        }
        else if(Flags & DBGETATTVAL_fREALLOC) {
            if(InBuffSize < *pul) {
                // Reallocable buffer,
                *ppVal = THReAllocEx(pTHS, *ppVal, *pul);
                InBuffSize = *pul;
            }
        }
        else {
            // No buffer.
            *ppVal = THAllocEx(pTHS, *pul);
            InBuffSize = *pul;
        }

        if(InBuffSize < *pul)
        {
            if (rgb) { 
                THFreeEx(pTHS,rgb); 
            }
            return DB_ERR_BUFFER_INADEQUATE;
        }

        pBlob = (INTERNAL_SYNTAX_DISTNAME_STRING *) *ppVal;
        pBlob->tag = ulValueDnt;
        memcpy(&pBlob->data,rgb,cb);
        Assert(pBlob->data.structLen == cb);
        if (rgb) { 
            THFreeEx(pTHS,rgb); 
        }

        // There should be no links to deleted objects in the link table
        Assert( !dbgIsAttValDeletedObject( pDB, pAC, *ppVal, *pul ) );

        return 0;

    default:

        // all other syntaxes must have some value in the link data
        // Note, we don't retrieve from index because the index
        // truncates the data.

        if ((err=JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                           linkdataid,
                                           NULL, 0, pul, 0, NULL)) !=
            JET_wrnBufferTruncated) {
            DsaExcept(DSA_DB_EXCEPTION, err, linkdataid);
        }

        if(Flags & DBGETATTVAL_fCONSTANT) {
            // Existing buffer, better be room.  We'll check later.
        }
        else if(Flags & DBGETATTVAL_fREALLOC) {
            if(InBuffSize < *pul) {
                // Reallocable buffer,
                *ppVal = THReAllocEx(pTHS, *ppVal, *pul);
                InBuffSize = *pul;
            }
        }
        else {
            // No buffer.
            *ppVal = THAllocEx(pTHS, *pul);
            InBuffSize = *pul;
        }

        if(*pul > InBuffSize)
            return DB_ERR_BUFFER_INADEQUATE;

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl, linkdataid,
                                 *ppVal, *pul, pul, 0, NULL);

        return 0;
    }
}

/*++
    Description:
      Gets the Nth link attribute value for the attribute passed in.  The
      sequence number passed in is expected to be 1 indexed.  This routine seeks
      to the first value for the attribute, then calls dbGetNthNextLinkVal.
      This routine uses absolute positioning from the beginning of the values
      for the attribute, the other routine uses relative positioning.
--*/
DWORD APIENTRY
dbGetLinkVal(
        DBPOS * pDB,
        ULONG sequence,
        ATTCACHE **ppAC,
        DWORD Flags,
        ULONG InBuffSize,
        PUCHAR *ppVal,
        ULONG *pul)
{
    JET_ERR     err;
    DWORD       targetDNT;
    LPSTR       pszIndexName;
    JET_INDEXID *pindexid;
    ATTCACHE    *pAC;

    Assert( ppAC );
    pAC = *ppAC; // pAC may now be null

    if(Flags & DBGETATTVAL_fUSESEARCHTABLE) {
        targetDNT = pDB->SDNT;
    }
    else {
        targetDNT = pDB->DNT;
    }

    Assert(VALID_DBPOS(pDB));

    // Sequences in the link table are 0 based, 1 based in the data table
    Assert( sequence );
    sequence--;

    DPRINT(2, "dbGetLinkVal entered\n");


    if ( pAC && (FIsBacklink(pAC->ulLinkID)) ) {
        // backlink
        if (Flags & DBGETATTVAL_fINCLUDE_ABSENT_VALUES) {
            pszIndexName = SZBACKLINKALLINDEX;
            pindexid = NULL;    //  UNDONE: add indexid for this index
        } else {
            pszIndexName = SZBACKLINKINDEX;
            pindexid = &idxBackLink;
        }
    }
    else {
        //link
        if (Flags & DBGETATTVAL_fINCLUDE_ABSENT_VALUES) {
            pszIndexName = NULL;    // OPTIMISATION: pass NULL when switching to primary index (SZLINKALLINDEX)
            pindexid = NULL;        // UNDONE: add indexid for this index
        } else {
            pszIndexName = ( pDB->fScopeLegacyLinks ? SZLINKLEGACYINDEX : SZLINKINDEX );
            pindexid = ( pDB->fScopeLegacyLinks ? &idxLinkLegacy : &idxLink );
        }
    }
    JetSetCurrentIndex4Success(
                pDB->JetSessID,
                pDB->JetLinkTbl,
                pszIndexName,
                pindexid,
                JET_bitMoveFirst );

    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 &(targetDNT), sizeof(targetDNT), JET_bitNewKey);

    if (pAC) {
        ULONG ulLinkBase = MakeLinkBase(pAC->ulLinkID);

        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &ulLinkBase, sizeof(ulLinkBase), 0);
    }

    // seek
    if (((err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE))
         !=  JET_errSuccess) &&
        (err != JET_wrnRecordFoundGreater)) {
        return DB_ERR_NO_VALUE;
    }

    return dbGetNthNextLinkVal(pDB, sequence, ppAC, Flags, InBuffSize, ppVal,
                               pul);
}


DB_ERR
DBGetNextLinkValForLogon(
        DBPOS   FAR * pDB,
        BOOL    bFirst,
        ATTCACHE * pAC,
        PULONG  pulDNTNext
        )
/*-------------------------------------------------------------------------

  This routine provides a fast path in the system to build a transtitive
  reverse membership evaluation routine that recurses through the link
  table with a minimum of additional overhead

  If bFirst is TRUE, this routine positions on the first value of the requested
  attribute. If it is FALSE, then we move forward 1 in the link table and get
  that value

  This routine always gives out DNT's that

    return 0 - found value
    return DB_ERR_ONLY_ON_LINKED_ATTRIBUTE - called on a non linked attribute
                                        other than the one requested.
    return DB_ERR_NO_VALUE - didn't find value
-----------------------------------------------------------------------------*/
{
    THSTATE            *pTHS=pDB->pTHS;
    JET_ERR             err=0;
    ULONG               ulObjectDnt;
    ULONG               targetDNT  = pDB->DNT;
    ULONG               ulLinkBase = MakeLinkBase(pAC->ulLinkID);
    ULONG               ulRecLinkBase = 0;

     // First, verify that the att passed in is a link/backlink.
    if (!pAC->ulLinkID) {
        return DB_ERR_ONLY_ON_LINKED_ATTRIBUTE;
    }

    if (bFirst)
    {
        //
        // We need to seek to the record with the right DNT
        //
        CHAR *          szIndexName;
        JET_INDEXID *   pindexid;

        if (FIsBacklink(pAC->ulLinkID))
        {
            // backlink
            //
            szIndexName = SZBACKLINKINDEX;
            pindexid = &idxBackLink;
        }
        else
        {
            // link
            //
            szIndexName = ( pDB->fScopeLegacyLinks ? SZLINKLEGACYINDEX : SZLINKINDEX );
            pindexid = ( pDB->fScopeLegacyLinks ? &idxLinkLegacy : &idxLink );
        }

        JetSetCurrentIndex4Success(
                    pDB->JetSessID,
                    pDB->JetLinkTbl,
                    szIndexName,
                    pindexid,
                    JET_bitMoveFirst );

        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &(targetDNT), sizeof(targetDNT), JET_bitNewKey);

        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &ulLinkBase, sizeof(ulLinkBase), 0);

        // seek
        if (((err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE))
             !=  JET_errSuccess) &&
            (err != JET_wrnRecordFoundGreater))
        {
            return DB_ERR_NO_VALUE;
        }
    }
    else
    {
        //
        // Move forward by 1
        //

        if (JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, 1, 0)) {
            return DB_ERR_NO_VALUE;
        }
    }

    //
    // Retrieve the link table data
    //

    dbGetLinkTableData (pDB,
                        FIsBacklink(pAC->ulLinkID),
                        FALSE,
                        &ulObjectDnt,
                        pulDNTNext,
                        &ulRecLinkBase);

    if ((ulObjectDnt != targetDNT) || (ulLinkBase != ulRecLinkBase))
    {
        return DB_ERR_NO_VALUE;
    }

    return(0);
}




/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Get the first or next value for a link attribute.
   A non-zero return indicates that the requested value doesn't exist.

   If bFirst is TRUE, this routine positions on the first value of the requested
   attribute.  If it is FALSE, then we move forward 1 in the link table and get
   that value.

   The caller can choose to have values returned in internal or external
   format.

   return 0 - found value
   return DB_ERR_ONLY_ON_LINKED_ATTRIBUTE - called on a non linked attribute
   return DB_ERR_NOT_ON_CORRECT_VALUE - called when positioned on some attribute
                                        other than the one requested.
   return DB_ERR_NO_VALUE - didn't find value
   return DB_ERR_BUFFER_INADEQUATE - buffer provided was not big enough
   return DB_ERR_UNKNOWN_ERROR - some other error

   NOTE!!!! This routine does not pass any SecurityDescriptorFlags to the
   internal to external data format conversions.  What this means is that you
   will always get back ALL parts of a Security Descriptor using this routine.
   DBGetMultipeAtts is wired to use SecurityDescriptorFlags, if it is important
   to you to trim parts from the SD, use that routine.

*/
DB_ERR
DBGetNextLinkVal_AC (
        DBPOS FAR *pDB,
        BOOL bFirst,
        ATTCACHE *pAC,
        DWORD Flags,
        ULONG InBuffSize,
        ULONG *pLen,
        UCHAR **ppVal
        )
{
    return
        DBGetNextLinkValEx_AC(
            pDB,
            bFirst,
            1,
            &pAC,
            Flags,
            InBuffSize,
            pLen,
            ppVal
            );
}



DB_ERR
DBGetNextLinkValEx_AC (
    DBPOS FAR *pDB,
    BOOL bFirst,
    DWORD Sequence,
    ATTCACHE **ppAC,
    DWORD Flags,
    ULONG InBuffSize,
    ULONG *pLen,
    UCHAR **ppVal
    )

/*++

Routine Description:

Position on the first or next link value.
Retrieve the internal value.
Convert to extern form if desired.

Arguments:

    pDB - DBPOS. Currency is on the object being searched.
    bFirst - If TRUE, position on the first value for the attribute. If
             FALSE, must already be on a value. Move forward by sequence.
    Sequence - if bFirst, Sequence > 0, seek to first, move forward sequence-1
               if !bFirst, Sequence >=0, no seek, move forward sequence
               bFirst = FALSE, Sequence == 0 may be used to re-read a value
    ppAC - Pointer to ATTCACHE. If ATTCACHE is non NULL, it is the 
          ATTCACHE of linked attribute on this object whose value is
          to be retrieved.  If ATTCACHE is NULL, it is filled with
          new ATTCACHE of record found.
    Flags - One or more of DBGETATTVAL_* from dbglobal.h
    InBuffSize - Size of previously allocated buffer pointed to by *ppVal.
                 Usually set when using DBGETATTVAL_REALLOC.
    pLen - Out. Length of data allocated or returned in *ppVal.
    ppVal - In/Out. Pointer to buffer. May be alloc'd or realloc'd

Return Value:

    DB_ERR - Errors from dbGetLinkVal or dbGetNthNextLinkVal

--*/

{
    THSTATE            *pTHS=pDB->pTHS;
    JET_ERR             err;
    ULONG               actuallen = 0;
    int                 rtn;
    BOOL                MakeExt=!(Flags & DBGETATTVAL_fINTERNAL);
    DWORD               dwSyntaxFlag = 0;
    ATTCACHE            *pAC;

    Assert(ppAC);
    pAC = *ppAC;
    // pAC may be null at this point

    // First, verify that the att passed in is a link/backlink.
    if (pAC) {
        if (!pAC->ulLinkID) {
            return DB_ERR_ONLY_ON_LINKED_ATTRIBUTE;
        }
        DPRINT2(2, "DBGetNextLinkVal_AC entered, fetching 0x%x (%s)\n",
                pAC->id, pAC->name);
    }

    if(Flags & DBGETATTVAL_fSHORTNAME) {
        dwSyntaxFlag = INTEXT_SHORTNAME;
    }
    else if(Flags &  DBGETATTVAL_fMAPINAME) {
        dwSyntaxFlag = INTEXT_MAPINAME;
    }

    Assert(VALID_DBPOS(pDB));
    Assert(!(Flags & DBGETATTVAL_fCONSTANT) || ((PUCHAR)pLen != *ppVal));

    if (!InBuffSize && (Flags & DBGETATTVAL_fREALLOC)) {
        // We have been given permission to realloc, but nothing has been
        // alloced.  This is the same case as if we were not given realloc
        // permission and so must just alloc.  Unset the realloc flag, leaving
        // us at the default behaviour, which is to alloc.
        Flags = Flags & ~DBGETATTVAL_fREALLOC;
    }

    if(!(Flags & DBGETATTVAL_fCONSTANT) && !(Flags & DBGETATTVAL_fREALLOC)) {
        // Since we don't have a currently existing buffer, make sure the
        // InBuffSize is 0
        InBuffSize = 0;
    }

    // Get the attribute value from the link table.
    if(bFirst) {
        // Position on the first element
        err = dbGetLinkVal(pDB,
                           Sequence,
                           ppAC,
                           Flags,
                           InBuffSize,
                           ppVal,
                           &actuallen);
    }
    else {
        ULONG            ulObjectDnt = 0, ulRecLinkBase = 0;
        ULONG            ulLinkBase;
        ULONG       targetDNT;
        BOOL        fIsBacklink;

        if(Flags & DBGETATTVAL_fUSESEARCHTABLE) {
            targetDNT = pDB->SDNT;
        }
        else {
            targetDNT = pDB->DNT;
        }

        fIsBacklink = pAC ? FIsBacklink(pAC->ulLinkID) : FALSE;

        dbGetLinkTableData (pDB,
                            fIsBacklink,
                            FALSE,
                            &ulObjectDnt,
                            NULL,
                            &ulRecLinkBase);
        if (pAC) {
            ulLinkBase = MakeLinkBase(pAC->ulLinkID);
        } else {
            // Disable the check on attribute id
            ulLinkBase = ulRecLinkBase;
        }

        if ((ulObjectDnt != targetDNT) || (ulLinkBase != ulRecLinkBase)) {
            DPRINT(2, "DBGetNextLinkVal_AC: not on a value!\n");
            return DB_ERR_NOT_ON_CORRECT_VALUE;
        }

        // move forward 1 and get the next value.
        err = dbGetNthNextLinkVal(pDB,
                                  Sequence,
                                  ppAC,
                                  Flags,
                                  InBuffSize,
                                  ppVal,
                                  &actuallen);
    }

    if(err) {
        return err;
    }

    // Read newly found attribute
    pAC = *ppAC;
    Assert(pAC);  // pAC no longer null

    // DBGetNextLinkVal makes sure that a big enough buffer already exists, so
    // set the InBuffSize to be big enough here so that we pass the checks
    // we make later during conversion to external format.
    InBuffSize = max(InBuffSize,actuallen);

    *pLen = actuallen;

    // Convert DB value to external format if so desired.

    if (MakeExt) {
        ULONG extLen;
        PUCHAR pExtVal=NULL;

        if (rtn = gDBSyntax[pAC->syntax].IntExt (
                pDB,
                DBSYN_INQ,
                *pLen,
                *ppVal,
                &extLen,
                &pExtVal,
                0, 0,
                dwSyntaxFlag)) {
            DsaExcept(DSA_EXCEPTION, DIRERR_BAD_ATT_SYNTAX, rtn);
        }

        if(Flags & DBGETATTVAL_fCONSTANT) {
            // Existing buffer, better be room.  We'll check later.
        }
        else {
            if(InBuffSize < extLen &&
               *pLen < extLen) {
                // Reallocable buffer,
                *ppVal = THReAllocEx(pTHS, *ppVal, extLen);
                InBuffSize = extLen;
            }
        }

        if(InBuffSize < extLen) {
            return DB_ERR_BUFFER_INADEQUATE;
        }

        *pLen = extLen;

        memcpy(*ppVal, pExtVal, extLen);
    }

    DPRINT1(2,"DBGetNextLinkVal_AC: complete  val:<%s>\n",
            asciiz(*ppVal,(USHORT)*pLen));
    return 0;

} /* DBGetNextLinkValEx_AC  */





VOID
dbInsertIntLinkVal(
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG ulDnt,
    ULONG ulLinkBase,
    ULONG ulBacklinkDnt,
    VOID *pvData,
    ULONG cbData,
    BOOL fPresent,
    IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
    )

/*++

Routine Description:

    Common routine to insert a new link record.
    The initial state of present or absent may be set.
    It is assumed that we have already checked and the record not exist.

    It is assumed that a refcount has already been added by our caller.

Arguments:

    pDB - 
    ulDnt - 
    ulLinkBase - 
    ulBacklinkDnt - 
    cbData - 
    pvData - 
    fPresent - 

Return Value:

    NONE, exceptions raised for error conditions

--*/

{
    BOOL fSuccess = FALSE, fTrackingValueMetadata;
    DWORD dwEventCode;
    CHAR szTime[SZDSTIME_LEN];
    DSTIME timeCurrent, timeDeleted;

    fTrackingValueMetadata = TRACKING_VALUE_METADATA( pDB );

    DPRINT2( 2, "dbInsertIntLinkVal, obj=%s, value=%s\n",
             GetExtDN( pDB->pTHS, pDB ),
             DBGetExtDnFromDnt( pDB, ulBacklinkDnt ) );

    // prepare for inserting new record in link table
    JetPrepareUpdateEx(pDB->JetSessID,
                       pDB->JetLinkTbl, JET_prepInsert);

    __try {
        JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                       linkdntid, &(pDB->DNT), sizeof(pDB->DNT), 0, 0);
        JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                       linkbaseid, &ulLinkBase, sizeof(ulLinkBase), 0, 0);
        JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                       backlinkdntid, &ulBacklinkDnt, sizeof(ulBacklinkDnt), 0, 0);

        // set link data - only if it exists

        if (cbData) {
            // A length of zero indicates the data is null
            JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                           linkdataid, pvData, cbData, 0, 0 );
        }

        timeCurrent = DBTime();

        if (fPresent) {
            //
            // Create record in the present state
            //
            dwEventCode = DIRLOG_LVR_SET_META_INSERT_PRESENT;

        } else {
            //
            // Create record in absent state
            //

            if (!fTrackingValueMetadata) {
                Assert( !"Can't apply value metadata when not in proper mode!" );
                DsaExcept(DSA_DB_EXCEPTION, ERROR_DS_INTERNAL_FAILURE, 0);
            }

            if (pMetaDataRemote) {
                // Use the incoming time of deletion
                timeDeleted = pMetaDataRemote->MetaData.timeChanged;
            } else {
                // Set to maximum of timeCurrent and creationTime
                timeDeleted = timeCurrent;
            }

            JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                           linkdeltimeid, &timeDeleted, sizeof(timeDeleted), 0, 0);

            DPRINT1( 4, "deltime = %s\n",
                     DSTimeToDisplayString(timeDeleted, szTime) );

            dwEventCode = DIRLOG_LVR_SET_META_INSERT_ABSENT;
        }

        if (fTrackingValueMetadata) {
            dbSetLinkValueMetaData( pDB, dwEventCode, pAC,
                                    NULL, /*local metadata */
                                    pMetaDataRemote, /*remote metadata*/
                                    &timeCurrent /* time changed */ );
        }

        // update the database
        JetUpdateEx(pDB->JetSessID, pDB->JetLinkTbl, NULL, 0, 0);

        fSuccess = TRUE;

    } __finally {

        if (!fSuccess) {
            JetPrepareUpdate(pDB->JetSessID, pDB->JetLinkTbl, JET_prepCancel);
        }

    }
} /* dbInsertIntLinkVal */


VOID
dbDecodeInternalDistnameSyntax(
    IN ATTCACHE *pAC,
    IN VOID *pIntVal,
    IN DWORD intLen,
    OUT DWORD *pulBacklinkDnt,
    OUT DWORD *pulLinkBase,
    OUT PVOID *ppvData,
    OUT DWORD *pcbData
    )

/*++

Routine Description:

    Decode an internal form of a distname depending on the syntax

Arguments:

    pAC - 
    pIntVal - 
    pulBacklinkDnt - 
    pulLinkBase - 
    ppvData - 
    pcbData - 

Return Value:

    None

--*/

{
    *pulLinkBase = MakeLinkBase(pAC->ulLinkID);

    // The link attribute can be of syntax DN or the two DISTNAME + data
    // syntaxes.  We handle them a little differently

    switch (pAC->syntax) {
    case SYNTAX_DISTNAME_TYPE:
        *pulBacklinkDnt = *((ULONG *) pIntVal);
        *ppvData = NULL;
        *pcbData = 0;
        break;

    case SYNTAX_DISTNAME_STRING_TYPE:
    case SYNTAX_DISTNAME_BINARY_TYPE:
    {
        INTERNAL_SYNTAX_DISTNAME_STRING *pBlob =
            (INTERNAL_SYNTAX_DISTNAME_STRING *) pIntVal;
        *pulBacklinkDnt = pBlob->tag;
        *ppvData = &pBlob->data;
        *pcbData = pBlob->data.structLen;
        break;
    }
    default:    // all other syntaxes
        *ppvData = pIntVal;
        *pcbData = (ULONG) intLen;
        *pulBacklinkDnt = 0;
        break;
    }
} /* dbDecodeInternalDistnameSyntax */


BOOL
dbFindIntLinkVal(
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG intLen,
    void *pIntVal,
    OUT BOOL *pfPresent
    )

/*++

Routine Description:

Position on the given internal form of the link value

Arguments:

    pDB - 
    pAC - 
    intLen - 
    pIntVal - 
    pfPresent - Only valid on success

Return Value:

    BOOL - 

--*/

{
    void *pvData;
    ULONG cbData, ulBacklinkDnt, ulLinkBase;
    BOOL fFound;

    // Only for linked attributes right now
    Assert( pAC->ulLinkID );

    Assert(VALID_DBPOS(pDB));

    dbDecodeInternalDistnameSyntax( pAC, pIntVal, intLen,
                                    &ulBacklinkDnt,
                                    &ulLinkBase,
                                    &pvData,
                                    &cbData );

    // We've got to have either a valid DNT, data, or both
    Assert(ulBacklinkDnt || cbData);

    fFound = dbPositionOnExactLinkValue(
            pDB,
            pDB->DNT,
            ulLinkBase,
            ulBacklinkDnt,
            pvData,
            cbData,
            pfPresent );

    DPRINT3( 2, "dbFindIntLinkVal, obj=%s, value=%s, found=%d\n",
             GetExtDN( pDB->pTHS, pDB ),
             DBGetExtDnFromDnt( pDB, ulBacklinkDnt ),
             *pfPresent );

    return fFound;
} /* dbFindIntLinkVal */

DWORD
dbAddIntLinkVal (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG intLen,
        void *pIntVal,
        IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
        )
/*++

Routine Description:

    Add an internal link attribute value to the current object.

    It is assumed that a refcount has already been added by our caller.

Callers:

dbobj.c:DBAddAttValEx_AC (for linked attributes)
    is called by dbobj.c:DBAddAttVal_AC
        has many originating write callers
    is called by drancrep.c:modifyLocalValue
        called during inbound replicate of LVR values only

dbobj.c:DBReplaceAtt_AC
    has many originating write callers
    called by mdupdate.c:ReplaceAtt
       called by mdmod.c:ApplyAtt
           is called by inbound replication in legacy mode

This routine is called both when the system is in W2K mode and when the system is in
LVR mode. (pTHS->fLinkedValueReplication)

This routine is called on both the originating write path and the replicated write path.
(pTHS->fDRA).

On the originating write path, there is no remote value metadata to apply.

In the replicated write path, there may or may not be remote value metadata to apply.
There is value metadata if the replicator is applying a inbound LVR value. There isn't
if the replicator is applying an attribute-level change, or if the replicator is
itself making an originating write! (pMetaDataRemote != NULL)

On the replicated write path, this routine can be called in two modes: when
the replicator is applying an attribute-level change, and when the replicator
is applying a value-level change. (pDB->fScopeLegacyLinks)

The field pDB->fScopeLegacyLinks is set true on the replicated write path for an attribute-
level change.

--*/
{
    JET_ERR      err;
    void         *pvData;
    ULONG        cbData;
    ULONG        ulBacklinkDnt;
    ULONG        ulLinkBase;
    BOOL         fPresent;

    DPRINT1(2, "dbAddIntLinkVal entered, add value <%s>\n", asciiz(pIntVal, (USHORT)intLen));

    Assert(VALID_DBPOS(pDB));

    Assert(pAC->ulLinkID);

    // Only the replicator should set fScopeLegacyLinks
    Assert( (!(pDB->fScopeLegacyLinks)) || (pDB->pTHS->fDRA) );

    // On the replicated write path for an attribute-level change, there
    // should be no incoming value metadata
    Assert( (!(pDB->fScopeLegacyLinks)) || (pMetaDataRemote == NULL) );

    // On originating writes, no remote metadata should be supplied
    Assert( (pDB->pTHS->fDRA) || (pMetaDataRemote == NULL) );

    // The link base is a number that should be the same for links and
    // backlinks. This is achieved by assuming that for LinkBase N, the
    // link ID of the link attribute is 2N , and the link ID of the backlink
    // is 2N+1. Furthermore, for security reasons and for avoiding weird
    // undesirable situations that might occur because of one-way interdomain
    // replication, we disallow setting backlink attributes.


    if (FIsBacklink(pAC->ulLinkID))
        return DB_ERR_NOT_ON_BACKLINK;

    // There should be no links to deleted objects in the link table
    Assert( !dbgIsAttValDeletedObject( pDB, pAC, pIntVal, intLen ) );

    dbDecodeInternalDistnameSyntax( pAC, pIntVal, intLen,
                                    &ulBacklinkDnt,
                                    &ulLinkBase,
                                    &pvData,
                                    &cbData );

    // We've got to have either a valid DNT, data, or both
    Assert(ulBacklinkDnt || cbData);

    // See if there is an absent value we can make present
    if (dbPositionOnExactLinkValue( pDB, pDB->DNT, ulLinkBase, ulBacklinkDnt,
                                    pvData, cbData, &fPresent ) ) {

        // Record does exist

        // Do not optimize out for replicator
        if (pDB->pTHS->fDRA || (!fPresent)) {

            // The forward link already exists so no need to add another one.
            // Reverse the ref-count already added by our caller
            DBAdjustRefCount(pDB, ulBacklinkDnt, -1);

            dbSetLinkValuePresent( pDB,
                                   DIRLOG_LVR_SET_META_INSERT_MADE_PRESENT,
                                   pAC,
                                   (!fPresent), /*reset deltime*/
                                   pMetaDataRemote
                                   );
        } else {
            DPRINT(1, "dbAddIntLinkVal: Linked Value already exists\n");
            return DB_ERR_VALUE_EXISTS;
        }

    } else if ( LEGACY_UPDATE_IN_LVR_MODE( pDB ) &&
                (pAC->isSingleValued) &&
                (DBHasLinkedValuesWithMetadata( pDB, pAC )) ) {
        // Single value semantics
        // Suppress the addition of a legacy value if any value with metadata
        // (present or absent) already exists

        Assert( pDB->pTHS->fDRA );
        Assert( pDB->fScopeLegacyLinks );
        Assert( pDB->pTHS->fLinkedValueReplication );

        DPRINT2( 0, "Not applying legacy change to object %s attr %s because it is single valued.\n",
                 GetExtDN( pDB->pTHS, pDB), pAC->name );

        // Reverse the ref-count already added by our caller
        DBAdjustRefCount(pDB, ulBacklinkDnt, -1);

    } else {

        // Record does not exist

        dbInsertIntLinkVal( pDB, pAC,
                            pDB->DNT, ulLinkBase, ulBacklinkDnt,
                            pvData, cbData, TRUE /*present*/,
                            pMetaDataRemote );
    }

    // Touch replication meta data for this attribute.
    // Never optimize this out for fDRA.
    DBTouchMetaData(pDB, pAC);

    // success

    return 0;
} // dbAddIntLinkVal

DWORD
dbRemIntLinkVal (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG intLen,
        void *pIntVal,
        IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
        )
/*++

Routine Description:

    Remove an internal link attribute value from the current object.

    Neither this routine nor its caller should decrement the ref count for the
    object that is the target of the link. That is because this routine does not
    remove the link, but actually marks it absent. The link is removed by the
    garbage collector at a later time.

    Two exceptions:
    1. If we are running not in LVR mode, then we will decrement the count and
    physically delete the link in dbSetLinkValueAbsent.
    2. The replicator can add a new link in the absent state. In this case it
    will use dbInsertIntLink, which will increment the ref count.
--*/
{
    JET_ERR      err;
    void         *pvData;
    ULONG        cbData;
    ULONG        ulBacklinkDnt;
    ULONG        ulLinkBase;
    BOOL         fPresent;

    DPRINT1(2, "dbRemIntLinkVal entered, add value <%s>\n", asciiz(pIntVal, (USHORT)intLen));

    Assert(VALID_DBPOS(pDB));

    Assert(pAC->ulLinkID);

    // The link base is a number that should be the same for links and
    // backlinks. This is achieved by assuming that for LinkBase N, the
    // link ID of the link attribute is 2N , and the link ID of the backlink
    // is 2N+1. Furthermore, for security reasons and for avoiding weird
    // undesirable situations that might occur because of one-way interdomain
    // replication, we disallow setting backlink attributes.


    if (FIsBacklink(pAC->ulLinkID))
        return DB_ERR_NOT_ON_BACKLINK;

    dbDecodeInternalDistnameSyntax( pAC, pIntVal, intLen,
                                    &ulBacklinkDnt,
                                    &ulLinkBase,
                                    &pvData,
                                    &cbData );

    // We've got to have either a valid DNT, data, or both
    Assert(ulBacklinkDnt || cbData);

    // See if there is a present value we can make absent

    if (dbPositionOnExactLinkValue( pDB, pDB->DNT, ulLinkBase, ulBacklinkDnt,
                     pvData, cbData, &fPresent ) ) {

        // Record does exist

        // Do not optimize out for replicator
        if (pDB->pTHS->fDRA || (fPresent)) {
            dbSetLinkValueAbsent( pDB,
                                  DIRLOG_LVR_SET_META_REMOVE_VALUE_MADE_ABSENT,
                                  pAC, pIntVal,
                                  pMetaDataRemote );
        } else {
            DPRINT(1, "dbRemIntLinkVal: Linked Value already absent\n");
            return DB_ERR_VALUE_DOESNT_EXIST;
        }

    } else {

        // Record does not exist

        // Only the replicator can create a value in the absent state
        if (pDB->pTHS->fDRA) {

            // We are creating a new link so we need a ref-count added
            // on the target.
            DBAdjustRefCount(pDB, ulBacklinkDnt, 1);

            dbInsertIntLinkVal( pDB, pAC,
                                pDB->DNT, ulLinkBase, ulBacklinkDnt,
                                pvData, cbData, FALSE /*present*/,
                                pMetaDataRemote );

        } else {

            DPRINT(1, "dbRemIntLinkVal: Linked Value doesn't exist\n");
            return DB_ERR_VALUE_DOESNT_EXIST;

        }
    }

    // Touch replication meta data for this attribute.
    // Never optimize this out for fDRA.
    DBTouchMetaData(pDB, pAC);

    // success

    return 0;
} // dbRemIntLinkVal


BOOL
DBHasLinks(
    DBPOS *pDB,
    DWORD DNT,
    BOOL fIsBacklink
    )

/*++

Routine Description:

    Verify that no more links

Arguments:

    pDB - 
    DNT - 
    fIsBacklink - 

Return Value:

    BOOL - 

--*/

{
    JET_ERR          err;
    ULONG            ulObjectDnt = INVALIDDNT, 
                     ulValueDnt = INVALIDDNT;
    ULONG            ulNewLinkBase;

    Assert(DNT != INVALIDDNT);
    PREFIX_ASSUME((DNT != INVALIDDNT), "parameters should be valid");

    // this index sees all backlinks/links, present or absent
    // UNDONE: add indexids for these indexes
    //
    JetSetCurrentIndexSuccess(pDB->JetSessID,
                              pDB->JetLinkTbl,
                              fIsBacklink ? SZBACKLINKALLINDEX : NULL); // OPTIMISATION: pass NULL when switching to primary index (SZLINKALLINDEX)

    // find first matching record
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetLinkTbl,
                 &DNT,
                 sizeof(DNT),
                 JET_bitNewKey);

    err = JetSeekEx(pDB->JetSessID,
                    pDB->JetLinkTbl,
                    JET_bitSeekGE);

    if ((err != JET_errSuccess) && (err != JET_wrnSeekNotEqual)) {
        // no records
        return FALSE;
    }

    // There is a record. See if it is our object

    dbGetLinkTableData (pDB,
                        fIsBacklink,           // fIsBacklink
                        FALSE,
                        &ulObjectDnt,
                        NULL,
                        NULL);

    return (ulObjectDnt == DNT);

} /* DBHasLinks */


BOOL
DBHasLinkedValuesWithMetadata(
    DBPOS *pDB,
    ATTCACHE *pAC
    )

/*++

Routine Description:

    Test whether the current object has any LVR values.
    These may be absent or present.

    Link table currency is changed
    Backlinks are not supported.

Arguments:

    pDB - 
    pAC - 

Return Value:

    BOOL - 

--*/

{
    JET_ERR err;
    ULONG ulTargetDnt = pDB->DNT, ulLinkBase = 0;
    ULONG ulNewTargetDnt, ulNewLinkBase;

    if (FIsBacklink(pAC->ulLinkID)) {
        Assert( !"This function does not apply to backlinks" );
        return FALSE;
    }

    ulLinkBase = MakeLinkBase(pAC->ulLinkID);

// Note the third segment of this key is descending. This is intended.
//char rgchLinkAttrUsnIndexKeys[] = "+" SZLINKDNT "\0+" SZLINKBASE "\0-" SZLINKUSNCHANGED "\0";

    JetSetCurrentIndex4Success(
                pDB->JetSessID,
                pDB->JetLinkTbl,
                SZLINKATTRUSNINDEX,
                &idxLinkAttrUsn,
                JET_bitMoveFirst );

    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 &(ulTargetDnt), sizeof(ulTargetDnt), JET_bitNewKey);

    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 &ulLinkBase, sizeof(ulLinkBase), 0);

    // seek
    if (((err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE))
         !=  JET_errSuccess) &&
        (err != JET_wrnRecordFoundGreater))
    {
        // end of table, we're done
        return FALSE;
    }

    dbGetLinkTableData(pDB,
                       FALSE,
                       FALSE,
                       &ulNewTargetDnt,
                       NULL, // pulValueDnt
                       &ulNewLinkBase);
    if ( (ulNewTargetDnt != ulTargetDnt) || (ulNewLinkBase != ulLinkBase) ) {
        // Have moved off current object, we're done
        return FALSE;
    }

    //FUTURE: return absent flag and metadata to caller

    return TRUE;
} /* DBHasLinkValuesWithMetadata */

// This is a public routine for other dblayer callers
// It has a simplified api compatible with existing code.
// It removes links for all attributes, in one direction.
// It supports restartability via the link cleaner
void
DBRemoveAllLinks(
        DBPOS *pDB,
        DWORD DNT,
        BOOL fIsBacklink
        )
/*++
  Description:
      Remove all links with the given DNT
      Being present or absent is ignored.
      Which attribute is also ignored. All links associated with this object
      are affected.
      The link is physically removed in a non-replicable way
      This is done regardless of whether we are tracking value metadata.

  Parameters:
    pDB - DBPOS to use.
    DNT - DNT of the phantom whose backlinks are being removed.
    fIsBacklink - Which index to use

  Returns:
    No return values.  It succeeds or excepts.
--*/
{
    BOOL fMoreLinks;

    fMoreLinks = DBRemoveAllLinksHelp_AC( pDB, DNT, NULL, fIsBacklink,
                                          gcLinksProcessedImmediately, NULL );
    if (fMoreLinks) {
        // Didn't clean up all the links - object needs cleaning
        DBSetObjectNeedsCleaning( pDB, TRUE );
    } else {
        Assert( !DBHasLinks( pDB, DNT, fIsBacklink ) );
    }
}

// This is a helper routine for all callers
// It supports the full range of functionality
DWORD
DBRemoveAllLinksHelp_AC(
        DBPOS *pDB,
        DWORD DNT,
        ATTCACHE *pAC,
        BOOL fIsBacklink,
        DWORD cLinkLimit,
        DWORD *pcLinksProcessed
        )
/*++
  Description:
      Remove all links with the given DNT
      Being present or absent is ignored.
      Which attribute is also ignored. All links associated with this object
      are affected.
      The link is physically removed in a non-replicable way
      This is done regardless of whether we are tracking value metadata.

  Parameters:
    pDB - DBPOS to use.
    DNT - DNT of the phantom whose backlinks are being removed.
    pAC - If present, restrict links to only this attribute
    fIsBacklink - Which index to use
    cLinkLimit - Maximum number of links to process.
                 Use 0xffffffff for infinite.
    pcLinksProcessed - Incremented for each link processed.
       Not cleared at start.

  Returns:
    BOOL - More data flag. TRUE means more data available
    It succeeds or excepts.
--*/
{
    JET_ERR          err;
    ULONG            ulObjectDnt = INVALIDDNT, 
                     ulValueDnt = INVALIDDNT;
    ULONG            ulLinkBase, ulNewLinkBase;
    DWORD            count;
    BOOL             fMoreData = TRUE;

    Assert( !pAC || ((ULONG) fIsBacklink) == FIsBacklink( pAC->ulLinkID ) );
    Assert(DNT != INVALIDDNT);
    PREFIX_ASSUME((DNT != INVALIDDNT), "parameters should be valid");

    // this index sees all backlinks/links, present or absent
    // UNDONE: add indexids for these indexes
    //
    JetSetCurrentIndexSuccess(pDB->JetSessID,
                              pDB->JetLinkTbl,
                              fIsBacklink ? SZBACKLINKALLINDEX : NULL); // OPTIMISATION: pass NULL when switching to primary index (SZLINKALLINDEX)

    // find first matching record
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetLinkTbl,
                 &DNT,
                 sizeof(DNT),
                 JET_bitNewKey);
    if (pAC) {
        ulLinkBase = MakeLinkBase(pAC->ulLinkID);
        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &ulLinkBase, sizeof(ulLinkBase), 0);
    }
    err = JetSeekEx(pDB->JetSessID,
                    pDB->JetLinkTbl,
                    JET_bitSeekGE);

    if ((err != JET_errSuccess) && (err != JET_wrnSeekNotEqual)) {
        // no records
        return FALSE;
    }

    // A word of explanation on linked value ref-counting. See dbsubj.c header for more.
    // For every linked value row, a ref-count is added to the dnt in the backlinkdnt
    // column. This is to say, the target of the forward link is reference counted. As
    // it says in dbsubj.c, the hosting-dn, which is also the target of the backlink, is
    // not ref-counted.
    // That said, we can enumerate links in this routine either of two ways.
    // If we are enumerating forward links, then we want to deref the backlinkdnt each
    // time we find a row.
    // If we are enumerating backward links, we can perform an optimization. Since we
    // are positioned on the object which will be in the backlinkdnt column for all of
    // the found records, and since this will always be the same dnt, we can deref
    // it once at the end.

    count = 0;
    while ( count < cLinkLimit ) {
        // test to verify that we found a qualifying record
        dbGetLinkTableData (pDB,
                            fIsBacklink,           // fIsBacklink
                            FALSE,
                            &ulObjectDnt,
                            &ulValueDnt,
                            &ulNewLinkBase);

        if ( (ulObjectDnt != DNT) ||
             ( (pAC != NULL) && (ulLinkBase != ulNewLinkBase) ) ) {
            // No more records.
            fMoreData = FALSE;
            break;
        }

        // update reference count and remove the record
        count++;
        if (!fIsBacklink) {
            DBAdjustRefCount(pDB, ulValueDnt, -1);

            DPRINT2( 2, "Forward Link Owner %s Target %s removed.\n",
                     DBGetExtDnFromDnt( pDB, ulObjectDnt ),
                     DBGetExtDnFromDnt( pDB, ulValueDnt ) );
            LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                     DS_EVENT_SEV_BASIC,
                     DIRLOG_GC_REMOVED_OBJECT_VALUE,
                     szInsertSz( DBGetExtDnFromDnt( pDB, ulValueDnt ) ),
                     szInsertSz( DBGetExtDnFromDnt( pDB, ulObjectDnt ) ),
                     NULL);

        } else {

            DPRINT2( 2, "Backward Link Owner %s Target %s removed.\n",
                     DBGetExtDnFromDnt( pDB, ulValueDnt ),
                     DBGetExtDnFromDnt( pDB, ulObjectDnt ) );
            LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                     DS_EVENT_SEV_BASIC,
                     DIRLOG_GC_REMOVED_OBJECT_VALUE,
                     szInsertSz( DBGetExtDnFromDnt( pDB, ulObjectDnt ) ),
                     szInsertSz( DBGetExtDnFromDnt( pDB, ulValueDnt ) ),
                     NULL);
        }

        JetDeleteEx(pDB->JetSessID,
                    pDB->JetLinkTbl);

        if (JET_errNoCurrentRecord ==
            JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, 1, 0)) {
            // No more records.
            fMoreData = FALSE;
            break;
        }
    }

    // If an exception is raised in the previous while loop, it is the caller's
    // duty not to commit the transaction, thus reversing the deletes and not
    // running into the problem that the reference counts were not adjusted.

    if ( (fIsBacklink) && (count) ) {
        DBAdjustRefCount(pDB, DNT, -((int)count));
    }

    if (pcLinksProcessed) {
        (*pcLinksProcessed) += count;
    }

    return fMoreData;
}


DWORD
DBPhysDelLinkVal(
    IN DBPOS *pDB,
    IN ULONG ulObjectDnt,
    IN ULONG ulValueDnt
    )

/*++

Routine Description:

Physically delete the value we are currently positioned on.

You must pass in the backlinkdnt which must have already been read.
Arguments:

    pDB - 
    ulValueDnt - Dnt being referenced by the forward link. Also called
                 the "backlink dnt".

Return Value:

   DWORD - error flag, 1 for error, 0 for success

--*/

{
    ULONG ulLinkDnt, ulBackLinkDnt, actuallen;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    DWORD err = 0;

#if DBG
    // Verify positioning
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                             linkdntid,
                             &ulLinkDnt, sizeof(ULONG),
                             &actuallen, 0, NULL);
    
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                             backlinkdntid,
                             &ulBackLinkDnt, sizeof(ULONG),
                             &actuallen, 0, NULL);
    if ( (ulObjectDnt != ulLinkDnt) || (ulValueDnt != ulBackLinkDnt) ) {
        Assert( !"Not positioned on correct object for delete" );
        return DB_ERR_VALUE_DOESNT_EXIST;
    }
#endif

    __try {
        // update reference count and remove the record
        DBAdjustRefCount(pDB, ulValueDnt, -1);

        JetDeleteEx(pDB->JetSessID, pDB->JetLinkTbl);
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        err = ulErrorCode;
        Assert(err);
    }

    return err;
} /* DBPhysDelValue */

// remove all link attributes - this should be done when deleting an object so
// that the backlinks don't show up in the interval between deletion and garbage
// collection
// This is a wrapper for non-dblayer callers
DWORD APIENTRY
DBRemoveLinks(DBPOS *pDB)
{
    ATTCACHE *pAC = NULL;
    ULONG SearchState = ATTRSEARCHSTATELINKS;
    BOOL fOldLegacyLinkState;

    DPRINT1( 2, "DBRemoveLinks, dnt = %d\n", pDB->DNT );

    // First remove all legacy values of forward link attributes and update the
    // legacy meta data of those attributes to signal an originating write.
    //
    // This is particularly important for object deletions (the only client
    // of this function).  It's true that when the deletion replicates to
    // another DSA that DSA will remove all linked values associated with the
    // object anyway, regardless of whether the inbound data tells it to do
    // so explicitly.  However, object resuscitation (e.g., when a DSA overrides
    // the replicated deletion of its own DSA object that was originated on
    // another DSA) in Win2k requires that all attributes removed during
    // deletion -- linked or not -- have their meta data touched during the
    // originating deletion.  Any attribute that is silently removed during the
    // originating deletion will not be overridden as part of resuscitation (see
    // use of fBadDelete in ReplReconcileRemoteMetaDataVector), and thus the
    // values of the attribute will not be revived on DSAs where the object was
    // at one time deleted (resulting in an inconsistency).
    //
    // Note that we cannot skip this step when in LVR mode, as legacy values of
    // linked attributes may still exist in LVR mode (i.e., if the values were
    // created before the switch to LVR replication).  And rather than create a
    // new mechanism, DSAs that understand LVR still depend on attribute-level
    // meta data for legacy linked attributes being updated during object
    // deletion in order for resuscitation to work correctly.

    fOldLegacyLinkState = pDB->fScopeLegacyLinks;
    pDB->fScopeLegacyLinks = TRUE;

    __try {
        while (!dbGetNextAtt(pDB, &pAC, &SearchState)
               && (ATTRSEARCHSTATELINKS == SearchState)) {
            if (dbHasAttributeMetaData(pDB, pAC)) {
                DBRemAtt_AC(pDB, pAC);
            }
        }
    } __finally {
        pDB->fScopeLegacyLinks = fOldLegacyLinkState;
    }

    // Remove the first 1,000 LVR forward links.  If any remain, mark the object
    // such that the rest are removed later.
    DBRemoveAllLinks( pDB, (pDB->DNT), FALSE /* use forward link */ );

    // Remove the first 1,000 back links (legacy and LVR).  If any remain,
    // mark the object such that the rest are removed later.
    DBRemoveAllLinks( pDB, (pDB->DNT), TRUE /* use backward link */ );

    return 0;
}

// Remove the forward links from a particular attribute of an object
// It is used when vaporizing a single attribute.
// This is a wrapper for non-dblayer callers
DWORD APIENTRY
DBRemoveLinks_AC(
    DBPOS *pDB,
    ATTCACHE *pAC
    )
{
    BOOL fMoreLinks;

    Assert( pAC );
    Assert( pAC->ulLinkID );
    DPRINT2( 2, "DBRemoveLinks_AC, dnt = %d, attr = %s\n",
             pDB->DNT, pAC->name );

    // Remove all forward links. These are attributes on this object which contain
    // values which are dn's of other objects.

    fMoreLinks = DBRemoveAllLinksHelp_AC(
        pDB, // object has currency
        pDB->DNT, // dnt to remove
        pAC, // Attribute to remove
        FALSE /*forward links */,
        gcLinksProcessedImmediately,  // how many to remove
        NULL // no processed count
        );
    if (fMoreLinks) {
        // Didn't clean up all the links - object needs cleaning
        DBSetObjectNeedsCleaning( pDB, TRUE );
    }

    return 0;
}


UCHAR *
dbGetExtDnForLinkVal(
    IN DBPOS * pDB
    )

/*++

Routine Description:

   Assume we are positioned on a link value.
   Assume we are on an index that contains the backlink dnt.
   Read the backlink dnt, and convert to printable form.

Arguments:

    pDB - 

Return Value:

    None

--*/

{
    DWORD ulValueDnt = INVALIDDNT;

    dbGetLinkTableData( pDB,
                        FALSE /*backlink*/,
                        FALSE /*bWarnings*/,
                        NULL /*ulObjectDnt*/,
                        &ulValueDnt,
                        NULL /*ulLinkBase */ );

    return DBGetExtDnFromDnt( pDB, ulValueDnt );
} /* GetExtDnForLinkVal */


DWORD
DBGetNextDelLinkVal(
    IN DBPOS FAR *pDB,
    IN DSTIME ageOutDate,
    IN OUT DSTIME *ptLastTime,
    IN OUT ULONG *pulObjectDnt,
    IN OUT ULONG *pulValueDnt
    )

/*++

Routine Description:

    Returns the next absent link value

    The reason we re-seek each time is that our index and position
    may be lost as part of committing the transaction.
    We form a UNIQUE key so that we can position on the next
    record to consider.

    Note that we make a best-effort attempt to be unique. To be 100% unique
    we would have to move the deletion time to the nanosecond granularity, 
    or include the linkbase and linkdata in the index. As it
    it is, if two values which differ only in data are deleted in the same
    second, only one will be found on a given pass of this algorithm. The other
    will be found on the next pass.

Arguments:

    pDB - 
    ageOutDate - dstime after which value is expired
    ptLastTime - in, last time found, out new time found
    pulObjectDnt - in, last object found, out new object
    pulValueDnt - in:last backlink found, out:new backlink

Return Value:

    DWORD - DB_ERR_* error status, not win32 status
    success - candidate found for deletion
    NO_MORE_DEL_RECORD - no more items found, end search
    others - error occurred

--*/

{
    JET_ERR  err;
    ULONG    actuallen;

    DBSetCurrentIndex( pDB, Idx_LinkDel, NULL, FALSE );

    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 ptLastTime, sizeof(*ptLastTime),
                 JET_bitNewKey);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 pulObjectDnt, sizeof(*pulObjectDnt), 0);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 pulValueDnt, sizeof(*pulValueDnt), 0);

    if ((err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl,
                         JET_bitSeekGT))         != JET_errSuccess)
    {
        DPRINT(5, "GetNextDelRecord search complete");
        return DB_ERR_NO_MORE_DEL_RECORD;
    }

    /* Retrieve DEL time from record */
    
    JetRetrieveColumnSuccess( pDB->JetSessID,
                              pDB->JetLinkTbl,
                              linkdeltimeid,
                              ptLastTime, sizeof(*ptLastTime),
                              &actuallen,JET_bitRetrieveFromIndex, NULL);
    
    // Get the two link ends

    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                             linkdntid,
                             pulObjectDnt, sizeof(ULONG),
                             &actuallen, JET_bitRetrieveFromIndex, NULL);
    
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                             backlinkdntid,
                             pulValueDnt, sizeof(ULONG),
                             &actuallen, JET_bitRetrieveFromIndex, NULL);
    
    // Note, the records referred to by these DNTs may no longer exist
#if DBG
    {
        CHAR szTime[SZDSTIME_LEN], szTime1[SZDSTIME_LEN];
        DPRINT4( 2, "[%d,%d,%s,%s,DELETED]\n",
                 *pulObjectDnt,
                 *pulValueDnt,
                 DSTimeToDisplayString(*ptLastTime, szTime),
                 DSTimeToDisplayString(ageOutDate, szTime1) );
    }
#endif

    /* if time greater than target, there are no more eligible records */
    
    if (*ptLastTime > ageOutDate)
    {
        DPRINT(5, "GetNextDelLinkVal search complete");
        return DB_ERR_NO_MORE_DEL_RECORD;
    }
    
    return 0;
} /* DBGetNextDelLinkVal */

DWORD
DBTouchAllLinksHelp_AC(
        DBPOS *pDB,
        ATTCACHE *pAC,
        USN usnEarliest,
        BOOL fIsBacklink,
        DWORD cLinkLimit,
        DWORD *pcLinksProcessed
        )
/*++
  Description:

    Update the metadata on all links (present or absent), in a single
    direction (foward or backward), for the particular attribute.

    We use this function to authoritatively restore the links by forcing
    all of them to appear to be updated.

    We use USNs as a positioning context. We only touch links with USNs < x
    so that we don't retouch the same links if multiple passes are required
    to touch all the links. Note that we don't use times because we want to
    be immune to local clock changes.

  Parameters:
    pDB - DBPOS to use.
          We are assumed to be positioned on the object whose
          links are to be operated on.
    pAC - Restrict links to only this attribute. May be NULL.
    usnEarliest - Smallest usn permissable
    fIsBacklink - Which index should be used
    cLinkLimit - Maximum number of links to process.
                 Use 0xffffffff for infinite.
    pcLinksProcessed - Incremented for each link processed.
       Not cleared at start.

  Returns:
    BOOL - More data flag. TRUE means more data available
    It succeeds or excepts.
--*/
{

    JET_ERR          err;
    ULONG            ulObjectDnt = INVALIDDNT, 
                     ulValueDnt = INVALIDDNT;
    ULONG            ulLinkBase = 0, ulNewLinkBase = 0;
    DWORD            count;
    BOOL             fMoreData = TRUE;
    VALUE_META_DATA  metaDataLocal;
    DBPOS            *pDBForward;
    ATTCACHE         *pACForward;

    Assert(VALID_DBPOS(pDB));
    Assert( pDB->pTHS->fLinkedValueReplication );
    Assert( !pAC || ((ULONG) fIsBacklink) == FIsBacklink( pAC->ulLinkID ) );

    // set the index
    // Note that these indexes contain absent values. In the case of a group type
    // change, replicating absent values is consistent with a newly promoted GC,
    // which will have absent members. Also, in the case of object revival, it
    // is important to revive all links, not just present ones.
    //
    // UNDONE: add indexids for these indexes
    //
    JetSetCurrentIndexSuccess(pDB->JetSessID,
                              pDB->JetLinkTbl,
                              fIsBacklink ? SZBACKLINKALLINDEX : NULL); // OPTIMISATION: pass NULL when switching to primary index (SZLINKALLINDEX)

    // find first matching record
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetLinkTbl,
                 &(pDB->DNT),
                 sizeof(pDB->DNT),
                 JET_bitNewKey);

    if (pAC) {
        ulLinkBase = MakeLinkBase(pAC->ulLinkID);
        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &ulLinkBase, sizeof(ulLinkBase), 0);
        pACForward = pAC;
    }

    err = JetSeekEx(pDB->JetSessID,
                    pDB->JetLinkTbl,
                    JET_bitSeekGE);

    if ((err != JET_errSuccess) && (err != JET_wrnSeekNotEqual)) {
        // no records
        return FALSE;
    }

    count = 0;
    while ( count < cLinkLimit ) {
        // test to verify that we found a qualifying record
        dbGetLinkTableData (pDB,
                            fIsBacklink,           // fIsBacklink
                            FALSE,           // Warnings
                            &ulObjectDnt,
                            &ulValueDnt,
                            &ulNewLinkBase);

        if (ulObjectDnt != (pDB->DNT)) {
            // No more records.
            fMoreData = FALSE;
            break;
        }
        if (pAC) {
            // Attribute was specified, check we are still on it
            if (ulLinkBase != ulNewLinkBase) {
                // No more records.
                fMoreData = FALSE;
                break;
            }
        } else {
            // Attribute not specified, derive it from current link
            // Note that this derives the name of the *forward* link attribute
            // which may not exist on pDB if this is a backlink to him
            ULONG ulNewLinkID = MakeLinkId(ulNewLinkBase);

            pACForward = SCGetAttByLinkId(pDB->pTHS, ulNewLinkID);
            if (!pACForward) {
                DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, ulNewLinkID);
            }
        }

        // Touching metadata must proceed from the currency perspective of the
        // forward link holder. The link metadata routines are coded this way
        // and it seems simpler to keep them that way. Position a new DBPOS on
        // the forward link holder if necessary.

        if (fIsBacklink) {
            DBOpen2( FALSE /* not new trans */, &pDBForward );
            // Link table in new db should have same currency as old db

            // Reset vars from the point of view of the forward link holder
            Assert( ulObjectDnt == pDB->DNT );
            ulObjectDnt = ulValueDnt;
            ulValueDnt = pDB->DNT;
        } else {
            pDBForward = pDB;
        }
        __try {
            if (fIsBacklink) {
                BOOL fFound, fPresent;
                BYTE *rgb = NULL;
                ULONG cb;

                // Position on object owning the *forward* link
                DBFindDNT(pDBForward, ulObjectDnt);

                // What we are doing here is positioning the link table on the same
                // row in the new pDB as we current are in the old pDB.  Is there a better
                // way to clone the position of a cursor onto another?

                // Read the data portion of the name, if any. Used for positioning
                if (JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                              linkdataid,
                                              NULL, 0, &cb, 0, NULL) ==
                    JET_wrnBufferTruncated) {
                    // data portion of the OR name exists -allocate space and read it

                    rgb = THAllocEx( pDB->pTHS, cb);
                    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                             linkdataid, rgb, cb,
                                             &cb, 0, NULL);
                }
                else {
                    cb = 0;
                }

                // Position on link to be touched
                fFound = dbPositionOnExactLinkValue(
                    pDBForward,
                    ulObjectDnt,
                    ulNewLinkBase,
                    ulValueDnt,
                    rgb, cb,
                    NULL
                    );
                // Just found it a minute ago...
                Assert( fFound );
                if (!fFound) {
                    DsaExcept(DSA_DB_EXCEPTION, DB_ERR_VALUE_DOESNT_EXIST, linkdataid);
                }
                if (rgb) {
                    THFreeEx( pDB->pTHS, rgb );
                }
            }

            // Get the metadata
            DBGetLinkValueMetaData( pDBForward, pACForward, &metaDataLocal );

            // Has it already been updated? If not, do so
            // Note, this handles legacy values because their usnProperty == 0
            if (metaDataLocal.MetaData.usnProperty < usnEarliest) {

                // Touch the item
                // Note that this routine, by not setting the reset deltime argument,
                // will touch the metadata but not make an absent value present.
                // This is intended.
                dbSetLinkValuePresent( pDBForward,
                                       DIRLOG_LVR_SET_META_GROUP_TYPE_CHANGE,
                                       pACForward,
                                       FALSE /* don't reset deltime*/,
                                       NULL );
                count++;

                DPRINT3( 1, "Object %s attr %s Value %s touched.\n",
                         DBGetExtDnFromDnt( pDBForward, ulObjectDnt ),
                         pACForward->name,
                         DBGetExtDnFromDnt( pDBForward, ulValueDnt ) );
                LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_GC_UPDATED_OBJECT_VALUE,
                         szInsertSz( DBGetExtDnFromDnt( pDBForward, ulValueDnt ) ),
                         szInsertSz( DBGetExtDnFromDnt( pDBForward, ulObjectDnt ) ),
                         NULL);
            }
        } __finally {
            if (fIsBacklink) {
                DBClose( pDBForward, !AbnormalTermination() );
            }
        }

        if (JET_errNoCurrentRecord ==
            JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, 1, 0)) {
            // No more records.
            fMoreData = FALSE;
            break;
        }
    }

    if (pcLinksProcessed) {
        (*pcLinksProcessed) += count;
    }

    return fMoreData;
}

DWORD APIENTRY
DBTouchLinks_AC(
    DBPOS *pDB,
    ATTCACHE *pAC,
    BOOL fIsBacklink
    )

/*++

Routine Description:

    Touch links, causing them to be replicated out.

    Update the metadata on all links (present or absent), in a single
    direction (forward or backward), for the particular attribute.

    We use this function to authoritatively restore the links by forcing
    all of them to appear to be updated.

    This routine does some number of links immediately. If there are more,
    the object is marked for the link cleaner to finish the job.

    If we don't touch all the links immediately, there may be some delay before
    the link cleaner runs to finish the job. Thus the first links will appear
    almost immediately, while others make take 6 hours or more to appear.

    When the links are marked immediately, they are marked with current USNs.
    Since this routine is called before the group_type usn is assigned, the USNs
    on the touched links are less than the group type usn. This means that the
    link cleaner will touch those links again.

Arguments:

    pDB - We are assumed to be positioned on the object whose links
          are to be operated on.
    pAC - Attribute to touch. May be null, meaning to touch all linked attributes
    fIsBacklink - if backlinks should be touched
Return Value:

    DWORD APIENTRY - 

--*/

{
    BOOL fMoreLinks;

    Assert(VALID_DBPOS(pDB));
    Assert( !pAC || ((ULONG) fIsBacklink) == FIsBacklink( pAC->ulLinkID ) );

    DPRINT2( 2, "DBTouchLinks_AC, dnt = %d, attr = %s\n",
             pDB->DNT, pAC ? pAC->name : "all" );

    // Touch all forward links

    fMoreLinks = DBTouchAllLinksHelp_AC(
        pDB, // object has currency
        pAC, // Attribute to remove
        DBGetHighestCommittedUSN(), // Default to current USN
        fIsBacklink, // Which links to touch
        gcLinksProcessedImmediately,  // how many to process
        NULL // no processed count
        );
    if (fMoreLinks) {
        // Didn't clean up all the links - object needs cleaning
        DBSetObjectNeedsCleaning( pDB, TRUE );
    }

    return 0;
} /* DBTouchLinks_AC */


VOID
DBImproveAttrMetaDataFromLinkMetaData(
    IN DBPOS *pDB,
    IN OUT PROPERTY_META_DATA_VECTOR ** ppMetaDataVec,
    IN OUT DWORD * pcbMetaDataVecAlloced
    )

/*++

Routine Description:

    Improve attribute metadata to account for metadata on its linked values.
    The resulting vector represents changes for all attributes. This modified
    vector is useful for clients that expect all attributes and metadaa to
    be included in the attribute metadata vector.

    For each linked attribute of the current object, find the row with the
    greatest usn-changed. Consider this row representative for the attribute
    and merge its metadata into the vector.

    This vector should not be written to disk or returned over the wire.

    Obviously, knowledge of incremental value changes is lost in the resulting
    vector. It can only express at a whole attribute level whether the attribute
    has changed or not.

    Direct usn-property filtering by comparing usn-changed should be accurate.
    Since the representative row is the last-written row, we can tell whether the
    client has seen the last row, and hence whether the client is current with
    the attribute as a whole, or not.

    Filtering using the up to date vector could be inaccurate. If the client has
    seen the representative row by virtue of transitive replication, that does
    not mean that the client has seen all other rows on the attribute. Each value
    on the attribute could have originated on a different dsa.

Arguments:

    pDB - 
    usnHighPropUpdateDest -
    pMetaDataVec - 

Return Value:

   Exceptions on error

--*/

{
    JET_ERR err;
    ULONG ulTargetDnt = pDB->DNT, ulLinkBase = 0, ulNewLinkID;
    ATTCACHE *pAC;
    VALUE_META_DATA metaDataValue;
    PROPERTY_META_DATA * pMetaData;
    BOOL fIsNewElement;

    JetSetCurrentIndex4Success(
                pDB->JetSessID,
                pDB->JetLinkTbl,
                SZLINKATTRUSNINDEX,
                &idxLinkAttrUsn,
                JET_bitMoveFirst );

    while (1) {
        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &(ulTargetDnt), sizeof(ulTargetDnt), JET_bitNewKey);

        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &ulLinkBase, sizeof(ulLinkBase), 0);

        // seek
        if (((err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE))
             !=  JET_errSuccess) &&
            (err != JET_wrnRecordFoundGreater))
        {
            // end of table, we're done
            break;
        }

        dbGetLinkTableData(pDB,
                           FALSE,
                           FALSE,
                           &ulTargetDnt,
                           NULL, // pulValueDnt
                           &ulLinkBase);
        if (ulTargetDnt != pDB->DNT) {
            // Have moved off current object, we're done
            break;
        }

        // Construct a pAC for the current attribute

        ulNewLinkID = MakeLinkId(ulLinkBase);

        pAC = SCGetAttByLinkId(pDB->pTHS, ulNewLinkID);
        if (!pAC) {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, ulNewLinkID);
        }

        // By virtue of the way this index is organized, the first record
        // matching this key will be the highest usn for this attribute

        DBGetLinkValueMetaData( pDB, pAC, &metaDataValue );

        // Legacy rows will not have usn's, and will not be on this index
        Assert( !IsLegacyValueMetaData( &metaDataValue ) );

        DPRINT4( 4, "dnt=%d,attr=%s,ver=%d,usnprop=%I64d\n",
                 ulTargetDnt,
                 pAC->name,
                 metaDataValue.MetaData.dwVersion,
                 metaDataValue.MetaData.usnOriginating );

        // Merge it in.
        // Value metadata should always be more recent than legacy attr metadata

        // Find or add a meta data entry for this attribute.
        pMetaData = ReplInsertMetaData(
            pDB->pTHS,
            pAC->id,
            ppMetaDataVec,
            pcbMetaDataVecAlloced,
            &fIsNewElement );

        Assert( NULL != pMetaData );
        Assert( pAC->id == pMetaData->attrType );

        // We must be careful with any claims about the relationship between the
        // metadata of the most recently changed value and the attribute metadata
        // which may or may not exist.  On an intuitive level, the value metadata
        // should be "more recent" in the sense that it should have been changed
        // after the last attribute level update in the old mode.  However, we
        // cannot use ReplCompareMetaData to check this since the version numbers
        // of the two pieces of metadata are not directly comparable.  We also do
        // not wish to use timestamps, since we do not depend on them for
        // correctness. Since we are on the same machine, we can check the local
        // USNs assigned to both updates.

        // If metadata already exists in the vector, it should lose to
        // new metadata
        Assert( fIsNewElement ||
                pMetaData->usnProperty < metaDataValue.MetaData.usnProperty );

        // Improve
        memcpy( pMetaData, &(metaDataValue.MetaData), sizeof( PROPERTY_META_DATA ) );

        // Set the improved uuidDsaOriginating to null, so that checks based on
        // the up to date vector will always ship the attribute.

        memset( &(pMetaData->uuidDsaOriginating), 0, sizeof( UUID ) );
        // usnOriginating must be non-zero for later consistency checks

        // Next attribute
        ulLinkBase++;
    }

    VALIDATE_META_DATA_VECTOR_VERSION(*ppMetaDataVec);
} /* DBImproveLinkMetaDataToAttrMetaData */

/* end dblink.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbobj.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbobj.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <dsatools.h>                   // For pTHStls
#include <mdlocal.h>                    // IsRoot
#include <ntseapi.h>
#include <xdommove.h>

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>
#include "ntdsctr.h"

// Assorted DSA headers
#include "dsevent.h"
#include "dstaskq.h"
#include "dstrace.h"       /* needed for GetCallerTypeString*/
#include "objids.h"        /* needed for ATT_MEMBER and ATT_IS_MEMBER_OFDL */
#include <dsexcept.h>
#include <filtypes.h>      /* Def of FI_CHOICE_???                  */
#include <anchor.h>
#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DBOBJ:" /* define the subsystem for debugging */
#include <dsutil.h>

// DBLayer includes
#include "dbintrnl.h"

// Replication includes
#include "ReplStructInfo.hxx"

#include <fileno.h>
#define  FILENO FILENO_DBOBJ

/* Internal functions */

extern DWORD dbGetConstructedAtt(
   DBPOS **ppDB,
   ATTCACHE *pAC,
   ATTR *pAttr,
   DWORD dwBaseIndex,
   PDWORD pdwNumRequested,
   const BOOL fUsingDefaultRange,
   PSID psidQuotaTrustee,
   const BOOL fExternal
);

DWORD
dbSetValueIfUniqueSlowVersion (
        DBPOS *pDB,
        ATTCACHE *pAC,
        PUCHAR pVal,
        DWORD  valLen);

DNList  *pAddListHead = NULL;
extern CRITICAL_SECTION csAddList;

DWORD gMaxTransactionTime;   // the threshold for logging a long-running transaction(in tick)

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*
Routine Description:

   Open a database handle by allocating and initializing the value
   and DBPOS structures.  Create unique JET session, database, data table
   and search table ids for the DBPOS. Create an "INSERT" JET copy buffer.
   Callers to this routine must have both a thread state (from
   create_thread_state) and a JET session id and DBid (from InitJetThread)

Arguments:

   fNewTransaction - TRUE/FALSE whether to open a new nested transaction

   pPDB - where to store the newly opened DBPOS

Return Value:

   Throws an exception on error.

*/


void
DBOpen2(BOOL fNewTransaction, DBPOS FAR **pPDB)
{
    THSTATE *pTHS = pTHStls;
    DBPOS FAR *pDB;

    DPRINT(2, "DBOpen entered\n");

    pDB = NULL;  /*Needed for bootstrap incase initial allocation fails*/

    if (eServiceShutdown) {
        if (   (eServiceShutdown >= eSecuringDatabase)
            || (    pTHS->fSAM
                || !pTHS->fDSA)) {
            RaiseDsaExcept(DSA_DB_EXCEPTION,
                           DIRERR_SHUTTING_DOWN,
                           0,
                           DSID(FILENO,__LINE__),
                           DS_EVENT_SEV_NO_LOGGING);
        }
    }

    Assert(pTHS);

    if ((&(pTHS->pDB) == pPDB) && (pTHS->pDB)){
        /* Already have a dbPos for this THSTATE. */
        DPRINT(0,"DBOpen, pTHS->pDB pDB exists, exiting\n");
#ifdef INCLUDE_UNIT_TESTS
        DebugBreak();
#endif
        PREFIX_ASSUME((*pPDB == pTHS->pDB), "Already have a dbPos for this THSTATE");
        return;
    }

    // dbAlloc zero's the allocated memory.
    pDB = dbAlloc(sizeof(DBPOS));

    /* Initialize value work buffer */

    DPRINT(5, "ALLOC and valBuf\n");
    pDB->pTHS = pTHS;
    pDB->pValBuf = NULL;
    pDB->valBufSize = 0;
    pDB->Key.pFilter = NULL;
    pDB->transType = pTHS->transType;
    pDB->transincount = 0;
    pDB->NewlyCreatedDNT = INVALIDDNT;
#if DBG
     pDB->TransactionLevelAtOpen = pTHS->transactionlevel;
#endif

    Assert(pTHS->JetCache.sesid);

    // get thread's JET session for new pDB
    pDB->JetSessID = pTHS->JetCache.sesid;
    pDB->JetDBID = pTHS->JetCache.dbid;

    // these cursors are defer-opened
    pDB->JetLinkEnumTbl = JET_tableidNil;

    __try {
        if (pTHS->JetCache.tablesInUse) {
            // The cached set of tables for this session is already in use,
            // so we need to open a new set.
    
            // Note that the table handles in the cache are still valid, though,
            // so that instead of having to open a new set we can just duplicate
            // them, which is much faster.  The one oddity is that we don't know
            // whether or not it is legal/valid/safe to duplicate a cursor that
            // is in the middle of an update, and that being in the middle of
            // an update is the general reason that we end up calling DBOpen
            // to begin with.  However, only the objtbl cursor could be in the
            // middle of an update, since all updates on the link or search tables
            // are completed as soon as they're begun.  Since the search table
            // is nothing but a duplicate of the obj table to begin with, we
            // can safely duplicate the other direction to get an update-free
            // cursor.
    
            // Open the data table, from the cached search table
            JetDupCursorEx(pDB->JetSessID,
                           pTHS->JetCache.searchtbl,
                           &pDB->JetObjTbl,
                           NO_GRBIT);
    
            // and the search table, from where you'd expect
            JetDupCursorEx(pDB->JetSessID,
                           pTHS->JetCache.searchtbl,
                           &pDB->JetSearchTbl,
                           NO_GRBIT);
    
            // and the link table
            JetDupCursorEx(pDB->JetSessID,
                           pTHS->JetCache.linktbl,
                           &pDB->JetLinkTbl,
                           NO_GRBIT);
    
            // and the propagator
            JetDupCursorEx(pDB->JetSessID,
                           pTHS->JetCache.sdproptbl,
                           &pDB->JetSDPropTbl,
                           NO_GRBIT);
    
            // and the SD table
            JetDupCursorEx(pDB->JetSessID,
                           pTHS->JetCache.sdtbl,
                           &pDB->JetSDTbl,
                           NO_GRBIT);

            // NOTE: Primary index is set by default on the duped cursor.
        }
        else {
            // The cached set of tables for this session is still available,
            // so all we need to do is copy the handles and mark them as in use.
    
            pDB->JetObjTbl = pTHS->JetCache.objtbl;
            pDB->JetSearchTbl = pTHS->JetCache.searchtbl;
            pDB->JetLinkTbl = pTHS->JetCache.linktbl;
            pDB->JetSDPropTbl = pTHS->JetCache.sdproptbl;
            pDB->JetSDTbl = pTHS->JetCache.sdtbl;
            pTHS->JetCache.tablesInUse = TRUE;
        }
    
        // Initialize new object
    
        DBSetFilter(pDB, NULL,NULL, NULL, 0,NULL);
        DBInitObj(pDB);
        if(fNewTransaction) {
            DBTransIn(pDB);
        }
    }
    __finally {
        if (AbnormalTermination()) {
            // we have excepted somewhere on the way, let's free the 
            // resources we managed to allocate
            if (pDB->JetObjTbl == pTHS->JetCache.objtbl) {
                // We used tables from pTHS->JetCache. Just mark them
                // as unused.
                pTHS->JetCache.tablesInUse = FALSE;
            }
            else {
                // We duplicated cursors. Just free them.
                if (pDB->JetObjTbl) {
                    JetCloseTable(pDB->JetSessID, pDB->JetObjTbl);
                }
                if (pDB->JetSearchTbl) {
                    JetCloseTable(pDB->JetSessID, pDB->JetSearchTbl);
                }
                if (pDB->JetLinkTbl) {
                    JetCloseTable(pDB->JetSessID, pDB->JetLinkTbl);
                }
                if (pDB->JetSDPropTbl) {
                    JetCloseTable(pDB->JetSessID, pDB->JetSDPropTbl);
                }
                if (pDB->JetSDTbl) {
                    JetCloseTable(pDB->JetSessID, pDB->JetSDTbl);
                }
                Assert( JET_tableidNil == pDB->JetLinkEnumTbl );
            }
            dbFree(pDB);
        }
    }
    
    // IMPORTANT: the code below should not except, otherwise
    // we will leak jet resources that have been allocated above.

    *pPDB = pDB;
    pTHS->opendbcount++;
    
#if DBG
    //
    // In debug builds set some tracking information
    //

    pTHS->Totaldbpos++;
    Assert(pTHS->opendbcount<MAX_PDB_COUNT);
    pTHS->pDBList[pTHS->opendbcount-1]= pDB;
    dbAddDBPOS (pDB, pTHS->JetCache.sesid);
#endif

    DPRINT1(2, "DBOpen complete pDB:%x\n", pDB);
    return;

}/*DBOpen*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Close the database handle by freeing all the resources associated with
   the handle. Free value buffer, and close the JET session
   (this will free all JET resources).  If this set of database tables are
   the set being cached for this JET session then we rely on DBCloseThread
   to actually do the resource freeing.
*/
DWORD APIENTRY
DBClose(DBPOS FAR *pDB, BOOL fCommit)
{
    DWORD TimeDiff;
    THSTATE *pTHS=pTHStls;

    if (!pDB)
    {
        DPRINT(0,"DBClose, pDB already freed, exiting\n");
#ifdef INCLUDE_UNIT_TESTS
        DebugBreak();
#endif
        return 0;
    }

    Assert(VALID_DBPOS(pDB));

    __try
    {
        if(pDB->transincount) {

            if (fCommit) {

                TimeDiff = GetTickCount() - pTHS->JetCache.cTickTransLevel1Started;

                // If a transaction lasts longer than expected, let's log it

                if ( TimeDiff > gMaxTransactionTime ) {
                    LogEvent(
                             DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_OVERLONG_TRANSACTION,
                             szInsertUL( TimeDiff/(60*1000) ),         //minutes
                             szInsertUL( TimeDiff/1000%60),            //seconds
                             szInsertSz( GetCallerTypeString(pTHS) )   //caller type
                             );
                }

                // if Commit is specified then assert that the transin
                // level is 1. Caller is responsible for calling DBTransOut
                // on all nested transactions  that were explicitly opened
                // using DBTransOut.

                Assert(1==pDB->transincount);
                DBTransOut(pDB, fCommit, FALSE);

            }
        }
    }
    __finally
    {
        // Free JET resources
        DBCloseSortTable(pDB);

        // Free Jet Resources
        dbCloseTempTables (pDB);

        // Free still more Jet resources
        // WARNING: errors are ignored here (it's probably too
        // late to do anything about the error, but at least
        // assert against errors to catch inadvertent leaks)
        if (JET_tableidNil != pDB->JetLinkEnumTbl) {
            const JET_ERR errT = JetCloseTable(pDB->JetSessID, pDB->JetLinkEnumTbl);
            Assert( JET_errSuccess == errT );
        }

        // Rollback any open transactions we have at this point
        // Note for the commit case we should have committed with the
        // DBTransOut in the try and hence our pDB->transincount
        // should be 0. So we will not acutally try to rollback.
        // Also note that we always rollback till level 0.

        while(pDB->transincount)
        {
            DBTransOut(pDB,FALSE,FALSE);
        }

        if (pDB->JetObjTbl == pTHS->JetCache.objtbl) {
                // This is the cached set of tables for this session.  Don't
                // close them, just mark them as available again.
                Assert(pDB->JetSearchTbl == pTHS->JetCache.searchtbl);
                Assert(pDB->JetLinkTbl == pTHS->JetCache.linktbl);
                Assert(pDB->JetSDPropTbl == pTHS->JetCache.sdproptbl);
                Assert(pDB->JetSDTbl == pTHS->JetCache.sdtbl);
                Assert(pTHS->JetCache.tablesInUse);
                pTHS->JetCache.tablesInUse = FALSE;
        }
        else {
                // This is some nested set of tables.  Junk'em.
                Assert(pDB->JetSearchTbl != pTHS->JetCache.searchtbl);
                Assert(pDB->JetLinkTbl != pTHS->JetCache.linktbl);
                Assert(pDB->JetSDPropTbl != pTHS->JetCache.sdproptbl);
                Assert(pDB->JetSDTbl != pTHS->JetCache.sdtbl);
                JetCloseTableEx(pDB->JetSessID, pDB->JetObjTbl);
                JetCloseTableEx(pDB->JetSessID, pDB->JetSearchTbl);
                JetCloseTableEx(pDB->JetSessID, pDB->JetLinkTbl);
                JetCloseTableEx(pDB->JetSessID, pDB->JetSDPropTbl);
                JetCloseTableEx(pDB->JetSessID, pDB->JetSDTbl);
        }


        Assert (pDB->numTempTablesOpened == 0);

        // Free work buffers

        dbFree(pDB->pValBuf);

        if (pDB->fIsMetaDataCached) {
            dbFreeMetaDataVector(pDB);
        }

        Assert (pDB->transincount == 0);

        Assert (pDB->pDNsAdded == NULL);

        // free the filter used
        if (pDB->Key.pFilter) {
            dbFreeFilter (pDB, pDB->Key.pFilter);
        }

        // Free the database anchor

        dbFree(pDB);

#if DBG
        dbEndDBPOS (pDB);
#endif


        // Zero out the pDB pointer so we don't reuse it in error

        if (pTHS->pDB == pDB){
            pTHS->pDB = NULL;
        }

        pTHS->opendbcount--;
    }

    return 0;

}/*DBClose*/


DWORD APIENTRY
DBCloseSafe(DBPOS *pDB, BOOL fCommit)
{
    DWORD err;

    __try {
        err = DBClose(pDB, fCommit);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        err = DB_ERR_EXCEPTION;
    }

    return err;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Initialize the pDB and create a new record
*/
DWORD APIENTRY
DBInitObj(DBPOS FAR *pDB)
{

    dbInitpDB(pDB);
    pDB->JetNewRec = TRUE;

    return 0;
}               /*DBInitObj*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Initialize the pDB
*/
DWORD APIENTRY
dbInitpDB(DBPOS FAR *pDB)
{
    (pDB)->root         = FALSE;
    (pDB)->DNT          = ROOTTAG;
    (pDB)->PDNT         = 0L;

    // Initialize key

    pDB->Key.fSearchInProgress = FALSE;
    pDB->Key.ulSearchType = 0;
    pDB->Key.ulSearchRootDnt = 0;

    if (pDB->Key.pFilter) {
        dbFreeFilter (pDB, pDB->Key.pFilter);
        pDB->Key.pFilter = NULL;
    }
    if (pDB->Key.pIndex) {
        dbFreeKeyIndex(pDB->pTHS, pDB->Key.pIndex);
        pDB->Key.pIndex = NULL;
    }

    // If there is a record in the copy buffer, kill it

    DBCancelRec(pDB);

    return 0;
}


// returns: 0 - found next att; 1 - no more atts

DWORD APIENTRY
dbGetNextAttLinkTable (DBPOS FAR *pDB,
                       ATTCACHE **pAC,
                       ULONG SearchState
                       )
{

    JET_ERR         err;
    ULONG           cb;
    ULONG           ulLinkBase;
    ULONG           ulNewLinkBase, ulNewLinkID;
    ULONG           ulObjectDnt;
    CHAR *          szIndexName;
    JET_INDEXID *   pindexid;

    Assert(VALID_DBPOS(pDB));

    ulLinkBase = ( *pAC ? MakeLinkBase((*pAC)->ulLinkID) + 1 : 0 );

    if(SearchState == ATTRSEARCHSTATELINKS) {
        szIndexName = ( pDB->fScopeLegacyLinks ? SZLINKLEGACYINDEX : SZLINKINDEX );
        pindexid = ( pDB->fScopeLegacyLinks ? &idxLinkLegacy : &idxLink );
    }
    else {
        szIndexName = SZBACKLINKINDEX;
        pindexid = &idxBackLink;
    }

    JetSetCurrentIndex4Success(
                pDB->JetSessID,
                pDB->JetLinkTbl,
                szIndexName,
                pindexid,
                JET_bitMoveFirst );

 TryAgain:
     // find the next record


    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl, &(pDB->DNT),
        sizeof(pDB->DNT), JET_bitNewKey);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
        &ulLinkBase, sizeof(ulLinkBase), 0);
    err = JetSeekEx(pDB->JetSessID,
        pDB->JetLinkTbl, JET_bitSeekGE);

    if ((err != JET_errSuccess) && (err != JET_wrnSeekNotEqual))
    {
        // no more records - return
        return 1;
    }

    // test to verify that we found a qualifying record
    dbGetLinkTableData (pDB,
                        (SearchState != ATTRSEARCHSTATELINKS),
                        FALSE,
                        &ulObjectDnt,
                        NULL,
                        &ulNewLinkBase);
    PREFIX_ASSUME(ulNewLinkBase, "dbGetLinkTableData raises exception on failure");

    if (ulObjectDnt != pDB->DNT)
    {
        //  record out of range - no more records so return

        return 1;
    }

    // we found the next attribute - set set up

    if(SearchState == ATTRSEARCHSTATELINKS)
        ulNewLinkID = MakeLinkId(ulNewLinkBase);
    else
        ulNewLinkID = MakeBacklinkId(ulNewLinkBase);

    if (!(*pAC = SCGetAttByLinkId(pDB->pTHS, ulNewLinkID))) {
        DPRINT1(1, "dbGetNextAttLinkTable Invalid Link Id:%ld\n",
                ulNewLinkBase);
        // We've encountered a record whose link base does not map to a
        // link or backlink attribute properly.  If we're looking for
        // backlinks, that just means that this is one of those rare
        // linked attributes for which no backlink is defined, which is
        // perfectly ok.  If we're looking for links, on the other hand,
        // that would mean that we found a backlink for which no link
        // exists, which is perfectly useless.
        Assert(SearchState != ATTRSEARCHSTATELINKS);
        ulLinkBase = ulNewLinkBase + 1;
        goto TryAgain;

    }

    return 0;
} /* dbGetNextAttLinkTable */

DWORD
dbGetNextAtt (
        DBPOS FAR *pDB,
        ATTCACHE **ppAC,
        ULONG *pSearchState
        )
/*++

Routine Description:

    Get the attcache of the next attribute in the link table.

Arguments:

    pDB - the DBPos to use.

    ppAC - pointer to pointer to attcache.  If an attcache is supplied, we
    will look forward in the link table for the next attribute.

    pSearchState - the current search state.  Must be ATTRSEARCHSTATELINKS
    (implying we are looking for link attributes) or ATTRSEARCHSTATEBACKLINKS
    (implying we are looking for backlink attributes).  We update this to
    backlinks after we are done looking for links.

Return Values:

    0 if we found an attribute, 1 otherwise.
    ppAC is filled with the attribute we found.
    pSearchState may be updated to show we are looking for backlinks.

    Note that if pSearchState is ATTRSEARCHSTATELINKS, we will return the first
    link OR backlink, while if pSearchState is ATTRSEARCHSTATEBACKLINKS, we
    will only return backlinks

--*/
{

   // find the first attr after the current attr with a different type

   DPRINT(2, "dbGetNextAtt entered\n");

   Assert(VALID_DBPOS(pDB));

   while (1)
   {
       switch (*pSearchState) {
       case ATTRSEARCHSTATELINKS:
           if (!dbGetNextAttLinkTable(pDB,
                                      ppAC,
                                      *pSearchState))
               return 0;

           // no more link attributes - look for backlinks
           *pSearchState = ATTRSEARCHSTATEBACKLINKS;
           *ppAC = NULL;
           break;

       case ATTRSEARCHSTATEBACKLINKS:
           if (!dbGetNextAttLinkTable(pDB,
                                      ppAC,
                                      *pSearchState))
               return 0;

           // no more backlink attributes - we're done

           return 1;

       default:
           Assert(FALSE);       // we should never be here
           return 1;
       }
   }
} /* dbGetNextAtt */

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Get the Nth attribute value.
   A non-zero return indicates that the requested value doesn't exist.

   The caller can choose to have values returned in internal or external
   format.

   return 0 - found value
   return DB_ERR_NO_VALUE - didn't find value
   return DB_ERR_BUFFER_INADEQUATE - buffer provided was not big enough
   return DB_ERR_UNKNOWN_ERROR - some other error

   NOTE!!!! This routine does not pass any SecurityDescriptorFlags to the
   internal to external data format conversions.  What this means is that you
   will always get back ALL parts of a Security Descriptor using this routine.
   DBGetMultipeAtts is wired to use SecurityDescriptorFlags, if it is important
   to you to trim parts from the SD, use that routine.

*/
DWORD
DBGetAttVal_AC (
        DBPOS FAR *pDB,
        DWORD tagSequence,
        ATTCACHE *pAC,
        DWORD Flags,
        ULONG InBuffSize,
        ULONG *pLen,
        UCHAR **ppVal
        )
{
    THSTATE             *pTHS=pDB->pTHS;
    JET_RETINFO         retinfo;
    JET_ERR             err;
    ULONG               actuallen = 0;
    int                 rtn;
    BOOL                MakeExt=!(Flags & DBGETATTVAL_fINTERNAL);
    BOOL                fReallocDown = FALSE;
    DWORD               dwSyntaxFlag = 0;
    JET_TABLEID         jTbl;

    if(Flags & DBGETATTVAL_fUSESEARCHTABLE) {
        jTbl = pDB->JetSearchTbl;
    }
    else {
        jTbl =  pDB->JetObjTbl;
    }

    if(Flags & DBGETATTVAL_fSHORTNAME) {
        dwSyntaxFlag = INTEXT_SHORTNAME;
    }
    else if(Flags &  DBGETATTVAL_fMAPINAME) {
        dwSyntaxFlag = INTEXT_MAPINAME;
    }

    DPRINT2(2, "DBGetAttVal_AC entered, fetching 0x%x (%s)\n",
            pAC->id, pAC->name);

    Assert(VALID_DBPOS(pDB));
    Assert(!(Flags & DBGETATTVAL_fCONSTANT) || ((PUCHAR)pLen != *ppVal));
    Assert(tagSequence != 0);  // tags are 1-based, not 0-based

    if (!InBuffSize && (Flags & DBGETATTVAL_fREALLOC)) {
        // We have been given permission to realloc, but nothing has been
        // alloced.  This is the same case as if we were not given realloc
        // permission and so must just alloc.  Unset the realloc flag, leaving
        // us at the default behaviour, which is to alloc.
        Flags = Flags & ~DBGETATTVAL_fREALLOC;
    }

    if(!(Flags & DBGETATTVAL_fCONSTANT) && !(Flags & DBGETATTVAL_fREALLOC)) {
        // Since we don't have a currently existing buffer, make sure the
        // InBuffSize is 0
        InBuffSize = 0;
    }

    // if this attribute is stored in the link table get it differently
    if (pAC->ulLinkID) {
        if (err = dbGetLinkVal(pDB,
                               tagSequence,
                               &pAC,
                               Flags,
                               InBuffSize,
                               ppVal,
                               &actuallen)) {
            return err;
        }
        // dbGetLinkVal makes sure that a big enough buffer already exists, so
        // set the InBuffSize to be big enough here so that we pass the checks
        // we make later during conversion to external format.
        InBuffSize = max(InBuffSize,actuallen);
    }
    else {
        // other attributes are columns in the data table record
        retinfo.cbStruct = sizeof(retinfo);
        retinfo.ibLongValue = 0;
        retinfo.itagSequence = tagSequence;
        retinfo.columnidNextTagged = 0;

        if ((0 == InBuffSize) &&
            !(Flags & DBGETATTVAL_fCONSTANT)) {
            // We *know* that the Jet call will fail with inadequate
            // buffer, because we don't have a buffer, and we also know
            // that the user wants us to alloc a buffer for him.
            // Since a realloc is felt to be cheaper than a Jet call,
            // let's fake up a buffer now based on the schema size for
            // this att and give that a try.
            switch (pAC->syntax) {
              case SYNTAX_OBJECT_ID_TYPE:
              case SYNTAX_INTEGER_TYPE:
                InBuffSize = sizeof(LONG);
                break;
              case SYNTAX_TIME_TYPE:
                InBuffSize = sizeof(DSTIME);
                break;
              case SYNTAX_I8_TYPE:
                InBuffSize = sizeof(LARGE_INTEGER);
                break;
              case SYNTAX_BOOLEAN_TYPE:
                InBuffSize = sizeof(BOOL);
                break;
              case SYNTAX_UNICODE_TYPE:
                if (pAC->rangeUpperPresent) {
                    InBuffSize = min(pAC->rangeUpper*sizeof(WCHAR), 1000);
                }
                break;
              case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
                if (pAC->rangeUpperPresent) {
                    InBuffSize = min(pAC->rangeUpper, DEFAULT_SD_SIZE);
                }
                break;
              case SYNTAX_OCTET_STRING_TYPE:
              case SYNTAX_SID_TYPE:
              case SYNTAX_CASE_STRING_TYPE:
              case SYNTAX_NOCASE_STRING_TYPE:
              case SYNTAX_PRINT_CASE_STRING_TYPE:
              case SYNTAX_NUMERIC_STRING_TYPE:
                if (pAC->rangeUpperPresent) {
                    InBuffSize = min(pAC->rangeUpper, 1000);
                }
                break;
              case SYNTAX_DISTNAME_TYPE:
              case SYNTAX_DISTNAME_STRING_TYPE:
              case SYNTAX_DISTNAME_BINARY_TYPE:
              case SYNTAX_ADDRESS_TYPE:
                InBuffSize = DSNameSizeFromLen(MAX_RDN_SIZE);
                break;
              default:
                // Confusion.  Just don't do it.
                ;
            }
            if (InBuffSize) {
                *ppVal = THAllocEx(pTHS, InBuffSize);
                fReallocDown = TRUE;
            }
        }

        err = JetRetrieveColumnWarnings(
                pDB->JetSessID,
                jTbl,
                pAC->jColid,
                *ppVal,
                InBuffSize,
                &actuallen,
                pDB->JetRetrieveBits,
                &retinfo);

        if(err == JET_wrnBufferTruncated) {
            if (Flags & DBGETATTVAL_fCONSTANT)
                return DB_ERR_BUFFER_INADEQUATE;
            else if((Flags & DBGETATTVAL_fREALLOC) || fReallocDown) {
                // Buff given was too small.  THReAlloc it.
                Assert(InBuffSize < actuallen);
                *ppVal = THReAllocEx(pTHS, *ppVal, actuallen);
                InBuffSize = actuallen;
            }
            else {
                *ppVal = THAllocEx(pTHS, actuallen);
                 InBuffSize = actuallen;
            }

            err = JetRetrieveColumnWarnings(
                    pDB->JetSessID,
                    jTbl,
                    pAC->jColid,
                    *ppVal,
                    actuallen,
                    &actuallen,
                    pDB->JetRetrieveBits,
                    &retinfo);
            if(err) {
                if(fReallocDown ||
                   !(Flags & (DBGETATTVAL_fCONSTANT | DBGETATTVAL_fREALLOC))) {
                    // Hey, we just allocated this.
                    THFreeEx(pTHS, *ppVal);
                    *ppVal = NULL;
                }
                return DB_ERR_UNKNOWN_ERROR;
            }
        }

        if(err) {
            if (fReallocDown) {
                THFreeEx(pTHS, *ppVal);
                *ppVal = NULL;
            }

            // if we are trying to read the SD and this is NULL then
            // we enqueue a SD propagation to fix this.
            // Exception to this is when we deliberately try to remove
            // an attribute from this object (from DBRemAtt*)

            if(pAC->id == ATT_NT_SECURITY_DESCRIPTOR &&
               tagSequence == 1 &&
               err == JET_wrnColumnNull &&
               !(Flags & DBGETATTVAL_fUSESEARCHTABLE) &&
               !(Flags & DBGETATTVAL_fDONT_FIX_MISSING_SD)) {
                // Security descriptor has no value in the object table.
                // Enqueue a propagation to get this fixed.
                DPRINT1(0, "NULL SD found, enqueueing SD propagation for DNT=%d\n", pDB->DNT);
                InsertInTaskQueue(TQ_DelayedSDPropEnqueue,
                                  (void *)((DWORD_PTR) pDB->DNT),
                                  1);
            }
            // NOTE: the caller may have supplied a buffer.  With this error, we
            // are not telling them about any reallocing we may have done
            // (which, if we did it, would only be to allocate it larger), and
            // we are not touching *pLen, so if they are not tracking the size
            // of their buffer correctly could cause them to leak buffers
            // (i.e. if they aren't tracking the max size of the buffer returned
            // to them, but only the current size, they may think that the
            // current size is 0 after this call, and if they call back in with
            // InBuffSize of 0, even if they have a pointer to valid memory, we
            // will do a THAlloc and lose their buffer).
            return DB_ERR_NO_VALUE;
        }

    }

    *pLen = actuallen;

    // Convert DB value to external format if so desired.

    if (MakeExt) {
        ULONG extLen;
        PUCHAR pExtVal=NULL;

        // Find out if there any special handling
        // is required for this attribute.
        dwSyntaxFlag|=DBGetExtraHackyFlags(pAC->id);

        // Enable encryption or decryption if the
        // attribute is a secret data
        if (DBIsSecretData(pAC->id))
           dwSyntaxFlag|=INTEXT_SECRETDATA;

        if (rtn = gDBSyntax[pAC->syntax].IntExt (
                pDB,
                DBSYN_INQ,
                *pLen,
                *ppVal,
                &extLen,
                &pExtVal,
                0, 0,
                dwSyntaxFlag)) {
            if (Flags & DBGETATTVAL_fDONT_EXCEPT_ON_CONVERSION_ERRORS) {
                if (fReallocDown) {
                    THFreeEx(pTHS, *ppVal);
                    *ppVal = NULL;
                }
                return DB_ERR_SYNTAX_CONVERSION_FAILED;
            }
            DsaExcept(DSA_EXCEPTION, DIRERR_BAD_ATT_SYNTAX, rtn);
        }

        if(Flags & DBGETATTVAL_fCONSTANT) {
            // Existing buffer, better be room.  We'll check later.
        }
        else {
            if(InBuffSize < extLen &&
               *pLen < extLen) {
                // Reallocable buffer,
                *ppVal = THReAllocEx(pTHS, *ppVal, extLen);
                InBuffSize = extLen;
            }
        }

        if(InBuffSize < extLen)
            return DB_ERR_BUFFER_INADEQUATE;

        *pLen = extLen;

        memcpy(*ppVal, pExtVal, extLen);
    }

    if (fReallocDown && (InBuffSize > *pLen)) {
        *ppVal = THReAllocEx(pTHS, *ppVal, *pLen);
    }
    DPRINT1(2,"DBGetAttVal_AC: complete  val:<%s>\n",
            asciiz(*ppVal,(USHORT)*pLen));
    return 0;

} /* DBGetAttVal_AC */

DWORD
DBGetAttVal (
        DBPOS FAR *pDB,
        DWORD tagSequence,
        ATTRTYP aType,
        DWORD Flags,
        ULONG InBuffSize,
        ULONG *pLen,
        UCHAR **ppVal
        )
/*++

   NOTE!!!! This routine does not pass any SecurityDescriptorFlags to the
   internal to external data format conversions.  What this means is that you
   will always get back ALL parts of a Security Descriptor using this routine.
   DBGetMultipeAtts is wired to use SecurityDescriptorFlags, if it is important
   to you to trim parts from the SD, use that routine.

--*/
{
    ATTCACHE            *pAC;

    DPRINT(5, "DBGetAttVal entered\n");
    Assert(VALID_DBPOS(pDB));
    if (!(pAC = SCGetAttById(pDB->pTHS, aType))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, aType);
    }
    return DBGetAttVal_AC(pDB, tagSequence, pAC, Flags, InBuffSize, pLen,
                          ppVal);

} /* DBGetAttVal */



DWORD
DBAddAtt_AC (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        UCHAR syntax
        )
/*++

Routine Description:

    Add an attribute with no values.  It is an error if the attribute already
    exists. Adding an attribute doesn't actually do anything to the database.

    This function assumes that we are positioned on a database object.

Argumets:

    pDB - the DBPos to use

    aType - the attribute to add.

    syntax - the expected syntax of the attribute.

Return Values:

    0 - no error
    DB_ERR_ATTRIBUTE_EXISTS - attribute already exists.
    DB_ERR_BAD_SYNTAX - attribute cannot be found in schema or syntax is
        incorrect.

--*/
{
    DPRINT1(2, "DBAddAtt_AC entered, add attr type <%lu>\n",pAC->id);

    Assert(VALID_DBPOS(pDB));

    // NOTE: this behaviour was not enforced before 5/20/96
    if(pAC->syntax != syntax        ) {
        Assert(0);
        return DB_ERR_BAD_SYNTAX;
    }

    // PERF 97/09/08 JeffParh TimWi
    //
    // Even though we're not necessarily about to perform a write, we need
    // to init the record because we _are_ about to perform a read, possibly
    // of what's supposed to be a brand new record.  This new record is never
    // actually created until dbInitRec() is performed, however -- until then,
    // we're still poitioned on the last record with currency; i.e., a read
    // would return data from this last record, rather than correctly claiming
    // that no such data exists on the new record.
    //
    // Perhaps we need a clearer notion of when such new records are created
    // (maybe create them immediately in DBInitObj()?)
    dbInitRec(pDB);

    //Check for existing values. Cannot add attribute that exists
    if (DBHasValues_AC(pDB, pAC)) {
        DPRINT(1, "DBAddAtt_AC: Attribute already exists\n");
        return DB_ERR_ATTRIBUTE_EXISTS;
    }

    // Touch replication meta data for this attribute.
    // Never optimize this out for fDRA.
    DBTouchMetaData(pDB, pAC);

    return 0;
}/*DBAddAtt*/

DWORD
DBAddAtt (
        DBPOS FAR *pDB,
        ATTRTYP aType,
        UCHAR syntax
        )
/*++

Routine Description:

    Add an attribute with no values.  It is an error if the attribute already
    exists. Adding an attribute doesn't actually do anything to the database.

    This function assumes that we are positioned on a database object.

    This function just looks up the attcache and calls DBAddAtt_AC

Argumets:

    pDB - the DBPos to use

    aType - the attribute to add.

    syntax - the expected syntax of the attribute.

Return Values:

    0 - no error
    DB_ERR_ATTRIBUTE_EXISTS - attribute already exists.
    DB_ERR_BAD_SYNTAX - attribute cannot be found in schema or syntax is
        incorrect.

--*/
{
    ATTCACHE *pAC;
    DPRINT1(5, "DBAddAtt entered, add attr type <%lu>\n",aType);

    Assert(VALID_DBPOS(pDB));

    if(!(pAC = SCGetAttById(pDB->pTHS, aType))) {
        return DB_ERR_BAD_SYNTAX;
    }

    return DBAddAtt_AC(pDB,pAC,syntax);

}/*DBAddAtt*/

DWORD
DBAddAttValEx_AC (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG extLen,
        void *pExtVal,
        VALUE_META_DATA *pRemoteValueMetaData
        )
/*++

Routine Description:

    Add an attribute value to the given attribute in the current object.
    If the value already exists, it cannot be added.

Return Values:

    A non-zero return indicates an error.

*/
{
    ULONG        intLen;                // The length of the internal value
    UCHAR        *pIntVal;              // Points to the internal value
    int          rtn;                   // syntax return code
    JET_SETINFO  setinfo;
    JET_RETINFO  retinfo;
    ULONG        actuallen;
    JET_ERR      err;
    DWORD        dwSyntaxFlags=0;
    BOOL         fFound = FALSE;
    // Look up the attribute.

    DPRINT1(2, "DBAddAttVal_AC entered, get att with type <%lu>\n",pAC->id);

    Assert(VALID_DBPOS(pDB));

    // add new value
    dbInitRec(pDB);

    if (FIsBacklink(pAC->ulLinkID)) {
        // we do not allow adding backlinks explicitly - it's a mess
        return DB_ERR_NOT_ON_BACKLINK;
    }

    switch(pAC->id) {

    case ATT_OBJ_DIST_NAME:
        dwSyntaxFlags |= EXTINT_NEW_OBJ_NAME;
        break;
    case ATT_DN_REFERENCE_UPDATE:
        dwSyntaxFlags |= EXTINT_UPDATE_PHANTOM;
        break;
    default:
        if (DBIsSecretData(pAC->id)){
            dwSyntaxFlags |= EXTINT_SECRETDATA;
        }
        else if ( (pDB->pTHS->fDRA) && (pAC->ulLinkID) ) {
            // For inbound repl, for dn-valued, reject deleted
            dwSyntaxFlags = EXTINT_REJECT_TOMBSTONES;
        }
    }

    if (dwSyntaxFlags & EXTINT_REJECT_TOMBSTONES) {
        // Since we are doing tombstone rejection, try to use the INQ
        // mode first since it is optimized.
        rtn=gDBSyntax[pAC->syntax].ExtInt(
            pDB,
            DBSYN_INQ,
            extLen,
            pExtVal,
            &intLen,
            &pIntVal,
            pDB->DNT,
            pDB->JetObjTbl,
            dwSyntaxFlags);
        if (!rtn) {
            // Value exists, add a reference count
            dbAdjustRefCountByAttVal(pDB, pAC, pIntVal, intLen, 1);
            fFound = TRUE;
        } else if (rtn == ERROR_DS_NO_DELETED_NAME) {
            // If the value is deleted, silently succeed without adding anything
            return 0;
        } else {
            // Fall through and try the add path
            ;
        }
    }

    if (!fFound) {
        // Convert value to internal format
        if(rtn=gDBSyntax[pAC->syntax].ExtInt(
            pDB,
            DBSYN_ADD,
            extLen,
            pExtVal,
            &intLen,
            &pIntVal,
            pDB->DNT,
            pDB->JetObjTbl,
            dwSyntaxFlags)) {
            DPRINT1(1, "Ext-Int syntax conv failed <%u>..return\n", rtn);
            return DB_ERR_SYNTAX_CONVERSION_FAILED;
        }
    }

    // if the attribute is of type link or backlink, call dbAddIntLinkVal
    // to do the work

    if (pAC->ulLinkID)
       return dbAddIntLinkVal(pDB, pAC, intLen, pIntVal, pRemoteValueMetaData );

    // All is ok, Add new value

    switch(pAC->syntax) {
    case SYNTAX_UNICODE_TYPE:
    case SYNTAX_NOCASE_STRING_TYPE:
        // Because non-binary equal values of these syntaxes can be semantically
        // equal, these might require the old slow way of comparing.

        // First, try to use Jet for dup detection.
        setinfo.cbStruct = sizeof(setinfo);
        setinfo.ibLongValue = 0;
        setinfo.itagSequence = 0;
        switch(JetSetColumnWarnings(
                pDB->JetSessID,
                pDB->JetObjTbl,
                pAC->jColid,
                pIntVal,
                intLen,
                JET_bitSetUniqueNormalizedMultiValues,
                &setinfo)) {
        case JET_errMultiValuedDuplicate:
            // Duplicate value.
            return DB_ERR_VALUE_EXISTS;
            break;

        case JET_errMultiValuedDuplicateAfterTruncation:
            // Can't tell if this is unique or not.  Try the old fashioned way.
            if(rtn = dbSetValueIfUniqueSlowVersion (pDB,
                                                    pAC,
                                                    pIntVal,
                                                    intLen)) {
                return rtn;
            }
            break;

        default:
            // Successfully added, it's not a duplicate.
            break;
        }
        break;

    default:
        // Everything else can make use of jet to do the dup detection during
        // the set column.
        setinfo.cbStruct = sizeof(setinfo);
        setinfo.ibLongValue = 0;
        setinfo.itagSequence = 0;
        if(JET_errMultiValuedDuplicate ==
           JetSetColumnWarnings(pDB->JetSessID, pDB->JetObjTbl, pAC->jColid,
                                pIntVal, intLen, JET_bitSetUniqueMultiValues,
                                &setinfo)) {
            // Duplicate value.
            return DB_ERR_VALUE_EXISTS;
        }
    }

    // Touch replication meta data for this attribute.
    // Never optimize this out for fDRA.
    DBTouchMetaData(pDB, pAC);

    if (dbNeedToFlushDNCacheOnUpdate(pAC->id)) {
        pDB->fFlushCacheOnUpdate = TRUE;
    }

    return 0;
} // DBAddAttVal_AC

DWORD
DBAddAttVal_AC (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG extLen,
        void *pExtVal
        )
/*++

Routine Description:

    Add an attribute value to the given attribute in the current object.
    If the value already exists, it cannot be added.

Return Values:

    A non-zero return indicates an error.

*/
{
    return DBAddAttValEx_AC( pDB, pAC, extLen, pExtVal, NULL );
}

DWORD
DBAddAttVal (
        DBPOS FAR *pDB,
        ATTRTYP aType,
        ULONG extLen,
        void *pExtVal
        )
/*++

Routine Description:

    Add an attribute value to the given attribute in the current object.
    If the value already exists, it cannot be added.

    A wrapper around DBAddAttVal_AC

Return Values:

    A non-zero return indicates an error.

*/
{
    ATTCACHE    *pAC;

    // Look up the attribute.

    DPRINT1(2, "DBAddAttVal entered, get att with type <%lu>\n",aType);

    Assert(VALID_DBPOS(pDB));

    if (!(pAC = SCGetAttById(pDB->pTHS, aType))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, aType);
    }

    return DBAddAttVal_AC(pDB,pAC, extLen,pExtVal);
} /* DBAddVal */

DWORD
DBReplaceAttVal (
    DBPOS FAR *pDB,
    ULONG tagSequence,
    ATTRTYP  aType,
    ULONG extLen,
    void *pExtVal)
{
    ATTCACHE    *pAC;

    // Look up the attribute
    DPRINT1(5, "DBReplaceAttVal entered, replace att with type <%lu>\n", aType);

    Assert(VALID_DBPOS(pDB));

    if (!(pAC = SCGetAttById(pDB->pTHS, aType)))
    {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, aType);
    }

    return DBReplaceAttVal_AC(pDB, tagSequence, pAC, extLen, pExtVal);
}

DWORD
DBReplaceAttVal_AC (
    DBPOS FAR *pDB,
    ULONG tagSequence,
    ATTCACHE *pAC,
    ULONG extLen,
    void *pExtVal)
/*++

  Routine Description:

    Replace an attribute value at the given position (tagSequence refers to the position).
    **LINK attributes are not handled in ReplaceAttVal_AC**.

  Return Values:
    DB_Success, if successfully replaced;
    DB_ERR_VALUE_EXISTS, if the new value is not unique;
    DB_ERR_BAD_SYNTAX, if the attribute is a LINK attribute;
    DB_ERR_SYNTAX_CONVERSION_FAILED, if syntax conversion failed;

*/
{
    THSTATE    *pTHS=pDB->pTHS;
    ULONG       intLen;         // length of the internal value
    UCHAR       *pIntVal;       // pointer to the internal representation of
                                // value
    int         rtn;            // syntax return code
    JET_SETINFO setinfo;
    JET_RETINFO retinfo;
    UCHAR       *pBuf;
    ULONG       cbBuf;
    ULONG       actuallen;
    DWORD       CurrAttrOccur;
    JET_ERR     err;
    ULONG       dwSyntaxFlags=0;
    UCHAR       *pOldValue = NULL;
    ULONG       cbOldValue;

    DPRINT1(2, "DBReplaceAttVal_AC entered, replace a value of att with type <%lu>\n", pAC->id);

    Assert(VALID_DBPOS(pDB));

    dbInitRec(pDB);

    if (pAC->ulLinkID)
    {
        // it is a link attribute - we don't support replacing values on a linked attribute
        return DB_ERR_BAD_SYNTAX;
    }

    if (pAC->id == ATT_OBJ_DIST_NAME){
        dwSyntaxFlags |= EXTINT_NEW_OBJ_NAME;
    }
    else if (DBIsSecretData(pAC->id)){
        dwSyntaxFlags |= EXTINT_SECRETDATA;
    }

    // convert value to internal format
    if (rtn = gDBSyntax[pAC->syntax].ExtInt(pDB,
                                            DBSYN_ADD,
                                            extLen,
                                            pExtVal,
                                            &intLen,
                                            &pIntVal,
                                            pDB->DNT,
                                            pDB->JetObjTbl,
                                            dwSyntaxFlags))
    {
        DPRINT1(1, "Ext-Int syntax conv failed and returned <%u> \n", rtn);
        return DB_ERR_SYNTAX_CONVERSION_FAILED;
    }

    // check to see the new value is unique (can appear in the position we replace
    //  though in which case the entire replace operation amounts to a no-op)

    cbBuf = intLen; // assume all internal values have the same length...
    pBuf = dbAlloc(cbBuf);
    CurrAttrOccur = 0;
    while (TRUE)
    {
        retinfo.cbStruct = sizeof(retinfo);
        retinfo.itagSequence = ++CurrAttrOccur;
        retinfo.ibLongValue = 0;
        retinfo.columnidNextTagged = 0;

        err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                                        pAC->jColid, pBuf, cbBuf,
                                        &actuallen, pDB->JetRetrieveBits,
                                        &retinfo);
        if (err == JET_wrnColumnNull)
        {
            // no values
            err = 0;
            break;
        }
        else if (err == JET_wrnBufferTruncated) {
            // realloc
            if (pBuf == NULL) {
                pBuf = dbAlloc(actuallen);
            }
            else {
                pBuf = dbReAlloc(pBuf, actuallen);
            }
            cbBuf = actuallen;
            // and get again...
            err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                                            pAC->jColid, pBuf, cbBuf,
                                            &actuallen, pDB->JetRetrieveBits,
                                            &retinfo);
        }
        if (err) {
            // something else happened...
            DPRINT(0, "Error reading value");
            break;
        }
        if (CurrAttrOccur == tagSequence) {
            // we are replacing this value. Remember it -- will need to deref it later
            pOldValue = pBuf;
            cbOldValue = actuallen;
            // reset pBuf -- a new one will be created on the next loop pass if needed
            pBuf = NULL;
            cbBuf = 0;
        }
        else {
            // looking at another value -- check that it is different
            if (gDBSyntax[pAC->syntax].Eval(
                    pDB,
                    FI_CHOICE_EQUALITY,
                    intLen,
                    pIntVal,
                    actuallen,
                    pBuf))
            {
                // there should be no duplicate
                Assert(!"Duplicate value found");
                err = DB_ERR_VALUE_EXISTS;
                break;
            }
        }
    }

    if (pBuf) {
        dbFree(pBuf);
    }
    if (err) {
        if (pOldValue) {
            dbFree(pOldValue);
        }
        return err;
    }

    if (pOldValue) {
        // adjust the refcount on the old value
        dbAdjustRefCountByAttVal(pDB, pAC, pOldValue, cbOldValue, -1);
        dbFree(pOldValue);
    }

    // Set the new value into position
    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = tagSequence;
    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, pAC->jColid,
                    pIntVal, intLen, 0, &setinfo);


    // Touch replication meta data for this attribute
    // Never optimize this out for fDRA.
    DBTouchMetaData(pDB, pAC);

    if (dbNeedToFlushDNCacheOnUpdate(pAC->id)) {
        pDB->fFlushCacheOnUpdate = TRUE;
    }

    return DB_success;

} /* DBReplaceAttVal_AC */

VOID
dbAdjustRefCountByAttVal(
        DBPOS    *pDB,
        ATTCACHE *pAC,
        PUCHAR   pVal,
        ULONG    valLen,
        int      adjust)
{
    DWORD tag, dwErr;
    DWORD   actualLength;
    int     refCount;

    if(FIsBacklink(pAC->ulLinkID)) {
        tag = pDB->DNT;
    }
    else {
        switch(pAC->syntax) {
            // These are DNTvalued attributes.  We need to adjust the
            // refcount.
        case SYNTAX_DISTNAME_BINARY_TYPE:
        case SYNTAX_DISTNAME_STRING_TYPE:
            tag = ((INTERNAL_SYNTAX_DISTNAME_STRING *)pVal)->tag;
            break;
        case SYNTAX_DISTNAME_TYPE:
            // Deref the object referenced by the property value being
            // removed.
            tag =  *((DWORD *)pVal);
            break;

        case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
            // SDs are sitting in a separate table with refcounts...
            if (valLen < SECURITY_DESCRIPTOR_MIN_LENGTH) {
                // new-style SD
                Assert(valLen == sizeof(SDID));

                // position on the SD in the SD table (the index is already set)
                JetMakeKeyEx(pDB->JetSessID, pDB->JetSDTbl, pVal, valLen, JET_bitNewKey);

                dwErr = JetSeekEx(pDB->JetSessID, pDB->JetSDTbl, JET_bitSeekEQ);
                if (dwErr) {
                    // did not find a corresponding SD in the SD table
                    DPRINT2(0, "Failed to locate SD, id=%I64x, err=%d\n", *((SDID*)pVal), dwErr);
                    Assert(!"Failed to locate SD -- not found in the SD table!");
                    DsaExcept(DSA_DB_EXCEPTION, dwErr, 0);
                }
                DPRINT2(1, "Located SD for id %I64x, adjusting refcount by %+d\n", *((SDID*)pVal), adjust);

                // adjust the refcount
                JetEscrowUpdateEx(pDB->JetSessID,
                                  pDB->JetSDTbl,
                                  sdrefcountid,
                                  &adjust,
                                  sizeof(adjust),
                                  NULL,     // pvOld
                                  0,        // cbOldMax
                                  NULL,     // pcbOldActual
                                  0);       // grbit
            }

            // that's it for SDs...
            return;

        default:
            return;
            break;
        }
    }

    // we got here because it was one of the DN-refcounted attributes. tag variable was properly set.
    // now we can adjust the refcount
    DBAdjustRefCount(pDB, tag, adjust);

    return;
}

int __cdecl
DNTAttrValCompare(const void *keyval, const void *datum)
{
    ATTRVAL *pValKey = (ATTRVAL *)keyval;
    ATTRVAL *pValDatum = (ATTRVAL *)datum;
    Assert(pValKey->valLen == sizeof(DWORD));
    Assert(pValDatum->valLen == sizeof(DWORD));

    return ((*(DWORD *)(pValKey->pVal)) - (*(DWORD *)(pValDatum->pVal)));
}

DWORD
DBReplaceAtt_AC(
        PDBPOS  pDB,
        ATTCACHE *pAC,
        ATTRVALBLOCK *pAttrVal,
        BOOL         *pfChanged
        )
/*++

  Three phases to this call
  1) translate external values to internal values.
  2) walk through the existing values on the attribute, remove those values not
  on the list passed in, remove duplicate values from the internal version of
  the list passed in.
  3) Now, only values that must continue to be on the object are still there,
  and only values that must be added to the object are still in the list of
  internal values to add.  Add them.

  Note that pfChanged is optional, if NULL no indication of whether or not
  anything changed is returned to the caller.
--*/
{
    THSTATE     *pTHS = pDB->pTHS;
    ULONG        len;
    DWORD        err, rtn;
    ULONG        index, extIndex, i;
    ULONG        bufSize;
    UCHAR       *pVal;
    ATTRVAL     *pAVal;
    ATTRVALBLOCK IntAttrVal;
    DWORD        dwSyntaxFlags=0;
    BOOL         fNewAllocs=FALSE;
    DWORD        firstNewAtt;
    JET_SETINFO  setinfo;
    PUCHAR       pTemp = NULL;
    BOOL         fChangedSomething=FALSE;
    BOOL         fSorted = FALSE;
    DWORD        SortedValuesIndex;
    PUCHAR      *addAlreadyDoneFor = NULL;
    DWORD        addAlreadyDoneCount;
    BOOL         fAddAlreadyDone;

    if(pfChanged) {
        *pfChanged = FALSE;
    }

    IntAttrVal.pAVal = NULL;
    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;

    // PHASE 1:
    // Translate the external values to internal values.

    // Look up the attribute.
    DPRINT1(2, "DBReplaceAtt_AC entered, get att with type <%lu>\n",pAC->id);

    Assert(VALID_DBPOS(pDB));

    if (FIsBacklink(pAC->ulLinkID)) {
        // we do not allow adding backlinks explicitly - it's a mess
        return DB_ERR_NOT_ON_BACKLINK;
    }

    if (pAC->id == ATT_OBJ_DIST_NAME){
        // We don't allow using this to mess with the OBJ_DIST_NAME, either.
        return DB_ERR_UNKNOWN_ERROR;
    }
    else if (DBIsSecretData(pAC->id)){
        dwSyntaxFlags = EXTINT_SECRETDATA;
    } else if ( (pTHS->fDRA) && (pAC->ulLinkID) ) {
        // For inbound repl, for dn-valued, reject deleted
        dwSyntaxFlags = EXTINT_REJECT_TOMBSTONES;
    }



    // assume we are to add new values
    dbInitRec(pDB);

    // OK, now translate the external values into internal values
    // extIndex iterates through the external array
    // index iterates through the internal array

    IntAttrVal.valCount = pAttrVal->valCount;
    IntAttrVal.pAVal = THAllocEx(pTHS, pAttrVal->valCount * sizeof(ATTRVAL));

    // alloc the array for the list of refCounted (DBSYN_ADDed) values
    addAlreadyDoneFor = THAllocEx(pTHS, pAttrVal->valCount * sizeof(PUCHAR));
    addAlreadyDoneCount = 0;

    index = 0;
    for(extIndex = 0; extIndex < pAttrVal->valCount; extIndex++) {
        // Convert value to internal format
        err = gDBSyntax[pAC->syntax].ExtInt(
                pDB,
                DBSYN_INQ,
                pAttrVal->pAVal[extIndex].valLen,
                pAttrVal->pAVal[extIndex].pVal,
                &IntAttrVal.pAVal[index].valLen,
                &IntAttrVal.pAVal[index].pVal,
                pDB->DNT,
                pDB->JetObjTbl,
                dwSyntaxFlags);

        fAddAlreadyDone = FALSE;
        if(err == DIRERR_OBJ_NOT_FOUND) {
            // This external value must be a DN or a syntax that has a DN in it,
            // and the DN doesn't exist yet.  Try the gdbSyntax[] again,
            // specifying DBSYN_ADD, which will create the appropriate phantom.
            // We are sure this attribute is not present in the current
            // set (i.e. it will not be optimized away) -- because otherwise a
            // phantom would be present. Thus, we can safely inc the refcount now.
            err = gDBSyntax[pAC->syntax].ExtInt(
                    pDB,
                    DBSYN_ADD,
                    pAttrVal->pAVal[extIndex].valLen,
                    pAttrVal->pAVal[extIndex].pVal,
                    &IntAttrVal.pAVal[index].valLen,
                    &IntAttrVal.pAVal[index].pVal,
                    pDB->DNT,
                    pDB->JetObjTbl,
                    dwSyntaxFlags);
            if(!err) {
                // remember that we already adjusted the refcount for this value
                fAddAlreadyDone = TRUE;
            }
        }

        if (err == ERROR_DS_NO_DELETED_NAME) {
            // Conversion rejected deleted dn
            IntAttrVal.valCount--;
            DPRINT1( 2, "Ext-Int rejecting deleted DSNAME %ws from attribute value\n",
                     ((DSNAME *) pAttrVal->pAVal[extIndex].pVal)->StringName );
            continue; // do not increment internal index
        } else if(err) {
            DPRINT1(1, "Ext-Int syntax conv failed <%u>..return\n", err);
            err = DB_ERR_SYNTAX_CONVERSION_FAILED;
            goto CleanUp;
        }
        if(IntAttrVal.pAVal[index].pVal != pAttrVal->pAVal[extIndex].pVal) {
            // The conversion process uses the dbsyntax temp buffer.  Copy the
            // value away to a safe location.
            pTemp = THAllocEx(pTHS, IntAttrVal.pAVal[index].valLen);
            // Remember the fact that we are allocating memory for the values,
            // we'll clean it up later.
            Assert((!fNewAllocs && !index) || (index && fNewAllocs));
            fNewAllocs=TRUE;
            memcpy(pTemp,
                   IntAttrVal.pAVal[index].pVal,
                   IntAttrVal.pAVal[index].valLen);
            IntAttrVal.pAVal[index].pVal = pTemp;
            pTemp = NULL;
        }
        if (fAddAlreadyDone) {
            // now that the value got copied, record that ADD was already called
            addAlreadyDoneFor[addAlreadyDoneCount++] = IntAttrVal.pAVal[index].pVal;
        }

        index++;
    }

    // Preliminary to phase 2:  If this is a link valued attribute, sort the
    // values (i.e. sort the values by DNT).  This is useful because we will be
    // able to short circuit a loop below if we know that the values in the DB
    // are sorted (which they are for link valued atts) AND the values being put
    // into the DB are also sorted.
    // TODO: handle SYNTAX_DISTNAME_BINARY and SYNTAX_DISTNAME_STRING
    // Do it be writing alternate comparision functions for them

    if (pAC->ulLinkID && (pAC->syntax == SYNTAX_DISTNAME_TYPE)) {
        // Yep, this is stored in the link table.  Sort it.
        qsort(IntAttrVal.pAVal,
              IntAttrVal.valCount,
              sizeof(ATTRVAL),
              DNTAttrValCompare);
        fSorted = TRUE;
    }
    // PHASE 2:
    // Now, walk through the existing vals, deleting the ones which do not exist
    // in the change list, and removing the ones in the change list that are
    // already there (I do this by swapping the last unchecked value in the list
    // with the one identified as already on the object.)

    pVal = NULL;
    len = 0;
    bufSize = 0;

    index = 1;
    if (pAC->ulLinkID) {
        err = DBGetNextLinkVal_AC (
                pDB,
                TRUE,
                pAC,
                DBGETATTVAL_fINTERNAL |  DBGETATTVAL_fREALLOC,
                bufSize,
                &len,
                &pVal);
    }
    else {
        err = DBGetAttVal_AC(pDB, index, pAC,
                             DBGETATTVAL_fINTERNAL | DBGETATTVAL_fREALLOC | DBGETATTVAL_fDONT_FIX_MISSING_SD,
                             bufSize, &len,
                             &pVal);
    }

    // Init pAVal to the front of the list.
    pAVal = IntAttrVal.pAVal;
    SortedValuesIndex = 0;
    while(!err) {
        BOOL fDone = FALSE;

        bufSize = max(bufSize, len);

        if(pAC->id != ATT_OBJECT_CLASS) {
            // Only look for existing atts if not object class.  This att is
            // handled differently because we MUST preserve the order of the
            // Attribute Values.

            if(fSorted) {
                BOOL fEndLoop = FALSE;

                // everything is sorted, do the simpler version of the loop
                // pAVal is already at the correct location.  Either this is the
                // first time through the while loop and we set it correctly
                // before we started, or we've been through here before and we
                // left pAVal pointing to the correct place on the previous exit
                // of loop.
                while(!fEndLoop && SortedValuesIndex < IntAttrVal.valCount) {
                    Assert(pAVal->valLen == sizeof(DWORD));
                    Assert(len == sizeof(DWORD));
                    if(*((DWORD *)pVal) == *((DWORD *)(pAVal->pVal))) {
                        // Matched.  Set the value to the magic value
                        *((DWORD *)pAVal->pVal) = INVALIDDNT;
                        pAVal++;
                        SortedValuesIndex++;
                        fDone = TRUE;
                        fEndLoop = TRUE;
                    }
                    else if(*((DWORD *)pVal) < *((DWORD *)(pAVal->pVal))) {
                        // The current value is greater than the value read from
                        // the DB.  That means that the value read from the DB
                        // isn't in the list, so we're done looking through the
                        // list.  The value in the DB must be removed.
                        fEndLoop = TRUE;
                    }
                    else {
                        // The current value is less than the value read from
                        // the DB.  That means that the value read from the DB
                        // might still be in the list, we have to increment our
                        // position in the list and keep going.
                        SortedValuesIndex++;
                        pAVal++;
                    }
                }
            }
            else {
                // Reinit pAVal to the front of the list.
                pAVal = IntAttrVal.pAVal;

                for(i=0;!fDone && i<IntAttrVal.valCount;i++) {
                    // We don't do syntax-sensitive comparisons for
                    // ReplaceAtt().  If someone's surname is changed from
                    // "smith" to "Smith," for example, we want to honor that
                    // change and quiesce to the updated casing across all
                    // replicas.  This is consistent with Exchange 4.0 behavior.
                    // Note that RDN changes do *not* go through this code path
                    // -- though changes in the RDN also quiesce to the same
                    // case across all replicas.
                    if ((len == pAVal->valLen)
                        && (0 == memcmp(pVal, pAVal->pVal, len))) {
                        // Matched
                        fDone = TRUE;
                        // swap this one with the one at the end of the list.
                        pAVal->valLen =
                            IntAttrVal.pAVal[IntAttrVal.valCount - 1].valLen;

                        pTemp = pAVal->pVal;
                        pAVal->pVal =
                            IntAttrVal.pAVal[IntAttrVal.valCount - 1].pVal;
                        IntAttrVal.pAVal[IntAttrVal.valCount - 1].pVal = pTemp;
                        pTemp = NULL;

                        IntAttrVal.valCount--;
                    }
                    else {
                        pAVal++;
                    }
                }
            }
        }


        if(!fDone) {
            // Didn't find it, remove this one.
            fChangedSomething=TRUE;

            Assert(!FIsBacklink(pAC->ulLinkID));

            /// OK, now really delete.
            if(pAC->ulLinkID) {
                dbSetLinkValueAbsent( pDB,
                                      DIRLOG_LVR_SET_META_REPLACE_MADE_ABSENT,
                                      pAC, pVal, NULL /*remote*/ );
            }
            else {
                // First, fix up the refcounts.
                dbAdjustRefCountByAttVal(pDB, pAC, pVal, len, -1);

                // attribute value lives in data table
                setinfo.itagSequence = index;
                JetSetColumnEx(pDB->JetSessID,
                               pDB->JetObjTbl, pAC->jColid,
                               NULL, 0, 0, &setinfo);
            }

            index--;
        }

        // Get the next value to consider.
        index++;
        if (pAC->ulLinkID) {
            err = dbGetNthNextLinkVal(
                    pDB,
                    1,
                    &pAC,
                    DBGETATTVAL_fINTERNAL |  DBGETATTVAL_fREALLOC,
                    bufSize,
                    &pVal,
                    &len);
        }
        else {
            err = DBGetAttVal_AC(pDB, index, pAC,
                                 DBGETATTVAL_fINTERNAL | DBGETATTVAL_fREALLOC | DBGETATTVAL_fDONT_FIX_MISSING_SD,
                                 bufSize, &len,
                                 &pVal);
        }
    }

    err = 0;
    // firstNewAtt is the index number of the first new value to be added to
    // the attribute.  It is 1 greater than the number of attributes we left on
    // the object in the DIT.
    firstNewAtt = index;

    if(bufSize)
        THFreeEx(pTHS, pVal);

    // PHASE 3:
    // Finally, add the remaining att values
    if(IntAttrVal.valCount) {
        pAVal = IntAttrVal.pAVal;

        for(index = 0; index < IntAttrVal.valCount; index++){
            Assert(!FIsBacklink(pAC->ulLinkID));

            // figure out if we already did a DBSYN_ADD on this value
            fAddAlreadyDone = FALSE;
            for (i = 0; i < addAlreadyDoneCount; i++) {
                if (addAlreadyDoneFor[i] == pAVal->pVal) {
                    fAddAlreadyDone = TRUE;
                    break;
                }
            }

            // Now really add the value.
            if (pAC->ulLinkID) {
                // Don't add values that are INVALID
                if(*(DWORD *)(pAVal->pVal) != INVALIDDNT) {
                    if (!fAddAlreadyDone) {
                        // Fix up the recounts.
                        dbAdjustRefCountByAttVal(pDB, pAC, pAVal->pVal, pAVal->valLen, 1);
                    }
                    fChangedSomething = TRUE;
                    err = dbAddIntLinkVal(pDB, pAC, pAVal->valLen, pAVal->pVal, NULL);
                }
            }
            else {
                if (!fAddAlreadyDone) {
                    // Fix up the recounts.
                    dbAdjustRefCountByAttVal(pDB, pAC, pAVal->pVal, pAVal->valLen, 1);
                }
                fChangedSomething=TRUE;

                // NOTE: if you add a value with no length, JET doesn't
                // complain, but it also doesn't change the DB in anyway.  So,
                // if you are doing that, you are just forcing the meta data to
                // change.  Don't do that.  If you hit this assert, your code
                // needs to change.
                //
                switch(pAC->syntax) {
                case SYNTAX_NOCASE_STRING_TYPE:
                case SYNTAX_UNICODE_TYPE:
                    // Because non-binary equal values of these syntaxes can be
                    // semantically equal, these require the old slow way of
                    // comparing.
                    // First, try to use Jet for dup detection.
                    setinfo.itagSequence = index + firstNewAtt;
                    switch(JetSetColumnWarnings(
                            pDB->JetSessID,
                            pDB->JetObjTbl,
                            pAC->jColid,
                            pAVal->pVal,
                            pAVal->valLen,
                            JET_bitSetUniqueNormalizedMultiValues,
                            &setinfo)) {
                    case JET_errMultiValuedDuplicate:
                        // NTRAID#NTRAID-580224-2002/03/18-andygo:  DBReplaceAtt_AC leaks memory on a duplicate multi value in a string
                        // REVIEW:  memory leak because we don't goto Cleanup
                        // Duplicate value.
                        return DB_ERR_VALUE_EXISTS;
                        break;

                    case JET_errMultiValuedDuplicateAfterTruncation:
                        // Can't tell if this is unique or not.  Try the old
                        // fashioned way.
                        if(rtn = dbSetValueIfUniqueSlowVersion(pDB,
                                                               pAC,
                                                               pAVal->pVal,
                                                               pAVal->valLen)) {
                            // NTRAID#NTRAID-580224-2002/03/18-andygo:  DBReplaceAtt_AC leaks memory on a duplicate multi value in a string
                            // REVIEW:  memory leak because we don't goto Cleanup
                            return rtn;
                        }
                        break;

                    default:
                        // Successfully added, it's not a duplicate.
                        break;
                    }
                    break;

                default:
                    // Everything else can make use of jet to do the dup
                    // detection during the set column.
                    setinfo.itagSequence = index + firstNewAtt;
                    if(JET_errMultiValuedDuplicate ==
                       JetSetColumnWarnings(pDB->JetSessID,
                                            pDB->JetObjTbl,
                                            pAC->jColid,
                                            pAVal->pVal,
                                            pAVal->valLen,
                                            JET_bitSetUniqueMultiValues,
                                            &setinfo)) {
                        err = DB_ERR_VALUE_EXISTS;
                    }
                    else {
                        err = 0;
                    }
                }
            }

            if(err) {
                goto CleanUp;
            }
            pAVal++;
        }
    }

    if(pAttrVal->valCount == 0 && pAC->id == ATT_NT_SECURITY_DESCRIPTOR) {
        // Security descriptor has no value in the object table.
        // Enqueue a propagation to get this fixed.
        DPRINT1(0, "NULL SD written, enqueueing SD propagation for DNT=%d\n", pDB->DNT);
        InsertInTaskQueue(TQ_DelayedSDPropEnqueue,
                          (void *)((DWORD_PTR) pDB->DNT),
                          1);
    }

CleanUp:
    // Free up allocated memory
    if(IntAttrVal.pAVal) {
        if(fNewAllocs) {
            for(index = 0;index < IntAttrVal.valCount;index++) {
                THFreeEx(pTHS, IntAttrVal.pAVal[index].pVal);
            }
        }
        THFreeEx(pTHS, IntAttrVal.pAVal);
    }
    if (addAlreadyDoneFor) {
        THFreeEx(pTHS, addAlreadyDoneFor);
    }

    if(!err && (pTHS->fDRA || fChangedSomething)) {
        // If the DRA did this call, we ALWAYS touch the metadata.  For anyone
        // else, we only touch the metadata if something changes.
        DBTouchMetaData(pDB, pAC);
    }

    if (fChangedSomething) {
        if (dbNeedToFlushDNCacheOnUpdate(pAC->id)) {
            pDB->fFlushCacheOnUpdate = TRUE;
        }
    }

    if(pfChanged) {
        *pfChanged = fChangedSomething;
    }
    return err;

}/*ReplaceAtt*/


DWORD
DBRemAtt_AC (
        DBPOS FAR *pDB,
        ATTCACHE *pAC
        )
/*++

Routine Description:

    Remove an entire attribute from the current object.  Removes all the
    attribute values.

    Returns DB_ERR_ATTRIBUTE_DOESNT_EXIST or Db_success.
--*/
{
    THSTATE *   pTHS = pDB->pTHS;
    DWORD       err = 0;
    DWORD       ret_err = 0;
    DWORD       bufSize;
    PUCHAR      pVal;
    DWORD       len;
    BOOL        fDidOne = FALSE;
    JET_SETINFO setinfo;

    DPRINT1(2, "DBRemAtt_AC entered, Remove attribute type <%lu>\n",pAC->id);

    Assert(VALID_DBPOS(pDB));

    dbInitRec(pDB);

    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 1;

    // Find and delete all values for this attribute

    pVal = NULL;
    len = 0;
    bufSize = 0;

    if (pAC->ulLinkID) {
        err = DBGetNextLinkVal_AC (
                pDB,
                TRUE,
                pAC,
                DBGETATTVAL_fINTERNAL |  DBGETATTVAL_fREALLOC,
                bufSize,
                &len,
                &pVal);
    }
    else {
        err = DBGetAttVal_AC(pDB, 1, pAC,
                             DBGETATTVAL_fINTERNAL |
                             DBGETATTVAL_fREALLOC  |
                             DBGETATTVAL_fDONT_FIX_MISSING_SD,
                             bufSize, &len,
                             &pVal);
    }

    if (err == DB_ERR_NO_VALUE) {
        ret_err = DB_ERR_ATTRIBUTE_DOESNT_EXIST;
    }

    while(!err) {
        bufSize = max(bufSize, len);

        fDidOne = TRUE;
        // OK, now really delete.
        if(pAC->ulLinkID) {
            dbSetLinkValueAbsent( pDB,
                                  DIRLOG_LVR_SET_META_REMOVE_ATT_MADE_ABSENT,
                                  pAC, pVal, NULL /*remote*/ );
        }
        else {
            // First, fix up the refcounts.
            dbAdjustRefCountByAttVal(pDB, pAC, pVal, len, -1);

            // attribute value lives in data table
            JetSetColumnEx(pDB->JetSessID,
                           pDB->JetObjTbl, pAC->jColid,
                           NULL, 0, 0, &setinfo);
        }


        // Get the next value to delete.
        if (pAC->ulLinkID) {
            err = dbGetNthNextLinkVal(
                    pDB,
                    1,
                    &pAC,
                    DBGETATTVAL_fINTERNAL | DBGETATTVAL_fREALLOC,
                    bufSize,
                    &pVal,
                    &len);
        }
        else {
            err = DBGetAttVal_AC(pDB, 1, pAC,
                                 DBGETATTVAL_fINTERNAL |
                                 DBGETATTVAL_fREALLOC  |
                                 DBGETATTVAL_fDONT_FIX_MISSING_SD,
                                 bufSize, &len,
                                 &pVal);
        }
    }

    if (NULL != pVal) {
        THFreeEx(pTHS, pVal);
    }

    if (fDidOne || pTHS->fDRA) {
        // Touch replication meta data for this attribute.
        // Never optimize this out for fDRA.
        DBTouchMetaData(pDB, pAC);
    }

    if (fDidOne) {
        if (dbNeedToFlushDNCacheOnUpdate(pAC->id)) {
            pDB->fFlushCacheOnUpdate = TRUE;
        }
    }

    return ret_err;

}//DBRemAtt_AC

DWORD
DBRemAtt (
        DBPOS FAR *pDB,
        ATTRTYP aType
        )
/*++

Routine Description:

    Remove an entire attribute from the current object.  Removes all the
    attribute values.

    Returns DB_ERR_ATTRIBUTE_DOESNT_EXIST or Db_success.
--*/
{
    ATTCACHE      *pAC;

    // Find the attcache of the attribute to be removed

    DPRINT1(5, "DBRemAtt entered, Remove attribute type <%lu>\n",aType);

    Assert(VALID_DBPOS(pDB));

    if (!(pAC = SCGetAttById(pDB->pTHS, aType))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, aType);
    }
    return DBRemAtt_AC(pDB,pAC);
}//DBRemAtt

DWORD
DBRemAttValEx_AC (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG extLen,
        void *pExtVal,
        VALUE_META_DATA *pRemoteValueMetaData
        )
/*++

Routine Description:

    Remove an attribute value.
    A non-zero return indicates a bad return.
--*/
{
    THSTATE          *pTHS=pDB->pTHS;
    PUCHAR            pTemp, pVal;
    ULONG             actuallen, len, bufSize;
    DWORD             index;
    UCHAR            *pIntVal;
    int               err;
    DWORD             dwSyntaxFlags=0;
    JET_SETINFO       setinfo;
    BOOL              fFound = FALSE;


    DPRINT1(2, "DBRemAttVal_AC entered, Remove attribute type <%lu>\n",pAC->id);

    Assert(VALID_DBPOS(pDB));

    // We disallow being called with the pExtVal == to the temp buffer
    // used by conversion.
    Assert(pExtVal != pDB->pValBuf);

    // We disallow removing backlinks.
    Assert(!FIsBacklink(pAC->ulLinkID));

    // assume we are to remove existing values
    dbInitRec(pDB);

    // Convert to internal value
    if (DBIsSecretData(pAC->id)){
        dwSyntaxFlags |= EXTINT_SECRETDATA;
    }

    if ( (pDB->pTHS->fDRA) && (pAC->ulLinkID) ) {

        // Replicating in a linked value removal
        dwSyntaxFlags = EXTINT_REJECT_TOMBSTONES;
        err = gDBSyntax[pAC->syntax].ExtInt(
            pDB,
            DBSYN_INQ,
            extLen,
            pExtVal,
            &actuallen,
            &pIntVal,
            0, 0,
            dwSyntaxFlags);
        if (err == ERROR_DS_NO_DELETED_NAME) {
            // If the value is deleted, silently succeed without adding anything
            return 0;
        } else if (err) {

            // Try to create the dn as a phantom
            err = gDBSyntax[pAC->syntax].ExtInt(
                pDB,
                DBSYN_ADD,
                extLen,
                pExtVal,
                &actuallen,
                &pIntVal,
                pDB->DNT,
                pDB->JetObjTbl,
                dwSyntaxFlags);
            if (!err) {
                // We just added a new phantom, and ExtInt has kindly increased
                // the ref-count for us. However, the code in dbRemIntLinkVal expects
                // in the case that the value row does not exist (which this HAS to be),
                // that it will add the ref count. So we reverse the extra ref-count.
                dbAdjustRefCountByAttVal(pDB, pAC, pIntVal, actuallen, -1 );
            } else {
                DPRINT1(1, "Ext-Int syntax conv failed <%u>..return\n", err);
                return DB_ERR_SYNTAX_CONVERSION_FAILED;
            }
        }

    } else {

        // Originating write case, or replicating in a non-linked attribute
        err = gDBSyntax[pAC->syntax].ExtInt(pDB,
                                            DBSYN_INQ,
                                            extLen,
                                            pExtVal,
                                            &actuallen,
                                            &pIntVal,
                                            0, 0,
                                            dwSyntaxFlags);
        if (err == DIRERR_OBJ_NOT_FOUND && pAC->syntax == SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE) {
            // this is allowed! Must be an old-style SD that is not present in the SD table
            // assign external value to internal value -- we will use this in Eval comparisons below
            pIntVal = pExtVal;
            actuallen = extLen;
            err = 0;
        }
        else if (err) {
            DPRINT1(0, "Ext-Int syntax conv failed <%u>..return\n",err);
            return  DB_ERR_SYNTAX_CONVERSION_FAILED;
        }

    }

    // allocate memory and copy internal value for comparing later

    pTemp = dbAlloc(actuallen);
    memcpy(pTemp, pIntVal, actuallen);
    pIntVal = pTemp;

    if (pAC->ulLinkID) {
        __try {
            err = dbRemIntLinkVal( pDB, pAC, actuallen, pIntVal, pRemoteValueMetaData );
        }
        __finally {
            dbFree(pIntVal);
        }

        return err;
    }

    // Now, walk through the existing vals, looking for a match.  Delete the
    // match if we find it.

    pVal = NULL;
    len = 0;
    bufSize = 0;

    __try {
        for(index = 1; ; index++) {
            err = DBGetAttVal_AC(pDB, index, pAC,
                                 DBGETATTVAL_fINTERNAL |  DBGETATTVAL_fREALLOC,
                                 bufSize, &len,
                                 &pVal);
            if (err) {
                break;
            }

            bufSize = max(bufSize, len);

            if(gDBSyntax[pAC->syntax].Eval(
                pDB,
                FI_CHOICE_EQUALITY,
                actuallen,
                pIntVal,
                len,
                pVal)) {
                // Matched.  Do the remove.

                // Touch replication meta data for this attribute.
                DBTouchMetaData(pDB, pAC);

                if (dbNeedToFlushDNCacheOnUpdate(pAC->id)) {
                    pDB->fFlushCacheOnUpdate = TRUE;
                }

                // OK, now really delete.

                // First, fix up the refcounts.
                // It is important that we are using the value that has been read, not
                // the pIntVal. Even though Eval thinks they are "the same", they might
                // be still different. This is the case for old-style security descriptors
                // that are stored directly in the obj table. dbAdjustRefCountByAttVal
                // knows how to deal with those (ignores them).
                dbAdjustRefCountByAttVal(pDB, pAC, pVal, len, -1);

                // attribute value lives in data table
                setinfo.cbStruct = sizeof(setinfo);
                setinfo.ibLongValue = 0;
                setinfo.itagSequence = index;
                JetSetColumnEx(pDB->JetSessID,
                               pDB->JetObjTbl, pAC->jColid,
                               NULL, 0, 0, &setinfo);

                fFound = TRUE;
                break;
            }
        } // end for
    }
    __finally {
        if (pVal) {
            THFreeEx(pDB->pTHS, pVal);
        }
        dbFree(pIntVal);
    }

    return fFound ? 0 : DB_ERR_VALUE_DOESNT_EXIST;
}

DWORD
DBRemAttVal_AC (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG extLen,
        void *pExtVal
        )
/*++

Routine Description:

    Remove an attribute value.
    A non-zero return indicates a bad return.
--*/
{
    return DBRemAttValEx_AC( pDB, pAC, extLen, pExtVal, NULL );
}


DWORD
DBFindAttLinkVal_AC(
    IN  DBPOS FAR *pDB,
    IN  ATTCACHE *pAC,
    IN  ULONG extLen,
    IN  void *pExtVal,
    OUT BOOL *pfPresent
    )

/*++

Routine Description:

Position on a external form linked value in the link table.

This routine will return an error if the DN doesn't exist. This routine only
determines if a link is present. This routine does not add a phantom for
DN's. If a phantom is not present, this implies that the linked value does
not exist, and we return with that indication.

Arguments:

    pDB -
    pAC -
    extLen -
    pExtVal -
    pfPresent - Only valid on success

Return Value:

    DWORD -
    ERROR_SUCCESS - Linked value was found and we are positioned on it
    ERROR_NO_DELETED_NAME - DN is to a deleted object
    DB_ERR_VALUE_DOESNT_EXIST - DN does not exist, or link is not present

--*/

{
    THSTATE *pTHS=pDB->pTHS;
    PUCHAR pTemp;
    ULONG actuallen, len, bufSize;
    UCHAR *pIntVal;
    int err;
    DWORD dwSyntaxFlags;

    DPRINT1(2, "DBFindttVal_AC entered, Find attribute type <%lu>\n",pAC->id);

    // Only for linked attributes right now
    Assert( pAC->ulLinkID );

    Assert(VALID_DBPOS(pDB));

    // We disallow being called with the pExtVal == to the temp buffer
    // used by conversion.
    Assert(pExtVal != pDB->pValBuf);

    // We disallow removing backlinks.
    Assert(!FIsBacklink(pAC->ulLinkID));

    // Check that DN does not refer to deleted object
    dwSyntaxFlags = EXTINT_REJECT_TOMBSTONES;

    // Convert to internal value
    if(err = gDBSyntax[pAC->syntax].ExtInt(
            pDB,
            DBSYN_INQ,
            extLen,
            pExtVal,
            &actuallen,
            &pIntVal,
            0, 0,
            dwSyntaxFlags)) {
        if (err == ERROR_DS_NO_DELETED_NAME) {
            return err;
        } else {
            // DNT doesn't exist => link doesn't exist, we're done
            return DB_ERR_VALUE_DOESNT_EXIST;
        }
    }

    // allocate memory and copy internal value for comparing later

    pTemp = dbAlloc(actuallen);
    memcpy(pTemp, pIntVal, actuallen);
    pIntVal = pTemp;

    // Position on exact value
    if (!dbFindIntLinkVal(
        pDB,
        pAC,
        actuallen,
        pIntVal,
        pfPresent
        )) {
        // We didn't find it.
        err = DB_ERR_VALUE_DOESNT_EXIST;
    }

    dbFree(pIntVal);

    return err;

} /* DBFindAttLinkVal_AC */


DWORD
DBRemAttVal (
        DBPOS FAR *pDB,
        ATTRTYP aType,
        ULONG extLen,
        void *pExtVal
        )
/*++

Routine Description:

    Remove an attribute value.
    A non-zero return indicates a bad return.
--*/
{
    ATTCACHE         *pAC;

    DPRINT1(5, "DBRemAttVal entered, Remove attribute type <%lu>\n",aType);

    Assert(VALID_DBPOS(pDB));

    if (!(pAC = SCGetAttById(pDB->pTHS, aType))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, aType);
    }

    return DBRemAttVal_AC(pDB, pAC, extLen, pExtVal);

} /* DBRemAttVal */

DWORD
dbGetMultipleColumns (
        DBPOS *pDB,
        JET_RETRIEVECOLUMN **ppOutputCols,
        ULONG *pcOutputCols,
        JET_RETRIEVECOLUMN *pInputCols,
        ULONG cInputCols,
        BOOL fGetValues,
        BOOL fFromDB
        )
/*++

Routine Description:

    Retrieve many columns at once. First figure out how many columns we have,
    then allocate sructures to represent each one and figure out the size of the
    value of each one, then call Jet again and get the values for each column

    if the client is reading objectClass, we might return also auxClass if existing
    the client should take care of copying the values to the correct place in objectClass

--*/
{
    THSTATE            *pTHS=pDB->pTHS;
    JET_RETRIEVECOLUMN retcolCount;
    JET_RETRIEVECOLUMN *pOutputCols, *pCol;
    ULONG               cb;
    ULONG               i, j;
    DWORD               grbit, err;

    Assert(VALID_DBPOS(pDB));

    if(fFromDB) {
        // The caller wants to read from the DB, not the copy buffer, regardless
        // of the state of pDB->JetRetrieveBits.
        grbit = 0;
    }
    else {
        grbit = pDB->JetRetrieveBits;
    }

    // query Jet for the count of columns in this record

    // was a list of columns specified?

    if (cInputCols && pInputCols)
    {
        // yes - make sure itagSequence is set to 0
        for (i=0; i < cInputCols; i++) {
            pInputCols[i].itagSequence = 0;
            pInputCols[i].grbit = grbit;
        }
    }
    else
    {
        pInputCols = &retcolCount;
        cInputCols = 1;
        memset(&retcolCount, 0, sizeof(retcolCount));
        retcolCount.grbit = grbit;
    }

    JetRetrieveColumnsWarnings(pDB->JetSessID,
        pDB->JetObjTbl,
        pInputCols,
        cInputCols);

    // set the count of columns
    *pcOutputCols = 0;
    *ppOutputCols = NULL;

    for (i=0; i< cInputCols; i++)
        *pcOutputCols += pInputCols[i].itagSequence;

    if ((*pcOutputCols) == 0)
        return 0;

    // allocate and initialize the structures for calling JetRetrieveColumns to
    // find out the value sizes for all the columns

    cb = (*pcOutputCols) * sizeof(JET_RETRIEVECOLUMN);
    pOutputCols = (JET_RETRIEVECOLUMN *) THAllocEx(pTHS, cb);
    *ppOutputCols = pOutputCols;
    memset(pOutputCols, 0, cb);

    // set up all the new JET_RETRIEVECOLUMNS to have a column ID and
    // itagSequence.
    // The itagSequence is relative to columnid, and represents the value number
    // of this columnid in the record, starting at 1

    pCol = pOutputCols;
    for (j=0; j < cInputCols; j++)
    {
        for (i=0; i<pInputCols[j].itagSequence; i++)
        {
            pCol->columnid = pInputCols[j].columnid;
            pCol->itagSequence = i + 1;
            // Use the same grbit in the output columns as we used in the input
            // columns.
            pCol->grbit = pInputCols[j].grbit;
            pCol++;
        }
    }

    // call jet retrieve columns to find out the necessary buffer size for all
    // values

    JetRetrieveColumnsWarnings(pDB->JetSessID,
        pDB->JetObjTbl,
        pOutputCols,
        *pcOutputCols);

    // Look for internal columns and trim them out.  They are tagged, but is
    // treated different from all the other tagged columns, and should NEVER be
    // returned from this routine.
    // TODO: If we get many more of these, a more extensible mechanism of removing
    // them should be designed.

    // Remove the ancestorsid column
    if(*pcOutputCols) {
        if(pOutputCols[*pcOutputCols - 1].columnidNextTagged ==
           ancestorsid) {
            // It's last, just adjust the count.
            *pcOutputCols = *pcOutputCols - 1;
        }
        else {
            for(i=0; i< (*pcOutputCols - 1); i++) {
                if (pOutputCols[i].columnidNextTagged == ancestorsid) {
                    memmove(&pOutputCols[i],
                            &pOutputCols[i+1],
                            (*pcOutputCols - i - 1)*sizeof(JET_RETRIEVECOLUMN));
                    *pcOutputCols = *pcOutputCols - 1;
                    break;
                }
            }
        }
    }


    // Remove the cleanid column
    if(*pcOutputCols) {
        if(pOutputCols[*pcOutputCols - 1].columnidNextTagged ==
           cleanid) {
            // It's last, just adjust the count.
            *pcOutputCols = *pcOutputCols - 1;
        }
        else {
            for(i=0; i< (*pcOutputCols - 1); i++) {
                if (pOutputCols[i].columnidNextTagged == cleanid) {
                    memmove(&pOutputCols[i],
                            &pOutputCols[i+1],
                            (*pcOutputCols - i - 1)*sizeof(JET_RETRIEVECOLUMN));
                    *pcOutputCols = *pcOutputCols - 1;
                    break;
                }
            }
        }
    }

    // if we don't need to return the values we can return

    if (!fGetValues)
        return 0;

    // set up the structure to query for the values of all columns

    for (i = 0; i < *pcOutputCols; i ++)
    {
        pOutputCols[i].pvData = THAllocEx(pTHS, pOutputCols[i].cbActual);
        pOutputCols[i].cbData = pOutputCols[i].cbActual;
    }

    // call Jet to return the values

    JetRetrieveColumnsSuccess(pDB->JetSessID,
        pDB->JetObjTbl,
        pOutputCols,
        *pcOutputCols);

    // success

    return 0;
}

// Lock a DN we are trying to add to avoid multiple entries with the same DN
// We only need to do this while adding until the transaction is committed. We
// do this by maintaining a global list of objects being added and a local list,
// maintained on the DBPOS. At commit (or rollback) time, we remove the objects
// on the DBPOS list from the global list
// We also need to lock whole sections of tree when we are moving an object from
// one part of the tree to another via a rename.  We don't wan't anyone creating
// new objects or moving objects to be under an object we are moving.
//
// Flags for DBLockDN.
// DB_LOCK_DN_WHOLE_TREE: This flag means to lock the whole tree under the given
//   DN.
// DB_LOCK_DN_STICKY: Normal behaviour for locked DNs is that they are released
//   automatically when the DBPOS they were locked on is DBClosed.  This flags
//   means that the DN should remain locked on the global locked DN list until
//   explicitly freed via  DBUnlockStickyDN()

DWORD
DBLockDN (
        DBPOS  *pDB,
        DWORD   dwFlags,
        DSNAME *pDN
        )
{
    THSTATE *pTHS=pDB->pTHS;
    DWORD  dwLockConflictFlags = 0;
    DNList *pGlobalListElement;
    DNList *pLocalListElement;
    ULONG  cb;
    BOOL   bWholeTree = dwFlags & DB_LOCK_DN_WHOLE_TREE;
    DWORD  dwTid = GetCurrentThreadId();

    Assert(VALID_DBPOS(pDB));

    // don't lock the DN when in singleuser mode
    if (pTHS->fSingleUserModeThread) {
        return 0;
    }

    // Can't lock a DN w/o a StringName.  But allow lock of the root
    // which is identified by no GUID, SID or StringName.

    Assert(IsRoot(pDN) || (pDN->NameLen != 0));


    EnterCriticalSection(&csAddList);
#if DBG
    pGlobalListElement = pAddListHead;
    while(pGlobalListElement) {
        Assert(IsValidReadPointer(pGlobalListElement,sizeof(DNList)));
        pGlobalListElement = pGlobalListElement->pNext;
    }
    pLocalListElement = pDB->pDNsAdded;
    while(pLocalListElement) {
        Assert(IsValidReadPointer(pLocalListElement,sizeof(DNList)));
        pLocalListElement = pLocalListElement->pNext;
    }
#endif
    __try
    {
        // look to see if DN is already on global list
        for (pGlobalListElement = pAddListHead;
             (!dwLockConflictFlags && pGlobalListElement);
             pGlobalListElement = pGlobalListElement->pNext) {

            // If we're the replicator or the phantom daemon and we're the one
            // who put this entry in the global list, ignore it.  This
            // essentially allows replication and the phantom daemon to relock
            // DNs it locked in the first place. This is necessary for the
            // phantom daemon because it adds an entry and deletes it inside the
            // same transaction.
            if ((pTHS->fDRA || pTHS->fPhantomDaemon) &&
                (dwTid == pGlobalListElement->dwTid)    ) {
                continue;
            }

            // First, do we directly conflict?
            if (NameMatched(pDN, (PDSNAME) pGlobalListElement->rgb)) {
                // We found the object already locked on the list.
                dwLockConflictFlags |= DB_LOCK_DN_CONFLICT_NODE;
            }

            // And, do we conflict with a tree lock?
            if((pGlobalListElement->dwFlags & DB_LOCK_DN_WHOLE_TREE) &&
               NamePrefix((PDSNAME) pGlobalListElement->rgb, pDN)) {
                // We found that the object is in a locked portion of the tree
                dwLockConflictFlags |= DB_LOCK_DN_CONFLICT_TREE_ABOVE;
            }

            // Finally, does this tree lock conflict with some lock below us?
            if (bWholeTree &&
                NamePrefix(pDN,(PDSNAME) pGlobalListElement->rgb)) {
                // We are trying to lock the whole subtree and found an object
                // that is in that subtree and is already locked
                dwLockConflictFlags |= DB_LOCK_DN_CONFLICT_TREE_BELOW;
            }

            if(dwLockConflictFlags) {
                // We conflict with the current node.  See if it is a sticky
                // node
                if(pGlobalListElement->dwFlags & DB_LOCK_DN_STICKY) {
                    dwLockConflictFlags |= DB_LOCK_DN_CONFLICT_STICKY;
                }
            }
        }


        if (!dwLockConflictFlags) {
            cb = sizeof(DNList) + pDN->structLen;

            // allocate elements for global added list and DBPos added list
            // pGlobalListElement goes on global list so allocate global memory
            pGlobalListElement = malloc(cb);
            if (!pGlobalListElement)
                dwLockConflictFlags = DB_LOCK_DN_CONFLICT_UNKNOWN;
            else {
                // pLocalListElement goes on DBPOS, allocate transaction memory
                pLocalListElement = dbAlloc(cb);
                if (!pLocalListElement) {
                    free(pGlobalListElement);
                    dwLockConflictFlags = DB_LOCK_DN_CONFLICT_UNKNOWN;
                }
            }
        }

        if (!dwLockConflictFlags) {
            // Insert new elements at head of Global list and DBPos list. By
            // inserting at the head we insure that the order of elemnts is the
            // same in both lists allowing for a one pass removal

            // first the global list
            pGlobalListElement->pNext = pAddListHead;
            memcpy(pGlobalListElement->rgb, pDN, pDN->structLen);
            pGlobalListElement->dwFlags = dwFlags;
            pGlobalListElement->dwTid = dwTid;
            pAddListHead = pGlobalListElement;

            // now the DBPos list
            pLocalListElement->pNext = pDB->pDNsAdded;
            memcpy(pLocalListElement->rgb, pDN, pDN->structLen);
            pLocalListElement->dwFlags = dwFlags;
            pLocalListElement->dwTid = dwTid;
            pDB->pDNsAdded = pLocalListElement;
        }
    }
    __finally {
        LeaveCriticalSection(&csAddList);
    }

    return dwLockConflictFlags;
}


// Remove all the DNs on the added list (maintained  on the DBPOS) from the
// global list of objects.  Don't remove them from the global list if they were
// marked as STICKY. Because we make sure the lists have the
// same relative order, we can do this in one pass.  DNs should be locked by
// LocalAdd, LocalModifyDN, and LocalRemove, and PrivateLocalRemoveTree.  This
// routine should be called immediately following transaction conclusion
void
dbUnlockDNs (
        DBPOS *pDB
        )
{
    THSTATE *pTHS=pDB->pTHS;
    BOOL fFound;
    DNList **ppGlobalListElement, *pLocalListElement, *pDeadElement;
    DNList *pDbgGlobalListElement;

    Assert(VALID_DBPOS(pDB));

    EnterCriticalSection(&csAddList);
#if DBG
    pDbgGlobalListElement = pAddListHead;
    while(pDbgGlobalListElement) {
        Assert(IsValidReadPointer(pDbgGlobalListElement,sizeof(DNList)));
        pDbgGlobalListElement = pDbgGlobalListElement->pNext;
    }
    pLocalListElement = pDB->pDNsAdded;
    while(pLocalListElement) {
        Assert(IsValidReadPointer(pLocalListElement,sizeof(DNList)));
        pLocalListElement = pLocalListElement->pNext;
    }
#endif
    __try {
        ppGlobalListElement = &pAddListHead;
        pLocalListElement = pDB->pDNsAdded;
        pDB->pDNsAdded = NULL;

        while (pLocalListElement) {
            fFound = FALSE;
            while (!fFound && *ppGlobalListElement) {
                if (NameMatched((PDSNAME) (pLocalListElement->rgb),
                                (PDSNAME) ((*ppGlobalListElement)->rgb))) {

                    // found the local DN on the global list; remove it and
                    // patch the list

                    fFound = TRUE;
                    if((*ppGlobalListElement)->dwFlags & DB_LOCK_DN_STICKY) {
                        // This was put into the global in a sticky manner, so
                        // by definition, we don't remove it here.
                        ppGlobalListElement = &(*ppGlobalListElement)->pNext;
                    }
                    else {
                        // OK, normal object.  Remove it.
                        pDeadElement = *ppGlobalListElement;
                        *ppGlobalListElement = (*ppGlobalListElement)->pNext;
                        free(pDeadElement);
                    }
                }
                else {
                    ppGlobalListElement = &(*ppGlobalListElement)->pNext;
                }
            }

            Assert(fFound);

            pDeadElement = pLocalListElement;
            pLocalListElement = pLocalListElement->pNext;
            dbFree(pDeadElement);
        }
    }
    __finally {
        LeaveCriticalSection(&csAddList);
    }
    return;
}
DWORD
DBUnlockStickyDN (
        PDSNAME pObj
        )
/*++
 Remove a specific DN from the global LOCK list, but only if it was stuck
 there with the STICK bit set.
--*/
{
    BOOL fFound;
    DNList **ppGlobalListElement, *pLocalListElement, *pDeadElement;


    EnterCriticalSection(&csAddList);
    __try {
        ppGlobalListElement = &pAddListHead;

        fFound = FALSE;
        while (!fFound && *ppGlobalListElement) {
            if(NameMatched((PDSNAME) ((*ppGlobalListElement)->rgb), pObj)) {
                // found the requested  DN on the global list; remove it and
                // patch the list

                fFound = TRUE;
                if( !((*ppGlobalListElement)->dwFlags & DB_LOCK_DN_STICKY) ) {
                    // This wasn't put into the global in a sticky manner, so
                    // by definition, we don't remove it here.
                    fFound = FALSE;
                    __leave;
                }
                else {
                    // OK, normal sticky object.  Remove it.
                    pDeadElement = *ppGlobalListElement;
                    *ppGlobalListElement = (*ppGlobalListElement)->pNext;
                    free(pDeadElement);
                }
            }
            else {
                ppGlobalListElement = &(*ppGlobalListElement)->pNext;
            }
        }

    }
    __finally {
        LeaveCriticalSection(&csAddList);
    }

    if(fFound) {
        // Deleted the object;
        return 0;
    }
    else {
        return DB_ERR_UNKNOWN_ERROR;
    }
}

VOID
dbRegisterLimitReached (
        THSTATE *pTHS,
        RANGEINF *pRangeInf,
        ATTRTYP AttId,
        DWORD lower,
        DWORD upper
        )
/*++
    Keep track of the fact that a limit was reached for the specific attribute
    specified.  Called from DBGetMultipleAtts.

    pRangeInf - the data structure we fill in to show what attributes were range
                limited.
    AttId - the attribute for which a limited range was returned.
    lower - the beginning of the range of values we are returning for the att.
    upper - the end of the range.  0xFFFFFFFF is used to show that we returned
            all the values through the end.

--*/
{
    if(!pRangeInf->count) {
        pRangeInf->pRanges =
            THAllocEx(pTHS, sizeof(RANGEINFOITEM));
    }
    else {
        pRangeInf->pRanges = THReAllocEx(pTHS,
                pRangeInf->pRanges,
                ((pRangeInf->count + 1)*sizeof(RANGEINFOITEM)));
    }


    pRangeInf->pRanges[pRangeInf->count].AttId = AttId;
    pRangeInf->pRanges[pRangeInf->count].lower = lower;
    pRangeInf->pRanges[pRangeInf->count].upper = upper;

    pRangeInf->count++;
}
VOID
DBGetValueLimits (
        ATTCACHE *pAC,
        RANGEINFSEL *pRangeSel,
        DWORD *pStartIndex,
        DWORD *pNumValues,
        BOOL  *pDefault
        )
/*++

  Find the range limits for the values of the selected attribute.  Default
  limits are 0 - 0xFFFFFFFF.

  pAC - the attribute in question
  pRangeSel - a list of pairs of explictly stated ranges and attributes.  May be
              NULL, in which case always use the default range.  Also,
              pRangeSel->valueLimit is an overriding value limit to use (i.e. to
              request that no more than N values are returned for ALL
              attributes.)
  pStartIndex - where to put the index of the first value to return.  Zero
              indexed.
  pNumValues - where to put the number of values to return. 0xFFFFFFFF means to
               return all remaining values.
  pDefault   - Boolean, set to TRUE if an explicitly stated range for this
               attribute was found, FALSE otherwise.


  So, after returning from this routine, the caller knows that it
  should return vaues *pStartIndex through (*pStartIndex) + (*pNumValues).

  Called by DBGetMultipleAtts.

--*/
{
    DWORD i;

    // Assume no limits.
    *pStartIndex = 0;
    *pNumValues = 0xFFFFFFFF;
    *pDefault = TRUE;

    if(!pRangeSel) {
        // Yup, no limits.
        return;
    }

    // OK, assume only general limit, not specific match.
    *pNumValues = pRangeSel->valueLimit;

    // Look through the rangesel for a specific match
    for(i=0;i<pRangeSel->count;i++) {
        if(pAC->id == pRangeSel->pRanges[i].AttId) {
            *pDefault = FALSE;
            if(pRangeSel->pRanges[i].upper == 0xFFFFFFFF) {
                *pStartIndex = pRangeSel->pRanges[i].lower;
                return;
            }
            else if(pRangeSel->pRanges[i].lower <=pRangeSel->pRanges[i].upper) {
                DWORD tempNumVals;
                *pStartIndex = pRangeSel->pRanges[i].lower;
                tempNumVals = (pRangeSel->pRanges[i].upper -
                               pRangeSel->pRanges[i].lower   )+ 1;

                if(*pNumValues != 0xFFFFFFFF) {
                    *pNumValues = min(*pNumValues, tempNumVals);
                }
                else {
                    *pNumValues = tempNumVals;
                }
            }
            else {
                *pNumValues = 0;
            }
            return;
        }
    }
}
DWORD
dbGetMultipleAttsLinkHelp (
        DBPOS        *pDB,
        BOOL          fExternal,
        DWORD         SyntaxFlags,
        ATTCACHE     *pAC,
        RANGEINFSEL  *pRangeSel,
        RANGEINF     *pRangeInf,
        ATTRVALBLOCK *pAVBlock,
        DWORD        *pSearchState,
        DWORD        *pCurrentLinkBase
        )
/*++
  Description:
    Help routine called by dbGetMultipleAtts to read the values of a link
    attribute. Reads the values in O(N) instead of the old algorithm which was
    O(N*N).

    NOTE: assumes that currency in the link table is on the 0th value for the
    attribute specified in pAC.

--*/
{
    THSTATE  *pTHS=pDB->pTHS;
    ATTRVAL  *pAVal=NULL;
    DWORD     currLinkVal = 0;
    DWORD     linkVals = 20;
    PUCHAR    pVal=NULL;
    DWORD     cbVal=0;
    DWORD     cbAlloc=0;
    DWORD     initialValIndex;
    DWORD     valueLimit;
    BOOL      defaultLimit;
    DWORD     err;
    DWORD     ulLen;
    UCHAR    *pucTmp;

    // Since we don't know how many values there are until we read
    // them, guess and then realloc if we need to.

    DBGetValueLimits(pAC, pRangeSel, &initialValIndex,
                     &valueLimit, &defaultLimit);



    // Get the first value we care about.  Assumes we are on the 0th value
    // already, but doesn't check that assumption (except in the debug case).
    // We get back a failure if moving forward initialValueIndex rows in the
    // Link Table doesn't land us on a value of the attribute pAC.
    // As of 12/10/97, we only call dbGetMultipleAttsHelp from two places in
    // DBGetMultipleAtts, and both have already set us to the correct location
    // in the link table. If we ever start calling this routine from
    // places where we are not already on the 0th value, change this to
    // dbGetLinkVal to get the first value of the attribute.  dbGetLinkVal does
    // a JetSeek, guaranteeing  that we are on the first value.  By not using
    // dbGetLinkVal, we are avoiding the extra seek.
#if DBG
    {
        DWORD        ulObjectDnt, ulRecLinkBase;
        ULONG        ulLinkBase = MakeLinkBase(pAC->ulLinkID);
        DWORD        err;

        // Verify that we are on the first value for the attribute in question.
        dbGetLinkTableData (pDB,
                            FIsBacklink(pAC->ulLinkID),
                            FALSE,
                            &ulObjectDnt,
                            NULL,
                            &ulRecLinkBase);

        Assert((ulObjectDnt == pDB->DNT) && (ulLinkBase == ulRecLinkBase));

        // Now, back up one
        err = JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, -1, 0);
        switch(err) {
        case JET_errSuccess:
            // Successfully backed up.

            dbGetLinkTableData (pDB,
                                FIsBacklink(pAC->ulLinkID),
                                FALSE,
                                &ulObjectDnt,
                                NULL,
                                &ulRecLinkBase);

            // We better not be on a qualifying record.
            Assert((ulObjectDnt != pDB->DNT) || (ulLinkBase != ulRecLinkBase));

            // OK, go bak to where you once belonged.
            JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, 1, 0);
            break;

        case JET_errNoCurrentRecord:
            // We didn't manage to back up, so we must be on the very first
            // object in the tree. Actually, we did manage to back up in a
            // sense.  We are on a non-entry before the beginning of the table.
            // Move forward.
            JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, 1, 0);
            break;

        default:
            Assert(!"Verification of position in dbGetMultipleAttsHelp failed");
            break;
        }
    }

#endif

    // it might fail if there is no value for the Nth attribute
    if (err = dbGetNthNextLinkVal(pDB,
                                  initialValIndex,
                                  &pAC,
                                  0,
                                  0,
                                  &pVal,
                                  &cbVal)) {
        return err;
    }

    pAVal = THAllocEx(pTHS, linkVals * sizeof(ATTRVAL));
    do {
        cbAlloc = max(cbAlloc,cbVal);
        if(currLinkVal == linkVals) {
            // We need to allocate some more room
            linkVals *=2;
            pAVal = THReAllocEx(pTHS, pAVal,
                                linkVals * sizeof(ATTRVAL));
        }
        // Save the value.
        if(fExternal) {
            // They want external values.
            if(err = gDBSyntax[pAC->syntax].IntExt(
                    pDB,
                    DBSYN_INQ,
                    cbVal,
                    pVal,
                    &ulLen,
                    &pucTmp,
                    0,
                    0,
                    SyntaxFlags)) {
                size_t iLinkVal;
                THFreeEx(pTHS, pVal);
                for (iLinkVal = 0; iLinkVal < linkVals; iLinkVal++) {
                    THFreeEx(pTHS, pAVal[iLinkVal].pVal);
                }
                THFreeEx(pTHS, pAVal);
                return err;
            }

            pAVal[currLinkVal].valLen = ulLen;
            pAVal[currLinkVal].pVal = THAllocEx(pTHS, ulLen);
            memcpy(pAVal[currLinkVal].pVal,
                   pucTmp,
                   ulLen);
        }
        else {
            // internal format
            pAVal[currLinkVal].valLen = cbVal;
            pAVal[currLinkVal].pVal = pVal;
            // We're handing away our buffer, so we must mark our local
            // pointer to make sure we don't re-use it.
            pVal = NULL;
            cbAlloc = cbVal = 0;
        }
        currLinkVal++;
    } while (valueLimit > currLinkVal &&
             !(err = dbGetNthNextLinkVal(pDB,
                                         1,
                                         &pAC,
                                         (cbAlloc ? DBGETATTVAL_fREALLOC : 0),
                                         cbAlloc,
                                         &pVal,
                                         &cbVal)));


    if(!err) {
        // We stopped before we verified that we got the last value.  See if
        // we got the last value.
        if(!(err = dbGetNthNextLinkVal(pDB,
                                       1,
                                       &pAC,
                                       0,
                                       0,
                                       &pVal,
                                       &cbVal))) {
            // Yep, there are more values.  Set up the range
            // info accordingly
            dbRegisterLimitReached(pTHS,
                                   pRangeInf,
                                   pAC->id,
                                   initialValIndex,
                                   initialValIndex + currLinkVal - 1);
            THFreeEx(pTHS, pVal);
            // And, note that since we aren't on the first value of some
            // attribute, we don't really know where we are.
            *pSearchState = ATTRSEARCHSTATEUNDEFINED;
        }
    }

    if(err) {
        DWORD ActualDNT;

        // Some call to dbGetNthNextLinkVal returned an error, so there are
        // no more values, we got them all.
        if(!defaultLimit) {
            // OK, we returned through the end, but this wasn't
            // a default limit, so we need to register anyway
            dbRegisterLimitReached(pTHS,
                                   pRangeInf,
                                   pAC->id,
                                   initialValIndex,
                                   0xFFFFFFFF);
        }

        // Now, find out what linkbase we are on.
        dbGetLinkTableData(pDB,
                           (FIsBacklink(pAC->ulLinkID)),
                           TRUE,
                           &ActualDNT,
                           NULL,
                           pCurrentLinkBase);

        if(ActualDNT != pDB->DNT) {
            // Positioned on the first value of something, but it wasn't the
            // correct DNT.
            *pCurrentLinkBase = 0xFFFFFFFF;
        }
    }


    pAVal = THReAllocEx(pTHS, pAVal, currLinkVal * sizeof(ATTRVAL));
    pAVBlock->pAVal = pAVal;
    pAVBlock->valCount = currLinkVal;

    return 0;
}
DWORD
dbPositionOnLinkVal (
        IN  DBPOS *pDB,
        IN  ATTCACHE *pAC,
        OUT DWORD *pActualDNT,
        OUT DWORD *pCurrentLinkBase,
        OUT DWORD *pSearchState
        )
/*++
  Description:
    Attempt to position on the first value of the link or back link attribute
    passed in.  Do this by seeking for the first thing with the correct DNT and
    a link base greater than or equal to the link base of the attribute.

  Parameters:
    pDB - DBPOS to use
    pAC - attcache of the attribute to look up.  Should be a link or backlink
        attribute.
    pActualDNT - the actual DNT of the entry we ended up on in the link table
        after we do the seek.
    pCurrentLinkBase - the actual link base of the entry we ended up on in the
        link table after we do the seek.
    pSearchState - The "search state" we're in.  Essentially, what index in the
        link table are we using, the link index or the backlink index.

  Return Values:
    0 -  if we successfully positioned on the first value of the requested
        attribute.
    DB_ERR_NO_VALUE - didn't successfully positioned on the first value of the
        requested attribute.

    Regardless of whether we return 0 or DB_ERR_NO_VALUE, the OUT params are
    filled in with the data from the actual object we found.  Because of the
    seek, We are guaranteed to be on the first value of the attribute described
    by the OUT parameters.  Thus, callers can be aware of the state of currency
    in the link table, and optimize access accordingly.

    One exception is the case where therer are NO entries in the link table
    whose DNT is Greater than or Equal to the DNT of the current object and
    whose linkBase is Greater than or Equal to the linkbase requested.  In this
    case, we set the returned actualDNT to INVALIDDNT and the linkbase to
    0xFFFFFFFF.

    Examples of optimizations:
    1) if the search was for LinkBase 5, and the return says we are on LinkBase
    90, then we know for a fact that there are no values for any attribute whose
    linkbase is between 5 (inclusive) and 90 (exclusive), and that the attribute
    with linkbase 90 has at least 1 value, and we are positioned on the very
    first value.

    2) if the search was for LinkBase 5 for the objects whose DNT is 900, and
    the return says we are on linkbase X and DNT 901, then we know for a fact
    that there are no values for any attribute whose linkbase is greater than or
    equal to 5 for the objects whose DNT is 900.

--*/
{
    ULONG       ulLinkBase = MakeLinkBase(pAC->ulLinkID);
    JET_ERR     err;

    Assert(VALID_DBPOS(pDB));

    *pSearchState = ATTRSEARCHSTATEUNDEFINED;
    if (FIsBacklink(pAC->ulLinkID)) {
        // backlink
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  SZBACKLINKINDEX,
                                  &idxBackLink,
                                  JET_bitMoveFirst);
        *pSearchState = ATTRSEARCHSTATEBACKLINKS;
    }
    else {
        //link
        // When not in LVR mode, values with metadata are invisible
        LPSTR           pszIndexName    = ( pDB->fScopeLegacyLinks ? SZLINKLEGACYINDEX : SZLINKINDEX );
        JET_INDEXID *   pindexid        = ( pDB->fScopeLegacyLinks ? &idxLinkLegacy : &idxLink );
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  pszIndexName,
                                  pindexid,
                                  JET_bitMoveFirst);
        *pSearchState = ATTRSEARCHSTATELINKS;
    }


    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetLinkTbl,
                 &(pDB->DNT),
                 sizeof(pDB->DNT),
                 JET_bitNewKey);

    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetLinkTbl,
                 &ulLinkBase,
                 sizeof(ulLinkBase),
                 0);

    // seek
    err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE);

    if((err) && (err != JET_wrnRecordFoundGreater)) {
        *pActualDNT = INVALIDDNT;
        *pCurrentLinkBase = 0xFFFFFFFF;
        return DB_ERR_NO_VALUE;
    }

    // We're on something.  What is it?
    // test to verify that we found a qualifying record
    dbGetLinkTableData (pDB,
                        (FIsBacklink(pAC->ulLinkID)),
                        FALSE,
                        pActualDNT,
                        NULL,
                        pCurrentLinkBase);

    if((*pActualDNT != pDB->DNT) ||
       (*pCurrentLinkBase != ulLinkBase)) {
        // Positioned on the first value of something, but it wasn't the
        // correct DNT.
        return DB_ERR_NO_VALUE;
    }

    // OK, positioned on the first value of the requested attribute.
    return 0;
}


VOID
DBFreeMultipleAtts(
        IN DBPOS *pDB,
        IN OUT ULONG *attrCount,
        IN OUT ATTR **ppAttr
        )
/*++

Routine Description:

    Free the ATTR array returned by DBGetMultipleAtts

Arguments:

    pTHS - thread state

    attrCount - addr of number of attributes returned by DBGetMultipleAtts

    ppAttr - array returned by DBGetMultipleAtts

Return Value:

    None. *pnAtts is set to 0. *ppAttr is set to NULL.

--*/
{
    THSTATE *pTHS = pDB->pTHS;
    DWORD   nAtt, nVal;
    ATTR    *pAttr;
    ATTRVAL *pAVal;

    if (*attrCount && *ppAttr) {
        pAttr = *ppAttr;
        for (nAtt = 0; nAtt < *attrCount; ++nAtt, ++pAttr) {
            if (pAttr->AttrVal.valCount && pAttr->AttrVal.pAVal) {
                pAVal = pAttr->AttrVal.pAVal;
                for (nVal = 0; nVal < pAttr->AttrVal.valCount; ++nVal, ++pAVal) {
                    if (pAVal->valLen && pAVal->pVal) {
                        THFreeEx(pTHS, pAVal->pVal);
                    }
                }
                THFreeEx(pTHS, pAttr->AttrVal.pAVal);
            }
        }
        THFreeEx(pTHS, *ppAttr);
    }

    *ppAttr = NULL;
    *attrCount = 0;
}


void* JET_API dbGetMultipleAttsRealloc(
    THSTATE*    pTHS,
    void*       pv,
    ULONG       cb
    )
{
    void* pvRet = NULL;

    if (!pv) {
        pvRet = THAllocNoEx(pTHS, cb);
    } else if (!cb) {
        THFreeNoEx(pTHS, pv);
    } else {
        pvRet = THReAllocNoEx(pTHS, pv, cb);
    }

    return pvRet;
}

void dbGetMultipleAttsFreeData(
    THSTATE*            pTHS,
    ULONG               cEnumColumn,
    JET_ENUMCOLUMN*     rgEnumColumn
    )
{
    size_t                  iEnumColumn         = 0;
    JET_ENUMCOLUMN*         pEnumColumn         = NULL;
    size_t                  iEnumColumnValue    = 0;
    JET_ENUMCOLUMNVALUE*    pEnumColumnValue    = NULL;

    if (rgEnumColumn) {
        for (iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++) {
            pEnumColumn = rgEnumColumn + iEnumColumn;

            if (pEnumColumn->err != JET_wrnColumnSingleValue) {
                if (pEnumColumn->rgEnumColumnValue) {
                    for (   iEnumColumnValue = 0;
                            iEnumColumnValue < pEnumColumn->cEnumColumnValue;
                            iEnumColumnValue++) {
                        pEnumColumnValue = pEnumColumn->rgEnumColumnValue + iEnumColumnValue;

                        if (pEnumColumnValue->pvData) {
                            THFreeEx(pTHS, pEnumColumnValue->pvData);
                        }
                    }

                    THFreeEx(pTHS, pEnumColumn->rgEnumColumnValue);
                }
            } else {
                if (pEnumColumn->pvData) {
                    THFreeEx(pTHS, pEnumColumn->pvData);
                }
            }
        }

        THFreeEx(pTHS, rgEnumColumn);
    }
}


DWORD
DBGetMultipleAtts2(
        DBPOS *pDB,
        ULONG cReqAtts,
        ATTCACHE *pReqAtts[],
        RANGEINFSEL *pRangeSel,
        RANGEINF *pRangeInf,
        ULONG *attrCount,
        ATTR **ppAttr,
        DWORD Flags,
        DWORD SecurityDescriptorFlags,
        PSID psidQuotaTrustee
        )
/*++

Routine Description:

    Get multiple attributes in internal or external format. If cReqAtts is 0,
    all attributes are returned. Otherwise, the attributes in pReqAtts present
    on the object are returned, in the same order. Attributes are returned in an
    array of ATTRs with a count.  We use dbGetMultipleColumns to return columns
    from the data table and dbGetNextAtt to retrieve attributes from
    the link table. Flags specify what values to return and how to return them

    The memory returned by this routine is allocated using THAlloc. Free with
    DBFreeMutlipleAtts.

Arguments:

    pDB - the DBPos to use.

    cReqAtts - the number of requested attributes, 0 if requesting all
    attributes.

    pReqAtts - array of attcache pointers specifying which attributes to read.
    Null if asking for all attributes.  Null pointers may be elements of the
    array; if so this routine simply skips that element of the array.

    attrCount - the number of attributes actually read.

    ppAttr - place to put an array of ATTRS, allocated here, filled with the
    attributes read.

    Flags - fEXTERNAL means return values and translate them to external
        format.  fGETVALS means return values and leave them in internal
        format. fREPLICATION means to trim out values that don't flow over
        replication links.  If no flags are specified, return the list of all
        attributes which exist on the object, but don't return any values.

Return Value:

    0 if all went well, non-zero otherwise. Free ppAttr w/DBFreeMultipleAtts.

--*/
{
    THSTATE              *pTHS=pDB->pTHS;
    ULONG                cEnumColumnId = 0;
    JET_ENUMCOLUMNID     *rgEnumColumnId = NULL;
    JET_GRBIT            grbit;
    ULONG                cEnumColumn = 0;
    JET_ENUMCOLUMN       *rgEnumColumn = NULL;
    JET_ENUMCOLUMN       *pEnumColumn;
    JET_ENUMCOLUMNVALUE  EnumColumnValueT = { 1, JET_errSuccess, 0, NULL };
    JET_ENUMCOLUMN       EnumColumnT = { 0, JET_errSuccess, 1, &EnumColumnValueT };
    ULONG                *pInConstr = NULL;
    ULONG                cInConstr = 0;
    ULONG                cb;
    ULONG                i, j;
    ULONG                ulCurrentColumnId = 0;
    ULONG                ulLen;
    UCHAR                *pucTmp;
    UCHAR                aSyntax;
    ATTCACHE             *pAC=NULL;
    BOOL                 fReadCols = FALSE;
    BOOL                 fReadConstr = FALSE;
    ATTR                 *pLinkAttList = NULL;
    ATTR                 *pColAttList = NULL;
    ATTR                 *pConstrAttList = NULL;
    ULONG                currLinkCol;
    DWORD                currCol = 0;
    DWORD                currConstr = 0;
    ULONG                cAtts;
    DWORD                valueLimit = 0xFFFFFFFF;
    DWORD                initialValIndex;
    DWORD                NthAttIndex;
    BOOL                 defaultLimit;
    DWORD                err;
    DWORD                SyntaxFlags=0;
    DWORD                savedExtraFlags=0;
    BOOL                 fGetValues;
    BOOL                 fTrim;
    BOOL                 fExternal;
    BOOL                 fPublic;
    BOOL                 fOriginal;
    ULONG                SearchState;
    ULONG                lastLinkBase = 0;  //initialized to avoid C4701
    ULONG                currentLinkBase;

    // Set up some flags we'll need later on.

    // DBGETMULITPLEATTS_fEXTERNAL implies fGETVALS (i.e. fEXTERNAL = 3,
    // fGETVALS = 1).  So to truly see if we need to get external vals, we
    // need to see if ((FLAGS & 3) & ~1).  Therefore, the complex boolean
    // on the nextline.
    fExternal = ((Flags & DBGETMULTIPLEATTS_fEXTERNAL) &
                 ~DBGETMULTIPLEATTS_fGETVALS);

    fGetValues = Flags & DBGETMULTIPLEATTS_fGETVALS;
    fTrim      = Flags & DBGETMULTIPLEATTS_fREPLICATION;
    fPublic    = Flags & DBGETMULTIPLEATTS_fREPLICATION_PUBLIC;
    fOriginal  = Flags & DBGETMULTIPLEATTS_fOriginalValues;

    Assert(VALID_DBPOS(pDB));

    Assert(!(SecurityDescriptorFlags & 0xFFFFF0));
    SyntaxFlags = SecurityDescriptorFlags;
    Assert (!SecurityDescriptorFlags || SecurityDescriptorFlags && fExternal);

    // INTEXT_SHORTNAME and INTEXT_MAPINAME are in the same space as valid
    // security descriptor flags.  Or in the appropriate value to pass to the
    // intext routines.
    if(Flags & DBGETMULTIPLEATTS_fSHORTNAMES) {
        SyntaxFlags |= INTEXT_SHORTNAME;

        Assert (fExternal);
    }
    if(Flags & DBGETMULTIPLEATTS_fMAPINAMES) {
        SyntaxFlags |= INTEXT_MAPINAME;

        Assert (fExternal);
    }

    // if we have a range selection, we must have a range information thing to
    // fill up.
    Assert(!pRangeSel || pRangeInf);

    if(pRangeSel) {
        pRangeInf->count = 0;
        pRangeInf->pRanges = NULL;
    }

    // First, set up the memory to hold link atts.  We may not need to hold any
    // link atts, but finding out first is difficult and not worth it.
    // We are looking for the 0th link att and we have allocated 5 ATTRs to
    // hold links.
    currLinkCol = 0;
    cAtts = 5;
    pLinkAttList = THAllocEx(pTHS, cAtts * sizeof(ATTR));


    // Now determine if we need to retrieve all attributes or a selection
    if (!cReqAtts) {
        SearchState = ATTRSEARCHSTATELINKS;
        // No atts have been specified, so retrieve all attributes

        fReadCols = TRUE;
        // First, read all the link attributes

        // Set the search state for dbGetNextAtt to look only for links
        // and backlinks

        while (!dbGetNextAtt(pDB, &pAC, &SearchState)) {

            // We now have a link attribute that has values on this object.
            // Furthermore, currency in the link table is already on this
            // object.

            if (fTrim && FIsBacklink(pAC->ulLinkID)) {
                // We don't want to use this one anyway, skip it
                continue;
            }

            if(currLinkCol == cAtts) {
                // We need to allocate some more room
                cAtts *=2;
                pLinkAttList=THReAllocEx(pTHS, pLinkAttList, cAtts * sizeof(ATTR));
            }

            pLinkAttList[currLinkCol].attrTyp = pAC->id;

            // Add the values - only if necessary
            if(fGetValues) {
                DWORD dummy;
                if(err = dbGetMultipleAttsLinkHelp (
                        pDB,
                        fExternal,
                        SyntaxFlags,
                        pAC,
                        pRangeSel,
                        pRangeInf,
                        &pLinkAttList[currLinkCol].AttrVal,
                        &dummy,
                        &dummy)) {
                    return err;
                }
                if(pLinkAttList[currLinkCol].AttrVal.valCount) {
                    currLinkCol++;
                }
            }
            else {
                // We don't really care about the values.
                pLinkAttList[currLinkCol].AttrVal.valCount = 0;
                pLinkAttList[currLinkCol].AttrVal.pAVal = NULL;
                currLinkCol++;
            }
        }
    }
    else {
        // allocate JET_RETRIEVECOLUMN structures for all selected attributes,
        // and read the link attributes directly now.
        SearchState = ATTRSEARCHSTATEUNDEFINED;

        cb = cReqAtts * sizeof(JET_ENUMCOLUMNID);
        rgEnumColumnId = (JET_ENUMCOLUMNID *) THAllocEx(pTHS,cb);
        pInConstr = (ULONG *) THAllocEx(pTHS,cReqAtts*sizeof(ULONG));

        for (i = 0; i < cReqAtts; i++) {
            BOOL fChecked = FALSE;
            if (!pReqAtts[i]) {
                // They didn't really want an attribute.
                continue;
            }

            if (pReqAtts[i]->ulLinkID) {
                DWORD requestedLinkBase = MakeLinkBase(pReqAtts[i]->ulLinkID);

                // The attribute they are asking for is a link or backlink

                if (fTrim && FIsBacklink(pReqAtts[i]->ulLinkID)) {
                    // We don't want to use this one, skip it
                    continue;
                }

                // Position on the correct value.
                fChecked = FALSE;
                // Try using state to position
                if(FIsBacklink((pReqAtts[i]->ulLinkID))) {
                    // We're looking up a backlink.
                    if(SearchState == ATTRSEARCHSTATEBACKLINKS) {
                        // And, our state is in the backlink table.
                        if((requestedLinkBase > lastLinkBase) &&
                           (requestedLinkBase < currentLinkBase)) {
                            // We're looking up an attribute that we know
                            // has no values, because it is in between the
                            // last link ID we tried to look up and
                            // the current link ID we are positioned on.
                            continue;
                        }
                        else if(requestedLinkBase == currentLinkBase) {
                            // We're on the right entry in the
                            // table, and it has values.
                            fChecked = TRUE;
                        }
                        // ELSE
                        //   We don't really know anything about whether
                        //   this has values.  We have to look it up.
                    }
                    // ELSE
                    //   We don't have currency in the correct index in the
                    //   link table.  We have to look it up.
                }
                else {
                    // We're looking up a link.
                    if(SearchState == ATTRSEARCHSTATELINKS) {
                        // And, our state is in the link table.
                        if((requestedLinkBase > lastLinkBase) &&
                           (requestedLinkBase < currentLinkBase)) {
                            // We're looking up an attribute that we know
                            // has no values, because it is in between the
                            // last link ID we tried to look up and
                            // the current link ID we are positioned on.
                            continue;
                        }
                        else if(requestedLinkBase == currentLinkBase) {
                            // Finally, we're on the right entry in the
                            // table, and it has values.
                            fChecked = TRUE;
                        }
                        // ELSE
                        //   We don't really know anything about whether
                        //   this has values.  We have to look it up.
                    }
                    // ELSE
                    //   We don't have currency in the correct index in the
                    //   link table.  We have to look it up.
                }

                if(!fChecked) {
                    DWORD ActualDNT;

                    err = dbPositionOnLinkVal(pDB,
                                              pReqAtts[i],
                                              &ActualDNT,
                                              &currentLinkBase,
                                              &SearchState);
                    lastLinkBase =  requestedLinkBase;
                    if(ActualDNT != pDB->DNT) {
                        // Oops, positioned on the next object, not really a
                        // value of this object at all.
                        currentLinkBase = 0xFFFFFFFF;
                    }

                    if(err) {
                        // No such attribute or we have no values.  Skip it.
                        continue;
                    }
                }

                // The attribute is present and has values.  Furthermore,
                // currency in the Link Table is on the first value.

                if(currLinkCol == cAtts) {
                    // We need to allocate some more room
                    cAtts *=2;
                    pLinkAttList =
                        THReAllocEx(pTHS, pLinkAttList, cAtts * sizeof(ATTR));
                }

                pLinkAttList[currLinkCol].attrTyp = pReqAtts[i]->id;


                // Add the values - only if necessary
                if(fGetValues ) {
                    if(err = dbGetMultipleAttsLinkHelp (
                            pDB,
                            fExternal,
                            SyntaxFlags,
                            pReqAtts[i],
                            pRangeSel,
                            pRangeInf,
                            &pLinkAttList[currLinkCol].AttrVal,
                            &SearchState,
                            &currentLinkBase)) {

                        THFreeEx(pTHS, rgEnumColumnId);
                        THFreeEx(pTHS, pInConstr);
                        return err;
                    }
                    if(pLinkAttList[currLinkCol].AttrVal.valCount) {
                        currLinkCol++;
                    }
                }
                else {
                    // They don't want values.
                    pLinkAttList[currLinkCol].AttrVal.valCount = 0;
                    pLinkAttList[currLinkCol].AttrVal.pAVal = NULL;
                    currLinkCol++;
                }
            }
            else if (pReqAtts[i]->bIsConstructed) {
                // constructed atts, save to read at end
                pInConstr[cInConstr] = pReqAtts[i]->id;
                cInConstr++;
                fReadConstr = TRUE;
            }
            else {
                // Attribute is a column - setup and read it later
                rgEnumColumnId[cEnumColumnId].columnid = pReqAtts[i]->jColid;
                rgEnumColumnId[cEnumColumnId].ctagSequence = 0;
                cEnumColumnId++;
                fReadCols = TRUE;
            }
        }
    }

    // Now we need to read the columns - if necessary
    if (fReadCols) {

        grbit = JET_bitEnumerateCompressOutput;
        if (!fOriginal) {
            // JET_bitEnumerateCopy == JET_bitRetrieveCopy
            Assert(pDB->JetRetrieveBits == 0 || pDB->JetRetrieveBits == JET_bitEnumerateCopy);
            grbit = grbit | pDB->JetRetrieveBits;
        }
        if (!fGetValues) {
            grbit = grbit | JET_bitEnumeratePresenceOnly;
        }
        if (!cEnumColumnId) {
            grbit = grbit | JET_bitEnumerateTaggedOnly;
        }
        JetEnumerateColumnsEx(
            pDB->JetSessID,
            pDB->JetObjTbl,
            cEnumColumnId,
            rgEnumColumnId,
            &cEnumColumn,
            &rgEnumColumn,
            (JET_PFNREALLOC)dbGetMultipleAttsRealloc,
            pTHS,
            -1,  // never truncate values
            grbit );

        i = 0;
        if(cEnumColumn) {
            // We have some columns, turn them into an attrblock
            DWORD numColsNeeded = 0;
            // Count the number of columns we read.
            numColsNeeded = cEnumColumn;

            // Tack this onto the end of the already allocated ATTRs we used for
            // the link atts.  Saves allocations later if the caller doesn't
            // care about what order we return things in
            numColsNeeded = currLinkCol + numColsNeeded;
            if (numColsNeeded > cAtts) {
                cAtts = numColsNeeded;
                pLinkAttList =
                    THReAllocEx(pTHS, pLinkAttList, cAtts * sizeof(ATTR));
            }
            pColAttList = &(pLinkAttList[currLinkCol]);

            i=0;
            while(i< cEnumColumn) {
                DWORD numVals;

                ulCurrentColumnId = rgEnumColumn[i].columnid;

                // Look for internal columns and trim them out.  They are tagged, but is
                // treated different from all the other tagged columns, and should NEVER be
                // returned from this routine.
                if(     ulCurrentColumnId == ancestorsid ||
                        ulCurrentColumnId == cleanid) {
                    i++;
                    continue;
                }

                if(rgEnumColumn[i].err == JET_wrnColumnNull) {
                    // We get this when we have removed a value in this
                    // transaction
                    i++;
                    continue;
                }

                // Get the attcache for this column
                if (!(pAC = SCGetAttByCol(pTHS, ulCurrentColumnId))) {
                    if (rgEnumColumnId) THFreeEx(pTHS, rgEnumColumnId);
                    dbGetMultipleAttsFreeData(pTHS, cEnumColumn, rgEnumColumn);
                    if (pInConstr) THFreeEx(pTHS, pInConstr);
                    return DB_ERR_SYSERROR;
                }

                // Find out if there is anything special about the
                // attribute.  First clear any flags that we might
                // have set in a previous pass.  Then set any flags
                // as appropriate.
                SyntaxFlags &= (~savedExtraFlags);
                savedExtraFlags = DBGetExtraHackyFlags(pAC->id);
                SyntaxFlags |= savedExtraFlags;

                // Pass the flags for decryption, if the attribute is
                // a secret data
                if (DBIsSecretData(pAC->id)){

                    // Filter out secrets if requested
                    if ( fTrim && fPublic ) {
                        i++;
                        continue; // note - jump to bottom of loop
                    }

                    SyntaxFlags|=INTEXT_SECRETDATA;
                }
                else
                {
                    SyntaxFlags&=(~((ULONG) INTEXT_SECRETDATA));
                }

                DBGetValueLimits(pAC, pRangeSel, &initialValIndex,
                                 &valueLimit, &defaultLimit);
                NthAttIndex = initialValIndex;

                if(fTrim) {
                    switch(pAC->id) {
                      case ATT_REPS_TO:
                      case ATT_REPS_FROM:
                      case ATT_OBJECT_GUID:
                      case ATT_REPL_PROPERTY_META_DATA:
                      case ATT_REPL_UPTODATE_VECTOR:

                        // We don't want to use this one.  We trim these out
                        // to support replication, as replication doesn't
                        // send any of these across a replication link
                        i++;
                        continue; // note - jump to bottom of loop

                      default:
                        ;
                    }

                }

                pEnumColumn = &rgEnumColumn[i];
                if(pEnumColumn->err == JET_wrnColumnSingleValue) {
                    // Decompress this column value to a temp enum column struct
                    EnumColumnT.columnid = pEnumColumn->columnid;
                    EnumColumnValueT.cbData = pEnumColumn->cbData;
                    EnumColumnValueT.pvData = pEnumColumn->pvData;
                    pEnumColumn = &EnumColumnT;
                }

                if(fGetValues) {
                    if (NthAttIndex > pEnumColumn->cEnumColumnValue) {
                        // We were told via range to skip all the values
                        i++;
                        continue;
                    }
                }

                // At this point, we definitely have some values left to return.
                pColAttList[currCol].attrTyp = pAC->id;

                // Count the values for this attribute.
                if (NthAttIndex >= pEnumColumn->cEnumColumnValue) {
                    numVals = 0;
                } else {
                    numVals = pEnumColumn->cEnumColumnValue - NthAttIndex;
                }

                if(numVals > valueLimit) {
                    dbRegisterLimitReached(pTHS,
                                           pRangeInf,
                                           pAC->id,
                                           initialValIndex,
                                           initialValIndex + valueLimit - 1);
                    numVals = valueLimit;
                }
                else if (!defaultLimit) {
                    // We're going to get all the rest of the values, but we
                    // need to register because they explicitly asked for limits
                    dbRegisterLimitReached(pTHS,
                                           pRangeInf,
                                           pAC->id,
                                           initialValIndex,
                                           0xFFFFFFFF);
                }

                // Set up the AttrValBlock
                if(fGetValues) {

                    pColAttList[currCol].AttrVal.valCount= numVals;
                    pColAttList[currCol].AttrVal.pAVal =
                        THAllocEx(pTHS, numVals * sizeof(ATTRVAL));
                }
                else {
                    // They don't want values at all.
                    pColAttList[currCol].AttrVal.valCount = 0;
                    pColAttList[currCol].AttrVal.pAVal = NULL;
                }

                // Now put the values into the AttrValBlock from the jet
                // columns
                for (j = 0; j < numVals; j++ ) {

                    // get the current column value
                    ULONG cbData = pEnumColumn->rgEnumColumnValue[j + NthAttIndex].cbData;
                    void* pvData = pEnumColumn->rgEnumColumnValue[j + NthAttIndex].pvData;

                    // pvData now owns the memory containing the column value
                    if (rgEnumColumn[i].err == JET_wrnColumnSingleValue) {
                        rgEnumColumn[i].pvData = NULL;
                    } else {
                        rgEnumColumn[i].rgEnumColumnValue[j + NthAttIndex].pvData = NULL;
                    }

                    if (j < valueLimit && fExternal && fGetValues) {
                        // They want external values.

                        if(err = gDBSyntax[pAC->syntax].IntExt(
                                pDB,
                                DBSYN_INQ,
                                cbData,
                                pvData,
                                &ulLen,
                                &pucTmp,
                                0,
                                0,
                                SyntaxFlags)) {
                            THFreeEx(pTHS, pvData);
                            if (rgEnumColumnId) THFreeEx(pTHS, rgEnumColumnId);
                            dbGetMultipleAttsFreeData(pTHS, cEnumColumn, rgEnumColumn);
                            if (pInConstr) THFreeEx(pTHS, pInConstr);
                            return err;
                        }
                        if (    ulLen == cbData &&
                                (   pucTmp == pvData ||
                                    memcmp(pucTmp, pvData, ulLen ) == 0) ) {
                            // Internal and external are the same, don't
                            // alloc any more memory.
                            pColAttList[currCol].AttrVal.pAVal[j].valLen =
                                cbData;
                            pColAttList[currCol].AttrVal.pAVal[j].pVal =
                                pvData;
                        }
                        else {
                            pColAttList[currCol].AttrVal.pAVal[j].valLen =
                                ulLen;
                            pColAttList[currCol].AttrVal.pAVal[j].pVal =
                                THAllocEx(pTHS, ulLen);
                            memcpy(pColAttList[currCol].AttrVal.pAVal[j].pVal,
                                   pucTmp,
                                   ulLen);
                            THFreeEx(pTHS, pvData);
                        }
                    }
                    else if (j < valueLimit && fGetValues) {
                        // They want values in internal format
                        pColAttList[currCol].AttrVal.pAVal[j].valLen =
                            cbData;
                        pColAttList[currCol].AttrVal.pAVal[j].pVal =
                            pvData;
                    }
                    else {
                        // They don't want these values at all.
                        THFreeEx(pTHS, pvData);
                    }
                }

                // Consume the source column and an attr block
                i++;
                currCol++;
            }
        }
    }


    // Don't need this anymore.
    if (rgEnumColumnId) THFreeEx(pTHS,rgEnumColumnId);
    dbGetMultipleAttsFreeData(pTHS, cEnumColumn, rgEnumColumn);

    // Now read and add any constructed atts

    if (fReadConstr) {

        DWORD numColsNeeded = 0;

        Assert(cReqAtts);
        // maximum space needed
        numColsNeeded = currLinkCol + currCol + cInConstr;
        if (numColsNeeded > cAtts) {
            cAtts = numColsNeeded;
            pLinkAttList =
                    THReAllocEx(pTHS, pLinkAttList, cAtts * sizeof(ATTR));
            pColAttList = &(pLinkAttList[currLinkCol]);
        }
        pConstrAttList = &(pLinkAttList[currLinkCol + currCol]);

        for (i=0; i<cReqAtts; i++) {
            // For every constructed attribute (pAC)
            DWORD dwBaseIndex;
            DWORD dwNumRequeseted;
            DWORD bDefault;

            if (pInConstr[i]) {
                if (!(pAC = SCGetAttById(pTHS, pInConstr[i]))) {
                    if (pInConstr) THFreeEx(pTHS, pInConstr);
                    return DB_ERR_SYSERROR;
                };

                // Get value range information. If no range information was explicitly provided using
                // the ;range= syntax default ranges will be used and bDefault will be true
                DBGetValueLimits(pAC, pRangeSel, &dwBaseIndex, &dwNumRequeseted, &bDefault);

                // tokenGroups or tokenGroupsNoGCAcceptable may have to
                // go off machine, in which case they close the current
                // transaction and open a new one. pDB will contain the
                // new dbpos in that case
                err = dbGetConstructedAtt(&pDB,
                                          pAC,
                                          &pConstrAttList[currConstr],
                                          dwBaseIndex,
                                          &dwNumRequeseted,
                                          bDefault,
                                          psidQuotaTrustee,
                                          fExternal);

                switch (err) {
                case DB_success:
                    if (!bDefault) {
                        // Register limits for return to client
                        DPRINT2(1,"Registering Limits = %d-%d \n", dwBaseIndex, dwNumRequeseted);
                        dbRegisterLimitReached(pTHS,
                                               pRangeInf,
                                               pAC->id,
                                               dwBaseIndex,
                                               dwNumRequeseted);
                    }

                    // got the constructed att. see if value is needed
                    pConstrAttList[currConstr].attrTyp = pInConstr[i];
                    if (!fGetValues) {
                        pConstrAttList[currConstr].AttrVal.valCount = 0;
                        pConstrAttList[currConstr].AttrVal.pAVal = NULL;
                    }
                    currConstr++;
                        break;
                case DB_ERR_NO_VALUE:
                       // this constructed att is not defined on this object
                       break;
                default:
                       // some other error
                      if (pInConstr) THFreeEx(pTHS, pInConstr);
                      return err;
                }
             }
          } // for

     }


    // Merge the lists into a sorted array - if necessary
    i = 0;
    if (!cReqAtts) {
        // No need for any particular order.  The ATTRs have all been allocated
        // using the pLinkAttList variable, just return that.
        *attrCount = currLinkCol + currCol;
        if(*attrCount)
            *ppAttr = pLinkAttList;
        else {
            *ppAttr = NULL;
            // since we don't return anything, free it
            THFreeEx (pTHS, pLinkAttList);
        }
    }
    else {
        ULONG iCol=0;
        ULONG iLink=0;
        ULONG iConstr=0;

        // We could conceivable play shuffling games using the already allocated
        // ATTR array, but for ease of coding I just allocate a new array.
        (*ppAttr) = THAllocEx(pTHS, (currLinkCol + currCol + currConstr)*sizeof(ATTR));

        i=0;
        for (j=0; j<cReqAtts; j++) {
            if(!pReqAtts[j]) {
                // They didn't ask for anything using this element.
                continue;
            }
            if ((iCol < currCol) &&
                (pReqAtts[j]->id == pColAttList[iCol].attrTyp)) {
                // The next one to put in the return array is a non-link att
                (*ppAttr)[i] = pColAttList[iCol];
                iCol++;
                i++;
            }
            else if((iLink < currLinkCol) &&
                    (pReqAtts[j]->id == pLinkAttList[iLink].attrTyp)) {
                // The next one to put in the return array is a link att
                (*ppAttr)[i] = pLinkAttList[iLink];
                iLink++;
                i++;
            }
            else if((iConstr < currConstr) &&
                    (pReqAtts[j]->id == pConstrAttList[iConstr].attrTyp)) {
                // The next one to put in the return array is a Constr att
                (*ppAttr)[i] = pConstrAttList[iConstr];
                iConstr++;
                i++;
            }
            else
                // The next one to put in the return array was not found on this
                // object, skip it.
                continue;

        }
        *attrCount = i;

        // since we already copied all the entries, free it
        THFreeEx (pTHS, pLinkAttList);
    }


    if (pInConstr) THFreeEx(pTHS, pInConstr);
    return 0;
}


extern BOOL gStoreSDsInMainTable;
#ifdef DBG
LONG gSecurityCacheHits = 0;
LONG gSecurityCacheMisses = 0;
#endif

/*++
DBGetObjectSecurityInfo

Description:

    Get SD, DN, Sid and pointer to CLASSCACHE for an object that is
    current in the table.

    NOTE!!! This routine returns an abbreviated form of the DSNAME GUID and SID
    filled in, but no string name.

Arguments:

    pDB - the DBPos to use.

    tag -- the DNT to check

    pulLen - (optional) the size of the buffer allocated to hold the security descriptor

    pNTSD - (optional) pointer to pointer to security descriptor found.

    ppCC - (optional) pointer to pointer to classcache to fill in.

    ppDN - (optional) pointer to DN (only SID and GUID are filled!).

    pObjFlag -- (optional) pointer to objFlag

    flags -- which table to use:
                DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE or DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE
             are we positioned on the correct row already or we need to seek the dnt?
                DBGETOBJECTSECURITYINFO_fSEEK_ROW (only seeks on Search table are allowed!)
             DBGETOBJECTSECURITYINFO_fDONT_EXCEPT_ON_MISSING_DNT -- don't except if the DNT is not found.
                Just return DIRERR_OBJ_NOT_FOUND. This is used by DBGetParentSecurityInfo to schedule
                a PDNT fixup.

    pfSDIsGlobalSDRef -- was the returned reference a ref to the global data.
                         Note that it is not guaranteed that the SD will be found in the cache.
                         If it is not found, then the caller must THFreeEx the SD.

--*/
DWORD
DBGetObjectSecurityInfo(
    PDBPOS pDB,
    DWORD dnt,
    PULONG pulLen,
    PSECURITY_DESCRIPTOR *ppNTSD,
    CLASSCACHE **ppCC,
    PDSNAME pDN,
    char    *pObjFlag,
    DWORD   flags,
    BOOL    *pfSDIsGlobalSDRef
    )
{
    THSTATE  *pTHS=pDB->pTHS;
    JET_RETRIEVECOLUMN attList[5];
    DWORD cAtt, ntsdIndex, sidIndex, guidIndex, ccIndex, objflagIndex;
    ATTRTYP class;
    JET_ERR err;
    SDID sdId; // temp buffer for SD ID
    UCHAR *sdBuf;
    d_memname* pname;
    JET_TABLEID table = flags & DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE ? pDB->JetSearchTbl : pDB->JetObjTbl;

    Assert(VALID_DBPOS(pDB));

    // make sure they are asking for at least something
    Assert((ppNTSD && pulLen && pfSDIsGlobalSDRef) || ppCC || pDN || pObjFlag);
    // seeks on the object table are not allowed
    Assert((flags & DBGETOBJECTSECURITYINFO_fSEEK_ROW) == 0 || (flags & DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE) != 0);

    if (pDN) {
        pDN->structLen = DSNameSizeFromLen(0);
        pDN->NameLen = 0;
    }

    if (ppNTSD) {
        *ppNTSD = NULL;
        *pulLen = 0;
    }
    if (ppCC) {
        *ppCC = NULL;
    }
    if (pObjFlag) {
        *pObjFlag = 0;
    }

    // try to find the entry in the cache
    // don't use cache if buffer copy is requested and reading from object table
    // don't use cache if NTSD is requested and is in old-style format
    if ( ( (flags & DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE)
           || (pDB->JetRetrieveBits == 0)) &&
         dnGetCacheByDNT(pDB, dnt, &pname) &&
         (ppNTSD && pname->sdId != (SDID)-1))
    {
#ifdef DBG
        InterlockedIncrement(&gSecurityCacheHits);
#endif
        // ok, we got some useful info in the cache... use it.
        if (ppNTSD) {
            ntsdIndex = 0;
            if (pname->sdId == (SDID)0) {
                // this object has no SD.
                attList[ntsdIndex].pvData = NULL;
                attList[ntsdIndex].err = JET_wrnColumnNull;
                attList[ntsdIndex].cbActual = 0;
            }
            else {
                // grab sdid
                attList[ntsdIndex].pvData = &sdId;
                sdId = pname->sdId;
                attList[ntsdIndex].cbActual = sizeof(SDID);
                attList[ntsdIndex].err = JET_errSuccess;
            }
        }

        class = pname->dwObjectClass;

        if (pDN) {
            // copy sid and guid
            memcpy(&pDN->Guid, &pname->Guid, sizeof(GUID));
            memcpy(&pDN->Sid, &pname->Sid, pname->SidLen);
            pDN->SidLen = pname->SidLen;
            // sid is already InPlaceSwapSid'ed
        }

        if (pObjFlag) {
            *pObjFlag = pname->objflag ? 1 : 0;
        }
    }
    else {
        // no luck with the cache, let's read the data from the DB
#ifdef DBG
        if ((flags & DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE) || pDB->JetRetrieveBits == 0) {
            // we hoped to find it in the cache...
            InterlockedIncrement(&gSecurityCacheMisses);
        }
#endif

        if (flags & DBGETOBJECTSECURITYINFO_fSEEK_ROW) {
            // need to position on the DNT first
            JetSetCurrentIndexSuccess(pDB->JetSessID,
                                      table,
                                      NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)

            JetMakeKeyEx(pDB->JetSessID, table, &dnt, sizeof(dnt), JET_bitNewKey);
            if (err = JetSeekEx(pDB->JetSessID, table, JET_bitSeekEQ)) {
                if (flags & DBGETOBJECTSECURITYINFO_fDONT_EXCEPT_ON_MISSING_DNT) {
                    return DIRERR_OBJ_NOT_FOUND;

                }
                DsaExcept(DSA_DB_EXCEPTION, err, dnt);
            }
            pDB->SDNT = dnt;
        }
        else {
#ifdef DBG
            // let's check we are positioned on the right row
            DWORD checkDNT, cbActual;
            err = JetRetrieveColumn(pDB->JetSessID, table, dntid, &checkDNT, sizeof(checkDNT), &cbActual, pDB->JetRetrieveBits, NULL);
            Assert(err == 0 && checkDNT == dnt);
#endif
        }

        // Set up the RetrieveColumn structure to do the JetRetrieveColumns

        cAtt = 0;
        memset(attList, 0, sizeof(attList));

        if (ppNTSD) {
            // First, the Security Descriptor hash
            ntsdIndex = cAtt;
            cAtt++;
            attList[ntsdIndex].pvData = (void *)&sdId;
            attList[ntsdIndex].cbData = sizeof(sdId);
            attList[ntsdIndex].columnid = ntsecdescid;
            attList[ntsdIndex].grbit = pDB->JetRetrieveBits;
            attList[ntsdIndex].itagSequence = 1;
        }
        else {
            ntsdIndex = -1;
        }

        if (pDN) {
            sidIndex = cAtt;
            cAtt++;
            // Next, the SID
            attList[sidIndex].pvData = (void *)&pDN->Sid;
            attList[sidIndex].columnid = sidid;
            attList[sidIndex].cbData = sizeof(NT4SID);
            attList[sidIndex].grbit = pDB->JetRetrieveBits;
            attList[sidIndex].itagSequence = 1;

            // And, the GUID
            guidIndex = cAtt;
            cAtt++;
            attList[guidIndex].pvData = (void *)&pDN->Guid;
            attList[guidIndex].columnid = guidid;
            attList[guidIndex].cbData = sizeof(GUID);
            attList[guidIndex].grbit = pDB->JetRetrieveBits;
            attList[guidIndex].itagSequence = 1;
        }
        else {
            sidIndex = guidIndex = -1;
        }

        if (ppCC) {
            // the class
            ccIndex = cAtt;
            cAtt++;
            attList[ccIndex].pvData = (void *)&class;
            attList[ccIndex].columnid = objclassid;
            attList[ccIndex].cbData = sizeof(class);
            attList[ccIndex].grbit = pDB->JetRetrieveBits;
            attList[ccIndex].itagSequence = 1;
        }
        else {
            ccIndex = -1;
        }

        if (pObjFlag) {
            // the object flag
            objflagIndex = cAtt;
            cAtt++;
            attList[objflagIndex].pvData = (void *)pObjFlag;
            attList[objflagIndex].columnid = objid;
            attList[objflagIndex].cbData = sizeof(*pObjFlag);
            attList[objflagIndex].grbit = pDB->JetRetrieveBits;
            attList[objflagIndex].itagSequence = 1;
        }
        else {
            objflagIndex = -1;
        }

        err = JetRetrieveColumnsWarnings(pDB->JetSessID,
                                         table,
                                         attList,
                                         cAtt);

        if((err != JET_errSuccess && err != JET_wrnBufferTruncated)           ||
           // overall error not Buffer Truncated or success
           (ntsdIndex != -1 && attList[ntsdIndex].err != JET_wrnBufferTruncated &&
            attList[ntsdIndex].err != JET_errSuccess && attList[ntsdIndex].err != JET_wrnColumnNull) ||
           // or specific error for NTSD not Buffer truncated or success or NULL
           (guidIndex != -1 && attList[guidIndex].err != JET_errSuccess && attList[guidIndex].err != JET_wrnColumnNull) ||
           // or some error other than no GUID (guid may be missing due to a bug in w2k)
           (sidIndex != -1 && attList[sidIndex].err != JET_errSuccess && attList[sidIndex].err != JET_wrnColumnNull ) ||
           // or some error other than no SID (sid is not always there)
           (ccIndex != -1 && attList[ccIndex].err != JET_errSuccess)          ||
           // or no Class
           (objflagIndex != -1 && attList[objflagIndex].err != JET_errSuccess && attList[objflagIndex].err != JET_wrnColumnNull)
          )
        {
            return DB_ERR_UNKNOWN_ERROR;
        }

        if (guidIndex != -1 && attList[guidIndex].err == JET_wrnColumnNull) {
            // guid is not there. Log an event
            DSNAME* pDN2 = NULL;
            DWORD err2 = ERROR_SUCCESS;
            
            err2 = sbTableGetDSName(pDB, dnt, &pDN2, 0);
            
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DSA_FOUND_GUIDLESS_OBJECT,
                     err2 == ERROR_SUCCESS && pDN2 != NULL && pDN2->NameLen > 0 ? 
                        szInsertWC2(pDN2->StringName, pDN2->NameLen) : szInsertSz("#err#"), 
                     NULL, NULL);
            if (pDN2) {
                THFreeEx(pTHS, pDN2);
            }
            if (flags & DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE) {
                // sbTableGetDSName might have moved the currency on the search table. Restore it.
                JetMakeKeyEx(pDB->JetSessID, table, &dnt, sizeof(dnt), JET_bitNewKey);
                err2 = JetSeekEx(pDB->JetSessID, table, JET_bitSeekEQ);
                // we should not have missed, because we already found that object before
                Assert(err2 == ERROR_SUCCESS);
                pDB->SDNT = dnt;
            }
        }

        if (ntsdIndex != -1 && attList[ntsdIndex].err == JET_wrnBufferTruncated) {
            // This is the expected case for old style SDs. We didn't allocate enough for the
            // Security Descriptor because we needed to know how big it was.  Now we
            // know, allocate and remake the call.

            attList[ntsdIndex].pvData = THAllocEx(pTHS, attList[ntsdIndex].cbActual);
            attList[ntsdIndex].cbData = attList[ntsdIndex].cbActual;

            err = JetRetrieveColumnsWarnings(pDB->JetSessID, table, &attList[ntsdIndex], 1);

            if(err || attList[ntsdIndex].err) {
                THFreeEx(pTHS, attList[ntsdIndex].pvData);
                return DB_ERR_UNKNOWN_ERROR;
            }
        }

        if (sidIndex != -1) {
            // Convert the Sid to external val
            pDN->SidLen = attList[sidIndex].cbActual;
            if (pDN->SidLen) {
                InPlaceSwapSid(&pDN->Sid);
            }
        }

        if (objflagIndex != -1 && attList[objflagIndex].err == JET_wrnColumnNull) {
            // phantom...
            *pObjFlag = 0;
        }
    }

    if (ppNTSD) {
        if (attList[ntsdIndex].err == JET_errSuccess) {
            *pfSDIsGlobalSDRef = FALSE;
            // check if we can get this SD out of the global cache
            if (attList[ntsdIndex].cbActual == sizeof(SDID)) {
                // ok, sd in the single-instancing format. Check the global cache
                PSDCACHE_ENTRY pEntry;
                // we should not have realloc'ed any new buffer for the sd
                Assert(attList[ntsdIndex].pvData == &sdId);
                pEntry = dbFindSDCacheEntry(pTHS->Global_DNReadCache, sdId);
                if (pEntry != NULL) {
                    // got one!
                    *ppNTSD = &pEntry->SD;
                    *pulLen = pEntry->cbSD;
                    *pfSDIsGlobalSDRef = TRUE;
                }
            }

            if (!(*pfSDIsGlobalSDRef)) {
                // got the NTSD. Convert it to external format.
                err = IntExtSecDesc(pDB, DBSYN_INQ, attList[ntsdIndex].cbActual, attList[ntsdIndex].pvData, pulLen, &sdBuf, 0, 0, 0);

                if (err == 0) {
                    *ppNTSD = THAllocEx(pTHS, *pulLen);
                    memcpy(*ppNTSD, sdBuf, *pulLen);
                }

                if (attList[ntsdIndex].pvData != &sdId) {
                    // we don't need this internal value anymore
                    THFreeEx(pTHS, attList[ntsdIndex].pvData);
                }

                if(err) {
                    // something bad happened in IntExtSecDesc...
                    *ppNTSD = NULL;
                    *pulLen = 0;
                    return DB_ERR_UNKNOWN_ERROR;
                }
            }
        }
        else {
            // null ntsd
            Assert(attList[ntsdIndex].err == JET_wrnColumnNull);
            *ppNTSD = NULL;
            *pulLen = 0;
        }
    }

    if (ppCC) {
        // And get the classcache pointer.
        *ppCC = SCGetClassById(pTHS, class);
        // REVIEW:  we should probably throw a schema exception here instead of returning 1
        if(NULL == *ppCC) {
            // Um, we have a problem, but it's not a JET error.  Oh, well, return it
            // anyway.
            if (ppNTSD) {
                THFreeEx(pTHS, *ppNTSD);
                *ppNTSD = NULL;
                *pulLen = 0;
            }
            return 1;
        }
    }

    return 0;
}

/*++
DBGetParentSecurityInfo

Routine Description:

    Get the security descriptor, DN, and pointer to CLASSCACHE for the object
    class  of the parent of the current object.  Do this using the search table
    so that the currency and current index of the object table is unnafected.

Arguments:

    pDB - the DBPos to use.

    pulLen - OUT (optional) the size of the buffer allocated to hold the security descriptor.

    ppNTSD - OUT (optional) security descriptor found.

    ppCC - OUT (optional) classcache to fill in.

    pDN - OUT (optional) DN to fill GUID and SID

    pfSDIsGlobalSDRef - did we get a ptr to the global SD cache? If not, caller needs to THFreeEx the SD.

Return Value:

    0 if all went well, non-zero otherwise.

--*/
DWORD
DBGetParentSecurityInfo (
        PDBPOS pDB,
        PULONG pulLen,
        PSECURITY_DESCRIPTOR *ppNTSD,
        CLASSCACHE **ppCC,
        PDSNAME pDN,
        BOOL*   pfSDIsGlobalSDRef
        )
{
    JET_ERR err;
    THSTATE* pTHS = pDB->pTHS;

    // since we are using search table, we will be able to use cache

    // call DBGetObjectSecurityInfo. We are not positioned on the row!
    err = DBGetObjectSecurityInfo(
            pDB,
            pDB->PDNT,
            pulLen,
            ppNTSD,
            ppCC,
            pDN,
            NULL,
            DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE 
            | DBGETOBJECTSECURITYINFO_fSEEK_ROW
            | DBGETOBJECTSECURITYINFO_fDONT_EXCEPT_ON_MISSING_DNT,
            pfSDIsGlobalSDRef
        );
    if (err == DIRERR_OBJ_NOT_FOUND) {
        DPRINT2(0, "Found an object with missing parent: DNT=%d, PDNT=%d\n", pDB->DNT, pDB->PDNT);
        
        // this object is missing its parent. Schedule fixup.
        InsertInTaskQueue(TQ_MoveOrphanedObject,
                          (void*)(DWORD_PTR)pDB->DNT,
                          0);
        // we can except now.
        DsaExcept(DSA_DB_EXCEPTION, err, pDB->PDNT);
    }

    if (pulLen && err == 0 && *pulLen == 0) {
        // no NTSD. Not allowed.
        err = DB_ERR_UNKNOWN_ERROR;
    }
    return err;
}

extern DWORD
DBFillGuidAndSid (
        DBPOS *pDB,
        DSNAME *pDN
        )
/*++

Routine Description:

    Fills in the GUID and SID fields of the DSNAME structure passed in by
    reading the GUID and SID from the current object in the pDB.  Completely
    ignores any string portion of the DSNAME.

Parameters:

    pDB - DBPos to use

    pDN - Pointer to a DSNAME.  The DSNAME must be preallocated and must be at
    least large enough to hold the GUID and SID.

Return Values:

    0 if all went well.
--*/
{
    JET_RETRIEVECOLUMN attList[2];
    DWORD cbActual;
    DWORD err;
    NT4SID  objectSid;


#if DBG
    // In the debug case, track the value of the old guid for an assert later.
    GUID  oldGuid;

    memcpy(&oldGuid, &pDN->Guid, sizeof(GUID));
#endif

    Assert(VALID_DBPOS(pDB));

    memset(&objectSid, 0, sizeof(NT4SID));

    memset(attList, 0, sizeof(attList));
    attList[0].pvData = (void *)&pDN->Guid;
    attList[0].columnid = guidid;
    attList[0].cbData = sizeof(GUID);
    attList[0].grbit = pDB->JetRetrieveBits;
    attList[0].itagSequence = 1;

    attList[1].pvData = (void *)&objectSid;
    attList[1].columnid = sidid;
    attList[1].cbData = sizeof(NT4SID);
    attList[1].grbit = pDB->JetRetrieveBits;
    attList[1].itagSequence = 1;

    err = JetRetrieveColumnsWarnings(pDB->JetSessID,
                                     pDB->JetObjTbl,
                                     attList,
                                     2);
    switch(err) {
    case JET_errSuccess:
        pDN->SidLen = attList[1].cbActual;
        if(attList[1].cbActual) {
            //
            // Convert the Sid to external val
            //
            InPlaceSwapSid(&objectSid);
            memcpy(&pDN->Sid, &objectSid, sizeof(NT4SID));
        }
        return 0;
        break;

    default:
        return DB_ERR_UNKNOWN_ERROR;
        break;
    }

#if DBG
    // either we didn't have a guid, or we did and we ended up with the same
    // guid.  This is here because I was too chicken to bail out of this request
    // if the dsname already had a GUID, and I wanted to see if anyone ever
    // tried to fill in a GUID on top of a different GUID (which they shouldn't
    // do.)
    Assert(fNullUuid(&oldGuid) || !memcmp(&oldGuid,&pDN->Guid,sizeof(GUID)));
#endif


    return DB_ERR_UNKNOWN_ERROR;
}

DWORD
DBFillDSName(
    DBPOS *    pDB,
    DSNAME **  ppDN,
    BOOL       fReAlloc
    )
/*++

Routine Description:

    Given a DBPOS which is current upon an object, it will fill a DSNAME structure (existing or not)

Arguments:

    pDB - current upon object to fill
    ppDN - out
    fReAlloc - this tells the routine that the original DN is THAlloc()'d and so the
        DB layer can do a THReAlloc() on it.


Return Value:

    DB_ERR values.

--*/
{
    DWORD err = ERROR_SUCCESS;
    ULONG ulLength = 0;

    Assert(IsValidDBPOS(pDB));
    if ((ppDN==NULL) || (pDB == NULL)) {
        Assert(!"Hello!!!  This shouldn't happen in production code!");
        err = ERROR_INVALID_PARAMETER;
    }

    if (err==ERROR_SUCCESS) {
        if ((*ppDN==NULL) || ((*ppDN)->NameLen==0)) {
            if (*ppDN==NULL) {
                ulLength = 0;
            } else {
                ulLength = sizeof(DSNAME);
            }
            err = DBGetAttVal(pDB, 1, ATT_OBJ_DIST_NAME,
                              (fReAlloc) ? DBGETATTVAL_fREALLOC : 0,
                              ulLength,
                              &ulLength,
                              (PUCHAR *)ppDN);
        } else if (fNullUuid(&(*ppDN)->Guid)) {
            err = DBFillGuidAndSid(pDB, *ppDN);
        }
    }

    return err;
}

VOID
DBFillResObj (
    DBPOS* pDB,
    DSNAME *pObj,
    ATTRTYP* pMSOC,
    ULONG* pIT,
    ULONG* pIsDel
    )
/*++

Routine Description:

    Retrieve a bunch of values required for the ResObj.
    Fills in the GUID and SID fields of the DSNAME structure passed in by
    reading the GUID and SID from the current object in the pDB.  Completely
    ignores any string portion of the DSNAME.
    Attempts to use DN read cache first to get GUID, SID and MSOC.

Parameters:

    pDB - DBPos to use

    pObj - Pointer to a DSNAME.  The DSNAME must be preallocated and must be at
    least large enough to hold the GUID and SID.

    pMSOC - most specific object class (CLASS_TOP if unable to retrieve)

    pIT - instance type (IT_UNINSTANT if unable to retrieve)

    pIsDel - deleted flag

Return Values:

    Succeeds (or excepts)
--*/
{
    JET_RETRIEVECOLUMN attList[5];
    DWORD cCols;
    d_memname* pname;
    DWORD err;

    Assert(pDB && pObj && pMSOC && pIT && pIsDel);

    if (pDB->DNT == ROOTTAG) {
        // special case for root DNT
        // don't hit the DB, just fill in the proper values
        memset(&pObj->Guid, 0, sizeof(GUID)); // no GUID
        pObj->SidLen = 0; // no SID
        *pIsDel = 0;
        *pIT = IT_UNINSTANT | IT_NC_HEAD;
        *pMSOC = CLASS_TOP;
        return;
    }

    // instanceType and isDeleted are always loaded
    memset(attList, 0, 2*sizeof(JET_RETRIEVECOLUMN));
    attList[0].pvData = pIT;
    attList[0].columnid = insttypeid;
    attList[0].cbData = sizeof(ULONG);
    attList[0].grbit = pDB->JetRetrieveBits;
    attList[0].itagSequence = 1;

    attList[1].pvData = pIsDel;
    attList[1].columnid = isdeletedid;
    attList[1].cbData = sizeof(ULONG);
    attList[1].grbit = pDB->JetRetrieveBits;
    attList[1].itagSequence = 1;
    cCols = 2;

    if (pDB->JetRetrieveBits == 0 && dnGetCacheByDNT(pDB, pDB->DNT, &pname)) {
        // found in the cache! Grab GUID, SID and objectclass
        memcpy(&pObj->Guid, &pname->Guid, sizeof(GUID));
        memcpy(&pObj->Sid, &pname->Sid, pname->SidLen);
        pObj->SidLen = pname->SidLen;
        *pMSOC = pname->dwObjectClass;
        if (*pMSOC == 0) {
            *pMSOC = CLASS_TOP;
        }
    }
    else {
        // not found in cache, load GUID, SID and MSOC from the DB
        memset(&attList[2], 0, 3*sizeof(JET_RETRIEVECOLUMN));
        attList[2].pvData = &pObj->Guid;
        attList[2].columnid = guidid;
        attList[2].cbData = sizeof(GUID);
        attList[2].grbit = pDB->JetRetrieveBits;
        attList[2].itagSequence = 1;

        attList[3].pvData = &pObj->Sid;
        attList[3].columnid = sidid;
        attList[3].cbData = sizeof(NT4SID);
        attList[3].grbit = pDB->JetRetrieveBits;
        attList[3].itagSequence = 1;

        attList[4].pvData = pMSOC;
        attList[4].columnid = objclassid;
        attList[4].cbData = sizeof(ATTRTYP);
        attList[4].grbit = pDB->JetRetrieveBits;
        attList[4].itagSequence = 1;

        cCols = 5;
    }

    // load values now
    JetRetrieveColumnsSuccess(pDB->JetSessID, pDB->JetObjTbl, attList, cCols);

    if (attList[0].err) {
        // no instanceType
        *pIT = IT_UNINSTANT;
    }
    if (attList[1].err) {
        // no isDeleted
        *pIsDel = 0;
    }
    if (cCols > 2) {
        if (attList[3].err || attList[3].cbActual == 0) {
            // no sid
            pObj->SidLen = 0;
        }
        else {
            // there is a sid
            pObj->SidLen = attList[3].cbActual;
            InPlaceSwapSid(&pObj->Sid);
        }
        if (attList[4].err) {
            // no object class
            *pMSOC = CLASS_TOP;
        }
    }
}


// NTRAID#NTRAID-580234-2002/03/18-andygo:  CHECK_FOR_ADMINISTRATOR_LOSS is dead code
// REVIEW:  CHECK_FOR_ADMINISTRATOR_LOSS is dead code
//
//  On October 22 1997, the NTWSTA Self Host Domain
//  lost all builtin group memberships. To track the
//  problem down if it happens again, have a hard coded
//  check for Administrator being removed from Administrators
//  The check works by reading in the DNT of Administrators
//  and the DNT of Administrator at boot time, and then
//  checking for them in DBRemoveLinkVal
//

#ifdef CHECK_FOR_ADMINISTRATOR_LOSS

ULONG ulDNTAdministrators=0;
ULONG ulDNTAdministrator=0;
BOOL  AdminDNTsAreValid=FALSE;

VOID
DBCheckForAdministratorLoss(
    ULONG ulDNTObject,
    ULONG ulDNTAttribute
   )
{

    if ((ulDNTObject==ulDNTAdministrators)
        && (ulDNTAttribute==ulDNTAdministrator)
        && (AdminDNTsAreValid))
    {
       KdPrint(("Possible removal of Administrator Account"
                "From the Administrators Group. Please "
                "Contact DS Development\n"));

       DebugBreak();
    }
}

/*++dbFindObjectWithSidInNc
 *
 *     Given a DS Name Specifying  a SID and an ULONG specifying the
 *     naming context, this routine will try to find an Object with
 *     the given Sid in the specified naming context
 *
 *
 *     Returns
 *          0                       - Found the Object Successfully
 *          DIRERR_OBJECT_NOT_FOUND - If the Object Was not found
 *          DIRERR_NOT_AN_OBJECT    - If the Object is a Phantom
 *
 --*/
DWORD APIENTRY
dbFindObjectWithSidInNc(DBPOS FAR *pDB, DSNAME * pDN, ULONG ulGivenNc)
{

    NT4SID InternalFormatSid;
    DWORD err;
    ULONG ulDNT;
    ULONG cbActual;


    Assert(VALID_DBPOS(pDB));
    Assert(pDN->SidLen>0);
    Assert(RtlValidSid(&pDN->Sid));


    err = DBSetCurrentIndex(pDB, Idx_Sid, NULL, FALSE);
    Assert(err == 0);       // the index must always be there

    // Convert the Sid to Internal Representation
    memcpy(&InternalFormatSid,&(pDN->Sid),RtlLengthSid(&(pDN->Sid)));
    InPlaceSwapSid(&InternalFormatSid);

    // Make a Jet Key
    JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
             &InternalFormatSid,RtlLengthSid(&InternalFormatSid), JET_bitNewKey);

    // Seek on Equal to the SId, Set the Index range
    err = JetSeek(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekEQ|JET_bitSetIndexRange);
    if ( 0 == err )
    {
#ifndef JET_BIT_SET_INDEX_RANGE_SUPPORT_FIXED
        JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
                 &InternalFormatSid,RtlLengthSid(&InternalFormatSid), JET_bitNewKey);

        JetSetIndexRangeEx(pDB->JetSessID, pDB->JetObjTbl,
            (JET_bitRangeUpperLimit | JET_bitRangeInclusive ));
#endif
        //
        // Ok We found the object. Keep Moving Forward Until either the SID does not
        // Match or we reached the given object
        //

       do
       {
            ULONG ulNcDNT;

            err = JetRetrieveColumn(pDB->JetSessID, pDB->JetObjTbl,ncdntid,
                &ulNcDNT, sizeof(ulNcDNT), &cbActual, 0 , NULL);

            if (0==err)
            {
                // We read the NC DNT of the object

                if (ulNcDNT==ulGivenNc)
                    break;
            }
            else if (JET_wrnColumnNull==err)
            {
                // It is Ok to find an object with No Value for NC DNT
                // this occurs on Phantoms. Try next object

                err = 0;
            }
            else
            {
                break;
            }

            err = JetMove(
                    pDB->JetSessID,
                    pDB->JetObjTbl,
                    JET_MoveNext,
                    0);


        }  while (0==err);

        if (0==err)
        {
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, dntid,
                             &ulDNT, sizeof(ulDNT), &cbActual, 0, NULL);


            #if DBG

            // On Checked Builds verify that the Sid is unique within the NC

            err = JetMove(
                    pDB->JetSessID,
                    pDB->JetObjTbl,
                    JET_MoveNext,
                    0);

            if (0==err)
            {
                ULONG ulNcDNT2=0;

                 err = JetRetrieveColumn(pDB->JetSessID, pDB->JetObjTbl,ncdntid,
                            &ulNcDNT2, sizeof(ulNcDNT2), &cbActual, 0 , NULL);

                 if ((0==err) && (ulNcDNT2==ulGivenNc))
                 {
                     // This is a case of a duplicate Sid . Assert this
                     Assert(FALSE && "Duplicate Sid Found By dbFindObjectWithSidinNc");
                 }
            }

            // Reset error back to 0
            err = 0;

            // Don't worry that we lost currency. DBFindDNT will restore it.
            #endif

            // Establish currency on the object found.
            DBFindDNT(pDB, ulDNT);

            // check if the record found is an object

            // DO NOT REMOVE FOLLOWING CHECK OR CHANGE ERROR CODE AS OTHER
            // OTHER ROUTINES DEPEND ON THIS BEHAVIOUR.

            if (!DBCheckObj(pDB))
            {
                DPRINT1(1, "dbFindObjectWithSidInNC: success on DNT=%ld of non object \n",
                        (pDB)->DNT);
                err = DIRERR_NOT_AN_OBJECT;
            }
        }
        else
        {
            err = DIRERR_OBJ_NOT_FOUND;
        }
    }
    else
    {
        err = DIRERR_OBJ_NOT_FOUND;
    }

    return err;
}



VOID
DBGetAdministratorAndAdministratorsDNT()
{
   ULONG AdministratorsSid[] = {0x201,0x05000000,0x20,0x220};
   DSNAME Administrator;
   DSNAME Administrators;
   ULONG  RidAuthority=0;
   DBPOS  *pDB=NULL;
   ULONG  err=0;


   AdminDNTsAreValid = FALSE;

   __try
   {
      //
      // Compose the DSNames
      //

      RtlZeroMemory(&Administrator,sizeof(DSNAME));
      RtlZeroMemory(&Administrators,sizeof(DSNAME));

      //
      // Compose the administrator user
      //

      //
      // This function is called so early on in the initialization
      // phase that we don't know if we are installing or not; only
      // do the search if the gAnchor has been setup correctly.
      // We will assert otherwise.
      //
      if ( RtlValidSid( &(gAnchor.pDomainDN->Sid) ) )
      {

      RtlCopyMemory(&Administrator.Sid,
                 &gAnchor.pDomainDN->Sid,
                 RtlLengthSid(&gAnchor.pDomainDN->Sid));

      RidAuthority= (*(RtlSubAuthorityCountSid(&Administrator.Sid)))++;
      *RtlSubAuthoritySid(&Administrator.Sid,RidAuthority) = DOMAIN_USER_RID_ADMIN;
      Administrator.structLen = DSNameSizeFromLen(0);
      Administrator.SidLen = RtlLengthSid(&Administrator.Sid);

      //
      // This function is called so early on in the initialization
      // phase that we don't know if we are installing or not; only
      // do the search if the gAnchor has been setup correctly.
      // We will assert otherwise.
      //
      if ( RtlValidSid( &(gAnchor.pDomainDN->Sid) ) )
      {

          RtlCopyMemory(&Administrator.Sid,
                     &gAnchor.pDomainDN->Sid,
                     RtlLengthSid(&gAnchor.pDomainDN->Sid));

          RidAuthority= (*(RtlSubAuthorityCountSid(&Administrator.Sid)))++;
          *RtlSubAuthoritySid(&Administrator.Sid,RidAuthority) = DOMAIN_USER_RID_ADMIN;
          Administrator.structLen = DSNameSizeFromLen(0);
          Administrator.SidLen = RtlLengthSid(&Administrator.Sid);

          //
          // Compose DSNAME for Administrators Alias
          //

          RtlCopyMemory(&Administrators.Sid,
                        AdministratorsSid,
                        RtlLengthSid((PSID)AdministratorsSid)
                        );

          Administrators.structLen = DSNameSizeFromLen(0);
          Administrators.SidLen = RtlLengthSid(&Administrators.Sid);

          __try
              {

             DBOpen(&pDB);
             err = dbFindObjectWithSidInNc(
                      pDB,
                      &Administrator,
                      gAnchor.ulDNTDomain
                      );


             if (0==err)
             {
                ulDNTAdministrator = pDB->DNT;

                err = dbFindObjectWithSidInNc(
                          pDB,
                          &Administrators,
                          gAnchor.ulDNTDomain
                          );

                if (0==err)
                {
                   ulDNTAdministrators = pDB->DNT;
                   AdminDNTsAreValid = TRUE;
                }
             }

          }
          __finally
          {
             DBClose(pDB,TRUE);
          }
      }
   }
   }
   __except (HandleAllExceptions(GetExceptionCode()))
   {

       AdminDNTsAreValid = FALSE;
   }

}
#endif

DWORD
dbSetValueIfUniqueSlowVersion (
        DBPOS *pDB,
        ATTCACHE *pAC,
        PUCHAR pVal,
        DWORD  valLen)
/*++
  Description:

    Read all the values on the current object and compare against the incoming
    value.  If the new value is unique, add it.  Otherwise, return an error.

    NOTE: only works for non link table attributes.  Don't call otherwise.

--*/
{
    JET_SETINFO  setinfo;
    JET_RETINFO  retinfo;
    BOOL         fDone = FALSE;
    DWORD        CurrAttrOccur = 1;
    PUCHAR       pTempVal=NULL;
    DWORD        cbTempVal=0;
    DWORD        actuallen;
    DWORD        err;

    Assert(!pAC->ulLinkID);

    // Start by allocating a buffer as big as the one we are comparing.
    pTempVal = THAllocEx(pDB->pTHS, valLen);
    cbTempVal = valLen;

    while(!fDone) {
        // Read the next value.
        retinfo.cbStruct = sizeof(retinfo);
        retinfo.itagSequence = CurrAttrOccur;
        retinfo.ibLongValue = 0;
        retinfo.columnidNextTagged = 0;

        err = JetRetrieveColumnWarnings(
                pDB->JetSessID,
                pDB->JetObjTbl,
                pAC->jColid,
                pTempVal,
                cbTempVal,
                &actuallen,
                pDB->JetRetrieveBits,
                &retinfo);

        switch(err) {
        case 0:
            // Got the value.  Compare.
            if (gDBSyntax[pAC->syntax].Eval(
                    pDB,
                    FI_CHOICE_EQUALITY,
                    valLen,
                    pVal,
                    actuallen,
                    pTempVal)) {
                // Duplicate value.
                // NTRAID#NTRAID-580268-2002/03/18-andygo:  dbSetValueIfUniqueSlowVersion leaks memory when a duplicate multi value is found
                // REVIEW:  we leak pTempVal here
                return DB_ERR_VALUE_EXISTS;
            }
            CurrAttrOccur++;
            break;

        case JET_wrnBufferTruncated:
            // The buffer was not big enough.  Resize, then redo the
            // JetRetrieveColumnWarnings (i.e. end the loop but don't advance
            // CurrAttrOccur.
            pTempVal = THReAllocEx(pDB->pTHS, pTempVal, actuallen);
            cbTempVal = actuallen;
            break;

        case JET_wrnColumnNull:
            // no more values.
            fDone = TRUE;
            break;

        default:
            // Huh?
            THFreeEx(pDB->pTHS, pTempVal);
            DsaExcept(DSA_DB_EXCEPTION, err, pAC->id);
            break;
        }
    }

    THFreeEx(pDB->pTHS, pTempVal);

    // OK, we got here, so it must not be duplicate.  Add it in.
    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 0;
    JetSetColumnEx(pDB->JetSessID,
                   pDB->JetObjTbl,
                   pAC->jColid,
                   pVal,
                   valLen,
                   0,
                   &setinfo);

    return 0;

}

DWORD
DBFindBestProxy(
    DBPOS   *pDB,
    BOOL    *pfFound,
    DWORD   *pdwEpoch
    )
/*++

  Description:

    Iterates over all proxy objects whose ATT_PROXIED_OBJECT_NAME references
    the current object and returns the highest valued epoch from that set.
    See also PreProcessProxyInfo() in drancrep.c.

  Arguments:

    pDB - Active DBPOS.

    pfFound - OUT which indicates if any matching proxy objects were found.

    pdwEpoch - OUT which holds highest matching epoch number if any matching
        proxy objects were found.

  Return Values:

    0 on success, !0 otherwise.

--*/
{
    DWORD                           dwErr;
    JET_RETINFO                     retInfo;
    ATTCACHE                        *pAC;
    UCHAR                           buff[PROXY_SIZE_INTERNAL];
    INTERNAL_SYNTAX_DISTNAME_STRING *pVal = NULL;
    ULONG                           len;
    BOOL                            fContinue = TRUE;

    Assert(VALID_DBPOS(pDB));
    Assert(VALID_THSTATE(pDB->pTHS));

    *pfFound = FALSE;
    *pdwEpoch = 0;

    if ( !(pAC = SCGetAttById(pDB->pTHS, ATT_PROXIED_OBJECT_NAME)) )
    {
        return(DIRERR_ATT_NOT_DEF_IN_SCHEMA);
    }

    if ( dwErr = JetSetCurrentIndex2(pDB->JetSessID,
                                     pDB->JetSearchTbl,
                                     SZPROXIEDINDEX,
                                     0) )
    {
        return(dwErr);
    }

    // Internal representation for DISTNAME_BINARY (syntax of
    // ATT_PROXIED_OBJECT_NAME) is INTERNAL_SYNTAX_DISTNAME_STRING
    // whose first DWORD is the DNT of the proxied object, followed
    // by the BOB structlen, followed by the proxy type, followed
    // by the epoch number.  (see xdommove.h).  So we can find all
    // matching proxy objects for the current object with a key whose
    // prefix is: { DNT, proxyLen, PROXY_TYPE_PROXY }.

    len = sizeof(buff);
    MakeProxyKeyInternal(pDB->DNT, PROXY_TYPE_PROXY, &len, buff);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl,
                 buff, len, JET_bitNewKey);

    dwErr = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekGE);

    switch ( dwErr )
    {
    case JET_wrnSeekNotEqual:   break;
    case JET_errRecordNotFound: return(0);
    default:                    return(dwErr);
    }

    while ( fContinue )
    {
        pVal = (INTERNAL_SYNTAX_DISTNAME_STRING *) buff;

        retInfo.cbStruct = sizeof(retInfo);
        retInfo.ibLongValue = 0;
        retInfo.itagSequence = 1;
        retInfo.columnidNextTagged = 0;

        if ( dwErr = JetRetrieveColumnWarnings(
                                    pDB->JetSessID,
                                    pDB->JetSearchTbl,
                                    pAC->jColid,
                                    (UCHAR *) pVal,
                                    sizeof(buff),
                                    &len,
                                    JET_bitRetrieveFromIndex,
                                    &retInfo) )
        {
            if ( JET_wrnBufferTruncated != dwErr )
            {
                return(dwErr);
            }

            // ATT_PROXIED_OBJECT_NAME value is only 4 DWORDs in internal
            // format and static buffer we used above was big enough, so if
            // we get here it means we have a malformed value.  However,
            // go ahead and read it so we can dump it in the debugger and
            // understand what it is and how it got here.
            Assert(!"Malformed ATT_PROXIED_OBJECT_NAME key");


            pVal = (INTERNAL_SYNTAX_DISTNAME_STRING *)
                                            THAllocEx(pDB->pTHS, len);

            retInfo.cbStruct = sizeof(retInfo);
            retInfo.ibLongValue = 0;
            retInfo.itagSequence = 1;
            retInfo.columnidNextTagged = 0;

            if ( dwErr = JetRetrieveColumnWarnings(
                                    pDB->JetSessID,
                                    pDB->JetSearchTbl,
                                    pAC->jColid,
                                    (UCHAR *) pVal,
                                    len,
                                    &len,
                                    JET_bitRetrieveFromIndex,
                                    &retInfo) )
            {
                THFreeEx(pDB->pTHS, pVal);
                return(dwErr);
            }
        }

        if (    (pVal->tag != pDB->DNT)
             || (PROXY_SIZE_INTERNAL != len)
             || (PROXY_BLOB_SIZE != pVal->data.structLen)
             || (PROXY_TYPE_PROXY != GetProxyTypeInternal(len, pVal)) )
        {
            // We've moved past the object of interest or its a malformed
            // ATT_PROXIED_OBJECT_NAME value.  There could theoretically
            // be additional ATT_PROXIED_OBJECT_NAME values for this DNT
            // which aren't malformed, but the malformed test is just to
            // gracefully handle values which pre-existed before we
            // got rid of the bogus DWORD on the end of the value.
            fContinue = FALSE;
        }
        else
        {
            *pfFound = TRUE;

            // Save epoch number if better/greater then current.

            if ( GetProxyEpochInternal(len, pVal) > *pdwEpoch )
            {
                *pdwEpoch = GetProxyEpochInternal(len, pVal);
            }

            // Advance to next item in index.

            dwErr = JetMoveEx(pDB->JetSessID, pDB->JetSearchTbl,
                              JET_MoveNext, 0);

            switch ( dwErr )
            {
            case JET_errSuccess:

                break;

            case JET_wrnRecordFoundGreater:
            case JET_errNoCurrentRecord:

                dwErr = 0;
                // fall through ...

            default:

                fContinue = FALSE;
                break;
            }
        }

        if ( pVal && (buff != (UCHAR *) pVal) )
        {
            THFreeEx(pDB->pTHS, pVal);
            pVal = NULL;
        }
    }

    return(dwErr);
}


DWORD
DBGetValueCount_AC(
    DBPOS *pDB,
    ATTCACHE *pAC
    )

/*++

Routine Description:

    Return the number of values which an attribute has.

    This code adapted from dbGetMultipleColumns

Arguments:

    pDB - Valid DB position
    Att - Attribute id to be queried for number of values

Return Value:

    DWORD - Number of values

--*/

{
    JET_RETRIEVECOLUMN  inputCol;
    DWORD err;

    Assert(VALID_DBPOS(pDB));
    Assert( pAC );

    // query Jet for the count of columns in this record

    memset(&inputCol, 0, sizeof(inputCol));
    inputCol.columnid = pAC->jColid;
    // Read from copy buffer if in prepared update, otherwise from db
    inputCol.grbit = pDB->JetRetrieveBits;

    // Use the non-excepting version so we can handle Column Not Found
    err = JetRetrieveColumns(
        pDB->JetSessID,
        pDB->JetObjTbl,
        &inputCol,
        1);
    switch (err) {
    case JET_errSuccess:
        break;
    case JET_errColumnNotFound:
        inputCol.itagSequence = 0;
        break;
    default:
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
        break;
    }

    return inputCol.itagSequence;
} /* DBGetValueCount */

void
DBGetObjectTableDataUsn (
    PDBPOS           pDB,
    DWORD           *pulNcDnt OPTIONAL,
    USN             *pusnChanged OPTIONAL,
    DWORD           *pulDnt OPTIONAL
    )

/*++

Routine Description:

    Return the fields from the object table dra usn index.

    You must be positioned on SZDRAUSNINDEX in order for this to work.

Arguments:

    pDB -
    pulNcDnt -
    pusnChanged -

Return Value:

    None

--*/

{
    JET_RETRIEVECOLUMN attList[3];
    DWORD              grbit, cAtt = 0;

    // Always retrieve from index
    grbit = pDB->JetRetrieveBits | JET_bitRetrieveFromIndex;

    memset(attList,0,sizeof(attList));
    // First, try to retrieve everything from the index.

    if (pulNcDnt) {
        attList[cAtt].pvData = pulNcDnt;
        attList[cAtt].columnid = ncdntid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }

    if (pusnChanged) {
        attList[cAtt].pvData = pusnChanged;
        attList[cAtt].columnid = usnchangedid;
        attList[cAtt].cbData = sizeof(USN);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }

    if (pulDnt) {
        attList[cAtt].pvData = pulDnt;
        attList[cAtt].columnid = dntid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }

    JetRetrieveColumnsSuccess(pDB->JetSessID,
                              pDB->JetObjTbl,
                              attList,
                              cAtt);
    return;
} /* DBGetLinkTableDataUsn  */


void DBFreeSearhRes (THSTATE *pTHS, SEARCHRES *pSearchRes, BOOL fFreeOriginal)
{
    DWORD        i,j,k;
    ENTINFLIST  *pEntList=NULL, *pTemp;
    ATTR        *pAttr=NULL;
    ATTRVAL     *pAVal=NULL;

    if(!pSearchRes) {
        return;
    }

    // We don't actually free most of the search result.
    pEntList = &pSearchRes->FirstEntInf;

    for(i=0;i < pSearchRes->count; i++) {
        // Free the values in the EntInf.
        THFreeEx(pTHS, pEntList->Entinf.pName);

        pAttr = pEntList->Entinf.AttrBlock.pAttr;
        for(j=0;j<pEntList->Entinf.AttrBlock.attrCount;j++) {
            pAVal = pAttr->AttrVal.pAVal;
            for(k=0;k<pAttr->AttrVal.valCount;k++) {
                THFreeEx(pTHS, pAVal->pVal);
                pAVal++;
            }
            THFreeEx(pTHS, pAttr->AttrVal.pAVal);
            pAttr++;
        }
        THFreeEx (pTHS, pEntList->Entinf.AttrBlock.pAttr);

        // hold a back pointer
        pTemp = pEntList;

        // step forward
        pEntList = pEntList->pNextEntInf;

        // free the back pointer.
        if(i) {
            // But, dont free the first one.
            THFreeEx(pTHS, pTemp);
        }
    }

    if (fFreeOriginal) {
        THFreeEx(pTHS, pSearchRes);
    }

    return;
}

/*
 * Helper routine to update root GUID
 */

DWORD DBUpdateRootGuid(THSTATE* pTHS) {
    GUID guid;
    DWORD dnt;
    DWORD err = 0;
    DBPOS* pDB;

    // this should only be called if the gdbFlag was not set
    Assert(gdbFlags[DBFLAGS_ROOT_GUID_UPDATED] != '1');
    Assert(pTHS->pDB == NULL);

    __try {
        DBOpen(&pTHS->pDB);
        pDB = pTHS->pDB;
        __try {
            JetSetCurrentIndex2Success(pDB->JetSessID, pDB->JetObjTbl, SZDNTINDEX, 0);

            // find $NOTANOBJECT$
            dnt = NOTOBJECTTAG;
            JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl, &dnt, sizeof(dnt), JET_bitNewKey);
            err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekEQ);
            if (err) {
                __leave;
            }

            // set guid=(1,0,0,0,0,0...,0)
            memset(&guid, 0, sizeof(GUID));
            guid.Data1 = 1;
            JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, DS_JET_PREPARE_FOR_REPLACE);
            JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, guidid, &guid, sizeof(guid), 0, NULL);
            JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, NULL);

            // find ROOT
            dnt = ROOTTAG;
            JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl, &dnt, sizeof(dnt), JET_bitNewKey);
            err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekEQ);
            if (err) {
                __leave;
            }

            // set guid=null
            guid.Data1 = 0;
            JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, DS_JET_PREPARE_FOR_REPLACE);
            JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, guidid, &guid, sizeof(guid), 0, NULL);
            JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, NULL);
        }
        __finally {
            DBClose(pTHS->pDB, !AbnormalTermination() && err == 0);
        }
    } __except (HandleMostExceptions(GetExceptionCode())) {
        /* Do nothing, but at least don't die */
        err = DB_ERR_EXCEPTION;
    }

    if (err == 0) {
        DPRINT(0, "Updating root GUID: success\n");
    }
    else {
        DPRINT1(0, "Updating root GUID: failed (err = %d)\n", err);
    }

    // done
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbmeta.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dbmeta.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Various functions to support handling of replication per-property meta data
    in the DBLayer.

DETAILS:

CREATED:

    97/05/07    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <attids.h>
#include <drameta.h>
#include <anchor.h>
#include <dsutil.h>
#include <drserr.h>

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>

// Assorted DSA headers
#include <dsevent.h>
#include <debug.h>
#define DEBSUB "DBMETA:"

// DBLayer includes
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBMETA

extern BOOL gfRestoring;
extern ULONG gulRestoreCount;
extern BOOL gfRunningAsExe;


// Factor used to bump up the version to make a write authoritative
// This value matches that used in util\ntdsutil\armain.c
#define VERSION_BUMP_FACTOR (100000)

// Version bump cannot exceed this any one time
#define VERSION_BUMP_LIMIT (10000000)

// Number of seconds in a day
#define SECONDS_PER_DAY (60*60*24)

////////////////////////////////////////////////////////////////////////////////
//
// Global implementations.
//


void
dbVerifyCachedObjectMetadata(
    IN DBPOS *pDB
    )

/*++

Routine Description:

    Verify that the metadata has enough attributes for a valid object

    Assumptions: these attributes are present on all objects: present, deleted,
    or pure subref's. We should not be called on a phantom.

Arguments:

    pDB - Database position

Return Value:

    None

--*/

{
    if (pDB->fSkipMetadataUpdate) {
        Assert (DsaIsSingleUserMode());
        return;
    }

    Assert( (pDB->DNT == ROOTTAG) || ReplLookupMetaData( ATT_INSTANCE_TYPE, pDB->pMetaDataVec, NULL ) );
    Assert( (pDB->DNT == ROOTTAG) || ReplLookupMetaData( ATT_OBJECT_CLASS, pDB->pMetaDataVec, NULL ) );
    Assert( (pDB->DNT == ROOTTAG) || ReplLookupMetaData( ATT_RDN, pDB->pMetaDataVec, NULL ) );
}

void
dbCacheMetaDataVector(
    IN  DBPOS * pDB
    )
/*++

Routine Description:

    Caches per-property meta data (if any) from the current object into the
    DBPOS.

Arguments:

    pDB

Return Values:

    None.

--*/
{
    DWORD dbErr;

    Assert(VALID_DBPOS(pDB));

    if ( !pDB->fIsMetaDataCached )
    {
        // Get the current meta data vector of the object.
        dbErr = DBGetAttVal(
                    pDB,
                    1,
                    ATT_REPL_PROPERTY_META_DATA,
                    0,
                    0,
                    &pDB->cbMetaDataVecAlloced,
                    (BYTE **) &pDB->pMetaDataVec
                    );

        switch ( dbErr )
        {
        case 0:
            // Meta data found and cached.
            VALIDATE_META_DATA_VECTOR_VERSION(pDB->pMetaDataVec);

            Assert(    pDB->cbMetaDataVecAlloced
                    == (DWORD) MetaDataVecV1Size( pDB->pMetaDataVec )
                  );
#if DBG
            dbVerifyCachedObjectMetadata( pDB );
#endif

            break;

        case DB_ERR_NO_VALUE:
            // No meta data found.  ('Salright.)
            pDB->pMetaDataVec = NULL;
            pDB->cbMetaDataVecAlloced = 0;
            break;

        case DB_ERR_BUFFER_INADEQUATE:
        case DB_ERR_UNKNOWN_ERROR:
        default:
            // This shouldn't happen....
            DPRINT1( 0, "Unexpected error %d reading meta data!\n", dbErr );
            LogUnhandledError( dbErr );
            Assert( !"Unexpected error reading meta data!" );
            DsaExcept( DSA_DB_EXCEPTION, dbErr, 0 );
            break;
        }

        // Meta data successfully cached.
        pDB->fIsMetaDataCached = TRUE;
        pDB->fMetaDataWriteOptimizable = TRUE; // meta data write is optimizable by default
                                               // we need to mark it as not optimizable only
                                               // if we insert or delete a meta data from the
                                               // cache at some point.
    }
}


void
dbTouchLinkMetaData(
    IN DBPOS *pDB,
    IN VALUE_META_DATA * pMetaData
    )

/*++

Routine Description:

    Indicate that value metadata on this object has been updated. We cache
    the first value metadata for each linked attribute touched on this object.
    The knowledge that a linked attribute was touched is used during dbFlush to
    trigger the update of the When_Changed attribute. The list of touched linked
    attributes is also retrieved by the core during a mdoification.

    Note that values are not necessarily touched in increasing usn order. For
    originating writes, they are. But for replicated writes, the values may have
    been sorted by object, and may not be applied in increasing usn order.

    The data structure is an unsorted array.

    The data is referenced from fields in the DBPOS:
    BOOL         fIsLinkMetaDataCached:1;  // Has pLinkMetaData been cached for this
                                        //   object?
    VALUE_META_DATA *rgLinkMetaData;      // Maximal value metadata for this object.
    DWORD       cLinkMetaData;           // Count of link value meta data entries cached
    DWORD       cbLinkMetaDataAlloced;   // Size in bytes of rgLinkMetaData

    The companion routine to this one is DBTouchMetaData. It builds a formal vector
    called the PROPERTY_META_DATA_VECTOR.  The reason we don't is that value metadata is
    not kept in a vector. It is stored individually on each link record. The only reason
    we are keeping a vector of value meta data is to have a list of attributes which
    have changed for bookkeeping purposes.  An array of ATTRTYPs would have worked as well.

Arguments:

    pDB - 
    pMetaData - 

Return Value:

    None

--*/

{
    DWORD i;

    if (!pDB->fIsLinkMetaDataCached) {
        // No link metadata cached
        Assert( pDB->cbLinkMetaDataAlloced == 0 );
        pDB->fIsLinkMetaDataCached = TRUE;
        pDB->cbLinkMetaDataAlloced = 4 * sizeof( VALUE_META_DATA );
        pDB->rgLinkMetaData = THAllocEx( pDB->pTHS, pDB->cbLinkMetaDataAlloced );
        (pDB->rgLinkMetaData)[0] = *pMetaData; // copy contents
        pDB->cLinkMetaData = 1;
        return;
    }

    // See if this attrtyp already cached
    // PERF: bsearch if the number of linked attributes / object gets large
    for( i = 0; i < pDB->cLinkMetaData; i++ ) {
        if (pDB->rgLinkMetaData[i].MetaData.attrType == pMetaData->MetaData.attrType) {
            return;
        }
    }

    // Was not found
    Assert(i == pDB->cLinkMetaData);

    // Grow array if full
    if ( (pDB->cLinkMetaData * sizeof( VALUE_META_DATA )) == pDB->cbLinkMetaDataAlloced ) {
        pDB->cbLinkMetaDataAlloced *= 2;
        pDB->rgLinkMetaData = THReAllocEx( pDB->pTHS, pDB->rgLinkMetaData,
                                           pDB->cbLinkMetaDataAlloced );
    }

    Assert( (pDB->cLinkMetaData * sizeof( VALUE_META_DATA )) < pDB->cbLinkMetaDataAlloced );

    // Add the new entry at the end
    (pDB->rgLinkMetaData)[pDB->cLinkMetaData] = *pMetaData; // copy contents
    pDB->cLinkMetaData++;

} /* dbTouchLinkMetaData */

void
DBTouchMetaData(
    IN  DBPOS *     pDB,
    IN  ATTCACHE *  pAC
    )
/*++

Routine Description:

    Touches cached meta data to signify a change in the given attribute.  The
    metadata properties as a whole are updated later; this routine simply flags
    the meta data for the given attribute as changed.

Arguments:

    pDB
    pAC - Attribute for which to update meta data.

Return Values:

    None.

--*/
{
    THSTATE *pTHS=pDB->pTHS;
    PROPERTY_META_DATA * pMetaData;

    Assert(VALID_DBPOS(pDB));

    if (pAC->bIsNotReplicated) {
        if (ATT_OBJ_DIST_NAME == pAC->id) {
            // A special case; map to ATT_RDN.
            pAC = SCGetAttById(pTHS, ATT_RDN);
            // prefix complains about pAC being NULL, 447335, bogus since we are using constant

            Assert(NULL != pAC);
            Assert(!pAC->bIsNotReplicated);
        }
        else {
            // Not replicated => no meta data => nothing to do.
            return;
        }
    }
    else if ((pAC->ulLinkID) && (TRACKING_VALUE_METADATA( pDB ))) {
        // This routine updates _attribute_ metadata. Linked attributes in
        // the new mode don't have attribute metadata, only value metadata.
        // Linked attributes are not replicated (their values are)
        // Note that we cannot assert that pDB->fIsLinkMetaDataCached. The object
        // operation routines always call DbTouchMetaData, even when no
        // linked values have been added. For example, see DbAttAtt_AC.
        // This is one difference between the old and new modes. In the old mode,
        // an add with no values resulted in atleast attr metadata, and
        // knowledge of any empty attr replicated around. In the new mode, an
        // add with no values leaves no trace, and there is nothing to replicate.
        return;
    }
    else if ((ATT_NT_SECURITY_DESCRIPTOR == pAC->id) && pTHS->fSDP) {
        // Don't update meta data for propagated security descriptor updates.
        return;
    }
    // we can skip updateing of metadata only in single user mode (domain rename).
    else  if (pDB->fSkipMetadataUpdate) {
        Assert (DsaIsSingleUserMode());
        return;
    }


    // Init rec.  If it's already inited, this is a no-op.
    dbInitRec( pDB );

    // Cache pre-existing meta data if we haven't done so already.
    if ( !pDB->fIsMetaDataCached )
    {
        dbCacheMetaDataVector( pDB );
    }

    if (pTHS->fGCLocalCleanup)
        {
 
	//locate the meta data, but don't actually delete it, instead
	//mark the pMetaData->usnProperty attribute as removed, later we'll make the real
	//delete (same form as update below).
	pMetaData = ReplLookupMetaData( pAC->id, pDB->pMetaDataVec, NULL );
	if (pMetaData!=NULL) {
	    //mark this attribute as removed.  We'll do the actual delete to the meta data later.
	    pMetaData->usnProperty = USN_PROPERTY_GCREMOVED;
	    pDB->fMetaDataWriteOptimizable = FALSE; // deleting something, meta data write
                                                // is no longer optimizable	
	}
    }
    else
    {
        BOOL fIsNewElement;

        // Find or add a meta data entry for this attribute.
        pMetaData = ReplInsertMetaData(
                        pTHS,
                        pAC->id,
                        &pDB->pMetaDataVec,
                        &pDB->cbMetaDataVecAlloced,
                        &fIsNewElement
                        );

        Assert( NULL != pMetaData );
        Assert( pAC->id == pMetaData->attrType );

        // Mark this attribute as touched.  We'll make the real update to its meta
        // data later.
        pMetaData->usnProperty = USN_PROPERTY_TOUCHED;

        if (fIsNewElement)
        {
            // new element has been added to meta data vector; meta data write is
            // no longer optimizable
            pDB->fMetaDataWriteOptimizable = FALSE;
        }
    }
}


DWORD
dbCalculateVersionBump(
    IN  DBPOS *pDB,
    DSTIME TimeCurrent
    )

/*++

Routine Description:

This routine calculates the amount to bump the version for an authoritative
write.  We want a value that is larger than any version that could be in
existence in the enterprise.

This code is similar to that used in util\ntdsutil\ar.c:GetVersionIncrease()

The algorithm is as follows:

bump = (age in days + restore count) * bump_factor

Arguments:

    pDB - 

Return Value:

    DWORD - 

--*/

{
    DWORD bump = 1, dbErr, idleDays, idleSeconds, restoreCount;
    DSTIME mostRecentChange;

    // Get the last time this object was changed
    if (dbErr = DBGetSingleValue(pDB,
                         ATT_WHEN_CHANGED,
                         &mostRecentChange,
                         sizeof(DSTIME), NULL)) {
        DsaExcept( DSA_DB_EXCEPTION, dbErr, 0 );
    }

    // How long ago was it, in days
    Assert(TimeCurrent > mostRecentChange);

    idleSeconds = (DWORD)(TimeCurrent - mostRecentChange);

    idleDays = idleSeconds / SECONDS_PER_DAY;
    if ( idleSeconds % SECONDS_PER_DAY > 0 ) {
        idleDays++;
    }

    // Get the number of times this system has been restored
    // This accounts for the number of bumps we have had in the past
    if (gulRestoreCount)
    {
        restoreCount = gulRestoreCount;
    }
    else
    {
        restoreCount = 1;
    }

    // Calculate the bump
    // The version factor represents the worst case maximal activity
    // on an object in a day

    bump = (restoreCount + idleDays) * VERSION_BUMP_FACTOR;

    // Not too big
    if (bump > VERSION_BUMP_LIMIT) {
        bump = VERSION_BUMP_LIMIT;
    }

#if 0
    {
        CHAR displayTime[SZDSTIME_LEN+1];
        DSTimeToDisplayString(mostRecentChange, displayTime);
        DPRINT1( 0, "most recent change at %s\n", displayTime );
        DPRINT3( 0, "idleSeconds = %d; idleDays = %d; restoreCount = %d\n",
                 idleSeconds, idleDays, restoreCount );
        DPRINT1( 0, "bump = %d\n", bump );
    }
#endif

    return bump;
} /* dbCalculateVersionBump */

void
dbFlushMetaDataVector(
    IN  DBPOS *                     pDB,
    IN  USN                         usn,
    IN  PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote OPTIONAL,
    IN  DWORD                       dwMetaDataFlags
    )
/*++

Routine Description:

    Update all touched attributes with the correct per-property meta data,
    merging replicated meta data (if any).  Write the updated meta data
    vector, highest USN changed, and highest changed time to the record.  
    
    Delete all attributes marked as removed.  Write the updated meta data vector
    but do not update the highest USN changed if 
    only deletes have occurred.  Still update the highest changed time on delete.

Arguments:

    pDB
    usn - The local USN to write in the meta data for changed attributes.
    pMetaDataExtVecRemote (OPTIONAL) - Replicated meta data vector to merge with
        the local vector.
    dwMetaDataFlags - bit flags specifying how to process meta data for 
                        Current values:
                        i) META_STANDARD_PROCESSING : 
                            - No special processing
                        ii) (dwMetaDataFlags & META_AUTHORITATIVE_MODIFY):
                            - Make the change authoritative by up'ing the
                              version to a much higher value than what 
                              could possibly exist in the enterprise

Return Values:

    None.

--*/
{
    THSTATE *               pTHS = pDB->pTHS;
    DWORD                   cNumPropsLocal;
    DWORD                   cNumPropsRemote;
    PROPERTY_META_DATA *    pMetaDataLocal;
    PROPERTY_META_DATA *    pMetaDataRemote;
    PROPERTY_META_DATA *    pNextMetaDataRemote;
    DSTIME                  timeCurrent;
    BOOL                    fReplicatedAttrChanged = FALSE;
    BOOL                    fReplicatedAttrDeleted = FALSE;
    BOOL                    fAuthoritative = (dwMetaDataFlags & META_AUTHORITATIVE_MODIFY);
    BOOL                    fWriteOptimizable = pDB->fMetaDataWriteOptimizable;
    PBYTE                   pbStart = NULL;
    DWORD                   cNumConsecutiveElemsChanged = 0;

    Assert(VALID_DBPOS(pDB));
    Assert(DsaIsInstalling() || !fNullUuid(&pTHS->InvocationID));

    // Only the replicator should pass remote meta data vectors to be merged.
    Assert( pTHS->fDRA || ( NULL == pMetaDataVecRemote ) );

    // Only HandleRestore() can currently issue an authoritative modify
    Assert( !fAuthoritative || gfRestoring);

    timeCurrent = DBTime();

    // If we haven't yet cached the meta data for this object, then no
    // replicated attributes have been touched and our work is done.
    if (!pDB->fIsMetaDataCached) {

        // Special mode to update WHEN_CHANGED when object changes in a way
        // other than through its attribute metadata
        if (pDB->fIsLinkMetaDataCached) {
            // Update the object-level When-Changed attribute.
            // It is intentional to use the current local time.
            DBResetAtt(pDB,
                       ATT_WHEN_CHANGED,
                       sizeof( DSTIME ),
                       &timeCurrent,
                       SYNTAX_TIME_TYPE
                );

            // This hack is for backward compatibility with those applications which search
            // for changes by USN. Even though only the linked values have changed, we
            // bump the object USN CHANGED so that external searches will find the object.
            // We introduce a minor inefficiency that outbound replication will now find
            // an object change on this object, but when searching the attribute level
            // metadata will not find anything to ship.
            DBResetAtt(pDB,
                       ATT_USN_CHANGED,
                       sizeof( usn ),
                       &usn,
                       SYNTAX_I8_TYPE
                );
        }

        return;
    }

    // Cue up the first remote meta data entry (if any).
    if ( NULL == pMetaDataVecRemote )
    {
        pNextMetaDataRemote = NULL;
        cNumPropsRemote = 0;
    }
    else
    {
        VALIDATE_META_DATA_VECTOR_VERSION(pMetaDataVecRemote);

        pNextMetaDataRemote = &pMetaDataVecRemote->V1.rgMetaData[ 0 ];
        cNumPropsRemote = pMetaDataVecRemote->V1.cNumProps;
    }

    // For each entry in the local meta data vector...
    for ( cNumPropsLocal = pDB->pMetaDataVec->V1.cNumProps,
            pMetaDataLocal = &pDB->pMetaDataVec->V1.rgMetaData[ 0 ];
          cNumPropsLocal > 0;
          cNumPropsLocal--, pMetaDataLocal++
        )
    {
        // Skip over irrelevant remote meta data.
        while (    ( NULL != pNextMetaDataRemote )
                && ( pNextMetaDataRemote->attrType < pMetaDataLocal->attrType )
              )
        {
            if ( --cNumPropsRemote )
                pNextMetaDataRemote++;
            else
                pNextMetaDataRemote = NULL;
        }

        // Get corresponding remote meta data (if any).
        if (    ( NULL != pNextMetaDataRemote )
             && ( pNextMetaDataRemote->attrType == pMetaDataLocal->attrType )
           )
        {
            pMetaDataRemote = pNextMetaDataRemote;
        }
        else
        {
            pMetaDataRemote = NULL;
        }

        if ( USN_PROPERTY_TOUCHED == pMetaDataLocal->usnProperty )
        {
            fReplicatedAttrChanged = TRUE;

            if (fWriteOptimizable)
            {
                // A property has been modifed inplace and changes in meta data vector
                // have been contiguous so far- potential candidate for optimization
                if (!pbStart)
                {
                    // this is the first element changed in meta data vector
                    // keep track of it
                    pbStart = (PBYTE) pMetaDataLocal;
                    cNumConsecutiveElemsChanged = 1;
                }
                else
                {
                    // this is not the first element changed, but see if it is consecutive
                    // with the block of elements that have been changed so far
                    PBYTE pbCurrent = (PBYTE) pMetaDataLocal;
                    if ((pbCurrent - pbStart) == (int) (cNumConsecutiveElemsChanged * sizeof(PROPERTY_META_DATA)))
                    {
                        // this change is also contiguous
                        cNumConsecutiveElemsChanged++;
                    }
                    else
                    {
                        // this changed element is not contiguous with 
                        // previously changed elements - we can't optimize 
                        // the meta data write for this kind of change
                        fWriteOptimizable = FALSE;
                    }
                }
            }

            // Attribute has been touched; update the meta data appropriately.
            if ( NULL == pMetaDataRemote )
            {
                // An originating write.
                pMetaDataLocal->usnProperty        = usn;
                if (fAuthoritative)
                {
                    pMetaDataLocal->dwVersion +=
                        dbCalculateVersionBump( pDB, timeCurrent );
                }
                else
                {
                    // non-authoritative - just increment the version by 1
                    pMetaDataLocal->dwVersion++;
                }
                pMetaDataLocal->timeChanged        = timeCurrent;
                pMetaDataLocal->uuidDsaOriginating = pTHS->InvocationID;
                pMetaDataLocal->usnOriginating     = usn;
            }
	    else if (USN_PROPERTY_GCREMOVED == pMetaDataRemote->usnProperty) {
		DRA_EXCEPT(DRAERR_InternalError, pMetaDataRemote->attrType);  
	    }
            else if (USN_PROPERTY_TOUCHED != pMetaDataRemote->usnProperty)
            {
                // A replicated write.
                Assert(!fAuthoritative);

                pMetaDataLocal->usnProperty        = usn;
                pMetaDataLocal->dwVersion          = pMetaDataRemote->dwVersion;
                pMetaDataLocal->timeChanged        = pMetaDataRemote->timeChanged;
                pMetaDataLocal->uuidDsaOriginating = pMetaDataRemote->uuidDsaOriginating;
                pMetaDataLocal->usnOriginating     = pMetaDataRemote->usnOriginating;
            }
            else
            {
                // Replication has decided to over- or underride a value.  (See
                // ReplOverrideMetaData() and ReplUnderrideMetaData().)
                //
                // 1. In both cases, we want to flag the change as having
                //    originated locally.
                // 2. In the override case, we want to make sure the change wins
                //    over all the values we've seen thus far -- the max thus
                //    far is pMetaDataRemote->dwVersion, and we're going to bump
                //    that by one to make our version "better."
                // 3. In the underride case, we want to make sure the change
                //    *loses* over other inbound values locally, and does not
                //    clobber any pre-existing values on remote machines.
                //    In this case pMetaDataRemote->dwVersion is ULONG_MAX, so
                //    when we bump it we will be setting the local dwVersion
                //    field to 0 -- a guaranteed loser.
                Assert(!fAuthoritative);

                pMetaDataLocal->usnProperty        = usn;
                pMetaDataLocal->dwVersion          = pMetaDataRemote->dwVersion + 1;
                pMetaDataLocal->timeChanged        = timeCurrent;
                pMetaDataLocal->uuidDsaOriginating = pTHS->InvocationID;
                pMetaDataLocal->usnOriginating     = usn;
            }
        }
        else if ( USN_PROPERTY_GCREMOVED == pMetaDataLocal->usnProperty ) { 
	    fReplicatedAttrDeleted = TRUE;
	    // Attribute has been deleted.  To delete an attributed, our schema
	    // must have validated this.  therefore any remote meta data for this
	    // attribute is irrelevant.
	    if (pMetaDataRemote) {
		if ( 
		    (USN_PROPERTY_TOUCHED == pMetaDataRemote->usnProperty) 
		    ||
		    (USN_PROPERTY_GCREMOVED == pMetaDataRemote->usnProperty) 
		    ) {
                    DRA_EXCEPT(DRAERR_InternalError, pMetaDataRemote->attrType);
		}
	    }
	
	     // shift left all entries to the right of the index we are deleting 
	    MoveMemory(pMetaDataLocal,
		       pMetaDataLocal+1,
		       sizeof(PROPERTY_META_DATA) * (cNumPropsLocal - 1));
      
	    pDB->pMetaDataVec->V1.cNumProps--;
	    //adjust value for pMetaDataLocal since we deleted the meta data it was pointing at.
	    pMetaDataLocal--; 
	    //we don't want to do any more calculations for this metadata pointer since it is 1 "behind"
	    //where it should be since the meta data was deleted, so continue...
	    continue;
	}
	else
        {
            // Attribute has not been touched or removed

            // Attributes not touched should have a lower local USN.
            Assert( pMetaDataLocal->usnProperty < usn );

            // Check for cases where ReplInsertMetaData was called but metadata was
            // not flagged as touched or removed.

            // Metadata attributes should be initialized
            // Unlike the checks in ReplInsertMetaData, these checks are for
            // metadata that has already been written to the database atleast once,
            // and should be completely filled in at this point.

            // dwVersion may be zero in the underridden case
            // Assert( pMetaDataLocal->dwVersion ); // fails for underriden metadata
            Assert( pMetaDataLocal->timeChanged );
            // Install time objects may be created before ginvocationid set
            Assert( DsaIsInstalling() || !fNullUuid( &(pMetaDataLocal->uuidDsaOriginating) ) );
            Assert( pMetaDataLocal->usnOriginating );
            Assert( pMetaDataLocal->usnProperty > 0 );
        }
    }

    // If no replicated attributes were touched, then we shouldn't have had
    // cached meta data, in which case we would have bailed out above. Only exception 
    // to this is GCCleanup where we would have removed the metadata for properties that 
    // are cleaned up from the object.       
    Assert(fReplicatedAttrChanged || fReplicatedAttrDeleted || pTHS->fGCLocalCleanup);

    // Update attributes only if a replicable change was made.
    if (fReplicatedAttrChanged || fReplicatedAttrDeleted) {
        // Update the Repl-Property-Meta-Data attribute.

#if DBG
        dbVerifyCachedObjectMetadata( pDB );
#endif

        if (fWriteOptimizable && pbStart)
        {
            Assert(pDB->fMetaDataWriteOptimizable);
            // contiguous block of data has been changed in-place in the meta
            // data vector we can really optimize this Jet write
            DBResetAttLVOptimized(pDB,
                                  ATT_REPL_PROPERTY_META_DATA,
                                  (DWORD)(pbStart - (PBYTE) pDB->pMetaDataVec),  // offset from the beginning
                                  cNumConsecutiveElemsChanged * sizeof(PROPERTY_META_DATA), //segment len
                                  pbStart,
                                  SYNTAX_OCTET_STRING_TYPE
                                  );
        }
        else
        {
            // changes are not in-place and/or contiguous; so we can't
            // explicitly optimize this write by writing only a portion of meta
            // data vector; 
            // But DBResetAtt() will still try to optimize it by setting the
            // appropriate grbits.
            DBResetAtt(pDB,
                       ATT_REPL_PROPERTY_META_DATA,
                       MetaDataVecV1Size( pDB->pMetaDataVec ),
                       pDB->pMetaDataVec,
                       SYNTAX_OCTET_STRING_TYPE
                       );
        }
	// Update the object-level When-Changed attribute.
        // It is intentional to use the current local time.
        DBResetAtt(pDB,
                   ATT_WHEN_CHANGED,
                   sizeof( timeCurrent ),
                   &timeCurrent,
                   SYNTAX_TIME_TYPE
            );
    }

    if (fReplicatedAttrChanged) {
	// only update the USN-Changed if something changed!
	// do not update if an attribute was deleted!

	// Update the USN-Changed value.
        DBResetAtt(pDB,
                   ATT_USN_CHANGED,
                   sizeof( usn ),
                   &usn,
                   SYNTAX_I8_TYPE
                   );
    }
}

BOOL
dbIsModifiedInMetaData (
        DBPOS *pDB,
        ATTRTYP att)
/*
 * Checks to see if the supplied ATT is marked as having been changed in the
 * but not yet committed by looking in the metadata 
 *
 * INPUT:
 *    pDB - DBPOS to use
 *    att - attribute to look to see if it has changed.
 *
 * RETURN VALUE:
 *    TRUE if we can find that the attribute has been changed and not committed,
 *    FALSE otherwise.
 */
{
    ULONG i, cProps;
    PROPERTY_META_DATA * pMetaData;

    Assert(VALID_DBPOS(pDB));

    if (   !pDB->fIsMetaDataCached
        || !pDB->pMetaDataVec
        || !pDB->pMetaDataVec->V1.cNumProps)  {
        // If meta data is not cached on the DBPOS that means either
        // no attribute has been touched, or we have already
        // flushed the cached meta data vector to the db
        // If meta data vector for the current object is empty that
        // means the object has no replicated property.
        return FALSE;
    }
    
    pMetaData = ReplLookupMetaData(att, pDB->pMetaDataVec, NULL);
     
    return ((NULL != pMetaData)
            && ((USN_PROPERTY_TOUCHED == pMetaData->usnProperty) || (USN_PROPERTY_GCREMOVED == pMetaData->usnProperty)));
}

ULONG
DBMetaDataModifiedList(
	DBPOS *pDB,
	ULONG *pCount,
	ATTRTYP **ppAttList)
/*
 * Returns an un-ordered list of all the attributes modified via this DBPOS 
 * until now and not yet committed.
 * 
 *
 * INPUT:
 *    pDB - DBPOS to use
 * OUTPUT:
 *    pCount - filled in with the number of modified attributes (i.e., the size of the AttList)
 *    ppAttList - filled in with a freshly THAlloced list of attrtyps.
 * RETURN VALUE:
 *    0 - success
 *   non-0 - a DB_ERR error code
 */
{
    ULONG i, cProps, cAttrs = 0;

    Assert(VALID_DBPOS(pDB));
    Assert(pCount);
    Assert(ppAttList);

    *pCount = 0;
    *ppAttList = NULL;

    // pDB->pMetaDataVec may be null

    if (pDB->fIsMetaDataCached && pDB->pMetaDataVec) {
        cAttrs += pDB->pMetaDataVec->V1.cNumProps;
    }
    if (pDB->fIsLinkMetaDataCached) {
        cAttrs += pDB->cLinkMetaData;
    }
    if (!cAttrs) {
        // If meta data is not cached on the DBPOS that means either
        // no attribute has been touched, or we have already
        // flushed the cached meta data vector to the db
        // If meta data vector for the current object is empty that
        // means the object has no replicated property.
        return DB_success;
    }

    // Allocate mem for maximum possible output
    *ppAttList = THAlloc( cAttrs * sizeof(ATTRTYP));
    if (!*ppAttList)
    {
        // couldn't locate an appropriate DB_ERR_ for out of memory
        return DB_ERR_SYSERROR;
    }

    // Add in attribute property metadata, if any
    if (pDB->fIsMetaDataCached && pDB->pMetaDataVec) {
        for (i = 0, cProps = pDB->pMetaDataVec->V1.cNumProps; i < cProps; i++)
        {
            if ((USN_PROPERTY_TOUCHED == pDB->pMetaDataVec->V1.rgMetaData[i].usnProperty) || (USN_PROPERTY_GCREMOVED == pDB->pMetaDataVec->V1.rgMetaData[i].usnProperty))
            {
                (*ppAttList)[(*pCount)++] = pDB->pMetaDataVec->V1.rgMetaData[i].attrType;
            }
        }
    }

    // Add in value metadata, if any
    if (pDB->fIsLinkMetaDataCached) {
        DWORD i;
        // I claim that it is not possible to get duplicates in this list because an
        // attribute cannot be modified both as an attribute and as a value in the
        // same transaction. This is certainly true for an originating update. While it
        // is true that replication can replicate in both attribute level and value
        // level changes to the same attribute during an LVR mode change, they are
        // applied in separate transactions.
        // Even if that weren't true, duplicates returned here are not fatal since
        // the results of this routine are only used for validity checks.
        for( i = 0; i < pDB->cLinkMetaData; i++ ) {
#if DBG
            // Make sure no duplicates
            DWORD j;
            for( j = 0; j < (*pCount); j++ ) {
                Assert((*ppAttList)[j] != (pDB->rgLinkMetaData[i].MetaData.attrType));
            }
#endif
            (*ppAttList)[(*pCount)++] = (pDB->rgLinkMetaData[i].MetaData.attrType);
        }
    }

    if (!(*pCount))
    {
        // no properties touched
        THFree(*ppAttList);
        *ppAttList = NULL;
    }
        
    return DB_success;       
}

void
dbFreeMetaDataVector(
    IN  DBPOS * pDB
    )
/*++

Routine Description:

    Free cached meta data (if any).

Arguments:

    pDB

Return Values:

    None.

--*/
{
    Assert(VALID_DBPOS(pDB));

    if ( NULL != pDB->pMetaDataVec )
    {
        Assert( pDB->fIsMetaDataCached );
        Assert( 0 != pDB->cbMetaDataVecAlloced );

        THFree( pDB->pMetaDataVec );

        pDB->pMetaDataVec = NULL;
        pDB->cbMetaDataVecAlloced = 0;
    }

    pDB->fIsMetaDataCached = FALSE;
}


void
DBGetLinkValueMetaData(
    IN  DBPOS *pDB,
    ATTCACHE *pAC,
    OUT VALUE_META_DATA *pMetaDataLocal
    )

/*++

Routine Description:

Get the metadata for an existing row.

The caller is expected to know whether the desired value has been created
already or not. This routine should only be called when the value has been
created and the metadata for the value is wanted. There may be some question
as to whether this is a legacy value or not.  This routine assumes that if the
metadata is not present, then this is a legacy value.

The internal form of the metadata is derived from
a. The external form of the metadata
b. The link base
c. The usn changed column

Arguments:

    pDB - dbpos, link cursor positioned on value.
    pAC - Attcache of value
    pMetaDataLocal - Local metadata read off object, or special metadata
                     returned from a legacy value

Return Value:

    None

--*/

{
    DWORD err, linkDnt = INVALIDDNT;
    VALUE_META_DATA_EXT metaDataExt;
    JET_RETRIEVECOLUMN attList[2];
    CHAR szIndexName[JET_cbNameMost];
    CHAR szTime1[SZDSTIME_LEN];
    CHAR szTime2[SZDSTIME_LEN];
    CHAR szUuid[ SZUUID_LEN ];

    Assert(VALID_DBPOS(pDB));
    Assert( pMetaDataLocal );

    // We don't support getting/setting metadata on backlinks because this
    // code assumes we are positioned (have DBPOS currency) on the object
    // which is the source object of the link.
    Assert( pAC->ulLinkID );
    Assert( !FIsBacklink(pAC->ulLinkID) );

    DPRINT1( 2, "DBGetLinkValueMeta, obj = %s\n", GetExtDN(pDB->pTHS, pDB) );

    pMetaDataLocal->MetaData.attrType = pAC->id;

    dbGetLinkTableData (pDB,
                        FALSE,           // fIsBacklink
                        FALSE,           // Warnings
                        &linkDnt,
                        NULL, //&ulValueDnt,
                        NULL // &ulNewLinkBase
        );

    Assert( linkDnt == pDB->DNT );
    if (linkDnt != pDB->DNT) {
        // Not positioned on valid link
        DsaExcept(DSA_DB_EXCEPTION, DB_ERR_ONLY_ON_LINKED_ATTRIBUTE, 0);
    }

    JetGetCurrentIndexEx( pDB->JetSessID, pDB->JetLinkTbl,
                          szIndexName, sizeof( szIndexName ) );

    memset(attList,0,sizeof(attList));
    // May not exist
    attList[0].columnid = linkusnchangedid;
    attList[0].pvData = &( pMetaDataLocal->MetaData.usnProperty );
    attList[0].cbData = sizeof( USN );
    attList[0].grbit = pDB->JetRetrieveBits;
    if ( (!strcmp( szIndexName, SZLINKDRAUSNINDEX )) ||
          (!strcmp( szIndexName, SZLINKATTRUSNINDEX )) ) {
        attList[0].grbit |= JET_bitRetrieveFromIndex;
    }
    attList[0].itagSequence = 1;

    // May not exist
    attList[1].columnid = linkmetadataid;
    attList[1].pvData = &metaDataExt;
    attList[1].cbData = sizeof( metaDataExt );
    attList[1].grbit = pDB->JetRetrieveBits;
    attList[1].itagSequence = 1;

    err = JetRetrieveColumnsWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                    attList, 2 );

    // Verify positioning

    // Detect a legacy row. It has a linkDnt column but none of the newer
    // columsn such as linkusnchangedid.
    if (attList[0].err) {
        DWORD dbErr;
        DSTIME timeCreated;

        // Metadata not present
        Assert( attList[1].err != JET_errSuccess );

        // The most important field we need to derive is the creation time.
        // Since legacy values always lose to LVR values, we should construct
        // *underridden* legacy metadata that will always lose.

        memset( pMetaDataLocal, 0, sizeof( VALUE_META_DATA ) );

        // Use the object's creation time
        dbErr = DBGetSingleValue( pDB, ATT_WHEN_CREATED,
                                  &timeCreated, sizeof(timeCreated),
                                  NULL );
        if (dbErr) {
            DsaExcept( DSA_DB_EXCEPTION, dbErr, 0 );
        }
        pMetaDataLocal->timeCreated = timeCreated;

#if DBG
        {
            CHAR szTime[SZDSTIME_LEN];
            DPRINT1( 5, "[%s,legacy]\n", DSTimeToDisplayString(timeCreated, szTime) );
        }
#endif
        return;
    }

    // Construct LVR metadata from the two fields we read above

    Assert( attList[1].err == JET_errSuccess );

    pMetaDataLocal->timeCreated = metaDataExt.timeCreated;
    pMetaDataLocal->MetaData.dwVersion = metaDataExt.MetaData.dwVersion;
    pMetaDataLocal->MetaData.timeChanged = metaDataExt.MetaData.timeChanged;
    pMetaDataLocal->MetaData.uuidDsaOriginating = metaDataExt.MetaData.uuidDsaOriginating;
    pMetaDataLocal->MetaData.usnOriginating = metaDataExt.MetaData.usnOriginating;
    // usnProperty is updated above

    DBLogLinkValueMetaData( pDB,
                            DIRLOG_LVR_GET_META_OP,
                            &( pMetaDataLocal->MetaData.usnProperty ),
                            &metaDataExt );

} /* DBGetLinkValueMetaData */


void
DBLogLinkValueMetaData(
    IN DBPOS *pDB,
    IN DWORD dwEventCode,
    IN USN *pUsn,
    IN VALUE_META_DATA_EXT *pMetaDataExt
    )

/*++

Routine Description:

Routine to dump metadata to the event log and/or kernel debugger. 

Since we read more data than usual, we only want the expense of collecting all
this info when requested.

Arguments:

    pDB - 
    dwEventCode - 
    pMetaDataExt - 

Return Value:

    None

--*/

{
    ULONG linkDnt = INVALIDDNT, linkBase = 0, backlinkDnt = INVALIDDNT, count;
    DWORD len, err;
    DSNAME *pValueDn = NULL;
    CHAR szTime[SZDSTIME_LEN];
    CHAR szTime1[SZDSTIME_LEN];
    CHAR szTime2[SZDSTIME_LEN];
    CHAR szUuid[ SZUUID_LEN ];
    CHAR  buf[150];
    LPSTR pszObjectDn;
    DSTIME timeDeletion = 0;
    BOOL fPresent;
    ATTCACHE *pAC;
    ULONG ulLinkID;

    Assert( pUsn );
    Assert( pMetaDataExt );

    // Short curcuit this routine if no logging desired

    // On free builds, only do if logging level elevated
    // On debug builds, also check if DPRINT level elevated
    if ( (!LogEventWouldLog( DS_EVENT_CAT_LVR, DS_EVENT_SEV_VERBOSE ))
#if DBG
         && (!DebugTest(2,DEBSUB))
#endif
         ) {
        return;
    }

    // Verify that we are positioned on the link's containing object
    // This also assumes that on an create, the linkdnt column has
    // been populated by now.

    dbGetLinkTableData (pDB,
                        FALSE,           // fIsBacklink
                        FALSE,           // Warnings
                        &linkDnt,
                        &backlinkDnt,
                        &linkBase);
    Assert( linkDnt == pDB->DNT );

    // Get deletion time
    err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                    linkdeltimeid,
                                    &timeDeletion, sizeof(timeDeletion), &len,
                                    JET_bitRetrieveCopy, NULL);
    fPresent = (err != JET_errSuccess);

    // Get ATTCACHE from linkbase
    ulLinkID = MakeLinkId( linkBase );
    // We don't support getting/setting metadata on backlinks because this
    // code assumes we are positioned (have DBPOS currency) on the object
    // which is the source object of the link.
    Assert( !FIsBacklink(ulLinkID) );
    pAC = SCGetAttByLinkId( pDB->pTHS, ulLinkID );
    Assert( pAC );

    // Get name of containing object
    pszObjectDn = GetExtDN( pDB->pTHS, pDB );

    // Translate the backlink dnt if possible
    // pValueDn is null if this doesn't work
    if (err = gDBSyntax[SYNTAX_DISTNAME_TYPE].IntExt(
        pDB,
        DBSYN_INQ,
        sizeof( ULONG ),
        (CHAR *) &backlinkDnt,
        &len,
        (CHAR **) &pValueDn,
        0,
        0,
        0 /*SyntaxFlags*/ )) {
        DPRINT2( 0, "IntExt of %d got error %d\n", backlinkDnt, err );
    }

    // Note, pValueDn is allocated in some temporary space. You will need to
    // copy the value out if you do any subsequent dblayer operations.

    //
    // Display the information
    //


    DPRINT6( 2, "DBLogLinkValueMeta, ncdnt = %d, obj = %s(%d), attr = %s, value = %ls(%d)\n",
             pDB->NCDNT,
             pszObjectDn, linkDnt,
             pAC->name,
             pValueDn ? pValueDn->StringName : L"(not available)", backlinkDnt );

    if (!fPresent) {
        DSTimeToDisplayString(timeDeletion, szTime);
        DPRINT1( 4, "\tdeltime = %s\n", szTime );
    }

    // Log the kind of operation that was performed
    LogEvent8( DS_EVENT_CAT_LVR,
               DS_EVENT_SEV_VERBOSE,
               dwEventCode,
               szInsertSz( pszObjectDn ),
               szInsertSz(pAC->name),
               pValueDn ? szInsertDN( pValueDn ) : szInsertSz("Not available"),
               fPresent ? szInsertSz("Not deleted") : szInsertSz( szTime ),
               NULL, NULL, NULL, NULL
        );

    DSTimeToDisplayString(pMetaDataExt->timeCreated, szTime1);
    DSTimeToDisplayString(pMetaDataExt->MetaData.timeChanged, szTime2);

    DPRINT6( 5, "[%s,%d,%s,%I64d,%s,%I64d]\n",
             szTime1,
             pMetaDataExt->MetaData.dwVersion,
             DsUuidToStructuredString(&pMetaDataExt->MetaData.uuidDsaOriginating, szUuid),
             pMetaDataExt->MetaData.usnOriginating,
             szTime2,
             *pUsn  );

    // Log the metadata
    LogEvent8( DS_EVENT_CAT_LVR,
               DS_EVENT_SEV_VERBOSE,
               DIRLOG_LVR_META_INFO,
               szInsertSz(szTime1),
               szInsertUL(pMetaDataExt->MetaData.dwVersion),
               szInsertUUID(&pMetaDataExt->MetaData.uuidDsaOriginating),
               szInsertUSN(pMetaDataExt->MetaData.usnOriginating),
               szInsertSz(szTime2),
               szInsertUSN(*pUsn),
               NULL, NULL
        );

} /* logLinkValueMetaData */


void
dbSetLinkValueMetaData(
    IN  DBPOS *pDB,
    IN  DWORD dwEventCode,
    IN  ATTCACHE *pAC,
    IN  VALUE_META_DATA *pMetaDataLocal OPTIONAL,
    IN  VALUE_META_DATA *pMetaDataRemote OPTIONAL,
    IN  DSTIME *ptimeCurrent OPTIONAL
    )

/*++

Routine Description:

Set the metadata properties on the value record.
We assume we are in a Jet Prepare Update.
There are three cases for the local metadata:
1. Fully populated because the row exists with LVR data
2. Partially populated because the row exists with legacy data
3. No local metadata cause new row being written.

   fGCLocalCleanup?
   Authoritative Modify?

The following is from section "Originating Writes" of the LVR spec:
On an originating write of a link-table row (identified by its <source DNT,
destination DNT, link-id>) the creation timestamp is assigned as follows:

Legacy row already exists on this replica. (This would happen e.g. if you are
removing a value that is included in the legacy part of a multivalue. Or if
you are changing the value of "stuff" in an instance of one of the "DN plus
stuff" syntaxes.) Convert the legacy row to LVR. Set the row's creation timestamp
by reading the creation time of the row's containing object (source DNT.)

LVR row already exists on this replica. (This would happen e.g. if you are adding
a value that was deleted less than a tombstone lifetime ago, so the value exists
as an absent value on this replica. Or if you are changing the value of "stuff"
in an instance of one of the "DN plus stuff" syntaxes.) Do not change
the creation timestamp.

Row does not exist on this replica. (This would happen e.g. if you are adding
a row that never existed, or that existed earlier but then was deleted and
finally garbage-collected.) Create a new LVR row. Set the creation timestamp of
the new row by reading the system clock.

The other metadata components in an LVR row are assigned on originating
update just as they are today for attribute updates: The version number
starts at 1 for a new row, increments the current value for an existing row.
The update timestamp comes from reading the system clock during the
originating update. The dc-guid is the invocation ID of the DC performing
the originating update.

Arguments:

    pDB - dbpos, in prepared update
    pMetaDataLocal - Metadata to be written
    pMetaDataRemote - remote metadata, if any, to be merged
    ptimeCurrent - Time to use if the caller desires to specify
                   Only used if pMetaDataRemote == NULL

Return Value:

    None

--*/

{
    THSTATE *pTHS = pDB->pTHS;
    USN usn;
    DSTIME timeCurrent;
    BOOL fWriteAllColumns;
    VALUE_META_DATA_EXT metaDataExt;
    VALUE_META_DATA_EXT *pMetaDataExt = &( metaDataExt );
    VALUE_META_DATA metaDataTouched;
    JET_SETCOLUMN attList[3];
    DWORD cAtts;

    Assert(VALID_DBPOS(pDB));
    // We don't support getting/setting metadata on backlinks because this
    // code assumes we are positioned (have DBPOS currency) on the object
    // which is the source object of the link.
    Assert( pAC->ulLinkID );
    Assert( !FIsBacklink(pAC->ulLinkID) );

    // We better be in LVR mode
    if (!pTHS->fLinkedValueReplication) {
        Assert( !"Can't apply value metadata when not in proper mode!" );
        DsaExcept(DSA_DB_EXCEPTION, ERROR_DS_INTERNAL_FAILURE, 0);
    }

    fWriteAllColumns = ( (pMetaDataLocal == NULL) ||
                          IsLegacyValueMetaData( pMetaDataLocal ) );

    usn = DBGetNewUsn();

    if (NULL == ptimeCurrent) {
        timeCurrent = DBTime();
        ptimeCurrent = &timeCurrent;
    }

    if (NULL == pMetaDataRemote) {

        //
        // An originating write
        //

        if (NULL == pMetaDataLocal) {

            // A new value
            pMetaDataExt->timeCreated = *ptimeCurrent;
            pMetaDataExt->MetaData.dwVersion = 1;

        } else {

            // An existing value
            // Legacy values should appear here, with metadata derived from the
            // containing object
            pMetaDataExt->timeCreated = pMetaDataLocal->timeCreated;
            pMetaDataExt->MetaData.dwVersion =
                pMetaDataLocal->MetaData.dwVersion + 1;
        }

        pMetaDataExt->MetaData.timeChanged = *ptimeCurrent;
        pMetaDataExt->MetaData.uuidDsaOriginating = pTHS->InvocationID;
        pMetaDataExt->MetaData.usnOriginating = usn;

    } else if (pMetaDataRemote->MetaData.usnProperty == USN_PROPERTY_TOUCHED) {

        //
        // An override of a replicated write
        //

        pMetaDataExt->timeCreated          = pMetaDataRemote->timeCreated;
        pMetaDataExt->MetaData.dwVersion   = pMetaDataRemote->MetaData.dwVersion + 1;
        pMetaDataExt->MetaData.timeChanged = *ptimeCurrent;
        pMetaDataExt->MetaData.uuidDsaOriginating = pTHS->InvocationID;
        pMetaDataExt->MetaData.usnOriginating = usn;

    } else {

        //
        // A replicated write.
        //

        pMetaDataExt->timeCreated          = pMetaDataRemote->timeCreated;
        pMetaDataExt->MetaData.dwVersion   = pMetaDataRemote->MetaData.dwVersion;
        pMetaDataExt->MetaData.timeChanged = pMetaDataRemote->MetaData.timeChanged;
        pMetaDataExt->MetaData.uuidDsaOriginating =
            pMetaDataRemote->MetaData.uuidDsaOriginating;
        pMetaDataExt->MetaData.usnOriginating = pMetaDataRemote->MetaData.usnOriginating;
    }

    memset( attList, 0, sizeof( attList ) );

    cAtts = 2;
    // Set LINKUSNCHANGED
    attList[0].columnid = linkusnchangedid;
    attList[0].pvData = &usn;
    attList[0].cbData = sizeof( usn );
    attList[0].itagSequence = 1;
    // Set LINKMETADATA
    attList[1].columnid = linkmetadataid;
    attList[1].pvData = &metaDataExt;
    attList[1].cbData = sizeof( metaDataExt );
    attList[1].itagSequence = 1;
    // Set LINKNCDNT
    if (fWriteAllColumns) {
        attList[2].columnid = linkncdntid;
        attList[2].pvData = &(pDB->NCDNT);
        attList[2].cbData = sizeof( ULONG );
        attList[2].itagSequence = 1;
        cAtts++;
    }

    JetSetColumnsEx(pDB->JetSessID, pDB->JetLinkTbl, attList, cAtts );

    DBLogLinkValueMetaData( pDB, dwEventCode, &usn, pMetaDataExt );

    // This cached metadata is a summary.

    memset( &metaDataTouched, 0, sizeof( metaDataTouched ) );
    metaDataTouched.MetaData.attrType = pAC->id;
    metaDataTouched.MetaData.timeChanged = pMetaDataExt->MetaData.timeChanged;
    metaDataTouched.MetaData.usnProperty = usn;

    dbTouchLinkMetaData( pDB, &metaDataTouched );

} /* dbSetValueMetaData */


BOOL
dbHasAttributeMetaData(
    IN  DBPOS *     pDB,
    IN  ATTCACHE *  pAC
    )
/*++

Routine Description:

    Detect whether attribute-granular meta data exists for a given attribute on
    the current object.  This routine specifically does *not* check for the
    presence of value-granular meta data.

Arguments:

    pDB (IN) - positioned on object for which meta data is being queried
    
    pAC (IN) - attribute for which meta data is to be checked
    
Return Values:

    TRUE if there exists attribute-granular meta data for this attribute,
    FALSE if not.
    
    Throws exception on catastrophic failure (e.g., failure to allocate memory).

--*/
{
    PROPERTY_META_DATA * pMetaData;
    
    // Caller should have already performed a dbInitRec().  This ensures that
    // if we are the first to cache the meta data for this object, we can rest
    // assured that the caller will eventually call either DBUpdateRec() or
    // DBCancelRec() to flush the meta data vector from the DBPOS.
    Assert(pDB->JetRetrieveBits == JET_bitRetrieveCopy);

    if (pAC->bIsNotReplicated) {
        // No meta data for non-replicated attributes.
        pMetaData = NULL;
    } else {
        // Cache pre-existing meta data if we haven't done so already.
        if (!pDB->fIsMetaDataCached) {
            dbCacheMetaDataVector(pDB);
        }
    
        // Determine if this object has attribute-level meta data for the given
        // attribute.
        pMetaData = ReplLookupMetaData(pAC->id, pDB->pMetaDataVec, NULL);
    }

    return (NULL != pMetaData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbsearch.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       dbsearch.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <mdlocal.h>
#include <dsatools.h>                   // For pTHS
#include <limits.h>


// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>
#include "ntdsctr.h"

// Assorted DSA headers
#include <anchor.h>
#include <mappings.h>
#include <dsevent.h>
#include <filtypes.h>                   // Def of FI_CHOICE_???
#include "objids.h"                     // Hard-coded Att-ids and Class-ids
#include "dsconfig.h"
#include "debug.h"                      // standard debugging header
#define DEBSUB "DBSEARCH:"              // define the subsystem for debugging

// LDAP errors
#include <winldap.h>

// DBLayer includes
#include "dbintrnl.h"
#include "lht.h"

#include <fileno.h>
#define  FILENO FILENO_DBSEARCH

#if (DB_CB_MAX_KEY != JET_cbKeyMost)
#error DB_CB_MAX_KEY not equal to JET_cbKeyMost
#endif

#define MAX_UPPER_KEY  "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"


#define VLV_TIMEOUT ((DWORD)(10 * 1000))


/* Internal functions */
DWORD
dbCreateASQTable (
        IN DBPOS *pDB,
        IN DWORD StartTick,
        IN DWORD DeltaTick,
        IN DWORD SortAttr,
        IN DWORD MaxTempTableSize
        );



void
dbFreeKeyIndex(
        THSTATE *pTHS,
        KEY_INDEX *pIndex
        )
{
    KEY_INDEX *pTemp;

    while(pIndex) {
        pTemp = pIndex->pNext;

        if(pIndex->szIndexName) {
            DPRINT1 (2, "dbFreeKeyIndex: freeing %s\n", pIndex->szIndexName);
            dbFree(pIndex->szIndexName);
        }
        if(pIndex->rgbDBKeyLower) {
            dbFree(pIndex->rgbDBKeyLower);
        }

        if(pIndex->rgbDBKeyUpper) {
            dbFree(pIndex->rgbDBKeyUpper);
        }

        if (pIndex->bIsIntersection) {

            Assert (pIndex->tblIntersection);
            JetCloseTable (pTHS->pDB->JetSessID, pIndex->tblIntersection );

            pIndex->bIsIntersection = 0;
            pIndex->tblIntersection = 0;
            #if DBG
            pTHS->pDB->numTempTablesOpened--;
            #endif
        }

        Assert (pIndex->tblIntersection == 0);

        dbFree(pIndex);

        pIndex = pTemp;
    }

    return;
}

DWORD
dbGetAncestorsFromDB(
        DBPOS *pDB,
        JET_TABLEID tblId
        )
/*++
  Description:
      Get the ancestors from Jet, not the dnreadcache.  This is called MANY
      times during a whole subtree search, so let's avoid filling the dnread
      cache with a copy of the entire dit.

  Parameters:
      pDB - What, are you kidding or something?
      tblId - jet table to use.  Should be either pDB->JetObjTbl or
                                                     ->JetSearchTbl
      pAncestors - THAlloc'ed memory to put things into
      pcbAllocated - number of bytes in pAncestors

  Return values:
      Number of bytes in resulting ancestors blob.
--*/
{
    DWORD err;
    DWORD actuallen=0;

    err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                    tblId,
                                    ancestorsid,
                                    pDB->pAncestorsBuff,
                                    pDB->cbAncestorsBuff,
                                    &actuallen,
                                    0,
                                    NULL);

    if(err) {
        if(err != JET_wrnBufferTruncated) {
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }
        // Value too small
        if(pDB->pAncestorsBuff) {
            pDB->pAncestorsBuff = THReAllocOrgEx(pDB->pTHS,
                                        pDB->pAncestorsBuff,
                                        actuallen);
            pDB->cbAncestorsBuff = actuallen;
        }
        else {
            pDB->pAncestorsBuff = THAllocOrgEx(pDB->pTHS, actuallen);
            pDB->cbAncestorsBuff = actuallen;
        }

        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 tblId,
                                 ancestorsid,
                                 pDB->pAncestorsBuff,
                                 actuallen,
                                 &actuallen,
                                 0,
                                 NULL);
    }

    return actuallen;
}

void
dbAdjustCurrentKeyToSkipSubtree (
        DBPOS *pDB
        )
/*++
  Description:
    OK, pay attention.  We're going to do adjust the current key to skip an
    entire subtree.  We're going to do this by modifying the jet key in the
    index structure, then setting the flag to  indicate we are NOT already in a
    search.  This will cause reposition to the next sibling and reset our jet
    index ranges appropriately.  Essentially, it is equivalent to abondoning our
    position in the current KeyIndex structure and building a better KeyIndex
    structure that trims out uninteresting portions of the tree.

    This should only be called from moveToNextSearchCandidate below.

--*/
{
    THSTATE   *pTHS = pDB->pTHS;
    BYTE       rgbKey[DB_CB_MAX_KEY];
    DWORD      cbActualKey = 0;
    DWORD      cbAncestors;
    DWORD      pseudoDNT, realDNT;

    Assert(!strcmp(pDB->Key.pIndex->szIndexName, SZANCESTORSINDEX));

    // Start by refreshing the ancestors info in the dbpos.
    cbAncestors = dbGetAncestorsFromDB(pDB, pDB->JetObjTbl);

    // Now, tweak to get the next subtree.
    // We used to just increment the last DNT in the array, until
    // we discovered that the index is not in DNT order, it's in *byte*
    // order.  This means that what we need is not the next-higher DNT,
    // but the next higher byte pattern.  We thus take the last DNT and
    // byte swap it (so that it's in big-endian order), increment it,
    // and then re-swap it.  This gives us the DNT that would be next in
    // byte order.  Presumably this could all be done better via clever
    // use of JetMakeKey flags.
    realDNT = pDB->pAncestorsBuff[(cbAncestors/sizeof(DWORD)) - 1];
    pseudoDNT = (realDNT >> 24) & 0x000000ff;
    pseudoDNT |= (realDNT >> 8) & 0x0000ff00;
    pseudoDNT |= (realDNT << 8) & 0x00ff0000;
    pseudoDNT |= (realDNT << 24) & 0xff000000;
    ++pseudoDNT;
    realDNT = (pseudoDNT >> 24) & 0x000000ff;
    realDNT |= (pseudoDNT >> 8) & 0x0000ff00;
    realDNT |= (pseudoDNT << 8) & 0x00ff0000;
    realDNT |= (pseudoDNT << 24) & 0xff000000;
    pDB->pAncestorsBuff[(cbAncestors/sizeof(DWORD)) - 1] = realDNT;

    // Now, recalculate the normalized key for the new beginning
    // of the search.
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetObjTbl,
                 pDB->pAncestorsBuff,
                 cbAncestors,
                 JET_bitNewKey);


    JetRetrieveKeyEx(pDB->JetSessID,
                     pDB->JetObjTbl,
                     rgbKey,
                     sizeof(rgbKey),
                     &cbActualKey,
                     JET_bitRetrieveCopy);

    // OK, put that key in place.
    if(pDB->Key.pIndex->cbDBKeyLower < cbActualKey) {
        pDB->Key.pIndex->rgbDBKeyLower =
            dbReAlloc(pDB->Key.pIndex->rgbDBKeyLower,
                      cbActualKey);
    }
    pDB->Key.pIndex->cbDBKeyLower = cbActualKey;
    memcpy(pDB->Key.pIndex->rgbDBKeyLower,
           rgbKey,
           cbActualKey);

    // Finally, set the flag to say we are NOT in an active
    // search for this KEY.
    pDB->Key.fSearchInProgress = FALSE;
    pDB->Key.indexType = UNSET_INDEX_TYPE;

    return;
}


//
// Checks to see if we have a local copy of the object
//
// Returns FALSE if the object is not a local one (phantom, read-only copy)
// TRUE otherwise
//
BOOL
dbIsObjectLocal (
        DBPOS *pDB,
        JET_TABLEID tblId
        )
{
    SYNTAX_INTEGER it;
    DWORD actuallen;

    Assert(VALID_DBPOS(pDB));

    if (JetRetrieveColumnWarnings(pDB->JetSessID,
                                  tblId,
                                  insttypeid,
                                  &it,
                                  sizeof( it ),
                                  &actuallen,
                                  0,
                                  NULL)) {
        // No instance type; must be a phantom, so skip it.
        return FALSE;
    }

    if (it & IT_WRITE) {
        return TRUE;
    }

    return FALSE;
}

BOOL
dbFObjectInCorrectNC (
        DBPOS *pDB,
        ULONG DNT,
        JET_TABLEID tblId
        )
/*++

Routine Description:

    Checks that the current object on the table passed in is correctly located
    for the search root DNT in the key in the pDB.

Arguments:

    pDB - DBPOS to use.

    DNT - the DNT of the current object.  Note that a caller could potentially
          lie and pass us a DNT which is not the DNT of the current object in
          the specified table, but in the interest of efficiency, we trust the
          caller to get this right.

    tblId - jet table to use.  Should be either pDB->JetObjTbl or ->JetSearchTbl

Return Value:

    TRUE if we could verify that the object was in correct portion of the DIT,
    FALSE otherwise.

--*/
{
    SYNTAX_INTEGER        it = 0;
    ULONG                 Ncdnt=0;
    JET_RETRIEVECOLUMN    attList[2];

    // first the instancetype
    attList[0].pvData = &it;
    attList[0].columnid = insttypeid;
    attList[0].cbData = sizeof(it);
    attList[0].grbit = pDB->JetRetrieveBits;
    attList[0].itagSequence = 1;
    attList[0].ibLongValue = 0;

    // then the NC
    attList[1].pvData = &Ncdnt;
    attList[1].columnid = ncdntid;
    attList[1].cbData = sizeof(Ncdnt);
    attList[1].grbit = pDB->JetRetrieveBits;
    attList[1].itagSequence = 1;
    attList[1].ibLongValue = 0;

    Assert(VALID_DBPOS(pDB));

    // This search is constrained to a single Naming Context.
    // Verify.

    /* Retrieve column parameter structure for JetRetrieveColumns */

    if(JetRetrieveColumnsWarnings(pDB->JetSessID, tblId, attList, 2) ||
       // Note the instanceType was in the first slot of the array.
       attList[0].err ){
        Assert(attList[0].err == JET_wrnColumnNull);
        // No instance type; must be a phantom, so skip it.
        return FALSE;
    }

    if(it & IT_UNINSTANT) {

        // Hey, this isn't real, so even if we're not constrainted to a
        // particular NC, we don't wan't this object.
        return FALSE;
    }

    if (!pDB->Key.bOneNC) {

        // We're in GC search, so we need to make sure that this
        // NC isn't one of the NCs were not supposed to search.
        // Note gAnchor.pNoGCSearchList will be NULL if there is
        // not even one NC to _not_ search.  This is the typical
        // case, so I've optimized for that case.

        if(it & IT_NC_HEAD){
            // In this rare rare case, we need to use the DNT of
            // this object, because the ncdnt will be the parent
            // NC's dnt, not the DNT of the current NC head.
            Ncdnt = DNT;
        }

        if(gAnchor.pNoGCSearchList &&
           bsearch(&Ncdnt, // The Key to search for.
                   gAnchor.pNoGCSearchList->pList, // sorted array to search.
                   gAnchor.pNoGCSearchList->cNCs, // number of elements in array.
                   sizeof(DNT), // sizeof each element in array.
                   CompareDNT) ){
            // This was one of the NCs weren't not supposed to
            // return objects from, so return FALSE.
            return(FALSE);
        }

        return(TRUE);
    }

    // NOT a GC search.
    if (it & IT_NC_HEAD) {
        // NC head; in this case, the object is in the correct
        // NC only if the base of the search was the NC head
        // and this is the NC head we found.
        return (DNT == pDB->Key.ulSearchRootNcdnt );
    } else {
        // Interior node; in this case, the object is in
        // the correct NC if its NCDNT matches that of
        // the search root in the key.


        // If only in one NC, then we're in the correct NC only
        // if the object's NCDNT matches that of the search root
        // in the key.

        if (Ncdnt != pDB->Key.ulSearchRootNcdnt &&
            pDB->Key.asqRequest.fPresent) {
            DPRINT (1, "Doing ASQ and found an object from another NC\n");

            if (!pDB->Key.asqRequest.Err) {
                pDB->Key.asqRequest.Err = LDAP_AFFECTS_MULTIPLE_DSAS;
            }
            return TRUE;
        }

        return ( Ncdnt == pDB->Key.ulSearchRootNcdnt );
    }
}

BOOL
dbFObjectInCorrectDITLocation (
        DBPOS *pDB,
        JET_TABLEID tblId
        )
/*++

Routine Description:

    Checks that the current object on the table passed in is correctly located
    for the search key in the pDB.

Arguments:

    pDB - DBPOS to use.

    tblId - jet table to use.  Should be either pDB->JetObjTbl or ->JetSearchTbl

Return Value:

    TRUE if we could verify that the object was in correct portion of the DIT,
    FALSE otherwise.

--*/
{
    ULONG       actuallen;
    ULONG       ulTempDNT;
    DWORD       i;
    DWORD       cAncestors;

    Assert(VALID_DBPOS(pDB));

    //
    // Sam search hints are only used in whole subtree
    // searches
    //

    ASSERT((pDB->Key.ulSearchType==SE_CHOICE_WHOLE_SUBTREE)
             ||(pDB->pTHS->pSamSearchInformation==NULL));

    switch (pDB->Key.ulSearchType) {

    case SE_CHOICE_BASE_ONLY:
        if (!pDB->Key.asqRequest.fPresent) {
            JetRetrieveColumnSuccess(pDB->JetSessID,
                                     tblId,
                                     dntid,
                                     &ulTempDNT,
                                     sizeof(ulTempDNT),
                                     &actuallen,
                                     0,
                                     NULL);
            return (pDB->Key.ulSearchRootDnt == ulTempDNT);
        }
        else {
            // in ASQ all the returned objects are ok
            return TRUE;
        }
        break;

    case SE_CHOICE_IMMED_CHLDRN:

        if (pDB->Key.pVLV && pDB->Key.pVLV->bUsingMAPIContainer) {
            // we might add a test to see that indeed one of the
            // showInAddressBook values in this record is the one we want
            return TRUE;
        }

        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 tblId,
                                 pdntid,
                                 &ulTempDNT,
                                 sizeof(ulTempDNT),
                                 &actuallen,
                                 0,
                                 NULL);
        return (pDB->Key.ulSearchRootDnt == ulTempDNT);
        break;

    case SE_CHOICE_WHOLE_SUBTREE:
        if(pDB->Key.ulSearchRootDnt == ROOTTAG) {
            // The root is a subtree ancestor of everything
            return TRUE;
        }

        //
        // If pSamsearch information indicates that ancestors need
        // not be checked then return true always
        //

        if (pDB->pTHS->pSamSearchInformation) {
            SAMP_SEARCH_INFORMATION * pSamSearchInformation
                = pDB->pTHS->pSamSearchInformation;

            if (pSamSearchInformation->bRootOfSearchIsNcHead) {
                //
                // If the root of the search is an NC head, then
                // the test for Same NC is sufficient to determine
                // wether the object is in the correct DIT location.
                // There fore we may simply return true in here.
                //
                return TRUE;
            }
        }

        // We are going to use the ancestry value from the DB.
        // We realize that is might be inconsistent, i.e. it can
        // be different from the "actual" ancestry obtained by walking
        // the parent chain. However, it is really difficult to figure
        // out if the ancestry value is inconsistent. It is inconsistent
        // and will produce an incorrect result, when one of the ancestors
        // on the path from current object to the search root was moved,
        // and the SDP did not yet get a chance to update the ancestry of 
        // the current object.
        //
        // While we can determine whether the ancestry value of the search
        // root is valid or not (see AncestryIsConsistentInSubtree in 
        // DBChooseIndex), we can not afford doing this here, because it would
        // require checking each object in the parent chain and looking at their
        // SD propagation stamp. Thus, we will just use the current ancestry
        // value from the DB.
        //
        // Imagine that there's a tree CN=C,CN=B,CN=A. Assume that CN=B was moved
        // outside of CN=A, say, into CN=D. The ancestry of CN=C has not been 
        // updated yet. If we do a search off CN=A, then we will hit a false positive
        // CN=C. If we do a search off CN=B, then we will not walk the ancestry
        // index (DBChooseIndex ensures that), and we will hit CN=C because
        // CN=B is still present in the ancestry value of CN=C.
        // If we do a search off CN=D, then we will not hit CN=C
        cAncestors = dbGetAncestorsFromDB(pDB, tblId) / sizeof(DWORD);
        for(i=0;i<cAncestors;i++) {
            if(pDB->pAncestorsBuff[i] == pDB->Key.ulSearchRootDnt) {
                return TRUE;
            }
        }

        return FALSE;
        break;

    default:                // shouldn't be here
        Assert(FALSE);
        return FALSE;
    }
} // dbFObjectInCorrectDITLocation

BOOL
dbIsInVLVContainer (DBPOS *pDB, DWORD ContainerID)
/*++

Routine Description:

    Verifies that the current index position is on the specified container.
    It reads the container info directly from the index, so it requires that
    the index is PDNT based or MAPI based.

    NOTE: assumes the DBPOS already is set up on the appropriate index for the
    Container in question.

Arguments:

    ContainerID - the Container to abstract this seek inside.
                  if PDNT based reads the PDNT from the index
                  if MAPI based, read the showInAddrBook from index

Return Values:

    TRUE if positioned on the specified container, FALSE otherwise.

--*/
{
    DWORD dwThisContainerID=!ContainerID;

    // Read the container id FROM THE INDEX KEY! and see if it is the one passed in.
    if (pDB->Key.pVLV->bUsingMAPIContainer) {
        DBGetSingleValueFromIndex (
                pDB,
                ATT_SHOW_IN_ADDRESS_BOOK,
                &dwThisContainerID,
                sizeof(DWORD),
                NULL);
    }
    else {
        DBGetSingleValueFromIndex (
                pDB,
                FIXED_ATT_PDNT,
                &dwThisContainerID,
                sizeof(DWORD),
                NULL);
    }

    return (dwThisContainerID == ContainerID);
} // dbIsInVLVContainer

// REVIEW:  pvData and cbData are never used so we could just seek based on the
// REVIEW:  index range keys.  we could also detect if we are in the container by
// REVIEW:  setting up a normal index range.  this would be much faster
DWORD
dbVlvSeek (
        DBPOS *pDB,
        void * pvData,
        DWORD cbData,
        DWORD ContainerID
      )
/*++

Routine Description:

    Abstracts a DBSeek inside a VLV container.  Assumes at most one
    value to seek on.  If no values are specified, it seeks to the
    beginning of the appropriate container.

    NOTE: assumes the DBPOS already is set up on the appropriate index for the
    VLV Container in question.

Arguments:

    pvData - the Data to look for.

    cbData - the count of bytes of the data.

    ContainerID - the Container to abstract this seek inside.

Return Values:

    0 if all went well, an error code otherwise.

--*/
{
    INDEX_VALUE index_values[2];
    ULONG       cVals = 0;
    ULONG       dataindex=0;
    DWORD       err;

    index_values[0].pvData = &ContainerID;
    index_values[0].cbData = sizeof(DWORD);
    dataindex++;
    cVals++;

    // PVData == 0 only for the abstraction of DB_MoveFirst in a container.  To
    // handle ascending and descending sorts correctly, this only seeks on
    // ContainerID.

    // REVIEW:  pvData and cbData are never passed so this is dead code
    if(pvData) {
        index_values[dataindex].pvData = pvData;
        index_values[dataindex].cbData = cbData;
        cVals++;
    }

    // We should never be called both without a ContainerID and without data.
    // REVIEW:  this assert is dead code because it can never go off
    Assert(cVals);

    err = DBSeek(pDB, index_values, cVals, DB_SeekGE);

    // Make sure we are in the correct container.
    if((err != DB_ERR_RECORD_NOT_FOUND) &&
       !dbIsInVLVContainer(pDB, ContainerID)) {
            err = DB_ERR_RECORD_NOT_FOUND;
    }

    return err;
} // dbVlvSeek

DWORD
dbVlvMove (DBPOS *pDB, long Delta, BOOL fForward, DWORD ContainerID)
/*++

Routine Description:
    Abstracts movement within a container used for VLV.

    Note that moving backward past the beginning of the VLV container leaves us
    on the first entry of the container, while moving forward past the end of
    the container leaves us one row past the end of the VLV container.

Arguments:

    Delta - The distance to move.  Accepts numeric arguments and DB_MoveFirst,
        DB_MoveLast, DB_MoveNext, DB_MovePrevious.

    fForward - forward / backward movement

    ContainerID - the ID of the Container to move around in.

Return Value:

    Returns 0 if successful, an error code otherwise.

--*/
{
    DWORD err;

    if(!Delta )                     // check for the null case
        return DB_success;          // nothing to do, and we did it well!

    Assert(ContainerID);

    switch(Delta) {
    case DB_MoveFirst:
        err = dbVlvSeek(pDB, NULL, 0, ContainerID);

        if((err == DB_success &&
            // REVIEW:  this call to dbIsInVLVContainer is redundant
            (!dbIsInVLVContainer(pDB, ContainerID)) ||
             err == DB_ERR_NO_CURRENT_RECORD           ||
             err == DB_ERR_RECORD_NOT_FOUND   )) {
                // Couldn't find the first object in this container.  The
                // container must be empty.
                err = DB_ERR_NO_CURRENT_RECORD;
        }
        break;

    case DB_MoveLast:
        // dbVlvSeek will always leave us in the correct place (one past the
        // end of the container, even if the container is empty.)
        dbVlvSeek(pDB, NULL, 0, ContainerID+1);

        // Back up to the last object in the container.
        err = DBMovePartial(pDB, DB_MovePrevious);
        if(err != DB_success ||
           !dbIsInVLVContainer(pDB, ContainerID)) {
            // We couldn't back up to the last row or we did back up and we
            // weren't in the correct container after we did.  Either way,
            // set the flags to indicate we are not in the container.
            err = DB_ERR_NO_CURRENT_RECORD;
        }
        break;

    default:
        err = DBMovePartial(pDB, Delta);
        if((err != DB_ERR_NO_CURRENT_RECORD) &&
           !dbIsInVLVContainer(pDB, ContainerID)) {
            // we moved to a valid row, but ended up outside of the
            // container.  Set the error to be the same as the error for not
            // moving to a valid row.
            err=DB_ERR_NO_CURRENT_RECORD;
        }

        switch( err ) {
        case DB_success:
            break;

        case DB_ERR_NO_CURRENT_RECORD:
            if (fForward) {
                // After the move, we did not end up on a valid row.
                if (Delta < 0) {
                    // Moving back, off the front, so move to the first record
                    // REVIEW:  why don't we move prev here so that a move next
                    // REVIEW:  will place us on the first entry?  because this
                    // REVIEW:  logic is based on the VLV for the MAPI AB Provider
                    // REVIEW:  which has no before first but does have an after
                    // REVIEW:  last.  is it valid to do this here?
                    dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID);
                }
                else {
                    // position on the first record of the next container, which
                    // is the same thing as being one past the last row of the
                    // current container.
                    dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID + 1);
                }
            }
            else {
                // After the move, we did not end up on a valid row.
                if (Delta < 0) {
                    // position on the last record of the prev container, which
                    // is the same thing as being one past the last row of the
                    // current container.
                    dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID - 1);
                }
                else {
                    // Moving back, off the front, so move to the last record
                    // since we are moving backwards
                    // REVIEW:  why don't we move next here so that a move prev
                    // REVIEW:  will place us on the last entry?  because this
                    // REVIEW:  logic is based on the VLV for the MAPI AB Provider
                    // REVIEW:  which has no before first but does have an after
                    // REVIEW:  last.  is it valid to do this here?
                    dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID);
                }
            }
            break;

        default:
            break;
        }                           // switch on err
        break;
    }                               // switch on Delta

    return err;
} // dbVlvMove

DWORD
dbVlvSetFractionalPosition (DBPOS *pDB, ULONG Flags)
/*++

Routine Description:
    Abstracts fractional positioning within an container / InMemory Result Set.

    The position is determined from the pDB->key.pVLV argument.
    Takes into considaration the beforeCount argument of the VLV request
    and positions accordingly.

    If it is near the start of the container, and there are not enough entries
    before the targetPosition, the total number of returned entries is adjusted
    accordingly.

Return Value:
    Returns 0 if successful, Jet error otherwise.

    the following are updated accordingly:
        pDB->Key.pVLV->currPosition
        pDB->Key.pVLV->requestedEntries

--*/
{
    THSTATE    *pTHS=pDB->pTHS;
    BOOL        fForward = !!(Flags & DB_SEARCH_FORWARD) ^ pDB->Key.fChangeDirection;
    DWORD       start, beforeCount;
    LONG        deltaCount, direction;
    VLV_SEARCH   *pVLV = pDB->Key.pVLV;

    Assert (pVLV);

    start = GetTickCount();

    // vlv positioning within a memory array
    //
    if (pDB->Key.indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE) {
        if (pVLV->positionOp == VLV_MOVE_FIRST) {
            pVLV->currPosition = 1;

            if(fForward) {
                // set to first Entry
                pDB->Key.currRecPos = 1;

            } else {
                // set to last entry
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
            }

            // since we start at the first entry, we are not interested
            // in the entries before this
            pVLV->requestedEntries -= pVLV->pVLVRequest->beforeCount;
        }
        else if (pVLV->positionOp == VLV_MOVE_LAST) {

            pVLV->currPosition = pDB->Key.cdwCountDNTs;

            if(fForward) {
                // set to last entry
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
            } else {
                // set to first Entry
                pDB->Key.currRecPos = 1;
            }


            // adjust for the before Count
            beforeCount = pVLV->pVLVRequest->beforeCount;

            if (fForward) {
                if (pVLV->currPosition > beforeCount) {
                    Assert(pDB->Key.currRecPos >= beforeCount);
                    pDB->Key.currRecPos -= beforeCount;
                }
                else {
                    Assert(beforeCount >= pVLV->currPosition - 1);
                    beforeCount -= pVLV->currPosition - 1;
                    Assert(pVLV->requestedEntries >= beforeCount);
                    pVLV->requestedEntries -= beforeCount;
                    pDB->Key.currRecPos = 1;
                }
            }
            else {
                if (pVLV->currPosition > beforeCount) {
                    Assert(pDB->Key.currRecPos + beforeCount <= pDB->Key.cdwCountDNTs + 1);
                    pDB->Key.currRecPos += beforeCount;
                }
                else {
                    Assert(beforeCount >= pVLV->currPosition - 1);
                    beforeCount -= pVLV->currPosition - 1;
                    Assert(pVLV->requestedEntries >= beforeCount);
                    pVLV->requestedEntries -= beforeCount;
                    pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
                }
            }
        }
        else {
            // pDB->Key.vlvSearch.positionOp == VLV_CALC_POSITION

            if ( pVLV->clnContentCount == 0 ) {
                pVLV->clnContentCount = pVLV->contentCount;
            }

            pVLV->currPosition = MulDiv(pVLV->contentCount - 1,
                                        pVLV->clnCurrPos - 1,
                                        pVLV->clnContentCount - 1) + 1;
            pVLV->currPosition = max(pVLV->currPosition, 1);
            pVLV->currPosition = min(pVLV->currPosition, pVLV->contentCount);

            // adjust for the before Count
            beforeCount = pVLV->pVLVRequest->beforeCount;

            if (fForward) {
                pDB->Key.currRecPos = pVLV->currPosition;

                if (pVLV->currPosition > beforeCount) {
                    Assert(pDB->Key.currRecPos >= beforeCount);
                    pDB->Key.currRecPos -= beforeCount;
                }
                else {
                    Assert(beforeCount >= pVLV->currPosition - 1);
                    beforeCount -= pVLV->currPosition - 1;
                    Assert(pVLV->requestedEntries >= beforeCount);
                    pVLV->requestedEntries -= beforeCount;
                    pDB->Key.currRecPos = 1;
                }
            }
            else {
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs - pVLV->currPosition + 1;

                if (pVLV->currPosition > beforeCount) {
                    Assert(pDB->Key.currRecPos + beforeCount <= pDB->Key.cdwCountDNTs + 1);
                    pDB->Key.currRecPos += beforeCount;
                }
                else {
                    Assert(beforeCount >= pVLV->currPosition - 1);
                    beforeCount -= pVLV->currPosition - 1;
                    Assert(pVLV->requestedEntries >= beforeCount);
                    pVLV->requestedEntries -= beforeCount;
                    pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
                }
            }
        }
    }
    // do the real thing. vlv position in the database
    //
    else {
        DWORD err;
        DWORD ContainerID = pDB->Key.pVLV->bUsingMAPIContainer ?
                                    pDB->Key.pVLV->MAPIContainerDNT :
                                    pDB->Key.ulSearchRootDnt;
        DWORD ContainerDenominator, ContainerNumeratorBegin, ContainerNumeratorEnd;
        DWORD Denominator, Numerator;
        DWORD BeginDenom, BeginNum, EndDenom, EndNum;
        LONG  requiredPos;
        LONG lastPosition = pVLV->currPosition;

        // We are Moving in a container.
        //
        // 1) Get the fractional position of the beginning of the appropriate
        //  container.  This is the offset from the beginning of the index to
        //  the first element of the subcontainer.
        //
        // 2) Get the fractional position of the end of the appropriate
        //  container.  This is the offset from the beginning of the index to
        //  the last element of the subcontainer.
        //
        // 3) Calculate the size of the container.
        //
        // 4) Calculate the new requested position in the container.
        //
        // 5) Find the new position relative to the start of the index
        //
        // 6) Go to the specified position. Check to see if target record belongs
        //    to container. If not move to the first record and move X records
        //    forward, or move to the last record and move X records backwards.
        //
        // There, that wasn't that hard, was it?


        // Get fractional position of beginning
        if (err = dbVlvMove(pDB, DB_MoveFirst, TRUE, ContainerID)) {
                return err;
        }
        DBGetFractionalPosition(pDB, &BeginNum, &BeginDenom);

        // Get fractional position of ending
        if (err = dbVlvMove(pDB, DB_MoveLast, TRUE, ContainerID)) {
                return err;
        }
        DBGetFractionalPosition(pDB, &EndNum, &EndDenom);

        DPRINT2 (1, "Start of Container: %d / %d \n", BeginNum, BeginDenom);
        DPRINT2 (1, "End of Container: %d / %d \n", EndNum, EndDenom);

        // Normalize the fractions of the fractional position to the average of
        // the two denominators.
        // denominator
        Denominator = (BeginDenom + EndDenom)/2;
        EndNum = MulDiv(EndNum, Denominator - 1, EndDenom - 1) + 1;
        BeginNum = MulDiv(BeginNum, Denominator - 1, BeginDenom - 1) + 1;

        // keep values for later
        ContainerNumeratorBegin = BeginNum;
        ContainerNumeratorEnd = EndNum;
        ContainerDenominator = Denominator;

        DPRINT2 (1, "Adj. Start of Container: %d / %d \n", BeginNum, Denominator);
        DPRINT2 (1, "Adj. End of Container: %d / %d \n", EndNum, Denominator);

        // calculate container size, since it might have changed
        pVLV->contentCount = NormalizeIndexPosition (BeginNum, EndNum);

        // we need better content size estimation since this container does not
        // have enough entries
        // we are positioned in the end
        // NTRAID#NTRAID-590547-2002/03/29-andygo:  PERF:  VLV should use JetIndexRecordCountEx to get size of small containers
        // REVIEW:  we should use JetIndexRecordCountEx inside an index range instead
        // REVIEW:  especially because the estimate could be off by a significant amount
        if (pVLV->contentCount < EPSILON) {
            ULONG newCount=0;
            if (dbIsInVLVContainer(pDB, ContainerID)) {
                newCount=1;

                while ( !(err = dbVlvMove(pDB, DB_MovePrevious, TRUE, ContainerID))) {
                    newCount++;
                }
            }
            pVLV->contentCount = newCount;
        }
        DPRINT1 (1, "Size of Container: %d\n", pVLV->contentCount);

        if ( pVLV->clnContentCount == 0 ) {
            pVLV->clnContentCount = pVLV->contentCount;
        }

        // position accordingly
        //
        if ( pVLV->positionOp == VLV_MOVE_FIRST) {

            if (fForward) {
                dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID);
            }
            else {
                dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID);
            }

            pVLV->currPosition = 1;

        } else if (pVLV->positionOp == VLV_MOVE_LAST) {
            if (fForward) {
                dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID);
            }
            else {
                dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID);
            }
            pVLV->currPosition = pVLV->contentCount;
        }
        else {
            // pVLV->positionOp == VLV_CALC_POSITION

            // calculate the required position
            requiredPos = MulDiv (pVLV->contentCount - 1,
                                  pVLV->clnCurrPos - 1,
                                  pVLV->clnContentCount - 1) + 1;

            // see if we are near ends so we have todo precise positioning
            //
            if (requiredPos < EPSILON) {
                if (fForward) {
                    DPRINT (1, "Precise Positioning Near Start of Container\n");
                    dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID );
                    // we subtract one here because requiredPos is 1 based
                    deltaCount = requiredPos - 1;
                }
                else {
                    DPRINT (1, "Precise Positioning Near End of Container\n");
                    dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID );
                    // we subtract one here because requiredPos is 1 based
                    deltaCount = 1 - requiredPos;
                }
                direction = deltaCount < 0 ? -1 : 1;
                while (deltaCount) {
                    if (GetTickCount() - start > VLV_TIMEOUT) {
                        return DB_ERR_TIMELIMIT;
                    }
                    if (dbVlvMove(pDB, direction, fForward, ContainerID)) {
                        break;
                    }
                    if (dbMakeCurrent(pDB, NULL) != DIRERR_NOT_AN_OBJECT &&
                        dbFObjectInCorrectDITLocation(pDB, pDB->JetObjTbl) &&
                        dbFObjectInCorrectNC(pDB, pDB->DNT, pDB->JetObjTbl)) {
                        DB_ERR errT;
                        BOOL bMatch = FALSE;
                        if (errT = DBMatchSearchCriteria(pDB, Flags & DB_SEARCH_DONT_EVALUATE_SECURITY, &bMatch)) {
                            return errT;
                        }
                        if (bMatch) {
                            deltaCount -= direction;
                        }
                    }
                }

                // CONSIDER:  we should recompute currPosition here
                pVLV->currPosition = requiredPos;
            }
            else if (pVLV->contentCount - requiredPos <= EPSILON) {
                if (fForward) {
                    DPRINT (1, "Precise Positioning Near End of Container\n");
                    dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID);
                    deltaCount = requiredPos - pVLV->contentCount;
                }
                else {
                    DPRINT (1, "Precise Positioning Near Start of Container\n");
                    dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID);
                    deltaCount = pVLV->contentCount - requiredPos;
                }
                direction = deltaCount < 0 ? -1 : 1;
                while (deltaCount) {
                    if (GetTickCount() - start > VLV_TIMEOUT) {
                        return DB_ERR_TIMELIMIT;
                    }
                    if (dbVlvMove(pDB, direction, fForward, ContainerID)) {
                        break;
                    }
                    if (dbMakeCurrent(pDB, NULL) != DIRERR_NOT_AN_OBJECT &&
                        dbFObjectInCorrectDITLocation(pDB, pDB->JetObjTbl) &&
                        dbFObjectInCorrectNC(pDB, pDB->DNT, pDB->JetObjTbl)) {
                        DB_ERR errT;
                        BOOL bMatch = FALSE;
                        if (errT = DBMatchSearchCriteria(pDB, Flags & DB_SEARCH_DONT_EVALUATE_SECURITY, &bMatch)) {
                            return errT;
                        }
                        if (bMatch) {
                            deltaCount -= direction;
                        }
                    }
                }

                // CONSIDER:  we should recompute currPosition here
                pVLV->currPosition = requiredPos;
            }
            else {
                BOOL fPositioned = FALSE;

                if (lastPosition) {
                    if ((lastPosition-EPSILON) < requiredPos &&
                        (lastPosition+EPSILON) > requiredPos ) {

                        DPRINT (1, "Precise Positioning in the Middle of the Container\n");

                        JetMakeKeyEx(pDB->JetSessID,
                                     pDB->JetObjTbl,
                                     pVLV->rgbCurrPositionKey,
                                     pVLV->cbCurrPositionKey,
                                     JET_bitNormalizedKey);
                        err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekGE);

                        // still on the same container ?
                        if (err == JET_errSuccess && dbIsInVLVContainer(pDB, ContainerID)) {

                            if (fForward) {
                                deltaCount = requiredPos - lastPosition;
                            }
                            else {
                                deltaCount = lastPosition - requiredPos;
                            }
                            direction = deltaCount < 0 ? -1 : 1;
                            while (deltaCount) {
                                if (GetTickCount() - start > VLV_TIMEOUT) {
                                    return DB_ERR_TIMELIMIT;
                                }
                                if (dbVlvMove(pDB, direction, fForward, ContainerID)) {
                                    break;
                                }
                                if (dbMakeCurrent(pDB, NULL) != DIRERR_NOT_AN_OBJECT &&
                                    dbFObjectInCorrectDITLocation(pDB, pDB->JetObjTbl) &&
                                    dbFObjectInCorrectNC(pDB, pDB->DNT, pDB->JetObjTbl)) {
                                    DB_ERR errT;
                                    BOOL bMatch = FALSE;
                                    if (errT = DBMatchSearchCriteria(pDB, Flags & DB_SEARCH_DONT_EVALUATE_SECURITY, &bMatch)) {
                                        return errT;
                                    }
                                    if (bMatch) {
                                        deltaCount -= direction;
                                    }
                                }
                            }

                            if (dbIsInVLVContainer(pDB, ContainerID)) {
                                fPositioned = TRUE;

                                // CONSIDER:  we should recompute currPosition here
                                pVLV->currPosition = requiredPos;
                            }
                        }
                    }
                }

                // we didn't think we had to position precisely,
                // so we position approximately
                //
                if (!fPositioned) {
                    // adjust the values to reflect the start of the index
                    if (EndNum > BeginNum) {
                        Numerator = BeginNum + MulDiv (requiredPos - 1,
                                                       EndNum - BeginNum,
                                                       pVLV->contentCount - 1);
                    }
                    else {
                        Numerator = BeginNum;
                    }

                    DPRINT2 (1, "Requested Position: %d / %d \n", Numerator, Denominator);

                    err = DBSetFractionalPosition(pDB, Numerator, Denominator);
                    if(err != DB_success ) {
                        return DB_ERR_NO_CURRENT_RECORD;
                    }

                    if(!dbIsInVLVContainer(pDB, ContainerID)) {
                        // not in the right container.  Do this the long way.
                        if((2 * Numerator) < Denominator ) {
                            // Closer to the front.
                            if (fForward) {
                                DPRINT (1, "Positioned out of container near front\n");
                                dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID);
                                // we subtract one here because requiredPos is 1 based
                                deltaCount = requiredPos - 1;
                            }
                            else {
                                DPRINT (1, "Positioned out of container near end\n");
                                dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID);
                                deltaCount = requiredPos - pVLV->contentCount;
                            }
                        }
                        else {
                            if (fForward) {
                                DPRINT (1, "Positioned out of container near end\n");
                                dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID);
                                deltaCount = requiredPos - pVLV->contentCount;
                            }
                            else {
                                DPRINT (1, "Positioned out of container near front\n");
                                dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID);
                                // we subtract one here because requiredPos is 1 based
                                deltaCount = requiredPos - 1;
                            }
                        }
                        direction = deltaCount < 0 ? -1 : 1;
                        while (deltaCount) {
                            if (GetTickCount() - start > VLV_TIMEOUT) {
                                return DB_ERR_TIMELIMIT;
                            }
                            if (dbVlvMove(pDB, direction, fForward, ContainerID)) {
                                break;
                            }
                            if (dbMakeCurrent(pDB, NULL) != DIRERR_NOT_AN_OBJECT &&
                                dbFObjectInCorrectDITLocation(pDB, pDB->JetObjTbl) &&
                                dbFObjectInCorrectNC(pDB, pDB->DNT, pDB->JetObjTbl)) {
                                DB_ERR errT;
                                BOOL bMatch = FALSE;
                                if (errT = DBMatchSearchCriteria(pDB, Flags & DB_SEARCH_DONT_EVALUATE_SECURITY, &bMatch)) {
                                    return errT;
                                }
                                if (bMatch) {
                                    deltaCount -= direction;
                                }
                            }
                        }

                        if(!dbIsInVLVContainer(pDB, ContainerID)) {
                            DPRINT (1, "FAILED adjusting position\n");
                            return DB_ERR_NO_CURRENT_RECORD;
                        }
                    }

                    // Get fractional position of current position.
                    DBGetFractionalPosition(pDB, &EndNum, &EndDenom);

                    DPRINT2 (1, "Found Position: %d / %d \n", EndNum, EndDenom);

                    EndNum = MulDiv(EndNum, ContainerDenominator - 1, EndDenom - 1) + 1;

                    DPRINT2 (1, "Adj. Position: %d / %d \n", EndNum, ContainerDenominator);

                    pVLV->currPosition = NormalizeIndexPosition(ContainerNumeratorBegin, EndNum);
                    pVLV->currPosition = max(pVLV->currPosition, 1);
                    pVLV->currPosition = min(pVLV->currPosition, pVLV->contentCount);

                    DPRINT2 (1, "Calculated Position: %d / %d \n",
                             pVLV->currPosition, pVLV->contentCount);
                }
            }
        }

        // get the key on the current position for later
        pVLV->cbCurrPositionKey = sizeof (pVLV->rgbCurrPositionKey);
        DBGetKeyFromObjTable(pDB,
                             pVLV->rgbCurrPositionKey,
                             &pVLV->cbCurrPositionKey);

        // adjust for the before Count
        beforeCount = 0;
        while (beforeCount < pVLV->pVLVRequest->beforeCount) {
            if (GetTickCount() - start > VLV_TIMEOUT) {
                return DB_ERR_TIMELIMIT;
            }
            if (dbVlvMove(pDB, fForward ? DB_MovePrevious : DB_MoveNext, fForward, ContainerID)) {
                break;
            }
            if (dbMakeCurrent(pDB, NULL) != DIRERR_NOT_AN_OBJECT &&
                dbFObjectInCorrectDITLocation(pDB, pDB->JetObjTbl) &&
                dbFObjectInCorrectNC(pDB, pDB->DNT, pDB->JetObjTbl)) {
                DB_ERR errT;
                BOOL bMatch = FALSE;
                if (errT = DBMatchSearchCriteria(pDB, Flags & DB_SEARCH_DONT_EVALUATE_SECURITY, &bMatch)) {
                    return errT;
                }
                if (bMatch) {
                    beforeCount++;
                }
            }
        }

        if (beforeCount < pVLV->pVLVRequest->beforeCount) {
            pVLV->requestedEntries = beforeCount + 1 + pVLV->pVLVRequest->afterCount;
        }
    }

    return 0;
} // dbVlvSetFractionalPosition

DWORD
dbMoveToNextSearchCandidateOnInMemoryTempTable (
        DBPOS *pDB,
        ULONG Flags,
        DWORD StartTick,
        DWORD DeltaTick
        )
/*++

Routine Description:

    Move to the next object in the in memory temp table.
    If we are seeking to a value, this is treated accordingly.
    The current position in the array is updated.

Arguments:

    same as dbMoveToNextSearchCandidate

Return Values:

    0 if all went well and we found a next candidate, DB_ERR_NEXTCHILD_NOTFOUND
    if no next candidate could be found.

--*/
{
    THSTATE    *pTHS=pDB->pTHS;
    BOOL        fForward = !!(Flags & DB_SEARCH_FORWARD) ^ pDB->Key.fChangeDirection;
    DWORD       err;

    DWORD       idwMin, idwMid, idwMax;
    DWORD       flags = DBGETATTVAL_fINTERNAL | DBGETATTVAL_fREALLOC;
    ULONG       cbAttValMost = 0;
    ULONG       cbAttVal = 0;
    UCHAR      *rgbAttVal = NULL;
    DWORD       beforeCount;
    BOOL        fFound=FALSE;
    ATTCACHE   *pAC;
    ATTRVAL     seekVal;
    SUBSTRING   substr;
    VLV_SEARCH *pVLV = pDB->Key.pVLV;

    Assert (pVLV);

    // If the restriction is empty, we can't find anything.
    if (pDB->Key.cdwCountDNTs == 0) {
        pDB->Key.currRecPos = 0;
        return DB_ERR_NEXTCHILD_NOTFOUND;
    }

    // if we are seeking to a particular value for the first time
    if (!pDB->Key.fSearchInProgress) {

        // we are looking for a specific key value
        if (pVLV->pVLVRequest->fseekToValue) {

            // convert the seek val into internal format
            if (!(pAC = SCGetAttById(pTHS, pVLV->SortAttr))) {
                DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, pVLV->SortAttr);
            }

            if (gDBSyntax[pAC->syntax].ExtInt(pDB,
                                              DBSYN_INQ,
                                              pVLV->pVLVRequest->seekValue.valLen,
                                              pVLV->pVLVRequest->seekValue.pVal,
                                              &seekVal.valLen,
                                              &seekVal.pVal,
                                              0,
                                              0,
                                              0)) {
                return DB_ERR_UNKNOWN_ERROR;
            }
            substr.type                 = pAC->id;
            substr.initialProvided      = TRUE;
            substr.InitialVal.valLen    = seekVal.valLen;
            substr.InitialVal.pVal      = seekVal.pVal;
            substr.AnyVal.count         = 0;
            substr.finalProvided        = FALSE;

            // bsearch the DNT array for the target by key value
            //
            // for ascending sorts, we partition the array into two pieces:
            // the entries less than seekVal [0,idwMax) and the entries greater
            // than or equal to seekVal [idwMax, pDB->Key.cdwCountDNTs).
            // the target value is idwMax because that is the entry closest to
            // the start of the array that is greater than or equal to seekVal.
            // if all entries are greater than or equal to seekVal then we land
            // on the first entry.  if all entries are less than seekVal then
            // we will land one past the end of the array which becomes the
            // special target value returned to the client that indicates this
            //
            // for descending sorts, we partition the array into two pieces:
            // the entries less than or equal to seekVal [0, idwMax) and the
            // entries greater than seekVal [idwMax, pDB->Key.cdwCountDNTs).
            // the target value is idwMax - 1 because that is the entry closest
            // to the end of the array that is less than or equal to seekVal.
            // if all entries are less than or equal to seekVal then we will
            // land one past the start of the array which becomes the special
            // target value returned to the client that indicates this.  if all
            // entries are greater than seekVal then we will land on the last
            // entry
            //
            // for descending sorts, an entry is considered equal if it has an
            // initial substring that matches seekVal.  this enables a search
            // for "C" to place everything that starts with "C" at or below the
            // target entry so that typedown will work as expected
            idwMin = 0;
            idwMax = pDB->Key.cdwCountDNTs;

            while (idwMin < idwMax) {

                idwMid = idwMin + (idwMax - idwMin) / 2;

                if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[idwMid])) {
                    return err;
                }
                if (err = DBGetAttVal_AC(pDB, 1, pAC, flags, cbAttValMost, &cbAttVal, &rgbAttVal)) {
                    return DB_ERR_UNKNOWN_ERROR;
                }
                cbAttValMost = max(cbAttValMost, cbAttVal);

                if (gDBSyntax[pAC->syntax].Eval(pDB,
                                                FI_CHOICE_LESS,
                                                seekVal.valLen,
                                                seekVal.pVal,
                                                cbAttVal,
                                                rgbAttVal) == TRUE ||
                    !fForward &&
                    gDBSyntax[pAC->syntax].Eval(pDB,
                                                FI_CHOICE_SUBSTRING,
                                                sizeof(substr),
                                                (UCHAR*)&substr,
                                                cbAttVal,
                                                rgbAttVal) == TRUE) {
                    idwMin = idwMid + 1;
                } else {
                    idwMax = idwMid;
                }
            }

            if (fForward) {
                pDB->Key.currRecPos = idwMax + 1;
                pVLV->currPosition = pDB->Key.currRecPos;
            } else {
                pDB->Key.currRecPos = idwMax - 1 + 1;
                pVLV->currPosition = pVLV->contentCount - pDB->Key.currRecPos + 1;
            }


            // adjust for the before Count
            beforeCount = pVLV->pVLVRequest->beforeCount;

            if (fForward) {
                if (pVLV->currPosition > beforeCount) {
                    Assert(pDB->Key.currRecPos >= beforeCount);
                    pDB->Key.currRecPos -= beforeCount;
                }
                else {
                    Assert(beforeCount >= pVLV->currPosition - 1);
                    beforeCount -= pVLV->currPosition - 1;
                    Assert(pVLV->requestedEntries >= beforeCount);
                    pVLV->requestedEntries -= beforeCount;
                    pDB->Key.currRecPos = 1;
                }
            }
            else {
                if (pVLV->currPosition > beforeCount) {
                    Assert(pDB->Key.currRecPos + beforeCount <= pDB->Key.cdwCountDNTs + 1);
                    pDB->Key.currRecPos += beforeCount;
                }
                else {
                    Assert(beforeCount >= pVLV->currPosition - 1);
                    beforeCount -= pVLV->currPosition - 1;
                    Assert(pVLV->requestedEntries >= beforeCount);
                    pVLV->requestedEntries -= beforeCount;
                    pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
                }
            }

            if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[pDB->Key.currRecPos-1] )) {
                return err;
            }
        }
        // we are looking for a specified position
        else {
            Assert (pDB->Key.cdwCountDNTs == pVLV->contentCount);

            dbVlvSetFractionalPosition (pDB, Flags);

            if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[pDB->Key.currRecPos-1] )) {
                return err;
            }
        }
    }
    // search already in progress
    else {
        // we are already positioned on the InMemory sorted table
        // either by seeking to a value or directly

        // going forward
        if(fForward) {
            pDB->Key.currRecPos++;

            if (pDB->Key.currRecPos <= pDB->Key.cdwCountDNTs) {
                if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[pDB->Key.currRecPos - 1] )) {
                    return err;
                }
            }
            else {
                // set to EOF
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs + 1;
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
        }
        // going backward
        else {
            if (pDB->Key.currRecPos >=1) {
                pDB->Key.currRecPos--;
            }

            if (pDB->Key.currRecPos) {
                if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[pDB->Key.currRecPos - 1] )) {
                    return err;
                }
            }
            else {
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
        }
    }

    return 0;
} // dbMoveToNextSearchCandidateOnInMemoryTempTable

DWORD dbMoveToNextSearchCandidateOnASQ (DBPOS *pDB,
                                        ULONG Flags,
                                        DWORD StartTick,
                                        DWORD DeltaTick)
/*++

Routine Description:

    Move to the next object in the memory table used for ASQ.
    If more entries are needed to be read, we read more.
    Paged requests are handled accordingly.

Arguments:

    same as dbMoveToNextSearchCandidate

Return Values:

    0 if all went well and we found a next candidate, DB_ERR_NEXTCHILD_NOTFOUND
    if no next candidate could be found.

--*/
{
    DWORD err;
    BOOL  fForward = !!(Flags & DB_SEARCH_FORWARD) ^ pDB->Key.fChangeDirection;

    if (!pDB->Key.cdwCountDNTs) {
        return DB_ERR_NEXTCHILD_NOTFOUND;
    }

    Assert (pDB->Key.pDNTs);

    // if we are seeking to a particular value for the first time
    if (!pDB->Key.fSearchInProgress) {

        if (fForward) {
            // if this is not a paged search, we start at the beggining of
            // the database records (ulASQLastUpperBound=0)
            if (! (pDB->Key.asqMode & ASQ_PAGED) ) {
                pDB->Key.ulASQLastUpperBound = 0;
                pDB->Key.currRecPos = 1;
            }
            // if this is sorted and paged, we start at the point we were
            // before (ulASQLastUpperBound+1). all the data are in the array
            else if ( (pDB->Key.asqMode == (ASQ_SORTED | ASQ_PAGED)) ) {
                pDB->Key.currRecPos = pDB->Key.ulASQLastUpperBound + 1;
            }
            // this is a paged search. we start at the start of the array
            // and we keep our database position unchanged (ulASQLastUpperBound)
            else {
                pDB->Key.currRecPos = 1;
            }
        }
        else {
            // we cannot do paged results in reverse order, unless
            // we are using sorted results, so we have all the data
            // in memory

            if (pDB->Key.ulASQLastUpperBound == 0 &&
                pDB->Key.cdwCountDNTs != pDB->Key.ulASQLastUpperBound) {
                pDB->Key.ulASQLastUpperBound = pDB->Key.cdwCountDNTs - 1;
            }

            // so if this is not paged, we start at the end of the array
            // otherwise where we left last time
            if (! (pDB->Key.asqMode & ASQ_PAGED) ) {
                pDB->Key.ulASQLastUpperBound = pDB->Key.cdwCountDNTs - 1;
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
            }
            else if ( (pDB->Key.asqMode == (ASQ_SORTED | ASQ_PAGED)) ) {
                pDB->Key.currRecPos = pDB->Key.ulASQLastUpperBound + 1;
            }
            else {
                Assert (!"Reverse ASQ paged search");
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
            }
        }
    }
    else {
        if (fForward) {
            // advance our position on the array and on the database
            pDB->Key.currRecPos++;
            pDB->Key.ulASQLastUpperBound++;

            // if we run out of entries in memory, and we are not doing sorted
            // search, read some more
            if (pDB->Key.currRecPos > pDB->Key.cdwCountDNTs) {
                if (! (pDB->Key.asqMode & ASQ_SORTED) ) {
                    if (err = dbCreateASQTable(pDB,
                                               StartTick,
                                               DeltaTick,
                                               0,
                                               0) ) {

                        return DB_ERR_NEXTCHILD_NOTFOUND;
                    }

                    pDB->Key.currRecPos = 1;
                }
                else {
                    return DB_ERR_NEXTCHILD_NOTFOUND;
                }
            }
        }
        else {
            pDB->Key.currRecPos--;

            // we don't support getting paged results backwards,
            // since we don't know the total number of entries
            // unless we were doing a sorted search
            if (pDB->Key.currRecPos == 0) {
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }

            if (pDB->Key.ulASQLastUpperBound) {
                pDB->Key.ulASQLastUpperBound--;
                pDB->Key.cdwCountDNTs--;
            }
            else {
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
        }
    }

    if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[pDB->Key.currRecPos - 1] )) {
        return err;
    }

    return 0;
}

DWORD
dbMoveToNextSearchCandidateOnIndex(DBPOS *pDB, ULONG Flags)
/*++

Routine Description:

    Move to the next object position on the current index.
    Assumes that we are already positioned on the index.

Arguments:

    same as dbMoveToNextSearchCandidate

Return Values:

    0 if all went well and we found a next candidate, Jet error otherwise.

--*/
{
    DWORD       err;
    JET_TABLEID JetTbl;
    BOOL        fForward = !!(Flags & DB_SEARCH_FORWARD) ^ pDB->Key.fChangeDirection;

    // If this is an exact match query, we know that
    // there was only one record which we have already called
    // so return. We need this because dbMoveToNextSearchCandidatePositionOnIndex
    // does not set an index range for exact match searches.
    if (IsExactMatch(pDB)) {
        return JET_errNoCurrentRecord;
    }
    if (pDB->Key.indexType == ANCESTORS_INDEX_TYPE) {
        // We never go backwards on the ancestors index.
        fForward = TRUE;
    }
    if (pDB->Key.pIndex->pAC && pDB->Key.pIndex->pAC->ulLinkID) {
        JetTbl = pDB->JetLinkEnumTbl;
    } else {
        JetTbl = pDB->JetObjTbl;
    }

    err = JetMoveEx(pDB->JetSessID,
                    JetTbl,
                    (fForward?JET_MoveNext:JET_MovePrevious),
                    0);

    if (pDB->Key.pVLV) {

        Assert (pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN);
        Assert (pDB->Key.pIndex->bIsPDNTBased || pDB->Key.pVLV->bUsingMAPIContainer);

        if (err != JET_errNoCurrentRecord) {


            if ( !dbIsInVLVContainer(pDB, pDB->Key.pVLV->bUsingMAPIContainer ?
                                     pDB->Key.pVLV->MAPIContainerDNT :
                                     pDB->Key.ulSearchRootDnt)) {
                err = JET_errNoCurrentRecord;
            }
        }
    }

    return err;
} // dbMoveToNextSearchCandidateOnIndex

DWORD
dbMoveToNextSearchCandidatePositionOnVLVIndex(
                DBPOS *pDB,
                ULONG Flags
                )
/*++

Routine Description:

    Position on the first candidate on the VLV index.

Arguments:

    pDB - the DBPos to use.

    Flags - flags describing the behaviour.  Values are:
      DB_SEARCH_FORWARD - movement in the database is forward, not backward.

Return Values:

    0 if all went well and we found a next candidate, Jet error otherwise.

--*/

{
    DWORD       err;
    BOOL        fForward = !!(Flags & DB_SEARCH_FORWARD) ^ pDB->Key.fChangeDirection;
    ATTCACHE   *pAC;
    ATTRVAL     seekVal;
    DWORD       start, beforeCount;
    VLV_SEARCH *pVLV = pDB->Key.pVLV;


    Assert (pVLV);
    Assert (pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN);
    Assert (pDB->Key.pIndex->bIsPDNTBased || pDB->Key.pVLV->bUsingMAPIContainer);

    start = GetTickCount();

    // we are looking for a specific value
    if (pVLV->pVLVRequest->fseekToValue) {
        DWORD Denominator, Numerator;
        DWORD BeginDenom, BeginNum, EndDenom, EndNum;
        DWORD ContainerDenominator, ContainerNumerator;
        DWORD ContainerID = pDB->Key.pVLV->bUsingMAPIContainer ?
                                    pDB->Key.pVLV->MAPIContainerDNT :
                                    pDB->Key.ulSearchRootDnt;

        // Get fractional position of beginning
        if (err = dbVlvMove(pDB, DB_MoveFirst, TRUE, ContainerID)) {
            return err;
        }
        DBGetFractionalPosition(pDB, &BeginNum, &BeginDenom);

        // Get fractional position of ending
        if (err = dbVlvMove(pDB, DB_MoveLast, TRUE, ContainerID)) {
            return err;
        }
        DBGetFractionalPosition(pDB, &EndNum, &EndDenom);

        // Normalize the fractions of the fractional position to the average of
        // the two denominators.
        Denominator = (BeginDenom + EndDenom)/2;
        EndNum = MulDiv(EndNum, Denominator - 1, EndDenom - 1) + 1;
        BeginNum = MulDiv(BeginNum, Denominator - 1, BeginDenom - 1) + 1;

        // keep values for later
        ContainerNumerator = BeginNum;
        ContainerDenominator = Denominator;

        // calculate container size, since it might have changed
        pVLV->contentCount = NormalizeIndexPosition (BeginNum, EndNum);

        // we need better content size estimation since this container does not
        // have enough entries
        // note we are positioned in the end of the container
        // NTRAID#NTRAID-590547-2002/03/29-andygo:  PERF:  VLV should use JetIndexRecordCountEx to get size of small containers
        // REVIEW:  we should use JetIndexRecordCountEx inside an index range instead
        // REVIEW:  especially because the estimate could be off by a significant amount
        if (pVLV->contentCount < EPSILON) {
            ULONG newCount=0;
            if (dbIsInVLVContainer(pDB, ContainerID)) {
                newCount=1;

                while ( !(err = dbVlvMove(pDB, DB_MovePrevious, TRUE, ContainerID))) {
                    newCount++;
                }
            }
            pVLV->contentCount = newCount;
        }

        // convert the seek val into internal format
        if (!(pAC = SCGetAttById(pDB->pTHS, pVLV->SortAttr))) {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, pVLV->SortAttr);
        }
        if (gDBSyntax[pAC->syntax].ExtInt(pDB,
                                          DBSYN_INQ,
                                          pVLV->pVLVRequest->seekValue.valLen,
                                          pVLV->pVLVRequest->seekValue.pVal,
                                          &seekVal.valLen,
                                          &seekVal.pVal,
                                          0,
                                          0,
                                          0)) {
            return DB_ERR_UNKNOWN_ERROR;
        }

        // position on the first record that matches our criteria
        //
        // for ascending sorts, we find the first record that has a key which
        // is greater than or equal to the partial column data provided by
        // seekVal
        //
        // for descending sorts, we find the last record that has a key which
        // is less than or equal to the partial column data provided by seekVal
        // such that we will match any keys that share the same initial data
        // as the seekVal.  this enables a search for "C" to place everything
        // that starts with "C" at or below the target entry so that typedown
        // will work as expected
        JetMakeKeyEx(pDB->JetSessID,
                     pDB->JetObjTbl,
                     &ContainerID,
                     sizeof(ContainerID),
                     JET_bitNewKey);

        JetMakeKeyEx(pDB->JetSessID,
                     pDB->JetObjTbl,
                     seekVal.pVal,
                     seekVal.valLen,
                     fForward ? 0 : JET_bitSubStrLimit | JET_bitStrLimit);

        err = JetSeekEx(pDB->JetSessID,
                        pDB->JetObjTbl,
                        fForward ? JET_bitSeekGE : JET_bitSeekLE);

        // if we couldn't find a record then we will position ourself just past
        // the end of the container and we will set our current position to one
        // plus the content count
        if (err == JET_errRecordNotFound || !dbIsInVLVContainer(pDB, ContainerID)) {

            if (err == JET_errRecordNotFound) {
                if (fForward) {
                    JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveLast, 0);
                    JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveNext, 0);
                    pVLV->cbCurrPositionKey = DB_CB_MAX_KEY;
                    memcpy(pVLV->rgbCurrPositionKey, MAX_UPPER_KEY, DB_CB_MAX_KEY);
                } else {
                    JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveFirst, 0);
                    JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MovePrevious, 0);
                    pVLV->cbCurrPositionKey = 0;
                }
            } else {
                // get the key on the current position for later
                pVLV->cbCurrPositionKey = sizeof(pVLV->rgbCurrPositionKey);
                DBGetKeyFromObjTable(pDB,
                                     pVLV->rgbCurrPositionKey,
                                     &pVLV->cbCurrPositionKey);

                // set our error to JET_errRecordNotFound to indicate that we
                // are not in the correct container

                err = JET_errRecordNotFound;
            }

            pVLV->currPosition = pVLV->contentCount + 1;
        }

        // if we could find a record then get the actual fractional position of
        // the current position
        else {
            DBGetFractionalPosition(pDB, &EndNum, &EndDenom);

            DPRINT2 (1, "Found Position: %d / %d \n", EndNum, EndDenom);

            EndNum = MulDiv(EndNum, ContainerDenominator - 1, EndDenom - 1) + 1;

            pVLV->currPosition = NormalizeIndexPosition(ContainerNumerator, EndNum);
            pVLV->currPosition = max(pVLV->currPosition, 1);
            pVLV->currPosition = min(pVLV->currPosition, pVLV->contentCount);

            // adjust our pos depending on the direction of the navigation
            if (!fForward) {
                pVLV->currPosition = pVLV->contentCount - pVLV->currPosition + 1;
            }

            DPRINT2 (1, "Calculated Position: %d / %d \n",
                     pVLV->currPosition, pVLV->contentCount);

            // get the key on the current position for later
            pVLV->cbCurrPositionKey = sizeof (pVLV->rgbCurrPositionKey);
            DBGetKeyFromObjTable(pDB,
                                 pVLV->rgbCurrPositionKey,
                                 &pVLV->cbCurrPositionKey);
        }

        // adjust for the before Count
        beforeCount = 0;
        while (beforeCount < pVLV->pVLVRequest->beforeCount) {
            if (GetTickCount() - start > VLV_TIMEOUT) {
                return DB_ERR_TIMELIMIT;
            }
            if (dbVlvMove(pDB, fForward ? DB_MovePrevious : DB_MoveNext, fForward, ContainerID)) {
                break;
            }
            if (dbMakeCurrent(pDB, NULL) != DIRERR_NOT_AN_OBJECT &&
                dbFObjectInCorrectDITLocation(pDB, pDB->JetObjTbl) &&
                dbFObjectInCorrectNC(pDB, pDB->DNT, pDB->JetObjTbl)) {
                DB_ERR errT;
                BOOL bMatch = FALSE;
                if (errT = DBMatchSearchCriteria(pDB, Flags & DB_SEARCH_DONT_EVALUATE_SECURITY, &bMatch)) {
                    return errT;
                }
                if (bMatch) {
                    beforeCount++;
                }
            }
        }

        if (beforeCount < pVLV->pVLVRequest->beforeCount) {
            pVLV->requestedEntries = beforeCount + 1 + pVLV->pVLVRequest->afterCount;
        }

    }
    else {
        return dbVlvSetFractionalPosition (pDB, Flags);
    }

    return err;
}

DWORD
dbMoveToNextSearchCandidatePositionOnIndex(
                DBPOS *pDB,
                ULONG Flags
                )
/*++

Routine Description:

    Position on the first candidate on the index.

Arguments:

    pDB - the DBPos to use.

    Flags - flags describing the behaviour.  Values are:
      DB_SEARCH_FORWARD - movement in the database is forward, not backward.

Return Values:

    0 if all went well and we found a next candidate, Jet error otherwise.
--*/
{
    BOOL        fForward = !!(Flags & DB_SEARCH_FORWARD) ^ pDB->Key.fChangeDirection;
    ULONG       actuallen;
    DWORD       err = 0;
    JET_TABLEID JetTbl;
    KEY_INDEX * const pIndex = pDB->Key.pIndex;
    CHAR        szIndexName[JET_cbNameMost + 1];

    if (pIndex->pAC && pIndex->pAC->ulLinkID) {
        if (JET_tableidNil == pDB->JetLinkEnumTbl) {
            JetDupCursorEx(pDB->JetSessID,
                            pDB->JetLinkTbl,
                            &pDB->JetLinkEnumTbl,
                            0);
        }
        JetTbl = pDB->JetLinkEnumTbl;
    } else {
        JetTbl = pDB->JetObjTbl;
    }

    if (pDB->Key.pVLV ||
        !IsExactMatch(pDB) ||
        !(Flags & DB_SEARCH_OPT_EXACT_MATCH)) {
        JetSetCurrentIndex4Success(
                    pDB->JetSessID,
                    JetTbl,
                    pIndex->szIndexName,
                    pIndex->pindexid,
                    JET_bitMoveFirst );
    }

#if DBG
    // we should now be on the correct index.  if we aren't then you shouldn't
    // be using DB_SEARCH_OPT_EXACT_MATCH for this search!
    memset(szIndexName, 0, sizeof(szIndexName));
    JetGetCurrentIndexEx(pDB->JetSessID,
                         JetTbl,
                         szIndexName,
                         JET_cbNameMost);
    Assert(!_stricmp(pIndex->szIndexName, szIndexName));
#endif

    if(!strcmp(pIndex->szIndexName, SZANCESTORSINDEX)) {
        pDB->Key.indexType = ANCESTORS_INDEX_TYPE;
        // We never go backwards on the ancestors index.
        fForward = TRUE;
    }
    else if (!strncmp(pIndex->szIndexName, SZTUPLEINDEXPREFIX, (sizeof(SZTUPLEINDEXPREFIX) - 1))) {
        pDB->Key.indexType = TUPLE_INDEX_TYPE;
    }
    else {
        pDB->Key.indexType = GENERIC_INDEX_TYPE;
    }

    // this is a VLV search
    if (pDB->Key.pVLV) {
        Assert(ANCESTORS_INDEX_TYPE != pDB->Key.indexType);
        return dbMoveToNextSearchCandidatePositionOnVLVIndex (pDB, Flags);
    }

    // This is an exact match search
    else if (IsExactMatch(pDB)) {
        if (!(Flags & DB_SEARCH_OPT_EXACT_MATCH)) {
            JetMakeKeyEx(pDB->JetSessID, JetTbl,
                      pIndex->rgbDBKeyLower,
                      pIndex->cbDBKeyLower,
                      JET_bitNormalizedKey);

            return JetSeekEx(pDB->JetSessID, JetTbl,
                             JET_bitSeekEQ);
        }
        else {
            return 0;
        }
    }

    // simple search (non VLV).
    else if(fForward) {
        if (pIndex->cbDBKeyLower) {
            JetMakeKeyEx(pDB->JetSessID, JetTbl,
                         pIndex->rgbDBKeyLower,
                         pIndex->cbDBKeyLower,
                         JET_bitNormalizedKey);

            err = JetSeekEx(pDB->JetSessID, JetTbl,
                            JET_bitSeekGE);
        }
        else {
            err = JetMoveEx(pDB->JetSessID, JetTbl,
                            JET_MoveFirst, 0);
        }

        switch (err) {
        case JET_errSuccess:
        case JET_wrnRecordFoundGreater:
            if(pIndex->cbDBKeyUpper) {
                // Now, set an index range.
#if DBG
                BYTE        rgbKey[DB_CB_MAX_KEY];
                // For the debug case, we're going to do some extra
                // verification.  This is just checking, not necessary
                // for the algorithm.
                JetRetrieveKeyEx(pDB->JetSessID,
                                 JetTbl,
                                 rgbKey,
                                 sizeof(rgbKey),
                                 &actuallen, 0);
#endif

                JetMakeKeyEx(pDB->JetSessID,
                             JetTbl,
                             pIndex->rgbDBKeyUpper,
                             pIndex->cbDBKeyUpper,
                             JET_bitNormalizedKey);
                err = JetSetIndexRangeEx(pDB->JetSessID,
                                         JetTbl,
                                         JET_bitRangeUpperLimit | JET_bitRangeInclusive);
                // The only error we allow here should be
                // nocurrentrecord, and we should only hit it if the
                // key we pulled off the object before the
                // setindexrange is greater than the key we are
                // setting in the index range.
                Assert((err == JET_errSuccess) ||
                       ((err == JET_errNoCurrentRecord) &&
                        (0 < memcmp(
                                rgbKey,
                                pIndex->rgbDBKeyUpper,
                                min(actuallen,pIndex->cbDBKeyUpper)))));

            }
            break;
        default:
            break;
        }
    }
    // moving backwards
    else {
        if(pIndex->cbDBKeyUpper == DB_CB_MAX_KEY &&
           !memcmp(pIndex->rgbDBKeyUpper,
                   MAX_UPPER_KEY, DB_CB_MAX_KEY)) {
            // We are really moving to the last object.
            err = JetMoveEx(pDB->JetSessID, JetTbl,
                            JET_MoveLast, 0);
        }
        else {
            JetMakeKeyEx(pDB->JetSessID, JetTbl,
                         pIndex->rgbDBKeyUpper,
                         pIndex->cbDBKeyUpper,
                         JET_bitNormalizedKey);

            err = JetSeekEx(pDB->JetSessID, JetTbl,
                            JET_bitSeekLE);
        }

        switch (err) {
        case JET_errSuccess:
        case JET_wrnRecordFoundLess:
            if(pIndex->cbDBKeyLower) {
                // Now, set an index range.
#if DBG
                BYTE        rgbKey[DB_CB_MAX_KEY];
                // For the debug case, we're going to do some extra
                // verification.  This is just checking, not necessary
                // for the algorithm.
                JetRetrieveKeyEx(pDB->JetSessID,
                                 JetTbl,
                                 rgbKey,
                                 sizeof(rgbKey),
                                 &actuallen, 0);
#endif


                JetMakeKeyEx(pDB->JetSessID,
                             JetTbl,
                             pIndex->rgbDBKeyLower,
                             pIndex->cbDBKeyLower,
                             JET_bitNormalizedKey);

                err = JetSetIndexRangeEx(pDB->JetSessID,
                                         JetTbl,
                                         JET_bitRangeInclusive);
                // The only error we allow here should be
                // nocurrentrecord, and we should only hit it if the
                // key we pulled off the object before the
                // setindexrange is greater than the key we are
                // setting in the index range.
                Assert((err == JET_errSuccess) ||
                       ((err == JET_errNoCurrentRecord) &&
                        (0 > memcmp(
                                rgbKey,
                                pIndex->rgbDBKeyLower,
                                min(actuallen,pIndex->cbDBKeyLower)))));
            }
            break;

        default:
            break;
        }

    } // forward / backward

    return err;
} // dbMoveToNextSearchCandidatePositionOnIndex

DWORD
dbMoveToNextSearchCandidate (
        DBPOS *pDB,
        ULONG Flags,
        DWORD StartTick,
        DWORD DeltaTick
        )
/*++

Routine Description:

    Move to the next object on the current index which is a potential search
    result item. Movement is done one object at a time on the current index
    unless otherwise specified (see Flags below).

Arguments:

    pDB - the DBPos to use.

    Flags - flags describing the behaviour.  Values are:

      DB_SEARCH_FORWARD - movement in the database is forward, not backward.

    StartTick - if !0, specifies a time limit is in effect, and this is the tick
            count when the call was started.
    DeltaTick - if a time limit is in effect, this is the maximum number of
            ticks past StartTick to allow.

Return Values:

    0 if all went well and we found a next candidate, DB_ERR_NEXTCHILD_NOTFOUND
    if no next candidate could be found.


--*/
{
    THSTATE    *pTHS=pDB->pTHS;
    JET_ERR     err = 0;
    JET_TABLEID JetTbl;
    ULONG       PDNT;
    BOOL        fForward = !!(Flags & DB_SEARCH_FORWARD) ^ pDB->Key.fChangeDirection;
    KEY_INDEX  *pTempIndex;
    BOOL        fFirst = TRUE;


    unsigned char rgbBookmark[JET_cbBookmarkMost];
    unsigned long cbBookmark;

    Assert(VALID_DBPOS(pDB));

    pDB->Key.bOnCandidate = FALSE;
    Assert(pDB->Key.indexType != INVALID_INDEX_TYPE);

    if (pDB->Key.ulSearchType == SE_CHOICE_BASE_ONLY && !pDB->Key.asqRequest.fPresent) {
        if (pDB->Key.fSearchInProgress) {
            Assert(pDB->Key.indexType == GENERIC_INDEX_TYPE);
            // Hey, this is a base object search, and we're already in
            // progress.  Therefore, we have already looked at the base and
            // there is nothing more to do.
            return DB_ERR_NEXTCHILD_NOTFOUND;
        }
        else {
            // Don't need all the stuff here, just seek to the base
            DBFindDNT(pDB, pDB->Key.ulSearchRootDnt);

            pDB->Key.fSearchInProgress = TRUE;
            Assert(pDB->Key.indexType == UNSET_INDEX_TYPE);
            pDB->Key.indexType = GENERIC_INDEX_TYPE;
            pDB->Key.bOnCandidate = TRUE;
            pDB->Key.fChangeDirection = FALSE;

            pTHS->pDB->SearchEntriesVisited++;
            PERFINC(pcSearchSubOperations);

            return 0;
        }
    }

    while (TRUE) { // Do this always

        if(   eServiceShutdown
           && !(   (eServiceShutdown == eRemovingClients)
                && (pTHS->fDSA)
                && !(pTHS->fSAM))) {
            // Shutting down, bail.
            return DB_ERR_NEXTCHILD_NOTFOUND;
        }
        if(!fFirst) {
            // OK, we've been through at least once, so we made some kind of
            // progress.  See if we hit a time limit.
            if(StartTick) {       // There is a time limit
                if((GetTickCount() - StartTick) > DeltaTick) {
                    return DB_ERR_TIMELIMIT;
                }
            }
        }
        fFirst = FALSE;


        // First, position on the next candidate object.  There are three cases:
        // 1) moving in a temp table or a intersected table
        //    a) sorted or sorted/paged search from a sort table        OR
        //    b) ASQ search without VLV                                 OR
        //    c) VLV or ASQ/VLV                                         OR
        //    d) sorted or sorted/paged search from an in memory array  OR
        //    e) intersected table
        //
        // 2) search in progress, we've already got an index, just move to the
        //        next object on the index
        //
        // 3) no search in progress, we need to set to the correct index and
        //        seek to the first object.

        if(pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE) {
            // CASE 1a: We're moving in a sort table.
            DWORD DNT, dwMove, cbActual;

            // We have a sort table we're using
            dwMove = (pDB->Key.fSearchInProgress?JET_MoveNext:JET_MoveFirst);

            do {
                // First, move in the sort table
                err = JetMoveEx(pDB->JetSessID,
                                pDB->JetSortTbl,
                                dwMove,
                                0);
                if(err) {
                    // end of sort table
                    return DB_ERR_NEXTCHILD_NOTFOUND;
                }

                dwMove = JET_MoveNext;

                // OK, pull the DNT out of the sort table
                DBGetDNTSortTable (
                        pDB,
                        &DNT);

                // Now move to that DNT in the object table
            } while(DBTryToFindDNT(pDB, DNT));
        }
        else if (pDB->Key.indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE) {

            if (pDB->Key.asqRequest.fPresent && !pDB->Key.pVLV) {
                // CASE 1b: this is an ASQ search without combining VLV
                // so it is either simple, sorted or paged

                if (err = dbMoveToNextSearchCandidateOnASQ (pDB,
                                                            Flags,
                                                            StartTick,
                                                            DeltaTick)) {
                    return DB_ERR_NEXTCHILD_NOTFOUND;
                }
            }
            else if (pDB->Key.pVLV) {
                // CASE 1c: We're moving in a InMemory sorted table.
                // this is either VLV or VLV/ASQ

                if (err = dbMoveToNextSearchCandidateOnInMemoryTempTable(pDB, Flags,
                                                                         StartTick,
                                                                         DeltaTick)) {
                    return DB_ERR_NEXTCHILD_NOTFOUND;
                }
            }
            else {
                // CASE 1d: We're moving in a InMemory sorted table holding a
                // sorted or sorted/paged search
                DWORD   DNT;
                BOOL    fSearchInProgress;

                fSearchInProgress = pDB->Key.fSearchInProgress;

                do {
                    if (fSearchInProgress) {
                        pDB->Key.currRecPos++;
                    }
                    else {
                        pDB->Key.currRecPos = 1;
                    }

                    if (pDB->Key.currRecPos > pDB->Key.cdwCountDNTs) {
                        pDB->Key.currRecPos = pDB->Key.cdwCountDNTs + 1;
                        return DB_ERR_NEXTCHILD_NOTFOUND;
                    }

                    fSearchInProgress = TRUE;

                    DNT = pDB->Key.pDNTs[pDB->Key.currRecPos - 1];
                } while(DBTryToFindDNT(pDB, DNT));
            }
        }
        else if (pDB->Key.pIndex && pDB->Key.pIndex->bIsIntersection) {
            // CASE 1e: We're moving in a intersected table.

            if (pDB->Key.indexType == UNSET_INDEX_TYPE) {

                err = JetMoveEx( pDB->JetSessID, pDB->Key.pIndex->tblIntersection,
                                 JET_MoveFirst, 0 );

                pDB->Key.indexType = INTERSECT_INDEX_TYPE;
            }
            else {

                err = JetMoveEx(pDB->JetSessID, pDB->Key.pIndex->tblIntersection,
                                JET_MoveNext, 0);
            }

            if (err == JET_errSuccess) {
                JetRetrieveColumnSuccess(
                                    pDB->JetSessID,
                                    pDB->Key.pIndex->tblIntersection,
                                    pDB->Key.pIndex->columnidBookmark,
                                    rgbBookmark,
                                    sizeof( rgbBookmark ),
                                    &cbBookmark,
                                    0,
                                    NULL);

                if (pDB->Key.pIndex->pAC && pDB->Key.pIndex->pAC->ulLinkID) {
                    JetTbl = pDB->JetLinkEnumTbl;
                } else {
                    JetTbl = pDB->JetObjTbl;
                }

                JetGotoBookmarkEx(pDB->JetSessID,
                                  JetTbl,
                                  rgbBookmark,
                                  cbBookmark );
            }
        }
        else if (pDB->Key.fSearchInProgress) {
            Assert(pDB->Key.indexType != INVALID_INDEX_TYPE);
            Assert(pDB->Key.indexType != UNSET_INDEX_TYPE);
            Assert(pDB->Key.indexType != TEMP_TABLE_INDEX_TYPE);

            // Case 2) Normal case of looking for the next search candidate.
            err = dbMoveToNextSearchCandidateOnIndex(pDB, Flags);
        }
        else {
            Assert(pDB->Key.indexType == UNSET_INDEX_TYPE || pDB->Key.pVLV);

            // Case 3) Looking for the very first search candidate on this index.
            err = dbMoveToNextSearchCandidatePositionOnIndex(pDB, Flags);
        }


        switch (err) {
        case JET_errSuccess:
        case JET_wrnRecordFoundGreater:
            break;

        case JET_errNoCurrentRecord:
        case JET_errRecordNotFound:
            // We didn't find anymore children on this index.  If we have more
            // indices, continue the search using the next index.
            if(pDB->Key.pIndex && pDB->Key.pIndex->pNext) {
                // Yep, more indices
                pTempIndex = pDB->Key.pIndex;
                pDB->Key.pIndex = pDB->Key.pIndex->pNext;
                pTempIndex->pNext = NULL;
                dbFreeKeyIndex(pTHS, pTempIndex);
                pDB->Key.fSearchInProgress = FALSE;
                pDB->Key.indexType = UNSET_INDEX_TYPE;

                continue;
            }
            else {
                // Nope, no more indices.  We're done.
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }

        default:
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }


#if DBG
        // We've moved to an object,  Let's verify that it's in range.
        if(!SORTED_INDEX (pDB->Key.indexType) &&
           !pDB->Key.pIndex->bIsIntersection) {
            BYTE        rgbKey[DB_CB_MAX_KEY];
            int         compareResult;
            ULONG       cb;
            ULONG       actuallen;

            Assert(pDB->Key.pIndex);

            if (pDB->Key.pIndex->pAC && pDB->Key.pIndex->pAC->ulLinkID) {
                JetTbl = pDB->JetLinkEnumTbl;
            } else {
                JetTbl = pDB->JetObjTbl;
            }

            // We are using an index of some nature, not the JetSortTable.
            // Lets verify that we're in the right portion of the index.
            JetRetrieveKeyEx(pDB->JetSessID,
                             JetTbl,
                             rgbKey,
                             sizeof(rgbKey),
                             &actuallen, 0);

            // check that key is in range
            // NTRAID#NTRAID-591459-2002/04/01-andygo:  should improve assert in dbMoveToNextSearchCandidate that checks that the current record is in the index range
            // REVIEW:  we should also check against the lower key because we may
            // REVIEW:  be moving backwards
            cb = min(actuallen,pDB->Key.pIndex->cbDBKeyUpper);
            compareResult = memcmp(rgbKey, pDB->Key.pIndex->rgbDBKeyUpper, cb);
            Assert(compareResult <= 0);
        }
#endif

        // At this point, we've moved to an object that is definitely in the
        // correct place in the index that we are currently walking.
        pDB->Key.fSearchInProgress = TRUE;
        Assert(pDB->Key.indexType != UNSET_INDEX_TYPE);
        Assert(pDB->Key.indexType != INVALID_INDEX_TYPE);

        if (pDB->Key.pIndex &&
            pDB->Key.pIndex->pAC &&
            pDB->Key.pIndex->pAC->ulLinkID) {
            JET_COLUMNID    colidDNT;
            DWORD           DNT;

            if (FIsBacklink(pDB->Key.pIndex->pAC->ulLinkID)) {
                colidDNT = linkdntid;
            } else {
                colidDNT = backlinkdntid;
            }

            JetRetrieveColumnSuccess(pDB->JetSessID,
                                    pDB->JetLinkEnumTbl,
                                    colidDNT,
                                    &DNT,
                                    sizeof(DNT),
                                    NULL,
                                    JET_bitRetrieveFromIndex,
                                    NULL);

            if (DBTryToFindDNT(pDB, DNT)) {
                DPRINT1(2, "dbMoveToNextSearchCandidate failed to set currency, err %d\n",err);
                Assert(!"dbMoveToNextSearchCandidate failed to set currency\n");
                return DB_ERR_UNKNOWN_ERROR;
            }
        }

        pDB->SearchEntriesVisited++;
        PERFINC(pcSearchSubOperations);

        if(DIRERR_NOT_AN_OBJECT == dbMakeCurrent(pDB, NULL)) {
            // Hey, we're not really on an object, so this can't be a candidate
            // unless we are doing ASQ

            if (pDB->Key.asqRequest.fPresent) {
                if (!pDB->Key.asqRequest.Err) {
                    pDB->Key.asqRequest.Err = LDAP_AFFECTS_MULTIPLE_DSAS;
                }
                // this error will bubble all the way up
                // where the current DNT will treated as a referral
                return DB_ERR_NOT_AN_OBJECT;
            }
            else {
                continue;
            }
        }

        if((!(Flags & DB_SEARCH_DELETIONS_VISIBLE)) && // Not interested in
                                                       // deleted objects.
           (DBIsObjDeleted(pDB))) {
            // Don't want deleted objects.
            if(pDB->Key.indexType == ANCESTORS_INDEX_TYPE) {
                // This the ancestors index.  Since we don't allow children of
                // deleted objects, skip the subtree here.
                dbAdjustCurrentKeyToSkipSubtree(pDB);

                // there is the posibility of bailing out this function due to a time
                // limit in a paged search operation, leaving partialy complete KEY_INDEX.
                // this way we force one more loop so as to fix things.
                fFirst = TRUE;
            }
            // ELSE,
            //    Just continue and get the next object.
            continue;
        }

        // ok. we have an object. if we are doing ASQ search and we are a GC
        // we want to know if we have the full info for this object, otherwise
        // we will return a referral
        //
        if (pDB->Key.asqRequest.fPresent &&
            !dbIsObjectLocal(pDB, pDB->JetObjTbl)) {


            if (pDB->Key.asqRequest.fMissingAttributesOnGC || pDB->Key.bOneNC) {
                DPRINT (1, "ASQ: found an entry that was missing attributes due to GCness\n");

                if (!pDB->Key.asqRequest.Err) {
                    pDB->Key.asqRequest.Err = LDAP_AFFECTS_MULTIPLE_DSAS;
                }

                if (pDB->Key.bOneNC) {
                    //
                    // We didn't come in through the GC port so this object
                    // shouldn't be visible at all.
                    // this error will bubble all the way up
                    // where the current DNT will treated as a referral
                    //
                    return DB_ERR_NOT_AN_OBJECT;
                }
            }

        }

        // Ok, at this point we've found an object that seems to be in
        // the correct portion of whatever index we are walking, and is really
        // an object, and is appropriately deleted.  Next, we verify location.
        // In the sort table, we already trimmed out any objects that weren't in
        // the correct DIT location, so don't bother rechecking.
        if(SORTED_INDEX (pDB->Key.indexType) ||
           dbFObjectInCorrectDITLocation(pDB, pDB->JetObjTbl) ) {

            // One more check.  Is the object in the correct NC?
            if(!dbFObjectInCorrectNC(pDB, pDB->DNT, pDB->JetObjTbl)) {
                // Wrong Naming Context.  Skip this object, look at the next
                // object. Note that we explicitly don't skip siblings, as
                // we are interested in the next sibling of this object.

                if(pDB->Key.indexType == ANCESTORS_INDEX_TYPE) {
                    // In the case of walking the ancestors index, we skip
                    // entire subtrees.  This should bring us to the next
                    // sibling of this object, skipping all descendants of this
                    // object.
                    dbAdjustCurrentKeyToSkipSubtree(pDB);

                    // there is the posibility of bailing out this function due to a time
                    // limit in a paged search operation, leaving partialy complete KEY_INDEX.
                    // this way we force one more loop so as to fix things.
                    fFirst = TRUE;
                }
                continue;
            }

            // Yes, the object is in the correct NC.
            // This is the success return path for this routine.
            pDB->Key.bOnCandidate = TRUE;
            return 0;
        }

        // We found an object that was in the correct part of the index we are
        // walking, but it wasn't in the correct location in the DIT.  This
        // can't happen if we're walking a PDNT based index.  So, assert that we
        // are either using a temp table or that the index we are using is NOT
        // PDNT based.
        Assert(pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE ||
               !pDB->Key.pIndex->bIsPDNTBased);
    } // while (TRUE)
} // dbMoveToNextSearchCandidate

SIZE_T
dbSearchDuplicateHashDNT(
    IN      ULONG*  pDNT
    )
{
    return *pDNT;
}

BOOLEAN
dbSearchDuplicateCompareDNTs(
    IN      ULONG*  pDNT1,
    IN      ULONG*  pDNT2
    )
{
    return *pDNT1 == *pDNT2;
}

PVOID
dbSearchDuplicateAlloc(
    IN      SIZE_T  cbAlloc
    )
{
    return THAlloc((DWORD)cbAlloc);
}

VOID
dbSearchDuplicateFree(
    IN      PVOID   pvAlloc
    )
{
    THFree(pvAlloc);
}

VOID
dbSearchDuplicateCreateHashTable(
    IN      PLHT*   pplht
    )
{
    LHT_ERR err;

    err = LhtCreate(
            sizeof( ULONG ),
            (LHT_PFNHASHKEY)dbSearchDuplicateHashDNT,
            (LHT_PFNHASHENTRY)dbSearchDuplicateHashDNT,
            (LHT_PFNENTRYMATCHESKEY)dbSearchDuplicateCompareDNTs,
            NULL,
            0,
            0,
            (LHT_PFNMALLOC)dbSearchDuplicateAlloc,
            (LHT_PFNFREE)dbSearchDuplicateFree,
            0,
            pplht);
    if (err != LHT_errSuccess) {
        Assert(err == LHT_errOutOfMemory);
        RaiseDsaExcept(
            DSA_MEM_EXCEPTION,
            0,
            0,
            DSID(FILENO, __LINE__),
            DS_EVENT_SEV_MINIMAL);
    }
}


DB_ERR
dbFIsSearchDuplicate(
    IN  DBPOS *pDB,
    OUT BOOL  *pbIsDup)
{
    DB_ERR      dbErr;
    void        *pv;
    ULONG       cb;
    UCHAR       operation;
    UCHAR       syntax;
    ATTCACHE * pAC;
    DWORD       i;
    LHT_ERR     errLHT;
    LHT_POS     posLHT;

    Assert(VALID_DBPOS(pDB));

    // If we are using a temp table, we better be doing a DUP_NEVER style
    // duplicate detection algorithm. Temp table searches are never duplicate,
    // the temp table is set up to forbid them.

    Assert(pDB->Key.indexType != TEMP_TABLE_INDEX_TYPE ||
           (pDB->Key.dupDetectionType == DUP_NEVER));

    // Base object  searches are never duplicate, the method of finding them
    // guarantees it.  So, we'd better be using a DUP_NEVER style duplicate
    // detection algorithm.
    Assert((pDB->Key.ulSearchType != SE_CHOICE_BASE_ONLY) ||
           (pDB->Key.dupDetectionType == DUP_NEVER));

    switch(pDB->Key.dupDetectionType) {
    case DUP_NEVER:
        // We believe that we will never find a duplicate, so just return FALSE;
        *pbIsDup = FALSE;
        return DB_success;
        break;

    case DUP_HASH_TABLE:
        // we are tracking duplicates via a hash table.  Try to insert the DNT
        // into the hash table.  If the insert fails with key duplicate then
        // we know that we have seen this DNT before.
        errLHT = LhtFindEntry(
                    pDB->Key.plhtDup,
                    &pDB->DNT,
                    &posLHT);
        if (errLHT == LHT_errSuccess) {
            *pbIsDup = TRUE;
            return DB_success;
        } else {
            errLHT = LhtInsertEntry(
                        &posLHT,
                        &pDB->DNT);
            if (errLHT == LHT_errSuccess) {
                *pbIsDup = FALSE;
                return DB_success;
            } else {
                Assert(errLHT == LHT_errOutOfMemory);
                RaiseDsaExcept(
                    DSA_MEM_EXCEPTION,
                    0,
                    0,
                    DSID(FILENO, __LINE__),
                    DS_EVENT_SEV_MINIMAL);
                return DB_ERR_UNKNOWN_ERROR;
            }
        }
        break;

    case DUP_MEMORY:
        // We are tracking duplicates via a block of memory.  See if the DNT is
        // in the block.
        for(i=0;i<pDB->Key.cDupBlock;i++) {
            if(pDB->Key.pDupBlock[i] == pDB->DNT) {
                // It's a duplicate
                *pbIsDup = TRUE;
                return DB_success;
            }
        }

        // OK, it's not in the block.  Add it.
        // First, is the block full?
        if(pDB->Key.cDupBlock == DUP_BLOCK_SIZE) {
            // Yes, so create a hash table and transfer all the DNTs we already
            // have to the hash table
            dbSearchDuplicateCreateHashTable(&pDB->Key.plhtDup);

            for(i=0;i<pDB->Key.cDupBlock;i++) {
                errLHT = LhtFindEntry(
                            pDB->Key.plhtDup,
                            &pDB->Key.pDupBlock[i],
                            &posLHT);
                Assert( errLHT == LHT_errEntryNotFound );
                errLHT = LhtInsertEntry(
                            &posLHT,
                            &pDB->Key.pDupBlock[i]);
                if (errLHT != LHT_errSuccess) {
                    Assert(errLHT == LHT_errOutOfMemory);
                    RaiseDsaExcept(
                        DSA_MEM_EXCEPTION,
                        0,
                        0,
                        DSID(FILENO, __LINE__),
                        DS_EVENT_SEV_MINIMAL);
                }
            }

            THFreeEx(pDB->pTHS, pDB->Key.pDupBlock);
            pDB->Key.pDupBlock = NULL;
            pDB->Key.cDupBlock = 0;

            // Mark that we are tracking via a hash table now.
            pDB->Key.dupDetectionType = DUP_HASH_TABLE;

            // recurse (once) to add this object (the one that caused the
            // overflow) to the hash table
            return dbFIsSearchDuplicate(pDB, pbIsDup);
        }
        else {
            // No, the block still has room.
            pDB->Key.pDupBlock[pDB->Key.cDupBlock] = pDB->DNT;
            pDB->Key.cDupBlock++;
        }
        *pbIsDup = FALSE;
        return DB_success;
        break;

    default:
        Assert(!"Dup_Detection type unknown!");
        // Huh?
        return DB_ERR_UNKNOWN_ERROR;
    }
} // dbFIsSearchDuplicate

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Determine if the object was deleted by getting the deletion attribute*/
BOOL
DBIsObjDeleted(DBPOS *pDB)
{
    UCHAR  syntax;
    ULONG  len;
    BOOL   Deleted;

    Assert(VALID_DBPOS(pDB));

    if (DBGetSingleValue(pDB, ATT_IS_DELETED, &Deleted, sizeof(Deleted),NULL) ||
        Deleted == FALSE) {
        return FALSE;
    }

    return TRUE;

}/*IsObjDeleted*/

BOOL
dbIsOKForSort (
        DBPOS *pDB
        )
{
    if(!pDB->Key.ulSorted ||
       // We're not sorted.
       SORTED_INDEX (pDB->Key.indexType)) {
       // We are sorted, but it's a temp table sort, which has already been
       // checked.
        return TRUE;
    }

    // We better have the boolean that controls sorting
    Assert(pDB->Key.pbSortSkip);
    Assert(pDB->Key.pIndex);

    // If this is the index for the sort order, then we should skip objects that
    // have no value.  If this isn't the index for the sort, it's the indices
    // designed to pick up NULLs, so we shouldn't skip objects that have no
    // value.

    if (pDB->Key.pIndex->bIsForSort) {
        return !(*(pDB->Key.pbSortSkip));
    } else {
        return TRUE;
    }
}

DB_ERR
DBMatchSearchCriteria (
        DBPOS FAR *pDB,
        BOOL  fDontEvaluateSecurity,
        BOOL *pbIsMatch)
/*++

Routine Description:

    Apply the filter specified in the Key in the pDB to the current object.
    Also, apply security and object checks (i.e. a real object?)
    Returns TRUE if the current object matches all these search criteria.  Also,
    loads the security descriptor of the object if asked and if the object
    matches the search criteria.

Parameters:

    pDB - The DBPOS to use.

    fDontEvaluateSecurity - do we need to skip evaluating security for this object?
    If FALSE, then the SD is loaded and left in pDB->pSecurity.

    pbIsMatch - If no error, then set to TRUE if object matches
    search criteria. FALSE if not. If TRUE and ppSecurity != NULL,
    then *ppSecurity is set to a pointer to a THAlloced buffer
    holding the Security Descriptor used in the evaluation.

Return Values:
    DB_success if all went well. *pbIsMatch is set to
        FALSE if the current object cannot be found to match the search criteria.
        TRUE if it can.  If TRUE and fEvaluateSecurity == TRUE, then pDB->pSecurity
        is set to a pointer to the Security Descriptor used in the evaluation.
    DB_ERR_xxx and *pbIsMatch is undefined.

--*/
{
    THSTATE *pTHS=pDB->pTHS;
    DWORD err;
    DSNAME TempDN;
    DWORD cbNTSD;
    CLASSCACHE *pCC=NULL;
    BOOL returnVal;
    char objFlag;

    Assert(VALID_DBPOS(pDB));

    // try to use the DN cache to retrieve vital fields.
    if (pTHS->fDRA || pTHS->fDSA || fDontEvaluateSecurity) {
        // only need to check if it's a phantom
        err = DBGetObjectSecurityInfo(
                pDB,
                pDB->DNT,
                NULL,
                NULL,
                NULL,
                NULL,
                &objFlag,
                DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                NULL
            );
    }
    else {
        // need to grab all data
        if (!pDB->fSecurityIsGlobalRef && pDB->pSecurity != NULL) {
            THFreeEx(pTHS, pDB->pSecurity);
        }
        pDB->pSecurity = NULL;
        err = DBGetObjectSecurityInfo(
                pDB,
                pDB->DNT,
                &cbNTSD,
                &pDB->pSecurity,
                &pCC,
                &TempDN,
                &objFlag,
                DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                &pDB->fSecurityIsGlobalRef
            );
    }

    if (err || objFlag == 0) {
        // A phantom never matches the search criteria.
        if (!fDontEvaluateSecurity) {
            if (!pDB->fSecurityIsGlobalRef && pDB->pSecurity != NULL) {
                THFreeEx(pTHS, pDB->pSecurity);
            }
            pDB->pSecurity = NULL;
        }

        *pbIsMatch = FALSE;
        return err;
    }

    err = DB_success;
    // REVIEW:  we should be using SORTED_INDEX() here but unsorted ASQ searches
    // REVIEW:  use TEMP_TABLE_MEMORY_ARRAY_TYPE but do not prefilter their results.
    // REVIEW:  other users of TEMP_TABLE_MEMORY_ARRAY_TYPE end up getting filtered
    // REVIEW:  twice because of this.  of course, this also enables us to refilter objects
    // REVIEW:  after a restart which may not be a bad idea in case someone denies us
    // REVIEW:  access to one of the filtered attr values in the mean time
    if(pDB->Key.ulSorted && pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE) {
        // In this case, we've already checked filter security, checked the OK
        // for Sort stuff, evaluated the security, and checked for duplicates.
        returnVal = TRUE;
    }
    else {
        TRIBOOL retfil = eFALSE;

        if ( fDontEvaluateSecurity || (dbEvalFilterSecurity(pDB, pCC, pDB->pSecurity, &TempDN))) {
            if (dbIsOKForSort(pDB)
                && ((retfil = DBEvalFilter(pDB, FALSE, pDB->Key.pFilter)) == eTRUE)) {

                err = dbFIsSearchDuplicate(pDB, &returnVal);
                returnVal = !returnVal;
            }
            else {
                returnVal = FALSE;
            } // Complex If Statement
        } else {
           returnVal = FALSE;
        }// dbEvalFilterSecurity

        Assert (VALID_TRIBOOL(retfil));
    }

    if(pDB->pSecurity && ((!returnVal) || (err != DB_success))) {
        // I got them a security descriptor, but this doesn't match the search
        // criteria  so they can't want the SD I found, so free it.
        if (!pDB->fSecurityIsGlobalRef) {
            THFreeEx(pDB->pTHS, pDB->pSecurity);
        }
        pDB->pSecurity = NULL;
    }

    *pbIsMatch = returnVal;
    return err;
}

BOOL
dbMatchSearchCriteriaForSortedTable (
        DBPOS *pDB,
        BOOL  *pCanRead
        )
/*++

Routine Description:

    Apply the filter specified in the Key in the pDB to the current object.
    Returns TRUE if the current object matches all these search criteria.

    Assumptions: The object we are interested in is on the pDB->ObjTable
                 pDB->DNT
                 pDB->PDNT are pointing to the right values.

Parameters:

    pDB - The DBPOS to use.
    pCanRead - TRUE is the sorted attribute can be read, FALSE otherwise

Return Values:

    FALSE if the current object cannot be found to match the search criteria.
    TRUE if it can.

--*/
{
    ATTRTYP              class;
    JET_ERR              err;
    DSNAME               TempDN;
    PSECURITY_DESCRIPTOR pSec=NULL;
    DWORD                sdLen;
    THSTATE             *pTHS=pDB->pTHS;
    CLASSCACHE          *pCC=NULL;
    BOOL                 returnVal;
    TRIBOOL              retfil;
    BOOL                 fSDIsGlobalSDRef;

    Assert(VALID_DBPOS(pDB));

    if(pTHS->fDRA || pTHS->fDSA) {
        *pCanRead = TRUE;

        returnVal = ((retfil = DBEvalFilter(pDB, FALSE, pDB->Key.pFilter)) == eTRUE);

        Assert (VALID_TRIBOOL(retfil));

        return returnVal;
    }

    // check to see whether the object is visible by security
    // otherwise there is no meaning putting the object on the
    // sorted table just to throw it away later
    // PERFHINT: this can be optimized since we are reading the SD in two places
    if(!IsObjVisibleBySecurity(pDB->pTHS, TRUE)) {
        DPRINT (1, "Got an object not visible by security in a sorted search\n");
        *pCanRead = FALSE;
        return FALSE;
    }

    // get SD, Sid, Guid and class
    err = DBGetObjectSecurityInfo(
            pDB,
            pDB->DNT,
            &sdLen,
            &pSec,
            &pCC,
            &TempDN,
            NULL,
            DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
            &fSDIsGlobalSDRef
        );
    if (err || sdLen == 0) {
        // something bad happened or no SD...
        return FALSE;
    }

    // OK, got the data, now make the check.
    retfil = eFALSE;
    returnVal = (dbEvalFilterSecurity(pDB, pCC, pSec, &TempDN) &&
                 ((retfil = DBEvalFilter(pDB, FALSE, pDB->Key.pFilter)) == eTRUE));

    Assert (VALID_TRIBOOL(retfil));

    if (pSec && !fSDIsGlobalSDRef) {
        THFreeEx(pTHS, pSec);
    }

    if(!returnVal) {
        *pCanRead=FALSE;
    }
    else {
        *pCanRead = !(*pDB->Key.pbSortSkip);
    }

    return returnVal;
}

DWORD
DBGetNextSearchObject (
        DBPOS *pDB,
        DWORD StartTick,
        DWORD DeltaTick,
        ULONG Flags)
/*++

Routine Description:

    Find the next search object.  This finds objects on the current index,
    applying the filter given.

    Moves to the next object which matches search criteria.  On a non-error
    return from this routine, we have moved forward in whatever index we are
    using to support this search, checked a filter (using security if any should
    be applied), checked for real objectness (not a phantom, deleted only if
    asked, etc.).

    On an error return of DB_ERR_TIMELIMIT, we have at least moved forward,
    although we might not be on a search candidate if the time limit was
    triggered inside of dbMoveToNextSearchCandidate.  We have NOT checked to see
    if we matched the search criteria.  So, if someone ends up repositioning to
    here via a paged search, we need to check the candidacy and then the
    search criteria.


Arguments:
    pDB - the DBPOS to use.
    StartTick - if !0, specifies a time limit is in effect, and this is the tick
            count when the call was started.
    DeltaTick - if a time limit is in effect, this is the maximum number of
            ticks past StartTick to allow.
    flags - Flags affecting search behaviour.  May be any combination of the
            following:
            DB_SEARCH_DELETIONS_VISIBLE         1
            DB_SEARCH_FORWARD                   2
            DB_SEARCH_DONT_EVALUATE_SECURITY    4
            DB_SEARCH_OPT_EXACT_MATCH           8


Return Values:
    0 if all went well, an error code otherwise:
        DB_ERR_TIMELIMIT
        DB_ERR_NEXTCHILD_NOTFOUND
        DB_ERR_NOT_AN_OBJECT

--*/
{
    ULONG       actuallen;
    DWORD       dwStatus;
    BOOL        bIsMatch;

    DPRINT(3,"DBGetNextSearchObject entered\n");

    Assert(VALID_DBPOS(pDB));

    if (!(Flags & DB_SEARCH_DONT_EVALUATE_SECURITY)) {
        // start by losing the current SD
        if (!pDB->fSecurityIsGlobalRef && pDB->pSecurity) {
            THFreeEx(pDB->pTHS, pDB->pSecurity);
        }
        pDB->pSecurity = NULL;
    }

    while (TRUE) {
        if (dwStatus =
            dbMoveToNextSearchCandidate(pDB, Flags, StartTick, DeltaTick)) {
            // Something wrong in finding the next search candidate.
            return dwStatus;
        }

        // We are on a candidate
        Assert(pDB->Key.bOnCandidate);

        // Base searches should never have a reason to time out.  Therefore
        // don't bother checking for timeout here if it's a base search.  For
        // any other search check for timeout if there is a timelimit.
        // REVIEW:  why is this the one and only place where we except ASQ searches?  shouldn't
        // REVIEW:  we also except the check in dbMoveToNextSearchCandidate and the checks in
        // REVIEW:  dbCreateASQTable as well?
        if(pDB->Key.ulSearchType != SE_CHOICE_BASE_ONLY &&
           !pDB->Key.asqRequest.fPresent                &&
           StartTick) {
            if((GetTickCount() - StartTick) > DeltaTick) {
                return DB_ERR_TIMELIMIT;
            }
        }

        // OK, we found something, and didn't hit a time limit. See if this is a
        // good object.
        dwStatus = DBMatchSearchCriteria(pDB, Flags & DB_SEARCH_DONT_EVALUATE_SECURITY, &bIsMatch);

        if (DB_success != dwStatus) {
            return dwStatus;
        }
        if(bIsMatch) {

            // This candidate matches the criteria.  It is no longer a
            // candidate, it is a real search object.

            return 0;
        }
    }
}/*DBGetNextSearchObject*/

DWORD APIENTRY
DBRepositionSearch (
        DBPOS FAR *pDB,
        PRESTART pArgRestart,
        DWORD StartTick,
        DWORD DeltaTick,
        ULONG Flags
        )
/*++

  Hand unmarshall the data packed into the restart arg

--*/
{
    ULONG       ulDnt;
    JET_ERR     err;
    JET_TABLEID JetTbl;
    ULONG       actuallen;
    BYTE        pDBKeyBMCurrent[DB_CB_MAX_KEY + DB_CB_MAX_KEY];
    ULONG       cbDBKeyCurrent;
    ULONG       cbDBBMCurrent;
    BYTE        rgbKey[DB_CB_MAX_KEY];
    BOOL        fForwardSeek = !!(Flags & DB_SEARCH_FORWARD) ^ pDB->Key.fChangeDirection;
    DWORD       StartDNT;
    KEY_INDEX   *pTempIndex;

    Assert(VALID_DBPOS(pDB));

    err = dbUnMarshallRestart(pDB,
                              pArgRestart,
                              pDBKeyBMCurrent,
                              Flags,
                              &cbDBKeyCurrent,
                              &cbDBBMCurrent,
                              &StartDNT);
    if (err) {
        return err;
    }

    if (pDB->Key.pVLV) {
        DPRINT (1, "Repositining on a VLV search.\n");
        return 0;

    } else if (pDB->Key.asqRequest.fPresent) {

        // if we are repositioning on a sorted search, this means that we
        // already have all our data on the array, so we don't have to
        // bring new data from the database
        // otherwise, for simple paged searches, we have to go to the db again

        if (! (pDB->Key.asqMode & ASQ_SORTED)) {
            if (err = dbCreateASQTable(pDB,
                                       StartTick,
                                       DeltaTick,
                                       0,
                                       0) ) {

                return DB_ERR_NO_CHILD;
            }
        }

        // now that we have data in memory, get the next one.
        err =  DBGetNextSearchObject (pDB,
                                      StartTick,
                                      DeltaTick,
                                      Flags);

        if (err && err != DB_ERR_NOT_AN_OBJECT) {
            return DB_ERR_NO_CHILD;
        }
        return err;
    }

    // Get the dnt of the record we need to position on
    if (DBFindDNT(pDB, StartDNT)) {
        DPRINT(1,"DBRepositionSearch: repositioning failed\n");
        return DB_ERR_NO_CHILD;
    }

    if(!SORTED_INDEX(pDB->Key.indexType)) {
        Assert(pDB->Key.pIndex);

        // get current table
        if (pDB->Key.pIndex->pAC && pDB->Key.pIndex->pAC->ulLinkID) {
            if (JET_tableidNil == pDB->JetLinkEnumTbl) {
                JetDupCursorEx(pDB->JetSessID,
                                pDB->JetLinkTbl,
                                &pDB->JetLinkEnumTbl,
                                0);
            }
            JetTbl = pDB->JetLinkEnumTbl;
        } else {
            JetTbl = pDB->JetObjTbl;
        }

        // set to the index we're using for the search and seek for the saved
        // key.  if we don't find that key then fail the restart
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                   JetTbl,
                                   pDB->Key.pIndex->szIndexName,
                                   pDB->Key.pIndex->pindexid,
                                   JET_bitMoveFirst);

        Assert(strcmp(pDB->Key.pIndex->szIndexName, SZANCESTORSINDEX) ||
               pDB->Key.indexType == ANCESTORS_INDEX_TYPE);

        if (cbDBBMCurrent == 0 ) {
            // if there is no BM portion of the key then this is simply a key on
            // a unique index.  we just seek on that key to find the entry
            JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         pDBKeyBMCurrent,
                         cbDBKeyCurrent,
                         JET_bitNormalizedKey);

            if (err = JetSeekEx(pDB->JetSessID, JetTbl, JET_bitSeekEQ)) {
                DPRINT(1,"DBRepositionSearch: repositioning failed\n");
                return DB_ERR_NO_CHILD;
            }
        } else {
            // if there is a BM portion of the key then we are on a secondary
            // index that may have many duplicate keys.  seek on both the key
            // and the BM so that we can directly find the correct entry in the
            // index without scanning
            err = JetGotoSecondaryIndexBookmarkEx(pDB->JetSessID,
                                                  JetTbl,
                                                  pDBKeyBMCurrent,
                                                  cbDBKeyCurrent,
                                                  pDBKeyBMCurrent + cbDBKeyCurrent,
                                                  cbDBBMCurrent,
                                                  JET_bitBookmarkPermitVirtualCurrency);
            if ( JET_errRecordDeleted == err ) {
                DPRINT(1,"DBRepositionSearch: repositioning failed\n");
                return DB_ERR_NO_CHILD;
            }
            else {
                Assert( JET_errSuccess == err );
            }
        }

        // if we are on the link table then seek to the correct object on the
        // object table
        if (pDB->Key.pIndex->pAC && pDB->Key.pIndex->pAC->ulLinkID) {
            JET_COLUMNID    colidDNT;
            DWORD           DNT;

            if (FIsBacklink(pDB->Key.pIndex->pAC->ulLinkID)) {
                colidDNT = linkdntid;
            } else {
                colidDNT = backlinkdntid;
            }

            JetRetrieveColumnSuccess(pDB->JetSessID,
                                    pDB->JetLinkEnumTbl,
                                    colidDNT,
                                    &DNT,
                                    sizeof(DNT),
                                    NULL,
                                    JET_bitRetrieveFromIndex,
                                    NULL);

            if (DNT != StartDNT) {
                Assert(!"DBRepositionSearch failed to set currency: inconsistent data in restart\n");
                return DB_ERR_NO_CHILD;
            }
        }
        else {
            // we have positioned on the object table. Make sure we
            // are looking at a correct DNT
            DWORD DNT;

            JetRetrieveColumnSuccess(pDB->JetSessID,
                                     pDB->JetObjTbl,
                                     dntid,
                                     &DNT,
                                     sizeof(DNT),
                                     NULL,
                                     JET_bitRetrieveFromPrimaryBookmark,
                                     NULL);
            if (DNT != StartDNT) {
                DPRINT(1, "DBRepositionSearch failed: StartDNT does not match the key-bookmark from the restart.\n");
                return DB_ERR_NO_CHILD;
            }
        }

        // We're on the correct record.  Now, set the appropriate index range.
        if(fForwardSeek && pDB->Key.pIndex->cbDBKeyUpper) {
            JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         pDB->Key.pIndex->rgbDBKeyUpper,
                         pDB->Key.pIndex->cbDBKeyUpper,
                         JET_bitNormalizedKey);

            err = JetSetIndexRangeEx(pDB->JetSessID,
                                     JetTbl,
                                     JET_bitRangeUpperLimit | JET_bitRangeInclusive);
        }
        else if(!fForwardSeek && pDB->Key.pIndex->cbDBKeyLower) {
            JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         pDB->Key.pIndex->rgbDBKeyLower,
                         pDB->Key.pIndex->cbDBKeyLower,
                         JET_bitNormalizedKey);

            err = JetSetIndexRangeEx(pDB->JetSessID,
                                     JetTbl,
                                     JET_bitRangeInclusive);
        }
        if(err) {
            // We failed to set the index range.  However, we know that we are
            // on the "correct" object (i.e. correct DNT and correct saved key),
            // and that this is a restart, so the key used to create the index
            // range should be valid, after all we used it last time we were
            // processing part of this paged search.  Therefore, we should never
            // get a failure on the index range.  Since we did, and we don't
            // really know where we are in the search, we're going to fail the
            // search (just as we did for the case where we couldn't find the
            // "correct" search object, above.)

            // Do an assert, since we really shouldn't ever see this failure.
            Assert(!"DBRepositionSearch: setindexrange failed\n");
            DPRINT1(1,"DBRepositionSearch: setindexrange failed, err %d\n",err);
            return DB_ERR_NO_CHILD;
        }
    }

    //  OK, we're here.  But is here where we want to be?

    if(!pDB->Key.bOnCandidate) {
        // We repositioned, but the object we are on was NOT a search
        // candidate, so it's not where we really want to be on return from this
        // routine. Move to the next object which IS where we want to be.
        return DBGetNextSearchObject (pDB,
                                      StartTick,
                                      DeltaTick,
                                      Flags);
    }


    if(((Flags & DB_SEARCH_DELETIONS_VISIBLE) || !DBIsObjDeleted(pDB))) {
        BOOL bIsMatch;

        err = DBMatchSearchCriteria(pDB, Flags & DB_SEARCH_DONT_EVALUATE_SECURITY, &bIsMatch);
        if (DB_success != err) {
            return err;
        }
        if (bIsMatch) {
            // Yep, database currency; it's everywhere you want to be
            return 0;
        }
    }

    // the SD will be released first thing in DBGetNextSearchObject

    // Oh, we aren't really where we wanted to be.  OK, move to the next object
    // which IS where we want to be.
    return DBGetNextSearchObject (pDB,
                                  StartTick,
                                  DeltaTick,
                                  Flags);
}

//
// retrieve the key from the current record in obj table and retuen it and
// it's length. errors are handled with exceptions.  Size of buffer handed in is
// in *pcb.  Buffer handed in should be at least DB_CB_MAX_KEY bytes.
//

void
DBGetKeyFromObjTable(DBPOS *pDB, BYTE *rgbKey, ULONG *pcb)
{
    DWORD err;

    Assert(VALID_DBPOS(pDB));

    if(!rgbKey) {
        // NULL key buffer was passed in.  They just want the size of buffer
        // they need.
        JetRetrieveKeyWarnings(pDB->JetSessID,
                               pDB->JetObjTbl,
                               rgbKey,
                               *pcb,
                               pcb,
                               0);
    }
    else {
        JetRetrieveKeyEx(pDB->JetSessID, pDB->JetObjTbl, rgbKey, *pcb,
                         pcb, 0);
    }

}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

void
DBSetVLVArgs (
    DBPOS       *pDB,
    VLV_REQUEST *pVLVrequest,
    ATTRTYP      SortAtt
    )
{
    VLV_SEARCH *pvlvSearch;

    Assert (pVLVrequest);
    Assert (pVLVrequest->fPresent);
    Assert (pDB->Key.pVLV == NULL);

    if (pVLVrequest->fPresent) {
        pvlvSearch = pDB->Key.pVLV = THAllocEx (pDB->pTHS, sizeof (VLV_SEARCH));

        pvlvSearch->clnContentCount = pVLVrequest->contentCount;
        pvlvSearch->clnCurrPos = pVLVrequest->targetPosition;
        //pvlvSearch->contentCount = 0;
        //pvlvSearch->currPosition = 0;
        //pvlvSearch->foundEntries = 0;
        pvlvSearch->pVLVRequest = pVLVrequest;
        pvlvSearch->requestedEntries =
                pVLVrequest->beforeCount +
                pVLVrequest->afterCount + 1;

        pvlvSearch->SortAttr = SortAtt;
    }
}

void DBSetVLVResult (
            DBPOS       *pDB,
            VLV_REQUEST *pVLVRequest,
            PRESTART    pResRestart
    )
{
    pVLVRequest->fPresent = TRUE;
    pVLVRequest->pVLVRestart = pResRestart;
    pVLVRequest->contentCount = pDB->Key.pVLV->contentCount;
    pVLVRequest->targetPosition = pDB->Key.pVLV->currPosition;

    pVLVRequest->Err = pDB->Key.pVLV->Err;

    DPRINT2 (1, "DBSetVLVResult: targetPos: %d contentCount: %d \n",
                pVLVRequest->targetPosition, pVLVRequest->contentCount);
    DPRINT (1, "====================================\n");

}

void
DBSetASQArgs (
    DBPOS       *pDB,
    ASQ_REQUEST *pASQRequest,
    COMMARG     *pCommArg
    )
{
    pDB->Key.asqRequest = *pASQRequest;
    pDB->Key.ulASQSizeLimit = UINT_MAX;

    // set the ASQ mode
    pDB->Key.asqMode = 0;
    if (pCommArg->VLVRequest.fPresent) {
        pDB->Key.asqMode = ASQ_VLV;
    }
    else {
        if (pCommArg->PagedResult.fPresent) {
            pDB->Key.asqMode = ASQ_PAGED;
        }

        if (pCommArg->SortAttr) {
            pDB->Key.asqMode |= ASQ_SORTED;
        }
    }

    if (pDB->Key.asqMode == ASQ_SIMPLE || pDB->Key.asqMode == ASQ_PAGED) {
        pDB->Key.ulASQSizeLimit = pCommArg->ulSizeLimit;
    }
} // DBSetASQArgs

void
DBSetASQResult (
    DBPOS       *pDB,
    ASQ_REQUEST *pASQRequest
    )
{
    *pASQRequest = pDB->Key.asqRequest;
}








/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* dbMakeKeyIndex --
   Given some actual data values, return the keys in the jet index for the
   upper and lower bounds the data describes.  Also, if asked, return a
   GUESS as to the number of records in bounds.

   Called when doing a search optimization.

   Input- DBPOS to use,
          Option of whether this is a PDNT, NCDNT, or unbased index.
          Boolean of whether or not to Guess number of records.
          ULONG * of where to put the guess.

          An array of INDEX_RANGE structures. Each index range structure contains
          a lower bound and an upper bound on one component of the index.


          Place to put key for lower bound.
          Place to put key for upper bound.

   Output-
          The two keys and (if asked) a guess as to the number of records.

*/
KEY_INDEX *
dbMakeKeyIndex(
        DBPOS *pDB,
        DWORD dwSearchType,
        BOOL  bIsSingleValued,
        DWORD Option,
        char * szIndex,
        JET_INDEXID * pindexid,
        DWORD Flags,
        DWORD cIndexRanges,
        INDEX_RANGE * rgIndexRanges)
{
    THSTATE     *pTHS=pDB->pTHS;
    JET_ERR     err;
    JET_TABLEID JetTbl;
    BOOL        fMoveToEnd = FALSE;
    DWORD       grBit;
    KEY_INDEX  *pIndex=NULL;
    BYTE        rgbKey[DB_CB_MAX_KEY];
    DWORD       cbActualKey = 0;
    DWORD       BeginNum, BeginDenom;
    DWORD       EndNum, EndDenom;
    DWORD       Denom;
    DWORD       i;
    JET_RECPOS  RecPos;

    if (Option == dbmkfir_LINK) {
        JetTbl = pDB->JetLinkTbl;
    } else {
        if (Flags & DB_MKI_USE_SEARCH_TABLE) {
            JetTbl = pDB->JetSearchTbl;
        } else {
            JetTbl = pDB->JetObjTbl;
        }
    }

    if (Flags & DB_MKI_SET_CURR_INDEX) {
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                  JetTbl,
                                  szIndex,
                                  pindexid,
                                  JET_bitMoveFirst);
    }

    pIndex = dbAlloc(sizeof(KEY_INDEX));
    pIndex->pNext = NULL;
    pIndex->bFlags = 0;
    pIndex->bIsSingleValued = bIsSingleValued;

    // Assume this is not for a sorted search. Caller will change value if necessary
    Assert( !pIndex->bIsForSort );

    // Assume this is not a tuple index search. Caller will change it if necessary
    Assert( !pIndex->bIsTupleIndex );

    pIndex->bIsEqualityBased = (dwSearchType == FI_CHOICE_EQUALITY);

    pIndex->szIndexName = dbAlloc(strlen(szIndex) + 1);
    strcpy(pIndex->szIndexName, szIndex);
    pIndex->pindexid = pindexid;

    pIndex->ulEstimatedRecsInRange = 0;

    pIndex->cbDBKeyLower = 0;
    pIndex->cbDBKeyUpper = 0;

    Assert(VALID_DBPOS(pDB));

    // make keys

    // First make the key for the lower bound ( ie key 1 )

    if ((Option == 0) &&  ((0==cIndexRanges) ||
                           (0==rgIndexRanges[0].cbValLower))) {
        // Range starts at beginning of file
        if (Flags & DB_MKI_GET_NUM_RECS) {
            // Get an estimate of the number of objects in the index range
            if (JetMoveEx(pDB->JetSessID, JetTbl, JET_MoveFirst, 0) == JET_errSuccess ) {
                JetGetRecordPositionEx(pDB->JetSessID, JetTbl, &RecPos, sizeof(RecPos));
                BeginNum = RecPos.centriesLT;
                BeginDenom = RecPos.centriesTotal;
            }
        }
    }
    else {
        grBit = JET_bitNewKey;

        if(Option == dbmkfir_PDNT) {
            JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         &pDB->Key.ulSearchRootDnt,
                         sizeof(pDB->Key.ulSearchRootDnt),
                         JET_bitNewKey);
            grBit = 0;
        }
        else if(Option == dbmkfir_NCDNT) {
            JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         &pDB->Key.ulSearchRootNcdnt,
                         sizeof(pDB->Key.ulSearchRootNcdnt),
                         JET_bitNewKey);
            grBit = 0;
        }

        //
        // Loop through the passed in index components making the
        // jet key
        //

        for (i=0;i<cIndexRanges;i++)
        {
            // break out of the loop as soon as
            // we encounter the 0 length index component
            if (0==rgIndexRanges[i].cbValLower)
                break;

            Assert(NULL!=rgIndexRanges[i].pvValLower);

            JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         rgIndexRanges[i].pvValLower,
                         rgIndexRanges[i].cbValLower,
                         grBit);
            grBit = 0;
        }


        JetRetrieveKeyEx(pDB->JetSessID,
                         JetTbl,
                         rgbKey,
                         sizeof(rgbKey),
                         &cbActualKey,
                         JET_bitRetrieveCopy);

        pIndex->cbDBKeyLower = cbActualKey;
        pIndex->rgbDBKeyLower = dbAlloc(cbActualKey);
        memcpy(pIndex->rgbDBKeyLower, rgbKey, cbActualKey);

        if (Flags & DB_MKI_GET_NUM_RECS) {
            // Get an estimate of the number of objects in the index range
            // NOTE: do not attempt to use the unique key opt if the key size
            // is already maxed out or we could erroneously believe that we
            // have found a record matching the filter!
            if (pIndex->bIsEqualityBased &&
                Option != dbmkfir_LINK &&
                cbActualKey < DB_CB_MAX_KEY) {
                err = JetSeekEx(pDB->JetSessID, JetTbl, JET_bitSeekEQ | JET_bitCheckUniqueness);
                if (err == JET_wrnUniqueKey) {
                    pIndex->ulEstimatedRecsInRange = 1;
                    pIndex->bIsUniqueRecord = TRUE;
                    Flags &= ~DB_MKI_GET_NUM_RECS;  //  we have our estimate
                } else if (err == JET_errRecordNotFound) {
                    JetMakeKeyEx(pDB->JetSessID, JetTbl, rgbKey, cbActualKey, JET_bitNormalizedKey);
                    err = JetSeekEx(pDB->JetSessID, JetTbl, JET_bitSeekGE);
                }
            } else {
                err = JetSeekEx(pDB->JetSessID, JetTbl, JET_bitSeekGE);
            }
        }
        if (Flags & DB_MKI_GET_NUM_RECS) {
            if (err >= JET_errSuccess) {
                JetGetRecordPositionEx(pDB->JetSessID, JetTbl, &RecPos, sizeof(RecPos));
                BeginNum = RecPos.centriesLT;
                BeginDenom = RecPos.centriesTotal;
            } else {
                Flags &= ~DB_MKI_GET_NUM_RECS;  //  we have our estimate (zero)
            }
        }
    }

    // key 2. This is the key for the upper bound on the
    // index range
    if ((0==cIndexRanges) || (0==rgIndexRanges[0].cbValUpper)) {
        // We want all of the objects in the index.
        switch(Option) {
        case dbmkfir_PDNT:
            // Get all the things with the same PDNT, regardless of the value of
            // the second portion of the index.
            JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         &pDB->Key.ulSearchRootDnt,
                         sizeof(pDB->Key.ulSearchRootDnt),
                         JET_bitNewKey | JET_bitStrLimit);

            JetRetrieveKeyEx(pDB->JetSessID,
                             JetTbl,
                             rgbKey,
                             sizeof(rgbKey),
                             &cbActualKey,
                             JET_bitRetrieveCopy);
            break;

        case dbmkfir_NCDNT:
            // Get all the things with the same NCDNT, regardless of the value
            // of the second portion of the index.
            JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         &pDB->Key.ulSearchRootNcdnt,
                         sizeof(pDB->Key.ulSearchRootNcdnt),
                         JET_bitNewKey | JET_bitStrLimit);

            JetRetrieveKeyEx(pDB->JetSessID,
                             JetTbl,
                             rgbKey,
                             sizeof(rgbKey),
                             &cbActualKey,
                             JET_bitRetrieveCopy);
            break;

        default:
            // Range ends at end of file, get all objects.
            cbActualKey = sizeof(rgbKey);
            memset(rgbKey, 0xff, cbActualKey);
            fMoveToEnd = TRUE;
            break;
        }
    }
    else {
        DWORD uppergrBit = JET_bitStrLimit;
        if(dwSearchType == FI_CHOICE_SUBSTRING) {
            uppergrBit |= JET_bitSubStrLimit;
        }

        switch(Option) {
        case dbmkfir_PDNT:
            JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         &pDB->Key.ulSearchRootDnt,
                         sizeof(pDB->Key.ulSearchRootDnt),
                         JET_bitNewKey);
            grBit = 0;
            break;

        case dbmkfir_NCDNT:
            JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         &pDB->Key.ulSearchRootNcdnt,
                         sizeof(pDB->Key.ulSearchRootNcdnt),
                         JET_bitNewKey);
            grBit = 0;
            break;

        default:
            grBit = JET_bitNewKey;
        }

        //
        // Loop through the passed in index components making the
        // jet key
        //

        for (i=0;i<cIndexRanges;i++) {
            BOOL LastIndexComponent;

            LastIndexComponent = ((i==(cIndexRanges-1))
                                  || (0==rgIndexRanges[i+1].cbValUpper));

            Assert(0!=rgIndexRanges[i].cbValUpper);
            Assert(NULL!=rgIndexRanges[i].pvValUpper);

            //
            // if it is the last index component on which we want the indes
            // range, then also or in upperbit which indicates string or
            // substring limit
            //

            if (LastIndexComponent)
                grBit |=uppergrBit;

            JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         rgIndexRanges[i].pvValUpper,
                         rgIndexRanges[i].cbValUpper,
                         grBit);

            if (LastIndexComponent)
                break;

            // reset the grbit.
            grBit=0;
        }

        JetRetrieveKeyEx(pDB->JetSessID,
                         JetTbl,
                         rgbKey,
                         sizeof(rgbKey),
                         &cbActualKey,
                         JET_bitRetrieveCopy);
    }

    pIndex->cbDBKeyUpper = cbActualKey;
    pIndex->rgbDBKeyUpper = dbAlloc(cbActualKey);
    memcpy(pIndex->rgbDBKeyUpper, rgbKey, cbActualKey);

    // Get an estimate of the number of objects in the index range
    if (Flags & DB_MKI_GET_NUM_RECS) {
        if (fMoveToEnd) {
            err = JetMoveEx(pDB->JetSessID, JetTbl, JET_MoveLast, 0);
        } else {
            err = JetSeekEx(pDB->JetSessID, JetTbl, JET_bitSeekLE);
        }
        if (err >= JET_errSuccess) {
            JetGetRecordPositionEx(pDB->JetSessID, JetTbl, &RecPos, sizeof(RecPos));
            EndNum = RecPos.centriesLT;
            EndDenom = RecPos.centriesTotal;
        } else {
            Flags &= ~DB_MKI_GET_NUM_RECS;  //  we have our estimate (zero)
        }
    }
    if (Flags & DB_MKI_GET_NUM_RECS) {
        // Normalize the fractions of the fractional position to the average of
        // the two denominators.
        Denom = (BeginDenom + EndDenom)/2;
        EndNum = MulDiv(EndNum, Denom - 1, EndDenom - 1) + 1;
        BeginNum = MulDiv(BeginNum, Denom - 1, BeginDenom - 1) + 1;

        if (BeginDenom == 1 || EndDenom == 1) {
            pIndex->ulEstimatedRecsInRange = 1;
        } else if (EndNum >= BeginNum) {
            pIndex->ulEstimatedRecsInRange = EndNum - BeginNum + 1;
        }
    }

    return pIndex;
}


DWORD
DBSetSearchScope(DBPOS  *pDB,
                 ULONG ulSearchType,
                 BOOL bOneNC,
                 RESOBJ *pResRoot)
/*
Routine Description:

    Sets the scope of the search on the default KEY on DBPOS.

Arguments:

    pDB - The DBPos to use.

    ulSearchType - the type of the search

    bOneNC - Are results constrained to same NC

    pResRoot - the RESOBJ that contains info about our position in the tree

Return Values:

    0 if all went well.
*/
{
    Assert(VALID_DBPOS(pDB));

    pDB->Key.ulSearchType = ulSearchType;
    pDB->Key.fSearchInProgress = FALSE;
    pDB->Key.indexType = INVALID_INDEX_TYPE;
    pDB->Key.bOnCandidate = FALSE;
    pDB->Key.fChangeDirection = FALSE;
    pDB->Key.bOneNC = bOneNC;

    pDB->Key.ulSearchRootDnt = pResRoot->DNT;
    pDB->Key.ulSearchRootPDNT = pResRoot->PDNT;
    pDB->Key.ulSearchRootNcdnt = pResRoot->NCDNT;

    return 0;
}


DWORD
DBFindComputerObj(
        DBPOS *pDB,
        DWORD cchComputerName,
        WCHAR *pComputerName
        )
/*
   Find a computer object.  Does so by taking the unicode string passed in and
   tacking on a $ at the end.  This should be the sam account name of the
   computer.  Then, it uses the NCDT/ACCOUNT TYPE/SAM ACCOUNT NAME index to find
   an object in the default domain with account type SAM_MACHINE_ACCOUNT and the
   computed SAM account name.  If an object is found, DB currency is set to that
   object (and reflected in the DBPOS).

   returns 0 if all went well, a jet error otherwise.
*/
{
    DWORD  acctType = SAM_MACHINE_ACCOUNT;
    WCHAR *pTemp = THAllocEx(pDB->pTHS,((cchComputerName + 1) * sizeof(WCHAR)));
    DWORD err;

    memcpy(pTemp, pComputerName, cchComputerName * sizeof(WCHAR));
    pTemp[cchComputerName] = L'$';
    cchComputerName++;

    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetObjTbl,
                               SZ_NC_ACCTYPE_NAME_INDEX,
                               &idxNcAccTypeName,
                               JET_bitMoveFirst);

    // First, the NCNDT
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetObjTbl,
                 &gAnchor.ulDNTDomain,
                 sizeof(gAnchor.ulDNTDomain),
                 JET_bitNewKey);

    // Now, the account type.
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetObjTbl,
                 &acctType,
                 sizeof(acctType),
                 0);


    // finally, the sam account name.
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetObjTbl,
                 pTemp,
                 cchComputerName * sizeof(WCHAR),
                 0);


    // OK, find it.
    err = JetSeekEx(pDB->JetSessID,
                    pDB->JetObjTbl,
                    JET_bitSeekEQ);

    THFreeEx(pDB->pTHS, pTemp);

    if(!err) {
        // Found it, update the dbpos
        err = dbMakeCurrent(pDB, NULL);
    }
    return err;
}

/*-------------------------------------------------------------------------*/
//
// Position ourselves on the start of the specified VLV search
//
DWORD
DBPositionVLVSearch (
    DBPOS *pDB,
    SEARCHARG *pSearchArg
    )
{
    DWORD dwSearchStatus = 0, srvNewPos;
    ULONG SearchFlags = SEARCH_FLAGS(pSearchArg->CommArg);
    int  direction = 0;
    DWORD beforeCount, clnCurrPos, clnContentCount;

    Assert (pDB->Key.pVLV);
    if (!pDB->Key.pVLV) {
        return DB_ERR_SYSERROR;
    }

    beforeCount = pDB->Key.pVLV->pVLVRequest->beforeCount;
    clnCurrPos = pDB->Key.pVLV->clnCurrPos;
    clnContentCount = pDB->Key.pVLV->clnContentCount;

    if (pDB->Key.pVLV->contentCount == 0) {
        DPRINT (1, "VLV: Empty Container\n");
        pDB->Key.pVLV->currPosition = 0;
        return DB_ERR_NEXTCHILD_NOTFOUND;
    }

    if (pDB->Key.pVLV->pVLVRequest->fseekToValue) {
        DPRINT (1, "VLV: Seeking to a Value\n");

        dwSearchStatus =
            DBGetNextSearchObject(pDB,
                                  pSearchArg->CommArg.StartTick,
                                  pSearchArg->CommArg.DeltaTick,
                                  SearchFlags);

        DPRINT2 (1, "VLV positioned status: 0x%x / %d\n",
                 dwSearchStatus, pDB->Key.pVLV->clnCurrPos );

        return dwSearchStatus;
    }

    if (clnContentCount == clnCurrPos) {
        DPRINT (1, "VLV: Moving to the LAST entry\n");

        pDB->Key.pVLV->positionOp = VLV_MOVE_LAST;

        dwSearchStatus =
            DBGetNextSearchObject(pDB,
                                  pSearchArg->CommArg.StartTick,
                                  pSearchArg->CommArg.DeltaTick,
                                  SearchFlags);

        DPRINT1 (1, "VLV positioned status: 0x%x / %d\n", dwSearchStatus);

        return dwSearchStatus;
    }
    else if (clnCurrPos == 0) {

        DPRINT (1, "VLV Client Offset Range Error\n" );

        pDB->Key.pVLV->Err = LDAP_OFFSET_RANGE_ERROR;

        return DB_ERR_VLV_CONTROL;
    }
    else if (clnCurrPos == 1) {
        DPRINT (1, "VLV: Moving to the FIRST entry\n");

        pDB->Key.pVLV->positionOp = VLV_MOVE_FIRST;

        dwSearchStatus =
            DBGetNextSearchObject(pDB,
                                  pSearchArg->CommArg.StartTick,
                                  pSearchArg->CommArg.DeltaTick,
                                  SearchFlags);

        DPRINT1 (1, "VLV positioned status: 0x%x / %d\n", dwSearchStatus);

        return dwSearchStatus;
    }

    // calculate position
    pDB->Key.pVLV->positionOp = VLV_CALC_POSITION;

    dwSearchStatus =
        DBGetNextSearchObject(pDB,
                              pSearchArg->CommArg.StartTick,
                              pSearchArg->CommArg.DeltaTick,
                              SearchFlags);

    DPRINT1 (1, "VLV positioned status: 0x%x\n", dwSearchStatus);

    return dwSearchStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbprop.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbprop.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements the dblayer routines to manage the security
    descriptor propagation queue table.

Author:

    Tim Williams     [TimWi]    2-Dec-1996

Revision History:

--*/
#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <dsatools.h>                   // For pTHS

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>

// Assorted DSA headers
#include "dsevent.h"
#include "ntdsctr.h"
#include "objids.h"        /* needed for ATT_MEMBER and ATT_IS_MEMBER_OFDL */
#include <dsexcept.h>
#include <filtypes.h>      /* Def of FI_CHOICE_???                  */
#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DBOBJ:" /* define the subsystem for debugging */

// DBLayer includes
#include "dbintrnl.h"

#include <anchor.h>
#include <sdprop.h>

#include <fileno.h>
#define  FILENO FILENO_DBPROP

/*++
Routine Description:

    Adds a row to the propagation queue table identifying a pending propagation
    starting at the current object in the data table.

Parameters:

    pDB - the active database handle

Return Codes:

    returns 0 if all went well, a non-zero error code otherwise.

--*/
DWORD
DBEnqueueSDPropagationEx(
        DBPOS * pDB,
        BOOL bTrimmable,
        DWORD dwFlags
        )
{
    THSTATE *pTHS=pDB->pTHS;
    JET_TABLEID table;
    JET_ERR     err=0;
    JET_SETCOLUMN attList[4];
    DWORD cAtts;
    BYTE bTrim;

    Assert(VALID_DBPOS(pDB));

    if (dwFlags & SDP_NEW_ANCESTORS) {
        // this object had his ancestry changed. Mark this in dsCorePropagationData
        DBAddSDPropTime(pDB, (BYTE)dwFlags | SDP_ANCESTRY_INCONSISTENT_IN_SUBTREE);
    }

    Assert(pDB->JetSDPropTbl);
    table = pDB->JetSDPropTbl;

    // Prepare the insert, which will automatically give us the index column
    // Succeeds or excepts
    JetPrepareUpdateEx(pDB->JetSessID,table,JET_prepInsert);

    memset(attList, 0, sizeof(attList));
    attList[0].columnid = begindntid;
    attList[0].pvData = &pDB->DNT;
    attList[0].cbData = sizeof(pDB->DNT);
    attList[0].itagSequence = 1;
    cAtts = 1;

    if (bTrimmable) {
        bTrim = 1;
        attList[cAtts].columnid = trimmableid;
        attList[cAtts].pvData = &bTrim;
        attList[cAtts].cbData = sizeof(bTrim);
        attList[cAtts].itagSequence = 1;
        cAtts++;
    }

    if (pTHS->dwClientID) {
        attList[cAtts].columnid = clientidid;
        attList[cAtts].pvData = &pTHS->dwClientID;
        attList[cAtts].cbData = sizeof(pTHS->dwClientID);
        attList[cAtts].itagSequence = 1;
        cAtts++;
    }

    if (dwFlags) {
        attList[cAtts].columnid = sdpropflagsid;
        attList[cAtts].pvData = &dwFlags;
        attList[cAtts].cbData = sizeof(dwFlags);
        attList[cAtts].itagSequence = 1;
        cAtts++;
    }

    // succeeds or excepts
    JetSetColumnsEx(pDB->JetSessID, table, attList, cAtts);

    // succeeds or excepts
    JetUpdateEx(pDB->JetSessID,
                table,
                NULL,
                0,
                NULL);

    //
    //
    if (pDB->DNT == gAnchor.ulDNTDomain) {
        // The domain's SD is cached in gAnchor, so schedule a rebuild
        pTHS->fAnchorInvalidated = TRUE;
    }

    pDB->SDEvents++;
    return 0;
}


/*++
Routine Description:

    Deletes a row to the propagation queue table identifying a pending
    propagation that has been completed.

Parameters:

    pDB - the active database handle
    index - the index number of the propagation.  If 0, the lowest event is
    removed.

Return Codes:

    returns 0 if all went well, a non-zero error code otherwise.

--*/
DWORD
DBPopSDPropagation (
        DBPOS * pDB,
        DWORD index
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;

    Assert(VALID_DBPOS(pDB));
    Assert(pDB->pTHS->fSDP);

    Assert(pDB->JetSDPropTbl);

    table = pDB->JetSDPropTbl;

    // Set to the order index.
    if(err = JetSetCurrentIndex2(
                    pDB->JetSessID,
                    table,
                    NULL,   // OPTIMISATION: pass NULL when switching to primary index (SZORDERINDEX)
                    JET_bitMoveFirst))
        return err;


    // Find the appropriate index.

    if(err = JetMakeKey(pDB->JetSessID, table, &index, sizeof(index),
                        JET_bitNewKey))
        return err;

    // Find the appropriate object.
    if(err = JetSeek(pDB->JetSessID, table, JET_bitSeekEQ))
        return err;

    // Delete the row.
    if(err = JetDelete(pDB->JetSessID, table))
        return err;

    pDB->SDEvents--;
    return 0;
}

/*++
Routine Description:

    Returns an array of information describing the remaining propagation events
    in the queue.

Parameters:

    pDB - the active database handle
    dwClientID - the clientid that we should restrict to. 0 means they don't
            want the list restricted.
    pdwSize - the number of elements found that match the criteria.
    ppInfo - Returns a list of filled in propinfo structures.  If NULL, no
            values are returned.

Return Codes:

    returns 0 if all went well (as well as the requested data).  A non-zero
    error code otherwise.

--*/
DWORD
DBSDPropagationInfo (
        DBPOS * pDB,
        DWORD dwClientID,
        DWORD *pdwSize,
        SDPropInfo **ppInfo
        )
{
    // For now, we just run through the queue and return the count.
    THSTATE     *pTHS=pDB->pTHS;
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       dwNumAllocated = 0;
    SDPropInfo  *pInfo=NULL;
    JET_RETRIEVECOLUMN attList[4];

    Assert(VALID_DBPOS(pDB));

    *pdwSize = 0;
    if(ppInfo) {
        *ppInfo = NULL;
    }

    Assert(pDB->JetSDPropTbl);
    table = pDB->JetSDPropTbl;

    if(dwClientID) {
        // They are looking specifically for propagations from a single client,
        // use the clientid index
        if(err = JetSetCurrentIndex2(pDB->JetSessID, table, SZCLIENTIDINDEX, 0))
            return err;

        // Now, seek to the right range
        if(err = JetMakeKey(pDB->JetSessID, table, &dwClientID,
                            sizeof(dwClientID), JET_bitNewKey))
            return err;

        // Find the appropriate object.
        err = JetSeek(pDB->JetSessID, table,
                      JET_bitSeekEQ | JET_bitSetIndexRange);
            if(err == JET_errRecordNotFound) {
                // Nothing in the list.
                return 0;
            }
            else {
#ifndef JET_BIT_SET_INDEX_RANGE_SUPPORT_FIXED
                if (!err) {
                    err = JetMakeKey(pDB->JetSessID, table, &dwClientID,
                            sizeof(dwClientID), JET_bitNewKey);

                    if (!err) {
                        err = JetSetIndexRange(pDB->JetSessID, table,
                            (JET_bitRangeUpperLimit | JET_bitRangeInclusive ));
                    }
                }
#endif

                return err;
            }
    }
    else {
        if(err = JetSetCurrentIndex2(
                        pDB->JetSessID,
                        table,
                        NULL,   // OPTIMISATION: pass NULL when switching to primary index (SZORDERINDEX)
                        JET_bitMoveFirst))
            return err;

        // Seek to the beginning.
        err = JetMove(pDB->JetSessID, table, JET_MoveFirst, 0);

        if(err) {
            if(err == JET_errNoCurrentRecord) {
                // Nothing in the list.
                return 0;
            }
            else {
                return err;
            }
        }
    }

    // OK, we're on the first object
    if(ppInfo) {
        // Allocate some
        dwNumAllocated = 20;
        pInfo = (SDPropInfo *)THAllocEx(pTHS,
                                        dwNumAllocated * sizeof(SDPropInfo));
    }

    do {
        if(ppInfo) {
            if(*pdwSize == dwNumAllocated) {
                // Grow the list
                dwNumAllocated *= 2;
                pInfo = (SDPropInfo *)
                    THReAllocEx(pTHS, pInfo, dwNumAllocated * sizeof(SDPropInfo));
            }

            memset(attList, 0, sizeof(attList));
            attList[0].columnid = orderid;
            attList[0].pvData = &(pInfo[*pdwSize].index);
            attList[0].cbData = sizeof(pInfo[*pdwSize].index);
            attList[0].itagSequence = 1;
            attList[1].columnid = begindntid;
            attList[1].pvData = &(pInfo[*pdwSize].beginDNT);
            attList[1].cbData = sizeof(pInfo[*pdwSize].beginDNT);
            attList[1].itagSequence = 1;
            attList[2].columnid = clientidid;
            attList[2].pvData = &(pInfo[*pdwSize].clientID);
            attList[2].cbData = sizeof(pInfo[*pdwSize].clientID);
            attList[2].itagSequence = 1;
            attList[3].columnid = sdpropflagsid;
            attList[3].pvData = &(pInfo[*pdwSize].flags);
            attList[3].cbData = sizeof(pInfo[*pdwSize].flags);
            attList[3].itagSequence = 1;

            err = JetRetrieveColumnsWarnings(pDB->JetSessID, table, attList, 4);
            if (err) {
                // JET_wrnColumnNull is never returned from JetRetrieveColumns
                return err;
            }
            if (attList[2].err == JET_wrnColumnNull) {
                pInfo[*pdwSize].clientID = 0;
            }
            if (attList[3].err == JET_wrnColumnNull) {
                pInfo[*pdwSize].flags = 0;
            }
            if (attList[0].err == JET_wrnColumnNull || attList[1].err == JET_wrnColumnNull) {
                return JET_wrnColumnNull;
            }
        }
        (*pdwSize) += 1;
    } while((!eServiceShutdown) &&
            (JET_errSuccess == JetMove(pDB->JetSessID, table, JET_MoveNext,0)));

    if(eServiceShutdown) {
        return DIRERR_SHUTTING_DOWN;
    }

    if(ppInfo) {
        *ppInfo = (SDPropInfo *)THReAllocEx(
                pTHS,
                pInfo,
                *pdwSize * sizeof(SDPropInfo));
    }

    return 0;
}

/*++
Routine Description:

    Walk the array of objects in the SD table and set the clientid field to
    NULL, unless the client id is negative, in which case we leave it alone.

Parameters:

    pDB - the active database handle

Return Codes:

    returns 0 if all went well (as well as the requested data).  A non-zero
    error code otherwise.

--*/
DWORD
DBSDPropInitClientIDs (
        DBPOS * pDB
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       zero=0;
#if DBG
    DWORD       thisId;
    DWORD       cbActual;
#endif

    Assert(VALID_DBPOS(pDB));

    // only the SDPropagator can do this
    Assert(pDB->pTHS->fSDP);

    Assert(pDB->JetSDPropTbl);

    table = pDB->JetSDPropTbl;


    if(err = JetSetCurrentIndex2(pDB->JetSessID, table, SZCLIENTIDINDEX, 0))
        return err;


    // Seek to the first non-null that's greater than 0.  Note that the sd
    // propagator itself occasionally enqueues with a client id of (-1).  This
    // should skip all those.

    if(err = JetMakeKey(pDB->JetSessID, table, &zero, sizeof(zero),
                        JET_bitNewKey))
        return err;

    err = JetSeek(pDB->JetSessID, table, JET_bitSeekGE);
    if(err == JET_wrnSeekNotEqual)
        err = 0;

    while(!eServiceShutdown && !err) {
        // Ok, we're on the first object with a client id.

#if DBG
        thisId = 0;
        // Get the current clientid.
        err = JetRetrieveColumn(pDB->JetSessID, table,clientidid,
                                &thisId, sizeof(thisId),
                                &cbActual, 0,
                                NULL);
        Assert(!err);
        Assert(thisId != ((DWORD)(-1)));
#endif

        // Prepare the replace,
        err = JetPrepareUpdate(pDB->JetSessID,table,JET_prepReplace);
        if(err != DB_success) {
            return err;
        }


        // Set the clientID column to NULL
        err = JetSetColumn(pDB->JetSessID,
                           table,
                           clientidid,
                           NULL,
                           0,
                           0,
                           NULL);
        if(err != DB_success) {
            JetPrepareUpdate(pDB->JetSessID,table,JET_prepCancel);
            return err;
        }

        // Put it in the DB.
        err = JetUpdate(pDB->JetSessID,
                        table,
                        NULL,
                        0,
                        NULL);
        if(err != DB_success)  {
            JetPrepareUpdate(pDB->JetSessID,table,JET_prepCancel);
            return err;
        }

        // We commit lazily after update.
        DBTransOut(pDB, TRUE, TRUE);
        DBTransIn(pDB);

        // We are messing with the very column we are indexed over, so reseek
        err = JetMakeKey(pDB->JetSessID, table, &zero, sizeof(zero),
                         JET_bitNewKey);
        if(!err) {
            err = JetSeek(pDB->JetSessID, table, JET_bitSeekGE);
            if(err == JET_wrnSeekNotEqual)
                err = 0;
        }
    }

    if(eServiceShutdown) {
        return DIRERR_SHUTTING_DOWN;
    }

    if(err != JET_errRecordNotFound) {
        return err;
    }

    return 0;
}


/*++
Routine Description:

    Returns information describing a propagation event in the queue.

Parameters:

    pDB - the active database handle
    pInfo - A preallocated propinfo structure.


Return Codes:

    returns 0 if all went well (as well as the requested data).  A non-zero
    error code otherwise.

--*/
DWORD
DBGetNextPropEvent (
        DBPOS * pDB,
        SDPropInfo *pInfo
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       index;
    JET_RETRIEVECOLUMN attList[5];

    memset(pInfo, 0, sizeof(SDPropInfo));

    Assert(VALID_DBPOS(pDB));

    Assert(pDB->JetSDPropTbl);
    table = pDB->JetSDPropTbl;

    // Set to the order index.
    if(err = JetSetCurrentIndex2(
                    pDB->JetSessID,
                    table,
                    NULL,   // OPTIMISATION: pass NULL when switching to primary index (SZORDERINDEX)
                    JET_bitMoveFirst))
        return err;


    // Seek to the beginning.
    err = JetMove(pDB->JetSessID, table, JET_MoveFirst, 0);

    if(err) {
        if(err == JET_errNoCurrentRecord) {
            return DB_ERR_NO_PROPAGATIONS;
        }
        else {
            return err;
        }
    }

    memset(attList, 0, sizeof(attList));
    attList[0].columnid = orderid;
    attList[0].pvData = &(pInfo->index);
    attList[0].cbData = sizeof(pInfo->index);
    attList[0].itagSequence = 1;
    attList[1].columnid = begindntid;
    attList[1].pvData = &(pInfo->beginDNT);
    attList[1].cbData = sizeof(pInfo->beginDNT);
    attList[1].itagSequence = 1;
    attList[2].columnid = clientidid;
    attList[2].pvData = &(pInfo->clientID);
    attList[2].cbData = sizeof(pInfo->clientID);
    attList[2].itagSequence = 1;
    attList[3].columnid = sdpropflagsid;
    attList[3].pvData = &(pInfo->flags);
    attList[3].cbData = sizeof(pInfo->flags);
    attList[3].itagSequence = 1;
    attList[4].columnid = sdpropcheckpointid;
    attList[4].pvData = NULL;
    attList[4].cbData = 0;
    attList[4].itagSequence = 1;

    err = JetRetrieveColumnsWarnings(pDB->JetSessID, table, attList, 5);
    if (err == JET_wrnBufferTruncated && attList[4].err == JET_wrnBufferTruncated) {
        // we need to alloc buffer for checkpoint data
        pInfo->pCheckpointData = (PBYTE)THAllocEx(pDB->pTHS, attList[4].cbActual);
        pInfo->cbCheckpointData = attList[4].cbActual;
        // and re-read the column
        attList[4].pvData = pInfo->pCheckpointData;
        attList[4].cbData = pInfo->cbCheckpointData;
        err = JetRetrieveColumnsWarnings(pDB->JetSessID, table, &attList[4], 1);
    };

    if (err) {
        // JET_wrnColumnNull is never returned from JetRetrieveColumns
        return err;
    }
    if (attList[2].err == JET_wrnColumnNull) {
        pInfo->clientID = 0;
    }
    if (attList[3].err == JET_wrnColumnNull) {
        pInfo->flags = 0;
    }
    if (attList[4].err == JET_wrnColumnNull) {
        pInfo->pCheckpointData = NULL;
        pInfo->cbCheckpointData = 0;
    }
    if (attList[0].err == JET_wrnColumnNull || attList[1].err == JET_wrnColumnNull) {
        return JET_wrnColumnNull;
    }

    return 0;
}

/*++
Routine Description:

    Returns the index of the last object in the propagation queue.

Parameters:

    pDB - the active database handle
    pInfo - A preallocated propinfo structure.


Return Codes:

    returns 0 if all went well (as well as the requested data).  A non-zero
    error code otherwise.

--*/
DWORD
DBGetLastPropIndex (
        DBPOS * pDB,
        DWORD * pIndex
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       cbActual;


    Assert(VALID_DBPOS(pDB));

    Assert(pDB->JetSDPropTbl);
    table = pDB->JetSDPropTbl;

    *pIndex = 0xFFFFFFFF;

    // Set to the order index.
    if(err = JetSetCurrentIndex2(
                    pDB->JetSessID,
                    table,
                    NULL,   // OPTIMISATION: pass NULL when switching to primary index (SZORDERINDEX)
                    JET_bitMoveFirst))
        return err;


    // Seek to the End
    err = JetMove(pDB->JetSessID, table, JET_MoveLast, 0);

    if(err) {
        return err;
    }

    // Get the info.
    err = JetRetrieveColumn(pDB->JetSessID, table, orderid,
                            pIndex, sizeof(DWORD),
                            &cbActual, 0,
                            NULL);

    return err;
}

/*++
Routine Description:

    Removes all duplicate searches in the prop queue, regardless of the
    trimmable flag.  Expected to be called at start up to trim out duplicate
    events in our queue.  Since we are just starting, no client is waiting
    around for answers, we can consider everything trimmable.


Parameters:

    pDB - the active database handle

Return Codes:

    returns 0 if all went well.  A non-zero error code otherwise.

--*/
DWORD
DBThinPropQueue (
        DBPOS * pDB,
        DWORD DNT
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       cbActual;
    DWORD       ThisDNT;

    Assert(VALID_DBPOS(pDB));

    // only the SDPropagator can do this
    Assert(pDB->pTHS->fSDP);

    Assert(pDB->JetSDPropTbl);

    table = pDB->JetSDPropTbl;

    // Set to the order index.
    if(err = JetSetCurrentIndex2(pDB->JetSessID, table, SZTRIMINDEX, 0))
        return err;

    if(!DNT) {
        // We're trimming the whole list, so seek to the beginning.
        err = JetMove(pDB->JetSessID, table, JET_MoveFirst, 0);

        if (err == JET_errNoCurrentRecord) {
            // OK, no records to trim.  Bail
            return 0;
        }

    }
    else {
        BYTE Trim=1;
        // We only want to trim objects with the correct DNT and which are
        // marked as trimmable.  Seek and set an index range.

        if((err = JetMakeKey(pDB->JetSessID,
                             table,
                             &DNT,
                             sizeof(DNT),
                             JET_bitNewKey)) ||
           (err = JetMakeKey(pDB->JetSessID,
                             table,
                             &Trim,
                             sizeof(Trim),
                             0))) {
            return err;
        }

        // Find the appropriate object.
        err = JetSeek(pDB->JetSessID, table,
                      JET_bitSeekEQ | JET_bitSetIndexRange);

        if(err == JET_errRecordNotFound) {
            // OK, no records to trim.  Bail
            return 0;
        }
#ifndef JET_BIT_SET_INDEX_RANGE_SUPPORT_FIXED
        if (!err) {
            if((err = JetMakeKey(pDB->JetSessID,
                                 table,
                                 &DNT,
                                 sizeof(DNT),
                                 JET_bitNewKey)) ||
               (err = JetMakeKey(pDB->JetSessID,
                                 table,
                                 &Trim,
                                 sizeof(Trim),
                                 0)) ||
               (err = JetSetIndexRange(pDB->JetSessID, table,
                        (JET_bitRangeUpperLimit | JET_bitRangeInclusive)))) {
                return err;
            }
        }
#endif
    }

    if(err) {
        // Something 'orrible 'appened.
        return err;
    }
    if(err = JetRetrieveColumn(pDB->JetSessID, table, begindntid,
                               &(DNT), sizeof(DNT),
                               &cbActual, 0,
                               NULL))
        return err;

    while(!eServiceShutdown && !err) {
        // Step forward.
        err = JetMove(pDB->JetSessID, table, JET_MoveNext, 0);
        if(err == JET_errNoCurrentRecord) {
            // No more objects, return
            return 0;
        }
        else if(!err) {
            // Ok, we're still on an object.
            err = JetRetrieveColumn(pDB->JetSessID, table, begindntid,
                                    &(ThisDNT), sizeof(ThisDNT),
                                    &cbActual, 0,
                                    NULL);

            if(err)
                return err;

            if(DNT == ThisDNT) {
                // Commit from the last delete
                DBTransOut(pDB, TRUE, TRUE);
                DBTransIn(pDB);

                // Duplicate event, kill it.
                if(err = JetDelete(pDB->JetSessID, table)) {
                    return err;
                }

                pDB->SDEvents--;
            }
            else {
                DNT = ThisDNT;
            }
        }
    }

    if(eServiceShutdown) {
        return DIRERR_SHUTTING_DOWN;
    }

    return err;
}



JET_RETRIEVECOLUMN dbAddSDPropTimeReadTemplate[] = {
        { 0, 0, sizeof(DSTIME), 0, 0, 0, 1, 0, 0},
        { 0, 0, sizeof(DSTIME), 0, 0, 0, 5, 0, 0},
        { 0, 0, sizeof(DSTIME), 0, 0, 0, 6, 0, 0}
    };

JET_SETCOLUMN dbAddSDPropTimeWriteTemplate[] = {
        { 0, NULL, sizeof(DSTIME), 0, 0, 1, 0},
        { 0, NULL, sizeof(DSTIME), 0, 0, 6, 0},
        { 0, NULL, 0, 0, 0, 2, 0}
    };

VOID
DBAddSDPropTime (
        DBPOS *pDB,
        BYTE flags
        )
/*++
  Description:
      This routine is called by the SD propagator to write some time and flag
      information onto an object that the propagator is touching for some
      reason.  We are maintaining the attribute DS_CORE_PROPAGATION__DATA.

      This attribute will hold at most 5 values. (Remember, Jet values are 1
      indexed).  Value 1 holds flags.  Values 2 through 5 hold times.  The flags
      in value 1 apply to the times in values 2 through 5.  To get the flags
      associated with value 2, mask value 1 with 0xFF.  To get the flags
      associated with value 3, mask vlaue 1 with 0xFF00, etc.

      The flags are BYTES, and we hold 4 of them.  That accounts for 32 bits of
      the 64 bit value held in value 1.  We don't use the top 32 bits (and must
      never use the top 24 bits, since that make the conversion of this value to
      a time string choke).

      The attribute in question is time valued.  So, when reading this attribute
      from an outside call, you get 4 normal looking times and 1 very odd time
      (the flags value).  Parsing the odd looking time back into bits is left as
      an exercise for the student.

      Note that we keep these ordered.  If 4 time values are already being held,
      we delete value 2 and add value 6.  Jet then collapses the values back to
      being indexed 2 through 5 after we commit changes to this object.

      Note that if the attribute is currently empty, this writes the flags and 1
      time value.  If the attribute has fewer than 4 time values, we touch up
      the flags and add a new time value.  We only delete time values if we are
      already holding 4.

      NOTE: Given that everything this routine does is for debugging and
      tracking purposes, it must not raise exceptions of any sort on
      failure, but just return an error code that the caller can ignore.

   Parameters:
      pDB - DBPOS to use
      flags - flags to associate with this time.
--*/
{
    DWORD  err, i;
    DSTIME timeNow = DBTime();
    DSTIME data;
    DSTIME localFlags;
    JET_RETRIEVECOLUMN jCol[3];
    JET_SETCOLUMN jColIn[3];
    DSTIME dummy;

    DBInitRec(pDB);

    // Set up the parameters to the JetRetrieveColumns and JetWriteColumns
    // calls. All the static portions are defined in the data structures
    // dbAddSDPropTimeWriteTemplate and dbAddSDPropTimeReadTemplate.  DBINIT.C
    // has already written the jet columnids into these constant structures.
    // All we have to do is copy the constant structures and get local pointers
    // to data.
    memcpy(jColIn, dbAddSDPropTimeWriteTemplate,
           sizeof(dbAddSDPropTimeWriteTemplate));

    memcpy(jCol, dbAddSDPropTimeReadTemplate,
           sizeof(dbAddSDPropTimeReadTemplate));


    // First thing to write back is the flags.  Writes to index 1.
    jColIn[0].pvData = &localFlags;
    // Second thing to write back is the time now.  Writes to index 6.
    jColIn[1].pvData = &timeNow;
    // Final thing we might write is a null to erase index 2.
    jColIn[2].pvData = NULL;


    // First thing we read is the flags already on the attribute (index 1)
    jCol[0].pvData = &localFlags;
    // Second thing we read is the 4th time value (index 5).  We read this to
    // find out whether we need to delete a time value or not.
    jCol[1].pvData = &data;
#if DBG
    // Only bother trying to read this value in the debug case, we only use it
    // in an assert.  The assert is that we have no value at index 6 (i.e. the
    // most we have is 1 flags value and 4 time values.
    jCol[2].pvData = &dummy;

    JetRetrieveColumnsSuccess(pDB->JetSessID, pDB->JetObjTbl, jCol, 3);
#else
    JetRetrieveColumnsSuccess(pDB->JetSessID, pDB->JetObjTbl, jCol, 2);
#endif

    switch(jCol[0].err) {
    case 0:
        localFlags = ((localFlags << 8) | flags);
        break;

    case JET_wrnColumnNull:
        // No flags value yet.  This is the first time the SDProp has touched
        // this object.
        localFlags = flags;
        // If we have no flags, we better have no times either.
        Assert(jCol[1].err == JET_wrnColumnNull);
        break;

    default:
        // Something went wrong.
        DsaExcept(DSA_DB_EXCEPTION, jCol[0].err, 0);
        break;
    }

    // We only track flags in the low 32 bits (4 8 bit flags).  So, the hi part
    // is 0.
    localFlags &= 0xFFFFFFFF;

    // And, we never have 6 values, right?
    Assert(jCol[2].err == JET_wrnColumnNull);

    if(!jCol[1].err) {
        // There are 4 times already, we don't hold more than 4.  So, we need to
        // delete the oldest time.  It's at index 2.  Use all three entries in
        // the jColIn structer, the third entry is the delete of index 2.
        i = 3;
    }
    else {
        // Just need to update the flags and tack a date onto the end.
        i = 2;
    }


    // Now, write back the new data
    // Succeeds or excepts
    JetSetColumnsEx(pDB->JetSessID,
                    pDB->JetObjTbl,
                    jColIn,
                    i);
}

DWORD
DBPropExists (
        DBPOS * pDB,
        DWORD DNT,
        DWORD dwExcludeIndex,
        BOOL* pfExists
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       cbActual;
    DWORD       ThisDNT;

    Assert(VALID_DBPOS(pDB));

    // only the SDPropagator can do this
    table = pDB->JetSDPropTbl;

    JetSetCurrentIndex2Success(pDB->JetSessID,
                               table,
                               SZTRIMINDEX,
                               0);
    
    JetMakeKeyEx(pDB->JetSessID,
                 table, 
                 &DNT,
                 sizeof(DNT),
                 JET_bitNewKey);

    // Find the appropriate object.
    err = JetSeekEx(pDB->JetSessID, table, JET_bitSeekGE);

    if (err == JET_errRecordNotFound) {
        *pfExists = FALSE;
        return DB_success;
    }
    // JetSeekEx can only error with JET_errRecordNotFound or JET_wrnSeekNotEqual

TryNext:
    JetRetrieveColumnSuccess(pDB->JetSessID,
                             table,
                             begindntid,
                             &(ThisDNT),
                             sizeof(ThisDNT),
                             &cbActual, 0,
                             NULL);

    if(ThisDNT != DNT) {
        *pfExists = FALSE;
        return ERROR_SUCCESS;
    }
    // DNTs match. Check the index
    if (dwExcludeIndex != 0) {
        DWORD index;
        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 table,
                                 orderid,
                                 &index,
                                 sizeof(index),
                                 &cbActual, 0,
                                 NULL);

        if (index == dwExcludeIndex) {
            // move to the next row
            err = JetMoveEx(pDB->JetSessID, table, JET_MoveNext, 0);
            if (err == ERROR_SUCCESS) {
                // try the next one. We don't need to check the index there.
                dwExcludeIndex = 0;
                goto TryNext;
            }
            // we moved off the table. No more rows.
            *pfExists = FALSE;
            return ERROR_SUCCESS;
        }
    }

    // we found a row which matches
    *pfExists = TRUE;
    return ERROR_SUCCESS;
}


DWORD
DBPropagationsExist (
        DBPOS * pDB
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;

    Assert(VALID_DBPOS(pDB));

    // only the SDPropagator can do this
    table = pDB->JetSDPropTbl;
    if(err = JetSetCurrentIndex2(pDB->JetSessID,
                                 table,
                                 SZTRIMINDEX,
                                 0)) {
        return err;
    }

    err = JetMove (pDB->JetSessID, table, JET_MoveFirst, 0);

    // if the table is empty, then there are no pending propagations
    if (err == JET_errNoCurrentRecord) {
        return FALSE;
    }

    return TRUE;
}

DWORD
DBGetChildrenDNTs(
        DBPOS  *pDB,
        DWORD  ParentDNT,
        DWORD  **ppDNTs,
        DWORD  *pDNTsLength,
        DWORD  *pDNTsCount,
        BOOL   *pfMoreChildren,
        DWORD  dwBatchSize,
        PWCHAR pLastRDNLoaded,
        DWORD* pcbLastRDNLoaded
        )
/*++
Routine Description:
    Identifies the next batch of the children of a given parent, writing them to the array
    passed in, reallocing the array as necessary.  This is a special purpose
    routine for the SD propagator.

Arguments:
    ParentDNT       -- (IN) DNT of the parent object.
    ppDNTs          -- (IN OUT) array of children DNTs
    pDNTsLength     -- (IN OUT) current length of the array
    pDNTsCount      -- (OUT) number of DNTs read
    pfMoreChildren  -- (OUT) are there more children to read
    dwBatchSize     -- (IN) max number of DNTs to read
    pLastRDNLoaded  -- (IN OUT) last child RDN loaded (used to restart the next batch)
                                if there are more children to read, records the last
                                child RDN back into this buffer. The buffer length
                                is MAX_RDN_SIZE
    pcbLastRDNLoaded-- (IN OUT) length of pLastRDNLoaded                                

Return Values:
    0 if all went well, error code otherwise.
--*/
{
    DWORD        err;
    INDEX_VALUE  IV[2];
    DWORD        ThisDNT;
    DWORD        cb;

    Assert(pDB->pTHS->fSDP);

    IV[0].pvData = &ParentDNT;
    IV[0].cbData = sizeof(ParentDNT);

    // Set to the PDNT index
    JetSetCurrentIndex4Success(
                pDB->JetSessID,
                pDB->JetObjTbl,
                SZPDNTINDEX,
                &idxPdnt,
                JET_bitMoveFirst );

    if (*pcbLastRDNLoaded > 0) {
        // we need to restart AFTER the last RDN
        IV[1].pvData = pLastRDNLoaded;
        IV[1].cbData = *pcbLastRDNLoaded;
        // PDNT_RDN index is unique. Therefore, it is safe for
        // us to do DB_SeekGT and skip the last entry we
        // have already processed. This would not be the case
        // if the index was not unique. There might have been
        // a block of RDNs starting with the same 255 bytes, and
        // we would skip them all.
        err = DBSeek(pDB, IV, 2, DB_SeekGT);
    }
    else {
        // Now, set an index range in the PDNT index to get all the children.
        // Use GE because this is a compound index.
        err = DBSeek(pDB, IV, 1, DB_SeekGE);
    }
    
    // assume there are no children
    *pDNTsCount = 0;
    *pfMoreChildren = FALSE;
    
    if(err && err != JET_wrnSeekNotEqual) {
        // Couldn't find anything.  So, no objects are children.
        return 0;
    }
    // Get the PDNT of the object we are on, since we may already be beyond the
    // range we care about.
    JetRetrieveColumnSuccess(pDB->JetSessID,
                             pDB->JetObjTbl,
                             pdntid,
                             &ThisDNT,
                             sizeof(ThisDNT),
                             &cb,
                             JET_bitRetrieveFromIndex,
                             NULL);
    if(ThisDNT != ParentDNT) {
        // No objects are children
        return 0;
    }

    err = DBSetIndexRange(pDB, IV, 1);
    if(err) {
        // Huh?
        return err;
    }

    do {
        // Get the DNT of the current object.  Note that we use the grbit saying
        // that we want the data (which is the primary key) retrieved from the
        // secondary index.  This should let us satisfy this call with only the
        // pages already accessed by JET, and not force us to visit the primary
        // index or the actual data page.
        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 pDB->JetObjTbl,
                                 dntid,
                                 &ThisDNT,
                                 sizeof(ThisDNT),
                                 &cb,
                                 JET_bitRetrieveFromPrimaryBookmark,
                                 NULL);

        // make sure we have space in the array
        if (*pDNTsCount >= *pDNTsLength) {
            // need to realloc more space
            DWORD newLength;
            PDWORD pTmp;

            if (*pDNTsLength == 0) {
                // new array.
                newLength = dwBatchSize/4;
            }
            else {
                newLength = *pDNTsLength * 2;
            }
            if (newLength > dwBatchSize) {
                newLength = dwBatchSize;
            }

            if (*pDNTsLength > 0) {
                *ppDNTs = (PDWORD)THReAllocEx(pDB->pTHS, *ppDNTs, newLength*sizeof(DWORD));
            }
            else {
                *ppDNTs = (PDWORD)THAllocEx(pDB->pTHS, newLength*sizeof(DWORD));
            }
            *pDNTsLength = newLength;
        }

        (*ppDNTs)[*pDNTsCount] = ThisDNT;
        (*pDNTsCount)++;

        // inc perfcounter (counting "activity" by the sd propagator)
        INC(pcSDPropRuntimeQueue);
        PERFINC(pcSDProps);

        if (*pDNTsCount >= dwBatchSize) {
            // we read enough children, we are going to break out of the loop now.
            Assert(*pDNTsCount == dwBatchSize);
            // remember the last RDN we read. We can read from the index (which only contains
            // the first 255 bytes -- might not be the whole RDN), because we don't need the 
            // whole RDN anyway. This value will be used to restart the next batch.
            JetRetrieveColumnSuccess(pDB->JetSessID,
                                     pDB->JetObjTbl,
                                     rdnid,
                                     pLastRDNLoaded,
                                     MAX_RDN_SIZE*sizeof(WCHAR),
                                     pcbLastRDNLoaded,
                                     JET_bitRetrieveFromIndex,
                                     NULL);
            // we know we will break out of the loop, but we will first probe
            // whether there are more children.
        }
        
        err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveNext, 0);
    } while(!eServiceShutdown && err == 0 && *pDNTsCount < dwBatchSize);

    if(eServiceShutdown) {
        return DIRERR_SHUTTING_DOWN;
    }

    if (err == 0) {
        // if err==0 then we broke from the loop because we got the whole batch,
        // and there were more children to read (because we successfully did JetMove)
        Assert(*pDNTsCount == dwBatchSize);
        *pfMoreChildren = TRUE;
    }

    return 0;
}

DWORD
DBSDPropSaveCheckpoint(
        DBPOS * pDB,
        DWORD dwIndex,
        PVOID pCheckpointData,
        DWORD cbCheckpointData
        )
/*++
Routine Description:

    Saves checkpoint data in a SDPROP entry

Parameters:

    pDB - the active database handle
    dwIndex - index of the SDPROP entry
    pCheckpointData - buffer with data
    cbCheckpointData - length of the buffer

Return Codes:

    returns 0 if all went well, a non-zero error code otherwise.

--*/
{
    THSTATE *pTHS=pDB->pTHS;
    JET_ERR     err=0;
    DWORD       index, cbActual;

    Assert(VALID_DBPOS(pDB));

    Assert(pDB->JetSDPropTbl);

    // locate the SDPROP entry
    
    // Set to the order index.
    JetSetCurrentIndex2Success(pDB->JetSessID, 
                               pDB->JetSDPropTbl, 
                               NULL,   // OPTIMISATION: pass NULL when switching to primary index (SZORDERINDEX)
                               JET_bitMoveFirst
                              );

    JetMakeKeyEx(pDB->JetSessID, pDB->JetSDPropTbl, &dwIndex, sizeof(dwIndex), JET_bitNewKey);

    // Find the appropriate object.
    if(err = JetSeekEx(pDB->JetSessID, pDB->JetSDPropTbl, JET_bitSeekEQ)) {
        return err;
    }

    // The jet calls below all either succeed or except
    // Prepare the insert
    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSDPropTbl, DS_JET_PREPARE_FOR_REPLACE);
    __try {
        JetSetColumnSuccess(pDB->JetSessID, pDB->JetSDPropTbl, sdpropcheckpointid, pCheckpointData, cbCheckpointData, 0, NULL);
        JetUpdateEx(pDB->JetSessID, pDB->JetSDPropTbl, NULL, 0, NULL);
    }
    __finally {
        if (AbnormalTermination()) {
            JetPrepareUpdate(pDB->JetSessID,pDB->JetSDPropTbl,JET_prepCancel);
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbsetup.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dbsetup.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements DBLayer functions to deal with initial setup.  This
    includes moving the schema that is in the boot DB to the correct place, and
    then walking through that schema fixing up a number of attributes.


Author:

    Tim Williams (timwi) 5-June-1998

Revision History:

--*/
#include <NTDSpch.h>
#pragma  hdrstop

#include <limits.h>

#include <dsjet.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <dsatools.h>
#include <mdlocal.h>

#include <mdcodes.h>
#include <dsevent.h>
#include <anchor.h>

#include <sddlp.h>

#include <dsexcept.h>
#include "objids.h"     /* Contains hard-coded Att-ids and Class-ids */
#include "debug.h"      /* standard debugging header */
#define DEBSUB     "DBSETUP:"   /* define the subsystem for debugging */

#include "dbintrnl.h"

#include <fileno.h>
#define FILENO_DBSETUP 1
#define  FILENO FILENO_DBSETUP

int
IntExtSecDesc(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG intLen,   UCHAR *pIntVal,
              ULONG *pExtLen, UCHAR **ppExtVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG SecurityInformation);

int
ExtIntSecDesc(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG extLen,   UCHAR *pExtVal,
              ULONG *pIntLen, UCHAR **ppIntVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags);

VOID
dbGetSDForSchemaObjects(
        IN  DBPOS *pDB,
        OUT DWORD *pcbAttSD,
        OUT BYTE **ppAttSD,
        OUT DWORD *pcbClassSD,
        OUT BYTE **ppClassSD,
        OUT DWORD *pcbSubSchemaSD,
        OUT BYTE **ppSubSchemaSD
        )
/*++

  Description:
     Read the SD on the current object (which should be the new schema
     container).  Create the default SD for schema objects.  Merge the two.
     Return the merged SD as the SD that is written on schema objects.

  Parameters:
     pDB - The current dbpos to use
     pcbSD - place to return the size in bytes of the SD to write on schema
           objects.
     ppAncestors - place to return an SD to write on schema objects.

  Return values:
     None.  It either succeeds, or it causes an exception.
--*/
{
    BYTE  *pContainerSD;
    DWORD  cbContainerSD;
    DWORD  err;
    THSTATE *pTHS = pDB->pTHS;
    CLASSCACHE *pClassSch=SCGetClassById(pTHS,CLASS_CLASS_SCHEMA);
    CLASSCACHE *pAttSch = SCGetClassById(pTHS, CLASS_ATTRIBUTE_SCHEMA);
    CLASSCACHE *pAggregate = SCGetClassById(pTHS, CLASS_SUBSCHEMA);
    PSECURITY_DESCRIPTOR pDefaultSD = NULL;
    DWORD                cbDefaultSD;
    PSECURITY_DESCRIPTOR pMergedSD=NULL;     // SD to write on the object.
    DWORD                cbMergedSD;
    GUID                 *ppGuid[1];


    *ppAttSD = NULL;
    *ppClassSD = NULL;
    *ppSubSchemaSD = NULL;

    // Get the SD
    err = DBGetAttVal(pDB, 1, ATT_NT_SECURITY_DESCRIPTOR, 0, 0, &cbContainerSD, (UCHAR**) &pContainerSD);
    if (err) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
        return; // just to fool PREFIX
    }

#define DEFAULT_SD_FOR_SCHEMA_OBJECTS "O:SAG:SAD:S:"
    // OK, create the default SD from the string.
    if(!ConvertStringSDToSDRootDomainA (
            gpRootDomainSid,
            DEFAULT_SD_FOR_SCHEMA_OBJECTS,
            SDDL_REVISION_1,
            &pDefaultSD,
            &cbDefaultSD
            )) {
        // Failed.
        DsaExcept(DSA_DB_EXCEPTION, GetLastError(), 0);
    }

    __try {
        ppGuid[0] = &(pClassSch->propGuid);


        // Make the CLASS_CLASS_SCHEMA version of the SD
        err = MergeSecurityDescriptorAnyClient(
                pTHS,
                pContainerSD,
                cbContainerSD,
                pDefaultSD,
                cbDefaultSD,
                (SACL_SECURITY_INFORMATION  |
                 OWNER_SECURITY_INFORMATION |
                 GROUP_SECURITY_INFORMATION |
                 DACL_SECURITY_INFORMATION   ),
                (MERGE_CREATE | MERGE_AS_DSA),
                ppGuid,
                1,
                NULL,
                &pMergedSD,
                &cbMergedSD
                );

        if(err) {
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }

        (*ppClassSD) = THAllocEx(pTHS, cbMergedSD);
        *pcbClassSD = cbMergedSD;
        memcpy((*ppClassSD), pMergedSD, cbMergedSD);
        DestroyPrivateObjectSecurity(&pMergedSD);
        pMergedSD = NULL;
        ppGuid[0] = &(pAttSch->propGuid);

        // Make the CLASS_ATTRIBUTE_SCHEMA version of the SD
        err = MergeSecurityDescriptorAnyClient(
                pTHS,
                pContainerSD,
                cbContainerSD,
                pDefaultSD,
                cbDefaultSD,
                (SACL_SECURITY_INFORMATION  |
                 OWNER_SECURITY_INFORMATION |
                 GROUP_SECURITY_INFORMATION |
                 DACL_SECURITY_INFORMATION   ),
                (MERGE_CREATE | MERGE_AS_DSA),
                ppGuid,
                1,
                NULL,
                &pMergedSD,
                &cbMergedSD
                );
        if(err) {
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }

        (*ppAttSD) = THAllocEx(pTHS, cbMergedSD);
        *pcbAttSD = cbMergedSD;
        memcpy((*ppAttSD), pMergedSD, cbMergedSD);
        DestroyPrivateObjectSecurity(&pMergedSD);
        pMergedSD = NULL;
        ppGuid[0] = &(pAggregate->propGuid);

        // Make the CLASS_SUBSCHEMA_SCHEMA version of the SD
        err = MergeSecurityDescriptorAnyClient(
                pTHS,
                pContainerSD,
                cbContainerSD,
                pDefaultSD,
                cbDefaultSD,
                (SACL_SECURITY_INFORMATION  |
                 OWNER_SECURITY_INFORMATION |
                 GROUP_SECURITY_INFORMATION |
                 DACL_SECURITY_INFORMATION   ),
                (MERGE_CREATE | MERGE_AS_DSA),
                ppGuid,
                1,
                NULL,
                &pMergedSD,
                &cbMergedSD
                );
        if(err) {
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }

        (*ppSubSchemaSD) = THAllocEx(pTHS, cbMergedSD);
        *pcbSubSchemaSD = cbMergedSD;
        memcpy((*ppSubSchemaSD), pMergedSD, cbMergedSD);
        DestroyPrivateObjectSecurity(&pMergedSD);
        pMergedSD = NULL;
    }
    __finally {
        if (AbnormalTermination()) {
            // get rid of allocated memory
            if (*ppAttSD) {
                THFreeEx(pTHS, *ppAttSD);
                *ppAttSD = NULL;
            }
            if (*ppClassSD) {
                THFreeEx(pTHS, *ppClassSD);
                *ppClassSD = NULL;
            }
            if (*ppSubSchemaSD) {
                THFreeEx(pTHS, *ppSubSchemaSD);
                *ppSubSchemaSD = NULL;
            }
        }
        if(pMergedSD) {
            DestroyPrivateObjectSecurity(&pMergedSD);
        }
        LocalFree(pDefaultSD);
        THFreeEx(pTHS, pContainerSD);
    }

    return;
}

VOID
dbGetAncestorsForSetup(
        IN  DBPOS *pDB,
        OUT DWORD *pcAncestors,
        OUT DWORD **ppAncestors
        )
/*++

  Description:
     Read the ancestors value for the object that has DB currency.  Allocate one
     extra DWORD on the end.  We use this to set new ancestors on the objects in
     the schema that we are about to reparent from the boot schema to the
     runtime schema.

  Parameters:
     pDB - The current dbpos to use
     pcAncestors - place to return the number of DWORDs in the ppAncestors
           array.
     ppAncestors - place to return an ancestors array.

  Return values:
     None.  It either succeeds, or it causes an exception.
--*/
{
    DWORD *pAncestors;
    DWORD  err;
    DWORD  actuallen;
    BOOL   done = FALSE;
    DWORD  cNumAncestors = 24;

    // Guess at a number of ancestors.
    pAncestors = THAllocEx(pDB->pTHS, (cNumAncestors + 1) * sizeof(DWORD));

    while(!done) {
        err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                        pDB->JetObjTbl,
                                        ancestorsid,
                                        pAncestors,
                                        cNumAncestors * sizeof(DWORD),
                                        &actuallen, 0, NULL);
        switch (err) {
        case 0:
            // OK, we got the ancestors.  Realloc down
            pAncestors = THReAllocEx(pDB->pTHS, pAncestors,
                                     (actuallen + sizeof(DWORD)));
            done = TRUE;
            break;

        case JET_wrnBufferTruncated:
            // Failed to read, not enough memory.  Realloc it larger.
            pAncestors = THReAllocEx(pDB->pTHS, pAncestors,
                                     (actuallen +  sizeof(DWORD)));

            cNumAncestors = actuallen / sizeof(DWORD);
            break;

        default:
            // Failed badly.
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
            break;
        }
    }

    *pcAncestors = actuallen / sizeof(DWORD);
    *ppAncestors = pAncestors;
    return;
}

VOID
dbGetAndFixMetaData (
        IN     DBPOS *pDB,
        IN     ATTCACHE *pAC,
        IN OUT BYTE **ppMetaData,
        IN OUT DWORD *pcbMetaDataAlloced,
        OUT    DWORD *pcbMetaDataUsed)
/*++

  Description:
      Read the metadata of the object that has currency in the object table.
      Then, spin through the metadata retrieved and fix some fields:
                uuidDsaOriginating
                timeChanged

  Parameters
     pDB - The current dbpos to use
     pAC - attcache pointer of the metadata attribute.  Passed in since we use
           this routine a lot and passing it in saves us from looking it up all
           the time.
     ppMetaData - pointer to a THReAllocable buffer (i.e. some buffer has
           already been THAlloc'ed, and this routine may THReAlloc if it
           wishes.)
     pcbMetaDataAlloced - size of ppMetaData.  If this routine reallocs, it
           needs to update this count.
     pcbMetaDataUsed - Actual size of the metadata read during this routine.

  Return Value:
     None.  This routine succeeds in reading a metadata and then fixing it up,
     or it causes an exception.

--*/
{
    THSTATE *pTHS = pDB->pTHS;
    DWORD err;
    BOOL done = FALSE;
    PROPERTY_META_DATA_VECTOR *pMeta;
    DWORD  i;
    DSTIME timeNow = DBTime();

    while(!done) {
        err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                        pDB->JetObjTbl,
                                        pAC->jColid,
                                        *ppMetaData,
                                        *pcbMetaDataAlloced,
                                        pcbMetaDataUsed,
                                        JET_bitRetrieveCopy, NULL);
        switch(err) {
        case 0:
            // Read it.  return
            done = TRUE;
            break;

        case JET_wrnBufferTruncated:
            // Need more space
            *ppMetaData = THReAllocEx(pTHS, *ppMetaData, *pcbMetaDataUsed);
            *pcbMetaDataAlloced = *pcbMetaDataUsed;
            break;

        default:
            // Huh?
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
            break;
        }
    }

    pMeta = (PROPERTY_META_DATA_VECTOR *)*ppMetaData;
    // OK, we need to spin through here and fix the uuidDsaOriginating and
    // timeChanged.
    for(i=0;i<pMeta->V1.cNumProps;i++) {
        pMeta->V1.rgMetaData[i].uuidDsaOriginating = pTHS->InvocationID;
        pMeta->V1.rgMetaData[i].timeChanged = timeNow;
    }
    return;

}

// These are the DNTs of the distribution boot tree. They are magic.  If we
// change mkdit.exe, then these numbers might need to change.  Note, however,
// that if mkdit does end up changing these numbers, then we have an
// incompatable change in the DIT; new binaries will be necessary to deal with
// the new DNTs.
#define MAGIC_DNT_BOOT         4
#define MAGIC_DNT_BOOT_SCHEMA  5
#define MAGIC_DNT_BOOT_MACHINE 7

DWORD
DBInitialSetup(
        IN WCHAR *pName
        )
/*
   Description:
         This routine spins through the schema that is in the distribution DIT
     and moves the objects in that schema to the new schema container specified
     as a parameter.  This involves changing a few of the attributes on each
     object.  This code is called from the install code in the boot code.  It
     should only ever be called from there.
         If pName is NULL, then spin through the distribution schema and delete
     objects.
   Parameters:
     pName - the friendly name of the new schema container
         (e.g. "CN=Schema,CN=Configuration,DC=Microsoft,DC=COM").
             NULL means to delete the boot schema.

   Return Values:
      Three main cases:
      1) returns 0 on success.
      2) returns non zero on some simple failures.
      3) Causes an exception on other errors.
-*/
{
    PDBPOS        pDB;
    ATTCACHE     *pAC;
    PDSNAME       pDN=NULL;
    DWORD         cAncestors;
    DWORD        *pAncestors;
    GUID          newGuid;
    DWORD         DNTNewContainer;
    DWORD         BootSchemaDNT = MAGIC_DNT_BOOT_SCHEMA;
    DWORD         BootMachineDNT = MAGIC_DNT_BOOT_MACHINE;
    DWORD         BootDNT = MAGIC_DNT_BOOT;
    DWORD         cb;
    BYTE         *pMetaData;
    DWORD         cbMetaDataAlloced;
    DWORD         cbMetaDataUsed;
    JET_SETCOLUMN setColumnInfo[6];
    JET_SETCOLUMN deleteSetColumnInfo[2];
    BOOL          fCommit = FALSE;
    DWORD         count=0;
    DWORD         err=0;
    ATTRTYP       objClass;
    JET_RETRIEVECOLUMN retColumnInfo[3];
    DWORD         cbClassSD;
    BYTE         *pClassSD=NULL;
    DWORD         cbAttSD;
    BYTE         *pAttSD=NULL;
    DWORD         cbAggregateSD;
    BYTE         *pAggregateSD=NULL;
    INDEX_VALUE   IV;
    DSTIME        time=1;
    DWORD         cColumns, cDeleteColumns;
    BOOL          isDeletedVal = TRUE;
    PUCHAR       *pOldSD = NULL, pNewSD = NULL, pIntSD = NULL;
    DWORD         cbOldSD, cbNewSD, cbIntSD;

    DBOpen(&pDB);

    if (!pDB) {
        return DB_ERR_UNKNOWN_ERROR;
    }

    __try {
#if DBG
        {
            ATTRTYP objClass;
            DWORD err2, len;

            // Verify the boot schema container.
            DBFindDNT(pDB, BootSchemaDNT);
            err2 = DBGetSingleValue(pDB,
                                    ATT_OBJECT_CLASS,
                                    &objClass,
                                    sizeof(objClass),
                                    &len);

            Assert(!err2);
            Assert(len == sizeof(DWORD));
            Assert(objClass == CLASS_DMD);
        }
#endif

        if(pName) {
            // Moving things to a new container.  Set up a buffer we'll need for
            // updating the meta data vector for the objects we move.
            pAC = SCGetAttById(pDB->pTHS, ATT_REPL_PROPERTY_META_DATA);

            pMetaData = THAllocEx(pDB->pTHS, 0x500);
            cbMetaDataAlloced = 0x500;
            cbMetaDataUsed = 0;

            // Find the DNT of the new schema container.
            UserFriendlyNameToDSName(pName, wcslen(pName), &pDN);

            err = DBFindDSName(pDB, pDN);
            if(err) {
                __leave;
            }

            DNTNewContainer = pDB->DNT;

            // The ancestors value on the schema objects need to inherit from
            // this container.
            dbGetAncestorsForSetup( pDB, &cAncestors, &pAncestors);
            cAncestors++;

            // Finally, get the security descriptors we're going to put on the
            // various classes of objects we move.
            dbGetSDForSchemaObjects(pDB,
                                    &cbAttSD,
                                    &pAttSD,
                                    &cbClassSD,
                                    &pClassSD,
                                    &cbAggregateSD,
                                    &pAggregateSD);
        }
        // ELSE {
        //       Delete case.  Obviously, we don't need to find any new
        //       container DNT, we don't have a new container.
        // }


        // Set up the Jet data structure we use to read information off of each
        // schema object.

        memset(retColumnInfo, 0, sizeof(retColumnInfo));

        retColumnInfo[0].columnid = dntid;
        retColumnInfo[0].pvData = &pAncestors[cAncestors - 1];
        retColumnInfo[0].cbData = sizeof(DWORD);
        retColumnInfo[0].cbActual = sizeof(DWORD);
        retColumnInfo[0].grbit = JET_bitRetrieveCopy;
        retColumnInfo[0].itagSequence = 1;

        retColumnInfo[1].columnid = objclassid;
        retColumnInfo[1].pvData = &objClass;
        retColumnInfo[1].cbData = sizeof(objClass);
        retColumnInfo[1].cbActual = sizeof(objClass);
        retColumnInfo[1].grbit = JET_bitRetrieveCopy;
        retColumnInfo[1].itagSequence = 1;

        retColumnInfo[2].columnid = ntsecdescid;
        retColumnInfo[2].pvData = THAllocEx(pDB->pTHS, sizeof(SDID));
        retColumnInfo[2].cbData = sizeof(SDID);
        retColumnInfo[2].cbActual = sizeof(SDID);
        retColumnInfo[2].grbit = JET_bitRetrieveCopy;
        retColumnInfo[2].itagSequence = 1;


        // Setup the invariant portions of the deleteSetColumnInfo.  We use this
        // in both the deletion case and the move case.
        memset(deleteSetColumnInfo, 0, sizeof(deleteSetColumnInfo));

        deleteSetColumnInfo[0].columnid = isdeletedid;
        deleteSetColumnInfo[0].pvData = &isDeletedVal;
        deleteSetColumnInfo[0].cbData = sizeof(isDeletedVal);
        deleteSetColumnInfo[0].itagSequence = 1;

        deleteSetColumnInfo[1].columnid = deltimeid;
        deleteSetColumnInfo[1].pvData = &time;
        deleteSetColumnInfo[1].cbData = sizeof(time);
        deleteSetColumnInfo[1].itagSequence = 1;

        cDeleteColumns = 2;

        if(pName) {
            // Setup the invariant portions of the setColumnInfo for the move
            // case.
            memset(setColumnInfo, 0, sizeof(setColumnInfo));

            setColumnInfo[0].columnid = pdntid;
            setColumnInfo[0].pvData = &DNTNewContainer;
            setColumnInfo[0].cbData = sizeof(DNTNewContainer);
            setColumnInfo[0].itagSequence = 1;

            setColumnInfo[1].columnid = ncdntid;
            setColumnInfo[1].pvData = &DNTNewContainer;
            setColumnInfo[1].cbData = sizeof(DNTNewContainer);
            setColumnInfo[1].itagSequence = 1;

            setColumnInfo[2].columnid = ancestorsid;
            setColumnInfo[2].pvData = pAncestors;
            setColumnInfo[2].cbData = cAncestors * sizeof(DWORD);
            setColumnInfo[2].itagSequence = 1;

            setColumnInfo[3].columnid = guidid;
            setColumnInfo[3].pvData = &newGuid;
            setColumnInfo[3].cbData = sizeof(newGuid);
            setColumnInfo[3].itagSequence = 1;

            setColumnInfo[4].columnid = ntsecdescid;
            // setColumnInfo[4] actual data pointers set inside the loop
            setColumnInfo[4].itagSequence = 1;

            setColumnInfo[5].columnid = pAC->jColid;
            setColumnInfo[5].itagSequence = 1;
            // setColumnInfo[5] actual data pointers set inside the loop

            cColumns = 6;
        }
        else {
            // Setup the invariant portions of the setColumnInfo for the
            // deletion case.  In this case, use exactly the same data we set up
            // for the deleteSetColumn case.
            memcpy(setColumnInfo, deleteSetColumnInfo,
                   sizeof(deleteSetColumnInfo));

            cColumns =  cDeleteColumns;
        }

        // Now, spin over all the children of the boot schema container and
        // do the following:
        // 1) Retrieve the DNT, used to fix up the Ancestors attribute.
        // 2) Retrieve and fix up the repl meta data on the object
        // 3) Modify the PDNT to be the new schema container.
        // 4) Modify the NCDNT to be the new schema container.
        // 5) Modify the Ancestors attribute to hold the correct value based on
        //    the new position.
        // 6) Give the object a new GUID.
        // 7) Write the default SD for the object.
        // 8) Write back the edited meta data

        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetObjTbl,
                                  SZPDNTINDEX);


        JetMakeKeyEx(pDB->JetSessID,
                     pDB->JetObjTbl,
                     &BootSchemaDNT,
                     sizeof(BootSchemaDNT),
                     JET_bitNewKey);

        //  NOTE: if this seek fails with JET_errRecordNotFound
        //  (because there are no index entries with
        //  PDNT>=BootSchemaDNT), the error will get trapped
        //  by JetSetIndexRange() below because that API
        //  call will fail with JET_errNoCurrentRecord
        //
        JetSeekEx( pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekGE );

        JetMakeKeyEx(
                pDB->JetSessID,
                pDB->JetObjTbl,
                &BootSchemaDNT,
                sizeof(BootSchemaDNT),
                JET_bitNewKey|JET_bitFullColumnEndLimit );

        //  UNDONE: should use JetSetIndexRangeEx(), but
        //  unfortunately that function currently
        //  ignores JET_errNoCurrentRecord
        //
        err = JetSetIndexRange(
                pDB->JetSessID,
                pDB->JetObjTbl,
                JET_bitRangeUpperLimit );
        if ( JET_errSuccess != err )
        {
            //  if the error is JET_errNoCurrentRecord, then
            //  something is gravely wrong because it means
            //  we're missing PDNT==MAGIC_DNT_BOOT_SCHEMA
            //
            DsaExcept( DSA_DB_EXCEPTION, (ULONG)err, 0 );
        }

        do
        {
            if ( pName )
            {
                //  NOTE: the index range guarantees that
                //  we are still on PDNT==BootSchemaDNT
                //
                //  Read the DNT, the objectclass and the SD of the current object.
                //
                err = JetRetrieveColumnsWarnings(
                                pDB->JetSessID,
                                pDB->JetObjTbl,
                                retColumnInfo,
                                3 );

                if ( JET_wrnBufferTruncated == err
                    && JET_wrnBufferTruncated == retColumnInfo[2].err )
                {
                    DPRINT(0, "SD in data table longer than SDHASHLENGTH: using an old-style initial DIT???");

                    //  realloc the sd buffer
                    //
                    retColumnInfo[2].pvData = THReAllocEx(pDB->pTHS, retColumnInfo[2].pvData, retColumnInfo[2].cbActual);
                    retColumnInfo[2].cbData = retColumnInfo[2].cbActual;

                    //  reget the SD
                    //
                    err = JetRetrieveColumnsWarnings(
                                    pDB->JetSessID,
                                    pDB->JetObjTbl,
                                    &retColumnInfo[2],
                                    1 );
                }

                if ( JET_errSuccess != err )
                {
                    //  unknown/unexpected db problem
                    //
                    DsaExcept( DSA_DB_EXCEPTION, (ULONG)err, 0 );
                }

                // dereference the old value
                err = IntExtSecDesc(pDB, DBSYN_REM, retColumnInfo[2].cbActual, retColumnInfo[2].pvData,
                                    &cbOldSD, (UCHAR**)&pOldSD, 0, 0, 0);
                if (err) {
                    // a problem occured
                    DsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0);
                }
                // don't need to get rid of old value -- it is alloced and freed automacially as pDB->valBuf

                // Get the variant portions of the setColumnInfo for the move
                // case.

                // First, what SD do we put on the object.
                switch(objClass) {
                case CLASS_ATTRIBUTE_SCHEMA:
                    pNewSD = pAttSD;
                    cbNewSD = cbAttSD;
                    break;
                case CLASS_CLASS_SCHEMA:
                    pNewSD = pClassSD;
                    cbNewSD = cbClassSD;
                    break;
                case CLASS_SUBSCHEMA:
                    pNewSD = pAggregateSD;
                    cbNewSD = cbAggregateSD;
                    break;
                default:
                    DsaExcept(DSA_DB_EXCEPTION, DB_ERR_UNKNOWN_ERROR,0);
                }

                // convert to internal and inc refCount
                // don't need to worry about int value buffer -- it is alloced and freed automatically as pDB->valBuf
                err = ExtIntSecDesc(pDB, DBSYN_ADD, cbNewSD, pNewSD, &cbIntSD, &pIntSD, 0, 0, 0);
                if (err) {
                    DsaExcept(DSA_DB_EXCEPTION, err, 0);
                }

                setColumnInfo[4].pvData = pIntSD;
                setColumnInfo[4].cbData = cbIntSD;

                // Get the data specific to this new object.
                DsUuidCreate(&newGuid);

                // Fixup the metadata
                dbGetAndFixMetaData(pDB, pAC, &pMetaData,
                                    &cbMetaDataAlloced, &cbMetaDataUsed);
                setColumnInfo[5].pvData = pMetaData;
                setColumnInfo[5].cbData = cbMetaDataUsed;
            }
            else
            {
                //  there is no variant portion of the
                //  setColumnInfo for the delete case.
                //
                NULL;
            }

            JetPrepareUpdateEx(
                    pDB->JetSessID,
                    pDB->JetObjTbl,
                    JET_prepReplace );

            JetSetColumnsEx(
                    pDB->JetSessID,
                    pDB->JetObjTbl,
                    setColumnInfo,
                    cColumns );

            JetUpdateEx(
                    pDB->JetSessID,
                    pDB->JetObjTbl,
                    NULL,
                    0,
                    0 );

            count++;

            err = JetMoveEx(
                        pDB->JetSessID,
                        pDB->JetObjTbl,
                        JET_MoveNext,
                        0 );
        }
        while ( JET_errNoCurrentRecord != err );

        //  either we moved to a new PDNT or we fell off the end of the index
        //
        err = JET_errSuccess;

        if(pName) {
            // In the move case, we need to adjust the refcount of the old and
            // new parents.
            DBAdjustRefCount(pDB, DNTNewContainer, count);
            DBAdjustRefCount(pDB, BootSchemaDNT, (-1 * count));
        }


        // Now, move to the distribution machine object.  We're going to
        // delete it. Note that we set the deleteTime to 2, so that garbage
        // collection will find and delete all the schema objects with a
        // deletion time of 1 first, so when it gets around to deleting this
        // object, it will have no refcounts on it.

        DBFindDNT(pDB, BootMachineDNT);
        JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
        JetSetColumnsEx(pDB->JetSessID, pDB->JetObjTbl, deleteSetColumnInfo,
                        cDeleteColumns);
        JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);
        // dbRemoveBackLinksFromPhantom
        DBRemoveAllLinks( pDB, BootMachineDNT, TRUE /*isbacklink*/ );


        // Now, move to the distribution schema container.  We're going to
        // delete it.  It's deletion time is 3, so that garbage collection
        // will  find and delete all the schema objects with a deletion time of
        // 1 first, and then the boot machine with a del time of 2 (which also
        // has some references to the schema), so when it gets around to
        // deleting this object, it will have no refcounts on it.
        time=3;
        DBFindDNT(pDB, BootSchemaDNT);
        JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
        JetSetColumnsEx(pDB->JetSessID, pDB->JetObjTbl, deleteSetColumnInfo,
                        cDeleteColumns);
        JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);
        // dbRemoveBackLinksFromPhantom
        DBRemoveAllLinks( pDB, BootSchemaDNT, TRUE /*isbacklink*/ );

        // Finally, move to the o=BOOT object, We're going to delete it also.
        // Note that we set the deleteTime to 4, so that garbage
        // collection will find and delete the distribution schema container and
        // the distribution machine (which have deletion times of 3 and 2)
        // first, then find this object after it's children are deleted.  It
        // will have no refcounts on it.
        time=4;
        DBFindDNT(pDB, BootDNT);
        JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
        JetSetColumnsEx(pDB->JetSessID, pDB->JetObjTbl, deleteSetColumnInfo,
                        cDeleteColumns);
        JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);
        // dbRemoveBackLinksFromPhantom
        DBRemoveAllLinks( pDB, BootDNT, TRUE /*isbacklink*/ );




        // All done.
        fCommit = TRUE;

    }
    __finally {
        THFreeEx(pDB->pTHS, retColumnInfo[2].pvData); // buffer for reading old SDs
        DBClose(pDB, fCommit);
        if(!err && !fCommit) {
            err = DB_ERR_UNKNOWN_ERROR;
        }
    }

    return err;

}

DWORD
DBMoveObjectDeletionTimeToInfinite(
        DSNAME *pDN
        )
/*++
  Description
      Given a DSNAME, find the object and set it's deletion time to be Later.
      The object must already be deleted, although we don't care if it yet has a
      value for the deletion time column or not.

      Two things get touched here.
      1) Deletion time column gets set.
      2) The modified time for the is-deleted attribute in the metadata is
         modified to Later.  This is so that when this object replicates, the
         deletion time get set appropriately on replicas.  Replication uses the
         modifed time of the is-deleted property to set the deletion time.

      This is a very special purpose routine.  It is currently only called
      during install.

  Parameters
      pDN - dsname of the object to set deletion time on.

  Return values:
      returns 0 if all went well, non-zero for some errors, and excepts for some
      others.

--*/
{
    DBPOS                     *pDB = NULL;
    ATTCACHE                  *pAC = NULL;
    BOOL                       done;
    BOOL                       isDeletedVal;
    BOOL                       fCommit = FALSE;
    DWORD                      cbMeta, cb, i;
    DWORD                      err;
    PROPERTY_META_DATA_VECTOR *pMeta;
    JET_SETCOLUMN              deleteSetColumnInfo[2];
    DSTIME                     Later=0x3db6022f7f;
    // Later = December 30, 23:59:59, year 9999

    DBOpen(&pDB);
    __try {
        // First, find the object.
        err = DBFindDSName(pDB, pDN);
        if(err) {
            __leave;
        }

        // Now, get the isDeleted attribute.  We will succeed this call if that
        // attribute is already set to true.
        if(err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                           pDB->JetObjTbl,
                                           isdeletedid,
                                           &isDeletedVal,
                                           sizeof(isDeletedVal),
                                           &cb,
                                           JET_bitRetrieveCopy, NULL)) {
            // Oops, couldn't read isDeleted,  fail.
            __leave;
        }

        // OK we read a value.  Make sure it was TRUE
        if(!isDeletedVal) {
            err = DB_ERR_UNKNOWN_ERROR;
            __leave;
        }


        pAC = SCGetAttById(pDB->pTHS, ATT_REPL_PROPERTY_META_DATA);
        Assert(pAC);
        if (!pAC)
            return DB_ERR_UNKNOWN_ERROR;

        pMeta = THAllocEx(pDB->pTHS, 0x500);
        cbMeta = 0x500;

        // Get the metadata that's on the object.   We need to tweak it some.
        done = FALSE;
        while(!done) {
            err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                            pDB->JetObjTbl,
                                            pAC->jColid,
                                            pMeta,
                                            cbMeta,
                                            &cbMeta,
                                            JET_bitRetrieveCopy, NULL);
            switch(err) {
            case 0:
                // Read it.  return
                done = TRUE;
                break;

            case JET_wrnBufferTruncated:
                // Need more space
                pMeta = THReAllocEx(pDB->pTHS, pMeta, cbMeta);
                break;

            default:
                // Huh?
                DsaExcept(DSA_DB_EXCEPTION, err, 0);
                break;
            }
        }

        Assert(!err);
        // Now, look through the metadata to find the is-deleted entry.  It must
        // be there, or we will fail.  Once found, set the modified time for the
        // is-deleted attribute to 0xFFFFFFFF
        done = FALSE;

        for(i=0;i<pMeta->V1.cNumProps;i++) {
            if(pMeta->V1.rgMetaData[i].attrType == ATT_IS_DELETED) {
                done = TRUE;
                pMeta->V1.rgMetaData[i].timeChanged = Later;
                break;
            }
        }

        if(!done) {
            // failed to find a deletion time already in the index.
            err = DB_ERR_UNKNOWN_ERROR;
            __leave;
        }

        // Setup the setColumnInfo data structure for the JetSetColumns call.
        memset(deleteSetColumnInfo, 0, sizeof(deleteSetColumnInfo));

        // Shove the tweaked metadata back into the object.
        deleteSetColumnInfo[0].columnid = pAC->jColid;
        deleteSetColumnInfo[0].pvData = pMeta;
        deleteSetColumnInfo[0].cbData = cbMeta;
        deleteSetColumnInfo[0].itagSequence = 1;

        // Set the local delete time to much later so we can avoid garbage
        // collection.  Note that we don't care if it actually has a value right
        // now, we are going to unilaterally set it to Later.
        deleteSetColumnInfo[1].columnid = deltimeid;
        deleteSetColumnInfo[1].pvData = &Later;
        deleteSetColumnInfo[1].cbData = sizeof(Later);
        deleteSetColumnInfo[1].itagSequence = 1;

        JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
        JetSetColumnsEx(pDB->JetSessID, pDB->JetObjTbl, deleteSetColumnInfo,
                        2);
        JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);

        // All done.
        fCommit = TRUE;
    }
    __finally {
        DBClose(pDB, fCommit);
        if(!err && !fCommit) {
            err = DB_ERR_UNKNOWN_ERROR;
        }
    }

    return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbsyntax.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dbsyntax.c
//
//--------------------------------------------------------------------------


#include <NTDSpch.h>
#pragma  hdrstop


#include <dsjet.h>
#include <ntrtl.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <mdglobal.h>                   // For dsatools.h
#include <dbglobal.h>                   //
#include <dsatools.h>                   // For pTHStls
#include <dsexcept.h>
#include <attids.h>
#include <crypto\md5.h>

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>
#include <dsevent.h>

// Assorted DSA headers
#include <filtypes.h>                   // Def of FI_CHOICE_???
#include   "debug.h"                    // standard debugging header
#define DEBSUB     "DBSYNTAX:"          // define the subsystem for debugging

// Password encryption
#include <pek.h>

// DBLayer includes
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBSYNTAX

// Yes, I know this looks like it overwrites the pValBuf with a NULL if the
// dbReAlloc fails.  However, dbReAlloc is wired to throw an exception if it
// fails, so either the realloc works and life is good, or it fails and we
// except out without overwriting pDB->pValBuf.  In both cases, pDB->pValBuf and
// pDB->valBufSize are maintained as a valid pair.
// Also note: pDBHiddens val buf is malloced and should never have to grow, but
// we have code here to do it if we need to.
//
// WARNING: Any pointers that references the buffer returned by a MAKEBIG call
// can be invalidated by a second MAKEBIG call. This is because the Realloc call
// that this macro makes can change the value of pDB->pValBuf.
//

#define MAKEBIG_VALBUF(size)                                    \
    if ((size) > pDB->valBufSize){                              \
        size_t sizeNew = max((size),VALBUF_INITIAL);            \
        if(pDB == pDBhidden) {                                  \
            PUCHAR pTemp;                                       \
            Assert(!"Growing hidden dbpos's valbuf!\n");        \
            pTemp = malloc(sizeNew);                            \
            if(!pTemp) {                                        \
                DsaExcept(DSA_MEM_EXCEPTION, sizeNew, 0);       \
            }                                                   \
            free(pDB->pValBuf);                                 \
            pDB->pValBuf = pTemp;                               \
            pDB->valBufSize = sizeNew;                          \
        }                                                       \
        else {                                                  \
            if (pDB->pValBuf) {                                 \
                pDB->pValBuf = dbReAlloc(pDB->pValBuf, sizeNew);\
            } else {                                            \
                pDB->pValBuf = dbAlloc(sizeNew);                \
            }                                                   \
            pDB->valBufSize = sizeNew;                          \
        }                                                       \
    }

#define NULLTAG ((ULONG) 0)

#define MAXSYNTAX       18  // The largest number of att syntaxes

/* The type of test for syntax Eval. */

#define DBSYN_EQUAL     0
#define DBSYN_SUB       1
#define DBSYN_GREQ      2
#define DBSYN_LEEQ      3
#define DBSYN_PRES      4

/* Error codes from syntax functions*/

#define DBSYN_BADOP   10
#define DBSYN_BADCONV 11
#define DBSYN_SYSERR  12

// Table of valid relational operators indexed by syntax
WORD    rgValidOperators[] =
{
    (WORD) 0,                               // syntax undefined

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax distname
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax object id
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax case string
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax no case string
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax print case string
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax numeric print case string
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_PRESENT)  | // Distname + Binary
    RelOpMask(FI_CHOICE_EQUALITY)      |
    RelOpMask(FI_CHOICE_NOT_EQUAL)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax boolean
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax integer
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
        RelOpMask(FI_CHOICE_PRESENT) |
        RelOpMask(FI_CHOICE_BIT_OR) |
        RelOpMask(FI_CHOICE_BIT_AND)),


    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax octet string
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax time
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax unicode
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax address
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax distname string
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)) ,

    (WORD) 0,                           // syntax security descriptor

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax large integer
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT) |
        RelOpMask(FI_CHOICE_BIT_OR) |
        RelOpMask(FI_CHOICE_BIT_AND)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax  SID
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT))
};


/*Internal functions*/

#define CMP_LT          1
#define CMP_LENGTH_LT   2
#define CMP_EQUAL       4
#define CMP_LENGTH_GT   8
#define CMP_GT          16
#define CMP_ERROR       32

int
CompareStr(
    BOOL Case,
    LPCSTR str1,
    int cch1,
    LPCSTR str2,
    int cch2
    );

int
CompareUnicodeStr(
    THSTATE *pTHS,
    LPCWSTR wstr1,
    int cwch1,
    LPCWSTR wstr2,
    int cwch2
    );

BOOL CompareSubStr(BOOL Case,
                   SUBSTRING * pSub, UCHAR * pIntVal, ULONG intValLen);

BOOL CompareUnicodeSubStr(THSTATE *pTHS,
                          SUBSTRING *pSub, UCHAR *pIntVal, ULONG intValLen);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int IntExtUnd(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG intLen,   UCHAR *pIntVal,
              ULONG *pExtLen, UCHAR **ppExtVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));
   DPRINT(3,"IntExtUnd entered\n");
    *ppExtVal = pIntVal;
   *pExtLen   = intLen;
   return 0;

   (void) flags;           /*NotReferenced*/
   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtUnd*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int ExtIntUnd(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG extLen,   UCHAR *pExtVal,
              ULONG *pIntLen, UCHAR **ppIntVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
   DPRINT(3,"ExtIntUnd entered\n");
   *ppIntVal  = pExtVal;
   *pIntLen = extLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntUnd*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Undefined syntax only supports a check for presence */

int EvalUnd(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
            UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2){

    DPRINT(3,"EvalUnd entered\n");

   if (Oper == FI_CHOICE_PRESENT)
      return TRUE;
   else
      return DBSYN_BADOP;

   (void *) pDB;           /*NotReferenced*/
   (void)   intLen1;       /*NotReferenced*/
   (void)   intLen2;       /*NotReferenced*/
   (void *) pIntVal1;      /*NotReferenced*/
   (void *) pIntVal2;      /*NotReferenced*/

}/*EvalUnd*/

/*
 * What an appalling hack.  We have a perfectly good dsname allocated off
 * of the transaction heap, but we may need to copy it into the db heap
 */
void PossiblyCopyDSName(DBPOS * pDB, DSNAME *pDN)
{
    THSTATE  *pTHS=pDB->pTHS;

    if (pDB->pTHS->hHeapOrg || pDB == pDBhidden) {
    /* We've allocated this DSNAME off of the wrong heap,
     * because someone is using that trouble-ridden mark/free-to-mark
     * stuff, and we're on an inferior heap, and we need to return
     * this data off of the original heap, in order to match
     * "normal" dbAlloc semantics.  If the current DBPOS buffer isn't
     * big enough we'll need to allocate a larger one, and then we
     * must copy the data from the current buffer into the DBPOS one.
     */
        // NOTE: the assert is here because we want to find pople who are
    // reading external format dsnames on the hidden dbpos.
        Assert(pDB != pDBhidden);
    MAKEBIG_VALBUF(pDN->structLen);
    memcpy(pDB->pValBuf, pDN, pDN->structLen);
    THFree(pDN);
    }
    else {
    /* We've allocated the data from the right heap, but we still
     * need to make it appear as though our freshly allocated buffer
     * is the DBPOS's normal output buffer.
     */
    if (pDB->valBufSize) {
        dbFree(pDB->pValBuf);
    }
    pDB->valBufSize = pDN->structLen;
    pDB->pValBuf = (UCHAR *)pDN;
    }
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Converts an internal DistName (ULONG) to a syntax_distname by calling the
   subject table translation routines.
*/

int
IntExtDist(DBPOS FAR *pDB, USHORT extTableOp,
           ULONG intLen, UCHAR *pIntVal,
           ULONG *pExtLen, UCHAR **ppExtVal,
           ULONG ulUpdateDnt, JET_TABLEID jTbl,
           ULONG flags)
{
    int    rtn;
    ULONG  tag;
    DBPOS  *pDBtmp;
    DSNAME *pDNTmp;

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

    DPRINT(3,"IntExtDist entered\n");
    if (intLen != sizeof(ULONG))             /*Must have a name tag */
        return DBSYN_BADCONV;

    tag = *(ULONG*)pIntVal;

    /* First retrieve the Dist Name based on the tag */
    Assert (extTableOp != DBSYN_ADD);
    switch (extTableOp) {
    case DBSYN_REM:
        if(rtn = sbTableGetDSName(pDB,
                                  tag,
                  &pDNTmp,
                                  0)) {
            DPRINT1(1,"DN DistName retrieval failed <%u>..returning\n",rtn);
            return rtn;
        }
        else {
            *pExtLen = pDNTmp->structLen;
            PossiblyCopyDSName(pDB, pDNTmp);
            *ppExtVal = pDB->pValBuf;
        }

        if ( flags & INTEXT_BACKLINK )
        {
            // In the DBSYN_REM case, the flag means this is a backlink.
            // We allow deleting backlinks but this should really only be
            // done when deleting an object. Anyway, All we need to do is
            // adjust the reference count on the current object since the
            // backlink is created as the result of adding a link which
            // updated the reference count on the object that gets the
            // backlink. (this object)

            DBAdjustRefCount(pDB, ulUpdateDnt, -1);
        }
        else
        {
            // Deref the object referenced by the property value being removed.
            DBAdjustRefCount(pDB, tag, -1);
        }

        return 0;
        break;

    case DBSYN_INQ:
        if(rtn=sbTableGetDSName(pDB, tag, &pDNTmp,flags)) {
            DPRINT1(1,"DN DistName retrieval failed <%u>..returning\n",rtn);
            return rtn;
        }
        else {
            *pExtLen = pDNTmp->structLen;
            PossiblyCopyDSName(pDB, pDNTmp);
            *ppExtVal = pDB->pValBuf;
        }
        break;
    default:
        DPRINT(1,"We should never be here\n");
        return DBSYN_BADOP;
    }


    (void) flags;           /*NotReferenced*/

    return 0;
}/*IntExtDist*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Converts an external syntax_distname to an internal DistName (ULONG)  by
   calling the subject table translation routines.
*/

int ExtIntDist(DBPOS FAR *pDB, USHORT extTableOp,
               ULONG extLen,   UCHAR *pExtVal,
               ULONG *pIntLen, UCHAR **ppIntVal,
               ULONG ulUpdateDnt, JET_TABLEID jTbl,
               ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    int    rtn;
    PDSNAME pDN = (PDSNAME)pExtVal;
    ULONG *pTag;
    ULONG actuallen;
    BOOL Deleted = FALSE;

    DPRINT(3,"EXTIntDist entered\n");

    /* Insure that val buf is atleast as big  as the max DN */

    MAKEBIG_VALBUF(sizeof(ULONG));
    pTag = (ULONG *)pDB->pValBuf;       // Convenient rename.
    *ppIntVal = pDB->pValBuf;           // user output points to val buf
    *pIntLen = sizeof(ULONG);           // The size of a name tag

    Assert(extTableOp != DBSYN_REM);

    if ((DBSYN_INQ == extTableOp)
        && (flags & EXTINT_REJECT_TOMBSTONES)
        && !fNullUuid(&pDN->Guid)) {
        // This is a special case where we're resolving a DSNAME into a DNT in
        // order to add it as the value of a linked attribute during inbound
        // replication.  We don't really care about the vast majority of
        // information on the record; all we want to know is (a) the DNT and
        // (b) whether the record is a deleted object (phantoms are okay).
        //
        // Shortcut the lookup to avoid pulling in the record's page -- this
        // will make e.g. adding large groups much faster, which will also help
        // minimize write conflicts (see bug 419338).
        Assert(pTHS->fDRA);

        JetSetCurrentIndex4Success(pDB->JetSessID,
                                   pDB->JetSearchTbl,
                                   SZGUIDINDEX,
                                   &idxGuid,
                                   0);

        JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, &pDN->Guid,
                     sizeof(GUID), JET_bitNewKey);

        rtn = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
        if (!rtn) {
            // Read the DNT of the record.
            JetRetrieveColumnSuccess(pDB->JetSessID,
                                     pDB->JetSearchTbl,
                                     dntid,
                                     pTag,
                                     sizeof(*pTag),
                                     &actuallen,
                                     JET_bitRetrieveFromPrimaryBookmark,
                                     NULL);
            pDB->SDNT = *pTag;

            // We have a record with this guid.  Switch to DNT+isDeleted index,
            // preserving currency on the record we just found.
            rtn = JetSetCurrentIndex4Warnings(
                            pDB->JetSessID,
                            pDB->JetSearchTbl,
                            SZISDELINDEX,
                            &idxIsDel,
                            JET_bitNoMove );
            switch ( rtn )
                {
                case JET_errSuccess:
                    // Read the deletion state of the record.  Note that only objects
                    // have an isDeleted attribute; phantoms have a deletion *time* but
                    // no isDeleted attribute.
                    // Guaranteed to return a value because if the column was NULL,
                    // it would not have been included in the index
                    //
                    JetRetrieveColumnSuccess(
                                    pDB->JetSessID,
                                    pDB->JetSearchTbl,
                                    isdeletedid,
                                    &Deleted,
                                    sizeof(Deleted),
                                    &actuallen,
                                    JET_bitRetrieveFromIndex,
                                    NULL );
                    if ( Deleted )
                        {
                        // Record is a deleted object.
                        //
                        DPRINT1(1, "ExtIntDist: fDRA INQ EXTINT_REJECT_TOMBSTONES"
                                   " -- DNT %d is deleted!\n", *pTag);
                        return ERROR_DS_NO_DELETED_NAME;
                        }
                    break;

                case JET_errNoCurrentRecord:
                    //  no entry in the index for this record, so it must be live
                    //
                    break;

                default:
                    DsaExcept( DSA_DB_EXCEPTION, rtn, 0 );
                }

            // Record is a phantom or a live object.
            DPRINT1(2, "ExtIntDist: fDRA INQ EXTINT_REJECT_TOMBSTONES"
                       " -- DNT %d is ok\n", *pTag);
            return 0;
        } else {
            // Failed to find a record with this GUID.  Continue on to normal
            // code path, where we'll try to find the record by DN, etc.
            NULL;
        }
    }

    switch (extTableOp) {
    case DBSYN_ADD:
        if((flags & EXTINT_UPDATE_PHANTOM)&&(flags & EXTINT_NEW_OBJ_NAME)) {
            return DBSYN_BADCONV;
        }
        if(rtn = sbTableAddRef(pDB,
                               (flags & (EXTINT_UPDATE_PHANTOM |
                                         EXTINT_NEW_OBJ_NAME     )),
                               pDN,
                               pTag)) {
            DPRINT1(1,"Bad return on DN ADD REF <%u>\n",rtn);
            return DBSYN_BADCONV;
        }

        return 0;
        break;

    case DBSYN_INQ:
    {
        ULONG ulSbtFlags = 0;
        if (flags & EXTINT_REJECT_TOMBSTONES) {
            // Force search table currency
            ulSbtFlags |= SBTGETTAG_fMakeCurrent;
        }
        rtn = sbTableGetTagFromDSName(pDB, pDN, ulSbtFlags, pTag, NULL);

        if (rtn && (DIRERR_NOT_AN_OBJECT != rtn)) {
            DPRINT1(1,
                    "DN DistName to tag retrieval failed <%u>..returning\n",
                    rtn);
            return rtn;
        } else if (flags & EXTINT_REJECT_TOMBSTONES) {
            // PERFORMANCE: For performance, someday push this support into dbsubj
            // so the cache knows about deletion status of objects

            // dn is present, see if tombstone
            rtn = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetSearchTbl,
                   isdeletedid, &Deleted, sizeof(Deleted), &actuallen, 0, NULL);
            if ( (!rtn) && (Deleted) ) {
                return ERROR_DS_NO_DELETED_NAME;
            }
        }
        return 0;
    }

    default:
        DPRINT(1,"We should never be here\n");
        return DBSYN_BADOP;
    }/*switch*/

}/*ExtIntDist*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare SYNTAX_DIST_NAMEs.  Only presence and equality tests allowed */

int
EvalDist (
        DBPOS FAR *pDB,
        UCHAR Oper,
        ULONG intLen1,
        UCHAR *pIntVal1,
        ULONG intLen2,
        UCHAR *pIntVal2
        )
{

    DPRINT(3,"EvalDist entered\n");

    if (Oper == FI_CHOICE_PRESENT)
    return TRUE;

    if (  intLen1 != sizeof(ULONG)  || intLen2 != sizeof(ULONG))
    {
    DPRINT(1,"Problem with DISTNAME on comparison values return error\n");
    return DBSYN_BADCONV;
    }

    switch(Oper)
    {
    case FI_CHOICE_EQUALITY:
        return (*(ULONG *)pIntVal1) == (*(ULONG *)pIntVal2);

    case FI_CHOICE_NOT_EQUAL:
        return (*(ULONG *)pIntVal1) != (*(ULONG *)pIntVal2);

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
   }/*switch*/

   (void *) pDB;           /*NotReferenced*/
}/*EvalDist*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_OBJECT_ID attributes are returned as is*/

int IntExtID(DBPOS FAR *pDB, USHORT extTableOp,
             ULONG intLen,   UCHAR *pIntVal,
             ULONG *pExtLen, UCHAR **ppExtVal,
             ULONG ulUpdateDnt, JET_TABLEID jTbl,
             ULONG flags)
{
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtId entered\n");
   *ppExtVal = pIntVal;
   *pExtLen   = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtID*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_OBJECT_ID attributes are returned as is*/

int ExtIntID(DBPOS FAR *pDB, USHORT extTableOp,
             ULONG extLen,   UCHAR *pExtVal,
             ULONG *pIntLen, UCHAR **ppIntVal,
             ULONG ulUpdateDnt, JET_TABLEID jTbl,
             ULONG flags)
{
   DPRINT(3,"ExtIntId entered\n");
   *ppIntVal  = pExtVal;
   *pIntLen = extLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntID*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare SYNTAX_OBJECT_IDs.  Only presence and equality tests allowed */

int EvalID(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
           UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2){

    DPRINT(3,"EvalID entered\n");

   if (Oper == FI_CHOICE_PRESENT)
      return TRUE;

   if (  intLen1 != sizeof(SYNTAX_OBJECT_ID)
      || intLen2 != sizeof(SYNTAX_OBJECT_ID)){

      DPRINT(1,"Problem with SYNTAX_OBJECT_ID values return error\n");
      return DBSYN_BADCONV;
   }

   switch(Oper)
   {
      case FI_CHOICE_EQUALITY:
        return     (((*(SYNTAX_OBJECT_ID *)pIntVal1)
                  == (*(SYNTAX_OBJECT_ID *)pIntVal2)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_NOT_EQUAL:
        return     (((*(SYNTAX_OBJECT_ID *)pIntVal1)
                  != (*(SYNTAX_OBJECT_ID *)pIntVal2)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_LESS_OR_EQ:
        return     (((*(SYNTAX_OBJECT_ID *)pIntVal2)
                  <= (*(SYNTAX_OBJECT_ID *)pIntVal1)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_LESS:
        return     ((*(SYNTAX_OBJECT_ID *)pIntVal2) < (*(SYNTAX_OBJECT_ID *)pIntVal1));
        break;

      case FI_CHOICE_GREATER_OR_EQ:
        return     (((*(SYNTAX_OBJECT_ID *)pIntVal2)
                  >= (*(SYNTAX_OBJECT_ID *)pIntVal1)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_GREATER:
        return     ((*(SYNTAX_OBJECT_ID *)pIntVal2) > (*(SYNTAX_OBJECT_ID *)pIntVal1));
        break;
      default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
   }/*switch*/

   (void *) pDB;           /*NotReferenced*/

}/*EvalID*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_CASE_STRING have the same internal and external form*/

int IntExtCase(DBPOS FAR *pDB, USHORT extTableOp,
               ULONG intLen,   UCHAR *pIntVal,
               ULONG *pExtLen, UCHAR **ppExtVal,
               ULONG ulUpdateDnt, JET_TABLEID jTbl,
               ULONG flags)
{

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

  DPRINT(3,"Internal to external case sensitive conv entered\n");

   *ppExtVal = pIntVal;
   *pExtLen  = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtCase*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_CASE_STRING have the same internal and external form.
*/

int ExtIntCase(DBPOS FAR *pDB, USHORT extTableOp,
               ULONG extLen,   UCHAR *pExtVal,
               ULONG *pIntLen, UCHAR **ppIntVal,
               ULONG ulUpdateDnt, JET_TABLEID jTbl,
               ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;

    DPRINT(3,"External to internal case sensitive conv entered\n");

   MAKEBIG_VALBUF (extLen);    /*Make output str atleast as large as input*/
   *ppIntVal = pDB->pValBuf;             /*user output points to valbuf*/
   *pIntLen = extLen;
   memcpy(*ppIntVal, pExtVal, extLen);

   return 0;

   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntCase*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare Case strings.  Presence, equality and substring tests allowed.
   All comparisons are case sensitive. This is a CASE SENSITIVE STRING.
*/

int EvalCase(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
             UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{
    int cmp;

    DPRINT(3,"EvalCase entered\n");

    if (Oper == FI_CHOICE_PRESENT) {
        return TRUE;
    }
    else if (Oper == FI_CHOICE_SUBSTRING) {
        return CompareSubStr(TRUE,
                             (SUBSTRING *) pIntVal1,
                             pIntVal2,
                             intLen2);
    }

    cmp = CompareStr(TRUE,
                     (LPCSTR) pIntVal2,
                     intLen2 / sizeof(SYNTAX_CASE_STRING),
                     (LPCSTR) pIntVal1,
                     intLen1 / sizeof(SYNTAX_CASE_STRING));

    switch (Oper) {
        case FI_CHOICE_EQUALITY:
            return cmp == CMP_EQUAL;

        case FI_CHOICE_NOT_EQUAL:
            return cmp != CMP_EQUAL;

        case FI_CHOICE_LESS:
            return cmp < CMP_EQUAL;

        case FI_CHOICE_LESS_OR_EQ:
            return cmp <= CMP_EQUAL;

        case FI_CHOICE_GREATER_OR_EQ:
            return cmp >= CMP_EQUAL;

        case FI_CHOICE_GREATER:
            return cmp > CMP_EQUAL;

        default:
            DPRINT(1,"Problem with OPERATION TYPE return error\n");
            return DBSYN_BADOP;
    }/*switch*/

   (void *) pDB;           /*NotReferenced*/
}/*EvalCase*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_NOCASE_STRING have the same internal and external form*/

int IntExtNoCase(DBPOS FAR *pDB, USHORT extTableOp,
                 ULONG intLen,   UCHAR *pIntVal,
                 ULONG *pExtLen, UCHAR **ppExtVal,
                 ULONG ulUpdateDnt, JET_TABLEID jTbl,
                 ULONG flags)
{

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

  DPRINT(3,"Internal to external NO case sensitive conv entered\n");

   *ppExtVal = pIntVal;
   *pExtLen   = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtNoCase*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_NOCASE_STRING have the same internal and external form but all
   leading and trailing blanks are removed.  Also multiple contiguous
   blanks are reduced to a single blank.
*/

int ExtIntNoCase(DBPOS FAR *pDB, USHORT extTableOp,
                 ULONG extLen,   UCHAR *pExtVal,
                 ULONG *pIntLen, UCHAR **ppIntVal,
                 ULONG ulUpdateDnt, JET_TABLEID jTbl,
                 ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    DPRINT(3,"External to internal NO case sensitive conv entered\n");

   MAKEBIG_VALBUF (extLen);    /*Make output str atleast as large as input*/
   *ppIntVal = pDB->pValBuf;             /*user output points to valbuf*/
   *pIntLen = extLen;
   memcpy(*ppIntVal, pExtVal, extLen);

   return 0;

   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntNoCase*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare NoCase strings.  Presence, equality and substring tests allowed.
   All comparisons are case insensitive. This is a CASE INSENSITIVE STRING.
*/


int EvalNoCase(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
               UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{
    int cmp;

    DPRINT(3,"EvalCase entered\n");

    if (Oper == FI_CHOICE_PRESENT) {
        return TRUE;
    }
    else if (Oper == FI_CHOICE_SUBSTRING) {
        return CompareSubStr(FALSE,
                             (SUBSTRING *) pIntVal1,
                             pIntVal2,
                             intLen2);
    }

    cmp = CompareStr(FALSE,
                     (LPCSTR) pIntVal2,
                     intLen2 / sizeof(SYNTAX_CASE_STRING),
                     (LPCSTR) pIntVal1,
                     intLen1 / sizeof(SYNTAX_CASE_STRING));

    switch (Oper) {
        case FI_CHOICE_EQUALITY:
            return cmp == CMP_EQUAL;

        case FI_CHOICE_NOT_EQUAL:
            return cmp != CMP_EQUAL;

        case FI_CHOICE_LESS:
            return cmp < CMP_EQUAL;

        case FI_CHOICE_LESS_OR_EQ:
            return cmp <= CMP_EQUAL;

        case FI_CHOICE_GREATER_OR_EQ:
            return cmp >= CMP_EQUAL;

        case FI_CHOICE_GREATER:
            return cmp > CMP_EQUAL;

        default:
            DPRINT(1,"Problem with OPERATION TYPE return error\n");
            return DBSYN_BADOP;
    }/*switch*/

   (void *) pDB;           /*NotReferenced*/
}/*EvalNoCase*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int IntExtError(DBPOS FAR *pDB, USHORT extTableOp,
                ULONG intLen,   UCHAR *pIntVal,
                ULONG *pExtLen, UCHAR **ppExtVal,
                ULONG ulUpdateDnt, JET_TABLEID jTbl,
                ULONG flags)
{

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtError entered bad syntax return conv err\n");
   return DBSYN_BADCONV;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   intLen;        /*NotReferenced*/
   (void *) pExtLen;       /*NotReferenced*/
   (void *) pIntVal;       /*NotReferenced*/
   (void **)ppExtVal;      /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtError*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

int ExtIntError(DBPOS FAR *pDB, USHORT extTableOp,
                ULONG extLen,   UCHAR *pExtVal,
                ULONG *pIntLen, UCHAR **ppIntVal,
                ULONG ulUpdateDnt, JET_TABLEID jTbl,
                ULONG flags)
{

   DPRINT(3,"ExtIntError entered bad syntax return conv err\n");
   return DBSYN_BADCONV;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   extLen;        /*NotReferenced*/
   (void *) pIntLen;       /*NotReferenced*/
   (void *) pExtVal;       /*NotReferenced*/
   (void **)ppIntVal;      /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntError*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

int EvalError(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
              UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2){

   DPRINT(3,"EvalError entered return bad syntax return conv err\n");
   return DBSYN_BADCONV;

   (void *) pDB;           /*NotReferenced*/
   (void)   Oper;          /*NotReferenced*/
   (void)   intLen1;       /*NotReferenced*/
   (void)   intLen2;       /*NotReferenced*/
   (void *) pIntVal1;      /*NotReferenced*/
   (void *) pIntVal2;      /*NotReferenced*/

}/*EvalError*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int IntExtBool(DBPOS FAR *pDB, USHORT extTableOp,
               ULONG intLen,   UCHAR *pIntVal,
               ULONG *pExtLen, UCHAR **ppExtVal,
               ULONG ulUpdateDnt, JET_TABLEID jTbl,
               ULONG flags)
{

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

    DPRINT(3,"IntExtBool entered\n");

    if (intLen ==sizeof(BOOL) && (   (*(BOOL *)pIntVal) == FALSE
                                  || (*(BOOL *)pIntVal) == TRUE)){

       *ppExtVal  = pIntVal;
       *pExtLen   = intLen;
       return 0;
    }

    DPRINT(1,"Not a boolean value....CONVERR\n");
    return DBSYN_BADCONV;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtBool*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* In C 0 is FALSE and !0 is TRUE.  In the Directory 0 is FALSE and
   1 is TRUE... Convert !0 value to internal form.
*/

int ExtIntBool(DBPOS FAR *pDB, USHORT extTableOp,
               ULONG extLen,   UCHAR *pExtVal,
               ULONG *pIntLen, UCHAR **ppIntVal,
               ULONG ulUpdateDnt, JET_TABLEID jTbl,
               ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;

    DPRINT(3,"ExtIntBool entered\n");

    if (extLen ==sizeof(BOOL)){

       MAKEBIG_VALBUF (extLen);  /*Make output str atleast as large as input*/
       *ppIntVal = pDB->pValBuf; /*user output points to valbuf*/

       (*(BOOL *)*ppIntVal)  = ((*(BOOL *)pExtVal) == FALSE) ? FALSE : TRUE;
       *pIntLen   = extLen;
       return 0;
    }

    DPRINT(1,"Not a boolean value....CONVERR\n");
    return DBSYN_BADCONV;

   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntBool*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare boolean values.  Only presence and equality test is allowed */

int EvalBool(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
             UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2){

    DPRINT(3,"EvalBool entered\n");

   if (Oper == FI_CHOICE_PRESENT)
      return TRUE;

   if (intLen1 != sizeof(BOOL) || intLen2 != sizeof(BOOL)){
      DPRINT(1,"Problem with BOOLEAN values return error\n");
      return DBSYN_BADCONV;
   }

   switch(Oper){
      case FI_CHOICE_EQUALITY:
        return     (((*(BOOL *)pIntVal1)
                  == (*(BOOL *)pIntVal2)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_NOT_EQUAL:
        return     (*(BOOL *)pIntVal1 != *(BOOL *)pIntVal2);

      case FI_CHOICE_LESS_OR_EQ:
        return     (((*(BOOL *)pIntVal2)
                  <= (*(BOOL *)pIntVal1)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_LESS:
        return     ((*(BOOL *)pIntVal2) < (*(BOOL *)pIntVal1));
        break;

      case FI_CHOICE_GREATER_OR_EQ:
        return     (((*(BOOL *)pIntVal2)
                  >= (*(BOOL *)pIntVal1)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_GREATER:
        return     ((*(BOOL *)pIntVal2) > (*(BOOL *)pIntVal1));
        break;


      default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
   }/*switch*/

   (void *) pDB;           /*NotReferenced*/

}/*EvalBool*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Integer Internal to External conversion */

int IntExtInt(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG intLen,   UCHAR *pIntVal,
              ULONG *pExtLen, UCHAR **ppExtVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtInt entered\n");
   *ppExtVal  = pIntVal;
   *pExtLen   = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtInt*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Integer Externalto Internal conversion */

int ExtIntInt(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG extLen,   UCHAR *pExtVal,
              ULONG *pIntLen, UCHAR **ppIntVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
   DPRINT(3,"ExtIntInt entered\n");
   *ppIntVal  = pExtVal;
   *pIntLen   = extLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntInt*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare integer values.  "Presence,=,<=,>=" tests are allowed */

int
EvalInt(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
        UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{
    SYNTAX_INTEGER IntVal1, IntVal2;

    DPRINT(3,"EvalInt entered\n");

   if (Oper == FI_CHOICE_PRESENT)
      return TRUE;

   if (  intLen1 != sizeof(SYNTAX_INTEGER)
      || intLen2 != sizeof(SYNTAX_INTEGER)){

      DPRINT(1,"Problem with Integer on comparison values return error\n");
      return DBSYN_BADCONV;
   }

    IntVal1 =  (*(SYNTAX_INTEGER *)pIntVal1);
    IntVal2 =  (*(SYNTAX_INTEGER *)pIntVal2);

    switch(Oper){
    case FI_CHOICE_EQUALITY:
        return    (IntVal1 == IntVal2);
        break;
    case FI_CHOICE_NOT_EQUAL:
        return     (IntVal1 != IntVal2);

    case FI_CHOICE_LESS_OR_EQ:
        return     (IntVal2 <= IntVal1);
        break;

    case FI_CHOICE_LESS:
        return     (IntVal2 < IntVal1);
        break;

    case FI_CHOICE_GREATER_OR_EQ:
        return     (IntVal2 >= IntVal1);
        break;

    case FI_CHOICE_GREATER:
        return     (IntVal2 > IntVal1);
        break;

    case FI_CHOICE_BIT_OR:
        // True if any bits in common.
        return     ((IntVal2 & IntVal1) != 0);
        break;

    case FI_CHOICE_BIT_AND:
        // True if all bits in intval2 are set in intval1
        return     ((IntVal2 & IntVal1) == IntVal1);
        break;

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
   }/*switch*/

   (void *) pDB;           /*NotReferenced*/

}/*EvalInt*/


/*-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------*/
/* Time Internal to External conversion */

int IntExtTime(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG intLen,   UCHAR *pIntVal,
              ULONG *pExtLen, UCHAR **ppExtVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtTime entered\n");
   *ppExtVal  = pIntVal;
   *pExtLen   = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtTime*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Time Externalto Internal conversion */

int ExtIntTime(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG extLen,   UCHAR *pExtVal,
              ULONG *pIntLen, UCHAR **ppIntVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
   DPRINT(3,"ExtIntTime entered\n");
   *ppIntVal  = pExtVal;
   *pIntLen   = extLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntInt*/

/*-------------------------------------------------------------------------*/

int
EvalTime(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
         UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{
    SYNTAX_TIME IntVal1, IntVal2;

    DPRINT(3,"EvalTime entered\n");

    if (Oper == FI_CHOICE_PRESENT)
        return TRUE;

    if (intLen1 != sizeof(SYNTAX_TIME)
        || intLen2 != sizeof(SYNTAX_TIME)) {

        DPRINT(1,"Problem with Time on comparison values return error\n");
        return DBSYN_BADCONV;
    }

    memcpy(&IntVal1, pIntVal1, sizeof(SYNTAX_TIME));
    memcpy(&IntVal2, pIntVal2, sizeof(SYNTAX_TIME));

    switch(Oper){
    case FI_CHOICE_EQUALITY:
        return    (IntVal1 == IntVal2);
        break;
    case FI_CHOICE_NOT_EQUAL:
        return     (IntVal1 != IntVal2);

    case FI_CHOICE_LESS_OR_EQ:
        return     (IntVal2 <= IntVal1);
        break;

    case FI_CHOICE_LESS:
        return     (IntVal2 < IntVal1);
        break;

    case FI_CHOICE_GREATER_OR_EQ:
        return     (IntVal2 >= IntVal1);
        break;

    case FI_CHOICE_GREATER:
        return     (IntVal2 > IntVal1);
        break;

    case FI_CHOICE_BIT_OR:
        // True if any bits in common.
        return     ((IntVal2 & IntVal1) != 0);
        break;

    case FI_CHOICE_BIT_AND:
        // True if all bits in intval2 are set in intval1
        return     ((IntVal2 & IntVal1) == IntVal1);
        break;

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
    }/*switch*/

    (void *) pDB;           /*NotReferenced*/

}/*EvalTime*/


/*-------------------------------------------------------------------------*/
/* Large Integer Internal to External conversion */

int IntExtI8(DBPOS FAR *pDB, USHORT extTableOp,
             ULONG intLen,   UCHAR *pIntVal,
             ULONG *pExtLen, UCHAR **ppExtVal,
             ULONG ulUpdateDnt, JET_TABLEID jTbl,
             ULONG flags)
{
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtI8 entered\n");
   *ppExtVal  = pIntVal;
   *pExtLen   = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtInt*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Large Integer Externalto Internal conversion */

int ExtIntI8(DBPOS FAR *pDB, USHORT extTableOp,
             ULONG extLen,   UCHAR *pExtVal,
             ULONG *pIntLen, UCHAR **ppIntVal,
             ULONG ulUpdateDnt, JET_TABLEID jTbl,
             ULONG flags)
{
   DPRINT(3,"ExtIntI8 entered\n");
   *ppIntVal  = pExtVal;
   *pIntLen   = extLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntInt*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare large integer values.*/

int
EvalI8(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
       UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{

    SYNTAX_I8 Val1;
    SYNTAX_I8 Val2;

    DPRINT(3,"EvalI8 entered\n");

    if (Oper == FI_CHOICE_PRESENT)
        return TRUE;

    if (  intLen1 != sizeof(SYNTAX_I8)
        || intLen2 != sizeof(SYNTAX_I8)){

        DPRINT(1,"Problem with large Integer on comparison values "
               "return error\n");
        return DBSYN_BADCONV;
    }

    memcpy(&Val1, pIntVal1, sizeof(SYNTAX_I8));
    memcpy(&Val2, pIntVal2, sizeof(SYNTAX_I8));

    switch(Oper){
    case FI_CHOICE_EQUALITY:
        return (Val2.QuadPart == Val1.QuadPart);
        break;

    case FI_CHOICE_NOT_EQUAL:
        return (Val2.QuadPart != Val1.QuadPart);
        break;

    case FI_CHOICE_LESS_OR_EQ:
        return (Val2.QuadPart <= Val1.QuadPart);
        break;

    case FI_CHOICE_LESS:
        return (Val2.QuadPart <  Val1.QuadPart);
        break;

    case FI_CHOICE_GREATER_OR_EQ:
        return (Val2.QuadPart >= Val1.QuadPart);
        break;

    case FI_CHOICE_GREATER:
        return (Val2.QuadPart >  Val1.QuadPart);
        break;

    case FI_CHOICE_BIT_OR:
        // True if any bits in common.
        return ((Val2.QuadPart & Val1.QuadPart) != 0i64);
        break;

    case FI_CHOICE_BIT_AND:
        // True if all bits in intval2 are set in intval1
        return ((Val2.QuadPart & Val1.QuadPart) == Val1.QuadPart);
        break;


    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
    }/*switch*/

    (void *) pDB;           /*NotReferenced*/

}/*EvalI8*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Octet Internal to External conversion */

int IntExtOctet(DBPOS FAR *pDB, USHORT extTableOp,
                ULONG intLen,   UCHAR *pIntVal,
                ULONG *pExtLen, UCHAR **ppExtVal,
                ULONG ulUpdateDnt, JET_TABLEID jTbl,
                ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtOctet entered\n");

   if (flags & INTEXT_SECRETDATA)
   {
       // Need to decrypt the data.

       if (!gfRunningInsideLsa) {
           return DB_ERR_SYNTAX_CONVERSION_FAILED;
       }

       // Jet will never pass us back 0 length
       // values. The Decryption routine may
       // barf on 0 length values
       Assert(intLen>0);
       // First get the length
       PEKDecrypt(pDB->pTHS,pIntVal,intLen,NULL,pExtLen);
       // Get a buffer large enough to hold the data
       MAKEBIG_VALBUF(*pExtLen);
       *ppExtVal = pDB->pValBuf;
       // Decrypt the Data
       PEKDecrypt(pDB->pTHS,pIntVal,intLen,*ppExtVal,pExtLen);
   }
   else
   {
        *ppExtVal  = pIntVal;
        *pExtLen   = intLen;
   }
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtOctet*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Octet External to Internal conversion */

int ExtIntOctet(DBPOS FAR *pDB, USHORT extTableOp,
                ULONG extLen,   UCHAR *pExtVal,
                ULONG *pIntLen, UCHAR **ppIntVal,
                ULONG ulUpdateDnt, JET_TABLEID jTbl,
                ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    DPRINT(3,"ExtIntOctet entered\n");

   if ((flags & EXTINT_SECRETDATA) && (extLen>0))
   {
        // Need to encrypt the data. Do not call the
        // encryption routines if the data is 0 size

       // we return this error if we are not in LSA
       if (!gfRunningInsideLsa) {
           return DB_ERR_SYNTAX_CONVERSION_FAILED;
       }

        // First the get the length of the encrypted data
        PEKEncrypt(pDB->pTHS,pExtVal, extLen,NULL,pIntLen);
        // Get a buffer large enough to hold the data
        MAKEBIG_VALBUF (*pIntLen);
        *ppIntVal = pDB->pValBuf;
        // Now encrypt the data
        PEKEncrypt(pDB->pTHS,pExtVal, extLen,*ppIntVal,pIntLen);
   }
   else
   {
        *ppIntVal  = pExtVal;
        *pIntLen   = extLen;
   }
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntOctet*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare Octet values.  "Presence,=,<=,>=, Substring" tests are allowed.
   Test are from low-high memory byte by byte
*/

int EvalOctet(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
              UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2){

    int comp;

    DPRINT(3,"EvalOctet entered\n");

   if (Oper == FI_CHOICE_PRESENT) {
      return TRUE;
   }
   else if (Oper == FI_CHOICE_SUBSTRING) {
    return CompareSubStr(TRUE  /*Case sensitive*/
                  ,(SUBSTRING *) pIntVal1, pIntVal2, intLen2);
   }

   comp =  memcmp(pIntVal2, pIntVal1,(intLen1 < intLen2)?intLen1 : intLen2);

   switch(Oper){
      case FI_CHOICE_EQUALITY:
        return (comp == 0 && intLen1 == intLen2)
                ? TRUE : FALSE;
        break;
      case FI_CHOICE_NOT_EQUAL:
        return !(comp == 0 && intLen1 == intLen2);

      case FI_CHOICE_LESS:
        return ((comp < 0) || ((!comp ) && (intLen2 < intLen1)));
        break;
      case FI_CHOICE_LESS_OR_EQ:
        return (comp < 0 || (comp == 0 && intLen2 <= intLen1))
                ? TRUE : FALSE;
        break;
      case FI_CHOICE_GREATER_OR_EQ:
        return (comp > 0 || (comp == 0 && intLen2 >= intLen1))
                ? TRUE : FALSE;
    break;
      case FI_CHOICE_GREATER:
        return (comp > 0 || (!comp && (intLen2 > intLen1)));
    break;
      default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
   }/*switch*/

   (void *) pDB;           /*NotReferenced*/

}/*EvalOctet*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_UNICODE have the same internal and external form*/

int IntExtUnicode(DBPOS FAR *pDB, USHORT extTableOp,
                  ULONG intLen,   UCHAR *pIntVal,
                  ULONG *pExtLen, UCHAR **ppExtVal,
                  ULONG ulUpdateDnt, JET_TABLEID jTbl,
                  ULONG flags)
{

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

  DPRINT(3,"Internal to external case sensitive conv entered\n");

   *ppExtVal = pIntVal;
   *pExtLen  = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtUnicode*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_UNICODE have the same internal and external form.
*/

int ExtIntUnicode(DBPOS FAR *pDB, USHORT extTableOp,
                  ULONG extLen,   UCHAR *pExtVal,
                  ULONG *pIntLen, UCHAR **ppIntVal,
                  ULONG ulUpdateDnt, JET_TABLEID jTbl,
                  ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;

    DPRINT(3,"External to internal unicode conversion entered\n");

   *pIntLen = extLen;
   MAKEBIG_VALBUF (extLen);    /*Make output str atleast as large as input*/
   *ppIntVal = pDB->pValBuf;   /*user output points to valbuf*/
   memcpy(*ppIntVal, pExtVal, extLen);

   return 0;

   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntUnicode*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare Unicode strings.  Presence, equality and substring tests allowed.
   All comparisons are case insensitive. This is a CASE INSENSITIVE STRING.
*/

int EvalUnicode(DBPOS *pDB,  UCHAR Oper, ULONG intLen1,
             UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{
    int cmp;

    DPRINT(3,"EvalUnicode entered\n");

    if (Oper == FI_CHOICE_PRESENT) {
        return TRUE;
    }
    else if (Oper == FI_CHOICE_SUBSTRING) {
        return CompareUnicodeSubStr(pDB->pTHS,
                                    (SUBSTRING *) pIntVal1,
                                    pIntVal2,
                                    intLen2);
    }

    cmp = CompareStringW(pDB->pTHS->dwLcid,
                         (pDB->pTHS->fDefaultLcid ?
                            DS_DEFAULT_LOCALE_COMPARE_FLAGS :
                            LOCALE_SENSITIVE_COMPARE_FLAGS),
                         (LPCWSTR) pIntVal2,
                         intLen2 / sizeof(SYNTAX_UNICODE),
                         (LPCWSTR) pIntVal1,
                         intLen1 / sizeof(SYNTAX_UNICODE));
    Assert(cmp != 0);

    switch (Oper) {
        case FI_CHOICE_EQUALITY:
            return cmp == CSTR_EQUAL;

        case FI_CHOICE_NOT_EQUAL:
            return cmp != CSTR_EQUAL;

        case FI_CHOICE_LESS:
            return cmp < CSTR_EQUAL;

        case FI_CHOICE_LESS_OR_EQ:
            return cmp <= CSTR_EQUAL;

        case FI_CHOICE_GREATER_OR_EQ:
            return cmp >= CSTR_EQUAL;

        case FI_CHOICE_GREATER:
            return cmp > CSTR_EQUAL;

        default:
            DPRINT(1,"Problem with OPERATION TYPE return error\n");
            return DBSYN_BADOP;
    }/*switch*/

}/*EvalUnicode*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*Internal - External Distname+String translation.  Use distname function to
  get the external representation of a distname.  Move the value to a temp
  area because we must resize the VALBUF to accomodate the distname+string.
  Finally, move in the distname and the string.
*/

int
IntExtDistString (
        DBPOS FAR *pDB, USHORT extTableOp,
        ULONG intLen, UCHAR *pIntVal,
        ULONG *pExtLen, UCHAR **ppExtVal,
        ULONG ulUpdateDnt, JET_TABLEID jTbl,
        ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    UCHAR            *buf;
    ULONG            DNLen;
    int              rtn;
    DSNAME           *pDN;
    DSNAME          *pDNTemp;
    INTERNAL_SYNTAX_DISTNAME_STRING *pINT_DNS;

    /* Copy internal value out of pDB->pValBuf */

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

    DPRINT(3,"IntExtDistString entered\n");
    buf = THAllocEx(pTHS,intLen);
    pINT_DNS = (INTERNAL_SYNTAX_DISTNAME_STRING *)buf;
    memcpy(buf, pIntVal, intLen);

    // Make sure its a valid value
    if (intLen != (sizeof(ULONG)+pINT_DNS->data.structLen)) {
        DPRINT(1,"Internal DN-Address length is incorrect\n");
        THFreeEx(pTHS,buf);
        return DBSYN_BADCONV;
    }

    // It is an assumption that no attributes of this type are backlinks.
    // If that assumption is not true, then the final paramater to IntExtDist
    // must be set to
    // newflags =
    //     ((extTableOp == DBSYN_REM &&
    //       (FIsBackLink(this attribute))) ? INTEXT_BACKLINK : 0);
    // Note that this_attribute is not available here, so if we need to
    // change this,then we need to make that data available here.


    // Translate DN portion to external form
    if (rtn = IntExtDist(pDB, extTableOp, sizeof(ULONG),
             (UCHAR *)(&pINT_DNS->tag),
                         &DNLen, (UCHAR **)&pDN,
             ulUpdateDnt, jTbl, flags)) {
        DPRINT1(1,"INT to EXT DIST returned an error code of %u..return\n",rtn);
        THFreeEx(pTHS,buf);
        return rtn;
    }

    pDNTemp = THAllocEx(pTHS, pDN->structLen);
    memcpy(pDNTemp, pDN, pDN->structLen); /*Hold value while we resize VALBUF*/
    *pExtLen = DERIVE_NAME_DATA_SIZE(pDNTemp, &pINT_DNS->data);
    MAKEBIG_VALBUF (*pExtLen);
    *ppExtVal = pDB->pValBuf;              /*user output points to valbuf*/
    BUILD_NAME_DATA((SYNTAX_DISTNAME_STRING*)*ppExtVal, pDNTemp,
            &pINT_DNS->data);
    THFreeEx(pTHS,buf);
    THFreeEx(pTHS,pDNTemp);
    return 0;

}/*IntExtDistString*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*External - Internal DistString translation.  Use distname function to
  get the Internal representation of a distname.  Move the value to a temp
  area because we must resize the VALBUF to accomodate the distname-string.
  Finally, move in the distname and the string.
*/

int
ExtIntDistString (
        DBPOS FAR *pDB, USHORT extTableOp,
        ULONG extLen,   UCHAR *pExtVal,
        ULONG *pIntLen, UCHAR **ppIntVal,
        ULONG ulUpdateDnt, JET_TABLEID jTbl,
        ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    ULONG       len;
    int         rtn;
    INTERNAL_SYNTAX_DISTNAME_STRING *pINT_DNS;
    ULONG       *pTag;
    DWORD       tag;
    SYNTAX_DISTNAME_STRING *pEXT_DNS = (SYNTAX_DISTNAME_STRING *)pExtVal;

    DPRINT(3,"ExtIntDistSTring entered\n");

    if (extLen != (ULONG)NAME_DATA_SIZE(pEXT_DNS)){
        DPRINT(1,"External DN-Address length is incorrect\n");
        return DBSYN_BADCONV;
    }

    // It is an assumption that this is not the OBJ_DIST_NAME.  If that
    // assumption is not true, then the final paramater to ExtIntDist must be
    // set to
    // newflags =
    //     ((extTableOp == DBSYN_ADD &&
    //       (this attribute == OBJ_DIST_NAME)) ? EXTINT_NEW_OBJ_NAME:0);
    // Note that this_attribute is not available here, so if we need to
    // change this,then we need to make that data available here.

    if(rtn = ExtIntDist(pDB,
                        extTableOp,
                        NAMEPTR(pEXT_DNS)->structLen,
                        (PUCHAR)NAMEPTR(pEXT_DNS),
                        &len,
                        (UCHAR **)&pTag,
                        ulUpdateDnt,
                        jTbl,
                        flags)) {

        DPRINT1(1,"EXT to INTDIST returned an error %u\n",rtn);
        return rtn;
    }

    //
    // copy off the tag because the MAKEBIG call can modify the pointer
    //

    tag = *pTag;
    *pIntLen = (sizeof(ULONG) + DATAPTR(pEXT_DNS)->structLen);

    MAKEBIG_VALBUF (*pIntLen);  /*Internal is never larger than external rep*/
    *ppIntVal = pDB->pValBuf;   /*user output points to valbuf*/

    pINT_DNS = (INTERNAL_SYNTAX_DISTNAME_STRING *)*ppIntVal;

    pINT_DNS->tag = tag;

    memcpy(&pINT_DNS->data, DATAPTR(pEXT_DNS), DATAPTR(pEXT_DNS)->structLen);

    return 0;

}/*ExtIntDistString*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Eval name-adress syntax.  only presence and equality tests are allowed*/

int
EvalDistString (
        DBPOS FAR *pDB,
        UCHAR Oper,
        ULONG intLen1,
        UCHAR *pIntVal1,
        ULONG intLen2,
        UCHAR *pIntVal2
        )
{
    INTERNAL_SYNTAX_DISTNAME_STRING *pIntDistString_1;
    INTERNAL_SYNTAX_DISTNAME_STRING *pIntDistString_2;
    pIntDistString_1=(INTERNAL_SYNTAX_DISTNAME_STRING *) pIntVal1;
    pIntDistString_2=(INTERNAL_SYNTAX_DISTNAME_STRING *) pIntVal2;
    DPRINT(3,"EvalDistString entered\n");

    // A diststring is a dnt + a unicode string, so the length must be even.
    if((intLen1 & 1) || (intLen2 & 1)) {
        return DBSYN_BADCONV;
    }

    if((intLen1 > sizeof(DWORD)) &&
       (pIntDistString_1->data.structLen + sizeof(DWORD)) != intLen1) {
        // length passed in doesn't match the internal encoding of the length of
        // the string.
        return DBSYN_BADCONV;
    }

    if((intLen2 > sizeof(DWORD)) &&
       (pIntDistString_2->data.structLen + sizeof(DWORD)) != intLen2) {
        // length passed in doesn't match the internal encoding of the length of
        // the string.
        return DBSYN_BADCONV;
    }

    switch(Oper){
    case FI_CHOICE_PRESENT:
        return TRUE;

    case FI_CHOICE_EQUALITY:
        if(pIntDistString_1->tag != pIntDistString_2->tag) {
            return FALSE;
        }
        // compare the string;
        return EvalUnicode(pDB,  FI_CHOICE_EQUALITY,
                           PAYLOAD_LEN_FROM_STRUCTLEN(pIntDistString_1->data.structLen),
                           pIntDistString_1->data.byteVal,
                           PAYLOAD_LEN_FROM_STRUCTLEN(pIntDistString_2->data.structLen),
                           pIntDistString_2->data.byteVal);
        break;

    case FI_CHOICE_NOT_EQUAL:
        if(pIntDistString_1->tag != pIntDistString_2->tag) {
            return TRUE;
        }
        // compare the string;
        return EvalUnicode(pDB,  FI_CHOICE_NOT_EQUAL,
                           PAYLOAD_LEN_FROM_STRUCTLEN(pIntDistString_1->data.structLen),
                           pIntDistString_1->data.byteVal,
                           PAYLOAD_LEN_FROM_STRUCTLEN(pIntDistString_2->data.structLen),
                           pIntDistString_2->data.byteVal);
        break;

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
    }/*switch*/

    (void *) pDB;           /*NotReferenced*/

}/*EvalDistString*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int
IntExtDistBinary (
        DBPOS FAR *pDB, USHORT extTableOp,
        ULONG intLen,   UCHAR *pIntVal,
        ULONG *pExtLen, UCHAR **ppExtVal,
        ULONG ulUpdateDnt, JET_TABLEID jTbl,
        ULONG flags)
{
    int             returnCode;
    SYNTAX_ADDRESS  *pSyntaxAddr;
    DWORD           dwSizeDiff;

    returnCode = IntExtDistString (pDB, extTableOp, intLen, pIntVal,
                             pExtLen, ppExtVal,
                             ulUpdateDnt, jTbl, flags);

    if (flags & INTEXT_WELLKNOWNOBJ) {
        // Early on in development the structlen of SYNTAX_ADDRESS's
        // was being calculated incorrectly.  In order to fix the
        // bug and allow users to upgrade, we need to fix those
        // values up before handing them up the stack.

        pSyntaxAddr = (SYNTAX_ADDRESS *)DATAPTR((SYNTAX_DISTNAME_BINARY*)*ppExtVal);
        if (pSyntaxAddr->structLen != (sizeof(GUID) + sizeof(ULONG)) ) {

            // Fix up the size of the buffer we hand back up.
            dwSizeDiff = pSyntaxAddr->structLen - (sizeof(GUID) + sizeof(ULONG));
            *pExtLen -= dwSizeDiff;

            // Fix up the structLen
            pSyntaxAddr->structLen = sizeof(GUID) + sizeof(ULONG);
        }
    }

    return returnCode;
}/*IntExtDistBinar*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

int
ExtIntDistBinary (
        DBPOS FAR *pDB, USHORT extTableOp,
        ULONG extLen,   UCHAR *pExtVal,
        ULONG *pIntLen, UCHAR **ppIntVal,
        ULONG ulUpdateDnt, JET_TABLEID jTbl,
        ULONG flags)
{
    return ExtIntDistString (pDB, extTableOp, extLen, pExtVal,
                             pIntLen, ppIntVal,
                             ulUpdateDnt, jTbl, flags);
}/*ExtIntDistBinary*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

int
EvalDistBinary (
        DBPOS FAR *pDB,
        UCHAR Oper,
        ULONG intLen1,
        UCHAR *pIntVal1,
        ULONG intLen2,
        UCHAR *pIntVal2
        )
{

    DPRINT(3,"EvalDistBinary entered\n");

    switch(Oper) {
    case FI_CHOICE_PRESENT:
        return TRUE;
        break;

    case FI_CHOICE_EQUALITY:
        return  (  intLen1 == intLen2
                 && memcmp(pIntVal1, pIntVal2, intLen1) == 0)
            ? TRUE : FALSE;
        break;

    case FI_CHOICE_NOT_EQUAL:
        return  !(intLen1 == intLen2 &&
                  (memcmp(pIntVal1, pIntVal2, intLen1) == 0));

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
    }/*switch*/

    (void *) pDB;           /*NotReferenced*/

}/*EvalDistBinary*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Substring match function.  If Case, all matches are case sensitive,
   otherwise they are case insensitive.  Both the substring and the
   target string are non-NULL otherwise a false is used.  PRESENT test
   should be used for NULL strings.

   The optional initial value is equivalent to "pattern*", the optional
   final value is equivalent to "*pattern" and any number of intermediate
   patterns which are equivalent to "*pattern*" are allowed.
*/


BOOL CompareSubStr(BOOL Case,
                   SUBSTRING * pSub,
                   UCHAR * pIntVal,
                   ULONG intValLen)
{
    ULONG  start = 0;
    ULONG  delta, num, cchSub;
    ULONG  cchStr = intValLen / sizeof(SYNTAX_CASE_STRING);
    SYNTAX_CASE_STRING  *pStr = (SYNTAX_CASE_STRING *) pIntVal;
    SYNTAX_CASE_STRING  *pSubString;
    ANYSTRINGLIST *pAnyList;
    int cmp;

    DPRINT(3,"CompareSubStr entered\n");

    // A NULL substring is not allowed
    if (!pSub ||
        !pSub->initialProvided && pSub->AnyVal.count == 0 && !pSub->finalProvided) {
        DPRINT(1,"an empty substring was provided return FALSE\n");
        return FALSE;
    }

    // Check optional initial left string match "pattern*"
    if (pSub->initialProvided) {
        pSubString = (SYNTAX_CASE_STRING *) pSub->InitialVal.pVal;
        cchSub = pSub->InitialVal.valLen / sizeof(SYNTAX_CASE_STRING);
        cmp = CompareStr(Case,
                         (LPCSTR)pSubString,
                         cchSub,
                         (LPCSTR)&(pStr[start]),
                         cchStr - start);
        if (!(cmp & (CMP_LENGTH_LT | CMP_EQUAL))) {
            DPRINT(3,"String failed initial substring test\n");
            return FALSE;
        }

        // Move to new position in target string
        start += cchSub;
    }

    // Check all intermediate patterns "*pattern1*pattern2*..."
    for (num = 0, pAnyList = &(pSub->AnyVal.FirstAnyVal);
         num < pSub->AnyVal.count;
         num++, pAnyList = pAnyList->pNextAnyVal) {
        pSubString = (SYNTAX_CASE_STRING *) pAnyList->AnyVal.pVal;
        cchSub = pAnyList->AnyVal.valLen / sizeof(SYNTAX_CASE_STRING);
        for (delta = 0; delta < cchStr - start; delta++) {
            cmp = CompareStr(Case,
                             (LPCSTR)pSubString,
                             cchSub,
                             (LPCSTR)&(pStr[start + delta]),
                             cchStr - start - delta);
            if (cmp & (CMP_LENGTH_LT | CMP_EQUAL)) {
                break;
            }
        }
        if (delta == cchStr - start) {
            DPRINT(3,"String failed any test with string\n");
            return FALSE;
        }

        // Move to new position in target string
        start += delta;
        start += cchSub;
    }

    // Check optional final right string match "*pattern"
    if (pSub->finalProvided) {
        pSubString = (SYNTAX_CASE_STRING *) pSub->FinalVal.pVal;
        cchSub = pSub->FinalVal.valLen / sizeof (SYNTAX_CASE_STRING);
        if (start + cchSub > cchStr) {
            DPRINT(3,"String failed final substring test\n");
            return FALSE;
        }
        cmp = CompareStr(Case,
                         (LPCSTR)pSubString,
                         cchSub,
                         (LPCSTR)&(pStr[cchStr - cchSub]),
                         cchSub);
        if (cmp != CMP_EQUAL) {
            DPRINT(3,"String failed final substring test\n");
            return FALSE;
        }
    }

    DPRINT(3,"Substring matched\n");
    return TRUE;
}/*CompareSubStr*/

int
CompareStr(
    BOOL Case,
    LPCSTR str1,
    int cch1,
    LPCSTR str2,
    int cch2
    )
/*++
Routine Description:
    Performs a case aware comparison of two ASCII strings and returns the
    result encoded as an integer.  The result of the comparison is analogous
    to the subtraction of the second string from the first string, meaning that
    if the first string is larger than the second string then the result will
    be greater than.

    The possible results returned are:
        CMP_LT          - the first string is less than the second string
        CMP_LENGTH_LT   - the first string is less than the second string
                          because the second string equals the first string
                          plus some additional characters
        CMP_EQUAL       - both strings are identical
        CMP_LENGTH_GT   - the first string is greater than the second string
                          because the first string equals the second string
                          plus some additional characters
        CMP_GT          - the first string is greater than the second string

    These flags can be tested in the traditional way to compare the relative
    order of the strings.  For example, if str1 - str2 >= CMP_EQUAL then
    the first string is greater than or equal to the second string.

    These flags may also be tested in more advanced ways to get more detailed
    comparisons of the strings.  For example, if one of the strings is a prefix
    of the other string then one of CMP_LENGTH_LT, CMP_EQUAL, or CMP_LENGTH_GT
    will be set.  If the first string is a prefix of the second string then one
    of CMP_LENGTH_LT or CMP_EQUAL will be set but if CMP_LENGTH_GT is set then
    you know that the first string is NOT a prefix of the second string because
    it is longer.

Arguments:
    Case    - TRUE if comparison is to be case sensitive
    str1    - first string
    cch1    - first string length
    str2    - second string
    cch2    - second string length

Return Values:
    One of the following mutually exclusive values:
        CMP_LT
        CMP_LENGTH_LT
        CMP_EQUAL
        CMP_LENGTH_GT
        CMP_GT
    Note that the value 0 is not a legal return value.
--*/
{
    int cmp;

    // compare the strings
    if (Case) {
        cmp = memcmp(str1, str2, min(cch1, cch2));
    } else {
        cmp = _memicmp(str1, str2, min(cch1, cch2));
    }

    // encode the result of the comparison
    if (cmp < 0) {
        cmp = CMP_LT;
    } else if (cmp == 0) {
        if (cch1 < cch2) {
            cmp = CMP_LENGTH_LT;
        } else if (cch1 == cch2) {
            cmp = CMP_EQUAL;
        } else {
            cmp = CMP_LENGTH_GT;
        }
    } else {
        cmp = CMP_GT;
    }

    return cmp;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Substring match function for unicode. All matches are case insensitive,
   Both the substring and the target string are non-NULL, otherwise false is
   returned.

*/


BOOL CompareUnicodeSubStr(THSTATE *pTHS,
                          SUBSTRING *pSub,
                          UCHAR *pIntVal,
                          ULONG intValLen)
{
    ULONG  start = 0;
    ULONG  delta, num, cchSub;
    ULONG  cchStr = intValLen / sizeof(SYNTAX_UNICODE);
    SYNTAX_UNICODE  *pStr = (SYNTAX_UNICODE *) pIntVal;
    SYNTAX_UNICODE  *pSubString;
    ANYSTRINGLIST *pAnyList;
    int cmp;

    DPRINT(3,"CompareUnicodeSubStr entered\n");

    // A NULL substring is not allowed
    if (!pSub ||
        !pSub->initialProvided && pSub->AnyVal.count == 0 && !pSub->finalProvided) {
        DPRINT(1,"an empty substring was provided return FALSE\n");
        return FALSE;
    }

    // Check optional initial left string match "pattern*"
    if (pSub->initialProvided) {
        pSubString = (SYNTAX_UNICODE *) pSub->InitialVal.pVal;
        cchSub = pSub->InitialVal.valLen / sizeof(SYNTAX_UNICODE);
        cmp = CompareUnicodeStr(pTHS,
                                (LPCWSTR)pSubString,
                                cchSub,
                                (LPCWSTR)&(pStr[start]),
                                cchStr - start);
        if (!(cmp & (CMP_LENGTH_LT | CMP_EQUAL))) {
            DPRINT(3,"String failed initial substring test\n");
            return FALSE;
        }

        // Move to new position in target string
        start += cchSub;
    }

    // Check all intermediate patterns "*pattern1*pattern2*..."
    for (num = 0, pAnyList = &(pSub->AnyVal.FirstAnyVal);
         num < pSub->AnyVal.count;
         num++, pAnyList = pAnyList->pNextAnyVal) {
        pSubString = (SYNTAX_UNICODE *) pAnyList->AnyVal.pVal;
        cchSub = pAnyList->AnyVal.valLen / sizeof(SYNTAX_UNICODE);
        for (delta = 0; delta < cchStr - start; delta++) {
            cmp = CompareUnicodeStr(pTHS,
                                    (LPCWSTR)pSubString,
                                    cchSub,
                                    (LPCWSTR)&(pStr[start + delta]),
                                    cchStr - start - delta);
            if (cmp & (CMP_LENGTH_LT | CMP_EQUAL)) {
                break;
            }
        }
        if (delta == cchStr - start) {
            DPRINT(3,"String failed any test with string\n");
            return FALSE;
        }

        // Move to new position in target string
        start += delta;
        start += cchSub;
    }

    // Check optional final right string match "*pattern"
    if (pSub->finalProvided) {
        pSubString = (SYNTAX_UNICODE *) pSub->FinalVal.pVal;
        cchSub = pSub->FinalVal.valLen / sizeof (SYNTAX_UNICODE);
        if (start + cchSub > cchStr) {
            DPRINT(3,"String failed final substring test\n");
            return FALSE;
        }
        cmp = CompareUnicodeStr(pTHS,
                                (LPCWSTR)pSubString,
                                cchSub,
                                (LPCWSTR)&(pStr[cchStr - cchSub]),
                                cchSub);
        if (cmp != CMP_EQUAL) {
            DPRINT(3,"String failed final substring test\n");
            return FALSE;
        }
    }

    DPRINT(3,"Substring matched\n");
    return TRUE;
}/*CompareUnicodeSubStr*/

int
CompareUnicodeStr(
    THSTATE *pTHS,
    LPCWSTR wstr1,
    int cwch1,
    LPCWSTR wstr2,
    int cwch2
    )
/*++
Routine Description:
    Performs a locale aware comparison of two Unicode strings and returns the
    result encoded as an integer.  The result of the comparison is analogous
    to the subtraction of the second string from the first string, meaning that
    if the first string is larger than the second string then the result will
    be greater than.

    The possible results returned are:
        CMP_LT          - the first string is less than the second string
        CMP_LENGTH_LT   - the first string is less than the second string
                          because the second string equals the first string
                          plus some additional characters
        CMP_EQUAL       - both strings are identical
        CMP_LENGTH_GT   - the first string is greater than the second string
                          because the first string equals the second string
                          plus some additional characters
        CMP_GT          - the first string is greater than the second string
        CMP_ERROR       - the comparison couldn't be made due to an error

    These flags can be tested in the traditional way to compare the relative
    order of the strings.  For example, if wstr1 - wstr2 >= CMP_EQUAL then
    the first string is greater than or equal to the second string.

    These flags may also be tested in more advanced ways to get more detailed
    comparisons of the strings.  For example, if one of the strings is a prefix
    of the other string then one of CMP_LENGTH_LT, CMP_EQUAL, or CMP_LENGTH_GT
    will be set.  If the first string is a prefix of the second string then one
    of CMP_LENGTH_LT or CMP_EQUAL will be set but if CMP_LENGTH_GT is set then
    you know that the first string is NOT a prefix of the second string because
    it is longer.

Arguments:
    pTHS    - THSTATE
    wstr1   - first string
    cwch1   - first string length
    wstr2   - second string
    cwch2   - second string length

Return Values:
    One of the following mutually exclusive values:
        CMP_LT
        CMP_LENGTH_LT
        CMP_EQUAL
        CMP_LENGTH_GT
        CMP_GT
        CMP_ERROR
    Note that the value 0 is not a legal return value.
--*/
{
    LCID    lcid            = pTHS->dwLcid;
    DWORD   dwMapFlags      = pTHS->fDefaultLcid ?
                                DS_DEFAULT_LOCALE_COMPARE_FLAGS :
                                LOCALE_SENSITIVE_COMPARE_FLAGS;
    int     cmp             = CMP_ERROR;

    // compare the strings
    cmp = CompareStringW(lcid, dwMapFlags, wstr1, min(cwch1, cwch2), wstr2, min(cwch1, cwch2));

    // encode the result of the comparison
    if (cmp == CSTR_LESS_THAN) {
        cmp = CMP_LT;
    } else if (cmp == CSTR_EQUAL) {
        if (cwch1 < cwch2) {
            cmp = CMP_LENGTH_LT;
        } else if (cwch1 == cwch2) {
            cmp = CMP_EQUAL;
        } else {
            cmp = CMP_LENGTH_GT;
        }
    } else if (cmp == CSTR_GREATER_THAN) {
        cmp = CMP_GT;
    } else {
        cmp = CMP_ERROR;
    }

    return cmp;
}

#ifdef DBG
// global flag to turn on SD hash collision modeling
BOOL gfModelSDCollisions = FALSE;
#endif

// compute SD hash, pHash should point to a 16-byte buffer
VOID __inline computeSDhash(PSECURITY_DESCRIPTOR pSD, DWORD cbSD, BYTE* pHash, DWORD cbHash)
{
    MD5_CTX md5Ctx;
    Assert(cbHash == MD5DIGESTLEN);

    MD5Init(&md5Ctx);
    MD5Update(&md5Ctx, pSD, cbSD);
    MD5Final(&md5Ctx);

#ifdef DBG
    if (gfModelSDCollisions) {
        // screw up the hash so we get more collisions
        memset(&md5Ctx.digest[1], 0, MD5DIGESTLEN-1);
        // just keep the first bits
        md5Ctx.digest[0] &= 0x80;
    }
#endif

    memcpy(pHash, md5Ctx.digest, MD5DIGESTLEN);
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Security Descriptor Internal to External conversion */

// NOTE!!!! When called without any value for SecurityInformation, all 4 parts
// of the SecurityDescriptor are returned.  Since DBGetAttVal and DBGetAttVal_AC
// DO NOT SET this value when calling here, those routines will always get the
// full Security Descriptor.

#define SEC_INFO_ALL (SACL_SECURITY_INFORMATION  | \
                      OWNER_SECURITY_INFORMATION | \
                      GROUP_SECURITY_INFORMATION | \
                      DACL_SECURITY_INFORMATION    )

// global flag controlling how SDs are stored
BOOL gStoreSDsInMainTable = FALSE;

typedef struct _SD_REALLOC {
    DBPOS*  pDB;
    BOOL    fUseValBuf;
    BYTE*   pbMin;
    BYTE*   pbMax;
    BYTE*   pb;
} SD_REALLOC, *PSD_REALLOC;

void* JET_API
SDRealloc(
    IN OUT  PSD_REALLOC     psdr,
    IN      void*           pv,
    IN      unsigned long   cb
    )
{
    // alloc
    if (!pv) {

        // alloc JET structs from the stack buffer
        Assert(sizeof(JET_ENUMCOLUMN) < SECURITY_DESCRIPTOR_MIN_LENGTH &&
               sizeof(JET_ENUMCOLUMNVALUE) < SECURITY_DESCRIPTOR_MIN_LENGTH &&
               "The code below assumes the size of JET_ENUMCOLUMN and JET_ENUMCOLUMNVALUE" \
               " is smaller than a minimum SD size.");

        if (cb == sizeof(JET_ENUMCOLUMN) || cb == sizeof(JET_ENUMCOLUMNVALUE)) {
            const size_t    cbAlign = sizeof( void* );
            size_t          cbAlloc = cb + cbAlign - 1;
                            cbAlloc = cbAlloc - cbAlloc % cbAlign;

            if ((size_t)( psdr->pbMax - psdr->pb ) >= cbAlloc) {
                BYTE* pbAlloc = psdr->pb;
                psdr->pb += cbAlloc;
                return pbAlloc;
            } else {
                Assert(!"We should not be here. " \
                        "Why would we need more than one JET_ENUMCOLUMN and one JET_ENUMCOLUMNVALUE?")
                return NULL;
            }

        // alloc SD data
        } else {
            // alloc SD data from the val buf
            if (psdr->fUseValBuf) {
                DBPOS* pDB = psdr->pDB;
                // Can't use MAKEBIG_VALBUF() here because it throws exceptions
                if (pDB->valBufSize < cb) {
                    // we need to alloc more space.
                    UCHAR* pBuf;
                    if (pDB->pValBuf) {
                        pBuf = (UCHAR*)THReAllocOrg(pDB->pTHS, pDB->pValBuf, cb);
                    }
                    else {
                        pBuf = (UCHAR*)THAllocOrg(pDB->pTHS, cb);
                    }
                    if (pBuf == NULL) {
                        // failed to allocate
                        return NULL;
                    }
                    pDB->pValBuf = pBuf;
                    pDB->valBufSize = cb;
                }
                return pDB->pValBuf;

            // alloc SD data using THAllocOrg()
            } else {
                // Can not throw exceptions in this JET callback.
                // Return NULL if allocation failed.
                return THAllocOrg(psdr->pDB->pTHS, cb);
            }
        }

    // free
    } else if (!cb) {

        // we are being asked to free stack buffer
        if (psdr->pbMin <= (BYTE*)pv && (BYTE*)pv < psdr->pbMax) {

            // we do not reuse memory from the stack buffer
            return NULL;

        // we are being asked to free the val buf
        } else if (pv == psdr->pDB->pValBuf) {

            // we do not free memory in the val buf
            return NULL;

        // we are being asked to free THAllocOrg()ed memory
        } else {
            THFreeOrg(psdr->pDB->pTHS, pv);
            return NULL;
        }

    // resize (not supported)
    } else {
        return NULL;
    }
}


void
SDFreeData(
    IN      PSD_REALLOC         psdr,
    IN      unsigned long       cEnumColumn,
    IN      JET_ENUMCOLUMN*     rgEnumColumn
    )
{
    JET_ERR                 err                 = JET_errSuccess;
    size_t                  iEnumColumn         = 0;
    JET_ENUMCOLUMN*         pEnumColumn         = NULL;
    size_t                  iEnumColumnValue    = 0;
    JET_ENUMCOLUMNVALUE*    pEnumColumnValue    = NULL;

    for (iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++) {
        pEnumColumn = rgEnumColumn + iEnumColumn;

        if (pEnumColumn->err != JET_wrnColumnSingleValue) {
            for (iEnumColumnValue = 0;
                 iEnumColumnValue < pEnumColumn->cEnumColumnValue;
                 iEnumColumnValue++) {
                pEnumColumnValue = pEnumColumn->rgEnumColumnValue + iEnumColumnValue;

                SDRealloc(psdr, pEnumColumnValue->pvData, 0);
            }

            SDRealloc(psdr, pEnumColumn->rgEnumColumnValue, 0);
        } else {
            SDRealloc(psdr, pEnumColumn->pvData, 0);
        }
    }

    SDRealloc(psdr, rgEnumColumn, 0);
}

int
IntExtSecDesc(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG intLen,   UCHAR *pIntVal,
              ULONG *pExtLen, UCHAR **ppExtVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG SecurityInformation)
{
    THSTATE  *pTHS=pDB->pTHS;
    NTSTATUS NtStatus;
    PISECURITY_DESCRIPTOR_RELATIVE RetrieveSD = NULL;
    ULONG ReturnSDLength;
    DWORD dwErr = 0;
    int   delta;
    BOOL bIsStoredInSDTable;
    ULONG cEnumColumnId = 1;
    JET_ENUMCOLUMNID rgEnumColumnId[1] = {
        { sdvalueid, 0, NULL, },
    };
    struct {
        JET_ENUMCOLUMN jec;
        JET_ENUMCOLUMNVALUE jecv;
    } rgbStackBuffer;
    SD_REALLOC sdr = {
        pDB,
        TRUE,
        (PBYTE)&rgbStackBuffer,
        ((PBYTE)&rgbStackBuffer) + sizeof(rgbStackBuffer),
        (PBYTE)&rgbStackBuffer
    };
    ULONG cEnumColumn = 0;
    JET_ENUMCOLUMN* rgEnumColumn = NULL;

    Assert((SecurityInformation & ~INTEXT_VALID_FLAGS) == 0 && extTableOp != DBSYN_ADD);

    DPRINT(3,"IntExtSecDesc entered\n");

    if (extTableOp == DBSYN_INQ) {
        // Mask out just the important bits
        SecurityInformation &= SEC_INFO_ALL;
        if (!SecurityInformation) {
            // They are really asking for everything
            SecurityInformation = SEC_INFO_ALL;
        }
        sdr.fUseValBuf = SecurityInformation == SEC_INFO_ALL;
    }

    // NOTE: to distinguish between the old SDs stored directly in the data table
    // and the new ones stored in the SD table we use the fact that the SD ID
    // (which is used as a key to point to the SD) is 8 bytes and the minimum
    // size of a SD is SECURITY_DESCRIPTOR_MIN_LENGTH, which is
    // 2 bytes + 1 word + 4 pointers = 20 bytes (or 36 bytes on Win64). Thus, if the
    // intLen is less than SECURITY_DESCRIPTOR_MIN_LENGTH then we must be looking
    // at an SD ID and should go to the SD table to pick up the actual SD.
    bIsStoredInSDTable = intLen < SECURITY_DESCRIPTOR_MIN_LENGTH;
    if (bIsStoredInSDTable) {
        PSDCACHE_ENTRY pEntry;
        Assert(intLen == sizeof(SDID));
        // first, try to find it in the the SD cache
        if (extTableOp == DBSYN_INQ && (pEntry = dbFindSDCacheEntry(pTHS->Global_DNReadCache, *((SDID*)pIntVal)))) {
            // got it!

            // We will not give away the ptr to the cached SD. This is to prevent accidental modification
            // of global data. The caller of this routine has no flag returned indicating whether the data
            // is ptr to cache or not. In the original code, the returned data was always sitting in the
            // pDB->pValBuf, so we will keep the old functionality.
            intLen = pEntry->cbSD;
            pIntVal = (PUCHAR)SDRealloc(&sdr, NULL, intLen);
            if (pIntVal == NULL) {
                DsaExcept(DSA_MEM_EXCEPTION, 0 ,0);
            }
            memcpy(pIntVal, &pEntry->SD, intLen);
            bIsStoredInSDTable = FALSE;
        }
        else {
            // position on the SD in the SD table (index is already set)
            JetMakeKeyEx(pDB->JetSessID, pDB->JetSDTbl, pIntVal, intLen, JET_bitNewKey);

            dwErr = JetSeekEx(pDB->JetSessID, pDB->JetSDTbl, JET_bitSeekEQ);
            if (dwErr) {
                // did not find a corresponding SD in the SD table
                DPRINT2(0, "Failed to locate SD for id=%I64x, err=%d\n", *((SDID*)pIntVal), dwErr);
                Assert(!"Failed to locate SD -- not found in the SD table!");
                return dwErr;
            }
            DPRINT1(1, "Located SD for sdid %I64x\n", *((SDID*)pIntVal));
        }
    }

    switch (extTableOp) {
    case DBSYN_INQ:
        // if we were given an SDID then read its SD
        if (bIsStoredInSDTable) {
            JetEnumerateColumnsEx(pDB->JetSessID,
                                  pDB->JetSDTbl,
                                  cEnumColumnId,
                                  rgEnumColumnId,
                                  &cEnumColumn,
                                  &rgEnumColumn,
                                  (JET_PFNREALLOC)SDRealloc,
                                  &sdr,
                                  -1,
                                  0);
            Assert(rgEnumColumn[0].err == JET_errSuccess ||
                   rgEnumColumn[0].err == JET_wrnColumnNull);
            Assert(rgEnumColumn[0].cEnumColumnValue == 1 ||
                   rgEnumColumn[0].cEnumColumnValue == 0);
        }

        // if no manipulation is required then return the value directly
        if (SecurityInformation == SEC_INFO_ALL) {
            if (bIsStoredInSDTable) {
                *pExtLen    = rgEnumColumn[0].rgEnumColumnValue[0].cbData;
                *ppExtVal   = rgEnumColumn[0].rgEnumColumnValue[0].pvData;
                Assert(*ppExtVal == pDB->pValBuf);
            } else {
                *pExtLen    = intLen;
                *ppExtVal   = pIntVal;
            }
        }

        // manipulation is required
        else {
            if (bIsStoredInSDTable) {
                RetrieveSD = (PISECURITY_DESCRIPTOR_RELATIVE)rgEnumColumn[0].rgEnumColumnValue[0].pvData;
            } else {
                RetrieveSD = (PISECURITY_DESCRIPTOR_RELATIVE)pIntVal;
            }

            //
            // blank out the parts that aren't to be returned
            //
            if ( !(SecurityInformation & SACL_SECURITY_INFORMATION) ) {
                RetrieveSD->Control  &= ~SE_SACL_PRESENT;
            }

            if ( !(SecurityInformation & DACL_SECURITY_INFORMATION) ) {
                RetrieveSD->Control  &= ~SE_DACL_PRESENT;
            }

            if ( !(SecurityInformation & OWNER_SECURITY_INFORMATION) ) {
                RetrieveSD->Owner = 0;
            }

            if ( !(SecurityInformation & GROUP_SECURITY_INFORMATION) ) {
                RetrieveSD->Group = 0;
            }


            //
            // Determine how much memory is needed for a self-relative
            // security descriptor containing just this information.
            //
            ReturnSDLength = 0;
            NtStatus = RtlMakeSelfRelativeSD(
                    (PSECURITY_DESCRIPTOR)RetrieveSD,
                    NULL,
                    &ReturnSDLength
                    );

            if (NtStatus != STATUS_BUFFER_TOO_SMALL) {
                dwErr = DBSYN_SYSERR;
                goto Exit;
            }

            *pExtLen = ReturnSDLength;

            MAKEBIG_VALBUF(ReturnSDLength);
            *ppExtVal = pDB->pValBuf;       // user output points to val buf

            //
            // make an appropriate self-relative security descriptor
            //

            NtStatus = RtlMakeSelfRelativeSD(
                    (PSECURITY_DESCRIPTOR)RetrieveSD,
                    *ppExtVal,
                    &ReturnSDLength);

            if(!NT_SUCCESS(NtStatus)) {
                dwErr = DBSYN_SYSERR;
                goto Exit;
            }
        }
Exit:
        SDFreeData(&sdr, cEnumColumn, rgEnumColumn);
        break;

    case DBSYN_REM:
        // remove the SD
        if (bIsStoredInSDTable) {
            DPRINT(1, "Successfully located SD, decrementing refcount\n");
            // need to dereference the SD. We are positioned on the right row in SD table
            delta = -1;
            JetEscrowUpdateEx(pDB->JetSessID,
                              pDB->JetSDTbl,
                              sdrefcountid,
                              &delta,
                              sizeof(delta),
                              NULL,     // pvOld
                              0,        // cbOldMax
                              NULL,     // pcbOldActual
                              0);       // grbit


        }
        break;

    default:
        DPRINT(1,"We should never be here\n");
        dwErr = DBSYN_BADOP;
    }

    return dwErr;

    (void)   jTbl;          /*NotReferenced*/
    (void)   ulUpdateDnt;   /*NotReferenced*/
#undef SEC_INFO_ALL
}/*IntExtSecDesc*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Security Descriptor External to Internal conversion */

int
ExtIntSecDesc(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG extLen,   UCHAR *pExtVal,
              ULONG *pIntLen, UCHAR **ppIntVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
    THSTATE *pTHS=pDB->pTHS;
    DWORD   dwErr = 0;
    int     refCount;
    JET_SETINFO setinfo;
    BOOL    bSdIsPresent;
    BYTE    sdHash[MD5DIGESTLEN];
    DWORD   cbActual;

    Assert(extTableOp != DBSYN_REM);

    DPRINT(3,"ExtIntDescDesc entered\n");

    if (gStoreSDsInMainTable) {
        // no conversion required!
        *ppIntVal  = pExtVal;
        *pIntLen   = extLen;
        return 0;
    }

    // compute the MD5 hash of the value.
    // we need to do this for both DBSYN_INQ and DBSYN_ADD
    computeSDhash((PSECURITY_DESCRIPTOR)pExtVal, extLen, sdHash, sizeof(sdHash));

    // change the index to hash
    JetSetCurrentIndex4Success(pDB->JetSessID, pDB->JetSDTbl, SZSDHASHINDEX, &idxSDHash, 0);

    __try {
        // position on the SD in the SD table (index is already set)
        JetMakeKeyEx(pDB->JetSessID, pDB->JetSDTbl, sdHash, sizeof(sdHash), JET_bitNewKey);
        dwErr = JetSeekEx(pDB->JetSessID, pDB->JetSDTbl, JET_bitSeekEQ | JET_bitSetIndexRange);

        if (dwErr == JET_errRecordNotFound) {
            bSdIsPresent = FALSE;
            dwErr = 0;
        }
        else if (dwErr) {
            // some other error happened
            DPRINT1(0, "Error locating SD 0x%x\n", dwErr);
            __leave;
        }
        else {
#ifdef WE_ARE_NOT_PARANOID
            // assume that if MD5 hashes match, then the values will also match
            bSdIsPresent = TRUE;
#else
            // Let's be paranoid and check that the SD is the same
            PBYTE pSD;
            pSD = THAllocEx(pTHS, extLen);
            bSdIsPresent = FALSE;
            while (dwErr == 0) {
                // read the SD
                dwErr = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetSDTbl, sdvalueid, pSD, extLen, &cbActual, 0, NULL);
                if (dwErr == 0 && cbActual == extLen && memcmp(pSD, pExtVal, extLen) == 0) {
                    // we found a match!
                    bSdIsPresent = TRUE;
                    break;
                }
#ifdef DBG
                if (gfModelSDCollisions) {
                    DPRINT(0, "SD hash collision. This is normal -- hash collision modeling is ON\n");
                }
                else {
                    // ok, according to DonH, the universe nears its end.
                    Assert(!"MD5 hash collision occured! Run for your lives!");
                }
#endif
                dwErr = JetMove(pDB->JetSessID, pDB->JetSDTbl, JET_MoveNext, 0);
            }
            if (dwErr == JET_errNoCurrentRecord) {
                // ok, no more records.
                dwErr = 0;
            }
            THFreeEx(pTHS, pSD);
#endif
        }

        if (bSdIsPresent) {
            // compute the internal value: read the ID
            MAKEBIG_VALBUF(sizeof(SDID));
            *pIntLen = sizeof(SDID);
            *ppIntVal = pDB->pValBuf;
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetSDTbl, sdidid, *ppIntVal, *pIntLen, &cbActual, 0, NULL);
            Assert(cbActual == sizeof(SDID));
        }

        switch (extTableOp) {
        case DBSYN_INQ:
            if (!bSdIsPresent) {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }
            // nothing else to do, internal value is already computed
            break;

        case DBSYN_ADD:
            if (!bSdIsPresent) {
                // did not find a corresponding SD in the SD table
                DPRINT(1, "Failed to locate SD, adding a new record\n");

SDNotFound:
                memset(&setinfo, 0, sizeof(setinfo));
                setinfo.cbStruct = sizeof(setinfo);
                setinfo.itagSequence = 1;

                MAKEBIG_VALBUF(sizeof(SDID));
                *pIntLen = sizeof(SDID);
                *ppIntVal = pDB->pValBuf;

                __try {
                    // Each of the Jet calls below either succeeds or excepts, so we are not checking the return values
                    // note: we are not setting sdrefcount, since its default value is 1 -- that's what we need
                    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSDTbl, JET_prepInsert);
                    // read the new ID right away
                    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetSDTbl, sdidid, *ppIntVal, sizeof(SDID), &cbActual, JET_bitRetrieveCopy, NULL);
                    Assert(cbActual == sizeof(SDID));
                    JetSetColumnSuccess(pDB->JetSessID, pDB->JetSDTbl, sdhashid, sdHash, sizeof(sdHash), 0, NULL);
                    JetSetColumnSuccess(pDB->JetSessID, pDB->JetSDTbl, sdvalueid, pExtVal, extLen, 0, &setinfo);
                    JetUpdateEx(pDB->JetSessID, pDB->JetSDTbl, NULL, 0, 0);
                }
                __finally {
                    if (AbnormalTermination()) {
                        // one of the above calls failed. Cancel the update
                        JetPrepareUpdate(pDB->JetSessID, pDB->JetSDTbl, JET_prepCancel);
                    }
                }
            }
            else {
                // found a matching SD, increment the refcount
                DPRINT(1, "Successfully located SD, incrementing refcount\n");

                refCount = 1;
                dwErr = JetEscrowUpdate(pDB->JetSessID,
                                        pDB->JetSDTbl,
                                        sdrefcountid,
                                        &refCount,
                                        sizeof(refCount),
                                        NULL,     // pvOld
                                        0,        // cbOldMax
                                        NULL,     // pcbOldActual
                                        0);       // grbit
                if (dwErr == JET_errWriteConflict) {
                    // Once a row is inserted into SD table, the only
                    // updates that are performed on it are escrow updates
                    // to the refCount, which can never conflict.
                    // Thus, since we got a write-conflict here, we can
                    // be sure we collided with the delete-on-zero cleanup
                    // task in JET. Thus, we can safely assume that this SD
                    // has been just deleted on us by the cleanup task.
                    // So, pretend we never found it.
                    dwErr = JET_errSuccess;
                    DPRINT(1, "SD escrow update write-conflicted with the cleanup task. Inserting a new row.\n");
                    goto SDNotFound;
                }
                else if (dwErr) {
                    // we should except on any other error.
                    DsaExcept(DSA_DB_EXCEPTION, dwErr, 0);
                }
            }
        }
    }
    __finally {
        // change the index back to SDID (pass NULL to set primary index)
        JetSetCurrentIndex4Success(pDB->JetSessID, pDB->JetSDTbl, NULL, &idxSDId, 0);
    }

    return dwErr;

    (void)   jTbl;     /*NotReferenced*/
    (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntSecDesc*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare SD value.  "Presence,=" tests are allowed.
*/

int
EvalSecDesc (DBPOS FAR *pDB,  UCHAR Oper,
             ULONG intLen1, UCHAR *pIntVal1,
             ULONG intLen2,  UCHAR *pIntVal2
             )
{
    PUCHAR pExtVal1, pExtVal2;
    DWORD extLen1 = 0, extLen2 = 0;
    DWORD err;
    BOOL match;
    THSTATE* pTHS = pDB->pTHS;

    DPRINT(3,"EvalSecDesc entered\n");

    switch(Oper) {
    case FI_CHOICE_PRESENT:
        return TRUE;
        break;

    case FI_CHOICE_EQUALITY:
        // You'll note that we don't advertise this comparitor in the
        // rgValidOperators array.  That is because this is binary comparison,
        // not functional comparison.  However, it is good enough (and
        // necessary) for internal use.

        if (intLen1 == sizeof(SDID) && intLen2 == sizeof(SDID)) {
            // most probable case -- both SDs are in the new format. Compare the ids
            if (*(SDID*)pIntVal1 == *(SDID*)pIntVal2) {
                return TRUE;
            }
            // even though SDIDs are different, we can not tell if the actual
            // SDs are different. We must read them an compare.
        }
        // Convert them both to actual SD values
        if (intLen1 == sizeof(SDID)) {
            // first one is in the new format, convert to external
            PUCHAR tmp;
            err = IntExtSecDesc(pDB, DBSYN_INQ, intLen1, pIntVal1, &extLen1, &tmp, 0, 0, 0);
            if (err) {
                return err;
            }
            // must make a copy, because the second IntExtSecDesc might use the conversion buffer
            pExtVal1 = dbAlloc(extLen1);
            memcpy(pExtVal1, tmp, extLen1);
        }
        else {
            // first one in the old format, leave it as is
            pExtVal1 = pIntVal1;
            extLen1 = intLen1;
        }
        if (intLen2 == sizeof(SDID)) {
            // second one is in the new format, convert to external
            err = IntExtSecDesc(pDB, DBSYN_INQ, intLen2, pIntVal2, &extLen2, &pExtVal2, 0, 0, 0);
            if (err) {
                if (pExtVal1 != pIntVal1) {
                    dbFree(pExtVal1);
                }
                return err;
            }
        }
        else {
            // second one in the old format, leave it as is
            pExtVal2 = pIntVal2;
            extLen2 = intLen2;
        }
        // now compare the external values
        match = extLen1 == extLen2 && memcmp(pExtVal1, pExtVal2, extLen1) == 0;
        if (pExtVal1 != pIntVal1) {
            dbFree(pExtVal1);
        }
        return match;
        break;

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
    }

}/*EvalSecDesc*/

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/* This routine does in place swap of the the last sub-authority of the SID */
void
InPlaceSwapSid(PSID pSid)
{
    ULONG ulSubAuthorityCount;

    ulSubAuthorityCount= *(RtlSubAuthorityCountSid(pSid));
    if (ulSubAuthorityCount > 0 && ulSubAuthorityCount <= MAX_NT4_SID_SUBAUTHORITY_COUNT)
    {
        PBYTE  RidLocation;
        BYTE   Tmp[4];

        RidLocation =  (PBYTE) RtlSubAuthoritySid(
                             pSid,
                             ulSubAuthorityCount-1
                             );

        //
        // Now byte swap the Rid location
        //

        Tmp[0] = RidLocation[3];
        Tmp[1] = RidLocation[2];
        Tmp[2] = RidLocation[1];
        Tmp[3] = RidLocation[0];

        RtlCopyMemory(RidLocation,Tmp,sizeof(ULONG));
    }
    else {
        // we should not have any SIDs with zero or more than 5 subauthorities.
        Assert(!"Invalid SID");
    }
}
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Sid External to Internal conversion  requires byte swapping the Rid, in case
   of Account Sids. However since we cannot apriori determine wether a given Sid
   is a domain Sid or Account Sid we will byte swap the last subauthority on the
   Sid
*/
int ExtIntSid(DBPOS FAR *pDB, USHORT extTableOp,
                ULONG extLen,   UCHAR *pExtVal,
                ULONG *pIntLen, UCHAR **ppIntVal,
                ULONG ulUpdateDnt, JET_TABLEID jTbl,
                ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    DWORD    cb;

   DPRINT(3,"ExtIntSid entered\n");

   // Validate The Sid

   if (    !RtlValidSid(pExtVal)
        || ((cb = RtlLengthSid(pExtVal)) != extLen)
        || (cb > sizeof(NT4SID)) )
   {
       return 1;
   }

   MAKEBIG_VALBUF(extLen);
   *ppIntVal  = pDB->pValBuf;
   *pIntLen   = extLen;

   RtlCopyMemory(*ppIntVal,pExtVal,extLen);

   InPlaceSwapSid(*ppIntVal);


   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntSid*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Sid Internal to External conversion */

int IntExtSid(DBPOS FAR *pDB, USHORT extTableOp,
                ULONG intLen,   UCHAR *pIntVal,
                ULONG *pExtLen, UCHAR **ppExtVal,
                ULONG ulUpdateDnt, JET_TABLEID jTbl,
                ULONG flags)
{
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtSid entered\n");

   //
   // For an Account Sid byte swap the Rid portion, so
   // that we index it correctly.
   //

   //
   // Since Internal to external conversion a Sid is just a
   // byte swapping on the Rid portion, the same code can be
   // used to do both
   //

   return ( ExtIntSid(pDB,extTableOp,intLen,pIntVal,
                        pExtLen, ppExtVal, ulUpdateDnt, jTbl,
                        flags));

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtSid*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare Sid values.  Since values to be compared are always internal
   values we can call EvalOctet
*/

int EvalSid(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
              UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{
    DPRINT(3,"EvalSid entered\n");

    return(EvalOctet(pDB,Oper,intLen1,pIntVal1,intLen2,pIntVal2));
}


// Now, put all thse into an array so the rest of the world can use them.
const DBSyntaxStruct gDBSyntax[MAXSYNTAX]	= {
		{ IntExtUnd, ExtIntUnd, EvalUnd },						//	syntax 0
		{ IntExtDist, ExtIntDist, EvalDist },					//	syntax 1
		{ IntExtID, ExtIntID, EvalID },							//	syntax 2
		{ IntExtCase, ExtIntCase, EvalCase },					//	syntax 3
		{ IntExtNoCase, ExtIntNoCase, EvalNoCase },				//	syntax 4
		{ IntExtCase, ExtIntCase, EvalCase },					//	Print_case
		{ IntExtCase, ExtIntCase, EvalCase },					//	Numeric print
		{ IntExtDistBinary, ExtIntDistBinary, EvalDistBinary },	//	syntax 7
		{ IntExtBool, ExtIntBool, EvalBool },					//	syntax 8
		{ IntExtInt, ExtIntInt, EvalInt },						//	syntax 9
		{ IntExtOctet, ExtIntOctet, EvalOctet },				//	syntax 10
		{ IntExtTime, ExtIntTime, EvalTime },					//	Time
		{ IntExtUnicode, ExtIntUnicode, EvalUnicode },			//	Unicode
		{ IntExtID, ExtIntID, EvalID },							//	Address
		{ IntExtDistString, ExtIntDistString, EvalDistString },	//	syntax 14
		{ IntExtSecDesc, ExtIntSecDesc, EvalSecDesc },			//	Security Descriptor
		{ IntExtI8, ExtIntI8, EvalI8 },							//	Large Integer
		{ IntExtSid, ExtIntSid, EvalSid }
};

// Small routine to determine attributes that are "Secret Data"
// None of the atts here can be GC-replicated. If you add anything here
// make sure that the att is not GC-replicated or will not need to be
// GC-replicated ever. Schema validation code makes sure that no att
// in this list can be marked as GC-replicated. If you add an att to this
// list that is already GC-replicated, any modification of that attribute
// in the schema, except to take un-GC-Replicate it, will fail.

BOOL
__fastcall
DBIsSecretData(ATTRTYP attrType)
{
    switch(attrType)
    {
    case ATT_UNICODE_PWD:
    case ATT_DBCS_PWD:
    case ATT_NT_PWD_HISTORY:
    case ATT_LM_PWD_HISTORY:
    case ATT_SUPPLEMENTAL_CREDENTIALS:
    case ATT_CURRENT_VALUE:
    case ATT_PRIOR_VALUE:
    case ATT_INITIAL_AUTH_INCOMING:
    case ATT_INITIAL_AUTH_OUTGOING:
    case ATT_TRUST_AUTH_INCOMING:
    case ATT_TRUST_AUTH_OUTGOING:
    case ATT_MS_DS_EXECUTESCRIPTPASSWORD:
        return(TRUE);
    default:
        return(FALSE);
    }
}

BOOL
__fastcall
DBIsHiddenData(ATTRTYP attrType)
{
    switch (attrType) {

    // these attributes are hidden from all users, but not encrypted
    case ATT_USER_PASSWORD: //depending on the value of the heristic we will treat this
                            // as a sam attribute or a regular ds attribute
        if (!gfUserPasswordSupport) {
            return FALSE;
        }

    case ATT_PEK_LIST:   // pek_list contains the encryption key, so we don't encrypt it

        return TRUE;

    // all encrypted attributes are also hidden
    default:
        return DBIsSecretData(attrType);
    }
}

DWORD
DBGetExtraHackyFlags(ATTRTYP attrType)
{
    DWORD dwRetFlags = 0;

    switch (attrType) {
    case ATT_WELL_KNOWN_OBJECTS:
    case ATT_OTHER_WELL_KNOWN_OBJECTS:
        dwRetFlags |= INTEXT_WELLKNOWNOBJ;
    }

    return dwRetFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbsubj.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       dbsubj.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Defines various functions for ref-counting DNs and translating them to/from
    DNTs (aka tags).

DETAILS:

    All DNs are stored internally as DNTs (ULONGs).  There is exactly one such
    DNT for each object or phantom in the local database.

    Phantoms generally have one, two, or three attributes -- ATT_RDN (always),
    ATT_OBJECT_GUID (if a reference phantom rather than a structural phantom),
    and ATT_OBJECT_SID (if ATT_OBJECT_GUID is present and the object referenced
    has a SID).  Noticeably absent is ATT_OBJ_DIST_NAME -- this property is
    unique to instantiated objects (be they deleted or not).
    
    (Reference phantoms (i.e., those with GUIDs) may also have ATT_USN_CHANGED
    attributes, used by the stale phantom cleanup daemon.)

    A DN receives one ref-count for:

      o  each direct child, whether that child is an object or phantom, and
      o  each DN-valued attribute that references it, whether that attribute
         is hosted on itself or on some other object.
      o  whether the clean_col column is non-null

    A corollary to the above is that since ATT_OBJ_DIST_NAME is present on a
    record if-and-only-if that record is an instantiated object (not a phantom)
    and ATT_OBJ_DIST_NAME is a DN-valued attribute, all objects have a minimum
    ref-count of 1.

    Note that no distinction is made between link and non-link attributes.  Even
    though a link attribute causes a backlink attribute to be added to its
    target, only one ref-count is added as a result of adding a link attribute,
    and as with non-link attributes that ref-count is added to the target DN.
    No ref-count is added to the host DN for being the target of the backlink.
    No dangling backlink reference is possible since if the host DN is removed
    it must have first been logically deleted, which implicitly removes all link
    attributes and their associated targets' backlinks.  The only difference
    that should be noted between link and non-link attributes with respect to DN
    ref-counting is that logical deletions remove both links and backlinks from
    the object, but do not remove other DN-valued attributes.  (Actually, even
    this distinction has partially disappeared -- most non-linked attributes
    are removed during logical deletion these days, too.)

    If an object is deleted, one tombstone lifetime later that object's
    non-essential attributes are stripped (including ATT_OBJ_DIST_NAME) and the
    object is demoted to a phantom.  Should the ref-count on a phantom reach 0,
    and after one tombstone lifetime has transpired since the record was created
    (if it was never a real object) or logically deleted (if it was once a real
    object), that DN is removed by the next pass of DN garbage collection.

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>

#include <mdcodes.h>
#include <dsevent.h>
#include <dstaskq.h>
#include <dsexcept.h>
#include "objids.h" /* Contains hard-coded Att-ids and Class-ids */
#include "debug.h"  /* standard debugging header */
#define DEBSUB "DBSUBJ:" /* define the subsystem for debugging */

#include "dbintrnl.h"
#include "anchor.h"
#include "dsutil.h"
#include <ntdsctr.h>
#include <filtypes.h>
#include <quota.h>
#include <sdprop.h>
#include <drameta.h>

#include <fileno.h>
#define  FILENO FILENO_DBSUBJ

static ULONG FakeCtr;
volatile ULONG *pcNameCacheTry = &FakeCtr;
volatile ULONG *pcNameCacheHit = &FakeCtr;

/* DNRead flags.*/
#define DN_READ_SET_CURRENCY        1
#define DN_READ_DONT_EXCEPT_ON_MISSING_DNT 2

#ifdef INCLUDE_UNIT_TESTS
// Test hook for refcount test.
GUID gLastGuidUsedToCoalescePhantoms = {0};
GUID gLastGuidUsedToRenamePhantom = {0};
#endif

extern
DWORD
DBPropagationsExist (
        DBPOS * pDB
        );

void
sbTablePromotePhantom(
    IN OUT  DBPOS *     pDB,
    IN      ULONG       dntPhantom,
    IN      ULONG       dntObjParent,
    IN      WCHAR *     pwchRDN,
    IN      DWORD       cbRDN
    );

DWORD
sbTableGetTagFromGuid(
    IN OUT  DBPOS *       pDB,
    IN      JET_TABLEID   tblid,
    IN      GUID *        pGuid,
    OUT     ULONG *       pTag,             OPTIONAL
    OUT     d_memname **  ppname,           OPTIONAL
    OUT     BOOL *        pfIsRecordCurrent OPTIONAL
    );

DWORD
sbTableGetTagFromStringName(
    IN  DBPOS *       pDB,
    IN  JET_TABLEID   tblid,
    IN  DSNAME *      pDN,
    IN  BOOL          fAddRef,
    IN  BOOL          fAnyRDNType,    
    IN  DWORD         dwExtIntFlags,
    OUT ULONG *       pTag,             OPTIONAL
    OUT d_memname **  ppname,           OPTIONAL
    OUT BOOL *        pfIsRecordCurrent OPTIONAL
    );

void __inline SwapDWORD(DWORD * px, DWORD * py)
{
    DWORD tmp = *px;
    *px = *py;
    *py = tmp;
}

void __inline SwapPTR(VOID ** ppx, VOID ** ppy)
{
    VOID * tmp = *ppx;
    *ppx = *ppy;
    *ppy = tmp;
}

ULONG
DNwrite(
    IN OUT  DBPOS *     pDB,
    IN OUT  d_memname * rec,
    IN      ULONG       dwFlags
    )
/*++

Routine Description:

    Inserts a new record/DNT.  This record may correspond to either a phantom or
    an object.
    
    Adds no refcount for itself, but *does* add-ref its parent.

Arguments:

    pDB (IN/OUT)
    
    rec (IN/OUT) - holds the RDN, RDN type, parent DNT, ancestors, and optional
        GUID/SID.  On return, the ancestors list is updated to include the DNT
        of the current record.
    
    dwFlags (IN) - 0 or EXTINT_NEW_OBJ_NAME.  The latter asserts that this
        record is being inserted for a new object, and therefore should be
        updated in the object table cursor (pDB->JetObjTbl).

Return Values:

    The DNT of the inserted record.

    Throws database exception on error.

--*/
{
    char        objval = 0;
    JET_TABLEID     tblid;
    DSTIME      ulDelTime;
    ULONG       cb;
    NT4SID              sidInternalFormat;
    ULONG               ulDNT;
    DWORD               cRef = 0;
    BOOL                fRecHasGuid;
    
    DPRINT(2, "DNwrite entered\n");

    fRecHasGuid = !fNullUuid(&rec->Guid);

    Assert(VALID_DBPOS(pDB));
    Assert((0 == rec->SidLen) || fRecHasGuid);
    Assert((0 == rec->SidLen) || RtlValidSid(&rec->Sid));

    if ( dwFlags & EXTINT_NEW_OBJ_NAME )
    {
        // Inserting a new object; since we're already udpating this DNT in
        // the object table, use its update context.
        tblid = pDB->JetObjTbl;
    }
    else
    {
        // Inserting a phantom DNT; the object table is already prepared in an
        // update of a different DNT, so use the search table (which requires
        // us to prepare and terminate our own update).
        tblid = pDB->JetSearchTbl;

        // We're going to use the search table to do the write, so we must do a
        // JetPrepare first.
        JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, JET_prepInsert);
    }

    /* indicate that data portion is missing;
     * set the deletion time in case this record will never become an
     * object. If it does become an object the del time is removed. If
     * it doesn't and the reference count drops to 0, this record will be
     * removed by garbage collection;
     * Set the Parent DNT
     */

    ulDelTime = DBTime();
    /* get the DNT */

    JetRetrieveColumnSuccess(pDB->JetSessID, tblid, dntid, &ulDNT,
                             sizeof(ulDNT), &cb, JET_bitRetrieveCopy, NULL);

    // A newly created row is treated differently when flushing
    // the dnread cache. Namely, the global cache's invalidation
    // logic is not triggered because a newly created row could
    // not be in the cache.
    pDB->NewlyCreatedDNT = ulDNT;

    rec->pAncestors[rec->cAncestors] = ulDNT;
    rec->cAncestors++;

    JetSetColumnEx(pDB->JetSessID, tblid, objid, &objval,
                   sizeof(objval), 0, NULL);
    JetSetColumnEx(pDB->JetSessID, tblid, deltimeid, &ulDelTime,
                   sizeof(ulDelTime), 0, NULL);
    JetSetColumnEx(pDB->JetSessID, tblid, pdntid, &rec->tag.PDNT,
                   sizeof(rec->tag.PDNT),  0, NULL);
    JetSetColumnEx(pDB->JetSessID, tblid, ancestorsid, rec->pAncestors,
                   rec->cAncestors * sizeof(DWORD), 0, NULL);
    // The rdnType is stored in the DIT as the msDS_IntId, not the
    // attributeId. This means an object retains its birth name
    // even if unforeseen circumstances allow the attributeId
    // to be reused.
    JetSetColumnEx(pDB->JetSessID, tblid, rdntypid, &rec->tag.rdnType,
                   sizeof(rec->tag.rdnType), 0, NULL);
    JetSetColumnEx(pDB->JetSessID, tblid, rdnid, rec->tag.pRdn,
                   rec->tag.cbRdn, 0, NULL);

    if (!(dwFlags & EXTINT_NEW_OBJ_NAME) && fRecHasGuid) {
        USN usnChanged;
        
        // We're inserting a new reference phantom -- add its GUID and SID
        // (if any) to the record. Also, give it a USN changed so that the code
        // to freshen stale phantoms can find it.
        JetSetColumnEx(pDB->JetSessID, tblid, guidid, &rec->Guid,
                       sizeof(GUID), 0, NULL);

        if (0 != rec->SidLen) {
            // Write SID in internal format.
            memcpy(&sidInternalFormat, &rec->Sid, rec->SidLen);
            InPlaceSwapSid(&sidInternalFormat);

            JetSetColumnEx(pDB->JetSessID, tblid, sidid, &sidInternalFormat,
                           rec->SidLen, 0, NULL);
        }

        usnChanged = DBGetNewUsn();
        
        JetSetColumnEx(pDB->JetSessID, tblid, usnchangedid,
                       &usnChanged, sizeof(usnChanged), 0, NULL);
    }

    /* Set reference count */

    JetSetColumnEx(pDB->JetSessID, tblid, cntid, &cRef, sizeof(cRef), 0, NULL);
        

    /* update the record. */

    if ( !( dwFlags & EXTINT_NEW_OBJ_NAME ) )
    {
        Assert( tblid == pDB->JetSearchTbl );

        JetUpdateEx(pDB->JetSessID, tblid, NULL, 0, 0);

        // Note that pDB->JetSearchTbl is no longer positioned on the inserted
        // object -- it's positioned wherever it was prior to the
        // JetPrepareUpdate() (which should be the record with DNT pDB->SDNT).
    }

    // Add a refcount to the parent, since we've just given it a new child.
    DBAdjustRefCount(pDB, rec->tag.PDNT, 1);
    
    /* return the DNT of the record written */
    return ulDNT;
}



d_memname *
DNread(DBPOS *pDB,
       ULONG tag,
       DWORD dwFlags)
/*++

  Find a record by DNT.  Look in the cache first.  If no luck there, read
  the record and put it in the cache.
  
  Normally, the routine will except if it can not find the tag passed.
  If DN_READ_DONT_EXCEPT_ON_MISSING_DNT is passed, then it will not except,
  but return NULL.

--*/    
{

    DWORD        index, i;
    JET_ERR  err;
    d_memname *  pname = NULL;

    DPRINT1(4, "DNread entered tag: 0x%x\n", tag);

    Assert(VALID_DBPOS(pDB));

    if(pDB != pDBhidden) {
        /* Now, look in the cache to avoid doing the read. */
        dnGetCacheByDNT(pDB,tag,&pname);
    }
    
    if ((NULL == pname) || (dwFlags & DN_READ_SET_CURRENCY)) {
        /* Make target record current for pDB->JetSearchTbl */
        pDB->SDNT = 0;
        
        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetSearchTbl,
                                  NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)
        
        JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, &tag, sizeof(tag),
                     JET_bitNewKey);

        err = JetSeek(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
        if (err) {
            if (err == JET_errRecordNotFound && (dwFlags & DN_READ_DONT_EXCEPT_ON_MISSING_DNT)) {
                // this is only called from sbTableGetDSName. It knows how to handle this situation.
                return NULL;
            }
            DsaExcept(DSA_DB_EXCEPTION, err, tag);
        }

        pDB->SDNT = tag;

        // Add record to read cache if it isn't there already.
        if (NULL == pname) {
            pname = DNcache(pDB, pDB->JetSearchTbl, FALSE);
        }
    }

    Assert(NULL != pname);

    return pname;
}


/*++ DNChildFind
 *
 * Given a DNT and an RDN, returns a cache element for the entry with
 * the specified RDN that is a child of the specified DNT.  If no such
 * object exists, returns ERROR_DS_OBJ_NOT_FOUND.  
 * The attribute type of the RDN is mandatory, and checked for accuracy.
 */
ULONG
DNChildFind(DBPOS *pDB,
            JET_TABLEID tblid,
            BOOL fEnforceType,
        ULONG parenttag,
        WCHAR *pRDN,
        ULONG cbRDN,
        ATTRTYP rdnType,
        d_memname **ppname,
        BOOL * pfIsRecordCurrent,
        BOOL * pfOnPDNTIndex)
{
    THSTATE *pTHS = pDB->pTHS;
    d_memname *pname=NULL;
    DWORD i,j;
    JET_ERR err;
    ULONG childtag;
    ULONG actuallen;
    ATTRTYP trialtype;
    BYTE *pLocalRDN = NULL;
    DWORD cbActual;
    
    Assert(VALID_DBPOS(pDB));

    /* Now, look in the cache to avoid doing the read. */
    if(pDB != pDBhidden) {
        // Note that this is enforcing type here, even if fEnforceType = FALSE.
        // If we don't find it here with a type checking on, we will continue
        // and do a DB lookup with type checking off.
        if(dnGetCacheByPDNTRdn(pDB,parenttag, cbRDN, pRDN, rdnType, ppname)) {
            // found it.
            *pfIsRecordCurrent = FALSE;
            return 0;
        }
    }

    // if we are not on the PDNT index then go there now
    if (!(*pfOnPDNTIndex)) {
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                   tblid,
                                   SZPDNTINDEX,
                                   &idxPdnt,
                                   JET_bitMoveFirst);
        *pfOnPDNTIndex = TRUE;
    }

    // ok, we couldn't find it in the cache.  go to the record directly
    // and then read it in a cache friendly manner
    HEAPVALIDATE
    JetMakeKeyEx(pDB->JetSessID,
         tblid,
         &parenttag,
         sizeof(parenttag),
         JET_bitNewKey);
    
    JetMakeKeyEx(pDB->JetSessID,
         tblid,
         pRDN,
         cbRDN,
         0);
    err = JetSeek(pDB->JetSessID,
          tblid,
          JET_bitSeekEQ );
    if (err) {
        DPRINT4(3, "No child '%*.*S' with parent tag 0x%x.\n",
                cbRDN/2, cbRDN/2, pRDN, parenttag);
    return ERROR_DS_OBJ_NOT_FOUND;
    }


    // Was our key truncated?
    err = JetRetrieveKey(pDB->JetSessID, tblid, NULL, 0, &cbActual, 0);
    if((err != JET_errSuccess) && (err != JET_wrnBufferTruncated)) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }

    if(cbActual >= JET_cbKeyMost) {
        // OK we've found something, but not necessarily the right thing since
        // key was potentially truncated.
        pLocalRDN = THAllocEx(pTHS,cbRDN);
        
        err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                        tblid,
                                        rdnid,
                                        pLocalRDN,
                                        cbRDN,
                                        &cbActual,
                                        0,
                                        NULL);
        switch (err) {
        case JET_errSuccess:
            // Successfully read an RDN
            if (gDBSyntax[SYNTAX_UNICODE_TYPE].Eval(
                    pDB,
                    FI_CHOICE_EQUALITY,
                    cbRDN,
                    (PUCHAR)pRDN,
                    cbActual,
                    pLocalRDN)) {
                // And it's the correct RDN.
                break;
            }
            // Else, 
            //   The key was right, but the value was wrong.  It's not the
            // correct object.  fall through and return OBJ_NOT_FOUND
        case JET_wrnBufferTruncated:
            // The RDN found was clearly too long, so it can't be the correct
            // object.  Return OBJ_NOT_FOUND
            // Didn't find the object.
            DPRINT5(3, "No child '%*.*S' with type 0x%x, parent tag 0x%x.\n",
                    cbRDN/2, cbRDN/2, pRDN, rdnType, parenttag);
            THFreeEx(pTHS,pLocalRDN);
            return ERROR_DS_KEY_NOT_UNIQUE;
            break;
            
        default:
            // The retrievecolumn failed in some obscure way.  We can't be sure
            // of anything.  Raise the same exception that
            // JetRetrieveColumnSuccess would have raised.
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
            break;
        }
        THFreeEx(pTHS,pLocalRDN);
    }

    // OK, we are now definitely on an object with the correct RDN and PDNT.
    // See if the type is correct.
    err = JetRetrieveColumnSuccess(pDB->JetSessID,
                                   tblid,
                                   rdntypid,
                                   &trialtype,
                                   sizeof(trialtype),
                                   &cbActual,
                                   0,
                                   NULL);
    Assert(!err);
    // The rdnType is stored in the DIT as the msDS_IntId, not the
    // attributeId. This means an object retains its birth name
    // even if unforeseen circumstances allow the attributeId
    // to be reused.
    if(rdnType != trialtype) {
        if(fEnforceType) {
            // Nope.  We found an object with the correct PDNT-RDN,
            // but the types were incorrect.  Return an error.
            DPRINT5(3, "No child '%*.*S' with type 0x%x, parent tag 0x%x.\n",
                    cbRDN/2, cbRDN/2, pRDN, rdnType, parenttag);
            return ERROR_DS_OBJ_NOT_FOUND;
        }
        else {
            // Hmm. Types are incorrect, but we don't care.  Call
            // DNcache to finish building the d_memname and add it
            // to the read cache, but tell the cache handler that we
            // don't know if this object is in the cache already or
            // not. 
            *ppname = DNcache(pDB, tblid, TRUE);
            *pfIsRecordCurrent = TRUE;
            return 0;
        }
    }
    else {
        // Yep.  Exact match on PDNT-RDN + RDNType. OK, call
        // DNcache to finish building the d_memname and add it
        // to the read cache.  Note that we can tell the DNcache
        // handler that we know this object is not already in the
        // cache because we tried to look it up at the top of this
        // routine and didn't find it (which does enforce type).
        *ppname = DNcache(pDB, tblid, FALSE);
        *pfIsRecordCurrent = TRUE;
        return 0;
    }
    
    Assert(!"You can't get here.\n");
    return ERROR_DS_OBJ_NOT_FOUND;
}

/*++ sbTableGetDSName
 *
 * This routine converts a DNT into the corresponding DSNAME.
 *
 * To eliminate all disagreements over how long a DSNAME can be, we no
 * longer allow callers to furnish a buffer.  sbTableGetDSName now allocates
 * a DSNAME off of the thread heap, and returns it "properly sized", meaning
 * that the heap block is the size indicated by pDN->structLen.
 *
 * Always unlocks cache before exit.
 *
 * Input:
 *  pDB DBPOS to use
 *  tag DNT of entry whose name should be returned
 *  ppName  pointer to pointer to returned name
 * Output:
 *  *ppName filled in with pointer to DSNAME for object
 * Return Value:
 *  0 on success, error code on error
 *
 */
DWORD APIENTRY
sbTableGetDSName(DBPOS FAR *pDB, 
         ULONG tag,
         DSNAME **ppName,
                 DWORD  fFlag
                 )
{
    THSTATE  *pTHS=pDB->pTHS;
    d_memname * pname;
    unsigned len, quotelen;
    ULONG allocLen;                     // Count of Unicode Chars allocated for
                                        // the stringname.
    DWORD dwReadFlags = 0;
    DWORD cChars;
    
    Assert(VALID_DBPOS(pDB));

    DPRINT1( 2, "SBTableGetDSName entered tag: 0x%x\n", tag );

    // Allocate enough memory for most names.
    allocLen = MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2;
    *ppName = THAllocEx(pTHS, DSNameSizeFromLen(allocLen));

    if( tag == ROOTTAG ) {
    /* it's the root! */
    (*ppName)->structLen = DSNameSizeFromLen(0);
    *ppName = THReAllocEx(pTHS, *ppName, DSNameSizeFromLen(0));
    return 0;
    }

    // Read the first component, which determines the GUID and SID

    if(fFlag & INTEXT_MAPINAME) {
        // In this case, we're going to have to read a property from the object,
        // so go ahead and set currency.
        dwReadFlags = DN_READ_SET_CURRENCY;
    }
    
    pname = DNread(pDB, tag, dwReadFlags);
    (*ppName)->Guid = pname->Guid;
    (*ppName)->Sid = pname->Sid;
    (*ppName)->SidLen = pname->SidLen;

    if(fFlag & INTEXT_SHORTNAME) {
        Assert(allocLen > sizeof(DWORD)/sizeof(wchar_t));
        
        // NOTE! assumes that the initial allocation is long enough to hold the
        // tag. 
        (*ppName)->NameLen = 0;
        *((DWORD *)((*ppName)->StringName)) = tag;
        // 2 unicode chars == sizeof DWORD, that's why the (2) in the next line
        (*ppName)->structLen = DSNameSizeFromLen(2);
        DPRINT1( 2, "SBTableGetDSName returning: 0x%x\n", tag);
    }
    else if(fFlag & INTEXT_MAPINAME) {
        CHAR     MapiDN[512];
        wchar_t *pTemp = (*ppName)->StringName;
        DWORD    err, i,cb;
        ATTRTYP  objClass;

        // PERFORMANCE: optimize use jetretrievecolumnS
        
        // First, get the object class
    err = JetRetrieveColumnWarnings(
                pDB->JetSessID,
                pDB->JetSearchTbl,
                objclassid,
                &objClass,
                sizeof(objClass),
                &cb,
                0,
                NULL);

        dbMapiTypeFromObjClass(objClass,pTemp);
        pTemp=&pTemp[2];
        
        // Now, the legacy dn, if one exists
    err = JetRetrieveColumnWarnings(
                pDB->JetSessID,
                pDB->JetSearchTbl,
                mapidnid,
                MapiDN,
                512,
                &cb,
                0,
                NULL);
        
        if(!err) {
            // The constant 2 is for the two chars we used to encode the mapi
            // type. 
            if(allocLen < cb + 2) {
                // need to alloc more.
                allocLen = cb + 2;
                *ppName = THReAllocEx(pTHS, *ppName, DSNameSizeFromLen(allocLen));
            }
            
            (*ppName)->NameLen = cb + 2;
            (*ppName)->structLen = DSNameSizeFromLen(cb + 2);
            // The mapidn is 7 bit ascii, but the string dn is expected to be
            // unicode, so stretch it.
            MultiByteToWideChar(CP_TELETEX,
                                0,
                                MapiDN,
                                cb,
                                pTemp,
                                cb);
        }
        else {
            // Failed to get a stored legacy name - we'll have to fake one
            DWORD ncdnt;
            ULONG cb;
            DSNAME * pNCDN;
            DWORD it;

            // We need to get the GUID of the NC head for this object, but
            // first we need to find out if this object is the NC head itself.
            JetRetrieveColumnSuccess(pDB->JetSessID,
                                     pDB->JetSearchTbl,
                                     insttypeid,
                                     &it,
                                     sizeof(it),
                                     &cb,
                                     0,
                                     NULL);

            // Now we get the NCDNT from the appropriate column
            JetRetrieveColumnSuccess(pDB->JetSessID,
                                     pDB->JetSearchTbl,
                                     ((it & IT_NC_HEAD)
                                      ? dntid
                                      : ncdntid),
                                     &ncdnt,
                                     sizeof(ncdnt),
                                     &cb,
                                     0,
                                     NULL);
            pNCDN = FindNCLFromNCDNT(ncdnt, FALSE)->pNC;

            (*ppName)->NameLen =  2 + DBMapiNameFromGuid_W (
                    pTemp,
                    allocLen - 2,
                    &pname->Guid,
                    &pNCDN->Guid,
                    &cChars);
            if((*ppName)->NameLen != cChars + 2) {
                // Failed to fill in the name, size we didn't give it enough
                // space. We need to alloc more
                allocLen = cChars + 2;
                *ppName = THReAllocEx(pTHS, *ppName, DSNameSizeFromLen(allocLen));
                pTemp = &(*ppName)->StringName[2];
                (*ppName)->NameLen =  DBMapiNameFromGuid_W (pTemp,
                                                            cChars,
                                                            &pname->Guid,
                                                            &pNCDN->Guid,
                                                            &cChars);
            }
            
            (*ppName)->structLen = DSNameSizeFromLen((*ppName)->NameLen);
        }
        (*ppName)->StringName[(*ppName)->NameLen] =  L'\0';
    }      
    else {
        Assert(!(fFlag&INTEXT_MAPINAME));
        Assert(!(fFlag&INTEXT_SHORTNAME));
        
        len = AttrTypeToKey(pname->tag.rdnType, (*ppName)->StringName);
        (*ppName)->StringName[len++] = L'=';

        quotelen= QuoteRDNValue(pname->tag.pRdn,
                                pname->tag.cbRdn/sizeof(WCHAR),
                                &(*ppName)->StringName[len],
                                allocLen - len);

        while (quotelen > (allocLen - len)) {
            allocLen += MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2;
            *ppName = THReAllocEx(pTHS, *ppName, DSNameSizeFromLen(allocLen));
            quotelen= QuoteRDNValue(pname->tag.pRdn,
                                    pname->tag.cbRdn/sizeof(WCHAR),
                                    &(*ppName)->StringName[len],
                                    allocLen - len);
        }
        len += quotelen;
        
        // Pull naming info off of each component, until we're done.
        
        while (pname->tag.PDNT != ROOTTAG) {
            d_memname* pCurName;
            if ((allocLen - len) < (MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2)) {
                // We might not have enough buffer to add another component,
                // so we need to reallocate the buffer up.  We allocate
                // enough for the maximal key, the maximal value, plus two
                // characters more for the comma and equal sign
                allocLen += MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2;
                *ppName = THReAllocEx(pTHS, *ppName, DSNameSizeFromLen(allocLen));
            }
            (*ppName)->StringName[len++] = L',';
            pCurName = pname;
            pname = DNread(pDB, pname->tag.PDNT, DN_READ_DONT_EXCEPT_ON_MISSING_DNT);
            if (pname == NULL || pname->DNT == tag) {
                if (pname == NULL) {
                    // This row has a missing PDNT reference! Enqueue a fixup.
                    DPRINT2(0, "Found an object with missing parent: DNT=%d, PDNT=%d\n", pCurName->DNT, pCurName->tag.PDNT);
                }
                else {
                    // Found a loop in PDNT chain! Enqueue a fixup.
                    DPRINT1(0, "Found a loop in PDNT chain: DNT=%d\n", pCurName->DNT);
                }
                InsertInTaskQueue(TQ_MoveOrphanedObject,
                                  (void*)(DWORD_PTR)pCurName->DNT,
                                  0);
                // Now, we can except
                DsaExcept(DSA_DB_EXCEPTION, JET_errRecordNotFound, pCurName->tag.PDNT);
            }
            len += AttrTypeToKey(pname->tag.rdnType, &(*ppName)->StringName[len]);
            (*ppName)->StringName[len++] = L'=';
            quotelen = QuoteRDNValue(pname->tag.pRdn,
                                     pname->tag.cbRdn/sizeof(WCHAR),
                                     &(*ppName)->StringName[len],
                                     allocLen - len);
            
            while (quotelen > (allocLen - len)) {
                allocLen += MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2;
                *ppName = THReAllocEx(pTHS, *ppName, DSNameSizeFromLen(allocLen));
                quotelen = QuoteRDNValue(pname->tag.pRdn,
                                         pname->tag.cbRdn/sizeof(WCHAR),
                                         &(*ppName)->StringName[len],
                                         allocLen - len);
            }
            len += quotelen;

            // We should not have run out of buffer
            Assert(len < allocLen);
        }
        
        (*ppName)->StringName[len] =  L'\0';
        
        (*ppName)->NameLen = len;
        (*ppName)->structLen = DSNameSizeFromLen(len);

        DPRINT1(2, "SBTableGetDSName returning: %S\n", (*ppName)->StringName );
    }
    // Our buffer is probably too big, so reallocate it down to fit.
    *ppName = THReAllocEx(pTHS, *ppName, (*ppName)->structLen);


    return 0;

} /* sbTableGetDSName */

/*++

Routine Description:

    Return true if the DNT passed in is an ancestor of the current object in the
    object table.  False otherwise.  Uses the DNRead cache.
    
Arguments:

    ulAncestor - DNT of object you care about.

Return Values:

    TRUE or FALSE, as appropriate.

--*/ 
BOOL
dbFIsAnAncestor (
        DBPOS FAR *pDB,
        ULONG ulAncestor
        )
{
    d_memname * pname;
    int i;
    ULONG curtag=pDB->DNT;
    
    Assert(VALID_DBPOS(pDB));

    // We assume that pDB->DNT is correct.
    

    if(curtag == ulAncestor) {
        // I have defined that an object is an ancestor of itself (nice for the
        // whole subtree search case, which is the main user of this routine)
        return TRUE;
    }

    
    if( curtag == ROOTTAG ) {
    // it's the root and the potential ancestor is not.  Therefore, the
        // potential ancestor is clearly not an real ancestor.
        return FALSE;
    }

    // Fetch a dnread element for each component of the name, up to the root
    do {
    pname = DNread(pDB, curtag, 0);
    Assert(curtag == pname->DNT);
    curtag = pname->tag.PDNT;
        if(curtag == ulAncestor)
            return TRUE;
    } while (curtag != ROOTTAG);

    // We didn't find the DNT they were asking for, so return FALSE
    return 0;
}


void
dbGetAncestorsSlowly(
    IN      DBPOS *  pDB,
    ULONG            DNT,
    IN OUT  DWORD *  pcbAncestorsSize,
    IN OUT  ULONG ** ppdntAncestors,
    OUT     DWORD *  pcNumAncestors
    );

void
DBGetAncestorsFromCache(
    IN      DBPOS *  pDB,
    IN OUT  DWORD *  pcbAncestorsSize,
    IN OUT  ULONG ** ppdntAncestors,
    OUT     DWORD *  pcNumAncestors
    )
{
    THSTATE    *pTHS=pDB->pTHS;
    d_memname * pname;
    
    pname = DNread(pDB, pDB->DNT, 0);

    if(*pcbAncestorsSize < pname->cAncestors * sizeof(DWORD)) {
        // buffer is too small (or not there).
        if(*ppdntAncestors) {
            *ppdntAncestors =
                THReAllocEx(pTHS, *ppdntAncestors,
                            pname->cAncestors * sizeof(DWORD)); 
        }
        else {
            *ppdntAncestors = THAllocEx(pTHS,
                                        pname->cAncestors * sizeof(DWORD));
        }

    }

    // Tell 'em how big it is.
    *pcbAncestorsSize = pname->cAncestors * sizeof(DWORD);


    memcpy((*ppdntAncestors),
           pname->pAncestors,
           pname->cAncestors * sizeof(DWORD));

    *pcNumAncestors = pname->cAncestors;
}


void
DBGetAncestors(
    IN      DBPOS *  pDB,
    IN OUT  DWORD *  pcbAncestorsSize,
    IN OUT  ULONG ** ppdntAncestors,
    OUT     DWORD *  pcNumAncestors
    )
/*++

Routine Description:

    Return the ancestor DNTs of the current object (pTHS->pDB), all the way
    up to the root, as an array of ULONGs.

    Assumes pDB->DNT is correct,

    The caller is responsible for eventually calling THFree( *ppdntAncestors ).

Arguments:

    pDB

    pcbAncestorsSize (IN/OUT) - Size in bytes of ancestors array.

    ppdntAncestors (IN/OUT) - Address of the thread-allocated ancestors array.

    pcNumAncestors (OUT) - Count of ancestors.

Return Values:

    None.  Throws exception on memory allocation failure - Database Failure.

--*/
{
    THSTATE    *pTHS=pDB->pTHS;
    BOOL        bReadAncestryFromDisk = FALSE;
    
    if(pTHS->fSDP) {
        DWORD err;
        DWORD actuallen=0;
        
        // The SDP doesn't want to put things in the dnread cache, it just wants
        // the ancestors

        // the SDP must provide a start buffer.  It's the price it pays for
        // special handling in this call.
        Assert(*pcbAncestorsSize);

        
        err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                        pDB->JetObjTbl,
                                        ancestorsid,
                                        *ppdntAncestors,
                                        *pcbAncestorsSize,
                                        &actuallen, 0, NULL);
        switch (err) {
        case 0:
            // OK, we got the ancestors.  Don't bother reallocing down.
            // This gives a guarantee to the SDProp that this buffer never
            // shrinks, so it can track it's real allocated size.
            // This is useful for when the sdprop thread repeatedly uses the
            // same buffer. 
            break;
            
        case JET_wrnBufferTruncated:
            // Failed to read, not enough memory.  Realloc it larger.
            *ppdntAncestors = THReAllocOrgEx(pTHS, *ppdntAncestors,
                                               actuallen); 
            
            if(err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                               pDB->JetObjTbl,
                                               ancestorsid,
                                               *ppdntAncestors,
                                               actuallen,
                                               &actuallen, 0, NULL)) {
                // Failed again.
                DsaExcept(DSA_DB_EXCEPTION, err, 0);
            }
            break;
            
        default:
            // Failed badly.
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
            break;
        }
        *pcNumAncestors = actuallen / sizeof(DWORD);
        *pcbAncestorsSize = actuallen;
    }
    else {

        // if there are enqueued SD events, then we are going to 
        // read the ancestry from disk
        if (*pcSDEvents) {
            // This operation does not reposition pDB on JetObjTbl. 
            // It only affects JetSDPropTbl.
            bReadAncestryFromDisk = DBPropagationsExist(pDB);
        }

        if (bReadAncestryFromDisk == FALSE) {
            DBGetAncestorsFromCache(pDB, 
                                    pcbAncestorsSize, 
                                    ppdntAncestors, 
                                    pcNumAncestors);
        }
        else {

            dbGetAncestorsSlowly (pDB, 
                                  pDB->DNT,
                                  pcbAncestorsSize,
                                  ppdntAncestors,
                                  pcNumAncestors);
        }
    }

    return;
}

void
dbGetAncestorsSlowly(
    IN      DBPOS *  pDB,
    ULONG            DNT,
    IN OUT  DWORD *  pcbAncestorsSize,
    IN OUT  ULONG ** ppdntAncestors,
    OUT     DWORD *  pcNumAncestors
    )
/*
Routine Description:

    Return the ancestor DNTs of the object with DNT, all the way
    up to the root, as an array of ULONGs.

    Assumes DNT is correct,

    The caller is responsible for eventually calling THFree( *ppdntAncestors ).
    
    Uses DNRead internally, and as a result uses SearchIndex.
    
    Note that DNT will NOT be included in the reuslting array. The client calling
    this func has to take care of adding the DNT if needed.

Arguments:

    pDB

    pcbAncestorsSize (IN/OUT) - Size in bytes of ancestors array.

    ppdntAncestors (IN/OUT) - Address of the thread-allocated ancestors array.

    pcNumAncestors (OUT) - Count of ancestors.

Return Values:

    None.  Throws exception on memory allocation failure - Database Failure.

*/

{
    THSTATE    *pTHS=pDB->pTHS;
    d_memname * pname;
    ULONG   curtag = DNT;
    DWORD   iAncestor1;
    DWORD   iAncestor2;

    if ( *pcbAncestorsSize < 16 * sizeof( DWORD ) ) {
        // Allocate a buffer to start off with, adequate for most calls.
        *pcbAncestorsSize = 16 * sizeof( DWORD );

        if(*ppdntAncestors) {
            *ppdntAncestors =
                THReAllocEx(pTHS, *ppdntAncestors, 16 * sizeof(DWORD)); 
        }
        else {
            *ppdntAncestors = THAllocEx(pTHS, 16 * sizeof(DWORD));
        }
    }

    if ( curtag == ROOTTAG )
    {
        // Root.
        *pcNumAncestors = 1;
        (*ppdntAncestors)[ 0 ] = ROOTTAG;
    }
    else
    {
        // Not root.

        // Fetch a dnread element for each component of the name (up to the
        // root) and add its parent's DNT to the array.

        for ( (*pcNumAncestors) = 0; curtag != ROOTTAG; (*pcNumAncestors)++ )
        {
            // Get the d_memname corresponding to this tag.
            pname = DNread(pDB, curtag, 0);
            Assert(curtag == pname->DNT);

            // Expand the ancestors array if necessary.
            if (*pcNumAncestors * sizeof( DWORD ) >= *pcbAncestorsSize) {

                *pcbAncestorsSize *= 2;
                *ppdntAncestors = THReAllocEx(pTHS,
                                        *ppdntAncestors,
                                        *pcbAncestorsSize
                                        );
            }

            // Add the parent of this tag to the ancestors array.
            (*ppdntAncestors)[ *pcNumAncestors ] = curtag;
            curtag = pname->tag.PDNT;
        }

        if ( curtag == ROOTTAG )
        {
            if (*pcNumAncestors * sizeof( DWORD ) >= *pcbAncestorsSize) {

                *pcbAncestorsSize += sizeof(DWORD);
                *ppdntAncestors = THReAllocEx(pTHS,
                                        *ppdntAncestors,
                                        *pcbAncestorsSize
                                        );
            }

            (*ppdntAncestors)[ *pcNumAncestors ] = curtag;
            (*pcNumAncestors)++;
        }


        // Reverse the ancestors array such that parents precede children.
        for ( iAncestor1 = 0; iAncestor1 < (*pcNumAncestors)/2; iAncestor1++ )
        {
            iAncestor2 = *pcNumAncestors - iAncestor1 - 1;

            curtag = (*ppdntAncestors)[ iAncestor1 ];
            (*ppdntAncestors)[ iAncestor1 ] = (*ppdntAncestors)[ iAncestor2 ];
            (*ppdntAncestors)[ iAncestor2 ] = curtag;
        }

    }
    // Tell 'em how big it is.
    *pcbAncestorsSize = *pcNumAncestors * sizeof( DWORD );
}



/* DBRenumberLinks - looks for all records in the link table with the
value of ulOldDnt in the column col, and changes that value to ulNewDnt.
This routine is used when copying the attributes of a new object to an
existing deleted one, and then aborting the insertion of the new one. This
is done when adding the OBJ_DISTNAME attribute in sbTableAddRefHelp if the
DN of the record to be inserted already exists */

DWORD APIENTRY
dbRenumberLinks(DBPOS FAR *pDB, ULONG ulOldDnt, ULONG ulNewDnt)
{
    THSTATE     *pTHS = pDB->pTHS;
    BYTE        *rgb = 0;
    ULONG       cbRgb = 0;
    ULONG       ulLinkDnt;
    ULONG       ulBacklinkDnt;
    ULONG       ulLinkBase;
    ULONG       nDesc;
    DSTIME              timeDeleted;
    USN                 usnChanged;
    ULONG               ulNcDnt;
    JET_ERR     err;
    ULONG       cb;
    JET_TABLEID     tblid;

    Assert(VALID_DBPOS(pDB));

    // set the index

    // Include all links, absent or present
    JetSetCurrentIndexSuccess(pDB->JetSessID,
                              pDB->JetLinkTbl, SZLINKALLINDEX);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 &ulOldDnt, sizeof(ulOldDnt), JET_bitNewKey);

    err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE);
    if ((err != JET_errSuccess) &&
        (err != JET_wrnRecordFoundGreater))
    {
        return 0;
    }

    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                             linkdntid, &ulLinkDnt, sizeof(ulLinkDnt), &cb, 0, NULL);

    if (ulLinkDnt != ulOldDnt)
    {
        return 0;
    }

    // clone the cursor for updates

    JetDupCursorEx(pDB->JetSessID, pDB->JetLinkTbl, &tblid, 0);

    do
    {
        JetPrepareUpdateEx(pDB->JetSessID, tblid, JET_prepInsert);
        JetPrepareUpdateEx(pDB->JetSessID, pDB->JetLinkTbl, DS_JET_PREPARE_FOR_REPLACE);

        // link dnt

        JetSetColumnEx(pDB->JetSessID, tblid,
                       linkdntid, &ulNewDnt, sizeof(ulNewDnt), 0,0);

        // backlink dnt

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                 backlinkdntid, &ulBacklinkDnt, sizeof(ulBacklinkDnt), &cb, 0, NULL);
        JetSetColumnEx(pDB->JetSessID, tblid,
                       backlinkdntid, &ulBacklinkDnt, sizeof(ulBacklinkDnt), 0,0);

        // linkbase

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                 linkbaseid, &ulLinkBase, sizeof(ulLinkBase), &cb, 0, NULL);
        JetSetColumnEx(pDB->JetSessID, tblid,
                       linkbaseid, &ulLinkBase, sizeof(ulLinkBase), 0,0);

        // link ndesc

        if ((err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                             linkndescid, &nDesc, sizeof(nDesc), &cb, 0, NULL)) == JET_errSuccess)
        {
            JetSetColumnEx(pDB->JetSessID, tblid,
                           linkndescid, &nDesc, sizeof(nDesc), 0,0);
        }


        // member address
        if ((err=JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                           linkdataid, rgb, cbRgb, &cb, 0, NULL)) == JET_wrnBufferTruncated)
        {
            cbRgb = cb;
            rgb = THAllocEx(pTHS,cb);
            err = JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                           linkdataid, rgb, cbRgb, &cb, 0, NULL);
        }

        if (err ==  JET_errSuccess)
        {
            JetSetColumnEx(pDB->JetSessID, tblid, linkdataid, rgb, cb, 0, 0);
        }

        // Link del time (only exists on absent rows)
        err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                        linkdeltimeid, &timeDeleted, sizeof(timeDeleted), &cb, 0, NULL);
        if (err == JET_errSuccess) {
            JetSetColumnEx(pDB->JetSessID, tblid,
                           linkdeltimeid, &timeDeleted, sizeof(timeDeleted), 0,0);
        }

        // Link usn changed (does not exist for legacy rows)
        err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                        linkusnchangedid, &usnChanged, sizeof(usnChanged), &cb, 0, NULL);
        if (err == JET_errSuccess) {
            JetSetColumnEx(pDB->JetSessID, tblid,
                           linkusnchangedid, &usnChanged, sizeof(usnChanged), 0,0);
        }

        // Link nc dnt (does not exist for legacy rows)
        err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                        linkncdntid, &ulNcDnt, sizeof(ulNcDnt), &cb, 0, NULL);
        if (err == JET_errSuccess) {
            JetSetColumnEx(pDB->JetSessID, tblid,
                           linkncdntid, &ulNcDnt, sizeof(ulNcDnt), 0,0);
        }

        // Link metadata (does not exist for legacy rows)
        // Handle any size item
        if (rgb) THFreeEx(pTHS,rgb);
        rgb = NULL;
        cbRgb = 0;
        if ((err=JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                           linkmetadataid, rgb, cbRgb, &cb, 0, NULL)) == JET_wrnBufferTruncated)
        {
            cbRgb = cb;
            rgb = THAllocEx( pDB->pTHS, cb);
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                     linkmetadataid, rgb, cbRgb, &cb, 0, NULL);
            JetSetColumnEx(pDB->JetSessID, tblid, linkmetadataid, rgb, cb, 0, 0);
            THFreeEx( pDB->pTHS, rgb );
            rgb = NULL;
            cbRgb = 0;
        } else {
            // Since we are not support zero-sized items, the only other valid
            // error is null column
            Assert( err == JET_wrnColumnNull );
        }

        // update the new record and delete the old

        JetUpdateEx(pDB->JetSessID, tblid, NULL, 0, 0);
        JetDeleteEx(pDB->JetSessID, pDB->JetLinkTbl);

        // move to next record

        if ((err = JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl,
                             JET_MoveNext, 0)) == JET_errSuccess)
        {

            // retrieve tag of found record and compare to old Dnt

            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                     linkdntid, &ulLinkDnt, sizeof(ulLinkDnt), &cb, 0, NULL);
        }
    } while (!err && (ulLinkDnt == ulOldDnt));

    JetCloseTableEx(pDB->JetSessID, tblid);

    // done

    return 0;
}

void
sbTableUpdateRecordIdentity(
    IN OUT  DBPOS * pDB,
    IN      DWORD   DNT,
    IN      WCHAR * pwchRDN,    OPTIONAL
    IN      DWORD   cchRDN,
    IN      GUID *  pGuid,      OPTIONAL
    IN      SID *   pSid,       OPTIONAL
    IN      DWORD   cbSid
    )
/*++

Routine Description:

    Updates the GUID, SID, and/or RDN of the record with the given tag.  Handles
    flushing the cache, etc.

Arguments:

    pDB (IN/OUT)
    
    pwchRDN (IN, OPTIONAL) - New RDN for the record, if 0 != cchRDN.

    cchRDN (IN) - Size in characters of the new RDN, or 0 if no change.
    
    pGuid (IN, OPTIONAL) - New GUID for the record, or NULL if no change.
    
    pSid (IN, OPTIONAL) - New SID for the record, if 0 != cbSid.
    
    cbSid (IN) - Size in bytes if the new SID, or 0 if no change.

Return Values:

    None.  Throws database exception on JET errors.

--*/
{
    int err;

    Assert((0 != cchRDN) || (NULL != pGuid) || (0 != cbSid));

    JetSetCurrentIndexSuccess(pDB->JetSessID,
                              pDB->JetSearchTbl,
                              NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, &DNT,
                 sizeof(ULONG), JET_bitNewKey);

    err = JetSeek(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
    if (err) {
        DsaExcept(DSA_DB_EXCEPTION, err, DNT);
    }

    pDB->SDNT = DNT;

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                       DS_JET_PREPARE_FOR_REPLACE);

    if (0 != cchRDN) {
        // Replace the RDN.
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, rdnid,
                       pwchRDN, cchRDN * sizeof(WCHAR), 0, NULL);
    }

    if (NULL != pGuid) {
        // Add the guid.  We should never replace the guid of a pre-existing
        // record.
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, guidid, pGuid,
                       sizeof(GUID), 0, NULL);
    }

    if (0 != cbSid) {
        // Add the SID (in internal format).
        NT4SID sidInternalFormat;

        memcpy(&sidInternalFormat, pSid, cbSid);
        InPlaceSwapSid(&sidInternalFormat);

        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, sidid,
                       &sidInternalFormat, cbSid, 0, NULL);
    }

    JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);

    // Reset entry in DN read cache.
    dbFlushDNReadCache(pDB, DNT);
}

DWORD
APIENTRY
sbTableGetTagFromDSName(
    IN OUT DBPOS *      pDB,
    IN     DSNAME *     pName,
    IN     ULONG        ulFlags,
    OUT    ULONG *      pTag,       OPTIONAL
    OUT    d_memname ** ppname      OPTIONAL
    )
/*++

Routine Description:

    Returns the DN tag associated with a given DSNAME.

Arguments:

    pDB (IN/OUT)
    pName (IN) - DSNAME of the object to map to a tag.
    ulFlags (IN) - 0 or more of the following bits:
        SBTGETTAG_fAnyRDNType - Don't check for the type of the RDN.  Therefore,
                 "cn=foo,dc=bar,dc=com" matches against "ou=foo,dc=bar,dc=com",
                 but not "cn=foo,cn=bar,dc=com".
        SBTGETTAG_fMakeCurrent - make the target record current.
        SBTGETTAG_fUseObjTbl - use pDB->JetObjTbl rather than pDB->JetSearchTbl.
    pTag (OUT, OPTIONAL) - on return, holds the tag associated with pName if the
        return value is 0; otherwise, holds the closest match.
    ppname (OUT, OPTIONAL) - on successful return, holds a pointer to the read
        cache entry for the record found UNLESS THE DSNAME REQUESTED WAS THE
        ROOT, IN WHICH CASE IT WILL BE SET TO NULL

Return Values:

    0 - successfully found a corresponding object.
    ERROR_DS_NOT_AN_OBJECT - successfully found a corresponding phantom.
    ERROR_DS_DUPLICATE_ID_FOUND - found an object with a duplicate sid
    ERROR_DS_OBJ_NOT_FOUND - didn't find the object
    other DB_ERR_* - failure.

    Throws database exception on unexpected JET errors.

--*/             
{
    DWORD           ret = 0;
    unsigned        curlen;
    ULONG           curtag = ROOTTAG;
    ATTRTYP         type;
    DWORD           err;
    WCHAR           *pKey, *pQVal;
    unsigned        ccKey, ccQVal, ccVal;
    WCHAR           rdnbuf[MAX_RDN_SIZE];
    BOOL            fSearchByGuid, fSearchByStringName, fSearchBySid;
    BOOL            fIsRoot;
    BOOL            fFoundRecord = FALSE;
    BOOL            fIsRecordCurrent = FALSE;
    d_memname       *pTempName = NULL;
    DWORD           SidDNT = 0;     //initialized to avoid C4701
    JET_TABLEID     tblid;

    Assert(VALID_DBPOS(pDB));

    DPRINT2(2, "sbTableGetTagFromDSName(): Looking for \"%ls\" (DSNAME @ %p).\n",
            pName->StringName, pName);

    if (ulFlags & SBTGETTAG_fUseObjTbl) {
        tblid = pDB->JetObjTbl;
    }
    else {
        tblid = pDB->JetSearchTbl;
    }
    if (ppname) {
        *ppname = NULL;
    }

    // Always search by GUID if one is present.
    fSearchByGuid = !fNullUuid(&pName->Guid);
    Assert(fSearchByGuid || !(ulFlags & SBTGETTAG_fSearchByGuidOnly));

    // if there is no sid, no guid and StringName is empty, then we are searching for root
    fIsRoot = !fSearchByGuid && (pName->SidLen == 0) && 
              (pName->NameLen == 0 || (pName->NameLen == 1 && pName->StringName[0] == '\0'));
    
    // Search by string name if one is present, or if we are searching for root.
    fSearchByStringName = !(ulFlags & SBTGETTAG_fSearchByGuidOnly)
                          && ((0 != pName->NameLen) || fIsRoot);

    // Search by SID only if it's valid and no other identifier is present in
    // the name.
    fSearchBySid = !fSearchByGuid && (0==pName->NameLen)
        && (pName->SidLen>0) && (RtlValidSid(&(pName->Sid)));

    if (fSearchByGuid) {
        ret = sbTableGetTagFromGuid(pDB,
                                    tblid,
                                    &pName->Guid,
                                    &curtag,
                                    &pTempName,
                                    &fIsRecordCurrent);
        fFoundRecord = (0 == ret);
    }
    else if (fSearchBySid) {
        NT4SID SidPrefix;
        // Or, attempt to find the record in the read cache.
        
        // Note that we leave the string name-based cache lookups to
        // DNChildFind(), as it requires multiple lookups to identify a record
        // as the "right" one (one for each component of the name), and one or
        // more of those components might not be in the cache.

        // We only look up things by SID if they are in a domain we host.  For
        // now, we only host one domain.  Copy the Sid, since we munge it while
        // checking see if it is in our domain

        SidDNT = INVALIDDNT;
        
        if (!gAnchor.pDomainDN || !gAnchor.pDomainDN->SidLen) {
            // No domain DN.  Assume that they are looking up in the domain.
            SidDNT = gAnchor.ulDNTDomain;
        }
        else {
            // verify the domain.
            SidPrefix = pName->Sid;
            (*RtlSubAuthorityCountSid(&SidPrefix))--;

            Assert(gAnchor.pDomainDN);
            Assert(pgdbBuiltinDomain);
            
            if(RtlEqualSid(&pName->Sid, &gAnchor.pDomainDN->Sid)) {
                // Case 1, they passed in the Sid of the Domain.
                // Shortcut and just look up the object which is the root of the
                // domain.
                if(pDB != pDBhidden) {
                    fFoundRecord = dnGetCacheByDNT(pDB,
                                                   gAnchor.ulDNTDomain,
                                                   &pTempName);
                }
                else {
                    fFoundRecord = FALSE;
                }
            }
            else if(RtlEqualSid(&SidPrefix, &gAnchor.pDomainDN->Sid) ||
                    // Case 2, an account in the domain.
                    RtlEqualSid(&SidPrefix, pgdbBuiltinDomain)       ||
                    // Case 4, an account in the builtin domain.
                    RtlEqualSid(&pName->Sid, pgdbBuiltinDomain)
                    // Case 3, the sid of the builtin domain
                                                                        ) {
                
                SidDNT = gAnchor.ulDNTDomain;
            }
            else {
                SidDNT = INVALIDDNT;
            }
            
        }   

        if (fFoundRecord) {
            curtag = pTempName->DNT;
        }
        
    }

    if (!fFoundRecord && fSearchBySid && (SidDNT != INVALIDDNT)) {
        // Search for the record by SID.
        NT4SID InternalFormatSid;
        ULONG  ulNcDNT;

        Assert(!pTempName);
        
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                   tblid,
                                   SZSIDINDEX,
                                   &idxSid,
                                   JET_bitMoveFirst);

        // Convert the SID to internal format.
        Assert(pName->SidLen == RtlLengthSid(&pName->Sid));
        memcpy(&InternalFormatSid, &pName->Sid, pName->SidLen);
        InPlaceSwapSid(&InternalFormatSid);

        JetMakeKeyEx(pDB->JetSessID, tblid, &InternalFormatSid, pName->SidLen,
                     JET_bitNewKey);

        // Seek on Equal to the SId, Set the Index range
        err = JetSeek(pDB->JetSessID, tblid,
                      JET_bitSeekEQ|JET_bitSetIndexRange);
        if ( 0 == err ) {
            DWORD cbActual;
#ifndef JET_BIT_SET_INDEX_RANGE_SUPPORT_FIXED
            JetMakeKeyEx(pDB->JetSessID, tblid, &InternalFormatSid,
                         pName->SidLen, JET_bitNewKey); 
            
            JetSetIndexRangeEx(pDB->JetSessID, tblid,
                               (JET_bitRangeUpperLimit|JET_bitRangeInclusive ));
#endif            
            //
            // Ok We found the object. Keep Moving Forward Until either the SID
            // does not Match or we reached the given object
            //
            
            do {
                
                err = JetRetrieveColumn(pDB->JetSessID, tblid, ncdntid,
                                        &ulNcDNT, sizeof(ulNcDNT), &cbActual, 0
                                        , NULL); 
                
                if (0==err) {
                    // We read the NC DNT of the object
                    if (ulNcDNT==SidDNT)
                        break;
                }
                else if (JET_wrnColumnNull==err) {
                    // It is Ok to find an object with No Value for NC DNT
                    // this occurs on Phantoms. Try next object
                    
                    err = 0;
                }
                else {
                    break;
                }
                
                err = JetMove(pDB->JetSessID, tblid, JET_MoveNext,  0);
                
                
            }  while (0==err);
            
                
            // We have a match.  
            if (0==err) {
                // The TRUE param to DNcache says that the current object may
                // already be in the cache, we haven't checked.
                pTempName = DNcache(pDB, tblid, TRUE);
                Assert(pTempName);
                fFoundRecord = TRUE;
                fIsRecordCurrent = FALSE;
                curtag = pTempName->DNT;

                // Now, verify that there is only one match.                
                err = JetMove(pDB->JetSessID, tblid, JET_MoveNext, 0);
                
                if (0==err) {
                    err = JetRetrieveColumn(pDB->JetSessID, tblid, ncdntid, 
                                            &ulNcDNT, sizeof(ulNcDNT),
                                            &cbActual, 0 , NULL); 
                    
                    if ((0==err) && (ulNcDNT==SidDNT)) {
                        // This is a case of a duplicate Sid.
                        ret = ERROR_DS_DUPLICATE_ID_FOUND;
                        pTempName = NULL;
                    }
                }
            }
        }
    }

    if (!fFoundRecord && fSearchByStringName) {
        // Search for the record by string name.
        if (fIsRoot) {
            Assert(ROOTTAG == curtag);
            Assert(!fIsRecordCurrent);
            Assert(NULL == pTempName);
            fFoundRecord = TRUE;
        }
        else {
            ret = sbTableGetTagFromStringName(pDB,
                                              tblid,
                                              pName,
                                              FALSE,
                                              (ulFlags & SBTGETTAG_fAnyRDNType),
                                              0,
                                              &curtag,
                                              &pTempName,
                                              &fIsRecordCurrent);
            fFoundRecord = (0 == ret);
        
            if (fFoundRecord) {
                DPRINT6(2,
                        "sbTableGetTagFromDSName() found DNT 0x%x by string "
                            "name: RDN '%*.*ls', RDN type 0x%x, PDNT 0x%x.\n",
                        pTempName->DNT,
                        pTempName->tag.cbRdn/2,
                        pTempName->tag.cbRdn/2,
                        pTempName->tag.pRdn,
                        pTempName->tag.rdnType,
                        pTempName->tag.PDNT);
            }
        }
    }

    if (!fFoundRecord && !ret) {
        // No matching record found.
        ret = ERROR_DS_OBJ_NOT_FOUND;
    }

    if (!ret) {
        // Found the requested record.
        Assert((NULL != pTempName) || (ROOTTAG == curtag));

        if (NULL != ppname) {
            // Return pointer to populated cache structure (unless we found
            // the root).
            *ppname = pTempName;
        }

        if (!fIsRecordCurrent && (ulFlags & SBTGETTAG_fMakeCurrent)) {
            // Record was found through the cache, but caller wants currency;
            // give it to him.
            JetSetCurrentIndexSuccess(pDB->JetSessID,
                                      tblid,
                                      NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)

            JetMakeKeyEx(pDB->JetSessID, tblid, &curtag, sizeof(curtag),
                         JET_bitNewKey);

            if (err = JetSeekEx(pDB->JetSessID, tblid, JET_bitSeekEQ)) {
                DsaExcept(DSA_DB_EXCEPTION, err, curtag);
            }

            fIsRecordCurrent = TRUE;
        }

        if (fIsRecordCurrent) {
            // Currency has been successfully changed; update pDB state.
            if (ulFlags & SBTGETTAG_fUseObjTbl) {
                dbMakeCurrent(pDB, pTempName);
            }
            else {
                pDB->SDNT = curtag;
            }
        }

        if ((ROOTTAG != curtag) && !pTempName->objflag) {
            // Found a phantom; return distinct error code.
            // NOTE THAT THE ROOT *IS* AN OBJECT.
            ret = ERROR_DS_NOT_AN_OBJECT;
        }
    }
    else {
        // Whatever currency was previously held in tblid is lost; update the
        // currency state in pDB.
        if (ulFlags & SBTGETTAG_fUseObjTbl) {
            pDB->DNT = pDB->PDNT = pDB->NCDNT = 0;
            pDB->JetNewRec = pDB->root = pDB->fFlushCacheOnUpdate = FALSE;
        }
        else {
            pDB->SDNT = 0;
        }

        DPRINT(3, "sbTableGetTagFromDSName() failed.\n");
    }

    // Always set the return tag to our best match (i.e. tag of longest subname
    // of the DSNAME given if we were allowed to search by string name, the
    // root tag otherwise).
    if (pTag) {
        *pTag = curtag;
    }

    return ret;
} /* sbTableGetTagFromDSName */

DWORD
sbTableGetTagFromGuid(
    IN OUT  DBPOS *       pDB,
    IN      JET_TABLEID   tblid,
    IN      GUID *        pGuid,
    OUT     ULONG *       pTag,             OPTIONAL
    OUT     d_memname **  ppname,           OPTIONAL
    OUT     BOOL *        pfIsRecordCurrent OPTIONAL
    )
/*++

Routine Description:

    Returns the DN tag associated with a given DSNAME's guid.

Arguments:

    pDB (IN/OUT) - Currency can be changed.
    
    tblid (IN) - Which table to use -- pDB->JetSearchTbl or pDB->JetObjTbl.
    
    pGuid (IN) - Guid of the object to map to a tag.
    
    pTag (OUT, OPTIONAL) - On successful return, holds the tag associated with
        this guid.
    
    ppname (OUT, OPTIONAL) - On successful return, holds a pointer to the
        d_memname struct (from the cache) associated with this guid.
        
    pfRecordIsCurrent (OUT, OPTIONAL) - On successful return, indicates whether
        the cursor tblid is positioned on the target record.

Return Values:

    0 - successfully found a record -- may be phantom or object.
    ERROR_DS_* - failure

    Throws database exception on unexpected JET errors.

--*/
{
    DWORD       ret = ERROR_DS_OBJ_NOT_FOUND;
    int         err = 0;
    BOOL        fIsRecordCurrent = FALSE;
    d_memname * pname = NULL;
    BOOL        fFoundRecord = FALSE;
    CHAR        szGuid[SZUUID_LEN];

    // First attempt to find the record in the read cache by guid
    // Don't use the cache for the hidden record.  The cache is associated with
    // the THSTATE its transaction state. The pDBhidden is not necessarily
    // associated with this threads thstate.
    if (pDB != pDBhidden) {
        fFoundRecord = dnGetCacheByGuid(pDB, pGuid, &pname);
    
        if (fFoundRecord) {
            DPRINT6(2,
                    "sbTableGetTagFromGuid() found DNT 0x%x in cache: "
                        "RDN '%*.*ls', RDN type 0x%x, PDNT 0x%x.\n",
                    pname->DNT, pname->tag.cbRdn/2, pname->tag.cbRdn/2,
                    pname->tag.pRdn, pname->tag.rdnType, pname->tag.PDNT);
        }
    }
    
    if (!fFoundRecord) {
        // Search for the record by GUID.
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                   tblid,
                                   SZGUIDINDEX,
                                   &idxGuid,
                                   JET_bitMoveFirst);

        JetMakeKeyEx(pDB->JetSessID, tblid, pGuid, sizeof(GUID), JET_bitNewKey);

        err = JetSeekEx(pDB->JetSessID, tblid, JET_bitSeekEQ);
        if (!err) {
            fFoundRecord = TRUE;
            fIsRecordCurrent = TRUE;
            pname = DNcache(pDB, tblid, FALSE);
        
            DPRINT6(2,
                    "sbTableGetTagFromGuid() seeked to DNT 0x%x: "
                        "RDN '%*.*ls', RDN type 0x%x, PDNT 0x%x.\n",
                    pname->DNT, pname->tag.cbRdn/2, pname->tag.cbRdn/2,
                    pname->tag.pRdn, pname->tag.rdnType, pname->tag.PDNT);
        }
    }

    if (fFoundRecord) {
        if (NULL != ppname) {
            *ppname = pname;
        }
    
        if (NULL != pTag) {
            *pTag = pname->DNT;
        }
    
        if (NULL != pfIsRecordCurrent) {
            *pfIsRecordCurrent = fIsRecordCurrent;
        }

        ret = 0;
    }
    else {
        Assert(ERROR_DS_OBJ_NOT_FOUND == ret);
    
        DPRINT1(2,
                "sbTableGetTagFromGuid() failed to find record with "
                    "guid %s.\n",
                UuidToStr(pGuid, szGuid, sizeof(szGuid)/sizeof(szGuid[0])));
    }

    return ret;
}

DWORD
sbTableGetTagFromStringName(
    IN OUT  DBPOS *       pDB,
    IN      JET_TABLEID   tblid,
    IN      DSNAME *      pDN,
    IN      BOOL          fAddRef,
    IN      BOOL          fAnyRDNType,
    IN      DWORD         dwExtIntFlags,
    OUT     ULONG *       pTag,             OPTIONAL
    OUT     d_memname **  ppname,           OPTIONAL
    OUT     BOOL *        pfIsRecordCurrent OPTIONAL
    )
/*++

Routine Description:

    Returns the DN tag associated with a given DSNAME's string name, and
    optionally adds a ref count for it (in which case it creates records as
    needed).

Arguments:

    pDB (IN/OUT) - Currency can be changed.
    
    tblid (IN) - Which table to use -- pDB->JetSearchTbl or pDB->JetObjTbl.
    
    pDN (IN) - DSNAME of the object to map to a tag.
    
    fAddRef (IN) - If TRUE, add a ref count to the record associated with this
        DN.  Creates records as necessary.  May not be combined with ppname.
        Also, may not be combined with fAnyRDNType.

    fAnyRDNType (IN) - If TRUE, ignore the type of the final RDN in the name
        (e.g. treat "cn=foo,dc=bar,dc=com" and "ou=foo,dc=bar,dc=com" as equal).
        May not be combined with fAddRef.
        
    dwExtIntFlags (IN) - 0 or EXTINT_NEW_OBJ_NAME.  The latter is valid only
        in combination with fAddRef, and indicates the DN we're add-refing is
        a new record in a prepard update in pDB->JetObjTbl.
    
    pTag (OUT, OPTIONAL) - On return, holds the tag associated with pDN if the
        return value is 0; otherwise, holds the closest match.
    
    ppname (OUT, OPTIONAL) - On return, holds a pointer to the d_memname struct
        (from the cache) associated with this DN if the return value is 0;
        otherwise, holds the closest match.  May not be combined with fAddRef.
        
    pfRecordIsCurrent (OUT, OPTIONAL) - On successful return, indicatess whether
        the cursor tblid is positioned on the target record.

Return Values:

    0 - successfully found a record -- may be phantom or object.
    DB_ERR_* - failure.

    Throws database exception on unexpected JET errors.

--*/
{
    THSTATE *   pTHS = pDB->pTHS;
    DWORD       ret = 0;
    unsigned    curlen;
    ULONG       curtag = ROOTTAG;
    BOOL        fIsRecordCurrent = FALSE;
    d_memname * pname = NULL;
    d_memname   search = {0};
    DWORD       cNameParts;
    DWORD       cAncestorsAllocated = 0;
    DWORD       cTempAncestorsAllocated = 0;
    DWORD       cTempAncestors = 0;
    DWORD *     pTempAncestors = NULL;
    DWORD       iNamePart;
    WCHAR       rdnbuf[MAX_RDN_SIZE];
    BOOL        fOnPDNTIndex = FALSE;
    WCHAR *     pKey;
    BOOL        fPromotePhantom = fAddRef
                                  && (dwExtIntFlags & EXTINT_NEW_OBJ_NAME);
    BOOL        fUseExtractedGuids = fAddRef;

    // Note that we extract and use the GUIDs of mangled RDNs only in the case
    // where we're doing an add-ref.  This is specifically required to avoid
    // creating multiple records for the same object -- some mangled, some not,
    // some with guids, some without.  Lack of this support in the add-ref case
    // led to bug 188247.  Note that this support *CANNOT* be restricted to only
    // fDRA -- see JeffParh.  This add-ref behavior should not be visible to
    // LDAP clients due to the way that we verify names fed to us via LDAP
    // up-front.
    //
    // We do *NOT* enable this in the normal read case so as not to perplex LDAP
    // clients.

    // We don't accurately track pname in the fAddRef case.
    Assert((NULL == ppname) || !fAddRef);

    // You can't be both adding a reference AND not caring about RDN type.
    Assert(!fAddRef || !fAnyRDNType);
    
    Assert((tblid == pDB->JetSearchTbl) || (tblid == pDB->JetObjTbl));
    Assert(fAddRef || (0 == dwExtIntFlags));

    if (NULL != ppname) {
        *ppname = NULL;
    }

    if (NULL != pfIsRecordCurrent) {
        *pfIsRecordCurrent = FALSE;
    }

    if (NULL != pTag) {
        *pTag = ROOTTAG;
    }

    ret = CountNameParts(pDN, &cNameParts);
    if (ret || (0 == cNameParts)) {
        // Failure, or we were asked to find the root.  We're done.
        return ret;
    }

    if (fAddRef) {
        // Pre-allocate the probable ancestors list size, based on the number of
        // name components.  Note that since we can find some records by guid,
        // the final ancestors count may be different.
        cAncestorsAllocated = 1 + cNameParts; // don't forget one for ROOTTAG!
        search.pAncestors = THAllocEx(pTHS,
                                      cAncestorsAllocated * sizeof(DWORD));
        search.pAncestors[0] = ROOTTAG;
        search.cAncestors = 1;

        cTempAncestorsAllocated = cAncestorsAllocated;
        pTempAncestors = THAllocEx(pTHS,
                                   cTempAncestorsAllocated * sizeof(DWORD));
        cTempAncestors = 0;
    }

    search.tag.pRdn = rdnbuf;

    // For each RDN in the name, starting with the most significant
    // (e.g., DC=COM)...
    for (iNamePart = 0, curlen = pDN->NameLen;
         iNamePart < cNameParts;
         iNamePart++,   curlen = (UINT)(pKey - pDN->StringName)) {
        
        BOOL    fIsLastNameComponent = (iNamePart == cNameParts-1);
        DWORD   cbSid = 0;
        SID *   pSid = NULL;
        GUID *  pGuid = NULL;
        BOOL    fNameConflict = FALSE;
        ATTRTYP type;
        WCHAR * pQVal;
        DWORD   ccKey, ccQVal, ccVal;

        // Parse out the RDN that's iNameParts from the top (most significant).
        ret = GetTopNameComponent(pDN->StringName, curlen, &pKey,
                                  &ccKey, &pQVal, &ccQVal);
        if (ret) {
            break;
        }

        Assert(pKey);
        Assert(ccKey != 0);
        Assert(pQVal != 0);
        Assert(ccQVal != 0);

        type = KeyToAttrType(pDB->pTHS, pKey, ccKey);
        if (0 == type) {
            ret = DIRERR_NAME_TYPE_UNKNOWN;
            break;
        }

        ccVal = UnquoteRDNValue(pQVal, ccQVal, rdnbuf);
        if (0 == ccVal) {
            ret = DIRERR_NAME_UNPARSEABLE;
            break;
        }

        Assert(search.tag.pRdn == rdnbuf);
        search.tag.PDNT    = curtag;
        search.tag.rdnType = type;
        search.tag.cbRdn   = ccVal * sizeof(WCHAR);

        if (fIsLastNameComponent && !fNullUuid(&pDN->Guid)) {
            // This is the last component of the DSNAME and the DSNAME has a
            // guid -- the guid for this record is that of the DSNAME.
            // Note that we assume we can't find this record by guid -- the
            // caller should have tried finding the target by guid before
            // calling us.  (We assert to this effect below.)
            search.Guid   = pDN->Guid;
            search.Sid    = pDN->Sid;
            search.SidLen = pDN->SidLen;
            
            pGuid = &search.Guid;
        }
        else if (fUseExtractedGuids
                 && IsMangledRDN(search.tag.pRdn,
                                 search.tag.cbRdn / sizeof(WCHAR),
                                 &search.Guid,
                                 NULL)) {
            // We successfully decoded the GUID from a previously mangled
            // RDN.  This RDN was mangled on some server due to deletion or
            // a name conflict; at any rate, we now have the guid, so we
            // should first try to see if we can find the record by guid.
            
            // sbTableGetTagFromGuid() will switch over to the GUID index.
            fOnPDNTIndex = FALSE;

            ret = sbTableGetTagFromGuid(pDB, tblid, &search.Guid, NULL, &pname,
                                        &fIsRecordCurrent);
            if (0 == ret) {
                // Found record by guid.
                
                Assert(!(fIsLastNameComponent
                         && fAddRef
                         && (dwExtIntFlags & EXTINT_NEW_OBJ_NAME)
                         && pname->objflag
                         && "Object conflict should have been detected in "
                                "CheckNameForAdd()!"));
                
                // Copy the ancestors list.
                if (pname->cAncestors) {
                    if (pname->cAncestors >= cAncestorsAllocated) {
                        cAncestorsAllocated = pname->cAncestors + 1;
                        search.pAncestors =
                            THReAllocEx(pTHS, search.pAncestors,
                                        cAncestorsAllocated * sizeof(DWORD));
                    }
                    
                    memcpy(search.pAncestors, pname->pAncestors,
                           pname->cAncestors * sizeof(DWORD));
                }
    
                search.cAncestors = pname->cAncestors;
                
                curtag = pname->DNT;
    
                Assert(0 == ret);

                // Move on to next name component.
                continue;
            }
            else {
                // Okay, we didn't find this record by GUID.  If we're add-
                // refing and find it by string name or we have to create it,
                // we should add the GUID to the record.
                pGuid = &search.Guid;
            }
        }
        else {
            // No GUID available for this record.
            memset(&search.Guid, 0, sizeof(GUID));
            pGuid = NULL;
        }

        Assert(fIsLastNameComponent || (0 == search.SidLen));
        
        // pGuid is NULL iff search.Guid is a null guid.
        Assert(((&search.Guid == pGuid) && !fNullUuid(&search.Guid))
               || ((NULL == pGuid) && fNullUuid(&search.Guid)));


        ret = DNChildFind(pDB,
                          tblid,
                          // enforce type if this is not the last component or
                          // we are not allowing any rdn type
                          (!fIsLastNameComponent || !fAnyRDNType),
                          curtag,
                          search.tag.pRdn,
                          search.tag.cbRdn,
                          search.tag.rdnType,
                          &pname,
                          &fIsRecordCurrent,
                          &fOnPDNTIndex);
        if(ret == ERROR_DS_KEY_NOT_UNIQUE) {
            // massage error code to be the one downstream callers expect.
            ret = DIRERR_OBJ_NOT_FOUND;
        }
        
        Assert((0 == ret) || (DIRERR_OBJ_NOT_FOUND == ret));

        if (0 == ret) {
            // Found this name component by string name -- it may or may not
            // actually be the record we're looking for.  All we know for
            // sure is that it has the right string DN.
            Assert((type == pname->tag.rdnType) ||
                   (fIsLastNameComponent && fAnyRDNType));
            Assert(curtag == pname->tag.PDNT);
            
            curtag = pname->DNT;

            if (fAddRef) {
                // Save ancestors list.  Operations below like
                // sbTableUpdateRecordIdentity() can nuke the ancestors list.
                if (pname->cAncestors >= cTempAncestorsAllocated) {
                    cTempAncestorsAllocated = pname->cAncestors;
                    pTempAncestors =
                        THReAllocEx(pTHS, pTempAncestors,
                                    cTempAncestorsAllocated * sizeof(DWORD));
                }
                memcpy(pTempAncestors, pname->pAncestors,
                       pname->cAncestors * sizeof(DWORD));
                cTempAncestors = pname->cAncestors;
            }

            if (NULL != pGuid) {
                if (!fAddRef) {
                    // String name matches.  However, we also know what the
                    // guid of the record is supposed to be.  If the record
                    // we found has a guid and it's not the same, the record
                    // is not a match.

                    if (!fNullUuid(&pname->Guid)) {
                        if (0 != memcmp(pGuid, &pname->Guid, sizeof(GUID))) {
                            // Same DN, different guid -- record not found!
                            ret = DIRERR_OBJ_NOT_FOUND;
                            break;
                        }
                        else if (fIsLastNameComponent) {
                            Assert(!"Found target record by string name when "
                                    "we should have searched for (and found) "
                                    "it by guid before we entered this "
                                    "function.");
                            Assert(0 == ret);
                        }
                        else {
                            Assert(!"Found and decoded mangled guid in an RDN "
                                    "other than the last (leaf-most) one in "
                                    "the DN; failed to find record by guid, "
                                    "but found it by string name and then "
                                    "found the guid *is* present -- "
                                    "sbTableGetTagFromGuid() failure?");
                            Assert(0 == ret);
                        }
                    }
                }
                else if (fNullUuid(&pname->Guid)) {
                    // Add-ref case.
                    // The record we found is a structural phantom, lacking a
                    // GUID and SID (if any).
                    
                    // This record has no GUID, so it had better be a
                    // phantom and not an object!
                    Assert(!pname->objflag);

                    if (!(dwExtIntFlags & EXTINT_NEW_OBJ_NAME)) {
                        // We're not adding a new object -- okay to go ahead
                        // and add the GUID (& SID, if any) to the phantom.
                        sbTableUpdateRecordIdentity(pDB, curtag, NULL, 0,
                                                    pGuid, (SID *) &search.Sid,
                                                    search.SidLen);
                    }
                
                    Assert(0 == ret);
                }
                else if (0 != memcmp(&pname->Guid, pGuid, sizeof(GUID))) {
                    // Add-ref case.
                    // The record we found has the right string name but the
                    // wrong GUID.  If it is a phantom, mangle its name and
                    // allow this latest reference to have the name it wants.
                    // If it's an object, mangle the name in the reference
                    // instead.
                    DWORD cchNewRDN;
                    
                    Assert(!fNameConflict);
                    fNameConflict = TRUE;
                    
                    if (!pname->objflag) {
                        // The record we found is a phantom; allow the new
                        // reference to take the name, and rename the record we
                        // found to avoid conflicts.
                        WCHAR szNewRDN[MAX_RDN_SIZE];
                    
                        memcpy(szNewRDN, pname->tag.pRdn, pname->tag.cbRdn);
                        cchNewRDN = pname->tag.cbRdn / sizeof(WCHAR);
                    
                        MangleRDN(MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT,
                                  &pname->Guid, szNewRDN, &cchNewRDN);
                        
                        sbTableUpdateRecordIdentity(pDB, curtag, szNewRDN,
                                                    cchNewRDN, NULL, NULL, 0);
                    }
                    else {
                        // The record we found is a pre-existing object, so it
                        // has dibs on the name.  Go ahead and create a new
                        // record for what we're looking for, but give our new
                        // record a mangled name to resolve the conflict.
                        cchNewRDN = search.tag.cbRdn / sizeof(WCHAR);

                        MangleRDN(MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT,
                                  &search.Guid, search.tag.pRdn, &cchNewRDN);

                        search.tag.cbRdn = cchNewRDN * sizeof(WCHAR);
                    }

                    // Treat this as the "not found" case -- add a new record.
                    ret = DIRERR_OBJ_NOT_FOUND;
                }
                else if (fIsLastNameComponent) {
                    // Add-ref case.
                    Assert(!"Found target record by string name when we should "
                            "have searched for (and found) it by guid before "
                            "we entered this function.");
                    Assert(0 == ret);
                }
                else {
                    // Add-ref case.
                    Assert(!"Found and decoded mangled guid in an RDN other "
                            "than the last (leaf-most) one in the DN; failed "
                            "to find record by guid, but found it by string "
                            "name and then found the guid *is* present -- "
                            "sbTableGetTagFromGuid() failure?");
                    Assert(0 == ret);
                }
            }
            else {
                Assert(!(fIsLastNameComponent
                         && fAddRef
                         && (dwExtIntFlags & EXTINT_NEW_OBJ_NAME)
                         && pname->objflag
                         && "Object conflict should have been detected in "
                                "CheckNameForAdd()!"));
            }
            
            if ((0 == ret) && fAddRef) {
                // This record does indeed match the component we were looking
                // for -- save its ancestors.
                SwapDWORD(&cTempAncestorsAllocated, &cAncestorsAllocated);
                SwapDWORD(&cTempAncestors, &search.cAncestors);
                SwapPTR(&pTempAncestors, &search.pAncestors);
            }
        }
        
        if (0 != ret) {
            // This name component was not found.
            Assert(DIRERR_OBJ_NOT_FOUND == ret);

            if (fAddRef) {
                // Add a new record for this name component.
                if (search.cAncestors >= cAncestorsAllocated) {
                    // Hmm.  I don't have enough room to add my own DNT to the
                    // end of the ancestors I got from my parent.  Add one to
                    // the size of the allocated ancestors buffer so I can add
                    // my own DNT.  Should occur only if we've grown the depth
                    // of the DN due to using extracted GUIDs.
                    Assert(fUseExtractedGuids);
                    cAncestorsAllocated = search.cAncestors + 1;
                    search.pAncestors =
                        THReAllocEx(pTHS, search.pAncestors,
                                    cAncestorsAllocated * sizeof(DWORD));
                }

                curtag = DNwrite(pDB,
                                 &search,
                                 fIsLastNameComponent ? dwExtIntFlags : 0);
                pname = NULL;

                // Note that DNwrite() has added the DNT of the new record
                // to the pAncestors array, so pAncestors is all set for the
                // next iteration.

                if (fIsLastNameComponent) {
                    // No record matching the string name we wanted to add-ref
                    // (which we just stamped in the obj table) -- no need to
                    // promote a phantom.
                    fPromotePhantom = FALSE;
                }

                // Successfully added this name component -- nnnext!
                ret = 0;
            }
            else {
                break;
            }
        }
    }

    // We either successfully walked all the RDNs or we encountered an error.
    Assert((0 != ret) || (iNamePart == cNameParts));
    Assert((0 != ret) || fAddRef || (NULL != pname));
    Assert((0 != ret) || fAddRef || (curtag == pname->DNT));
    
    if (0 == ret) {
        if (fAddRef) {
            if (fPromotePhantom) {
                // An add-ref for a new object currently in a prepared update in
                // pDB->JetObjTbl.  We found a phantom with the new object's DN
                // -- we need to promote it to an object and merge in the
                // object's attributes from JetObjTbl.
                sbTablePromotePhantom(pDB, curtag, search.tag.PDNT,
                                      search.tag.pRdn, search.tag.cbRdn);
            
                DPRINT2(1,
                        "Promoted phantom \"%ls\" (@ DNT 0x%x) and ref-counted "
                            "by string name!\n",
                        pDN->StringName, curtag);
            }
            else {
                DPRINT2(1, "Ref-counted \"%ls\" (@ DNT 0x%x) by string name.\n",
                        pDN->StringName, curtag);
            }
        
            DBAdjustRefCount(pDB, curtag, 1);
        }
        else {
            DPRINT2(1, "Found \"%ls\" (@ DNT 0x%x) by string name.\n",
                    pDN->StringName, curtag);
        }
    }

    // Note that even in the error case (0 != ret), we return the best match
    // we could find.  This functionality is used by sbTableGetTagFromDSName().
    if (NULL != ppname) {
        *ppname = pname;
    }

    if (NULL != pTag) {
        *pTag = curtag;
    }

    if (NULL != pfIsRecordCurrent) {
        *pfIsRecordCurrent = fIsRecordCurrent;
    }

    return ret;
}

void
sbTablePromotePhantom(
    IN OUT  DBPOS *     pDB,
    IN      ULONG       dntPhantom,
    IN      ULONG       dntObjParent,
    IN      WCHAR *     pwchRDN,
    IN      DWORD       cbRDN
    )
/*++

Routine Description:

    Promote the phantom at the given DNT into the object with currency in
    pDB->JetObjTbl.  The phantom is promoted in-place such that any pre-existing
    references to it (e.g., by children or DN-valued attributes of other
    objects) are not left dangling, and it acquires all attributes from the
    pDB->JetObjTbl record.  The pDB->JetObjTbl record is subsequently lost.

Arguments:

    pDB (IN/OUT)

    dntPhantom - DNT of the phantom to promote.

    dntObjParent - DNT of the object's parent (which might be different from the
        current parent of the phantom).

    pwchRDN - the new object's RDN (_not_ null-terminated)

    cbRDN - the size IN BYTES of pwchRDN.

Return Values:

    0 on success, non-zero on failure.

--*/
{
    THSTATE                    *pTHS=pDB->pTHS;
    JET_ERR                     err;
    JET_RETINFO                 retinfo;
    JET_SETINFO                 setinfo;
    char *                      buf;
    ULONG                       cbBuf;
    ULONG                       cbCol;
    ULONG                       dntNewObj;
    ULONG                       CurrRecOccur = 1;
    char                        objval = 0;
    BOOL                        fIsMetaDataCached;
    BOOL                        fMetaDataWriteOptimizable;
    DWORD                       cbMetaDataVecAlloced;
    PROPERTY_META_DATA_VECTOR * pMetaDataVec;
    d_memname *                 pname;
    ULONG                       dntPhantomParent;
    SYNTAX_INTEGER              insttype = 0;
    BOOL                        fHasType = FALSE;
    PSECURITY_DESCRIPTOR        pSDForQuotaFixup = NULL;

    Assert(VALID_DBPOS(pDB));

    // cbRDN is a size in BYTES, not WCHARS
    Assert( 0 == ( cbRDN % sizeof( WCHAR ) ) );

    // Save meta data vector we've created thus far; we'll restore it once
    // we've moved over to the phantom's DNT.

    fIsMetaDataCached = pDB->fIsMetaDataCached;
    fMetaDataWriteOptimizable = pDB->fMetaDataWriteOptimizable;
    cbMetaDataVecAlloced = pDB->cbMetaDataVecAlloced;
    if ( fIsMetaDataCached && cbMetaDataVecAlloced )
    {
        pMetaDataVec = THAllocEx(pTHS,  cbMetaDataVecAlloced );
        memcpy( pMetaDataVec, pDB->pMetaDataVec,
                cbMetaDataVecAlloced );
    }
    else
    {
        pMetaDataVec = NULL;
    }

    /* update the record using SearchTbl */

    pname = DNread(pDB, dntPhantom, DN_READ_SET_CURRENCY);
    dntPhantomParent = pname->tag.PDNT;

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                       DS_JET_PREPARE_FOR_REPLACE);

    /* get the DNT of the record to be inserted so we can
     * replace references to it
     */

    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl,
                             dntid, &dntNewObj, sizeof(dntNewObj),
                             &cbCol,  pDB->JetRetrieveBits, NULL);

    // Copy record's attributes from ObjTbl to SearchTbl. All the non-tagged
    // columns are already set on the older object. So, copy all the tagged
    // columns from JetObjTbl (with currency on the new DNT we're aborting) to
    // JetSearchTbl (with currency on the phantom we're promoting).

    retinfo.cbStruct = sizeof(retinfo);
    retinfo.ibLongValue = 0;
    retinfo.itagSequence = CurrRecOccur;
    retinfo.columnidNextTagged = 0;
    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 0;   /* New tag */
    cbBuf =  DB_INITIAL_BUF_SIZE;
    buf = dbAlloc(cbBuf);

    while (((err=JetRetrieveColumnWarnings(pDB->JetSessID,
                                           pDB->JetObjTbl,
                                           0, buf, cbBuf,
                                           &cbCol,
                                           pDB->JetRetrieveBits,
                                           &retinfo)) ==
             JET_errSuccess) ||
           (err == JET_wrnBufferTruncated)) {

        if (err == JET_errSuccess) {

            // Don't copy RDN; it will be blasted onto the phantom below.
            if (rdnid != retinfo.columnidNextTagged) {

                if (guidid == retinfo.columnidNextTagged
                    || sidid == retinfo.columnidNextTagged) {
                    // This attribute may or may not already exist on the
                    // phantom; if it already exists, the following will
                    // prevent us from having a duplicate on the final,
                    // promoted object.
                    setinfo.itagSequence = 1;
                }
                else if (insttypeid == retinfo.columnidNextTagged) {
                    // need insttype in case we need to fix up quota counts
                    // (should only be one occurrence of it)
                    //
                    Assert( !fHasType );
                    Assert( sizeof(insttype) == cbCol );
                    fHasType = TRUE;
                    insttype = *(SYNTAX_INTEGER *)buf;
                }

                JetSetColumnEx(pDB->JetSessID,
                               pDB->JetSearchTbl,
                               retinfo.columnidNextTagged,
                               buf, cbCol, 0, &setinfo);

                setinfo.itagSequence = 0;   /* New tag */
            }

            retinfo.itagSequence = ++CurrRecOccur;
            retinfo.columnidNextTagged = 0;
        }
        else {
            cbBuf = cbCol;
            dbFree(buf);
            buf = dbAlloc(cbBuf);
        }
    }

    dbFree(buf);

    // Set ATT_RDN and PDNT on the phantom being promoted to those derived from
    // the DN of the new object.  This is necessary since we most likely found
    // this phantom by GUID, implying the object might have been renamed and/or
    // moved since the phantom was created.

    Assert(setinfo.cbStruct == sizeof(setinfo));
    Assert(setinfo.ibLongValue == 0);
    setinfo.itagSequence = 1;

    JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, rdnid,
                   pwchRDN, cbRDN, 0, &setinfo);

    if (dntObjParent != pname->tag.PDNT) {
        // Object has indeed been moved; change its parent.
        // Note that this implies we need to move the parent refcount from the
        // phantom's parent to the object's parent.
        DBAdjustRefCount(pDB, dntPhantomParent, -1);
        DBAdjustRefCount(pDB, dntObjParent, 1);

        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, pdntid,
                       &dntObjParent, sizeof(dntObjParent), 0, &setinfo);
    }

	// we rely on instance type to tell us whether we
	// need to track quota for this object, so if this
	// object doesn't yet have an instance type, I must
	// have missed a code path
	//
	Assert( fHasType );

    // HACK! HACK! HACK! HACK! HACK!
    //
    // normally, quota counts have been updated for the object we just
    // cancelled and the promoted phantom just takes the place of the
    // cancelled object as far as quota reconciliation goes, but there's
    // a case where the object may get double-counted if async rebuild
    // of the quota table is happening and the rebuild task hasn't yet
    // gotten to the promoted phantom, so we need to manually update
    // quota counts here
    //
	if ( !gAnchor.fQuotaTableReady
		&& dntPhantom > gAnchor.ulQuotaRebuildDNTLast
		&& dntPhantom <= gAnchor.ulQuotaRebuildDNTMax
		&& FQuotaTrackObject( insttype ) ) {

        ULONG   cbSD;
        UCHAR * pValBufSave     = pDB->pValBuf;     // will be re-allocated when we fetch the SD
        ULONG   cbValBufSave    = pDB->valBufSize;

        pDB->pValBuf = NULL;
        pDB->valBufSize = 0;

        err = DBGetAttVal(
                    pDB,
                    1,
                    ATT_NT_SECURITY_DESCRIPTOR,
                    0,
                    0,
                    &cbSD,
                    (PUCHAR *)&pSDForQuotaFixup );

        // reinstate original
        //
        Assert( NULL != pDB->pValBuf );
        dbFree( pDB->pValBuf );
        pDB->pValBuf = pValBufSave;
        pDB->valBufSize = cbValBufSave;

        // update quota count for cancelled object
        //
        if ( err
            || ( err = ErrQuotaDeleteObject( pDB, pDB->NCDNT, pSDForQuotaFixup, FALSE ) ) ) {
            Assert( "!Couldn't update quota counts. Something horrible went wrong." );
            RaiseDsaException(
                    DSA_DB_EXCEPTION,
                    err,
                    0,
                    FILENO,
                    __LINE__,
                    DS_EVENT_SEV_MINIMAL );
        }
	}


    /* replace any referencesto the aborted DNT in the links
     * table
     */

    dbRenumberLinks(pDB, dntNewObj, dntPhantom);
    DBCancelRec(pDB);

    // We're promoting a phantom to real object.  Move all the refcounts
    // from temporary real object to phantom which is being promoted.
    dbEscrowPromote(dntPhantom,     // phantom being promoted
                    dntNewObj);     // temporary real object

    /* indicate that data portion is missing */

    JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, objid,
                   &objval, sizeof(objval), 0, NULL);

    JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                NULL, 0, 0);

    // Future updates should occur to the now-promoted phantom's DNT.
    pDB->JetNewRec = FALSE;
    DBFindDNT(pDB, dntPhantom);
    dbInitRec(pDB);

    // Flush the phantom's DNT (which may have just undergone an RDN change)
    // from the read cache.
    dbFlushDNReadCache( pDB, dntPhantom );

    // ...and flush it again when we make the update, since we're changing the
    // value of its objflag.
    pDB->fFlushCacheOnUpdate = TRUE;

    // Restore meta data we've constructed thus far.
    Assert( !pDB->fIsMetaDataCached );

    pDB->fIsMetaDataCached    = fIsMetaDataCached;
    pDB->fMetaDataWriteOptimizable = fMetaDataWriteOptimizable;
    pDB->cbMetaDataVecAlloced = cbMetaDataVecAlloced;
    pDB->pMetaDataVec         = pMetaDataVec;

    // update quota counts for promoted phantom if necessary
    //
    if ( NULL != pSDForQuotaFixup ) {
        // QUOTA_UNDONE: what happens if we're actually promoting
        // a tombstoned object??
        //
        err = ErrQuotaAddObject( pDB, pDB->NCDNT, pSDForQuotaFixup, FALSE );

        // regardless of whether or not we succeeded, don't need SD anymore
        //
        THFreeEx( pDB->pTHS, pSDForQuotaFixup );

        if ( err ) {
            Assert( "!Couldn't update quota counts. Something horrible went wrong." );
            RaiseDsaException(
                    DSA_DB_EXCEPTION,
                    err,
                    0,
                    FILENO,
                    __LINE__,
                    DS_EVENT_SEV_MINIMAL );
        }
    }

    DPRINT2(1, "Promoted phantom @ DNT 0x%x from new object @ DNT 0x%x.\n",
            dntPhantom, dntNewObj);

} /* sbTablePromotePhantom */

void
sbTableUpdatePhantomDNCase (
        IN OUT DBPOS      *pDB,
        IN     DWORD       DNT,
        IN     ATTRBLOCK  *pNowBlockName,
        IN     ATTRBLOCK  *pRefBlockName)
/*++     
  Description.
      Iteratively walks up the PDNT chain starting at the DNT passed in.
      Compares two blocknames and if the RDN of this object differs, write a new
      RDN.  Only do this for structural phantoms, I.E. halt recursion anytime
      the object passed in is NOT a structural phantom.

      This routine is very sensitive to it's parameters.  It is expected that
      the two blocknames passed in are identical in every way except for a
      casing difference in some of the RDNs.  The DNT passed in should be the
      DNT for the object whose DSNAME is implied by the blocknames. 

      This routine is a helper for sbTableUpdatePhantomName.  It is called when
      we are updating a phantom name where the case of some parent objects RDN
      has changed.  sbTableUpdatePhantomName is very careful with the
      parameters, so we don't verify them here.

      This routine modifies objects on the search table, but only phantoms.  It
      does not make any change which is replicable, only strictly local.

  Parameters:    
      pDB - the DBPos to use
      DNT - the DNT of the object implied by the blocknames.
      pNowBlockName - BlockName which represents the actual contents of the
          database. 
      pRefBlockName - BlockName which represents what we want the actual
          contents of the database to be.

  Returns           
      None.  Either success or we except out.
--*/
{
    JET_RETRIEVECOLUMN jCol[2];
    DWORD              err;
    DWORD              cb;
    DWORD              level;

    Assert(pRefBlockName->attrCount == pNowBlockName->attrCount);
    
    JetSetCurrentIndexSuccess(pDB->JetSessID,
                              pDB->JetSearchTbl,
                              NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)

    for(level = pRefBlockName->attrCount - 1;level;level--) {
        // First, position on the object in the search table.
        pDB->SDNT = 0;
        JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, &DNT, sizeof(DNT),
                     JET_bitNewKey);
        err = JetSeek(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
        if (err) {
            DsaExcept(DSA_DB_EXCEPTION, err, DNT);
        }
        pDB->SDNT = DNT;
        
        // See if it is a structural phantom.  You do this by checking for the
        // absence of both a GUID and a OBJ_DIST_NAME
        memset(jCol, 0, sizeof(jCol));
        jCol[0].columnid = distnameid;
        jCol[0].itagSequence = 1;
        jCol[1].columnid = guidid;
        jCol[1].itagSequence = 1;
         
        JetRetrieveColumnsWarnings(pDB->JetSessID,
                                   pDB->JetSearchTbl,
                                   jCol,
                                   2);
        if((jCol[0].err != JET_wrnColumnNull) ||
           (jCol[1].err != JET_wrnColumnNull)     ) {
            // It is not a structural phantom.  Leave, we're done.
            return;
        }
        
        // Now, look at the RDN info in the names
        Assert(pNowBlockName->pAttr[level].attrTyp ==
               pRefBlockName->pAttr[level].attrTyp    );
        Assert(pNowBlockName->pAttr[level].AttrVal.pAVal->valLen ==
               pRefBlockName->pAttr[level].AttrVal.pAVal->valLen    );
        
        if(memcmp(pNowBlockName->pAttr[level].AttrVal.pAVal->pVal,
                  pRefBlockName->pAttr[level].AttrVal.pAVal->pVal,
                  pRefBlockName->pAttr[level].AttrVal.pAVal->valLen)) {
            // Yes, the RDN needs to change.
            JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                               DS_JET_PREPARE_FOR_REPLACE);
            JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, rdnid,
                           pRefBlockName->pAttr[level].AttrVal.pAVal->pVal,
                           pRefBlockName->pAttr[level].AttrVal.pAVal->valLen,
                           0, NULL);
            
            JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);
            
            // Reset entry in DN read cache, since the RDN has changed.
            dbFlushDNReadCache(pDB, DNT);
        }
        
        // Finally, get the PDNT of the current object as the next DNT to look
        // at and then continue the loop
        cb = 0;
        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 pDB->JetSearchTbl, pdntid,
                                 &DNT,
                                 sizeof(DNT),
                                 &cb,
                                 JET_bitRetrieveCopy,
                                 NULL);
        
        Assert(cb = sizeof(DNT));
    }
    return;
}

DWORD
sbTableUpdatePhantomName (
        IN  OUT DBPOS     *pDB,
        IN      d_memname *pdnName,
        IN      DWORD      dnt,
        IN      DSNAME    *pdnRef,
        IN      DSNAME    *pdnNow)
/*++

Routine Description:

    Update phantom names.  Looks at the stringname of the phantom passed in and
    the stringname of the phantom in the DIT and modifies appropriately.  This
    can be as simple as modifying the RDN, or as complex as creating a new
    structural phantom to be a parent of the phantom, moving the phantom to be a
    child of the new structural phantom, modifying it's RDN, and modifying its
    SID.

    It is expected that this routine is called after already finding that the
    string name of the phantom is stale.

    pdnRef must have a stringname and a guid.  No check is made here.

    If the stringname in the dsname passed in is already in use and the object
    using that name is a phantom, the existing object which uses that name has
    it's RDN mangled to free up the name.  It is expected that a later
    modification will give the mangled object a better name.  If the name is in
    use by an instantiated object, this routine does nothing and returns.
    
Arguments:

    pDB (IN/OUT) - PDB to do this work on.  This routine uses the search table.
                 pDB->SDNT may change, etc.

    pdnName (IN) - memname of the existing phantom object whose name is to be
        updated.  This is the data that exists in the DIT and is to be changed
        by this routine.

    dnt (IN) - dnt of the existing phantom object whose name is to be updated.

    pdnRef (IN) - DSNAME of the object whose name is to be updated.  The
        stringname holds the name that is to be written into the DIT.  This
        is expected to be different from the stringname already on the object in
        the DIT (and reflected in pdnName).

Return Values:

    0 on success, non-zero DIRERR_* on failure.

--*/
{
    DWORD       err;
    WCHAR       rgwchRDN[MAX_RDN_SIZE];
    WCHAR       rgwchMangledRDN[MAX_RDN_SIZE];
    DWORD       cchRDN;
    ATTRTYP     attidRDN;
    DSNAME *    pdnRefParent;
    DSNAME *    pdnNowParent;
    DWORD       PDNT;
    NT4SID      sidRefInt;
    BOOL        fWriteNewRDN;
    BOOL        fWriteNewSid;
    BOOL        fWriteNewPDNT;
    BOOL        fMangledRDN = FALSE;
    USN         usnChanged;
    BOOL        fNewParentCreated = FALSE;
    DWORD       DNTConflict;
    GUID        GuidConflict, objGuid;
    DWORD       objSidLen;
    DWORD       actuallen, cchMangledRDN;
    ATTRBLOCK  *pNowBlockName=NULL;
    ATTRBLOCK  *pRefBlockName=NULL;
    THSTATE     *pTHS = pDB->pTHS;
    d_memname  *pconflPhantom = NULL;
    DWORD      *pdntAncestors = NULL;
    DWORD      cbAncestorsSize = 0, cNumAncestors = 0;
    

    // First, examine the parent.  There are three possible outcomes:
    // 1) The new name implies a completely new parent.  In this case, find the
    //    PDNT of the new parent (and add a new structural phantom if the new
    //    parent doesn't yet exist.)
    // 2) The new name implies exactly the same parent.  In this case, we do
    //    nothing more for the parent name, it is already correct.
    // 3) The new name implies the same parent via NameMatch, but the case of
    //    some part of the parents DN has changed.  In this case, we traverse up
    //    our parent chain and fix any RDN case changes for phantom objects.
    pdnRefParent = THAllocEx(pTHS, pdnRef->structLen);
    TrimDSNameBy(pdnRef, 1, pdnRefParent);
    pdnNowParent = THAllocEx(pTHS, pdnNow->structLen);
    TrimDSNameBy(pdnNow, 1, pdnNowParent);
    err = 0;
    if(NameMatchedStringNameOnly(pdnRefParent, pdnNowParent)) {
        // Same parent.
        fWriteNewPDNT = FALSE;
        if(memcmp(pdnNowParent->StringName,
                  pdnRefParent->StringName,
                  pdnRefParent->NameLen)) {
            // however, some case change has occurred.  Fix it up.
            // Transform the names to a block names.
            err = DSNameToBlockName(pTHS,
                                    pdnRefParent,
                                    &pRefBlockName,
                                    DN2BN_PRESERVE_CASE);
            if(!err) {
                err = DSNameToBlockName(pTHS,
                                        pdnNowParent,
                                        &pNowBlockName,
                                        DN2BN_PRESERVE_CASE);
                
                if(!err) {
                    sbTableUpdatePhantomDNCase(
                            pDB,
                            pdnName->tag.PDNT,
                            pNowBlockName,
                            pRefBlockName);
                }
            }
        }
    }
    else {
        fWriteNewPDNT = TRUE;
        
        if (NamePrefix(pdnNow, pdnRefParent)) {
            // looks like phantom's name changed in such a way that it ended 
            // up being a descendant of its current name. If we proceed as 
            // normally, when we will be searching the new parent, we will end
            // up locating the current object (or one of its descendants).
            // If we move current phantom under that object, then we will 
            // introduce a loop in PDNT chain, which is fatal. 
            // So, to get around the problem, let's mangle
            // this phantom's name. Fortunately, we have its guid.
            Assert(!fNullUuid(&pdnName->Guid));

            // get the current phantom RDN
            memcpy(rgwchRDN, pdnName->tag.pRdn, pdnName->tag.cbRdn);
            cchRDN = pdnName->tag.cbRdn / sizeof(WCHAR);
            // The current RDN can not be mangled (if it was, then how would we
            // encountered another object somewhere in our parent chain
            // that has our GUID in his RDN???)
            Assert(!IsMangledRDN(rgwchRDN, cchRDN, &objGuid, NULL));
            
            MangleRDN(MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT, &pdnName->Guid, rgwchRDN, &cchRDN);

            sbTableUpdateRecordIdentity(pDB, dnt, rgwchRDN, cchRDN, NULL, NULL, 0);

            // We just changed the RDN of the phantom. So, we also will need to update it back.
            fMangledRDN = TRUE;
        }

        // Parent seems to have changed -- add ref the new parent.
        Assert(fNullUuid(&pdnRefParent->Guid));
        err = sbTableGetTagFromStringName(pDB,
                                          pDB->JetSearchTbl,
                                          pdnRefParent,
                                          TRUE,
                                          FALSE,
                                          0,
                                          &PDNT,
                                          NULL,
                                          NULL);
        
        // We have found the new parent. If we mangled our RDN above, then
        // our old RDN is now busy -- a new structural phantom was created
        // with this name. So, we can not unmangle it now. We will write the
        // correct RDN later on, after we move the object under the correct
        // parent.

        // Drop the refcount of the old parent by one.
        DBAdjustRefCount(pDB, pdnName->tag.PDNT, -1);

        if (!err) {

            // also read the ancestry from the parent so as to put it later 
            // on the child
            dbGetAncestorsSlowly(pDB, PDNT, &cbAncestorsSize, &pdntAncestors, &cNumAncestors);

            // if our parent was not ROOT, we need two more entries on the resulting array
            if (PDNT != ROOTTAG) {
                if (cbAncestorsSize < (cNumAncestors + 2) * sizeof(*pdntAncestors)) {
                    // Make room for an additional DNT at the end of the ancestors list.
                    cbAncestorsSize = (cNumAncestors + 2) * sizeof(*pdntAncestors);
                    pdntAncestors = THReAllocEx(pDB->pTHS, pdntAncestors, cbAncestorsSize);
                }
                pdntAncestors[cNumAncestors++] = PDNT;
            }
            else {
                // ROOTTAG is already on the list
                if (cbAncestorsSize < (cNumAncestors + 1) * sizeof(*pdntAncestors)) {
                    // Make room for an additional DNT at the end of the ancestors list.
                    cbAncestorsSize = (cNumAncestors + 1) * sizeof(*pdntAncestors);
                    pdntAncestors = THReAllocEx(pDB->pTHS, pdntAncestors, cbAncestorsSize);
                }
            }
        }
    }

    if(pNowBlockName)
        FreeBlockName(pNowBlockName);
    if(pRefBlockName)
        FreeBlockName(pRefBlockName);
    THFreeEx(pTHS, pdnNowParent);
    THFreeEx(pTHS, pdnRefParent);

    if(err) {
        // Something went wrong with the parent verification.
        return err;
    }
    
    // Second, examine the SID.  There are only two outcomes.
    // 1) The sid hasn't changed.  Do nothing.
    // 2) There is a new sid.  In this case, write that SID on the object
    //    instead of the SID that's already there.
    if ((pdnName->SidLen != pdnRef->SidLen)
        || memcmp(&pdnName->Sid, &pdnRef->Sid, pdnRef->SidLen)) {
        // The phantom's SID is either absent (in which case we want
        // to add the one from the reference) or different (in which
        // case we still want to add the one from the reference).
        
        // Convert the SID from the reference into internal format.
        memcpy(&sidRefInt, &pdnRef->Sid, pdnRef->SidLen);
        InPlaceSwapSid(&sidRefInt);
        fWriteNewSid = TRUE;
    }
    else {
        fWriteNewSid = FALSE;
    }
        

    // Finally, examine the RDN.  There are three outcomes.
    // 1) The RDN has not changed in any way, so there is nothing to do.
    // 2) The RDN has only changed cases.
    // 3) The RDN is completely different.
    // In cases 2 and 3, we're going to need to write a new RDN on the object.

    GetRDNInfo(pTHS, pdnRef, rgwchRDN, &cchRDN, &attidRDN);
    if(fMangledRDN ||
       (pdnName->tag.cbRdn != cchRDN * sizeof(WCHAR)) ||
       (pdnName->tag.rdnType != attidRDN) ||
       (memcmp(pdnName->tag.pRdn, rgwchRDN, pdnName->tag.cbRdn))) {
        // The RDN has changed, reset it.
        fWriteNewRDN = TRUE;

        // this assert should never hit in a real system, unless we are 
        // doing refcount testing. 
        // an existing object can never change its rdntype.
        Assert ( (pdnName->tag.rdnType == attidRDN) && "Disable this Assert if your are doing a refcount test." );
    }
    else {
        fWriteNewRDN = FALSE;
    }

    // A side bit of work.  If the RDN has changed, it might have changed to a
    // name for a deleted object.  If it has, we need to romp through the link
    // table and sever link/backlink connections.
    if(fWriteNewRDN) {
        GUID tmpGuid;
        MANGLE_FOR reasonMangled;
        // See if the new RDN is for a deleted object and the old RDN is not
        if((IsMangledRDN(rgwchRDN, cchRDN, &tmpGuid, &reasonMangled)) &&
           (reasonMangled == MANGLE_OBJECT_RDN_FOR_DELETION) &&
           !(IsMangledRDN(pdnName->tag.pRdn,
                          pdnName->tag.cbRdn/2,
                          &tmpGuid,
                          NULL))) {
            // RemoveBackLinksFromPhantom
            DBRemoveAllLinks( pDB, pdnName->DNT, TRUE /*isbacklink*/ );
        }
    }
    
    if(fWriteNewRDN || fWriteNewPDNT) {
        // We are changing the RDN or PDNT.  In either case, we might end up
        // conflicting with an existing object.  Check by temporarily nulling
        // the guid and sidLen out of the existing name and then looking up the
        // name (thus forcing lookup by string name).  Remember to put back the
        // guid and sidLen.
        objGuid = pdnRef->Guid;
        objSidLen = pdnRef->SidLen;
        memset(&pdnRef->Guid, 0, sizeof(GUID));
        pdnRef->SidLen = 0;
        __try {
            err = sbTableGetTagFromDSName(
                    pDB,
                    pdnRef,
                    SBTGETTAG_fMakeCurrent | SBTGETTAG_fAnyRDNType,
                    &DNTConflict,
                    NULL);
        }
        __finally {
            pdnRef->Guid = objGuid;
            pdnRef->SidLen = objSidLen;
        }
            
        
        
        switch(err) {
        case 0:
            // Normal object.
            // The RDN of the reference phantom differs from that of the local phantom,
            // and the code would like to reset the RDN of the local phantom to that
            // of the reference phantom, but it can't because a live object already exists
            // holding the RDN of the reference phantom.  This is a valid scenario.
            // This can occur, for example, when the local phantom has a mangled name and
            // the reference phantom does not. The reason the local phantom has a
            // mangled name is that it had a name conflict with a live object already holding
            // the name.

            // Silently fail, since we don't have the authority to rename an
            // instantiated object.
            return 0;
            break;
            
        case ERROR_DS_NOT_AN_OBJECT:
            if(DNTConflict == dnt) {
                // We conflict with ourselves.  This must mean we are NOT
                // changing PDNT, we ARE changing RDN, and the only difference
                // in RDN is a case change or a RDN type change
                Assert(!fWriteNewPDNT);
                Assert(fWriteNewRDN);
                err = 0;
            }
            else {
                // The object we conflict with is a Phantom.  We need to mangle
                // it's RDN.  Later (if the object is a reference phantom),
                // someone else should update the object to whatever its new
                // name should be (it must need a new name, since the phantom
                // we're updating wants to steal the name.)  If the object is a
                // structural phantom, someday someone will update some
                // reference child, and that will clean everything up.

                // Get the phantoms guid if it has one.
                switch(err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                                       pDB->JetSearchTbl,
                                                       guidid,
                                                       &GuidConflict,
                                                       sizeof(GuidConflict),
                                                       &actuallen,
                                                       0,
                                                       NULL)) {
                case 0:
                {
                    // got a guid, no problem.
                    pconflPhantom = DNread (pDB, DNTConflict, 0);
                
                    memcpy(rgwchMangledRDN, pconflPhantom->tag.pRdn, pconflPhantom->tag.cbRdn);
                    cchMangledRDN = pconflPhantom->tag.cbRdn / sizeof(WCHAR);

                    MangleRDN(MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT,
                              &GuidConflict,
                              rgwchMangledRDN,
                              &cchMangledRDN);
                
                    // Write new new RDN on the object we conflict with.
                    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                                       DS_JET_PREPARE_FOR_REPLACE);

                    JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, rdnid,
                                   rgwchMangledRDN, cchMangledRDN * sizeof(WCHAR),
                                   0, NULL);

                    JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);
                
                    // Reset entry in DN read cache, since the RDN has changed.
                    dbFlushDNReadCache(pDB, DNTConflict);
                    break;

                }
                case JET_wrnColumnNull:
                {
                    // phantom has no guid.  It's a structural phantom.
                    // Coalesce the children of the structural phantom to the reference
                    // phantom. Mangle the structural phantom. Give the reference
                    // phantom the name.
                    DBPOS *pDBTmp = NULL;
                    BOOL fCommit = FALSE;
                    // Note: stay in same transaction
                    DBOpen2(FALSE,&pDBTmp);
                    __try {
                        DBCoalescePhantoms(pDBTmp, dnt, DNTConflict );
                        fCommit = TRUE;
                    } __finally {
                        DBClose(pDBTmp, fCommit);
                    }
                    err = 0;
                    break;
                }

                default:
                    // Something badly wrong.  Raise the same exception we would
                    // have raised in JetRetrieveColumnWarnings.
                    DsaExcept(DSA_DB_EXCEPTION, err, 0);
                    break;
                }

            }
            break;

        case ERROR_DS_NAME_NOT_UNIQUE:
            return err;

        default:
            // Didn't find anything, the name is free for use.
            err = 0;
            break;
        }
    }

    // OK, we've done all the preperatory work.  Do the actual update. Note
    // that we might not actually have a new RDN, PDNT, or SID to write here
    // because we might have needed to just change some case of some ancestors
    // RDN.  However, no matter what, we are going to write a new USN changed to
    // this object to show that we've done some processing while verifying it's
    // name. 

    // Set Currency and prepare to update.
    DNread(pDB, dnt, DN_READ_SET_CURRENCY);

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                       DS_JET_PREPARE_FOR_REPLACE);
    if(fWriteNewSid) {
        // Update the SID.
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, sidid,
                       &sidRefInt, pdnRef->SidLen, 0, NULL);
    }
    if(fWriteNewRDN) {
        // Update the RDN.
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, rdnid,
                       rgwchRDN, cchRDN * sizeof(WCHAR), 0, NULL);

        // The rdnType is stored in the DIT as the msDS_IntId, not the
        // attributeId. This means an object retains its birth name
        // even if unforeseen circumstances allow the attributeId
        // to be reused.
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, rdntypid,
                       &attidRDN, sizeof (attidRDN), 0, NULL);
    }
    if(fWriteNewPDNT) {
        // Update the PDNT.  Old/new parent refcounts have already been
        // adjusted.
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, pdntid,
                       &PDNT, sizeof(PDNT), 0, NULL);
    
        // also update the ancestors
        if (cNumAncestors) {
            DPRINT (3, "Updating ancestry for phantom\n");
            Assert ((cNumAncestors+1) * sizeof (DWORD) <= cbAncestorsSize);
            pdntAncestors[cNumAncestors] = dnt;

            JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, ancestorsid,
                           &pdntAncestors, cbAncestorsSize, 0, NULL);
        }
    }
    
    usnChanged = DBGetNewUsn();
    JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, usnchangedid,
                   &usnChanged, sizeof(usnChanged), 0, NULL);
    
    JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);


    
    // Reset entry in DN read cache, since either the RDN or the PDNT had to
    // have changed.
    dbFlushDNReadCache(pDB, dnt);
    
    return err;
}

DWORD
sbTableAddRefByGuid(
    IN OUT  DBPOS *     pDB,
    IN      DWORD       dwFlags,
    IN      DSNAME *    pdnRef,
    OUT     ULONG *     pTag
    )
/*++

Routine Description:

    Increment the ref count on a DN, finding the appropriate record by GUID.
    Fails if the appropriate record does not already exist.

Arguments:

    pDB (IN/OUT)

    dwFlags (IN) - 0, EXTINT_NEW_OBJ_NAME, or EXTINT_UPDATE_PHANTOM.
        EXTINT_NEW_OBJ_NAME indicates that we're adding a refcount for a new,
            instantiated object's name.
        EXTINT_UPDATE_PHANTOM indicates we want to update a phantom if found

    pdnRef (IN) - fully populated name of the phantom or object.

    pTag (OUT) - on return, holds the DNT of the record written (i.e., the
        record corresponding to the given DN).

Return Values:

    0 on success, non-zero DIRERR_* on failure.

--*/
{
    THSTATE *   pTHS = pDB->pTHS;
    DWORD       err;
    DSNAME *    pdnCurrent;
    DSNAME *    pdnOldParent;
    DSNAME *    pdnNewParent;
    WCHAR       rgwchRDN[MAX_RDN_SIZE];
    DWORD       cchRDN;
    d_memname * pname;
    ULONG       PDNT;
    BOOL        fCurrency = FALSE;
    DWORD       insttype = 0;  // 0 is not a valid instance type
    DWORD       cbActual;

    Assert(VALID_DBPOS(pDB));
    Assert(!fNullUuid(&pdnRef->Guid));

    err = sbTableGetTagFromGuid(pDB, pDB->JetSearchTbl, &pdnRef->Guid, pTag,
                                &pname, &fCurrency);

    if (   (0 == err) 
        && (dwFlags & EXTINT_UPDATE_PHANTOM)
        && pname->objflag ) {

        // We found the record and it is not a phantom.  Read the object's 
        // instance type since we want to update subrefs, too
        if ( !fCurrency ) {

            // Position on the object
            JetSetCurrentIndexSuccess(pDB->JetSessID,
                                      pDB->JetSearchTbl,
                                      NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         &pname->DNT,
                         sizeof(pname->DNT),
                         JET_bitNewKey);
            err = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
            if (err) {
                DsaExcept(DSA_DB_EXCEPTION, err, pname->DNT);
            }
        }

        // Read the instance type
        err = JetRetrieveColumn(pDB->JetSessID,
                                pDB->JetSearchTbl,
                                insttypeid,
                                &insttype,
                                sizeof(insttype),
                                &cbActual,
                                0,
                                NULL);
        if( err ) {
            DPRINT1(0, "Couldn't read instance type, error %d\n", err);
            // this error is continuable; we won't treat the object
            // like a subref
            insttype = 0;
            err = 0;
        }
    }

    if ((0 == err) && (dwFlags & EXTINT_NEW_OBJ_NAME)) {
        // The record we're trying to add-ref is the new record with currency
        // in pDB->JetObjTbl, which is in the middle of a prepared update.
        
        // There may or may not be another record with this same guid -- if
        // there is, we need to promote it.  If not, we just need to add the
        // appropriate columns.

        d_memname search = {0};
        BOOL      fPromotePhantom = !pname->objflag;
        
        Assert(pDB->JetRetrieveBits == JET_bitRetrieveCopy);
        Assert(pDB->JetNewRec);
        
        Assert(!pname->objflag
               && "Object conflict should have been detected in "
                  "CheckNameForAdd()!");
        
        // Derive RDN of the new object from its DN.
        GetRDNInfo(pDB->pTHS, pdnRef, rgwchRDN, &cchRDN,
                   &search.tag.rdnType);
        search.tag.cbRdn = cchRDN * sizeof(WCHAR);
        search.tag.pRdn  = rgwchRDN;
        
        // Copy other identities from the DSNAME.
        search.Guid   = pdnRef->Guid;
        search.Sid    = pdnRef->Sid;
        search.SidLen = pdnRef->SidLen;

        // Derive PDNT that should go on the new object.
        pdnNewParent = THAllocEx(pTHS,pdnRef->structLen);
        TrimDSNameBy(pdnRef, 1, pdnNewParent);

        err = sbTableGetTagFromStringName(pDB,
                                          pDB->JetSearchTbl,
                                          pdnNewParent,
                                          FALSE,
                                          FALSE,
                                          0,
                                          &search.tag.PDNT,
                                          &pname,
                                          NULL);
        THFreeEx(pTHS,pdnNewParent);

        if (0 != err) {
            // The parent of the object we're adding does not exist --
            // this should have been detected (and rejected) earlier.
            // Note that the parent can be a phantom; e.g., when the object
            // we're adding is the head of a new NC.
            DPRINT2(0,
                    "Parent of new object %ls not found, error %u.\n",
                    pdnRef->StringName, err);
            Assert(FALSE);
            DsaExcept(DSA_EXCEPTION, DS_ERR_NO_PARENT_OBJECT, err);
        }

        
        // Promote the phantom to be the full-fledged object.
        sbTablePromotePhantom(pDB, *pTag, search.tag.PDNT, rgwchRDN,
                              cchRDN * sizeof(WCHAR));
        DBAdjustRefCount(pDB, *pTag, 1);

        DPRINT2(1,
                "Promoted phantom \"%ls\" (@ DNT 0x%x) and "
                    "ref-counted by GUID!\n",
                pdnRef->StringName, *pTag);

        // Success!
        Assert(0 == err);
    }
    else if (!err) {
        // Found DN by GUID!
        BOOL fProcessed = FALSE;
        err = 0;

        // If the record is a phantom and the phantom updater is calling us
        // then proceed
        if (  !pname->objflag 
           && (dwFlags & EXTINT_UPDATE_PHANTOM) ) {

            DSNAME *pDNTmp=NULL;
            // We're adding a reference to a phantom which already exists,
            // and we were told to update the name if we need to

            // Simple test for changed name.  Get the DN of the object in
            // question and compare it to the string portion of the DN
            // passed in.  We do an exact byte-for-byte comparison to catch
            // case changes.  Note that we expect both names to be
            // "canonical", that is, both should be in the format returned
            // by sbTableGetDSName.  That's obviously true of pDNTmp.  At
            // the moment, only the stale phantom daemon or replication ever
            // writes this attribute, and they both ultimately get the value
            // via sbTableGetDSName.
            if(err=sbTableGetDSName(pDB, pname->DNT, &pDNTmp,0)) {
                return err;
            }
            if((pdnRef->NameLen != pDNTmp->NameLen) ||
               memcmp(pdnRef->StringName, pDNTmp->StringName,
                      pdnRef->NameLen * sizeof(WCHAR))) {
                err = sbTableUpdatePhantomName(pDB, pname,*pTag,
                                               pdnRef,
                                               pDNTmp);
                if(err) {
                    return err;
                }
                fProcessed = TRUE;
                
            }
            // ELSE
            //  The string name is the same.  Just pass it on through
            THFreeEx(pDB->pTHS, pDNTmp);
        }
            
        // If we have processed the reference and the object is a phantom
        // then enter
        // OR if this object is a subref, then enter so its sid can get updated.

        if (   ((!fProcessed) && (!pname->objflag))
            || (insttype & SUBREF) ) {

            if ( insttype & SUBREF ) {
                // If we are here becuase of a subref update, then only the
                // phantom cleanup task should be calling us
                Assert( (dwFlags & EXTINT_UPDATE_PHANTOM) )
            }

            if (pdnRef->SidLen) {
                // We're add-refing an existing phantom that already has a GUID.
                // Update its SID if it's different from that in the reference.
                
                if ((pname->SidLen != pdnRef->SidLen)
                    || memcmp(&pname->Sid, &pdnRef->Sid, pdnRef->SidLen)) {
                    // The phantom's SID is either absent (in which case we want
                    // to add the one from the reference) or different (in which
                    // case we want to make the assumption that the reference's
                    // SID is more recent and update the phantom's SID).
                    NT4SID sidRefInt;
                    
                    // Convert the SID from the reference into internal format.
                    memcpy(&sidRefInt, &pdnRef->Sid, pdnRef->SidLen);
                    InPlaceSwapSid(&sidRefInt);
                    
                    // Set currency.
                    DNread(pDB, *pTag, DN_READ_SET_CURRENCY);
                    
                    // Update the SID.
                    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                                       DS_JET_PREPARE_FOR_REPLACE);
                    
                    JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, sidid,
                                   &sidRefInt, pdnRef->SidLen, 0, NULL);
                    
                    JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);
                    
                    // Reset entry in DN read cache.
                    dbFlushDNReadCache(pDB, *pTag);
                }
            }
        }

        if (0 == err) {
            DBAdjustRefCount(pDB, *pTag, 1 );

            DPRINT2(1, "Ref-counted \"%ls\" (@ DNT 0x%x) by GUID!\n",
                    pdnRef->StringName, *pTag);
        }
    }

    return err;
}

/*--------------------------------------------------------------------------- */
/*--------------------------------------------------------------------------- */
DWORD APIENTRY sbTableAddRef(DBPOS FAR *pDB,
                             DWORD dwFlags,
                             DSNAME *pNameArg,
                             ULONG *pTag)
/*++

Routine Description:

    Increment the ref count on a DN.  Creates the appropriate records for the
    various components of the name if they do not already exist.

Arguments:

    pDB (IN/OUT)

    dwFlags (IN) - 0 or EXTINT_NEW_OBJ_NAME or EXTINT_UPDATE_PHANTOM
        EXTINT_NEW_OBJ_NAME indicates that we're adding a refcount for a new, 
            instantiated object's name.
        EXTINT_UPDATE_PHANTOM indicates we want to update a phantom if found

    pNameArg (IN) - fully populated name of the phantom or object.

    pTag (OUT) - on return, holds the DNT of the record written (i.e., the
        record corresponding to the given DN).

Return Values:

    0 on success, non-zero on failure.

--*/
{
    THSTATE         *pTHS=pDB->pTHS;
    d_tagname        *tagarray;
    unsigned int     partno, i;
    ATTRBLOCK        *pBlockName;
    DWORD            code;
    BOOL             fNameHasGuid;
    BOOL             fRetry;
    DSNAME *         pName = pNameArg;
    DWORD           *pAncestors=NULL;
    DWORD            cAncestors=0;
    DWORD            cAncestorsAllocated;
    
    DPRINT(2, "sbTableAddRef entered\n");

    Assert(VALID_DBPOS(pDB));

    fNameHasGuid = !fNullUuid( &pName->Guid );

    // Attempt to ref-count record by GUID first.
    if (fNameHasGuid) {

        code = sbTableAddRefByGuid(pDB, dwFlags, pName, pTag);

        if (!code) {
            // Successfully ref-counted by GUID!
            return 0;
        }
    }

    // No guid in DN or guid was not found in the database.

    DPRINT1(1, "Ref-counting \"%ls\" by string name.\n", pName->StringName);

    code = sbTableGetTagFromStringName(pDB,
                                       pDB->JetSearchTbl,
                                       pName,
                                       TRUE,
                                       FALSE,
                                       dwFlags,
                                       pTag,
                                       NULL,
                                       NULL);
    
    return code;

}


/*

Routine Description:
    This routine resets the RDN.  Note that since the RDN has become a normal
    attribute, one could reset the RDN through normal DBSetAttVal calls.
    However, this routine was created to reset the RDN and give us a place to
    hang code to update the DNReadCache as necessary.

Arguments:
    pAVal - An attrval that we will use the first value of as the new RDN

Return Values:
    Returns 0 if all went well.  Currently, only 0 is returned.  Note that if
    the JetSetColumnEx fails, an exception is thrown.

*/
DWORD
DBResetRDN (
        DBPOS *pDB,
        ATTRVAL *pAVal
        )
{
    ATTCACHE * pAC;

    Assert(VALID_DBPOS(pDB));

    dbInitRec(pDB);

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, rdnid,
                   pAVal->pVal,
                   pAVal->valLen, 0, NULL);

    // Whenever the RDN is changed, we need to schedule an SD propagation.
    // This is because SDPROP is now loading its children in batches from
    // PDNT_RDN index, and by renaming a child and moving it back in PDNT_RDN
    // index, we can exclude it from propagation. If the SD does not change, 
    // than this SD propagation is a noop.
    pDB->fEnqueueSDPropOnUpdate = TRUE;

    // Touch replication meta data for this attribute.
    pAC = SCGetAttById(pDB->pTHS, ATT_RDN);
    // prefix complains about pAC being NULL, 447340, bogus since we are using constant
    Assert(pAC != NULL);
    DBTouchMetaData(pDB, pAC);

    pDB->fFlushCacheOnUpdate = TRUE;

    return 0;
}


DB_ERR
DBMangleRDNforPhantom(
        IN OUT  DBPOS * pDB,
        IN      MANGLE_FOR eMangleFor,
        IN      GUID *  pGuid
        )

/*++

Routine Description:

    Mangle the name of the current record to avoid name conflicts.

    Currently designed to work only for phantoms.

    A name may be mangled according to a conflict, or as a deletion.

Arguments:

    pDB (IN/OUT)
    eMangleFor (IN)
    pGuid (IN) - guid of the record.

Return Values:

    0 on success, DB_ERR_* on failure.

--*/
{
    GUID    guid;
    WCHAR   szRDN[ MAX_RDN_SIZE ];
    DWORD   cchRDN;
    DWORD   cb;
    DB_ERR  err;
    ATTRVAL AValNewRDN;

    Assert(VALID_DBPOS(pDB));

    // We currently only mangle the ATT_RDN; to handle objects, we'd also need
    // to mangle the value of the class-specific RDN attribute.
    Assert(!DBCheckObj(pDB));

    err = DBGetSingleValue(pDB, ATT_RDN, szRDN, sizeof(szRDN), &cb);
    Assert(!err);

    // prefix complains about cb unassigned,  447348, bogus
    cchRDN = cb / sizeof(WCHAR);

    Assert( (eMangleFor == MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT) ||
            (eMangleFor == MANGLE_PHANTOM_RDN_FOR_DELETION) );

    MangleRDN( eMangleFor, pGuid, szRDN, &cchRDN);

    AValNewRDN.valLen = cchRDN * sizeof(WCHAR);
    AValNewRDN.pVal   = (BYTE *) szRDN;

    err = DBResetRDN(pDB, &AValNewRDN);
    if ( (!err) && (eMangleFor == MANGLE_PHANTOM_RDN_FOR_DELETION) ) {
        // The phantom now has a deleted name.
        // Search through the link table and sever backlinks.
        // See similar code in sbTableUpdatePhantomName

        // BUGBUG wlees 24 Oct 01.
        // What this code does not do is remove any child phantoms that are
        // in the same nc as the phantom nc head. It would be nice to clean them
        // off of this machine as well. As it is we would need to examine every phantom
        // on the machine, determine syntactically whether we think they are in the same
        // nc as the phantom nc head, and remove their backlinks. Perhaps we should
        // store the ncdnt of phantoms, so we can find them and remove them
        // conveniently.  See RAID 486136.

        DBRemoveAllLinks( pDB, pDB->DNT, TRUE /*isbacklink*/ );
    }

    return err;
}


DWORD
DBResetParent(
    DBPOS *pDB,
    DSNAME *pNewParentName,
    ULONG ulFlags
    )

/*++

Routine Description:

    This routine resets an object's parent, decrements the reference count
    on the original parent, and increments the count on the new parent.

Arguments:

    pDB - Pointer, current position in the database table, points to the
        record of the source object (of the move).

    pNewParentName - Pointer, DS name of the destination parent.

    ulFlags - 0 or DBRESETPARENT_CreatePhantomParent (indicates a phantom
        parent should be created if the new parent doesn't exist.

Return Value:

    This routine returns zero if successful, otherwise a DS error code is
    returned.

--*/

{
    THSTATE *pTHS = pDB->pTHS;
    DBPOS *pDBTemp = NULL;
    DWORD *pdwParentDNT = 0;
    DWORD dwParentDNT = 0;
    DWORD dwStatus = 1;
    DWORD dwLength = 0;
    JET_ERR JetErr = 0;
    BOOL fCommit = FALSE;
    d_memname *pname=NULL;
    DWORD     *pAncestors=NULL;
    DWORD      cAncestors = 0;
    ATTCACHE  *pAC;
    DWORD     *pOldAncestors, cOldAncestors, cbOldAncestorsBuff;

    Assert(VALID_DBPOS(pDB));

    // Find the DNT of the new parent name, using a temporary DBPOS so that
    // cursor position associated with pDB is not changed. IsCrossDomain is
    // TRUE when the pNewParentName is in a different domain. It is set to
    // FALSE when simply moving an object within the same domain. Note that
    // in the first release of the product, cross NC moves within the same
    // domain are handled by the LocalModifyDN case (IsCrossDomain == FALSE)
    // while cross NC moves across domains is handled by the RemoteAdd case
    // (IsCrossDomain == TRUE).

    dbInitRec(pDB);

    DBOpen(&pDBTemp);

    __try
    {
     if ( DBRESETPARENT_SetNullNCDNT & ulFlags)
        {
            // The caller wanted the NCDNT to be set to NULL.
            DBResetAtt(pDB,
                       FIXED_ATT_NCDNT,
                       0,
                       NULL,
                       SYNTAX_INTEGER_TYPE);
        }
#if DBG
        else
        {
            // Either the object has no NCDNT, or we are moving within an NCDNT,
            // right?
            DWORD err;
            DWORD ulTempDNT;
            DWORD actuallen;
            
            err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                           pDB->JetObjTbl,
                                           ncdntid,
                                           &ulTempDNT,
                                           sizeof(ulTempDNT),
                                           &actuallen,
                                           JET_bitRetrieveCopy,
                                           NULL);
            
            Assert((err == JET_wrnColumnNull) ||
                   (!err && pDB->NCDNT == ulTempDNT));
        }
#endif

        // In the !cross-domain move case we expect the new parent
        // to exist so we just DBFindDSName to it.  In the cross-domain
        // move case we want the parent to be created as a phantom if it
        // doesn't exist so we leverage that side effect of ExtIntDist.

        if ( DBRESETPARENT_CreatePhantomParent & ulFlags )
        {
            dwStatus = ExtIntDist(pDB,
                                DBSYN_ADD,
                                pNewParentName->structLen,
                                (PUCHAR)(pNewParentName),
                                &dwLength,
                                (UCHAR **)&pdwParentDNT,
                                pDB->DNT,
                                pDB->JetObjTbl,
                                0);
        }
        else
        {
            dwStatus = DBFindDSName(pDBTemp, pNewParentName);
            Assert(0 == dwStatus);

            if ( 0 == dwStatus )
            {
                dwParentDNT = (pDBTemp->DNT);
                pdwParentDNT = &dwParentDNT;
            }
        }

        if ( 0 == dwStatus )
        {
            // get the previous ancestry. needed for notifications
            //
            cbOldAncestorsBuff = sizeof(DWORD) * 12;
            pOldAncestors = THAllocEx(pDB->pTHS, cbOldAncestorsBuff);
            DBGetAncestors(pDB,
                           &cbOldAncestorsBuff,
                           &pOldAncestors,
                           &cOldAncestors);

            // Reset the object's Ancestors to the value of the new parent's
            // ancestors with the DNT of the object concatenated.
            pname = DNread(pDB, *pdwParentDNT, 0);
            
            cAncestors = pname->cAncestors + 1;
            pAncestors = THAllocEx(pTHS,cAncestors * sizeof(DWORD));
            memcpy(pAncestors, pname->pAncestors,
                   pname->cAncestors * sizeof(DWORD));
            pAncestors[cAncestors - 1] = pDB->DNT;

            JetErr = JetSetColumnEx(pDB->JetSessID,
                                    pDB->JetObjTbl,
                                    ancestorsid,
                                    pAncestors,
                                    cAncestors * sizeof(DWORD),
                                    0,
                                    NULL);

            if(0 == JetErr) {
                JetErr = JetSetColumnEx(pDB->JetSessID,
                                        pDB->JetObjTbl,
                                        pdntid,
                                        pdwParentDNT,
                                        sizeof(dwParentDNT),
                                        0,
                                        NULL);
            }
            
            if (0 == JetErr)
            {
                pDB->fEnqueueSDPropOnUpdate = TRUE;
                pDB->fAncestryUpdated = TRUE;
                
                pDB->fFlushCacheOnUpdate = TRUE;

                if ( DBRESETPARENT_CreatePhantomParent & ulFlags )
                {
                    // The reference count on the new parent was incremented
                    // by ExtIntDist, so do not increment it again here.
                    NULL;
                }
                else
                {
                    // Adjust the refcount on the new parent.
                    DBAdjustRefCount(pDB, pDBTemp->DNT, 1);
                }

                // Adjust the refcount on the original parent.
                DBAdjustRefCount(pDB, pDB->PDNT, -1);

                dwStatus = 0;
                fCommit = TRUE;
            }
        }
     
        if ( 0 == dwStatus )
        {
            dbTrackModifiedDNTsForTransaction(
                    pDB,
                    pDB->NCDNT,
                    cOldAncestors,
                    pOldAncestors,
                    TRUE,
                    (( DBRESETPARENT_CreatePhantomParent & ulFlags ) ?
                     MODIFIED_OBJ_intersite_move :
                     MODIFIED_OBJ_intrasite_move));
            
        }
    }
    __finally
    {
        DBClose(pDBTemp, fCommit);
        if (pAncestors) {
            THFreeEx(pTHS,pAncestors);
        }
    }

    // Touch replication meta data for ATT_RDN, which signals to replication
    // that this object has been renamed (new parent, new RDN, or both).
    pAC = SCGetAttById(pDB->pTHS, ATT_RDN);
    // prefix complains about pAC being NULL, 447341, bogus since we are using constant
    Assert(pAC != NULL);
    DBTouchMetaData(pDB, pAC);

    return(dwStatus);
}

DWORD
DBResetParentByDNT(
        DBPOS *pDB,
        DWORD dwParentDNT,
        BOOL  fTouchMetadata

    )

/*++

Routine Description:

    This routine resets an object's parent, decrements the reference count
    on the original parent, and increments the count on the new parent.  Unlike
    DBResetParent, it takes a DNT.

Arguments:

    pDB - Pointer, current position in the database table, points to the
        record of the source object (of the move).

    dwParentDNT - Pointer, DS name of the destination parent.
    
    fTouchMetadata - whether this function should touch the replication 
                     metadata of the object.

Return Value:

    This routine returns zero if successful, otherwise a DS error code is
    returned.

--*/

{
    JET_ERR    err = 0;
    d_memname *pname=NULL;
    DWORD     *pAncestors=NULL;
    DWORD      cAncestors = 0;
    ATTCACHE  *pAC;
    DWORD      ulTempDNT, actuallen;
    DWORD     *pOldAncestors, cOldAncestors, cbOldAncestorsBuff;
    
    Assert(VALID_DBPOS(pDB));

    // We're already inside an update, right?  LocalDelete should take care of
    // this. 
    Assert(pDB->JetRetrieveBits == JET_bitRetrieveCopy);

    // We aren't trying to move objects to be under the root, right?
    Assert(dwParentDNT != ROOTTAG);

    // We should already be flushing the cache for the current
    // object. 
    Assert(pDB->fFlushCacheOnUpdate);
            

    if(dwParentDNT == pDB->PDNT) {
        // already there.
        return 0;
    }

    cbOldAncestorsBuff = sizeof(DWORD) * 12;
    pOldAncestors = THAllocEx(pDB->pTHS, cbOldAncestorsBuff);
    DBGetAncestors(pDB,
                   &cbOldAncestorsBuff,
                   &pOldAncestors,
                   &cOldAncestors);

    // Find the new parent name by DNT, using a the search table on the DBPOS
    // so that cursor position associated with pDB is not changed. This routine
    // should only be called to move objects within an NC.
    JetSetCurrentIndexSuccess(pDB->JetSessID,
                              pDB->JetSearchTbl,
                              NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)

    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl,
                 &dwParentDNT, sizeof(dwParentDNT), JET_bitNewKey);
    
    if (JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ)) {
        return DIRERR_OBJ_NOT_FOUND;
    }

#if DBG
    // We're moving inside a NC, right?
    JetRetrieveColumnSuccess(pDB->JetSessID,
                             pDB->JetSearchTbl,
                             ncdntid,
                             &ulTempDNT,
                             sizeof(ulTempDNT),
                             &actuallen,
                             JET_bitRetrieveCopy,
                             NULL);

    Assert(pDB->NCDNT == ulTempDNT);
#endif    

    // OK we found the new parent.  Reset the object's Ancestors to the value of
    // the new parent's ancestors with the DNT of the object concatenated.
    pname = DNread(pDB, dwParentDNT, 0);
    cAncestors = pname->cAncestors + 1;
    // Don't use alloca, they might have a huge number of ancestors.
    pAncestors = THAllocEx(pDB->pTHS, cAncestors * sizeof(DWORD));
    memcpy(pAncestors, pname->pAncestors,
           pname->cAncestors * sizeof(DWORD));
    pAncestors[cAncestors - 1] = pDB->DNT;
    
    err = JetSetColumnEx(pDB->JetSessID,
                         pDB->JetObjTbl,
                         ancestorsid,
                         pAncestors,
                         cAncestors * sizeof(DWORD),
                         0,
                         NULL);
    
    THFreeEx(pDB->pTHS, pAncestors);
    
    if(err) {
        return DIRERR_UNKNOWN_ERROR;
    }
    
    if(JetSetColumnEx(pDB->JetSessID,
                      pDB->JetObjTbl,
                      pdntid,
                      &dwParentDNT,
                      sizeof(dwParentDNT),
                      0,
                      NULL)) {
        return DIRERR_UNKNOWN_ERROR;
    }
    
    // We have to always enqueue an SD propagation when the parent
    // is changed, even if there are no children. This ensures that
    // the object gets the inheritable aces from the new parent.
    pDB->fEnqueueSDPropOnUpdate = TRUE;
    pDB->fAncestryUpdated = TRUE;
    
    // Adjust the refcount on the new parent.
    DBAdjustRefCount(pDB, dwParentDNT, 1);
    
    // Adjust the refcount on the original parent.
    DBAdjustRefCount(pDB, pDB->PDNT, -1);
    
    dbTrackModifiedDNTsForTransaction(
            pDB,
            pDB->NCDNT,
            cOldAncestors,
            pOldAncestors,
            TRUE,
            MODIFIED_OBJ_intrasite_move);
    

    // Touch replication meta data for ATT_RDN, which signals to replication
    // that this object has been renamed (new parent, new RDN, or both).
    if (fTouchMetadata) {
        pAC = SCGetAttById(pDB->pTHS, ATT_RDN);
        Assert(pAC != NULL);
        // prefix complains about pAC being NULL, 447342, bogus since we are using constant

        DBTouchMetaData(pDB, pAC);
    }

    return 0;
}

ULONG
DBResetDN(
    IN  DBPOS *     pDB,
    IN  DSNAME *    pParentDN,
    IN  ATTRVAL *   pAttrValRDN
    )
/*++

Routine Description:

    Reset the DN of the record (phantom or object) to that given.

    Note that we assume the RDN type (e.g., CN, DC, OU, ...) is unchanged,
    though this could easily be remedied if needed.

Arguments:

    pDB (IN) - Has currency on the record for which the DN is to be reset.

    pParentDN (IN) - DSNAME of the record's new parent.

    pAttrRDN (IN) - The record's new RDN (or NULL to leave RDN as-is).

Return Values:

    0 - Success.

--*/
{
    THSTATE     *pTHS = pDB->pTHS;
    JET_ERR     JetErr = 0;
    d_memname * pname=NULL;
    DWORD *     pAncestors=NULL;
    DWORD       cAncestors = 0;
    ATTCACHE *  pAC;
    BOOL        fIsObject;
    ULONG       PDNT;
    ULONG       dbError;

    // Prepare for update if we haven't already done so.
    dbInitRec(pDB);

    dbError = sbTableGetTagFromDSName(pDB, pParentDN, 0, &PDNT, &pname);
    if (dbError && (ERROR_DS_NOT_AN_OBJECT != dbError)) {
        return dbError;
    }

    if (pname) {
        // The 99%+ case - the parent is not ROOT

        // Reset the object's Ancestors to the value of the new parents
        // ancestors with the DNT of the object concatenated.
        cAncestors = pname->cAncestors + 1;
        pAncestors = THAllocEx(pTHS, cAncestors * sizeof(DWORD));
        memcpy(pAncestors,
               pname->pAncestors,
               pname->cAncestors * sizeof(DWORD));
        pAncestors[cAncestors - 1] = pDB->DNT;
    }
    else {
        Assert(IsRoot(pParentDN));

        cAncestors = 2;
        pAncestors = THAllocEx(pTHS,cAncestors * sizeof(DWORD));
        pAncestors[0] = ROOTTAG;
        pAncestors[1] = pDB->DNT;
    }

    fIsObject = DBCheckObj(pDB);

    JetErr = JetSetColumnEx(pDB->JetSessID,
                            pDB->JetObjTbl,
                            ancestorsid,
                            pAncestors,
                            cAncestors * sizeof(DWORD),
                            0,
                            NULL);
    Assert(0 == JetErr);

    THFreeEx(pTHS,pAncestors);

    if (0 == JetErr) {
        // Reset PDNT.
        JetErr = JetSetColumnEx(pDB->JetSessID,
                                pDB->JetObjTbl,
                                pdntid,
                                &PDNT,
                                sizeof(PDNT),
                                0,
                                NULL);
        Assert(0 == JetErr);
    }

    if ((0 == JetErr) && (NULL != pAttrValRDN)) {
        // Reset RDN.
        JetErr = JetSetColumnEx(pDB->JetSessID,
                                pDB->JetObjTbl,
                                rdnid,
                                pAttrValRDN->pVal,
                                pAttrValRDN->valLen,
                                0,
                                NULL);

        if ((0 == JetErr) && fIsObject) {
            // Touch replication meta data for this attribute.
            pAC = SCGetAttById(pDB->pTHS, ATT_RDN);
            Assert(pAC != NULL);
            DBTouchMetaData(pDB, pAC);
        }
    }

    if (0 == JetErr) {
        if (fIsObject) {
            pDB->fEnqueueSDPropOnUpdate = TRUE;
            pDB->fAncestryUpdated = TRUE;
        }
        
        pDB->fFlushCacheOnUpdate = TRUE;

        // Adjust the refcount on the new parent.
        DBAdjustRefCount(pDB, PDNT, 1);

        // Adjust the refcount on the original parent.
        DBAdjustRefCount(pDB, pDB->PDNT, -1);

        pDB->PDNT = PDNT;
    }

    return JetErr ? DB_ERR_SYSERROR : 0;
}


void
DBCoalescePhantoms(
    IN OUT  DBPOS * pDB,
    IN      ULONG   dntRefPhantom,
    IN      ULONG   dntStructPhantom
    )
/*++

Routine Description:

    Collapses references to dntStructPhantom to dntRefPhantom as follows:
    
    (1) moves all children of dntStructPhantom to be children of dntRefPhantom
    (2) asserts that, with the pending escrowed update ref count changes,
        dntStructPhantom has no further references
    (3) generates a guid G and mangles dntStructPhantom from its original
        string name S to its new string name mangle(S, G)
    (4) renames dntRefPhantom to S
    
    Note that step (3) violates the general rule that you can always unmangle
    a mangled RDN to produce its objectGuid, as in this case we don't have the
    objectGuid with which to mangle the name (since it's a structural phantom,
    which by definition has no guid).  However, following this routine
    dntStructPhantom will have no remaining references and therefore these
    semantics are no longer important.
    
    One might declare that instead of renaming dntStructPhantom we could simply
    delete its record, but in the case of gamma rays causing the above refcount
    assertion to fail, it's far better not to have references to DNTs that no
    longer exist and instead opt to allow them to expire through normal garbage
    collection.
    
    This routine is intended to be invoked when an existing GUIDed phantom needs
    its string name changed, but that string name is already occupied by an
    existing phantom with no GUID.

Arguments:

    pDB (IN/OUT)

    dntRefPhantom (IN) - On successful return, acquires the string name of
        dntStructPhantom and receives all of dntStructPhantom's children.

    dntStructPhantom (IN) - On successful return, has no remaining references
        and is name munged, quietly awaiting its garbage collection.

Return Values:

    None.  Throws exception on catastrophic failure.

--*/
{
    DWORD   err;
    DWORD   cbAncestorsSize = 0;
    DWORD * pdntAncestors = NULL;
    DWORD   cNumAncestors = 0;
    int     cNumChildren = 0;
    GUID    guid;
    WCHAR   rgwchRDN[MAX_RDN_SIZE];
    DWORD   cbRDN;
    ATTRTYP rdnType;
    DWORD   cbActual;
    DWORD   DNT;
    DWORD   PDNT;
#if DBG
    DWORD   cnt;
#endif

    //
    // Move all children of dntStructPhantom to be children of dntRefPhantom.
    //

    // Retrieve the ancestors of dntStructPhantom.
    if (err = DBFindDNT(pDB, dntStructPhantom)) {
        DsaExcept(DSA_DB_EXCEPTION, err, dntStructPhantom);
    }

    Assert(!DBCheckObj(pDB));
    Assert(!DBHasValues(pDB, ATT_OBJECT_GUID));

    if ((err = DBGetSingleValue(pDB, ATT_RDN, rgwchRDN,
                                sizeof(rgwchRDN), &cbRDN))
        || (err = DBGetSingleValue(pDB, FIXED_ATT_RDN_TYPE, &rdnType,
                                   sizeof(rdnType), NULL))) {
        DsaExcept(DSA_DB_EXCEPTION, err, dntStructPhantom);
    }

#if DBG
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, cntid,
                             &cnt, sizeof(cnt), &cbActual,
                             JET_bitRetrieveCopy, NULL);
#endif

    dbGetAncestorsSlowly(pDB, pDB->DNT, &cbAncestorsSize, &pdntAncestors, &cNumAncestors);
    if (cNumAncestors < 2) {
        // Can't replace root!
        DsaExcept(DSA_DB_EXCEPTION, DIRERR_INTERNAL_FAILURE, dntStructPhantom);
    }

    if (cbAncestorsSize < (cNumAncestors + 1) * sizeof(*pdntAncestors)) {
        // Make room for an additional DNT at the end of the ancestors list.
        cbAncestorsSize = (cNumAncestors + 1) * sizeof(*pdntAncestors);
        pdntAncestors = THReAllocEx(pDB->pTHS, pdntAncestors, cbAncestorsSize);
    }

    Assert(pdntAncestors[cNumAncestors-1] == dntStructPhantom);
    pdntAncestors[cNumAncestors-1] = dntRefPhantom;

    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetSearchTbl,
                               SZPDNTINDEX,
                               &idxPdnt,
                               JET_bitMoveFirst);
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetSearchTbl,
                 &dntStructPhantom,
                 sizeof(dntStructPhantom),
                 JET_bitNewKey);
    
    err = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekGE);
    if (JET_wrnSeekNotEqual == err) {
        err = 0;
    }

    while (0 == err) {
        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 pDB->JetSearchTbl,
                                 pdntid,
                                 &PDNT,
                                 sizeof(PDNT),
                                 &cbActual,
                                 JET_bitRetrieveFromIndex,
                                 NULL);
        if (PDNT != dntStructPhantom) {
            // No more children.
            break;
        }

        // Found a direct child of dntStructPhantom.  Reset its PDNT & ancestors
        // to make it a child of dntRefPhantom.
        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 pDB->JetSearchTbl,
                                 dntid,
                                 &DNT,
                                 sizeof(DNT),
                                 &cbActual,
                                 0,
                                 NULL);
        pdntAncestors[cNumAncestors] = DNT;

        JetPrepareUpdateEx(pDB->JetSessID,
                           pDB->JetSearchTbl,
                           DS_JET_PREPARE_FOR_REPLACE);

        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, ancestorsid,
                       pdntAncestors,
                       (cNumAncestors + 1) * sizeof(*pdntAncestors), 0, NULL);
        
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, pdntid,
                       &dntRefPhantom, sizeof(dntRefPhantom), 0, NULL);

        JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);
        dbFlushDNReadCache(pDB, DNT);

        cNumChildren++;
        
        // Move on to next (potential) child.
        err = JetMove(pDB->JetSessID, pDB->JetSearchTbl, JET_MoveNext, 0);
    }
    
    // Adjust refcounts.
    if (cNumChildren) {
        DBAdjustRefCount(pDB, dntRefPhantom, cNumChildren);
        DBAdjustRefCount(pDB, dntStructPhantom, -cNumChildren);
    }

    
    //
    // Assert that, with the pending escrowed update ref count changes,
    // dntStructPhantom has no further references.
    //

    Assert(cnt == (DWORD) cNumChildren);

    
    //
    // Generate a guid G and mangle dntStructPhantom from its original string
    // name S to its new string name mangle(S, G).
    //

    DsUuidCreate(&guid);
    Assert(pDB->DNT == dntStructPhantom);
    if ((err = DBMangleRDNforPhantom(pDB, MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT, &guid))
        || (err = DBUpdateRec(pDB))) {
        DsaExcept(DSA_DB_EXCEPTION, err, dntStructPhantom);
    }
     
    
    //
    // Rename dntRefPhantom to S.
    //

    if (err = DBFindDNT(pDB, dntRefPhantom)) {
        DsaExcept(DSA_DB_EXCEPTION, err, dntRefPhantom);
    }

    Assert(!DBCheckObj(pDB));
    Assert(DBHasValues(pDB, ATT_OBJECT_GUID));

    JetPrepareUpdateEx(pDB->JetSessID,
                       pDB->JetObjTbl,
                       DS_JET_PREPARE_FOR_REPLACE);

    // Ancestors.
    Assert(pdntAncestors[cNumAncestors-1] == dntRefPhantom);
    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, ancestorsid,
                   pdntAncestors, cNumAncestors * sizeof(*pdntAncestors),
                   0, NULL);
    
    // PDNT.
    JetSetColumnEx(pDB->JetSessID,
                   pDB->JetObjTbl,
                   pdntid,
                   &pdntAncestors[cNumAncestors-2],
                   sizeof(pdntAncestors[cNumAncestors-2]),
                   0,
                   NULL);

    // RDN.
    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, rdnid,
                   rgwchRDN, cbRDN, 0, NULL);

    // RDN type.
    // The rdnType is stored in the DIT as the msDS_IntId, not the
    // attributeId. This means an object retains its birth name
    // even if unforeseen circumstances allow the attributeId
    // to be reused. No need to convert here because rdnType
    // was read from the DIT above.
    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, rdntypid,
                   &rdnType, sizeof(rdnType), 0, NULL);

    // Enqueue a propagation to ensure that all descendants of dntRefPhantom
    // get their ancestors column properly updated.
    if (err = DBEnqueueSDPropagationEx(pDB, FALSE, SDP_NEW_ANCESTORS)) {
        DsaExcept(DSA_DB_EXCEPTION, err, dntStructPhantom);
    }

    JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);
    dbFlushDNReadCache(pDB, dntRefPhantom);

    THFreeEx(pDB->pTHS, pdntAncestors);

#ifdef INCLUDE_UNIT_TESTS
    // Test hook for refcount test.
    gLastGuidUsedToCoalescePhantoms = guid;
#endif
}

#ifdef INCLUDE_UNIT_TESTS
void
AncestorsTest(
        )
{
    THSTATE   *pTHS = pTHStls;
    DBPOS     *pDB;
    DWORD      ThisDNT, ThisPDNT, cThisAncestors, cParentAncestors;
    DWORD      pThisAncestors[500], pParentAncestors[500];
    DWORD      cbActual;
    d_memname *pname;
    DWORD      err, i, count=0;
    wchar_t    NameBuff[512];
    
    DPRINT(0, "Beginning Ancestors test\n");
    DBOpen2(TRUE, &pTHS->pDB);
    __try {
        pDB = pTHS->pDB;
        
        // Walk the DNT index, get the ancestors of each object, get the
        // parent's ancestors, check em.
        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetObjTbl,
                                  NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)

        err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveFirst, 0);
        
        while(!err) {
            count++;
            if(!(count % 100)) {
                DPRINT2(0,
                        "Ancestors test, current DNT = %X, iteration = %d\n",
                        ThisDNT, count);
            }
            
            // Get the ancestors, the dnt, and the pdnt
            err = JetRetrieveColumn(pDB->JetSessID,
                                    pDB->JetObjTbl,
                                    dntid,
                                    &ThisDNT,
                                    sizeof(ThisDNT),
                                    &cbActual,
                                    0,
                                    NULL);
            if(err) {
                DPRINT2(0, "Failed to get DNT, %X (last DNT was %X)\n", err,
                        ThisDNT);
                goto move;
            }

            if(ThisDNT == 1) {
                // DNT 1 has no PDNT or ancestors
                goto move;
            }
            
            err = JetRetrieveColumn(pDB->JetSessID,
                                    pDB->JetObjTbl,
                                    pdntid,
                                    &ThisPDNT,
                                    sizeof(ThisPDNT),
                                    &cbActual,
                                    0,
                                    NULL);
            if(err) {
                DPRINT2(0, "(%X), Failed to get PDNT, %X\n", ThisDNT,err);
                goto move;
            }
            err = JetRetrieveColumn(pDB->JetSessID,
                                    pDB->JetObjTbl,
                                    ancestorsid,
                                    pThisAncestors,
                                    500 * sizeof(DWORD),
                                    &cbActual,
                                    0,
                                    NULL);
            if(err) {
                DPRINT2(0, "(%X), Failed to get ancestors, %X\n", ThisDNT,err);
                goto move;
            }
            cThisAncestors = cbActual /sizeof(DWORD);
            
            pname = DNread(pDB, ThisDNT, 0);
            memset(NameBuff, 0, sizeof(NameBuff));
            memcpy(NameBuff, pname->tag.pRdn, pname->tag.cbRdn);
            
            // First, make sure that the DNread cache has the correct info
            if(pname->cAncestors != cThisAncestors) {
                DPRINT1(0,"RDN = %S\n",NameBuff);
                DPRINT3(0, "DNT %X, count of ancestors from disk (%d) != "
                        "from DNread cache (%d).\n", ThisDNT,
                        cThisAncestors, pname->cAncestors );
                for(i=0;i<min(cThisAncestors, pname->cAncestors);i++) {
                    DPRINT2(0, "Disk-%X, Cache-%X.\n", pThisAncestors[i],
                            pname->pAncestors[i]);
                }
                goto move;
            }
            if(memcmp(pname->pAncestors, pThisAncestors, cbActual)) {
                DPRINT1(0,"RDN = %S\n",NameBuff);
                DPRINT1(0,"DNT %X, ancestors from disk != from DNread cache.\n",
                        ThisDNT);
                for(i=0;i<cThisAncestors;i++) {
                    DPRINT2(0, "Disk-%X, Cache-%X.\n", pThisAncestors[i],
                            pname->pAncestors[i]);
                }
                goto move;
            }
            if(pThisAncestors[cThisAncestors - 1] != ThisDNT) {
                DPRINT1(0,"RDN = %S\n",NameBuff);
                DPRINT3(0, "DNT %X, final ancestor (%X) != DNT (%X).\n",
                        ThisDNT, pThisAncestors[cThisAncestors - 1], ThisPDNT);
                goto move;
            }

            if(ThisDNT == ROOTTAG) {
                // ROOTTAG should have 1 ancestor, itself.  It has no parent, so
                // verify the ancestors and then  skip the rest of the
                // test.
                if((cThisAncestors != 1) || (pThisAncestors[0] != ROOTTAG)) {
                    DPRINT1(0,"RDN = %S\n",NameBuff);
                    DPRINT1(0,
                            "Root has wrong ancestors count (%d) or val.\n",
                            cThisAncestors);
                    for(i=0;i<cThisAncestors;i++) {
                        DPRINT1(0, "Ancestors, -%X.\n", pThisAncestors[i]);
                    }
                }
                    
                goto move;
            }
            

            // OK, now find the parent and get it's ancestors
            if(err = JetSetCurrentIndexWarnings(pDB->JetSessID,
                                                pDB->JetSearchTbl,
                                                NULL)) {    // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)
                DPRINT2(0, "(%X), couldn't set search table to dntindex, %X.\n",
                        ThisDNT, err);
                goto move;
            }

            
            JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, 
                         &ThisPDNT, sizeof(ThisPDNT), JET_bitNewKey);
            
            if (err = JetSeekEx(pDB->JetSessID,
                                pDB->JetSearchTbl, JET_bitSeekEQ)) {
                if(err) {
                    DPRINT3(0, "(%X), Failed to move to (%X), %X\n",
                            ThisDNT,ThisPDNT, err);
                    goto move;
                }
                // Huh? couldn't find it.
            }
            
            err = JetRetrieveColumn(pDB->JetSessID,
                                    pDB->JetSearchTbl,
                                    ancestorsid,
                                    pParentAncestors,
                                    100 * sizeof(DWORD),
                                    &cbActual,
                                    0,
                                    NULL);
            cParentAncestors = cbActual /sizeof(DWORD);
            if(err) {
                if(ThisPDNT == ROOTTAG) {
                    // This is ok.
                }
                else {
                    DPRINT2(0, "PDNT (%X), Failed to get ancestors, %X\n",
                            ThisPDNT,err);
                    goto move;
                }
            }
                
            
            if(cParentAncestors + 1 != cThisAncestors) {
                DPRINT1(0,"RDN = %S\n",NameBuff);
                DPRINT4(0,
                        "DNT %X, anc. size (%d) !=PDNT %X, anc. size (%d) +1\n",
                        ThisDNT, cThisAncestors, ThisPDNT, cParentAncestors);
                if(!memcmp(
                        pParentAncestors,pThisAncestors,
                        min(cThisAncestors,cParentAncestors) * sizeof(DWORD))) {
                    DPRINT(0,"Value equal through lesser count.\n");
                }
                else {
                    for(i=0;i<(min(cThisAncestors,cParentAncestors));i++) {
                        DPRINT2(0, "This-%X, Parent-%X.\n", pThisAncestors[i],
                                pParentAncestors[i]);
                    }
                }
                goto move;
            }
            if(memcmp(pParentAncestors, pThisAncestors, cbActual)) {
                DPRINT1(0,"RDN = %S\n",NameBuff);
                DPRINT1(0,
                        "DNT %X, ancestors != parents ancestors + PDNT.\n",
                        ThisDNT); 
                for(i=0;i<cParentAncestors;i++) {
                    DPRINT2(0, "This-%X, Parent-%X.\n", pThisAncestors[i],
                            pParentAncestors[i]);
                }
                goto move;
            }
             
        move:
            err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveNext, 0);
        }
    }
    __finally {
        DBClose(pTHS->pDB, TRUE);
    }

    DPRINT(0, "Completed Ancestors test\n");
    return;
}
        
#endif
 

DWORD
DBFindChildAnyRDNType (
        DBPOS *pDB,
        DWORD PDNT,
        WCHAR *pRDN,
        DWORD ccRDN
        )
/*++
  Description:
      Find a child of the DNT passed in that uses the RDN specified, ignoring
      RDN type.

  Parameters:      
      pDB   - dbpos to use
      pDNT  - the DNT of the proposed parent
      pRDN  - pointer to the RDN value we're looking for
      ccRDN - number of characters in pRDN

  Return:
      0 if we found the object requested.  Currency is placed on this object.

      ERROR_DS_NOT_AN_OBJECT if we found the object requested but it wasn't an
        object.  In this case, we put currency on the phantom found.

      ERROR_DS_KEY_NOT_UNIQUE if we didn't find an object with the requested
        name, but did find an object with the same key in the PDNT-RDN index.
        In this case, we put currency on the object found.

      ERROR_DS_OBJ_NOT_FOUND if we couldn't find anything with that name or that
        key. 

      Assorted other errors may be returned (DNChildFind errors).
--*/
{
    DWORD           ret, err;
    BOOL            fIsRecordCurrent;
    d_memname       *pname=NULL;
    BOOL            fOnPDNTIndex = FALSE;

    ret = DNChildFind(pDB,
                      pDB->JetObjTbl,
                      FALSE,
                      PDNT,
                      pRDN,
                      ccRDN * sizeof(WCHAR),
                      0,
                      &pname,
                      &fIsRecordCurrent,
                      &fOnPDNTIndex);
    switch(ret) {
    case 0:
        // Found an object with the requested RDN (ignoring attrtyp)
        Assert(pname);
        if (!fIsRecordCurrent) {
            // Record was found through the cache, but caller wants currency;
            // give it to him.
            JetSetCurrentIndexSuccess(pDB->JetSessID,
                                      pDB->JetObjTbl,
                                      NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)

            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetObjTbl,
                         &pname->DNT,
                         sizeof(pname->DNT),
                         JET_bitNewKey);
            
            if (err = JetSeekEx(pDB->JetSessID,
                                pDB->JetObjTbl,
                                JET_bitSeekEQ)) {
                DsaExcept(DSA_DB_EXCEPTION, err, pname->DNT);
            }
            
        }
        
        // Currency has been successfully changed; update pDB state.
        dbMakeCurrent(pDB, pname);
        
        if (!pname->objflag) {
            // Found a phantom; return distinct error code.
            // NOTE THAT THE ROOT *IS* AN OBJECT.
            ret = ERROR_DS_NOT_AN_OBJECT;
        }
        break;

    case ERROR_DS_KEY_NOT_UNIQUE:
        // No objects with the requested name exist, but an object with the same
        // key exists (and DB currency is pointing at it)
        dbMakeCurrent(pDB, NULL);
        break;

    default:
        // Only one other error code is expected.
        Assert(ret == ERROR_DS_OBJ_NOT_FOUND);
        break;
    }
    
    return ret;
}
 
VOID
MoveOrphanedObject(
    void *  pv,
    void ** ppvNext,
    DWORD * pcSecsUntilNextIteration
    )
/**
 * Move orphaned object (missing parent or loop in PDNT chain).
 * pv contains the DNT of the object being moved.
 * The RDN is CNF-mangled to avoid potential conflicts.
 * 
 **/
{
    THSTATE *pTHS = pTHStls;
    DWORD dwNewParentDNT, dwOldParentDNT;
    DWORD dwObjDNT = PtrToUlong(pv);
    BOOL  fIsObject;
    WCHAR szRDN[MAX_RDN_SIZE];
    DWORD cchRDN;
    GUID  objGuid;
    DWORD dwErr = ERROR_SUCCESS;
    ATTCACHE* pAC;
    PUCHAR pNewDN;
    DBPOS* pDB = NULL;
    ULONG dwException, dsid;
    PVOID dwEA;
    BOOL  fHasGuid = FALSE;

    __try {
        DBOpen(&pDB);
        __try {
            dwErr = DBTryToFindDNT(pDB, dwObjDNT);
            if (dwErr) {
                // the object got deleted. Ah well, nothing to fix then.
                dwErr = ERROR_SUCCESS;
                __leave;
            }

            // do we have an old PDNT?
            dwErr = DBTryToFindDNT(pDB, pDB->DNT);
            if (dwErr) {
                // no parent
                dwOldParentDNT = INVALIDDNT;
                dwErr = ERROR_SUCCESS;
            }
            else {
                dwOldParentDNT = pDB->DNT;
            }

            // move back to the object
            DBFindDNT(pDB, dwObjDNT);
            fIsObject = DBCheckObj(pDB);

            if (fIsObject) {
                // find an appropriate L&F container
                NAMING_CONTEXT_LIST* pNCL = FindNCLFromNCDNT(pDB->NCDNT, FALSE);
                if (pNCL == NULL) {
                    // weird. No NC for this live object?
                    LooseAssert(!"Expected NC not found", GlobalKnowledgeCommitDelay);
                    dwErr = ERROR_DS_INTERNAL_FAILURE;
                    __leave;
                }
                dwNewParentDNT = pNCL->LostAndFoundDNT;

                // make sure we are not moving under one of our descendants
                DBFindDNT(pDB, dwNewParentDNT);
                do {
                    if (pDB->DNT == dwObjDNT) {
                        // No good. L&F container is our descendant. Can't move.
                        // That means L&F container has lost its parent or
                        // the NC itself has lost its parent. They are really doomed.
                        dwNewParentDNT = ROOTTAG;
                        break;
                    }
                    if (pDB->PDNT == ROOTTAG) {
                        break;
                    }
                    DBFindDNT(pDB, pDB->PDNT);
                } while (TRUE);
                // move back to the object being moved.
                DBFindDNT(pDB, dwObjDNT);
            }
            else {
                // move phantoms under root
                dwNewParentDNT = ROOTTAG;
            }

            DPRINT3(0, "Moving orphaned object: DNT=%d, old PDNT=%d, new PDNT=%d\n", pDB->DNT, pDB->PDNT, dwNewParentDNT);

            pDB->fFlushCacheOnUpdate = TRUE;

            // get object's GUID
            dwErr = DBGetSingleValue(pDB, ATT_OBJECT_GUID, &objGuid, sizeof(objGuid), NULL);
            if (dwErr == DB_ERR_NO_VALUE) {
                // Too bad, no guid. Let's make one.
                Assert(!fIsObject);
                DsUuidCreate(&objGuid);
                fHasGuid = FALSE;
            }
            else {
                fHasGuid = TRUE;
            }

            // Get the RDN
            dwErr = DBGetSingleValue(pDB, ATT_RDN, szRDN, sizeof(szRDN), &cchRDN);
            if (dwErr) {
                DsaExcept(DSA_DB_EXCEPTION, ERROR_DS_MISSING_EXPECTED_ATT, 0);
            }
            cchRDN /= sizeof(WCHAR);

            // mangle the RDN to avoid write conflicts
            MangleRDN(fIsObject ? MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT : MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT, 
                      &objGuid,
                      szRDN,
                      &cchRDN);

            DBInitRec(pDB);
            // set PDNT
            JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, pdntid, &dwNewParentDNT, sizeof(dwNewParentDNT), 0, NULL);
            // Adjust the refCount on the new parent
            DBAdjustRefCount(pDB, dwNewParentDNT, 1);

            if (dwOldParentDNT != INVALIDDNT) {
                // Adjust the refCount on the old parent
                DBAdjustRefCount(pDB, dwOldParentDNT, -1);
            }

            // schedule an SD propagation to fixup ancestry.
            pDB->fEnqueueSDPropOnUpdate = TRUE;
            pDB->fAncestryUpdated = TRUE;

            // set RDN
            JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, rdnid, szRDN, cchRDN*sizeof(WCHAR), 0, NULL);
            if (fIsObject) {
                // also, update the rdnType attribute
                DWORD attRdnTyp;

                dwErr = DBGetSingleValue(pDB, FIXED_ATT_RDN_TYPE, &attRdnTyp, sizeof(attRdnTyp), NULL);
                Assert(dwErr == DB_success);
                pAC = SCGetAttById(pTHS, attRdnTyp);
                Assert(pAC);
                dwErr = DBReplaceAttVal_AC(pDB, 1, pAC, cchRDN*sizeof(WCHAR), szRDN);
                Assert(dwErr == DB_success);

                // for live objects, make this an originating mod.
                pAC = SCGetAttById(pTHS, ATT_RDN);
                Assert(pAC != NULL);
                DBTouchMetaData(pDB, pAC);

                DBRepl(pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);

                // Currency of DBPOS must be at the target object
                DBNotifyReplicasCurrDbObj(pDB, FALSE);
            }
            else {
                DBUpdateRec(pDB);
            }

            // get the new object DN for logging
            pNewDN = DBGetExtDnFromDnt(pDB, pDB->DNT);
            
            dwErr = ERROR_SUCCESS;
        }
        __finally {
            DBClose(pDB, dwErr == ERROR_SUCCESS && !AbnormalTermination());
            if (!AbnormalTermination() && dwErr != ERROR_SUCCESS) {
                LogUnhandledErrorAnonymous(dwErr);
            }
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException, &dwEA, &dwErr, &dsid)) 
    {
        DoLogUnhandledError(dsid, dwErr, FALSE);
    }

    if (dwErr == ERROR_SUCCESS && pNewDN) {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_ORPHANED_OBJECT_MOVED,
                 fHasGuid ? szInsertUUID(&objGuid) : szInsertSz("(n/a)"),
                 szInsertSz(pNewDN),
                 NULL);
    }
    if (pNewDN) {
        THFreeEx(pTHS, pNewDN);
    }

    // if we failed for whatever reason, then retry in one minute
    *pcSecsUntilNextIteration = dwErr ? 60 : TASKQ_DONT_RESCHEDULE;
}

#ifdef INCLUDE_UNIT_TESTS

#define CORRUPT_NONE            0
#define CORRUPT_INVALID_PDNT    1
#define CORRUPT_PDNT_CHAIN_LOOP 2
#define CORRUPT_REMOVE_GUID     3

struct _CorruptDbOp {
    PCHAR szOp;
    DWORD opCode;
} corruptDbOps[] = {
    { "invalidPDNT:",     CORRUPT_INVALID_PDNT },           // usage: invalidPDNT:dn
    { "pdntChainLoop:",   CORRUPT_PDNT_CHAIN_LOOP },        // usage: pdntChainLoop:[levels:]dn
                                                            // if levels X (0..9) is specified, then creates
                                                            // a loop from X levels up down to the DN.
                                                            // If X is not specified or is zero, then
                                                            // make dn its own parent.
    { "removeGUID:",      CORRUPT_REMOVE_GUID },            // usage: removeGUID:dn (sets NULL guid)
    { NULL,               0                    }
};

DWORD
CorruptDB(THSTATE* pTHS, IN PCHAR pBuf) {
    LPWSTR pszWideDN = NULL;
    DWORD dwRet;
    DSNAME *pDN = NULL;
    DWORD dwNewPDNT;
    DWORD opCode = CORRUPT_NONE;
    DWORD i, levels;
    PCHAR pOriginalBuf = pBuf;

    for (i = 0; corruptDbOps[i].szOp != NULL; i++) {
        if (_strnicmp(pBuf, corruptDbOps[i].szOp, strlen(corruptDbOps[i].szOp)) == 0) {
            opCode = corruptDbOps[i].opCode;
            pBuf += strlen(corruptDbOps[i].szOp);
            break;
        }
    }

    switch(opCode) {
    case CORRUPT_INVALID_PDNT:
        dwNewPDNT = INVALIDDNT;
        // fall through to get the DN
        break;
    case CORRUPT_PDNT_CHAIN_LOOP:
        // get levels
        if (pBuf[0] >= '0' && pBuf[0] <= '9' && pBuf[1] == ':') {
            // levels param is specified
            levels = pBuf[0] - '0';
            pBuf += 2;
        }
        else {
            levels = 0;
        }
        break;

    case CORRUPT_REMOVE_GUID:
        break;

    default:
        return ERROR_INVALID_PARAMETER;
    }

    // parse the DN
    pszWideDN = UnicodeStringFromString8( CP_UTF8, pBuf, strlen(pBuf));
    Assert( pszWideDN );

    dwRet = UserFriendlyNameToDSName( pszWideDN, wcslen( pszWideDN ), &pDN );
    if (dwRet) {
        DPRINT1( 0, "DSNAME conversion failed, string=%ws\n", pszWideDN );
        return dwRet;
    }

    SYNC_TRANS_WRITE();

    try {
        dwRet = DBFindDSName(pTHS->pDB, pDN);
        if (dwRet && dwRet != DIRERR_NOT_AN_OBJECT) {
            DPRINT1( 0, "DSNAME %ws not found\n", pDN->StringName );
            __leave;
        }
        dwRet = ERROR_SUCCESS;

        if (opCode == CORRUPT_REMOVE_GUID) {
            DBRemAtt(pTHS->pDB, ATT_OBJECT_GUID);
            DBUpdateRec(pTHS->pDB);
            __leave;
        }

        if (opCode == CORRUPT_PDNT_CHAIN_LOOP) {
            dwNewPDNT = pTHS->pDB->DNT;
            if (levels > 0) {
                PDSNAME pNewDN;
                pNewDN = (PDSNAME)THAllocEx(pTHS, pDN->structLen);
                dwRet = TrimDSNameBy(pDN, levels, pNewDN);
                if (dwRet) {
                    // failed to trim the DN
                    DPRINT3( 0, "Failed to trim DSNAME %ws by %d, err=%d\n", pDN->StringName, levels, dwRet );
                    __leave;
                }
                THFreeEx(pTHS, pDN);
                pDN = pNewDN;
                // move to the ancestor
                dwRet = DBFindDSName(pTHS->pDB, pNewDN);
                if (dwRet && dwRet != DIRERR_NOT_AN_OBJECT) {
                    DPRINT1( 0, "DSNAME %ws not found\n", pNewDN->StringName );
                    __leave;
                }
                dwRet = ERROR_SUCCESS;
            }
        }

        DBInitRec(pTHS->pDB);
        
        // deref the current parent
        DBAdjustRefCount(pTHS->pDB, pTHS->pDB->PDNT, -1);

        if (dwNewPDNT != INVALIDDNT) {
            // ref the new parent
            DBAdjustRefCount(pTHS->pDB, dwNewPDNT, 1);
        }

        JetSetColumnEx(pTHS->pDB->JetSessID, 
                       pTHS->pDB->JetObjTbl,
                       pdntid,
                       &dwNewPDNT, sizeof(dwNewPDNT),
                       0, NULL);

        // we want to remove the object from the cache.
        pTHS->pDB->fFlushCacheOnUpdate = TRUE;

        DBUpdateRec(pTHS->pDB);
    } finally {
        CLEAN_BEFORE_RETURN(dwRet);
    }
    if (dwRet == ERROR_SUCCESS) {
        DPRINT1(0, "CorruptDB: %s success\n", pOriginalBuf);
    }
    return dwRet;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbtools.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dbtools.c
//
//--------------------------------------------------------------------------

/*
Description:
    Various tools for the DB layer.

*/
#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <mdlocal.h>                    // For dsatools.h
#include <dsatools.h>                   // For pTHStls

#include <dstaskq.h>
#include <crypt.h>                      // for samisrv.h
#include <samrpc.h>                     // for samisrv.h
#include <lsarpc.h>                     // for samisrv.h
#include <samisrv.h>                    // for nlrepl.h
#include <nlrepl.h>                     // For NetLogon notifications
#include <mappings.h>
#include <dsconfig.h>
#include <ntdskcc.h>                    // KccExecuteTask
#include <anchor.h>

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>

// Assorted DSA headers
#include "dsevent.h"
#include "objids.h"        /* needed for ATT_MEMBER and ATT_IS_MEMBER_OFDL */
#include <filtypes.h>      /* Def of FI_CHOICE_???                  */
#include <sdprop.h>
#include   "debug.h"         /* standard debugging header */
#define DEBSUB  "DBTOOLS:" /* define the subsystem for debugging  */

// DBLayer includes
#include "dbintrnl.h"
#include "dbopen.h"
#include "lht.h"
#include "sync.h"

#include <fileno.h>
#define  FILENO FILENO_DBTOOLS

// The maximum time (in msec) that a transaction should be allowed to be open
// during normal operation (e.g., unless we're stress testing huge group
// replication, etc.).
DWORD gcMaxTicksAllowedForTransaction = MAX_TRANSACTION_TIME;

const ULONG csecOnlineDefragPeriodMax   = HOURS_IN_SECS;

/*--------------------------------------------------------------------------- */
/*--------------------------------------------------------------------------- */
/* Find a record by DNT. This record changes the pDB->JetObjTbl currency
   to the specified record, as well as correctly filling in the pDB->DNT,
   pDB->PDNT, and pDB->NCDNT fields.
 */
DWORD APIENTRY
DBFindDNT(DBPOS FAR *pDB, ULONG tag)
{
    JET_ERR  err;
    ULONG    actuallen;

    Assert(VALID_DBPOS(pDB));

    // Since we are moving currency, we have to cancel rec.  Callers should
    // take care of this by either not being in an init rec in the first place,
    // or by doing their own cancel rec or update rec.  This is important since
    // cancelling a rec here leaves the caller under the mistaking impression
    // that a JetSetColumn they've done is just waiting for an update rec to
    // be flushed to disk.  Anyway, assert on it now, but keep going if they
    // have done this.
    // later, we might want to change this to error if we are in a
    // init rec.

    Assert(pDB->JetRetrieveBits == 0);

    DBCancelRec(pDB);
    DBSetCurrentIndex(pDB, Idx_Dnt, NULL, FALSE);

    JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
        &tag, sizeof(tag), JET_bitNewKey);

    if (err = JetSeekEx(pDB->JetSessID,
        pDB->JetObjTbl, JET_bitSeekEQ))
    {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }

    (pDB)->DNT = tag;

    dbMakeCurrent(pDB, NULL);

    DPRINT1(2, "DBFindDNT complete DNT:%ld\n", (pDB)->DNT);
    return 0;
}

/*++ DBMakeCurrent
 *
 * This routine makes the DBPOS currency information match whatever object
 * the pDB->JetObjTbl is positioned at.
 *
 * The return value is either 0, or DIRRER_NOT_AN_OBJECT if currency has
 * been established on a phantom
 */
DWORD __fastcall
DBMakeCurrent(DBPOS *pDB)
{
    return dbMakeCurrent(pDB, NULL);
}


/*++ dbMakeCurrent
 *
 * This routine makes the DBPOS currency information match whatever object
 * the pDB->JetObjTbl is positioned at.
 *
 * If pname is passed in, that information will be used to update the DBPOS,
 * rather than going to JET.
 *
 * The return value is either 0, or DIRRER_NOT_AN_OBJECT if currency has
 * been established on a phantom
 */
BOOL gfEnableReadOnlyCopy;

DWORD
dbMakeCurrent(DBPOS *pDB, d_memname *pname)
{
    THSTATE     *pTHS = pDB->pTHS;
    JET_RETRIEVECOLUMN jCol[4];
    UCHAR objflag;
    DWORD cb;
    DWORD err;

    // Since we are moving currency, we need to assure that we are not
    // in the middle of an init rec.  If we were, then whatever update
    // we were doing would be lost, because you can't change currency
    // inside of an update.  This assertion frees us from having to
    // set the jCol grbits to pDB->JetRetrieveBits
    Assert(pDB->JetRetrieveBits == 0);

    pDB->JetNewRec = FALSE;
    pDB->fFlushCacheOnUpdate = FALSE;

    //  if we are in a read-only transaction then cache the current record in
    //  Jet to make JetRetrieveColumn calls much faster
    if (    gfEnableReadOnlyCopy &&
            pTHS->fSyncSet &&
            pTHS->transType == SYNC_READ_ONLY &&
            pTHS->transControl == TRANSACT_BEGIN_END &&
            pDB->transincount &&
            !pDB->JetCacheRec)
        {
        JetPrepareUpdateEx( pDB->JetSessID, pDB->JetObjTbl, JET_prepReadOnlyCopy );
        pDB->JetCacheRec = TRUE;
        }

    if (NULL != pname) {
        pDB->DNT = pname->DNT;
        if (pDB->DNT == ROOTTAG) {
            pDB->root = TRUE;
            pDB->PDNT = 0;
            pDB->NCDNT = 0;
        }
        else {
            pDB->root = FALSE;
            pDB->PDNT = pname->tag.PDNT;
            pDB->NCDNT = pname->NCDNT;
        }

        if (!pname->objflag) {
            return DIRERR_NOT_AN_OBJECT;
        }
        else {
            return 0;
        }
    }

    memset(jCol, 0, sizeof(jCol));

    jCol[0].columnid = dntid;
    jCol[0].pvData = &pDB->DNT;
    jCol[0].cbData = sizeof(ULONG);
    jCol[0].cbActual = sizeof(ULONG);
    jCol[0].itagSequence = 1;

    jCol[1].columnid = pdntid;
    jCol[1].pvData = &pDB->PDNT;
    jCol[1].cbData = sizeof(ULONG);
    jCol[1].cbActual = sizeof(ULONG);
    jCol[1].itagSequence = 1;

    jCol[2].columnid = objid;
    jCol[2].pvData = &objflag;
    jCol[2].cbData = sizeof(objflag);
    jCol[2].cbActual = sizeof(objflag);
    jCol[2].itagSequence = 1;

    jCol[3].columnid = ncdntid;
    jCol[3].pvData = &pDB->NCDNT;
    jCol[3].cbData = sizeof(ULONG);
    jCol[3].cbActual = sizeof(ULONG);
    jCol[3].itagSequence = 1;

    // Jet has better performance if columns are retrieved in id order
    Assert((dntid < pdntid) && "Ignorable assert, performance warning");
    Assert((pdntid < objid) && "Ignorable assert, performance warning");
    Assert((objid < ncdntid) && "Ignorable assert, performance warning");

    JetRetrieveColumnsWarnings(pDB->JetSessID,
                               pDB->JetObjTbl,
                               jCol,
                               4);

    Assert(jCol[2].err == JET_errSuccess);

    if (pDB->DNT == ROOTTAG) {
        pDB->root = TRUE;
        pDB->PDNT = 0;
        pDB->NCDNT = 0;
    }
    else {
        pDB->root = FALSE;
    }

    if ((jCol[3].err == JET_wrnColumnNull) ||
        !objflag) {
        return DIRERR_NOT_AN_OBJECT;
    }
    else {
        return 0;
    }
}

/*++

Routine Descrition:

    Try to find a record by DNT. This record changes the pDB->JetObjTbl
    currency to the specified record, as well as correctly filling in the
    pDB->DNT, pDB->PDNT, and pDB->NCDNT fields.  Unlike DBFindDNT, we return an
    error code if we couldn find the object instead of throwing an exception.

Parameters

    pDB - dbPos to use.

    tag - tag to look up.

Return values:

    0 if all went well, DIRERR_OBJ_NOT_FOUND if we couldn't find the object.
    Note that currency is undefined if we return an error.

 */
DWORD APIENTRY
DBTryToFindDNT(DBPOS FAR *pDB, ULONG tag)
{
    JET_ERR  err;
    ULONG    actuallen;
    JET_RETRIEVECOLUMN jCol[2];

    Assert(VALID_DBPOS(pDB));

    // Since we are moving currency, we have to cancel rec.  Callers should
    // take care of this by either not being in an init rec in the first place,
    // or by doing their own cancel rec or update rec.  This is important since
    // cancelling a rec here leaves the caller under the mistaking impression
    // that a JetSetColumn they've done is just waiting for an update rec to
    // be flushed to disk.  Anyway, assert on it now, but keep going if they
    // have done this.
    // later, we might want to change this to error if we are in a
    // init rec.
    Assert(pDB->JetRetrieveBits == 0);
    DBCancelRec(pDB);
    DBSetCurrentIndex(pDB, Idx_Dnt, NULL, FALSE);

    JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
                 &tag, sizeof(tag), JET_bitNewKey);

    if (err = JetSeekEx(pDB->JetSessID,
                        pDB->JetObjTbl, JET_bitSeekEQ)) {
        return DIRERR_OBJ_NOT_FOUND;
    }

    (pDB)->DNT = tag;

    if (tag == ROOTTAG) {
        pDB->PDNT = 0;
        pDB->NCDNT = 0;
    }
    else {
        memset(jCol, 0, sizeof(jCol));

        jCol[0].columnid = pdntid;
        jCol[0].pvData = &pDB->PDNT;
        jCol[0].cbData = sizeof(ULONG);
        jCol[0].cbActual = sizeof(ULONG);
        jCol[0].itagSequence = 1;

        jCol[1].columnid = ncdntid;
        jCol[1].pvData = &pDB->NCDNT;
        jCol[1].cbData = sizeof(ULONG);
        jCol[1].cbActual = sizeof(ULONG);
        jCol[1].itagSequence = 1;

        JetRetrieveColumnsSuccess(pDB->JetSessID,
                                  pDB->JetObjTbl,
                                  jCol,
                                  2);
    }

    pDB->JetNewRec = FALSE;
    (pDB)->root = (tag == ROOTTAG);
    pDB->fFlushCacheOnUpdate = FALSE;

    DPRINT1(2, "DBTryToFindDNT complete DNT:%ld\n", (pDB)->DNT);
    return 0;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function begins a JET transaction.
*/
USHORT
DBTransIn(DBPOS FAR *pDB)
{
    THSTATE     *pTHS = pDB->pTHS;
    UUID *pCurrInvocationID;
    BOOL fTransactionOpened = FALSE;
    NESTED_TRANSACTIONAL_DATA *pNewInfo = NULL;

    Assert(pDB);
    Assert(VALID_DBPOS(pDB));
    Assert(VALID_THSTATE(pTHS));

    __try {
        // We need to begin the transaction now.  We also need to pick up some
        // dnreadcache stuff, if this is from transaction level 0 to 1.
        if(pTHS->JetCache.transLevel) {
            // simple case.
            JetBeginTransactionEx(pDB->JetSessID);
            fTransactionOpened = TRUE;
        }
        else {
            // This is going from transaction level 0 to transaction level 1.  We
            // need to atomically start a transaction and pick up a new global
            // dnread cache.  Atomicity is needed to keep us from starting a
            // transaction in thread A, then having thread B commit a change which
            // affects the global dnread cache, then having thread C create a new
            // global dnread cache, then finally picking up this new cache for use
            // in thread A.  In this unlikely series of events, thread A has a
            // global DNRead cache which is inconsistent with his transacted view of
            // the database.  If we force thread A to begin a transaction and pick
            // up the DNRead cache before thread C can replace it, we avoid such an
            // unlikely fate.
            // In order to achieve this ordering use a rw lock representing the
            // globaldnread cache on the anchor.  We take it as a reader here (so
            // that no threads block while trying to enter a transaction) in thread
            // A, and we take it as a writer when writing the new read cache to the
            // anchor (so that we get the necessary atomicity in this thread) in
            // thread C.  In concrete terms, dbReplaceCacheInAnchor uses the same
            // rw lock in an exclusive fashion.

            const PPLS ppls = GetPLS();
            SyncEnterRWLockAsReader(&ppls->rwlGlobalDNReadCache);
            __try {
                // Get a global dnread cache.
                dbResetGlobalDNReadCache(pTHS);

                // Begin the transaction.
                JetBeginTransactionEx(pDB->JetSessID);
                fTransactionOpened = TRUE;
            }
            __finally {
                SyncLeaveRWLockAsReader(&ppls->rwlGlobalDNReadCache);
            }

            // Refresh the local part of the DN read cache.
            dbResetLocalDNReadCache(pTHS, FALSE);

            // Refresh our invocation ID.
            // Note that local var pCurrInvocationID is used for atomicity.
            pCurrInvocationID = gAnchor.pCurrInvocationID;
            if (NULL == pCurrInvocationID) {
                // In startup, before real invocation ID has been read.
                pTHS->InvocationID = gNullUuid;
            } else {
                // Normal operation.
                pTHS->InvocationID = *pCurrInvocationID;
            }
        }
        if (!pDB->fHidden) {
            pNewInfo = (NESTED_TRANSACTIONAL_DATA*) dbAlloc(sizeof(NESTED_TRANSACTIONAL_DATA));
        }

    }
    __finally {
        if (AbnormalTermination()) {
            if (fTransactionOpened) {
                // we excepted after opening a Jet transaction. Roll it back.
                JetRollback(pDB->JetSessID, 0);
            }
            if (pNewInfo != NULL) {
                dbFree(pNewInfo);
            }
        }
    }

    // **********************************************************************
    // IMPORTANT:
    // The code below should never except. If it does, we can end up with a
    // Jet transaction and no matching DBPOS (when DBTransIn is called from
    // DBOpen) -- this is bad.
    // An alternative is to move the block below into the try/finally, but
    // then we'd need to provide the "undo" mechanism to roll back updates
    // to pDB->transincount and such in case of an exception.
    // **********************************************************************

    pDB->transincount++;

    // Assert that we should not be using nested DBTransIn, rather use
    // multiple DBPos's

    Assert((pDB->transincount<2)
            && "Do not use nested DBtransIn, use Addtional pDB's");

    // Allow us to start maintaining state regarding escrow updates.
    // However do not do this for the Hidden DBPOS. The hidden DBPOS
    // uses a seperate Jet session other than the one in pTHS and can
    // cause problems if someone interleaved normal DBcalls and Hidden
    // DBPOS calls. Also we never expect escrow updates on the hidden DBPOS.

    if (!pDB->fHidden) {
        // NESTED_TRANSACTIONAL_DATA structs are hung in a linked list off the
        // thread state. Inner-most transaction is at the front of the list,
        // outer-most transaction is at the end of the list.  So on transaction
        // begin, we only need to insert into the front of the list.

        Assert(pNewInfo != NULL);

#if DBG
        __try {
            // Count the number of transactional data blobs we already have

            NESTED_TRANSACTIONAL_DATA *pTestInfo = pTHS->JetCache.dataPtr;
            DWORD count=0;

            while(pTestInfo) {
                count++;
                pTestInfo = pTestInfo->pOuter;
            }

            Assert(count == pTHS->JetCache.transLevel);
        }
        __except (TRUE) {
            Assert(!"Failed to walk to the end of the xactional data");
        }
#endif

        pNewInfo->pOuter = pTHS->JetCache.dataPtr;
        pTHS->JetCache.dataPtr = pNewInfo;

    }

    // if this is not the DBPOS used for the hidden record then
    // then increment the transaction level in the Thread state. Hidden record
    // DBPOS is on a seperate JetSession so the transaction level is not linked
    // to the thread state
    if (!pDB->fHidden) {
        pTHS->JetCache.transLevel++;

        if (1 == pTHS->JetCache.transLevel) {
            // Starting our first level transaction.  Until we return to level
            // 0, we are a potential drain on Jet resources -- version store, in
            // particular.  Record the current time (in ticks) so we can sanity
            // check it later to make sure we haven't been here "too long."
            pTHS->JetCache.cTickTransLevel1Started = GetTickCount();
        }
    }

    pDB->JetRetrieveBits = 0;
    DPRINT1(2,"DBTransIn complete Sess: %lx\n", pDB->JetSessID);

    DPRINT4(3,"TransIn pDB tcount:%d thread dbcount:%x Sess:%lx pDB:%x\n",
               pDB->transincount,
               pTHS->opendbcount,
               pDB->JetSessID,
               pDB);

    return 0;
}

VOID
dbTrackModifiedDNTsForTransaction (
        PDBPOS pDB,
        DWORD NCDNT,
        ULONG cAncestors,
        DWORD *pdwAncestors,
        BOOL  fNotifyWaiters,
        DWORD fChangeType)
{

    THSTATE *pTHS = pDB->pTHS;

    MODIFIED_OBJ_INFO *pTemp2;
    MODIFIED_OBJ_INFO *pTemp = pTHS->JetCache.dataPtr->pModifiedObjects;


    if(pTemp && pTemp->cItems < MODIFIED_OBJ_INFO_NUM_OBJS) {
        pTemp->Objects[pTemp->cItems].ulNCDNT = NCDNT;
        pTemp->Objects[pTemp->cItems].pAncestors = pdwAncestors;
        pTemp->Objects[pTemp->cItems].cAncestors = cAncestors;
        pTemp->Objects[pTemp->cItems].fNotifyWaiters = fNotifyWaiters;
        pTemp->Objects[pTemp->cItems].fChangeType = fChangeType;
        pTemp->cItems += 1;
    }
    else {
        pTemp2 =
            (MODIFIED_OBJ_INFO *)THAllocOrgEx(pTHS, sizeof(MODIFIED_OBJ_INFO));
        pTemp2->pNext = pTemp;
        pTHS->JetCache.dataPtr->pModifiedObjects = pTemp2;
        pTemp2->Objects[0].ulNCDNT = NCDNT;
        pTemp2->Objects[0].pAncestors = pdwAncestors;
        pTemp2->Objects[0].cAncestors = cAncestors;
        pTemp2->Objects[0].fNotifyWaiters = fNotifyWaiters;
        pTemp2->Objects[0].fChangeType = fChangeType;
        pTemp2->cItems = 1;
    }
}

DWORD
ComplainAndContinue (
        BOOL fDoAssert
        )
{
    if(fDoAssert) {
        Assert(!"POSTPROCESSING transactional data must NEVER except!\n");
    }
    return EXCEPTION_CONTINUE_SEARCH;
}


BOOL
dbPreProcessTransactionalData(
        PDBPOS pDB,
        BOOL fCommit
        )
/*++
    Preprocess any transactional data.  This is called before the actual end of
    transaction. This routine calls out the the various portions of the DS that
    track transactional data to let them prepare to commit transactional data.
    These pre-process routines should return success if they have managed to
    correctly prepare for commit (e.g. they may validate the data, allocate
    memory used by the post-proccess code, etc).  If the pre-process routines
    return success, then the post-process routines MUST NOT FAIL.  If the
    pre-process routines succeed, we're going to make a commit to the Jet
    Database.   We can't have the post process routines failing after we have
    done the DB commit.

    Pre-process routines are allowed to cause exceptions.  Post-process routines
    should NEVER throw exceptions.

    Note that if the dbpos we're dealing with is for the hidden table, no
    transactional data should be present.
--*/
{
    NESTED_TRANSACTIONAL_DATA *pInfo;
    THSTATE *pTHS;
    BOOL     retVal1, retVal2, retVal3, retVal4;

    if(pDB->fHidden) {
        return TRUE;
    }

    pTHS = pDB->pTHS;

    pInfo = pTHS->JetCache.dataPtr;

    Assert(pInfo);
    Assert(!pInfo->preProcessed);
    Assert(pTHS->JetCache.transLevel > 0);

#if DBG
    __try {
        // Count the number of transactional data blobs we already have

        NESTED_TRANSACTIONAL_DATA *pTestInfo = pTHS->JetCache.dataPtr;
        DWORD count=0;

        while(pTestInfo) {
            count++;
            pTestInfo = pTestInfo->pOuter;
        }

        Assert(count == pTHS->JetCache.transLevel);
    }
    __except (TRUE) {
        Assert(!"Failed to walk to the end of the xactional data");
    }
#endif

    // GroupTypeCachePreProcessTransactionalData does not exist, since it
    // doesn't need to do anything
    // (I.E. GroupTypeCachePostProcessTransactionalData does all the work and
    // should never fail)

    retVal1 = dnReadPreProcessTransactionalData(fCommit);
    retVal2 = dbEscrowPreProcessTransactionalData(pDB, fCommit);
    retVal3 = LoopbackTaskPreProcessTransactionalData(fCommit);
    retVal4 = ObjCachingPreProcessTransactionalData(fCommit);

    pInfo->preProcessed = TRUE;

    return (retVal1 && retVal2 && retVal3 && retVal4);
}


void
dbPostProcessTrackModifiedDNTsForTransaction (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        )
/*++
    Called when after a transaction has ended. If the transaction is aborted,
    the transactional data associated with the deepest transaction is deleted.
    If a transaction is committed to some level other than 0, the transactional
    data is propagated to the next level up.  If committed to 0, calls several
    other routines that make use of the data.

    Regardless of commit or abort and level, the data associated with the
    current transaction level is no longer associated (i.e., it is deleted, or
    it is moved, or it is acted on then deleted.)

--*/
{
    DWORD          i;
    MODIFIED_OBJ_INFO *pTemp2;
    MODIFIED_OBJ_INFO *pTemp = pTHS->JetCache.dataPtr->pModifiedObjects;


    Assert(VALID_THSTATE(pTHS));

    if(!pTHS->JetCache.dataPtr->pModifiedObjects ) {
        // nothing to do.
        return;
    }

    if ( !fCommitted ) {
        // Aborted transaction - throw away all the data of
        // this (possibly nested) transaction.
        pTemp = pTHS->JetCache.dataPtr->pModifiedObjects;
        while(pTemp) {
            pTemp2 = pTemp->pNext;
            THFreeOrg(pTHS, pTemp);
            pTemp = pTemp2;
        }
        // reset ptr so that md.c:Dump_ModifiedObjectInfo will not get confused
        pTHS->JetCache.dataPtr->pModifiedObjects = NULL;
    }
    else if (pTHS->JetCache.transLevel > 0) {
        // Committing, to non-zero level.  Propagate the ModifiedObjects
        // updates to the outer transaction.

        // first, find the end of the outer transactions modified dnt info
        // chain.
        Assert(pTHS->JetCache.dataPtr->pOuter);
        if(!pTHS->JetCache.dataPtr->pOuter->pModifiedObjects) {
            pTHS->JetCache.dataPtr->pOuter->pModifiedObjects =
                pTHS->JetCache.dataPtr->pModifiedObjects;
        }
        else {
            pTemp = pTHS->JetCache.dataPtr->pOuter->pModifiedObjects;

            while(pTemp->pNext) {
                pTemp = pTemp->pNext;
            }


            pTemp->pNext = pTHS->JetCache.dataPtr->pModifiedObjects;
            pTHS->JetCache.dataPtr->pModifiedObjects = NULL;
        }
    }
    else {
        // OK, we're committing to transaction level 0.  Give the people who
        // care about this data a chance to do something with it, then delete
        // the data.

        __try {
            GroupTypeCachePostProcessTransactionalData(pTHS,
                                                       fCommit,
                                                       fCommitted);

            NotifyWaitersPostProcessTransactionalData(pTHS,
                                                      fCommit,
                                                      fCommitted);
        }
        __except(ComplainAndContinue(TRUE)) {
            Assert(!"Hey, we shouldn't be here!\n");
        }

        // Free up stuff
        pTemp = pTHS->JetCache.dataPtr->pModifiedObjects;
        while(pTemp) {
            pTemp2 = pTemp->pNext;
            THFreeOrg(pTHS, pTemp);
            pTemp = pTemp2;
        }
        // reset ptr so that md.c:Dump_ModifiedObjectInfo will not get confused
        pTHS->JetCache.dataPtr->pModifiedObjects = NULL;

        if (gfDsaWritable == FALSE) {
            // We didn't think we could write to the database, but we can!
            // Tell NetLogon, who cares about such things.
            SetDsaWritability(TRUE, 0);
        }

    }
}

VOID
dbPostProcessTransactionalData(
    IN DBPOS *pDB,
    IN BOOL fCommit,
    IN BOOL fCommitted
    )
/*++
    Postprocess any transactional data.  This is called after the actual end of
    transaction.  Mostly, call out the the various portions of the DS that track
    transactional data to let them clean up, then cut the current transaction
    out of the transactional data linked list.

    The various routines called by this wrapper routine are responsible for
    cleaning up the memory that has been allocated for their use.  This routine
    is responsible for cleaning up the linked list of transactional data blobs.

    The post processing routines SHOULD NEVER FAIL!!!!!  Since we've already
    committed the Jet transaction, these calls must suceed.  Therefore, all the
    necessary memory allocation must have been done in the pre-processing phase.

    Note that if the dbpos we're dealing with is for the hidden table, no
    transactional data should be present.
--*/
{
    NESTED_TRANSACTIONAL_DATA *pInfo;
    THSTATE *pTHS=pDB->pTHS;

    Assert( pDB );

    if( pDB->fHidden ) {
        return;
    }

    pInfo = pTHS->JetCache.dataPtr;

    Assert( pInfo );
    Assert( pInfo->preProcessed || !fCommitted);

#if DBG
    __try {
        // Count the number of transactional data blobs we already have

        NESTED_TRANSACTIONAL_DATA *pTestInfo = pTHS->JetCache.dataPtr;
        DWORD count=0;

        while(pTestInfo) {
            count++;
            pTestInfo = pTestInfo->pOuter;
        }

        Assert(count == (1 + pTHS->JetCache.transLevel));
    }
    __except (TRUE) {
        Assert(!"Failed to walk to the end of the xactional data");
    }
#endif


    __try {
        __try {
            LoopbackTaskPostProcessTransactionalData(pTHS,
                                                     fCommit,
                                                     fCommitted);

            dbPostProcessTrackModifiedDNTsForTransaction(pTHS,
                                                         fCommit,
                                                         fCommitted);

            dnReadPostProcessTransactionalData(pTHS,
                                               fCommit,
                                               fCommitted);

            dbEscrowPostProcessTransactionalData(pDB,
                                                 fCommit,
                                                 fCommitted);

            ObjCachingPostProcessTransactionalData(pTHS,
                                                   fCommit,
                                                   fCommitted);

            // Do this last, so that prior routines have a chance to set the bit
            if (    (0 == pTHS->JetCache.transLevel)
                 && (pTHS->fExecuteKccOnCommit) ) {
                if (fCommitted) {
                    DRS_MSG_KCC_EXECUTE msg;
                    DWORD err;

                    // Request the KCC to run immediately to revise topology
                    memset( &msg, 0, sizeof(msg) );
                    msg.V1.dwTaskID = DS_KCC_TASKID_UPDATE_TOPOLOGY;
                    // Do async, this could take a while...
                    msg.V1.dwFlags = DS_KCC_FLAG_ASYNC_OP | DS_KCC_FLAG_DAMPED;
                    err = KccExecuteTask( 1, &msg );
                    if (err && (ERROR_DS_NOT_INSTALLED != err)) {
                        LogUnhandledError(err);
                    }
                    // Ignore failures
                }
                pTHS->fExecuteKccOnCommit = 0;
            }
        }
        __except(ComplainAndContinue(TRUE)) {
            Assert(!"Hey, we shouldn't be here!\n");
        }
    }
    __finally {
        // Strip this transaction's TRANSACTIONALDATA out of the linked
        // list.

        pTHS->JetCache.dataPtr = pInfo->pOuter;
        dbFree(pInfo);

        // Stop treating a newly created row as special; its just
        // another existing object, now.
        if (pTHS->JetCache.transLevel == 0) {
            pDB->NewlyCreatedDNT = INVALIDDNT;
        }

        // If this was a level 0 transaction terminating, then THSTATE
        // should not have any transactional data remaining, otherwise
        // it should.

        Assert((pTHS->JetCache.transLevel == 0)?
               NULL == pTHS->JetCache.dataPtr :
               NULL != pTHS->JetCache.dataPtr);
    }

}
/* Tiny wrapper used only to get the required exception handler out
 * from the innards of a finally block, where the compiler would not
 * let it appear, presumably for reasons of good taste.
 */
NTSTATUS MyNetNotifyDsChange(NL_DS_CHANGE_TYPE change)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    __try {
        status = I_NetNotifyDsChange(change);
    }
    __except (HandleAllExceptions(GetExceptionCode())) {
        ;
    }
    return status;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function completes the current JET transaction.
*/
USHORT
DBTransOut(DBPOS FAR *pDB, BOOL fCommit, BOOL fLazy)
{
    ULONG err;
    BOOL fCommitted = FALSE;
    BOOL fPreProcessed = FALSE;
    THSTATE    *pTHS=pDB->pTHS;

    Assert(pDB);
    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pDB));

    // JLiem suspects that we have DB corruption stemming from committing
    // transactions while still in the midst of a prepare update.
    Assert((FALSE == fCommit) || (0 == pDB->JetRetrieveBits));


    // Commit or rollback JET transaction

    __try
    {

        fPreProcessed = dbPreProcessTransactionalData(pDB, fCommit);

        if (fPreProcessed && fCommit)
        {
#if DBG
            // Assert that if we opened a pDB at transaction level n
            // then we do not commit beyond transactionlevel n. This assert
            // is not applicable to the hidden DBPOS
            Assert((pDB->fHidden)||((pDB->transincount+pDB->TransactionLevelAtOpen)
                    >= pTHS->JetCache.transLevel));
#endif

            if (pDB->JetCacheRec && pDB->transincount == 1)
                {
                //  should either succeed or fail with update not prepared
                err = JetPrepareUpdate(pDB->JetSessID, pDB->JetObjTbl, JET_prepCancel);
                Assert(err == 0 || err == JET_errUpdateNotPrepared);
                pDB->JetCacheRec = FALSE;
                }

            JetCommitTransactionEx(pDB->JetSessID,
                                   (pTHS->fLazyCommit || fLazy)?
                                   JET_bitCommitLazyFlush : 0);
            fCommitted = TRUE;
        }

    }
    __finally
    {
        // We have to test for abnormal termination here, instead of down
        // below where we need it because AT() tells you about the try block
        // that most closely encloses you, and we're about to start a new try!
        // Were we to just call AT() inside the try block below (as we used
        // to), it would always return false.
        BOOL fAbnormalTermination = AbnormalTermination();

        __try {
            // Rollback if commit is not specified or if errors occurred
            if ((!fCommit ) || (!fPreProcessed) || (fAbnormalTermination)) {
                JetRollback(pDB->JetSessID, 0);
            }

            pDB->transincount--;

            // Bump the transaction level down in THSTATE if this is not the
            // hidden record.
            if (!pDB->fHidden) {
                pTHS->JetCache.transLevel--;

                // We need to call dbFlushUncUsn's upon a commit to a level 0
                // transaction. The real test for level 0 is
                // pTHS->transactionlevel  going to 0.

                // we don't notify interested parties, update anchor when in singleuser mode
                // cause our internal state is propably broken and we are planning on rebooting
                // shortly
                if (0 == pTHS->JetCache.transLevel && !pTHS->fSingleUserModeThread) {
                    // Here we have commited changes, update uncommited usn data

                    dbFlushUncUsns ();

                    // Let NetLogon know if we changed anything important
                    // As well, notify SAM of changes, too.
                    if (fCommitted) {
                        if (pTHS->fNlSubnetNotify) {
                            MyNetNotifyDsChange(NlSubnetObjectChanged);
                        }
                        if (pTHS->fNlSiteObjNotify) {
                            MyNetNotifyDsChange(NlSiteObjectChanged);
                        }
                        if (pTHS->fNlSiteNotify) {
                            MyNetNotifyDsChange(NlSiteChanged);
                            SamINotifyServerDelta(SampNotifySiteChanged);
                        }
                        if (pTHS->fNlDnsRootAliasNotify) {
                            MyNetNotifyDsChange(NlDnsRootAliasChanged);
                            InsertInTaskQueue(TQ_WriteServerInfo,
                                              (void *)(DWORD)SERVINFO_RUN_ONCE,
                                              0);
                        }
                        if (pTHS->fAnchorInvalidated) {
                            // During installation, we should not rebuild the anchor
                            // asynchronously. This stems from our anchor model, which
                            // does not ref count the memory. The anchor model depends
                            // on use of DelayedFreeMemory. DelayedFreeMemory does not
                            // work asynchronously during install, see dsatools.c
                            if (DsaIsRunning()) {
                                InsertInTaskQueueDamped(TQ_RebuildAnchor,
                                                        NULL,
                                                        0,
                                                        0,
                                                        TaskQueueNameMatched,
                                                        NULL);
                            }
                        }
                        if (pTHS->fBehaviorVersionUpdate) {
                            InsertInTaskQueueDamped(TQ_BehaviorVersionUpdate,
                                                    NULL,
                                                    0,
                                                    0,
                                                    TaskQueueNameMatched,
                                                    NULL);

                        }
                    }

                    pTHS->fNlSubnetNotify = 0;
                    pTHS->fNlSiteObjNotify = 0;
                    pTHS->fNlSiteNotify = 0;
                    pTHS->fNlDnsRootAliasNotify = 0;
                    pTHS->fAnchorInvalidated = 0;
                    pTHS->fBehaviorVersionUpdate = 0;

                    pTHS->JetCache.cTickTransLevel1Started = 0;
                }
            }

            // we keep the locked DN all the way till this pDB goes to level 0
            if ( pDB->pDNsAdded && (0 == pDB->transincount) ) {
                dbUnlockDNs(pDB);
            }

            // Process and dispose of the list of replica notifications
            // This is for the entire thread and not DBPOS specific
            // This only happens when finishing the level 0 transaction

            if ( (0 == pTHS->JetCache.transLevel) && (pTHS->pNotifyNCs) )  {
                PNCnotification pItem, pNext;

                pItem = (PNCnotification) pTHS->pNotifyNCs;
                while (pItem) {

                    if (fCommitted) {
                        NotifyReplicas( pItem->ulNCDNT, pItem->fUrgent );
                    }

                    pNext = pItem->pNext;

                    dbFree( pItem );

                    pItem = pNext;
                }
                pTHS->pNotifyNCs = NULL;
            }

        }
        __finally {
            dbPostProcessTransactionalData( pDB, fCommit, fCommitted );
        }


        DPRINT4(3,"TransOut pDB tcount:%d thread dbcount:%x Sess:%lx pDB:%x\n",
               pDB->transincount,
               pTHS->opendbcount,
               pDB->JetSessID,
               pDB);
    }

    return 0;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function begins a JET transaction and loads the current JET
   record into the copy buffer. If there is a record already in the copy
   buffer then ther is already a transaction & we just return.
*/

DWORD
dbInitRec(DBPOS FAR *pDB)
{
    ULONG    err;
    ULONG    actuallen;

    Assert(VALID_DBPOS(pDB));

    if (pDB->JetRetrieveBits == JET_bitRetrieveCopy)
        return 0;

    if (pDB->JetCacheRec)
        {
        //  should either succeed or fail with update not prepared
        err = JetPrepareUpdate(pDB->JetSessID, pDB->JetObjTbl, JET_prepCancel);
        Assert(err == 0 || err == JET_errUpdateNotPrepared);
        pDB->JetCacheRec = FALSE;
        }

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl,
        (pDB->JetNewRec ? JET_prepInsert : DS_JET_PREPARE_FOR_REPLACE));

    pDB->JetRetrieveBits = JET_bitRetrieveCopy;

    // if this is a new record get its brand new  DNT and store it in pDB->DNT
    if (pDB->JetNewRec)
    {
        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl,
            dntid, &(pDB)->DNT, sizeof((pDB)->DNT),
            &actuallen, pDB->JetRetrieveBits, NULL);
    }

    if (pDB->fIsMetaDataCached) {
        // We shouldn't have any replication meta data hanging around from a
        // previous record.
        Assert(!"Lingering replication meta data found!");
        dbFreeMetaDataVector(pDB);
    }
    if (pDB->fIsLinkMetaDataCached) {
        // We shouldn't have any replication meta data hanging around from a
        // previous record.
        Assert(!"Lingering link replication meta data found!");
        Assert( pDB->cbLinkMetaDataAlloced != 0 );
        THFreeEx( pDB->pTHS, pDB->rgLinkMetaData );
        pDB->rgLinkMetaData = NULL;
        pDB->fIsLinkMetaDataCached = FALSE;
        pDB->cbLinkMetaDataAlloced = 0;
    }

    DPRINT1(2, "dbInitRec complete DNT:%ld\n", (pDB)->DNT);
    return 0;
}


// Public wrapper for dbInitRec. Called by LocalAdd to create the new
// record prior to adding new attributes and reading values.
DWORD __fastcall
DBInitRec(DBPOS* pDB)
{
    return dbInitRec(pDB);
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Update the permanent record from the copy buffer, complete the
   current transaction. Check for new record, this cannot be written
   as the name has not yet been added, leave in copy buffer.
*/
USHORT
DBUpdateRec(DBPOS FAR *pDB)
{
    ULONG grbit;
    DPRINT1(2, "DBUpdateRec entered DNT:%ld\n", (pDB)->DNT);

    Assert(VALID_DBPOS(pDB));

    if (pDB->JetNewRec || pDB->JetRetrieveBits != JET_bitRetrieveCopy)
        return 0;

    if ((gAnchor.ForestBehaviorVersion <= DS_BEHAVIOR_WIN2000)
        && !(pDB->pTHS->fDRA)) {
        grbit = JET_bitUpdateCheckESE97Compatibility;
    }
    else {
        grbit = NO_GRBIT;
    }

    if (pDB->fEnqueueSDPropOnUpdate) {
        DWORD dwErr;
        dwErr = DBEnqueueSDPropagationEx(pDB, FALSE, pDB->fAncestryUpdated ? SDP_NEW_ANCESTORS : 0);
        if (dwErr) {
            DsaExcept(DSA_DB_EXCEPTION, dwErr, 0);
        }
        pDB->fEnqueueSDPropOnUpdate = FALSE;
        pDB->fAncestryUpdated = FALSE;
    }

    JetUpdate2Ex(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0, grbit);

    pDB->JetRetrieveBits = 0;

    if (pDB->fFlushCacheOnUpdate) {
        // Flush this record from the read cache, now that other cursors can
        // see it by its new name.
        dbFlushDNReadCache(pDB, pDB->DNT);
        pDB->fFlushCacheOnUpdate = FALSE;
    }

    if (pDB->fIsMetaDataCached) {
        dbFreeMetaDataVector(pDB);
    }

    if (pDB->fIsLinkMetaDataCached) {
        Assert( pDB->cbLinkMetaDataAlloced != 0 );
        THFreeEx( pDB->pTHS, pDB->rgLinkMetaData );
        pDB->rgLinkMetaData = NULL;
        pDB->fIsLinkMetaDataCached = FALSE;
        pDB->cbLinkMetaDataAlloced = 0;
    }

    DPRINT1(2, "DBUpdateRec complete DNT:%ld\n", (pDB)->DNT);

    return 0;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function invalidates the JetObjTbl copy buffer.
*/
USHORT
DBCancelRec(DBPOS FAR *pDB)
{
    ULONG err;

    DPRINT1(2, "DBCancelRec entered DNT:%ld\n", (pDB)->DNT);

    if (pDB->fIsMetaDataCached) {
        // Destroy any replicated meta data we've cached for the previous
        // record.

        dbFreeMetaDataVector(pDB);
    }

    if (pDB->fIsLinkMetaDataCached) {
        // Ditto
        Assert( pDB->cbLinkMetaDataAlloced != 0 );
        THFreeEx( pDB->pTHS, pDB->rgLinkMetaData );
        pDB->rgLinkMetaData = NULL;
        pDB->fIsLinkMetaDataCached = FALSE;
        pDB->cbLinkMetaDataAlloced = 0;
    }

    if (!pDB->JetRetrieveBits && !pDB->JetCacheRec)
        return 0;

    pDB->JetRetrieveBits = 0;
    pDB->JetCacheRec = FALSE;
    pDB->JetNewRec = FALSE;
    pDB->fFlushCacheOnUpdate = FALSE;

    //  should either succeed or fail with update not prepared
    err = JetPrepareUpdate(pDB->JetSessID, pDB->JetObjTbl, JET_prepCancel);
    Assert(err == 0 || err == JET_errUpdateNotPrepared);

    DPRINT1(2, "DBCancelRec complete DNT:%ld\n", (pDB)->DNT);
    return 0;
}

void
DBCreateRestart(
        DBPOS *pDB,
        PRESTART *ppRestart,
        DWORD SearchFlags,
        DWORD problem,
        RESOBJ *pResObj
        )
/*++

Build a restart argument.  We hand marshall the data, so we are sensitive to the
data structures PACKED_KEY_HEADER and PACKED_KEY_INDEX

--*/
{
    THSTATE  *pTHS=pDB->pTHS;
    RESTART *pRestart;
    BYTE   rgbKeyBMCurrent[DB_CB_MAX_KEY + DB_CB_MAX_KEY];
    DWORD  cbDBKeyCurrent;
    DWORD  cbDBBMCurrent;
    DWORD  NumKeyIndices = 0, NumDNTs = 0;
    DWORD  cdwAllocated;
    DWORD  dataIndex=0;
    DWORD  err;
    KEY_INDEX *pIndex;
    DWORD cdwCurrentKey, cdwHeader, cdwVLVCurrentKey;
    PACKED_KEY_HEADER *pPackedHeader;
    PACKED_KEY_INDEX  *pPackedIndex;
    VLV_SEARCH *pVLV = pDB->Key.pVLV;

    *ppRestart = NULL;

    // we are not interested in keeping the current key if we are on
    // a temp table or we are doing VLV
    if(pDB->Key.indexType != TEMP_TABLE_INDEX_TYPE && !pDB->Key.pVLV) {
        JET_TABLEID JetTbl;

        // Get the current bound key
        if (pDB->Key.pIndex &&
            pDB->Key.pIndex->pAC &&
            pDB->Key.pIndex->pAC->ulLinkID) {
            JetTbl = pDB->JetLinkEnumTbl;
        } else {
            JetTbl = pDB->JetObjTbl;
        }

        // this returns the secondary index key and the primary bookmark for
        // the current entry on the secondary index.  these two keys completely
        // describe our current position on this index
        err = JetGetSecondaryIndexBookmarkEx(pDB->JetSessID,
                                           JetTbl,
                                           rgbKeyBMCurrent,
                                           DB_CB_MAX_KEY,
                                           &cbDBKeyCurrent,
                                           rgbKeyBMCurrent + DB_CB_MAX_KEY,
                                           DB_CB_MAX_KEY,
                                           &cbDBBMCurrent);
        if (err == JET_errNoCurrentIndex) {
            // we must be on the primary index (rare), so just get the key for
            // our current position.  this key completely describes our current
            // position on this index because the primary index must be unique
            JetRetrieveKeyEx(pDB->JetSessID,
                            JetTbl,
                            rgbKeyBMCurrent,
                            DB_CB_MAX_KEY,
                            &cbDBKeyCurrent,
                            0);
            cbDBBMCurrent = 0;
            err = JET_errSuccess;
        } else {
            // pack the two keys together for marshalling
            Assert( JET_errSuccess == err );
            memmove(rgbKeyBMCurrent + cbDBKeyCurrent,
                    rgbKeyBMCurrent + DB_CB_MAX_KEY,
                    cbDBBMCurrent);
        }
    }
    else {
        cbDBKeyCurrent = 0;
        cbDBBMCurrent = 0;
    }
    cdwCurrentKey = ((cbDBKeyCurrent + cbDBBMCurrent) / sizeof(DWORD)) + 1;

    if (pVLV) {
        cdwVLVCurrentKey = (pVLV->cbCurrPositionKey / sizeof(DWORD)) + 1;
    }
    else {
        cdwVLVCurrentKey = 1;
    }

    // Figure out how much to allocate for the header portion.  Note that we
    // count in DWORDs to ease directly accessing the pRestart->data array.
    cdwHeader = (sizeof(PACKED_KEY_HEADER)/sizeof(DWORD));

    cdwAllocated = (cdwHeader + cdwCurrentKey + cdwVLVCurrentKey) * 2;
    pRestart = (RESTART *)
        THAllocEx(pTHS, offsetof(RESTART, data) + cdwAllocated * sizeof(DWORD));
    pPackedHeader =(PACKED_KEY_HEADER *)pRestart->data;

    pPackedHeader->NumIndices = 0;
    pPackedHeader->NumDNTs = 0;
    pPackedHeader->StartDNT = pDB->DNT;
    pPackedHeader->cbCurrentKey = cbDBKeyCurrent;
    pPackedHeader->cbCurrentBM = cbDBBMCurrent;
    pPackedHeader->ulSearchType = pDB->Key.ulSearchType;
    pPackedHeader->ulSorted = pDB->Key.ulSorted;
    pPackedHeader->indexType = pDB->Key.indexType;
    pPackedHeader->bOnCandidate = pDB->Key.bOnCandidate;
    pPackedHeader->fChangeDirection = pDB->Key.fChangeDirection;
    pPackedHeader->dupDetectionType = pDB->Key.dupDetectionType;
    pPackedHeader->BaseResObj = *pResObj;
    pPackedHeader->BaseResObj.pObj = NULL;
    pPackedHeader->BaseGuid = pResObj->pObj->Guid;
    pPackedHeader->bOneNC = pDB->Key.bOneNC;
    pPackedHeader->SearchEntriesReturned = pDB->SearchEntriesReturned;
    pPackedHeader->SearchEntriesVisited = pDB->SearchEntriesVisited;
    pPackedHeader->fVLVSearch = pVLV != NULL;

    if (pVLV) {
        pRestart->restartType = NTDS_RESTART_VLV;
        pPackedHeader->ulVLVContentCount =  pVLV->contentCount;
        pPackedHeader->ulVLVTargetPosition = pVLV->currPosition;
        pPackedHeader->cbVLVCurrPositionKey = pVLV->cbCurrPositionKey;
        pPackedHeader->bUsingMAPIContainer = pVLV->bUsingMAPIContainer;
        pPackedHeader->MAPIContainerDNT = pVLV->MAPIContainerDNT;
    }
    else {
        pRestart->restartType = NTDS_RESTART_PAGED;
        pPackedHeader->ulVLVContentCount =  0;
        pPackedHeader->ulVLVTargetPosition = 0;
        pPackedHeader->cbVLVCurrPositionKey = 0;
        pPackedHeader->bUsingMAPIContainer = 0;
        pPackedHeader->MAPIContainerDNT = 0;
    }
    pPackedHeader->asqMode = pDB->Key.asqMode;
    pPackedHeader->ulASQLastUpperBound = pDB->Key.ulASQLastUpperBound;

    Assert(pDB->Key.ulSearchRootDnt == pResObj->DNT || pPackedHeader->bUsingMAPIContainer);
    Assert(pDB->Key.ulSearchRootPDNT == pResObj->PDNT);
    Assert(pDB->Key.ulSearchRootNcdnt == pResObj->NCDNT);

    memcpy(&pPackedHeader[1], rgbKeyBMCurrent, cbDBKeyCurrent + cbDBBMCurrent);

    dataIndex = cdwCurrentKey + cdwHeader;

    // now the VLV position
    if (pVLV && pVLV->cbCurrPositionKey) {
        memcpy(&pRestart->data[dataIndex],
               pVLV->rgbCurrPositionKey,
               pVLV->cbCurrPositionKey);

        dataIndex += cdwVLVCurrentKey;
    }

    // Now, do the index_keys.
    pIndex = pDB->Key.pIndex;
    while(pIndex) {
        DWORD  cbIndexName;
        DWORD  cdwBytes, cdwIndex;
        PUCHAR pBytes;

        NumKeyIndices++;
        // Figure out how much space this key index will take
        cbIndexName = strlen(pIndex->szIndexName);
        cdwBytes = (cbIndexName +
                    pIndex->cbDBKeyLower +
                    pIndex->cbDBKeyUpper) / sizeof(DWORD) + 1;
        cdwIndex = sizeof(PACKED_KEY_INDEX)/sizeof(DWORD);

        if(cdwAllocated < dataIndex + cdwBytes + cdwIndex) {
            // Need more space
            cdwAllocated = (cdwAllocated + cdwBytes + cdwIndex) * 2;
            pRestart = (RESTART *)
                THReAllocEx(pTHS,
                            pRestart,
                            offsetof(RESTART, data) + cdwAllocated * sizeof(DWORD));
        }

        pPackedIndex = (PACKED_KEY_INDEX *)&pRestart->data[dataIndex];

        pPackedIndex->bPDNT = pIndex->bIsPDNTBased;
        pPackedIndex->cbIndexName = cbIndexName;
        pPackedIndex->bIsSingleValued = pIndex->bIsSingleValued;
        pPackedIndex->bIsEqualityBased = pIndex->bIsEqualityBased;
        pPackedIndex->bIsForSort = pIndex->bIsForSort;
        pPackedIndex->type = pIndex->pAC ? pIndex->pAC->id : INVALID_ATT;
        pPackedIndex->cbDBKeyLower = pIndex->cbDBKeyLower;
        pPackedIndex->cbDBKeyUpper = pIndex->cbDBKeyUpper;

        // Now, unpack the bytes of the data.
        pBytes = (PUCHAR)&pPackedIndex[1];

        memcpy(pBytes, pIndex->szIndexName, cbIndexName);
        pBytes = &pBytes[cbIndexName];

        memcpy(pBytes, pIndex->rgbDBKeyLower, pIndex->cbDBKeyLower);
        pBytes = &pBytes[pIndex->cbDBKeyLower];

        memcpy(pBytes, pIndex->rgbDBKeyUpper, pIndex->cbDBKeyUpper);
        pBytes = &pBytes[pIndex->cbDBKeyUpper];

        dataIndex += cdwIndex + cdwBytes;

        pIndex = pIndex->pNext;
    }

    // OK, now marshall the DNTs we are tracking for duplicate detection or
    // Sorted table output (we might store either of these in a jet temp table,
    // or we might store DNTs for duplicate detection in a memory block.)
    if(pDB->JetSortTbl) {
        Assert (!pVLV);

        // Yes, we have a jet temp table.  Therefore, we need to marshall the
        // DNTs in that temp table.

        if(pDB->Key.indexType != TEMP_TABLE_INDEX_TYPE) {
            // == TEMP_TABLE_INDEX_TYPE means that the temp table holds sorted
            // candidates.
            // Since it is not set, we are using the temp table to track objects
            // we have already returned or at least considered and rejected.  In
            // this case we need to marshall ALL the DNTs in the temp table.  If
            // we were holding sorted candidates, we don't need all the DNTs,
            // just the ones that are after the "currency" point (we've already
            // looked at the ones before "currency"
            err = JetMove(pDB->JetSessID,
                          pDB->JetSortTbl,
                          JET_MoveFirst,
                          0);
        }
        else {
            err = 0;
        }

        if(!err) {
            do {
                NumDNTs++;

                if(dataIndex >= cdwAllocated) {
                    cdwAllocated *= 2;
                    pRestart = THReAllocEx(pTHS,
                                           pRestart,
                                           (offsetof(RESTART, data) +
                                            (cdwAllocated * sizeof(DWORD))));
                }

                // OK, pull the DNT out of the sort table
                DBGetDNTSortTable (
                        pDB,
                        &pRestart->data[dataIndex]);

                if( (problem == PA_PROBLEM_SIZE_LIMIT) &&
                    (pRestart->data[dataIndex] == pDB->DNT)) {
                    // Actually, we don't put the start DNT in this list.  In
                    // the case of a restart for a size limit, we've verified
                    // that the current object should be returned.  Part of that
                    // verification meant checking this table for duplicates,
                    // which adds the value to the table.  So, we need to make
                    // sure that the object is NOT in the table, so that when we
                    // restart, it still passes the duplicate test.
                    NumDNTs--;
                }
                else {
                    dataIndex++;
                }
                err = JetMove(pDB->JetSessID,
                              pDB->JetSortTbl,
                              JET_MoveNext,
                              0);

            } while (!err);
        }
    }
    else if (pDB->Key.indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE) {
        DWORD iDNTSave;
        DWORD cDNTSave;

        // save all entries for ASQ or VLV
        if (pDB->Key.asqRequest.fPresent || pDB->Key.pVLV) {
            iDNTSave = 0;
            cDNTSave = pDB->Key.cdwCountDNTs;
        }
        // save only the unvisited entries for sorted search
        else {
            iDNTSave = (pDB->Key.currRecPos + 1) - 1;
            cDNTSave = pDB->Key.cdwCountDNTs - iDNTSave;
        }

        if( (dataIndex + cDNTSave) >= cdwAllocated) {
            cdwAllocated = (dataIndex + cDNTSave) * 2;
            pRestart = THReAllocEx(pTHS,
                                   pRestart,
                                   (offsetof(RESTART, data) +
                                    (cdwAllocated * sizeof(DWORD))));
        }

        memcpy (&pRestart->data[dataIndex],
                pDB->Key.pDNTs + iDNTSave,
                cDNTSave * sizeof (DWORD));

        dataIndex += cDNTSave;
        NumDNTs = cDNTSave;
    }
    else if(pDB->Key.cDupBlock) {
        DWORD i;

        Assert (!pVLV && "VLV search should not use DupDetection");

        // We are storing some DNTs for duplicate detection in an in-memory
        // duplicate detection block.  Marshall them.
        if(dataIndex + pDB->Key.cDupBlock >= cdwAllocated) {
            cdwAllocated =
                (max(cdwAllocated, dataIndex + pDB->Key.cDupBlock)) * 2;
            pRestart = THReAllocEx(pTHS,
                                   pRestart,
                                   (offsetof(RESTART, data) +
                                    (cdwAllocated * sizeof(DWORD))));
        }

        // First, make sure we've allocated enough memory.
        for(i=0;i<pDB->Key.cDupBlock;i++) {
            NumDNTs++;

            pRestart->data[dataIndex] = pDB->Key.pDupBlock[i];

            if(problem == PA_PROBLEM_SIZE_LIMIT &&
               pRestart->data[dataIndex] == pDB->DNT ) {
                // Actually, we don't put the start DNT in this list.  In
                // the case of a restart for a size limit, we've verified
                // that the current object should be returned.  Part of that
                // verification meant checking this table for duplicates,
                // which adds the value to the table.  So, we need to make
                // sure that the object is NOT in the table, so that when we
                // restart, it still passes the duplicate test.
                NumDNTs--;
            }
            else {
                dataIndex++;
            }
        }
    } else if (pDB->Key.plhtDup ){
        LHT_STAT    statLHT;
        LHT_POS     posLHT;
        ULONG       DNT;

        Assert (!pVLV && "VLV search should not use DupDetection");

        // We are storing some DNTs for duplicate detection in a hash table.
        // Marshall them.
        LhtQueryStatistics(
            pDB->Key.plhtDup,
            &statLHT );

        if(dataIndex + statLHT.cEntry >= cdwAllocated) {
            cdwAllocated =
                (DWORD)(max(cdwAllocated, dataIndex + statLHT.cEntry)) * 2;
            pRestart = THReAllocEx(pTHS,
                                   pRestart,
                                   (offsetof(RESTART, data) +
                                    (cdwAllocated * sizeof(DWORD))));
        }

        // First, make sure we've allocated enough memory.
        LhtMoveBeforeFirst(
            pDB->Key.plhtDup,
            &posLHT);
        while (LhtMoveNext(&posLHT) == LHT_errSuccess) {
            LhtRetrieveEntry(
                &posLHT,
                &DNT);

            NumDNTs++;

            pRestart->data[dataIndex] = DNT;

            if(problem == PA_PROBLEM_SIZE_LIMIT &&
               pRestart->data[dataIndex] == pDB->DNT ) {
                // Actually, we don't put the start DNT in this list.  In
                // the case of a restart for a size limit, we've verified
                // that the current object should be returned.  Part of that
                // verification meant checking this table for duplicates,
                // which adds the value to the table.  So, we need to make
                // sure that the object is NOT in the table, so that when we
                // restart, it still passes the duplicate test.
                NumDNTs--;
            }
            else {
                dataIndex++;
            }
        }
    }


    pRestart->structLen = offsetof(RESTART, data) + (dataIndex * sizeof(DWORD));
    pPackedHeader =(PACKED_KEY_HEADER *)pRestart->data;

    pPackedHeader->NumIndices = NumKeyIndices;
    pPackedHeader->NumDNTs = NumDNTs;

    *ppRestart = THReAllocEx(pTHS,
                             pRestart,
                             (offsetof(RESTART, data) +
                              (dataIndex * sizeof(DWORD))));
}


DWORD
DBCreateRestartForSAM(
        DBPOS    *pDB,
        PRESTART *ppRestart,
        eIndexId  idIndexForRestart,
        RESOBJ   *pResObj,
        DWORD     SamAccountType
        )
/*++

  Build a restart argument to allow SAM to make a call that looks like a
  restart.  We hand marshall the data, so we are sensitive to the data
  structures PACKED_KEY_HEADER and PACKED_KEY_INDEX

  INPUT
    pDB - the DBPOS to use
    idIndexForRestart - index to use for restarting.
    pResObj - the current Result Object
    SamAccountType - the AccountType that we are using

  OUTPUT
    ppRestart- where to put the Restart data

  RETURN
    0 on success, otherwise error (Jet error or DB_ERR_BAD_INDEX).

--*/
{
    THSTATE  *pTHS=pDB->pTHS;
    DWORD       cDwordSize=0;
    DWORD       cdwCurrentKey, cdwIndexKeys, cdwHeader, cdwIndex;
    DWORD       StartDNT;
    ULONG       SamAccountTypeUpperBound;
    ULONG       SamAccountTypeLowerBound;
    DWORD       err;
    CHAR        rgbKeyBMCurrent[DB_CB_MAX_KEY + DB_CB_MAX_KEY];
    DWORD       cbDBKeyCurrent = DB_CB_MAX_KEY;
    DWORD       cbDBBMCurrent = DB_CB_MAX_KEY;
    CHAR        rgbDBKeyUpper[DB_CB_MAX_KEY];
    DWORD       cbDBKeyUpper = DB_CB_MAX_KEY;
    CHAR        rgbDBKeyLower[DB_CB_MAX_KEY];
    DWORD       cbDBKeyLower = DB_CB_MAX_KEY;
    DWORD       cbIndexName;
    INDEX_VALUE IV[3];
    DWORD       dwError;
    PUCHAR      pBytes;
    PACKED_KEY_HEADER *pPackedHeader;
    PACKED_KEY_INDEX *pPackedIndex;
    char        *szIndexForRestart;

    *ppRestart = NULL;

    // Get the current DNT
    StartDNT = pDB->DNT;

    // size of the index name.
    if (idIndexForRestart == Idx_NcAccTypeName) {
        szIndexForRestart = SZ_NC_ACCTYPE_NAME_INDEX;
        cbIndexName = strlen(szIndexForRestart);
    }
    else {
        // we don't support other indexes for now.
        // so return a error
        cbIndexName = 0;    //avoid C4701
        return DB_ERR_BAD_INDEX;
    }

    // Get the current Key.
    err = JetGetSecondaryIndexBookmarkEx(pDB->JetSessID,
                                       pDB->JetObjTbl,
                                       rgbKeyBMCurrent,
                                       cbDBKeyCurrent,
                                       &cbDBKeyCurrent,
                                       rgbKeyBMCurrent + DB_CB_MAX_KEY,
                                       cbDBBMCurrent,
                                       &cbDBBMCurrent);
    if (err == JET_errNoCurrentIndex) {
        JetRetrieveKeyEx(pDB->JetSessID,
                        pDB->JetObjTbl,
                        rgbKeyBMCurrent,
                        cbDBKeyCurrent,
                        &cbDBKeyCurrent,
                        0);
        cbDBBMCurrent = 0;
        err = 0;
    } else {
        Assert( JET_errSuccess == err );
        memmove(rgbKeyBMCurrent + cbDBKeyCurrent,
                rgbKeyBMCurrent + DB_CB_MAX_KEY,
                cbDBBMCurrent);
    }

    //
    // Get the upper bound key. This requires seeking to the last
    // possible position in the current Index that can still Satisfy
    // us
    //

    SamAccountTypeUpperBound = SamAccountType + 1;
    IV[0].pvData = &pResObj->NCDNT;
    IV[0].cbData = sizeof(ULONG);
    IV[1].pvData = &SamAccountTypeUpperBound;
    IV[1].cbData = sizeof(ULONG);

    if(dwError = DBSeek(pDB, IV, 2, DB_SeekLE)) {
        return dwError;
    }

    //
    // Make the upper bound Key, we are either positioned on the last object
    // that is acceptable or the first object that is uacceptable
    //

    DBGetKeyFromObjTable(pDB,
                         rgbDBKeyUpper,
                         &cbDBKeyUpper);


    //
    // Get the lower bound key. First position on the first object
    // with the correct Sam account type value
    //

    SamAccountTypeLowerBound = SamAccountType - 1;
    IV[0].pvData = &pResObj->NCDNT;
    IV[0].cbData = sizeof(ULONG);
    IV[1].pvData = &SamAccountTypeLowerBound;
    IV[1].cbData = sizeof(ULONG);

    if(dwError = DBSeek(pDB, IV, 2, DB_SeekGE)) {
        return dwError;
    }

    //
    // Get the lower bound key. For purpose of the Restart Structure
    //

    DBGetKeyFromObjTable(pDB,
                         rgbDBKeyLower,
                         &cbDBKeyLower);


    // Now, allocate the size of the structure we need. Calculate the
    // DWORDS or DWORD equivalents we need.  We use DWORDs instead of bytes to
    // aid the process of leaving things aligned on DWORD boundaries.

    // First, the size of the current key.  Add one to the result of the
    // division to handle those cases where have some bytes left over (e.g. 4,
    // 5, 6, and 7 bytes end up using 2 DWORDs, even though 4 bytes only really
    // needs 1 DWORD. This calculation is faster, and not too much of a space
    // waste.
    cdwCurrentKey = (cbDBKeyCurrent + cbDBBMCurrent)/sizeof(DWORD) + 1;

    // Next, the size of the packed index name, upper, and lower bound keys.
    cdwIndexKeys = (cbIndexName + cbDBKeyUpper + cbDBKeyLower)/sizeof(DWORD) +1;


    // The size of the constant header portion
    cdwHeader = sizeof(PACKED_KEY_HEADER)/sizeof(DWORD);

    // The size of the constant Key Index portion;
    cdwIndex = sizeof(PACKED_KEY_INDEX)/sizeof(DWORD);

    // The whole size is the sum of those four sizes.
    cDwordSize = cdwHeader + cdwIndex + cdwCurrentKey + cdwIndexKeys;

    *ppRestart = THAllocEx(pTHS, offsetof(RESTART, data) + (cDwordSize * sizeof(DWORD)));
    (*ppRestart)->structLen = offsetof(RESTART, data) + (cDwordSize * sizeof(DWORD));

    pPackedHeader = (PACKED_KEY_HEADER *)(*ppRestart)->data;

    // OK, fill in the structure.
    pPackedHeader->NumIndices = 1;
    pPackedHeader->NumDNTs = 0;
    pPackedHeader->StartDNT = StartDNT;
    pPackedHeader->cbCurrentKey = cbDBKeyCurrent;
    pPackedHeader->cbCurrentBM = cbDBBMCurrent;
    pPackedHeader->ulSearchType = SE_CHOICE_WHOLE_SUBTREE;
    pPackedHeader->ulSorted = SORT_NEVER;
    pPackedHeader->indexType = GENERIC_INDEX_TYPE;
    pPackedHeader->bOnCandidate = FALSE;
    pPackedHeader->fChangeDirection = FALSE;
    pPackedHeader->dupDetectionType = DUP_NEVER;
    pPackedHeader->BaseResObj = *pResObj;
    pPackedHeader->BaseResObj.pObj = NULL;
    pPackedHeader->BaseGuid = pResObj->pObj->Guid;
    pPackedHeader->bOneNC = TRUE;
    pPackedHeader->SearchEntriesReturned = pDB->SearchEntriesReturned;
    pPackedHeader->SearchEntriesVisited = pDB->SearchEntriesVisited;

    memcpy(&pPackedHeader[1], rgbKeyBMCurrent, cbDBKeyCurrent + cbDBBMCurrent);

    // Now, the key index
    pPackedIndex = (PACKED_KEY_INDEX *)
        &(*ppRestart)->data[cdwHeader + cdwCurrentKey];

    // How many bytes in the index name?
    pPackedIndex->bPDNT = FALSE;
    pPackedIndex->bIsSingleValued = TRUE;
    pPackedIndex->bIsEqualityBased = FALSE;
    pPackedIndex->bIsForSort = FALSE;
    pPackedIndex->type = INVALID_ATT;
    pPackedIndex->cbIndexName = cbIndexName;
    pPackedIndex->cbDBKeyLower = cbDBKeyLower;
    pPackedIndex->cbDBKeyUpper = cbDBKeyUpper;

    // Now, pack the bytes of the data.
    pBytes = (PUCHAR)&pPackedIndex[1];

    memcpy(pBytes, szIndexForRestart, cbIndexName);
    pBytes = &pBytes[cbIndexName];

    memcpy(pBytes, rgbDBKeyLower, cbDBKeyLower);
    pBytes = &pBytes[cbDBKeyLower];

    memcpy(pBytes, rgbDBKeyUpper, cbDBKeyUpper);

    return 0;

}

RESOBJ *
ResObjFromRestart(THSTATE *pTHS,
                  DSNAME  * pDN,
                  RESTART * pRestart
                  )
{
    PACKED_KEY_HEADER *pPackedHeader;
    RESOBJ * pResObj;

    pPackedHeader = (PACKED_KEY_HEADER *)pRestart->data;

    pResObj = THAllocEx(pTHS, sizeof(RESOBJ));
    *pResObj = pPackedHeader->BaseResObj;
    pResObj->pObj = pDN;
    if (fNullUuid(&pDN->Guid)) {
        pDN->Guid = pPackedHeader->BaseGuid;
    }
    else {
        Assert(0 == memcmp(&pDN->Guid,
                           &pPackedHeader->BaseGuid,
                           sizeof(GUID)));
    }

    return pResObj;
}

DWORD
dbUnMarshallRestart (
        DBPOS FAR *pDB,
        PRESTART pArgRestart,
        BYTE *pDBKeyBMCurrent,
        DWORD SearchFlags,
        DWORD *cbDBKeyCurrent,
        DWORD *cbDBBMCurrent,
        DWORD *StartDNT
        )

/*++

  Hand unmarshall the data packed into the restart arg.  Note that we are
  sensitive to the data structures PACKED_KEY_HEADER and PACKED_KEY_INDEX

--*/
{
    THSTATE   *pTHS=pDB->pTHS;
    ULONG     *pData = (ULONG *)pArgRestart->data;
    PUCHAR     pBytes = NULL;
    KEY_INDEX *pIndex, **pIndexPrevNext;
    ULONG      ulTemp, NumKeyIndices, NumDNTs, cbIndexName, cbBytes, i;
    ATTCACHE  *pAC;
    PACKED_KEY_HEADER *pPackedHeader;
    PACKED_KEY_INDEX  *pPackedIndex;
    ULONG     *pEnd;
    DWORD     err;
    BOOL      fVLVsearch;
    VLV_SEARCH   *pVLV;
    DWORD     SortFlags = 0;

    Assert(VALID_DBPOS(pDB));

    // We've been seeing some corrupted restarts, so assert that the
    // buffer seems ok.  Further tests are included below for free builds.
    Assert(IsValidReadPointer(pArgRestart, pArgRestart->structLen));
    pEnd = pArgRestart->data + (pArgRestart->structLen/sizeof(ULONG));

    // Set up the key

    pPackedHeader = (PACKED_KEY_HEADER *)pArgRestart->data;

    NumKeyIndices = pPackedHeader->NumIndices;
    NumDNTs = pPackedHeader->NumDNTs;
    *StartDNT = pPackedHeader->StartDNT;
    *cbDBKeyCurrent = pPackedHeader->cbCurrentKey;
    *cbDBBMCurrent = pPackedHeader->cbCurrentBM;
    pDB->Key.ulSearchType = pPackedHeader->ulSearchType;
    pDB->Key.ulSearchRootDnt = pPackedHeader->BaseResObj.DNT;
    pDB->Key.ulSearchRootPDNT = pPackedHeader->BaseResObj.PDNT;
    pDB->Key.ulSearchRootNcdnt = pPackedHeader->BaseResObj.NCDNT;
    pDB->Key.bOneNC = pPackedHeader->bOneNC;
    pDB->Key.ulSorted = pPackedHeader->ulSorted;
    pDB->Key.indexType = pPackedHeader->indexType;
    pDB->Key.bOnCandidate = pPackedHeader->bOnCandidate;
    pDB->Key.fChangeDirection = pPackedHeader->fChangeDirection;
    pDB->Key.dupDetectionType = pPackedHeader->dupDetectionType;
    pDB->SearchEntriesReturned = pPackedHeader->SearchEntriesReturned;
    pDB->SearchEntriesVisited = pPackedHeader->SearchEntriesVisited;

    fVLVsearch = pPackedHeader->fVLVSearch;
    if (fVLVsearch) {
        Assert (pDB->Key.pVLV);
        pVLV = pDB->Key.pVLV;
        pVLV->contentCount = pPackedHeader->ulVLVContentCount;
        pVLV->currPosition = pPackedHeader->ulVLVTargetPosition;
        pVLV->cbCurrPositionKey = pPackedHeader->cbVLVCurrPositionKey;
        pVLV->bUsingMAPIContainer = pPackedHeader->bUsingMAPIContainer;
        pVLV->MAPIContainerDNT = pPackedHeader->MAPIContainerDNT;

        if (pVLV->bUsingMAPIContainer) {
            pDB->Key.ulSearchRootDnt = pVLV->MAPIContainerDNT;
            pDB->Key.ulSearchType = SE_CHOICE_IMMED_CHLDRN;
        }
    }

    // overwrite asqMode, to make sure we use what we stored
    pDB->Key.asqMode = pPackedHeader->asqMode;
    pDB->Key.ulASQLastUpperBound = pPackedHeader->ulASQLastUpperBound;

    // use ULONGLONG to avoid possible integer overflow
    if ((ULONGLONG)NumKeyIndices * sizeof(PACKED_KEY_INDEX) > pArgRestart->structLen) {
        // There is no way that this restart can be valid, because it's
        // not even long enough to hold its fixed data, much less any
        // variable data that goes with it.
        return DB_ERR_BUFFER_INADEQUATE;
    }

    if(pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE ||
       pDB->Key.indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE ||
       fVLVsearch) {
        // force dbMoveToNextSeachCandidate to to a JET_MoveFirst, not a
        // JET_MoveNext.
        pDB->Key.fSearchInProgress = FALSE;
    }
    else {
        pDB->Key.fSearchInProgress = TRUE;
    }

    pData = (DWORD *)(&pPackedHeader[1]);
    if (pEnd < (pData + (*cbDBKeyCurrent + *cbDBBMCurrent)/sizeof(DWORD))) {
        return DB_ERR_BUFFER_INADEQUATE;
    }
    memcpy(pDBKeyBMCurrent, pData, *cbDBKeyCurrent + *cbDBBMCurrent);
    pData = &pData[((*cbDBKeyCurrent + *cbDBBMCurrent) / sizeof(DWORD)) + 1];

    // now the VLV position
    if (pDB->Key.pVLV && pDB->Key.pVLV->cbCurrPositionKey) {
        if (pEnd < (pData + pDB->Key.pVLV->cbCurrPositionKey/sizeof(DWORD))) {
            return DB_ERR_BUFFER_INADEQUATE;
        }
        memcpy(pDB->Key.pVLV->rgbCurrPositionKey, pData, pDB->Key.pVLV->cbCurrPositionKey);
        pData = &pData[(pDB->Key.pVLV->cbCurrPositionKey / sizeof(DWORD)) + 1];
    }

    // Now, the Key Indices.
    pPackedIndex = (PACKED_KEY_INDEX *) pData;

    pDB->Key.pIndex = NULL;
    pIndexPrevNext = &pDB->Key.pIndex;
    while(NumKeyIndices) {
        // Test for buffer overrun
        if (pEnd < (pData + sizeof(PACKED_KEY_INDEX)/sizeof(DWORD))) {
            return DB_ERR_BUFFER_INADEQUATE;
        }

        // Unpack key indices
        pIndex = dbAlloc(sizeof(KEY_INDEX));
        pIndex->pNext = NULL;
        pIndex->bFlags = 0;
        *pIndexPrevNext = pIndex;
        pIndexPrevNext = &(pIndex->pNext);

        // We don't bother storing this.
        pIndex->ulEstimatedRecsInRange = 0;

        pIndex->bIsPDNTBased = pPackedIndex->bPDNT;
        pIndex->bIsSingleValued = pPackedIndex->bIsSingleValued;
        pIndex->bIsEqualityBased = pPackedIndex->bIsEqualityBased;
        pIndex->bIsForSort = pPackedIndex->bIsForSort;
        pIndex->pAC = SCGetAttById(pTHS,pPackedIndex->type);
        cbIndexName = pPackedIndex->cbIndexName;
        pIndex->pindexid = NULL;
        pIndex->cbDBKeyLower = pPackedIndex->cbDBKeyLower;
        pIndex->cbDBKeyUpper = pPackedIndex->cbDBKeyUpper;

        // Now, unpack the bytes of the data.
        pBytes = (PUCHAR)&pPackedIndex[1];
        cbBytes = (cbIndexName +
                   pIndex->cbDBKeyUpper +
                   pIndex->cbDBKeyLower  );
        if ((PUCHAR)pEnd < (pBytes + cbBytes)) {
            return DB_ERR_BUFFER_INADEQUATE;
        }

        pIndex->szIndexName = dbAlloc(cbIndexName+1);
        memcpy(pIndex->szIndexName, pBytes, cbIndexName);
        pIndex->szIndexName[cbIndexName] = 0;
        pBytes = &pBytes[cbIndexName];

        pIndex->rgbDBKeyLower = dbAlloc(pIndex->cbDBKeyLower);
        memcpy(pIndex->rgbDBKeyLower, pBytes, pIndex->cbDBKeyLower);
        pBytes = &pBytes[pIndex->cbDBKeyLower];

        pIndex->rgbDBKeyUpper = dbAlloc(pIndex->cbDBKeyUpper);
        memcpy(pIndex->rgbDBKeyUpper, pBytes, pIndex->cbDBKeyUpper);
        pBytes = &pBytes[pIndex->cbDBKeyUpper];

        // Now, adjust pData
        pData = (DWORD *)(&pPackedIndex[1]);
        pData = &pData[cbBytes/sizeof(DWORD) + 1];
        pPackedIndex = (PACKED_KEY_INDEX *)pData;

        // Keep pData aligned to ULONG packing
        NumKeyIndices--;
    }

    pData = (DWORD *)pPackedIndex;

    if (pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE ||
        pDB->Key.indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE) {
        if ( (pData + NumDNTs) > pEnd ) {
            return DB_ERR_BUFFER_INADEQUATE;
        }

        // force TEMP_TABLE_INDEX_TYPE to become TEMP_TABLE_MEMORY_ARRAY_TYPE
        pDB->Key.indexType = TEMP_TABLE_MEMORY_ARRAY_TYPE;

        if (pDB->Key.pDNTs) {
            pDB->Key.pDNTs = THReAllocEx(pTHS, pDB->Key.pDNTs, NumDNTs * sizeof(DWORD));
        }
        else {
            pDB->Key.pDNTs = THAllocEx(pTHS, NumDNTs * sizeof(DWORD));
        }
        pDB->Key.cdwCountDNTs = NumDNTs;


        memcpy (pDB->Key.pDNTs,
                pData,
                NumDNTs * sizeof (DWORD));

        pData += NumDNTs;
    }
    else {
        switch (pDB->Key.dupDetectionType) {
        case DUP_NEVER:
            // We're not actually tracking duplicates.  We'd better not have any
            // DNTs.
            Assert(!NumDNTs);
            break;

        case DUP_HASH_TABLE:
            Assert (!fVLVsearch);
            // We're tracking duplicates in a hash table.  Set it up.
            dbSearchDuplicateCreateHashTable( &pDB->Key.plhtDup );

            for(i=0;i<NumDNTs;i++) {
                LHT_ERR     errLHT;
                LHT_POS     posLHT;

                errLHT = LhtFindEntry(
                            pDB->Key.plhtDup,
                            &pData[i],
                            &posLHT);
                Assert( errLHT == LHT_errEntryNotFound );
                errLHT = LhtInsertEntry(
                            &posLHT,
                            &pData[i]);
                if (errLHT != LHT_errSuccess) {
                    Assert(errLHT == LHT_errOutOfMemory);
                    RaiseDsaExcept(
                        DSA_MEM_EXCEPTION,
                        0,
                        0,
                        DSID(FILENO, __LINE__),
                        DS_EVENT_SEV_MINIMAL);
                }
            }
            break;

        case DUP_MEMORY:
            Assert (!fVLVsearch);
            // We're tracking duplicates in a memory block.  Set it up.
            pDB->Key.pDupBlock = THAllocEx(pTHS, DUP_BLOCK_SIZE * sizeof(DWORD));
            pDB->Key.cDupBlock = NumDNTs;
            memcpy(pDB->Key.pDupBlock, pData, NumDNTs * sizeof(DWORD));
            break;

        default:
            // Huh?
            break;
        }
    }
    return 0;
}

#if DBG

BOOL IsValidDBPOS(DBPOS * pDB)
{
    THSTATE *pTHS = pTHStls;  // For assertion comparison
    DWORD    cTicks;

    // A null DBPOS is never valid
    if (NULL == pDB)
      return FALSE;

    // The DBPOS should be from this thread.
    if (pTHS != pDB->pTHS) {
        return FALSE;
    }

    if (pDB->fHidden) {
        // There should only be one hidden DBPOS
        if (pDB != pDBhidden) {
            return FALSE;
        }
    }
    else {
        // A normal, non-hidden DBPOS, which has links to its THSTATE info.

        // Except for the hidden DBPOS, our transaction levels should match
        // what out THSTATE thinks we have.
        if ((pDB->TransactionLevelAtOpen + pDB->transincount)
            > pTHS->JetCache.transLevel) {
            return FALSE;
        }

        if (0 != pTHS->JetCache.transLevel) {
            cTicks = GetTickCount() - pTHS->JetCache.cTickTransLevel1Started;
            Assert((cTicks <= gcMaxTicksAllowedForTransaction)
                   && "This transaction has been open for longer than it should "
                      "have been under normal operation.  "
                      "Please contact dsdev.");
        }
    }

    // There are only two valid values for this field, make sure we have
    // one of them.
    if (   (pDB->JetRetrieveBits != 0)
        && (pDB->JetRetrieveBits != JET_bitRetrieveCopy))
      return FALSE;

    return TRUE;

}
#endif


// Put the knowlege of how to create MAPI string DNs in one place.
#define MAPI_DN_TEMPLATE_W L"/o=NT5/ou=00000000000000000000000000000000/cn=00000000000000000000000000000000"
#define MAPI_DN_TEMPLATE_A "/o=NT5/ou=00000000000000000000000000000000/cn=00000000000000000000000000000000"
#define DOMAIN_GUID_OFFSET 10
#define OBJECT_GUID_OFFSET 46

DWORD
DBMapiNameFromGuid_W (
        wchar_t *pStringDN,
        DWORD  countChars,
        GUID *pGuidObj,
        GUID *pGuidNC,
        DWORD *pSize
        )
/*++
Description
    Given a buffer to hold a unicode value, and a count of chars in that buffer,
    and a guid, fill in that buffer with a MAPI DN.  Returns the length of the
    buffer (in characters.)  Checks the buffer size against the length, and if
    the buffer is not long enough, returns a length 0 (and an unmodified
    buffer).
--*/
{
    DWORD i;
    PUCHAR pucGuidObj = (PUCHAR) pGuidObj;
    PUCHAR pucGuidNC = (PUCHAR) pGuidNC;

    *pSize = (sizeof(MAPI_DN_TEMPLATE_A)-1);

    if(countChars <  *pSize) {
        // Hey, we don't have room.
        return 0;
    }

    memcpy(pStringDN, MAPI_DN_TEMPLATE_W, sizeof(MAPI_DN_TEMPLATE_W));
    // write in the domain and object guids.
    for(i=0;i<sizeof(GUID);i++) {
        wsprintfW(&(pStringDN[(2*i) + DOMAIN_GUID_OFFSET]),L"%02X",
                  pucGuidNC[i]);
        wsprintfW(&(pStringDN[(2*i) + OBJECT_GUID_OFFSET]),L"%02X",
                  pucGuidObj[i]);
    }
    pStringDN[OBJECT_GUID_OFFSET-4]=L'/';
    return (sizeof(MAPI_DN_TEMPLATE_A)-1);
}
DWORD
DBMapiNameFromGuid_A (
        PUCHAR pStringDN,
        DWORD countChars,
        GUID *pGuidObj,
        GUID *pGuidNC,
        DWORD *pSize
        )
/*++
Description
    Given a buffer to hold a 8 bit value, and a count of chars in that buffer,
    and a guid, fill in that buffer with a MAPI DN.  Returns the length of the
    buffer (in characters.)  Checks the buffer size against the length, and if
    the buffer is not long enough, returns a length 0 (and an unmodified
    buffer).
--*/
{
    DWORD i;
    PUCHAR pucGuidObj = (PUCHAR) pGuidObj;
    PUCHAR pucGuidNC = (PUCHAR) pGuidNC;

    *pSize = (sizeof(MAPI_DN_TEMPLATE_A)-1);

    if(countChars <  *pSize) {
        // Hey, we don't have room.
        return 0;
    }

    memcpy(pStringDN, MAPI_DN_TEMPLATE_A, sizeof(MAPI_DN_TEMPLATE_A));
    // write in the domain and object guids.
    for(i=0;i<sizeof(GUID);i++) {
        wsprintf(&(pStringDN[(2*i) + DOMAIN_GUID_OFFSET]),"%02X",
                 pucGuidNC[i]);
        wsprintf(&(pStringDN[(2*i) + OBJECT_GUID_OFFSET]),"%02X",
                 pucGuidObj[i]);
    }
    pStringDN[OBJECT_GUID_OFFSET-4]='/';
    return (sizeof(MAPI_DN_TEMPLATE_A)-1);
}

DWORD
DBGetGuidFromMAPIDN (
        PUCHAR pStringDN,
        GUID *pGuid
        )
/*++
Description
    Given a string DN and a pointer to a guid, fill in the guid based on the
    string DN if the String DN is a properly formatted NT5 default MAPI DN.
    Returns 0 on success, an error code otherwise.
--*/
{
    CHAR        acTmp[3];
    PUCHAR      pTemp, myGuid = (PUCHAR)pGuid;
    DWORD       i;

    if(strlen(pStringDN) != sizeof(MAPI_DN_TEMPLATE_A) - 1) {
        // Nope, we don't know what this thing is.
        return DB_ERR_UNKNOWN_ERROR;
    }

    // See if its ours
    if(_strnicmp(pStringDN, "/o=NT5/ou=", 10)) {
        // Nope, we don't know what this thing is.
        return DB_ERR_UNKNOWN_ERROR;
    }

    // OK, make sure the next 32 characters are a guid
    for(i=10;i<42;i++) {
        if(!isxdigit(pStringDN[i])) {
            // Nope
            return DB_ERR_UNKNOWN_ERROR;
        }
    }

    // Check to see if the name has a GUID in an ok place
    if (pStringDN[42] == '\0') {
        // The name has been truncated, and we want the domain GUID
        pTemp = &pStringDN[10];
    }
    else if(_strnicmp(&pStringDN[42],"/cn=",4)) {
        // Something we don't recognize
        return DB_ERR_UNKNOWN_ERROR;
    }
    else {
        // A normal three part name
        pTemp = &pStringDN[OBJECT_GUID_OFFSET];
    }

    // OK, the string looks ok, it is ours if the GUID is there

    acTmp[2]=0;
    for(i=0;i<16;i++) {
        acTmp[0] = (CHAR)tolower(*pTemp++);
        acTmp[1] = (CHAR)tolower(*pTemp++);
        if(isxdigit(acTmp[0]) && isxdigit(acTmp[1])) {
            myGuid[i] = (UCHAR)strtol(acTmp, NULL, 16);
        }
        else {
            return DB_ERR_UNKNOWN_ERROR;  // non-hex digit
        }
    }
    return 0;
}

// defined in the MAPI head.
extern DWORD
ABDispTypeFromClass (
        ATTRTYP objClass
        );

DWORD
dbMapiTypeFromObjClass (
        ATTRTYP objClass,
        wchar_t *pTemp
        )
{

    wsprintfW(pTemp, L"%02X", ABDispTypeFromClass(objClass));

    return 0;
}

void
DBNotifyReplicasCurrDbObj (
                           DBPOS *pDB,
                           BOOL fUrgent
                           )
/*++
Description:

    Notify the replicas of the NC of the object being modified that they need
    to do inbound replication.

    First, here we queue the NCDNT for the object on a per-thread notification
    list.

    Later, when the transaction commits in DbTransOut, we enqueue the NCDNT
    for the replica notification thread using NotifyReplica(). That routine
    dequeues the items and does the actual notification in mdnotify.c.

    Find the NCDNT for the object and queue it on a list inside the thread
    state.  pNotifyNCs list is a sorted, single linked list

    Postpone checks on the suitability of the NC (ie does it have replicas)
    until later.

Arguments:

    pDB - DBPOS positioned on the object
    fUrgent - Whether replication should occur immediately, or not

Return Values:

    None.

--*/
{
    THSTATE *pTHS = pDB->pTHS;
    PNCnotification pEntry, pPrev, pNew;
    ULONG ncdnt, err;
    SYNTAX_INTEGER it;

    DPRINT3(1,"DBNotifyreplicasCurrent, DNT=%d, NCDNT=%d, Urgent = %d\n",
            pDB->DNT, pDB->NCDNT, fUrgent);

    Assert(VALID_DBPOS(pDB));

    // do nothing if in singleusermode
    if (pTHS->fSingleUserModeThread) {
        return;
    }

    // Calculate the notify NCDNT of the object.
    // If the object is a NC_HEAD, use itself for its NCDNT
    // Ignore uninstantiated objects (pure subrefs)

    if (err = DBGetSingleValue( pDB, ATT_INSTANCE_TYPE, &it, sizeof(it), NULL)) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }
    if (it & IT_UNINSTANT) {
        return;
    } else if (it & IT_NC_HEAD) {
        ncdnt = pDB->DNT;
    } else {
        Assert( pDB->NCDNT );
        ncdnt = pDB->NCDNT;
    }

    // Locate existing entry in sorted list
    for( pPrev = NULL, pEntry = (PNCnotification) pTHS->pNotifyNCs;
        (pEntry != NULL);
        pPrev = pEntry, pEntry = pEntry->pNext ) {

        if (pEntry->ulNCDNT > ncdnt) {
            break;
        } else if (pEntry->ulNCDNT == ncdnt) {
            // Entry is already present in the list
            pEntry->fUrgent |= fUrgent; // Promote if needed
            return;
        }
    }

    // Enqueue a new notification
    pNew = (PNCnotification) dbAlloc( sizeof( NCnotification ) );
    pNew->ulNCDNT = ncdnt;
    pNew->fUrgent = fUrgent;
    pNew->pNext = pEntry;
    if (pPrev == NULL) {
        pTHS->pNotifyNCs = pNew;
    } else {
        pPrev->pNext = pNew;
    }

} /* DBNotifyReplicasCurrent */

void
DBNotifyReplicas (
                  DSNAME *pObj,
                  BOOL fUrgent
                  )
/*++
Description:

    Notify the replicas of the NC of the object being modified that they need
    to do inbound replication.

    See above routine.

    This routine is called with a DSNAME to be found

Arguments:

    pObj - DSNAME of object, whose NC is to be notified
    fUrgent - Whether replication should occur immediately, or not

Return Values:

    None.

--*/
{
    DBPOS *pDB;

    DPRINT2(1,"DBNotifyreplicas, DN='%ws', Urgent Flag = %d\n",
            pObj->StringName, fUrgent);

    // Open a new DB stream
    DBOpen2(FALSE, &pDB);
    __try
    {
        // Position on the object, verify existance
        if (DBFindDSName(pDB, pObj)) {
            __leave;
        }

        DBNotifyReplicasCurrDbObj( pDB, fUrgent );
    }
    __finally
    {
        DBClose(pDB, TRUE);
    }
} /* DBNotifyReplicas */

// convert from jet pages to megabytes by shifting right 7 (* 8k / 1mb)
#if JET_PAGE_SIZE != (8 * 1024)
    Fix the macro that converts jet pages to megabytes
#else
#define JET_PAGES_TO_MB(_pages) ((_pages) >> (20 - 13))
#endif

DB_ERR DBGetFreeSpace(DBPOS *pDB, ULONG* pulFreeMB, ULONG* pulAllocMB)
/*++
 * Description:
 *    Computes the amount of free space and total allocated space in the database
 *
 * Arguments:
 *    pDB           - DBPOS containing session to use
 *    pulFreeMB     - ULONG to return free mb
 *    pulAllocMB    - ULONG to return alloc mb
 *
 * Return value:
 *    JET error (if any)
 */
{
    JET_ERR err;
    unsigned long ulFreePages1, ulFreePages2, ulAllocPages;
    unsigned long ulFreeMB, ulAllocMB;

    Assert(pulFreeMB && pulAllocMB);

    // Allocated space
    err = JetGetDatabaseInfo(pDB->JetSessID,
                             pDB->JetDBID,
                             &ulAllocPages,
                             sizeof(ulAllocPages),
                             JET_DbInfoSpaceOwned);
    if (err != JET_errSuccess) {
        DPRINT1(0, "JetGetDatabaseInfo(DbinfoSpaceOwned) ==> %d\n", err);
        return err;
    }

    // Free space available in the database
    err = JetGetDatabaseInfo(pDB->JetSessID,
                             pDB->JetDBID,
                             &ulFreePages1,
                             sizeof(ulFreePages1),
                             JET_DbInfoSpaceAvailable);
    if (err != JET_errSuccess) {
        DPRINT1(0, "JetGetDatabaseInfo(DbInfoSpaceAvailable) ==> %d\n", err);
        return err;
    }

    // Plus free space available in the object table
    err = JetGetTableInfo(pDB->JetSessID,
                          pDB->JetObjTbl,
                          &ulFreePages2,
                          sizeof(ulFreePages2),
                          JET_TblInfoSpaceAvailable);
    if (err != JET_errSuccess) {
        DPRINT1(0, "JetGetTableInfo(ObjTbl, TblInfoSpaceAvailable) ==> %d\n", err);
        return err;
    }
    ulFreePages1 += ulFreePages2;

    // Plus free space available in the link table
    err = JetGetTableInfo(pDB->JetSessID,
                          pDB->JetLinkTbl,
                          &ulFreePages2,
                          sizeof(ulFreePages2),
                          JET_TblInfoSpaceAvailable);
    if (err != JET_errSuccess) {
        DPRINT1(0, "JetGetTableInfo(LinkTbl, TblInfoSpaceAvailable) ==> %d\n", err);
        return err;
    }
    ulFreePages1 += ulFreePages2;

    // Plus free space available in the SD table
    err = JetGetTableInfo(pDB->JetSessID,
                          pDB->JetSDTbl,
                          &ulFreePages2,
                          sizeof(ulFreePages2),
                          JET_TblInfoSpaceAvailable);
    if (err != JET_errSuccess) {
        DPRINT1(0, "JetGetTableInfo(SDTbl, TblInfoSpaceAvailable) ==> %d\n", err);
        return err;
    }
    ulFreePages1 += ulFreePages2;

    // Log the event for free vs. allocated space
    *pulFreeMB = JET_PAGES_TO_MB(ulFreePages1);
    *pulAllocMB = JET_PAGES_TO_MB(ulAllocPages);
    return 0;
}

void
DBDefrag(DBPOS *pDB, ULONG durationInSeconds)
/*++
 * Description:
 *    Invokes JET online defragmentation.  We don't have to wait for anything
 *    to finish, because the OLD thread will quietly exit when it finishes
 *    or when JetTerm is called, whichever comes first.  We tell OLD to make
 *    one pass through the database, but to only run for at most half a
 *    garbage collection interval, just so we can be sure that it doesn't
 *    run forever.
 *
 * Arguments:
 *    pDB  - DBPOS containing session to use
 *    durationInSeconds  -- the duration that online defrag will run.
 *                          -1:  default duration
 *                           0:  zero seconds (i.e. stop OLD)
 *                           n:  n seconds
 *
 * Return value:
 *    none
 */
{
    JET_ERR err;
    JET_GRBIT grbit;
    unsigned long ulFreeMB, ulAllocMB;
    unsigned long ulPasses = 1;
    unsigned long ulSeconds;

    if (durationInSeconds == -1) {
        ulSeconds = min( gulGCPeriodSecs/2, csecOnlineDefragPeriodMax );
        grbit = JET_bitDefragmentBatchStart;
    }
    else if (durationInSeconds == 0) {
        grbit = JET_bitDefragmentBatchStop;
    }
    else {
        ulSeconds = durationInSeconds;
        grbit = JET_bitDefragmentBatchStart;
    }

    // Log an event with free space vs. allocated space

    // Allocated space
    if (DBGetFreeSpace(pDB, &ulFreeMB, &ulAllocMB) == 0) {
        // Log the event for free vs. allocated space
        LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DB_FREE_SPACE,
                 szInsertUL(ulFreeMB),
                 szInsertUL(ulAllocMB),
                 NULL);
    }

    err = JetDefragment(pDB->JetSessID,
                        pDB->JetDBID,
                        NULL,
                        &ulPasses,
                        &ulSeconds,
                        grbit);
    DPRINT1((USHORT)(err == JET_errSuccess ? 1 : 0),
            "JetDefragment returned error code %d\n",
            err);
}

DWORD
DBGetDepthFirstChildren (
        DBPOS   *pDB,
        PDSNAME **ppNames,
        DWORD   *iLastName,
        DWORD   *cMaxNames,
        BOOL    *fWrapped,
        BOOL    fPhantomizeSemantics
        )
/*++
  pDB - DBPOS to use
  ppNames - where to put an array of PDSNAMEs
  iLastName - index of the end of the list.
  cMaxNames - size of allocated arrays of PDSNAMEs.
  fWrapped - set to TRUE if this routine runs out of room to allocate and
             overwrites values early in the list.
  fPhantomizeSemantics - return immediate children in full DSNAME format.

  For example, if the routine is limited to 5 values and 8 values need to be
  returned, like the following tree:

                   1
                 /   \
               2      5
             / \     /  \
            3   4   6    7
                          \
                           8


   the algorithm will start filling the 5 element array as follows:

   | 1 |   |   |   |   |
   | 1 | 2 | 5 |   |   |
   | 1 | 2 | 5 | 3 | 4 |
   | 6 | 7 | 5 | 3 | 4 |
   | 6 | 7 | 8 | 3 | 4 |

   The return values might look like this.
   ppNames = 6, 7, 8, 3, 4
   iLastName = 2
   cMaxNames = 5
   fWrapped = TRUE

   If all those objects were deleted, leaving the tree:

                   1
                 /   \
                2     5

   If the algorithm is run again:
   | 1 |   |   |   |   |
   | 1 | 2 | 5 |   |   |

   Then, the return values would look like
   ppNames = 1, 2, 5
   iLastName = 2
   cMaxNames = < doesn't matter >
   fWrapped = FALSE


   NOTE: The client has to delete the entries in the correct order:
         from iLastName to zero
         from cMaxNames to iLastName (if fWrapped == TRUE)


    BUGBUG: maybe we would like to re-write the algorithm to delete
            entries as we go:
            have an array that we keep the path in the tree that we
            are positioned at any time and delete all the leafs under
            this entry. if we encounter an entry that is not a leaf,
            add it to the array and continue from this entry. if the
            current entry has no more childs, remove it and continue
            with the last entry in the array.
--*/
{
    #define DEPTHFIRST_START_ENTRIES   (1024)
    #define DEPTHFIRST_MAX_ENTRIES     (DEPTHFIRST_START_ENTRIES * 16)

    THSTATE     *pTHS=pDB->pTHS;
    DWORD        parentIndex = 0;
    DWORD        ParentDNT;
    ATTCACHE    *pACDistName;
    INDEX_VALUE  IV[1];
    DWORD        len, iLastNameUsed;
    DWORD        err;
    DWORD        cAllocated = DEPTHFIRST_START_ENTRIES; // Initial allocation size
    PDSNAME     *pNames;
    DWORD        cParents = 0;
    BOOL         bSkipTest;

    pNames = THAllocEx(pTHS, cAllocated * sizeof(PDSNAME));
    *fWrapped = FALSE;

    IV[0].pvData = &ParentDNT;
    IV[0].cbData = sizeof(ParentDNT);

    *iLastName = 0;

    pACDistName = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME);
    Assert(pACDistName != NULL);
    // prefix complains about pAC beeing NULL, 447347, bogus since we are using constant


    // start by putting the root object in position 0.
    if (DBGetAttVal_AC(pDB,
                       1,
                       pACDistName,
                       DBGETATTVAL_fSHORTNAME,
                       0,
                       &len,
                       (PUCHAR *)&pNames[parentIndex])) {
        DPRINT(2,"Problem retrieving DN attribute\n");
        LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_RETRIEVE_DN,
                 szInsertSz(""),
                 NULL,
                 NULL);

        return DB_ERR_DSNAME_LOOKUP_FAILED;
    }

    // Set to the PDNT index
    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetObjTbl,
                               SZPDNTINDEX,
                               &idxPdnt,
                               0);

    iLastNameUsed = 1;

    // Get the children of the object in position parentIndex
    do {
        bSkipTest = FALSE;
        // find the children of the object at pNames[parentIndex]
        ParentDNT = DNTFromShortDSName(pNames[parentIndex]);

        // Now, set an index range in the PDNT index to get all the children.
        // Use GE because this is a compound index.
        err = DBSeek(pDB, IV, 1, DB_SeekGE);

        if((!err || err == JET_wrnSeekNotEqual) && (pDB->PDNT == ParentDNT)) {
            // OK, we're GE. Set an indexRange.
            if ( fPhantomizeSemantics && cParents++ ) {
                // Only evaluate first parent in phantomization case.
                break;
            }

            // set an index range on the children
            err = DBSetIndexRange(pDB, IV, 1);

            while(!err) {
                // First, see if this is a real, non-deleted object.
                if(fPhantomizeSemantics || (!DBIsObjDeleted(pDB) && DBCheckObj(pDB))) {

                    // Yep, it's a real object.
                    if (DBGetAttVal_AC(pDB,
                                       1,
                                       pACDistName,
                                       fPhantomizeSemantics
                                        ? DBGETATTVAL_fREALLOC
                                        : (DBGETATTVAL_fSHORTNAME
                                                    | DBGETATTVAL_fREALLOC),
                                       (pNames[iLastNameUsed]
                                        ? pNames[iLastNameUsed]->structLen
                                        : 0),
                                       &len,
                                       (PUCHAR *)&pNames[iLastNameUsed])) {
                        DPRINT(2,"Problem retrieving DN attribute\n");
                        LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                                 DS_EVENT_SEV_MINIMAL,
                                 DIRLOG_CANT_RETRIEVE_DN,
                                 szInsertSz(""),
                                 NULL,
                                 NULL);

                        return DB_ERR_DSNAME_LOOKUP_FAILED;
                    }

                    // we want to skip the test below, since we added at least
                    // one entry in the iLastNameUsed position, so if it just happens
                    // and iLastNameUsed and parentIndex are off by one, we don't
                    // want to exit, but keep going for one more round
                    bSkipTest = TRUE;

                    iLastNameUsed++;

                    if(iLastNameUsed == cAllocated) {
                        // We used up all the available space.
                        if(cAllocated < DEPTHFIRST_MAX_ENTRIES) { // Max allocation size
                            // That's OK, we'll just reallocate some more
                            cAllocated *= 2;
                            pNames =
                                THReAllocEx(pTHS,
                                            pNames,
                                            cAllocated * sizeof(PDSNAME));
                        }
                        else {
                            // We won't allow any more growth, so just wrap.
                            *fWrapped = TRUE;
                            iLastNameUsed = 0;
                        }
                    }

                    // if we have an overlap, we don't want to enumerate any
                    // more children of this parent. instead we want to check
                    // whether we have any more internal nodes in the list
                    if(iLastNameUsed == (parentIndex+1) ||
                       ((iLastNameUsed == cAllocated) && (parentIndex==0))) {

                        break;
                    }
                }
                // get next children
                err = DBMove(pDB, FALSE, DB_MoveNext);
            }
        }
        // advance to the next potential internal node
        parentIndex++;
        if(parentIndex == cAllocated) {
            parentIndex = 0;
        }

        // if we recently added an entry, we don't want to finish looking
        // for internal nodes.
        // otherwise, we stop looking whenever we exhausted all the possible
        // internal nodes (overlapping of parentIndex and iLastNameUsed)
    } while(bSkipTest || (parentIndex != iLastNameUsed));

    *iLastName = parentIndex;
    *cMaxNames = cAllocated;
    *ppNames = pNames;

    return 0;
}

char rgchPhantomIndex[] = "+" SZUSNCHANGED "\0+" SZGUID "\0";

DWORD
DBCreatePhantomIndex (
        DBPOS *pDB
        )
{
    JET_CONDITIONALCOLUMN condColumn;
    JET_INDEXCREATE       indexCreate;
    JET_UNICODEINDEX      unicodeIndexData;
    DWORD                 err;

    memset(&condColumn, 0, sizeof(condColumn));
    condColumn.cbStruct = sizeof(condColumn);
    condColumn.szColumnName = SZDISTNAME;
    condColumn.grbit =  JET_bitIndexColumnMustBeNull;

    memset(&indexCreate, 0, sizeof(indexCreate));
    indexCreate.cbStruct = sizeof(indexCreate);
    indexCreate.szIndexName = SZPHANTOMINDEX;
    indexCreate.szKey = rgchPhantomIndex;
    indexCreate.cbKey = sizeof(rgchPhantomIndex);
    indexCreate.grbit = (JET_bitIndexIgnoreNull |
                         JET_bitIndexUnicode    |
                         JET_bitIndexIgnoreAnyNull);
    indexCreate.ulDensity = 100;
    indexCreate.cbVarSegMac = 8;
    indexCreate.rgconditionalcolumn = &condColumn;
    indexCreate.cConditionalColumn = 1;
    indexCreate.err = 0;
    indexCreate.pidxunicode = &unicodeIndexData;

    memset(&unicodeIndexData, 0, sizeof(unicodeIndexData));
    unicodeIndexData.lcid = DS_DEFAULT_LOCALE;
    unicodeIndexData.dwMapFlags = (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                                      LCMAP_SORTKEY);


    err =  JetCreateIndex2(pDB->JetSessID, pDB->JetObjTbl, &indexCreate, 1);

    return err;
}


DWORD
DBUpdateUsnChanged(
        DBPOS *pDB
        )
{
    USN usnChanged;

    // Verify that we aren't already in a prepared update.
    Assert(pDB->JetRetrieveBits == 0);

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
    usnChanged = DBGetNewUsn();

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, usnchangedid,
                   &usnChanged, sizeof(usnChanged), 0, NULL);
    JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);

    return 0;
}

PDSNAME
DBGetCurrentDSName(
        DBPOS *pDB
        )
/*++
  Description:
     Semi-reliably get the dsname for the current object. That is, since
     phantoms don't have a dsname attribute, use the DNT and call sb table
     routines to turn it into the dsname.  Therefore, this routine works for
     both real objects and phantoms.
     Mostly, this is just a wrapper around sbTableGetDSName, which is not
     exported by the dblayer.

  Returns the dsname in thalloced memory.  NULL is returned if something went
  wrong (which should be quite rare).

--*/
{
    DWORD   rtn;
    DSNAME *pName=NULL;

    __try {
        if(rtn=sbTableGetDSName(pDB, pDB->DNT, &pName,0)) {
            DPRINT1(1,"DN DistName retrieval failed <%u>..returning\n",rtn);
            return NULL;
        }
    } __except (HandleAllExceptions(GetExceptionCode())) {
        pName = NULL;
    }

    return pName;
}

PDSNAME
DBGetDSNameFromDnt(
        DBPOS *pDB,
        ULONG ulDnt
        )
/*++
  Description:
     Semi-reliably get the dsname for the current object. That is, since
     phantoms don't have a dsname attribute, use the DNT and call sb table
     routines to turn it into the dsname.  Therefore, this routine works for
     both real objects and phantoms.
     Mostly, this is just a wrapper around sbTableGetDSName, which is not
     exported by the dblayer.

  Returns the dsname in thalloced memory.  NULL is returned if something went
  wrong (which should be quite rare).

--*/
{
    DWORD   rtn;
    DSNAME *pName=NULL;

    __try {
        if(rtn=sbTableGetDSName(pDB, ulDnt, &pName,0)) {
            DPRINT1(1,"DN DistName retrieval failed <%u>..returning\n",rtn);
            return NULL;
        }
    } __except (HandleAllExceptions(GetExceptionCode())) {
        pName = NULL;
    }

    return pName;
}

ULONG
DBGetDntFromDSName(
        DBPOS *pDB,
        PDSNAME pDN
        )
/*++

Description:

  Gets the DNT of the DN requested.  This routine is typically only used
  when you want to just get the DNT of a DN for comparison purposes, without
  changing the currency.

Arguments:
  pDB (IN) - Valid DBPOS, we don't change the currency of the object table
  pDN (IN) - The DN you want the DNT of.

Return:

    Returns the DNT of the pDN passed in, if there was some sort of error
    retrieving this, we return 0, which is an invalid DNT.

--*/
{
    DWORD   dwError;
    ULONG   ulDnt;

    Assert(VALID_DBPOS(pDB));

    dwError = sbTableGetTagFromDSName(pDB,
                                      (DSNAME*)pDN,
                                      0,
                                      &ulDnt,
                                      NULL);
    if (dwError) {
        return(INVALIDDNT);
    }
    return (ulDnt);
}


UCHAR *
DBGetExtDnFromDnt(
    DBPOS *pDB,
    ULONG ulDnt
    )

/*++

Routine Description:

Return a buffer containing the DN corresponding to a DNT.

We want to avoid disturbing the current DBPOS.

pString should be freed by the caller.

Arguments:

    pTHS -
    ulDnt -

Return Value:

    UCHAR * -

--*/

{
    char   errBuff[128];
    DSNAME *pDN = NULL;
    ULONG  len, err;
    UCHAR *pString;

    // Translate the backlink dnt if possible
    // pDN is null if this doesn't work
    pDN = DBGetDSNameFromDnt( pDB, ulDnt );
    if (!pDN) {
        sprintf(errBuff, "Error retrieving the DN attribute of DNT 0x%x", ulDnt);
        len = strlen(errBuff);
        pString = THAllocEx(pDB->pTHS, len+1);
        memcpy(pString, errBuff, len+1);
        return pString;
    }

    pString = MakeDNPrintable(pDN);

    THFreeEx( pDB->pTHS, pDN );

    return pString;
} /* GetExtDnFromDnt */

ULONG
DBClaimWriteLock(DBPOS *pDB)
{
    JetGetLockEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitWriteLock);
    return 0;
}

ULONG
DBClaimReadLock(DBPOS *pDB)
{
    JetGetLockEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitReadLock);
    return 0;
}


/* CountAncestorsIndexSize
 *
 * This routine (invoked off of the task queue) counts the ancestors index size.
 * This size is used in index optimizations by the filter optimizer.
 *
 * INPUT:
 *   A bunch of junk that we don't use, to match the task queue prototype
 * OUTPUT
 *   pcSecsUntilNextIteration: When the to schedule this task next
 */
void CountAncestorsIndexSize  (
    IN  void *  buffer,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )
{
    THSTATE             *pTHS = pTHStls;
    NAMING_CONTEXT_LIST *pNCL;
    ULONG                ulSizeEstimate;
    DBPOS               *pDB;
    DWORD                rootDNT = ROOTTAG;
    NCL_ENUMERATOR       nclEnum;

    Assert(!pTHS->pDB);
    DBOpen(&pTHS->pDB);
    Assert(pTHS->pDB);
    __try {
        pDB = pTHS->pDB;
        DPRINT(1,"Processing CountAncestorsIndexSize request\n");

        ulSizeEstimate = CountAncestorsIndexSizeHelper (pDB, sizeof (rootDNT), &rootDNT);

        if (ulSizeEstimate) {
            gulEstimatedAncestorsIndexSize = ulSizeEstimate;
        }
        else {
            gulEstimatedAncestorsIndexSize = 100000000;
        }

        DPRINT1 (1, "Estimated GC Ancestor Index Size: %d\n", gulEstimatedAncestorsIndexSize);

        NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
        // we are modifying global data here! no big deal since we don't update any ptrs
        while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
            pNCL->ulEstimatedSize = CountAncestorsIndexSizeHelper (pTHS->pDB,
                                                                   pNCL->cbAncestors,
                                                                   pNCL->pAncestors);

            DPRINT2 (1, "Estimated Ancestor Index Size for %ws = %d\n",
                              pNCL->pNC->StringName, pNCL->ulEstimatedSize);
        }
    }
    __finally {
            DBClose(pTHS->pDB, TRUE);
        *pcSecsUntilNextIteration = 33 * 60; // 33 minutes. why ? why not ?
    }
}

ULONG CountAncestorsIndexSizeHelper (DBPOS *pDB,
                                     DWORD  cbAncestors,
                                     DWORD *pAncestors)
{
    JET_ERR     err;
    DWORD       BeginNum, BeginDenom;
    DWORD       EndNum, EndDenom;
    DWORD       Denom;
    JET_RECPOS  RecPos;

    ULONG       dwException, ulErrorCode, dsid;
    PVOID       dwEA;

    ULONG       ulSizeEstimate = 0;

    DWORD       numAncestors;
    DWORD       cbAncestorsBuff;
    DWORD       *pAncestorsBuff;
    DWORD       realDNT, pseudoDNT;

    numAncestors = cbAncestors / sizeof (DWORD);
    Assert (numAncestors);

    if (numAncestors == 0) {
        return 0;
    }

    cbAncestorsBuff = cbAncestors;
    pAncestorsBuff = THAllocEx (pDB->pTHS, cbAncestors);
    memcpy (pAncestorsBuff, pAncestors, cbAncestors);

    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetSearchTbl,
                               SZANCESTORSINDEX,
                               &idxAncestors,
                               0);

    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetSearchTbl,
                 pAncestorsBuff,
                 cbAncestorsBuff,
                 JET_bitNewKey);

    err = JetSeekEx(pDB->JetSessID,
                    pDB->JetSearchTbl,
                    JET_bitSeekGE);

    if ((err == JET_errSuccess) ||
        (err == JET_wrnRecordFoundGreater)) {

        JetGetRecordPosition(pDB->JetSessID,
                             pDB->JetSearchTbl,
                             &RecPos,
                             sizeof(JET_RECPOS));
        BeginNum = RecPos.centriesLT;
        BeginDenom = RecPos.centriesTotal;

        numAncestors--;
        //pAncestorsBuff[numAncestors]++;

        // We thus take the last DNT and
        // byte swap it (so that it's in big-endian order), increment it,
        // and then re-swap it.  This gives us the DNT that would be next in
        // byte order.
        realDNT = pAncestorsBuff[numAncestors];
        pseudoDNT = (realDNT >> 24) & 0x000000ff;
        pseudoDNT |= (realDNT >> 8) & 0x0000ff00;
        pseudoDNT |= (realDNT << 8) & 0x00ff0000;
        pseudoDNT |= (realDNT << 24) & 0xff000000;
        ++pseudoDNT;
        realDNT = (pseudoDNT >> 24) & 0x000000ff;
        realDNT |= (pseudoDNT >> 8) & 0x0000ff00;
        realDNT |= (pseudoDNT << 8) & 0x00ff0000;
        realDNT |= (pseudoDNT << 24) & 0xff000000;

        pAncestorsBuff[numAncestors] = realDNT;



        JetMakeKeyEx(pDB->JetSessID,
                     pDB->JetSearchTbl,
                     pAncestorsBuff,
                     cbAncestorsBuff,
                     JET_bitNewKey | JET_bitStrLimit | JET_bitSubStrLimit);

        err = JetSeekEx(pDB->JetSessID,
                        pDB->JetSearchTbl,
                        JET_bitSeekLE);

        if ( (err == JET_errSuccess) ||
             (err == JET_wrnRecordFoundLess)) {

            JetGetRecordPosition(pDB->JetSessID,
                                 pDB->JetSearchTbl,
                                 &RecPos,
                                 sizeof(JET_RECPOS));

            EndNum = RecPos.centriesLT;
            EndDenom = RecPos.centriesTotal;

            // Normalize the fractions of the fractional position
            // to the average of the two denominators.
            // denominator
            Denom = (BeginDenom + EndDenom)/2;
            EndNum = MulDiv(EndNum, Denom - 1, EndDenom - 1) + 1;
            BeginNum = MulDiv(BeginNum, Denom - 1, BeginDenom - 1) + 1;

            if (BeginDenom == 1 || EndDenom == 1) {
                ulSizeEstimate = 1;
            } else if (EndNum >= BeginNum) {
                ulSizeEstimate = EndNum - BeginNum + 1;
            }
        }
    }

    return ulSizeEstimate;
}

DB_ERR
DBErrFromJetErr(
    IN  DWORD   jetErr
    )
{
    switch (jetErr) {
    case JET_errKeyDuplicate:
        return DB_ERR_ALREADY_INSERTED;

    case JET_errNoCurrentRecord:
        return DB_ERR_NO_CURRENT_RECORD;

    case JET_errRecordNotFound:
        return DB_ERR_RECORD_NOT_FOUND;

    default:
        return DB_ERR_DATABASE_ERROR;
    }
}


DB_ERR
DBTrimDSNameBy(
    DBPOS *pDB,
    DSNAME *pDNSrc,
    ULONG cava,
    DSNAME **ppDNDst
    )

/*++

Routine Description:

    Gets an ancestor's DSNAME.

    This routine trims AVAs from a DSNAME.  It uses the dnread cache. It returns a
    fully formed DSNAME including guid. It does not depend on the string name being valid.

    Unlike TrimDsNameBy, this routine is not purely syntactic. It returns a fully filled
    in DSNAME. It also can avoid any lookups by StringName if initial dsname has a guid.

    This routine positions on the source using its guid, and calculates its parent
    based on the database ancestry. The dsname returned is guaranteed to contain a
    guid if the parent has one.

    This routine is specifically designed to work in the case where string name of
    the source is not valid, but the guid is. This can occur during replica removal,
    where a grandparent partition may have been removed, making our current string
    name invalid.

    This routine uses the dn read cache and the search table. It does not assume, nor
    affect, currency in the object table.

Arguments:

    pDB - database position

    pDNSrc - the source Dsname. May or may not have a guid.

    cava - the number of AVAs to remove from the first name

    ppDNDst - pointer to dsname *, to receive pointer to called new name

Return Value:

    DB_ERR -

--*/

{
    DWORD err, dnt;
    d_memname *pname = NULL;

    Assert( !IsRoot(pDNSrc) );

    // Take the defaults:
    // Do check type of RDN, Don't make current, and Do use search table
    err = sbTableGetTagFromDSName( pDB, pDNSrc, 0, NULL, &pname );
    if (err) {
        return err;
    }
    if (!pname) {
        return ERROR_DS_INVALID_DN_SYNTAX;
    }

    if ( (cava == 0) || (cava >= pname->cAncestors) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // pAncestors is an array of dnts.
    // pAncestors[0] is the root, and
    // pAncestors[pname->cAncestors - 1] is the object itself.

    dnt = pname->pAncestors[pname->cAncestors - 1 - cava];

    return sbTableGetDSName( pDB, dnt, ppDNDst, 0 );

} /* DBTrimDSNameBy */


DB_ERR
DBRefreshDSName(
    DBPOS *pDB,
    DSNAME *pDNSrc,
    DSNAME **ppDNDst
    )

/*++

Routine Description:

    This routine positions on the source (using its guid or its name), and returns the
    most current dsname of the object. The dsname returned is guaranteed to contain a
    guid.

    This routine is specifically designed to work in the case where string name of
    the source is not valid, but the guid is. This can occur during replica removal,
    where a grandparent partition may have been removed, making our current string
    name invalid.

    This routine uses the dn read cache and the search table. It does not assume, nor
    affect, currency in the object table.

Arguments:

    pDB -
    pDNSrc - DSName of the object to be refreshed
    ppDNDst - Updated dsname

Return Value:

    DB_ERR -

--*/

{
    DWORD err, dnt;
    d_memname *pname = NULL;

    // Take the defaults:
    // Do check type of RDN, Don't make current, and Do use search table
    err = sbTableGetTagFromDSName( pDB, pDNSrc, 0, NULL, &pname );
    if (err) {
        return err;
    }
    if (!pname) {
        return ERROR_DS_INVALID_DN_SYNTAX;
    }

    return sbTableGetDSName( pDB, pname->DNT, ppDNDst, 0 );

} /* DBRefreshDSName */



BOOL
DBHasChildren(
    DBPOS *pDB,
    DWORD  pdnt,
    BOOL   fIncludeDel
    )
/*++

    This function returns TRUE if there are children below the supplied
    pdnt.  This function is primarily used to validate that there are no
    children below the supplied pdnt.

Arguments:

    pDB - A DBPOS to use.
    pdnt - The DNT of the parent object to check for children under.
    fIncludeDel - Include deleted children in the call or not.

Return Value:

    BOOL - TRUE if there are children, FALSE if there are not
    Throws exceptions for unexpected DB errors.

--*/
{
    DWORD tag;
    JET_ERR               dwError;
    char                  fObject = TRUE;
    long                  actuallen;
    DWORD                 ulTempDNT;
    BOOL                  fDeleted = FALSE;
    JET_RETRIEVECOLUMN    attList[2];

    Assert(VALID_DBPOS(pDB));

    // throws exceptions
    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetSearchTbl,
                               SZPDNTINDEX,
                               &idxPdnt,
                               0);

    // throws exceptions
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetSearchTbl,
                 &pdnt,
                 sizeof(pdnt),
                 JET_bitNewKey);

    dwError = JetSeek(pDB->JetSessID,
                      pDB->JetSearchTbl,
                      JET_bitSeekGE);
    Assert(dwError && "Seek equal on a JET_bitSeekGE?");
    if(! (dwError == JET_wrnRecordFoundGreater ||
          dwError == JET_errSuccess) ){
        // This means there was no children.
        return(FALSE);
    }

    // Means there's something!

    // first the isObj attr/column
    attList[0].pvData = &fObject;
    attList[0].columnid = objid;
    attList[0].cbData = sizeof(fObject);
    attList[0].grbit = pDB->JetRetrieveBits;
    attList[0].itagSequence = 1;
    attList[0].ibLongValue = 0;

    // then the isDeleted attr/column
    attList[1].pvData = &fDeleted;
    attList[1].columnid = isdeletedid;
    attList[1].cbData = sizeof(fDeleted);
    attList[1].grbit = pDB->JetRetrieveBits;
    attList[1].itagSequence = 1;
    attList[1].ibLongValue = 0;

    while(TRUE){

        // Currency on the object of interest.

        // throws exceptions
        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 pDB->JetSearchTbl,
                                 pdntid,
                                 &ulTempDNT,
                                 sizeof(ulTempDNT),
                                 &actuallen,
                                 pDB->JetRetrieveBits,
                                 NULL);

        if(ulTempDNT != pdnt){
            // No more children of the parent, break.
            break;
        }

        dwError = JetRetrieveColumnsWarnings(pDB->JetSessID,
                                             pDB->JetSearchTbl,
                                             attList,
                                             2);

        if(dwError != JET_errSuccess &&
           dwError != JET_wrnColumnNull){
            Assert(!"Unexpected DB Exception!");
            DsaExcept(DSA_DB_EXCEPTION, attList[0].err, 0);
        }

        // First take care of fObject
        if(attList[0].err != JET_wrnColumnNull &&
           attList[0].err != JET_errSuccess){
            Assert(!"DB Exception trying to read objid!");
            DsaExcept(DSA_DB_EXCEPTION, attList[0].err, 0);
        }
        // An wrnColumnNull means we've got a phantom.
        if(attList[0].err == JET_wrnColumnNull){
            fObject = FALSE;
        }

        // Second take care of fDeleted, an error in getting the
        // isdeleteid column means it's not deleted.
        if(attList[1].err){
            fDeleted = FALSE;
        }

        // Heart of the logic ...
        if(fObject && (fIncludeDel || !fDeleted)){
            // Real Object!!!!   Finally, return TRUE.
            return(TRUE);
        }

        // Increment to next object.  Throws exceptions.
        dwError = JetMoveEx(pDB->JetSessID, pDB->JetSearchTbl, JET_MoveNext, 0);
        Assert(dwError == JET_errSuccess || dwError == JET_errNoCurrentRecord);
        if(dwError == JET_errNoCurrentRecord){
            // expected, means we've run off the last index value
            break;
        }

    }

    // If we walked all the entries in the PDNT index with this pRes->DNT and
    // none of them had OBJ set, then there aren't any children.
    return(FALSE);

}

ULONG
DBReplaceHiddenTableBackupCols(
    BOOL        fSetUsnAtBackup,
    BOOL        fSetBackedupDitState,
    BOOL        fUnSetBackupState,
    DSTIME      dstimeBackupExpiration,
    USN         usnAtBackup
    )
/*++

    Write to the hidden backup state, that represents the validity
    state of this DIT.  For Legacy backups we'll only be writing the
    "usn at backup" column.  For snapshot backups, we set the dstate
    to eBackedupDit in the "DITSTATE" column, and finally we also
    set the time in "SecondsSince1601()" that the backup will expire
    in the "backup expiration" column.  Finally for snapshot end
    backup/clean up we reset the DITSTATE to eRunning, and we set the
    backup expired column to 0.


Arguments:

    fSetUsnAtBackup - TRUE for legacy and snapshot backup preperation
    fSetBackedupDitState - TRUE for snapshot backup prep time
    fUnSetBackupState - TRUE for inidicating snapshot backup clean up time
    dstimeBackupExpiration - time in SecondsSince1601() when backup expires
    usnAtBackup - value to write

Return Value:

    0 on success, an error, or also exceptions are errors

--*/
{
    JET_ERR         err;
    BOOL            fCommit = FALSE, fTHSLazy = FALSE;
    THSTATE *       pTHS = pTHStls;
    DBPOS *         pDB = NULL;
    DWORD           dwTemp;
    DITSTATE        eDitState = eMaxDit;

    pDB = dbGrabHiddenDBPOS(pTHS);
    Assert(pDB);

    /* Durable transactions which are nested might in fact end up being lazy.
     * Since updating the USNs must not be done lazily, this transaction must
     * not be nested. */
    Assert( 0 == pDB->transincount );

    // If fSetBackupState is set, we better have been provided an expiration.
    Assert(!fSetBackedupDitState || dstimeBackupExpiration);

    __try
    {
        /* Save the thread state's lazy flag and clear it */
        Assert( pDB->pTHS == pTHS );
        fTHSLazy = pTHS->fLazyCommit;
        pTHS->fLazyCommit = FALSE;

        DBTransIn(pDB);
        __try {

            if (err = JetMoveEx(pDB->JetSessID, HiddenTblid, JET_MoveFirst, NO_GRBIT)){
                Assert(!"JetMoveEx() to first/only record failed on hidden table, can this really happen?");
                __leave;
            }

            JetPrepareUpdateEx(pDB->JetSessID, HiddenTblid, JET_prepReplace);

            //
            // Set the Backup USN column
            //
            if (fSetUsnAtBackup) {
                Assert(usnAtBackup); // I'll bet this is never 0
                JetSetColumnSuccess(pDB->JetSessID, HiddenTblid, jcidBackupUSN,
                               &usnAtBackup, sizeof(usnAtBackup),
                               NO_GRBIT, NULL);
            }

            //
            // Set the expiration of this backup (calculated from tombstone lifetime)
            //
            if (dstimeBackupExpiration || fUnSetBackupState) {
                if (fUnSetBackupState) {
                    Assert(dstimeBackupExpiration == 0);
                    dstimeBackupExpiration = 0;
                }
                JetSetColumnSuccess(pDB->JetSessID, HiddenTblid, jcidBackupExpiration,
                               &dstimeBackupExpiration, sizeof(dstimeBackupExpiration),
                               NO_GRBIT, NULL);

            }

            //
            // Set the DitState enum, so we know this DIT is backed up.
            //
            if (fSetBackedupDitState || fUnSetBackupState) {
                // Ensure valid params
                Assert(fSetBackedupDitState != fUnSetBackupState);
                JetRetrieveColumnSuccess(pDB->JetSessID, HiddenTblid,
                                         dsstateid,
                                         &eDitState, sizeof(eDitState), &dwTemp,
                                         NO_GRBIT,
                                         NULL);
                Assert(dwTemp == sizeof(eDitState));
                if (eDitState != eRunningDit &&
                    eDitState != eBackedupDit &&
                    eDitState != eRestoredPhaseI) {
                    Assert(!"The DIT should always be in one of these two states");
                    err = ERROR_INVALID_PARAMETER;
                    __leave;
                }
                Assert( (fSetBackedupDitState && (eDitState == eRunningDit)) ||
                        (fUnSetBackupState && (eDitState == eRunningDit)) ||
                        (fUnSetBackupState && (eDitState == eBackedupDit)) ||
                        (fUnSetBackupState && (eDitState == eRestoredPhaseI)) );

                // Set to the appropriate state.
                eDitState = fSetBackedupDitState ? eBackedupDit : eRunningDit;
                JetSetColumnSuccess(pDB->JetSessID, HiddenTblid, dsstateid,
                               &eDitState, sizeof(eDitState),
                               NO_GRBIT, NULL);

            }

            JetUpdateEx(pDB->JetSessID, HiddenTblid, NULL, 0, NULL);

            //
            // Success.
            //
            fCommit = TRUE;

        } __finally {

            if (!fCommit) {
                dwTemp = JetPrepareUpdateEx(pDB->JetSessID, HiddenTblid, JET_prepCancel);
                Assert(dwTemp == JET_errUpdateNotPrepared);

            }

            DBTransOut(pDB, fCommit, FALSE);
        }

    } __finally {

        dbReleaseHiddenDBPOS(pDB);

        /* Restore the thread state's lazy flag */
        pTHS->fLazyCommit = fTHSLazy;
    }

    if (fCommit == FALSE) {
        // If we didn't commit, then this DB is not prepared for backup!
        // This is bad, because a snapshow restore with this backup, would
        // fail to change it's Invocation ID, so we need to fail this
        // backup.
        return(err ? err : ERROR_DS_INTERNAL_FAILURE);
    }

    return(ERROR_SUCCESS);
}



ULONG
DBDsReplBackupUpdate(
    BOOL        fSetUsnAtBackup,
    BOOL        fSetBackupState,
    BOOL        fUnSetBackupState,
    DSTIME      dstimeBackupExpiration,
    DWORD       dwDSID
    )
/*++

    Externally called function by backup to prepare the DS for backup.

Arguments:

    fSetUsnAtBackup - TRUE for legacy and snapshot backup preperation
    fSetBackedupDitState - TRUE for snapshot backup prep time
    fUnSetBackupState - TRUE for inidicating snapshot backup clean up time
    dstimeBackupExpiration - time in SecondsSince1601() when backup expires
    usnAtBackup - value to write

Return Value:

    Win32 Error.

--*/
{
    USN usnBackup = 0;
    ULONG ret = ERROR_SUCCESS;

    if (fSetUsnAtBackup) {
        // No reason to do this unless we have to.  One of the things we
        // need to do to prepare for a backup is to write the usn before
        // backup to the hidden table so that we can read it back during
        // restore, to optimize how we catch up with replication, and to
        // ensure that we don't get any replication USN gaps.
        usnBackup = DBGetHighestCommittedUSN();
    }

    THCreate(CALLERTYPE_INTERNAL);

    __try {

        // Note this function must force any outstanding lazy updates to
        // disk, so that the highest committed USN is indeed the highest
        // committed USN.
        ret = DBReplaceHiddenTableBackupCols(fSetUsnAtBackup,
                                             fSetBackupState,
                                             fUnSetBackupState,
                                             dstimeBackupExpiration,
                                             usnBackup);

    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        // This is fatal for snapshot backup, but not for normal backup,
        // but for consistency we'll fail either way.
        ret = ERROR_DS_INTERNAL_FAILURE;
    }

    if (ret) {
        if (fUnSetBackupState) {
            LogEvent(DS_EVENT_CAT_BACKUP,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BACKUP_UNREGISTERING_DB_BACKUP_FAILED,
                     szInsertWin32ErrCode(ret),
                     szInsertWin32Msg(ret),
                     NULL);
        } else {
            LogEvent(DS_EVENT_CAT_BACKUP,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BACKUP_DS_DB_PREPARE_FAILURE,
                     szInsertWin32ErrCode(ret),
                     szInsertWin32Msg(ret),
                     szInsertHex(dwDSID));
        }
    }

    THDestroy();
    return ret;
}


ULONG
DBGetOrResetBackupExpiration(
    DSTIME *  pllExpiration
    )
/*++

    This either gets or resets the backup expiration column.

Arguments:

    pllExpiration - A NULL indicates you want the function to erase
        the current backup expiration time.  A non-NULL assumes you've
        passed in a pointer to an allocated dstime structure that we'll
        fill with the current backup expiration time from the hidden
        table.

Return Value:

    Win32 Error

--*/
{
    ULONG           ret = ERROR_SUCCESS;
    ULONG           cbExpiration = 0;
    DBPOS *         pDB;
    JET_ERR         err;
    BOOL            fCommit = FALSE;
    DSTIME          llNullTime = 0;

    pDB = dbGrabHiddenDBPOS(pTHStls);
    Assert(pDB);
    Assert( 0 == pDB->transincount );

    __try {

        __try {
            DBTransIn(pDB);
            __try {

                // Move to first (only) record in table
                if (err = JetMoveEx(pDB->JetSessID, HiddenTblid, JET_MoveFirst, NO_GRBIT)) {
                    __leave;
                }

                if (pllExpiration == NULL) {

                    //
                    // Reset the expiration.
                    //
                    JetPrepareUpdateEx(pDB->JetSessID, HiddenTblid, JET_prepReplace);

                    JetSetColumnEx(pDB->JetSessID, HiddenTblid, jcidBackupExpiration,
                                   &llNullTime, sizeof(llNullTime),
                                   NO_GRBIT, NULL);

                    JetUpdateEx(pDB->JetSessID, HiddenTblid, NULL, 0, NULL);

                } else {

                    //
                    // Just return the expiration.
                    //
                    JetRetrieveColumnSuccess(pDB->JetSessID,
                                             HiddenTblid,
                                             jcidBackupExpiration,
                                             pllExpiration,
                                             sizeof(*pllExpiration),
                                             &cbExpiration,
                                             NO_GRBIT,
                                             NULL);
                    Assert(sizeof(*pllExpiration) == cbExpiration);

                }


                fCommit = TRUE;
                err = 0;
            }
            __finally {
                if (!fCommit) {
                    JetPrepareUpdate(pDB->JetSessID, HiddenTblid, JET_prepCancel);
                }
                DBTransOut(pDB, fCommit, FALSE);
            }
        } __except (HandleMostExceptions(GetExceptionCode())) {
            /* Do nothing, but at least don't die */
            err = DB_ERR_EXCEPTION;
        }

    } __finally {

        dbReleaseHiddenDBPOS(pDB);

    }

    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\draasync.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       draasync.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database

#include <dsaapi.h>
#define INCLUDE_OPTION_TRANSLATION_TABLES
#include <mdglobal.h>                   // MD global definition header
#undef INCLUDE_OPTION_TRANSLATION_TABLES

#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <dsconfig.h>
#include <windns.h>

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dsutil.h"

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/


#include "debug.h"                      /* standard debugging header */
#define DEBSUB     "DRAASYNC:"          /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "draasync.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dstaskq.h"                    /* task queue stuff */
#include <ntdsctr.h>
#include "dsexcept.h"
#include "dramail.h"
#include "draaudit.h"

#include <fileno.h>
#define  FILENO FILENO_DRAASYNC

#define THIRTY_MINUTES_IN_MSECS  (30*60*1000)
#define THIRTY_5_MINUTES_IN_SECS (35*60)

DWORD
draTranslateOptions(
    IN  DWORD                   InternalOptions,
    IN  OPTION_TRANSLATION *    Table
    );

#if DBG
// Do not query directly -- use helper function below.
BOOL g_fDraQueueIsLockedByTestHook = FALSE;

BOOL
draQueueIsLockedByTestHook(
    IN  DWORD   cNumMsecToWaitForLockRelease
    );
#endif

// If we have any operations in the queue at this priority or higher we will
// automatically boost AsyncThread's thread priority.
ULONG gulDraThreadOpPriThreshold = DEFAULT_DRA_THREAD_OP_PRI_THRESHOLD;

void dsa_notify(void);

DWORD TidDRAAsync = 0;

// The AO currently being worked on (sync or async).  Guarded by csAOList.
AO *gpaoCurrent = NULL;

// csAsyncThreadStart - guards multiple async thread starts.

CRITICAL_SECTION csAsyncThreadStart;

// csAOList - guards the async op list.

CRITICAL_SECTION csAOList;

// csLastReplicaMTX - guards pLastReplicaMTX
CRITICAL_SECTION csLastReplicaMTX;

// This is the count of async operations in the queue. We count operations
// in and out, and when there are none left, we assert that this is zero.
// Updates to this are shielded by csAOList.
ULONG gulpaocount = 0;

// This is how large we'll let gulpaocount grow before we increase the
// priority of the AyncThread
ULONG gulAOQAggressionLimit = DEFAULT_DRA_AOQ_LIMIT;

// Priorities for the DRA async thread.  Low vs. high is controlled by
// gulAOQAggressionLimit and gulDraThreadOpPriThreshold.
int gnDraThreadPriHigh = DEFAULT_DRA_THREAD_PRI_HIGH;
int gnDraThreadPriLow  = DEFAULT_DRA_THREAD_PRI_LOW;

// hmtxSyncLock
// Ensures that only one DRA operation (with the exception of getncchanges)
// runs at a time.

HANDLE hmtxSyncLock;

// paoFirst
// First pao in the list

AO *paoFirst = NULL;

// hevEntriesInAOList
// Event is unsignalled if no (unserviced) entries in async op list,
// signalled otherwise. This is cleared by AsyncOpThread after  servicing
// the last entry and signalled by AddAsyncOp when a new entry is added.

HANDLE hevEntriesInAOList = 0L;

// hevDRASetup
// Event is signalled when the DRA has been initialized

HANDLE hevDRASetup = 0L;

/* fAsyncThreadExists - Does the Async Op service thread exist? This thread
        is created the first time an async op is called, after that it lives
        forever.
*/
BOOL fAsyncThreadExists = FALSE;
HANDLE hAsyncThread;
HANDLE hmtxAsyncThread;

// fAsyncThreadAlive. Cleared by daemon, set by async thread,

BOOL fAsyncThreadAlive;

// fAsyncCheckStarted. Is the daemon started?
BOOL fAsyncAndQueueCheckStarted=FALSE;
ULONG gulReplQueueCheckTime;

DWORD lastSeen;         // Last thing async thread did

// gfDRABusy. Indicates DRA is busy doing something. When we detect
// that the async thread appears to be hung, we check that this flag
// to ensure that the DRA is not busy on a long async or sync
// task (such as synchronization).

BOOL gfDRABusy = FALSE;

// Time at which execution of the current AO began, or 0 if none.
DSTIME gtimeOpStarted = 0;

// Unique ID (per machine, per boot) for this AO.
ULONG gulSerialNumber = 0;

// Maximum number of mins we have to wait for a replication job before we
// whine to the event log.  Optionally configured via the registry.
ULONG gcMaxMinsSlowReplWarning = 0;

// Forward declarations

void CheckAsyncThread();
void CheckReplQueue();
void CheckAsyncThreadAndReplQueue(void *pv, void **ppvNext, DWORD *pcSecsUntilNext);

void GetDRASyncLock()
{
retrydrasl:

    if (WaitForSingleObject(hmtxSyncLock, THIRTY_MINUTES_IN_MSECS)) {
        if (!gfDRABusy) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                        DS_EVENT_SEV_BASIC,
                        DIRLOG_DRA_DISPATCHER_TIMEOUT,
                        NULL,
                        NULL,
                        NULL);
        }
        goto retrydrasl;
    }
    Assert( TidDRAAsync == 0 ); // No recursive ownership
    TidDRAAsync = GetCurrentThreadId();
    Assert( TidDRAAsync != 0 );
}

void FreeDRASyncLock ()
{
    // We better own it
    Assert(OWN_DRA_LOCK());
    // Do this first so there won't be a timing window where the var is set
    // once the mutex is released.
    TidDRAAsync = 0;

    if (!ReleaseMutex(hmtxSyncLock)) {
        DWORD dwret;
        dwret = GetLastError();
        Assert (FALSE);
    }
}


void
FreeAO(
    IN  AO *  pao
    )
/*++

Routine Description:

    Free the given AO structure.

Arguments:

    pao (IN) - Pointer to AO structure to free.

Return Values:

    None.

--*/
{
    if (AO_OP_REP_SYNC == pao->ulOperation) {
        DEC(pcPendSync);
    }
    DEC(pcDRAReplQueueOps);

    if (pao->hDone) {
        CloseHandle(pao->hDone);
    }

    free(pao);
}

void logEventPaoFinished(
    AO *pao,
    DWORD cMinsDiff,
    DWORD ret
    )
{
    DPRINT4( 0, "Perf warning: Repl op %d, options 0x%x, status %d took %d mins.\n",
             pao->ulOperation, pao->ulOptions, ret, cMinsDiff );

    // szInsertDN can handle null arguments
    // Do we need a new event category for performance advisories?

    switch (pao->ulOperation) {

    case AO_OP_REP_ADD:
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_DRA_REPLICATION_FINISHED,
                  szInsertUL(cMinsDiff),
                  szInsertDsMsg( DIRLOG_PAO_ADD_REPLICA ),
                  szInsertHex(pao->ulOptions),
                  szInsertWin32Msg(ret),
                  szInsertDN(pao->args.rep_add.pNC),
                  szInsertDN(pao->args.rep_add.pSourceDsaDN), // opt
                  szInsertDN(pao->args.rep_add.pTransportDN), // opt
                  szInsertMTX(pao->args.rep_add.pDSASMtx_addr)
            );
        break;
    case AO_OP_REP_DEL:
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_DRA_REPLICATION_FINISHED,
                  szInsertUL(cMinsDiff),
                  szInsertDsMsg( DIRLOG_PAO_DELETE_REPLICA ),
                  szInsertHex(pao->ulOptions),
                  szInsertWin32Msg(ret),
                  szInsertDN(pao->args.rep_del.pNC),
                  szInsertMTX(pao->args.rep_del.pSDSAMtx_addr),
                  szInsertSz(""),  // unused parameter
                  szInsertSz("") // unused parameter
            );
        break;
    case AO_OP_REP_SYNC:
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_DRA_REPLICATION_FINISHED,
                  szInsertUL(cMinsDiff),
                  szInsertDsMsg( DIRLOG_PAO_SYNCHRONIZE_REPLICA ),
                  szInsertHex(pao->ulOptions),
                  szInsertWin32Msg(ret),
                  szInsertDN(pao->args.rep_sync.pNC),
                  pao->ulOptions & DRS_SYNC_BYNAME
                  ? szInsertWC(pao->args.rep_sync.pszDSA)      // opt
                  : szInsertUUID(&(pao->args.rep_sync.invocationid)),
                  szInsertSz(""),  // unused parameter
                  szInsertSz("")  // unused parameter
            );
        break;
    case AO_OP_UPD_REFS:
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_DRA_REPLICATION_FINISHED,
                  szInsertUL(cMinsDiff),
                  szInsertDsMsg( DIRLOG_PAO_UPDATE_REFERENCES ),
                  szInsertHex(pao->ulOptions),
                  szInsertWin32Msg(ret),
                  szInsertDN(pao->args.upd_refs.pNC),
                  szInsertMTX(pao->args.upd_refs.pDSAMtx_addr),
                  szInsertUUID(&(pao->args.rep_sync.invocationid)),
                  szInsertSz("")  // unused parameter
            );
        break;
    case AO_OP_REP_MOD:
        LogEvent8(DS_EVENT_CAT_REPLICATION,
            DS_EVENT_SEV_MINIMAL,
            DIRLOG_DRA_REPLICATION_FINISHED,
            szInsertUL(cMinsDiff),
            szInsertDsMsg( DIRLOG_PAO_MODIFY_REPLICA ),
            szInsertHex(pao->ulOptions),
            szInsertWin32Msg(ret),
            pao->args.rep_mod.puuidSourceDRA  // opt
        ? szInsertUUID(pao->args.rep_mod.puuidSourceDRA)
            :  szInsertSz(""),
               pao->args.rep_mod.pmtxSourceDRA    // opt
        ? szInsertMTX(pao->args.rep_mod.pmtxSourceDRA)
            :  szInsertSz(""),
               szInsertHex(pao->args.rep_mod.ulReplicaFlags),
               szInsertHex(pao->args.rep_mod.ulModifyFields)
            );
        break;
    default:
        LogEvent8(DS_EVENT_CAT_REPLICATION,
            DS_EVENT_SEV_MINIMAL,
            DIRLOG_DRA_REPLICATION_FINISHED,
            szInsertUL(cMinsDiff),
            szInsertUL(pao->ulOperation),
            szInsertHex(pao->ulOptions),
            szInsertWin32Msg(ret),
            szInsertSz(""),  // unused parameter
            szInsertSz(""),  // unused parameter
            szInsertSz(""),  // unused parameter
            szInsertSz("")  // unused parameter
            );
        break;
    }
}

DWORD DispatchPao(AO *pao)
{
    THSTATE *pTHS=NULL;
    DWORD ret = ERROR_SUCCESS;
    GUID uuidDsaObjSrc;

    memset(&uuidDsaObjSrc, 0, sizeof(GUID));

    GetDRASyncLock();

    EnterCriticalSection(&csAOList);
    __try {
        Assert(NULL == gpaoCurrent);
        Assert(0 == gtimeOpStarted);
        gpaoCurrent = pao;
        pao->paoNext = paoFirst;
        gtimeOpStarted = GetSecondsSince1601();
    }
    __finally {
        LeaveCriticalSection(&csAOList);
    }
    __try {         /* Exception handler */

        /* Save type of thread we are so that deep in other code we will
         * know whether we should allow preemption or not.
         */

        __try {         // Finally handler

            // Discard request if we're not installed (unless it's install)

            Assert(OWN_DRA_LOCK());    // We'd better own it

            InitDraThread(&pTHS);

            // If you update this switch, please update logEventPao as well
            switch (pao->ulOperation) {

            case AO_OP_REP_ADD:
		DRA_AUDITLOG_REPLICAADD_BEGIN(pTHS,
					      pao->args.rep_add.pSourceDsaDN,
					      pao->args.rep_add.pDSASMtx_addr,
					      pao->args.rep_add.pNC,
					      pao->ulOptions);
		pTHS->fIsValidLongRunningTask = TRUE;  
		ret = DRA_ReplicaAdd(
		    pTHS,
		    pao->args.rep_add.pNC,
		    pao->args.rep_add.pSourceDsaDN,
		    pao->args.rep_add.pTransportDN,
		    pao->args.rep_add.pDSASMtx_addr,
		    pao->args.rep_add.pszSourceDsaDnsDomainName,
		    pao->args.rep_add.preptimesSync,
		    pao->ulOptions,
		    &uuidDsaObjSrc);
		break;

	    case AO_OP_REP_DEL:
		pTHS->fIsValidLongRunningTask = TRUE;
		ret = DRA_ReplicaDel(
		    pTHS,
		    pao->args.rep_del.pNC,
		    pao->args.rep_del.pSDSAMtx_addr,
		    pao->ulOptions);
		break;

	    case AO_OP_REP_SYNC: 
		DRA_AUDITLOG_REPLICASYNC_BEGIN(pTHS, 
					       pao->args.rep_sync.pszDSA,
					       &pao->args.rep_sync.invocationid, 
					       pao->args.rep_sync.pNC,
					       pao->ulOptions);
		pTHS->fIsValidLongRunningTask = TRUE;
		ret = DRA_ReplicaSync(
		    pTHS,
		    pao->args.rep_sync.pNC,
		    &pao->args.rep_sync.invocationid,
		    pao->args.rep_sync.pszDSA,
		    pao->ulOptions);
		break;

	    case AO_OP_UPD_REFS:
		ret = DRA_UpdateRefs(
		    pTHS,
		    pao->args.upd_refs.pNC,
		    pao->args.upd_refs.pDSAMtx_addr,
		    &pao->args.upd_refs.invocationid,
		    pao->ulOptions);
		break;

	    case AO_OP_REP_MOD:
		ret = DRA_ReplicaModify(
		    pTHS,
		    pao->args.rep_mod.pNC,
		    pao->args.rep_mod.puuidSourceDRA,
		    pao->args.rep_mod.puuidTransportObj,
		    pao->args.rep_mod.pmtxSourceDRA,
		    &pao->args.rep_mod.rtSchedule,
		    pao->args.rep_mod.ulReplicaFlags,
		    pao->args.rep_mod.ulModifyFields,
		    pao->ulOptions
		    );
		break;

	    default:
		RAISE_DRAERR_INCONSISTENT( pao->ulOperation );
		break;
	    }
	} __finally {
	    DWORD cMinsDiff = (DWORD) ((GetSecondsSince1601() - gtimeOpStarted) / 60); 

	    // Done with this operation.
	    EnterCriticalSection(&csAOList);
	    __try {
		gpaoCurrent = NULL;
		gtimeOpStarted = 0;
		gulpaocount--;
	    }
	    __finally {
		LeaveCriticalSection(&csAOList);
	    }

	    FreeDRASyncLock();

	    if (cMinsDiff > gcMaxMinsSlowReplWarning) {
		logEventPaoFinished( pao, cMinsDiff, ret );
	    }
        }

    } __except (GetDraException((GetExceptionInformation()), &ret)) {
        // This is a normal exit path if we encounter a bad parameter
        // or out of memory etc, so nothing to do. Filter function
        // converts exception data to return code in ret, and
        // will assert if debug and the exception code is access
        // violation or unrecognized.
        ;
    }

    __try {
	// log the success or failure (depending on ret) of the operation.
	switch (pao->ulOperation) {
	case AO_OP_REP_ADD:
	    DRA_AUDITLOG_REPLICAADD_END(pTHS, 
					pao->args.rep_add.pSourceDsaDN, 
					pao->args.rep_add.pDSASMtx_addr, 
					pao->args.rep_add.pNC,
					pao->ulOptions,
					uuidDsaObjSrc,
					ret);
	    break;

	case AO_OP_REP_DEL:
	    DRA_AUDITLOG_REPLICADEL(pTHS, 
				    pao->args.rep_del.pSDSAMtx_addr, 
				    pao->args.rep_del.pNC, 
				    pao->ulOptions,
				    ret);
	    break;

	case AO_OP_REP_SYNC:
	    DRA_AUDITLOG_REPLICASYNC_END(pTHS, 
					 pao->args.rep_sync.pszDSA, 
					 &pao->args.rep_sync.invocationid,
					 pao->args.rep_sync.pNC, 
					 pao->ulOptions,        
					 ret);
	    break;

	case AO_OP_UPD_REFS:
	    DRA_AUDITLOG_UPDATEREFS(pTHS, 
				    pao->args.upd_refs.pDSAMtx_addr,
				    &pao->args.upd_refs.invocationid,
				    pao->args.upd_refs.pNC,
				    pao->ulOptions,
				    ret);
	    break;

	case AO_OP_REP_MOD:
	    DRA_AUDITLOG_REPLICAMODIFY(pTHS, 
				       pao->args.rep_mod.pmtxSourceDRA,
				       pao->args.rep_mod.puuidSourceDRA, 
				       pao->args.rep_mod.pNC,
				       pao->ulOptions, 
				       ret);
	    break;

	default:
	    Assert(!"Unable to log unknown operation!\n");
	    break;
	}
    } __except (GetDraException((GetExceptionInformation()), &ret)) {
	  Assert(!"Logging operations shouldn't except!\n");

    }

	if(!pTHS) {
	    ret = DRAERR_InternalError;
	}
	else if (pTHS->fSyncSet){
        // Correct problem now we've detected it
        pTHS->fSyncSet = FALSE;
        ret = DRAERR_InternalError;
    }

    if (ret) {
        if ( (ret == ERROR_DS_DRA_PREEMPTED) ||
             (ret == ERROR_DS_DRA_ABANDON_SYNC) ) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_CALL_EXIT_WARN,
                     szInsertUL(ret),
                     szInsertWin32Msg(ret),
                     NULL);
        } else {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_BASIC,
                     DIRLOG_DRA_CALL_EXIT_BAD,
                     szInsertUL(ret),
                     szInsertWin32Msg(ret),
                     NULL);
        }
    } else {
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_DRA_CALL_EXIT_OK,
                 NULL,
                 NULL,
                 NULL);
    }

    if (pTHS) {
        DraReturn(pTHS, ret);
    }

    free_thread_state();

    Assert(!OWN_DRA_LOCK());    // We better not own it

    return ret;
}

// PaoGet
// Get the first pao in the list if there is one and remove it from the list.

AO *
PaoGet(void)
{
    AO * paoRet;

    /* verify that if I'm here, I have the correct critical section */
    Assert(OWN_CRIT_SEC(csAOList));

    paoRet = paoFirst;
    if (paoRet) {
        paoFirst = paoRet->paoNext;
    }

    return paoRet;
}

unsigned __stdcall
AsyncThread(void * unused)
/*++

Routine Description:

    Replication worker thread.  All serialized replication operations -- adds,
    syncs, deletes, etc. -- are performed by this thread.

    The only exception to this is that replication updates received via ISM are
    applied in the MailThread().

Arguments:

    Unused.

Return Values:

    0 on normal exit, non-zero on error.

--*/
{
    DWORD dwException;
    ULONG ulErrorCode;
    ULONG ul2;
    PVOID dwEA;
    AO *  pao;

    __try { /* except */

        // Wait until DRA is setup.

        WaitForSingleObject(hevDRASetup, INFINITE);

        while (!eServiceShutdown) {
            HANDLE rghEnqueueWaits[2];

            fAsyncThreadAlive = TRUE;

            rghEnqueueWaits[0] = hevEntriesInAOList;
            rghEnqueueWaits[1] = hServDoneEvent;

            // Wait until there is an entry to service
            WaitForMultipleObjects(ARRAY_SIZE(rghEnqueueWaits),
                                   rghEnqueueWaits,
                                   FALSE,
                                   THIRTY_MINUTES_IN_MSECS);

            if (eServiceShutdown) {
                break;
            }

            /* Grab the async thread mutex, which tells the main thread that
             * there is an active async thread.
             */
            WaitForSingleObject(hmtxAsyncThread,INFINITE);

            InterlockedIncrement((ULONG *)&ulcActiveReplicationThreads);
            __try { /* finally */
                // Gain access to list
retrycrit:
#if DBG
                while (draQueueIsLockedByTestHook(5 * 1000)) {
                    DPRINT(0, "TEST HOOK: Replication queue is still locked, as requested.\n");
                }
#endif
                __try {
                    EnterCriticalSection(&csAOList);
                }
                __except (HandleMostExceptions(GetExceptionCode())) {
                    goto retrycrit;
                }
#if DBG
                if (draQueueIsLockedByTestHook(0)) {
                    LeaveCriticalSection(&csAOList);
                    goto retrycrit;
                }
#endif
                __try {
                    pao = PaoGet();

                    if (pao == NULL) {
                        ResetEvent(hevEntriesInAOList);
                    }
                }
                __finally {
                    LeaveCriticalSection(&csAOList);
                }

                if (pao != NULL) {
                    DWORD status;

                    lastSeen = 12;

                    // Dispatch routine and set return status.

                    status = DispatchPao(pao);

                    if (pao->ulOptions & DRS_ASYNC_OP) {
                        // Clean up.  DoOpDRS() does this for synchronous ops.
                        FreeAO(pao);
                    }
                    else {
                        // Record status and inform waiting thread we're done.
                        pao->ulResult = status;
                        if (!SetEvent(pao->hDone)) {
                            Assert(!"SetEvent() failed!");
                        }
                    }

                    lastSeen = 13;
                }
                else {
                    // We're completely caught up with all pending
                    // replication requests, which can reasonably be
                    // interpreted as saying we don't need to work
                    // quite so hard in the future.  Assuming that our
                    // initial syncs have already been scheduled (and
                    // completed), we should lower the priority of the
                    // async thread a notch, so as to let client threads
                    // zip through faster.
                    if (gfInitSyncsFinished) {
                        SetThreadPriority(GetCurrentThread(),
                                          gnDraThreadPriLow);
                    }
                }
            } __finally {
                InterlockedDecrement((ULONG *) &ulcActiveReplicationThreads);
                ReleaseMutex(hmtxAsyncThread);
                Assert(!OWN_DRA_LOCK());    // We'd better not own it
            }
        }
    }
    __except (GetExceptionData(GetExceptionInformation(), &dwException, &dwEA,
                               &ulErrorCode, &ul2)) {
        /* Oops, we died.  Don't log, since we believe that we've been here
         * at least once without a pTHStls.  Write up an obituary and then
         * lie down.
         */
        // We should never get here.  There is nothing in this function that
        // should generate any exception we would catch -- DispatchPao() wraps
        // itself in its own __try/__except.
        // A note on debugging thread disappearances. If the exception is not caught here,
        // it is very serious such as stack overflow, it will be caught by the debugger.
        // This is by design. The only known reason for the thread to disappear without
        // any trace is use of the TerminateThread api, either by code called by this thread,
        // or by the use DbgBreakPoint 'T' command.
        Assert(!"AsyncThread() exception caught!");
        fAsyncThreadAlive=FALSE;
        fAsyncThreadExists=FALSE;
        _endthreadex(dwException);
    }

    fAsyncThreadExists = FALSE;
    return 0;
}

BOOL
draIsSameOp(
    IN  AO *  pao1,
    IN  AO *  pao2
    )
/*++

Routine Description:

    Compare two operations to see if they describe the same operation type
    with identical parameters.

Arguments:

    pao1, pao2 (IN) - Operations to compare.

Return Values:

    None.

--*/
{
// TRUE iff (both NULL) || (neither NULL && NameMatched())
#define SAME_DN(a,b)                        \
    ((NULL == (a))                          \
     ? (NULL == (b))                        \
     : ((NULL != (b)) && NameMatched(a,b)))

// TRUE iff (both NULL) || (neither NULL && MtxSame())
#define SAME_MTX(a,b)                       \
    ((NULL == (a))                          \
     ? (NULL == (b))                        \
     : ((NULL != (b)) && MtxSame(a,b)))

// TRUE iff (both NULL) || (neither NULL && DnsNameCompare())
#define SAME_DNSNAME(a,b)                      \
    ((NULL == (a))                          \
     ? (NULL == (b))                        \
     : ((NULL != (b)) && DnsNameCompare_W (a,b)))

// TRUE iff (both NULL) || (neither NULL && !memcmp())
#define SAME_SCHED(a,b)                                     \
    ((NULL == (a))                                          \
     ? (NULL == (b))                                        \
     : ((NULL != (b)) && !memcmp(a,b,sizeof(REPLTIMES))))

// TRUE iff (both NULL) || (neither NULL && !memcmp())
#define SAME_UUID(a,b)                                  \
    ((NULL == (a))                                      \
     ? (NULL == (b))                                    \
     : ((NULL != (b)) && !memcmp(a,b,sizeof(GUID))))

    BOOL fIsIdentical = FALSE;

    if ((pao1->ulOperation == pao2->ulOperation)
        && (pao1->ulOptions == pao2->ulOptions)) {

        // If these are synchronous ops being waited on by different callers,
        // can they really be the same?
        Assert(pao1->hDone == NULL);
        Assert(pao2->hDone == NULL);

        switch (pao1->ulOperation) {
        case AO_OP_REP_ADD:
            fIsIdentical
                =    SAME_DN(pao1->args.rep_add.pNC, pao2->args.rep_add.pNC)
                  && SAME_DN(pao1->args.rep_add.pSourceDsaDN,
                             pao2->args.rep_add.pSourceDsaDN)
                  && SAME_DN(pao1->args.rep_add.pTransportDN,
                             pao2->args.rep_add.pTransportDN)
                  && SAME_MTX(pao1->args.rep_add.pDSASMtx_addr,
                              pao2->args.rep_add.pDSASMtx_addr)
                  && SAME_DNSNAME(pao1->args.rep_add.pszSourceDsaDnsDomainName,
                                  pao2->args.rep_add.pszSourceDsaDnsDomainName)
                  && SAME_SCHED(pao1->args.rep_add.preptimesSync,
                                pao2->args.rep_add.preptimesSync);
            break;

        case AO_OP_REP_DEL:
            fIsIdentical
                =    SAME_DN(pao1->args.rep_del.pNC, pao2->args.rep_del.pNC)
                  && SAME_MTX(pao1->args.rep_del.pSDSAMtx_addr,
                              pao2->args.rep_del.pSDSAMtx_addr);
            break;

        case AO_OP_REP_MOD:
            fIsIdentical
                =    SAME_DN(pao1->args.rep_mod.pNC, pao2->args.rep_mod.pNC)
                  && SAME_UUID(pao1->args.rep_mod.puuidSourceDRA,
                               pao2->args.rep_mod.puuidSourceDRA)
                  && SAME_UUID(pao1->args.rep_mod.puuidTransportObj,
                               pao2->args.rep_mod.puuidTransportObj)
                  && SAME_MTX(pao1->args.rep_mod.pmtxSourceDRA,
                              pao2->args.rep_mod.pmtxSourceDRA)
                  && SAME_SCHED(&pao1->args.rep_mod.rtSchedule,
                                &pao2->args.rep_mod.rtSchedule)
                  && (pao1->args.rep_mod.ulReplicaFlags
                      == pao2->args.rep_mod.ulReplicaFlags)
                  && (pao1->args.rep_mod.ulModifyFields
                      == pao2->args.rep_mod.ulModifyFields);
            break;

        case AO_OP_REP_SYNC:
            fIsIdentical
                =    SAME_DN(pao1->args.rep_sync.pNC, pao2->args.rep_sync.pNC)
                  && SAME_UUID(&pao1->args.rep_sync.invocationid,
                               &pao2->args.rep_sync.invocationid)
                  && SAME_DNSNAME(pao1->args.rep_sync.pszDSA,
                                  pao2->args.rep_sync.pszDSA);
            break;

        case AO_OP_UPD_REFS:
            fIsIdentical
                =    SAME_DN(pao1->args.upd_refs.pNC, pao2->args.upd_refs.pNC)
                  && SAME_MTX(pao1->args.upd_refs.pDSAMtx_addr,
                              pao2->args.upd_refs.pDSAMtx_addr)
                  && SAME_UUID(&pao1->args.upd_refs.invocationid,
                               &pao2->args.upd_refs.invocationid);
            break;

        default:
            Assert(!"Unknown op type!");
        }
    }

    return fIsIdentical;
}


void
draFilterDuplicateOpsFromQueue(
    IN  AO *    pao,
    OUT BOOL *  pfAddToQ
    )
/*++

Routine Description:

    Scan the replication queue to determine if the given operation should be
    added to the queue.  There are three possibilities:

    1. There are no similar operations in the queue.  Queue is unchanged,
       *pfAddToQ = TRUE.

    2. There are one or more similar operations in the queue that are superseded
       by the new operation.  The superseded operations are removed from the
       queue, *pfAddToQ = TRUE.

    3. There is an existing operation in the queue that supersedes the new
       operation.  Queue is unchanged, *pfAddToQ = FALSE.

Note that paoCurrent is intentionally not included in this search. The primary reason is that
if we allowed duplicates of the currently executing element to be filtered, we would
prevent requeues of the same operation by that operation, say in the event of preemption.

Arguments:

    pao (IN) - New operation that is a candidate for being added to the queue.

    pfAddToQ (OUT) - On return, TRUE iff the new operation should be added to
        the queue.

Return Values:

    None.

--*/
{
    BOOL  fHaveNewSyncAll = FALSE;
    AO *  paoTmp;
    AO *  paoTmpNext;
    AO ** ppaoPrevNext;
    BOOL  fAddToQ = TRUE;

    Assert(OWN_CRIT_SEC(csAOList));

    if (!(pao->ulOptions & DRS_ASYNC_OP)
        || (pao->ulOptions & DRS_NO_DISCARD)) {
        // We never consolidate synchronous or explicitly non-discardable
        // operations.
        *pfAddToQ = TRUE;
        return;
    }

    fHaveNewSyncAll = (pao->ulOperation == AO_OP_REP_SYNC)
                      && (pao->ulOptions & DRS_SYNC_ALL);

    for (paoTmp=paoFirst, ppaoPrevNext = &paoFirst;
         NULL != paoTmp;
         paoTmp = paoTmpNext) {

        // Save next pointer in case we free paoTmp
        paoTmpNext = paoTmp->paoNext;

        // If not same op type or existing op is non-discardable or synchronous,
        // no match.
        if ((pao->ulOperation != paoTmp->ulOperation)
            || !(paoTmp->ulOptions & DRS_ASYNC_OP)
            || (paoTmp->ulOptions & DRS_NO_DISCARD)) {
            goto loop_end;  // need to inc ppaoPrevNext
        }

        if (AO_OP_REP_SYNC == pao->ulOperation) {
            // If this async op is a sync of the same NC with
            // the same writeable flag and the same syncing options,
            // check it further.

            if (((paoTmp->ulOptions & DRS_FULL_SYNC_NOW)
                 == (pao->ulOptions & DRS_FULL_SYNC_NOW))
                && NameMatched(pao->args.rep_sync.pNC,
                               paoTmp->args.rep_sync.pNC)
                && ((pao->ulOptions & DRS_WRIT_REP)
                    == (paoTmp->ulOptions & DRS_WRIT_REP))) {

                if (fHaveNewSyncAll) {
                    // If existing op is sync all, discard new op,
                    // unless the new op is of higher priority, in
                    // which case discard the old one
                    if ((paoTmp->ulOptions & DRS_SYNC_ALL)
                        && (paoTmp->ulPriority >= pao->ulPriority)) {
                        fAddToQ = FALSE;
                        break;
                    } else {
                        // This sync will be performed as a part of
                        // the new sync all, so remove
                        // existing sync from q.

                        gulpaocount--;
                        *ppaoPrevNext = paoTmp->paoNext;
                        FreeAO(paoTmp);
                        continue;       // Skip inc of ppaoPrevNext
                    }
                } else {
                    // New async op is not sync all, discard it if
                    // the existing op is a sync all, or identical
                    // specific sync.
                    // If the new op is higher priority, then leave
                    // both ops in the queue.

                    if ((paoTmp->ulPriority >= pao->ulPriority)
                        && ((paoTmp->ulOptions & DRS_SYNC_ALL)
                            || ((paoTmp->ulOptions & DRS_SYNC_BYNAME)
                                && (pao->ulOptions & DRS_SYNC_BYNAME)
                                && !_wcsicmp(paoTmp->args.rep_sync.pszDSA,
                                             pao->args.rep_sync.pszDSA))
                            || (!(paoTmp->ulOptions & DRS_SYNC_BYNAME)
                                && !(pao->ulOptions & DRS_SYNC_BYNAME)
                                && !memcmp(&pao->args.rep_sync.invocationid,
                                           &paoTmp->args.rep_sync.invocationid,
                                           sizeof(UUID))))) {
                        fAddToQ = FALSE;
                        break;
                    }
                }
            }
        } else if (draIsSameOp(pao, paoTmp)) {
            // Existing operation in the queue is sufficient to cover this
            // request.
            fAddToQ = FALSE;
            break;
        }

    loop_end:
        ppaoPrevNext = &(paoTmp->paoNext);
    }

    *pfAddToQ = fAddToQ;
}


VOID
DraRemovePeriodicSyncsFromQueue(
    UUID *puuidDsa
    )

/*++

Routine Description:

    Remove periodic sync entries across multiple naming contexts for the same DSA.
    Used to prune the queue and save work.

    Sync's of NCs are not completely independent from one another. For example, all other syncs
    will fail with schema mismatch until the schema NC is sunk. Sync of domain may require sync
    of config. After a cross domain move, sync of domain1 may require the sync of domain2 first.

    Should only be used after the caller has determined that an nc-wide error has occurred,
    and that it is not the kind of error that a sync of another nc is required to correct.
 
    Criteria:
    o Only syncs
    o Only asynchronous operations
    o Only syncs that are marked DRS_PER_SYNC
    o Only syncs that sync by uuid (as opposed to those that sync by name)
    o Only syncs of non-system nc's (RO & NDNCs)

    Synchronous operations should never be deleted because there is a client waiting for them.
    This criteria excludes init syncs. Init syncs must never be deleted because the
    advertising code is waiting for them to finish.

    Removing an item from the queue does not update the status of the operation. The operation
    appears to be late, that is it was not attempted during its window.

Arguments:

    uuidDSA - uuid of DSA to purge

Return Value:

    None

--*/

{
    AO *  paoTmp;
    AO *  paoTmpNext;
    AO ** ppaoPrevNext;

    if (DsaIsInstalling()) {
        return;
    }

    Assert( gAnchor.pDMD );
    Assert( !fNullUuid( &gAnchor.pDMD->Guid ) );
    Assert( gAnchor.pConfigDN );
    Assert( !fNullUuid( &gAnchor.pConfigDN->Guid ) );
    Assert( gAnchor.pDomainDN );
    Assert( !fNullUuid( &gAnchor.pDomainDN->Guid ) );

retrycrit:
    __try {
        EnterCriticalSection(&csAOList);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        goto retrycrit;
    }

    __try {

        for (paoTmp=paoFirst, ppaoPrevNext = &paoFirst;
             NULL != paoTmp;
             paoTmp = paoTmpNext) {

            // Save next pointer in case we free paoTmp
            paoTmpNext = paoTmp->paoNext;

            // Match a periodic sync as enqueued by drainit.c
            // Note that rpc_sync.invocationid is a misnomer: it is the source dsa uuid
            if ((AO_OP_REP_SYNC == paoTmp->ulOperation)
                && (paoTmp->ulOptions & DRS_ASYNC_OP)
                && (paoTmp->ulOptions & DRS_PER_SYNC)
                && (!(paoTmp->ulOptions & DRS_SYNC_BYNAME))
                && (!memcmp( &paoTmp->args.rep_sync.invocationid, puuidDsa, sizeof(GUID) ))
                && (!NameMatched( paoTmp->args.rep_sync.pNC, gAnchor.pDMD ))
                && (!NameMatched( paoTmp->args.rep_sync.pNC, gAnchor.pConfigDN ))
                && (!NameMatched( paoTmp->args.rep_sync.pNC, gAnchor.pDomainDN )) ) {

#if DBG
                {
                CHAR szUuid1[SZUUID_LEN];
                DPRINT5( 0, "Removing PER SYNC: SN %d, pri %d, opt 0x%x, NC %ws, source guid %s\n",
                         paoTmp->ulSerialNumber,
                         paoTmp->ulPriority,
                         paoTmp->ulOptions,
                         paoTmp->args.rep_sync.pNC->StringName,
                         DsUuidToStructuredString(&(paoTmp->args.rep_sync.invocationid), szUuid1) );
                }
#endif
                gulpaocount--;
                *ppaoPrevNext = paoTmp->paoNext;
                FreeAO(paoTmp);
                continue;       // Skip inc of ppaoPrevNext
            }

            ppaoPrevNext = &(paoTmp->paoNext);
        }

    } __finally {
        LeaveCriticalSection(&csAOList);
    }
}

void
AddAsyncOp(
    IN OUT  AO *  pao
    )
/*++

Routine Description:

    Enqueue the operation described by the given AO structure to our worker
    thread (AsyncThread()) by inserting it into the priority queue.  If the
    operation is an asynchronous sync request it may be dropped (and freed)
    if an existing item in the queue is identical or is a superset of the
    request.  Conversely, if the new operation is a superset of an existing
    operation, the existing operation is removed from the queue.

Arguments:

    pao (IN/OUT) - Pointer to AO structure to enqueue.

Return Values:

    None.

--*/
{
    BOOL fAddToQ = TRUE;
    AO *paoTmp;
    AO *paoTmpNext;
    AO **ppaoPrevNext;

    // Get permission to access list

retrycrit:
    __try {
        EnterCriticalSection(&csAOList);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        goto retrycrit;
    }

    __try {
        __try {
            EnterCriticalSection(&csAsyncThreadStart);
            if (!fAsyncThreadExists) {
                unsigned tid;
                /* Set up task that checks that the async thread */
                /* and the status of the replication queue       */
                if (!fAsyncAndQueueCheckStarted) {
                    InsertInTaskQueue(TQ_CheckAsyncQueue, NULL, THIRTY_5_MINUTES_IN_SECS);
                    fAsyncAndQueueCheckStarted = TRUE;
                } 
                // Stack size of 0 means to take the image default of 1Mb
                hAsyncThread = (HANDLE) _beginthreadex(NULL, /* security */
                                                       0, /* stack size */
                                                       AsyncThread,
                                                       NULL, /* arg list */
                                                       0, /* init running */
                                                       &tid);
                fAsyncThreadExists = hAsyncThread != 0;
            }
        } __finally {
            LeaveCriticalSection(&csAsyncThreadStart);
        }

        draFilterDuplicateOpsFromQueue(pao, &fAddToQ);

        // If required, add pao to the list.  It is inserted immediately before
        // the first operation with a lesser priority.

        if (fAddToQ) {

            gulpaocount++;

            /* verify that if I'm here,
             * I have the correct critical section
             */
            Assert(OWN_CRIT_SEC(csAOList));

            // Find the 'next' pointer of the immediate predecessor of where pao
            // should be put in the queue.  (It should be enqueued right after
            // all other operations at its own or greater priority level.)
            for (ppaoPrevNext = &paoFirst, paoTmp = paoFirst;
                 (NULL != paoTmp) && (paoTmp->ulPriority >= pao->ulPriority);
                 ppaoPrevNext = &paoTmp->paoNext, paoTmp = paoTmp->paoNext) {
                ;  
            }

            // Wedge pao into its proper place in the queue.
            *ppaoPrevNext = pao;
            pao->paoNext = paoTmp;

            if (NULL != gpaoCurrent) {
                // In this case gpaoCurrent is the head of the linked list.
                // Make sure whatever we've added is linked in behind it.
                gpaoCurrent->paoNext = paoFirst;
            }

            // If we think it deserves it, make sure the AsyncThread is
            // running at its full normal priority
            if ((pao->ulPriority >= gulDraThreadOpPriThreshold)
                || (gulpaocount >= gulAOQAggressionLimit)) {
                SetThreadPriority(hAsyncThread, gnDraThreadPriHigh);
            }

            // Set hevEntriesInAOList
            if (!SetEvent(hevEntriesInAOList)) {
                Assert(FALSE);
            }
        } else {
            // Not queueing this op, so free its memory.
            FreeAO(pao);
        }
    } __finally {
        LeaveCriticalSection(&csAOList);
    }
}

void
SetOpPriority(
    IN OUT  AO *    pao
    )
/*++

Routine Description:

    Determine the priority of the operation described by the given AO structure
    and set its ulPriority element accordingly.

Arguments:

    pao (IN/OUT) - Pointer to AO structure to manipulate.

Return Values:

    None.

--*/
{
    BOOL fWriteableNC = FALSE;
    BOOL fSystemNC = FALSE;
    NCL_ENUMERATOR nclEnum;

    switch (pao->ulOperation) {
        
    case AO_OP_REP_SYNC:
        // Fall through.
        
    case AO_OP_REP_ADD:
        
        if (pao->ulOptions & DRS_WRIT_REP) {
            fWriteableNC = TRUE;
        }
        else {
            NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
            NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NC, (PVOID)pao->args.rep_sync.pNC);
            if (NCLEnumeratorGetNext(&nclEnum)) {
                fWriteableNC = TRUE;
            }
        }

        // Check for system NC's
        if (!DsaIsInstalling()) {
            Assert( gAnchor.pDMD );
            Assert( gAnchor.pConfigDN );

            fSystemNC = ( 
                (gAnchor.pDMD ? NameMatched( pao->args.rep_sync.pNC, gAnchor.pDMD ) : FALSE ) ||
                (gAnchor.pConfigDN ? NameMatched( pao->args.rep_sync.pNC, gAnchor.pConfigDN ) : FALSE )
                );
        }

        pao->ulPriority = AOPRI_SYNCHRONIZE_BASE;

        if (fWriteableNC) {
            pao->ulPriority += AOPRI_SYNCHRONIZE_BOOST_WRITEABLE;
        }

        if (!(pao->ulOptions & DRS_ASYNC_OP)) {
            pao->ulPriority += AOPRI_SYNCHRONIZE_BOOST_SYNC;
        }

        if (!(pao->ulOptions & DRS_NEVER_SYNCED)) {
            pao->ulPriority += AOPRI_SYNCHRONIZE_BOOST_INCREMENTAL;
        }

        if (pao->ulOptions & DRS_PREEMPTED) {
            pao->ulPriority += AOPRI_SYNCHRONIZE_BOOST_PREEMPTED;
        }

        if (fSystemNC) {
            pao->ulPriority += AOPRI_SYNCHRONIZE_BOOST_SYSTEM_NC;
        }
        
        // We use notification as an approximation of intrasitedness.  We could have
        // also used compression for this purpose.  Ideally we would compare the
        // site guids, or the presence of the transport dn, neither of which is
        // handy here. The reason we prefer notification is because it corresponds
        // to a sense of nearness. A link between sites which has notification
        // explicitly enabled by the user is considered "intrasite" for our purposes.
        if (!(pao->ulOptions & DRS_NEVER_NOTIFY)) {
            pao->ulPriority += AOPRI_SYNCHRONIZE_BOOST_INTRASITE;
        }

        break;

    case AO_OP_REP_DEL:
        pao->ulPriority = (pao->ulOptions & DRS_ASYNC_OP)
                            ? AOPRI_ASYNC_DELETE
                            : AOPRI_SYNC_DELETE;
        break;

    case AO_OP_UPD_REFS:
        pao->ulPriority = (pao->ulOptions & DRS_GETCHG_CHECK)
                            ? AOPRI_UPDATE_REFS_VERIFY
                            : AOPRI_UPDATE_REFS;
        break;

    case AO_OP_REP_MOD:
        pao->ulPriority = (pao->ulOptions & DRS_ASYNC_OP)
                            ? AOPRI_ASYNC_MODIFY
                            : AOPRI_SYNC_MODIFY;
        break;

    default:
        Assert(!"Unknown AO_OP in SetOpPriority()!");
        pao->ulPriority = 0;
        break;
    }
}


DWORD
DoOpDRS(
    IN OUT  AO *  pao
    )
/*++

Routine Description:

    Execute the operation described by the given AO -- synchronously or
    asynchronously, depending upon whether DRS_ASYNC_OP was specified in the
    AO options.

    pao must be malloc()'ed.  This routine (or one of its minions) will see to
    it that the structure is free()'d.

    This is the primary interface between the in-process replication head
    (DirReplica* in dradir.c) and the worker thread.

Arguments:

    pao (IN/OUT) - Pointer to AO structure to execute.

Return Values:

    None.

--*/
{
    DWORD retval = ERROR_SUCCESS;
    BOOL  fWaitForCompletion;

    pao->hDone = NULL;

    if (AO_OP_REP_SYNC == pao->ulOperation) {
        INC(pcPendSync); 
    }
    INC(pcDRAReplQueueOps);

    if (eServiceShutdown) {
        FreeAO(pao);
        return ERROR_DS_SHUTTING_DOWN;
    }

    __try {
        pao->timeEnqueued   = GetSecondsSince1601();
        pao->ulSerialNumber = InterlockedIncrement(&gulSerialNumber);

        // Determine priority level for this operation.
        SetOpPriority(pao);

        if (pao->ulOptions & DRS_ASYNC_OP) {
            fWaitForCompletion = FALSE;
        }
        else {
            fWaitForCompletion = TRUE;
            pao->hDone = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (NULL == pao->hDone) {
                retval = GetLastError();
                __leave;
            }
        }

        // Enqueue operation to our worker thread.
        AddAsyncOp(pao);

        if (fWaitForCompletion) {
            // Wait for the operation to be completed.
            HANDLE rgHandles[3];
            DWORD  waitStatus;

            rgHandles[0] = pao->hDone;
            rgHandles[1] = hServDoneEvent;
            rgHandles[2] = hAsyncThread;

            do {
                waitStatus = WaitForMultipleObjects(ARRAY_SIZE(rgHandles),
                                                    rgHandles,
                                                    FALSE,
                                                    THIRTY_MINUTES_IN_MSECS);
                switch (waitStatus) {
                case WAIT_OBJECT_0:
                    // Task completed.
                    retval = pao->ulResult;
                    break;

                case WAIT_OBJECT_0 + 1:
                    // DS is shutting down.
                    Assert(eServiceShutdown);
                    retval = ERROR_DS_SHUTTING_DOWN;
                    break;

                case WAIT_OBJECT_0 + 2:
                    // AsyncThread terminated -- should never happen.
                    Assert(!"AsyncThread() terminated unexpectedly!");
                    retval = ERROR_DS_SHUTTING_DOWN;
                    // Allow for restart
                    fAsyncThreadAlive=FALSE;
                    fAsyncThreadExists=FALSE;
                    break;

                case WAIT_FAILED:
                    // Failure!
                    retval = GetLastError();
                    break;

                case WAIT_TIMEOUT:
                    // Task not done yet -- make sure we're making progress.
                    if (!gfDRABusy) {
                        LogEvent(DS_EVENT_CAT_REPLICATION,
                                 DS_EVENT_SEV_BASIC,
                                 DIRLOG_DRA_DISPATCHER_TIMEOUT,
                                 NULL,
                                 NULL,
                                 NULL);
                    }
                    break;
                }
            } while (WAIT_TIMEOUT == waitStatus);
        }
    }
    __except (GetDraException(GetExceptionInformation(), &retval)) {
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_DRA_CALL_EXIT_BAD,
                 szInsertUL(retval),
                 szInsertWin32Msg(retval),
                 NULL);
    }

    if (fWaitForCompletion && !eServiceShutdown) {
        // Clean up.  (In the async case, the AsyncThread does this.)
        // In the shutdown case, the AsyncThread() may be operating on this
        // very request, and when it finishes it will still try to signal us.
        // In that case, let it do so, and leak pao.  (We're about to
        // terminate anyway.)
        FreeAO(pao);
    }

    return retval;
}

BOOL
CheckReplQueueFileTimeLessThan(const FILETIME* pftimeOne, const FILETIME* pftimeTwo) {
    FILETIME ftimeZeroTime;
    DSTimeToFileTime(0,&ftimeZeroTime);
    //zero file time is invalid
    //"missing" time is not less than (assume missing time is current time since
    //time hasn't happened "yet", it's time will be at least current time)
    if (CompareFileTime(&ftimeZeroTime,pftimeOne)>=0) {
	return FALSE;
    }
    //same rational here
    if (CompareFileTime(&ftimeZeroTime,pftimeTwo)>=0) {
	return TRUE;
    }
    return (CompareFileTime(pftimeOne,pftimeTwo)<=0);

}

//CheckReplQueue
// Runs periodically to check the status of the replication queue.  Logs events if the
// currently executing operation is taking more than X time to execute (X is configurable 
// in the registry) and logs events if it finds an operation in the queue that is being
// starved not because of a long running event but because other higher priority events
// are run continually - ie the replication workload for this interval is too high.

void CheckReplQueue()
{
     //start
    DWORD err;
    DS_REPL_QUEUE_STATISTICSW * pReplQueueStats;
    THSTATE      *pTHS = pTHStls;
    FILETIME ftimeCurrTimeMinusSecInQueue;
    FILETIME ftimeOldestOp;
    DSTIME timeCurrentOpStarted;
    DSTIME timeOldestOp;
    
    ULONG ulSecInQueue;
    ULONG ulSecInExecution;
    CHAR szTime[SZDSTIME_LEN];
    LPSTR lpstrTime = NULL;
	
    DPRINT(1, " Entering critical section \n");
    EnterCriticalSection(&csAOList);

    __try {
	err = draGetQueueStatistics(pTHS, &pReplQueueStats);  
    } __finally {
	DPRINT(1, " Leaving critical section \n");
	LeaveCriticalSection(&csAOList);
    }

    if (!err) { 
	//gulReplQueueCheckTime is a registry variable, defaults to 12 hours (in seconds)
	ulSecInQueue = gulReplQueueCheckTime;
	ulSecInExecution = gulReplQueueCheckTime;

	FileTimeToDSTime(pReplQueueStats->ftimeCurrentOpStarted,&timeCurrentOpStarted);
	DSTimeToFileTime(GetSecondsSince1601()-ulSecInQueue,&ftimeCurrTimeMinusSecInQueue);


	if ((timeCurrentOpStarted!=0) && (timeCurrentOpStarted+ulSecInExecution<GetSecondsSince1601())) {
	    //current operation is stuck in the queue, log an error for this.
	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_DRA_REPLICATION_OP_OVER_TIME_LIMIT,
		     szInsertDSTIME(timeCurrentOpStarted,szTime),
		     szInsertInt((ULONG)pReplQueueStats->cNumPendingOps),
		     NULL);
	}
	else if ((pReplQueueStats->cNumPendingOps>0)
		 &&
		 (
		  (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestSync,&ftimeCurrTimeMinusSecInQueue))
		  ||
		  (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestAdd,&ftimeCurrTimeMinusSecInQueue))
		  ||
		  (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestDel,&ftimeCurrTimeMinusSecInQueue))
		  ||
		  (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestMod,&ftimeCurrTimeMinusSecInQueue))
		  ||
		  (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestUpdRefs,&ftimeCurrTimeMinusSecInQueue))
		  )
		 ) {
	    //some operation is being starved, find which operation and
	    //find the oldest time and convert it to dstime to print in the log  
	    ftimeOldestOp = pReplQueueStats->ftimeOldestSync;
	    if (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestAdd,&ftimeOldestOp)) {
		ftimeOldestOp = pReplQueueStats->ftimeOldestAdd;
	    }
	    if (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestDel,&ftimeOldestOp)) {
		ftimeOldestOp = pReplQueueStats->ftimeOldestDel;
	    }
	    if (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestMod,&ftimeOldestOp)) {
		ftimeOldestOp = pReplQueueStats->ftimeOldestMod;
	    }
	    if (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestUpdRefs,&ftimeOldestOp)) {
		ftimeOldestOp = pReplQueueStats->ftimeOldestUpdRefs;
	    }
	    FileTimeToDSTime(ftimeOldestOp,&timeOldestOp);
	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_DRA_REPLICATION_OP_NOT_EXECUTING,
		     szInsertDSTIME(timeOldestOp,szTime),  
		     szInsertInt((ULONG)pReplQueueStats->cNumPendingOps),
		     NULL);

	}
    }
    else {
	Assert(!"Replication Queue Statistics are not available!");
    }
} //CheckReplQueue

// CheckAsyncThread.
//
// Runs periodically to check async thread is alive and that no thread
// is stuck in the mail DLL.
// This routine sets the fAsyncThreadAlive flag to FALSE, and if the
// dispatcher loop code has not set it to TRUE by the next time this
// routine runs, we log that the dispatcher thread is hung or gone.

void CheckAsyncThread()
{
    DWORD dwExitCode;

    if(eServiceShutdown) {
	/* Don't bother */
	goto End;
    }

    // Now check to see if the async thread is ok.

    if ((fAsyncThreadAlive == FALSE) && (!gfDRABusy)) {

	/* Thread does not appear to be executing dispatcher loop,
		 * see if the thread has terminated.
		 */

	GetExitCodeThread (hAsyncThread, &dwExitCode);
	if (dwExitCode != STILL_ACTIVE) {
	    __try {
		/* Yep, the thread is dead, */

		EnterCriticalSection(&csAsyncThreadStart);

		LogEvent(DS_EVENT_CAT_REPLICATION,
			 DS_EVENT_SEV_ALWAYS,
			 DIRLOG_DRA_DISP_DEAD_DETAILS,
			 szInsertHex(dwExitCode),
			 NULL,
			 NULL);


    		if(!fAsyncThreadExists) {
                    unsigned tid;
                    /* And no one else has already restarted it.
                     * Restart the asyncthread.
                     */
                    hAsyncThread = (HANDLE) _beginthreadex(NULL, /* security */
                                                           0, /* stack size */
                                                           AsyncThread,
                                                           NULL, /* arg list */
                                                           0, /* init running */
                                                           &tid);
    		    fAsyncThreadExists = hAsyncThread != 0;
    		}

	    } __finally {
                LeaveCriticalSection(&csAsyncThreadStart);
	    }

	} else {
	    /* Thread is running, see if it has hung in an RPC call */

	    EnterCriticalSection(&csLastReplicaMTX);

	    __try {

		if (pLastReplicaMTX) {
		    /*
			     * We seem to be stuck in an RPC call.
			     * This is handled by RpcCancel(De)Register code.
			     * continue.
			     */

		    NULL;
		} else {
		    /* The thread is alive, but stuck somewhere other
			     * than an RPC call.  Log this condition.
			     */
		    LogEvent(DS_EVENT_CAT_REPLICATION,
			     DS_EVENT_SEV_ALWAYS,
			     DIRLOG_DRA_DISPATCHER_DEAD,
			     szInsertUL(lastSeen),
			     NULL,
			     NULL);
		    /* One possibility is that the thread is languishing
			     * at some reduced priority.  Jack it back up.
				 */
		    SetThreadPriority(hAsyncThread,
				      gnDraThreadPriHigh);
		}
	    }
	    __finally {
		LeaveCriticalSection(&csLastReplicaMTX);
	    }
	}
    } else {
	// Dispatcher loop has been executed since last time this routine
	// ran, or DRA is busy. Clear the alive and busy flags so that
	// unless dispatcher loop runs again, or the DRA sets the busy
	// flag again, we'll notice we're dead next time.

	fAsyncThreadAlive = FALSE;
	gfDRABusy = FALSE;
    }
    End:;

}

// Taskq function to run CheckAsyncThread and CheckReplQueue
void 
CheckAsyncThreadAndReplQueue(void *pv, void **ppvNext, DWORD *pcSecsUntilNextIteration) {
    __try {
	CheckAsyncThread();
	CheckReplQueue();
    }
    __finally {
	/* Set task to run again */
	if(!eServiceShutdown) {
	    *ppvNext = NULL;
	    *pcSecsUntilNextIteration = THIRTY_5_MINUTES_IN_SECS;
	}
    }

    (void) pv;   // unused
}

ULONG
draGetQueueStatistics(
    IN THSTATE * pTHS,
    OUT DS_REPL_QUEUE_STATISTICSW ** ppQueueStats)
/*++

Routine Description:

    Return statistics about the pending operations. Return the results
    by allocating and populating a DS_REPL_QUEUE_STATISTICSW structure.

    This data is public, available via ntdsapi.h.

    Caller must have already acquired the csAOList lock.

Arguments:

    pTHS (IN)

    ppPendingOps (OUT) - On successful return, holds a pointer to the
        populated queue statistics structure. This pointer will always
        be allocated unless the function returns an error.

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    DS_REPL_QUEUE_STATISTICSW * pQueueStats;
    AO * pao;
    DSTIME * ptimeOldestSync = NULL;
    DSTIME * ptimeOldestAdd = NULL;
    DSTIME * ptimeOldestDel = NULL;
    DSTIME * ptimeOldestMod = NULL;
    DSTIME * ptimeOldestUpdRefs = NULL;
    FILETIME ftimeTime;

    Assert(ARGUMENT_PRESENT(pTHS));
    Assert(ARGUMENT_PRESENT(ppQueueStats));
    Assert(OWN_CRIT_SEC(csAOList));

    pQueueStats = THAllocEx(pTHS, sizeof(DS_REPL_QUEUE_STATISTICSW));
    Assert(pQueueStats);

    // Set pQueueStats->ftimeCurrentOpStarted to
    // the time at which current op started executing.
    if (NULL != gpaoCurrent) {
        DSTimeToFileTime(gtimeOpStarted,
                         &pQueueStats->ftimeCurrentOpStarted);
    }

    // Set pQueueStats->cNumPendingOps to
    // the number of pending operations in the queue
    for (pao = gpaoCurrent ? gpaoCurrent : paoFirst;
         NULL != pao;
         pao = pao->paoNext)
    {
        pQueueStats->cNumPendingOps++;
	Assert(pQueueStats->cNumPendingOps <= gulpaocount); 

	//find oldest operation of each AO_OP_REP_ type
	switch (pao->ulOperation) {
	case AO_OP_REP_SYNC:
	    if (ptimeOldestSync) { 
		ptimeOldestSync = (*ptimeOldestSync > pao->timeEnqueued) ? &(pao->timeEnqueued) : ptimeOldestSync;
	    }
	    else {
		ptimeOldestSync = &(pao->timeEnqueued);
	    }
	    break;

	case AO_OP_REP_ADD:
	    if (ptimeOldestAdd) { 
		ptimeOldestAdd = (*ptimeOldestAdd > pao->timeEnqueued) ? &(pao->timeEnqueued) : ptimeOldestAdd;
	    }
	    else {
		ptimeOldestAdd = &(pao->timeEnqueued);
	    }
	    break;

	case AO_OP_REP_DEL:
	    if (ptimeOldestDel) { 
		ptimeOldestDel = (*ptimeOldestDel > pao->timeEnqueued) ? &(pao->timeEnqueued) : ptimeOldestDel;
	    }
	    else {
		ptimeOldestDel = &(pao->timeEnqueued);
	    }
	    break;

	case AO_OP_REP_MOD:
	    if (ptimeOldestMod) { 
		ptimeOldestMod = (*ptimeOldestMod > pao->timeEnqueued) ? &(pao->timeEnqueued) : ptimeOldestMod;
	    }
	    else {
		ptimeOldestMod = &(pao->timeEnqueued);
	    }
	    break;

	case AO_OP_UPD_REFS:
	    if (ptimeOldestUpdRefs) { 
		ptimeOldestUpdRefs = (*ptimeOldestUpdRefs > pao->timeEnqueued) ? &(pao->timeEnqueued) : ptimeOldestUpdRefs;
	    }
	    else {
		ptimeOldestUpdRefs = &(pao->timeEnqueued);
	    }
	    break; 

        default:
	    Assert(!"Logic error - unhandled AO op type");
            DRA_EXCEPT(DRAERR_InternalError, 0);
	}

    }
    
    if (ptimeOldestSync) {
	DSTimeToFileTime(*ptimeOldestSync,&ftimeTime);
	pQueueStats->ftimeOldestSync = ftimeTime;
    }
         
    if (ptimeOldestAdd) {
	DSTimeToFileTime(*ptimeOldestAdd,&ftimeTime);
	pQueueStats->ftimeOldestAdd = ftimeTime;
    }

    if (ptimeOldestDel) {
	DSTimeToFileTime(*ptimeOldestDel,&ftimeTime);
	pQueueStats->ftimeOldestDel = ftimeTime;
    }
    if (ptimeOldestMod) {
	DSTimeToFileTime(*ptimeOldestMod,&ftimeTime);
	pQueueStats->ftimeOldestMod = ftimeTime;
    }
    if (ptimeOldestUpdRefs) {
	DSTimeToFileTime(*ptimeOldestUpdRefs,&ftimeTime);
	pQueueStats->ftimeOldestUpdRefs = ftimeTime;
    }
    *ppQueueStats = pQueueStats;
    return 0;
}

ULONG
draGetPendingOps(
    IN THSTATE * pTHS,
    IN DBPOS * pDB,
    OUT DS_REPL_PENDING_OPSW ** ppPendingOps
    )
/*++

Routine Description:

    Return the pending replication syncs.

    This data is public, available via ntdsapi.h.

    Caller must have already acquired the csAOList lock.

Arguments:

    pTHS (IN)

    ppPendingOps (OUT) - On successful return, holds a pointer to the
        completed pending syncs structure.

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    DWORD                   cbPendingOps;
    DS_REPL_PENDING_OPSW *  pPendingOps;
    DS_REPL_OPW *           pOp;
    DS_REPL_OPW *           pOp2;
    AO *                    pao;
    DWORD                   dwFindFlags;
    MTX_ADDR *              pmtxDsaAddress;
    MTX_ADDR *              pmtxToFree;
    BOOL                    fTryToFindDSAInRepAtt;
    REPLICA_LINK *          pRepsFrom;
    DWORD                   cbRepsFrom;
    DSNAME                  GuidOnlyDN = {0};
    DSNAME *                pFullDN;
    DWORD                   i;
    DWORD                   j;
    OPTION_TRANSLATION *    pOptionXlat;
    DSNAME *                pNC;

    Assert(OWN_CRIT_SEC(csAOList));

    GuidOnlyDN.structLen = DSNameSizeFromLen(0);

    cbPendingOps = offsetof(DS_REPL_PENDING_OPSW, rgPendingOp)
                     + sizeof(pPendingOps->rgPendingOp[0])
                       * gulpaocount;
    pPendingOps = THAllocEx(pTHS, cbPendingOps);

    if (NULL != gpaoCurrent) {
        // Translate time at which current op started executing.
        DSTimeToFileTime(gtimeOpStarted,
                         &pPendingOps->ftimeCurrentOpStarted);
    }

    pOp = &pPendingOps->rgPendingOp[0];

    for (pao = gpaoCurrent ? gpaoCurrent : paoFirst;
         NULL != pao;
         pao = pao->paoNext) {

        pmtxDsaAddress = NULL;
        pNC = NULL;

        DSTimeToFileTime(pao->timeEnqueued, &pOp->ftimeEnqueued);

        pOp->ulSerialNumber = pao->ulSerialNumber;
        pOp->ulPriority     = pao->ulPriority;

        switch (pao->ulOperation) {
        case AO_OP_REP_SYNC:
            // Is an enqueued sync operation.
            pOp->OpType = DS_REPL_OP_TYPE_SYNC;
            pOptionXlat = RepSyncOptionToDra;
            pNC = pao->args.rep_sync.pNC;

            if (pao->ulOptions & DRS_SYNC_BYNAME) {
                pOp->pszDsaAddress = pao->args.rep_sync.pszDSA;
            }
            else {
                pOp->uuidDsaObjGuid = pao->args.rep_sync.invocationid;
            }
            break;

        case AO_OP_REP_ADD:
            // Is an enqueued add operation.
            pOp->OpType = DS_REPL_OP_TYPE_ADD;
            pOptionXlat = RepAddOptionToDra;
            pNC = pao->args.rep_add.pNC;

            pmtxDsaAddress = pao->args.rep_add.pDSASMtx_addr;

            if (NULL != pao->args.rep_add.pSourceDsaDN) {
                pOp->pszDsaDN = pao->args.rep_add.pSourceDsaDN->StringName;
                pOp->uuidDsaObjGuid = pao->args.rep_add.pSourceDsaDN->Guid;
            }
            break;

        case AO_OP_REP_DEL:
            // Is an enqueued delete operation.
            pOp->OpType = DS_REPL_OP_TYPE_DELETE;
            pOptionXlat = RepDelOptionToDra;
            pNC = pao->args.rep_del.pNC;

            pmtxDsaAddress = pao->args.rep_del.pSDSAMtx_addr;
            break;

        case AO_OP_REP_MOD:
            // Is an enqueued modify operation.
            pOp->OpType = DS_REPL_OP_TYPE_MODIFY;
            pOptionXlat = RepModOptionToDra;
            pNC = pao->args.rep_mod.pNC;

            if (fNullUuid(pao->args.rep_mod.puuidSourceDRA)) {
                pmtxDsaAddress = pao->args.rep_mod.pmtxSourceDRA;
            }
            else {
                pOp->uuidDsaObjGuid = *pao->args.rep_mod.puuidSourceDRA;
            }
            break;

        case AO_OP_UPD_REFS:
            // Is an enqueued repsTo update operation.
            pOp->OpType = DS_REPL_OP_TYPE_UPDATE_REFS;
            pOptionXlat = UpdRefOptionToDra;
            pNC = pao->args.upd_refs.pNC;

            pmtxDsaAddress = pao->args.upd_refs.pDSAMtx_addr;
            pOp->uuidDsaObjGuid = pao->args.upd_refs.invocationid;
            break;

        default:
            Assert(!"Logic error - unhandled AO op type");
            DRA_EXCEPT(DRAERR_InternalError, 0);
        }

        // Convert NC name.
        Assert(NULL != pNC);
        pOp->pszNamingContext = pao->args.rep_del.pNC->StringName;
        pOp->uuidNamingContextObjGuid = pao->args.rep_del.pNC->Guid;


        // Translate options bits to their public form.
        pOp->ulOptions = draTranslateOptions(pao->ulOptions,
                                             pOptionXlat);

        // Translate MTX_ADDR to transport address if necessary.
        if ((NULL == pOp->pszDsaAddress)
            && (NULL != pmtxDsaAddress)) {
            pOp->pszDsaAddress = TransportAddrFromMtxAddrEx(pmtxDsaAddress);
        }

        // If we have only one of the DSA's guid & address, try to use the one
        // we do have to determine the other.
        fTryToFindDSAInRepAtt = FALSE;
        pmtxToFree = NULL;
        if (fNullUuid(&pOp->uuidDsaObjGuid)) {
            // Don't have the DSA objectGuid.
            if ((NULL == pmtxDsaAddress)
                && (NULL != pOp->pszDsaAddress)) {
                // Derive MTX_ADDR from transport address.
                pmtxDsaAddress
                    = MtxAddrFromTransportAddrEx(pTHS, pOp->pszDsaAddress);
                pmtxToFree = pmtxDsaAddress;
            }

            if (NULL != pmtxDsaAddress) {
                // Try to derive ntdsDsa objectGuid from transport address.
                fTryToFindDSAInRepAtt = TRUE;
                dwFindFlags = DRS_FIND_DSA_BY_ADDRESS;
            }
        }
        else if (NULL == pOp->pszDsaAddress) {
            if (!fNullUuid(&pOp->uuidDsaObjGuid)) {
                // Try to derive transport address from ntdsDsa objectGuid.
                fTryToFindDSAInRepAtt = TRUE;
                dwFindFlags = DRS_FIND_DSA_BY_UUID;
            }
        }

        if (fTryToFindDSAInRepAtt
            && !DBFindDSName(pDB, pNC)
            && (0 == FindDSAinRepAtt(pDB,
                                     ATT_REPS_FROM,
                                     dwFindFlags,
                                     &pOp->uuidDsaObjGuid,
                                     pmtxDsaAddress,
                                     NULL,
                                     &pRepsFrom,
                                     &cbRepsFrom))) {
            // We're able to find a repsFrom for this source.
            if (DRS_FIND_DSA_BY_ADDRESS == dwFindFlags) {
                Assert(NULL != pOp->pszDsaAddress);
                pOp->uuidDsaObjGuid = pRepsFrom->V1.uuidDsaObj;
            }
            else {
                Assert(!fNullUuid(&pOp->uuidDsaObjGuid));
                pOp->pszDsaAddress
                    = TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepsFrom));
            }

            THFreeEx(pTHS, pRepsFrom);
        }

        if (NULL != pmtxToFree) {
            THFreeEx(pTHS, pmtxToFree);
        }

        pPendingOps->cNumPendingOps++;
        Assert(pPendingOps->cNumPendingOps <= gulpaocount);
        pOp++;
    }

    // Translate any ntdsDsa objectGuids we found into string names, if we don't
    // already know them.

    for (i = 0; i < pPendingOps->cNumPendingOps; i++) {
        pOp = &pPendingOps->rgPendingOp[i];

        if ((NULL == pOp->pszDsaDN)
            && !fNullUuid(&pOp->uuidDsaObjGuid)) {

            GuidOnlyDN.Guid = pOp->uuidDsaObjGuid;
            if (!DBFindDSName(pDB, &GuidOnlyDN)) {
                pFullDN = GetExtDSName(pDB);
                pOp->pszDsaDN = pFullDN->StringName;

                for (j = i+1; j < pPendingOps->cNumPendingOps; j++) {
                    pOp2 = &pPendingOps->rgPendingOp[j];

                    if (0 == memcmp(&pOp->uuidDsaObjGuid,
                                    &pOp2->uuidDsaObjGuid,
                                    sizeof(GUID))) {
                        // Same guid, same DN.
                        pOp2->pszDsaDN = pFullDN->StringName;
                    }
                }
            }
        }
    }

    *ppPendingOps = pPendingOps;

    return 0;
}


BOOL
IsHigherPriorityDraOpWaiting(void)
/*++

Routine Description:

    Determine whether there is a higher priority operation waiting in the queue
    than that that is currently executing.

Arguments:

    None.

Return Values:

    TRUE if a higher priority operation is waiting (and therefore the current
    operation should be preempted); FALSE otherwise.

--*/
{
    BOOL fPreempt = FALSE;

    // Note that gpaoCurrent will be NULL in the mail-based UpdateNC() case --
    // see ProcessUpdReplica() in dramail.c.

    EnterCriticalSection(&csAOList);
    __try {
        fPreempt = (NULL != gpaoCurrent)
                   && (NULL != paoFirst)
                   && (gpaoCurrent->ulPriority < paoFirst->ulPriority);
    }
    __finally {
        LeaveCriticalSection(&csAOList);
    }

    return fPreempt;
}


BOOL
IsDraOpWaiting(void)
/*++

Routine Description:

    Determine whether there is a operation waiting in the queue

Arguments:

    None.

Return Values:

    TRUE if an operation is waiting; FALSE otherwise.

--*/
{
    BOOL fWaiting = FALSE;

    // Note that gpaoCurrent will be NULL in the mail-based UpdateNC() case --
    // see ProcessUpdReplica() in dramail.c.

    EnterCriticalSection(&csAOList);
    __try {
        fWaiting = (NULL != paoFirst);
    }
    __finally {
        LeaveCriticalSection(&csAOList);
    }

    return fWaiting;
}


void
InitDraQueue(void)
/*++

Routine Description:

    Initialize the worker thread state.  Called once (indirectly) per
    DsInitialize().

Arguments:

    None.

Return Values:

    None.

--*/
{
    gpaoCurrent = NULL;
    gulpaocount = 0;
    paoFirst = NULL;
    fAsyncThreadAlive = FALSE;
    fAsyncAndQueueCheckStarted = FALSE;
}


DWORD
draTranslateOptions(
    IN  DWORD                   InternalOptions,
    IN  OPTION_TRANSLATION *    Table
    )
/*++

Routine Description:

    Utility routine to translate options bit from internal form to their
    public equivalent.

Arguments:

    InternalOptions -

    Table -

Return Value:

    Translated options.

--*/
{
    DWORD i, publicOptions;

    publicOptions = 0;
    for(i = 0; 0 != Table[i].InternalOption; i++) {
        if (InternalOptions & Table[i].InternalOption) {
            publicOptions |= Table[i].PublicOption;
        }
    }

    return publicOptions;
} /* draTranslateOptions */

#if DBG

BOOL
draQueueIsLockedByTestHook(
    IN  DWORD   cNumMsecToWaitForLockRelease
    )
/*++

Routine Description:

    Determine whether the queue should be considered "locked," ergo no
    operations should be dispatched.

    This routine is provided solely as a test hook.

Arguments:

    cNumMsecToWaitForLockRelease (IN) - Number of milliseconds to wait for queue
        to be unlocked, if we initially find it to be locked.

Return Values:

    TRUE if queue is locked, FALSE otherwise.

--*/
{
    HANDLE hevWaitHandles[2] = {hevEntriesInAOList, hServDoneEvent};
    DWORD cTickStart = GetTickCount();
    DWORD cTickDiff;
    DWORD cNumMsecRemainingToWait = cNumMsecToWaitForLockRelease;

    while (!eServiceShutdown
           && g_fDraQueueIsLockedByTestHook
           && cNumMsecRemainingToWait) {
        // Queue is locked and caller asked us to wait a bit to see if it's
        // unlocked.  Poll every half second to see if the lock has been
        // released yet.  If this were anything more than a test hook, we would
        // implement a new event rather than poll, but as it is we're trying to
        // minimize code impact.

        WaitForSingleObject(hServDoneEvent,
                            min(cNumMsecRemainingToWait, 500));

        cTickDiff = GetTickCount() - cTickStart;
        if (cTickDiff > cNumMsecToWaitForLockRelease) {
            cNumMsecRemainingToWait = 0;
        } else {
            cNumMsecRemainingToWait = cNumMsecToWaitForLockRelease - cTickDiff;
        }
    }

    if (eServiceShutdown) {
        // Shutting down -- clear any remaining queue locks so we can bail out.
        g_fDraQueueIsLockedByTestHook = FALSE;
    }

    return g_fDraQueueIsLockedByTestHook;
}

ULONG
DraSetQueueLock(
    IN  BOOL  fSetLock
    )
/*++

Routine Description:

    Lock (or unlock, if !fSetLock) the replication operation queue.  While the
    queue is locked no operations in the queue will be performed or removed
    (although additional operations can be added).

    This routine is provided solely as a test hook.

Arguments:

    fSetLock (IN) - Acquire (fSetLock) or release (!fSetLock) lock.

Return Values:

    Win32 error code.

--*/
{
    g_fDraQueueIsLockedByTestHook = fSetLock;

    return 0;
}
#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\addsid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       addsid.c
//
//--------------------------------------------------------------------------
/*++

Module Name:

    addsid.c

Abstract:

    This module implements IDL_DRSAddSidHistory.
    This module implements IDL_DRSInheritSecurityIdentity.

Author:

    Dave Straube    (DaveStr)   03/09/99

Revision History:

    Dave Straube    (DaveStr)   05/11/99
        Added IDL_DRSInheritSecurityIdentity.

--*/

#include <NTDSpch.h>
#pragma hdrstop

// Core headers.
#include <winldap.h>
#include <samrpc.h>
#include <ntlsa.h>
#include <samsrvp.h>
#include <samisrv.h>
#include <samicli2.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <lmaccess.h>                   // UF_*
#include <lmerr.h>                      // NERR_*
#include <msaudite.h>                   // SE_AUDITID_*
#include <lmcons.h>                     // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>                   // NetApiBufferFree()
#include <nlwrap.h>                     // (ds)DsrGetDcNameEx2()
#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // SPN
#include <debug.h>                      // Assert()
#include <dsatools.h>                   // Memory, etc.
#include <winsock2.h>                   // gethostbyname, etc.
#include <drs.h>                        // prototypes and CONTEXT_HANDLE_TYPE_*
#include <drautil.h>                    // DRS_CLIENT_CONTEXT
#include <anchor.h>
#include <attids.h>
#include <filtypes.h>
#include <cracknam.h>
#include <mappings.h>
#include <drarpc.h>

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError
#include <dstrace.h>

// Assorted DSA headers.
#include <dsexcept.h>

#define DEBSUB "DRASERV:"               // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_ADDSID

extern DWORD DsaExceptionToWin32(DWORD xCode);
extern VOID  SampBuildNT4FullSid(NT4SID *DomSid, ULONG Rid, NT4SID *NewSid);
extern VOID  SampSplitNT4SID(NT4SID *pObjSid, NT4SID *pDomSid, ULONG *pRid);
extern DWORD mapApiErrorToWin32(THSTATE *pTHS, DWORD ApiError);
extern ULONG IDL_DRSInheritSecurityIdentity(DRS_HANDLE hDrs,
                                            DWORD dwInVersion,
                                            DRS_MSG_ADDSIDREQ *pmsgIn,
                                            DWORD *pdwOutVersion,
                                            DRS_MSG_ADDSIDREPLY *pmsgOut);

// DsAddSidHistory may operate on machine accounts, but not interdomain
// trust accounts, nor on temp duplicate accounts.  Define UF_ versions
// of legal bits for later use.

#define LEGAL_UF_ACCOUNT_CONTROL    (   UF_NORMAL_ACCOUNT               \
                                      | UF_WORKSTATION_TRUST_ACCOUNT    \
                                      | UF_SERVER_TRUST_ACCOUNT )

DWORD
BuildDstObjATTRMODLIST(
    THSTATE                     *pTHS,                      // in
    ATTR                        *pSrcSid,                   // in
    ATTR                        *pSrcSidHistory,            // in
    ATTR                        *pDstSid,                   // in
    ATTR                        *pDstSidHistory,            // in
    MODIFYARG                   *pModifyArg);               // out

DWORD
BuildCheckAndUpdateArgs(
    THSTATE                     *pTHS,                      // in
    BOOL                        fSrcIsW2K,                  // in
    WCHAR                       *SrcDomainController,       // in
    WCHAR                       *SrcDomain,                 // in
    SEC_WINNT_AUTH_IDENTITY_W   *pAuthInfo,                 // in
    NT4SID                      *pSrcObjSid,                // in
    DWORD                       Flags,                      // in
    BOOL                        NeedImpersonation,          // in
    DWORD                       *pcNames,                   // out
    WCHAR                       ***prpNames,                // out
    ATTR                        **ppSrcSid,                 // out
    ATTR                        **ppSrcSidHistory,          // out
    DWORD                       *pDsid,                     // out
    BOOL                        *pImpersonating);           // out

DWORD
VerifySrcAuditingEnabledAndGetFlatName(
    IN  UNICODE_STRING  *usSrcDC,
    OUT WCHAR           **pSrcDomainFlatName,
    OUT DWORD           *pdsid
    );

DWORD
VerifySrcIsSP4OrGreater(
    IN  BOOL    fSrcIsW2K,
    IN  PWCHAR  SrcDc,
    OUT DWORD   *pdsid
    );

DWORD
VerifyIsPDC(
    IN  PWCHAR  DC,
    OUT DWORD   *pdsid
    );

DWORD
ForceAuditOnSrcObj(
    IN  WCHAR   *SrcDc,
    IN  NT4SID  *pSrcObjSid,
    IN  WCHAR   *pSrcDomainFlatName,
    OUT DWORD   *pdsid
    );

DWORD
ImpersonateSrcAdmin(
    IN  SEC_WINNT_AUTH_IDENTITY_W   *pauthInfo,
    IN  BOOL                        NeedImpersonation,
    OUT DWORD                       *pdsid,
    OUT BOOL                        *pImpersonating,
    OUT HANDLE                      *phToken
    );

DWORD
UnimpersonateSrcAdmin(
    IN  BOOL        NeedImpersonation,
    OUT DWORD       *pdsid,
    IN OUT BOOL     *pImpersonating,
    IN OUT HANDLE   *phToken
    );

// set DSID in subroutine
#define SetDsid(_pdsid_)    \
    *_pdsid_ = (FILENO << 16) | __LINE__;

DWORD
VerifyAuditingEnabled(
    )
/*++

  Description:

    Verify auditing is enabled for the domain this DC hosts.  Note that
    LSA assumes only one domain per DC this which domain does not need
    to be specified.

  Arguments:

    None

  Return Value:

    WIN32 return code.

--*/
{
    NTSTATUS                    status;
    POLICY_AUDIT_EVENTS_INFO    *pPolicy = NULL;
    BOOL                        fAuditing = FALSE;

    // Verify auditing is enabled for destination domain.
    // Note that the LSA API assumes one domain per DC.

    if ( status = LsaIQueryInformationPolicyTrusted(
                                PolicyAuditEventsInformation,
                                (PLSAPR_POLICY_INFORMATION *) &pPolicy) ) {
        return(RtlNtStatusToDosError(status));
    }

    if ( pPolicy->AuditingMode
            &&
         (pPolicy->EventAuditingOptions[AuditCategoryAccountManagement]
                                           & POLICY_AUDIT_EVENT_SUCCESS)
             &&
         (pPolicy->EventAuditingOptions[AuditCategoryAccountManagement]
                                           & POLICY_AUDIT_EVENT_FAILURE) ) {
        fAuditing = TRUE;
    }

    LsaIFree_LSAPR_POLICY_INFORMATION(PolicyAuditEventsInformation,
                                      (PLSAPR_POLICY_INFORMATION) pPolicy);

    if ( !fAuditing ) {
        return(ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED);
    }

    return(ERROR_SUCCESS);
}

DWORD
VerifyCallerIsDomainAdminOrLocalAdmin(
    THSTATE *pTHS,
    PSID    pDomainSid,
    BOOL    *pfAdminSidPresent
    )
/*++

  Description:

    Verify the current caller is a member of domain admins
    for the domain in question or a member of the local
    admins on this DC.  If both failed, then check if
    the caller are granted RIGHT_DS_MIGRATE_SID_HISTORY
    right on the domain DNS object.

  Arguments:

    pDomainSid - SID of domain to verify against.

    pfAdminSidPresent - Receives admin status on success.

  Return Value:

    WIN32 error code.

--*/
{
    DWORD   dwErr;
    NT4SID  adminSid;
    PSID    OtherSid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    CLASSCACHE *pCC;
    
    *pfAdminSidPresent = FALSE;

    // clear client context on the thread state since we are going to change context
    AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
    if ( dwErr = RpcImpersonateClient(NULL) ) {
        return(dwErr);
    }

    // check if member of domain admins
    SampBuildNT4FullSid(pDomainSid,
                        DOMAIN_GROUP_RID_ADMINS,
                        &adminSid);

    if ( !CheckTokenMembership(NULL, &adminSid, pfAdminSidPresent) ) {
        dwErr = GetLastError();
    } else if (!*pfAdminSidPresent) {
        // not member of domain admins, check if member of local admins
        if (!AllocateAndInitializeSid(&NtAuthority, 2,
                                      SECURITY_BUILTIN_DOMAIN_RID,
                                      DOMAIN_ALIAS_RID_ADMINS,
                                      0, 0, 0, 0, 0, 0,
                                      &OtherSid)) {
            dwErr = GetLastError();
        } else {
            if ( !CheckTokenMembership(NULL, OtherSid, pfAdminSidPresent) ) {
                dwErr = GetLastError();
            }
            FreeSid(OtherSid);
        }
    }

    // if the caller is not an domain admin nor local admin,
    // check if RIGHT_DS_MIGRATE_SID_HISTORY is present.
    if (!(*pfAdminSidPresent)) {

            pCC = SCGetClassById(pTHS, CLASS_DOMAIN_DNS);

            Assert(pCC && gAnchor.pDomainDN && gAnchor.pDomainSD );

            if (IsControlAccessGranted(gAnchor.pDomainSD,
                                       gAnchor.pDomainDN,
                                       pCC,
                                       RIGHT_DS_MIGRATE_SID_HISTORY,
                                       TRUE)) {
                *pfAdminSidPresent = TRUE;
                dwErr = 0;

            }
            else {
                dwErr = ERROR_DS_INSUFF_ACCESS_RIGHTS;
            }
       
    }


    RpcRevertToSelf();
    return(dwErr);
}

WCHAR *
FindSrcDomainController(
    WCHAR   *SrcDomain
    )
/*++

  Routine Description:

    Finds a domain controller for the source domain from which we are
    going to grab a SID.  Works for both NT4 and W2K domains.

  Arguments:

    SrcDomain - UNICODE source domain name.  Can be either NetBIOS flat
        name or DNS domain name.  DsGetDcName handles either.

  Return Value:

    LocalAlloc'd DC name or NULL.

--*/
{
    DWORD                   dwErr;
    DWORD                   flags;
    DWORD                   i;
    WCHAR                   *pDc;
    DOMAIN_CONTROLLER_INFOW *pDCInfo = NULL;
    WCHAR                   *pRet = NULL;

    // Set DsGetDcName flags such that we get exactly what we want regardless
    // of whether source domain is NT4 or NT5.  Asking for a writable DC gets
    // the PDC in the NT4 case. PDC's are now required.

    flags = ( DS_DIRECTORY_SERVICE_PREFERRED |
              DS_PDC_REQUIRED |
              DS_WRITABLE_REQUIRED);

    for ( i = 0; i < 2; i++ ) {
        if ( 1 == i ) {
            // Normally one shouldn't force discovery indiscriminately.
            // But considering that the source domain is ex-forest, this
            // won't invalidate the cache for domains inside the forest.

            flags |= DS_FORCE_REDISCOVERY;
        }

        RpcTryExcept {
            dwErr = dsDsrGetDcNameEx2(
                    NULL,                   // computer name
                    NULL,                   // account name
                    0x0,                    // allowable account control
                    SrcDomain,              // domain name
                    NULL,                   // domain guid
                    NULL,                   // site name
                    flags,
                    &pDCInfo);
//  UNDONE: seems more appropriate to use RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        } RpcExcept( HandleMostExceptions( RpcExceptionCode() ) ) {
            dwErr = RpcExceptionCode();
        } RpcEndExcept;

        if ( !dwErr ) {
            break;
        }
    }

    if ( !dwErr && pDCInfo ) {
        // ldap_initW cannot handle the leading "\\".
        pDc = pDCInfo->DomainControllerName;
        i = (wcslen(pDc) + 1) * sizeof(WCHAR);
        if (i > (sizeof(WCHAR) * 2)) {
            if (*pDc == L'\\' && *(pDc + 1) == L'\\') {
                pDc += 2;
                i -= (sizeof(WCHAR) * 2);
            }
        }

        if ( pRet = (WCHAR *) LocalAlloc(LPTR, i) ) {
            wcscpy(pRet, pDc);
        }
    }

    if ( pDCInfo ) {
        NetApiBufferFree(pDCInfo);
    }

    return(pRet);
}

DWORD
GetDomainHandleAndSid(
    SAM_HANDLE  hSam,
    WCHAR       *SrcDomain,
    SAM_HANDLE  *phDom,
    NT4SID      *pDomSid
    )
/*++

  Routine Description:

    Opens the source domain using calls guaranteed to work on NT4 or later
    and returns both a domain handle and the domain SID.

  Arguments:

    hSam - Valid SAM handle for source domain controller.

    SrcDomain - Name of source domain.

    phDom - Received valid domain handle on success.  Should be released
        via SamCloseHandle().

    pDomSid - Receives domain SID on success.

  Return Value:

    WIN32 error code.

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    NTSTATUS        status;
    UNICODE_STRING  usSrcDomain;
    PSID            pSid;

    *phDom = NULL;

    // Map domain name to SID.
    RtlInitUnicodeString(&usSrcDomain, SrcDomain);
    status = SamLookupDomainInSamServer(hSam, &usSrcDomain, &pSid);

    if ( !NT_SUCCESS(status) ) {
        dwErr = RtlNtStatusToDosError(status);
    } else {
        // Get a handle to the domain.
        status = SamOpenDomain(hSam, DOMAIN_LOOKUP, pSid, phDom);

        if ( !NT_SUCCESS(status) ) {
            dwErr = RtlNtStatusToDosError(status);
        } else {
            Assert(RtlLengthSid(pSid) <= sizeof(NT4SID));
            memcpy(pDomSid, pSid, RtlLengthSid(pSid));
        }

        SamFreeMemory(pSid);
    }

    return(dwErr);
}

DWORD
VerifySrcDomainAdminRights(
    SAM_HANDLE  hDom
    )
/*++

  Routine Description:

    Verifies that the principal which obtained the domain handle has
    domain admin rights in the domain.

  Arguments:

    hDom - Valid domain handle.

  Return Value:

    WIN32 error code.

--*/
{
    // We need to verify that the credentials used to get hSam have domain
    // admin rights in the source domain.  RichardW observes that we can
    // do this easily for both NT4 and NT5 cases by checking whether we
    // can open the domain admins object for write.  On NT4, the principal
    // would have to be an immediate member of domain admins.  On NT5 the
    // principal may transitively be a member of domain admins.  But rather
    // than checking memberships per se, the ability to open domain admins
    // for write proves that the principal could add himself if he wanted
    // to, thus he/she is essentially a domain admin.  I.e. The premise is
    // that security is set up such that only domain admins can modify the
    // domain admins group.  If that's not the case, the customer has far
    // worse security issues to deal with than someone stealing a SID.

    DWORD       dwErr = ERROR_SUCCESS;
    NTSTATUS    status;
    SAM_HANDLE  hGroup;
    ACCESS_MASK access;

    // You'd think we should ask for GROUP_ALL_ACCESS.  But it turns out
    // that in 2000.3 DELETE is not given by default to domain admins.
    // So we modify the access required accordingly.  PraeritG has been
    // notified of this phenomena.

    access = GROUP_ALL_ACCESS & ~DELETE;
    status = SamOpenGroup(hDom, access, DOMAIN_GROUP_RID_ADMINS, &hGroup);

    if ( !NT_SUCCESS(status) ) {
        dwErr = RtlNtStatusToDosError(status);
    } else {
        SamCloseHandle(hGroup);
    }

    return(dwErr);
}


DWORD
ForceSuccessAuditOnDstObj(
    WCHAR       *srcAccountName,
    WCHAR       *srcDomainName,
    NT4SID      *pSrcObjSid,
    NT4SID      *pDstObjSid,
    WCHAR       *flatAccountName,
    WCHAR       *flatDomainName
    )
/*++

  Routine Description:

    Forces a success audit event on the object whose ATT_SID_HISTORY
    was extended.

  Arguments:

    srcAccountName - SAM account name of the source object.

    srcDomainName - SAM account name of the source domain.

    pSrcObjSid - SID of the source object.

    pDstObjSid - SID of destination object.

    flatAccountName - SAM account name of destination object.

    flatDomainName - SAM account name of destination domain.

  Return Value:

    WIN32 error code.

--*/
{
    NTSTATUS        status;
    DWORD           dwErr = ERROR_SUCCESS;
    NT4SID          dstDomainSid;
    ULONG           dstObjRid;
    UNICODE_STRING  usAccountName;
    UNICODE_STRING  usDomainName;
    UNICODE_STRING  srcName;    // Source Account Name. (including domain name)
    PWCHAR          temp = NULL;
    ULONG           cb = 0;
    THSTATE         *pTHS = pTHStls;

    Assert(srcAccountName && srcDomainName && pSrcObjSid && pDstObjSid && flatAccountName && flatDomainName);

    SampSplitNT4SID(pDstObjSid, &dstDomainSid, &dstObjRid);
    RtlInitUnicodeString(&usAccountName, flatAccountName);
    RtlInitUnicodeString(&usDomainName, flatDomainName);

    //
    // Construct the Source Account Name (including Domain Name)
    //
    cb = sizeof(WCHAR) * (wcslen(srcDomainName) + wcslen(srcAccountName) + 2);
    temp = THAllocEx(pTHS, cb);

    if (NULL == temp)
        return(ERROR_NOT_ENOUGH_MEMORY);

    memset(temp, 0, cb);
    swprintf(temp, L"%s\\%s", srcDomainName, srcAccountName);
    RtlInitUnicodeString(&srcName, temp);

    status = LsaIAuditSamEvent(
                    STATUS_SUCCESS,                 // operation status
                    SE_AUDITID_ADD_SID_HISTORY,     // audit ID
                    &dstDomainSid,                  // domain SID
                    &srcName,                       // Additional Info - Src Account Name
                    NULL,                           // member RID - NULL
                    pSrcObjSid,                     // member SID - Src Principal SID
                    &usAccountName,                 // object's SAM name
                    &usDomainName,                  // domain's SAM name
                    &dstObjRid,                     // object RID
                    NULL,                           // privileges
                    NULL);                          // extended info



    if ( !NT_SUCCESS(status) ) {
        dwErr = RtlNtStatusToDosError(status);
    }

    THFreeEx(pTHS, temp);

    return(dwErr);
}

VOID
ForceFailureAuditOnDstDom(
    WCHAR       *srcAccountName,
    WCHAR       *srcDomainName,
    NT4SID      *pDstDomSid,
    WCHAR       *flatAccountName,
    WCHAR       *flatDomainName
    )
/*++

  Routine Description:

    Forces a failure audit event on the destination domain.

  Arguments:

    srcAccountName - SAM account name of the source object.

    srcDomainName - SAM account name of the source domain.

    pDstDomSid - SID of destination domain.

    flatAccountName - SAM account name of the destination account.

    flatDomainName - SAM account name of destination domain.

  Return Value:

    None.

--*/
{
    UNICODE_STRING  usAccountName;
    UNICODE_STRING  usDomainName;
    UNICODE_STRING  srcName;    // Source Account Name. (including domain name)
    PWCHAR          temp = NULL;
    ULONG           cb = 0;
    THSTATE         *pTHS = pTHStls;

    Assert(srcAccountName && srcDomainName && pDstDomSid && flatAccountName && flatDomainName);
    //
    // Construct the Source Account Name (including Domain Name)
    //
    cb = sizeof(WCHAR) * (wcslen(srcAccountName) + wcslen(srcDomainName) + 2);
    temp = THAllocEx(pTHS, cb);

    if (NULL == temp)
        return;

    memset(temp, 0, cb);
    swprintf(temp, L"%s\\%s", srcDomainName, srcAccountName);
    RtlInitUnicodeString(&srcName, temp);

    RtlInitUnicodeString(&usAccountName, flatAccountName);
    RtlInitUnicodeString(&usDomainName, flatDomainName);
    LsaIAuditSamEvent(
                    STATUS_ACCESS_DENIED,           // operation status
                    SE_AUDITID_ADD_SID_HISTORY,     // audit ID
                    pDstDomSid,                     // domain SID
                    &srcName,                       // Source Account Name
                    NULL,                           // member RID
                    NULL,                           // member SID
                    &usAccountName,                 // object's SAM name
                    &usDomainName,                  // domain's SAM name
                    NULL,                           // object RID
                    NULL,                           // privileges
                    NULL);                          // extended info


    THFreeEx(pTHS, temp);
}

DWORD
GetSrcPrincipalSid(
    SAM_HANDLE      hDom,
    WCHAR           *SrcPrincipal,
    NT4SID          *pSrcDomSid,
    NT4SID          *pSrcObjSid,
    SID_NAME_USE    *pSrcObjUse,
    DWORD           *pSrcObjControl,
    WCHAR           *dstDomainName
    )
/*++

  Routine Description:

    Derive the SID and object type of an object in the source domain.

  Arguments:

    hDom - Valid domain handle.

    SrcPrincipal - SAM Account Name of a principal in the domain.

    pSrcDomSid - SID of the domain.

    pSrcObjSid - Receives SID of the principal if found.

    pSrcObjUse - Receives the object type of the principal if found.

    pSrcObjControl - Receives the account control of the sourc object.
        These are returned in UF_* format, not USER_* format.  I.e. The
        returned data matches the format stored in the DS, not in legacy SAM.

    dstDomainName - SAM account name of destination domain.

  Return Value:

    WIN32 error code.

--*/
{
    DWORD                       dwErr = ERROR_SUCCESS;
    NTSTATUS                    status;
    UNICODE_STRING              usObj;
    SID_NAME_USE                *pUse = NULL;
    ULONG                       *pRid = NULL;
    SAM_HANDLE                  hObj = NULL;
    USER_CONTROL_INFORMATION    *pUserControl = NULL;

    memset(pSrcObjSid, 0, sizeof(NT4SID));
    *pSrcObjUse = SidTypeUnknown;
    *pSrcObjControl = 0;

    // Map name to SID.
    RtlInitUnicodeString(&usObj, SrcPrincipal);
    status = SamLookupNamesInDomain(hDom, 1, &usObj, &pRid, &pUse);

    if ( !NT_SUCCESS(status) ) {
        dwErr = RtlNtStatusToDosError(status);
    } else if (NULL == pUse) {
        // PREFIX: claims pUse may be NULL
        dwErr = ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER;
    } else {
        // Force audit - though source auditing is not a requirement.
        switch ( *pUse ) {
        case SidTypeUser:
            status = SamOpenUser(hDom, MAXIMUM_ALLOWED, *pRid, &hObj);
            if ( NT_SUCCESS(status) ) {
                // Users may be computers, etc. via account control.
                status = SamQueryInformationUser(hObj,
                                                 UserControlInformation,
                                                 &pUserControl);
                if ( NT_SUCCESS(status) ) {
                    *pSrcObjControl = SampAccountControlToFlags(
                                            pUserControl->UserAccountControl);
                    *pSrcObjControl &= UF_ACCOUNT_TYPE_MASK;
                    if ( *pSrcObjControl & ~LEGAL_UF_ACCOUNT_CONTROL ) {
                        dwErr = ERROR_DS_UNWILLING_TO_PERFORM;
                    }
                    SamFreeMemory(pUserControl);
                } else {
                    dwErr = RtlNtStatusToDosError(status);
                }
                SamCloseHandle(hObj);
            } else {
                dwErr = RtlNtStatusToDosError(status);
            }
            break;
        case SidTypeGroup:
            status = SamOpenGroup(hDom, MAXIMUM_ALLOWED, *pRid, &hObj);
            if ( NT_SUCCESS(status) ) {
                SamCloseHandle(hObj);
            } else {
                dwErr = RtlNtStatusToDosError(status);
            }
            break;
        case SidTypeAlias:
            status = SamOpenAlias(hDom, MAXIMUM_ALLOWED, *pRid, &hObj);
            if ( NT_SUCCESS(status) ) {
                SamCloseHandle(hObj);
            } else {
                dwErr = RtlNtStatusToDosError(status);
            }
            break;
        case SidTypeWellKnownGroup:
            // Eg: "Everyone" - illegal to move.
        case SidTypeComputer:
            // Not supported by NT4, nor by later versions for compatability.
        case SidTypeDomain:
            // Illegal to move.
        case SidTypeDeletedAccount:
            // Illegal to move.
        case SidTypeInvalid:
            // Illegal to move.
        case SidTypeUnknown:
            // Illegal to move.
        default:
            dwErr = ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER;
            break;
        }

        if ( !dwErr ) {
            // Set up return data.
            SampBuildNT4FullSid(pSrcDomSid, *pRid, pSrcObjSid);
            *pSrcObjUse = *pUse;
        }

        SamFreeMemory(pRid);
        SamFreeMemory(pUse);
    }

    return(dwErr);
}

DWORD
CheckIfSidsInForest(
    DWORD           cSids,
    WCHAR           **rpStringSids,
    GUID            *pGuid
    )
/*++

  Routine Description:

    Determines whether some SIDs are already present in the forest as either
    an ATT_OBJECT_SID or ATT_SID_HISTORY value.  If there is exactly one
    such object, then returns success and fills in pGuid with the GUID
    of that one object.

  Arguments:

    cSids - Count of SIDs to verify.

    rpStringSids - Array of string-ized SIDs to verify.

    pGuid - Receives GUID of object with this SID if it already exists.

  Return Value:

    WIN32 error code.

--*/
{
    DWORD           pass, i, dwErr = ERROR_SUCCESS;
    WCHAR           dnsName[256+1];
    WCHAR           guidName[40];
    DWORD           dnsNameLen;
    DWORD           guidNameLen;
    NTSTATUS        status;
    DWORD           nameErr;
    PVOID           pvSave;
    GUID            tmpGuid;
    BOOL            fCrackAtGC;

    memset(pGuid, 0, sizeof(GUID));

    // Verify src SIDs are not present in this forest.  There will always
    // be latency problems with this test, but we try to mitigate them
    // by going to a GC _AND_ performing the search locally in case the
    // SID was just added on this machine and hasn't made it to the GC yet.
    // Note that cracking a name by SID checks both ATT_OBJECT_SID
    // and ATT_SID_HISTORY.

    // PERFHINT: CrackSingleName assumes there is no THSTATE so we must
    // save/restore. This is incredibly inefficient and intended as a quick
    // prototyping solution only.  The efficient mechanism is to call
    // IDL_DRSCrackNames() if required, then open a DB and do a local
    // CrackNames().

    pvSave = THSave();

    __try {
        // Perform two passes - first against the GC, second locally.
        for ( pass = 0; pass < 2; pass++ ) {
            if ( 0 == pass ) {
                // First pass always at a GC - which could be ourself.
                fCrackAtGC = TRUE;
            } else if ( gAnchor.fAmVirtualGC ) {
                // Since we're a GC, pass 0 executed locally already.
                break;
            } else {
                fCrackAtGC = FALSE;
            }

            for ( i = 0; i < cSids; i++ ) {
                dnsNameLen = sizeof(dnsName) / sizeof(WCHAR);
                guidNameLen = sizeof(guidName) / sizeof(WCHAR);
                status = CrackSingleName(DS_STRING_SID_NAME, 
                                         (fCrackAtGC)?DS_NAME_FLAG_GCVERIFY:DS_NAME_NO_FLAGS,
                                         rpStringSids[i], DS_UNIQUE_ID_NAME,
                                         &dnsNameLen, dnsName,
                                         &guidNameLen, guidName,
                                         &nameErr);

                if ( !NT_SUCCESS(status) ) {
                    dwErr = RtlNtStatusToDosError(status);
                    break;
                } else if ( CrackNameStatusSuccess(nameErr) ) {
                    // Object with this SID exists once in forest.
                    if ( IsStringGuid(guidName, &tmpGuid) ) {
                        if ( fNullUuid(pGuid) ) {
                            // This is the first GUID we've found - save it.
                            *pGuid = tmpGuid;
                        } else if ( memcmp(pGuid, &tmpGuid, sizeof(GUID)) ) {
                            // Same SID on two different objects - bail.
                            dwErr = ERROR_DS_SRC_SID_EXISTS_IN_FOREST;
                            break;
                        } else {
                            // Two SIDs mapped to same object - this is OK.
                            Assert(ERROR_SUCCESS == dwErr);
                        }
                    } else {
                        // Malformed response from CrackSingleName.
                        dwErr = ERROR_DS_INTERNAL_FAILURE;
                        break;
                    }
                } else if ( DS_NAME_ERROR_NOT_UNIQUE == nameErr ) {
                    // SID exists more than once in the forest.
                    dwErr = ERROR_DS_SRC_SID_EXISTS_IN_FOREST;
                    break;
                } else if ( DS_NAME_ERROR_NOT_FOUND != nameErr
                            && DS_NAME_ERROR_DOMAIN_ONLY != nameErr  ) {
                    // Random processing error.
                    // We are fine if the return code is NOT_FOUND, or 
                    // DOMAIN_ONLY, which is an xforest routing hint,
                    // otherwise ......
                    dwErr = ERROR_DS_INTERNAL_FAILURE;
                    break;
                }
            }

            if ( dwErr ) {
                // Break from outer loop.
                break;
            }
        }
    } __finally {
        THRestore(pvSave);
    }

    return(dwErr);
}

BOOL
IsDomainInForest(
    WCHAR       *pDomain,
    CROSS_REF   **ppCR
    )
/*++

  Routine Description:

    Determines whether a domain is in the forest or not.  Domain name
    can be either flat NetBIOS name or DNS domain name, with or without
    trailing '.'.

  Arguments:

    pDomain - Domain name to find.

    ppCR - Receives address of corresponding CROSS_REF if domain is found.

  Return Value:

    TRUE if yes.

--*/
{
    THSTATE     *pTHS = pTHStls;
    WCHAR       *pTmp;
    DWORD       cChar;
    DWORD       cBytes;

    *ppCR = NULL;

    // Don't know if this is a flat or DNS name - so attempt both.

    if ( *ppCR = FindExactCrossRefForAltNcName(ATT_NETBIOS_NAME,
                                               (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                               pDomain) ) {
        return(TRUE);
    }

    if ( *ppCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT,
                                               (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                               pDomain) ) {
        return(TRUE);
    }

    // Retry with/without trailing '.' on DNS name as required.

    cChar = wcslen(pDomain);
    pTmp = (WCHAR *) THAllocEx(pTHS,(cChar + 2) * sizeof(WCHAR));
    
    wcscpy(pTmp, pDomain);

    if ( L'.' == pTmp[cChar-1] ) {
        pTmp[cChar-1] = L'\0';
    } else {
        pTmp[cChar] = L'.';
        pTmp[cChar+1] = L'\0';
    }

    if ( *ppCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT,
                                               (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                               pTmp) ) {
        THFreeEx(pTHS,pTmp);
        return(TRUE);
    }
    THFreeEx(pTHS,pTmp);
    return(FALSE);
}

VOID
THFreeATTR(
    THSTATE     *pTHS,
    ATTR        *pAttr,
    BOOL        fFreeBasePointer
    )
/*++

  Description:

    Deallocates a THAlloc'd ATTR and all that it points to.

  Arguments:

    pTHS - Valid THSTATE pointer.

    pAttr - Pointer to ATTR to deallocate.

    fFreeBasePointer - Flag indicating whether to free pAttr itself.  For
        example, set this to FALSE if passing in &MODIFYARG.FirstMod.AttrInf.

  Return Value:

    None.

--*/
{
    DWORD   i;

    if ( pTHS ) {
        if ( pAttr ) {
            if ( pAttr->AttrVal.pAVal ) {
                for ( i = 0; i < pAttr->AttrVal.valCount; i++ ) {
                    if ( pAttr->AttrVal.pAVal[i].pVal ) {
                        THFreeEx(pTHS, pAttr->AttrVal.pAVal[i].pVal);
                    }
                }
                THFreeEx(pTHS, pAttr->AttrVal.pAVal);
            }
            if ( fFreeBasePointer ) {
                THFreeEx(pTHS, pAttr);
            }
        }
    }
}


#define ADDSID_SECURE_KEY_SIZE (128)
DWORD AddSidSecureKeySize = ADDSID_SECURE_KEY_SIZE;
DWORD
VerifyCallIsSecure(
    IN DRS_CLIENT_CONTEXT   *pCtx,
    OUT DWORD               *pdsid
    )
/*++

  Description:

    This routine verifies that the call is local or, if remote, is
    using >= 128bit encryption. Addsid requires a secure connection
    in case the credentials for the src domain are being sent over the
    wire.

    A local connection is determined by checking the ip address in the
    context handle. If the ip addr is INADDR_NONE or matches one of the
    ip addresses for this computer then the call is local.

    If the call isn't local, then the keysize is extracted from the
    security context of the caller. If the extracted keysize is less
    than 128, an ERROR_DS_MUST_BE_RUN_ON_DST_DC is returned.

  Arguments:

    pCtx - explicit context handle

    pdsid - dsid returned to caller for error logging

  Return Value:

    Win32 error code.

--*/
{
    DWORD                   dwErr;
    DWORD                   i;
    ULONG                   KeySize;
    struct hostent          *phe;
    VOID                    *pSecurityContext;
    SecPkgContext_KeyInfo   KeyInfo;

    // LRPC (aka LPC_PROTSEQ, aka local call)
    if (pCtx->fLPC) {
        return ERROR_SUCCESS;
    }

    // Get the security context from the RPC handle
    dwErr = I_RpcBindingInqSecurityContext(I_RpcGetCurrentCallHandle(),
                                           &pSecurityContext);
    if (dwErr) {
        SetDsid(pdsid);
        return (dwErr);
    }

    // get the keysize
    dwErr = QueryContextAttributesW(pSecurityContext,
                                    SECPKG_ATTR_KEY_INFO,
                                    &KeyInfo);
    if (dwErr) {
        // treat "not supported" as "not secure"
        if (dwErr != SEC_E_UNSUPPORTED_FUNCTION) {
            SetDsid(pdsid);
            return (dwErr);
        }
        KeySize = 0;
    } else {
        KeySize = KeyInfo.KeySize;
        FreeContextBuffer(KeyInfo.sSignatureAlgorithmName);
        FreeContextBuffer(KeyInfo.sEncryptAlgorithmName);
    }

    // is the key size large enough?
    if (KeySize < AddSidSecureKeySize) {
        DPRINT2(0, "AddSid: keysize is %d (minimum is %d)\n",
                KeySize, AddSidSecureKeySize);
        return ERROR_DS_MUST_BE_RUN_ON_DST_DC;
    }

    return ERROR_SUCCESS;
}

#define SetAddSidError(err)                         \
{dwErr = pmsgOut->V1.dwWin32Error = err;     \
dsid = (FILENO << 16) | __LINE__;}

#define SetAddSidErrorWithDsid(err, id)             \
{dwErr = pmsgOut->V1.dwWin32Error = err;     \
dsid = id;}

ULONG
DRS_MSG_ADDSIDREQ_V1_InputValidate(
    DRS_MSG_ADDSIDREQ_V1 * pmsg
    )
/*
typedef struct _DRS_MSG_ADDSIDREQ_V1
    {
    DWORD Flags;
    [string] WCHAR *SrcDomain;
    [string] WCHAR *SrcPrincipal;
    [string][ptr] WCHAR *SrcDomainController;
    [range] DWORD SrcCredsUserLength;
    [size_is] WCHAR *SrcCredsUser;
    [range] DWORD SrcCredsDomainLength;
    [size_is] WCHAR *SrcCredsDomain;
    [range] DWORD SrcCredsPasswordLength;
    [size_is] WCHAR *SrcCredsPassword;
    [string] WCHAR *DstDomain;
    [string] WCHAR *DstPrincipal;
    } 	DRS_MSG_ADDSIDREQ_V1;
*/
{
    ULONG ret = ERROR_SUCCESS;  

    if ( pmsg->Flags & ~DS_ADDSID_FLAG_PRIVATE_CHK_SECURE ) {
	ret = ERROR_INVALID_PARAMETER;
    }

    if (ret==ERROR_SUCCESS) {
	ret = LPWSTR_Validate(pmsg->SrcDomain, FALSE);
    }
    if (ret==ERROR_SUCCESS) {
	ret = LPWSTR_Validate(pmsg->DstDomain, FALSE);
    }
    if (ret==ERROR_SUCCESS) {
	ret = LPWSTR_Validate(pmsg->SrcDomainController, TRUE);
    }

    if ( (ret==ERROR_SUCCESS) && (pmsg->SrcCredsUserLength > 0) && (pmsg->SrcCredsUser==NULL)) {
        ret = ERROR_INVALID_PARAMETER;
    }
    if ( (ret==ERROR_SUCCESS) && (pmsg->SrcCredsDomainLength > 0) && (pmsg->SrcCredsDomain==NULL)) {
        ret = ERROR_INVALID_PARAMETER;
    }
    if ( (ret==ERROR_SUCCESS) && (pmsg->SrcCredsPasswordLength > 0) && (pmsg->SrcCredsPassword==NULL)) {
        ret = ERROR_INVALID_PARAMETER;
    }

    if (ret==ERROR_SUCCESS) {
	ret = LPWSTR_Validate(pmsg->SrcPrincipal, FALSE);
    }
    if (ret==ERROR_SUCCESS) {
	ret = LPWSTR_Validate(pmsg->DstPrincipal, FALSE);
    }
         
    return ret;
}

ULONG
DRSAddSidHistory_InputValidate(
    DWORD                   dwMsgInVersion,
    DRS_MSG_ADDSIDREQ *     pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_ADDSIDREPLY *   pmsgOut
    ) 
/*
    [notify] ULONG IDL_DRSAddSidHistory( 
    [ref][in] DRS_HANDLE hDrs,
    [in] DWORD dwInVersion,
    [switch_is][ref][in] DRS_MSG_ADDSIDREQ *pmsgIn,
    [ref][out] DWORD *pdwOutVersion,
    [switch_is][ref][out] DRS_MSG_ADDSIDREPLY *pmsgOut)
*/
{
    ULONG ret = ERROR_SUCCESS;
    DWORD id;

    if ( 1 != dwMsgInVersion ) {
	ret = ERROR_INVALID_PARAMETER;
    }

    ret = DRS_MSG_ADDSIDREQ_V1_InputValidate(&(pmsgIn->V1)); 	 

    return ret;
}

ULONG
IDL_DRSAddSidHistory(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_ADDSIDREQ       *pmsgIn,
    DWORD                   *pdwOutVersion,
    DRS_MSG_ADDSIDREPLY     *pmsgOut
    )
/*++

  Routine Description:

    Grabs a SID from a principal in an ex-forest domain and adds it to the
    SID history of in-forest principal.  However, many, many conditions
    must be met for this to actually be performed.

    Auditing is performed since this operation can have a high security
    impact.  The source DC is responsible for auditing all operations at
    its end.  We, the destination DC, need to audit successful operations
    and any operations which fail for security reasons.  There's only one
    occurrence of the latter and that is when we check the caller for
    membership in domain admins of the destination domain.  The actual
    update to ATT_SID_HISTORY occurs with fDSA set, so it passes all
    security checks by definition.

  Arguments:

    hDrs - Valid DRS_HANDLE from RPC run times.

    dwInVersion - Identifies union version in DRS_MSG_ADDSIDREQ.

    pmsgIn - Input argument block.

    pdwOutVersion - Receives union version in DRS_MSG_ADDSIDREPLY.

    pmsgOut - Receives return data.

  Return Value:

    WIN32 error code.

--*/
{
    THSTATE                     *pTHS = pTHStls;
    DWORD                       i, cAtts, id, dsid = 0;
    DWORD                       ret = 0;
    BOOL                        fDbOpen = FALSE;
    BOOL                        fCommit = FALSE;
    DWORD                       dwErr = ERROR_INVALID_PARAMETER;
    DWORD                       xCode;
    RPC_AUTHZ_HANDLE            hAuthz;
    ULONG                       authnLevel;
    CROSS_REF                   *pSrcCR, *pDstCR;
    NT4SID                      dstAdminSid;
    BOOL                        fAdminSidPresent = FALSE;
    NTSTATUS                    status;
    WCHAR                       *SrcDomainController = NULL;
    SEC_WINNT_AUTH_IDENTITY_W   authInfo;
    OBJECT_ATTRIBUTES           oa;
    BOOL                        fSrcIsW2K;
    UNICODE_STRING              usSrcDC;
    SAM_HANDLE                  hSam = NULL;
    SAM_HANDLE                  hDom = NULL;
    NT4SID                      srcDomSid;
    NT4SID                      srcObjSid;
    NT4SID                      tmpSid;
    ULONG                       srcObjRid;
    ULONG                       dstObjRid;
    SID_NAME_USE                srcObjUse;
    BOOLEAN                     fMixedMode = TRUE;
    WCHAR                       *NT4Name;
    DWORD                       cBytes;
    DWORD                       cNamesOut;
    CrackedName                 *pCrackedName = NULL;
    ATTRTYP                     objClass;
    DWORD                       srcControl = 0;     // UF_* format
    DWORD                       dstControl = 0;     // UF_* format
    DWORD                       groupType;
    NT4_GROUP_TYPE              groupTypeNT4;
    NT5_GROUP_TYPE              groupTypeNT5;
    BOOLEAN                     fSecEnabled;
    MODIFYARG                   modifyArg;
    ATTRVAL                     attrVal;
    BOOL                        fLog = FALSE;
    GUID                        guidPreExists;
    ULONG                       mostBasicClass;
    BOOL                        fInheritSecurityIdentity = FALSE;
    DWORD                       cSids = 0;
    WCHAR                       **rpStringSids = NULL;
    ATTR                        *pSrcSid = NULL;
    ATTR                        *pSrcSidHistory = NULL;
    ATTR                        *pDstSidHistory = NULL;
    ATTR                        *pDstSid = NULL;
    ATTCACHE                    *pAC;
    BOOL                        Impersonating = FALSE;
    BOOL                        NeedImpersonation = FALSE;
    WCHAR                       *SrcSpn = NULL;
    HANDLE                      hToken = INVALID_HANDLE_VALUE;
    WCHAR                       *pSrcDomainFlatName = NULL;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSADDSIDHISTORY);
    drsReferenceContext( hDrs );
    // Since we have in args which were THAlloc'd we should have a THSTATE.
    Assert(pTHS);
    __try {
	*pdwOutVersion = 1;
	memset(&modifyArg, 0, sizeof(modifyArg)); 
	memset(pmsgOut, 0, sizeof(*pmsgOut));
	pmsgOut->V1.dwWin32Error = ERROR_DS_INTERNAL_FAILURE;

	// A defined method for calling this function is to "check" if a 
	// secure call can be made.  On this call, the input parameters aren't
	// set by the client (since it might not be secure).  So we can't
	// check the input params in this case.  Simply verify if the
	// connection is secure enough, and return.  At this time, this means 
	// the connection is local or, if remote, is using encryption keys 
	// that are at least 128bits in length.
	if ( DS_ADDSID_FLAG_PRIVATE_CHK_SECURE & pmsgIn->V1.Flags ) {
	    // verify that the call is local or keysize >= 128bits.
	    ret = VerifyCallIsSecure(hDrs, &id);
	    SetAddSidErrorWithDsid(ret, id);
	    __leave;
	}

	// branch off to IDL_DRSInheritSecurityIdentity now, if applicable
	// it'll check it's own args.
	if ( DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ & pmsgIn->V1.Flags ) {
	    // Disable logging and such outside the primary try/except
	    // as IDL_DRSInheritSecurityPrincipal does its own.
	    fInheritSecurityIdentity = TRUE;
	    ret = IDL_DRSInheritSecurityIdentity(hDrs, dwInVersion, pmsgIn,
						 pdwOutVersion, pmsgOut);
	    __leave;
	}
	// Sanity check arguments.

	if ((ret = DRSAddSidHistory_InputValidate(dwInVersion, 
						  pmsgIn,
						  pdwOutVersion,
						  pmsgOut
						  ))!=ERROR_SUCCESS) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    // don't return DRAERR_* codes, translate
	    if (ret==ERROR_DS_DRA_INVALID_PARAMETER) {
		ret = ERROR_INVALID_PARAMETER;
	    }
	    __leave;
	} 

	// Verify source domain is outside forest.

	if ( IsDomainInForest(pmsgIn->V1.SrcDomain, &pSrcCR) ) {
	    SetAddSidError(ERROR_DS_SOURCE_DOMAIN_IN_FOREST);
	    __leave;
	}

	// Verify destination domain is in forest.

	if ( !IsDomainInForest(pmsgIn->V1.DstDomain, &pDstCR) ) {
	    SetAddSidError(ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST);
	    __leave;
	}

	// Verify destination domain is writeable at this replica.

	if (    !gAnchor.pDomainDN
		|| !NameMatched(gAnchor.pDomainDN, pDstCR->pNC) ) {
	    SetAddSidError(ERROR_DS_MASTERDSA_REQUIRED);
	    __leave;
	}

	// Verify existence of stuff we will need from pDstCR,

	if ( !pDstCR->pNC->SidLen || !pDstCR->NetbiosName ) {
	    SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
	    __leave;
	}

	// Verify auditing is enabled for destination domain.

	if ( dwErr = VerifyAuditingEnabled() ) {
	    SetAddSidError(dwErr);
	    __leave;
	}

	// Verify caller is a member of domain admins for destination domain.

	if ( dwErr = VerifyCallerIsDomainAdminOrLocalAdmin(pTHS,
							   &pDstCR->pNC->Sid,
							   &fAdminSidPresent) ) {
	    SetAddSidError(dwErr);
	    __leave;
	}

	if ( !fAdminSidPresent ) {
	    ForceFailureAuditOnDstDom(pmsgIn->V1.SrcPrincipal,
				      pmsgIn->V1.SrcDomain,
				      &pDstCR->pNC->Sid,
				      pmsgIn->V1.DstPrincipal,
				      pDstCR->NetbiosName);
	    SetAddSidError(ERROR_DS_INSUFF_ACCESS_RIGHTS);
	    __leave;
	}

	// Verify destination domain is in native mode.

	status = SamIMixedDomain2((PSID) &pDstCR->pNC->Sid, &fMixedMode);

	if ( !NT_SUCCESS(status) ) {
	    SetAddSidError(RtlNtStatusToDosError(status));
	    __leave;
	}

	if ( fMixedMode ) {
	    SetAddSidError(ERROR_DS_DST_DOMAIN_NOT_NATIVE);
	    __leave;
	}

	// Find a domain controller in the source domain if required.

	if ( pmsgIn->V1.SrcDomainController ) {
	    SrcDomainController = pmsgIn->V1.SrcDomainController;
	}
	else
	    {
	    SrcDomainController = FindSrcDomainController(
		pmsgIn->V1.SrcDomain);

	    if ( !SrcDomainController ) {
		SetAddSidError(ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN);
		__leave;
	    }
	}

	// Connect to source domain using explicitly provided credentials.

	memset(&authInfo, 0, sizeof(authInfo));
	authInfo.UserLength = pmsgIn->V1.SrcCredsUserLength;
	authInfo.User = pmsgIn->V1.SrcCredsUser;
	authInfo.DomainLength = pmsgIn->V1.SrcCredsDomainLength;
	authInfo.Domain = pmsgIn->V1.SrcCredsDomain;
	authInfo.PasswordLength = pmsgIn->V1.SrcCredsPasswordLength;
	authInfo.Password = pmsgIn->V1.SrcCredsPassword;
	authInfo.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
	// No creds; need to impersonate caller
	if (   0 == authInfo.UserLength
	       && 0 == authInfo.DomainLength
	       && 0 == authInfo.PasswordLength) {
	    authInfo.User = NULL;
	    authInfo.Domain = NULL;
	    authInfo.Password = NULL;
	    NeedImpersonation = TRUE;
	} else if (0 == authInfo.PasswordLength) {
	    // Password may be a garbage pointer if PasswordLength is 0
	    // because of the semantics of the [size_is(xxx)] IDL definition.
	    authInfo.Password = L"";
	}

	InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
	RtlInitUnicodeString(&usSrcDC, SrcDomainController);

	// No creds; impersonate caller
	if (NeedImpersonation) {
	    // clear client context on the thread state since we are going to change context
	    AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
	    if (dwErr = RpcImpersonateClient(NULL)) {
		SetAddSidError(dwErr);
		__leave;
	    }
	    Impersonating = TRUE;

	    // build an Spn for binding to the SrcDc
	    //
	    // WARNING: Use "cifs" and not "HOST" because a subsequent
	    // call to LsaOpenPolicy prepends cifs to the server name
	    // and kerberos will not find the correct ticket in the
	    // ticket cache unless both cifs and the server name
	    // matches. Obviously, "HOST" doesn't match "cifs".
	    //
	    // This worked on on w2k because LsaOpenPolicy prepended
	    // HOST and not cifs.
	    SrcSpn = THAllocEx(pTHS, (  wcslen(L"cifs/")
					+ wcslen(SrcDomainController)
					+ wcslen(L"@")
					+ wcslen(pmsgIn->V1.SrcDomain)
					+ 1) * sizeof (WCHAR));
	    wcscpy(SrcSpn, L"cifs/");
	    wcscat(SrcSpn, SrcDomainController);
	    wcscat(SrcSpn, L"@");
	    wcscat(SrcSpn, pmsgIn->V1.SrcDomain);
	}

	// connect with PKT_INTEGRITY
	// WARNING: when using NULL creds, this call sets up the
	// kerberos ticket cache so that a later call to LsaOpenPolicy
	// picks up that ticket and goes across the wire to the SrcDc
	// w/appropriate creds. Otherwise, it goes across the wire
	// as ANONYMOUS and fails with access denied (error 5)
	if ( status = SamConnectWithCreds(&usSrcDC, &hSam, MAXIMUM_ALLOWED,
					  &oa, &authInfo, SrcSpn, &fSrcIsW2K) ) {
	    // It might be that the SrcDc is NT4 and the client is
	    // running locally. This config is supported so try the
	    // binding with a NULL SrcSpn to force the underlying code
	    // to use AUTH_WINNT instead of AUTH_NEGOTIATE.
	    if (status == RPC_NT_UNKNOWN_AUTHN_SERVICE && SrcSpn) {
		status = SamConnectWithCreds(&usSrcDC, &hSam,
					     MAXIMUM_ALLOWED,
					     &oa, &authInfo,
					     NULL, &fSrcIsW2K);
	    }
	    if (status) {
		SetAddSidError(RtlNtStatusToDosError(status));
		__leave;
	    }
	}
	// stop impersonation
	if (Impersonating) {
	    Impersonating = FALSE;
	    RpcRevertToSelf();
	}

	// Get a handle to the source domain.
	if ( dwErr = GetDomainHandleAndSid(hSam, pmsgIn->V1.SrcDomain,
					   &hDom, &srcDomSid) ) {
	    SetAddSidError(dwErr);
	    __leave;
	}

	// Verify source domain credentials have admin rights.
	if ( dwErr = VerifySrcDomainAdminRights(hDom) ) {
	    SetAddSidError(dwErr);
	    __leave;
	}

	if ( dwErr = GetSrcPrincipalSid(hDom, pmsgIn->V1.SrcPrincipal ,
					&srcDomSid, &srcObjSid,
					&srcObjUse, &srcControl,
					pDstCR->NetbiosName) ) {
	    SetAddSidError(dwErr);
	    __leave;
	}

	Assert(    (SidTypeUser == srcObjUse)
		   || (SidTypeGroup == srcObjUse)
		   || (SidTypeAlias == srcObjUse) );

	if ( dwErr = BuildCheckAndUpdateArgs(pTHS, fSrcIsW2K,
					     SrcDomainController,
					     pmsgIn->V1.SrcDomain,
					     &authInfo,
					     &srcObjSid,
					     pmsgIn->V1.Flags,
					     NeedImpersonation,
					     &cSids, &rpStringSids,
					     &pSrcSid, &pSrcSidHistory, &id,
					     &Impersonating) ) {
	    SetAddSidErrorWithDsid(dwErr, id);
	    __leave;
	}

	// String-ized src object SID is in now rpStringSids[0].
	Assert(rpStringSids && rpStringSids[0]);

	if ( dwErr = CheckIfSidsInForest(cSids, rpStringSids,
					 &guidPreExists) ) {
	    SetAddSidError(dwErr);
	    __leave;
	}

	// -----
	// BEGIN SRC CREDS IMPERSONATION
	// -----

	// Impersonate implicit or explicit Src admin creds
	if ( dwErr = ImpersonateSrcAdmin(&authInfo,
					 NeedImpersonation,
					 &id,
					 &Impersonating,
					 &hToken) ) {
	    SetAddSidErrorWithDsid(dwErr, id);
	    __leave;
	}

	// Verify source domain is auditing
	if ( dwErr = VerifySrcAuditingEnabledAndGetFlatName(&usSrcDC,
							    &pSrcDomainFlatName,
							    &id) ) {
	    SetAddSidErrorWithDsid(dwErr, id);
	    __leave;
	}

	// Verify source dc is SP4 or greater
	if ( dwErr = VerifySrcIsSP4OrGreater(fSrcIsW2K,
					     SrcDomainController,
					     &id) ) {
	    SetAddSidErrorWithDsid(dwErr, id);
	    __leave;
	}

	// Verify source dc is PDC
	if ( dwErr = VerifyIsPDC(SrcDomainController, &id) ) {
	    SetAddSidErrorWithDsid(dwErr, id);
	    __leave;
	}

	// Force audit on src dc by adding the src object's sid to the
	// SrcDomainFlatName$$$ group on the SrcDc and then deleting it.
	//
	// This has the added benefit of requiring the src admin
	// to create the SrcDomainFlatName$$$ group before Addsid will
	// steal sids from the SrcDomain. And it leaves a much more
	// obvious audit trail.
	if ( dwErr = ForceAuditOnSrcObj(SrcDomainController,
					&srcObjSid,
					pSrcDomainFlatName,
					&id) ) {
	    SetAddSidErrorWithDsid(dwErr, id);
	    __leave;
	}

	// Unimpersonate src admin
	if ( dwErr = UnimpersonateSrcAdmin(NeedImpersonation,
					   &id,
					   &Impersonating,
					   &hToken) ) {
	    SetAddSidErrorWithDsid(dwErr, id);
	    __leave;
	}
	// -----
	// END SRC CREDS IMPERSONATION
	// -----

	// Initialize thread state and open DB - this is not quite a no-op
	// if pTHS already exists.  I.e. It sets the caller type and refreshes
	// various things.

	if ( !(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI)) ) {
	    SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
	    __leave;
	}

	// WARNING - DO NOT GO OFF MACHINE AFTER THIS POINT AS THERE IS A
	// TRANSACTION OPEN!  (and long transactions exhaust version store)

	DBOpen2(TRUE, &pTHS->pDB);
	fDbOpen = TRUE;

	__try
	    {
	    // Crack domain\samAccountName for destination principal to a DN.

	    cBytes =   wcslen(pDstCR->NetbiosName)
	    + wcslen(pmsgIn->V1.DstPrincipal)
	    + 2;
	    cBytes *= sizeof(WCHAR);
	    NT4Name = (WCHAR *) THAllocEx(pTHS,cBytes);
	    wcscpy(NT4Name, pDstCR->NetbiosName);
	    wcscat(NT4Name, L"\\");
	    wcscat(NT4Name, pmsgIn->V1.DstPrincipal);
	    CrackNames(DS_NAME_NO_FLAGS, GetACP(), GetUserDefaultLCID(),
		       DS_NT4_ACCOUNT_NAME, DS_FQDN_1779_NAME, 1,
		       &NT4Name, &cNamesOut, &pCrackedName);
	    THFreeEx(pTHS,NT4Name);

	    if ( DS_NAME_ERROR_NOT_FOUND == pCrackedName->status ) {
		SetAddSidError(ERROR_DS_OBJ_NOT_FOUND);
		__leave;
	    } else if ( DS_NAME_ERROR_NOT_UNIQUE == pCrackedName->status ) {
		SetAddSidError(ERROR_DS_NAME_ERROR_NOT_UNIQUE);
		__leave;
	    } else if ( !CrackNameStatusSuccess(pCrackedName->status) ) {
		SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
		__leave;
	    }

	    // We now have enough info to do logging.

	    fLog = TRUE;

	    // Bail with error if any SIDs pre-existed on any other object.

	    if (    !fNullUuid(&guidPreExists)
		    && memcmp(&guidPreExists, &pCrackedName->pDSName->Guid,
			      sizeof(GUID)) ) {
		SetAddSidError(ERROR_DS_SRC_SID_EXISTS_IN_FOREST);
		__leave;
	    }

	    // Verify that we are doing user-to-user, group-to-group,
	    // alias-to-alias, workstation-to-workstation, server-to-server,
	    // but not mix and match of object classes or object types.

	    if (    DBFindDSName(pTHS->pDB, pCrackedName->pDSName)
		    || DBGetSingleValue(pTHS->pDB, ATT_OBJECT_CLASS,
					&objClass, sizeof(objClass), NULL) ) {
		SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
		__leave;
	    }

	    mostBasicClass = SampDeriveMostBasicDsClass(objClass);

	    switch ( mostBasicClass ) {
	    case CLASS_USER:
	    case CLASS_COMPUTER:
		// Computers added via legacy APIs can be user objects.
		// But all computers are SidTypeUser for legacy reasons.
		if ( SidTypeUser != srcObjUse) {
		    SetAddSidError(ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH);
		    __leave;
		}
		if ( DBGetSingleValue(pTHS->pDB, ATT_USER_ACCOUNT_CONTROL,
				      &dstControl, sizeof(dstControl), NULL) ) {
		    SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
		    __leave;
		}
		dstControl &= UF_ACCOUNT_TYPE_MASK;
		// Users and computers must have same account control bits set.
		if (    (dstControl & ~LEGAL_UF_ACCOUNT_CONTROL)
			|| (srcControl != dstControl) ) {
		    SetAddSidError(ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH);
		    _leave;
		}
		break;
	    case CLASS_GROUP:
		// Group objects don't have an account control.
		if (    (SidTypeGroup != srcObjUse)
			&& (SidTypeAlias != srcObjUse) ) {
		    SetAddSidError(ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH);
		    __leave;
		}
		if ( DBGetSingleValue(pTHS->pDB, ATT_GROUP_TYPE, &groupType,
				      sizeof(groupType), NULL) ) {
		    SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
		    __leave;
		}
		status = SampComputeGroupType(objClass, groupType,
					      &groupTypeNT4, &groupTypeNT5,
					      &fSecEnabled);
		if ( !NT_SUCCESS(status) ) {
		    SetAddSidError(RtlNtStatusToDosError(status));
		    __leave;
		}
		if (    (    (SidTypeGroup == srcObjUse)
			     && (NT4GlobalGroup != groupTypeNT4))
			|| (    (SidTypeAlias == srcObjUse)
				&& (NT4LocalGroup != groupTypeNT4)) ) {
		    SetAddSidError(ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH);
		    __leave;
		}
		break;
	    default:
		SetAddSidError(ERROR_DS_OBJ_CLASS_VIOLATION);
		__leave;
	    }

	    // Security principals must have SIDs.

	    Assert(pCrackedName->pDSName->SidLen > 0);

	    // Disallow theft of built in accounts.

	    if ( SECURITY_BUILTIN_DOMAIN_RID ==
		 *RtlSubAuthoritySid(&srcObjSid, 0) ) {
		SetAddSidError(ERROR_DS_UNWILLING_TO_PERFORM);
		__leave;
	    }

	    // Require that well known SIDs (which also have well known RIDs)
	    // are only added to like accounts.  Eg: Administrators of source
	    // can only be assigned to Administrators of destination.

	    SampSplitNT4SID(&srcObjSid, &tmpSid, &srcObjRid);
	    SampSplitNT4SID(&pCrackedName->pDSName->Sid, &tmpSid, &dstObjRid);

	    if (    (srcObjRid < SAMP_RESTRICTED_ACCOUNT_COUNT)
		    && (srcObjRid != dstObjRid) ) {
		SetAddSidError(ERROR_DS_UNWILLING_TO_PERFORM);
		__leave;
	    }

	    // Read dst object's ATT_SID_HISTORY and ATT_OBJECT_SID so we
	    // can do duplicate checks. Must read it in external form as
	    // we will check against external form SIDs.

	    if (    !(pAC = SCGetAttById(pTHS, ATT_SID_HISTORY))
		    || DBGetMultipleAtts(pTHS->pDB, 1, &pAC, NULL, NULL,
					 &cAtts, &pDstSidHistory,
					 DBGETMULTIPLEATTS_fEXTERNAL, 0) ) {
		SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
		__leave;
	    }

	    if ( 0 == cAtts ) {
		pDstSidHistory = NULL;
	    }

	    if (    !(pAC = SCGetAttById(pTHS, ATT_OBJECT_SID))
		    || DBGetMultipleAtts(pTHS->pDB, 1, &pAC, NULL, NULL,
					 &cAtts, &pDstSid,
					 DBGETMULTIPLEATTS_fEXTERNAL, 0) ) {
		SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
		__leave;
	    }

	    if ( 0 == cAtts ) {
		pDstSid = NULL;
	    }

	    // Everything checks out.  Now add src object's SID and SID
	    // history, if present, to dst object's SID history.  We
	    // need to filter out duplicate values in order to avoid
	    // ERROR_DS_ATT_VAL_ALREADY_EXISTS errors.

	    modifyArg.pObject = pCrackedName->pDSName;
	    modifyArg.count = 1;
	    modifyArg.FirstMod.choice = AT_CHOICE_ADD_VALUES;
	    InitCommarg(&modifyArg.CommArg);
	    modifyArg.pResObj = CreateResObj(pTHS->pDB, pCrackedName->pDSName);

	    if ( dwErr = BuildDstObjATTRMODLIST(pTHS,
						pSrcSid, pSrcSidHistory,
						pDstSid, pDstSidHistory,
						&modifyArg) ) {
		SetAddSidError(dwErr);
		__leave;
	    }

	    // Bail with success if all SIDs pre-existed on this object
	    // already.  Note that the earlier test against guidPreExists
	    // only proved that there was at least one SID which mapped
	    // to some object other than the destination object.  If
	    // guidPreExists matched the destination object, then its only
	    // now that we know whether some vs all SIDs were present already.
	    // We exit with success rather than complain the SIDs are already
	    // present so that the customer can re-run half-finished scripts
	    // and not error out when re-doing previous SID additions.

	    if ( 0 == modifyArg.FirstMod.AttrInf.AttrVal.valCount ) {
		SetAddSidError(ERROR_SUCCESS);
		__leave;
	    }

	    // Perform the write as fDSA as all checks have passed and
	    // ATT_SID_HISTORY is protected otherwise.

	    pTHS->fDSA = TRUE;
	    __try {
		LocalModify(pTHS, &modifyArg);
	    } __finally {
		pTHS->fDSA = FALSE;
	    }

	    if ( pTHS->errCode ) {
		// OK to leave w/o auditing since there can be no security
		// errors at this point due to fDSA being set during modify.
		SetAddSidError(mapApiErrorToWin32(pTHS, pTHS->errCode));
		__leave;
	    }

	    pTHS->fDSA = FALSE;

	    // Force local audit and fail entire operation if we can't do it.

	    if ( dwErr = ForceSuccessAuditOnDstObj(pmsgIn->V1.SrcPrincipal,
						   pmsgIn->V1.SrcDomain,
						   &srcObjSid,
						   &pCrackedName->pDSName->Sid,
						   pmsgIn->V1.DstPrincipal,
						   pDstCR->NetbiosName) ) {
		SetAddSidError(dwErr);
		__leave;
	    }

	    fCommit = TRUE;
	}
	__finally
	    {
	    if ( fDbOpen )
		{
		DBClose(pTHS->pDB, fCommit);
	    }
	}

	pmsgOut->V1.dwWin32Error = dwErr;

    }
    __except(HandleMostExceptions(xCode = GetExceptionCode()))
    {
	ret = DsaExceptionToWin32(xCode);
    }

    drsDereferenceContext( hDrs );

    __try {
	// stop impersonation (ignore errors)
	UnimpersonateSrcAdmin(NeedImpersonation,
			      &id,
			      &Impersonating,
			      &hToken);

	// Misc cleanup (moved outside of try/except to avoid resouce
	// exhaustion (eg, sam handles).

	if (    SrcDomainController
		&& (SrcDomainController != pmsgIn->V1.SrcDomainController) ) {
	    LocalFree(SrcDomainController);
	}

	if ( hDom ) {
	    SamCloseHandle(hDom);
	}

	if ( hSam ) {
	    SamCloseHandle(hSam);
	}

	if ( pSrcSid ) {
	    THFreeATTR(pTHS, pSrcSid, TRUE);
	}

	if ( pSrcSidHistory ) {
	    THFreeATTR(pTHS, pSrcSidHistory, TRUE);
	}

	if ( pDstSid ) {
	    THFreeATTR(pTHS, pDstSid, TRUE);
	}

	if ( pDstSidHistory ) {
	    THFreeATTR(pTHS, pDstSidHistory, TRUE);
	}

	if ( modifyArg.pResObj ) {
	    THFreeEx(pTHS, modifyArg.pResObj);
	}

	if ( SrcSpn ) {
	    THFreeEx(pTHS, SrcSpn);
	}

	if ( pSrcDomainFlatName ) {
	    THFreeEx(pTHS, pSrcDomainFlatName);
	}

	// Log to Directory Service event log.  Log exception error if there
	// is one, operation error otherwise.
	if ( pTHS && !fInheritSecurityIdentity ) {
	    LogEvent8(DS_EVENT_CAT_DIRECTORY_ACCESS,
		      ( !ret && !dwErr )
		      ? DS_EVENT_SEV_MINIMAL
		      : DS_EVENT_SEV_ALWAYS,
		( !ret && !dwErr )
	    ? DIRLOG_SID_HISTORY_MODIFIED
		: DIRLOG_FAILED_TO_ADD_SID_HISTORY,
		( fLog )
	    ? szInsertWC(pCrackedName->pDSName->StringName)
	    : szInsertWC(L"?"),
			  ( !ret && !dwErr )
		      ? (( fLog )
			 ? szInsertWC(rpStringSids[0])
			 : szInsertWC(L"?"))
		      : szInsertHex(dsid),
		    szInsertInt(ret ? ret : dwErr),
		    szInsertWin32Msg(ret ? ret : dwErr),
		    NULL, NULL, NULL, NULL);
	}

	// Clean up those items which we needed around for logging.

	if ( pCrackedName ) {
	    if ( pCrackedName->pDSName ) {
		THFreeEx(pTHS, pCrackedName->pDSName);
	    }
	    if ( pCrackedName->pFormattedName ) {
		THFreeEx(pTHS, pCrackedName->pFormattedName);
	    }
	    if ( pCrackedName->pDnsDomain ) {
		THFreeEx(pTHS, pCrackedName->pDnsDomain);
	    }
	    THFreeEx(pTHS, pCrackedName);
	}

	if ( rpStringSids ) {
	    for ( i = 0; i < cSids; i++ ) {
		if ( rpStringSids[i] ) {
		    THFreeEx(pTHS, rpStringSids[i]);
		}
	    }
	    THFreeEx(pTHS, rpStringSids);
	}
    } __except(HandleMostExceptions(xCode = GetExceptionCode())) {
	  if (!ret) {
	      ret = DsaExceptionToWin32(xCode);
	  }
    }
 
   return(ret);
}

BOOL
ExistsSidInSidHistory(
    ATTRVAL     *pAVal,
    ATTR        *pDstSidHistory
    )
/*++

  Description:

    Determines whether the ATTRVAL presented already exists in the ATTR.

  Arguments:

    pAVal - ATTRVAL for which to test.

    pDstSidHistory - ATTR to test against representing dst object's SID
        history.  May be NULL.

  Return Values:

    TRUE or FALSE

--*/
{
    DWORD   i;

    if ( pDstSidHistory ) {
        for ( i = 0; i < pDstSidHistory->AttrVal.valCount; i++ ) {
            if (    (pAVal->valLen == pDstSidHistory->AttrVal.pAVal[i].valLen)
                 && !memcmp(pAVal->pVal,
                            pDstSidHistory->AttrVal.pAVal[i].pVal,
                            pAVal->valLen) ) {
                return(TRUE);
            }
        }
    }

    return(FALSE);
}

DWORD
BuildDstObjATTRMODLIST(
    THSTATE     *pTHS,
    ATTR        *pSrcSid,
    ATTR        *pSrcSidHistory,
    ATTR        *pDstSid,
    ATTR        *pDstSidHistory,
    MODIFYARG   *pModifyArg
    )
/*++

  Description:

    Constructs an ATTRMODLIST which has only those SIDs from the src object
    which are not already present on the dst object's SID history or as
    the dst object's sid.

  Arguments:

    pTHS - Valid THSTATE.

    pSrcSid - ATTR representing source object's SID.

    pSrcSidHistory - ATTR representing source object's SID history - may
        be NULL.

    pDstSid - ATTR representing destination object's SID.

    pDstSidHistory - ATTR representing destination object's SID history -
        may be NULL.

  Return Values:

    Win32 error code

--*/
{
    DWORD       i, j, cSids;
    ATTR        *rAttr[] = { pSrcSid, pSrcSidHistory, NULL };
    ATTR        *pAttr;
    ULONG       *pulValCount;

    // Count SIDs on src object.

    cSids = pSrcSid->AttrVal.valCount;
    if ( pSrcSidHistory ) {
        cSids += pSrcSidHistory->AttrVal.valCount;
    }

    // Allocate for max # of SIDs in MODIFYARG - some may not get used.

    pModifyArg->FirstMod.AttrInf.attrTyp = ATT_SID_HISTORY;
    pModifyArg->FirstMod.AttrInf.AttrVal.valCount = 0;
    pModifyArg->FirstMod.AttrInf.AttrVal.pAVal =
            (ATTRVAL *) THAllocEx(pTHS, cSids * sizeof(ATTRVAL));
    if ( !pModifyArg->FirstMod.AttrInf.AttrVal.pAVal ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Now add each SID in source to ATTRMODLIST if it is not yet present
    // in destination.  We run the same multi-value algorithm for both
    // SID and SID history though we know that object SID is single valued.

    pulValCount = &pModifyArg->FirstMod.AttrInf.AttrVal.valCount;
    for ( i = 0, pAttr = rAttr[0];  NULL != pAttr; i++, pAttr = rAttr[i] ) {
        for ( j = 0; j < pAttr->AttrVal.valCount; j++ ) {
            if (   (!ExistsSidInSidHistory(&pAttr->AttrVal.pAVal[j],
                                           pDstSid))
                && (!ExistsSidInSidHistory(&pAttr->AttrVal.pAVal[j],
                                           pDstSidHistory)) ) {
                pModifyArg->FirstMod.AttrInf.AttrVal.pAVal[(*pulValCount)++] =
                                                    pAttr->AttrVal.pAVal[j];
            }
        }
    }

    return(ERROR_SUCCESS);
}

ULONG
DRS_MSG_INHERITSECREQ_V1_InputValidate(
    DRS_MSG_ADDSIDREQ_V1 * pmsg
    )
/*
    * this isn't a real type, it's just
      the addsidhistory structure reused
      with different input requirements.

typedef struct _DRS_MSG_ADDSIDREQ_V1
    {
    DWORD Flags;
    [string] WCHAR *SrcDomain;
    [string] WCHAR *SrcPrincipal;
    [string][ptr] WCHAR *SrcDomainController;
    [range] DWORD SrcCredsUserLength;
    [size_is] WCHAR *SrcCredsUser;
    [range] DWORD SrcCredsDomainLength;
    [size_is] WCHAR *SrcCredsDomain;
    [range] DWORD SrcCredsPasswordLength;
    [size_is] WCHAR *SrcCredsPassword;
    [string] WCHAR *DstDomain;
    [string] WCHAR *DstPrincipal;
    } 	DRS_MSG_ADDSIDREQ_V1;
*/
{
    ULONG ret = ERROR_SUCCESS;  

    if (pmsg->Flags & ~DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ) {
	ret = ERROR_INVALID_PARAMETER;
    }

    if (ret==ERROR_SUCCESS) {
	// in this case, the param should be empty 
	if (pmsg->SrcDomain!=NULL) {
	    ret = ERROR_INVALID_PARAMETER;
	}
    }
    if (ret==ERROR_SUCCESS) {
	// same here
	if (pmsg->DstDomain!=NULL) {
	    ret = ERROR_INVALID_PARAMETER;
	}
    }

    if (ret==ERROR_SUCCESS) {
	if ((pmsg->SrcCredsUserLength!=0) || (pmsg->SrcCredsDomainLength!=0) || (pmsg->SrcCredsPasswordLength!=0)) {
	    ret = ERROR_INVALID_PARAMETER;
	}
    }

    if (ret==ERROR_SUCCESS) {
	ret = LPWSTR_Validate(pmsg->SrcDomainController, TRUE);
    }

    if (ret==ERROR_SUCCESS) {
	ret = LPWSTR_Validate(pmsg->SrcPrincipal, FALSE);
    }
    if (ret==ERROR_SUCCESS) {
	ret = LPWSTR_Validate(pmsg->DstPrincipal, FALSE);
    }

    return ret;
}

ULONG
DRSInheritSecurityIdentity_InputValidate(
    DWORD                   dwMsgInVersion,
    DRS_MSG_ADDSIDREQ *     pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_ADDSIDREPLY *   pmsgOut
    ) 
/*
    *this isn't a "real" rpc function, it's a branch off
     AddSidHistory, but because of it's setup, and different
     arg requirements, we're treating it such.

    [notify] ULONG IDL_DRSAddSidHistory( 
    [in] DRS_HANDLE hDrs,
    [in] DWORD dwInVersion,
    [switch_is][ref][in] DRS_MSG_ADDSIDREQ *pmsgIn,
    [ref][out] DWORD *pdwOutVersion,
    [switch_is][ref][out] DRS_MSG_ADDSIDREPLY *pmsgOut)
*/
{
    ULONG ret = ERROR_SUCCESS;
    DWORD id;

    if ( 1 != dwMsgInVersion ) {
	ret = ERROR_INVALID_PARAMETER;
    }

    ret = DRS_MSG_INHERITSECREQ_V1_InputValidate(&(pmsgIn->V1)); 	 

    return ret;
}

ULONG
IDL_DRSInheritSecurityIdentity(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_ADDSIDREQ       *pmsgIn,
    DWORD                   *pdwOutVersion,
    DRS_MSG_ADDSIDREPLY     *pmsgOut
    )
/*++

  Routine Description:

    Grabs SID and SID history from src principal and adds it to the SID
    history of the dst principal and deletes the src principal.  Both
    principals must be in the same domain such that the entire operation
    can be transacted.

    Auditing is performed since this operation can have a high security
    impact.

    The routine is called IDL_DRSInheritSecurityIdentity although it isn't
    truly a drs.idl entry point.  The name is chosen to highlight that the
    implementation should do all the same checks and logging as would a
    drs.idl entry point even though it comes across the wire on the
    IDL_DRSAddSidHistory entry point.

  Arguments:

    hDrs - Valid DRS_HANDLE from RPC run times.

    dwInVersion - Identifies union version in DRS_MSG_ADDSIDREQ.

    pmsgIn - Input argument block.

    pdwOutVersion - Receives union version in DRS_MSG_ADDSIDREPLY.

    pmsgOut - Receives return data.

  Return Value:

    WIN32 error code.

--*/
{
    THSTATE                     *pTHS = pTHStls;
    DWORD                       dsid = 0;
    DWORD                       ret = 0;
    BOOL                        fDbOpen = FALSE;
    BOOL                        fCommit = FALSE;
    DWORD                       dwErr = ERROR_INVALID_PARAMETER;
    DWORD                       xCode;
    CROSS_REF                   *pSrcCR, *pDstCR;
    BOOL                        fAdminSidPresent = FALSE;
    NTSTATUS                    status;
    BOOLEAN                     fMixedMode = TRUE;
    MODIFYARG                   modifyArg;
    ATTRVAL                     attrVal;
    BOOL                        fLog = FALSE;
    COMMARG                     commArg;
    ATTCACHE                    *rAC[3];
    DSNAME                      *pSrcDSName = NULL;
    DSNAME                      *pDstDSName = NULL;
    DWORD                       cb1, cb2;
    ULONG                       cAttsSrc = 0;
    ATTR                        *rAttsSrc = NULL;
    ULONG                       cAttsDst = 0;
    ATTR                        *pSrcSid = NULL;
    ATTR                        *pSrcSidHistory = NULL;
    ATTR                        *rAttsDst = NULL;
    ATTR                        *pDstSid = NULL;
    ATTR                        *pDstSidHistory = NULL;
    ATTR                        *pDstSamAcctName = NULL;
    WCHAR                       *pwszSamAcctName = NULL;
    DWORD                       i, j;
    ULONG                       mostBasicClass;
    REMOVEARG                   removeArg;
    ATTRTYP                     dstClass;
    NT4SID                      domainSid;
    DWORD                       srcRid, dstRid;
    RESOBJ                      *pSrcResObj = NULL;
    RESOBJ                      *pDstResObj = NULL;
 
    // drsReferenceContext( hDrs ); - this isn't a real rpc call, so we shouldn't
    //                                call this - IDL_DRSAddSidHistory does this
    //                                for us.

    // Since we have in args which were THAlloc'd we should have a THSTATE.
    Assert(pTHS);

    __try {
	*pdwOutVersion = 1;
	memset(pmsgOut, 0, sizeof(*pmsgOut));
	pmsgOut->V1.dwWin32Error = ERROR_DS_INTERNAL_FAILURE;

	Assert(DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ & pmsgIn->V1.Flags);

	// Sanity check remaining arguments.

	if ((ret = DRSInheritSecurityIdentity_InputValidate(dwInVersion, 
							    pmsgIn,
							    pdwOutVersion,
							    pmsgOut
							    ))!=ERROR_SUCCESS) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    // don't return DRAERR_* codes, translate
	    if (ret==ERROR_DS_DRA_INVALID_PARAMETER) {
		ret = ERROR_INVALID_PARAMETER;
	    }
	    __leave;
	}

	#define SetInheritSidError(err)                         \
	dwErr = pmsgOut->V1.dwWin32Error = err;         \
	dsid = (FILENO << 16) | __LINE__;

	// All we need for logging is valid SrcPrincipal and DstPrincipal args.

	fLog = TRUE;

	// Construct DSNAMEs for src and dst objects.

	cb1 = (DWORD)DSNameSizeFromLen(wcslen(pmsgIn->V1.SrcPrincipal));
	cb2 = (DWORD)DSNameSizeFromLen(wcslen(pmsgIn->V1.DstPrincipal));
	pSrcDSName = (DSNAME *) THAllocEx(pTHS, cb1);
	pDstDSName = (DSNAME *) THAllocEx(pTHS, cb2);

	if ( !pSrcDSName || !pDstDSName ) {
	    SetInheritSidError(ERROR_NOT_ENOUGH_MEMORY);
	    __leave;
	}

	pSrcDSName->structLen = cb1;
	wcscpy(pSrcDSName->StringName, pmsgIn->V1.SrcPrincipal);
	pSrcDSName->NameLen = wcslen(pmsgIn->V1.SrcPrincipal);

	pDstDSName->structLen = cb2;
	wcscpy(pDstDSName->StringName, pmsgIn->V1.DstPrincipal);
	pDstDSName->NameLen = wcslen(pmsgIn->V1.DstPrincipal);

	// Map objects to domains and verify they are in the same domain.

	InitCommarg(&commArg);
	commArg.Svccntl.dontUseCopy = TRUE;
	pSrcCR = FindBestCrossRef(pSrcDSName, &commArg);
	pDstCR = FindBestCrossRef(pDstDSName, &commArg);

	if ( !pSrcCR || !pDstCR || (pSrcCR != pDstCR) ) {
	    SetInheritSidError(ERROR_INVALID_PARAMETER);
	    __leave;
	}

	// Verify domain is writeable at this replica.

	if (    !gAnchor.pDomainDN
		|| !NameMatched(gAnchor.pDomainDN, pDstCR->pNC) ) {
	    SetInheritSidError(ERROR_DS_MASTERDSA_REQUIRED);
	    __leave;
	}

	// Verify existence of stuff we will need from pDstCR,

	if ( !pDstCR->pNC->SidLen || !pDstCR->NetbiosName ) {
	    SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
	    __leave;
	}

	// Verify auditing is enabled for destination domain.

	if ( dwErr = VerifyAuditingEnabled() ) {
	    SetInheritSidError(dwErr);
	    __leave;
	}

	// Verify caller is a member of domain admins for destination domain.

	if ( dwErr = VerifyCallerIsDomainAdminOrLocalAdmin(pTHS,
							   &pDstCR->pNC->Sid,
							   &fAdminSidPresent) ) {
	    SetInheritSidError(dwErr);
	    __leave;
	} else if ( !fAdminSidPresent ) {
	    ForceFailureAuditOnDstDom(pmsgIn->V1.SrcPrincipal,
				      pDstCR->NetbiosName,
				      &pDstCR->pNC->Sid,
				      pmsgIn->V1.DstPrincipal,
				      pDstCR->NetbiosName);
	    SetInheritSidError(ERROR_DS_INSUFF_ACCESS_RIGHTS);
	    __leave;
	}

	// Verify destination domain is in native mode.

	status = SamIMixedDomain2((PSID) &pDstCR->pNC->Sid, &fMixedMode);

	if ( !NT_SUCCESS(status) ) {
	    SetInheritSidError(RtlNtStatusToDosError(status));
	    __leave;
	} else if ( fMixedMode ) {
	    SetInheritSidError(ERROR_DS_DST_DOMAIN_NOT_NATIVE);
	    __leave;
	}

	// Initialize thread state and open DB - this is not quite a no-op
	// if pTHS already exists.  I.e. It sets the caller type and refreshes
	// various things.

	if ( !(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI)) ) {
	    SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
	    __leave;
	}

	DBOpen2(TRUE, &pTHS->pDB);
	fDbOpen = TRUE;

	__try
	    {
	    // Obtain various ATTCACHE entries we will need.

	    if (    !(rAC[0] = SCGetAttById(pTHS, ATT_OBJECT_SID))
		    || !(rAC[1] = SCGetAttById(pTHS, ATT_SID_HISTORY))
		    || !(rAC[2] = SCGetAttById(pTHS, ATT_SAM_ACCOUNT_NAME)) ) {
		SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
		__leave;
	    }

	    // Position on the source object.

	    if ( DBFindDSName(pTHS->pDB, pSrcDSName) ) {
		SetInheritSidError(ERROR_INVALID_PARAMETER);
		__leave;
	    }

	    // Create src object RESOBJ which nets us class info.

	    if ( !(pSrcResObj = CreateResObj(pTHS->pDB, pSrcDSName)) ) {
		SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
		__leave;
	    }

	    // Is this a security principal?

	    mostBasicClass = SampDeriveMostBasicDsClass(
		pSrcResObj->MostSpecificObjClass);

	    if (    (CLASS_USER != mostBasicClass)
		    && (CLASS_GROUP != mostBasicClass)
		    && (CLASS_COMPUTER != mostBasicClass) ) {
		SetInheritSidError(ERROR_INVALID_PARAMETER);
		__leave;
	    }

	    // Read various other source object properties.
	    // Get everything in external form as we will write it back
	    // later via LocalModify which expects external form arguments.

	    if ( dwErr = DBGetMultipleAtts(pTHS->pDB, 3, rAC, NULL, NULL,
					   &cAttsSrc, &rAttsSrc,
					   DBGETMULTIPLEATTS_fEXTERNAL, 0) ) {
		SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
		__leave;
	    }

	    // See what we've got.

	    for ( i = 0; i < cAttsSrc; i++ ) {
		switch ( rAttsSrc[i].attrTyp ) {
		case ATT_OBJECT_SID:    pSrcSid = &rAttsSrc[i];         break;
		case ATT_SID_HISTORY:   pSrcSidHistory = &rAttsSrc[i];  break;
		}
	    }

	    // It is a security principal, it better have a SID.

	    if ( !pSrcSid ) {
		SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
		__leave;
	    }

	    // Delete source object now that we have its SIDs in hand.  Do
	    // this with full security checking to insure caller is bumped
	    // if he doesn't have delete rights.  The reason we delete before
	    // adding SIDs to dst object is to avoid any duplicate SID
	    // scenarios the core may check for.

	    // We're still positioned on the src object and thus can call
	    // CreateResObj directly.

	    memset(&removeArg, 0, sizeof(removeArg));
	    removeArg.pObject = pSrcDSName;
	    memcpy(&removeArg.CommArg, &commArg, sizeof(commArg));
	    removeArg.pResObj = pSrcResObj;

	    if ( LocalRemove(pTHS, &removeArg) ) {
		SetInheritSidError(mapApiErrorToWin32(pTHS, pTHS->errCode));
		__leave;
	    }

	    // Now operate on dst object.  There is no problem if things fail
	    // after this point although we've already deleted the src object
	    // as the entire transaction is only committed if we get to the
	    // end without errors.

	    // Position at dst object.

	    if ( DBFindDSName(pTHS->pDB, pDstDSName) ) {
		SetInheritSidError(ERROR_INVALID_PARAMETER);
		__leave;
	    }

	    // Create dst object RESOBJ which nets us class info.

	    if ( !(pDstResObj = CreateResObj(pTHS->pDB, pDstDSName)) ) {
		SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
		__leave;
	    }

	    // Is this a security principal?

	    mostBasicClass = SampDeriveMostBasicDsClass(
		pDstResObj->MostSpecificObjClass);

	    if (    (CLASS_USER != mostBasicClass)
		    && (CLASS_GROUP != mostBasicClass)
		    && (CLASS_COMPUTER != mostBasicClass) ) {
		SetInheritSidError(ERROR_INVALID_PARAMETER);
		__leave;
	    }

	    // Read various other destination object properties.
	    // Get everything in external form as we will write it back
	    // later via LocalModify which expects external form arguments.

	    if ( dwErr = DBGetMultipleAtts(pTHS->pDB, 3, rAC, NULL, NULL,
					   &cAttsDst, &rAttsDst,
					   DBGETMULTIPLEATTS_fEXTERNAL, 0) ) {
		SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
		__leave;
	    }

	    // See what we've got.

	    for ( i = 0; i < cAttsDst; i++ ) {
		switch ( rAttsDst[i].attrTyp ) {
		case ATT_OBJECT_SID:
		    pDstSid = &rAttsDst[i];
		    break;
		case ATT_SID_HISTORY:
		    pDstSidHistory = &rAttsDst[i];
		    break;
		case ATT_SAM_ACCOUNT_NAME:
		    pDstSamAcctName = &rAttsDst[i];
		    break;
		}
	    }

	    // It is a security principal, it better have a SID.  Also
	    // need SAM account name for logging.

	    if ( !pDstSid || !pDstSamAcctName ) {
		SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
		__leave;
	    }

	    // Disallow operations on well known SIDs.

	    SampSplitNT4SID((PNT4SID) pSrcSid->AttrVal.pAVal[0].pVal,
			    &domainSid, &srcRid);
	    SampSplitNT4SID((PNT4SID) pDstSid->AttrVal.pAVal[0].pVal,
			    &domainSid, &dstRid);

	    if (    (srcRid < SAMP_RESTRICTED_ACCOUNT_COUNT)
		    || (dstRid < SAMP_RESTRICTED_ACCOUNT_COUNT) ) {
		SetInheritSidError(ERROR_INVALID_PARAMETER);
		__leave;
	    }

	    // Src and dst may not be the same object.

	    if ( RtlEqualSid(pSrcSid->AttrVal.pAVal[0].pVal,
			     pDstSid->AttrVal.pAVal[0].pVal) ) {
		SetInheritSidError(ERROR_INVALID_PARAMETER);
		__leave;
	    }

	    // Everything checks out.  Now add src object's SID and SID
	    // history, if present, to dst object's SID history.  We
	    // need to filter out duplicate values in order to avoid
	    // ERROR_DS_ATT_VAL_ALREADY_EXISTS errors.

	    memset(&modifyArg, 0, sizeof(modifyArg));
	    modifyArg.pObject = pDstDSName;
	    modifyArg.count = 1;
	    modifyArg.FirstMod.choice = AT_CHOICE_ADD_VALUES;
	    memcpy(&modifyArg.CommArg, &commArg, sizeof(commArg));
	    modifyArg.pResObj = pDstResObj;

	    if ( dwErr = BuildDstObjATTRMODLIST(pTHS,
						pSrcSid, pSrcSidHistory,
						pDstSid, pDstSidHistory,
						&modifyArg) ) {
		SetInheritSidError(dwErr);
		__leave;
	    }

	    // Perform the write as fDSA as all checks have passed and
	    // ATT_SID_HISTORY is protected otherwise.

	    pTHS->fDSA = TRUE;
	    __try {
		LocalModify(pTHS, &modifyArg);
	    } __finally {
		pTHS->fDSA = FALSE;
	    }

	    if ( pTHS->errCode ) {
		SetInheritSidError(mapApiErrorToWin32(pTHS, pTHS->errCode));
		__leave;
	    }

	    // Set up for auditing.  Need null terminated version of
	    // destination object's SAM account name.

	    cb1 = pDstSamAcctName->AttrVal.pAVal[0].valLen + sizeof(WCHAR);
	    pwszSamAcctName = (WCHAR *) THAllocEx(pTHS, cb1);
	    memcpy(pwszSamAcctName,
		   pDstSamAcctName->AttrVal.pAVal[0].pVal,
		   pDstSamAcctName->AttrVal.pAVal[0].valLen);
	    pwszSamAcctName[(cb1 / sizeof(WCHAR)) - 1] = L'\0';

	    // Force local audit and fail entire operation if we can't do it.

	    if ( dwErr = ForceSuccessAuditOnDstObj(
		pmsgIn->V1.SrcPrincipal,
		pDstCR->NetbiosName,
		(PNT4SID) pSrcSid->AttrVal.pAVal[0].pVal,
		(PNT4SID) pDstSid->AttrVal.pAVal[0].pVal,
		pwszSamAcctName,
		pDstCR->NetbiosName) ) {
		SetInheritSidError(dwErr);
		__leave;
	    }

	    fCommit = TRUE;
	}
	__finally
	    {
	    if ( fDbOpen )
		{
		DBClose(pTHS->pDB, fCommit);
	    }
	}

	pmsgOut->V1.dwWin32Error = dwErr;

	// Miscellaneous cleanup.

	if ( rAttsSrc ) {
	    if ( pSrcSid ) {
		THFreeATTR(pTHS, pSrcSid, FALSE);
	    }
	    if ( pSrcSidHistory ) {
		THFreeATTR(pTHS, pSrcSidHistory, FALSE);
	    }
	    THFreeEx(pTHS, rAttsSrc);
	}

	if ( rAttsDst ) {
	    if ( pDstSid ) {
		THFreeATTR(pTHS, pDstSid, FALSE);
	    }
	    if ( pDstSidHistory ) {
		THFreeATTR(pTHS, pDstSidHistory, FALSE);
	    }
	    if ( pDstSamAcctName ) {
		THFreeATTR(pTHS, pDstSamAcctName, FALSE);
	    }
	    THFreeEx(pTHS, rAttsDst);
	}

	if ( pSrcDSName ) {
	    THFreeEx(pTHS, pSrcDSName);
	}

	if ( pDstDSName ) {
	    THFreeEx(pTHS, pDstDSName);
	}

	if ( pSrcResObj ) {
	    THFreeEx(pTHS, pSrcResObj);
	}

	if ( pDstResObj ) {
	    THFreeEx(pTHS, pDstResObj);
	}

	if ( pwszSamAcctName ) {
	    THFreeEx(pTHS, pwszSamAcctName);
	}
    }
    __except(HandleMostExceptions(xCode = GetExceptionCode()))
    {
	ret = DsaExceptionToWin32(xCode);
    }

    //  drsDereferenceContext( hDrs ); - this isn't a real rpc call, so we shouldn't
    //                                call this - IDL_DRSAddSidHistory does this
    //                                for us.

    // Log to Directory Service event log.  Log exception error if there
    // is one, operation error otherwise.
    if ( pTHS ) {
	LogEvent8(DS_EVENT_CAT_DIRECTORY_ACCESS,
		  ( !ret && !dwErr )
		  ? DS_EVENT_SEV_MINIMAL
		  : DS_EVENT_SEV_ALWAYS,
	    ( !ret && !dwErr )
	? DIRLOG_INHERIT_SECURITY_IDENTITY_SUCCEEDED
	    : DIRLOG_INHERIT_SECURITY_IDENTITY_FAILURE,
	    ( fLog )
	? szInsertWC(pmsgIn->V1.SrcPrincipal)
	: szInsertWC(L"?"),
		      ( !ret && !dwErr )
		  ? (( fLog )
		     ? szInsertWC(pmsgIn->V1.DstPrincipal)
		     : szInsertWC(L"?"))
		  : szInsertHex(dsid),
		szInsertInt(ret ? ret : dwErr),
		szInsertWin32Msg(ret ? ret : dwErr),
		NULL, NULL, NULL, NULL);
    }

    return(ret);
}

DWORD
BuildCheckAndUpdateArgs(
    THSTATE                     *pTHS,                      // in
    BOOL                        fSrcIsW2K,                  // in
    WCHAR                       *SrcDomainController,       // in
    WCHAR                       *SrcDomain,                 // in
    SEC_WINNT_AUTH_IDENTITY_W   *pAuthInfo,                 // in
    NT4SID                      *pSrcObjSid,                // in
    DWORD                       Flags,                      // in
    BOOL                        NeedImpersonation,          // in
    DWORD                       *pcNames,                   // out
    WCHAR                       ***prpNames,                // out
    ATTR                        **ppSrcSid,                 // out
    ATTR                        **ppSrcSidHistory,          // out
    DWORD                       *pDsid,                     // out
    BOOL                        *pImpersonating             // out
    )
/*++

  Description:

    This routine constructs the arguments required for SID verification
    and local database modification.  It additionally reads the source
    object's ATT_SID_HISTORY if the source is W2K or better.

    The ATT_SID_HISTORY is read using LDAP as opposed to IDL_DRSVerifyNames
    over RPC.  This is because we may not have trust with the source domain
    and the DRS binding handle cache mechanism does not support per-handle
    credentials outside the install-time scenario.

    All OUT parameters are THAlloc'd and thus need to be THFree'd by caller.

  Arguments:

    pTHS - Valid THSTATE pointer.

    fSrcIsW2K - Indicates whether SrcDomainController is W2K or better and
        thus ATT_SID_HISTORY should be obtained via LDAP.

    SrcDomainController - DNS Name of domain controller to which the LDAP
        connection is to be made.  This should be identical to what the
        caller used for the SamConnectWithCreds call. It must be the
        dns name for LDAP_OPT_SIGN to work. Ignored if src is NT4.

    SrcDomain - DNS Name of domain to which the LDAP connection is
        to be made. It must be the dns name for LDAP_OPT_SIGN to work.
        Ignored if src is NT4.

    pAuthInfo - Explicit credentials to use for authentication.

    pSrcObjSid - Source object's ATT_OBJECT_SID, i.e. primary SID.

    Flags - From client call

    NeedImpersonation - TRUE if need to impersonate client

    pcNames - Receives count of SIDs in prpNames.

    prpNames - Receives array of string-ized SIDs which can subsequently
        be handed directly to DsCrackNames.  This array minimally includes
        the source object's ATT_OBJECT_SID and additionally includes all
        values from the source object's ATT_SID_HSITORY, if any exist.

    ppSrcSid - Receives ATTR representing the source object's ATT_OBJECT_SID.

    ppSrcSidHistory - Receives ATTR representing the source object's
        ATT_SID_HISTORY if it exists, NULL otherwise.

    pDsid - Receives DSID of failing line on error, zero otherwise.

    pImpersonating - Set to TRUE if impersonation is active

  Return Value:

    Win32 error code.

--*/
{
    LDAP            *hLdap = NULL;
    DWORD           ret = ERROR_SUCCESS;
    DWORD           i, dwErr;
    NTSTATUS        status;
    ULONG           ver = LDAP_VERSION3;
    ULONG           on = PtrToUlong(LDAP_OPT_ON);
    UNICODE_STRING  uniStr = { 0, 0, NULL };
    WCHAR           *pSearchBase = NULL;
    WCHAR           *pTmp;
    WCHAR           *attrs[2] = { L"sidHistory", NULL };
    PLDAPMessage    ldapMsg = NULL;
    PLDAPMessage    ldapEntry = NULL;
    PLDAP_BERVAL    *ldapBVals = NULL;
    ULONG           cVals = 0;
    DWORD           cBytes;
    UCHAR           uc0, uc1;

    *pcNames = 0;
    *prpNames = NULL;
    *ppSrcSid = NULL;
    *ppSrcSidHistory = NULL;
    *pDsid = 0;

#define SetReadSidHistoryError(err)                 \
        ret = err;                                  \
        *pDsid = (FILENO << 16) | __LINE__;

    __try {

        if ( fSrcIsW2K ) {
            // Source is W2K or better and thus might have a SID history.

            // Fail if a secure ldap port could not be opened
            if (    !(hLdap = ldap_initW(SrcDomainController, LDAP_PORT))
                 || (dwErr = ldap_set_option(hLdap, LDAP_OPT_VERSION, &ver))
                 || (dwErr = ldap_set_option(hLdap, LDAP_OPT_SIGN, &on))
                 || (dwErr = ldap_set_option(hLdap, LDAP_OPT_AREC_EXCLUSIVE, &on))
                 || (dwErr = ldap_set_optionW(hLdap, LDAP_OPT_DNSDOMAIN_NAME, &SrcDomain)) ) {
                SetReadSidHistoryError(ERROR_DS_UNAVAILABLE);
                __leave;
            }

            // No creds; impersonate caller
            if (NeedImpersonation) {
                // clear client context on the thread state since we are going to change context
                AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
                if (dwErr = RpcImpersonateClient(NULL)) {
                    SetReadSidHistoryError(dwErr);
                    __leave;
                }
                *pImpersonating = TRUE;
            }

            // Authenticate using explicit credentials.
            if ( dwErr = ldap_bind_sW(hLdap, NULL,
                                      (NeedImpersonation) ? NULL : (PWCHAR) pAuthInfo,
                                      LDAP_AUTH_NEGOTIATE) ) {
                DPRINT1(0, "ldap_bind_sW() %08x\n", dwErr);
                SetReadSidHistoryError(ERROR_DS_INAPPROPRIATE_AUTH);
                __leave;
            }
            // stop impersonation
            if (*pImpersonating) {
                *pImpersonating = FALSE;
                RpcRevertToSelf();
            }

            // Construct <SID=xxx> value which we will use as search base
            // for reading ATT_SID_HISTORY.

            cBytes = RtlLengthSid(pSrcObjSid);
            pSearchBase = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) *
                                (   wcslen(L"<SID=>")   // key words, etc.
                                  + 1                   // null terminator
                                  + (2 * cBytes) ) );   // 2 hex chars per byte
            if ( !pSearchBase ) {
                SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }

            wcscpy(pSearchBase, L"<SID=");
            pTmp = pSearchBase + 5;
            for ( i = 0; i < cBytes; i++ ) {
                uc0 = ((PUCHAR) pSrcObjSid)[i] & 0x0f;
                uc1 = (((PUCHAR) pSrcObjSid)[i] >> 4) & 0x0f;
                *pTmp++ = ((uc1 < 0xa) ? L'0' + uc1 : L'A' + (uc1 - 0xa));
                *pTmp++ = ((uc0 < 0xa) ? L'0' + uc0 : L'A' + (uc0 - 0xa));
            }
            *pTmp = L'>';

            // Read ATT_SID_HISTORY off the source object.

            if ( dwErr = ldap_search_ext_sW(hLdap, pSearchBase,
                                            LDAP_SCOPE_BASE, L"objectClass=*",
                                            attrs, 0, NULL, NULL,
                                            NULL, 10000, &ldapMsg) ) {
                SetReadSidHistoryError(LdapMapErrorToWin32(dwErr));
                __leave;
            }

            if ( ldapEntry = ldap_first_entry(hLdap, ldapMsg) ) {
                if ( ldapBVals = ldap_get_values_lenW(hLdap, ldapMsg,
                                                      attrs[0]) ) {
                    cVals = ldap_count_values_len(ldapBVals);
                }
            }
        }

        // cVals now holds the count of values in the source object's
        // ATT_SID_HISTORY and the values are in ldapBVals[i].bv_val.
        // Our caller verified that the RPC client was an admin in the
        // source domain.  Thus we assume that if no values were returned
        // it is not due to insufficient rights.  This is not a totally
        // safe assumption of course, but the best we can do.

        // Construct the out args.  The total number of SIDs is (cVals+1)
        // where the +1 is for the original ATT_OBJECT_SID.
        // Do prpNames first.

        *prpNames = (PWCHAR *) THAllocEx(pTHS, sizeof(PWCHAR) * (cVals+1));
        if ( !*prpNames ) {
            SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }

        // Put ATT_OBJECT_SID in first slot.

        status = RtlConvertSidToUnicodeString(&uniStr, pSrcObjSid, TRUE);

        if ( !NT_SUCCESS(status) ) {
            SetReadSidHistoryError(RtlNtStatusToDosError(status));
            __leave;
        }

        cBytes = sizeof(WCHAR) * (wcslen(uniStr.Buffer) + 1);
        (*prpNames)[0] = (PWCHAR) THAllocEx(pTHS, cBytes);
        if ( !(*prpNames)[0] ) {
            SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }
        memcpy((*prpNames)[0], uniStr.Buffer, cBytes);
        *pcNames += 1;

        // Put ATT_SID_HISTORY in subsequent slots.

        for ( i = 0; i < cVals; i++ ) {
            // Convert ith SID in SID history to string for name cracking.
            if ( uniStr.Buffer ) {
                RtlFreeHeap(RtlProcessHeap(), 0, uniStr.Buffer);
                uniStr.Buffer = NULL;
            }
            status = RtlConvertSidToUnicodeString(&uniStr,
                                                  ldapBVals[i]->bv_val, TRUE);

            if ( !NT_SUCCESS(status) ) {
                SetReadSidHistoryError(RtlNtStatusToDosError(status));
                __leave;
            }

            cBytes = sizeof(WCHAR) * (wcslen(uniStr.Buffer) + 1);
            (*prpNames)[i+1] = (PWCHAR) THAllocEx(pTHS, cBytes);
            if ( !(*prpNames)[i+1] ) {
                SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }
            memcpy((*prpNames)[i+1], uniStr.Buffer, cBytes);
            *pcNames += 1;
        }

        // Make ppSrcSid.

        *ppSrcSid = (ATTR *) THAllocEx(pTHS, sizeof(ATTR));
        if ( !(*ppSrcSid) ) {
            SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }

        (*ppSrcSid)->attrTyp = ATT_OBJECT_SID;
        (*ppSrcSid)->AttrVal.pAVal = (ATTRVAL *) THAllocEx(
                                                    pTHS, sizeof(ATTRVAL));
        if ( !(*ppSrcSid)->AttrVal.pAVal ) {
            SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }
        (*ppSrcSid)->AttrVal.valCount = 1;

        cBytes = RtlLengthSid(pSrcObjSid);
        (*ppSrcSid)->AttrVal.pAVal[0].pVal = (UCHAR *) THAllocEx(pTHS, cBytes);
        if ( !(*ppSrcSid)->AttrVal.pAVal[0].pVal ) {
            SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }
        (*ppSrcSid)->AttrVal.pAVal[0].valLen = cBytes;
        memcpy((*ppSrcSid)->AttrVal.pAVal[0].pVal, pSrcObjSid, cBytes);

        // Make ppSrcSidHistory.

        if ( cVals ) {
            *ppSrcSidHistory = (ATTR *) THAllocEx(pTHS, sizeof(ATTR));
            if ( !(*ppSrcSidHistory) ) {
                SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }

            (*ppSrcSidHistory)->attrTyp = ATT_SID_HISTORY;
            (*ppSrcSidHistory)->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS,
                                                    cVals * sizeof(ATTRVAL));
            if ( !(*ppSrcSidHistory)->AttrVal.pAVal ) {
                SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }
            (*ppSrcSidHistory)->AttrVal.valCount = cVals;

            for ( i = 0; i < cVals; i++ ) {
                cBytes = RtlLengthSid(ldapBVals[i]->bv_val);
                (*ppSrcSidHistory)->AttrVal.pAVal[i].pVal =
                                            (UCHAR *) THAllocEx(pTHS, cBytes);
                if ( !(*ppSrcSidHistory)->AttrVal.pAVal[i].pVal ) {
                    SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
                    __leave;
                }
                (*ppSrcSidHistory)->AttrVal.pAVal[i].valLen = cBytes;
                memcpy((*ppSrcSidHistory)->AttrVal.pAVal[i].pVal,
                       ldapBVals[i]->bv_val, cBytes);
            }
        }

        Assert(!ret);
    } __finally {

        if ( hLdap ) {
            ldap_unbind(hLdap);
        }

        if ( uniStr.Buffer ) {
            RtlFreeHeap(RtlProcessHeap(), 0, uniStr.Buffer);
        }

        if ( pSearchBase ) {
            THFreeEx(pTHS, pSearchBase);
        }

        if ( ldapBVals ) {
            ldap_value_free_len(ldapBVals);
        }

        if ( ldapMsg ) {
            ldap_msgfree(ldapMsg);
        }

        // Clean up out args on error.
        if ( ret ) {
            if ( *prpNames ) {
                for ( i = 0; i < *pcNames; i++ ) {
                    if ( (*prpNames)[i] ) {
                        THFreeEx(pTHS, (*prpNames)[i]);
                    }
                }
                THFreeEx(pTHS, (*prpNames));
            }
            THFreeATTR(pTHS, *ppSrcSid, TRUE);
            THFreeATTR(pTHS, *ppSrcSidHistory, TRUE);
            *pcNames = 0;
            *prpNames = NULL;
            *ppSrcSid = NULL;
            *ppSrcSidHistory = NULL;
        }
    }

    return(ret);
}

DWORD
VerifySrcAuditingEnabledAndGetFlatName(
    IN  UNICODE_STRING  *usSrcDC,
    OUT WCHAR           **pSrcDomainFlatName,
    OUT DWORD           *pdsid
    )
/*++

  Description:

    Verify auditing is enabled at the Src DC and fetch the SrcDomain's
    NetBIOS name (flat name) using the same LsaQuery API.

    CALLER IS RESPONSIBLE FOR IMPERSONATION!

    Since a domain admin on the SrcDc can surely query audit info
    an access denied must be caused by an outstanding NetUseAdd()
    by some code running as LocalSystem (or as the domain admin?).
    The LsaOpenPolicy() is using the cached creds from that NetUseAdd()
    instead of the creds from the impersonation. Map the error
    to something that may help the user diagnose the problem.

  Arguments:

    usSrcDC - name of Src DC
    pdsid   - Inform caller of line number of failure

  Return Value:

    WIN32 return code.

--*/
{
    THSTATE                     *pTHS = pTHStls;
    DWORD                       dwErr;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           policy;
    WCHAR                       *FlatName;
    HANDLE                      hPolicy = INVALID_HANDLE_VALUE;
    POLICY_AUDIT_EVENTS_INFO    *pPolicy = NULL;
    POLICY_PRIMARY_DOMAIN_INFO  *pDomain = NULL;

    // Since we have IN args which were THAlloc'd we should have a THSTATE.
    Assert(pTHS);

    // initialize return value
    *pSrcDomainFlatName = NULL;

    // Open the remote LSA
    InitializeObjectAttributes(&policy,
                               NULL,             // Name
                               0,                // Attributes
                               NULL,             // Root
                               NULL);            // Security Descriptor

   // WARNING: when using NULL creds, the previous call to
   // SamConnectWithCreds sets up the kerberos ticket cache so that
   // this call to LsaOpenPolicy picks up that ticket and goes across
   // the wire to the SrcDc w/appropriate creds. Otherwise, this call
   // goes across the wire as ANONYMOUS and fails with access denied (error 5)
    status = LsaOpenPolicy(usSrcDC,
                           &policy,
                             POLICY_VIEW_AUDIT_INFORMATION
                           | POLICY_VIEW_LOCAL_INFORMATION,
                           &hPolicy);
    if (!NT_SUCCESS(status)) {
        // Since a domain admin on the SrcDc can surely query audit info
        // this access denied must be caused by an outstanding NetUseAdd()
        // by some code running as LocalSystem (or as the domain admin?).
        // The LsaOpenPolicy() is using the cached creds from that NetUseAdd()
        // instead of the creds from the impersonation. Map the error
        // to something that may help the user diagnose the problem.
        dwErr = RtlNtStatusToDosError(status);
        SetDsid(pdsid);
        // 390672 - Security guys have suggested that I not map this error
        // if (dwErr == ERROR_ACCESS_DENIED) {
            // dwErr = ERROR_SESSION_CREDENTIAL_CONFLICT;
        // }
        goto cleanup;
    }

    // Fetch the auditing info from the src server
    status = LsaQueryInformationPolicy(hPolicy,
                                       PolicyAuditEventsInformation,
                                       &pPolicy);
    if (!NT_SUCCESS(status)) {
        dwErr = RtlNtStatusToDosError(status);
        SetDsid(pdsid);
        goto cleanup;
    }

    // Verify auditing is enabled
    if ( pPolicy->AuditingMode
            &&
         (pPolicy->EventAuditingOptions[AuditCategoryAccountManagement]
                                           & POLICY_AUDIT_EVENT_SUCCESS)
            &&
        (pPolicy->EventAuditingOptions[AuditCategoryAccountManagement]
                                          & POLICY_AUDIT_EVENT_FAILURE) ) {
        dwErr = ERROR_SUCCESS;
    } else {
        dwErr = ERROR_DS_SOURCE_AUDITING_NOT_ENABLED;
        SetDsid(pdsid);
        goto cleanup;
    }

    // Fetch the domain info from the src server
    status = LsaQueryInformationPolicy(hPolicy,
                                       PolicyPrimaryDomainInformation,
                                       &pDomain);
    if (!NT_SUCCESS(status)) {
        dwErr = RtlNtStatusToDosError(status);
        SetDsid(pdsid);
        goto cleanup;
    }
    Assert(pDomain->Name.Length && pDomain->Name.Buffer);

    // Create the name SrcDomainFlatName$$$
    FlatName = THAllocEx(pTHS,
                         pDomain->Name.Length +
                         ((wcslen(L"$$$") + 1) * sizeof(WCHAR)));
    memcpy(FlatName, pDomain->Name.Buffer, pDomain->Name.Length);
    *(FlatName + (pDomain->Name.Length / sizeof(WCHAR))) = L'\0';
    wcscat(FlatName, L"$$$");
    *pSrcDomainFlatName = FlatName;

    // SUCCESS
    dwErr = ERROR_SUCCESS;

cleanup:
    // close policy
    if (hPolicy && hPolicy != INVALID_HANDLE_VALUE) {
        status = LsaClose(hPolicy);
        if (!NT_SUCCESS(status) && ERROR_SUCCESS == dwErr) {
            dwErr = RtlNtStatusToDosError(status);
            SetDsid(pdsid);
        }
    }
    if (pPolicy) {
        LsaFreeMemory(pPolicy);
    }
    if (pDomain) {
        LsaFreeMemory(pDomain);
    }

    return(dwErr);
}

DWORD
VerifySrcIsSP4OrGreater(
    IN  BOOL    fSrcIsW2K,
    IN  PWCHAR  SrcDc,
    OUT DWORD   *pdsid
    )
/*++

  Description:

    Verify SrcDomain is SP4 or greater.
    CALLER IS RESPONSIBLE FOR IMPERSONATION!

  Arguments:

    fSrcIsW2K - SrcDc is NT5?
    SrcDC     - name of Src DC (not UNICODE_STRING)
    pdsid     - Inform caller of line number of failure

  Return Value:

    WIN32 return code.

--*/
{
    THSTATE *pTHS = pTHStls;
    DWORD   dwErr;
    WCHAR   *pwszCSDVersion = NULL;
    HKEY    hRemoteKey = 0;
    HKEY    hVersionKey = 0;
    PWCHAR  CSDVersion;
    BOOL    CSDVersionOk;
    DWORD   ValType;
    DWORD   ValLen;

    // NT5; definitely SP4 or greater
    if (fSrcIsW2K) {
        dwErr = 0;
        goto cleanup;
    }

    // Is the NT4 computer at least Service Pack 4?

    // connect to the SrcDc
    if (dwErr = RegConnectRegistryW(SrcDc,
                                    HKEY_LOCAL_MACHINE,
                                    &hRemoteKey)) {
        SetDsid(pdsid);
        goto cleanup;
    }
    if (dwErr = RegOpenKeyExW(hRemoteKey,
                              L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",
                              0,
                              KEY_QUERY_VALUE,
                              &hVersionKey)) {
        SetDsid(pdsid);
        goto cleanup;
    }
    // Get the length of the service pack version
    ValLen = 0;
    if (dwErr = RegQueryValueExW(hVersionKey,
                                 L"CSDVersion",
                                 NULL,
                                 &ValType,
                                 NULL,
                                 &ValLen)) {
        SetDsid(pdsid);
        goto cleanup;
    }
    // Get the service pack version
    CSDVersionOk = FALSE;
    if (ValLen) {
        pwszCSDVersion = THAllocEx(pTHS, ValLen);
        if (dwErr = RegQueryValueExW(hVersionKey,
                                     L"CSDVersion",
                                     NULL,
                                     &ValType,
                                     (PCHAR)pwszCSDVersion,
                                     &ValLen)) {
            SetDsid(pdsid);
            goto cleanup;
        }
        if (ValType == REG_SZ && ValLen) {
            // Check for not Service Pack 0, 1, 2, and 3 (hence >= SP4)
            CSDVersionOk = (   _wcsicmp(pwszCSDVersion, L"Service Pack 0")
                            && _wcsicmp(pwszCSDVersion, L"Service Pack 1")
                            && _wcsicmp(pwszCSDVersion, L"Service Pack 2")
                            && _wcsicmp(pwszCSDVersion, L"Service Pack 3"));
        }
    }
    if (!CSDVersionOk) {
        dwErr = ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER;
        SetDsid(pdsid);
        goto cleanup;
    }

cleanup:
    // This error code is more useful than the generic errors 
    // returned by the individual functions. A developer then
    // uses the DSID in the eventlog to identify which function
    // actually failed.
    if (dwErr) {
        dwErr = ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER;
    }

    if (pwszCSDVersion) {
        THFreeEx(pTHS, pwszCSDVersion);
    }
    if (hRemoteKey) {
        RegCloseKey(hRemoteKey);
    }
    if (hVersionKey) {
        RegCloseKey(hVersionKey);
    }

    return(dwErr);
}

DWORD
VerifyIsPDC(
    IN  PWCHAR  DC,
    OUT DWORD   *pdsid
    )
/*++

  Description:

    Verify DC is a PDC
    CALLER IS RESPONSIBLE FOR IMPERSONATION!

  Arguments:

    DC - name of DC (not UNICODE_STRING)
    pdsid - Inform caller of line number of failure

  Return Value:

    WIN32 return code.

--*/
{
    DWORD              dwErr;
    USER_MODALS_INFO_1 *Role;

    // Get DC's role (good for both NT4 and NT5 DCs)
    if (dwErr = NetUserModalsGet(DC,
                                 1,
                                 (PUCHAR *)&Role) ) {

        // NetUserModalsGet returns mixed mode error codes; yuk!
        if (dwErr == NERR_InvalidComputer) {
            dwErr = ERROR_INVALID_COMPUTERNAME;
        }
        SetDsid(pdsid);
        return (dwErr);
    }

    // PREFIX: claims Role may be NULL.
    if (NULL == Role) {
        SetDsid(pdsid);
        return (ERROR_INVALID_DOMAIN_ROLE);
    }

    // Must be PDC
    if (Role->usrmod1_role != UAS_ROLE_PRIMARY) {
        dwErr = ERROR_INVALID_DOMAIN_ROLE;
        SetDsid(pdsid);
    }
    NetApiBufferFree(Role);
    return (dwErr);
}

DWORD
ForceAuditOnSrcObj(
    IN  WCHAR   *SrcDc,
    IN  NT4SID  *pSrcObjSid,
    IN  WCHAR   *pSrcDomainFlatName,
    OUT DWORD   *pdsid
    )
/*++

  Description:

    Force audit on src dc by adding the src object's sid to the
    SrcDomainFlatName$$$ group on the SrcDc and then deleting it.

    This has the added benefit of requiring the src admin
    to create the SrcDomainFlatName$$$ group before Addsid will
    steal sids from the SrcDomain. And it leaves a much more
    obvious audit trail.

    CALLER IS RESPONSIBLE FOR IMPERSONATION!

  Arguments:

    SrcDc              - src dc
    pSrcObjSid         - Object sid of src object (sid being stolen)
    pSrcDomainFlatName - NetBIOS name of src domain
    pdsid              - Inform caller of line number of failure

  Return Value:

    WIN32 return code.

--*/
{
    DWORD                       dwErr;
    LOCALGROUP_MEMBERS_INFO_0   Members;

    // Add src object sid to SrcDomainFlatName$$$ group on SrcDc
    memset(&Members, 0, sizeof(Members));
    Members.lgrmi0_sid = pSrcObjSid;
    if (dwErr = NetLocalGroupAddMembers(SrcDc,
                                        pSrcDomainFlatName,
                                        0,
                                        (PUCHAR)&Members,
                                        1) ) {
        SetDsid(pdsid);
        // NetLocalGroupAddMembers returns mixed mode error codes; yuk!
        if (dwErr == NERR_GroupNotFound) {
            dwErr = ERROR_NO_SUCH_ALIAS;
        }

        // These errors occur when attempting to add a Local Group
        // to SrcDomainFlatName$$$ when SrcDc is NT4 or NT5 in Mixed
        // Mode. Ignore since it is safe to clone the sids of
        // local groups without auditing.
        if (   dwErr == ERROR_INVALID_MEMBER
            || dwErr == ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN ) {
            dwErr = ERROR_SUCCESS;
        }
        return (dwErr);
    }

    // Del src object sid from SrcDomainFlatName$$$ group on SrcDc
    if (dwErr = NetLocalGroupDelMembers(SrcDc,
                                        pSrcDomainFlatName,
                                        0,
                                        (PUCHAR)&Members,
                                        1) ) {
        SetDsid(pdsid);
        // NetLocalGroupDelMembers returns mixed mode error codes; yuk!
        if (dwErr == NERR_GroupNotFound) {
            dwErr = ERROR_NO_SUCH_ALIAS;
        }
    }

    return(dwErr);
}

DWORD
ImpersonateSrcAdmin(
    IN  SEC_WINNT_AUTH_IDENTITY_W   *pauthInfo,
    IN  BOOL                        NeedImpersonation,
    OUT DWORD                       *pdsid,
    OUT BOOL                        *pImpersonating,
    OUT HANDLE                      *phToken
    )
/*++

  Description:

    Impersonate implicit or explicit Src creds.
    Call UnimpersonateSrcAdmin to undo.

  Arguments:

    pauthInfo         - Contains counted strings for dom, user, and password
    NeedImpersonation - Set to TRUE if client impersonation is needed
    pdsid             - Inform caller of line number of failure
    pImpersonating    - Set to TRUE if client impersonation is still active
    phToken           - pointer to HANDLE for logon/impersonation token

  Return Value:

    WIN32 return code.

--*/
{
    THSTATE *pTHS = pTHStls;
    DWORD   dwErr;
    WCHAR   *pwszSrcUser = NULL;
    WCHAR   *pwszSrcDomain = NULL;
    WCHAR   *pwszSrcPassword = NULL;
    HANDLE  hToken = INVALID_HANDLE_VALUE;

    // Since we have IN args which were THAlloc'd we should have a THSTATE.
    Assert(pTHS);

    // Not impersonating anyone at the moment
    *phToken = INVALID_HANDLE_VALUE;

    // No creds; impersonate caller
    if (NeedImpersonation) {
        // clear client context on the thread state since we are going to change context
        AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
        dwErr = RpcImpersonateClient(NULL);
        if (dwErr) {
            SetDsid(pdsid);
        } else {
            *pImpersonating = TRUE;
        }
        goto cleanup;
    }

    // Explicit creds; impersonate logon user

    // Convert the counted strings into null-terminated strings

    // User
    if (pauthInfo->UserLength) {
        pwszSrcUser = THAllocEx(pTHS,
                                (pauthInfo->UserLength + 1) * sizeof(WCHAR));
        memcpy(pwszSrcUser, pauthInfo->User, pauthInfo->UserLength * sizeof(WCHAR));
        pwszSrcUser[pauthInfo->UserLength] = L'\0';
    }
    // Domain
    if (pauthInfo->DomainLength) {
        pwszSrcDomain = THAllocEx(pTHS,
                                (pauthInfo->DomainLength + 1) * sizeof(WCHAR));
        memcpy(pwszSrcDomain, pauthInfo->Domain, pauthInfo->DomainLength * sizeof(WCHAR));
        pwszSrcDomain[pauthInfo->DomainLength] = L'\0';
    }
    // Password
    if (pauthInfo->PasswordLength) {
        pwszSrcPassword = THAllocEx(pTHS,
                                (pauthInfo->PasswordLength + 1) * sizeof(WCHAR));
        memcpy(pwszSrcPassword, pauthInfo->Password, pauthInfo->PasswordLength * sizeof(WCHAR));
        pwszSrcPassword[pauthInfo->PasswordLength] = L'\0';
    }

    // Establish credentials for later calls (eg, LsaOpenPolicy())
    if (!LogonUserW(pwszSrcUser,
                    pwszSrcDomain,
                    pwszSrcPassword,
                    LOGON32_LOGON_NEW_CREDENTIALS,
                    LOGON32_PROVIDER_WINNT50,
                    &hToken)) {
        dwErr = GetLastError();
        SetDsid(pdsid);
        goto cleanup;
    }
    // clear client context on the thread state since we are going to change context
    AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
    if (!ImpersonateLoggedOnUser(hToken)) {
        dwErr = GetLastError();
        SetDsid(pdsid);
        goto cleanup;
    }

    // SUCCESSFUL IMPERSONATION
    dwErr = ERROR_SUCCESS;
    *phToken = hToken;
    hToken = INVALID_HANDLE_VALUE;

cleanup:
    // free the null-terminated strings
    if (pwszSrcUser) {
        THFreeEx(pTHS, pwszSrcUser);
    }
    if (pwszSrcDomain) {
        THFreeEx(pTHS, pwszSrcDomain);
    }
    if (pwszSrcPassword) {
        THFreeEx(pTHS, pwszSrcPassword);
    }
    if (hToken && hToken != INVALID_HANDLE_VALUE) {
        CloseHandle(hToken);
    }
    return(dwErr);
}

DWORD
UnimpersonateSrcAdmin(
    IN  BOOL        NeedImpersonation,
    OUT DWORD       *pdsid,
    IN OUT BOOL     *pImpersonating,
    IN OUT HANDLE   *phToken
    )
/*++

  Description:

    Stop impersonation

  Arguments:

    NeedImpersonation - Set to TRUE if client impersonation is needed
    pdsid             - Inform caller of line number of failure
    pImpersonating    - Set to TRUE if client impersonation is still active
    phToken           - impersonation/logon handle

  Return Value:

    WIN32 return code.

--*/
{
    DWORD   dwErr = 0;

    // stop impersonation (NULL creds)
    if (*pImpersonating) {
        *pImpersonating = FALSE;
        if (dwErr = RpcRevertToSelf()) {
            SetDsid(pdsid);
        }
    }

    // stop impersonation (explicit creds)
    if (*phToken && *phToken != INVALID_HANDLE_VALUE) {
        if (!RevertToSelf()) {
            dwErr = GetLastError();
            SetDsid(pdsid);
        }
        if (!CloseHandle(*phToken)) {
            if (!dwErr) {
                dwErr = GetLastError();
                SetDsid(pdsid);
            }
        } else {
            *phToken = INVALID_HANDLE_VALUE;
        }
    }
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drachkpt.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drachkpt.c
//
//--------------------------------------------------------------------------

/*++

    This File Contains Services Pertaining to taking checkpoints, to support
    downlevel replication. Checkpoints are taken to prevent Full syncs with
    NT4 domain controllers, upon a role transfer. For more details please read
    the theory of operation

    Author

        Murlis

    Revision History

        10/13/97 Created

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dstrace.h"

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"


#include   "debug.h"                    /* standard debugging header */
#define DEBSUB     "DRASERV:"           /* define the subsystem for debugging */


#include <ntrtl.h>
#include <ntseapi.h>
#include <ntsam.h>

#include "dsaapi.h"
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "draasync.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "mappings.h"
#include "samsrvp.h"
#include "drarpc.h"
#include <nlwrap.h>                     /* I_NetLogon* wrappers */

#include <fileno.h>
#define  FILENO FILENO_DRACHKPT


#define DRACHKPT_SUCCESS_RETRY_INTERVAL 3600
#define DRACHKPT_FAILURE_RETRY_INTERVAL  (4*3600)
#define MAX_CHANGELOG_BUFFER_SIZE 16384
#define NUM_CHKPT_RETRIES 5

ULONG
NtStatusToDraError(NTSTATUS NtStatus);




/*--------------------------------------------------------------------------------------------

                                THEORY OF OPERATION


        NT4 Incremental Replication Protocol ( netlogon replication protocol )
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        The netlogon replication protocol, defines an incremental
    replication scheme based on a change log. The change log is a sequence of change entries,
    each entry consisting of a unique monotonically increasing sequence number ( the serial
    number ) and information that describes the change. An NT4 BDC remembers the highest sequence
    number that it has seen, and replicates in changes and change log entries having a sequence
        number higher than the highest sequence number that it has seen.



        Role Transfer in NT4
        ~~~~~~~~~~~~~~~~~~~~~

         Upon a role transfer in a NT4 system, all the NT4 BDC's will start replicating with the
        new PDC. The new PDC has a change log nearly identical to the old PDC. I use the term, nearly,
    because the new PDC, sees the same order of changes as the old one, but It may lag behind the
    old PDC. Freshly made changes on the new PDC, are distinguished from changes made on the old PDC,
        by means of a promotion count ---- A constant large offset is added to the sequence number after
        a promotion. An NT4 BDC that is at a sequence number greater, than the highest sequence number
        at the new PDC during the time of promotion knows to undo all the changes such that it is at the
        same state as the new PDC at promotion time  and sync afresh to the changes on to the new PDC.

        Mixed Mode Operation of NT4 and NT5 Controllers
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        In a mixed domain environment, NT5 Domain controllers replicate amongst themselves using
        the DS replication protocol, while the NT5 PDC replicates to NT4 Domain controllers using
        the netlogon replication protocol. With no further work, a full sync on role transfer needs to
        be forced. This is because a change log maintained on a NT5 BDC is not guarenteed to contain
        changes in the same order, as the change log in the PDC. This can potentially confuse an NT4
        BDC.

        Full Sync avoidance through checkpointing
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        The requirement for non NT4 BDC full sync role transfer is that the new PDC has a change log
        that is "substantially similar" to the change log on the original PDC. The term substantially
        similar means that the 2 change log's have the same ordering of changes but the change log on
        the new PDC is not completely upto date. This change log is maintained through a periodic
        checkpointing scheme. The term checkpointing means "transfer of change log from PDC to BDC
        taking checkpoint after ensuring that the BDC taking the checkpoint has all the changes described in the
        change log, and contains no changes not described in the change log".  The basic checkpoint
        algorithm can be described as

                1. Synchronize with PDC
                2. Make PDC synchronize to you
                3. Grab the change log

                For a successful checkpoint no external modifications should occur to the database
        during steps 1, 2 and 3.

        After taking a checkpoint the BDC sets its state such that it continues building the change log
        locally with the locally made changes having a sequence number offset by a promotion increment.
        This is best illustrated by an example


        Assume that changes A, B and C are made on the PDC. The PDC has a change log like

        1. A
        2. B
        3. C
        where 1. 2. and 3. are the respective sequence numbers

        Immediately after taking a checkpoint, an NT5 BDC will have a change log like

        1. A
        2. B
        3. C

        Suppose now change D is made on the PDC and change E is made on the NT5 BDC. The PDC
        change log will be

        1. A
        2. B
        3. C
        4. D
        5. E

        The NT5 BDC change log will look like

        1. A
        2. B
        3. C
        1004. E
        1005. D

        Where 1000 is the promotion increment. If the NT5 BDC is promoted to be PDC, then to an NT4
        BDC it will appear as if the new PDC had been in sync only upto change C ( serial no 3),
        at the time of  promotion and then changes E and D have been freshly made on it. It will
        therefore undo changes D and E ( described by seria numbers 4 and 5 ) and then apply changes
        E and D (serial numbers 1004 and 1005 ).


        Best Effort checkpointing
        ~~~~~~~~~~~~~~~~~~~~~~~~~~

        Gurarenteed checkpointing implies that the 3 steps to successful checkpointing be performed
        with the database locked against external modifications. This guarentees the fact that a
        successful checkpoint will be taken whenever attempted subject to machine availability
        constraints. Locking the database while doing network operations opens up windows for deadlock,
        or possible long periods where the DC may not be available for modifications.

        Best Effort checkpointing on the other hand does not lock the database, but rather has a
        mechanism to detect whether external modifications took place while executing the steps for taking
        a checkpoint. If modifications took place, the algorithm will retry the process. After a certain
        number of retries, if still the checkpoint cannot be taken, the operation is described as a
        failure, and the check point taking is rescheduled for a later time. Best effort checkpointing
        recognizes the fact that the probability of modifications is small, therefore the probability
        of taking a checkpoint with the database unlocked is high.

----------------------------------------------------------------------------------------------------*/


NTSTATUS
DraReadNT4ChangeLog(
    IN OUT PVOID * Restart,
    IN OUT PULONG  RestartLength,
    IN ULONG   PreferredMaximumLength,
    OUT PULONG   SizeOfChanges,
    OUT PVOID  * Buffer
    )
/*++

    This function reads the netlogon changelog by calling the appropriate
    netlogon API. All memory allocation issues are taken care of in this
    function. Netlogon uses the process heap, while DS uses a thread heap.
    If necessary reallocations are done, so that consisted usage of the thread
    heap is the only model that is exposed to the callers of this routine

    Paramters

        Restart  IN/OUT parameter, that takes in a restart to be passed to
                  netlogon, and compute a new restart after the call is completed

        RestartLength IN/OUT parameter specifying the length of the restart
                      structure

        PreferredMaximumLength -- The maximum length of that data that can be
                     retrieved in a single shot.

        SizeofChanges   -- The size of the change buffer is returned in here

        Buffer          -- The actual buffer is returned in here
--*/
{
    ULONG OldRestartLength = *RestartLength;
    PVOID NetlogonRestart = NULL;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    THSTATE *pTHS = pTHStls;



    //
    // Allocate space for the change buffer
    //

    *Buffer = THAllocEx(pTHS,PreferredMaximumLength);


    //
    // Read the change log from netlogon
    //

    __try {
        NtStatus = dsI_NetLogonReadChangeLog(
                   *Restart,               // In context
                    OldRestartLength,       // In context size
                    PreferredMaximumLength, // Buffer Size
                    *Buffer,                // Buffer for netlogon to fill in change log
                    SizeOfChanges,           // Bytes read
                    &NetlogonRestart,       // out context
                    RestartLength          // out context length
                    );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = STATUS_UNSUCCESSFUL;
    }


    if (NT_SUCCESS(NtStatus))
    {
        //
        // Copy the restart structure into thread memory
        //

        *Restart = (PVOID) THAllocEx(pTHS,*RestartLength);
        RtlCopyMemory(*Restart,NetlogonRestart,*RestartLength);
        dsI_NetLogonFree(NetlogonRestart);

    }

    return NtStatus;
}


NTSTATUS
DraGetNT4ReplicationState(
            IN  DSNAME * pDomain,
            NT4_REPLICATION_STATE *ReplicationState
            )
/*++

    This routine will obtain the serial numbers for the
    3 databases. The first cut of this implementation,
    obtains the serial number only for the Sam account domain.
    Once the test bed has been proved the routine will be generalized
    to builtin and lsa serial numbers.

    Parameters

        pDomain -- DS Name of the Domain for which the serial number
                   has to be obtained

        SamSerialNumber -- The serial number of the Sam database
        BuiltinSerialNumber -- The serial number of the builtin database
        LsaSerialNumber     -- The serial number of the lsa database

    Return values

        STATUS_SUCCESS
        Other Error codes

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    THSTATE     *pTHSSaved = NULL;

    //
    // Save Current thread state. Making in process
    // calls into SAM and LSA, which can result in
    // database operations involving a thread state
    //

    pTHSSaved = THSave();

    //
    // Obtain the serial numbers from SAM
    //

    SampGetSerialNumberDomain2(
        &pDomain->Sid,
        &ReplicationState->SamSerialNumber,
        &ReplicationState->SamCreationTime,
        &ReplicationState->BuiltinSerialNumber,
        &ReplicationState->BuiltinCreationTime
        );




    //
    // Obtain the serial number for the LSA database
    //

    //
    // N.B.  Setting this value to one will always cause
    // a full sync of the LSA database upon a promotion.  This
    // gaurentees that the BDC's are up to date with the new PDC.
    // The LSA database is typically small so this is acceptable
    // performance-wise.
    //

    ReplicationState->LsaSerialNumber.QuadPart = 1;
    NtQuerySystemTime(&ReplicationState->LsaCreationTime);

    THRestore(pTHSSaved);

    return NtStatus;
}

NTSTATUS
DraSetNT4ReplicationState(
            IN  DSNAME * pDomain,
            IN  NT4_REPLICATION_STATE * ReplicationState
            )
/*++

    This routine will sts the serial numbers  and creation time for the
    3 databases. It will also give dummy change notifications, to
    make the world consistent for an NT4 BDC. The first cut of this implementation,
    obtains the serial number only for the Sam account domain.
    Once the test bed has been proved the routine will be generalized
    to builtin and lsa serial numbers.

    Parameters

        pDomain -- DS Name of the Domain for which the serial number
                   has to be obtained

        ReplicationState -- Structure containing the serial number and
                   creation time of the domain.

    Return values

        STATUS_SUCCESS
        Other Error codes

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    THSTATE     *pTHSSaved = NULL;
    UCHAR       BuiltinDomainSid[]={0x01,0x01,0x00,0x00,
                                    0x00,0x00,0x00,0x05,
                                    0x20,0x00,0x00,0x00
                                    };

    //
    // Save Current thread state. Making in process
    // calls into SAM and LSA, which can result in
    // database operations involving a thread state
    //

    pTHSSaved = THSave();

    //
    // Set the serial numbers from SAM
    //

    NtStatus = SampSetSerialNumberDomain2(
                    &pDomain->Sid,
                    &ReplicationState->SamSerialNumber,
                    &ReplicationState->SamCreationTime,
                    &ReplicationState->BuiltinSerialNumber,
                    &ReplicationState->BuiltinCreationTime
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Give Dummy Sam notifications for both account and
    // and builtin SAM domains
    //

    SampNotifyReplicatedInChange(
            &pDomain->Sid,
            TRUE,
            SecurityDbChange,
            SampDomainObjectType,
            NULL,
            0,
            0,      // group type
            CALLERTYPE_INTERNAL,  // it is from task queue, not triggered by ldap client, don't audit
            FALSE,
            FALSE
            );

    SampNotifyReplicatedInChange(
            (PSID) BuiltinDomainSid,
            TRUE,
            SecurityDbChange,
            SampDomainObjectType,
            NULL,
            0,
            0,      // group type
            CALLERTYPE_INTERNAL,  // it is from task queue, not triggered by ldap client, don't audit
            FALSE,
            FALSE
            );

    //
    // For now do nothing for the LSA
    //

Error:


    THRestore(pTHSSaved);

    return NtStatus;
}

ULONG
DRSGetNT4ChangeLog_InputValidate(
    DWORD                     dwMsgInVersion,
    DRS_MSG_NT4_CHGLOG_REQ   *pmsgIn,
    DWORD *                   pdwMsgOutVersion,
    DRS_MSG_NT4_CHGLOG_REPLY *pmsgOut
    )
/*
    [notify] ULONG IDL_DRSGetNT4ChangeLog( 
    [ref][in] DRS_HANDLE hDrs,
    [in] DWORD dwInVersion,
    [switch_is][ref][in] DRS_MSG_NT4_CHGLOG_REQ *pmsgIn,
    [ref][out] DWORD *pdwOutVersion,
    [switch_is][ref][out] DRS_MSG_NT4_CHGLOG_REPLY *pmsgOut)
*/
{
    ULONG ret = DRAERR_Success;

    if ( 1 != dwMsgInVersion ) {
	DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
    }

    return ret;
}

ULONG
IDL_DRSGetNT4ChangeLog(
   RPC_BINDING_HANDLE  rpc_handle,
   DWORD               dwInVersion,
   DRS_MSG_NT4_CHGLOG_REQ *pmsgIn,
   DWORD               *pdwOutVersion,
   DRS_MSG_NT4_CHGLOG_REPLY *pmsgOut
   )
/*++

    Routine Description:

        This Routine reads the change log from netlogon and returns the log
        in the reply message. This is the server side of the RPC routine

    Parameters:

        rpc_handle    The Rpc Handle which the client used for binding
        dwInVersion   The Clients version of the Request packet
        psmgIn        The Request Packet
        dwOutVersion  The Clients version of the Reply packet
        pmsgOut       The Reply Packet

    Return Values

        Return Values are NTSTATUS values casted as a ULONG

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   ret = 0, win32status;
    NTSTATUS                ReadStatus = STATUS_SUCCESS;
    THSTATE                 *pTHS = pTHStls;

    DRS_Prepare(&pTHS, rpc_handle, IDL_DRSGETNT4CHANGELOG);
    drsReferenceContext( rpc_handle );
    __try { 
	*pdwOutVersion=1;
	RtlZeroMemory(&pmsgOut->V1,sizeof(DRS_MSG_NT4_CHGLOG_REQ_V1));
	
	//
	// Initialize thread state and open data base.
	//

	if(!(pTHS = InitTHSTATE(CALLERTYPE_SAM))) {
	    ret = ERROR_DS_INTERNAL_FAILURE;
	    __leave;
	}

	if ((ret = DRSGetNT4ChangeLog_InputValidate(dwInVersion, 
						    pmsgIn, 
						    pdwOutVersion, 
						    pmsgOut))!=DRAERR_Success) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    __leave;
	}

	//
	// PREFIX: PREFIX complains that there is the possibility
	// of pTHS->CurrSchemaPtr being NULL at this point.  However,
	// the only time that CurrSchemaPtr could be NULL is at the
	// system start up.  By the time that the RPC interfaces
	// of the DS are enabled and this function could be called,
	// CurrSchemaPtr will no longer be NULL.
	//
	Assert(NULL != pTHS->CurrSchemaPtr);

	Assert(1 == dwInVersion);
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_EXTENSIVE,
			 DIRLOG_IDL_DRS_GET_NT4_CHGLOG_ENTRY,
			 EVENT_TRACE_TYPE_START,
			 DsGuidDrsGetNT4ChgLog,
			 szInsertUL(pmsgIn->V1.dwFlags),
			 szInsertUL(pmsgIn->V1.PreferredMaximumLength),
			 NULL, NULL, NULL, NULL, NULL, NULL);

	//
	// Make the security check, wether we have rights to take
	// a checkpoint
	//
	if (!IsDraAccessGranted(pTHS, gAnchor.pDomainDN,
				&RIGHT_DS_REPL_GET_CHANGES, &win32status))
	    {
	    // CODE.IMP: IsDraAccessGranted has returned a more specific failure
	    // reason, but we are not using it at this point.
	    NtStatus = STATUS_ACCESS_DENIED;
	}
	else
	    {
	    pTHS->fDSA = TRUE;

	    //
	    // Read the Change Log from Netlogon, if Changelog read
	    // was requested
	    //

	    if (pmsgIn->V1.dwFlags & DRS_NT4_CHGLOG_GET_CHANGE_LOG)
		{
		pmsgOut->V1.pRestart = pmsgIn->V1.pRestart;
		pmsgOut->V1.cbRestart = pmsgIn->V1.cbRestart;


		NtStatus = DraReadNT4ChangeLog(
		    &pmsgOut->V1.pRestart,
		    &pmsgOut->V1.cbRestart,
		    pmsgIn->V1.PreferredMaximumLength,
		    &pmsgOut->V1.cbLog,
		    &pmsgOut->V1.pLog
		    );
	    }

	    //
	    // Save of the Read Status
	    //

	    ReadStatus = NtStatus;

	    if ((pmsgIn->V1.dwFlags & DRS_NT4_CHGLOG_GET_SERIAL_NUMBERS)
		&& (NT_SUCCESS(NtStatus)))
		{



		//
		// Grab the serial Numbers in the database
		// at the current time
		//

		NtStatus = DraGetNT4ReplicationState(
		    gAnchor.pDomainDN,
		    &pmsgOut->V1.ReplicationState
		    );
	    }


	    //
	    // Map any Errors
	    //
	    ret = NtStatusToDraError(NtStatus);
	    if (NT_SUCCESS(NtStatus))
		{
		pmsgOut->V1.ActualNtStatus = ReadStatus;
	    }
	    else
		{
		pmsgOut->V1.ActualNtStatus = NtStatus;
	    }

	} // End of Successful Access check 
    } // End of Try Block
    __except ( GetDraException( GetExceptionInformation(), &ret ) )
    {
	//
	// Return DS Busy as status code for any outstantding
	// exceptions
	//
	pmsgOut->V1.ActualNtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    drsDereferenceContext( rpc_handle );

    if (NULL != pTHS) {
	Assert(1 == *pdwOutVersion);
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_EXTENSIVE,
			 DIRLOG_IDL_DRS_GET_NT4_CHGLOG_EXIT,
			 EVENT_TRACE_TYPE_END,
			 DsGuidDrsGetNT4ChgLog,
			 szInsertNtStatusCode(pmsgOut->V1.ActualNtStatus),
			 szInsertNtStatusMsg(pmsgOut->V1.ActualNtStatus),
			 NULL, NULL, NULL, NULL, NULL, NULL);
    }

    return ret;
}




VOID
DraPreventModifications()
/*++

    Routine Description

        This routine prevents modifications to the SAM / LSA databases by
        acquiring the SAM lock and LSA lock for exclusive access. This is
        sufficient to prevent in bound replication also, as the netlogon
        notification path, will try to acquire the lock, before giving out
        the notification.

--*/
{
    SampAcquireSamLockExclusive();
}

VOID
DraAllowModifications()
/*++

    Routine Description

        This routine will allow modifications to SAM / LSA databases by
        releasing the SAM lock and the LSA lock for exclusive access. This
        release is done corresponding to order of the acquire

--*/
{
    SampReleaseSamLockExclusive();
}


BOOLEAN
DraSameSite(
   THSTATE * pTHS,
   DSNAME * Machine1,
   DSNAME * Machine2
   )
/*++

    Routine Description

        This routine will check wether Machine 1 and Machine 2 are in the
        same site. The check is done, by comparing wether they have the same
        parent

    Parameters

        Machine1  -- Ds Name of the First machine
        Machine2  -- Ds Name of the second machine


    Return Values

        TRUE     -- If they are in the same site
        FALSE    -- False Otherwise
--*/
{
    DSNAME * Parent1, * Parent2;
    BOOLEAN ret;

    Parent1 = THAllocEx(pTHS,Machine1->structLen);
    Parent2 = THAllocEx(pTHS,Machine2->structLen);
    if (   TrimDSNameBy(Machine1,2,Parent1)
        || TrimDSNameBy(Machine2,2,Parent2)
        || !NameMatched(Parent1,Parent2))
        ret = FALSE;
    else
        ret = TRUE;

    THFreeEx(pTHS,Parent1);
    THFreeEx(pTHS,Parent2);
    return ret;
}

NTSTATUS
DraGetPDCChangeLog(
    THSTATE *pTHS,
    IN  LPWSTR pszPDCFDCServer,
    IN  OUT HANDLE *ChangeLogHandle,
    OUT NT4_REPLICATION_STATE * ReplicationState,
    IN  OUT PVOID  *ppRestart,
    IN  OUT PULONG pcbRestart
    )
/*++

    Routine Description

        This routine will open a new change log locally if required and then
        grab the change log from the PDC and set it on the new change log.

    Parameters

        szPDCFDCServer --- The name of the PDC / FDC
        ChangeLogHandle -- Handle to the open change log
        ppRestart       --  In-Out parameter descibing a restart structure to
                            incrementaly update the change log

        pcbRestart      --  The length of the restart structure is passed in
                            or updated in her

    Return Values

        STATUS_SUCCESS
        Other NT error codes to indicate errors pertaining to resource failures

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        RetrieveStatus;
    PVOID           pLog=NULL;
    ULONG           cbLog=0;
    LARGE_INTEGER   SamSerialNumber;
    LARGE_INTEGER   LsaSerialNumber;
    LARGE_INTEGER   BuiltinSerialNumber;
    ULONG           RetCode = 0;

    //
    // If the change log has not been opened then open it
    //

    if (INVALID_HANDLE_VALUE==*ChangeLogHandle)
    {
        __try {
            NtStatus = dsI_NetLogonNewChangeLog(ChangeLogHandle);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    }

    //
    // Grab the change log from the PDC in chunks, till there is no
    // further entries
    //

    do
    {
        pLog = NULL;

        RetCode = I_DRSGetNT4ChangeLog(
                        pTHS,
                        pszPDCFDCServer,
                        DRS_NT4_CHGLOG_GET_CHANGE_LOG
                        |DRS_NT4_CHGLOG_GET_SERIAL_NUMBERS,
                        MAX_CHANGELOG_BUFFER_SIZE,
                        ppRestart,
                        pcbRestart,
                        &pLog,
                        &cbLog,
                        ReplicationState,
                        &NtStatus
                        );

        if (0!=RetCode)
        {
            //
            // Morph any connect errors to this error code
            //

            NtStatus = STATUS_DOMAIN_CONTROLLER_NOT_FOUND;
            goto Error;
        }

        //
        // If the actual call failed then also abort
        //

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Save the return code returned by the RPC call
        //

        RetrieveStatus = NtStatus;

        //
        // Now append the changes to the new change log
        //

        __try {
            NtStatus = dsI_NetLogonAppendChangeLog(
                        *ChangeLogHandle,
                        pLog,
                        cbLog
                        );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = STATUS_UNSUCCESSFUL;
        }

        if (NULL!=pLog)
        {
            THFree(pLog);
        }

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    } while (STATUS_MORE_ENTRIES==RetrieveStatus);


Error:


    return NtStatus;
}

NTSTATUS
DraGetPDCFDCRoleOwner(
    DSNAME * pDomain,
    DSNAME ** ppRoleOwner
    )
/*++

    Routine Description

        This routine retrieves the FSMO role owner property
        for PDCness for the appropriate domain.

    Parameters

        pDomain -- DS name of the domain object
        ppRoleOwner -- The DS name of the role owner is returned in here

    Return Values

        STATUS_SUCCESS
        Other Error codes upon failure
--*/
{
    THSTATE * pTHS = pTHStls;
    ULONG     RoleOwnerSize;

    Assert(NULL!=pTHS);

    __try
    {
        //
        // Begin a Transaction
        //

        DBOpen2(TRUE,&pTHS->pDB);

        //
        // Position on the Domain object
        //

        if (0!=DBFindDSName(
                    pTHS->pDB,
                    pDomain))
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        //
        // Read the Value
        //

        if (0!=DBGetAttVal(
                pTHS->pDB,
                1,
                ATT_FSMO_ROLE_OWNER,
                DBGETATTVAL_fREALLOC,
                0,
                &RoleOwnerSize,
                (PUCHAR *)ppRoleOwner
                ))
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    __finally
    {
        //
        // End the Transaction
        //

        DBClose(pTHS->pDB,TRUE);
    }

    return STATUS_SUCCESS;
}

BOOLEAN
TestForCheckpoint(
    IN NT4_REPLICATION_STATE *StartState,
    IN NT4_REPLICATION_STATE *EndState
    )
{
    return (( StartState->SamSerialNumber.QuadPart==EndState->SamSerialNumber.QuadPart) &&
           ( StartState->BuiltinSerialNumber.QuadPart==EndState->BuiltinSerialNumber.QuadPart) &&
           ( StartState->LsaSerialNumber.QuadPart==EndState->LsaSerialNumber.QuadPart));
}


ULONG
DraSynchronizeWithPdc(
    DSNAME * pDomain,
    DSNAME * pPDC
    )
/*++

    Routine Description

            This routine makes the call to synchronize with the PDC,
            after saving the current thread state

    Parameters

        pDOmain --- The DSNAME of the Domain object
        pPDC    --- The DSNAME of the NTDS DSA object for the PDC

    Return Values

        0 Success
        Other Replication Error Codes

--*/
{
    ULONG retCode = 0;
    THSTATE *pTHSSaved=NULL;

    __try
    {
        //
        // Save the existing thread state, as DirReplicaSynchronize will create a new
        // one as the DRA.
        //

        pTHSSaved = THSave();

        //
        // Synchronize with the PDC
        //

        //
        // DirReplica synchronize today keeps retrying till synchronization is achieved
        // As per JeffParh this is not a problem, as replication is "faster" than anything
        // else, and will eventually catch up. This delays the checkpointing, but is not
        // fatal to the algorithm. In case this proves to be a problem, then we should
        // pass in a ulOption to DirReplicaSynchronize, that it abandon the operatio, after
        // a few cycles of "GetNcChanges -- UpDateNc"
        //

        retCode =DirReplicaSynchronize(
                    pDomain,
                    NULL,
                    &pPDC->Guid,
                    0
                    );

        //
        // free the thread state created by DirReplicaSynchronize
        //
    }
    __finally
    {

        free_thread_state();

        THRestore(pTHSSaved);

    }

    return retCode;
}

DWORD
DraTakeCheckPoint(
            IN ULONG RetryCount,
            OUT PULONG RescheduleInterval
            )
/*++

    This routine does all the client side work of taking a checkpoint


  Parameters

    RetryCount -- The number of times this routine should retry the
    checkpoint operation.

    RescheduleInterval -- Time after which this task should be rescheduled

  Return values

   Void Function
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN  CheckpointTaken = FALSE;
    NT4_REPLICATION_STATE ReplicationStateAtPDC,
                          ReplicationStateLocalAtStart,
                          ReplicationStateLocalAtEnd;
    THSTATE       *pTHS = pTHStls;
    HANDLE        ChangeLogHandle = INVALID_HANDLE_VALUE;
    DSNAME        *pDomain = gAnchor.pDomainDN;
    DSNAME        *pDSA    = gAnchor.pDSADN;
    DSNAME        *pPDC, *pPDCAfterSync;
    PVOID         pRestart = NULL;
    ULONG         cbRestart =  0;
    ULONG         retCode ;
    LPWSTR        szPDCFDCServer = NULL;
    BOOLEAN       MixedDomain;



    Assert(NULL!=pTHS);

    //
    // First Check the mixed domain setting
    //

    NtStatus = SamIMixedDomain2(&pDomain->Sid,&MixedDomain);

    if (!NT_SUCCESS(NtStatus))
    {
        retCode = RtlNtStatusToDosError(NtStatus);
        goto Failure;
    }

    if (!MixedDomain)
    {
        //
        // If not a mixed domain, then no checkpointing
        //

        goto Success;
    }

    //
    // Get the PDC or FDC role owner
    //

    NtStatus = DraGetPDCFDCRoleOwner(
                    pDomain,            // The domain, whose PDC ness we are testing
                    &pPDC
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        retCode = RtlNtStatusToDosError(NtStatus);
        goto Failure;
    }

    //
    // Check wether we are in same site, or are the PDC ourselves
    //

    if (NameMatched(pDSA,pPDC))
    {
        //
        // If we are the PDC itself then return success
        //


        goto Success;
    }

    if (!DraSameSite(pTHS,pDSA,pPDC))
    {
        //
        // Not in the same site. Return a filure
        // Do not log an event and set the reschedule interval to be the
        // success interval
        //

        *RescheduleInterval = DRACHKPT_SUCCESS_RETRY_INTERVAL;
        return(ERROR_DS_DRA_NO_REPLICA);
    }



    //
    // O.K we are now a "candidate PDCFDC" ie we are not the PDC or FDC, and are
    // in the same site as the PDC or FDC. Therefore proceed with taking the
    // checkpoint.
    //

    //
    // Synchronize with the PDC
    //

    retCode = DraSynchronizeWithPdc(
                    pDomain,
                    pPDC
                    );

    if (0!=retCode)
    {

        goto Failure;
    }


    //
    // After the Sync verify again that the PDC is the same, and in the same site
    // We could have had an out of date FSMO, and we need to make sure that it is
    // more upto date. It is true, that we could always make a DsGetDcName to obtain
    // the PDC, but then this mechanism should also be "adequate". Therefore we can
    // can trim out one network operation. We need to do the sync anyway in the success
    // case, and therefore we can save the network operation of calling DsGetDcName
    //

    //
    // Get the PDC or FDC role owner once again !
    //

    NtStatus = DraGetPDCFDCRoleOwner(
                    pDomain,            // The domain, whose PDC ness we are testing
                    &pPDCAfterSync
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        retCode = RtlNtStatusToDosError(NtStatus);;
        goto Failure;
    }

    //
    // Verify that the PDC remained the same
    //

    if (!NameMatched(pPDC,pPDCAfterSync))
    {
        retCode = ERROR_DS_PDC_OPERATION_IN_PROGRESS;
        goto Failure;
    }

    //
    // Note At this point, it is safe to assume, that the machine we think
    // is the PDC is the PDC itself. This is because the FSMO operation
    // guarentees us that every machine has accurate knowledge of its own role.
    //

    do
    {

         //
         // Get local serial numbers
         //

        NtStatus = DraGetNT4ReplicationState(
                        pDomain,
                        &ReplicationStateLocalAtStart
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            retCode = RtlNtStatusToDosError(NtStatus);
            goto Failure;
        }



        //
        // Make the PDC synchronize with Us
        //

        szPDCFDCServer   = DSaddrFromName(pTHS,
                                          pPDC);
        if (NULL==szPDCFDCServer)
        {
            retCode = ERROR_NOT_ENOUGH_MEMORY;
            goto Failure;
        }

        retCode = I_DRSReplicaSync(
                        pTHS,
                        szPDCFDCServer, // PDC server
                        pDomain,      // NC to synchronize
                        NULL,         // String name of source
                        &pDSA->Guid,  // Invocation Id of Source
                        0);

        if (0!=retCode)
        {
            goto Failure;
        }

        //
        // Get the complete change log
        //

        NtStatus = DraGetPDCChangeLog(
                        pTHS,
                        szPDCFDCServer,
                        &ChangeLogHandle,
                        &ReplicationStateAtPDC,
                        &pRestart,
                        &cbRestart
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            retCode = RtlNtStatusToDosError(NtStatus);
            goto Failure;
        }

        //
        // Synchronize with the PDC.
        //

        retCode = DraSynchronizeWithPdc(
                        pDomain,
                        pPDC
                        );

        if (0!=retCode)
        {
            goto Failure;
        }

        __try
        {

            //
            // Prevent modifications to accounts database
            //

            DraPreventModifications();

            //
            // Check Checkpoint criteria
            //

             NtStatus = DraGetNT4ReplicationState(
                            pDomain,
                            &ReplicationStateLocalAtEnd
                            );

            if (!NT_SUCCESS(NtStatus))
            {
                retCode = RtlNtStatusToDosError(NtStatus);
                goto Failure;
            }

            CheckpointTaken = TestForCheckpoint(
                                &ReplicationStateLocalAtStart,
                                &ReplicationStateLocalAtEnd
                                );
            //
            // If Criteria Matched, commit and close change log
            //

            if (CheckpointTaken)
            {
                LARGE_INTEGER PromotionIncrement = DOMAIN_PROMOTION_INCREMENT;

                //
                // Add the promotion count to the serial
                // numbers retrieved from the PDC
                //

                ReplicationStateAtPDC.SamSerialNumber.QuadPart+=
                                        PromotionIncrement.QuadPart;
                ReplicationStateAtPDC.BuiltinSerialNumber.QuadPart+=
                                        PromotionIncrement.QuadPart;
                ReplicationStateAtPDC.LsaSerialNumber.QuadPart+=
                                        PromotionIncrement.QuadPart;


                //
                // Commit the change log making it the new log
                //

                __try {
                    NtStatus = dsI_NetLogonCloseChangeLog(
                                ChangeLogHandle,
                                TRUE
                                );
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

                ChangeLogHandle = INVALID_HANDLE_VALUE;

                if (!NT_SUCCESS(NtStatus))
                {
                    retCode = RtlNtStatusToDosError(NtStatus);
                    goto Failure;
                }


                //
                // Set the new set of serial numbers and creation time
                //


                NtStatus = DraSetNT4ReplicationState(
                                pDomain,
                                &ReplicationStateAtPDC
                                );

                if (!NT_SUCCESS(NtStatus))
                {
                    retCode = RtlNtStatusToDosError(NtStatus);
                    goto Failure;
                }

            }
        }
        __finally
        {

            //
            // Reenable modifications to accounts database
            //

            DraAllowModifications();
        }

        //
        // Bump down retry count
        //

        RetryCount--;

    } while ( (!CheckpointTaken) && (RetryCount>0));


    if (!CheckpointTaken)
    {
        retCode = ERROR_DS_NO_CHECKPOINT_WITH_PDC;
        goto Failure;
    }

Success:

    //
    // The call succeeded. Either the checkpoint was taken,
    // or it is not necessary to take the check point.
    // Reschedule the operation at success interval

    *RescheduleInterval = DRACHKPT_SUCCESS_RETRY_INTERVAL;

     LogEvent(
         DS_EVENT_CAT_REPLICATION,
         DS_EVENT_SEV_MINIMAL,
         DIRLOG_NT4_REPLICATION_CHECKPOINT_SUCCESSFUL,
         NULL,
         NULL,
         NULL);

    return(0);

Failure:

     LogEvent(
         DS_EVENT_CAT_REPLICATION,
         DS_EVENT_SEV_ALWAYS,
         DIRLOG_NT4_REPLICATION_CHECKPOINT_UNSUCCESSFUL,
         szInsertWin32Msg(retCode),
         szInsertWin32ErrCode(retCode),
         NULL);

    if (INVALID_HANDLE_VALUE!=ChangeLogHandle)
    {
        __try {
            dsI_NetLogonCloseChangeLog(
                                     ChangeLogHandle,
                                     FALSE
                                     );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            ;
        }

    }

    *RescheduleInterval  = DRACHKPT_FAILURE_RETRY_INTERVAL;
    Assert(0!=retCode);
    return(retCode);

}

VOID
NT4ReplicationCheckpoint(
    VOID *  pV,
    VOID ** ppVNext,
    DWORD * pcSecsUntilNextIteration
    )
{
    DraTakeCheckPoint(NUM_CHKPT_RETRIES, pcSecsUntilNextIteration);
}

#ifdef INCLUDE_UNIT_TESTS
VOID
TestCheckPoint(VOID)
/*++
    Routine Description

        This is a basic test, that allows, manual initiation of
        a checkpoint

--*/
{
    ULONG RetryInterval;


    DraTakeCheckPoint(3,&RetryInterval);
}

VOID
RoleTransferStress(VOID)
/*++

    This is a more advanced test, that every 10 minutes will initiate
    taking a checkpoint followed by a role transfer. Coupled with a modify
    intensive test, this test is a good test bed for the non full sync
    role transfer code. The role transfer stress iterates through about
    48 iterations, which makes it run for about 8 hrs.

--*/
{
    ULONG i;
    ULONG RetryInterval;
    OPARG OpArg;
    OPRES *OpRes;
    PSID  DomainSid;
    ULONG RetCode;

    for (i=0;i<48;i++)
    {
        DraTakeCheckPoint(NUM_CHKPT_RETRIES,&RetryInterval);
        if (DRACHKPT_SUCCESS_RETRY_INTERVAL==RetryInterval)
        {
            KdPrint(("DS:RoleTransferStress : CheckPointSucceeded\n"));
        }
        else
        {
            KdPrint(("DS:RoleTransferStress : CheckPointFailed\n"));
        }

        RtlZeroMemory(&OpArg, sizeof(OPARG));
        OpArg.eOp = OP_CTRL_BECOME_PDC;
        DomainSid =  &gAnchor.pDomainDN->Sid;
        OpArg.pBuf = DomainSid;
        OpArg.cbBuf = RtlLengthSid(DomainSid);

        RetCode = DirOperationControl(&OpArg, &OpRes);

        if (0!=RetCode)
        {
            KdPrint(("DS:RoleTransferStress : Promotion Failed\n"));
        }
        else
        {
            KdPrint(("DS:RoleTransferStress: Promotion Succeeded\n"));
        }

        pTHStls->errCode=0;
        pTHStls->pErrInfo = NULL;

        Sleep(60*10*1000/*10 minutes*/);

        THRefresh();
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\draaudit.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       draaudit.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Security Audit Routines

Author:

    Greg Johnson (gregjohn) 

Revision History:

    Created     <10/1/2001>  gregjohn

--*/
#include <NTDSpch.h>
#pragma hdrstop

#include <attids.h>
#include <ntdsa.h>
#include <dsjet.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>  
#include <msaudite.h>
#include <ntlsa.h>
#include <minmax.h>

#include <lsarpc.h>
#include <lsaisrv.h>

#include "draaudit.h"
#include "drautil.h"
#include "dsatools.h"
#include "anchor.h"
#include "dsexcept.h"
#include "drserr.h"
#include "dsevent.h"
#include "dsutil.h"

#include "debug.h"
#define DEBSUB "DRAAUDIT:"
#include <fileno.h>
#define  FILENO FILENO_DRAAUDIT

// temp - gregjohn 5/17/02 - to be removed as soon as base changes to msaudite.h migrate to lab03
#ifndef SE_AUDITID_REPLICA_LINGERING_OBJECT_REMOVAL
#define SE_AUDITID_REPLICA_LINGERING_OBJECT_REMOVAL ((ULONG)0x00000349L)
#endif

#define SAFE_STRING_NAME(pDsName) ((pDsName) ? pDsName->StringName : NULL)
#define SZUSN_LEN (24)

/*

    Not all log parameters are valid in all code paths.  Unfortunately for us, 
    the Authz calls don't accept NULL APT_String parameters.  We'd like to use
    APT_None, but it doesn't appear to be similar to SeAdtParmTypeNone in ntlsa.h,
    which is what we want.  So we have two choices:  L"" or L"-" (which would 
    simulate the SeAdtParmTypeNone type).  Currently we choose the L"-" simulation.

*/

#define EMPTY_AUDIT_STRING L"-" 
#define SAFE_AUDIT_STRING(x) (x ? x : EMPTY_AUDIT_STRING)

ULONG gulSyncSessionID = 0;

#define NUM_AUDIT_EVENT_TYPES (10)

PAUTHZ_AUDIT_EVENT_TYPE_HANDLE grghAuditEventType[NUM_AUDIT_EVENT_TYPES] = {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};

// if there are any new (out of order) SE_AUDITID_REPLICA params, this access function will have to get smarter...
#define AUDIT_EVENT_TYPE_HANDLE(auditID) (grghAuditEventType[(auditID - (USHORT)SE_AUDITID_REPLICA_SOURCE_NC_ESTABLISHED)])

BOOL
DraAuthziInitializeAuditEventTypeWrapper(
    IN DWORD Flags,
    IN USHORT CategoryID,
    IN USHORT AuditID,
    IN USHORT ParameterCount,
    OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
    )
/*++

Routine Description:

    The call to AuthziInitializeAuditEventType is expensive.  So, for each audit type, we'll only have one
    call to AuditEventType and will hold the audit handles in a global array, grghAuditEventType (accessed
    with AUDIT_EVENT_TYPE_HANDLE macro)

Arguments:

    Flags - pass to AuthziInitializeAuditEventType
    CategoryID - ditto
    AuditID - ditto - also used to access the global handle
    ParameterCount - pas to AuthziInitializeAuditEventType
    phAuditEventType - OUT - handle to return

Return Value:

    TRUE if success full, false otherwise.  GetLastError is set on false.  phAuditEventType is global
    memory, do not free.

--*/
{
    if ((AuditID < (USHORT)SE_AUDITID_REPLICA_SOURCE_NC_ESTABLISHED) ||
	(AuditID > (USHORT)SE_AUDITID_REPLICA_LINGERING_OBJECT_REMOVAL)) {
	Assert(!"Unknown audit type!");
	SetLastError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }

    if (AUDIT_EVENT_TYPE_HANDLE(AuditID)==NULL) {
	AUDIT_EVENT_TYPE_HANDLE(AuditID) = malloc(sizeof(AUTHZ_AUDIT_EVENT_TYPE_HANDLE));
	if (AUDIT_EVENT_TYPE_HANDLE(AuditID)==NULL) {
	    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
	    return FALSE;
	}
	if (!AuthziInitializeAuditEventType(Flags, 
					    CategoryID, 
					    AuditID, 
					    ParameterCount, 
					    (AUDIT_EVENT_TYPE_HANDLE(AuditID)))) {

	    Assert(AUDIT_EVENT_TYPE_HANDLE(AuditID)==NULL);
	    AUDIT_EVENT_TYPE_HANDLE(AuditID)=NULL;
	    return FALSE;
	}
    }
    
    *phAuditEventType = *(AUDIT_EVENT_TYPE_HANDLE(AuditID));
    return TRUE;
}

LPWSTR
USNToString(
    THSTATE * pTHS,
    USN       usn
    )
/*++

Routine Description:

    Convert a USN to a string for output

Arguments:

    pTHS -
    usn - usn to convert

Return Value:

    pointer to a string (THAlloc'ed)

--*/
{
    LARGE_INTEGER *pli = (LARGE_INTEGER *) &usn; 
    CHAR pszTemp[SZUSN_LEN]; 
    LPWSTR pszUSN = THAllocEx(pTHS, (SZUSN_LEN+1)*sizeof(WCHAR));
    DWORD cchTemp; 
    RtlLargeIntegerToChar( pli, 10, SZUSN_LEN, pszTemp ); 
    cchTemp = MultiByteToWideChar(CP_ACP, 0, (PCHAR)pszTemp, SZUSN_LEN, pszUSN, SZUSN_LEN);
    pszUSN[SZUSN_LEN] = L'\0';
    return pszUSN;
}

UNICODE_STRING *
UStringFromAttrVal(
    THSTATE * pTHS,
    ATTRVAL attrVal
    )
/*++

Routine Description:

    Encode a unicode string which represents the hex value stored in attrVal

Arguments:

    pTHS -
    attrVal - value to encode

Return Value:

    pointer to a unicode string (THAlloc'ed)

--*/
{
    LPWSTR pszBuffer = NULL;
    LPWSTR pszBufferOut = NULL;
    USHORT cbBuffer = (USHORT) attrVal.valLen;
    UNICODE_STRING * pusBuffer;
    ULONG i = 0;

    // allocate the buffer (needs to be null terminated)
    pusBuffer = THAllocEx(pTHS, (cbBuffer*2 + 1)*sizeof(WCHAR) + sizeof(UNICODE_STRING));
    pszBuffer = pszBufferOut = (LPWSTR)(pusBuffer+1); 

    // copy in the data - slowly.
    for (i=0; i < cbBuffer; i++) {
	swprintf(pszBuffer,
		 L"%02X",
		 *((BYTE *)attrVal.pVal+i));
	pszBuffer = pszBuffer + 2;
    }

    // terminate the string
    pszBuffer = L"\0";

    RtlInitUnicodeString(pusBuffer, NULL);
    pusBuffer->Buffer = pszBufferOut;
    pusBuffer->Length = cbBuffer;
    pusBuffer->MaximumLength = cbBuffer+1;

    return pusBuffer;
}

BOOL
IsDraAuditLogEnabledForAttr()
/*++

Routine Description:

    Check the registry to see if replication security auditing for attr/values is enabled

Arguments:

    none -
    
Return Value:

    BOOL

--*/
{
    #define LSA_CONFIG      "System\\CurrentControlSet\\Control\\Lsa"
    #define AUDIT_DS_OBJECT "AuditDSObjectsInReplication"
    DWORD herr, err = 0, dwType, dwSize = sizeof(DWORD);
    HKEY  hk;
    DWORD Value;
    BOOL fAuditing = FALSE;

    if (!(herr = RegOpenKey(HKEY_LOCAL_MACHINE, LSA_CONFIG, &hk)) &&
	!(err = RegQueryValueEx(hk, AUDIT_DS_OBJECT, NULL, &dwType, (PBYTE) &Value, &dwSize)) &&
	!(Value==0)) {
	fAuditing = TRUE;
    }

    if (!herr) {
	//  Close the handle if one was opened.
	RegCloseKey(hk);
    }

    return fAuditing;
}

BOOL
IsDraAuditLogEnabled(
    )
/*++

Routine Description:

    See if replication security auditing is enabled

Arguments:

    none -
    
Return Value:

    BOOL

--*/
{
    NTSTATUS NtStatus;
    BOOLEAN fAuditEnabled = FALSE;

    // we are logging before and after actions.  before the action, we
    // don't know if we're logging sucess or failure.  If either is
    // true, return true from this function.

    NtStatus = LsaIAdtAuditingEnabledByCategory(
	AuditCategoryDirectoryServiceAccess,
	EVENTLOG_AUDIT_SUCCESS,
	NULL,
	NULL,
	&fAuditEnabled
	);

    if ( !NT_SUCCESS( NtStatus ) ) {
	Assert(!fAuditEnabled);
	fAuditEnabled = FALSE;
    }

    if (!fAuditEnabled) {
	NtStatus = LsaIAdtAuditingEnabledByCategory(
	    AuditCategoryDirectoryServiceAccess,
	    EVENTLOG_AUDIT_FAILURE,
	    NULL,
	    NULL,
	    &fAuditEnabled
	    );

	if ( !NT_SUCCESS( NtStatus ) ) {
	    Assert(!fAuditEnabled);
	    fAuditEnabled = FALSE;
	}
    }

    return ( (BOOL) fAuditEnabled ); 
}

ULONG
DRA_AuditLog_Failure_Begin(
    THSTATE *pTHS,
    ULONG ulOperation,
    ULONG ulAuditError
    )
/*++

Routine Description:

    We've failed to log correctly somewhere.  THIS FUNCTION SHOULD NEVER EVER
    EXCEPT.  So log what we can.

Arguments:

    pTHS - not used, passed for consistency
    ulOperation - the operation attempted. 
    ulAuditError - the result of that attempt.
      
Return Value:

    WINERROR

--*/
{
    ULONG ret = ERROR_SUCCESS;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent = NULL;
    AUDIT_PARAMS AuditParams = {0};

    Assert((ulAuditError==ERROR_DS_DRA_DB_ERROR) || (ulAuditError==ERROR_DS_SHUTTING_DOWN) || (ulAuditError==ERROR_DS_DRA_OUT_OF_MEM));

    __try { 
	AUDIT_PARAM ParamArray[4];
	USHORT NUM_AUDIT_PARAMS = 2;

	RtlZeroMemory( ParamArray, sizeof(AUDIT_PARAM)*NUM_AUDIT_PARAMS );

	if ((ret==ERROR_SUCCESS) && 
	    (!DraAuthziInitializeAuditEventTypeWrapper(0, 
						       SE_CATEGID_DS_ACCESS, 
						       (USHORT) SE_AUDITID_REPLICA_FAILURE_EVENT_BEGIN, 
						       NUM_AUDIT_PARAMS, 
						       &hAuditEventType))) {
	    ret = GetLastError();
	    Assert(!"Unable to initialize DS Repl Audit Event Type!");
	}

	AuditParams.Parameters = ParamArray;
	Assert(ghAuthzRM);

	if ((ret==ERROR_SUCCESS) && 
	    (!AuthziInitializeAuditParamsWithRM(APF_AuditSuccess,
						ghAuthzRM,
						NUM_AUDIT_PARAMS,
						&AuditParams,
						APT_Ulong,      ulOperation,
						APT_Ulong,      ulAuditError
						))) { 
	    ret = GetLastError();
	    Assert(!"Unable to initialize DS Repl Audit Parameters!");
	}

	if ((ret==ERROR_SUCCESS) && 
	    (!AuthziInitializeAuditEvent(0,            // flags
					 ghAuthzRM,         // resource manager
					 hAuditEventType,
					 &AuditParams,
					 NULL,         // hAuditQueue
					 INFINITE,     // time out
					 L"", L"", L"", L"", // obj access strings
					 &hAuditEvent))) {
	    ret = GetLastError();
	    Assert(!"Unable to initialize DS Repl Audit Event!");
	}

	if ((ret==ERROR_SUCCESS) && 
	    (!AuthziLogAuditEvent(0,            // flags
				  hAuditEvent,
				  NULL))) {        // reserved
	    ret = GetLastError();
	    Assert(!"Unable to log DS Repl Audit!");
	}

	if ( hAuditEvent ) {
	    AuthzFreeAuditEvent( hAuditEvent );
	}

    }
    __except(1) {
	Assert(!"Audit logging operations shouldn't accept!  Contact DsRepl!");
	if (ret!=ERROR_SUCCESS) {
	    ret = ERROR_EXCEPTION_IN_SERVICE;
	}
    }

    return ret;
}

ULONG
DRA_AuditLog_Failure_End(
    THSTATE *pTHS,
    ULONG ulOperation,
    ULONG ulAuditError,
    ULONG ulReplError
    )
/*++

Routine Description:

    We've failed to log correctly somewhere.  THIS FUNCTION SHOULD NEVER EVER
    EXCEPT.  So log what we can.

Arguments:

    pTHS - 
    ulOperation - the operation attempted
    ulAuditError - the result of that audit attempt.
    ulReplError - the result of that operation attempt.
      
Return Value:

    WINERROR

--*/
{
    ULONG ret = ERROR_SUCCESS;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent = NULL;
    AUDIT_PARAMS AuditParams = {0};

    Assert((ulAuditError==ERROR_DS_DRA_DB_ERROR) || (ulAuditError==ERROR_DS_SHUTTING_DOWN) || (ulAuditError==ERROR_DS_DRA_OUT_OF_MEM));

    __try { 
	AUDIT_PARAM ParamArray[5];
	USHORT NUM_AUDIT_PARAMS = 3;

	RtlZeroMemory( ParamArray, sizeof(AUDIT_PARAM)*NUM_AUDIT_PARAMS );

	if ((ret==ERROR_SUCCESS) && 
	    (!DraAuthziInitializeAuditEventTypeWrapper(0, 
						       SE_CATEGID_DS_ACCESS, 
						       (USHORT) SE_AUDITID_REPLICA_FAILURE_EVENT_END, 
						       NUM_AUDIT_PARAMS, 
						       &hAuditEventType))) {
	    ret = GetLastError();
	    Assert(!"Unable to initialize DS Repl Audit Event Type!");
	}

	AuditParams.Parameters = ParamArray;
	Assert(ghAuthzRM);

	if ((ret==ERROR_SUCCESS) && 
	    (!AuthziInitializeAuditParamsWithRM(APF_AuditSuccess,
						ghAuthzRM,
						NUM_AUDIT_PARAMS,
						&AuditParams,
						APT_Ulong,      ulOperation,
						APT_Ulong,      ulAuditError,
						APT_Ulong,      ulReplError
						))) { 
	    ret = GetLastError();
	    Assert(!"Unable to initialize DS Repl Audit Parameters!");
	}

	if ((ret==ERROR_SUCCESS) && 
	    (!AuthziInitializeAuditEvent(0,            // flags
					 ghAuthzRM,         // resource manager
					 hAuditEventType,
					 &AuditParams,
					 NULL,         // hAuditQueue
					 INFINITE,     // time out
					 L"", L"", L"", L"", // obj access strings
					 &hAuditEvent))) {
	    ret = GetLastError();
	    Assert(!"Unable to initialize DS Repl Audit Event!");
	}

	if ((ret==ERROR_SUCCESS) && 
	    (!AuthziLogAuditEvent(0,            // flags
				  hAuditEvent,
				  NULL))) {        // reserved
	    ret = GetLastError();
	    Assert(!"Unable to log DS Repl Audit!");
	}

	if ( hAuditEvent ) {
	    AuthzFreeAuditEvent( hAuditEvent );
	}

    }
    __except(1) {
	Assert(!"Audit logging operations shouldn't accept!  Contact DsRepl!");
	if (ret!=ERROR_SUCCESS) {
	    ret = ERROR_EXCEPTION_IN_SERVICE;
	}
    }

    return ret;
}

ULONG
DRA_AuditLog_ReplicaGen(
    THSTATE *pTHS,
    ULONG    AuditId,
    LPWSTR   pszDestinationDRA,
    LPWSTR   pszSourceDRA,
    LPWSTR   pszSourceAddr,
    LPWSTR   pszNC,
    ULONG    ulOptions,
    ULONG    ulError
    ) 
/*++

Routine Description:

    Call the audit logging for logging of the form:

    //  %tDestination DRA:%t%1%n
    //  %tSource DRA:%t%2%n
    //  %tSource Addr:%t%3%n
    //  %tNaming Context:%t%4%n
    //  %tOptions:%t%5%n
    //  %tStatus Code:%t%6%n

Arguments:

    pTHS - 
    AuditId - Type of Audit must be either  
		SE_AUDITID_REPLICA_SOURCE_NC_ESTABLISHED
		SE_AUDITID_REPLICA_SOURCE_NC_REMOVED
		SE_AUDITID_REPLICA_SOURCE_NC_MODIFIED
		SE_AUDITID_REPLICA_DEST_NC_MODIFIED
    pszDestinationDRA - see above logging params
    pszSourceDRA -
    pszSourceAddr -
    pszNC -
    ulOptions -
    ulError - Status Code
      
Return Value:

    WINERROR

--*/
{   
    ULONG ret = ERROR_SUCCESS;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent = NULL;
    AUDIT_PARAMS AuditParams = {0};
    
    /*
    
	Okay, we have only 6 params to audit, why do we need to define
	the AUDIT_PARAM array to size 8?  The short story is because
	it works.  The long story is that there are always two hidden parameters
	to log with every audit, the SID of the user to log and the
	subsystem.  For the first param, in our case, we want it logged 
	under local system, so we don't need to do anything or impersonate.  
	The second param is the subsystem, in our case, "DS Access".  The use
	of the ghAuthzRM get's that for us.  
	
	Why do we have to allocate space for these params?  See
	AuthziInitializeAuditParamsWithRM for questions.  
    
    */
    
    AUDIT_PARAM ParamArray[8];
    USHORT NUM_AUDIT_PARAMS = 6;

    // only use for certian audit calls.
    Assert((AuditId>=SE_AUDITID_REPLICA_SOURCE_NC_ESTABLISHED) && (AuditId<=SE_AUDITID_REPLICA_DEST_NC_MODIFIED));

    // validate params
    if ((pszDestinationDRA==NULL) && (pszSourceDRA==NULL) && (pszNC==NULL)) {
	// there isn't anything to log?

	// this had better be due to some catastrophic error.
	Assert(ulError!=ERROR_SUCCESS);
	ret = ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory( ParamArray, sizeof(AUDIT_PARAM)*NUM_AUDIT_PARAMS );

    if ((ret==ERROR_SUCCESS) && 
	(!DraAuthziInitializeAuditEventTypeWrapper(0, 
						   SE_CATEGID_DS_ACCESS, 
						   (USHORT) AuditId, 
						   NUM_AUDIT_PARAMS, 
						   &hAuditEventType))) {
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Event Type!");
    }

    AuditParams.Parameters = ParamArray;
    Assert(ghAuthzRM);

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziInitializeAuditParamsWithRM(APF_AuditSuccess,
					    ghAuthzRM,
					    NUM_AUDIT_PARAMS,
					    &AuditParams,
					    APT_String,     SAFE_AUDIT_STRING(pszDestinationDRA),
					    APT_String,     SAFE_AUDIT_STRING(pszSourceDRA),
					    APT_String,     SAFE_AUDIT_STRING(pszSourceAddr),
					    APT_String,     SAFE_AUDIT_STRING(pszNC),
					    APT_Ulong,      ulOptions,
					    APT_Ulong,      ulError
					    ))) { 
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Parameters!");
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziInitializeAuditEvent(0,            // flags
				     ghAuthzRM,         // resource manager
				     hAuditEventType,
				     &AuditParams,
				     NULL,         // hAuditQueue
				     INFINITE,     // time out
				     L"", L"", L"", L"", // obj access strings
				     &hAuditEvent))) {
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Event!");
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziLogAuditEvent(0,            // flags
			      hAuditEvent,
			      NULL))) {        // reserved
	ret = GetLastError();
	Assert(!"Unable to log DS Repl Audit!");
    }

    if ( hAuditEvent ) {
	AuthzFreeAuditEvent( hAuditEvent );
    }

    return ret;  
}


ULONG
DRA_AuditLog_ReplicaSync_Begin_Helper( 
    THSTATE *pTHS,
    DSNAME * pDSA,
    LPWSTR   pszDSA,
    DSNAME * pNC,
    ULONG    ulOptions
    )
/*++

Routine Description:

    Help to log info for the beginning of a DRA_ReplicaSync call.

Arguments:

    pTHS - 
    pDSA - DSA to sync from 
    pszDSA - identifying string for sync source
    pNC - NC to sync
    ulOptions - options to DRA_ReplicaSync
      
Return Value:

    WINERROR

--*/
{
    ULONG ret = ERROR_SUCCESS;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent = NULL;
    AUDIT_PARAMS AuditParams = {0};
    AUDIT_PARAM ParamArray[8];
    USHORT NUM_AUDIT_PARAMS = 6;

    BOOL fRpcFree = FALSE;
    ULONG ulSessionID = ++gulSyncSessionID;
    USN usnStart = DraGetCursorUsnForDsa(pTHS,
					 pDSA,     
					 pNC);
    LPWSTR pszUSNStart = USNToString(pTHS, usnStart);

    RtlZeroMemory( ParamArray, sizeof(AUDIT_PARAM)*NUM_AUDIT_PARAMS );

    if ((ret==ERROR_SUCCESS) && 
	(!DraAuthziInitializeAuditEventTypeWrapper(0, 
						   SE_CATEGID_DS_ACCESS, 
						   (USHORT) SE_AUDITID_REPLICA_SOURCE_NC_SYNC_BEGINS, 
						   NUM_AUDIT_PARAMS, 
						   &hAuditEventType))) {
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Event Type!");
    }

    AuditParams.Parameters = ParamArray;
    Assert(ghAuthzRM);

    if ((pszDSA==NULL) && (pDSA->NameLen>0)) {
	pszDSA = pDSA->StringName;
    } else if ((pszDSA==NULL) && (!fNullUuid(&(pDSA->Guid)))) {
	DsUuidToStringW(&(pDSA->Guid),&pszDSA); 
	fRpcFree = TRUE;
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziInitializeAuditParamsWithRM(APF_AuditSuccess,
					    ghAuthzRM,
					    NUM_AUDIT_PARAMS,
					    &AuditParams,
					    APT_String,     SAFE_AUDIT_STRING(SAFE_STRING_NAME(gAnchor.pDSADN)),
					    APT_String,     SAFE_AUDIT_STRING(pszDSA),
					    APT_String,     SAFE_AUDIT_STRING(SAFE_STRING_NAME(pNC)),
					    APT_Ulong,      ulOptions,
					    APT_Ulong,      ulSessionID,
					    APT_String,     SAFE_AUDIT_STRING(pszUSNStart)
					    ))) { 
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Parameters!");
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziInitializeAuditEvent(0,            // flags
				     ghAuthzRM,         // resource manager
				     hAuditEventType,
				     &AuditParams,
				     NULL,         // hAuditQueue
				     INFINITE,     // time out
				     L"", L"", L"", L"", // obj access strings
				     &hAuditEvent))) {
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Event!");
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziLogAuditEvent(0,            // flags
			      hAuditEvent,
			      NULL))) {        // reserved
	ret = GetLastError();
	Assert(!"Unable to log DS Repl Audit!");
    }

    if ( hAuditEvent ) {
	AuthzFreeAuditEvent( hAuditEvent );
    }

    if (fRpcFree && pszDSA) {
	RpcStringFreeW(&pszDSA); 
    }

    if (pszUSNStart) {
	THFreeEx(pTHS, pszUSNStart);
    }

    return ret;
}


ULONG
DRA_AuditLog_ReplicaSync_Begin( 
    THSTATE *pTHS,
    LPWSTR   pszSourceDRA,
    UUID *   puuidSource,
    DSNAME * pNC,
    ULONG    ulOptions
    )
/*++

Routine Description:

    Log info for the beginning of a DRA_ReplicaSync call.

Arguments:

    pTHS - 
    pszSourceDRA - source of sync
    puuidSource - uuid of source ntdsa settings object
    pNC - NC to sync
    ulOptions - options to DRA_ReplicaSync
      
Return Value:

    WINERROR

--*/
{

    DSNAME * pDSA = NULL;
    ULONG ret = ERROR_SUCCESS;

    __try {
	if (ulOptions & DRS_SYNC_ALL) {
	    // we don't want/need to audit this, it simply
	    // generates a sync for each NC and we'll
	    // audit those.
	    ret = ERROR_SUCCESS;
	    __leave;
	}

	if (ulOptions & DRS_SYNC_BYNAME) {
	    // this had better be a guid base dns-name!
	    Assert(IsGuidBasedDNSName(pszSourceDRA));
	    pDSA = DSNameFromAddr(pTHS, pszSourceDRA);
	} else {
	    pDSA = draGetServerDsNameFromGuid(pTHS, Idx_ObjectGuid, puuidSource);   
	}

	Assert(pDSA);

	ret = DRA_AuditLog_ReplicaSync_Begin_Helper(pTHS, pDSA, pszSourceDRA, pNC, ulOptions);

	if (pDSA) {
	    THFreeEx(pTHS, pDSA);
	}
    }
    __except(GetDraException((GetExceptionInformation()), &ret)) {
	ret = DRA_AuditLog_Failure_Begin(pTHS, DS_REPL_OP_TYPE_SYNC, ret);
    }

    return ret;
    
}

ULONG
DRA_AuditLog_ReplicaSync_End_Helper( 
    THSTATE *pTHS,
    DSNAME * pDSA,
    LPWSTR   pszDSA,
    DSNAME * pNC,
    ULONG    ulOptions,
    USN_VECTOR * pusn,
    ULONG    ulError
    )
/*++

Routine Description:

    Log info after completion (success or failure) of a DRA_ReplicaSync call.

Arguments:

    pTHS - 
    pDSA - DC to sync from
    pszDSA - string name of DC to sync form
    pNC - NC to sync
    ulOptions - options to DRA_ReplicaSync
    pusn - optional usn vector that was sync'ed to.
    ulError - status
      
Return Value:

    WINERROR

--*/
{
    ULONG ret = ERROR_SUCCESS;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent = NULL;
    AUDIT_PARAMS AuditParams = {0};
    AUDIT_PARAM ParamArray[9];
    USHORT NUM_AUDIT_PARAMS = 7;

    BOOL fRpcFree = FALSE;
    ULONG ulSessionID = gulSyncSessionID;
    
    USN usnEnd = pusn ? 
	max(pusn->usnHighObjUpdate,DraGetCursorUsnForDsa(pTHS, 
							 pDSA,	
							 pNC)) 
    : DraGetCursorUsnForDsa(pTHS, 
			    pDSA,	
			    pNC);
    
    LPWSTR pszUSNEnd = USNToString(pTHS, usnEnd);
    
    RtlZeroMemory( ParamArray, sizeof(AUDIT_PARAM)*NUM_AUDIT_PARAMS );

    if ((ret==ERROR_SUCCESS) && 
	(!DraAuthziInitializeAuditEventTypeWrapper(0, 
						   SE_CATEGID_DS_ACCESS, 
						   (USHORT) SE_AUDITID_REPLICA_SOURCE_NC_SYNC_ENDS, 
						   NUM_AUDIT_PARAMS, 
						   &hAuditEventType))) {
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Event Type!");
    }

    AuditParams.Parameters = ParamArray;
    Assert(ghAuthzRM);

    if ((pszDSA==NULL) && (pDSA->NameLen>0)) {
	pszDSA = pDSA->StringName;
    } else if ((pszDSA==NULL) && (!fNullUuid(&(pDSA->Guid)))) {
	DsUuidToStringW(&(pDSA->Guid),&pszDSA); 
	fRpcFree = TRUE;
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziInitializeAuditParamsWithRM(APF_AuditSuccess,
					    ghAuthzRM,
					    NUM_AUDIT_PARAMS,
					    &AuditParams,
					    APT_String,     SAFE_AUDIT_STRING(SAFE_STRING_NAME(gAnchor.pDSADN)),
					    APT_String,     SAFE_AUDIT_STRING(pszDSA),
					    APT_String,     SAFE_AUDIT_STRING(SAFE_STRING_NAME(pNC)),
					    APT_Ulong,      ulOptions,
					    APT_Ulong,      ulSessionID,
					    APT_String,     SAFE_AUDIT_STRING(pszUSNEnd),
					    APT_Ulong,      ulError
					    ))) { 
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Parameters!");
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziInitializeAuditEvent(0,            // flags
				     ghAuthzRM,         // resource manager
				     hAuditEventType,
				     &AuditParams,
				     NULL,         // hAuditQueue
				     INFINITE,     // time out
				     L"", L"", L"", L"", // obj access strings
				     &hAuditEvent))) {
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Event!");
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziLogAuditEvent(0,            // flags
			      hAuditEvent,
			      NULL))) {        // reserved
	ret = GetLastError();
	Assert(!"Unable to log DS Repl Audit!");
    }

    if ( hAuditEvent ) {
	AuthzFreeAuditEvent( hAuditEvent );
    }
    

    if (fRpcFree && pszDSA) {
	RpcStringFreeW(&pszDSA); 
    }

    if (pszUSNEnd) {
	THFreeEx(pTHS, pszUSNEnd);
    }

    return ret;
}

ULONG
DRA_AuditLog_ReplicaSync_End( 
    THSTATE *pTHS,
    LPWSTR   pszSourceDRA,
    UUID *   puuidSource,
    DSNAME * pNC,
    ULONG    ulOptions,
    USN_VECTOR *pusn,
    ULONG    ulError
    )
/*++

Routine Description:

    Log info after completion (success or failure) of a DRA_ReplicaSync call.

Arguments:

    pTHS - 
    pszSourceDRA - source of sync
    puuidSource - uuid of source ntdsa settings object
    pNC - NC to sync
    ulOptions - options to DRA_ReplicaSync
    ulError - status
      
Return Value:

    WINERROR

--*/
{
    ULONG ret = ERROR_SUCCESS;
    DSNAME * pDSA = NULL;
    __try {
	if (ulOptions & DRS_SYNC_ALL) {
	    // we don't want/need to audit this, it simply
	    // generates a sync for each NC and we'll
	    // audit those.
	    ret = ERROR_SUCCESS;
	    __leave;
	}

	if (ulOptions & DRS_SYNC_BYNAME) { 
	    // this had better be a guid base dns-name!
	    Assert(IsGuidBasedDNSName(pszSourceDRA));
	    pDSA = DSNameFromAddr(pTHS, pszSourceDRA);
	} else {
	    pDSA = draGetServerDsNameFromGuid(pTHS, Idx_ObjectGuid, puuidSource);   
	}

	Assert(pDSA);

	ret = DRA_AuditLog_ReplicaSync_End_Helper(pTHS, pDSA, pszSourceDRA, pNC, ulOptions, pusn, ulError);

	if (pDSA) {
	    THFreeEx(pTHS, pDSA);
	}
    }
    __except(GetDraException((GetExceptionInformation()), &ret)) {
	ret = DRA_AuditLog_Failure_End(pTHS, DS_REPL_OP_TYPE_SYNC, ret, ulError);
    }
    return ret;
}

ULONG
DRA_AuditLog_ReplicaAdd_Begin( 
    THSTATE *pTHS,
    DSNAME * pSource,
    MTX_ADDR * pmtx_addrSource,
    DSNAME * pNC,
    ULONG    ulOptions
    )
/*++

Routine Description:

    Log info for the beginning of a DRA_ReplicaAdd call.  This is required
    because add may begin a sync immediately after adding the nc.

Arguments:

    pTHS - 
    pSource - source of call
    pmtx_addrSource - mtx addr of source
    pNC - NC being added
    ulOptions - options to DRA_ReplicaAdd
      
Return Value:

    WINERROR

--*/
{
    ULONG ret = ERROR_SUCCESS;
    LPWSTR pszSourceAddr = NULL;
    DSNAME * pDSA = NULL;
    DSNAME * pDSAAlloc = NULL;

    __try {
	pszSourceAddr = (pmtx_addrSource) ? TransportAddrFromMtxAddrEx(pmtx_addrSource) : NULL;
	// if the options doesn't have async replication, then it will initiate a sync right away.
	// we don't have uloptions for ReplicaSync because it isn't directly called.
	// in the future we could do some "first sync" fake option just for the log...
	if (!(ulOptions & DRS_ASYNC_REP)) {
	    if ((pSource) && (!fNullUuid(&(pSource->Guid)))) { 
		pDSA = pSource;
	    } else if (IsGuidBasedDNSName(pszSourceAddr)) {
		pDSAAlloc = pDSA = DSNameFromAddr(pTHS, pszSourceAddr);
	    } 

	    // pDSA can be null here.  If adding a new NC from a source, you might not have the source
	    // GUID or full name.  

	    ret = DRA_AuditLog_ReplicaSync_Begin_Helper(pTHS,
							pDSA,
							pszSourceAddr,
							pNC,
							0);
	}

	if (pszSourceAddr) {
	    THFreeEx(pTHS, pszSourceAddr);
	}
	if (pDSAAlloc) {
	    THFreeEx(pTHS, pDSAAlloc);
	}
    }
    __except(GetDraException((GetExceptionInformation()), &ret)) {
	ret = DRA_AuditLog_Failure_Begin(pTHS, DS_REPL_OP_TYPE_ADD, ret);
    }
    return ret;
}

ULONG
DRA_AuditLog_ReplicaAdd_End(
    THSTATE *pTHS,
    DSNAME * pSource,
    MTX_ADDR * pmtx_addrSource,
    DSNAME * pNC,
    ULONG    ulOptions,
    GUID     uuidDsaObjSrc,
    ULONG    ulError)
/*++

Routine Description:

    Log info for DRA_ReplicaAdd

Arguments:

    pTHS - 
    pSource - source of call
    pmtx_addrSource - mtx addr of source
    pNC - NC being added
    ulOptions - options to DRA_ReplicaAdd
    uuidDsaObjSrc - guid of DRA_ReplicaAdd src ntds settings object
    ulError - Error value from DRA_ReplicaAdd
      
Return Value:

    WINERROR

--*/
{
    ULONG ret = ERROR_SUCCESS;
    ULONG ret1 = ERROR_SUCCESS;
    LPWSTR pszSourceAddr = NULL;
    DSNAME * pDSA = NULL;
    DSNAME * pDSAAlloc = NULL;

    __try {
	pszSourceAddr = (pmtx_addrSource) ? TransportAddrFromMtxAddrEx(pmtx_addrSource) : NULL;
	// if the options don't contain async repl, then it attempted/intiated a sync.
	if (!(ulOptions & DRS_ASYNC_REP)) {
	    if ((pSource) && (!fNullUuid(&(pSource->Guid)))) { 
		pDSA = pSource;
	    } else if (IsGuidBasedDNSName(pszSourceAddr)) {
		pDSAAlloc = pDSA = DSNameFromAddr(pTHS, pszSourceAddr);
	    } else if (!fNullUuid(&uuidDsaObjSrc)) {
		pDSAAlloc = pDSA = draGetServerDsNameFromGuid(pTHS, Idx_ObjectGuid, &uuidDsaObjSrc);
	    }

	    // if we don't have pDSA here, then DRA_ReplicaAdd *must* have excepted or failed.  We'll
	    // log a corresponding sync end with USN of 0 - which is what it was for the sync begin
	    // of this new NC.
	    Assert(pDSA || (ulError!=ERROR_SUCCESS));

	    ret1 = DRA_AuditLog_ReplicaSync_End_Helper(pTHS,
						       pDSA,
						       pszSourceAddr,
						       pNC,
						       0,
						       NULL,
						       ulError);
	}

	ret = DRA_AuditLog_ReplicaGen(pTHS,
				      SE_AUDITID_REPLICA_SOURCE_NC_ESTABLISHED,
				      SAFE_STRING_NAME(gAnchor.pDSADN),
				      SAFE_STRING_NAME(pSource),
				      pszSourceAddr,
				      SAFE_STRING_NAME(pNC),
				      ulOptions,
				      ulError);

	if (pDSAAlloc) {
	    THFreeEx(pTHS, pDSAAlloc);
	}
	if (pszSourceAddr) {
	    THFreeEx(pTHS, pszSourceAddr);
	}

    }
    __except(GetDraException((GetExceptionInformation()), &ret)) {
	ret = DRA_AuditLog_Failure_End(pTHS, DS_REPL_OP_TYPE_ADD, ret, ulError);
    }

    return ret1 ? ret1 : ret;
}

ULONG 
DRA_AuditLog_ReplicaDel(
    THSTATE *pTHS,
    MTX_ADDR * pmtx_addrSource,
    DSNAME * pNC,
    ULONG    ulOptions,
    ULONG    ulError)
/*++

Routine Description:

    Log info for DRA_ReplicaDel

Arguments:

    pTHS - 
    pmtx_addrSource - mtx addr of source
    pNC - NC being deleted
    ulOptions - options to DRA_ReplicaDel
    ulError - Error value from DRA_ReplicaDel
      
Return Value:

    WINERROR

--*/
{
    ULONG ret = ERROR_SUCCESS;
    LPWSTR pszSourceAddr = (pmtx_addrSource) ? TransportAddrFromMtxAddrEx(pmtx_addrSource) : NULL;

    __try {
	ret = DRA_AuditLog_ReplicaGen(pTHS,
				      SE_AUDITID_REPLICA_SOURCE_NC_REMOVED,
				      SAFE_STRING_NAME(gAnchor.pDSADN),
				      NULL,
				      pszSourceAddr,
				      SAFE_STRING_NAME(pNC),
				      ulOptions,
				      ulError);

	if (pszSourceAddr) {
	    THFreeEx(pTHS, pszSourceAddr);
	}
    }
    __except(GetDraException((GetExceptionInformation()), &ret)) {
	ret = DRA_AuditLog_Failure_End(pTHS, DS_REPL_OP_TYPE_DELETE, ret, ulError);
    }
    
    return ret;
}

ULONG
DRA_AuditLog_ReplicaModify(
    THSTATE *pTHS,
    MTX_ADDR * pmtx_addrSource,
    GUID * pGuidSource,
    DSNAME * pNC,
    ULONG    ulOptions,
    ULONG    ulError)
/*++

Routine Description:

    Log info for DRA_ReplicaModify

Arguments:

    pTHS - 
    pmtx_addrSource - mtx addr of source
    pGuidSource - Guid of source
    pNC - NC being modified
    ulOptions - options to DRA_ReplicaModify
    ulError - Error value from DRA_ReplicaModify
      
Return Value:

    WINERROR

--*/
{
    ULONG ret = ERROR_SUCCESS;
    LPWSTR pszSourceAddr = NULL;
    BOOL fRpcFree = FALSE;

    __try {
	pszSourceAddr = (pmtx_addrSource) ? TransportAddrFromMtxAddrEx(pmtx_addrSource) : NULL;
	if ((pszSourceAddr==NULL) && !fNullUuid(pGuidSource)) { 
	    DsUuidToStringW(pGuidSource, &pszSourceAddr); 
	    fRpcFree = TRUE;
	}

	ret = DRA_AuditLog_ReplicaGen(pTHS,
				      SE_AUDITID_REPLICA_SOURCE_NC_MODIFIED,
				      SAFE_STRING_NAME(gAnchor.pDSADN),   
				      NULL,
				      pszSourceAddr,
				      SAFE_STRING_NAME(pNC),
				      ulOptions,
				      ulError);

	if (pszSourceAddr) {
	    if (!fRpcFree) {
		THFreeEx(pTHS, pszSourceAddr);
	    } else {
		RpcStringFreeW(&pszSourceAddr);
	    }
	}
    }
    __except(GetDraException((GetExceptionInformation()), &ret)) {
	ret = DRA_AuditLog_Failure_End(pTHS, DS_REPL_OP_TYPE_MODIFY, ret, ulError);
    }

    return ret;
}

ULONG 
DRA_AuditLog_UpdateRefs(
    THSTATE *pTHS,
    MTX_ADDR * pmtx_addrDestination,
    GUID * pGuidDestination,
    DSNAME * pNC,
    ULONG    ulOptions,
    ULONG    ulError)
/*++

Routine Description:

    Log info for DRA_UpdateRefs

Arguments:

    pTHS - 
    pmtx_addrDestination - mtx addr of destination
    pGuidDestination - Guid of destination
    pNC - NC being updated
    ulOptions - options to DRA_UpdateRefs
    ulError - Error value from DRA_UpdateRefs
      
Return Value:

    WINERROR

--*/
{
    ULONG ret = ERROR_SUCCESS;
    LPWSTR pszDestinationAddr = NULL;
    BOOL fRpcFree = FALSE;

    __try {
	pszDestinationAddr = (pmtx_addrDestination) ? TransportAddrFromMtxAddrEx(pmtx_addrDestination) : NULL;
	if ((pszDestinationAddr==NULL) && !fNullUuid(pGuidDestination)) {
	    DsUuidToStringW(pGuidDestination,&pszDestinationAddr); 
	    fRpcFree = TRUE;
	}

	ret = DRA_AuditLog_ReplicaGen(pTHS,
				      SE_AUDITID_REPLICA_DEST_NC_MODIFIED,
				      pszDestinationAddr,
				      SAFE_STRING_NAME(gAnchor.pDSADN),
				      NULL,
				      SAFE_STRING_NAME(pNC),
				      ulOptions,
				      ulError);

	if (pszDestinationAddr) {
	    if (!fRpcFree) {
		THFreeEx(pTHS, pszDestinationAddr);
	    } else {
		RpcStringFreeW(&pszDestinationAddr);
	    }
	}
    }
    __except(GetDraException((GetExceptionInformation()), &ret)) {
	ret = DRA_AuditLog_Failure_End(pTHS, DS_REPL_OP_TYPE_UPDATE_REFS, ret, ulError);
    }

    return ret;
}

ULONG
DRA_AuditLog_UpdateGen(
    THSTATE * pTHS,
    LPWSTR    pszObj,
    LPWSTR    pszAttrType,
    ULONG     typeChange,
    UNICODE_STRING usAttrVal,
    USN       usn,
    ULONG     ulSessionID,
    ULONG     ulError)
/*++

Routine Description:

    Call the audit logging for logging of the form:
	
	//  %tSession ID:%t%1%n
	//  %tObject:%t%2%n
	//  %tAttribute:%t%3%n
	//  %tType of change:%t%4%n
	//  %tNew Value:%t%5%n
	//  %tUSN:%t%6%n
	//  %tStatus Code:%t%7%n

Arguments:

    pTHS - 
    pszObj - object which is being updated
    pszAttrType - string name of the attribute updated
    typeChange - must be either: 
	//		UPDATE_NOT_UPDATED, 
	//		UPDATE_INSTANCE_TYPE, 
	//		UPDATE_OBJECT_UPDATE, 
	//		UPDATE_OBJECT_CREATION, 
	//		UPDATE_VALUE_UPDATE, 
	//		UPDATE_VALUE_CREATION
    
    usAttrVal - UNICODE_STRING of the value of the attr being updated in Hex representation
    usn - local usn
    ulSessionID - session id 
    ulError - success or failure of update
      
Return Value:

    WINERROR

--*/
{
    ULONG ret = ERROR_SUCCESS;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent = NULL;
    AUDIT_PARAMS AuditParams = {0};
    AUDIT_PARAM ParamArray[9];
    USHORT NUM_AUDIT_PARAMS = 7;

    LPWSTR pszUSN = USNToString(pTHS, usn);

    RtlZeroMemory( ParamArray, sizeof(AUDIT_PARAM)*NUM_AUDIT_PARAMS );

    if ((ret==ERROR_SUCCESS) && 
	(!DraAuthziInitializeAuditEventTypeWrapper(0, 
						   SE_CATEGID_DS_ACCESS, 
						   (USHORT) SE_AUDITID_REPLICA_OBJ_ATTR_REPLICATION, 
						   NUM_AUDIT_PARAMS, 
						   &hAuditEventType))) {
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Event Type!");
    }

    AuditParams.Parameters = ParamArray;
    Assert(ghAuthzRM);

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziInitializeAuditParamsWithRM(APF_AuditSuccess,
					    ghAuthzRM,
					    NUM_AUDIT_PARAMS,
					    &AuditParams,
					    APT_Ulong,      ulSessionID,
					    APT_String,     SAFE_AUDIT_STRING(pszObj),
					    APT_String,     SAFE_AUDIT_STRING(pszAttrType),
					    APT_Ulong,      typeChange,
					    APT_String,     usAttrVal.Buffer,
					    APT_String,     SAFE_AUDIT_STRING(pszUSN),
					    APT_Ulong,      ulError
					    ))) { 
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Parameters!");
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziInitializeAuditEvent(0,            // flags
				     ghAuthzRM,         // resource manager
				     hAuditEventType,
				     &AuditParams,
				     NULL,         // hAuditQueue
				     INFINITE,     // time out
				     L"", L"", L"", L"", // obj access strings
				     &hAuditEvent))) {
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Event!");
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziLogAuditEvent(0,            // flags
			      hAuditEvent,
			      NULL))) {        // reserved
	ret = GetLastError();
	Assert(!"Unable to log DS Repl Audit!");
    }

    if ( hAuditEvent ) {
	AuthzFreeAuditEvent( hAuditEvent );
    }
    
    if (pszUSN) {
	THFreeEx(pTHS, pszUSN);
    }

    return ret;
}

ULONG
DRA_AuditLog_UpdateRepObj(
    THSTATE * pTHS,
    ULONG     ulSessionID,
    DSNAME *  pObj,
    ATTRBLOCK attrBlock,
    USN       usn,
    ULONG     ulUpdateStatus,
    ULONG     ulError)
/*++

Routine Description:

    Log info for UpdateRepObj

Arguments:

    pTHS - 
    ulSessionID - SessionID
    pObj - object being updated
    attrBlock - block of attributes being updated
    usn - local usn at time of update
    ulUpdateStatus - type of update made
    ulError - success of UpdateRepObj
      
Return Value:

    WINERROR

--*/
{
    ULONG i,j;
    UNICODE_STRING * pusAttr = NULL;
    LPWSTR pszAttrName = NULL;
    ULONG ret = 0;
    ULONG ret2 = 0;
    ATTCACHE * pAC = NULL;

    __try {
	for (i=0; i < attrBlock.attrCount; i++) {
	    if (DBIsSecretData(attrBlock.pAttr[i].attrTyp)) {
		continue;
	    }

	    // okay, first, find an attribute cache
	    pAC = SCGetAttById(pTHS, attrBlock.pAttr[i].attrTyp);
	    if (pAC==NULL) {
		continue;
	    }
	    pszAttrName = UnicodeStringFromString8(CP_UTF8, pAC->name, (pAC->nameLen + 1)*sizeof(UCHAR));

	    // log one entry for each value...
	    for (j=0; j < attrBlock.pAttr[i].AttrVal.valCount; j++) {
		pusAttr = UStringFromAttrVal(pTHS, attrBlock.pAttr[i].AttrVal.pAVal[j]);
		Assert(pusAttr);

		ret2 = DRA_AuditLog_UpdateGen(pTHS, 
					      SAFE_STRING_NAME(pObj),
					      pszAttrName,
					      ulUpdateStatus,
					      *pusAttr,
					      usn,
					      ulSessionID,
					      ulError);
		if (pusAttr) {
		    THFreeEx(pTHS, pusAttr);
		    pusAttr = NULL;
		}

		ret = ret ? ret : ret2;
	    }

	    if (pszAttrName) {
		THFreeEx(pTHS, pszAttrName);
		pszAttrName = NULL;
	    }
	}
    }
    __except(GetDraException((GetExceptionInformation()), &ret)) {
	ret = DRA_AuditLog_Failure_End(pTHS, DS_REPL_OP_TYPE_SYNC, ret, ulError);
    }

    return ret;
}

ULONG
DRA_AuditLog_UpdateRepValue(
    THSTATE * pTHS,
    ULONG ulSessionID,
    REPLVALINF * pReplValInf,
    USN usn,
    ULONG ulUpdateValueStatus,
    ULONG ulError)
/*++

Routine Description:

    Log info for UpdateRepValue

Arguments:

    pTHS - 
    ulSessionID - SessionID
    pReplValInf - object, attr, and value info for update
    usn - local usn at time of update
    ulUpdateValueStatus - type of update made
    ulError - success of UpdateRepValue
      
Return Value:

    WINERROR

--*/
{
    UNICODE_STRING * pusVal = NULL;
    LPWSTR pszAttrName = NULL;
    ULONG ret = 0;
    ATTCACHE * pAC = NULL;
    LPWSTR pszObj = NULL;
    WCHAR pszObjUuid[SZUUID_LEN];

    __try {

	if (DBIsSecretData(pReplValInf->attrTyp)) {
	    return ERROR_SUCCESS;
	}

	if ((pReplValInf==NULL) || (pReplValInf->pObject==NULL)) {
	    Assert(!"Replication Audit Logging Error:  Nothing to log!\n");
	    return ERROR_INTERNAL_ERROR;
	}

	pAC = SCGetAttById(pTHS, pReplValInf->attrTyp);
	if (pAC==NULL) {
	    return ERROR_INTERNAL_ERROR;
	}
	pszAttrName = UnicodeStringFromString8(CP_UTF8, pAC->name, (pAC->nameLen + 1)*sizeof(UCHAR));

	pusVal = UStringFromAttrVal(pTHS, pReplValInf->Aval);
	Assert(pusVal);

	pszObj = SAFE_STRING_NAME(pReplValInf->pObject);
	if (pszObj == NULL) {
	    if (DsUuidToStructuredStringW(&(pReplValInf->pObject->Guid), pszObjUuid) !=NULL) { 
		pszObj=pszObjUuid;
	    }
	}

	ret = DRA_AuditLog_UpdateGen(pTHS, 
				     pszObj,
				     pszAttrName,
				     ulUpdateValueStatus,
				     *pusVal,
				     usn,
				     ulSessionID,
				     ulError);
	if (pusVal) {
	    THFreeEx(pTHS, pusVal);
	    pusVal = NULL;
	}

	if (pszAttrName) {
	    THFreeEx(pTHS, pszAttrName);
	    pszAttrName = NULL;
	}
    }
    __except(GetDraException((GetExceptionInformation()), &ret)) {
	ret = DRA_AuditLog_Failure_End(pTHS, DS_REPL_OP_TYPE_SYNC, ret, ulError);
    }

    return ret;
}

ULONG
DRA_AuditLog_LingeringObj_Removal_Helper( 
    THSTATE *pTHS,
    DSNAME * pDSA,
    LPWSTR   pszDSA,
    DSNAME * pDN,
    ULONG    ulOptions,	
    ULONG    ulError
    )
/*++

Routine Description:

    Log info after completion (success or failure) of a Lingering Object removal deletion.

Arguments:

    pTHS - 
    pDSA - DC to sync LO from
    pszDSA - string name of DC to sync from
    ulOptions - options
    pDN - object attempting to delete
    ulError - status 
      
Return Value:

    WINERROR

--*/
{
    ULONG ret = ERROR_SUCCESS;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent = NULL;
    AUDIT_PARAMS AuditParams = {0};
    AUDIT_PARAM ParamArray[7];
    USHORT NUM_AUDIT_PARAMS = 5;

    BOOL fRpcFree = FALSE;

    RtlZeroMemory( ParamArray, sizeof(AUDIT_PARAM)*NUM_AUDIT_PARAMS );

    if ((ret==ERROR_SUCCESS) && 
	(!DraAuthziInitializeAuditEventTypeWrapper(0, 
						   SE_CATEGID_DS_ACCESS, 
						   (USHORT) SE_AUDITID_REPLICA_LINGERING_OBJECT_REMOVAL, 
						   NUM_AUDIT_PARAMS, 
						   &hAuditEventType))) {
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Event Type!");
    }

    AuditParams.Parameters = ParamArray;
    Assert(ghAuthzRM);

    if ((pszDSA==NULL) && (pDSA->NameLen>0)) {
	pszDSA = pDSA->StringName;
    } else if ((pszDSA==NULL) && (!fNullUuid(&(pDSA->Guid)))) {
	DsUuidToStringW(&(pDSA->Guid),&pszDSA); 
	fRpcFree = TRUE;
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziInitializeAuditParamsWithRM(APF_AuditSuccess,
					    ghAuthzRM,
					    NUM_AUDIT_PARAMS,
					    &AuditParams,
					    APT_String,     SAFE_AUDIT_STRING(SAFE_STRING_NAME(gAnchor.pDSADN)),
					    APT_String,     SAFE_AUDIT_STRING(pszDSA),
					    APT_String,     SAFE_AUDIT_STRING(SAFE_STRING_NAME(pDN)),
					    APT_Ulong,      ulOptions,	
					    APT_Ulong,      ulError
					    ))) { 
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Parameters!");
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziInitializeAuditEvent(0,            // flags
				     ghAuthzRM,         // resource manager
				     hAuditEventType,
				     &AuditParams,
				     NULL,         // hAuditQueue
				     INFINITE,     // time out
				     L"", L"", L"", L"", // obj access strings
				     &hAuditEvent))) {
	ret = GetLastError();
	Assert(!"Unable to initialize DS Repl Audit Event!");
    }

    if ((ret==ERROR_SUCCESS) && 
	(!AuthziLogAuditEvent(0,            // flags
			      hAuditEvent,
			      NULL))) {        // reserved
	ret = GetLastError();
	Assert(!"Unable to log DS Repl Audit!");
    }

    if ( hAuditEvent ) {
	AuthzFreeAuditEvent( hAuditEvent );
    }
    

    if (fRpcFree && pszDSA) {
	RpcStringFreeW(&pszDSA); 
    }

    return ret;
}

ULONG
DRA_AuditLog_LingeringObj_Removal( 
    THSTATE *pTHS,
    LPWSTR   pszSource,
    DSNAME * pDN,
    ULONG    ulOptions,
    ULONG    ulError
    )
{
    ULONG ret = ERROR_SUCCESS;
    DSNAME * pDSA = NULL;
    __try {
	
	Assert(!(ulOptions & DS_EXIST_ADVISORY_MODE));

        if (IsGuidBasedDNSName(pszSource)) {
	    pDSA = DSNameFromAddr(pTHS, pszSource); 	
	} 
	
	ret = DRA_AuditLog_LingeringObj_Removal_Helper(pTHS, pDSA, pszSource, pDN, ulOptions, ulError);
	
	if (pDSA) {
	    THFreeEx(pTHS, pDSA);
	}
    }
    __except(GetDraException((GetExceptionInformation()), &ret)) {
	ret = DRA_AuditLog_Failure_End(pTHS, DS_REPL_OP_TYPE_SYNC, ret, ulError);
    }

    return ret;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\dracrypt.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dracrypt.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Methods to sign/encrypt asynchronous (e.g., mail) replication messages.

DETAILS:

CREATED:

    3/5/98      Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <wincrypt.h>
#include <certca.h>
#include <cryptui.h>

#include <ntdsctr.h>                    // PerfMon hook support
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <attids.h>
#include <drs.h>                        // DRS_MSG_*
#include <anchor.h>

#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dsexcept.h"

#include "drserr.h"
#include "dramail.h"
#include "drautil.h"
#include "dsutil.h"

#include "debug.h"                      /* standard debugging header */
#define  DEBSUB "DRACRYPT:"             /* define the subsystem for debugging */

#include <fileno.h>
#define  FILENO FILENO_DRACRYPT


///////////////////////////////////////////////////////////////////////////////
//
//  MACROS
//

// Use this constant definition (or one similar to it) to define
// a single encoding type that can be used in all parameters and
// data members that require one or the other or both.
#define MY_ENCODING_TYPE (PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING)

// How frequently do we log an error if we have no DC certificate? (secs)
#define NO_CERT_LOG_INTERVAL (15 * 60)

// Various hooks for unit test harness.
#ifdef TEST_HARNESS

#undef THAllocEx
#define THAllocEx(pTHS, x) LocalAlloc(LPTR, x)

#undef THReAllocEx
#define THReAllocEx(pTHS, x, y) LocalReAlloc(x, y, LPTR)

#define THFree(x) LocalFree(x)

#undef DRA_EXCEPT
#define DRA_EXCEPT(x, y)                                                    \
    {                                                                       \
        CHAR sz[1024];                                                      \
        sprintf(sz, "DRA_EXCEPT(%d, 0x%x) @ line %d\n", x, y, __LINE__);    \
        OutputDebugString(sz);                                              \
        DebugBreak();                                                       \
        ExitProcess(-1);                                                    \
    }

#undef LogUnhandledError
#define LogUnhandledError(x)                                                \
    {                                                                       \
        CHAR sz[1024];                                                      \
        sprintf(sz, "LogUnhandledError(0x%x) @ line %d\n", x, __LINE__);    \
        OutputDebugString(sz);                                              \
        DebugBreak();                                                       \
        ExitProcess(-1);                                                    \
    }

#endif // #ifdef TEST_HARNESS


///////////////////////////////////////////////////////////////////////////////
//
//  LOCAL FUNCTION PROTOTYPES
//

PCCERT_CONTEXT
draGetDCCert(
    IN  THSTATE *   pTHS,
    IN  HCERTSTORE  hCertStore
    );

PDSNAME
draVerifyCertAuthorization(
    IN  THSTATE      *  pTHS,
    IN  PCCERT_CONTEXT  pCertContext
    );

#ifdef TEST_HARNESS
#define draIsDsaComputerObjGuid(x,y) (TRUE)
#else // #ifdef TEST_HARNESS
BOOL
draIsDsaComputerObjGuid(
    IN  GUID *      pComputerObjGuid,
    OUT PDSNAME *   ppNtdsDsaDN
    );
#endif // #else // #ifdef TEST_HARNESS


void
draGetCertArrayToSend(
    IN  THSTATE *           pTHS,
    IN  HCERTSTORE          hCertStore,
    OUT DWORD *             pcNumCerts,
    OUT PCCERT_CONTEXT **   prgpCerts
    );

void
draFreeCertArray(
    IN  DWORD               cNumCerts,
    IN  PCCERT_CONTEXT *    rgpCerts
    );

PCCERT_CONTEXT
WINAPI
draGetAndVerifySignerCertificate(
    IN  VOID *      pvGetArg,
    IN  DWORD       dwCertEncodingType,
    IN  PCERT_INFO  pSignerId,
    IN  HCERTSTORE  hCertStore
    );

CERT_ALT_NAME_ENTRY *
draGetCertAltNameEntry(
    IN  THSTATE *       pTHS,
    IN  PCCERT_CONTEXT  pCertContext,
    IN  DWORD           dwAltNameChoice,
    IN  LPSTR           pszOtherNameOID     OPTIONAL
    );


///////////////////////////////////////////////////////////////////////////////
//
//  GLOBAL FUNCTION IMPLEMENTATIONS
//

void
draSignMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pUnsignedMailRepMsg,
    OUT MAIL_REP_MSG ** ppSignedMailRepMsg
    )
/*++

Routine Description:

    Sign the given asynchronous replication message.

    This code is aware of variable length headers.

Arguments:

    pUnsignedMailRepMsg (IN) - Message to sign.
    
    ppSignedMailRepMsg (OUT) - On return, holds a pointer to the thread-
        allocated signed version of the message.

Return Values:

    None.  Throws DRA exception on failure.

--*/
{
    BYTE *                      MessageArray[1];
    DWORD                       MessageSizeArray[] = {pUnsignedMailRepMsg->cbDataSize};
    BOOL                        ok = FALSE;
    HCERTSTORE                  hStoreHandle = NULL;
    PCCERT_CONTEXT              pSignerCert = NULL;
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    CRYPT_SIGN_MESSAGE_PARA     SigParams;
    DWORD                       cbSignedData;
    MAIL_REP_MSG *              pSignedMailRepMsg;
    DWORD                       winError;
    PCCERT_CONTEXT *            rgpCertsToSend = NULL;
    DWORD                       cCertsToSend = 0;
    PCHAR                       pbDataIn, pbDataOut;

    Assert(NULL != MAIL_REP_MSG_DATA(pUnsignedMailRepMsg));

    __try {
        // Get a handle to a crytographic provider.
        hStoreHandle = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                     0,
                                     0,
                                     CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                     L"MY");
        if (!hStoreHandle) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }
        
        // Get our certificate plus the signing CAs' certificates.
        draGetCertArrayToSend(pTHS, hStoreHandle, &cCertsToSend,
                              &rgpCertsToSend);
        pSignerCert = rgpCertsToSend[0];

        // Initialize the Algorithm Identifier structure.
        memset(&HashAlgorithm, 0, sizeof(HashAlgorithm));
        HashAlgorithm.pszObjId = szOID_RSA_MD5;

        // Initialize the signature structure.
        memset(&SigParams, 0, sizeof(SigParams));
        SigParams.cbSize            = sizeof(SigParams);
        SigParams.dwMsgEncodingType = MY_ENCODING_TYPE;
        SigParams.pSigningCert      = pSignerCert;
        SigParams.HashAlgorithm     = HashAlgorithm;
        SigParams.cMsgCert          = cCertsToSend;
        SigParams.rgpMsgCert        = rgpCertsToSend;

        pbDataIn = MAIL_REP_MSG_DATA(pUnsignedMailRepMsg);
        MessageArray[0] = pbDataIn;

        // Get the size of the buffer needed to hold the signed data.
        ok = CryptSignMessage(
                  &SigParams,               // Signature parameters
                  FALSE,                    // Not detached
                  ARRAY_SIZE(MessageArray), // Number of messages
                  MessageArray,             // Messages to be signed
                  MessageSizeArray,         // Size of messages
                  NULL,                     // Buffer for signed msg
                  &cbSignedData);           // Size of buffer
        if (!ok) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }

        // Allocate memory for the signed blob.
        pSignedMailRepMsg = THAllocEx(pTHS,
                                      pUnsignedMailRepMsg->cbDataOffset
                                      + cbSignedData);

        // Copy all but the message data.
        memcpy(pSignedMailRepMsg,
               pUnsignedMailRepMsg,
               pUnsignedMailRepMsg->cbDataOffset);

        pbDataOut = MAIL_REP_MSG_DATA(pSignedMailRepMsg);

        // Sign the message.
        ok = CryptSignMessage(
                  &SigParams,               // Signature parameters
                  FALSE,                    // Not detached
                  ARRAY_SIZE(MessageArray), // Number of messages
                  MessageArray,             // Messages to be signed
                  MessageSizeArray,         // Size of messages
                  pbDataOut,                // Buffer for signed msg
                  &cbSignedData);           // Size of buffer
        if (!ok) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }

        // Message is now signed.
        pSignedMailRepMsg->dwMsgType |= MRM_MSG_SIGNED;
        pSignedMailRepMsg->cbUnsignedDataSize = pSignedMailRepMsg->cbDataSize;
        pSignedMailRepMsg->cbDataSize         = cbSignedData;

        *ppSignedMailRepMsg = pSignedMailRepMsg;
    }
    __finally {
        if (NULL != rgpCertsToSend) {
            draFreeCertArray(cCertsToSend, rgpCertsToSend);
        }

        if (hStoreHandle
            && !CertCloseStore(hStoreHandle, CERT_CLOSE_STORE_CHECK_FLAG)) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }
    }
}


PDSNAME
draVerifyMessageSignature(
    IN  THSTATE      *      pTHS,
    IN  MAIL_REP_MSG *      pSignedMailRepMsg,
    IN  CHAR         *      pbData,
    OUT MAIL_REP_MSG **     ppUnsignedMailRepMsg,
    OUT DRA_CERT_HANDLE *   phSignerCert         OPTIONAL
    )
/*++

Routine Description:

    Verify the signature on a given replication message.  Also ensure that
    the sender's certificate is signed by a certifying authority we trust,
    and that it was issued to a domain controller in our enterprise.

    This routine takes the message header and the data pointer as separate
    items. This allows the caller to specify separate buffers for each
    that will be concatenated into a new buffer.

Arguments:

    pSignedMailRepMsg (IN) - Message to verify.  Data field not valid.

    pbData (IN) - Start of data

    ppunsignedmailrepmsg (OUT) - On return, holds a pointer to the thread-
        allocated unsigned version of the message.
        
    phSignerCert (OUT, OPTIONAL) - Holds a handle to the sender's certificate
        on return.  This handle can be used in subsequent calls to
        draEncryptAndSignMessage(), for example.  It is the caller's
        responsibility to eventually call draFreeCertHandle(*phSignerCert).

Return Values:

    Throws DRA exception any failure, including authorization failure.
    Returns the DN of the NTDS Settings object for the owner of the cert if
    the function succeeds. The DN is allocated on the thread heap and must be
    freed by the caller.

--*/
{
    BOOL                        ok = FALSE;
    PCCERT_CONTEXT              pSignerCertContext = NULL;
    DWORD                       winError;
    CRYPT_VERIFY_MESSAGE_PARA   VerifyParams;
    MAIL_REP_MSG *              pUnsignedMailRepMsg;
    PCCERT_CONTEXT              pCertContext;
    PDSNAME                     pNtdsDsaDN;

    Assert(pSignedMailRepMsg->dwMsgType & MRM_MSG_SIGNED);
    Assert(MAIL_REP_MSG_IS_NATIVE_HEADER_ONLY(pSignedMailRepMsg));

    __try {
        // Initialize the CRYPT_VERIFY_MESSAGE_PARA structure (Step 4).
        memset(&VerifyParams, 0, sizeof(VerifyParams));
        VerifyParams.cbSize                   = sizeof(VerifyParams);
        VerifyParams.dwMsgAndCertEncodingType = MY_ENCODING_TYPE;
        VerifyParams.pfnGetSignerCertificate  = draGetAndVerifySignerCertificate;
        
        // Allocate buffer to hold the unsigned message.
        pUnsignedMailRepMsg = THAllocEx(pTHS,
                                        MAIL_REP_MSG_CURRENT_HEADER_SIZE
                                        + pSignedMailRepMsg->cbUnsignedDataSize);
        *pUnsignedMailRepMsg = *pSignedMailRepMsg;
        pUnsignedMailRepMsg->cbDataOffset = MAIL_REP_MSG_CURRENT_HEADER_SIZE;
        pUnsignedMailRepMsg->cbDataSize = pSignedMailRepMsg->cbUnsignedDataSize;

        ok = CryptVerifyMessageSignature(
                    &VerifyParams,                      // Verify parameters
                    0,                                  // Signer index
                    pbData,                             // Pointer to signed blob
                    pSignedMailRepMsg->cbDataSize,      // Size of signed blob
                    MAIL_REP_MSG_DATA(pUnsignedMailRepMsg), // Buffer for decoded msg
                    &pUnsignedMailRepMsg->cbDataSize,   // Size of buffer
                    &pSignerCertContext);               // Pointer to signer cert
        if (!ok) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }

        // Message is now unsigned.
        pUnsignedMailRepMsg->dwMsgType &= ~MRM_MSG_SIGNED;

        // Verify sender's authorization.
        pNtdsDsaDN = draVerifyCertAuthorization(pTHS, pSignerCertContext);
        Assert( NULL!=pNtdsDsaDN );

        // Return unsigned message to caller.
        *ppUnsignedMailRepMsg = pUnsignedMailRepMsg;

        // Return signer's cert if requested.
        if (NULL != phSignerCert) {
            *phSignerCert = (DRA_CERT_HANDLE) pSignerCertContext;
        }
    }
    __finally {
        if (pSignerCertContext
            && (AbnormalTermination() || (NULL == phSignerCert))
            && !CertFreeCertificateContext(pSignerCertContext)) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }
    }

    return pNtdsDsaDN;
}


void
draEncryptAndSignMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pUnsealedMailRepMsg,
    IN  DRA_CERT_HANDLE hRecipientCert,
    IN  DRA_KEY_SIZE    eKeySize,
    OUT MAIL_REP_MSG ** ppSealedMailRepMsg
    )
/*++

Routine Description:

    Sign & seal the given asynchronous replication message.

    This code is aware of variable length headers.

Arguments:

    pUnsealedMailRepMsg (IN) - Message to seal.
    
    hRecipientCert (IN) - Handle to certificate of the recipient for which the
        message is to be encrypted.
    
    eKeySize (IN) - The key length in bits

    ppSealedMailRepMsg (OUT) - On return, holds a pointer to the thread-
        allocated sealed version of the message.

Return Values:

    None.  Throws DRA exception on failure.

--*/
{
    BOOL                        ok = FALSE;
    HCERTSTORE                  hStoreHandle = NULL;
    PCCERT_CONTEXT              pSignerCert = NULL;
    PCCERT_CONTEXT *            rgpCertsToSend = NULL;
    DWORD                       cCertsToSend;
    PCCERT_CONTEXT              MsgRecipientArray[1];
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    CRYPT_ALGORITHM_IDENTIFIER  CryptAlgorithm;
    CRYPT_SIGN_MESSAGE_PARA     SigParams;
    CRYPT_ENCRYPT_MESSAGE_PARA  EncryptParams;
    CMSG_RC4_AUX_INFO           Rc4AuxInfo;
    DWORD                       cbSignedData = 0;
    MAIL_REP_MSG *              pSealedMailRepMsg;
    DWORD                       winError;
    PCCERT_CONTEXT              pCertContext = (PCCERT_CONTEXT) hRecipientCert;
    PCHAR                       pbDataIn, pbDataOut;

    Assert(NULL != MAIL_REP_MSG_DATA(pUnsealedMailRepMsg));

    __try {
        // Get a handle to a crytographic provider.
        hStoreHandle = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                     0,
                                     0,
                                     CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                     L"MY");
        if (!hStoreHandle) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }
        
        // Get our certificate plus the signing CAs' certificates.
        draGetCertArrayToSend(pTHS, hStoreHandle, &cCertsToSend,
                              &rgpCertsToSend);
        pSignerCert = rgpCertsToSend[0];

        // Initialize the Algorithm Identifier for hashing.
        memset(&HashAlgorithm, 0, sizeof(HashAlgorithm));
        HashAlgorithm.pszObjId = szOID_RSA_MD5;

        // Initialize the signature structure.
        memset(&SigParams, 0, sizeof(SigParams));
        SigParams.cbSize            = sizeof(SigParams);
        SigParams.dwMsgEncodingType = MY_ENCODING_TYPE;
        SigParams.pSigningCert      = pSignerCert;
        SigParams.HashAlgorithm     = HashAlgorithm;
        SigParams.cMsgCert          = cCertsToSend;
        SigParams.rgpMsgCert        = rgpCertsToSend;

        // Initialize the Algorithm Identifier for encrypting.
        memset(&CryptAlgorithm, 0, sizeof(CryptAlgorithm));
        CryptAlgorithm.pszObjId = szOID_RSA_RC4;

        // Initialize array of recipients.
        MsgRecipientArray[0] = pCertContext;

        // Specify RC4 key size
        memset( &Rc4AuxInfo, 0, sizeof(Rc4AuxInfo) );
        Rc4AuxInfo.cbSize      = sizeof(Rc4AuxInfo);
        switch (eKeySize) {
        case DRA_KEY_SIZE_56:
            Rc4AuxInfo.dwBitLen    = 56;
            break;
        case DRA_KEY_SIZE_128:
            Rc4AuxInfo.dwBitLen    = 128;
            break;
        default:
            DRA_EXCEPT(DRAERR_InternalError, eKeySize);
        }

        // Initialize the encryption structure.
        memset(&EncryptParams, 0, sizeof(EncryptParams));
        EncryptParams.cbSize                     = sizeof(EncryptParams);
        EncryptParams.dwMsgEncodingType          = MY_ENCODING_TYPE;
        EncryptParams.ContentEncryptionAlgorithm = CryptAlgorithm;
        EncryptParams.pvEncryptionAuxInfo        = &Rc4AuxInfo;

        pbDataIn = MAIL_REP_MSG_DATA(pUnsealedMailRepMsg);

        // Get the size of the buffer needed to hold the signed/encrypted data.
        ok = CryptSignAndEncryptMessage(
                  &SigParams,                   // Signature parameters
                  &EncryptParams,               // Encryption params
                  ARRAY_SIZE(MsgRecipientArray),// Number of recipients
                  MsgRecipientArray,            // Recipients
                  pbDataIn,
                  pUnsealedMailRepMsg->cbDataSize,
                  NULL,                         // Buffer for signed msg
                  &cbSignedData);               // Size of buffer
        if (!ok) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }

        // Allocate memory for the signed blob.
        pSealedMailRepMsg = THAllocEx(pTHS,
                                      pUnsealedMailRepMsg->cbDataOffset
                                      + cbSignedData);

        // Copy all but the message data.
        memcpy(pSealedMailRepMsg,
               pUnsealedMailRepMsg,
               pUnsealedMailRepMsg->cbDataOffset);

        pbDataOut = MAIL_REP_MSG_DATA(pSealedMailRepMsg);

        // Sign the message.
        ok = CryptSignAndEncryptMessage(
                  &SigParams,                   // Signature parameters
                  &EncryptParams,               // Encryption params
                  ARRAY_SIZE(MsgRecipientArray),// Number of recipients
                  MsgRecipientArray,            // Recipients
                  pbDataIn,
                  pUnsealedMailRepMsg->cbDataSize,
                  pbDataOut,                    // Buffer for signed msg
                  &cbSignedData);               // Size of buffer
        if (!ok) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }

        // Message is now signed & encrypted.
        pSealedMailRepMsg->dwMsgType |= MRM_MSG_SIGNED | MRM_MSG_SEALED;
        pSealedMailRepMsg->cbUnsignedDataSize = pSealedMailRepMsg->cbDataSize;
        pSealedMailRepMsg->cbDataSize         = cbSignedData;

        *ppSealedMailRepMsg = pSealedMailRepMsg;
    }
    __finally {
        if (NULL != rgpCertsToSend) {
            draFreeCertArray(cCertsToSend, rgpCertsToSend);
        }

        if (hStoreHandle
            && !CertCloseStore(hStoreHandle, CERT_CLOSE_STORE_CHECK_FLAG)) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }
    }
}


PDSNAME
draDecryptAndVerifyMessageSignature(
    IN  THSTATE      *      pTHS,
    IN  MAIL_REP_MSG *      pSealedMailRepMsg,
    IN  CHAR         *      pbData,
    OUT MAIL_REP_MSG **     ppUnsealedMailRepMsg,
    OUT DRA_CERT_HANDLE *   phSignerCert         OPTIONAL
    )
/*++

Routine Description:

    Decrypt and verify the signature on a given replication message.  Also
    ensure that the sender's certificate is signed by a certifying authority we
    trust, and that it was issued to a domain controller in our enterprise.

    This routine takes the message header and the data pointer as separate
    items. This allows the caller to specify separate buffers for each
    that will be concatenated into a new buffer.

Arguments:

    pSignedMailRepMsg (IN) - Message to verify. Data field not valid.
    
    pbData (IN ) - Start of data

    ppUnsignedMailRepMsg (OUT) - On return, holds a pointer to the thread-
        allocated unsigned version of the message.
        
    phSignerCert (OUT, OPTIONAL) - Holds a handle to the sender's certificate
        on return.  This handle can be used in subsequent calls to
        draEncryptAndSignMessage(), for example.  It is the caller's
        responsibility to eventually call draFreeCertHandle(*phSignerCert).

Return Values:

    Throws DRA exception any failure, including authorization failure.
    Returns the DN of the NTDS Settings object for the owner of the cert if
    the function succeeds. The DN is allocated on the thread heap and must be
    freed by the caller.

--*/
{
    BOOL                        ok = FALSE;
    HCERTSTORE                  hStoreHandle = NULL;
    PCCERT_CONTEXT              pSignerCertContext = NULL;
    DWORD                       winError;
    CRYPT_DECRYPT_MESSAGE_PARA  DecryptParams;
    CRYPT_VERIFY_MESSAGE_PARA   VerifyParams;
    MAIL_REP_MSG *              pUnsealedMailRepMsg;
    PDSNAME                     pNtdsDsaDN;

    Assert((pSealedMailRepMsg->dwMsgType & MRM_MSG_SEALED)
           && (pSealedMailRepMsg->dwMsgType & MRM_MSG_SIGNED));
    Assert(MAIL_REP_MSG_IS_NATIVE_HEADER_ONLY(pSealedMailRepMsg));

    __try {
        // Get a handle to a crytographic provider.
        hStoreHandle = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                     0,
                                     0,
                                     CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                     L"MY");
        if (!hStoreHandle) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }
        
        // Initialize the decryption parameters.
        memset(&DecryptParams, 0, sizeof(DecryptParams));
        DecryptParams.cbSize                   = sizeof(DecryptParams);
        DecryptParams.dwMsgAndCertEncodingType = MY_ENCODING_TYPE;
        DecryptParams.cCertStore               = 1;
        DecryptParams.rghCertStore             = &hStoreHandle;
        
        // Initialize the CRYPT_VERIFY_MESSAGE_PARA structure.
        memset(&VerifyParams, 0, sizeof(VerifyParams));
        VerifyParams.cbSize                   = sizeof(VerifyParams);
        VerifyParams.dwMsgAndCertEncodingType = MY_ENCODING_TYPE;
        VerifyParams.pfnGetSignerCertificate  = draGetAndVerifySignerCertificate;
        
        // Allocate buffer to hold the unsigned message.
        pUnsealedMailRepMsg = THAllocEx(pTHS,
                                        MAIL_REP_MSG_CURRENT_HEADER_SIZE
                                        + pSealedMailRepMsg->cbUnsignedDataSize);
        *pUnsealedMailRepMsg = *pSealedMailRepMsg;
        pUnsealedMailRepMsg->cbDataOffset = MAIL_REP_MSG_CURRENT_HEADER_SIZE;
        pUnsealedMailRepMsg->cbDataSize = pSealedMailRepMsg->cbUnsignedDataSize;

        ok = CryptDecryptAndVerifyMessageSignature(
                    &DecryptParams,                     // Decrypt parameters
                    &VerifyParams,                      // Verify parameters
                    0,                                  // Signer index
                    pbData,                             // Pointer to sealed blob
                    pSealedMailRepMsg->cbDataSize,      // Size of sealed blob
                    MAIL_REP_MSG_DATA(pUnsealedMailRepMsg), // Buffer for decoded msg
                    &pUnsealedMailRepMsg->cbDataSize,   // Size of buffer
                    NULL,                               // Pointer to xchg cert
                    &pSignerCertContext);               // Pointer to signer cert
        if (!ok) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }

        // Message is now unsealed.
        pUnsealedMailRepMsg->dwMsgType &= ~(MRM_MSG_SIGNED | MRM_MSG_SEALED);

        // Verify sender's authorization.
        pNtdsDsaDN = draVerifyCertAuthorization(pTHS, pSignerCertContext);
        Assert( NULL!=pNtdsDsaDN );

        // Return unsealed message to caller.
        *ppUnsealedMailRepMsg = pUnsealedMailRepMsg;

        // Return signer's cert if requested.
        if (NULL != phSignerCert) {
            *phSignerCert = (DRA_CERT_HANDLE) pSignerCertContext;
        }
    }
    __finally {
        if (pSignerCertContext
            && (AbnormalTermination() || (NULL == phSignerCert))
            && !CertFreeCertificateContext(pSignerCertContext)) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }

        if (hStoreHandle
            && !CertCloseStore(hStoreHandle, CERT_CLOSE_STORE_CHECK_FLAG)) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }
    }

    return pNtdsDsaDN;
}


void
draFreeCertHandle(
    IN  DRA_CERT_HANDLE hCert
    )
/*++

Routine Description:

    Frees a cert handle returned by a prior call to draVerifyMessageSignature()
    or draDecryptAndVerifyMessageSignature().

Arguments:

    hCert (IN) - Handle to free.
    
Return Values:

    None.

--*/
{
    PCCERT_CONTEXT  pCertContext = (PCCERT_CONTEXT) hCert;
    DWORD           winError;

    Assert(NULL != pCertContext);

    if (!CertFreeCertificateContext(pCertContext)) {
        winError = GetLastError();
        LogUnhandledError(winError);
    }
}


///////////////////////////////////////////////////////////////////////////////
//
//  LOCAL FUNCTION IMPLEMENTATIONS
//


BOOL
draCheckEnrollExtensionHelper(
    IN  THSTATE *   pTHS,
    PCCERT_CONTEXT          pCertContext
    )

/*++

Routine Description:

    Check whether an ENROLL type extension is present.
    These are only found in V1 certificates.

Xiaohong Su writes:
An observation is that in draCheckEnrollExtensionHelper, you can safely compare pszCertTypeName with wszCERTTYPE_DC.  All of the following can be removed.  It is just a suggestion.  What you have is fine.

Arguments:

    pTHS - thread state
    pCertContext - The certificate to check

Return Value:

    BOOL - TRUE if extension is found, FALSE otherwise or on error
    No exceptions are raised

--*/

{
    CERT_EXTENSION *        pCertExtension;
    DWORD                   cbCertTypeMax = 512;
    DWORD                   cbCertType;
    CERT_NAME_VALUE *       pCertType = NULL;
    HRESULT                 hr;
    HCERTTYPE               hCertType;
    LPWSTR *                ppszCertTypePropertyList;
    BOOL                    ok = FALSE;
    BOOL                    fCertFound = FALSE;

    // Allocate buffer to hold cert type extension.
    pCertType = THAllocEx(pTHS, cbCertTypeMax);

    // Find the cert type.
    pCertExtension = CertFindExtension(szOID_ENROLL_CERTTYPE_EXTENSION,
                                       pCertContext->pCertInfo->cExtension,
                                       pCertContext->pCertInfo->rgExtension);

    if (NULL != pCertExtension) {
    
        // Decode the cert type.
        cbCertType = cbCertTypeMax;
        ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                               X509_UNICODE_ANY_STRING,
                               pCertExtension->Value.pbData,
                               pCertExtension->Value.cbData,
                               0,
                               (void *) pCertType,
                               &cbCertType);
            
        if (!ok && (ERROR_MORE_DATA == GetLastError())) {
            // Our buffer isn't big enough to hold this cert; realloc and
            // try again.
            DPRINT1(0, "Buffer insufficient; reallocing to %u bytes.\n",
                    cbCertType);
            pCertType = THReAllocEx(pTHS, pCertType, cbCertType);
            cbCertTypeMax = cbCertType;
            
            ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                                   X509_UNICODE_ANY_STRING,
                                   pCertExtension->Value.pbData,
                                   pCertExtension->Value.cbData,
                                   0,
                                   (void *) pCertType,
                                   &cbCertType);
        }
            
        if (ok && (0 != cbCertType)) {
            LPWSTR pszCertTypeName = (LPWSTR) pCertType->Value.pbData;

            hCertType = NULL;
            ppszCertTypePropertyList = NULL;

            // Get a handle to the cert type
            hr = CAFindCertTypeByName( 
                pszCertTypeName,
                NULL, // hCAInfo
                CT_FIND_LOCAL_SYSTEM | CT_ENUM_MACHINE_TYPES, // dwFlags
                &hCertType
                );

            if (FAILED(hr)) {
                DPRINT1(0,"CAFindCertTypeByName failed, error 0x%x\n",hr );
            } else {

                // Get the base name property of the cert type object
                hr = CAGetCertTypeProperty( hCertType,
                                            CERTTYPE_PROP_CN,
                                            &ppszCertTypePropertyList
                    );
                if (FAILED(hr)) {
                    DPRINT1( 0, "CAGetCertTypeProperty failed, error 0x%x\n",hr );
                } else {
                    Assert( ppszCertTypePropertyList[1] == NULL );

                    if (0 == _wcsicmp(ppszCertTypePropertyList[0],
                                      wszCERTTYPE_DC )) {
                        // We found our DC certificate; we're done!
                        fCertFound = TRUE;
                    }
                } // if failed
            } // if failed

            if (ppszCertTypePropertyList != NULL) {
                hr = CAFreeCertTypeProperty( hCertType,
                                             ppszCertTypePropertyList );
                if (FAILED(hr)) {
                    DPRINT1( 0, "CAFreeCertTypeProperty failed, error 0x%x\n",hr );
                }
            }
            if (hCertType != NULL) {
                hr = CACloseCertType( hCertType );
                if (FAILED(hr)) {
                    DPRINT1(0,"CACloseCertType failed, error 0x%x\n",hr );
                }
            }
        } // if ok
    } // if null == cert extension

    if (NULL != pCertType) {
        THFree(pCertType);
    }

    return fCertFound;
}

PCCERT_CONTEXT
draGetDCCertEx(
    IN  THSTATE *   pTHS,
    IN  HCERTSTORE  hCertStore,
    IN  BOOL        fRequestV2Certificate
    )
/*++

Routine Description:

    Retrieve the "DomainController" type certificate associated with the local
    machine.  This routine checks for one specific type of certificate at a time.
    It must be called several times to check all the possibilities. In this sense
    it is a helper function meant to be called as part of a logic get dc cert
    function.  This routine does not except, but returns null quietly if the type
    you want is not present.

    For background on the need for V2 certificates, see bug 148245. In summary, a V1
    cert looks like this:
    V1 cert
        ENROLL_CERTYPE_EXTENSION with type CERTTYPE_DC
        SUBJECT_ALT_NAME2 extension with REPLICATION OID
    This was found to be nonstandard after W2K shipped.
    The V2 cert looks like this:
        (no ENROLL_CERTTYPE_EXTENSION)
        CERTIFICATE_TEMPLATE extension
        SUBJECT_ALT_NAME2 extension with REPLICATION OID
        
    A Whistler or later enterprise CA will only have a V2 cert. A W2K CA, or a
    W2K CA upgraded to Whistler will have both a V1 and a V2 cert.

    Given the way the W2K code to find the certificate worked, it was not
    predictable which one it would find.  We want the code to prefer a V2 certificate
    if one is available.  For example, in a Whistler only forest, we must use
    the V2 certificate, even if the CA was originally upgraded from W2K.

Xiaohong Su writes:
Back to your questions.  V2 directory email replication certificate should not co-exist with any V1 DC certificate, unless you manually enrolled for a V2 certificate.  V2 replication certificate template supersedes the V1 DC certificate, thus autoenrollment will automatically archive the V1 certificate upon receiving a new V2 certificate.  To obtain a V2 directory email replication certificate, install a Whistler CA, enable template based machine autoenrollment via GPO, and force a group policy download (gpupdate /force).  

Arguments:

    hCertStore (IN) - Handle to the cert store to search.
    fRequestV2Certificate - Whether we should only accept a V2 certificate    
    
Return Values:

    Handle to the certificate.  NULL if none matching.

--*/
{
    PCCERT_CONTEXT          pCertContext = NULL;
    CERT_ALT_NAME_ENTRY * pCertAltNameEntry;
    CRYPT_OBJID_BLOB *    pEncodedGuidBlob = NULL;
    DWORD                 cbDecodedGuidBlob;
    CRYPT_DATA_BLOB *     pDecodedGuidBlob = NULL;
    GUID                  ComputerObjGuid;
    BOOL                  ok;
    DWORD                 winError;

    Assert( gAnchor.pComputerDN );
    Assert( !fNullUuid( &gAnchor.pComputerDN->Guid ) );

    // Grovel through each of our certificates, looking for the one of type DC.
    for (pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext);
         (NULL != pCertContext);
         pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext)) {

        if (fRequestV2Certificate) {
            // A V2 certificate has a CERTIFICATE_TEMPLATE extension, but
            // no ENROLL_CERTTYPE extension.
            if (!CertFindExtension(szOID_CERTIFICATE_TEMPLATE,
                                   pCertContext->pCertInfo->cExtension,
                                   pCertContext->pCertInfo->rgExtension)) {
                continue;
            }
        } else {
            if (!draCheckEnrollExtensionHelper( pTHS, pCertContext )) {
                continue;
            }
        }

        // We found one!
        // A certificate suitable for mail-based replication will have our
        // OID in it, by definition.
        pCertAltNameEntry = draGetCertAltNameEntry(pTHS,
                                                   pCertContext,
                                                   CERT_ALT_NAME_OTHER_NAME,
                                                   szOID_NTDS_REPLICATION);
        if (!pCertAltNameEntry) {
            // Doesn't have one? Skip it.
            continue;
        }

        // Validate that the computer guid found in the dc cert is our own and not
        // some stale one left behind from a previous dcpromo

        pEncodedGuidBlob = &pCertAltNameEntry->pOtherName->Value;

        cbDecodedGuidBlob = 64;
        pDecodedGuidBlob = (CRYPT_DATA_BLOB *) THAllocEx(pTHS, cbDecodedGuidBlob);

        ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                               X509_OCTET_STRING,
                               pEncodedGuidBlob->pbData,
                               pEncodedGuidBlob->cbData,
                               0,
                               pDecodedGuidBlob,
                               &cbDecodedGuidBlob);
        if (!ok
            || (0 == cbDecodedGuidBlob)
            || (sizeof(GUID) != pDecodedGuidBlob->cbData)) {
            winError = GetLastError();
            DPRINT1(0, "Can't decode computer objectGuid (error 0x%x); access denied.\n",
                    winError);
            THFreeEx( pTHS, pDecodedGuidBlob );
            continue;
        }

        memcpy(&ComputerObjGuid, pDecodedGuidBlob->pbData, sizeof(GUID)); // align

        THFreeEx( pTHS, pDecodedGuidBlob );

        // Validate that this computer obj guid is ours

        if ( gAnchor.pComputerDN &&
             (memcmp( &gAnchor.pComputerDN->Guid, &ComputerObjGuid, sizeof(GUID) )) ) {
            CHAR szUuid1[SZUUID_LEN];
            DPRINT1( 0, "Found stale dc cert with other computer guid %s\n",
                     DsUuidToStructuredString(&ComputerObjGuid, szUuid1) );
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_CERT_WRONG_DC,
                     szInsertUUID(&ComputerObjGuid),
                     NULL,
                     NULL
                );
            continue;
        }

        // Found a suitable one
        break;
    } // for

    return pCertContext;
}

PCCERT_CONTEXT
draGetDCCert(
    IN  THSTATE *   pTHS,
    IN  HCERTSTORE  hCertStore
    )
/*++

Routine Description:

    Retrieve the "DomainController" type certificate associated with the local
    machine.

Arguments:

    hCertStore (IN) - Handle to the cert store to search.
    
Return Values:

    Handle to the certificate.  Throws DRA exception if not found or on other
    error.

--*/
{
    static DSTIME           timeLastFailureLogged = 0;

    PCCERT_CONTEXT          pDCCert = NULL;

    pDCCert = draGetDCCertEx(pTHS, hCertStore, TRUE /*v2 */ );
    if (!pDCCert) {
        pDCCert = draGetDCCertEx(pTHS, hCertStore, FALSE /* v1 */ );
        if (pDCCert) {
            DPRINT( 1, "A V1 domain controller certificate is being used.\n" );
        }
    } else {
        DPRINT( 1, "A V2 mail replication certificate is being used.\n" );
    }

    if (!pDCCert) {
        DSTIME timeCurrent = GetSecondsSince1601();

        if ((timeCurrent < timeLastFailureLogged)
            || (timeCurrent > (timeLastFailureLogged + NO_CERT_LOG_INTERVAL))) {
            // Log event to alert admin that we have no certificate.
            timeLastFailureLogged = timeCurrent;
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_NO_CERTIFICATE,
                     NULL, NULL, NULL);
        }

        DPRINT(0, "No certificate of type suitable for mail-based replication found.\n");
        DRA_EXCEPT(DRAERR_CryptError, 0);
    }
    else if (0 != timeLastFailureLogged) {
        // We failed to find a certificate earlier in this boot, but now we have
        // one.
        timeLastFailureLogged = 0;
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DRA_CERTIFICATE_ACQUIRED,
                 NULL, NULL, NULL);
    }

    return pDCCert;
}


PDSNAME
draVerifyCertAuthorization(
    IN  THSTATE      *  pTHS,
    IN  PCCERT_CONTEXT  pCertContext
    )
/*++

Routine Description:

    Verify that the given certificate is trustworthy.  Checks that we trust one
    or more of the certifying authorities and that the owner of the certificate
    is a DC in our enterprise.

Arguments:

    pCertContext (IN) - Cert to verify.
    
Return Values:

    Throws DRA exception any failure, including authorization failure.
    Returns the DN of the NTDS Settings object for the owner of the cert if
    the function succeeds. The DN is allocated on the thread heap and must be
    freed by the caller.

--*/
{
    CERT_ALT_NAME_ENTRY * pCertAltNameEntry;
    BOOL                  ok;
    DWORD                 winError;
    DWORD                 i;
    CRYPT_OBJID_BLOB *    pEncodedGuidBlob = NULL;
    DWORD                 cbDecodedGuidBlob;
    CRYPT_DATA_BLOB *     pDecodedGuidBlob = NULL;
    GUID                  ComputerObjGuid;
    PDSNAME               pNtdsDsaDN = NULL;

    pCertAltNameEntry = draGetCertAltNameEntry(pTHS,
                                               pCertContext,
                                               CERT_ALT_NAME_OTHER_NAME,
                                               szOID_NTDS_REPLICATION);
    if (NULL == pCertAltNameEntry) {
        DPRINT(0, "Certificate contains no szOID_NTDS_REPLICATION alt subject name;"
                  " access denied.\n");
        DRA_EXCEPT(DRAERR_AccessDenied, 0);
    }
    
    pEncodedGuidBlob = &pCertAltNameEntry->pOtherName->Value;

    cbDecodedGuidBlob = 64;
    pDecodedGuidBlob = (CRYPT_DATA_BLOB *) THAllocEx(pTHS, cbDecodedGuidBlob);

    ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                           X509_OCTET_STRING,
                           pEncodedGuidBlob->pbData,
                           pEncodedGuidBlob->cbData,
                           0,
                           pDecodedGuidBlob,
                           &cbDecodedGuidBlob);
    if (!ok
        || (0 == cbDecodedGuidBlob)
        || (sizeof(GUID) != pDecodedGuidBlob->cbData)) {
        winError = GetLastError();
        DPRINT1(0, "Can't decode computer objectGuid (error 0x%x); access denied.\n",
                winError);
        DRA_EXCEPT(DRAERR_AccessDenied, winError);
    }

    // The following statement is here to make extra sure the GUID is suitably
    // aligned.  (But it may be unnecessary.)
    memcpy(&ComputerObjGuid, pDecodedGuidBlob->pbData, sizeof(GUID));

#if DBG
    {
        CHAR szGuid[33];
        
        for (i = 0; i < sizeof(GUID); i++) {
            sprintf(szGuid+2*i, "%02x", 0xFF & ((BYTE *) &ComputerObjGuid)[i]);
        }
        szGuid[32] = '\0';

        DPRINT1(2, "Sent by DSA with computer objectGuid %s.\n", szGuid);
    }
#endif

    if (!draIsDsaComputerObjGuid(&ComputerObjGuid, &pNtdsDsaDN)) {
        // Computer object guid does not correspond to a DS DC in our
        // enterprise (or at least we haven't seen its addition to the
        // enterprise yet).
        DRA_EXCEPT(DRAERR_AccessDenied, 0);
    }
    Assert( NULL!=pNtdsDsaDN );
    
    if(pDecodedGuidBlob != NULL) THFreeEx(pTHS, pDecodedGuidBlob);

    return pNtdsDsaDN;
}


#ifndef TEST_HARNESS
BOOL
draIsDsaComputerObjGuid(
    IN  GUID *      pComputerObjGuid,
    OUT PDSNAME *   ppNtdsDsaDN
    )
/*++

Routine Description:

    Is the given guid that of a computer object representing a DS DC in our
    enterprise?

Arguments:

    pComputerObjGuid (IN) - Guid to check.
    ppNtdsDsaDN (OUT) - If the function succeeds and the argument is non-NULL,
        it will be set to a pointer to the DN of the NTDS Settings object
        for the DC to whom this cert was issued. The DN is allocated on the
        thread heap and should be freed by the caller.
    
Return Values:

    TRUE - is the guid of a computer object representing a DS DC in our
        enterprise.
        
    FALSE - is not.

--*/
{
    BOOL          fIsDsa = FALSE;
    THSTATE *     pTHS = pTHStls;
    DSNAME        ComputerDN = {0};
    DB_ERR        err;
    DWORD         cb;
    DSNAME *      pServerDN = NULL;
    DSNAME *      pNtdsDsaDN = NULL;
    CLASSCACHE *  pCC;
    DWORD         iServer = 0;

    Assert(NULL != pComputerObjGuid);
    Assert(NULL == pTHS->pDB);

    ComputerDN.structLen = sizeof(ComputerDN);
    ComputerDN.Guid = *pComputerObjGuid;

    BeginDraTransaction(SYNC_READ_ONLY);

    __try {
        // Find the computer record (object or phantom).
        err = DBFindDSName(pTHS->pDB, &ComputerDN);
        if (err && (DS_ERR_NOT_AN_OBJECT != err)) {
            DPRINT1(0, "Can't find computer record, error 0x%x.\n", err);
            __leave;
        }

        // Determine which server object in the config container corresponds to
        // it. Check all values: backlinks are inherently multi-valued.  It is possible
        // that a server was retired without dcdemote, its NTDS-DSA object was removed
        // using ntdsutil, and another server was promoted with the same name in a new
        // site. If the computer account was re-used, we will have a computer account
        // with two backlinks to two servers, only one of which has a valid NTDS-DSA.

        // Two other interesting observations:
        // 1. You can read a backlink attribute from a phantom if you an internal caller.
        //    Phantoms normally don't have attributes. The backlink is really a generated
        //    attribute based on forward links on other real objects.
        // 2. If such backlinks exist, it implies that the forward linker, the server
        //    object, is not deleted.
        
        while ((err = DBGetAttVal(pTHS->pDB, ++iServer, ATT_SERVER_REFERENCE_BL,
                                  0, 0, &cb, (BYTE **) &pServerDN)) == 0) {

            DBPOS *pDB = NULL;  

            // Construct the name of the child ntdsDsa object.
            pNtdsDsaDN = (DSNAME *) THAllocEx(pTHS, (pServerDN->structLen + 50));
            err = AppendRDN(pServerDN,
                            pNtdsDsaDN,
                            pServerDN->structLen + 50,
                            L"NTDS Settings",
                            0,
                            ATT_COMMON_NAME);
            Assert(!err);
        
            // Use another database position to seek to the DSA object, so we don't
            // mess up our position on the computer object.
            DBOpen2(FALSE, &pDB);
            if (!pDB) {
                break;
            }
            __try {
                // Seek to the ntdsDsa object.
                err = DBFindDSName(pDB, pNtdsDsaDN);
                if (err) {
                    DPRINT2(0, "Can't find ntdsDsa object \"%ls\", error 0x%x.\n",
                            pNtdsDsaDN->StringName, err);
                    __leave;
                }

                // Is it indeed an ntdsDsa object?
                // We know this is not deleted because we just found it BY NAME (not guid)
                GetObjSchema(pDB, &pCC);
                if (CLASS_NTDS_DSA != pCC->ClassId) {
                    DPRINT1(0, "%ls is not an ntdsDsa object -- spoof attempt?\n",
                            pNtdsDsaDN->StringName);
                    err = ERROR_DS_CLASS_NOT_DSA;
                    __leave;
                }

                // First fill in the GUID for the caller since we expect
                // that he will need it.
                err = DBFillGuidAndSid(pDB, pNtdsDsaDN);
                if( err ) {
                    DRA_EXCEPT(DRAERR_DBError, err);
                }
            } __finally {
                DBClose(pDB, TRUE);
            }
            if (err) {
                continue;
            }

            // Okay, we trust you.
            fIsDsa = TRUE;
            break;
        }
    }
    __finally {
        EndDraTransaction(!AbnormalTermination());
    }

    // Log why we did not authenticate the guid
    if (!fIsDsa) {
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DRA_CERT_ACCESS_DENIED_NOT_DC,
                 szInsertUUID(pComputerObjGuid),
                 szInsertDN(pServerDN),  // szInsertDn can handle nulls too
                 szInsertDN(pNtdsDsaDN)  // ditto
                 );
    }

    if (NULL != pServerDN) {
        THFree(pServerDN);
    }

    // If this function succeeded and the caller requested the DN of the
    // NTDS Settings object, return it to him.
    if( fIsDsa ) {
        Assert( NULL!=pNtdsDsaDN );
        if( ppNtdsDsaDN ) {
            *ppNtdsDsaDN = pNtdsDsaDN;
            // Null out the DN so that it is not freed below
            pNtdsDsaDN = NULL;
        }
    }

    if(pNtdsDsaDN != NULL) THFreeEx(pTHS, pNtdsDsaDN);
    
    return fIsDsa;
}
#endif // #ifndef TEST_HARNESS


void
draLogAccessDeniedError(
    IN  THSTATE *           pTHS,
    IN  PCCERT_CONTEXT      pCertContext OPTIONAL,
    IN  DWORD               winError,
    IN  DWORD               dwTrustError
    )

/*++

Routine Description:

    Log an access denied event

    One of winError or dwTrustError must be specified non-zero.

Arguments:

    pTHS - thread state
    pCertContext - Certificate Context, optional
    winError - api call failure status
    dwTrustError - Certificate chain error

Return Value:

    None

--*/

{
    DWORD                 cch;
    LPWSTR                pwszIssuerName = NULL;
    LPWSTR                pwszSubjectDnsName = NULL;
    CERT_ALT_NAME_ENTRY * pCertAltNameEntry;
    DWORD dwMsgID, dwErrCode;

    if (pCertContext) {
        // Derive issuer name (for logging purposes).
        cch = CertGetNameStringW(pCertContext,
                                 CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                 CERT_NAME_ISSUER_FLAG,
                                 NULL,
                                 NULL,
                                 0);
        if (0 != cch) {
            pwszIssuerName = THAlloc(cch * sizeof(WCHAR));

            if (NULL != pwszIssuerName) {
                CertGetNameStringW(pCertContext,
                                   CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                   CERT_NAME_ISSUER_FLAG,
                                   NULL,
                                   pwszIssuerName,
                                   cch);
            }
        }

        // Derive subject's DNS name (for logging purposes).
        pCertAltNameEntry = draGetCertAltNameEntry(pTHS,
                                                   pCertContext,
                                                   CERT_ALT_NAME_DNS_NAME,
                                                   NULL);
        if (NULL != pCertAltNameEntry) {
            pwszSubjectDnsName = pCertAltNameEntry->pwszDNSName;
        }
    }

    // Log "access denied" event for admin.

    if (winError) {
        dwMsgID = DIRLOG_DRA_CERT_ACCESS_DENIED_WINERR;
        dwErrCode = winError;
    }
    else {
        Assert(dwTrustError);
        dwMsgID = DIRLOG_DRA_CERT_ACCESS_DENIED_TRUSTERR;
        dwErrCode = dwTrustError;
    }
        
    LogEvent8(DS_EVENT_CAT_REPLICATION,
              DS_EVENT_SEV_ALWAYS,
              dwMsgID,
              szInsertWC(pwszSubjectDnsName ? pwszSubjectDnsName : L""),
              szInsertWC(pwszIssuerName ? pwszIssuerName : L""),
              szInsertWin32Msg(winError),
              szInsertWin32ErrCode(winError),
              NULL, NULL, NULL, NULL );

} /* draLogAccessDeniedError */

void
draGetCertArrayToSend(
    IN  THSTATE *           pTHS,
    IN  HCERTSTORE          hCertStore,
    OUT DWORD *             pcNumCerts,
    OUT PCCERT_CONTEXT **   prgpCerts
    )
/*++

Routine Description:

    Retrieves array of certificate contexts to include in outbound messages.
    The array includes the local DC's certificates plus all the signing CAs'
    certificates up to the root.

Arguments:

    hCertStore (IN) - Certificate store from which to retrieve DC certificate.
    
    pcNumCerts (OUT) - On return, the number of certificates in the array.
    
    prgpCerts (OUT) - On return, the array of certificate contexts.

Return Values:

    None.
    
--*/
{
    PCCERT_CONTEXT          pDCCert = NULL;
    PCCERT_CHAIN_CONTEXT    pChainContext = NULL;
    CERT_CHAIN_PARA         ChainPara;
    PCERT_SIMPLE_CHAIN      pChain;
    DWORD                   iCert;
    DWORD                   winError;

    //
    // NOTE: If any usage checks need to be done, then place them in
    //       the chain parameters under the Usage field
    //

    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    pDCCert = draGetDCCert(pTHS, hCertStore );

    Assert( pDCCert );  // An exception should have been raised

    if (!CertGetCertificateChain(HCCE_LOCAL_MACHINE,
                                 pDCCert,
                                 NULL,
                                 NULL,
                                 &ChainPara,
                                 0,
                                 NULL,
                                 &pChainContext)) {
        winError = GetLastError();
        DPRINT1(0, "CertGetCertificateChain() failed, error %d.\n", winError);
        draLogAccessDeniedError( pTHS, pDCCert, winError, 0 );
        DRA_EXCEPT(DRAERR_CryptError, winError);
    }

    __try {
        DWORD dwTrustError = pChainContext->TrustStatus.dwErrorStatus;
        if (CERT_TRUST_NO_ERROR != dwTrustError ) {
            DPRINT1(0, "CertGetCertificateChain() failed, trust status %d.\n",
                    dwTrustError );
            draLogAccessDeniedError( pTHS, pDCCert, 0, dwTrustError );
            DRA_EXCEPT(DRAERR_CryptError, dwTrustError );
        }

        Assert(1 == pChainContext->cChain);
        pChain = pChainContext->rgpChain[0];
        
        *prgpCerts = (PCCERT_CONTEXT *) THAllocEx(pTHS,
                                                  pChain->cElement
                                                  * sizeof(PCCERT_CONTEXT));
        *pcNumCerts = pChain->cElement;

        for (iCert = 0; iCert < pChain->cElement; iCert++) {
            (*prgpCerts)[iCert] = CertDuplicateCertificateContext(
                                      pChain->rgpElement[iCert]->pCertContext);
            Assert(NULL != (*prgpCerts)[iCert]);
        }
    }
    __finally {
        if (NULL != pChainContext) {
            CertFreeCertificateChain(pChainContext);
        }
        
        if ((NULL != pDCCert)
            && !CertFreeCertificateContext(pDCCert)) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }
    }
}


void
draFreeCertArray(
    IN  DWORD             cNumCerts,
    IN  PCCERT_CONTEXT *  rgpCerts
    )
/*++

Routine Description:

    Frees an array of certificate contexts (such as that returned by
    draGetCertArrayToSend()).

Arguments:

    cNumCerts (IN) - Number of certificates in array.
    
    pCerts (IN) - Array of certificate contexts to free.

Return Values:

    None.
    
--*/
{
    DWORD iCert;
    DWORD winError;

    if (NULL != rgpCerts) {
        for (iCert = 0; iCert < cNumCerts; iCert++) {
            if (!CertFreeCertificateContext(rgpCerts[iCert])) {
                winError = GetLastError();
                LogUnhandledError(winError);
            }
        }
    }
}


PCCERT_CONTEXT
WINAPI
draGetAndVerifySignerCertificate(
    IN  VOID *      pvGetArg,
    IN  DWORD       dwCertEncodingType,
    IN  PCERT_INFO  pSignerId,
    IN  HCERTSTORE  hCertStore
    )
/*++

Routine Description:

    Helper function for draVerifyMessageSignature() and
    draDecryptAndVerifyMessageSignature().

Arguments:

    See description of pfnGetSignerCertificate field of
    CRYPT_VERIFY_MESSAGE_PARA structure in Win32 SDK.

Return Values:

    NULL or valid certificate context.

--*/
{
    CERT_CHAIN_PARA       ChainPara;
    PCCERT_CHAIN_CONTEXT  pChainContext = NULL;
    PCCERT_CONTEXT        pCertContext = NULL;
    DWORD                 winError = ERROR_SUCCESS;
    DWORD                 dwTrustError = 0;
    THSTATE *             pTHS = pTHStls;
    CERT_CHAIN_POLICY_PARA ChainPolicyPara;
    CERT_CHAIN_POLICY_STATUS ChainPolicyStatus;

    if (NULL == pSignerId) {
        return NULL;
    }

    pCertContext = CertGetSubjectCertificateFromStore(hCertStore,
                                                      dwCertEncodingType,
                                                      pSignerId);

    if (NULL != pCertContext) {
        memset(&ChainPara, 0, sizeof(ChainPara));
        ChainPara.cbSize = sizeof(ChainPara);

        if (CertGetCertificateChain(HCCE_LOCAL_MACHINE,
                                    pCertContext,
                                    NULL,
                                    hCertStore,
                                    &ChainPara,
                                    0,
                                    NULL,
                                    &pChainContext)) {
            if (CERT_TRUST_NO_ERROR
                == pChainContext->TrustStatus.dwErrorStatus) {

                memset(&ChainPolicyPara, 0, sizeof(ChainPolicyPara));
                ChainPolicyPara.cbSize = sizeof(ChainPolicyPara);
                memset(&ChainPolicyStatus, 0, sizeof(ChainPolicyStatus));
                ChainPolicyStatus.cbSize = sizeof(ChainPolicyStatus);

                if (CertVerifyCertificateChainPolicy(
                        CERT_CHAIN_POLICY_NT_AUTH,
                        pChainContext,
                        &ChainPolicyPara,
                        &ChainPolicyStatus )) {

                    if (ERROR_SUCCESS == ChainPolicyStatus.dwError) {
                        DPRINT( 1, "Sender's cert chain policy has been verified.\n" );
                    } else {
                        dwTrustError = ChainPolicyStatus.dwError;
                        DPRINT1(0, "Sender's cert chain policy is not trusted, trust status = 0x%x.\n",
                                    dwTrustError);
                    }

                } else {
                    winError = GetLastError();
                    if (!winError) {
                        winError = TRUST_E_CERT_SIGNATURE;
                    }
                    DPRINT1(0, "Can't verify sender's cert chain policy, error 0x%x.\n",
                            winError);
                }

            }
            else {
                dwTrustError = pChainContext->TrustStatus.dwErrorStatus;
                DPRINT1(0, "Sender's cert chain is not trusted, trust status = 0x%x.\n",
                        dwTrustError);
            }

            CertFreeCertificateChain(pChainContext);
        }
        else {
            winError = GetLastError();
            if (!winError) {
                winError = TRUST_E_CERT_SIGNATURE;
            }
            DPRINT1(0, "Can't retrieve sender's cert chain, error 0x%x.\n",
                    winError);
        }

    }
    else {
        winError = GetLastError();
        if (!winError) {
            winError = TRUST_E_CERT_SIGNATURE;
        }
        DPRINT1(0, "Can't CertGetSubjectCertificateFromStore(), error 0x%x.\n",
                winError);
    }

    // If we got either kind of error, log access denied
    if (winError || dwTrustError ) {
        draLogAccessDeniedError( pTHS, pCertContext, winError, dwTrustError );

        if ( pCertContext ) {
            // Free the context we acquired.
            CertFreeCertificateContext(pCertContext);
            pCertContext = NULL;
        }
    }

    return pCertContext;
}


CERT_ALT_NAME_ENTRY *
draGetCertAltNameEntry(
    IN  THSTATE *       pTHS,
    IN  PCCERT_CONTEXT  pCertContext,
    IN  DWORD           dwAltNameChoice,
    IN  LPSTR           pszOtherNameOID     OPTIONAL
    )
/*++

Routine Description:

    Retrieve a specific alt subject name entry from the given certificate.

Arguments:

    pCertContext (IN) - Certificate from which info is to be derived.
    
    dwAltNameChoice (IN) - The CERT_ALT_NAME_* for the desired alternate name.
    
    pszOtherNameOID (IN) - If retrieving CERT_ALT_NAME_OTHER_NAME, an OID
        specifying the specific "other name" desired.  Must be NULL for other
        values of dwAltNameChoice.
        
Return Values:

    A pointer to the CERT_ALT_NAME_ENTRY (success) or NULL (failure).
    
--*/
{
    CERT_EXTENSION *      pCertExtension;
    CERT_ALT_NAME_INFO *  pCertAltNameInfo;
    DWORD                 cbCertAltNameInfo = 0;
    CERT_ALT_NAME_ENTRY * pCertAltNameEntry = NULL;
    BOOL                  ok;
    DWORD                 winError;
    DWORD                 i;
    
    Assert((CERT_ALT_NAME_OTHER_NAME == dwAltNameChoice)
           || (NULL == pszOtherNameOID));

    // Find the cert extension containing the alternate subject names.
    pCertExtension = CertFindExtension(szOID_SUBJECT_ALT_NAME2,
                                       pCertContext->pCertInfo->cExtension,
                                       pCertContext->pCertInfo->rgExtension);
    if (NULL == pCertExtension) {
        DPRINT(0, "Certificate has no alt subject name.\n");
        LogUnhandledError(0);
        return NULL;
    }
        
    // Decode the list of alternate subject names.
    ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                           X509_ALTERNATE_NAME,
                           pCertExtension->Value.pbData,
                           pCertExtension->Value.cbData,
                           0,
                           NULL,
                           &cbCertAltNameInfo);
    if (!ok || (0 == cbCertAltNameInfo)) {
        winError = GetLastError();
        DPRINT1(0, "Can't decode alt subject name (error 0x%x).\n", winError);
        LogUnhandledError(winError);
        return NULL;
    }
    
    pCertAltNameInfo = THAlloc(cbCertAltNameInfo);
    
    if (NULL == pCertAltNameInfo) {
        DPRINT1(0, "Failed to allocate %d bytes.\n", cbCertAltNameInfo);
        LogUnhandledError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
        
    ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                           X509_ALTERNATE_NAME,
                           pCertExtension->Value.pbData,
                           pCertExtension->Value.cbData,
                           0,
                           pCertAltNameInfo,
                           &cbCertAltNameInfo);
    if (!ok) {
        winError = GetLastError();
        DPRINT1(0, "Can't decode alt subject name (error 0x%x).\n", winError);
        LogUnhandledError(winError);
        return NULL;
    }
    
    // Grovel through the alternate names to find the one the caller asked for.
    for (i = 0; i < pCertAltNameInfo->cAltEntry; i++) {
        if ((dwAltNameChoice
             == pCertAltNameInfo->rgAltEntry[i].dwAltNameChoice)
            && ((NULL == pszOtherNameOID)
                || (0 == strcmp(pszOtherNameOID,
                                pCertAltNameInfo->rgAltEntry[i]
                                    .pOtherName->pszObjId)))) {
            pCertAltNameEntry = &pCertAltNameInfo->rgAltEntry[i];
            break;
        }
    }

    return pCertAltNameEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drademot.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       drdemot.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Implementation of DirReplicaDemote, used to remove a writeable NC from a
    DSA either as part of full DC demotion or "on the fly" by itself.

DETAILS:

CREATED:

    2000/05/01  Jeff Parham (jeffparh)
        Parts adapted from ntdsetup (author ColinBr).

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsa.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <winldap.h>
#include <ntldap.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <attids.h>
#include <objids.h>

#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes
#include "dsexcept.h"
#include "anchor.h"
#include "dstaskq.h"

#include "drserr.h"
#include "dsaapi.h"
#include "drautil.h"
#include "drsuapi.h"
#include "drancrep.h"
#include "dramail.h"
#include "drameta.h"

#include "debug.h"                      // standard debugging header
#define  DEBSUB "DRADEMOT:"              // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_DRADEMOT


///////////////////////////////////////////////////////////////////////////////
//
//  MACROS
//

#define DRA_REPORT_STATUS_TO_NTDSETUP0(msg) { \
    if (gpfnInstallCallBack) { \
        SetInstallStatusMessage((msg), NULL, NULL, NULL, NULL, NULL); \
    } \
}

#define DRA_REPORT_STATUS_TO_NTDSETUP1(msg, s1) { \
    if (gpfnInstallCallBack) { \
        SetInstallStatusMessage((msg), (s1), NULL, NULL, NULL, NULL); \
    } \
}

#define DRA_REPORT_STATUS_TO_NTDSETUP2(msg, s1, s2) { \
    if (gpfnInstallCallBack) { \
        SetInstallStatusMessage((msg), (s1), (s2), NULL, NULL, NULL); \
    } \
}


///////////////////////////////////////////////////////////////////////////////
//
//  MODULE VARIABLES
//

// Tracks state information re an ongoing DC demotion.
typedef struct _DRS_DEMOTE_INFO {
    // Info re an ongoing FSMO transfer being done as part of demotion.
    GUID  DsaObjGuid;
    DWORD tidDemoteThread;
} DRS_DEMOTE_INFO;

DRS_DEMOTE_INFO * gpDemoteInfo = NULL;


///////////////////////////////////////////////////////////////////////////////
//
//  LOCAL FUNCTION PROTOTYPES
//

DWORD
draGetDSADNFromDNSName(
    IN  THSTATE * pTHS,
    IN  LPWSTR    pszDNSName,
    OUT DSNAME ** ppDSADN
    );

void
draGiveAwayFsmoRoles(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN
    );

void
draCompletePendingLinkCleanup(
    IN  THSTATE *   pTHS
    );

void
draReplicateOffChanges(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN
    );


///////////////////////////////////////////////////////////////////////////////
//
//  GLOBAL FUNCTION IMPLEMENTATIONS
//

ULONG
DirReplicaGetDemoteTarget(
    IN      DSNAME *                        pNC,
    IN OUT  DRS_DEMOTE_TARGET_SEARCH_INFO * pDTSInfo,
    OUT     LPWSTR *                        ppszDemoteTargetDNSName,
    OUT     DSNAME **                       ppDemoteTargetDSADN
    )
/*++

Routine Description:

    Locate a DSA to which any remaining updates and FSMO roles can be
    transferred as part of demoting an NDNC replica.

    Caller can continue to call this API to get further candidates until
    an error is returned.

    Invokes the locator to find candidates.  An alternate implementation
    would be to search the config NC.

Arguments:

    pNC (IN) - NC being demoted.

    pDTSInfo (IN/OUT) - A search handle, of sorts.  Should be initialized to
        all zeros on the first call.  Caller may keep invoking this function
        as long as it returns success in order to find additional targets.

    ppszDemoteTargetDNSName (OUT) - On successful return, holds the DNS host
        name of the discovered target.  Caller should THFree when no longer
        useful.

    ppDemoteTargetDSADN (OUT) - On successful return, holds the ntdsDsa DN
        of the discovered target.  Caller should THFree when no longer useful.

Return Values:

    0 or Win32 error.

--*/
{
    THSTATE * pTHS = pTHStls;
    LPWSTR pszNC = pNC->StringName;
    DWORD err;
    BOOL fFoundDC;

    __try {
        if (NULL == pTHS) {
            pTHS = InitTHSTATE(CALLERTYPE_DRA);
            if (NULL == pTHS) {
                *ppDemoteTargetDSADN = NULL;
                *ppszDemoteTargetDNSName = NULL;
                DRA_EXCEPT(DRAERR_OutOfMem, 0);
            }
        }

        do {
            ULONG ulGetDCFlags = DS_AVOID_SELF | DS_IS_DNS_NAME | DS_RETURN_DNS_NAME
                                 | DS_ONLY_LDAP_NEEDED | DS_WRITABLE_REQUIRED;
            DS_NAME_RESULTW * pNameResult = NULL;
            DOMAIN_CONTROLLER_INFOW * pDCInfo = NULL;
            LPWSTR pszNCDnsName;
            DWORD cchNCDnsName;

            fFoundDC = FALSE;
            *ppDemoteTargetDSADN = NULL;
            *ppszDemoteTargetDNSName = NULL;

            __try {
                switch (pDTSInfo->cNumAttemptsSoFar) {
                case 0:
                    // Try to find a suitable DC, use the DC in the locator cache if
                    // available.
                    break;

                case 1:
                    // Try again to find a suitable DC, this time forcing the locator to
                    // refresh its cache.
                    ulGetDCFlags |= DS_FORCE_REDISCOVERY;
                    break;

                default:
                    Assert(!"Logic error!");
                case 2:
                    // Bag of tricks is empty.
                    err = ERROR_NO_SUCH_DOMAIN;
                    __leave;
                }

                // Convert NC name into a DNS name.
                err = DsCrackNamesW(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY, DS_FQDN_1779_NAME,
                                    DS_CANONICAL_NAME, 1, &pszNC, &pNameResult);
                if (err
                    || (1 != pNameResult->cItems)
                    || (DS_NAME_NO_ERROR != pNameResult->rItems[0].status)) {
                    if (!err) {
                        err = ERROR_DS_NAME_ERROR_RESOLVING;
                    }
                    DPRINT2(0, "Can't crack %ls into DNS name, error %d.\n",
                           pNC->StringName, err);
                    DRA_EXCEPT(err, 0);
                }

                pszNCDnsName = pNameResult->rItems[0].pName;
                cchNCDnsName = wcslen(pszNCDnsName);

                Assert(0 != cchNCDnsName);
                Assert(L'/' == pNameResult->rItems[0].pName[cchNCDnsName - 1]);

                if ((0 != cchNCDnsName)
                    && (L'/' == pNameResult->rItems[0].pName[cchNCDnsName - 1])) {
                    pNameResult->rItems[0].pName[cchNCDnsName - 1] = L'\0';
                }

                // Find another DC that hosts this NC.
                err = DsGetDcNameW(NULL, pszNCDnsName, &pNC->Guid, NULL, ulGetDCFlags,
                                   &pDCInfo);
                if (err) {
                    DPRINT2(0, "Can't find DC for %ls, error %d.\n",
                            pNC->StringName, err);
                    DRA_EXCEPT(err, 0);
                }

                Assert(NULL != pDCInfo);
                Assert(pDCInfo->Flags & DS_NDNC_FLAG);
                Assert(pDCInfo->Flags & DS_DNS_CONTROLLER_FLAG);

                fFoundDC = TRUE;
                pDTSInfo->cNumAttemptsSoFar++;

                *ppszDemoteTargetDNSName
                    = THAllocEx(pTHS,
                                sizeof(WCHAR)
                                * (1 + wcslen(pDCInfo->DomainControllerName)));
                wcscpy(*ppszDemoteTargetDNSName, pDCInfo->DomainControllerName);

                // Translate DSA DNS name into an ntdsDsa DN.
                err = draGetDSADNFromDNSName(pTHS,
                                             pDCInfo->DomainControllerName,
                                             ppDemoteTargetDSADN);
                if (err) {
                    DPRINT2(0, "Can't resolve DNS name %ls into an ntdsDsa DN, error %d.\n",
                            pDCInfo->DomainControllerName, err);

                    // Note that we __leave rather than DRA_EXCEPT so that we
                    // try the next cnadidate.
                    __leave;
                }

                Assert(NULL != *ppDemoteTargetDSADN);
                Assert(!fNullUuid(&(*ppDemoteTargetDSADN)->Guid));

                if (0 == memcmp(&(*ppDemoteTargetDSADN)->Guid,
                                &pDTSInfo->guidLastDSA,
                                sizeof(GUID))) {
                    // Found the same DC this time as we did last time.  Don't try
                    // it again.
                    Assert(2 == pDTSInfo->cNumAttemptsSoFar);
                    DPRINT1(0, "Forced DC location found same bad demotion target %ls.\n",
                            pDCInfo->DomainControllerName);
                    THFree(*ppDemoteTargetDSADN);
                    *ppDemoteTargetDSADN = NULL;
                    THFree(*ppszDemoteTargetDNSName);
                    *ppszDemoteTargetDNSName = NULL;
                    err = ERROR_NO_SUCH_DOMAIN;
                    DRA_EXCEPT(err, 0);
                }

                // Remember this candidate.
                pDTSInfo->guidLastDSA = (*ppDemoteTargetDSADN)->Guid;
            } __finally {
                if (NULL != pDCInfo) {
                    NetApiBufferFree(pDCInfo);
                }

                if (NULL != pNameResult) {
                    DsFreeNameResultW(pNameResult);
                }
            }
        } while (fFoundDC && err); // Found a candidate but e.g. couldn't resolve
                                   // its DNS name into a DN.
    } __except(GetDraException(GetExceptionInformation(), &err)) {
          if (err == ERROR_SUCCESS) {
              Assert(!"Leaving by exception should usually be a DB error right?!");
              err = ERROR_DS_UNKNOWN_ERROR;
          }
          if (*ppszDemoteTargetDNSName){
              THFree(*ppszDemoteTargetDNSName);
              *ppszDemoteTargetDNSName = NULL;
          }
          if (*ppDemoteTargetDSADN) {
              THFree(*ppDemoteTargetDSADN);
              *ppDemoteTargetDSADN = NULL;
          }
    }

    // If we didn't find a candidate then we must have set an appropriate error
    // to return.
    Assert(fFoundDC || err);

    // We return values iff there was no error.
    Assert(!!err == !*ppDemoteTargetDSADN);
    Assert(!!err == !*ppszDemoteTargetDNSName);

    return err;
}

ULONG
DirReplicaDemote(
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN,
    IN  ULONG       ulOptions
    )
/*++

Routine Description:

    Removes a writeable NC from a DSA, either as part of full DC demotion or
    "on the fly" by itself.

Arguments:

    pNC (IN) - Name of the writeable NC to remove.

    pszOtherDSADNSName (IN) - DNS name of DSA to transfer FSMO roles to.  Used
        for display purposes only -- replication still uses the GUID-based DNS
        name.

    pOtherDSADN (IN) - NTDS Settings (ntdsDsa) DN of the DSA to give FSMO
        roles/replicate to.

    ulOptions (IN) - Zero or more of the following bits:
        DRS_NO_SOURCE - This DC should no longer act as a replication source for
            this NC.  Set when a single NC is being removed from a running
            system, as opposed to when the entire DC is being demoted.  Not
            setting this flag during DC demotion makes this routine non-
            destructive, such that if some later part of the DC demotion fails
            then the DC can still operate with all the NCs it had prior to the
            demotion attempt.

Return Values:

    0 on success, Win32 error on failure.

--*/
{
    THSTATE * pTHS = pTHStls;
    SYNTAX_INTEGER it;
    DWORD err;
    BOOL fSavedDRA;

    __try {
        if ((NULL == pNC)
            || (NULL == pOtherDSADN)) {
            DRA_EXCEPT(DRAERR_InvalidParameter, 0);
        }

        if (NULL == pTHS) {
            pTHS = InitTHSTATE(CALLERTYPE_DRA);
            if (NULL == pTHS) {
                DRA_EXCEPT(DRAERR_OutOfMem, 0);
            }
        }

        SyncTransSet(SYNC_WRITE);

        __try {
            // Validate NC argument.
            err = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC, &it);
            if (err) {
                // Writeable NC not instantiated on this DSA.
                DRA_EXCEPT(err, 0);
            }

            if (it & IT_NC_GOING) {
                // NC is already in the process of being torn down.  It's too
                // late to give away FSMO roles, etc.  The DS will take care of
                // completing the NC removal.
                DRA_EXCEPT(DRAERR_NoReplica, it);
            }

            if ((DRS_NO_SOURCE & ulOptions)
                && DBHasValues(pTHS->pDB, ATT_REPS_FROM)) {
                // We still have inbound replication partners for this NC.
                // Those must be removed first (unless we're demoting the entire
                // DC).
                DRA_EXCEPT(DRAERR_BadNC, 0);
            }

            // Validate other DSA DN argument.
            err = DBFindDSName(pTHS->pDB, pOtherDSADN);
            if (err) {
                DRA_EXCEPT(DRAERR_BadDN, err);
            }

            DBFillGuidAndSid(pTHS->pDB, pOtherDSADN);
        } __finally {
            // Close transaction before beginning operations that may go off
            // machine.
            SyncTransEnd(pTHS, !AbnormalTermination());
        }

        // Transfer NC-specific FSMO roles to other DSA.
        draGiveAwayFsmoRoles(pTHS, pNC, pszOtherDSADNSName, pOtherDSADN);

        // Disable further originating writes and inbound replication of
        // this NC (on this DSA).
        // BUGBUG - jeffparh - TODO

        // Complete any pending link cleanup tasks -- e.g., touching the
        // membership of pre-existing groups that have been switched to
        // universal groups.  This is necessary in this specific case to
        // ensure that GCs quiesce to a consistent state (i.e., by
        // appropriately adding the membership of the now-universal
        // group).
        draCompletePendingLinkCleanup(pTHS);

        // Replicate off any local changes to other DSA.
        draReplicateOffChanges(pTHS, pNC, pszOtherDSADNSName, pOtherDSADN);

        if (DRS_NO_SOURCE & ulOptions) {
            // Schedule asynchronous removal of the NC from the DS (if this is
            // not a full DC demotion).
            err = DirReplicaDelete(pNC,
                                   NULL,
                                   DRS_REF_OK | DRS_NO_SOURCE | DRS_ASYNC_REP);
            if (err) {
                DRA_EXCEPT(err, 0);
            }
        } else {

            // In this case, we're demoting this DC.  This means that we
            // should IT_NC_GOING so that later when we try to get the 
            // list of remaing instantiated NDNCs, this NC is not returned.
            // 
            // BUGBUG - BrettSh - 8/1/2001 - There is a bug with this approach
            // in that if we fail the dcpromo then this NC will be left with
            // the IT_NC_GOING bit set.  The NC will remain locally instantiated
            // though not advertised, until such time as we reboot, when the NC
            // will simply be removed.
            if(fIsNDNC(pNC)){
                
                SyncTransSet(SYNC_WRITE);

                __try {
                    // Validate NC argument.
                    err = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC, &it);
                    if (err) {
                        // Writeable NC not instantiated on this DSA.
                        DRA_EXCEPT(err, 0);
                    }

                    // Change instance type to reflect that the NC is not valid
                    // (instantiated) ... now technically while it isn't going
                    // it's 
                    fSavedDRA = pTHS->fDRA;
                    pTHS->fDRA = TRUE;
                    it = (it & ~IT_NC_COMING) | IT_NC_GOING;
                    err = ChangeInstanceType(pTHS, pNC, it, DSID(FILENO,__LINE__));
                    if (err) {
                        DRA_EXCEPT(err, 0);
                    }

                    // Must also remove the reps-from, so we don't try a scheduled
                    // replication from any partners.
                    err = DBRemAtt(pTHS->pDB, ATT_REPS_FROM);
                    if (err) {
                        if (err == DB_ERR_ATTRIBUTE_DOESNT_EXIST) {
                            err = DB_success;
                        } else {
                            // remove attribute failed
                            DRA_EXCEPT(DRAERR_InternalError, err);
                        }
                    }

                    err = DBRepl(pTHS->pDB, TRUE, DBREPL_fKEEP_WAIT, 
                                 NULL, META_STANDARD_PROCESSING);
                    if (err) {
                        DRA_EXCEPT(DRAERR_InternalError, err);
                    }

                } __finally {
                    pTHS->fDRA = fSavedDRA;
                    SyncTransEnd(pTHS, !AbnormalTermination());
                }
            }
        }

    } __except(GetDraException(GetExceptionInformation(), &err)) {
        ;
    }

    return err;
}


BOOL
draIsCompletionOfDemoteFsmoTransfer(
    IN  DRS_MSG_GETCHGREQ_NATIVE *  pMsgIn    OPTIONAL
    )
/*++

Routine Description:

    Detects whether the caller is involved in completing a FSMO transfer that's
    being performed as part of DC (not just NC) demotion.  Since as a rule
    writes are disabled during DC demotion (even replicator writes), the caller
    uses this information to determine whether he can bypass write restrictions.
    Without bypassing write restrictions, he would generate a
    DRA_EXCEPT(DRAERR_Busy, 0) when calling BeginDraTransaction.

    The sequence of events is:

    DC1   ntdsetup!NtdsPrepareForDemotion
        * ntdsetup!NtdspDisableDs <- disables further writes
          ntdsa!DirReplicaDemote(pNC, DC2)
          ntdsa!draGiveAwayFsmoRoles(pNC, DC2)
          ntdsa!GiveawayAllFsmoRoles(pNC, DC2)
          ntdsa!ReqFsmoOpAux(pFSMO, FSMO_ABANDON_ROLE, DC2)
          ntdsa!I_DRSGetNCChanges(DC2, {DC1, pFSMO, FSMO_ABANDON_ROLE})

    DC2   ntdsa!IDL_DRSGetNCChanges({DC1, pFSMO, FSMO_ABANDON_ROLE})
          ntdsa!DoFSMOOp({DC1, pFSMO, FSMO_ABANDON_ROLE})
          ntdsa!GenericBecomeMaster(pFSMO)
          ntdsa!ReqFsmoOpAux(pFSMO, FSMO_REQ_ROLE, DC1)
          ntdsa!I_DRSGetNCChanges(DC1, {DC2, pFSMO, FSMO_REQ_ROLE})

    DC1   ntdsa!IDL_DRSGetNCChanges({DC2, pFSMO, FSMO_REQ_ROLE})
          ntdsa!DoFSMOOp({DC2, pFSMO, FSMO_REQ_ROLE})
        * ntdsa!draIsCompletionOfDemoteFsmoTransfer({DC2, pFSMO, FSMO_REQ_ROLE})
        * ntdsa!BeginDraTransaction(SYNC_WRITE, TRUE) <- okay to bypass chk
          ntdsa!FSMORoleTransfer(pFSMO, DC2)
          return from ntdsa!IDL_DRSGetNCChanges

    DC2   return from ntdsa!IDL_DRSGetNCChanges

    DC1 * ntdsa!draIsCompletionOfDemoteFsmoTransfer(NULL)
        * ntdsa!BeginDraTransaction(SYNC_WRITE, TRUE) <- okay to bypass chk
          return from ntdsa!draGiveAwayFsmoRoles
          ...

Arguments:

    pMsgIn (IN, OPTIONAL) - If present, indicates DC1 is (possibly) fulfilling
        DC2's FSMO_REQ_ROLE request.  If not present, indicates DC1 is
        (possibly) writing the updates returned from the completed
        FSMO_ABANDON_ROLE request.

Return Values:

    TRUE - This is the completion of the DC demote FSMO transfer and therefore
        the value of ntdsa!gUpdatesEnabled can be ignored.

    FALSE - Otherwise, in which case ntdsa!gUpdatesEnabled should be adhered to.

--*/
{
    DRS_DEMOTE_INFO * pDemoteInfo = gpDemoteInfo;
    BOOL fIsCompletionOfDemoteFsmoTransfer = FALSE;

    if (// Performing DC demotion.
        !gUpdatesEnabled
        && (NULL != pDemoteInfo)
        && ((// Writing new role owner value so we can send back to new owner.
             (NULL != pMsgIn)
             && (EXOP_FSMO_REQ_ROLE == pMsgIn->ulExtendedOp)
             && (0 == memcmp(&pDemoteInfo->DsaObjGuid,
                             &pMsgIn->uuidDsaObjDest,
                             sizeof(GUID))))
            || (// Applying updates in reply from new owner.
                (NULL == pMsgIn)
                && (pDemoteInfo->tidDemoteThread == GetCurrentThreadId())))) {
        fIsCompletionOfDemoteFsmoTransfer = TRUE;
    }

    return fIsCompletionOfDemoteFsmoTransfer;
}


///////////////////////////////////////////////////////////////////////////////
//
//  LOCAL FUNCTION IMPLEMENTATIONS
//


DWORD
draGetDSADNFromDNSName(
    IN  THSTATE * pTHS,
    IN  LPWSTR    pszDNSName,
    OUT DSNAME ** ppDSADN
    )
/*++

Routine Description:

    Convert a DSA DNS name (such as that returned by the locator) into a DSA
    DN.  Goes off machine as an LDAP client to read the DSA's rootDSE (similar
    to invoking the locator).

    An alternate implementation would be to search for all server objects
    in the config NC that have this DNS name as their ATT_DNS_HOST_NAME, then
    find the first one that has a live ntdsDsa child.  However, we're about
    to go contact this machine anyway (to transfer FSMO roles and force
    replication), so it doesn't really make much difference.

Arguments:

    pszDNSName (IN) - DNS name of the remote DSA.

    ppDSADN (OUT) - On successful return, the corresponding ntdsDsa DN.

Return Values:

    0 or Win32 error.

--*/
{
#define SZRAWUUID_LEN (2 * sizeof(GUID)) // 2 hex characters per byte

    LPWSTR rgpszAttrsToRead[] = {
        LDAP_OPATT_DS_SERVICE_NAME_W,
        NULL
    };

    LDAPControlW ExtendedDNCtrl = {
        LDAP_SERVER_EXTENDED_DN_OID_W, {0, NULL}, TRUE // isCritical
    };

    LDAPControlW * rgpServerCtrls[] = {
        &ExtendedDNCtrl,
        NULL
    };

    LDAP_TIMEVAL tvTimeout = {2 * 60, 0}; // 2 minutes (possible dial-on-demand)

    LDAP * hld = NULL;
    LDAPMessage * pResults = NULL;
    LDAPMessage * pEntry = NULL;
    DWORD err = 0;
    int ldErr;
    LPWSTR * ppszDsServiceName = NULL;
    WCHAR szGuid[1 + SZRAWUUID_LEN];
    BYTE rgbGuid[sizeof(GUID)];
    DWORD ib;
    WCHAR szHexByte[3] = {0};
    GUID guidDsaObj;
    ULONG ulOptions;
    DSNAME * pGuidOnlyDN = (DSNAME *) THAllocEx(pTHS,DSNameSizeFromLen(0));

    *ppDSADN = NULL;
    Assert(!pTHS->fSyncSet);

    __try {
        if ((L'\\' == pszDNSName[0]) && (L'\\' == pszDNSName[1])) {
            // Skip '\\' prefix -- ldap_initW doesn't like it.
            pszDNSName += 2;
        }

        hld = ldap_initW(pszDNSName, LDAP_PORT);
        if (!hld) {
            err = LdapGetLastError();
            Assert(err);
            DPRINT2(0, "ldap_initW to %ls failed, error %d.\n", pszDNSName, err);
            __leave;
        }

        // use only A record dns name discovery
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

        ldErr = ldap_search_ext_sW(hld, NULL, LDAP_SCOPE_BASE,
                                   L"(objectClass=*)", rgpszAttrsToRead, 0,
                                   rgpServerCtrls, NULL, &tvTimeout,
                                   LDAP_NO_LIMIT, &pResults);
        if (ldErr) {
            err = LdapMapErrorToWin32(ldErr);
            Assert(err);
            DPRINT3(0, "ldap_search of %ls failed, error %d (LDAP error %d).\n",
                    pszDNSName, err, ldErr);
            __leave;
        }

        pEntry = ldap_first_entry(hld, pResults);
        if (NULL == pEntry) {
            err = LdapGetLastError();
            Assert(err);
            DPRINT2(0, "ldap_first_entry failed, error %d.\n", pszDNSName, err);
            __leave;
        }

        ppszDsServiceName = ldap_get_valuesW(hld, pEntry,
                                             LDAP_OPATT_DS_SERVICE_NAME_W);
        if (NULL == ppszDsServiceName) {
            err = LdapGetLastError();
            Assert(err);
            DPRINT1(0, "ldap_get_values failed, error %d.\n", err);
            __leave;
        }

        Assert(1 == ldap_count_valuesW(ppszDsServiceName));

        if ((NULL == ppszDsServiceName[0])
            || (0 != wcsncmp(ppszDsServiceName[0], L"<GUID=", 6))
            || (wcslen(ppszDsServiceName[0] + 6) < SZRAWUUID_LEN)
            || (L'>' != ppszDsServiceName[0][6+SZRAWUUID_LEN])) {
            // DN didn't come back in the format we expected.
            err = ERROR_DS_INVALID_DN_SYNTAX;
            DPRINT1(0, "Unexpected syntax for DN.\n", err);
            __leave;
        }

        wcsncpy(szGuid, ppszDsServiceName[0] + 6, SZRAWUUID_LEN);
        szGuid[SZRAWUUID_LEN] = 0;

        // Decode hex digit stream (e.g., 625c1438265ad211b3880000f87a46c8).
        for (ib = 0; ib < sizeof(GUID); ib++) {
            szHexByte[0] = towlower(szGuid[2*ib]);
            szHexByte[1] = towlower(szGuid[2*ib + 1]);
            if (iswxdigit(szHexByte[0]) && iswxdigit(szHexByte[1])) {
                rgbGuid[ib] = (BYTE) wcstol(szHexByte, NULL, 16);
            }
            else {
                // DN didn't come back in the format we expected.
                err = ERROR_DS_INVALID_DN_SYNTAX;
                DPRINT2(0, "Unexpected syntax for guid '%ls'.\n", szGuid, err);
                __leave;
            }
        }

        // Get the local string DN for this object, which may be different from
        // the remote string DN due to replication latency.
        pGuidOnlyDN->structLen = DSNameSizeFromLen(0);
        pGuidOnlyDN->NameLen = 0;
        memcpy(&pGuidOnlyDN->Guid, rgbGuid, sizeof(GUID));


        SyncTransSet(SYNC_WRITE);

        __try {
            err = DBFindDSName(pTHS->pDB, pGuidOnlyDN);
            if (err) {
                DPRINT2(0, "Unable to find DSA object with guid %ls, error %d.\n",
                        szGuid, err);
                err = ERROR_DS_CANT_FIND_DSA_OBJ;
                __leave;
            }

            *ppDSADN = GetExtDSName(pTHS->pDB);
            if (NULL == *ppDSADN) {
                err = ERROR_DS_DRA_DB_ERROR;
                __leave;
            }
        } __finally {
            SyncTransEnd(pTHS, !AbnormalTermination());
        }
    

    } __finally {
        if (NULL != pResults) {
            ldap_msgfree(pResults);
        }

        if (NULL != ppszDsServiceName){
            ldap_value_freeW(ppszDsServiceName);
	}

        if (NULL != hld) {
            ldap_unbind(hld);
        }

        THFreeEx(pTHS,pGuidOnlyDN);
    }

    if (!err && (NULL == *ppDSADN)) {
        Assert(!"Logic error!");
        err = ERROR_DS_UNKNOWN_ERROR;
    }

    return err;
}

void
draGiveAwayFsmoRoles(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN
    )
/*++

Routine Description:

    Invoke the appropriate DS operational control to tranfer FSMO roles held by
    the local DSA for pNC to pOtherDSADN.

    Adapted from ntdsetup!NtdspGetRidOfAllFSMOs.

Arguments:

    pTHS (IN)

    pNC (IN) - NC for which to give up FSMO roles.

    pszOtherDSADNSName (IN) - DNS name of DSA to transfer FSMO roles to.  Used
        for display purposes only -- replication still uses the GUID-based DNS
        name.

    pOtherDSADN (IN) - DN of ntdsDsa object for DSA to transfer FSMO roles to.

Return Values:

    None.  Throws exception on failure.

--*/
{
    DWORD err;
    DWORD dirErr;
    OPARG OpArg = {0};
    OPRES *pOpRes = NULL;
    DWORD cbFsmoData;
    FSMO_GIVEAWAY_DATA *pFsmoData = NULL;
    LPWSTR psz;
    DRS_DEMOTE_INFO * pDemoteInfo;

    DRA_REPORT_STATUS_TO_NTDSETUP2(DIRMSG_DEMOTE_NC_GIVING_AWAY_FSMO_ROLES,
                                   pNC->StringName,
                                   pszOtherDSADNSName);

    pDemoteInfo = malloc(sizeof(*pDemoteInfo));
    if (NULL == pDemoteInfo) {
        DRA_EXCEPT(DRAERR_OutOfMem, sizeof(*pDemoteInfo));
    }

    __try {
        pDemoteInfo->DsaObjGuid = pOtherDSADN->Guid;
        pDemoteInfo->tidDemoteThread = GetCurrentThreadId();
        gpDemoteInfo = pDemoteInfo;

        cbFsmoData = offsetof(FSMO_GIVEAWAY_DATA, V2)
                     + offsetof(FSMO_GIVEAWAY_DATA_V2, Strings)
                     + (pOtherDSADN->NameLen + 1) * sizeof(WCHAR)
                     + (pNC->NameLen + 1) * sizeof(WCHAR);
        pFsmoData = THAllocEx(pTHS, cbFsmoData);

        pFsmoData->Version = 2;

        if (NameMatched(gAnchor.pDMD, pNC)
            || NameMatched(gAnchor.pConfigDN, pNC)) {
            pFsmoData->V2.Flags = FSMO_GIVEAWAY_ENTERPRISE;
        } else if (NameMatched(gAnchor.pDomainDN, pNC)) {
            pFsmoData->V2.Flags = FSMO_GIVEAWAY_DOMAIN;
        } else {
            pFsmoData->V2.Flags = FSMO_GIVEAWAY_NONDOMAIN;
        }

        psz = pFsmoData->V2.Strings;

        // Copy DSA name.
        pFsmoData->V2.NameLen = pOtherDSADN->NameLen;
        memcpy(psz, pOtherDSADN->StringName, sizeof(WCHAR) * pOtherDSADN->NameLen);
        // Already null-terminated by virtue of THAlloc().
        psz += 1 + pOtherDSADN->NameLen;

        // Copy NC name.
        pFsmoData->V2.NCLen = pNC->NameLen;
        memcpy(psz, pNC->StringName, sizeof(WCHAR) * pNC->NameLen);
        // Already null-terminated by virtue of THAlloc().

        OpArg.eOp = OP_CTRL_FSMO_GIVEAWAY;
        OpArg.pBuf = (BYTE *) pFsmoData;
        OpArg.cbBuf = cbFsmoData;

        dirErr = DirOperationControl(&OpArg, &pOpRes);
    } __finally {
        gpDemoteInfo = NULL;
        DELAYED_FREE(pDemoteInfo);
    }

    if (dirErr != 0) {
        // Something went wrong, log an event.
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_GIVEAWAY_ALL_FSMOS_FAILURE,
                  szInsertSz(pszOtherDSADNSName),
                  szInsertWin32Msg(DirErrorToWinError(dirErr, &(pOpRes->CommRes))),
                  szInsertUL(GetErrInfoExtData(dirErr, pOpRes->CommRes.pErrInfo)),
                  szInsertUL((DWORD) GetErrInfoProblem(dirErr, pOpRes->CommRes.pErrInfo)),
                  szInsertUL(GetErrInfoDSID(dirErr, pOpRes->CommRes.pErrInfo)),
                  NULL, NULL, NULL);
    }

    err = DirErrorToWinError(dirErr, &pOpRes->CommRes);
    if (err) {
        DRA_EXCEPT(err, 0);
    }

    DRA_REPORT_STATUS_TO_NTDSETUP2(DIRMSG_DEMOTE_NC_GIVING_AWAY_FSMO_ROLES_COMPELETE,
                                   pNC->StringName,
                                   pszOtherDSADNSName);
    

    THFreeEx(pTHS, pFsmoData);
    THFreeEx(pTHS, pOpRes);
}


void
draCompletePendingLinkCleanup(
    IN  THSTATE *   pTHS
    )
/*++

Routine Description:

    Force a run of the link cleaner to complete any pending link cleanup tasks.

Parameters:

    pTHS (IN)

Return Values:

    None.  Throws exception on failure.

--*/
{
    DRA_REPORT_STATUS_TO_NTDSETUP0(DIRMSG_DEMOTE_NC_COMPLETING_LINK_CLEANUP);

#ifdef LATER
    DWORD err;
    DWORD dirErr;
    OPARG OpArg = {0};
    OPRES *pOpRes = NULL;
    DWORD LinkCleanupData = 0;

    OpArg.eOp = OP_CTRL_LINK_CLEANUP;
    OpArg.pBuf = (BYTE *) &LinkCleanupData;
    OpArg.cbBuf = sizeof(LinkCleanupData);

    do {
        dirErr = DirOperationControl(&OpArg, &pOpRes);

        err = DirErrorToWinError(dirErr, &pOpRes->CommRes);
        if (err) {
            DRA_EXCEPT(err, 0);
        }

        err = pOpRes->ulExtendedRet;
        THFreeEx(pTHS, pOpRes);
        pOpRes = NULL;
    } while (!err);

    // Link cleanup completed successfully!
    Assert(ERROR_NO_MORE_ITEMS == err);
#else
    ;
#endif
}


void
draReplicateOffChanges(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN
    )
/*++

Routine Description:

    Ensure pszOtherDSAAddr has all updates in pNC that we have (be they
    originated or replicated).

Parameters:

    pTHS (IN)

    pNC (IN) - NC to sync.

    pszOtherDSADNSName (IN) - DNS name of DSA to transfer FSMO roles to.  Used
        for display purposes only -- replication still uses the GUID-based DNS
        name.

    pszOtherDSAAddr (IN) - DNS name (GUID-based or otherwise) of DSA to push
        changes to.

Return Values:

    None.  Throws exception on failure.

--*/
{
    DWORD err;
    LPWSTR pszOtherDSAAddr = NULL;
    LPWSTR pszOurGuidDNSName;

    DRA_REPORT_STATUS_TO_NTDSETUP2(DIRMSG_DEMOTE_NC_REPLICATING_OFF_CHANGES,
                                   pNC->StringName,
                                   pszOtherDSADNSName);

    // Get network address of the other DSA.
    pszOtherDSAAddr = DSaddrFromName(pTHS, pOtherDSADN);
    if (NULL == pszOtherDSAAddr) {
        DRA_EXCEPT(DRAERR_OutOfMem, 0);
    }

    // Tell pszOtherDSAAddr to get changes from us.
    err = I_DRSReplicaSync(pTHS, pszOtherDSAAddr, pNC, NULL,
                           &gAnchor.pDSADN->Guid, DRS_WRIT_REP);

    if (ERROR_DS_DRA_REPL_PENDING == err) {
        MTX_ADDR *  pmtxMail;
        // A mail-based reps-from is present. Remove it preparatory to
        // creating an RPC-based one.

        SyncTransSet(SYNC_READ_ONLY);
        __try {
            pmtxMail = draGetTransportAddress(pTHS->pDB, gAnchor.pDSADN, ATT_SMTP_MAIL_ADDRESS);
            if (NULL == pmtxMail) {
                DRA_EXCEPT(ERROR_DS_MISSING_REQUIRED_ATT, 0);
            }
        } __finally {
            SyncTransEnd(pTHS, !AbnormalTermination());
        }

        pszOurGuidDNSName = TransportAddrFromMtxAddrEx(pmtxMail);

        THFreeEx(pTHS, pmtxMail);

        // WISH: the ability to delete by source dsa guid would be useful here.
        // It would remove the dependency on knowing the reps-from
        // transport-specific address.
        err = I_DRSReplicaDel( pTHS, pszOtherDSAAddr, pNC, pszOurGuidDNSName,
                               DRS_WRIT_REP | DRS_LOCAL_ONLY );
        if (err) {
            DRA_EXCEPT(err, 0);
        }

        THFreeEx(pTHS, pszOurGuidDNSName);

        err = ERROR_DS_DRA_NO_REPLICA;
    }
    if (ERROR_DS_DRA_NO_REPLICA == err) {
        // pszOtherDSAAddr does not currently have a replication agreement
        // (repsFrom) for us -- tell it to add one.

        pszOurGuidDNSName = TransportAddrFromMtxAddrEx(gAnchor.pmtxDSA);

        err = I_DRSReplicaAdd(pTHS, pszOtherDSAAddr, pNC, NULL, NULL,
                              pszOurGuidDNSName, NULL, DRS_WRIT_REP);
        if (err) {
            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_REPLICATE_OFF_CHANGES_FAILURE,
                      szInsertDN(pNC),
                      szInsertWC(pszOtherDSAAddr), 
                      szInsertWin32ErrCode(err),
                      szInsertWin32Msg(err),
                      NULL, NULL, NULL, NULL);
            DRA_EXCEPT(err, 0);
        }

        THFreeEx(pTHS, pszOurGuidDNSName);
    } else if (err) {
        // Sync failed with an error other than ERROR_DS_DRA_NO_REPLICA.
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_REPLICATE_OFF_CHANGES_FAILURE,
                  szInsertDN(pNC),
                  szInsertWC(pszOtherDSAAddr), 
                  szInsertWin32ErrCode(err),
                  szInsertWin32Msg(err),
                  NULL, NULL, NULL, NULL);
        DRA_EXCEPT(err, 0);
    }

    // Sync or add completed successfully!

    DRA_REPORT_STATUS_TO_NTDSETUP2(DIRMSG_DEMOTE_NC_REPLICATING_OFF_CHANGES_COMPELETE,
                                   pNC->StringName,
                                   pszOtherDSADNSName);
    

    THFreeEx(pTHS, pszOtherDSAAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\dradir.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       dradir.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"


#include   "debug.h"                    /* standard debugging header */
#define DEBSUB     "DRADIR:"            /* define the subsystem for debugging */


#include "dsaapi.h"
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "draasync.h"
#include "drautil.h"
#include "draerror.h"

#include <fileno.h>
#define  FILENO FILENO_DRADIR

/* Macro to force alignment of a buffer.  Assumes that it may move pointer
 * forward up to 7 bytes.
 */
#define ALIGN_BUFF(pb)  pb += (8 - ((DWORD_PTR)(pb) % 8)) % 8
#define ALIGN_PAD(x) (x * 8)


ULONG
DirReplicaAdd(
    IN  DSNAME *    pNC,
    IN  DSNAME *    pSourceDsaDN,               OPTIONAL
    IN  DSNAME *    pTransportDN,               OPTIONAL
    IN  LPWSTR      pszSourceDsaAddress,
    IN  LPWSTR      pszSourceDsaDnsDomainName,  OPTIONAL
    IN  REPLTIMES * preptimesSync,              OPTIONAL
    IN  ULONG       ulOptions
    )
/*++

Routine Description:

    Add inbound replication of an NC (which may or may not already exist
    locally) from a given source DSA.

Arguments:

    pNC (IN) - NC for which to add the replica.  The NC record must exist
        locally as either an object (instantiated or not) or a reference
        phantom (i.e., a phantom with a guid).

    pSourceDsaDN (IN, OPTIONAL) - DN of the source DSA's ntdsDsa object.
        Required if ulOptions includes DRS_ASYNC_REP; ignored otherwise.

    pTransportDN (IN, OPTIONAL) - DN of the interSiteTransport object
        representing the transport by which to communicate with the source
        server.  Required if ulOptions includes DRS_MAIL_REP; ignored otherwise.

    pszSourceDsaAddress (IN) - Transport-specific address of the source DSA.

    pszSourceDsaDnsDomainName (IN, OPTIONAL) - DNS domain name of the source
        server.  If pszSourceDsaAddress is not a GUID-based DNS name for an
        ntdsDsa object that is present on the local machine, this parameter
        is required if the caller wants mutual authentication.

    preptimesSync (IN, OPTIONAL) - Schedule by which to replicate the NC from
        this source in the future.

    ulOptions (IN) - Zero or more of the following bits:
        DRS_ASYNC_OP
            Perform this operation asynchronously.
        DRS_WRIT_REP
            Create a writeable replica.  Otherwise, read-only.
        DRS_MAIL_REP
            Sync from the source DSA via mail (i.e., an ISM transport) rather
            than RPC.
        DRS_ASYNC_REP
            Don't replicate the NC now -- just save enough state such that we
            know to replicate it later.
        DRS_INIT_SYNC
            Sync the NC from this source when the DSA is started.
        DRS_PER_SYNC
            Sync the NC from this source periodically, as defined by the
            schedule passed in the preptimesSync argument.
        DRS_CRITICAL_ONLY
            Sync only the critical objects now
        DRS_DISABLE_AUTO_SYNC
            Disable notification-based synchronization for the NC from this
            source.  (Synchronization can be forced by using the DRS_SYNC_FORCED
            bit in the sync request options.)
        DRS_DISABLE_PERIODIC_SYNC
            Disable periodic synchronization for the NC from this source.
            (Synchronization can be forced by using the DRS_SYNC_FORCED bit in
            the sync request options.)

Return Values:

    0 - Success.
    DRSERR_* - Failure.

--*/
{
    THSTATE * pTHS = pTHStls;
    AO *pao;
    UCHAR *pb;
    unsigned int cbTimes;
    DWORD cbSourceDsaDN;
    DWORD cbTransportDN;
    DWORD cbDnsDomainName;
    ULONG ret;
    MTX_ADDR *pmtx_addr;
    BOOL fDRAOnEntry;
    BOOL fResetfDRAOnExit = FALSE;

    if (    ( NULL == pNC )
         || ( NULL == pszSourceDsaAddress )
       )
    {
        return DRAERR_InvalidParameter;
    }

    // This prevents callers from setting reserved flags
    if (ulOptions & (~REPADD_OPTIONS)) {
        Assert( !"Unexpected replica add options" );
        return DRAERR_InvalidParameter;
    }

    PERFINC(pcRepl);                    // PerfMon hook

    if (NULL != pTHS) {
        fDRAOnEntry = pTHS->fDRA;
        fResetfDRAOnExit = TRUE;
    }

    __try {
        InitDraThread(&pTHS);

        pmtx_addr = MtxAddrFromTransportAddrEx(pTHS, pszSourceDsaAddress);

        cbTimes = (preptimesSync == NULL) ? 0 : sizeof(REPLTIMES);
        cbSourceDsaDN = (NULL == pSourceDsaDN) ? 0 : pSourceDsaDN->structLen;
        cbTransportDN = (NULL == pTransportDN) ? 0 : pTransportDN->structLen;
        cbDnsDomainName = (NULL == pszSourceDsaDnsDomainName)
                            ? 0
                            : sizeof(WCHAR) * (1 + wcslen(pszSourceDsaDnsDomainName));

        if ((pao = malloc(sizeof(AO) +
                          ALIGN_PAD(6) + /* align pad for 6 variable-length args */
                          pNC->structLen +
                          cbSourceDsaDN +
                          cbTransportDN +
                          MTX_TSIZE(pmtx_addr) +
                          cbDnsDomainName +
                          cbTimes)) == NULL) {
            ret = DRAERR_OutOfMem;
            DEC(pcThread);              // PerfMon hook
            return ret;
        }

        pao->ulOperation = AO_OP_REP_ADD;
        pao->ulOptions = ulOptions;

        // Append variable-length arguments.

        pb = (UCHAR *)pao + sizeof(AO);
        ALIGN_BUFF(pb);

        pao->args.rep_add.pNC = (DSNAME *)(pb);
        memcpy(pb, pNC, pNC->structLen);
        pb += pNC->structLen;
        ALIGN_BUFF(pb);

        if (cbSourceDsaDN) {
            pao->args.rep_add.pSourceDsaDN = (DSNAME *) pb;
            memcpy(pb, pSourceDsaDN, cbSourceDsaDN);
            pb += cbSourceDsaDN;
            ALIGN_BUFF(pb);
        }
        else {
            pao->args.rep_add.pSourceDsaDN = NULL;
        }

        if (cbTransportDN) {
            pao->args.rep_add.pTransportDN = (DSNAME *) pb;
            memcpy(pb, pTransportDN, cbTransportDN);
            pb += cbTransportDN;
            ALIGN_BUFF(pb);
        }
        else {
            pao->args.rep_add.pTransportDN = NULL;
        }

        if (cbDnsDomainName) {
            pao->args.rep_add.pszSourceDsaDnsDomainName = (LPWSTR) pb;
            memcpy(pb, pszSourceDsaDnsDomainName, cbDnsDomainName);
            pb += cbDnsDomainName;
            ALIGN_BUFF(pb);
        }
        else {
            pao->args.rep_add.pszSourceDsaDnsDomainName = NULL;
        }

        pao->args.rep_add.pDSASMtx_addr = (MTX_ADDR*)(pb);
        memcpy(pb, pmtx_addr, MTX_TSIZE(pmtx_addr));
        pb += MTX_TSIZE(pmtx_addr);
        ALIGN_BUFF(pb);

        if (cbTimes) {
            pao->args.rep_add.preptimesSync = (REPLTIMES *)pb;
            memcpy(pb, preptimesSync, cbTimes);
        }
        else {
            pao->args.rep_add.preptimesSync = NULL;
        }

        if(!(ulOptions & DRS_ASYNC_OP)){
            // A synchronous operation can take a _long_ time!
            pTHS->fIsValidLongRunningTask = TRUE;
        }

        ret = DoOpDRS(pao);

        THFreeEx(pTHS, pmtx_addr);
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
        ;
    }

    if (fResetfDRAOnExit) {
        pTHS->fDRA = fDRAOnEntry;
    }

    return ret;
}


ULONG
DirReplicaDelete(
    IN  DSNAME *          pNC,
    IN  LPWSTR            pszSourceDRA,         OPTIONAL
    IN  ULONG             ulOptions
    )
/*++

Routine Description:

    Delete a source of a given NC for the local server.

Arguments:

    pNC (IN) - Name of the NC for which to delete a source.

    pszSourceDRA (IN, OPTIONAL) - DSA for which to delete the source.  Required
        unless ulOptions & DRS_NO_SOURCE.

    ulOptions (IN) - Bitwise OR of zero or more of the following:
        DRS_ASYNC_OP
            Perform this operation asynchronously.
        DRS_REF_OK
            Allow deletion of read-only replica even if it sources other read-
            only replicas.
        DRS_NO_SOURCE
            Delete all the objects in the NC.  Incompatible with (and rejected
            for) writeable NCs that are not non-domain NCs.  This is valid only
            for read-only and non-domain NCs, and then only if the NC has no
            source.
        DRS_LOCAL_ONLY
            Do not contact the source telling it to scratch this server from
            its Rep-To for this NC.  Otherwise, if the link is RPC-based, the
            source will be contacted.
        DRS_IGNORE_ERROR
            Ignore any error generated by contacting the source to tell it to
            scratch this server from its Reps-To for this NC.
        DRS_ASYNC_REP
            If a tree removal is required (i.e., if DRS_NO_SOURCE), do that
            part asynchronously.

Return Values:

    0 on success, or Win32 error on failure.

--*/
{
    THSTATE * pTHS = pTHStls;
    AO *pao;
    UCHAR *pb;
    ULONG ret;
    MTX_ADDR *pSDSAMtx_addr = NULL;
    BOOL fDRAOnEntry;
    BOOL fResetfDRAOnExit = FALSE;
    DWORD cb;

    if ( NULL == pNC )
    {
        return DRAERR_InvalidParameter;
    }

    // This prevents callers from using reserved flags
    if (ulOptions & (~REPDEL_OPTIONS)) {
        Assert( !"Unexpected replica del options" );
        return DRAERR_InvalidParameter;
    }

    PERFINC(pcRepl);                    // PerfMon hook

    if (NULL != pTHS) {
        fDRAOnEntry = pTHS->fDRA;
        fResetfDRAOnExit = TRUE;
    }

    __try {
        InitDraThread(&pTHS);

        cb = sizeof(AO) + ALIGN_PAD(2) + pNC->structLen;

        if (NULL != pszSourceDRA) {
            pSDSAMtx_addr = MtxAddrFromTransportAddrEx(pTHS, pszSourceDRA);
            cb += MTX_TSIZE (pSDSAMtx_addr);
        }

        if ((pao = malloc(cb)) == NULL) {
            ret =  DRAERR_OutOfMem;
            return ret;
        }

        pao->ulOperation = AO_OP_REP_DEL;
        pao->ulOptions = ulOptions;

        pb = (UCHAR *)pao + sizeof(AO);
        ALIGN_BUFF(pb);
        pao->args.rep_del.pNC = (DSNAME *)(pb);
        memcpy(pao->args.rep_del.pNC, pNC, pNC->structLen);

        if (NULL == pszSourceDRA) {
            pao->args.rep_del.pSDSAMtx_addr = NULL;
        }
        else {
            pb += pNC->structLen;
            ALIGN_BUFF(pb);
            pao->args.rep_del.pSDSAMtx_addr = (MTX_ADDR*)(pb);
            memcpy(pb, pSDSAMtx_addr, MTX_TSIZE(pSDSAMtx_addr));
        }

        if(!(ulOptions & DRS_ASYNC_OP)){
            // A synchronous operation can take a _long_ time!
            pTHS->fIsValidLongRunningTask = TRUE;
        }

        ret = DoOpDRS(pao);

        if (NULL != pSDSAMtx_addr) {
            THFreeEx(pTHS, pSDSAMtx_addr);
        }
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
        ;
    }

    if (fResetfDRAOnExit) {
        pTHS->fDRA = fDRAOnEntry;
    }

    return ret;
}


ULONG
DirReplicaSynchronize(
    DSNAME *    pNC,
    LPWSTR      pszSourceDRA,
    UUID *      puuidSourceDRA,
    ULONG       ulOptions
    )
//
//  Synchronize a replica of a given NC on the local server, pulling changes
//  from the specified source server.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC to synchronize.
//      pszSourceDRA (LPWSTR)
//          DSA with which to synchronize the replica.  Ignored if ulOptions
//          does not include DRS_SYNC_BYNAME.
//      puuidSourceDRA (UUID *)
//          objectGuid of DSA with which to synchronize the replica.  Ignored
//          if ulOptions includes DRS_SYNC_BYNAME.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more of the following:
//              DRS_ASYNC_OP
//                  Perform this operation asynchronously.
//                  Required when using DRS_SYNC_ALL
//              DRS_SYNC_BYNAME
//                  Use pszSourceDRA instead of puuidSourceDRA to identify
//                  source.
//              DRS_SYNC_ALL
//                  Sync from all sources.
//              DRS_CRITICAL
//                  Sync only the critical objects now
//              DRS_SYNC_FORCED
//                  Sync even if link is currently disabled.
//              DRS_FULL_SYNC_NOW
//                  Sync starting from scratch (i.e., at the first USN).
//              DRS_NO_DISCARD
//                  Don't discard this synchronization request, even if a
//                  similar sync is pending.
//
//              DRS_WRIT_REP
//                  Replica is writeable.  Not needed unless we're
//                  INIT_SYNCing as a part of startup (i.e., clients need
//                  not set this flag).
//              DRS_INIT_SYNC_NOW
//                  This sync is part of INIT_SYNCing this DSA as a part
//                  of startup.  Clients should not set this flag.
//              DRS_ABAN_SYNC
//                  Sync of this DSA has been abandoned and rescheduled
//                  once because no progress was being made; don't abandon
//                  it again.  Clients should not set this flag.
//              DRS_SYNC_RETRY
//                  Asynchronous sync of this NC failed once; if this sync
//                  fails, don't retry again.  Clients should not set this
//                  flag.
//              DRS_PER_SYNC
//                  This is a periodic sync request as scheduled by the admin.
//              DRS_SYNC_URGENT
//                  This is a notification of an update that was marked urgent.
//                  Notifications caused by this update will also be marked
//                  urgent.
//              DRS_ADD_REF
//                  Request source DSA to ensure it has a Reps-To for the local
//                  DSA such that it properly sends change notifications.  Valid
//                  only for replicas across the RPC transport.  Clients should
//                  have no need to set this flag.
//              DRS_TWOWAY_SYNC
//                  This sync is being performed because the remote DC was
//                  configured for two-way syncs (see DirRepicaAdd()).
//              DRS_SYNC_PAS
//                  This sync is for getting Partial Attribute Set changes
//                  to a destination GC.
//
//  RETURNS:
//      DRS error (DWORD), as defined in \nt\private\ds\src\inc\drserr.h.
//
{
    THSTATE *       pTHS = pTHStls;
    AO *            pao;
    ULONG           ret;
    ULONG           ulpaosize;
    UCHAR *         pb;
    BOOL            fDRAOnEntry;
    BOOL            fResetfDRAOnExit = FALSE;
    MTX_ADDR *      pmtx = NULL;
    REPLICA_LINK *  pRepsFromRef = NULL;
    ULONG           cbRepsFromRef;
    BOOL            fAttExists;
    ULONG           ulPaoPrioFlags, ulCorrectPrioFlags;
    DBPOS           *pDBTmp;

    if ((NULL == pNC )
        || ((ulOptions & DRS_SYNC_BYNAME) && (NULL == pszSourceDRA))
        || (!(ulOptions & DRS_SYNC_BYNAME) && (NULL == puuidSourceDRA))
        || (!(ulOptions & DRS_SYNC_BYNAME) && (fNullUuid(puuidSourceDRA)))
        ) {
        return DRAERR_InvalidParameter;
    }

    PERFINC(pcRepl);                                // PerfMon hook

    if (NULL != pTHS) {
        fDRAOnEntry = pTHS->fDRA;
        fResetfDRAOnExit = TRUE;
    }

    __try {
        InitDraThread(&pTHS);

        ret = DRAERR_Success;

        if (DRS_ASYNC_OP & ulOptions) {
            // We're not going to sync just yet (asynchronous sync was requested),
            // but check to see that we actually replicate from this source so we
            // can inform the caller if he is in error. Also validate the options.
            // Synchronous operations are not checked because they will be executed
            // now and feedback given immediately to the caller.

            // Don't disturb existing pTHS->pDB
            DBOpen( &pDBTmp );
            __try {
                ret = FindNC(pDBTmp, pNC, FIND_MASTER_NC | FIND_REPLICA_NC,
                             NULL);

                if (ret) {
                    // No NC.
                    ret = DRAERR_BadNC;
                    __leave;
                }

                if (!(ulOptions & DRS_SYNC_ALL)) {
                    if (ulOptions & DRS_SYNC_BYNAME) {
                        pmtx = MtxAddrFromTransportAddrEx(pTHS, pszSourceDRA);
                    }

                    ret = FindDSAinRepAtt(
                            pDBTmp,
                            ATT_REPS_FROM,
                            ( ulOptions & DRS_SYNC_BYNAME )
                                ? DRS_FIND_DSA_BY_ADDRESS
                                : DRS_FIND_DSA_BY_UUID,
                            puuidSourceDRA,
                            pmtx,
                            &fAttExists,
                            &pRepsFromRef,
                            &cbRepsFromRef );

                    if (ret) {
                        // We don't source this NC from the given DSA.
                        ret = DRAERR_NoReplica;
                        __leave;
                    }

                    VALIDATE_REPLICA_LINK_VERSION(pRepsFromRef);

                    if ( (DRS_UPDATE_NOTIFICATION & ulOptions) &&
                         (pRepsFromRef->V1.ulReplicaFlags & DRS_NEVER_NOTIFY) &&
                         !(ulOptions & DRS_TWOWAY_SYNC) ) {
                        // We should not be getting notifications along this
                        // link.  (Perhaps it was once intrasite and is now
                        // intersite and therefore notification-less.)  By
                        // returning "no replica" we are informing the source
                        // to remove his "Reps-To" value for us, and therefore
                        // not to generate future change notifications.
                        ret = DRAERR_NoReplica;
                        __leave;
                    }

                    // Correct options so that entry is AO is prioritized correctly
                    // Extract the old and new priority flags
                    ulPaoPrioFlags = ulOptions & AO_PRIORITY_FLAGS;
                    ulCorrectPrioFlags = pRepsFromRef->V1.ulReplicaFlags & AO_PRIORITY_FLAGS;

                    if( ulPaoPrioFlags != ulCorrectPrioFlags ) {
                        DPRINT2(1, "DirReplicaSynchronize: Correcting priority flags from "
                                "0x%x to 0x%x\n", ulPaoPrioFlags, ulCorrectPrioFlags );

                        // Remove existing priority flags
                        ulOptions &= ~AO_PRIORITY_FLAGS;

                        // Add correct priority flags
                        ulOptions |= ulCorrectPrioFlags;
            
                    } else {
                        DPRINT1(2, "DirReplicaSynchronize: Priority flags 0x%x are correct\n",
                                ulPaoPrioFlags );
                    }


                }
            }
            __finally {
                DBClose( pDBTmp, FALSE );
            }
        }

        if (!ret) {
            // Determine pao size
            ulpaosize = sizeof(AO) + ALIGN_PAD(2) + pNC->structLen;
            if (ulOptions & DRS_SYNC_BYNAME) {
                ulpaosize += sizeof(WCHAR) * (1 + wcslen(pszSourceDRA));
            }

            if ((pao = malloc (ulpaosize)) == NULL) {
                ret =  DRAERR_OutOfMem;
                return ret;
            }

            pao->ulOperation = AO_OP_REP_SYNC;
            pao->ulOptions = ulOptions;

            pb = ((UCHAR *)pao + sizeof(AO));
            ALIGN_BUFF(pb);
            pao->args.rep_sync.pNC = (DSNAME *)(pb);
            memcpy(pb, pNC, pNC->structLen);

            // Copy over UUID or name, and zero out unused parameter.

            if (ulOptions & DRS_SYNC_BYNAME) {
                pb += pNC->structLen;
                ALIGN_BUFF(pb);
                pao->args.rep_sync.pszDSA = (LPWSTR) pb;
                wcscpy(pao->args.rep_sync.pszDSA, pszSourceDRA);
            }
            else {
                // Allow for pinvocation id being NULL.
                if (NULL != puuidSourceDRA) {
                    pao->args.rep_sync.invocationid = *puuidSourceDRA;
                }
                pao->args.rep_sync.pszDSA = NULL;
            }

            if(!(ulOptions & DRS_ASYNC_OP)){
                // A synchronous operation can take a _long_ time!
                pTHS->fIsValidLongRunningTask = TRUE;
            }

            ret =  DoOpDRS(pao);
        }

        if (NULL != pmtx) {
            THFreeEx(pTHS, pmtx);
        }
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
        ;
    }

    if (fResetfDRAOnExit) {
        pTHS->fDRA = fDRAOnEntry;
    }

    return ret;
}

ULONG
DirReplicaModify(
    DSNAME *    pNC,
    UUID *      puuidSourceDRA,
    UUID *      puuidTransportObj,
    LPWSTR      pszSourceDRA,
    REPLTIMES * prtSchedule,
    ULONG       ulReplicaFlags,
    ULONG       ulModifyFields,
    ULONG       ulOptions
    )
//
//  Update the REPLICA_LINK value corresponding to the given server in the
//  Reps-From attribute of the given NC.
//
//  The value must already exist.
//
//  Either the UUID or the MTX_ADDR may be used to identify the current value.
//  If a UUID is specified, the UUID will be used for comparison.  Otherwise,
//  the MTX_ADDR will be used for comparison.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC for which the Reps-From should be modified.
//      puuidSourceDRA (UUID *)
//          Invocation-ID of the referenced DRA.  May be NULL if:
//            . ulModifyFields does not include DRS_UPDATE_ADDRESS and
//            . pmtxSourceDRA is non-NULL.
//      puuidTransportObj (UUID *)
//          objectGuid of the transport by which replication is to be performed.
//          Ignored if ulModifyFields does not include DRS_UPDATE_TRANSPORT.
//      pszSourceDRA (LPWSTR)
//          DSA for which the reference should be added or deleted.  Ignored if
//          puuidSourceDRA is non-NULL and ulModifyFields does not include
//          DRS_UPDATE_ADDRESS.
//      prtSchedule (REPLTIMES *)
//          Periodic replication schedule for this replica.  Ignored if
//          ulModifyFields does not include DRS_UPDATE_SCHEDULE.
//      ulReplicaFlags (ULONG)
//          Flags to set for this replica.  Ignored if ulModifyFields does not
//          include DRS_UPDATE_FLAGS.
//      ulModifyFields (ULONG)
//          Fields to update.  One or more of the following bit flags:
//              DRS_UPDATE_ADDRESS
//                  Update the MTX_ADDR associated with the referenced server.
//              DRS_UPDATE_SCHEDULE
//                  Update the periodic replication schedule associated with
//                  the replica.
//              DRS_UPDATE_FLAGS
//                  Update the flags associated with the replica.
//              DRS_UPDATE_TRANSPORT
//                  Update the transport associated with the replica.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more of the following:
//              DRS_ASYNC_OP
//                  Perform this operation asynchronously.
//
//  RETURNS:
//      DRS error (DWORD), as defined in \nt\private\ds\src\inc\drserr.h.
//
{
    THSTATE *   pTHS = pTHStls;
    AO *        pao;
    BYTE *      pb;
    ULONG       ret;
    BOOL        fDRAOnEntry;
    BOOL        fResetfDRAOnExit = FALSE;
    DWORD       cbAO;
    MTX_ADDR *  pmtxSourceDRA = NULL;

    // Note that DRS_UPDATE_ALL is rejected by this check
    if (    ( NULL == pNC )
         || ( ( NULL == puuidSourceDRA ) && ( NULL == pszSourceDRA ) )
         || ( ( NULL != puuidSourceDRA ) && ( fNullUuid(puuidSourceDRA) ) && ( NULL == pszSourceDRA ) )
         || ( ( NULL == pszSourceDRA   ) && ( DRS_UPDATE_ADDRESS  & ulModifyFields ) )
         || ( ( NULL == prtSchedule    ) && ( DRS_UPDATE_SCHEDULE & ulModifyFields ) )
         || ( 0 == ulModifyFields )
         || (    ulModifyFields
              != (   ulModifyFields
                   & ( DRS_UPDATE_ADDRESS | DRS_UPDATE_SCHEDULE | DRS_UPDATE_FLAGS
                       | DRS_UPDATE_TRANSPORT
                     )
                 )
            )
       )
    {
        return DRAERR_InvalidParameter;
    }

    // This prevents callers from using reserved flags
    if (ulOptions & (~REPMOD_OPTIONS)) {
        Assert( !"Unexpected replica modify options" );
        return DRAERR_InvalidParameter;
    }

    // This prevents callers from setting inappropriate flags
    // Note that the caller may specify a system flag at this point,
    // and we enforce later than he cannot change its state
    if ( ( (ulModifyFields & DRS_UPDATE_FLAGS) != 0 ) &&
         (ulReplicaFlags & (~RFR_FLAGS)) ) {
        Assert( !"Unexpected replica modify flags" );
        return DRAERR_InvalidParameter;
    }

    PERFINC(pcRepl);          // PerfMon hook

    if (NULL != pTHS) {
        fDRAOnEntry = pTHS->fDRA;
        fResetfDRAOnExit = TRUE;
    }

    __try {
        InitDraThread(&pTHS);

        cbAO = sizeof(AO) + ALIGN_PAD(1) + pNC->structLen;

        if ((NULL == puuidSourceDRA)
            || fNullUuid( puuidSourceDRA )
            || (DRS_UPDATE_ADDRESS & ulModifyFields)) {

            pmtxSourceDRA = MtxAddrFromTransportAddrEx(pTHS, pszSourceDRA);
            cbAO += ALIGN_PAD(1) + MTX_TSIZE(pmtxSourceDRA);
        }

        pao = malloc(cbAO);

        if (NULL == pao) {
            ret = DRAERR_OutOfMem;
        }
        else {
            memset(pao, 0, cbAO);

            pao->ulOperation = AO_OP_REP_MOD;
            pao->ulOptions   = ulOptions;

            pb = (BYTE *)pao + sizeof(AO);

            ALIGN_BUFF(pb);
            pao->args.rep_mod.pNC = (DSNAME *) pb;
            memcpy(pb, pNC, pNC->structLen);
            pb += pNC->structLen;

            if (NULL != puuidSourceDRA) {
                pao->args.rep_mod.puuidSourceDRA = &pao->args.rep_mod.uuidSourceDRA;
                pao->args.rep_mod.uuidSourceDRA = *puuidSourceDRA;
            }

            if (NULL != puuidTransportObj) {
                pao->args.rep_mod.puuidTransportObj = &pao->args.rep_mod.uuidTransportObj;
                pao->args.rep_mod.uuidTransportObj = *puuidTransportObj;
            }

            if ((NULL == puuidSourceDRA)
                || fNullUuid(puuidSourceDRA)
                || (DRS_UPDATE_ADDRESS & ulModifyFields)) {
                ALIGN_BUFF(pb);
                pao->args.rep_mod.pmtxSourceDRA = (MTX_ADDR *) pb;
                memcpy(pb, pmtxSourceDRA, MTX_TSIZE(pmtxSourceDRA));
            }

            if (DRS_UPDATE_SCHEDULE & ulModifyFields) {
                pao->args.rep_mod.rtSchedule = *prtSchedule;
            }

            pao->args.rep_mod.ulReplicaFlags = ulReplicaFlags;
            pao->args.rep_mod.ulModifyFields = ulModifyFields;

            ret = DoOpDRS(pao);
        }

        if (NULL != pmtxSourceDRA) {
            THFreeEx(pTHS, pmtxSourceDRA);
        }
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
        ;
    }

    if (fResetfDRAOnExit) {
        pTHS->fDRA = fDRAOnEntry;
    }

    Assert((NULL == pTHS) || (NULL == pTHS->pDB));

    return ret;
}

ULONG
DirReplicaReferenceUpdate(
    DSNAME *    pNC,
    LPWSTR      pszRepsToDRA,
    UUID *      puuidRepsToDRA,
    ULONG       ulOptions
    )
//
//  Add or remove a target server from the Reps-To property on the given NC.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC for which the Reps-To should be modified.
//      pszRepsToDRA (LPWSTR)
//          Network address of DSA for which the reference should be added
//          or deleted.
//      puuidRepsToDRA (UUID *)
//          Invocation-ID of DSA for which the reference should be added
//          or deleted.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more of the following:
//              DRS_ASYNC_OP
//                  Perform this operation asynchronously.
//              DRS_WRIT_REP
//                  Destination is writeable or readonly
//              DRS_ADD_REF
//                  Add the given server to the Reps-To property.
//              DRS_DEL_REF
//                  Remove the given server from the Reps-To property.
//          Note that DRS_ADD_REF and DRS_DEL_REF may be paired to perform
//          "add or update".
//
//  RETURNS:
//      DRS error (DWORD), as defined in \nt\private\ds\src\inc\drserr.h.
//
{
    THSTATE * pTHS = pTHStls;
    AO *pao;
    UCHAR *pb;
    ULONG ret;
    MTX_ADDR *pDSAMtx_addr;
    BOOL fDRAOnEntry;
    BOOL fResetfDRAOnExit = FALSE;

    if (    ( NULL == pNC )
         || ( NULL == pszRepsToDRA )
         || ( NULL == puuidRepsToDRA )
         || ( fNullUuid( puuidRepsToDRA ) )
         || ( 0 == ( ulOptions & ( DRS_ADD_REF | DRS_DEL_REF ) ) )
       )
    {
        return DRAERR_InvalidParameter;
    }

    // This prevents callers from using reserved flags
    // Note that DRS_GETCHG_CHECK might be considered a system-only flag
    // from its name, but its functon is closer to IGNORE_ERROR. As such
    // we do not prevent remote callers from setting it.
    if (ulOptions & (~REPUPDREF_OPTIONS)) {
        Assert( !"Unexpected replica update reference options" );
        return DRAERR_InvalidParameter;
    }

    PERFINC(pcRepl);                                // PerfMon hook

    if (NULL != pTHS) {
        fDRAOnEntry = pTHS->fDRA;
        fResetfDRAOnExit = TRUE;
    }

    __try {
        InitDraThread(&pTHS);

        pDSAMtx_addr = MtxAddrFromTransportAddrEx(pTHS, pszRepsToDRA);

        if ((pao = malloc(sizeof(AO) + ALIGN_PAD(2) + pNC->structLen +
                          MTX_TSIZE(pDSAMtx_addr))) == NULL) {
            ret = DRAERR_OutOfMem;
            __leave;
        }

        pao->ulOperation = AO_OP_UPD_REFS;
        pao->ulOptions = ulOptions;

        pb = (UCHAR *)pao + sizeof(AO);
        ALIGN_BUFF(pb);
        pao->args.upd_refs.pNC = (DSNAME *)(pb);
        memcpy(pb, pNC, pNC->structLen);

        pb += pNC->structLen;
        ALIGN_BUFF(pb);
        pao->args.upd_refs.pDSAMtx_addr = (MTX_ADDR *)(pb);
        memcpy(pb, pDSAMtx_addr, MTX_TSIZE(pDSAMtx_addr));

        if (NULL != puuidRepsToDRA) {
            pao->args.upd_refs.invocationid = *puuidRepsToDRA;
        }

        ret = DoOpDRS(pao);

        THFreeEx(pTHS, pDSAMtx_addr);
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
        ;
    }

    if (fResetfDRAOnExit) {
        pTHS->fDRA = fDRAOnEntry;
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\draerror.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       draerror.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>			// schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>			// MD global definition header
#include <mdlocal.h>			// MD local definition header
#include <dsatools.h>			// needed for output allocation

// Logging headers.
#include "dsevent.h"			/* header Audit\Alert logging */
#include "mdcodes.h"			/* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"			/* Defines for selected classes and atts*/
#include "dsexcept.h"
#include "dsconfig.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAERROR:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"

#include <fileno.h>
#define  FILENO FILENO_DRAERROR

// DraErrOutOfMem

void DraErrOutOfMem(void)
{

    DPRINT(0,"DRA - OUT OF MEMORY\n");

    LogEvent(DS_EVENT_CAT_REPLICATION,
                        DS_EVENT_SEV_BASIC,
                        DIRLOG_DRA_OUT_OF_MEMORY,
                        NULL,
                        NULL,
                        NULL);

    DRA_EXCEPT (DRAERR_OutOfMem, 0);
}

// DraErrInconsistent - Called when we detect an inconistent state within the
// DRA. Writes appropriate log entries. Id is the DSID of the caller. A
// macro makes this easier to call.

void  DraErrInconsistent(DWORD Arg, DWORD Id)
{
    LogEvent(DS_EVENT_CAT_REPLICATION,
  	    DS_EVENT_SEV_MINIMAL,
  	    DIRLOG_CODE_INCONSISTENCY,
  	    szInsertUL( Arg ),
  	    szInsertUL( Id ),
  	    NULL);
    DRA_EXCEPT_DSID(DRAERR_InternalError, Arg, Id);
}

// DraErrBusy - Called whenever we get a dblayer SYSERR.

void DraErrBusy(void)
{
    DRA_EXCEPT (DRAERR_Busy, 0);
}

// DraErrMissingAtt - Called whenever we are unable to read an expected
// attribute. We make an error log entry.

void DraErrMissingAtt(PDSNAME pDN, ATTRTYP type)
{
    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
  	    DS_EVENT_SEV_MINIMAL,
  	    DIRLOG_MISSING_EXPECTED_ATT,
  	    szInsertUL(type),
  	    szInsertWC(pDN->StringName),
  	    NULL);

    DRA_EXCEPT (DRAERR_InternalError, type);
}

// DraErrCannotFindNC - The master NC cannot be found.

void DraErrCannotFindNC(DSNAME *pNC)
{
    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
  	    DS_EVENT_SEV_MINIMAL,
  	    DIRLOG_CANT_FIND_EXPECTED_NC,
  	    szInsertWC(pNC->StringName),
	    NULL,
  	    NULL);

    DRA_EXCEPT (DRAERR_InconsistentDIT, 0);
}

// DraErrInappropriateInstanceType - an inappropriate instance type was
// encountered.

void DraErrInappropriateInstanceType(DSNAME *pDN, ATTRTYP type)
{
    DRA_EXCEPT (DRAERR_InconsistentDIT, type);
}


void
DraErrMissingObject(
    IN  THSTATE *pTHS,
    IN  ENTINF *pEnt
    )
/*++

Routine Description:

    Called when there is no local information regarding the object and the
    inbound replication stream does not contain enough attribute information
    to create it.
    
    This is either (1) the result of a replication error, where the USN
    bookmarks were advanced further than they should have been somewhere, or
    (2) a symptom of not having fully replicated within a tombstone lifetime.

    There are a small number of legitimate situations where we expect to run into
    this condition. In these cases we do not log nor assert on check builds. These are:
    1. A TTL object has expired on the destination by the time that a change replicates in.
    2. An object has been phantomized because of a cross domain move operation, but
    there is insufficient information in PreProcessProxyObject to know if the
    operation should be prevented.


Arguments:

    pEnt (IN) - Entry info for the incomplete inbound object.
        
Return Values:

    None.  Throws a replication exception.
    
--*/
{
    DPRINT1(0, "Object %ws is incomplete for add\n", pEnt->pName->StringName);

    // Dynamic objects may disappear at any time without a tombstone.
    // Request the whole object from the source
    if (pEnt->ulFlags & ENTINF_DYNAMIC_OBJECT) {
        DRA_EXCEPT(DRAERR_NotEnoughAttrs, 0);
    }

    // See if the target object exists as a phantom with a name indicative of
    // being cross domain moved.  This code is to prevent assertions on a checked
    // build when this scenario occurs during test. The scenario is this. System A
    // is a GC. On system B, object is cross domain moved from domain1 to domain2.
    // System A replicates in domain2 BEFORE replicating in domain1. System A demotes
    // the object from domain1 to domain2. System A is then un-GC'd. The object
    // becomes a phantom in domain 2.  If a change comes for the old object in domain1
    // before the proxy object arrives, we won't have the full contents of the object.

    {
        COMMARG commArg;
        CROSS_REF *pIncomingNcCr, *pPhantomNcCr;
        DSNAME *pPhantomDN;
        DWORD cbName=0, err;

        InitCommarg(&commArg);

        // See if the object exists locally as a phantom, meaning the object was here
        // once but has disappeared for some reason.

        err = DBFindDSName(pTHS->pDB, pEnt->pName);
        if (err == DIRERR_NOT_AN_OBJECT) {

            // Get incoming object CR by name
            if (!(pIncomingNcCr = FindBestCrossRef(pEnt->pName, &commArg))) {
                DRA_EXCEPT(DRAERR_InternalError, 0);
            }
            // Turn the DNT into the dsname (don't just read the name off
            // the object, phantoms don't have such a thing.
            if ( !(pPhantomDN = DBGetDSNameFromDnt( pTHS->pDB, pTHS->pDB->DNT ))) {
                DRA_EXCEPT(DRAERR_InternalError, 0);
            }

            // Get the CrossRef for the phantom.
            // This may not exist if the CrossRef containing the phantom was deleted
            // from the enterprise
            pPhantomNcCr = FindBestCrossRef(pPhantomDN, &commArg);

	    THFreeEx(pTHS, pPhantomDN);

            DPRINT1( 1, "Incoming NC: %ls\n", pIncomingNcCr->pNC->StringName );
            DPRINT1( 1, "Phantom NC: %ls\n",
                     pPhantomNcCr ? pPhantomNcCr->pNC->StringName : L"not found" );

            if ( !pPhantomNcCr ||
                 (!NameMatched(pIncomingNcCr->pNC, pPhantomNcCr->pNC)) )
            {
                // Phantom is not in the current domain
                // Allow it to be regenerated
                DRA_EXCEPT(DRAERR_NotEnoughAttrs, 0);
            }
        }
    }

    Assert(!"Missing object identified!  Contact GregJohn,DsRepl.");
    
    if (gfStrictReplicationConsistency) {
        // Abort the packet, don't apply        
	// as long as we don't return DRAERR_MissingObject or DRAERR_NotEnoughAttrs we will abort the packet and not
	// recreate the object
        DRA_EXCEPT(ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT, DRAERR_MissingObject);
    }
    else {
	// This is a lingering object.
        // The exception below is caught and handled to work around the failure. 
	// excepting with this error will be caught and the object will be re-requested and will
	// be created on this DC!
        DRA_EXCEPT(DRAERR_MissingObject, 0);
    }
}


void
DraLogGetChangesFailure(
    IN DSNAME *pNC,
    IN LPWSTR pszDsaAddr,
    IN DWORD ret,
    IN DWORD ulExtendedOp
    )

/*++

Routine Description:

    Log an source-side Get Changes failure.
    Common normal errors are not logged.

Arguments:

    pNC - naming context
    pszDsaAddr - The destination server's address
    ret - win32 error code
    ulExtendedOp - the Extended FSMO operation if any

Return Value:

    None

--*/

{
    // Filter out "normal" errors

    // "Normal" errors are:
    // ERROR_REVISION_MISMATCH - Client and server are not compatible
    // DRAERR_SourceDisabled - Outbound replication is disabled by admin
    // DRAERR_BadDN, BadNC - NC not present
    // DRAERR_NoReplica - NC being removed
    // ERROR_DS_DRA_SCHEMA_INFO_SHIP - Schema cache is temporarily invalid, perhaps
    //      while indices are being rebuilt

    switch (ret) {
    case ERROR_REVISION_MISMATCH:
    case ERROR_DS_DRA_SCHEMA_INFO_SHIP:
    case DRAERR_SourceDisabled:
    case DRAERR_BadDN:
    case DRAERR_BadNC:
    case DRAERR_NoReplica:
    case DRAERR_Busy:
    case ERROR_DS_THREAD_LIMIT_EXCEEDED:
    case DRAERR_RPCCancelled:
    case ERROR_DS_DIFFERENT_REPL_EPOCHS:
    case ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET:
        return;

    default:
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_GETCHANGES_FAILED,
                  szInsertDN(pNC),
                  szInsertWC(pszDsaAddr),
                  szInsertWin32Msg( ret ),
                  szInsertUL(ulExtendedOp),
                  szInsertWin32ErrCode( ret ),
                  NULL, NULL, NULL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\dragtchg.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dragtchg.c
//
//--------------------------------------------------------------------------
/*++

ABSTRACT:

    Outbound replication methods.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <dstrace.h>
// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dsconfig.h"                   // Registry sections

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <filtypes.h>
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include <prefix.h>
#include <dsutil.h>

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAGTCHG:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "drasig.h"           // DraImproveCallersUsnVector
#include "draerror.h"
#include "usn.h"
#include "drauptod.h"
#include "drameta.h"
#include "drametap.h"
#include "drasch.h"
#include "drancrep.h" // For RenameLocalObject

// RID Manager header.
#include <samsrvp.h>
#include <ridmgr.h>                     // RID FSMO access in SAM

// Cross domain move.
#include <xdommove.h>

// Jet functions
#include <dsjet.h>
#include <dbintrnl.h>

#include <fileno.h>
#define  FILENO FILENO_DRAGTCHG

// Ldap
#include <ntldap.h>

// Bogus encoding buffer to satisfy the RPC encoding library.  The contents will
// never be used, so we don't have to worry about multiple threads accessing it
// concurrently.
BYTE grgbFauxEncodingBuffer[16];

// Maximum number of milliseconds we should spend in a single DRA_GetNCChanges
// call looking for objects to ship.
const ULONG gulDraMaxTicksForGetChanges = 60 * 1000;

// Forward declarations.

ULONG AcquireRidFsmoLock(DSNAME *pDomainDN, int msToWait);
VOID  ReleaseRidFsmoLock(DSNAME *pDomainDN);
BOOL  IsRidFsmoLockHeldByMe();

void FSMORegisterObj(THSTATE *pTHS, HANDLE hRetList, DSNAME * pObj);
ULONG GetSchemaRoleObjectsToShip(DSNAME *pFSMO,
                           USN_VECTOR *pusnvecFrom,
                           HANDLE hList);
ULONG GetProxyObjects(DSNAME *pDomainDN,
                      HANDLE hList,
                      USN_VECTOR *pusnvecFrom);
ULONG GetDomainRoleTransferObjects(THSTATE *pTHS,
                                   HANDLE hList,
                                   USN_VECTOR *pusnvecFrom);
ULONG GetInfrastructureRoleTransferObjects(THSTATE *pTHS,
                                           HANDLE hList,
                                           USN_VECTOR *pusnvecFrom);

void
AddAnyUpdatesToOutputList(
    IN      DBPOS *                     pDB,
    IN      DWORD                       dwDirSyncControlFlags,
    IN      PSECURITY_DESCRIPTOR        pSecurity,
    IN      ULONG                       dntNC,
    IN      USN                         usnHighPropUpdateDest,
    IN      PARTIAL_ATTR_VECTOR *       pPartialAttrVec,
    IN      DRS_MSG_GETCHGREQ_NATIVE *  pMsgIn,
    IN      handle_t                    hEncoding,              OPTIONAL
    IN OUT  DWORD *                     pcbTotalOutSize,        OPTIONAL
    IN OUT  DWORD *                     pcNumOutputObjects,
    IN OUT  DNT_HASH_ENTRY *            pDntHashTable,
    IN OUT  REPLENTINFLIST ***          pppEntInfListNext
    );

void
AddAnyValuesToOutputList(
    IN      DBPOS *                         pDB,
    IN      DWORD                           dwDirSyncControlFlags,
    IN      PSECURITY_DESCRIPTOR            pSecurity,
    IN      USN                             usnHighPropUpdateDest,
    IN      DRS_MSG_GETCHGREQ_NATIVE *      pMsgIn,
    IN      PARTIAL_ATTR_VECTOR *           pPartialAttrVec,
    IN      handle_t                        hEncoding,              OPTIONAL
    IN OUT  DWORD *                         pcbTotalOutSize,
    IN OUT  ULONG *                         pcAllocatedValues,
    IN OUT  ULONG *                         pcNumValues,
    IN OUT  REPLVALINF **                   ppValues
    );



/* AddToList - Add the current object (pTHStls->pDB) to the results list. The
*       current position in the results list is given by ppEntInfList, 'pSel'
*       specifies which attributes are wanted.
*
*  Notes:
*       This routine returns DSA type error codes not suitable for returning
*       from DRA APIs.
*
*  Returns:
*       BOOL - whether an entry was added
*/
BOOL
AddToList(
    IN  DBPOS                     * pDB,
    IN  DWORD                       dwDirSyncControlFlags,
    IN  PSECURITY_DESCRIPTOR        pSecurity,
    IN  ENTINFSEL *                 pSel,
    IN  PROPERTY_META_DATA_VECTOR * pMetaData,
    IN  BOOL                        fIsNCPrefix,
    OUT REPLENTINFLIST **           ppEntInfList
    )
{
    REPLENTINFLIST *pEntInfList;
    PROPERTY_META_DATA_EXT_VECTOR *pMetaDataExt = NULL;
    DWORD err, dwGetEntInfFlags = 0, dwSecurityFlags = 0;
    RANGEINFSEL *pSelRange = NULL;
    RANGEINFSEL selRange;
    RANGEINF *pRange = NULL;
    RANGEINF range;
    BOOL fUseRangeToLimitValues =
        ( (dwDirSyncControlFlags & LDAP_DIRSYNC_PUBLIC_DATA_ONLY) &&
          (!(dwDirSyncControlFlags & LDAP_DIRSYNC_INCREMENTAL_VALUES)) );
    BOOL fResult = TRUE;

    if (fUseRangeToLimitValues) {
        memset( &selRange, 0, sizeof( selRange ) );
        // Limit any attribute to return no more than 5000 values
        selRange.valueLimit = 5000;
        pSelRange = &selRange;

        // GetEntInf requires an output range structure
        memset( &range, 0, sizeof( range ) );
        pRange = &range;
        // After the call, pRange->pRange points to a range info item
    }
    
    // We rely on caller to reliably pass us an SD if the object has one
    if ( (dwDirSyncControlFlags & LDAP_DIRSYNC_OBJECT_SECURITY) &&
         pSecurity ) {

        dwSecurityFlags = (SACL_SECURITY_INFORMATION  |
                           OWNER_SECURITY_INFORMATION |
                           GROUP_SECURITY_INFORMATION |
                           DACL_SECURITY_INFORMATION  );
    } else {

        dwGetEntInfFlags = GETENTINF_NO_SECURITY;
    }

    pEntInfList = THAllocEx(pDB->pTHS, sizeof(REPLENTINFLIST));

    err = GetEntInf(pDB,
                    pSel,
                    pSelRange,
                    &(pEntInfList->Entinf),
                    pRange,
                    dwSecurityFlags,
                    pSecurity,
                    dwGetEntInfFlags,
                    NULL,
                    NULL);
    if (err) {
        DPRINT(2,"Error in getting object info\n");
        DRA_EXCEPT(DRAERR_DBError, err);
    }
    else if ( pEntInfList->Entinf.AttrBlock.attrCount ) {
        DPRINT1(2, "Object retrieved (%S)\n",
                pEntInfList->Entinf.pName->StringName);

        // If this is the NC prefix, mark it as such in the data to ship.
        pEntInfList->fIsNCPrefix = fIsNCPrefix;

        // Build remaining data to ship in pEntInfList.
        ReplPrepareDataToShip(
            pDB->pTHS,
            pSel,
            pMetaData,
            pEntInfList
            );

        *ppEntInfList = pEntInfList;
    } else {
        fResult = FALSE;
        THFreeEx( pDB->pTHS, pEntInfList );
    }

    return fResult;
}

//
// AddToOutputList
//
// Adds the selection to the output list and increments the count.
//

void
AddToOutputList (
    IN      DBPOS                     * pDB,
    IN      DWORD                       dwDirSyncControlFlags,
    IN      PSECURITY_DESCRIPTOR        pSecurity,
    IN      ENTINFSEL *                 pSel,
    IN      PROPERTY_META_DATA_VECTOR * pMetaData,
    IN      BOOL                        fIsNCPrefix,
    IN      handle_t                    hEncoding,          OPTIONAL
    IN OUT  ULONG *                     pcbTotalOutSize,    OPTIONAL
    IN OUT  REPLENTINFLIST ***          pppEntInfListNext,
    IN OUT  ULONG *                     pcEntries
    )
{
    BOOL fEntryWasAdded;

    fEntryWasAdded = AddToList(pDB,
                               dwDirSyncControlFlags,
                               pSecurity,
                               pSel,
                               pMetaData,
                               fIsNCPrefix,
                               *pppEntInfListNext);

    if (fEntryWasAdded) {
        // Update count and continuation ref.
        (*pcEntries)++;

        if ((NULL != hEncoding) && (NULL != pcbTotalOutSize)) {
            // Update byte count of return message.
            *pcbTotalOutSize += REPLENTINFLIST_AlignSize(hEncoding,
                                                         **pppEntInfListNext);
        }

        *pppEntInfListNext = &((**pppEntInfListNext)->pNextEntInf);
        **pppEntInfListNext = NULL;
    }
}


ULONG
FSMORidRequest(
    IN THSTATE *pTHS,
    IN DSNAME *pFSMO,
    IN DSNAME *pReqDsa,
    IN ULARGE_INTEGER *pliClientAllocPool,
    OUT HANDLE  pList
    )
/*++

Routine Description:

    This routine calls into SAM to allocate a rid pool for pReqDsa.  The rid
    pool is updated on pReqDsa's rid object on the attribute AllocatedPool.
    Both the computer object and the rid object are returned in pList.

Parameters:

    pFSMO:  the dsname of the FSMO

    pReqDsa: the dsname of the request dsa (ntdsa object)

    pliClientAllocPool: the client's notion of what its alloc'ed pool is

    pList: objects to ship back to pReqDsa


Return Values:

    An error from the EXOP_ERR space


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG err = 0;
    ULONG FsmoStatus = EXOP_ERR_SUCCESS;

    ULONG cbRet = 0;
    DBPOS *pDB;

    DSNAME *pRoleOwner = NULL;
    DSNAME *pRidManager = NULL;
    DSNAME **ObjectsToReturn = NULL;
    BOOL    fSaveDRA = FALSE;
    ULONG   i;

    //
    // Parameter check
    //
    Assert( pFSMO );
    Assert( pReqDsa );
    Assert( pList );

    //
    // N.B. Access check done in RPC server side stub for REPL_GET_NC_CHANGES
    //

    BeginDraTransaction( SYNC_READ_ONLY );
    try
    {
        pDB = pTHS->pDB;

        //
        // Though, we are passed in the dsname of the rid manager object,
        // double check this is the object we think is the rid manager object
        //
        err = DBFindDSName(pDB, gAnchor.pDomainDN);
        if ( 0 == err )
        {
            DPRINT1( 0, "DSA: FSMO Domain = %ws\n", gAnchor.pDomainDN->StringName );

            err = DBGetAttVal(pDB,
                              1,
                              ATT_RID_MANAGER_REFERENCE,
                              0,
                              0,
                              &cbRet,
                              (UCHAR **)&pRidManager);
        }

        if ( 0 != err )
        {
            FsmoStatus = EXOP_ERR_UPDATE_ERR;
            goto Cleanup;
        }

        DPRINT1( 1, "DSA: FSMO RID Mgr = %ws\n", pRidManager->StringName );
        if ( !NameMatched( pFSMO, pRidManager ) )
        {
            //
            // There is a mismatch of rid manager objects - refuse the request
            //
            DPRINT2( 1, "DSA: Rid manager mismatch.  Slave: %ws ; Master %ws",
                    pFSMO->StringName, pRidManager->StringName );
            FsmoStatus = EXOP_ERR_MISMATCH;
        }

    }
    _finally
    {
        EndDraTransaction( TRUE );
    }


    //
    // We aren't really the dra agent.  This flag can cause unwanted errors
    //
    fSaveDRA = pTHS->fDRA;
    pTHS->fDRA = FALSE;

    //
    // Now perform the operation
    //

    NtStatus = SamIFloatingSingleMasterOpEx(pFSMO,
                                            pReqDsa,
                                            SAMP_REQUEST_RID_POOL,
                                            pliClientAllocPool,
                                            &ObjectsToReturn );

    pTHS->fDRA = fSaveDRA;

    if ( !NT_SUCCESS(NtStatus) )
    {
        DPRINT1( 0, "DSA: SamIFloatingSingleMasterOp status = 0x%lx\n",
                 NtStatus );

        if ( NtStatus == STATUS_NO_MORE_RIDS )
        {
            FsmoStatus =  EXOP_ERR_RID_ALLOC;
        }
        else if ( NtStatus == STATUS_INVALID_OWNER )
        {
            FsmoStatus =  EXOP_ERR_FSMO_NOT_OWNER;
        }
        else
        {
            //
            // This must have been a resource err
            //
            FsmoStatus = EXOP_ERR_UPDATE_ERR;
        }

        goto Cleanup;
    }
    Assert( ObjectsToReturn );

    //
    // Replicate back the objects modified
    //
    for (i = 0; NULL != ObjectsToReturn[i]; i++)
    {
        FSMORegisterObj(pTHS, pList, ObjectsToReturn[i] );
    }

Cleanup:

    return( FsmoStatus );

}


typedef struct _FSMOlist {
    DSNAME * pObj;
    struct _FSMOlist *pNext;
} FSMOlist;
/*++ FSMORegisterObj
 *
 * A routine called by FSMO server-side worker code that identifies an
 * object as one to be returned by the FSMO operation.  Note that the
 * object name is only added to the list if it is not already present.
 * The objects added into this list will be freed automatically.
 *
 * INPUT:
 *  pObj - pointer to DSNAME of object to be added to return list
 *  hRetList - handle to list
 * OUTPUT:
 *  none
 * RETURN VALUE:
 *  none
 */
void FSMORegisterObj(THSTATE *pTHS,
                     HANDLE hRetList,
                     DSNAME * pObj)
{
    FSMOlist * pList;

    Assert(hRetList && pObj);

    pList = (FSMOlist *) hRetList;
    while (pList->pNext && !NameMatched(pObj, pList->pObj)) {
        pList = pList->pNext;
    }
    if (!NameMatched(pObj, pList->pObj)) {
        Assert(pList->pNext == NULL);
        pList->pNext = THAllocEx(pTHS, sizeof(FSMOlist));
        pList->pNext->pNext = NULL;
        pList->pNext->pObj = pObj;
    }
}


/*++ FSMORoleTransfer
 *
 * Scaffold Role-Owner transfer.  Code to handle pre- or post-processing
 * (e.g, determining desirability of transfer, or sending notification)
 * can be done by testing the name of the object in either the pre- or post-
 * testing branch.
 *
 * INPUT:
 *  pFSMO - name of FSMO object
 *  pReqDSName - name of requesting DS
 *  usnvecFrom - usn vector sent from client
 *  hList - handle to output list
 * OUTPUT:
 *  none
 * RETURN VALUE:
 *  EXOP_ERR_xxx return code
 */
ULONG FSMORoleTransfer(DSNAME * pFSMO,
                       DSNAME * pReqDSName,
                       USN_VECTOR *pusnvecFrom,
                       HANDLE   hList)
{
    THSTATE *pTHS = pTHStls;
    ULONG err;
    DSNAME * pDN;
    ULONG cbRet;
    DBPOS * const pDB = pTHS->pDB;
    MODIFYARG ModArg;
    MODIFYRES ModRes;
    ATTRVAL AVal;

    err = DBFindDSName(pDB, pFSMO);
    if (err) {
        return EXOP_ERR_UPDATE_ERR;
    }

    // Find the current owner of this role
    err = DBGetAttVal(pDB,
                      1,
                      ATT_FSMO_ROLE_OWNER,
                      0,
                      0,
                      &cbRet,
                      (UCHAR **)&pDN);
    if (err) {
        return EXOP_ERR_UPDATE_ERR;
    }

    if (!NameMatched(pDN, gAnchor.pDSADN)
        || !IsFSMOSelfOwnershipValid( pFSMO )) {
        // If this DSA isn't the owner, fail
        THFreeEx(pTHS, pDN);
        return EXOP_ERR_FSMO_NOT_OWNER;
    }

    /******/
    /* Any object specific pre-processing of the change (e.g, determination
     * as to whether or not we should transfer the role) should be done here.
     */
    // SCHEMA FSMO pre-processing
    if (   NameMatched(pFSMO, gAnchor.pDMD)
        && !SCExpiredSchemaFsmoLease()) {
        THFreeEx(pTHS, pDN);
        return(EXOP_ERR_FSMO_PENDING_OP);
    }

    // RID FSMO pre-processing
    DBFindDSName(pDB, gAnchor.pDomainDN);
    DBGetAttVal(pDB,
                1,
                ATT_RID_MANAGER_REFERENCE,
                DBGETATTVAL_fREALLOC,
                cbRet,
                &cbRet,
                (UCHAR **)&pDN);
    if ( NameMatched(pFSMO, pDN) ) {
        // Acquire the RID FSMO lock so as to insure exclusion with respect
        // to cross domain moves.  See CheckRidOwnership in mdmoddn.c.
        // Only one domain per DC in product 1, so know which domain to use.
        if ( AcquireRidFsmoLock(gAnchor.pDomainDN, 1000) ) {
            THFreeEx(pTHS, pDN);
            return(EXOP_ERR_FSMO_PENDING_OP);
        }
    }

    // Perform everything else within try/finally so we are guaranteed
    // to release the RID FSMO lock if we are holding it.

    _try {
        if ( IsRidFsmoLockHeldByMe() ) {
            // Fill hlist with all the proxy objects as these
            // move with RID FSMO.  Only one domain per DC in
            // product 1, so know which domain to use.
            if ( GetProxyObjects(gAnchor.pDomainDN, hList, pusnvecFrom) ) {
                THFreeEx(pTHS, pDN);
                return(EXOP_ERR_EXCEPTION);
            }
        }

        if ( NameMatched(pFSMO, gAnchor.pPartitionsDN) ) {
            if (GetDomainRoleTransferObjects(pTHS,
                                             hList,
                                             pusnvecFrom)) {
                THFreeEx(pTHS, pDN);
                return(EXOP_ERR_EXCEPTION);
            }
        }

        if ( NameMatched(pFSMO, gAnchor.pInfraStructureDN) ) {
            if (GetInfrastructureRoleTransferObjects(pTHS,
                                                     hList,
                                                     pusnvecFrom)) {
                THFreeEx(pTHS, pDN);
                return(EXOP_ERR_EXCEPTION);
            }
        }

        THFreeEx(pTHS, pDN);
        pDN = NULL;
        cbRet = 0;
        /*** End of preprocessing ***/

        /* Ok, we can go ahead and change the owner, but we need to do it via
         * normal calls so that meta-data gets set correctly.
         */

        ZeroMemory(&ModArg, sizeof(ModArg));
        ZeroMemory(&ModRes, sizeof(ModRes));

        ModArg.pObject = pFSMO;
        ModArg.count = 1;
        ModArg.FirstMod.pNextMod = NULL;
        ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
        ModArg.FirstMod.AttrInf.attrTyp = ATT_FSMO_ROLE_OWNER;
        ModArg.FirstMod.AttrInf.AttrVal.valCount = 1;
        ModArg.FirstMod.AttrInf.AttrVal.pAVal = &AVal;
        AVal.valLen = pReqDSName->structLen;
        AVal.pVal = (UCHAR*)pReqDSName;
        InitCommarg(&ModArg.CommArg);

        pTHS->fDRA = FALSE;
        pTHS->fDSA = TRUE;
        DoNameRes(pTHS,
                  0,
                  ModArg.pObject,
                  &ModArg.CommArg,
                  &ModRes.CommRes,
                  &ModArg.pResObj);
        if (0 == pTHS->errCode) {
            err = LocalModify(pTHS, &ModArg);
        }
        pTHS->fDRA = TRUE;
        pTHS->fDSA = FALSE;

        if (pTHS->errCode) {
            return EXOP_ERR_UPDATE_ERR;
        }

        /* Note that we don't have to register the object, because the
         * FSMO object itself is pre-registered.
         */

        /*** This is where role-transfer post-processing goes, which consists
          *  largely of identifying objects that must be transferred when
          *  transferring the role.
         ***/

        if (NameMatched(pFSMO, gAnchor.pDMD)) {
            /* If this is a schema master change operation, return all
             * schema objects along with the role transfer
             * PERFHINT: This code enumerates all schema objects that we
             * might need to transfer via direct usn comparison, but that
             * will erroneously include ones which have already replicated from
             * here to the destination indirectly (via a third DSA).  Those
             * extra objects will be filtered out before being transmitted,
             * but it would have been better to not even pick up their names
             * here.  Unfortunately that's hard to do, because it would require
             * fiddling around with replication logic that no one willing to
             * work on FSMO code understands.
             */
            err = GetSchemaRoleObjectsToShip(pFSMO, pusnvecFrom, hList);
        }
        else if (NameMatched(pFSMO, gAnchor.pDomainDN)) {
            // This is the FSMO for PDC-ness in the domain.
            // We must issue a synchronous notification to netlogon, lsa, and
            // SAM that the role has changed.
            if (EXOP_ERR_SUCCESS == err) {
                NTSTATUS IgnoreStatus;
                THSTATE  *pTHSSave;

                // THSave and restore around SamINotifyRoleChange. This is
                // because SamINotifyRoleChange makes LSA calls, which may
                // potentially access the DS database

                pTHSSave = THSave();

                IgnoreStatus = SamINotifyRoleChange(
                                                    &pFSMO->Sid, // domain sid
                                                    DomainServerRoleBackup // new role
                                                    );

                // If the notification failed, we have a problem on our hands, we
                // have already changed our FSMO, and cannot do anything about it.
                // And we cannot do anything to undo it. However the chances of
                // this happening should be extremely rare ( as the notification
                // is an in -memory operation )
                // Therfore just assert that it succeeded.

                THRestore(pTHSSave);

                Assert(NT_SUCCESS(IgnoreStatus));
            }
        }
        /*** End of post-processing ***/
    } _finally {
        if ( IsRidFsmoLockHeldByMe() ) {
            // Only one domain per DC in product 1, so know which domain to use.
            ReleaseRidFsmoLock(gAnchor.pDomainDN);
        }
    }

    if (err) {
        return EXOP_ERR_UPDATE_ERR;
    }

    return EXOP_ERR_SUCCESS;
}

/*++ GetSchemaRoleObjectsToShip
 *
 * Gets all changes in the NC containing the FSMO object
 *
 * INPUT:
 *   pFSMO - FSMO object
 *   usnvecFrom - usn vector used in searching
 *   hList - FSMOList to append to
 *
 * OUTPUT:
 *  0 on success, non-0 on error
*/

ULONG GetSchemaRoleObjectsToShip(DSNAME * pFSMO,
                       USN_VECTOR *pusnvecFrom,
                       HANDLE hList)
{
    ULONG           ret;
    USN             usnChangedSeekStart;
    USN             usnChangedFound;
    ULONG           cbReturned;
    ULONG           count, cObj;
    ULONG           dntNC;
    THSTATE * pTHS = pTHStls;
    FSMOlist *pList = (FSMOlist *) hList, *pTail;
    DSNAME *pNC = NULL, *pObj;

    pTail = pList;

    // Find the NC object, get and save its DNT.
    pNC = FindNCParentDSName(pFSMO, FALSE, FALSE);
    if (pNC == NULL) {
        DPRINT(0,"GetObjectsToShip: FindNCParentDSName failed\n");
        return 1;
    }

    if (ret = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, NULL)) {
        DPRINT1(0,"GetObjectsToShip: FindNC failed, err %d\n",ret);
        return 1;
    }

    // Save the DNT of the NC object
    dntNC = pTHS->pDB->DNT;

    // set the seek start to one higher than the watermark
    usnChangedSeekStart = pusnvecFrom->usnHighObjUpdate + 1;

    // Initialize no. of objects. hList already has one element
    // (pMsgIn->pNC added in DoFSMOOp)
    cObj=1;

    // No limit on objects, we want all changes.
    // Note: This code is taken straight from parts of GetNCChanges
    while (TRUE) {
        if (GetNextObjByUsn(pTHS->pDB,
                            dntNC,
                            usnChangedSeekStart,
                            NULL /*nousnfound*/ )) {
            // No more updated items. Set no continuation
            break;
        }

        // Get the USN-Changed from the record.
        if(DBGetSingleValue(pTHS->pDB, ATT_USN_CHANGED, &usnChangedFound,
                   sizeof(usnChangedFound), NULL)) {
            DPRINT(0,"GetObjectsToShip: Error getting usn changed\n");
            return 1;
        }

        // set the search start for the next iteration
        usnChangedSeekStart = usnChangedFound + 1;

        // Get the DSNAME of the object
        if (DBGetAttVal(pTHStls->pDB, 1, ATT_OBJ_DIST_NAME, DBGETATTVAL_fREALLOC,
                0, &cbReturned, (LPBYTE *) &pObj))
        {
            DPRINT(0,"GetObjectsToShip: Error getting obj DSName\n");
            return 1;
        }

        // Add to end of list
        // Duplicates could be added into the list, though rare.
        // It doesn't matter, because the duplicates will be eliminated
        // later when composing the output list.
        Assert(pTail->pNext == NULL);
        pTail->pNext = THAllocEx(pTHS, sizeof(FSMOlist));
        pTail->pNext->pNext = NULL;
        pTail->pNext->pObj = pObj;
        pTail = pTail->pNext;
        cObj++;

    } /* while */

    return 0;
} /* GetSchemaRoleObjectsToShip */


/*++ GetObjectToShip
 *
 * Gets the object to ship
 *
 * INPUT:
 *   pDN - object
 *   usnvecFrom - usn vector used in searching for changes to validate pDN from
 *   hList - List to append to
 *
 * OUTPUT:
 *  0 on success, non-0 on error
*/

ULONG GetObjectToShip(
    THSTATE * pTHS,
    DSNAME * pDN,
    USN_VECTOR *pusnvecFrom,
    HANDLE hList)
{
    ULONG           ret;
    USN             usnChangedFound;
    FSMOlist *pList = (FSMOlist *) hList;
    DSNAME * pObj = NULL;

    if (ret = DBFindDSName(pTHS->pDB, pDN)){
	// object not found!
	DPRINT2(0,"GetObjectToShip:  Object %S not found on error %d!\n", pDN->StringName, ret);
	return ret;
    }

    // Get the USN-Changed from the record.
    if(DBGetSingleValue(pTHS->pDB, ATT_USN_CHANGED, &usnChangedFound,
			sizeof(usnChangedFound), NULL)) {
	DPRINT(0,"GetObjectsToShip: Error getting usn changed\n");
	return ERROR_DS_INTERNAL_FAILURE;
    }

    // the hList assumes that all object on it are free-able, so 
    // make a copy of pDN so that the hList can free it (other callers
    // get DSNAMES from DBGet...
    pObj = THAllocEx(pTHS, pDN->structLen);
    memcpy(pObj, pDN, pDN->structLen);

    // now, verify if this is an object we actually want to send.
    if (usnChangedFound > pusnvecFrom->usnHighPropUpdate) {

	// Add to list
	Assert(pList->pNext == NULL);
	pList->pNext = THAllocEx(pTHS, sizeof(FSMOlist));
	pList->pNext->pNext = NULL;
	pList->pNext->pObj = pObj;
    }

    return ERROR_SUCCESS;
} /* GetObjectToShip */

VOID
addValuesToShip(
    IN      THSTATE                        *pTHS,
    IN      ULONG                           dntNC,
    IN      USN                             usnHighPropUpdate,
    IN      UPTODATE_VECTOR                *pUpTodateVecDest,
    IN      DRS_MSG_GETCHGREQ_NATIVE       *pMsgIn,
    IN OUT  ULONG *                         pcAllocatedValues,
    IN      DRS_MSG_GETCHGREPLY_NATIVE     *pMsgOut
    )

/*++

Routine Description:

    The FSMO code has already decided that this object needs to be shipped.  We want
    to add any link values, that have changed, to the outgoing packet.  We only
    want link changes for the current object.
    
    Note that object currency is changed as a result of this call.

Arguments:

    pTHS - thread state. Incoming pDB->DNT is the desired object to search for, outgoing
           pDB->DNT is unpredictable.
    dntNC - The dnt of the naming context to be searched
    usnHighPropUpdate - The usn to start the search
    pUptoDateVecTest - The utd with which to filter values.
    pMsgIn - The get-changes request
    pcAllocatedValues - pointer to count of allocated values in the value array.
    pMsgOut - The get-changes reply, under construction

Return Value:

    None
    Exceptions raised on error conditions
    
--*/
{
    DB_ERR err = DB_success;
    DBPOS * pDB = pTHS->pDB;
    ULONG ulObjDnt = pDB->DNT, ulSearchLinkBase = 0, ulNewLinkID;
    ATTCACHE *pAC;
    VALUE_META_DATA metaDataValue;
    PROPERTY_META_DATA * pMetaData;
    BOOL fIsNewElement;
    BOOL fDoneAttr = FALSE, fDoneObj = FALSE;
    INDEX_VALUE IV[3];

    // this code exploits the SZLINATTRUSNINDEX format, specifically, the index is
    // +link_DNT +link_base -link_usnchanged
    // In this instance, we want all linked values for a specific DNT which are
    // greater than usnHighPropUpdate.

    err = DBSetCurrentIndex(pDB, Idx_LinkAttrUsn, NULL, FALSE);

    // for each attribute on the object
    while ((!fDoneObj) && (err==DB_success)) { 

	// Initially (obviously) we have to seek to the first value.  Here we seek to the
	// specific DNT, a specific LinkBase, and a specific usnHighPropUpdate.  We use 
	// the JET_bitSeekGE to get the next (first) linkbase.

        IV[0].pvData = &ulObjDnt;
        IV[0].cbData = sizeof(ulObjDnt);
        IV[1].pvData = &ulSearchLinkBase;
        IV[1].cbData = sizeof(ulSearchLinkBase);
        IV[2].pvData = &usnHighPropUpdate;
        IV[2].cbData = sizeof(usnHighPropUpdate);
 
        // seek to the first value that matches our search

        if ((err = DBSeekEx(pDB, pDB->JetLinkTbl, IV, 3, DB_SeekGE)) == DB_success) {

	    // for each value found
	    fDoneAttr = FALSE;
	    while ((!fDoneAttr) && (!fDoneObj) && (err==DB_success)) {  
		
		dbGetLinkTableData(pDB,
				   FALSE,
				   FALSE,
				   &ulObjDnt,
				   NULL, // pulValueDnt
				   &ulSearchLinkBase);

		DPRINT2(3,"Examining %d with link base %d\n", ulObjDnt, ulSearchLinkBase);
		
		if (ulObjDnt != pDB->DNT) {
		    // what if ulSearchLinkBase isn't right?  We don't care, as long as 
		    // the DNT is correct, we're safe to continue.

		    // if the dnt is off, then we're totally done.  leave this function.
		    fDoneObj = TRUE;
		} else {  
		    // Construct a pAC for the current linkbase
		    
		    ulNewLinkID = MakeLinkId(ulSearchLinkBase);
		    
		    pAC = SCGetAttByLinkId(pDB->pTHS, ulNewLinkID);
		    if (!pAC) {
			DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, ulNewLinkID);
		    }  
		    
		    DBGetLinkValueMetaData( pDB, pAC, &metaDataValue );
		    
		    // Legacy rows will not have usn's, and will not be on this index
		    Assert( !IsLegacyValueMetaData( &metaDataValue ) );  
		    
		    DPRINT4( 3, "dnt=%d,attr=%s,ver=%d,usnprop=%I64d\n",
			     ulObjDnt,
			     pAC->name,
			     metaDataValue.MetaData.dwVersion,
			     metaDataValue.MetaData.usnOriginating );

		    // if the meta data shows this is a value change that should be shipped, then
		    // put in on the list. 
		    if (ReplValueIsChangeNeeded(usnHighPropUpdate, pUpTodateVecDest, &metaDataValue)) { 
			AddAnyValuesToOutputList(
			    pDB,
			    0, // dwDirSyncControlFlags, 
			    NULL, // no security desc
			    usnHighPropUpdate,
			    pMsgIn,
			    NULL, // pNewDestPAS,
			    NULL, // hEncoding,
			    &pMsgOut->cNumBytes,
			    pcAllocatedValues,
			    &(pMsgOut->cNumValues),
			    &(pMsgOut->rgValues)
			    );
		    }
		      
		    if (usnHighPropUpdate<=metaDataValue.MetaData.usnProperty) {     
			// go to the next value
                        err = DBMoveEx(pDB, pDB->JetLinkTbl, DB_MoveNext);
		    } else {
			// if the usn isn't high enough, we can stop searching on this linkbase
			// and skip to the next linkbase.
			fDoneAttr = TRUE;
		    }       
		}
	    }
	}
	// Next linkbase
	ulSearchLinkBase++;
    }
}


/*++ DoExtendedOp
 *
 * Main server side driver routine that control extended operations
 *
 * INPUT:
 *  pTHS - THSTATE
 *  pMsgIn - input request message
 *  pMsgOut - results message
 * OUTPUT:
 *  pMsgOut - filled in
 */
ULONG DoExtendedOp(THSTATE *pTHS,
		   DRS_MSG_GETCHGREQ_NATIVE *pMsgIn,  
                   ULONG *pcAllocatedValues,
		   DRS_MSG_GETCHGREPLY_NATIVE *pMsgOut)
{
    DSNAME ReqDSName, *pReqDSName;
    BOOL fCommit = FALSE;
    ENTINFSEL sel;
    FSMOlist * pList, * pTemp;
    ULONG err;

    DSNAME * pObjName = NULL;
    ULONG cbObjName = 0;
    PROPERTY_META_DATA_VECTOR *pMetaData = NULL;
    ULONG cbMetaData = 0;
    ULONG cbRet;
    SYNTAX_INTEGER itHere;
    ULONG *pitHere = &itHere;
    ULONG len;
    REPLENTINFLIST * pEIListHead = NULL;
    REPLENTINFLIST ** ppEIListNext = &pEIListHead;
    CLASSCACHE *pCC;
    BOOL fNCPrefix;
    DWORD numValues = 0;
    SCHEMA_PREFIX_TABLE * pLocalPrefixTable;
    OPRES OpRes;
    BOOL fBypassUpdatesEnabledCheck = FALSE;
    DNT_HASH_ENTRY * pDntHashTable;
    ULONG   dntNC = INVALIDDNT;
    SYNTAX_INTEGER  it;


    pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    Assert(pMsgIn->ulExtendedOp);

    // Read-only destinations not supported for FSMO ops-- i.e., we don't filter on the
    // partial attribute set
    Assert(DRS_WRIT_REP & pMsgIn->ulFlags);

    // if someone unscroupolous tries, deny them anyway.
    if (!(DRS_WRIT_REP & pMsgIn->ulFlags)) {
	pMsgOut->ulExtendedRet = EXOP_ERR_PARAM_ERR;
        return 0;
    }

    /* Initialize variables */
    memset(&ReqDSName, 0, sizeof(DSNAME));
    ReqDSName.Guid = pMsgIn->uuidDsaObjDest;
    ReqDSName.structLen = DSNameSizeFromLen(0);
    pMsgOut->pNC = pMsgIn->pNC;
    pMsgOut->uuidDsaObjSrc = gAnchor.pDSADN->Guid;
    pMsgOut->uuidInvocIdSrc = pTHS->InvocationID;
    pMsgOut->PrefixTableSrc = *pLocalPrefixTable;
    memset(&sel, 0, sizeof(sel));
    sel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    sel.attSel = (pMsgIn->ulFlags & DRS_MAIL_REP) ?
      EN_ATTSET_LIST_DRA_EXT : EN_ATTSET_LIST_DRA;
    pMsgOut->fMoreData = FALSE;
    pList = THAllocEx(pTHS, sizeof(*pList));
    pList->pObj = THAllocEx(pTHS,pMsgIn->pNC->structLen);
    memcpy(pList->pObj, pMsgIn->pNC, pMsgIn->pNC->structLen);
    pList->pNext = NULL;
    pMsgOut->ulExtendedRet = EXOP_ERR_EXCEPTION;

    // If updates are disabled, it's okay to generate writes iff we're demoting
    // this DC and this is our demotion partner requesting we complete the FSMO
    // transfer that we initiated as part of the demotion.
    fBypassUpdatesEnabledCheck = draIsCompletionOfDemoteFsmoTransfer(pMsgIn);

    BeginDraTransactionEx(SYNC_WRITE, fBypassUpdatesEnabledCheck);

    __try {
        /* First, let's make sure we recognize the caller, by checking to
         * see that his object is present on this server.
         */
        err = DBFindDSName(pTHS->pDB, &ReqDSName);
        if (err) {
            pMsgOut->ulExtendedRet = EXOP_ERR_UNKNOWN_CALLER;
            __leave;
        }
        err = DBGetAttVal(pTHS->pDB,
                          1,
                          ATT_OBJ_DIST_NAME,
                          0,
                          0,
                          &cbRet,
                          (UCHAR **)&pReqDSName);
        if (err) {
            DRA_EXCEPT(DRAERR_DBError, err);
        }

        switch(pMsgIn->ulExtendedOp) {
          case EXOP_FSMO_REQ_PDC:    // obsolete
          case EXOP_FSMO_RID_REQ_ROLE: // obsolete
            //fall through to general case

          case EXOP_FSMO_REQ_ROLE:
            /* generic role-owner transfer */
            pMsgOut->ulExtendedRet = FSMORoleTransfer(pMsgIn->pNC,
                                                      pReqDSName,
                                                      &pMsgIn->usnvecFrom,
                                                      (HANDLE)pList);
            
            if ( pMsgOut->ulExtendedRet != EXOP_ERR_SUCCESS ) {
                LogEvent8( DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                           DS_EVENT_SEV_ALWAYS,
                           DIRLOG_FSMO_XFER_FAILURE,
                           szInsertDN(pMsgIn->pNC),          
                           szInsertDN(gAnchor.pDSADN),        
                           szInsertDN(pReqDSName),
                           szInsertUL(pMsgOut->ulExtendedRet),
                           NULL, NULL, NULL, NULL
                           );

            }
            else {
                LogEvent( DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_FSMO_XFER,
                          szInsertDN(pMsgIn->pNC),          
                          szInsertDN(pReqDSName),
                          szInsertDN(gAnchor.pDSADN)
                          );
            }
            break;


          case EXOP_FSMO_ABANDON_ROLE:
            /* a request to take away a role */
            EndDraTransaction(TRUE);
            pTHS->fDSA = TRUE;
            err = GenericBecomeMaster(pMsgIn->pNC,
                                      0,
                                      gNullUuid,
                                      &OpRes);
            pMsgOut->ulExtendedRet = OpRes.ulExtendedRet;
            BeginDraTransaction(SYNC_READ_ONLY);
            break;

	case EXOP_FSMO_REQ_RID_ALLOC:

            /* RID pool allocation request */
            EndDraTransaction(TRUE);
            pTHS->fDSA = TRUE;

            pMsgOut->ulExtendedRet = FSMORidRequest(pTHS,
                                                    pMsgIn->pNC,
                                                    pReqDSName,
                                                    &pMsgIn->liFsmoInfo,
                                                    (HANDLE) pList );

            BeginDraTransaction(SYNC_READ_ONLY);

            break;

	case EXOP_REPL_OBJ:
	    { 
		// The request is for a replication of a single object.

                // There is nothing more to add since the fsmo object is always
                // included in the list. See above.

                // Verify the existence of the object.

                err = DBFindDSName(pTHS->pDB,pMsgIn->pNC);
                if (err==0) {
		    pMsgOut->ulExtendedRet = EXOP_ERR_SUCCESS;
		}
		else {
		    pMsgOut->ulExtendedRet = EXOP_ERR_UPDATE_ERR;
		}
	    }
	    break;

	default:
            pMsgOut->ulExtendedRet = EXOP_ERR_UNKNOWN_OP;
        }

        switch (pMsgOut->ulExtendedRet) {
          case EXOP_ERR_SUCCESS:
          case EXOP_ERR_FSMO_NOT_OWNER:
            fCommit = TRUE;
            break;

          default:
            Assert(fCommit == FALSE);
        }
    }
    __finally {

        EndDraTransaction(fCommit);
    }

    Assert(pMsgOut->ulExtendedRet);

    if (!fCommit) {
        /* We didn't want to update our database, so it must have been
         * an error, which means that we should not be proclaiming
         * success to the caller.  Further, we have nothing to pass back.
         */
        Assert(pMsgOut->ulExtendedRet != EXOP_ERR_SUCCESS);
        return 0;
    }

    /* If we've gotten here, we have data to return to our caller,
     * so start a new read transaction and walk down the list of objects
     * to be returned, gathering the correct data from each.
     */

    /* Build a couple auxilliary data structures that let us optimize the
     * set of objects that need to be returned.
     */
    pDntHashTable = dntHashTableAllocate( pTHS );

    /* N.B. A New transaction should be started since additions maybe be
     * stored in the dn cache and when the DBGetAttVal is called the guid
     * maybe be returned.
     */

    BeginDraTransaction(SYNC_READ_ONLY);

    __try {


        do {

            // seek to object
            err = DBFindDSName(pTHS->pDB,pList->pObj);
            if (err) {
                DRA_EXCEPT(DRAERR_DBError, err);
            }

            if ( INVALIDDNT == dntNC ) {
                //
                // Get ncDnt. If the object is the NC head, we'll use its
                // DNT, otherwise use pDB->NCDNT. We find if it is via its
                // instance type.
                //

                if ( (err=GetExistingAtt(
                                pTHS->pDB,
                                ATT_INSTANCE_TYPE,
                                &it,
                                sizeof( it )
                                 ) ) )
                {
                    DRA_EXCEPT(DRAERR_DBError, err);
                }
                dntNC = FExitIt( it )? (pTHS->pDB->DNT): (pTHS->pDB->NCDNT);
            }

            AddAnyUpdatesToOutputList(pTHS->pDB,
                                      0, // dwDirSyncControlFlags
                                      NULL, // No security desc
                                      dntNC,
                                      pMsgIn->usnvecFrom.usnHighPropUpdate,
                                      NULL,
                                      pMsgIn,
                                      NULL,
                                      NULL,
                                      &pMsgOut->cNumObjects,
                                      pDntHashTable,
                                      &ppEIListNext);

	    addValuesToShip( pTHS,
			     dntNC,
			     pMsgIn->usnvecFrom.usnHighPropUpdate,
			     pMsgIn->pUpToDateVecDest,
			     pMsgIn,
			     pcAllocatedValues,
			     pMsgOut );
	    
	    pTemp = pList;
	    pList = pList->pNext;
	    THFreeEx(pTHS,pTemp->pObj);
	    THFreeEx(pTHS,pTemp);
	} while (pList);

        // return created output list
        *ppEIListNext = NULL;
        pMsgOut->pObjects = pEIListHead;
    }
    __finally {
        /* Always commit reads */
        EndDraTransaction(TRUE);
    }
    return 0;
}

//
//  This functions checks if the object
//  referred to by pDB is a univarsal group
//  object and decides whether the group
//  member property should be shipped to the
//  GC or not.
//
//  Returns TRUE if the group member property
//  should filtered; FALSE, otherwise.
//  Throws a DRA exception if there is any DB related
//  failure.
//
BOOL IsFilterGroupMember(DBPOS *pDB, CLASSCACHE *pCC)
{
    SYNTAX_OBJECT_ID    objClass;
    ULONG               ulGroupType;
    BOOL                fFilter = FALSE;

    if (CLASS_GROUP == pCC->ClassId)
    {
        if (DBGetSingleValue(pDB, ATT_GROUP_TYPE, &ulGroupType, sizeof(ulGroupType), NULL))
        {
            if (DBIsObjDeleted(pDB))
            {
                // Okay for ATT_GROUP_TYPE to be absent on tombstones.
                // In this case the membership is absent, too, but we
                // should replicate it out anyway so that the meta data
                // is correct.
                fFilter = FALSE;
            }
            else
            {
                // Object is live; group type must be present.
                DraErrMissingAtt(GetExtDSName(pDB), ATT_GROUP_TYPE);
            }
        }
        else
        {
            // group types are defined in sdk\inc\ntsam.h
            fFilter = !(ulGroupType & GROUP_TYPE_UNIVERSAL_GROUP);
        }
    }

    return fFilter;
}


int __cdecl
CompareReplValInf(
    const void * Arg1,
    const void * Arg2
    )

/*++

Routine Description:

    Sort an array of REPLVALINF structures.

    This is done for reasons of grouping the entries for processing efficiency, NOT for
    duplicate removal.  The destination of an RPC request batches updates to values by
    containing object.  At the source using the LDAP replication control, the code for
        LDAP_ReplicaMsgToSearchResultFull ()
    groups changes by containing object, attribute, and present/absent status.

    It is possible to see duplicate values identical in all respects except for metadata. Since
    we pick up changes in multiple transactions, it is possible to see the same object
    changed more than once.  The convergence properties of our algorithm guarantee that we
    can apply changes to a value or object in any order, regardless of whether the changes
    arrive in one packet or several.  In short, duplicates are an hopefully infrequent, but
    definite possibility here.

Arguments:

    Arg1 -
    Arg2 -

Return Value:

    int __cdecl -

--*/

{
    THSTATE *pTHS = pTHStls;
    int state;
    REPLVALINF *pVal1 = (REPLVALINF *) Arg1;
    REPLVALINF *pVal2 = (REPLVALINF *) Arg2;
    ATTCACHE *pAC;
    DSNAME *pdnValue1, *pdnValue2;

    Assert( !fNullUuid( &pVal1->pObject->Guid ) );
    Assert( !fNullUuid( &pVal2->pObject->Guid ) );

    // Sort by containing object guid first
    state = memcmp(&pVal1->pObject->Guid, &pVal2->pObject->Guid, sizeof(GUID));
    if (state) {
        return state;
    }

    // Sort by attrtyp second
    state = ((int) pVal1->attrTyp) - ((int) pVal2->attrTyp) ;
    if (state) {
        return state;
    }

    // Sort by isPresent third
    // This will sort by absent values first
    state = ((int) pVal1->fIsPresent) - ((int) pVal2->fIsPresent) ;
    if (state) {
        return state;
    }

    // Sort on the value itself as a (mostly) tie-breaker

    // Since attrTyp1 == attrType2, both use same pAC
    pAC = SCGetAttById(pTHS, pVal1->attrTyp);
    if (!pAC) {
        DRA_EXCEPT(DIRERR_ATT_NOT_DEF_IN_SCHEMA, 0);
    }
    // Get the DSNAME output of the ATTRVAL
    pdnValue1 = DSNameFromAttrVal( pAC, &(pVal1->Aval) );
    if (pdnValue1 == NULL) {
        DRA_EXCEPT(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX, 0);
    }
    pdnValue2 = DSNameFromAttrVal( pAC, &(pVal2->Aval) );
    if (pdnValue2 == NULL) {
        DRA_EXCEPT(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX, 0);
    }

    // Sort by value guid last
    state = memcmp(&pdnValue1->Guid, &pdnValue2->Guid, sizeof(GUID));
    if (state) {
        return state;
    }

    // The values are duplicates. As stated above, duplicates do not affect the correctness
    // of the replication algorithm. To further differentiate would only serve to help
    // qsort efficiency. To further differentiate, we could compare the
    // binary data in a value, if any.  Finally, the values should differ in their
    // metadata stamps.

    // Not executed. Keep compiler happy
    return 0;
} /* CompareReplValInf */


DWORD
ProcessPartialSets(
    IN  THSTATE *                   pTHS,
    IN  DRS_MSG_GETCHGREQ_NATIVE *  pmsgIn,
    IN  BOOL                        fIsPartialSource,
    OUT PARTIAL_ATTR_VECTOR **      ppNewDestPAS
    )
/*++

Routine Description:

    Process partial sets for RO replication:
     - handle prefix mapping
     - use local PAS if dest didn't sent one (W2K dest)
     - PAS only: combine dest's PAS & extended PAS
     - RO src+dest only: ensure that we have dest's PAS

Arguments:

    pTHS - Thread state
    pmsgIn - incoming repl request
    fIsPartialSource - are we RO as well
    ppNewDestPAS - combined PAS.

Return Value:

    Error: in DRAERR error space
    Success: DRAERR_success

--*/
{
    SCHEMA_PREFIX_MAP_HANDLE        hPrefixMap = NULL;
    PARTIAL_ATTR_VECTOR             *pNCPAS = NULL;

    Assert(ppNewDestPAS);
    Assert(pmsgIn->pPartialAttrSet);


    if ( pmsgIn->PrefixTableDest.PrefixCount ) {
        //
        // Dest sent Prefix Table
        //

        //
        // Attribute Mapping
        // Dest sent a prefix table & attr vector, thus map ATTRTYPs in
        // destination's partial attribute set to local ATTRTYPs.

        hPrefixMap = PrefixMapOpenHandle(
                        &pmsgIn->PrefixTableDest,
                        &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable);
        if (!PrefixMapTypes(hPrefixMap,
                            pmsgIn->pPartialAttrSet->cAttrs,
                            pmsgIn->pPartialAttrSet->rgPartialAttr)) {
            // Mapping failed.
            return(DRAERR_SchemaMismatch);
        }
        // sort results in place
        qsort(pmsgIn->pPartialAttrSet->rgPartialAttr,
              pmsgIn->pPartialAttrSet->cAttrs,
              sizeof(ATTRTYP),
              CompareAttrtyp);
    }

    if ( pmsgIn->ulFlags & DRS_SYNC_PAS ) {

         //
         // PAS replication
         //

         // parameter sanity
         if (!pmsgIn->pPartialAttrSet || !pmsgIn->pPartialAttrSetEx) {
             // how come? all PAS requests should contain both PAS sets!
             Assert(!"Invalid PAS replcation request: no PAS in packet\n");
             return(DRAERR_InternalError);
         }


         // Now map prefix table for extended PAS vector
         Assert(hPrefixMap);
         if (!PrefixMapTypes(hPrefixMap,
                             pmsgIn->pPartialAttrSetEx->cAttrs,
                             pmsgIn->pPartialAttrSetEx->rgPartialAttr)) {
             // Mapping failed.
             return(DRAERR_SchemaMismatch);
         }
         // sort results in place
         qsort(pmsgIn->pPartialAttrSetEx->rgPartialAttr,
               pmsgIn->pPartialAttrSetEx->cAttrs,
               sizeof(ATTRTYP),
               CompareAttrtyp);

    }

    if ( hPrefixMap ) {
        // done w/ PrefixMap handle. Close it.
        PrefixMapCloseHandle(&hPrefixMap);
    }



    // although could get generated later, we calculate this here & pass on
    // to prevent expensive re-calc later.
    *ppNewDestPAS = GC_CombinePartialAttributeSet(
                    pTHS,
                    (PARTIAL_ATTR_VECTOR*)pmsgIn->pPartialAttrSet,
                    (PARTIAL_ATTR_VECTOR*)pmsgIn->pPartialAttrSetEx);
    Assert(*ppNewDestPAS);

    //
    // RO Destination. If source is RO, then we must ensure that
    // we can supply source w/ the current PAS.
    // (if we're RW, we always have all attributes).
    // Except: if we'd generated the PAS vector, skip the check.
    //

    if (fIsPartialSource &&
        (PVOID)pmsgIn->pPartialAttrSet !=
        (PVOID)((SCHEMAPTR *)pTHS->CurrSchemaPtr)->pPartialAttrVec) {
        // get PAS from NC head
        if (!GC_ReadPartialAttributeSet(pmsgIn->pNC, &pNCPAS)) {
            // Unable to read the partial attribute set on the NCHead
            return(DRAERR_DBError);
        }

        // ensure working PAS is contained in NC head's PAS.
        // that is, make sure all attributes in requested set were
        // commited by the replication engine on the NC head
        // (see bug Q:452022)
        if (!GC_IsSubsetOfPartialSet(*ppNewDestPAS,
                                     pNCPAS)) {
            // NC PAS doesn't contain all attributes in working set.
            // Are we waiting to replicate them in?
            return(DRAERR_IncompatiblePartialSet);
        }                           // pNewDestPAS isn't subset of PAS
    }                               // fIsPartialSource

    return DRAERR_Success;
}

DWORD
DraGetNcSize(
    IN  THSTATE *                     pTHS,
    IN  BOOL                          fCriticalOnly,
    IN  ULONG                         dntNC
)
/*++

Routine Description:

    Get the approximate size of the NC.  First, try to get the size of the
    NC from the local memory NC cache on the gAnchor.  If not present or 
    the size is 0 (meaning not cached), then actually query the database.

    The original database query was too expensive on the big DIT machines,
    so now we've got this.  NOTE: This blows your currency, and throws
    exceptions for errors.

Arguments:

    pTHS (IN)
        pTHS->fLinkedValueReplication (IN) - If the forest is in LVR mode.

    fCriticalOnly (IN) - If we want the critical objects only.

    dntNC (IN) - The Naming Context of interest.

Return Values:

    Approximate count of number of objects in NC.  Currency will be lost!

--*/
{
    NCL_ENUMERATOR          nclData;
    NAMING_CONTEXT_LIST *   pNCL = NULL;
    ULONG                   ulEstimatedSize;

    // If it's critical objects only it shouldn't matter, the count will be
    // relatively quick.
    if(!fCriticalOnly){
        NCLEnumeratorInit(&nclData, CATALOG_MASTER_NC);
        NCLEnumeratorSetFilter(&nclData, NCL_ENUMERATOR_FILTER_NCDNT, (void *)UlongToPtr(dntNC));
        pNCL = NCLEnumeratorGetNext(&nclData);
        if(pNCL &&
           pNCL->ulEstimatedSize != 0){
            // YES! We got a cached hit with valid data.
            return(pNCL->ulEstimatedSize);
        }
        // We don't check the partial replica list, because this list does
        // not cache the estimated size.  If someone ever decided to cache
        // the estimated size of the partial replica NCs, this should be
        // updated to try that cache first.
    }

    if (!fCriticalOnly) {
        ulEstimatedSize = DBGetEstimatedNCSizeEx(pTHS->pDB, dntNC);
        if(ulEstimatedSize == 0){
            return(DBGetApproxNCSizeEx( pTHS->pDB, pTHS->pDB->JetObjTbl,
                                        Idx_DraUsn,
                                        dntNC ) );
        } else {
            return(ulEstimatedSize);
        }
    } else {
        return(DBGetNCSizeExSlow( pTHS->pDB, pTHS->pDB->JetObjTbl,
                                  Idx_DraUsnCritical,
                                  dntNC ) );
    }

    Assert(!"We should never get this far!");
    return 0;
    // currency is lost after this.  Make sure callers reestablish.
}
  

ULONG
DRA_GetNCChanges(
    IN  THSTATE *                     pTHS,
    IN  FILTER *                      pFilter OPTIONAL,
    IN  DWORD                         dwDirSyncControlFlags,
    IN  DRS_MSG_GETCHGREQ_NATIVE *    pmsgIn,
    OUT DRS_MSG_GETCHGREPLY_NATIVE *  pmsgOut
    )
/*++

Routine Description:

    Construct an outbound replication packet at the request of another replica
    or a DirSync client.

Arguments:

    pTHS (IN)

    pFilter (IN, OPTIONAL) - If specified, only objects that match the filter
        will be returned.  Used by DirSync clients.

    pmsgIn (IN) - Describes the desired changes, including the NC and the sync
        point to start from.

    pmsgOut (OUT) - On successful return, holds the changes and the next sync
        point (amongst other things).

Return Values:

    Win32 error.

--*/
{
    USN                             usnLowestC;
    ULONG                           ret;
    USN                             usnChangedSeekStart;
    REPLENTINFLIST *                pEntInfListHead;
    REPLENTINFLIST **               ppEntInfListNext;
    USN                             usnChangedFound = 0;
    char                            szUuid[ SZUUID_LEN ];
    ULONG                           dntNC;
    BOOL                            fInsertNCPrefix;
    DNT_HASH_ENTRY *                pDntHashTable;
    DWORD                           cbAncestorsSize = 0;
    ULONG *                         pdntAncestors = NULL;
    DWORD                           cNumAncestors;
    DWORD                           iAncestor;
    SYNTAX_INTEGER                  instanceType;
    SCHEMA_PREFIX_TABLE *           pLocalPrefixTable;
    USN                             usnFromUtdVec;
    BOOLEAN                         fReturnCritical;
    CLASSCACHE *                    pccNC;
    FILTER *                        pIntFilter = NULL;
    handle_t                        hEncoding = NULL;
    DWORD                           cbEncodedSize = 0;
    ULONG                           ulOutMsgMaxObjects;
    ULONG                           ulOutMsgMaxBytes;
    ULONG                           ulTickToTimeOut;
    PARTIAL_ATTR_VECTOR             *pNewDestPAS=NULL;
    BOOL                            fIsPartialSource;
    ULONG                           cAllocatedValues = 0;
    BOOL                            fValueChangeFound = FALSE;
    PVOID                           pvCachingContext = NULL;
    DBPOS                           *pDBAnc = NULL;
    POBJECT_TYPE_LIST               pFilterSecurity;
    DWORD *                         pResults;
    ULONG                           FilterSecuritySize;
    BOOL *                          pbSortSkip = NULL;
    DRS_EXTENSIONS *                pextLocal = (DRS_EXTENSIONS *) gAnchor.pLocalDRSExtensions;
#if DBG
    DWORD                           cTickSaveTransStart;
#endif

    // When using DirSync Control, filter must be specified
    Assert( !dwDirSyncControlFlags || pFilter );

    fReturnCritical = (((pmsgIn->ulFlags) & DRS_CRITICAL_ONLY) != 0);

    pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    ZeroMemory(pmsgOut, sizeof(*pmsgOut));
    // The mail-based reply must have a minimum of fields filled in
    // Do this first so that these are filled in on error.

    // Send "from" vector back to destination such that if it is
    // replicating aynchronously (e.g., by mail), it can ensure that
    // the reply it gets from this source corresponds to the last batch
    // of changes it requested.
    pmsgOut->usnvecFrom = pmsgIn->usnvecFrom;

    pmsgOut->pNC = THAllocEx(pTHS,  pmsgIn->pNC->structLen);
    memcpy(pmsgOut->pNC, pmsgIn->pNC, pmsgIn->pNC->structLen);

    // Caller needs to know our UUIDs.
    pmsgOut->uuidDsaObjSrc = gAnchor.pDSADN->Guid;



    // Log parameters
    LogAndTraceEvent(TRUE,
                     DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_GETNCCH_ENTRY,
                     EVENT_TRACE_TYPE_START,
                     DsGuidGetNcChanges,
                     szInsertUUID(&pmsgIn->uuidDsaObjDest),
                     szInsertDN(pmsgIn->pNC),
                     szInsertUSN(pmsgIn->usnvecFrom.usnHighObjUpdate),
                     szInsertHex(pmsgIn->ulFlags),
                     szInsertUL(fReturnCritical),
                     szInsertUL(pmsgIn->ulExtendedOp),
                     NULL,
                     NULL);

    // Check for invalid parameters
    if (    ( NULL == pmsgIn      )
         || ( NULL == pmsgIn->pNC )
         || ( NULL == pmsgOut     ) )
    {
        ret = DRAERR_InvalidParameter;
        goto LogAndLeave;
    }

    // Reject if outbound replication is disabled
    if (    (    gAnchor.fDisableOutboundRepl
              && !( pmsgIn->ulFlags & DRS_SYNC_FORCED )
            )
       )
    {
        ret = DRAERR_SourceDisabled;
        goto LogAndLeave;
    }

    if (!(dwDirSyncControlFlags & LDAP_DIRSYNC_PUBLIC_DATA_ONLY)
        && (REPL_EPOCH_FROM_DRS_EXT(pextLocal)
            != REPL_EPOCH_FROM_DRS_EXT(pTHS->pextRemote))) {
        // The replication epoch has changed (usually as the result of a domain
        // rename).  We are not supposed to communicate with DCs of other
        // epochs.
        DSNAME *pdnRemoteDsa = draGetServerDsNameFromGuid(pTHS,
                                                          Idx_ObjectGuid,
                                                          &pmsgIn->uuidDsaObjDest);

        DPRINT3(0, "GetChanges request from %ls denied - replication epoch mismatch (remote %d, local %d).\n",
                pdnRemoteDsa->StringName,
                REPL_EPOCH_FROM_DRS_EXT(pTHS->pextRemote),
                REPL_EPOCH_FROM_DRS_EXT(pextLocal));

        LogEvent(DS_EVENT_CAT_RPC_SERVER,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_REPL_EPOCH_MISMATCH_COMMUNICATION_REJECTED,
                 szInsertDN(pdnRemoteDsa),
                 szInsertUL(REPL_EPOCH_FROM_DRS_EXT(pTHS->pextRemote)),
                 szInsertUL(REPL_EPOCH_FROM_DRS_EXT(pextLocal)));

        THFreeEx(pTHS, pdnRemoteDsa);

        ret = ERROR_DS_DIFFERENT_REPL_EPOCHS;
        goto LogAndLeave;
    }

    // Create hash table to use to determine whether a given object has already
    // been put in the output buffer.
    pDntHashTable = dntHashTableAllocate( pTHS );

    // Make server-side modifications to from vector.
    if (pmsgIn->ulFlags & DRS_FULL_SYNC_PACKET) {
	// In "full sync packet" mode, return all properties.
	pmsgIn->pUpToDateVecDest = NULL;
	pmsgIn->usnvecFrom.usnHighPropUpdate = 0;
    }
    else {
	// The more typical cases.
	DraImproveCallersUsnVector(pTHS,
				   &pmsgIn->uuidDsaObjDest,
				   pmsgIn->pUpToDateVecDest,
				   &pmsgIn->uuidInvocIdSrc,
				   pmsgIn->ulFlags,
				   &pmsgIn->usnvecFrom);
    }

    pmsgOut->PrefixTableSrc = *pLocalPrefixTable;

    // If we're doing an extended operation, branch off now
    if (pmsgIn->ulExtendedOp) {
        ret = DoExtendedOp(pTHS, pmsgIn, &cAllocatedValues, pmsgOut);
        goto LogAndLeave;
    }

    // Calculate the tick at which we should terminate our attempts to find
    // more objects to put in the outbound packet.  We will chop off the packet
    // and send what we have when
    // (1) the packet has crested the object limit,
    // (2) the packet has crested the byte count limit, or
    // (3) gulDraMaxTicksForGetChanges (msecs) have transpired.
    ulTickToTimeOut = GetTickCount() + gulDraMaxTicksForGetChanges;

    // Before we start a transaction, determine the lowest uncommitted
    // usn that exists. It's there because transactions can be committed out of USN order.
    // I.e., USNs are allocated sequentially, but they may well not be committed to the
    // database sequentially.  usnLowestC is the highest USN for which we know there are no
    // transactions in progress using a lower USN.  Returning a USN higher than this value
    // could cause us to miss sending an update, leading to divergence

    // [Jeffparh] The call to DBGetHighestUncommittedUSN() has to be made
    // before the transaction starts to avoid a race condition.  (We want to
    // make sure that the USN we get here has indeed been committed before
    // our transaction starts, otherwise we wouldn't see it in our
    // transaction.)

    usnLowestC = 1 + DBGetHighestCommittedUSN();
    
    
    BeginDraTransaction(SYNC_READ_ONLY);
    
#if DBG
    // Get current transaction signature
    cTickSaveTransStart = pTHS->JetCache.cTickTransLevel1Started;
#endif

    // From here on, all exceptions trapped to end clean up.

    __try {
        // Force all lazily committed transactions to disk.  All changes visible in this
        // transaction are durable after this call.
        DBForceDurableCommit();

        // Convert caller-supplied filter (if any) to internal version.
        if (NULL != pFilter) {
            if ( (ret = DBMakeFilterInternal(pTHS->pDB, pFilter, &pIntFilter, NULL)) != ERROR_SUCCESS) {
                DRA_EXCEPT(ret, 0);
            }
            GetFilterSecurity(pTHS,
                              pIntFilter,
                              SORT_NEVER,
                              0, // SortAttr
                              FALSE, // fABSearch
                              &pFilterSecurity,
                              &pbSortSkip,
                              &pResults,
                              &FilterSecuritySize);
        }

        // Capture the invocation id in the same transaction as the one where we read the
        // up to date vector so that the updated local cursor uses the same one
        // Note that pTHS->InvocationID can be refreshed on DBTransIn().
        pmsgOut->uuidInvocIdSrc = pTHS->InvocationID;

        // The new water mark is at least as high as the water mark that was
        // passed in even if no new objects have been written.
        pmsgOut->usnvecTo = pmsgIn->usnvecFrom;

        // Find the NC object, get and save its DNT.
        if (ret = FindNC(pTHS->pDB, pmsgIn->pNC,
                         FIND_MASTER_NC | FIND_REPLICA_NC, &instanceType)) {
            DRA_EXCEPT_NOLOG(DRAERR_BadDN, ret);
        }

        // Save the DNT of the NC object
        dntNC = pTHS->pDB->DNT;

        // If NC is in the process of being removed, it's an invalid replication
        // source.  It's perfectly acceptable for e.g. an interior node in a
        // partially removed NC to have a phantom parent, which is taboo for
        // replication sources.
        if (instanceType & IT_NC_GOING) {
            DRA_EXCEPT(DRAERR_NoReplica, ret);
        }

        // If this is a placeholder NC, it is not yet populated locally so we
        // should refuse outbound replication.
        GetObjSchema(pTHS->pDB, &pccNC);
        if (CLASS_TOP == pccNC->ClassId) {
            DRA_EXCEPT_NOLOG(DRAERR_NoReplica, 0);
        }

        if (!(pmsgIn->ulFlags & DRS_ASYNC_REP) ) {
            // Go ahead and get up-to-date vector now.  We don't do so
            // afterwards so that we don't risk skipping sending changes due to
            // an originating write occurring between the time we insert the
            // last element into the return buffer and the time we update the
            // vector with our latest USN.
            //
            // We skip this in the DRS_ASYNC_REP case since we're just going
            // to reset the destination's replication state anyway -- we will
            // never return a UTD vector to a caller who specified the
            // DRS_ASYNC_REP flag.

            UpToDateVec_Read(pTHS->pDB,
                             instanceType,
                             UTODVEC_fUpdateLocalCursor,
                             usnLowestC - 1,
                             &pmsgOut->pUpToDateVecSrc);

            // pUpToDateVecSrc may be null here for legitimate reasons
            Assert(IS_NULL_OR_VALID_UPTODATE_VECTOR(pmsgOut->pUpToDateVecSrc));
#if DBG
            {
                USN usn;
                Assert( (!pmsgOut->pUpToDateVecSrc) ||
                        ( UpToDateVec_GetCursorUSN(
                            pmsgOut->pUpToDateVecSrc,
                            &(pmsgOut->uuidInvocIdSrc),
                            &usn) &&
                          (usn <= usnLowestC - 1) ) );
            }
#endif
        }

        //
        // Partial-Attribute-Set setup
        //
        if (dwDirSyncControlFlags & LDAP_DIRSYNC_PUBLIC_DATA_ONLY) {
            // for dirsync clients, use specified partial attr set.
            pNewDestPAS = (PARTIAL_ATTR_VECTOR*)pmsgIn->pPartialAttrSet;
        }


        // remember if we're partial
        fIsPartialSource = FPartialReplicaIt(instanceType);

        if (!(pmsgIn->ulFlags & DRS_WRIT_REP)) {
            // Destination is a partial replica --
            // Partial Attribute Set Processing
            ret = ProcessPartialSets(
                        pTHS,
                        pmsgIn,
                        fIsPartialSource,
                        &pNewDestPAS );
            if (ret) {
                DRA_EXCEPT(ret, 0);
            }
        }
        else if (fIsPartialSource) {
            // Destination is a full or master replica and the local machine is
            // a partial replica; replication cannot proceed.
            DRA_EXCEPT(DRAERR_SourceIsPartialReplica, 0);
        }

        // We will start searching from one higher than the highest
        // usnChanged given.
        usnChangedSeekStart = pmsgIn->usnvecFrom.usnHighObjUpdate + 1;

        // Initialize the output list
        pEntInfListHead = NULL;
        ppEntInfListNext = &pEntInfListHead;
        pmsgOut->cNumObjects = 0;

        pmsgOut->fMoreData = TRUE;

        // Look for changes on the NC prefix first.  Note that the NC prefix
        // must be special-cased in this manner as it will never be found by
        // GetNextObjByIndex() -- its dntNC is that of its parent NC, not its
        // own dnt, and is thus missing from the index for the NC as a whole.

        fInsertNCPrefix = TRUE;

        // Return the number of objects in the NC
        if (pmsgIn->ulFlags & DRS_GET_NC_SIZE) {
            pmsgOut->cNumNcSizeObjects = DraGetNcSize(pTHS, fReturnCritical, dntNC);

            if (pTHS->fLinkedValueReplication) {
                // Only values in the database after LVR mode enabled
                pmsgOut->cNumNcSizeValues =
                    DBGetApproxNCSizeEx( pTHS->pDB, pTHS->pDB->JetLinkTbl,
                                         Idx_LinkDraUsn, dntNC );
            }

            // currency is lost after this, but ok, since reestablished below
        }

        // Sanity check cutoff values provided by client
        if (DRS_MAIL_REP & pmsgIn->ulFlags) {
            // Async (e.g., mail-based) intersite request.
            ulOutMsgMaxObjects = gcMaxAsyncInterSiteObjects;
            ulOutMsgMaxBytes = gcMaxAsyncInterSiteBytes;
        } else if (IS_REMOTE_DSA_IN_SITE(pTHS->pextRemote, gAnchor.pSiteDN)) {
            // DirSync/RPC intrasite request.  (Note that we err on the
            // side of "same site" if we can't tell for sure.)
            ulOutMsgMaxObjects = gcMaxIntraSiteObjects;
            ulOutMsgMaxBytes = gcMaxIntraSiteBytes;
        } else {
            // RPC intersite request.
            ulOutMsgMaxObjects = gcMaxInterSiteObjects;
            ulOutMsgMaxBytes = gcMaxInterSiteBytes;
        }

        pmsgIn->cMaxObjects = min(pmsgIn->cMaxObjects, ulOutMsgMaxObjects);
        pmsgIn->cMaxBytes = min(pmsgIn->cMaxBytes, ulOutMsgMaxBytes);
        pmsgIn->cMaxObjects = max(pmsgIn->cMaxObjects, DRA_MAX_GETCHGREQ_OBJS_MIN);
        pmsgIn->cMaxBytes = max(pmsgIn->cMaxBytes, DRA_MAX_GETCHGREQ_BYTES_MIN);


        // Create encoding handle to be used to size the data we're going to
        // ship.
        ret = MesEncodeFixedBufferHandleCreate(grgbFauxEncodingBuffer,
                                               sizeof(grgbFauxEncodingBuffer),
                                               &cbEncodedSize,
                                               &hEncoding);
        if (ret) {
            DRA_EXCEPT(ret, 0);
        }

        // While we have less than the maximum number of objects, search for
        // next object. We also check to see if the search loop has taken too
        // much time. This can happen when we are finding objects, but filtering
        // them out because the destination has already seen them according to
        // his UTD vector.  This is a common scenario when we are a newly
        // installed source and other older members are full syncing from us
        // for their first time.
        while ( (pmsgOut->cNumObjects < pmsgIn->cMaxObjects) &&
                (pmsgOut->cNumBytes < pmsgIn->cMaxBytes)  &&
                (CompareTickTime(GetTickCount(), ulTickToTimeOut) < 0) &&
                (eServiceShutdown == eRunning)) {

            if ( fInsertNCPrefix )
            {
                USN usnChanged;

                ret = DBFindDNT(pTHS->pDB, dntNC);
                if (0 != ret) {
                    // We found it just a second ago....
                    DRA_EXCEPT( DRAERR_DBError, ret );
                }

                fInsertNCPrefix = FALSE;

                // We have to seek to the NC head since it's NCDNT is not its
                // own DNT.  See, however, if we can filter it out up-front by
                // checking it's USN-Changed value.
                GetExpectedRepAtt(pTHS->pDB,
                                  ATT_USN_CHANGED,
                                  &usnChanged,
                                  sizeof(usnChanged));

                if (usnChanged < usnChangedSeekStart) {
                    // Nothing to see here; move along.
                    continue;
                }
            }
            else if (pmsgIn->ulFlags & DRS_ASYNC_REP) {
                // The destination is attempting to asynchronously add a replica
                // from the local machine.  We've already added any changes the
                // destination hasn't seen (if any) from the NC head to the
                // replication stream; call it quits.  The destination will do
                // the remainder of the replication later.
                pmsgOut->fMoreData = FALSE;
                memset(&pmsgOut->usnvecTo, 0, sizeof(pmsgOut->usnvecTo));
                break;
            }
            else {
                // If the client is DirSync and he doesn't understand values, don't return
                // any. The client gets a complete view because of two things:
                // 1. Value changes still touch the usn of their object (so they get picked up)
                // 2. AddAnyUpdate will merge lvr values back into their objects
                BOOL fIncludeValues =
                    ( (!(dwDirSyncControlFlags & LDAP_DIRSYNC_PUBLIC_DATA_ONLY)) ||
                      (dwDirSyncControlFlags & LDAP_DIRSYNC_INCREMENTAL_VALUES) );

                ret = GetNextObjOrValByUsn(pTHS->pDB,
                                           dntNC,
                                           usnChangedSeekStart,
                                           fReturnCritical,
                                           fIncludeValues, // Include values with objects?
                                           &ulTickToTimeOut,
                                           &pvCachingContext, // Caching context
                                           &usnChangedFound,
                                           &fValueChangeFound );
                if (ERROR_NO_MORE_ITEMS == ret) {
                    // No more updated items.  Set no continuation.
                    pmsgOut->fMoreData = FALSE;
                    break;
                }
                else if (ret && (ERROR_TIMEOUT != ret)) {
                    Assert(!"GetNextObjByIndex() returned unexpected error!");
                    DRA_EXCEPT(ret, 0);
                }

                // Don't return a maxusn past the lowest uncommitted (but return
                // object).
                if (usnChangedFound < usnLowestC) {

                    Assert(usnChangedFound > pmsgOut->usnvecTo.usnHighObjUpdate);
                    pmsgOut->usnvecTo.usnHighObjUpdate = usnChangedFound;
                }

                if (ERROR_TIMEOUT == ret) {
                    // Our time limit expired.  Return any objects we've found
                    // in this packet (if any) along with the updated USN.
                    // (Thus, even if we aren't returning any objects in this
                    // packet, we're still making progress.)
                    Assert(pmsgIn->usnvecFrom.usnHighObjUpdate
                           < pmsgOut->usnvecTo.usnHighObjUpdate);
                    break;
                }

                Assert(!ret);

                // set the usnChangedSeekStart for the next iteration
                usnChangedSeekStart = usnChangedFound + 1;
            }

            //
            // Found a change to potentially ship.
            // The change, either an object or a value, is represented by currency
            // in either the ObjTbl or LinkTbl respectively. This currency must be
            // preserved until the AddAnyXXX calls below are executed.
            //
            // [wlees 7/14/00] Having currency in the link table outside a single
            // DB layer call is an extension (for good or ill) of the original design.
            // The link table does not have the usual mechanisms to express currency,
            // such as a row tag and a means to seek to it. Hence the use of pDBAnc
            // below to preserve the whole DBPOS.
            //

            // Can this object be listed?
            if ( (dwDirSyncControlFlags & LDAP_DIRSYNC_OBJECT_SECURITY) &&
                 (!IsObjVisibleBySecurity(pTHS, FALSE)) ) {
                DPRINT1(1, "Object %ls cannot be listed; skipping...\n",
                        GetExtDSName(pTHS->pDB)->StringName);
                continue;
            }

            // Does this object match the filter and optionally security
            // provided by the caller?
            if (NULL != pIntFilter) {
                BOOL fMatch;
                DB_ERR dbErr;
                SYNTAX_INTEGER it;
                BOOL fDontEvalSecurity;

                // Make this look like a filtered search...
                DBSetFilter(pTHS->pDB, 
                            pIntFilter, 
                            pFilterSecurity,
                            pResults,
                            FilterSecuritySize, 
                            pbSortSkip
                    );

                pTHS->pDB->Key.ulSearchType = SE_CHOICE_BASE_ONLY;
                pTHS->pDB->Key.dupDetectionType = DUP_NEVER;
                pTHS->pDB->Key.ulSorted = SORT_NEVER;
                pTHS->pDB->Key.indexType = UNSET_INDEX_TYPE;

                GetExpectedRepAtt(pTHS->pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));

                // pure subref's don't have SD's
                fDontEvalSecurity = 
                    ((!(dwDirSyncControlFlags & LDAP_DIRSYNC_OBJECT_SECURITY)) ||
                     (it == SUBREF));

                dbErr = DBMatchSearchCriteria(pTHS->pDB,
                                              fDontEvalSecurity,
                                              &fMatch );
                if (DB_success != dbErr) {
                    DRA_EXCEPT( DRAERR_DBError, dbErr );
                }


                // This is necessary else other dblayer calls will try to free our
                // pIntFilter that was cached in the dbpos
                memset(&pTHS->pDB->Key, 0, sizeof(KEY));

                if (!fMatch) {
                    // Not a match; skip it.
                    DPRINT1(1, "Object %ls does not match filter criteria; skipping...\n",
                            GetExtDSName(pTHS->pDB)->StringName);
                    continue;
                }
                Assert( (!(dwDirSyncControlFlags & LDAP_DIRSYNC_OBJECT_SECURITY)) ||
                        (it == SUBREF) ||
                        pTHS->pDB->pSecurity );
            }


            //  If the object's not already in the output list, and if there are
            //  changes for this object that the destination has not yet seen,
            //  ship them.

            if (    ( pmsgIn->ulFlags & DRS_GET_ANC )
                 && ( pTHS->pDB->DNT != dntNC )
               )
            {
                DWORD dntObj = pTHS->pDB->DNT;
#if DBG
                DBPOS *pDBSave = pTHS->pDB;
#endif

                // Caller wants all ancestors, presumably because he couldn't
                // apply objects in the order we gave him last time.  (This
                // can occur when older objects are moved under newer objects.)

                DBGetAncestors(
                    pTHS->pDB,
                    &cbAncestorsSize,
                    &pdntAncestors,
                    &cNumAncestors
                    );

                // Skip over any ancestors preceding the head of this NC.
                for ( iAncestor = 0;
                      pdntAncestors[ iAncestor ] != dntNC;
                      iAncestor++
                    )
                {
                    ;
                }

                // And skip the NC head, too, since we've already added it to
                // the output list if necessary.
                iAncestor++;

                if (!fValueChangeFound) {
                    // Skip ourself, since we are added below
                    cNumAncestors--;
                }
                
                // For each remaining ancestor, ship it if we have changes the
                // destination hasn't seen (and if we haven't already added it
                // to the output buffer).

                // Open a new DB stream to preserve pTHS->pDB currency
                // This will be re-used for all object in this packet
                if (!pDBAnc) {
                    DBOpen2(FALSE, &pDBAnc);
                }

#if DBG
                // Verify no one is using this
                pTHS->pDB = NULL;
                __try {
#endif

                for ( ; iAncestor < cNumAncestors; iAncestor++ )
                {
                    ret = DBFindDNT( pDBAnc, pdntAncestors[ iAncestor ] );
                    if ( 0 != ret )
                    {
                        DRA_EXCEPT( DRAERR_DBError, ret );
                    }

                    AddAnyUpdatesToOutputList(
                        pDBAnc,
                        dwDirSyncControlFlags,
                        NULL, // No SD fetched yet
                        dntNC,
                        pmsgIn->usnvecFrom.usnHighPropUpdate,
                        pNewDestPAS,
                        pmsgIn,
                        hEncoding,
                        &pmsgOut->cNumBytes,
                        &pmsgOut->cNumObjects,
                        pDntHashTable,
                        &ppEntInfListNext
                        );
                }

#if DBG
                } __finally {
                    Assert( pTHS->pDB == NULL );
                    pTHS->pDB = pDBSave;
                }
#endif                
                Assert( dntObj == pTHS->pDB->DNT );
            }

            if (fValueChangeFound) {
                Assert( (!(dwDirSyncControlFlags & LDAP_DIRSYNC_PUBLIC_DATA_ONLY)) ||
                        (dwDirSyncControlFlags & LDAP_DIRSYNC_INCREMENTAL_VALUES) );

                AddAnyValuesToOutputList(
                    pTHS->pDB,
                    dwDirSyncControlFlags,
                    pTHS->pDB->pSecurity,
                    pmsgIn->usnvecFrom.usnHighPropUpdate,
                    pmsgIn,
                    pNewDestPAS,
                    hEncoding,
                    &pmsgOut->cNumBytes,
                    &cAllocatedValues,
                    &(pmsgOut->cNumValues),
                    &(pmsgOut->rgValues)
                    );
            } else {
                // Add the object we found via the creation or update index to the
                // output list (if any changes need to be sent for it).
                AddAnyUpdatesToOutputList(
                    pTHS->pDB,
                    dwDirSyncControlFlags,
                    pTHS->pDB->pSecurity,
                    dntNC,
                    pmsgIn->usnvecFrom.usnHighPropUpdate,
                    pNewDestPAS,
                    pmsgIn,
                    hEncoding,
                    &pmsgOut->cNumBytes,
                    &pmsgOut->cNumObjects,
                    pDntHashTable,
                    &ppEntInfListNext
                    );
            }

            // release the SD that has been loaded by DBMatchSearchCriteria
            if (pTHS->pDB->pSecurity && !pTHS->pDB->fSecurityIsGlobalRef) {
                THFreeEx(pTHS, pTHS->pDB->pSecurity);
            }
            pTHS->pDB->pSecurity = NULL;
        }  // while ()

        // Either there are no more changes, or we have hit max object limit

        //
        // Wrap up response message
        //

        if (pmsgOut->fMoreData) {
            //
            // Actions on "more data"
            //

            // don't send up-to-date vector until there are no more changes
            if (NULL != pmsgOut->pUpToDateVecSrc) {
                THFreeEx(pTHS, pmsgOut->pUpToDateVecSrc);
                pmsgOut->pUpToDateVecSrc = NULL;
            }
        }
        else {
            //
            // Actions on "no more data"
            //

            // Update property update watermark if it is the end of the repl session
            // and we are returning an up-to-date vector.
            // The reason we don't return the property update USN when the NC is coming is
            // analogous to why we don't return the property update USN in the middle of a
            // repl session. In the middle of a session, we're not guaranteed to have seen
            // all the objects yet, and there may be some later objects with attribute property
            // USNs less than our current usn.  Similary, if the NC is coming we haven't seen
            // all the incoming SUBREFs yet. An incoming SUBREF may cause an existing local
            // NC HEAD to be "grafted" into our NC, and it may have attributes with property
            // USNs less than the current USN.

            if (pmsgOut->pUpToDateVecSrc) {
                pmsgOut->usnvecTo.usnHighPropUpdate = pmsgOut->usnvecTo.usnHighObjUpdate;
            } else {
                // Enumerate scenarios were pUpToDateVecSrc is allowed to be NULL
                Assert( (pmsgIn->ulFlags & DRS_ASYNC_REP) || (instanceType & IT_NC_COMING) );
            }
        }

        // Add in size of the packet header.  (The struct does not yet include
        // the linked list of objects, but their size is already accounted for
        // in pmsgOut->cNumBytes.)
        pmsgOut->cNumBytes += DRS_MSG_GETCHGREPLY_V6_AlignSize(hEncoding,
                                                               pmsgOut);

        *ppEntInfListNext = NULL;
        pmsgOut->pObjects = pEntInfListHead;

        // Verify outbound USN vector is okay, but only if inbound USN vector
        // was also okay.  See restore remarks above.
        if (((pmsgIn->usnvecFrom.usnHighPropUpdate < usnLowestC)
             && (pmsgOut->usnvecTo.usnHighPropUpdate >= usnLowestC))
            || ((pmsgIn->usnvecFrom.usnHighObjUpdate < usnLowestC)
                && (pmsgOut->usnvecTo.usnHighObjUpdate >= usnLowestC))) {
            Assert(!"USN vector being given to destination implies he's more "
                    "up to date with respect to us than we are!");
            DRA_EXCEPT(DRAERR_InternalError, (ULONG) usnLowestC);
        }

        // NCs being removed cannot be used as replication sources (see similar
        // check at beginning of this function).  We must check at the end of
        // the function as we may have begun to tear down the NC while this
        // function was executing.  We verify that the NC has neither begun
        // (IT_NC_GOING) or completed (FPrefixIt) teardown.
        if ((ret = DBFindDNT(pTHS->pDB, dntNC))
            || (instanceType & IT_NC_GOING)
            || !FPrefixIt(instanceType)) {
            DRA_EXCEPT(DRAERR_NoReplica, ret);
        }

        // Note that the total byte size we calculate is just a little higher
        // than it really is (i.e., a little higher than what we'd get by
        // calling DRS_MSG_GETCHGREPLY_V1_AlignSize(hEncoding, pmsgOut) now),
        // presumably due to more padding bytes in the size we calculate
        // incrementally than are really need if we marshall the entire
        // structure at once.  In empirical testing the difference is only on
        // the order of 0.5%.
        DPRINT3(1, "Sending %d objects in %d bytes to %s.\n", pmsgOut->cNumObjects,
                                                              pmsgOut->cNumBytes,
                                                              UuidToStr(&pmsgIn->uuidDsaObjDest, szUuid, sizeof(szUuid)/sizeof(szUuid[0])));
    } __finally {

        if (pDBAnc) {
            // The "safe" variant doesn't except, so we are sure to end trans below
            DBCloseSafe(pDBAnc, TRUE);
        }

        // We require that this transaction not be closed by this or lower
        // layers while outbound replication is occurring.
        Assert( cTickSaveTransStart == pTHS->JetCache.cTickTransLevel1Started );

        EndDraTransaction(TRUE);

        if (NULL != hEncoding) {
            MesHandleFree(hEncoding);
        }
    }

    // Normal, non-FSMO-transfer exit path.  If we had hit an error, we would
    // have generated an exception -- we didn't, so we're successful.
    ret = 0;

LogAndLeave:

    // Sort the returned value list.
    // We do this here so that the list generated by DoFsmoOp can
    // take advantage of this as well.
    if ( (!ret) && (pmsgOut->cNumValues) ) {
        qsort( pmsgOut->rgValues,
               pmsgOut->cNumValues,
               sizeof( REPLVALINF ),
               CompareReplValInf );
    }

    LogAndTraceEvent(TRUE,
                     DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_GETNCCH_EXIT,
                     EVENT_TRACE_TYPE_END,
                     DsGuidGetNcChanges,
                     szInsertUL(pmsgOut->cNumObjects),
                     szInsertUL(pmsgOut->cNumBytes),
                     szInsertUSN(pmsgOut->usnvecTo.usnHighObjUpdate),
                     szInsertUL(pmsgOut->ulExtendedRet),
                     NULL, NULL, NULL, NULL);

    pmsgOut->dwDRSError = ret;

    return ret;
}


void
moveOrphanToLostAndFound(
    IN      DBPOS *                         pDB,
    IN      ULONG                           dntNC,
    IN      DRS_MSG_GETCHGREQ_NATIVE *      pMsgIn,
    IN      DSNAME *                        pdnObj
    )

/*++

Routine Description:

    An object has been found during outbound replication with a phantom parent.
    Move the object to Lost & Found

    This code corrects corrupt databases that were possible when running W2K and W2K SP1.
    To get into this situation, two bugs had to occur. The first was that a live object
    had to be left under a deleted parent. The correct behavior now is to move the object
    to Lost & Found. Second, the deleted parent had to be phantomized by the garbage
    collector. Now, the garbage collector will not phantomize deleted parents until their
    children are phantomized.

Arguments:

    pDB - Database position
    dntNC - DNT of NC
    pMsgIn - Get NC Changes request message
    pdnObj - DSNAME of object

Return Value:

    None
    Excepts on error

--*/

{
    DWORD ret;
    DSNAME *pNC;
    GUID objectGuid, objGuidLostAndFound;
    WCHAR   szRDN[ MAX_RDN_SIZE ];
    DWORD   cb;
    ATTR attrRdn;
    ATTRVAL attrvalRdn;

    DPRINT1( 0, "moveOrphanToLostAndFound, orphan = %ws\n", pdnObj->StringName);

    // Get the naming context
    if (pMsgIn->ulExtendedOp) {
        // For a FSMO operation, pMsgIn->pNC points to the FSMO object
        pNC = FindNCParentDSName(pMsgIn->pNC, FALSE, FALSE);
    } else {
        pNC = pMsgIn->pNC;
    }
    if (NULL == pNC) {
        DRA_EXCEPT( DRAERR_InternalError, 0 );
    }

    // Compute the guid of the lost and found container for this nc
    draGetLostAndFoundGuid(pDB->pTHS, pNC, &objGuidLostAndFound);

    // Get the current object's guid
    GetExpectedRepAtt(pDB, ATT_OBJECT_GUID, &(objectGuid), sizeof(GUID) );

    // Get the current name of the object
    ret = DBGetSingleValue(pDB, ATT_RDN, szRDN, sizeof(szRDN), &cb);
    if (ret) {
        DRA_EXCEPT (DRAERR_DBError, ret);
    }

    attrvalRdn.valLen = cb;
    attrvalRdn.pVal = (BYTE *) szRDN;

    // New name same as the old name
    attrRdn.attrTyp = ATT_RDN;
    attrRdn.AttrVal.valCount = 1;
    attrRdn.AttrVal.pAVal = &attrvalRdn;

    // Reparent the object to lost & found
    // The replicator can rename objects even on GC's
    ret = RenameLocalObj(pDB->pTHS,
                         dntNC,
                         &attrRdn,
                         &objectGuid,
                         &objGuidLostAndFound,
                         NULL,  // Originating write
                         TRUE, // fMoveToLostAndFound,
                         FALSE ); // fDeleteLocalObj
    if (ret) {
        DPRINT2( 0, "Failed to reparent orphan %ws, error %d\n", pdnObj->StringName, ret );
        LogEvent8( DS_EVENT_CAT_REPLICATION,
                   DS_EVENT_SEV_ALWAYS,
                   DIRLOG_DRA_ORPHAN_MOVE_FAILURE,
                   szInsertDN(pdnObj),
                   szInsertUUID(&objectGuid),
                   szInsertDN(pNC),
                   szInsertWin32Msg(ret),
                   szInsertWin32ErrCode(ret),
                   NULL, NULL, NULL );
        // We failed to rename the object. Except here with the reason. Outbound
        // replication will stop until someone can get rid of or move this object.
        // Note that we are not reporting the original exception that got us here,
        // which was missing parent or not an object.
        DRA_EXCEPT( ret, 0 );
    } else {
        // Log success
        DPRINT1( 0, "Successfully reparented orphan %ws\n", pdnObj->StringName );
        LogEvent( DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_ORPHAN_MOVE_SUCCESS,
                  szInsertDN(pdnObj),
                  szInsertUUID(&objectGuid),
                  szInsertDN(pNC) );
    }

} /* moveOrphanToLostAndFound */


void
AddAnyUpdatesToOutputList(
    IN      DBPOS *                         pDB,
    IN      DWORD                           dwDirSyncControlFlags,
    IN      PSECURITY_DESCRIPTOR            pSecurity,
    IN      ULONG                           dntNC,
    IN      USN                             usnHighPropUpdateDest,
    IN      PARTIAL_ATTR_VECTOR *           pPartialAttrVec,
    IN      DRS_MSG_GETCHGREQ_NATIVE *      pMsgIn,
    IN      handle_t                        hEncoding,              OPTIONAL
    IN OUT  DWORD *                         pcbTotalOutSize,        OPTIONAL
    IN OUT  DWORD *                         pcNumOutputObjects,
    IN OUT  DNT_HASH_ENTRY *                pDntHashTable,
    IN OUT  REPLENTINFLIST ***              pppEntInfListNext
    )
/*++

Routine Description:

    Adds the object with currency to the list of objects to be shipped to the
    replication client if there are changes the destination has not yet seen and
    if it has not already been added.

Arguments:

    pDB - Currency set on object to be shipped (if necessary).

    dwDirSyncControlFlags - Flags when being used as part of LDAP control

    dntNC - The DNT of the head of the NC being replicated.

    usnHighPropUpdateDest - Highest USN the remote machine has seen of changes
        made on the local machine.

    pmsgin - Incoming replication packet (for additional processing info)

    hEncoding (IN, OPTIONAL) - Encoding handle, if pcbTotalOutSize is desired
        (i.e., non-NULL).

    pcbTotalOutSize (IN/OUT, OPTIONAL) - Total number of bytes in output msg.

    pcNumOutputObjects (IN/OUT) - Number of objects in the output buffer.

    pDntHashTable (IN/OUT) - Hash table of objects currently in the uutput
        buffer.  Used to protect against duplicates.

    pppEntInfListNext (IN/OUT) - If the candidate object is to be shipped, is
        updated with the information ot be shipped for this object and is
        incremented to point to a free buffer for the next object.

Return Values:

    None.  Throws appropriate exeception on error.

--*/
{
    THSTATE                    *pTHS=pDB->pTHS;
    DSNAME *                    pdnObj = NULL;
    PROPERTY_META_DATA_VECTOR * pMetaDataVec = NULL;
    DWORD                       cbReturned;
    CLASSCACHE *                pClassSch;
    BOOL                        fIsSubRef = FALSE, fIsPureSubRef = FALSE;
    ENTINFSEL                   sel;
    SYNTAX_INTEGER              it;
    DNT_HASH_ENTRY *            pNewEntry;
    ATTRTYP                     rdnType;
    BOOL                        fFilterGroupMember = FALSE;
    BOOL                        fPublic =
        (((dwDirSyncControlFlags & LDAP_DIRSYNC_PUBLIC_DATA_ONLY) != 0) ||
	(!(pMsgIn->ulFlags & DRS_WRIT_REP))); // no secrets
    BOOL                        fMergeValues =
        ( (dwDirSyncControlFlags & LDAP_DIRSYNC_PUBLIC_DATA_ONLY) &&
          (!(dwDirSyncControlFlags & LDAP_DIRSYNC_INCREMENTAL_VALUES)) );
    BOOL fFreeSD = FALSE;

    // Sanity check our flags
    // If DirSync, must be writeable and public
    Assert( !(dwDirSyncControlFlags & LDAP_DIRSYNC_PUBLIC_DATA_ONLY) ||
            ( (pMsgIn->ulFlags & DRS_WRIT_REP) && fPublic ) );
    // Only DirSync has pPartial and writeable
    Assert( !(pPartialAttrVec && (pMsgIn->ulFlags & DRS_WRIT_REP)) ||
            (dwDirSyncControlFlags & LDAP_DIRSYNC_PUBLIC_DATA_ONLY) );

    // Has this object already been added to the output buffer?
    // We can attempt to add multiple identical objects because of get anc mode.
    // It is also possible that we will find multiple versions of the same object
    // while searching for changes because we use multiple transactions. This guarantees
    // that only the first is returned. This is NOT required for correctness however.
    if (dntHashTablePresent( pDntHashTable, pDB->DNT, NULL )) {
        // Object is already in output buffer; bail.
        return;
    }

    // Get its DN, ...
    if ( DBGetAttVal(
            pDB,
            1,
            ATT_OBJ_DIST_NAME,
            0,
            0,
            &cbReturned,
            (LPBYTE *) &pdnObj
            )
       )
    {
        DRA_EXCEPT(DRAERR_DBError, 0);
    }

    // ...meta data vector, ...
    if ( DBGetAttVal(
            pDB,
            1,
            ATT_REPL_PROPERTY_META_DATA,
            0,
            0,
            &cbReturned,
            (LPBYTE *) &pMetaDataVec
            )
       )
    {
        DRA_EXCEPT (DRAERR_DBError, 0);
    }

    if ( dntNC != pDB->DNT )
    {
        // Not the prefix of this NC; is it a subref?
        GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));
        fIsSubRef = FExitIt( it );
        fIsPureSubRef = (it == SUBREF);
        // If nc head found in this ncdnt, it must be a subref
        Assert( !fIsSubRef || (it & IT_NC_ABOVE) );
    }

    // Get SD if needed
    if ( (dwDirSyncControlFlags & LDAP_DIRSYNC_OBJECT_SECURITY) &&
         (!pSecurity) ) {
        ULONG ulLen;
        if (DBGetAttVal(pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                        DBGETATTVAL_fDONT_FIX_MISSING_SD,
                        0, &ulLen, (PUCHAR *)&pSecurity))
        {
            // The only object that is allowed not to have a security descriptor
            // is a pure subref. But it may have one, depending on how it was
            // created.
            if (!fIsPureSubRef) {
                DRA_EXCEPT(DRAERR_DBError, 0);
            }
        } else {
            fFreeSD = TRUE;
        }
    }

    // This embodies the current rules for when we need to have a SD...
    Assert( (!(dwDirSyncControlFlags & LDAP_DIRSYNC_OBJECT_SECURITY)) ||
            (fIsPureSubRef) ||
            (pSecurity)
        );

    // Old DirSync clients only...
    if (fMergeValues) {
        // We are here because we want to include link value changes in the context
        // of an object change entry that describes the whole object, including all
        // values. Since linked value metadata is stored in a separate table, we
        // must merge it in here.
        DBImproveAttrMetaDataFromLinkMetaData(
            pDB,
            &pMetaDataVec,
            &cbReturned
            );
    }

    if (pMetaDataVec)
    {
        VALIDATE_META_DATA_VECTOR_VERSION(pMetaDataVec);
    }

    // ...and object class.
    GetObjSchema( pDB, &pClassSch );

    // ...and rdnType
    // A superceding class may have an rdnattid that is different
    // from the object's rdnType. Use the rdnType from the object
    // and not the rdnattid from the class.
    GetObjRdnType( pDB, pClassSch, &rdnType );

    // need to filter group member only for a GC replication and if the
    // object under consideration satisfies the requirement for this special
    // filtering
    // Note the subtle distinction here:
    // DRS_WRIT_REP - (non-GC or DirSync) vs GC
    // pPartialAttrVec - attribute filtering, either GC or DirSync

    fFilterGroupMember = ( (!(pMsgIn->ulFlags & DRS_WRIT_REP)) &&
                           pPartialAttrVec &&
                           IsFilterGroupMember(pDB, pClassSch) );

    memset( &sel, 0, sizeof( ENTINFSEL ) );
    sel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    sel.attSel    = fPublic ? EN_ATTSET_LIST_DRA_PUBLIC : EN_ATTSET_LIST_DRA;

    // Determine subset of attributes to be shipped (if any).
    ReplFilterPropsToShip(
        pTHS,
        pdnObj,
        rdnType,
        fIsSubRef,
        usnHighPropUpdateDest,
        pPartialAttrVec,
        pMetaDataVec,
        &sel.AttrTypBlock,
        fFilterGroupMember,
        pMsgIn
        );

#if DBG
    // Sanity check the "creation property set".  There are certain attributes that are only
    // shipped on a creation. Verify that if any of these are shipped, that there are enough
    // attributes to create the object
    if ( (!AttrValFromAttrBlock(&sel.AttrTypBlock, ATT_WHEN_CREATED, NULL, NULL)) ||
         (!AttrValFromAttrBlock(&sel.AttrTypBlock, ATT_OBJECT_CLASS, NULL, NULL)) ) {
        SYNTAX_INTEGER  it;

        // This code intentionally parallels the destination side check in AddLocalObj()
        if (AttrValFromAttrBlock(&sel.AttrTypBlock, ATT_INSTANCE_TYPE, &it, NULL)
            || AttrValFromAttrBlock(&sel.AttrTypBlock, ATT_OBJECT_CLASS, NULL, NULL)
            || AttrValFromAttrBlock(&sel.AttrTypBlock, ATT_WHEN_CREATED, NULL, NULL)
            || AttrValFromAttrBlock(&sel.AttrTypBlock, ATT_RDN, NULL, NULL)
            || ( (it != SUBREF) &&
                 (AttrValFromAttrBlock(&sel.AttrTypBlock, ATT_NT_SECURITY_DESCRIPTOR,
                                       NULL, NULL)) ) ) {
            Assert( !"Source is not shipping enough attributes to create object! Is this Windows Bug 615261?" );
        }
    }
#endif

    // fMergeValues is true when we are being called by the LDAP replication control
    // and the caller desires the old semantics of returning all values instead of
    // just incremental changes.
    // The setting of fMergeValues affects how we retrieve values.
    // 1. fScopeLegacyLinks is a mechanism to control whether new style values with
    // metadata are visible. Under normal outbound replication of objects and attributes,
    // we want new style values to be invisible. Under normal operation, fMergeValues is
    // false, and thus scope limiting is true.
    // 2. We pass an argument to AddToList to control whether we limit the number of
    // values that may be added. Normally, outbound replication has no value limits
    // and so when fMerge is false, we apply no limits. However, when the replication
    // control is called in the old mode, we want to place some limits.

    if ( sel.AttrTypBlock.attrCount )
    {
        DWORD err = 0;

        pDB->fScopeLegacyLinks = !fMergeValues;
        __try {
            __try {
                // We have at least one property to ship from this object, so add it to
                // the output list.
                // The fifth argument controls whether we limit the number of values added
                // to attributes in the list.
                AddToOutputList(
                    pDB,
                    dwDirSyncControlFlags,
                    pSecurity,
                    &sel,
                    pMetaDataVec,
                    (pDB->DNT == dntNC),
                    hEncoding,
                    pcbTotalOutSize,
                    pppEntInfListNext,
                    pcNumOutputObjects
                    );
            } __finally {
                pDB->fScopeLegacyLinks = FALSE;
            }

            // Add object to hash table.
            dntHashTableInsert( pTHS, pDntHashTable, pDB->DNT, 0 );
        }
        __except (GetDraAnyOneWin32Exception(GetExceptionInformation(), &err, DRAERR_MissingParent)) {

            // An object has been found which has a phantomized parent
            // Do not include the object at the current point in the change stream.
            // Rename the object to lost and found
            // The rename will be found later in the change stream
            moveOrphanToLostAndFound( pDB, dntNC, pMsgIn, pdnObj );
        }
    }
    else {
        DPRINT2(4, "Property-filtered object %ws at usn %I64d\n",
                pdnObj->StringName, usnHighPropUpdateDest);
    }

    // Be heap-friendly.
    THFreeEx(pTHS, pMetaDataVec );
    THFreeEx(pTHS, pdnObj );
    if ( fFreeSD && (pSecurity)) {
        THFreeEx( pTHS, pSecurity );
    }
}


void
AddAnyValuesToOutputList(
    IN      DBPOS *                         pDB,
    IN      DWORD                           dwDirSyncControlFlags,
    IN      PSECURITY_DESCRIPTOR            pSecurity,
    IN      USN                             usnHighPropUpdateDest,
    IN      DRS_MSG_GETCHGREQ_NATIVE *      pMsgIn,
    IN      PARTIAL_ATTR_VECTOR *           pPartialAttrVec,
    IN      handle_t                        hEncoding,              OPTIONAL
    IN OUT  DWORD *                         pcbTotalOutSize,
    IN OUT  ULONG *                         pcAllocatedValues,
    IN OUT  ULONG *                         pcNumValues,
    IN OUT  REPLVALINF **                   ppValues
    )

/*++

Routine Description:

Add the current value to the output array.

It is assumed that the link table is positioned on the value to be added, and
that the object table is positioned on the containing object of the link.

The output list is an array that is grown in chunks as needed.

Source-side filtering is performed, so that a value is not added if
it is not needed.

Arguments:

    pDB - database context
    usnHighPropUpdateDest - destination's directly up to date usn
    pMsgIn - input request message
    pPartialAttrVec - destinations partial attribute vector. Passed when
              destination is a GC
    hEncoding - RPC marshalling encoding buffer, used for calculating sizes
    pcAllocatedValues - Currently allocated size of output array
    pcNumValues - Number of actual values in the array currently
    ppValues - Output array, reallocated as needed
    pcbTotalOutSize - Running total of bytes in output array

Return Value:

    None
    Exceptions raised

--*/

{
    ULONG ulLinkDnt, ulValueDnt, ulLinkBase, ulLinkId;
    ATTCACHE *pAC;
    VALUE_META_DATA valueMetaData;
    REPLVALINF *pReplValInf;
    DSTIME timeDeleted;
    DWORD err, cbReturned;
    GUID uuidObject;
    CHAR szUuid[ SZUUID_LEN ];
    USN usnCursor = 0;
    BOOL fIgnoreWatermarks = FALSE;

    Assert( pcAllocatedValues && pcNumValues && ppValues );

    Assert( pDB->pTHS->fLinkedValueReplication );

    //
    // Gather all the data about the change up front
    //

    // Get the link properties
    // We better be positioned on a value change for this to work
    DBGetLinkTableData( pDB, &ulLinkDnt, &ulValueDnt, &ulLinkBase );
    DPRINT3( 2, "AddAnyValues: linkdnt=%d, valuednt=%d, linkbase=%d\n",
             ulLinkDnt, ulValueDnt, ulLinkBase );

    // Compute which attribute this is
    ulLinkId = MakeLinkId(ulLinkBase);
    pAC = SCGetAttByLinkId(pDB->pTHS, ulLinkId);
    if (!pAC) {
        DRA_EXCEPT(DRAERR_InternalError, DRAERR_SchemaMismatch);
    }

    // get value metadata
    DBGetLinkValueMetaData( pDB, pAC, &valueMetaData );

    // Object table is positioned on containing object, get guid
    err = DBGetSingleValue(pDB, ATT_OBJECT_GUID,
                           &(uuidObject), sizeof(GUID), NULL);
    if (err) {
        DRA_EXCEPT (DRAERR_DBError, err);
    }

    // Get the dest's USN wrt orig of change
    // Get usnCursor only if we are going to log
    if (LogEventWouldLog( DS_EVENT_CAT_REPLICATION, DS_EVENT_SEV_EXTENSIVE )) {
        UpToDateVec_GetCursorUSN(
            pMsgIn->pUpToDateVecDest,
            &(valueMetaData.MetaData.uuidDsaOriginating),
            &usnCursor );
    }

    //
    // Filter the change
    //

    // Filter attribute based on partial attribute set
    if (pPartialAttrVec) {
        if ( ReplFilterGCAttr(
                        pAC->id,
                        pPartialAttrVec,
                        pMsgIn,
                        FALSE,
                        &fIgnoreWatermarks)) {
            DPRINT1( 3, "Attribute %s is not partial attribute set, value filtered\n",
                     pAC->name );
            // Log that value was filtered
            LogEvent8( DS_EVENT_CAT_REPLICATION,
                       DS_EVENT_SEV_EXTENSIVE,
                       DIRLOG_LVR_FILTERED_NOT_PAS,
                       szInsertUSN( valueMetaData.MetaData.usnProperty ),
                       szInsertSz( GetExtDN( pDB->pTHS, pDB ) ),
                       szInsertUUID( &uuidObject ),
                       szInsertSz( pAC->name ),
                       szInsertSz( DBGetExtDnFromDnt( pDB, ulValueDnt ) ),
                       NULL, NULL, NULL );
            return;
        }

        // need to filter group member only for a GC replication and if the
        // object under consideration satisfies the requirement for this special
        // filtering
        if ( (!(pMsgIn->ulFlags & DRS_WRIT_REP)) && (ATT_MEMBER == pAC->id) ) {
            CLASSCACHE *pClassSch;

            // Get object class
            GetObjSchema( pDB, &pClassSch );

            if (IsFilterGroupMember(pDB, pClassSch)) {
                DPRINT1( 3, "Attribute %s is special group member, value filtered\n",
                     pAC->name );
                // Log that value was filtered
                LogEvent8( DS_EVENT_CAT_REPLICATION,
                           DS_EVENT_SEV_EXTENSIVE,
                           DIRLOG_LVR_FILTERED_NOT_GROUP,
                           szInsertUSN( valueMetaData.MetaData.usnProperty ),
                           szInsertSz( GetExtDN( pDB->pTHS, pDB ) ),
                           szInsertUUID( &uuidObject ),
                           szInsertSz( pAC->name ),
                           szInsertSz( DBGetExtDnFromDnt( pDB, ulValueDnt ) ),
                           NULL, NULL, NULL );
                return;
            }
        }
    }

    // Does the client already have this value?
    if (!fIgnoreWatermarks &&
        !ReplValueIsChangeNeeded(
            usnHighPropUpdateDest,
            pMsgIn->pUpToDateVecDest,
            &valueMetaData )) {

        DPRINT( 3, "Client already has this change, value filtered\n" );

        // Log that value was filtered
        LogEvent8( DS_EVENT_CAT_REPLICATION,
                   DS_EVENT_SEV_EXTENSIVE,
                   DIRLOG_LVR_FILTERED_NOT_NEEDED,
                   szInsertUSN( valueMetaData.MetaData.usnProperty ),
                   szInsertSz( GetExtDN( pDB->pTHS, pDB ) ),
                   szInsertUUID( &uuidObject ),
                   szInsertSz( pAC->name ),
                   szInsertSz( DBGetExtDnFromDnt( pDB, ulValueDnt ) ),
                   szInsertUSN( usnHighPropUpdateDest ),
                   szInsertUSN( usnCursor ),
                   NULL );

        return;
    }

    //
    // Ship it!
    //

    // Allocate/resize output array as needed
    if (*ppValues == NULL) {
        // Never allocated before
        *pcAllocatedValues = 200;
        *ppValues = THAllocEx( pDB->pTHS,
                               (*pcAllocatedValues) * sizeof( REPLVALINF ) );
    } else if ( (*pcNumValues) == (*pcAllocatedValues) ) {
        // Need to grow array
        *pcAllocatedValues *= 2;
        *ppValues = THReAllocEx( pDB->pTHS,
                                 *ppValues,
                                 (*pcAllocatedValues) * sizeof( REPLVALINF ) );
    }

    pReplValInf = &( (*ppValues)[ (*pcNumValues) ] );

    // Populate the REPLVALINF
    // Fill in the object name depending on what the caller wants
    if (dwDirSyncControlFlags & LDAP_DIRSYNC_PUBLIC_DATA_ONLY) {
        // LDAP replication control wants the full name
        // Get its DN, ...
        if ( DBGetAttVal(
            pDB,
            1,
            ATT_OBJ_DIST_NAME,
            DBGETATTVAL_fREALLOC,
            0,
            &cbReturned,
            (LPBYTE *) &( pReplValInf->pObject )
            ) )
        {
            DRA_EXCEPT(DRAERR_DBError, 0);
        }

    } else {
        // Client is another DSA: needs the GUID only
        pReplValInf->pObject = THAllocEx( pDB->pTHS, DSNameSizeFromLen( 0 ) );
        memcpy( &(pReplValInf->pObject->Guid), &uuidObject, sizeof( GUID ) );
        pReplValInf->pObject->structLen = DSNameSizeFromLen( 0 );
    }

    // Check whether containing attribute is readable
    if (dwDirSyncControlFlags & LDAP_DIRSYNC_OBJECT_SECURITY) {
        DWORD       cInAtts;
        ATTCACHE    *rgpAC[1];
        ATTRTYP     classid;
        CLASSCACHE *pCC;
        ULONG ulLen;
        BOOL fFreeSD = FALSE;

        Assert( pReplValInf->pObject->NameLen );  // Need a name

        // Get SD if needed
        if (!pSecurity) {
            if (DBGetAttVal(pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                            0, 0, &ulLen, (PUCHAR *)&pSecurity))
            {
                DRA_EXCEPT(DRAERR_DBError, 0);
            }
            fFreeSD = TRUE;
        }

        // Get the class cache value
        err = DBGetSingleValue(pDB, ATT_OBJECT_CLASS,
                               &classid, sizeof(classid), NULL);
        if (err) {
            DRA_EXCEPT (DRAERR_DBError, err);
        }
        pCC = SCGetClassById(pDB->pTHS, classid);
        if (!pCC) {
            DRA_EXCEPT (DRAERR_DBError, ERROR_DS_OBJECT_CLASS_REQUIRED);
        }

        cInAtts = 1;
        rgpAC[0] = pAC;
    
        CheckReadSecurity(pDB->pTHS,
                          0,
                          pSecurity,
                          pReplValInf->pObject,
                          pCC,
                          NULL,
                          &cInAtts,
                          rgpAC);

        if ( fFreeSD && (pSecurity)) {
            THFreeEx( pDB->pTHS, pSecurity );
        }

        if (rgpAC[0] == NULL) {
            // Value is not visible
            DPRINT2( 0, "Attribute %s is not visible: value %s not returned.\n",
                     pAC->name,
                     DBGetExtDnFromDnt( pDB, ulValueDnt ) );
            return;
        }
    }


    DPRINT2( 2, "AddAnyValues, Adding guid %s as REPLVALINF[%d]\n",
             DsUuidToStructuredString(&(pReplValInf->pObject->Guid), szUuid),
             *pcNumValues );
    DPRINT1( 2, "Value retrieved: %s\n", DBGetExtDnFromDnt( pDB, ulValueDnt ) );

    pReplValInf->attrTyp = pAC->id;

    // Get the currently positioned value.
    // Since we do the positioning, we don't want the dblayer to do it too.
    // Specify a sequence of zero to indicate it doesn't need to move.
    // pReplValInf->Aval is zero'd already
    err = DBGetNextLinkValEx_AC( pDB,
                                 FALSE /*notfirst*/,
                                 0, // Use currently positioned value
                                 &pAC, // Attribute
                                 0, // Flags
                                 0, // In buff size
                                 &(pReplValInf->Aval.valLen), // pLen
                                 &(pReplValInf->Aval.pVal) // ppVal
        );
    if (err) {
        DRA_EXCEPT (DRAERR_DBError, err);
    }

    DBGetLinkTableDataDel( pDB, &timeDeleted );
    pReplValInf->fIsPresent = (timeDeleted == 0);

    // Convert to external form
    pReplValInf->MetaData.timeCreated = valueMetaData.timeCreated;
    pReplValInf->MetaData.MetaData.dwVersion = valueMetaData.MetaData.dwVersion;
    pReplValInf->MetaData.MetaData.timeChanged = valueMetaData.MetaData.timeChanged;
    pReplValInf->MetaData.MetaData.uuidDsaOriginating =
        valueMetaData.MetaData.uuidDsaOriginating;
    pReplValInf->MetaData.MetaData.usnOriginating = valueMetaData.MetaData.usnOriginating;

    // Update count and continuation ref.
    (*pcNumValues)++;

    //TODO: Add counter for linked values
    PERFINC(pcDRAPropShipped);

    if ((NULL != hEncoding) && (NULL != pcbTotalOutSize)) {
        // Update byte count of return message.
        *pcbTotalOutSize += REPLVALINF_AlignSize(hEncoding, pReplValInf );
    }

    LogEvent8( DS_EVENT_CAT_REPLICATION,
               DS_EVENT_SEV_EXTENSIVE,
               DIRLOG_LVR_SHIPPED,
               szInsertUSN( valueMetaData.MetaData.usnProperty ),
               szInsertSz( GetExtDN( pDB->pTHS, pDB ) ),
               szInsertUUID( &uuidObject ),
               szInsertSz( pAC->name ),
               szInsertSz( DBGetExtDnFromDnt( pDB, ulValueDnt ) ),
               szInsertUSN( usnHighPropUpdateDest ),
               szInsertUSN( usnCursor ),
               NULL );

} /* AddAnyValuesToOutputList */

extern CRITICAL_SECTION csRidFsmo;
BOOL                    gfRidFsmoLocked = FALSE;
DWORD                   gdwRidFsmoLockHolderThreadId;

// Acquire the RID FSMO lock for a given domain or return an
// appropriate WIN32 error code.  Needs improvement to handle
// multiple domains per DC.

// N.B. The reason we spin/wait rather than block on the critical
// section is that cross domain move must hold the lock while going
// off machine.  A spin/wait algorithm insures that no one is
// blocked forever as can happen with remoted RPC calls.

ULONG
AcquireRidFsmoLock(
    DSNAME  *pDomainDN,
    int     msToWait)
{
    ULONG   retVal = 1;
    int     waitInterval = 0;

    Assert(NameMatched(pDomainDN, gAnchor.pDomainDN));

    do {
        EnterCriticalSection(&csRidFsmo);

        if ( waitInterval < 500 ) {
            // Wait 50 ms longer each time so that initial latency is low.
            waitInterval += 50;
        }

        if ( !gfRidFsmoLocked ) {
            retVal = 0;
            gdwRidFsmoLockHolderThreadId = GetCurrentThreadId();
            gfRidFsmoLocked = TRUE;
            LeaveCriticalSection(&csRidFsmo);
            break;
        }

        LeaveCriticalSection(&csRidFsmo);
        Sleep((waitInterval < msToWait) ? waitInterval : msToWait);
        msToWait -= waitInterval;
    }
    while ( msToWait > 0 );

    return(retVal);
}

// Release the RID FSMO lock for a given domain.  Needs improvement to
// handle multiple domains per DC.

VOID
ReleaseRidFsmoLock(
    DSNAME *pDomainDN)
{
    BOOL    fLockHeldByMe;

    Assert(NameMatched(pDomainDN, gAnchor.pDomainDN));
    EnterCriticalSection(&csRidFsmo);
    fLockHeldByMe = IsRidFsmoLockHeldByMe();
    gfRidFsmoLocked = FALSE;
    LeaveCriticalSection(&csRidFsmo);
    Assert(fLockHeldByMe);
}

BOOL
IsRidFsmoLockHeldByMe()
{
    BOOL    fRetVal;

    EnterCriticalSection(&csRidFsmo);
    fRetVal = (    gfRidFsmoLocked
                && (GetCurrentThreadId() == gdwRidFsmoLockHolderThreadId) );
    LeaveCriticalSection(&csRidFsmo);
    return(fRetVal);
}

ULONG
GetProxyObjects(
    DSNAME      *pDomainDN,
    HANDLE      hList,
    USN_VECTOR  *pusnvecFrom)
/*++
  Routine Description:

    Adds to hlist all the proxy objects which move with the RID FSMO.
    We prevent two replicas of a domain from moving their respective
    copies of an object to two different domains concurrently by:

        1) A RID FSMO lock is held while performing the move - specifically
           while transitioning from a real object to a phantom.

        2) All proxy objects are created in the infrastructure container.
           This makes them easy to find for step (3).

        3) All proxy objects move with the RID FSMO.  Since the destination
           of the FSMO transfer must apply all the changes that came with the
           FSMO before claiming FSMO ownership, it will end up phantomizing
           any object which has already been moved of the prior FSMO role
           owner.  Thus there is no local object to move anymore and the
           problem is prevented.  See logic in ProcessProxyObject in ..\dra
           for how we deal with objects that are moved out and then back
           in to the same domain.

    This routine finds the proxy objects which need to move.

  Arguments:

    pDomainDN - DSNAME of domain whose objects we need to ship.

    hList - HANDLE for FSMOlist which will hold the object names.

    pusnvecFrom - Pointer to the destination's USN_VECTOR with respect to us.

  Return Value:

    0 on success, !0 otherwise.
    May throw exceptions.
--*/
{
    THSTATE     *pTHS = pTHStls;
    FSMOlist    *pList = (FSMOlist *) hList;
    ATTRTYP     objClass = CLASS_INFRASTRUCTURE_UPDATE;
    FILTER      andFilter, classFilter, proxyFilter, usnFilter;
    SEARCHARG   searchArg;
    SEARCHRES   searchRes;
    ENTINFSEL   selection;
    ENTINFLIST  *pEntInfList;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(NameMatched(pDomainDN, gAnchor.pDomainDN));  // product 1 assert.

    memset(&searchArg, 0, sizeof(searchArg));
    memset(&searchRes, 0, sizeof(searchRes));
    memset(&selection, 0, sizeof(selection));

    memset(&andFilter, 0, sizeof (andFilter));
    memset(&classFilter, 0, sizeof (classFilter));
    memset(&proxyFilter, 0, sizeof (proxyFilter));
    memset(&usnFilter, 0, sizeof (usnFilter));

    // We note that proxy objects do not become visible until they have been
    // both created and deleted.  In addition, proxy objects are the only
    // CLASS_INFRASTRUCTURE_UPDATE objects with ATT_PROXIED_OBJECT_NAME
    // properties.  Thus, we can quickly get the list of objects the
    // destination needs by searching:

    //  - under the infrastructure container
    //  - match on object category
    //  - existence of a proxy value
    //  - usn changed > than destination's usnHighObjUpdate


    // class filter
    // Can't use object category as that is stripped on delete.  Efficiency
    // not an issue as we'll use the PDNT index due to SE_CHOICE_IMMED_CHLDRN.
    classFilter.pNextFilter = NULL;
    classFilter.choice = FILTER_CHOICE_ITEM;
    classFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    classFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    classFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(objClass);
    classFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *) &objClass;

    // existence of proxy value filter
    proxyFilter.pNextFilter = &classFilter;
    proxyFilter.choice = FILTER_CHOICE_ITEM;
    proxyFilter.FilterTypes.Item.choice = FI_CHOICE_PRESENT;
    proxyFilter.FilterTypes.Item.FilTypes.present = ATT_PROXIED_OBJECT_NAME;

    // usn filter
    usnFilter.pNextFilter = &proxyFilter;
    usnFilter.choice = FILTER_CHOICE_ITEM;
    usnFilter.FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
    usnFilter.FilterTypes.Item.FilTypes.ava.type = ATT_USN_CHANGED;
    usnFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                    sizeof(pusnvecFrom->usnHighObjUpdate);
    usnFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                    (UCHAR *) &pusnvecFrom->usnHighObjUpdate;

    // AND filter
    andFilter.pNextFilter = NULL;
    andFilter.choice = FILTER_CHOICE_AND;
    andFilter.FilterTypes.And.count = 3;
    andFilter.FilterTypes.And.pFirstFilter = &usnFilter;

    // selection
    selection.attSel = EN_ATTSET_LIST;
    selection.AttrTypBlock.attrCount = 0;
    selection.AttrTypBlock.pAttr = NULL;
    selection.infoTypes = EN_INFOTYPES_TYPES_ONLY;

    // search arg
    if ( !gAnchor.pInfraStructureDN ) {
        return(1);
    }

    searchArg.pObject = THAllocEx(pTHS, gAnchor.pInfraStructureDN->structLen);
    memcpy(searchArg.pObject,
           gAnchor.pInfraStructureDN,
           gAnchor.pInfraStructureDN->structLen);
    searchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    searchArg.bOneNC = TRUE;
    searchArg.pFilter = &andFilter;
    searchArg.pSelection = &selection;
    InitCommarg(&searchArg.CommArg);
    searchArg.CommArg.Svccntl.makeDeletionsAvail = TRUE;

    SearchBody(pTHS, &searchArg, &searchRes, 0);
    if ( pTHS->errCode ) {
        return(1);
    } else if ( 0 == searchRes.count ) {
        return(0);
    }

    pEntInfList = &searchRes.FirstEntInf;
    while ( pEntInfList )
    {
        FSMORegisterObj(pTHS, hList, pEntInfList->Entinf.pName);
        pEntInfList = pEntInfList->pNextEntInf;
    }

    return(0);
}

ULONG
GetDomainRoleTransferObjects(
    THSTATE     *pTHS,
    HANDLE      hList,
    USN_VECTOR  *pusnvecFrom)
/*++
  Routine Description:

    Adds to hlist all the objects required for Domain role transfer.


  Arguments:

    hList - HANDLE for FSMOlist which will hold the object names.

    pusnvecFrom - Pointer to the destination's USN_VECTOR with respect to us.

  Return Value:

    0 on success, !0 otherwise.
    May throw exceptions.
--*/
{
    FSMOlist    *pList = (FSMOlist *) hList;
    ATTRTYP     objClass = CLASS_INFRASTRUCTURE_UPDATE;
    FILTER      usnFilter;
    SEARCHARG   searchArg;
    SEARCHRES   searchRes;
    ENTINFSEL   selection;
    ENTINFLIST  *pEntInfList;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    memset(&searchArg, 0, sizeof(searchArg));
    memset(&searchRes, 0, sizeof(searchRes));
    memset(&selection, 0, sizeof(selection));

    memset(&usnFilter, 0, sizeof (FILTER));

    // We need to send along all the cross refs, which is basically all
    // the objects immediately under the partitions container.

    // usn filter
    usnFilter.pNextFilter = NULL;
    usnFilter.choice = FILTER_CHOICE_ITEM;
    usnFilter.FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
    usnFilter.FilterTypes.Item.FilTypes.ava.type = ATT_USN_CHANGED;
    usnFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                    sizeof(pusnvecFrom->usnHighObjUpdate);
    usnFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                    (UCHAR *) &pusnvecFrom->usnHighObjUpdate;

    // selection
    selection.attSel = EN_ATTSET_LIST;
    selection.AttrTypBlock.attrCount = 0;
    selection.AttrTypBlock.pAttr = NULL;
    selection.infoTypes = EN_INFOTYPES_TYPES_ONLY;

    searchArg.pObject = THAllocEx(pTHS, gAnchor.pPartitionsDN->structLen);
    memcpy(searchArg.pObject,
           gAnchor.pPartitionsDN,
           gAnchor.pPartitionsDN->structLen);
    searchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    searchArg.bOneNC = TRUE;
    searchArg.pFilter = &usnFilter;
    searchArg.pSelection = &selection;
    InitCommarg(&searchArg.CommArg);

    SearchBody(pTHS, &searchArg, &searchRes, 0);
    if ( pTHS->errCode ) {
        return(1);
    } else if ( 0 == searchRes.count ) {
        return(0);
    }

    pEntInfList = &searchRes.FirstEntInf;
    while ( pEntInfList )
    {
        FSMORegisterObj(pTHS, hList, pEntInfList->Entinf.pName);
        pEntInfList = pEntInfList->pNextEntInf;
    }

    return(0);
}

ULONG
GetInfrastructureRoleTransferObjects(
    THSTATE     *pTHS,
    HANDLE      hList,
    USN_VECTOR  *pusnvecFrom
    )
/*++
  Routine Description:

    Adds to hlist all the objects required for Infrastructure role transfer.

    The idea of this fix (474872) is that we want to make sure container 
    CN=DomainUpdates,CN=System is kept in sync with replication partner 
    when Infrastructure Master Role is transferred.   
    
    Adprep.exe /domainprep will update this container if /domainprep is 
    finished successfully, also adprep.exe /domainprep can only be run on 
    Infrastructure Master DC, This fix will eliminate the possibility of 
    creating potential conflict caused by moving infrastrusture role and 
    run adprep.exe immediately.  However CN=DomainUpdates container may 
    not exist, so we will ignore the SearchBody() failure, only try with 
    best effort.     

  Arguments:

    hList - HANDLE for FSMOlist which will hold the object names.

    pusnvecFrom - Pointer to the destination's USN_VECTOR with respect to us.

  Return Value:

    0 on success, !0 otherwise.
    May throw exceptions.
--*/
{
    FSMOlist    *pList = (FSMOlist *) hList;
    FILTER      usnFilter;
    SEARCHARG   searchArg;
    SEARCHRES   searchRes;
    ENTINFSEL   selection;
    ENTINFLIST  *pEntInfList;
    DSNAME      *pSystemContainerDN = NULL;
    DSNAME      *pDomainUpdatesDN = NULL;
    LONG        ObjectLen = 0;
    BOOL        fDRATemp;
    BOOL        fDSATemp;


    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    memset(&searchArg, 0, sizeof(searchArg));
    memset(&searchRes, 0, sizeof(searchRes));
    memset(&selection, 0, sizeof(selection));

    memset(&usnFilter, 0, sizeof (FILTER));

    // We need to send along all changes under CN=DomainUpdates,CN=System 
    // container

    // usn filter
    usnFilter.pNextFilter = NULL;
    usnFilter.choice = FILTER_CHOICE_ITEM;
    usnFilter.FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
    usnFilter.FilterTypes.Item.FilTypes.ava.type = ATT_USN_CHANGED;
    usnFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                    sizeof(pusnvecFrom->usnHighObjUpdate);
    usnFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                    (UCHAR *) &pusnvecFrom->usnHighObjUpdate;

    // selection
    selection.attSel = EN_ATTSET_LIST;
    selection.AttrTypBlock.attrCount = 0;
    selection.AttrTypBlock.pAttr = NULL;
    selection.infoTypes = EN_INFOTYPES_TYPES_ONLY;

    //
    // Construct CN=DomainUpdates,CN=System,DC=<X> DSNAME based on
    // gAnchor.pDomainDN
    // 
    // call AppendRDN with NULL output buffer in order to calculate length  
    ObjectLen = AppendRDN(gAnchor.pDomainDN,
                          pSystemContainerDN,
                          0,
                          L"System",
                          0,
                          ATT_COMMON_NAME
                          );

    Assert(ObjectLen > 0);
    pSystemContainerDN = THAllocEx(pTHS, ObjectLen);
    AppendRDN(gAnchor.pDomainDN,
              pSystemContainerDN,
              ObjectLen,
              L"System",
              0,
              ATT_COMMON_NAME
              );

    // call AppendRDN with NULL output buffer in order to calculate length  
    ObjectLen = AppendRDN(pSystemContainerDN,
                          pDomainUpdatesDN,
                          0,
                          L"DomainUpdates",
                          0,
                          ATT_COMMON_NAME
                          );

    Assert(ObjectLen > 0);
    pDomainUpdatesDN = THAllocEx(pTHS, ObjectLen);
    AppendRDN(pSystemContainerDN,
              pDomainUpdatesDN,
              ObjectLen,
              L"DomainUpdates",
              0,
              ATT_COMMON_NAME
              );

    searchArg.pObject = pDomainUpdatesDN;
    searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    searchArg.bOneNC = TRUE;
    searchArg.pFilter = &usnFilter;
    searchArg.pSelection = &selection;
    InitCommarg(&searchArg.CommArg);

    _try {

        // 
        // SearchBody will raise exception if fDRA is TRUE and the search 
        // base object is not found. Container cn=domainupdates is NOT always 
        // there, for example, customer may delete it. (though it doesn't 
        // happen often). We need to temporarily unset fDRA.
        // RAID 697557
        // 

        fDRATemp = pTHS->fDRA;
        fDSATemp = pTHS->fDSA;
        pTHS->fDRA = FALSE;
        pTHS->fDSA = TRUE;

        SearchBody(pTHS, &searchArg, &searchRes, 0);

        // ignore the error because the CN=DomainUpdates may not exist
        if ( !pTHS->errCode && 
             (0 != searchRes.count) )
        {
            pEntInfList = &searchRes.FirstEntInf;
            while ( pEntInfList )
            {
                FSMORegisterObj(pTHS, hList, pEntInfList->Entinf.pName);
                pEntInfList = pEntInfList->pNextEntInf;
            }
        }

        // clear error if any
        THClearErrors();

    } _finally {

        pTHS->fDRA = fDRATemp;
        pTHS->fDSA = fDSATemp;

    }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drainfo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       drainfo.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Implements server side of IDL_DRSGetReplInfo() function exported to the DRS
    RPC interface.  Returns various state information pertaining to replication.

DETAILS:

CREATED:

    10/29/98    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                    // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <drs.h>
#include <ntdskcc.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
//#include <ntdsapi.h>

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dstrace.h"

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"
#include <dsutil.h>
#include "drserr.h"
#include "draasync.h"
#include "drautil.h"
#include "drauptod.h"
#include "drarpc.h"
#include "drsuapi.h"                    // Get server call contexts

#include "debug.h"                      /* standard debugging header */
#define DEBSUB "DRAINFO:"               /* define the subsystem for debugging */

#include <fileno.h>
#define  FILENO FILENO_DRAINFO

// Default item limit
// This limit matches a similar limit in ntdsa\ldap\ldapconv.cxx. If this is ever
// made an ldap policy, we should use that policy here as well.
#define DEFAULT_ITEM_PAGE_SIZE 1000
// For old client's that don't support paging
#define RPC_CLIENT_ITEM_PAGE_SIZE (0xffffffff - 0x1)

void dsa_notify(void);

// Replication via ldap includes
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "draConstr.h"

DWORD
draGetReplStruct(IN THSTATE * pTHS,
                 IN ATTRTYP attrId,
                 IN DSNAME * pObjDSName,
                 IN DWORD dwBaseIndex,
                 IN PDWORD pdwNumRequested, OPTIONAL
                 OUT puReplStructArray * ppReplStructArray);
DWORD
draReplStruct2Attr(IN DS_REPL_STRUCT_TYPE structId,
                   IN puReplStruct pReplStruct,
                   IN OUT PDWORD pdwBufferSize,
                   IN PCHAR pBuffer, OPTIONAL
                   OUT ATTRVAL * pAttr);

ULONG
draGetNeighbors(
    IN  THSTATE *             pTHS,
    IN  DBPOS *               pDB,
    IN  ATTRTYP               attrType,
    IN  DSNAME *              pNCarg,                   OPTIONAL
    IN  UUID *                puuidSourceDsaObjGuid,    OPTIONAL
    IN  DWORD                 dwBaseIndex,
    IN  PDWORD                pdwNumRequested,
    OUT DS_REPL_NEIGHBORSW ** ppNeighbors
    );
void
draFreeCursors(
    IN THSTATE *            pTHS,
    IN DS_REPL_INFO_TYPE    InfoType,
    IN void *               pCursors
    );

ULONG
draGetCursors( 
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pNC,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppCursors
    );

UPTODATE_VECTOR *
draGetCursorsPrivate(
    IN THSTATE *            pTHS,
    IN LPWSTR               pszNC
    );

ULONG
draGetObjMetaData(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pObjectDN,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  DWORD               dwInfoFlags,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppObjMetaData
    );

ULONG
draGetAttrValueMetaData(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pObjectDN,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  ATTCACHE *          pAC,
    IN  DSNAME *            pValueDN,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppAttrValueMetaData
    );

ULONG
draGetFailureCache(
    IN  THSTATE *                     pTHS,
    IN  DBPOS *                       pDB,
    IN  DWORD                         InfoType,
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    );

ULONG
draGetClientContexts(
    IN  THSTATE *                   pTHS,
    OUT DS_REPL_CLIENT_CONTEXTS **  ppContexts
    );


DWORD
CheckAttrReadPermissions(
    IN  THSTATE *   pTHS,
    IN  ATTRTYP     attrId,
    IN  PDSNAME     pObjectDN
    )
/*++

    Routine Description:

        Check that the caller is allowed to read this attribute on
        this object.

        Notes: 
         - Does not affect database currency.
         - Does not check that a value of this attribute actually exists
           on the object.
         - Code largely stolen from LocalCompare in mdcomp.c

    Parameters:

        pTHS - thread state
        attrId - attribute to examine
        pObjectDN - object to examine. May not be NULL.

    Return Values:

        ERROR_SUCCESS - read permission granted
        ERROR_DS_DRA_ACCESS_DENIED - read permission denied
        ERROR_INVALID_PARAMETER - unknown attrid
        Other error codes may be returned.

--*/    
{
    DBPOS *                 pDBSaved, *pDBNew=NULL;
    ATTCACHE *              pAC;
    CLASSCACHE *            pCC = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    DSNAME                  TempDN;
    ULONG                   ulLen;
    DWORD                   cInAtts = 1;
    BOOL                    fDRASaved, fSDIsGlobalSDRef;
    DWORD                   dwErr = ERROR_DS_DRA_ACCESS_DENIED;    // fail secure

    Assert( NULL!=pObjectDN );
    memset( &TempDN, 0, sizeof(DSNAME) );

    __try {

        // Save and then turn off fDRA flag because DRA can read anything
        fDRASaved = pTHS->fDRA;
        pTHS->fDRA = FALSE;

        // Open our own dbpos to avoid any side-effects for the caller
        // Install the new dbpos on the thread state for convenience.
        pDBSaved = pTHS->pDB;
        DBOpen( &pDBNew );
        pTHS->pDB = pDBNew;
        
        // Position dbpos on the object
        dwErr = DBFindDSName(pTHS->pDB, pObjectDN);
        if( ERROR_SUCCESS!=dwErr ) {
            __leave;
        }

        // Verify that the attribute type and value exist on this object
        pAC = SCGetAttById(pTHS, attrId);
        if( NULL==pAC ) {
            dwErr = ERROR_INVALID_PARAMETER;
            __leave;
        }

        // Get SD for this object
        dwErr = DBGetObjectSecurityInfo( pTHS->pDB, pTHS->pDB->DNT, &ulLen, &pSD,
            &pCC, &TempDN, NULL, DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
            &fSDIsGlobalSDRef );
        if( ERROR_SUCCESS!=dwErr ) {
            __leave;
        }

        // Finally do the security check.  If the check fails then pAC will
        // be NULL'ed out.
        CheckReadSecurity(pTHS, 0, pSD, &TempDN, pCC, NULL, &cInAtts, &pAC); 
        if( !pAC ) {
            dwErr = ERROR_DS_DRA_ACCESS_DENIED;
        }
        if( pSD && !fSDIsGlobalSDRef ) {
            THFreeEx(pTHS, pSD);
        }

    } __finally {
    
        // Restore original dbpos
        pTHS->pDB = pDBSaved;

        // Close our dbpos if we succeeded in opening it
        if( NULL!=pDBNew ) {
            DBClose(pDBNew, TRUE);
        }

        // Restore fDRA setting
        pTHS->fDRA = fDRASaved;
        
    }

    return dwErr;
}


ATTCACHE *
getAttByNameW(
    IN THSTATE *pTHS,
    IN LPWSTR pszAttributeName
    )

/*++

Routine Description:

    This is a helper function to get an ATTCACHE pointer given a
    Unicode version of the attribute name.

Arguments:

    pTHS -
    pszAttributeName -

Return Value:

    ATTCACHE * -

--*/

{
    LPSTR       paszAttributeName = NULL;
    DWORD       len;
    ATTCACHE    *pAC;

    // Convert Unicode attribute name to Ascii
    paszAttributeName = String8FromUnicodeString(TRUE, CP_UTF8,
                                                 pszAttributeName, -1,
                                                 &len, NULL);
    if (!paszAttributeName) {
        DPRINT( 0, "String8FromUnicodeString failed\n" );
        return NULL;
    }

    pAC = SCGetAttByName( pTHS, (len - 1), paszAttributeName );

    THFreeEx( pTHS, paszAttributeName );

    return pAC;
} /* getAttByNameW */

ULONG
DRS_MSG_GETREPLINFO_REQ_V1_InputValidate(
    DRS_MSG_GETREPLINFO_REQ_V1 * pmsg
    )
/*

typedef struct _DRS_MSG_GETREPLINFO_REQ_V1
    {
    DWORD InfoType;
    [string] LPWSTR pszObjectDN;
    UUID uuidSourceDsaObjGuid;
    } 	DRS_MSG_GETREPLINFO_REQ_V1;

*/
{
    ULONG ret = DRAERR_Success;
    
    ret = LPWSTR_Validate(pmsg->pszObjectDN, TRUE);

    return ret;
}

ULONG
DRS_MSG_GETREPLINFO_REQ_V2_InputValidate(
    DRS_MSG_GETREPLINFO_REQ_V2 * pmsg
    )
/*

typedef struct _DRS_MSG_GETREPLINFO_REQ_V2
    {
    DWORD InfoType;
    [string] LPWSTR pszObjectDN;
    UUID uuidSourceDsaObjGuid;
    DWORD ulFlags;
    [string] LPWSTR pszAttributeName;
    [string] LPWSTR pszValueDN;
    DWORD dwEnumerationContext;
    } 	DRS_MSG_GETREPLINFO_REQ_V2;

*/
{
    ULONG ret = DRAERR_Success;
    
    ret = LPWSTR_Validate(pmsg->pszObjectDN, TRUE);

    if (ret==DRAERR_Success) {
	ret = LPWSTR_Validate(pmsg->pszAttributeName, TRUE);
    }
    if (ret==DRAERR_Success) {
	ret = LPWSTR_Validate(pmsg->pszValueDN, TRUE);
    }

    return ret;
}

ULONG
DRSGetReplInfo_InputValidate(
    DWORD                      dwMsgInVersion,
    DRS_MSG_GETREPLINFO_REQ   *pmsgIn,
    DWORD *                    pdwMsgOutVersion,
    DRS_MSG_GETREPLINFO_REPLY *pmsgOut
    )
/*
    [notify] ULONG IDL_DRSGetReplInfo( 
    [in] DRS_HANDLE hDrs,
    [in] DWORD dwInVersion,
    [switch_is][ref][in] DRS_MSG_GETREPLINFO_REQ *pmsgIn,
    [ref][out] DWORD *pdwOutVersion,
    [switch_is][ref][out] DRS_MSG_GETREPLINFO_REPLY *pmsgOut)
*/
{
    ULONG ret = DRAERR_Success;

    if (ret==DRAERR_Success) {
	if (dwMsgInVersion==1) { 
	    ret = DRS_MSG_GETREPLINFO_REQ_V1_InputValidate(&(pmsgIn->V1));
	} else if (dwMsgInVersion==2) {
	    ret = DRS_MSG_GETREPLINFO_REQ_V2_InputValidate(&(pmsgIn->V2));
	} else { 
	    DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwMsgInVersion);
	}
    }

    return ret;
}

ULONG
IDL_DRSGetReplInfo(
    DRS_HANDLE                    hDrs,
    DWORD                         dwInVersion,
    DRS_MSG_GETREPLINFO_REQ *     pMsgIn,
    DWORD *                       pdwOutVersion,
    DRS_MSG_GETREPLINFO_REPLY *   pMsgOut
    )
/*++

Routine Description:

    Return selected replication state (e.g., replication partners, meta data,
    etc.) to an RPC client.

    This routine can handle either a V1 or a V2 request structure. The V2 is a
    superset of V1.

    ISSUE wlees Sep 22, 2000
    The V2 structure uses an enumeration context to pass the base index on input
    and next/end indicator on output. Internally we use base index/num requested
    to represent this information. Perhaps we need a V3 structure that uses this
    same approach.

Arguments:

    hDrs (IN) - DRS RPC context handle.

    dwInVersion (IN) - Version (union discriminator) of input message.

    pMsgIn (IN) - Input message.  Describes the data desired by the caller.
        See drs.idl for possible inputs.

    pdwOutVersion (OUT) - Version (union discriminator) of output message.

    pMsgOut (OUT) - On successful return holds the requested info.  See drs.idl
        for possible return info.

Return Values:

    0 or Win32 error.

--*/
{
    DRS_CLIENT_CONTEXT * pCtx = (DRS_CLIENT_CONTEXT *) hDrs;
    ULONG       ret = 0;
    THSTATE *   pTHS = pTHStls;
    DSNAME *    pObjectDN = NULL;
    DSNAME *    pAccessCheckDN = NULL;
    UUID *      puuidSourceDsaObjGuid = NULL;
    ATTCACHE *  pAC = NULL;
    DWORD       dwEnumerationContext = 0, dwInfoFlags = 0;
    DSNAME *    pValueDN = NULL;
    DWORD       dwNumRequested = 0;
    DWORD       dwBaseIndex = 0;
    BOOL        fAccessCheckBinaryBlob=FALSE, fAccessGranted=FALSE;
    ATTRTYP     attBinaryBlob = 0;
    PDSNAME     pBinaryBlobDN = NULL;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSGETREPLINFO);
    drsReferenceContext( hDrs );
    INC(pcThread);   // Perfmon hook

    __try {
	*pdwOutVersion = pMsgIn->V1.InfoType;
	memset(pMsgOut, 0, sizeof(*pMsgOut));

	InitDraThread(&pTHS);

	if ((ret = DRSGetReplInfo_InputValidate(dwInVersion, 
						pMsgIn, 
						pdwOutVersion, 
						pMsgOut))!=DRAERR_Success) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    __leave;
	}



	Assert( dwInVersion <= 2);
	// Rely on the fact that the V1 and V2 structures have common fields
	Assert( offsetof(  DRS_MSG_GETREPLINFO_REQ_V1, uuidSourceDsaObjGuid ) ==
		offsetof(  DRS_MSG_GETREPLINFO_REQ_V2, uuidSourceDsaObjGuid ) );
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_EXTENSIVE,
			 DIRLOG_IDL_DRS_GET_REPL_INFO_ENTRY,
			 EVENT_TRACE_TYPE_START,
			 DsGuidDrsGetReplInfo,
			 szInsertUL(pMsgIn->V1.InfoType),
			 pMsgIn->V1.pszObjectDN
			 ? szInsertWC(pMsgIn->V1.pszObjectDN)
			 : szInsertSz(""),
	    szInsertUUID(&pMsgIn->V1.uuidSourceDsaObjGuid),
	    NULL, NULL, NULL, NULL, NULL);

	// ************************************************************************
	// Decode message arguments
	// ************************************************************************

	if (!fNullUuid(&pMsgIn->V1.uuidSourceDsaObjGuid)) {
	    puuidSourceDsaObjGuid = &pMsgIn->V1.uuidSourceDsaObjGuid;
	}

	if (NULL != pMsgIn->V1.pszObjectDN) {
	    if (UserFriendlyNameToDSName(pMsgIn->V1.pszObjectDN,
					 wcslen(pMsgIn->V1.pszObjectDN),
					 &pObjectDN)) {
		ret = ERROR_DS_INVALID_DN_SYNTAX;
		__leave;
	    }
	}

	// Set the page size of an RPC request according to the capability of
	// the caller. We have old clients that don't support paging that
	// won't be able to address items beyond the first page.

	switch (pMsgIn->V1.InfoType) {
	    // These items support paging via the enumeration context
	case DS_REPL_INFO_CURSORS_2_FOR_NC:
	case DS_REPL_INFO_CURSORS_3_FOR_NC:
	case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE:
	case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE:
	    dwNumRequested = DEFAULT_ITEM_PAGE_SIZE;
	    break;
	default:
	    // Default to no paging
	    dwNumRequested = RPC_CLIENT_ITEM_PAGE_SIZE;
	}

	// The following variables will be defaulted for a V1 message:
	// pAC, pValueDn, dwBaseIndex, dwNumRequested, dwInfoFlags

	if (dwInVersion == 2) {
	    // Optional parameter. We check for null pAC below.
	    if (pMsgIn->V2.pszAttributeName) {
		pAC = getAttByNameW( pTHS, pMsgIn->V2.pszAttributeName );
	    }

	    if (NULL != pMsgIn->V2.pszValueDN) {
		if (UserFriendlyNameToDSName(pMsgIn->V2.pszValueDN,
					     wcslen(pMsgIn->V2.pszValueDN),
					     &pValueDN)) {
		    ret = ERROR_DS_INVALID_DN_SYNTAX;
		    __leave;
		}

		// Require pAC be set as well
		if (!pAC) {
		    ret = ERROR_INVALID_PARAMETER;
		    __leave;
		}
	    }

	    dwEnumerationContext = pMsgIn->V2.dwEnumerationContext;
	    if (dwEnumerationContext == 0xffffffff) {
		// This is the signal for end of data. It should not be passed in
		ret = ERROR_NO_MORE_ITEMS;
		__leave;
	    }
	    dwBaseIndex = dwEnumerationContext;
	    dwInfoFlags = pMsgIn->V2.ulFlags;
	    // Range sanity checks are performed in the worker functions
	}

	// ************************************************************************
	// Security check
	// 
	// Some of the info types just return data that is read from a binary-blob
	// attribute. If the caller can read the binary-blob attribute, access is
	// granted.
	// 
	// Note: This code should be kept in sync with the corresponding code in
	// draLdapReplInfoAccessCheck().
	// ************************************************************************

	// What object do we need to check access against?
	switch (pMsgIn->V1.InfoType) {
	case DS_REPL_INFO_NEIGHBORS:
	    pAccessCheckDN = (NULL == pObjectDN) ? gAnchor.pDomainDN
		: pObjectDN;
	    fAccessCheckBinaryBlob = TRUE;
	    attBinaryBlob = ATT_REPS_FROM;
	    pBinaryBlobDN = pAccessCheckDN;
	    break;

	case DS_REPL_INFO_REPSTO:
	    pAccessCheckDN = (NULL == pObjectDN) ? gAnchor.pDomainDN
		: pObjectDN;
	    fAccessCheckBinaryBlob = TRUE;
	    attBinaryBlob = ATT_REPS_TO;
	    pBinaryBlobDN = pAccessCheckDN;
	    break;

	case DS_REPL_INFO_CURSORS_FOR_NC:
	case DS_REPL_INFO_CURSORS_2_FOR_NC:
	case DS_REPL_INFO_CURSORS_3_FOR_NC:
	case DS_REPL_INFO_UPTODATE_VECTOR_V1:
	    if (NULL == pObjectDN) {
		ret = ERROR_INVALID_PARAMETER;
		__leave;
	    }
	    pAccessCheckDN = pObjectDN;
	    fAccessCheckBinaryBlob = TRUE;
	    attBinaryBlob = ATT_REPL_UPTODATE_VECTOR;
	    pBinaryBlobDN = pAccessCheckDN;
	    break;

	case DS_REPL_INFO_METADATA_FOR_OBJ:
	case DS_REPL_INFO_METADATA_2_FOR_OBJ:
	case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE:
	case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE:
	    if (NULL == pObjectDN) {
		ret = ERROR_INVALID_PARAMETER;
		__leave;
	    }
	    fAccessCheckBinaryBlob = TRUE;
	    attBinaryBlob = ATT_REPL_PROPERTY_META_DATA;
	    pBinaryBlobDN = pObjectDN;

	    if (0 == pObjectDN->NameLen) {
		// The name presented is e.g. guid-only, but FindNCParentDSName
		// requires a string name.  Get it.
		ret = ERROR_DS_DRA_BAD_DN;
		BeginDraTransaction(SYNC_READ_ONLY);
		__try {
		    DSNAME * pFullObjectDN;
		    if ((0 == DBFindDSName(pTHS->pDB, pObjectDN))
			&& (pFullObjectDN = GetExtDSName(pTHS->pDB))) {
			THFreeEx(pTHS, pObjectDN);
			pBinaryBlobDN = pObjectDN = pFullObjectDN;
			ret = 0;
		    }
		}
		__finally {
		    EndDraTransaction(TRUE);
		}

		if (0 != ret) {
		    __leave;
		}
	    }

	    pAccessCheckDN = FindNCParentDSName(pObjectDN, FALSE, FALSE);
	    if (NULL == pAccessCheckDN) {
		// We don't have the NC for this object.
		ret = ERROR_DS_DRA_BAD_DN;
		__leave;
	    }
	    break;

	case DS_REPL_INFO_PENDING_OPS:
	case DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES:
	case DS_REPL_INFO_KCC_DSA_LINK_FAILURES:
	case DS_REPL_INFO_CLIENT_CONTEXTS:
	case DS_REPL_INFO_SERVER_OUTGOING_CALLS:
	    pAccessCheckDN = gAnchor.pDomainDN;
	    break;

	default:
	    ret = ERROR_INVALID_PARAMETER;
	    __leave;
	}

	fAccessGranted = FALSE;

	// If the information is available in a binary blob attribute,
	// check for read access on that attribute
	if( fAccessCheckBinaryBlob ) {
	    ret = CheckAttrReadPermissions( pTHS, attBinaryBlob, pBinaryBlobDN );
	    if( ERROR_SUCCESS==ret ) {
		fAccessGranted = TRUE;
	    }                
	}

	if( ! fAccessGranted ) {
	    // Verify the caller has the access required to retrieve this
	    // information.
	    Assert(NULL != pAccessCheckDN);
	    if (NULL == pAccessCheckDN) {
		ret = ERROR_DS_DRA_ACCESS_DENIED;
		__leave;
	    }
	    // Check if the caller is granted either the 'manage' or 'monitor'
	    // control access right on the appropriate object.
	    if(   IsDraAccessGranted(pTHS, pAccessCheckDN,
				     &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)
		  || IsDraAccessGranted(pTHS, pAccessCheckDN,
					&RIGHT_DS_REPL_MONITOR_TOPOLOGY, &ret) )
		{
		fAccessGranted = TRUE;
	    }
	}

	if( ! fAccessGranted ) {
	    ret = ERROR_DS_DRA_ACCESS_DENIED;
	    __leave;
	}

	// ************************************************************************
	// Get the information
	// The code below is not aware of the version of the request
	// ************************************************************************

	// No transaction yet.
	Assert(0 == pTHS->JetCache.transLevel);

	BeginDraTransaction(SYNC_READ_ONLY);

	__try {
	    switch (pMsgIn->V1.InfoType) {
	    case DS_REPL_INFO_NEIGHBORS:
		ret = draGetNeighbors(pTHS,
				      pTHS->pDB,
				      ATT_REPS_FROM,
				      pObjectDN,
				      puuidSourceDsaObjGuid,
				      dwBaseIndex,
				      &dwNumRequested,
				      &pMsgOut->pNeighbors);
		break;

	    case DS_REPL_INFO_REPSTO:
		ret = draGetNeighbors(pTHS,
				      pTHS->pDB,
				      ATT_REPS_TO,
				      pObjectDN,
				      puuidSourceDsaObjGuid,
				      dwBaseIndex,
				      &dwNumRequested,
				      &pMsgOut->pRepsTo);
		break;

	    case DS_REPL_INFO_CURSORS_FOR_NC:
	    case DS_REPL_INFO_CURSORS_2_FOR_NC:
	    case DS_REPL_INFO_CURSORS_3_FOR_NC:
		Assert((void *) &pMsgOut->pCursors == (void *) &pMsgOut->pCursors2);
		Assert((void *) &pMsgOut->pCursors == (void *) &pMsgOut->pCursors3);
		ret = draGetCursors(pTHS,
				    pTHS->pDB,
				    pObjectDN,
				    pMsgIn->V1.InfoType,
				    dwBaseIndex,
				    &dwNumRequested,
				    &pMsgOut->pCursors);
		// Update the enumeration context for the return
		if (!ret) {
		    switch (pMsgIn->V1.InfoType) {
		    case DS_REPL_INFO_CURSORS_FOR_NC:
			// No enumeration context support.
			break;

		    case DS_REPL_INFO_CURSORS_2_FOR_NC:
		    case DS_REPL_INFO_CURSORS_3_FOR_NC:
			Assert((void *) &pMsgOut->pCursors2->dwEnumerationContext
			       == (void *) &pMsgOut->pCursors3->dwEnumerationContext);
			// dwNumRequested is end or the index of the last item returned.
			pMsgOut->pCursors2->dwEnumerationContext = dwNumRequested;
			if (dwNumRequested != 0xffffffff) {
			    // Point to the index of the next item to be returned
			    pMsgOut->pCursors2->dwEnumerationContext++;
			}
			break;

		    default:
			Assert(!"Logic error!");
		    }
		}
		break;

	    case DS_REPL_INFO_UPTODATE_VECTOR_V1:  
		{     
		    UPTODATE_VECTOR * putodVector = NULL;
		    UPTODATE_VECTOR * putodConvert = NULL;   
		    putodVector = draGetCursorsPrivate(pTHS, pMsgIn->V1.pszObjectDN);
		    // convert to version 1 vector
		    pMsgOut->pUpToDateVec = UpToDateVec_Convert(pTHS, 1, putodVector); 
		    THFreeEx(pTHS, putodVector);   
		}
		break;

	    case DS_REPL_INFO_METADATA_FOR_OBJ:
	    case DS_REPL_INFO_METADATA_2_FOR_OBJ:
		ret = draGetObjMetaData(pTHS,
					pTHS->pDB,
					pObjectDN,
					pMsgIn->V1.InfoType,
					dwInfoFlags,
					dwBaseIndex,
					&dwNumRequested,
					&pMsgOut->pObjMetaData);
		break;

	    case DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES:
	    case DS_REPL_INFO_KCC_DSA_LINK_FAILURES:
		Assert(offsetof(DRS_MSG_GETREPLINFO_REPLY, pConnectFailures)
		       == offsetof(DRS_MSG_GETREPLINFO_REPLY, pLinkFailures));
		ret = draGetFailureCache(pTHS,
					 pTHS->pDB,
					 pMsgIn->V1.InfoType,
					 &pMsgOut->pConnectFailures);
		break;

	    case DS_REPL_INFO_PENDING_OPS:
		// IMPORTANT NOTE: This critical section must be held until
		// the queue is marshalled (which doesn't happen until we
		// leave this routine).  IDL_DRSGetReplInfo_notify(), which
		// is called by the RPC stub after marshalling is complete,
		// releases this critsec.
		EnterCriticalSection(&csAOList);

		ret = draGetPendingOps(pTHS, pTHS->pDB, &pMsgOut->pPendingOps);
		break;

	    case DS_REPL_INFO_CLIENT_CONTEXTS:
		ret = draGetClientContexts(pTHS, &pMsgOut->pClientContexts);
		break;

	    case DS_REPL_INFO_SERVER_OUTGOING_CALLS:
		ret = draGetServerOutgoingCalls(pTHS, &pMsgOut->pServerOutgoingCalls);
		break;

	    case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE:
	    case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE:
		if ( pAC && (!(pAC->ulLinkID)) ) {
		    ret = ERROR_DS_WRONG_LINKED_ATT_SYNTAX;
		    __leave;
		}

		Assert((void *) &pMsgOut->pAttrValueMetaData
		       == (void *) &pMsgOut->pAttrValueMetaData2);

		ret = draGetAttrValueMetaData(pTHS,
					      pTHS->pDB,
					      pObjectDN,
					      pMsgIn->V1.InfoType,
					      pAC,
					      pValueDN,
					      dwBaseIndex,
					      &dwNumRequested,
					      &pMsgOut->pAttrValueMetaData);

		// Update the enumeration context for the return
		if (!ret) {
		    Assert((void *) &pMsgOut->pAttrValueMetaData->dwEnumerationContext
			   == (void *) &pMsgOut->pAttrValueMetaData2->dwEnumerationContext);

		    // dwNumRequested is end or the index of the last item returned.
		    pMsgOut->pAttrValueMetaData->dwEnumerationContext = dwNumRequested;
		    if (dwNumRequested != 0xffffffff) {
			// Point to the index of the next item to be returned
			pMsgOut->pAttrValueMetaData->dwEnumerationContext++;
		    }
		}

		break;

	    default:
		Assert(!"Logic error");
		ret = ERROR_INVALID_PARAMETER;
		break;
	    }
	}
	__finally {
	    EndDraTransaction(TRUE);
	}
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
	;
    }

    DEC(pcThread);   // Perfmon hook
    drsDereferenceContext( hDrs );

    // Either we were successful or we're not going to return any data.
    // Note that the pNeighbors is arbitrary -- we return a union of a bunch of
    // pointers -- any and all of them should be NULL in the error case.
    Assert((0 == ret) || (NULL == pMsgOut->pNeighbors));

    if (NULL != pTHS) {
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_EXTENSIVE,
			 DIRLOG_IDL_DRS_GET_REPL_INFO_EXIT,
			 EVENT_TRACE_TYPE_END,
			 DsGuidDrsGetReplInfo,
			 szInsertUL(ret),
			 szInsertWin32Msg(ret),
			 NULL, NULL, NULL,
			 NULL, NULL, NULL);
    }

    return ret;
}


void
IDL_DRSGetReplInfo_notify(void)
/*++

Routine Description:

    Called by RPC after the data returned by IDL_DRSGetReplInfo() has been
    marshalled to clean up any associated resources.

Arguments:

    None.

Return Values:

    None.

--*/
{
    // See DS_REPL_INFO_PENDING_OPS handling in IDL_DRSGetReplInfo().
    if (OWN_CRIT_SEC(csAOList)) {
        LeaveCriticalSection(&csAOList);
    }

    // The usual (free the thread state).
    dsa_notify();
}


VOID
draCheckInputRangeLimits(
    DWORD dwBaseIndex,
    PDWORD pdwNumRequested
    )

/*++

Routine Description:

    Make sure the input limits are correct and consistent

    Since there are three ways that ranges can be generated, we need to assure
    that they are all consistent.  The three input paths are:
    1. RPC call. DRA_DRSGetReplInfo calls worker functions directly.
    2. Non-root atts. DBGetMultipleAtts->dbGetConstructedAtt->draGetLdapReplInfo
    3. RootDSE atts.  LDAP_GetReplDseAtts->draGetLdapReplInfo

    Each worker routine has to deal with boundry conditions itself:
    1. No items requested: dwNumRequested == 0
    2. Base too high: dwBaseIndex > last item available
    3. Limit preceeds boundry: dwBaseIndex + dwNumRequested -1 < last item avail
    3. Limit ends on boundry: dwBaseIndex + dwNumRequested - 1 == last item available
    4. Limit exceeds boundry: dwBaseIndex + dwNumReqested - 1 > last item available

Arguments:

    dwBaseIndex - Starting item. zero-based.
    pdwNumRequested - Count of number of items desired.

Return Value:

    DWORD - 

--*/

{
    // This parameter must be present
    Assert( pdwNumRequested );

    // (*pdwNumRequested == 0) is permitted
    // It means a request for no elements

    // dwBaseIndex == 0xffffffff is permitted
    // It is usually nonsensical since there isn't an element indexed that large

    // (*pdwNumRequested == 0xffffffff) is permitted
    // It means the largest page size possible, effectively none

    // See if range wraps around
    if ( (0xffffffff - *pdwNumRequested) < dwBaseIndex) {
        // Adjust num requested to fit
        *pdwNumRequested = 0xffffffff - dwBaseIndex;
    }

} /* draCheckInputRangeLimits */

DWORD
draRangeSupportUpperIndex(IN DWORD dwAvailable,
                          IN DWORD dwBaseIndex,
                          IN DWORD dwNumRequested)
/*++
Routine Description:

  Algorithm to calculate the return value for the pdwNumRequested passed into range aware
  draGetXXX functions.

  How do I calculate dwBaseIndex and dwNumRequested?
    These values are passed into the draGetXXX functions and should simply be shuttled here.

  How do I calculate dwAvailable if I call an enumeration function?
    Call the enumeration function until it fails or if it returned one more
    than the last requested index (dwBaseIndex + dwNumReqested - 1).

Arguments:

  dwAvailable - number of avaliable items
  dwBaseIndex - base index of first item to be returned
  dwNumRequested - max number of requested items

Return Values:

  A DWORD which should be placed into *pdwNumRequested.
  The value of the DWORD is:
    1. 0xFFFFFFFF if the last index the user requested was equal to or beyond the
       last index of the last item avaliable.
    2. The last index the user requested otherwise.
--*/
{
    DWORD ALL = 0xFFFFFFFF;
    DWORD dwRetUpperIndex;
    DWORD dwReqUpperIndex = dwBaseIndex + dwNumRequested - 1;
    DWORD dwActualUpperIndex = dwAvailable - 1;

    DPRINT3(1, "dwAvail %d, dwBaseIndex %d, dwNumReq %d\n",
        dwAvailable, dwBaseIndex, dwNumRequested);

    // If none were requested, all have been returned
    if (dwNumRequested == 0) {
        dwRetUpperIndex = ALL;
    }

    // If all are requested OR none are avaliable THEN everything has been returned
    else if (ALL == dwNumRequested || 0 == dwAvailable) {
        dwRetUpperIndex = ALL;
    }

    else if (dwReqUpperIndex < dwActualUpperIndex) {
        dwRetUpperIndex = dwReqUpperIndex;
    }

    else {
        Assert(dwReqUpperIndex >= dwActualUpperIndex);
        dwRetUpperIndex = ALL;
    }

    DPRINT1(1, "dwRetUpperIndex %d\n", dwRetUpperIndex);

    return dwRetUpperIndex;
}


DWORD
draLdapReplInfoAccessCheck(
    IN THSTATE *    pTHS,
    IN ATTRTYP      attrId,
    IN DSNAME *     pObjectDN
    )
/*++

    Routine Description:

        Perform an access check for the constructed attribute given by attrId
        on the object given by pObjectDN.

        A summary of the checks is as follows:
            If attribute is a root DSE attribute
               Check for control access right on domain NC head
            Else
               Check for read permissions on the binary-blob attribute
                that corresponds to the constructed attribute.
               Check for control access right on the appropriate object.
            End

        Note: This code should be kept in sync with the corresponding logic in
        IDL_DRSGetReplInfo().

    Parameters:

        pTHS - Thread state
        attrId - Attribute ID of the constructed attribute.
        pObjectDN - Object DN of the object on which to check access rights.

    Return Values:

        ERROR_SUCCESS - Access Granted
        ERROR_DS_DRA_ACCESS_DENIED - Access Denied
        ERROR_DS_DRA_BAD_DN - We don't have the NC for this DN
        ERROR_INVALID_PARAMETER - Bad parameter
        Other error codes may be returned

--*/
{
    PDSNAME     pAccessCheckDN = NULL;
    DWORD       dwErr = ERROR_SUCCESS;
    ATTRTYP     attBinaryBlob = 0;      // Note: objectClass is 0

    //------------------------------------------------------------------
    // Check function parameters

    // Check that the attrId we were given is known to us as a repl
    // constructed attribute.
    if( !Repl_IsConstructedReplAttr(attrId) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Check that the object DN is consistent with the attrId
    if( Repl_IsRootDseAttr(attrId) ?
        ARGUMENT_PRESENT(pObjectDN) : !ARGUMENT_PRESENT(pObjectDN))
    {
        Assert( !"Mismatch between object and type of attribute" );
        return ERROR_INVALID_PARAMETER;
    }
    //------------------------------------------------------------------

    // For rootDSE attributes, access check is against domain DN
    if( Repl_IsRootDseAttr(attrId) ) {
        
        pAccessCheckDN = gAnchor.pDomainDN;
        
    } else {

        // All non-rootDSE constructed attributes are just a easily-readable
        // representation of data that is stored in a binary-blob attribute.

        // Find the binary blob that corresponds to this constructed attribute.
        switch( attrId ) {
            case ATT_MS_DS_REPL_ATTRIBUTE_META_DATA:
            case ATT_MS_DS_REPL_VALUE_META_DATA:
                attBinaryBlob = ATT_REPL_PROPERTY_META_DATA;
                break;

            case ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS:
                attBinaryBlob = ATT_REPS_FROM;
                break;
                
            case ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS:
                attBinaryBlob = ATT_REPS_TO;
                break;
                
            case ATT_MS_DS_NC_REPL_CURSORS:
                attBinaryBlob = ATT_REPL_UPTODATE_VECTOR;
                break;

            default:
                Assert( !"Invalid attrId in draLdapReplInfoAccessCheck" );
                return ERROR_INVALID_PARAMETER;
        }

        // If the caller can read the binary blob, access is granted.
        dwErr = CheckAttrReadPermissions( pTHS, attBinaryBlob, pObjectDN );
        if( ERROR_SUCCESS==dwErr ) {
            return ERROR_SUCCESS;
        }
        
        // No luck, we will have to check the control access right.

        // First we need to determine on what to check for the right.

        // For metadata attributes, we check on the NC head object.
        if(    attrId==ATT_MS_DS_REPL_ATTRIBUTE_META_DATA
            || attrId==ATT_MS_DS_REPL_VALUE_META_DATA )
        {
            // First verify that the DN has a string name (required by
            // FindNCParentDSName).
            if( 0==pObjectDN->NameLen ) {
                // This shouldn't happen, but if it does we won't allow
                // access.
                Assert( !"DN must have string name here" );
                return ERROR_INVALID_PARAMETER;
            }

            // Find enclosing NC head.
            pAccessCheckDN = FindNCParentDSName(pObjectDN, FALSE, FALSE);
            if( NULL == pAccessCheckDN ) {
                // We don't have the NC for this object.
                return ERROR_DS_DRA_BAD_DN;
            }
        } else {
            // For all other attributes, we check the object itself
            // (which would presumably be an NC head)
            pAccessCheckDN = pObjectDN;
        }
        
    }

    Assert(NULL != pAccessCheckDN);
    if( NULL == pAccessCheckDN ) {
        return ERROR_DS_DRA_ACCESS_DENIED;
    }

    // Check if the caller is granted either the 'manage' or 'monitor'
    // control access right on the appropriate object.
    if(   IsDraAccessGranted(pTHS, pAccessCheckDN,
           &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &dwErr)
       || IsDraAccessGranted(pTHS, pAccessCheckDN,
           &RIGHT_DS_REPL_MONITOR_TOPOLOGY, &dwErr) )
    {
        return ERROR_SUCCESS;
    }
    
    return ERROR_DS_DRA_ACCESS_DENIED;
}


DWORD
draGetLdapReplInfo(IN THSTATE * pTHS,
                   IN ATTRTYP attrId,
                   IN DSNAME * pObjDSName,
                   IN DWORD dwBaseIndex,
                   IN PDWORD pdwNumRequested, OPTIONAL
                   IN BOOL fXML,
                   OUT ATTR * pAttr)
/*++

Routine Description:

  Gets a replication structure and maps that structure into a pAttr.

  The PendingOps structure returned from draGetReplStruct needs to be protected
  by a mutex during the conversion from repl struct to attr. After the conversion
  the PendingOps structure is no longer referanced and so the mutex can be
  safely released.

Security Notes:

  Access is checked here by calling draLdapReplInfoAccessCheck().

Arguments:

  pTHS - Thread state so we can allocate thread memory
  attrId - the type of attribute requested
  pObjDSName - the CN of the object the attribute is associated with. NULL for root DSE.
  dwBaseIndex - the index to start retreiving values from
  pdwNumRequested - NULL or -1 for all or the number requested. Can not request 0 elements.
  pAttr - the internal data strucutre which hold the results of requests
  
  fXML - return the results as an XML blob

Return Values:

  0 - success
  DB_ERR_NO_VALUE - if the array is zero length or if access is denied

--*/{
    puReplStructArray pReplStructArray;
    DS_REPL_STRUCT_TYPE structId;
    DWORD err, dwBufferSize;
    PCHAR pBuffer;

    // Check parameters
    Assert(ARGUMENT_PRESENT(pTHS) &&  ARGUMENT_PRESENT(pAttr));
    
    // Security Check: Is the caller authorized to read these attributes?
    err = draLdapReplInfoAccessCheck( pTHS, attrId, pObjDSName );
    if( ERROR_SUCCESS!=err ) {
        return DB_ERR_NO_VALUE;
    }

    structId = Repl_Attr2StructTyp(attrId);

    __try {
        if (ROOT_DSE_MS_DS_REPL_PENDING_OPS == attrId ||
            ROOT_DSE_MS_DS_REPL_QUEUE_STATISTICS == attrId)
        {
            DPRINT(1, " Entering critical section \n");
            EnterCriticalSection(&csAOList);
        }

        // Get the structure  
        err = draGetReplStruct(pTHS, attrId, pObjDSName, dwBaseIndex, pdwNumRequested, &pReplStructArray);
        if (err) {
            __leave;
        }
        DPRINT1(1, " draGetLdapReplInfo, %d values returned \n",
            Repl_GetArrayLength(structId, pReplStructArray));

        // Discover how much memory is needed to wrap the structure in the attribute structure
        err = Repl_StructArray2Attr(structId, pReplStructArray, &dwBufferSize, NULL, pAttr);
        if (err) {
            __leave;
        }

        // Memory must have been requested for the head of the struct array
        Assert(dwBufferSize);
        pBuffer = (PCHAR)THAllocEx(pTHS, dwBufferSize);

        err = Repl_StructArray2Attr(structId, pReplStructArray, &dwBufferSize, pBuffer, pAttr);
        if (err) {
            __leave;
        }

        if (fXML) {
            uReplStruct replStruct;
            DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);
            PWSTR szXML;
            DWORD dwXMLLen;
            ATTRVAL *pValue;
            DWORD   count;

            for (count=0; count < pAttr->AttrVal.valCount; count++) {
                
                pValue = &pAttr->AttrVal.pAVal[count];

                err = Repl_DeMarshalValue(structId, (PCHAR)pValue->pVal, pValue->valLen, (PCHAR)&replStruct);
                if (err)
                {
                    DPRINT1(0, " Repl_DeMarshalValue failed with %x \n", err);
                    __leave;
                }

                err = Repl_MarshalXml(&replStruct, attrId, NULL, &dwXMLLen);
                if (err)
                {
                    DPRINT1(0, " Repl_MarshalXml alloc failed with %x \n", err);
                    __leave;
                }

                szXML = (PWSTR)THAllocEx(pTHS, dwXMLLen);
                err = Repl_MarshalXml(&replStruct, attrId, szXML, &dwXMLLen);
                if (err)
                {
                    DPRINT1(0, " Repl_MarshalXml failed with %x \n", err);
                    __leave;
                }

                pValue->pVal = (PUCHAR)szXML;
                pValue->valLen = dwXMLLen;
            }
        }

    } __finally {
        if (OWN_CRIT_SEC(csAOList)) {
            DPRINT(1, " Leaving critical section \n");
            LeaveCriticalSection(&csAOList);
        }
    }

    DPRINT1(1, " Done with draGetLdapReplInfo with code %x \n", err);
    return err;
}

/*++
Routine Description:

  Retrieves the replication structure returned by a draGetXXX function. DraGetXXX
  functions are passed the given pTHS, pObjDSName, dwBaseIndex and pdwNumRequested
  parameters. Other draGetXXX parameters are set to NULL or zero.

  -- pTHS->pDB issues --
  The draGetXXX functions where designed under the assumption that they would
  only be called from RPC and hence the pDB pointer would only be used once.
  However LDAP allows multiple attribute value pairs to be returned from a call
  at once hence each call to draGetXXX needs its own pDB.

  How do I add a different type of replication structure to this function?

    It's recommended to add a case statement that simply calls draGetNewStruct and does
    no other processing. The newDraGet function should allocate any memory it needs. Use
    draRangeSupportUpperIndex() to calculate dwNumRequested.

Arguments:

  pTHS - thread state used to allocate memory for the blobs and garbage collect
  pTHS->pDB - see note above
  attrId - the type of replication information requested
  pObjDSName - Object which owns the attribute
  dwBaseIndex - the index to start gathering data

  pdwNumRequested - the max number of values to return this call. Use 0xFFFFFFFF to
    indicate all values should be returned. If NULL or if the number requested wrap
    around when added to dwBaseIndex, then a temp variable with a value of
    0xFFFFFFFF is passed to the draGetXXX functions so those functions don't have to
    bother checking for those corner cases.

  ppReplStructArray - returned repl structure.

Return Values:

  pdwNumRequested
    number of values in the multivalue - If there are more values available to be returned
    0xFFFFFFF - if all available values were returned

  0 - success
  ERROR_INTERNAL_DB_ERROR if DBOpen2 returns a null DB pointer
  DB_ERR_NO_VALUE - if the array is zero length
  Any errors generated by draGetXXX

--*/
DWORD
draGetReplStruct(IN THSTATE * pTHS,
                 IN ATTRTYP attrId,
                 IN DSNAME * pObjDSName, OPTIONAL
                 IN DWORD dwBaseIndex,
                 IN PDWORD pdwNumRequested, OPTIONAL
                 OUT puReplStructArray * ppReplStructArray)
{
    puReplStructArray pReplStructArray = NULL;
    DWORD err;
    GUID guidZero = { 0 };
    DWORD dwNumRequested;
    DBPOS * pDB = NULL;

    Assert(ARGUMENT_PRESENT(ppReplStructArray) &&
           ARGUMENT_PRESENT(pTHS));
    *ppReplStructArray = NULL;

    DPRINT(1, "In draGetReplStruct \n");
    if (!pdwNumRequested)
    {
        // No range specified
        dwNumRequested = DEFAULT_ITEM_PAGE_SIZE;
    } else {
        dwNumRequested = *pdwNumRequested;
    }

    draCheckInputRangeLimits( dwBaseIndex, &dwNumRequested );

    DBOpen2(pTHS->pDB ? FALSE : TRUE, &pDB);

    if (!pDB)
    {
        DPRINT(1, "Failed to create a new data base pointer \n");
        return ERROR_INTERNAL_DB_ERROR;
    }

    __try {
        switch (attrId)
        {
        case ROOT_DSE_MS_DS_REPL_ALL_INBOUND_NEIGHBORS:
            err = draGetNeighbors(pTHS, pDB, ATT_REPS_FROM, NULL, NULL,
                dwBaseIndex, &dwNumRequested, &(DS_REPL_NEIGHBORSW *)pReplStructArray);
            break;

        case ROOT_DSE_MS_DS_REPL_ALL_OUTBOUND_NEIGHBORS:
            err = draGetNeighbors(pTHS, pDB, ATT_REPS_TO, NULL, NULL,
                dwBaseIndex, &dwNumRequested, &(DS_REPL_NEIGHBORSW *)pReplStructArray);
            break;

        case ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS:
            pObjDSName->Guid = guidZero;
            err = draGetNeighbors(pTHS, pDB, ATT_REPS_FROM, pObjDSName, NULL,
                dwBaseIndex, &dwNumRequested, &(DS_REPL_NEIGHBORSW *)pReplStructArray);
            break;

        case ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS:
            pObjDSName->Guid = guidZero;
            err = draGetNeighbors(pTHS, pDB, ATT_REPS_TO, pObjDSName, NULL,
                dwBaseIndex, &dwNumRequested, &(DS_REPL_NEIGHBORSW *)pReplStructArray);
            break;

        case ATT_MS_DS_NC_REPL_CURSORS:
            err = draGetCursors(pTHS,
                                pDB,
                                pObjDSName,
                                DS_REPL_INFO_CURSORS_3_FOR_NC,
                                dwBaseIndex,
                                &dwNumRequested,
                                &pReplStructArray);
            break;

        case ATT_MS_DS_REPL_ATTRIBUTE_META_DATA:
            err = draGetObjMetaData(pTHS,
                                    pDB,
                                    pObjDSName,
                                    DS_REPL_INFO_METADATA_2_FOR_OBJ,
                                    0,
                                    dwBaseIndex,
                                    &dwNumRequested,
                                    &pReplStructArray);
            break;

        case ATT_MS_DS_REPL_VALUE_META_DATA:
            err = draGetAttrValueMetaData(pTHS,
                                          pDB,
                                          pObjDSName,
                                          DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE,
                                          NULL,
                                          NULL,
                                          dwBaseIndex,
                                          &dwNumRequested,
                                          &pReplStructArray);
            if (ERROR_NO_MORE_ITEMS == err) {
                err = DB_ERR_NO_VALUE;
                goto exit;
            }
            break;

            // Root Dse attributes are not passed range information
            // ISSUE wlees Oct 11, 2000  Return range information for these functions
            // 1. Fix the helper routines to use dwBaseIndex and dwNumRequested.
            //    This involves changes to draasync and the kcc. Those routines will
            //    need access to draCheckInputRangeLimits and draRangeUpper
            // 2. Callers of these routines will need to use DsGetReplicaInfo2 or
            //    LDAP attribute ranges in order to page through an extended set
            //    of values.

        case ROOT_DSE_MS_DS_REPL_PENDING_OPS:
            err = draGetPendingOps(pTHS, pDB, &(DS_REPL_PENDING_OPSW *)pReplStructArray);
            if (!err) {
                dwNumRequested = 0xffffffff; // all was returned
            }
            break;

        case ROOT_DSE_MS_DS_REPL_QUEUE_STATISTICS:
            err = draGetQueueStatistics(pTHS, &(DS_REPL_QUEUE_STATISTICSW *)pReplStructArray);
            if (!err) {
                dwNumRequested = 0xffffffff; // all was returned
            }
            break;

        case ROOT_DSE_MS_DS_REPL_LINK_FAILURES:
            err = draGetFailureCache(pTHS, pDB, DS_REPL_INFO_KCC_DSA_LINK_FAILURES, &(DS_REPL_KCC_DSA_FAILURESW *)pReplStructArray);
            if (!err) {
                dwNumRequested = 0xffffffff; // all was returned
            }
            break;

        case ROOT_DSE_MS_DS_REPL_CONNECTION_FAILURES:
            err = draGetFailureCache(pTHS, pDB, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, &(DS_REPL_KCC_DSA_FAILURESW *)pReplStructArray);
            if (!err) {
                dwNumRequested = 0xffffffff; // all was returned
            }
            break;

        default:
            DPRINT1(1, "draGetReplStruct failed with an unrecognized attrid! %d \n", attrId);
            return ERROR_INVALID_PARAMETER; // Error is ture
        }
    } __finally {
        DBClose(pDB, TRUE);
    }

    if (!err) {
        *ppReplStructArray = pReplStructArray;
        if (pdwNumRequested)
        {
            *pdwNumRequested = dwNumRequested;
            DPRINT3(1, " range {%d,%d} elements {%d} \n", dwBaseIndex, *pdwNumRequested,
                    Repl_GetArrayLength(Repl_Attr2StructTyp(attrId), pReplStructArray));
        }
    }

    // If there was an error, or no records were constructed, make it look to the
    // caller as if there was no attribute value.
    if (err || (0 == Repl_GetArrayLength(Repl_Attr2StructTyp(attrId), pReplStructArray)) ) {
        err = DB_ERR_NO_VALUE;
    }

exit:
    if (DB_ERR_NO_VALUE == err) {
        DPRINT(1, "No values returned - DB_ERR_NO_VALUE\n");
    }
    return err;
}


typedef struct _DRA_GUID_TO_NAME_ELEM {
    UUID *      pGuid;
    LPWSTR *    ppszName;
} DRA_GUID_TO_NAME_ELEM;

int __cdecl
draGuidToStringNameElem_Compare(
    IN  const void *  pElem1,
    IN  const void *  pElem2
    )
{
    return memcmp(((DRA_GUID_TO_NAME_ELEM *) pElem1)->pGuid,
                  ((DRA_GUID_TO_NAME_ELEM *) pElem2)->pGuid,
                  sizeof(GUID));
}

void
draXlateGuidsToStringNames(
    IN      DBPOS *     pDB,
    IN      eIndexId    eIndex,
    IN      DWORD       cbGuidOffset,
    IN      DWORD       cbNameOffset,
    IN      DWORD       cbArrayElementSize,
    IN      DWORD       cNumArrayElements,
    IN OUT  void *      pArrayElements
    )
/*++

Routine Description:

    Translates the guids in an array of structures to the string DNs of the
    objects they represent (by filling in an element of the same structure).
    
    Only one lookup per unique guid is performed.
    
    Assigns NULL string DNs for guids that cannot be resolved.

Arguments:

    pDB (IN) - DBPOS to use to perform database lookups.
    
    eIndex (IN) - Index on which to look up the guids.
    
    cbGuidOffset (IN) - Offset from the beginning of the structure of the
        UUID element (to be converted).
        
    cbNameOffset (IN) - Offset from the beginning of the structure of the
        LPWSTR element (to be filled in).
        
    cbArrayElementSize (IN) - Size in bytes of the structure.
    
    cNumArrayElements (IN) - Total number of structures in the array to be
        converted.
        
    pArrayElements (IN/OUT) - Array of structures to update.

Return Values:

    None.  Throws exception on catastrophic error.

--*/
{
    THSTATE *pTHS = pDB->pTHS;
    DRA_GUID_TO_NAME_ELEM *pMap;
    DWORD iElem;
    DB_ERR err;
    LPWSTR pszDN = NULL;
    ULONG ulNameLen;

    Assert(cbGuidOffset + sizeof(GUID) <= cbArrayElementSize);
    Assert(cbNameOffset + sizeof(LPWSTR) <= cbArrayElementSize);

    // Sort the elemnts by guid in a lookaside list.
    pMap = THAllocEx(pTHS, cNumArrayElements * sizeof(DRA_GUID_TO_NAME_ELEM));

    for (iElem = 0; iElem < cNumArrayElements; iElem++) {
        BYTE * pbCurrElem = ((BYTE *) pArrayElements) + (cbArrayElementSize * iElem);
        
        pMap[iElem].pGuid = (GUID *) (pbCurrElem + cbGuidOffset);
        pMap[iElem].ppszName = (LPWSTR *) (pbCurrElem + cbNameOffset);
        
        // Default is NULL, in case we fail utterly below (e.g., can't set index).
        Assert(NULL == *(pMap[iElem].ppszName));
    }
    
    err = DBSetCurrentIndex(pDB, eIndex, NULL, FALSE);
    if (!err) {
        qsort(pMap,
              cNumArrayElements,
              sizeof(*pMap),
              draGuidToStringNameElem_Compare);
    
        // Walk through the guid-sorted list and translate the guids to names.
        for (iElem = 0; iElem < cNumArrayElements; iElem++) {
            if ((iElem > 0)
                && (0 == memcmp(pMap[iElem].pGuid,
                                pMap[iElem-1].pGuid,
                                sizeof(GUID)))) {
                // Has same guid (and thus same name) as last element -- copy it.
                *(pMap[iElem].ppszName) = *(pMap[iElem-1].ppszName);
            } else {
                // Look up this guid in the database.
                DSNAME * pDN = NULL;
                INDEX_VALUE IV;
            
                if (!fNullUuid(pMap[iElem].pGuid)) {
                    IV.pvData = pMap[iElem].pGuid;
                    IV.cbData = sizeof(GUID);
        
                    err = DBSeek(pDB, &IV, 1, DB_SeekEQ);
                    if (!err) {
                        pDN = GetExtDSName(pDB);
                    }
                }
 
		if (pDN) {  
		    //get the value we want out of the DSNAME
		    ulNameLen = wcslen(pDN->StringName);
		    pszDN = THAllocEx(pTHS, (ulNameLen+1)*sizeof(WCHAR));
		    wcscpy(pszDN, pDN->StringName);  
		    *(pMap[iElem].ppszName) = pszDN; 

		    //free the DSNAME
		    THFreeEx(pTHS, pDN);
		}
		else {
		    *(pMap[iElem].ppszName) = NULL;
		}



            }
        }
    }

    THFreeEx(pTHS, pMap);
}


ULONG
draGetNeighbors(
    IN  THSTATE *             pTHS,
    IN  DBPOS *               pDB,
    IN  ATTRTYP               attrType,
    IN  DSNAME *              pNCarg,                   OPTIONAL
    IN  UUID *                puuidSourceDsaObjGuid,    OPTIONAL
    IN  DWORD                 dwBaseIndex,
    IN  PDWORD                pdwNumRequested,
    OUT DS_REPL_NEIGHBORSW ** ppNeighbors
    )
/*++

Routine Description:

    Returns the public form of the inbound replication partners for this DSA.
    Optionally filtered by NC and/or source DSA.

Arguments:

    pTHS (IN)

    attrType (IN) - ATT_REPS_FROM or ATT_REPS_TO.

    pNCarg (IN, OPTIONAL) - The NC for which partners are requested.  NULL
        implies all NCs.

    puuidSourceDsaObjGuid (IN, OPTIONAL) - The source DSA for which replication
        state is desired.  If NULL, returns all sources.

    ppNeighbors (OUT) - On return, the associated sources.

Return Values:

    0 or Win32 error.

--*/
{
    DWORD                   cNCs = 0;
    DWORD                   iNC = 0;
    NAMING_CONTEXT_LIST *   pNCL;
    DSNAME **               ppNCs;
    DSNAME *                pNC;
    DWORD                   cb;
    DWORD                   cNeighborsAlloced;
    DS_REPL_NEIGHBORSW *    pNeighbors;
    DS_REPL_NEIGHBORW *     pNeighbor;
    DWORD                   iNeighbor;
    DWORD                   cbRepsFromAlloced = 0;
    REPLICA_LINK *          pRepsFrom = NULL;
    DWORD                   iRepsFrom;
    DWORD                   iFlag;
    ATTCACHE *              pAC;
    DWORD                   err;
    DWORD                   j;
    DSNAME                  GuidOnlyDSName;
    DSNAME *                pDSName;
    NCL_ENUMERATOR          nclMaster, nclReplica;
    DWORD                   dwcNeighbor;
    DWORD                   dwNumRequested;
    DWORD                   dwNumRet;

    dwNumRequested = *pdwNumRequested;
    draCheckInputRangeLimits( dwBaseIndex, &dwNumRequested );

    dwcNeighbor = 0;
    dwNumRet = dwBaseIndex + dwNumRequested;

    // Should have a transaction before we get here.
    Assert(1 == pTHS->JetCache.transLevel);

    // Determine which NC(s) we're looking at.
    if (NULL != pNCarg) {
        // Explicit NC given.
        ppNCs = &pNCarg;
        cNCs = 1;
    }
    else {
        // Count the NCs hosted by this machine.
        DPRINT(1, "// Count the NCs hosted by this machine.\n");
        cNCs = 0;
        NCLEnumeratorInit(&nclMaster, CATALOG_MASTER_NC);
        NCLEnumeratorInit(&nclReplica, CATALOG_REPLICA_NC);
        while (pNCL = NCLEnumeratorGetNext(&nclMaster)) {
            cNCs++;
        }
        while (pNCL = NCLEnumeratorGetNext(&nclReplica)) {
            cNCs++;
        }

        // Allocate an array for them.
        ppNCs = THAllocEx(pTHS, cNCs * sizeof(DSNAME *));

        // And copy a pointer to each NC name into the array.
        iNC = 0;
        NCLEnumeratorReset(&nclMaster);
        NCLEnumeratorReset(&nclReplica);
        while (pNCL = NCLEnumeratorGetNext(&nclMaster)) {
            Assert(iNC < cNCs);
            ppNCs[iNC++] = pNCL->pNC;
        }
        while (pNCL = NCLEnumeratorGetNext(&nclReplica)) {
            Assert(iNC < cNCs);
            ppNCs[iNC++] = pNCL->pNC;
        }
    }

    cNeighborsAlloced = 20;

    cb = offsetof(DS_REPL_NEIGHBORSW, rgNeighbor);
    cb += sizeof(DS_REPL_NEIGHBORW) * cNeighborsAlloced;
    pNeighbors = THAllocEx(pTHS, cb);

    pAC = SCGetAttById(pTHS, attrType);
    Assert(NULL != pAC);

    for (iNC = 0; iNC < cNCs; iNC++) {
        pNC = ppNCs[iNC];

        if (pNCarg)
            DPRINT1(1, " Searching for NC {%ws}\n", pNCarg->StringName);
        err = DBFindDSName(pDB, pNC);
        if (err) {
            // It's conceivable this could occur due to gAnchor / transaction
            // incoherency, but that seems awfully unlikely.
            DPRINT2(0, "Can't find NC %ls (DSNAME @ %p)!\n",
                    pNC->StringName, pNC);
            LooseAssert(!"Can't find NC", GlobalKnowledgeCommitDelay);
            if (cNCs == 1) {
                DRA_EXCEPT(DRAERR_BadNC, 0);
            } else {
                // Try another...
                continue;
            }
        }

        // Read the repsFrom's.
        iRepsFrom = 0;
        while (!DBGetAttVal_AC(pDB, ++iRepsFrom, pAC, DBGETATTVAL_fREALLOC,
                               cbRepsFromAlloced, &cb,
                               (BYTE **) &pRepsFrom)) {
            cbRepsFromAlloced = max(cbRepsFromAlloced, cb);

            Assert(1 == pRepsFrom->dwVersion);
            Assert(cb == pRepsFrom->V1.cb);

            // potentially fix repsfrom version &  recalc size
            pRepsFrom = FixupRepsFrom(pRepsFrom, &cbRepsFromAlloced);
            Assert(cbRepsFromAlloced >= pRepsFrom->V1.cb);

            if ((NULL != puuidSourceDsaObjGuid)
                && (0 != memcmp(puuidSourceDsaObjGuid,
                                &pRepsFrom->V1.uuidDsaObj,
                                sizeof(GUID)))) {
                // Not interested in this source -- move along.
                continue;
            }

            dwcNeighbor++;
            if (dwcNeighbor - 1 < dwBaseIndex)
            {
                continue;
            }
            if (dwcNeighbor > dwNumRet)
            {
                break;
            }

            if (pNeighbors->cNumNeighbors++ >= cNeighborsAlloced) {
                cNeighborsAlloced *= 2;
                cb = offsetof(DS_REPL_NEIGHBORSW, rgNeighbor);
                cb += sizeof(DS_REPL_NEIGHBORW) * cNeighborsAlloced;
                pNeighbors = THReAllocEx(pTHS, pNeighbors, cb);
            }

            pNeighbor = &pNeighbors->rgNeighbor[pNeighbors->cNumNeighbors - 1];

            pNeighbor->pszNamingContext = pNC->StringName;
            pNeighbor->pszSourceDsaAddress
                = TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepsFrom));
            // pNeighbor->pszSourceDsaDN filled in below
            // pNeighbor->pszAsyncIntersiteTransportDN filled in below

            pNeighbor->uuidNamingContextObjGuid  = pNC->Guid;
            pNeighbor->uuidSourceDsaObjGuid      = pRepsFrom->V1.uuidDsaObj;
            pNeighbor->uuidSourceDsaInvocationID = pRepsFrom->V1.uuidInvocId;
            pNeighbor->uuidAsyncIntersiteTransportObjGuid
                = pRepsFrom->V1.uuidTransportObj;

            pNeighbor->usnLastObjChangeSynced
                = pRepsFrom->V1.usnvec.usnHighObjUpdate;
            pNeighbor->usnAttributeFilter
                = pRepsFrom->V1.usnvec.usnHighPropUpdate;

            DSTimeToFileTime(pRepsFrom->V1.timeLastSuccess,
                             &pNeighbor->ftimeLastSyncSuccess);
            DSTimeToFileTime(pRepsFrom->V1.timeLastAttempt,
                             &pNeighbor->ftimeLastSyncAttempt);

            pNeighbor->dwLastSyncResult = pRepsFrom->V1.ulResultLastAttempt;
            pNeighbor->cNumConsecutiveSyncFailures
                = pRepsFrom->V1.cConsecutiveFailures;

            for (iFlag = 0; RepNbrOptionToDra[iFlag].pwszPublicOption; iFlag++) {
                if (pRepsFrom->V1.ulReplicaFlags &
                    RepNbrOptionToDra[iFlag].InternalOption) {
                    pNeighbor->dwReplicaFlags |= RepNbrOptionToDra[iFlag].PublicOption;
                }
            }
        }
    }

    draXlateGuidsToStringNames(pDB,
                               Idx_ObjectGuid,
                               offsetof(DS_REPL_NEIGHBORW, uuidSourceDsaObjGuid),
                               offsetof(DS_REPL_NEIGHBORW, pszSourceDsaDN),
                               sizeof(DS_REPL_NEIGHBORW),
                               pNeighbors->cNumNeighbors,
                               pNeighbors->rgNeighbor);

    draXlateGuidsToStringNames(pDB,
                               Idx_ObjectGuid,
                               offsetof(DS_REPL_NEIGHBORW, uuidAsyncIntersiteTransportObjGuid),
                               offsetof(DS_REPL_NEIGHBORW, pszAsyncIntersiteTransportDN),
                               sizeof(DS_REPL_NEIGHBORW),
                               pNeighbors->cNumNeighbors,
                               pNeighbors->rgNeighbor);

    if (1 != cNCs) {
        THFreeEx(pTHS, ppNCs);
    }

    if (pNeighbors->cNumNeighbors) {
        DPRINT4(1, " DraGetNeighbors ND, Addr, Trans, Contxt %ws, %ws, %ws, %ws \n",
                pNeighbors->rgNeighbor[0].pszSourceDsaDN,
                pNeighbors->rgNeighbor[0].pszSourceDsaAddress,
                pNeighbors->rgNeighbor[0].pszAsyncIntersiteTransportDN,
                pNeighbors->rgNeighbor[0].pszNamingContext);
    }
    
    *pdwNumRequested = draRangeSupportUpperIndex(dwcNeighbor, dwBaseIndex, dwNumRequested);
    DPRINT5(1, " Neighbors upperBound = %d ni=%d, cn=%d, bi=%d, nr=%d\n",
        *pdwNumRequested, dwcNeighbor, pNeighbors->cNumNeighbors, dwBaseIndex, dwNumRequested);

    *ppNeighbors = pNeighbors;

    return 0;
}

void
draFreeCursors(
    IN THSTATE *            pTHS,
    IN DS_REPL_INFO_TYPE    InfoType,
    IN void *               pCursors
    )
/*++

Routine Description:

    Frees the Cursor memory from the draGetCursors call.

Arguments:

    pTHS (IN)
    
    InfoType (IN) - The cursor type

    pCursors (IN) - the allocated cursor from draGetCursors

Return Values:

    None

--*/
{
    DS_REPL_CURSORS_3W *    pCursors3;
    ULONG i;
    
    Assert((DS_REPL_INFO_CURSORS_FOR_NC == InfoType)
	   || (DS_REPL_INFO_CURSORS_2_FOR_NC == InfoType)
	   || (DS_REPL_INFO_CURSORS_3_FOR_NC == InfoType));

    if (InfoType == DS_REPL_INFO_CURSORS_3_FOR_NC) {
	pCursors3 = (DS_REPL_CURSORS_3W *) pCursors;
	for (i = 0; i < pCursors3->cNumCursors; i++) {
	    THFreeEx(pTHS, pCursors3->rgCursor[i].pszSourceDsaDN); 
	}
    }
    THFreeEx(pTHS, pCursors);
}

UPTODATE_VECTOR *
draGetCursorsPrivate(
    IN THSTATE *            pTHS,
    IN LPWSTR               pszNC
    ) 
/*++

Routine Description:

    Returns the private form of the up-to-date vector for the given NC.

Arguments:

    pTHS (IN)
    
    pszNC - given NC

Return Values:

    UTD vector, caller must free with THAllocEx

--*/
{
	UPTODATE_VECTOR * putodvec = NULL;
	ULONG instanceType = 0;
	DSNAME * pNC;
	DWORD err = 0;

	pNC = DSNameFromStringW(pTHS, pszNC);

	if (err = FindNC(pTHS->pDB, pNC,
			 FIND_MASTER_NC | FIND_REPLICA_NC, &instanceType)) {
	    DRA_EXCEPT_NOLOG(DRAERR_BadNC, err);
	}

	if ((instanceType & IT_NC_COMING) || (instanceType & IT_NC_GOING)) {
	    DRA_EXCEPT_NOLOG(ERROR_DS_DRA_NO_REPLICA, 0);
	}

	THFreeEx(pTHS, pNC);

	UpToDateVec_Read(pTHS->pDB, instanceType, UTODVEC_fUpdateLocalCursor,     
			 DBGetHighestCommittedUSN(), &putodvec);

	return putodvec;
}

ULONG
draGetCursors(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pNC,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppCursors
    )
/*++

Routine Description:

    Returns the public form of the up-to-date vector for the given NC.

Arguments:

    pTHS (IN)

    pNC (IN) - The NC for which the vector is requested.

    ppCursors (OUT) - On return, the associated vector.

Return Values:

    0 or Win32 error.

--*/
{
    UPTODATE_VECTOR *         putodvec;
    DWORD                     cb;
    DWORD                     iCursor;
    void *                    pCursorsToReturn = NULL;
    SYNTAX_INTEGER            it = 0;
    DWORD                     iIndex;
    DWORD                     dwNumRequested;
    DWORD                     dwNumRet;
    UPTODATE_VECTOR_NATIVE *  pNativeUTD;
    DWORD                     cNumCursorsTotal;

    Assert((DS_REPL_INFO_CURSORS_FOR_NC == InfoType)
           || (DS_REPL_INFO_CURSORS_2_FOR_NC == InfoType)
           || (DS_REPL_INFO_CURSORS_3_FOR_NC == InfoType));

    dwNumRequested = *pdwNumRequested;
    draCheckInputRangeLimits( dwBaseIndex, &dwNumRequested );

    // Should have a transaction before we get here.
    Assert(1 == pTHS->JetCache.transLevel);

    DPRINT1(1, " Searching for NC {%ws}\n", pNC->StringName);
    if (FindNC(pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, &it) || (it & IT_NC_GOING)) {
        // The name we were given does not correspond to a fully instantiated NC on
        // this machine.
        return ERROR_DS_DRA_BAD_NC;
    }

    UpToDateVec_Read(pDB, it, UTODVEC_fUpdateLocalCursor,
                     DBGetHighestCommittedUSN(), &putodvec);
    Assert((NULL == putodvec)
           || (UPTODATE_VECTOR_NATIVE_VERSION == putodvec->dwVersion));
    
    pNativeUTD = putodvec ? &putodvec->V2 : NULL;
    cNumCursorsTotal = putodvec ? pNativeUTD->cNumCursors : 0;

    if ((0 == cNumCursorsTotal) || (cNumCursorsTotal <= dwBaseIndex)) {
        dwNumRet = 0;
    } else {
        dwNumRet = min(dwNumRequested, cNumCursorsTotal - dwBaseIndex);
    }

    switch (InfoType) {
    case DS_REPL_INFO_CURSORS_FOR_NC: {
        DS_REPL_CURSORS * pCursors = NULL;
        
        cb = offsetof(DS_REPL_CURSORS, rgCursor);
        cb += sizeof(DS_REPL_CURSOR) * dwNumRet;
    
        pCursors = THAllocEx(pTHS, cb);
        pCursors->cNumCursors = dwNumRet;

        for (iCursor = 0, iIndex = dwBaseIndex; 
             iCursor < dwNumRet; 
             iIndex++, iCursor++) {
            pCursors->rgCursor[iCursor].uuidSourceDsaInvocationID
                = pNativeUTD->rgCursors[iIndex].uuidDsa;
            pCursors->rgCursor[iCursor].usnAttributeFilter
                = pNativeUTD->rgCursors[iIndex].usnHighPropUpdate;
        }

        pCursorsToReturn = pCursors;
        break;
    }

    case DS_REPL_INFO_CURSORS_2_FOR_NC: {
        DS_REPL_CURSORS_2 * pCursors = NULL;
        
        cb = offsetof(DS_REPL_CURSORS_2, rgCursor);
        cb += sizeof(DS_REPL_CURSOR_2) * dwNumRet;
    
        pCursors = THAllocEx(pTHS, cb);
        pCursors->cNumCursors = dwNumRet;

        for (iCursor = 0, iIndex = dwBaseIndex; 
             iCursor < dwNumRet; 
             iIndex++, iCursor++) {
            pCursors->rgCursor[iCursor].uuidSourceDsaInvocationID
                = pNativeUTD->rgCursors[iIndex].uuidDsa;
            pCursors->rgCursor[iCursor].usnAttributeFilter
                = pNativeUTD->rgCursors[iIndex].usnHighPropUpdate;
            DSTimeToFileTime(pNativeUTD->rgCursors[iIndex].timeLastSyncSuccess,
                             &pCursors->rgCursor[iCursor].ftimeLastSyncSuccess);
        }

        pCursorsToReturn = pCursors;
        break;
    }

    case DS_REPL_INFO_CURSORS_3_FOR_NC: {
        DS_REPL_CURSORS_3W * pCursors = NULL;
        
        cb = offsetof(DS_REPL_CURSORS_3W, rgCursor);
        cb += sizeof(DS_REPL_CURSOR_3W) * dwNumRet;
    
        pCursors = THAllocEx(pTHS, cb);
        pCursors->cNumCursors = dwNumRet;

        for (iCursor = 0, iIndex = dwBaseIndex; 
             iCursor < dwNumRet; 
             iIndex++, iCursor++) {
            pCursors->rgCursor[iCursor].uuidSourceDsaInvocationID
                = pNativeUTD->rgCursors[iIndex].uuidDsa;
            pCursors->rgCursor[iCursor].usnAttributeFilter
                = pNativeUTD->rgCursors[iIndex].usnHighPropUpdate;
            DSTimeToFileTime(pNativeUTD->rgCursors[iIndex].timeLastSyncSuccess,
                             &pCursors->rgCursor[iCursor].ftimeLastSyncSuccess);
        }

        draXlateGuidsToStringNames(pDB,
                                   Idx_InvocationId,
                                   offsetof(DS_REPL_CURSOR_3W, uuidSourceDsaInvocationID),
                                   offsetof(DS_REPL_CURSOR_3W, pszSourceDsaDN),
                                   sizeof(DS_REPL_CURSOR_3W),
                                   pCursors->cNumCursors,
                                   pCursors->rgCursor);
        
        pCursorsToReturn = pCursors;
        break;
    }

    default:
        Assert(!"Logic error!");
    }


    *pdwNumRequested = draRangeSupportUpperIndex(cNumCursorsTotal, dwBaseIndex, dwNumRequested);

    DPRINT4(1, " Cursors bi=%d nr=%d ub=%d nc=%d\n",
            dwBaseIndex, dwNumRequested, *pdwNumRequested, cNumCursorsTotal);

    if (NULL != putodvec) {
        THFreeEx(pTHS, putodvec);
    }

    *ppCursors = pCursorsToReturn;

    return 0;
}


ULONG
draGetObjMetaData(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pObjectDN,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  DWORD               dwInfoFlags,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppObjMetaData
    )
/*++

Routine Description:

    Returns the public form of the object meta data vector for the given object.

Arguments:

    pTHS (IN)

    pObjectDN (IN) - The object for which meta data is requested.

    dwInfoFlags (IN) - Behavior modifiers

    ppObjMetaData (OUT) - On return, the associated meta data.

Return Values:

    0 or Win32 error.

--*/
{
    DWORD                       err;
    DWORD                       cb;
    PROPERTY_META_DATA_VECTOR * pMetaDataVec;
    ATTCACHE *                  pAC;
    PROPERTY_META_DATA *        pIntMetaData;
    DWORD                       i;
    DWORD                       j;
    void *                      pObjMetaDataToReturn = NULL;
    DWORD                       dwNumRequested, dwUpperBound;

    Assert((DS_REPL_INFO_METADATA_FOR_OBJ == InfoType)
           || (DS_REPL_INFO_METADATA_2_FOR_OBJ == InfoType));

    dwNumRequested = *pdwNumRequested;
    draCheckInputRangeLimits( dwBaseIndex, &dwNumRequested );

    // Find the object.
    err = DBFindDSName(pDB, pObjectDN);
    if (err) {
        return err;
    }

    // Get its meta data.
    err = DBGetAttVal(pDB,
                      1,
                      ATT_REPL_PROPERTY_META_DATA,
                      0,
                      0,
                      &cb,
                      (BYTE **) &pMetaDataVec);
    if (err) {
        DPRINT3(0, "Error %d reading meta data for %ls!\n",
                err, pObjectDN->StringName, pObjectDN);
        return ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
    }

    Assert(1 == pMetaDataVec->dwVersion);
    Assert(cb == MetaDataVecV1Size(pMetaDataVec));

    if (dwInfoFlags & DS_REPL_INFO_FLAG_IMPROVE_LINKED_ATTRS) {
        DBImproveAttrMetaDataFromLinkMetaData(
            pDB,
            &pMetaDataVec,
            &cb
            );
    }

    switch (InfoType) {
    case DS_REPL_INFO_METADATA_FOR_OBJ: {
        DS_REPL_OBJ_META_DATA * pObjMetaData;
        DS_REPL_ATTR_META_DATA * pExtMetaData;
        
        cb = offsetof(DS_REPL_OBJ_META_DATA, rgMetaData);
        cb += sizeof(DS_REPL_ATTR_META_DATA) * pMetaDataVec->V1.cNumProps;
    
        pObjMetaData = THAllocEx(pTHS, cb);
    
        pIntMetaData = &pMetaDataVec->V1.rgMetaData[0];
        pExtMetaData = &pObjMetaData->rgMetaData[0];
        pObjMetaData->cNumEntries = 0;
    
        // Convert meta data into its public form.
        // dwBaseIndex is passed in by the user. If the value is too large, the loop test
        // will fail, and no data will be returned. pIntMetaData is not valid until
        // dwBaseIndex is validated.

        pIntMetaData += dwBaseIndex;
        dwUpperBound = min(pMetaDataVec->V1.cNumProps, dwBaseIndex + dwNumRequested);
        for (i = dwBaseIndex; i < dwUpperBound; i++, pIntMetaData++) {
            pAC = SCGetAttById(pTHS, pIntMetaData->attrType);
            if (NULL == pAC) {
                DPRINT1(0, "Can't find ATTCACHE for attid 0x%x!\n",
                        pIntMetaData->attrType);
                continue;
            }
    
            pExtMetaData->pszAttributeName
                = UnicodeStringFromString8(CP_UTF8, pAC->name, -1);
            pExtMetaData->dwVersion = pIntMetaData->dwVersion;
            DSTimeToFileTime(pIntMetaData->timeChanged,
                             &pExtMetaData->ftimeLastOriginatingChange);
            pExtMetaData->uuidLastOriginatingDsaInvocationID
                = pIntMetaData->uuidDsaOriginating;
            pExtMetaData->usnOriginatingChange = pIntMetaData->usnOriginating;
            pExtMetaData->usnLocalChange = pIntMetaData->usnProperty;
    
            pObjMetaData->cNumEntries++;
            pExtMetaData++;
        }

        pObjMetaDataToReturn = pObjMetaData;
        break;
    }

    case DS_REPL_INFO_METADATA_2_FOR_OBJ: {
        DS_REPL_OBJ_META_DATA_2 * pObjMetaData;
        DS_REPL_ATTR_META_DATA_2 * pExtMetaData;
        
        cb = offsetof(DS_REPL_OBJ_META_DATA_2, rgMetaData);
        cb += sizeof(DS_REPL_ATTR_META_DATA_2) * pMetaDataVec->V1.cNumProps;
    
        pObjMetaData = THAllocEx(pTHS, cb);
    
        pIntMetaData = &pMetaDataVec->V1.rgMetaData[0];
        pExtMetaData = &pObjMetaData->rgMetaData[0];
        pObjMetaData->cNumEntries = 0;
    
        // Convert meta data into its public form.
        // dwBaseIndex is passed in by the user. If the value is too large, the loop test
        // will fail, and no data will be returned. pIntMetaData is not valid until
        // dwBaseIndex is validated.

        pIntMetaData += dwBaseIndex;
        dwUpperBound = min(pMetaDataVec->V1.cNumProps, dwBaseIndex + dwNumRequested);
        for (i = dwBaseIndex; i < dwUpperBound; i++, pIntMetaData++) {
            pAC = SCGetAttById(pTHS, pIntMetaData->attrType);
            if (NULL == pAC) {
                DPRINT1(0, "Can't find ATTCACHE for attid 0x%x!\n",
                        pIntMetaData->attrType);
                continue;
            }
    
            pExtMetaData->pszAttributeName
                = UnicodeStringFromString8(CP_UTF8, pAC->name, -1);
            pExtMetaData->dwVersion = pIntMetaData->dwVersion;
            DSTimeToFileTime(pIntMetaData->timeChanged,
                             &pExtMetaData->ftimeLastOriginatingChange);
            pExtMetaData->uuidLastOriginatingDsaInvocationID
                = pIntMetaData->uuidDsaOriginating;
            pExtMetaData->usnOriginatingChange = pIntMetaData->usnOriginating;
            pExtMetaData->usnLocalChange = pIntMetaData->usnProperty;
    
            pObjMetaData->cNumEntries++;
            pExtMetaData++;
        }
        
        // Translate invocationIDs to DSA DNs where possible.
        draXlateGuidsToStringNames(pDB,
                                   Idx_InvocationId,
                                   offsetof(DS_REPL_ATTR_META_DATA_2, uuidLastOriginatingDsaInvocationID),
                                   offsetof(DS_REPL_ATTR_META_DATA_2, pszLastOriginatingDsaDN),
                                   sizeof(DS_REPL_ATTR_META_DATA_2),
                                   pObjMetaData->cNumEntries,
                                   pObjMetaData->rgMetaData);
        
        pObjMetaDataToReturn = pObjMetaData;
        break;
    }

    default:
        Assert(!"Logic error!");
    }

    *pdwNumRequested = draRangeSupportUpperIndex(pMetaDataVec->V1.cNumProps, dwBaseIndex, dwNumRequested);

    *ppObjMetaData = pObjMetaDataToReturn;

    return 0;
}


ULONG
draGetAttrValueMetaData(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pObjectDN,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  ATTCACHE *          pAC,
    IN  DSNAME *            pValueDN,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppAttrValueMetaData
    )
/*++

Routine Description:

    Returns the public form of the attribute value meta data
    for the given object and attribute.

    The attribute range information is communicated through the dwEnumContext
    parameter.

    On input, dwEnumContext contains the starting index. The starting
    index is always 0-based.

    dwNumRequested contains the page size on input.
    It cannot be zero. It may be 0xfffffff to indicate the user wants all.
    On output, it is adjusted to indicate whether all were returned, or
    the last index that the user requested.

    On output, dwEnumContext is updated to contain the base index of the
    next item to return next time.

Arguments:

    pTHS (IN)

    pObjectDN (IN) - The object for which meta data is requested.

    pAC (IN) - Attribute cache entry for the desired attribute

    dwBaseIndex (IN) - Positional context

    ppAttrValueMetaData (OUT) - On return, the associated meta data.

Return Values:

    0 or Win32 error.

--*/
{
    DWORD err, cb, cbValLen, cNumEntries = 0, pageSize;
    UCHAR *pVal = NULL;
    void *pAttrValueMetaDataToReturn = NULL;
    DSTIME timeDeleted;
    VALUE_META_DATA valueMetaData;
    ATTCACHE *pACValue;
    DWORD dwNumRequested, dwUpperIndex;

    Assert((DS_REPL_INFO_METADATA_FOR_ATTR_VALUE == InfoType)
           || (DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE == InfoType));

    dwNumRequested = *pdwNumRequested;
    draCheckInputRangeLimits( dwBaseIndex, &dwNumRequested );
    // This is the largest page size we support
    // This check can be removed if we go to an incremental memory
    // allocation model in this routine.
    if (dwNumRequested > DEFAULT_ITEM_PAGE_SIZE) {
        dwNumRequested = DEFAULT_ITEM_PAGE_SIZE;
    }
    // If requesting a single value, only return one
    // ISSUE: I will observe that this provision for returning a single value does
    // not provide for the specification of DSNAME-BINARY values, nor does it provide
    // for returning all DSNAME-BINARY values matching a particular dsname.
    if (pValueDN) {
        dwNumRequested = 1;
    }
    pageSize = dwNumRequested;

    DPRINT2(1, "draGetAttrValue base/#req = %d:%d\n", dwBaseIndex, dwNumRequested);

    // Find the object.
    err = DBFindDSName(pDB, pObjectDN);
    if (err) {
        DPRINT1(1, "DBFindDSName returned unexpected db error %d\n", err );
        return err;
    }

    // if pValueDn is set, pAC must be also
    Assert( !pValueDN || pAC );



    // We allocate this early so that we have a structure to return
    // Comment on memory allocation strategy. We allocate a maximal sized structure
    // up front. This will not all be used if the number of items available
    // is less than the page size. Perhaps we should grow the structure
    // incrementally.

    switch (InfoType) {
    case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE:
        cb = offsetof(DS_REPL_ATTR_VALUE_META_DATA, rgMetaData);
        cb += sizeof(DS_REPL_VALUE_META_DATA) * pageSize;
        break;

    case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE:
        cb = offsetof(DS_REPL_ATTR_VALUE_META_DATA_2, rgMetaData);
        cb += sizeof(DS_REPL_VALUE_META_DATA_2) * pageSize;
        break;

    default:
        Assert(!"Logic error");
    }

    pAttrValueMetaDataToReturn = THAllocEx(pTHS, cb);

    // Position on the initial value. When requesting a single value, it will
    // be the only value returned.
    if (dwNumRequested == 0) {
        // No results required
        goto return_results;
    } else if ( (pValueDN) &&
         (pAC->syntax == SYNTAX_DISTNAME_TYPE) ) {
        DWORD fPresent;

        // The valueDN can only express a SYNTAX_DISTNAME_TYPE. It does not
        // express the external form of a SYNTAX_DISTNAME_BINARY type.

        // We know what the value is. Position on it.
        cbValLen = pValueDN->structLen;
        pVal = (UCHAR *) pValueDN;
        err = DBFindAttLinkVal_AC( pDB, pAC, cbValLen, pVal, &fPresent );
        pACValue = pAC;
    } else {
        pACValue = pAC;
        // Position on first value and return it.
        // Sequence is 1 based
        err = DBGetNextLinkValEx_AC (
            pDB, TRUE /*first*/, (dwBaseIndex + 1), &pACValue,
            DBGETATTVAL_fINCLUDE_ABSENT_VALUES,
            0, &cbValLen, &pVal );
    }
    if ( (err == DB_ERR_NO_VALUE) ||
         (err == DB_ERR_VALUE_DOESNT_EXIST) ) {
        // No results returned
        goto return_results;
    } else if (err) {
        // Have DB_ERR, need WIN32
        DPRINT1( 0, "DBGetAttrVal_AC returned unexpected db error %d\n", err );
        return ERROR_DS_DATABASE_ERROR;
    }

    do {
        LPWSTR pszAttributeName;
        DSNAME * pObjectDN = NULL;
        DWORD cbData = 0;
        BYTE * pbData = NULL;

        Assert( pACValue );
        
        // Attribute name
        pszAttributeName = UnicodeStringFromString8(CP_UTF8, pACValue->name, -1);

        // Object name
        switch (pACValue->syntax) {
        case SYNTAX_DISTNAME_TYPE:
            pObjectDN = (DSNAME *) pVal;
            cbData = 0;
            pbData = NULL;
            break;
        case SYNTAX_DISTNAME_BINARY_TYPE:
        case SYNTAX_DISTNAME_STRING_TYPE:
        {
            struct _SYNTAX_DISTNAME_DATA *pDD =
                (struct _SYNTAX_DISTNAME_DATA *) pVal;
            SYNTAX_ADDRESS *pSA = DATAPTR( pDD );

            pObjectDN = NAMEPTR( pDD );
            cbData = PAYLOAD_LEN_FROM_STRUCTLEN( pSA->structLen );
            pbData = pSA->byteVal;
            break;
        }
        default:
            Assert( FALSE );
        }

        DBGetLinkValueMetaData( pDB, pACValue, &valueMetaData );
        
        // timeDeleted is set to zero if not present
        DBGetLinkTableDataDel( pDB, &timeDeleted );

        // Convert to external form.
        switch (InfoType) {
        case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE: {
            DS_REPL_ATTR_VALUE_META_DATA *pAttrValueMetaData = pAttrValueMetaDataToReturn;
            DS_REPL_VALUE_META_DATA *pValueMetaData
                = &(pAttrValueMetaData->rgMetaData[pAttrValueMetaData->cNumEntries]);
            
            pValueMetaData->pszAttributeName = pszAttributeName;
            pValueMetaData->pszObjectDn = pObjectDN->StringName;
            pValueMetaData->cbData = cbData;
            pValueMetaData->pbData = pbData;

            DSTimeToFileTime( valueMetaData.timeCreated,
                              &(pValueMetaData->ftimeCreated) );
            pValueMetaData->dwVersion = valueMetaData.MetaData.dwVersion;
            DSTimeToFileTime( valueMetaData.MetaData.timeChanged,
                              &(pValueMetaData->ftimeLastOriginatingChange) );
            pValueMetaData->uuidLastOriginatingDsaInvocationID =
                valueMetaData.MetaData.uuidDsaOriginating;
            pValueMetaData->usnOriginatingChange =
                valueMetaData.MetaData.usnOriginating;
            pValueMetaData->usnLocalChange =
                valueMetaData.MetaData.usnProperty;
    
            DSTimeToFileTime( timeDeleted, &(pValueMetaData->ftimeDeleted) );
    
            cNumEntries = ++(pAttrValueMetaData->cNumEntries);
            break;
        }

        case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE: {
            DS_REPL_ATTR_VALUE_META_DATA_2 *pAttrValueMetaData = pAttrValueMetaDataToReturn;
            DS_REPL_VALUE_META_DATA_2 *pValueMetaData
                = &(pAttrValueMetaData->rgMetaData[pAttrValueMetaData->cNumEntries]);
            
            pValueMetaData->pszAttributeName = pszAttributeName;
            pValueMetaData->pszObjectDn = pObjectDN->StringName;
            pValueMetaData->cbData = cbData;
            pValueMetaData->pbData = pbData;

            DSTimeToFileTime( valueMetaData.timeCreated,
                              &(pValueMetaData->ftimeCreated) );
            pValueMetaData->dwVersion = valueMetaData.MetaData.dwVersion;
            DSTimeToFileTime( valueMetaData.MetaData.timeChanged,
                              &(pValueMetaData->ftimeLastOriginatingChange) );
            pValueMetaData->uuidLastOriginatingDsaInvocationID =
                valueMetaData.MetaData.uuidDsaOriginating;
            pValueMetaData->usnOriginatingChange =
                valueMetaData.MetaData.usnOriginating;
            pValueMetaData->usnLocalChange =
                valueMetaData.MetaData.usnProperty;
    
            DSTimeToFileTime( timeDeleted, &(pValueMetaData->ftimeDeleted) );
            
            cNumEntries = ++(pAttrValueMetaData->cNumEntries);
            break;
        }

        default:
            Assert(!"Logic error");
        }

        // Get next relative value.
        cbValLen = 0;  // Value has been given away - alloc another
        pVal = NULL;
        pACValue = pAC;
        err = DBGetNextLinkValEx_AC (
            pDB, FALSE /*notfirst*/, 1, &pACValue,
            DBGETATTVAL_fINCLUDE_ABSENT_VALUES,
            0, &cbValLen, &pVal );
    
    } while (!err && (cNumEntries < pageSize));

    if (!err) {
        // We have read all the entries we can and have confirmed that more
        // entries still remain. We increment cNumEntries here because it represents
        // the number of items we know exist and are available. This quantity is used
        // below in the upper range calculation.
        cNumEntries++;
        Assert(cNumEntries == pageSize + 1);
        DPRINT(1, "More available\n");
    } else {
        DPRINT(1, "No more available\n");
        // No more values
        // DB_ERR_NO_VALUE is the normal expected result
        // Otherwise, if we got some other error, we just close the page
        // and hope things start working again when he asks again.
    }

    if (DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE == InfoType) {
        // Translate invocationIDs to DSA DNs where possible.
        draXlateGuidsToStringNames(pDB,
                                   Idx_InvocationId,
                                   offsetof(DS_REPL_VALUE_META_DATA_2, uuidLastOriginatingDsaInvocationID),
                                   offsetof(DS_REPL_VALUE_META_DATA_2, pszLastOriginatingDsaDN),
                                   sizeof(DS_REPL_VALUE_META_DATA_2),
                                   ((DS_REPL_ATTR_VALUE_META_DATA_2 *) pAttrValueMetaDataToReturn)->cNumEntries,
                                   ((DS_REPL_ATTR_VALUE_META_DATA_2 *) pAttrValueMetaDataToReturn)->rgMetaData);
    }

return_results:

    *pdwNumRequested = draRangeSupportUpperIndex(cNumEntries + dwBaseIndex, dwBaseIndex, dwNumRequested);

    DPRINT1(1, "draGetAttrValue numEntries = %d\n", cNumEntries);
    DPRINT1(1, "draGetAttrValue upper index = %d\n", *pdwNumRequested);

    *ppAttrValueMetaData = pAttrValueMetaDataToReturn;

    return 0;
}


ULONG
draGetFailureCache(
    IN  THSTATE *                     pTHS,
    IN  DBPOS *                       pDB,
    IN  DWORD                         InfoType,
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    )
/*++

Routine Description:

    Returns the public form of the requested KCC failure cache.

Arguments:

    pTHS (IN)

    InfoType (IN) - Identifies the cache to return -- either
        DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES or
        DS_REPL_INFO_KCC_DSA_LINK_FAILURES.

    ppFailures (OUT) - On successful return, holds the contents of the cache.

Return Values:

    Win32 error code.

--*/
{
    DS_REPL_KCC_DSA_FAILURESW * pFailures;
    DS_REPL_KCC_DSA_FAILUREW *  pFailure;
    DWORD                       iFailure;
    DWORD                       err;
    DSNAME                      GuidOnlyDSName;
    DSNAME *                    pDSName;

    // Ask the KCC for a copy of the appropriate failure cache.  The KCC will
    // fill in all fields other than the string DNs.
    err = KccGetFailureCache(InfoType, &pFailures);
    if (err) {
        return err;
    }

    Assert(NULL != pFailures);

    // Now look up the objectGuids amd fill in the string DNs.
    GuidOnlyDSName.structLen = DSNameSizeFromLen(0);
    GuidOnlyDSName.NameLen = 0;
    GuidOnlyDSName.SidLen = 0;

    pFailure = &pFailures->rgDsaFailure[0];
    for (iFailure = 0;
         iFailure < pFailures->cNumEntries;
         iFailure++, pFailure++) {
        // Convert DSA object guid to string name.
        Assert(NULL == pFailure->pszDsaDN);
        Assert(!fNullUuid(&pFailure->uuidDsaObjGuid));

        GuidOnlyDSName.Guid = pFailure->uuidDsaObjGuid;

        err = DBFindDSName(pDB, &GuidOnlyDSName);
        if (0 == err) {
            // Resolved this object guid -- get the associated string name.
            pDSName = GetExtDSName(pDB);
            pFailure->pszDsaDN = pDSName->StringName;
        }
    }

    *ppFailures = pFailures;

    return 0;
}


ULONG
draGetClientContexts(
    IN  THSTATE *                   pTHS,
    OUT DS_REPL_CLIENT_CONTEXTS **  ppContexts
    )
/*++

Routine Description:

    Returns a list of all outstanding client contexts, sorted by ascending
    last used time.  (I.e., most recently used contexts are at the end of the
    list.)

Arguments:

    pTHS (IN)

    ppContexts (OUT) - On successful return, holds the client context list.

Return Values:

    Win32 error code.

--*/
{
    DS_REPL_CLIENT_CONTEXTS *   pContexts;
    DS_REPL_CLIENT_CONTEXT  *   pContext;
    DRS_CLIENT_CONTEXT *        pCtx;
    DWORD                       cb;
    DWORD                       iCtx;

    EnterCriticalSection(&gcsDrsuapiClientCtxList);
    __try {
        if (!gfDrsuapiClientCtxListInitialized) {
            InitializeListHead(&gDrsuapiClientCtxList);
            Assert(0 == gcNumDrsuapiClientCtxEntries);
            gfDrsuapiClientCtxListInitialized = TRUE;
        }

        cb = offsetof(DS_REPL_CLIENT_CONTEXTS, rgContext)
             + sizeof(DS_REPL_CLIENT_CONTEXT) * gcNumDrsuapiClientCtxEntries;

        pContexts = THAllocEx(pTHS, cb);

        pCtx = (DRS_CLIENT_CONTEXT *) gDrsuapiClientCtxList.Flink;
        for (iCtx = 0; iCtx < gcNumDrsuapiClientCtxEntries; iCtx++) {
            pContext = &pContexts->rgContext[iCtx];

            pContext->hCtx            = (ULONGLONG) pCtx;
            pContext->lReferenceCount = pCtx->lReferenceCount;
            pContext->fIsBound        = TRUE;
            pContext->uuidClient      = pCtx->uuidDsa;
            pContext->IPAddr          = pCtx->IPAddr;
            pContext->timeLastUsed    = pCtx->timeLastUsed;
            pContext->pid             = ((DRS_EXTENSIONS_INT *) &pCtx->extRemote)->pid;

            pCtx = (DRS_CLIENT_CONTEXT *) pCtx->ListEntry.Flink;
        }

        Assert(pCtx == (DRS_CLIENT_CONTEXT *) &gDrsuapiClientCtxList);
        pContexts->cNumContexts = gcNumDrsuapiClientCtxEntries;
    }
    __finally {
        LeaveCriticalSection(&gcsDrsuapiClientCtxList);
    }

    *ppContexts = pContexts;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drainit.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drainit.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

This module contains the task queue functions which accomplish initial sync, delayed
gc promotion, as well as initial syncs.

There are four task queue functions ("threads") in this module:

CheckSyncProgress - Starts inital syncs.  Also reexecuted periodically to check that
the syncs are making progress.  When the syncs finish, drancrep.c calls us back
at InitSyncAttemptComplete().

CheckFullSyncProgress - Checks whether the primary domain has completed atleast
one successful sync since installation.  This routine calls DsaSetIsSynchronized
when this criteria is met. This routine is called by InitSyncAttemptComplete when
all the writeable init syncs have completed.

CheckGCPromotionProgress - Checks whether all readonly domains are present, and if
present, whether they have completed atleast one successful sync since installation.
This routine calls UpdateAnchorFromDsaOptions when this criteria is met.  This
routine is called from InitSyncAttemptComplete when all readonly init syncs have
completed.

SynchronizeReplica - Looks at the master and readonly ncs hosted by this server
to see if there are any that need to be periodicaly synced.  If any are found,
a synchronization is started for each of them.

Here is the calling hierarchy:
InitDraTasks()
    call AddInitSyncList for each writeable partition
    InsertInTaskQueue( SynchronizeReplica )
    CheckSyncProgress( TRUE ) // start syncs

InitSyncAttemptComplete() - called when a sync completes in success or error
    Mark (nc, source) pair as complete
    If success or last source, mark nc as complete
    If all writeable ncs complete, call CheckFullSyncProgress()
    If all readonly ncs complete, call UpdateAnchorFromDsaOptionsDelayed( TRUE )
    If all ncs complete, call CheckInitSyncsFinished()

These are the requirements for advertising the DC in general by calling
DsaSetIsSynchronized():
1. Initial syncs of all writable ncs complete.  For each nc, a success must be
achieved or all sources must be tried.  This may involving waiting for multiple
runs of CheckSyncProgress to restart new syncs.
2. CheckFullSyncProgress has run, and has found the primary domain to have synced
atleast once.
3. DsaSetIsSynchronized is called.

These are the requirements for advertising the DC as a GC by calling
UpdateAnchorFromDsaOptions():
1. Initial syncs of all readonly ncs complete.  For each nc, a success must be
achieved or all sources must be tried.  This may involving waiting for multiple
runs of CheckSyncProgress to restart new syncs.
2. UpdateAnchorFromDsaOptionsDelayed is called.  If GC promotion is requested,
CheckGCPromotionProgress() is called.
3. CheckGCPromotionProgress runs and checks whether all readonly ncs are present
and have synced atleast once.  If any have not, we reschedule to try again later.
Once all have met the criteria, we call the real UpdateAnchorFromDsaOptions() to
complete the GC promotion.

Additional commentary on UpdateAnchorFromDsaOptionsDelayed() can be found in
mdinidsa.c

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// SAM headers
#include <samsrvp.h>                    /* for SampInvalidateRidRange() */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include "dstaskq.h"
#include "dsconfig.h"
#include <dsutil.h>
#include <winsock.h>                    /* htonl, ntohl */
#include <filtypes.h>                   // For filter construction
#include <windns.h>

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAINIT:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dramail.h"
#include "dsaapi.h"
#include "usn.h"
#include "drauptod.h"
#include "draasync.h"
#include "drameta.h"
#include "drauptod.h"

#include <fileno.h>
#define  FILENO FILENO_DRAINIT

// Periodic sync defines

#define INIT_PS_ENTRIES 10
#define PS_ENTRIES_INC 10

#define FIFTEEN_MINUTES (15 * 60)

#define SCHEDULE_LEN ((4*24*7)/8)

// Pause before we try and sync mail replicas, to let MTA start

#define MAIL_DELAY_SECS 300     // 5 minutes

#define ENQUEUE_INIT_SYNC_DELAY_SECS 30     // 30 seconds

#define MAX_GC_PROMOTION_ATTEMPTS       5

extern HANDLE hevDRASetup;

// Head of NC sync data list

NCSYNCDATA *gpNCSDFirst = NULL;

// Count of NCs that have not been synced since startup
ULONG gulNCUnsynced = 0;
// Count of writable ncs unsynced
ULONG gulNCUnsyncedWrite = 0;
// Count of readable ncs unsynced
ULONG gulNCUnsyncedReadOnly = 0;

// Initial syncs finished.  This indicates both writable and readonly
// partitions have been checked.  For most requirements, we only need
// to know that the writable ones have been checked, and use
// gfIsSynchronized instead.
BOOL gfInitSyncsFinished = FALSE;

ULONG gMailReceiveTid = 0;

CRITICAL_SECTION csNCSyncData;

// Time at which we last checked for periodic syncs we might need to perform.
DSTIME gtimeLastPeriodicSync = 0;

// The way we know if we got through the promotion process once
BOOL gfWasPreviouslyPromotedGC = FALSE;

// To Track GC State
CRITICAL_SECTION csGCState;

// Vector of attributes of ntdsDSA objects that dictate what NCs we hold.
const struct {
    ATTRTYP AttrType;
    ULONG   ulFindNCFlags;
} gAtypeCheck[] = {
    {ATT_MS_DS_HAS_MASTER_NCS,    FIND_MASTER_NC},
    {ATT_HAS_PARTIAL_REPLICA_NCS, FIND_REPLICA_NC}
};



// Function prototypes

BOOL fIsBetweenTime(REPLTIMES *, DSTIME, DSTIME);
void DelayedMailStart(void *pv, void **ppvNext,
                      DWORD *pcSecsUntilNextIteration);
NCSYNCDATA * GetNCSyncData (DSNAME *pNC);
void
CheckFullSyncProgress(
    IN  void *  pv,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    );
void
CheckGCPromotionProgress(
    IN  void *  pvParam,
    OUT void ** ppvParamNextIteration,
    OUT DWORD * pcSecsUntilNextIteration
    );







void
CheckSyncProgress(
    IN  void *  pv,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )

/*++

Routine Description:

?? DO WE REALLY NEED THIS ??
WLEES 9-APR-99. Is this really useful?
This is necessary to start the initial syncs.  But what good does it do
to requeue sync's that have not finished yet?
Sync's that fail and are retriable, are retried in drasync.c
My guess is that this is to catch sync's that complete without calling
us back at SyncAttemptComplete. In this case, we kick them off again.

This routine runs on a replicated server after reboot or install
until admin updates have been enabled.

Run the first time directlty to sync the replicas, and then runs
from the timer thread to ensure that we are making progress on syncing
the replicas.

It may queue syncs that already exist in the queue, but this will
have a minimal performance impact.

This routine also checks to see if updates should be enabled. We use this
functionality to defer setting updates enabled prematurely when we
restart a replicated server.

Arguments:

    pv -
    ppvNext -
    pcSecsUntilNextIteration -

Return Value:

    None

--*/

{
    ULONG i, ulRet = 0;
    ULONG sourcenum;
    NCSYNCDATA *pNCSDTemp;
    NCSYNCSOURCE *pNcSyncSource;
    BOOL fReplicaFound = TRUE;
    BOOL fSync = FALSE;
    BOOL fProgress = FALSE;

    // If we are passed sync up indication, try and sync each NC\source.
    // Otherwise we queue syuncs only if we're not making progress.
    fSync = (BOOL)(pv != NULL);

    EnterCriticalSection(&csNCSyncData);

    __try {
        __try {
            // If init syncs have finished, we're done, else check
            if (!gfInitSyncsFinished) {

                if (!fSync) {
                    // Not told to sync explicitly, see if we are making progress.

                    // For each NC, see if we have any more synced sources
                    // than last time. If any have, we're getting there

                    for (pNCSDTemp = gpNCSDFirst; pNCSDTemp;
                         pNCSDTemp = pNCSDTemp->pNCSDNext) {
                        if (pNCSDTemp->ulTriedSrcs > pNCSDTemp->ulLastTriedSrcs) {
                            pNCSDTemp->ulLastTriedSrcs = pNCSDTemp->ulTriedSrcs;
                            fProgress = TRUE;
                        }
                        LogEvent(DS_EVENT_CAT_REPLICATION,
                                 DS_EVENT_SEV_BASIC,
                                 fProgress ? DIRLOG_ADUPD_SYNC_PROGRESS : DIRLOG_ADUPD_SYNC_NO_PROGRESS,
                                 szInsertDN((&(pNCSDTemp->NC))),
                                 NULL,
                                 NULL);
                    }
                    // Force sync of unsynced NC sources if we're making no progress.

                    if (!fProgress) {
                        fSync = TRUE;
                    }
                } // if (!Sync ) ...

                // If we were told to sync or have no progress, queue syncs.

                if (fSync) {
                    // Sync each NC from one source, then each NC from the next source, etc.

                    for (sourcenum=0; fReplicaFound; sourcenum++) {

                        // are we being signalled to shutdown?
                        if (eServiceShutdown) {
                            DRA_EXCEPT(DRAERR_Shutdown, 0);
                        }

                        // Set no ith replica found yet.
                        fReplicaFound = FALSE;
                        for (pNCSDTemp = gpNCSDFirst; pNCSDTemp ;
                             pNCSDTemp = pNCSDTemp->pNCSDNext) {
                            // Only queue sync if NC is not already synced from one source
                            if (!(pNCSDTemp->fNCComplete)) {
                                for (pNcSyncSource = pNCSDTemp->pFirstSource, i=0;
                                     pNcSyncSource && (i < sourcenum);
                                     pNcSyncSource = pNcSyncSource->pNextSource, i++) {
                                }
                                // If we have an ith source, sync it.
                                if (pNcSyncSource) {

                                    // Found ith replica of at least one NC.
                                    fReplicaFound = TRUE;

                                    // Sync source by name.
                                    if (fSync) {
                                        ULONG ulSyncFlags =
                                            (pNCSDTemp->ulReplicaFlags &
                                             AO_PRIORITY_FLAGS) |
                                            DRS_ASYNC_OP |
                                            DRS_SYNC_BYNAME |
                                            DRS_INIT_SYNC_NOW;
                                        if (NULL == ppvNext) {
                                            // Set no discard flag only on first attempt
                                            ulSyncFlags |= DRS_NO_DISCARD;
                                        }

                                        ulRet = DirReplicaSynchronize (
                                            (DSNAME*)&(pNCSDTemp->NC),
                                            pNcSyncSource->szDSA,
                                            NULL,
                                            ulSyncFlags );
                                        // If we failed to enqueue, it means the nc or the source
                                        // has gone away since the list was built.
                                        if (ulRet) {
                                            InitSyncAttemptComplete (
                                                (DSNAME*)&(pNCSDTemp->NC),
                                                ulSyncFlags,
                                                ulRet,
                                                pNcSyncSource->szDSA );
                                        }
                                    }
                                }
                            }
                        }
                    } // for each source num
                } // if (fSync)

                CheckInitSyncsFinished();

            } // if ! updates enabled

        } __finally {
            // If updates still not enabled or error, replace task to run again

            if ((!gfInitSyncsFinished) || AbnormalTermination()) {
                if ( NULL != ppvNext ) {
                    // Warn user this is going to take a while...
                    // In this arm so it logged on 2nd and later attempts...
                    if (gulNCUnsyncedWrite!=0) {
                        DPRINT( 0, "Init syncs not finished yet, server not advertised\n" );
                        LogEvent(DS_EVENT_CAT_REPLICATION,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_ADUPD_INIT_SYNC_ONGOING,
                                 NULL,
                                 NULL,
                                 NULL);
                    }
                    else {
                        Assert(gulNCUnsyncedReadOnly!=0);
                        DPRINT( 0, "Init syncs for read-only partitions not finished\n");
                        LogEvent(DS_EVENT_CAT_REPLICATION,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_ADUPD_INIT_SYNC_ONGOING_READONLY,
                                 NULL,
                                 NULL,
                                 NULL);
                    }
                    // called by Task Scheduler; reschedule in-place
                    *ppvNext = (void *)FALSE;
                    *pcSecsUntilNextIteration = SYNC_CHECK_PERIOD_SECS;
                } else {
                    // not called by Task Scheduler; must insert new task
                    InsertInTaskQueueSilent(
                        TQ_CheckSyncProgress,
                        (void *)FALSE,
                        SYNC_CHECK_PERIOD_SECS,
                        TRUE);
                }
            }
            LeaveCriticalSection(&csNCSyncData);
        }
    }
    __except (GetDraException((GetExceptionInformation()), &ulRet)) {
        DPRINT1( 0, "Caught exception %d in task queue function CheckSyncProgress\n", ulRet );
        LogUnhandledError( ulRet );
    }
} /* CheckSyncProgress */

void
DelayedEnqueueInitSyncs(
    IN  void *  pv,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )

/*++

Routine Description:

    Kick off init syncs.

    Init syncs are necessary so the DS is authoritative when it advertises. Init syncs allow
    the DS to catch up with its peers after being down. Also fsmo operations are not considered
    valid until a successful sync has been performed.

    Init syncs should not start until the network and DNS are ready.

Arguments:

    pv -
    ppvNext -
    pcSecsUntilNextIteration -

Return Value:

    None

--*/

{
    THSTATE *pTHS = pTHStls;
    ULONG ulRet = 0;
    UCHAR *pVal;
    ULONG bufSize = 0;
    ULONG len;
    DSNAME *pNC;
    DBPOS *pDBTmp;
    REPLICA_LINK *pRepsFromRef;
    UCHAR i;
    BOOL fPerformInitSyncs = TRUE; // Default
    SYNTAX_INTEGER it;

    // Unused variables
    pv;
    ppvNext;
    pcSecsUntilNextIteration;

    // Check registry override.  This key controls whether we perform the initial
    // syncs at all.  Once they have been issued, there is no easy way to cancel
    // them.
    GetConfigParam(DRA_PERFORM_INIT_SYNCS, &fPerformInitSyncs, sizeof(BOOL));
    if (!fPerformInitSyncs) {
        DPRINT(0, "DRA Initial Synchronizations are disabled.\n");
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DRA_INIT_SYNCS_DISABLED,
                 NULL,
                 NULL,
                 NULL);
    }

    // Read DSA object and find all the replica.
    BeginDraTransaction(SYNC_WRITE);
    __try {
        // Find the DSA object
        if (ulRet = DBFindDSName(pTHS->pDB, gAnchor.pDSADN)) {
            DRA_EXCEPT (DRAERR_InternalError, ulRet);
        }

        // Set up the temporary pDB
        DBOpen (&pDBTmp);
        __try {
            /* Set up a comparison for a schedule of never.  That is a
             * byte array big enough for 1 bit per every 15 minutes of a
             * week.
             */
            BYTE pScheduleNever[SCHEDULE_LEN] = {0};

            // Search the master and replica NCs to see if there are any that
            // need to be periodically or initally synched. We search the
            // master NCs so that we'll find the writeable replicas too.

            for (i = 0; i < ARRAY_SIZE(gAtypeCheck); i++) {
                ULONG NthValIndex = 0;

                // For each NC that we replicate, see if they need to be
                // initially synchronized and whether they need to be put
                // in the periodic replica scheme.

                while (!(DBGetAttVal(pTHS->pDB,
                                     ++NthValIndex,
                                     gAtypeCheck[i].AttrType,
                                     0,
                                     0, &len, (PUCHAR *)&pNC))) {
                    ULONG NthValIndex = 0;

                    if (ulRet = FindNC(pDBTmp,
                                       pNC,
                                       gAtypeCheck[i].ulFindNCFlags,
                                       &it)) {
                        DRA_EXCEPT(DRAERR_InconsistentDIT, ulRet);
                    }

                    if (fPerformInitSyncs) {
                        //
                        // Get the repsfrom attribute
                        //
                        while (!(DBGetAttVal(pDBTmp,
                                             ++NthValIndex,
                                             ATT_REPS_FROM,
                                             DBGETATTVAL_fREALLOC,
                                             bufSize, &len, &pVal))) {

                            bufSize=max(bufSize,len);

                            Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );
                            VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);

                            pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufSize);
                            //note: we preserve pVal for DBGetAttVal realloc
                            pVal = (PUCHAR)pRepsFromRef;
                            Assert(bufSize >= pRepsFromRef->V1.cb);

                            Assert( pRepsFromRef->V1.cbOtherDra
                                    == MTX_TSIZE(RL_POTHERDRA(pRepsFromRef)) );

                            // Init sync if
                            // a. Initial sync flag is set (usually by KCC)
                            // b. Schedule is not NEVER
                            // c1. The replica is writable, OR
                            // c2. We were never fully promoted before, OR
                            // c3. This is not a full sync
                            if (
                                (pRepsFromRef->V1.ulReplicaFlags & DRS_INIT_SYNC) &&
                                ( 0 != memcmp(
                                            &pRepsFromRef->V1.rtSchedule,
                                            pScheduleNever,
                                            sizeof( REPLTIMES ) )
                                    ) &&
                                ( (pRepsFromRef->V1.ulReplicaFlags & DRS_WRIT_REP) ||
                                  (!gfWasPreviouslyPromotedGC) ||
                                  (!(pRepsFromRef->V1.ulReplicaFlags & DRS_NEVER_SYNCED))
                                    )
                                )
                            {
                                LPWSTR pszSource;

                                // Mail replicas are not initially synced
                                Assert( !(pRepsFromRef->V1.ulReplicaFlags & DRS_MAIL_REP ));

                                // If this is a non-mail replica add it to the
                                // list of NCs and sources to initial sync.

                                // Add the replica to the list of
                                // NCs and increment sources count.

                                pszSource = TransportAddrFromMtxAddrEx(
                                    RL_POTHERDRA(pRepsFromRef));

                                AddInitSyncList( pNC,
                                                 pRepsFromRef->V1.ulReplicaFlags,
                                                 pszSource );
                                THFreeEx(pTHS, pszSource);
                            }

                            // Guarantee that preempted syncs get into the queue first.
                            // The preempted flag is a simple means of achieving source
                            // stickiness, were we try to sync the same source in the same
                            // priority class to completion.
                            // Note that the preempted flag can be lost on error, and
                            // another preferred source will be selected.
                            if (pRepsFromRef->V1.ulReplicaFlags & DRS_PREEMPTED) {
                                CHAR szUuid1[SZUUID_LEN];
                                DWORD ulSyncFlags = (pRepsFromRef->V1.ulReplicaFlags
                                                     & AO_PRIORITY_FLAGS)
                                    | DRS_PREEMPTED
                                    | DRS_ASYNC_OP;
                                DPRINT3( 0, "Resuming preempted sync of %ws from %s with options 0x%x\n",
                                         pNC->StringName,
                                         DsUuidToStructuredString(&(pRepsFromRef->V1.uuidDsaObj), szUuid1),
                                         ulSyncFlags );
                                ulRet = DirReplicaSynchronize (
                                    pNC,
                                    NULL, // pszSourceDsa, ignored
                                    &pRepsFromRef->V1.uuidDsaObj,
                                    ulSyncFlags );
                                // Since we're reading the repsfrom, should be able to enqueue
                                Assert( !ulRet );
                            }
                        }
                    }
                }
            }
            if(bufSize)
                THFree(pVal);

        } __finally {

            // Close the temporary pDB
            DBClose (pDBTmp, !AbnormalTermination());
        }

        ulRet = 0;

    } _finally {
        EndDraTransaction(!AbnormalTermination());

        // Allow async thread to start
        SetEvent(hevDRASetup);
    }

    DraReturn(pTHS, ulRet);

    // Check for early termination

    if (!gulNCUnsyncedWrite) {
        // Writes are done, now check synced atleast once criteria
        CheckFullSyncProgress( (void *) NULL, NULL, NULL );
    }

    // If there are no readonly sync's to perform, update the anchor immediately
    if (!gulNCUnsyncedReadOnly) {
        // Reads are done, promote to GC if necessary
        UpdateGCAnchorFromDsaOptionsDelayed( TRUE /* startup */ );
    }

    if (gulNCUnsynced) {
        // Attempt to initial sync replicas as required.
        CheckSyncProgress((void *) TRUE, NULL, NULL);
    } else {
        // Call routine to determine of admin updates can be enabled.
        CheckInitSyncsFinished();
    }

    DPRINT1( 1, "Finished enqueuing init syncs, status = %d\n", ulRet );

} /* DelayedEnqueueInitSyncs */

ULONG
InitDRATasks (
    THSTATE *pTHS
    )

/*++

Routine Description:

Checks through all the master and replica NCs on this DSA, and checks:
If initial sync is required on a NC, it puts the periodic sync task
on the queue.

Note that if DSA is not installed, we return immediately

The requirements for starting an initial sync of a nc are:

a. Initial sync flag is set
   This is controlled by the KCC or by the creator of the manual connection.
   The KCC does not mark inter-site connections as INIT_SYNC

b. Schedule is not NEVER

c1. The replica is writable, OR
c2. We were never fully promoted before, OR
c3. This is not a full sync

    The rationale here is to prevent "maintenance" full sync's from blocking
    GC advertisement.  Full sync's can happen during initial GC promotion,
    or later they may be requested manually or as a result of a partial
    attribute change.  We want promotion related full syncs to go through
    as init syncs, but post-promotion full syncs to be delayed.

    Specifically, the scenario we are trying to avoid is a change in the partial
    attribute set (which sometimes forces full syncs on all links), and then a
    site-wide power failure.  We want to avoid all GC's being down (unadvertised)
    because they are waiting for an init sync full sync.


Arguments:

    pTHS - current thread state

Return Value:

    ULONG - error in DRA error space.

--*/

{
    ULONG ulRet = 0;

    // Reset AsyncThread() state.
    InitDraQueue();

    // Skip this if not installed. (No replicas if not installed). All we
    // do is release the async queue.

    if ( DsaIsInstalling() ) {
        SetEvent(hevDRASetup);
        return 0;
    }

    // Enqueuing the init syncs in a separate task is useful for modularity and
    // restartability. But the main reason is to decouple this activity from the startup
    // main line for parallelism. Init syncs should not start until the network and DNS
    // are ready.
    InsertInTaskQueue(TQ_DelayedEnqueueInitSyncs, NULL, ENQUEUE_INIT_SYNC_DELAY_SECS );

    InsertInTaskQueue(TQ_CheckInstantiatedNCs, NULL, CHECK_INSTANTIATED_NCS_PERIOD_SECS);

    gtimeLastPeriodicSync = DBTime();
    InsertInTaskQueue(TQ_SynchronizeReplica,
                      &gtimeLastPeriodicSync,
                      FIFTEEN_MINUTES);

    hMailReceiveThread = (HANDLE) _beginthreadex(NULL,
                                                 0,
                                                 MailReceiveThread,
                                                 NULL,
                                                 0,
                                                 &gMailReceiveTid);

    InsertInTaskQueue(TQ_DelayedMailStart, NULL, MAIL_DELAY_SECS);

    return ulRet;
}

void
DelayedMailStart(
    IN  void *  pv,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )

/*++

Routine Description:

// Just calls DRAEnsureMailRunning. Can't call that directly because of
// different parameters

Arguments:

    pv -
    ppvNext -
    pcSecsUntilNextIteration -

Return Value:

    None

--*/

{
    pv;
    ppvNext;
    pcSecsUntilNextIteration;

    DRAEnsureMailRunning();
} /* DelayedMailStart */

void
AddInitSyncList(
    IN  DSNAME *  pNC,
    IN  ULONG     ulReplicaFlags,
    IN  LPWSTR    pszDSA
    )

/*++

Routine Description:

// Keeps records of sync status of NCs. Called when we startup and have
// a replica to initial sync, or when we add a new replica.

Arguments:

    pNC -
    ulReplicaFlags -
    pszDSA -

Return Value:

    None

--*/

{
    DWORD cchDSA;
    NCSYNCDATA **ppNCSDTemp;
    NCSYNCSOURCE **ppNcSyncSource;
    BOOL fDataAllocated = FALSE;

    // Mail-based relicas are not init sync
    Assert(!(ulReplicaFlags & DRS_MAIL_REP));

    DPRINT3( 1, "Adding (nc %ws, source %ws, flags 0x%x) to unsynced list\n",
             pNC->StringName, pszDSA, ulReplicaFlags );
    LogEvent(DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_VERBOSE,
             DIRLOG_DRA_ADUPD_INC_SRC,
             szInsertDN(pNC),
             szInsertWC(pszDSA),
             szInsertUL(ulReplicaFlags));

    EnterCriticalSection(&csNCSyncData);

    __try {
        // If we are finished, we don't keep track anymore
        if (gfInitSyncsFinished) {
            __leave;
        }

        // Search for the NC in the list.

        for (ppNCSDTemp = &gpNCSDFirst; *ppNCSDTemp;
                                ppNCSDTemp = &((*ppNCSDTemp)->pNCSDNext)) {
            if (NameMatched (pNC, &((*ppNCSDTemp)->NC))) {
                break;
            }
        }

        // If it's not there, allocate and keep track of this NC

        if (!(*ppNCSDTemp)) {

            DWORD cb = sizeof(NCSYNCDATA) + pNC->structLen;

            *ppNCSDTemp = malloc(cb);
	    if (!(*ppNCSDTemp)) {
		DRA_EXCEPT (DRAERR_OutOfMem, 0);
	    }
            fDataAllocated = TRUE;

            memset((*ppNCSDTemp), 0, cb);
            // Save NC

            memcpy (&((*ppNCSDTemp)->NC), pNC, pNC->structLen);
            (*ppNCSDTemp)->ulReplicaFlags = ulReplicaFlags;

            // Increment the count of sources that need to be synced.
            gulNCUnsynced++;
            if (ulReplicaFlags & DRS_WRIT_REP) {
                gulNCUnsyncedWrite++;
            } else {
                gulNCUnsyncedReadOnly++;
            }
        }

        // Allocate memory for name and copy over.

        for (ppNcSyncSource = &((*ppNCSDTemp)->pFirstSource);
                    *ppNcSyncSource; ppNcSyncSource = &((*ppNcSyncSource)->pNextSource)) {
        }

        cchDSA = wcslen(pszDSA);
	*ppNcSyncSource = malloc(sizeof(NCSYNCSOURCE)
				 + sizeof(WCHAR) * (cchDSA + 1) );
	if (!(*ppNcSyncSource)) {
            if (fDataAllocated) {
                free( (*ppNCSDTemp) );
                (*ppNCSDTemp) = NULL;
            }
	    DRA_EXCEPT (DRAERR_OutOfMem, 0);
	}


        (*ppNcSyncSource)->fCompletedSrc = FALSE;
        (*ppNcSyncSource)->ulResult = ERROR_DS_DRA_REPL_PENDING;
        (*ppNcSyncSource)->pNextSource = NULL;
        (*ppNcSyncSource)->cchDSA = cchDSA;
        wcscpy((*ppNcSyncSource)->szDSA, pszDSA);

        // Increment the count of sources for this NC

        (*ppNCSDTemp)->ulUntriedSrcs++;

    } __finally {
        LeaveCriticalSection(&csNCSyncData);
    }
} /* AddInitSyncList */

void
InitSyncAttemptComplete(
    IN  DSNAME *  pNC,
    IN  ULONG     ulOptions,
    IN  ULONG     ulResult,
    IN  LPWSTR    pszDSA
    )

/*++

Routine Description:

Record that this NC has been synced (either successfully or otherwise)

Note that our callers, replica delete and replica sync, are simple and liberal
in when they call us. They do not check whether the sync in progress was an actual
init sync. They err on the side of notifying too often rather than leave an init sync
incomplete. Thus we must be generous and defensive in screening out unnecessary
notifications.

Arguments:

    pNC - naming context
    ulResult - final error
    pszDSA - source server

Return Value:

    None

--*/

{
    NCSYNCDATA * pNCSDTemp;
    NCSYNCSOURCE *pNcSyncSource;
    ULONG prevWriteCount = gulNCUnsyncedWrite;
    ULONG prevReadOnlyCount = gulNCUnsyncedReadOnly;

    // Ignore if we're installing.
    if ( DsaIsInstalling() || gResetAfterInstall ) {
        return;
    }

    // No longer trying this NC.

    EnterCriticalSection(&csNCSyncData);

    __try {
        // If init syncs are finished, we don't keep track anymore
        if (gfInitSyncsFinished) {
            __leave;
        }

        // Find NC in list

        pNCSDTemp = GetNCSyncData (pNC);
        if (!pNCSDTemp) {
            // This NC completed a sync while init syncs were active, but it was
            // not one of the NCs that was chosen for init sync.  Not all NCs are
            // init synced. The criteria for which NCs are init synced can be found
            // in InitDraTasks(). Just ignore it.
            __leave;
        }

        // Find source.

        for (pNcSyncSource = pNCSDTemp->pFirstSource; pNcSyncSource;
                                pNcSyncSource = pNcSyncSource->pNextSource) {
            if (DnsNameCompare_W(pNcSyncSource->szDSA, pszDSA)) {
                break;
            }
        }

        // Only do the rest of this routine if source is not already completed and we
        // knew about this source.

        if (pNcSyncSource && (!pNcSyncSource->fCompletedSrc)) {

            DPRINT3( 1, "Marking (nc %ws, source %ws) as init sync complete, status %d\n",
                     pNC->StringName, pszDSA, ulResult );

            // Any kind of sync may complete an NC waiting for an init sync.  It just
            // depends on which sync completes first. It may be an INIT_SYNC_NOW sync,
            // or a PERIODIC sync, or a user-requested sync.

            // Record progress
            pNcSyncSource->ulResult = ulResult;

            // Set source as completed (synced or failed)
            pNcSyncSource->fCompletedSrc = TRUE;

            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_DRA_ADUPD_DEC_SRC,
                      szInsertDN(pNC),
                      szInsertWC(pszDSA),
                      szInsertWin32Msg(ulResult),
                      szInsertWin32ErrCode(ulResult),
                      NULL, NULL, NULL, NULL );

            // If we synced ok from this source, record it
            // here. This stops future syncs of this NC trying to get
            // modifications made by any DSA.

            if ((!ulResult) && (!(pNCSDTemp->fSyncedFromOneSrc))) {
                pNCSDTemp->fSyncedFromOneSrc = TRUE;

                // If this NC is not marked complete (could have been completed
                // by RPC failing all sources, not by syncing) then mark as complete
                // and decrement unsynced NCs count.

                if (!(pNCSDTemp->fNCComplete)) {
                    pNCSDTemp->fNCComplete = TRUE;

                    // NC is synced, decrement unsynced count.

                    if (gulNCUnsynced) {
                        gulNCUnsynced--;
                        if (pNCSDTemp->ulReplicaFlags & DRS_WRIT_REP) {
                            gulNCUnsyncedWrite--;
                        } else {
                            gulNCUnsyncedReadOnly--;
                        }
                    } else {
                        // Count of all unsynced Naming contexts should
                        // never go negative.
                        DRA_EXCEPT (DRAERR_InternalError, gulNCUnsynced);
                    }
                    DPRINT2( 1, "nc %ws successfully init synced from source %ws\n",
                             pNC->StringName, pNcSyncSource->szDSA );
                    LogEvent(DS_EVENT_CAT_REPLICATION,
                             DS_EVENT_SEV_VERBOSE,
                             DIRLOG_DRA_ADUPD_NC_SYNCED,
                             szInsertDN(pNC),
                             szInsertWC(pNcSyncSource->szDSA),
                             NULL);
                }
            }

            // Sync has been attempted, increment tried sources, decrement
            // untried sources, and if we've tried all sources, decrement
            // the count of NCs for which we're waiting.

            pNCSDTemp->ulTriedSrcs++;

            if (pNCSDTemp->ulUntriedSrcs) {
                (pNCSDTemp->ulUntriedSrcs)--;
                if ((!(pNCSDTemp->ulUntriedSrcs)) && (!(pNCSDTemp->fSyncedFromOneSrc))) {

                    // If we weren't fully synced and this was the last source, and
                    // thsi NC isn't already marked complete, mark complete now
                    // and decrement unsynced NCs count.

                    if (!(pNCSDTemp->fNCComplete)) {
                        pNCSDTemp->fNCComplete = TRUE;
                        if (gulNCUnsynced) {
                            gulNCUnsynced--;
                            if (pNCSDTemp->ulReplicaFlags & DRS_WRIT_REP) {
                                gulNCUnsyncedWrite--;
                            } else {
                                gulNCUnsyncedReadOnly--;
                            }
                            DPRINT1( 1, "nc %ws had to give up init sync\n",
                                     pNC->StringName );
                            LogEvent(DS_EVENT_CAT_REPLICATION,
                                     DS_EVENT_SEV_VERBOSE,
                                     DIRLOG_ADUPD_NC_GAVE_UP,
                                     szInsertDN(pNC),
                                     NULL,
                                     NULL);
                        } else {
                            // Count of all unsynced Naming contexts should
                            // never go negative.
                            DRA_EXCEPT (DRAERR_InternalError, gulNCUnsynced);
                        }
                    }
                }
            } else {
                // Count of all unsynced sources should
                // never go negative.
                DRA_EXCEPT (DRAERR_InternalError, pNCSDTemp->ulUntriedSrcs);
            }

            // Some NCs have finished syncing: see if there is anything to do
            if ( (prevWriteCount) && (!gulNCUnsyncedWrite) ) {
                // Write count transitioned to zero
                CheckFullSyncProgress( (void *) NULL, NULL, NULL );
            }
            if ( (prevReadOnlyCount) && (!gulNCUnsyncedReadOnly) ) {
                // ReadOnly count transitioned to zero
                // Promote to GC if necessary
                UpdateGCAnchorFromDsaOptionsDelayed( TRUE /* startup */ );
            }

            // Ok, we have synced or attempted all NCs.
            // Check admin update status and cleanup.
            if (!gulNCUnsynced) {
                CheckInitSyncsFinished();
            }
        }
    } __finally {
        LeaveCriticalSection(&csNCSyncData);
    }
} /* InitSyncAttemptComplete */

NCSYNCDATA *
GetNCSyncData(
    DSNAME *pNC
    )

/*++

Routine Description:

// Find NC in NC sync data linked list. Returns NULL if not found. Caller
// must have entered critical section

Arguments:

    pNC -

Return Value:

    NCSYNCDATA * -

--*/

{
    NCSYNCDATA *pNCSDTemp;

    // Find NC in list

    for (pNCSDTemp = gpNCSDFirst; pNCSDTemp;
                                    pNCSDTemp = pNCSDTemp->pNCSDNext) {
        if (NameMatched (pNC, &(pNCSDTemp->NC))) {
            break;
        }
    }
    return pNCSDTemp;
} /* GetNCSyncData */

void
CheckInitSyncsFinished(
    void
    )

/*++

Routine Description:

This routine determines if admin updates can be enabled.

Normally, this check is looking for the number of unsynced partitions to go
to zero.  However, this process can be short circuited by setting the
wait initial synchronizations to zero.

Arguments:

    void -

Return Value:

    None

--*/

{

    NCSYNCDATA *pNCSDTemp;
    NCSYNCDATA *pNCSDNext;
    NCSYNCSOURCE *pNcSyncSource;
    NCSYNCSOURCE *pNcSyncSourceNext;

    EnterCriticalSection(&csNCSyncData);
    __try {

        // Check that there we are installed, that there are no
        // unsynced NCs

        if (DsaIsRunning() &&
            (!gfInitSyncsFinished) &&
            (!gulNCUnsynced) ) {

            Assert( !gulNCUnsyncedWrite );
            Assert( !gulNCUnsyncedReadOnly );
            gfInitSyncsFinished = TRUE;

            // Walk list freeing NC data allocations if any

            for (pNCSDTemp = gpNCSDFirst; pNCSDTemp;) {
                pNCSDNext = pNCSDTemp->pNCSDNext;

                // Free all source allocations

                for (pNcSyncSource = pNCSDTemp->pFirstSource; pNcSyncSource;) {
                    pNcSyncSourceNext = pNcSyncSource->pNextSource;
                    free (pNcSyncSource);
                    pNcSyncSource = pNcSyncSourceNext;
                }
                free (pNCSDTemp);
                pNCSDTemp = pNCSDNext;
            }
            gpNCSDFirst = NULL;

            DPRINT( 1, "This server has finished the initial syncs phase.\n" );
            LogEvent(DS_EVENT_CAT_REPLICATION,
                        DS_EVENT_SEV_VERBOSE,
                        DIRLOG_DRA_ADUPD_ALL_SYNCED,
                        NULL,
                        NULL,
                        NULL);
        }
    } __finally {
        LeaveCriticalSection(&csNCSyncData);
    }
} /* CheckInitSyncsFinished */

void
SynchronizeReplica(
    IN  void *  pvParam,
    OUT void ** ppvParamNextIteration,
    OUT DWORD * pcSecsUntilNextIteration
    )

/*++

Routine Description:

// SynchronizeReplica - Looks for NCs and decides whether
// they need to be periodic synced NOW.  Called from the taskq, and
// reschedules itself after it has run.
//
// Its one parameter is the last time it ran.  It will try to do necessary
// period syncs scheduled between now and the last time it ran.

Arguments:

    pvParam -
    ppvParamNextIteration -
    pcSecsUntilNextIteration -

Return Value:

    None

--*/

{
    DBPOS *pDBTmp;
    DSNAME *pNC=NULL;
    REPLICA_LINK *pRepsFromRef;
    UCHAR *pVal;
    ULONG len;
    ULONG ulRet;
    DSTIME timeNow = DBTime();
    DSTIME timeLastIteration;
    SYNTAX_INTEGER it;
    THSTATE *pTHS = pTHStls;

    Assert(NULL != pvParam);
    timeLastIteration = *((DSTIME *)pvParam);

    *((DSTIME *)pvParam)      = timeNow;
    *ppvParamNextIteration    = pvParam;
    *pcSecsUntilNextIteration = FIFTEEN_MINUTES;

    Assert(!DsaIsInstalling());

    // Set up DB stuff
    if (InitFreeDRAThread(pTHS, SYNC_READ_ONLY)) {
        // Failure,(probably memory) give up.
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DRA_PR_ALLOC_FAIL,
                 NULL,
                 NULL,
                 NULL);
        return;
    }

    __try {
        // Read DSA object and find all the replicas.
        if (ulRet = DBFindDSName(pTHS->pDB, gAnchor.pDSADN)) {
            DRA_EXCEPT (DRAERR_InternalError, ulRet);
        }

        // Set up the temporary pDB
        DBOpen (&pDBTmp);
        __try {
            int i;
            ULONG ulSyncFlags;

            // Search the master and replica NCs to see if there are any that
            // need to be periodically synched. We search the
            // master NCs so that we'll find the writeable replicas too.

            for (i = 0; i < ARRAY_SIZE(gAtypeCheck); i++) {
                ULONG NthValIndex=0;
                ULONG bufSize = 0;

                while (!(DBGetAttVal(pTHS->pDB,
                                     ++NthValIndex,
                                     gAtypeCheck[i].AttrType,
                                     0,
                                     0,
                                     &len, (UCHAR**)&pNC))) {
                    // are we being signalled to shutdown?
                    if (eServiceShutdown) {
                        DRA_EXCEPT(DRAERR_Shutdown, 0);
                    }

                    // Go to the NC
                    if (ulRet = FindNC(pDBTmp,
                                       pNC,
                                       gAtypeCheck[i].ulFindNCFlags,
                                       &it)) {
                        DRA_EXCEPT(DRAERR_InconsistentDIT, ulRet);
                    }

                    if (it & IT_NC_GOING) {
                        // NC tear down has partially completed.  Make sure
                        // there is an operation in the task queue to continue
                        // to make progress.
                        Assert(!DBHasValues(pDBTmp, ATT_REPS_FROM));

                        DirReplicaDelete(pNC,
                                         NULL,
                                         DRS_ASYNC_OP | DRS_NO_SOURCE
                                            | DRS_REF_OK | DRS_IGNORE_ERROR);
                    } else {
                        ULONG NthValIndex = 0;
                        // Get the repsfrom attribute

                        while(!(DBGetAttVal(pDBTmp,
                                            ++NthValIndex,
                                            ATT_REPS_FROM,
                                            DBGETATTVAL_fREALLOC,
                                            bufSize,
                                            &len,&pVal))) {
                            bufSize = max(bufSize, len);

                            Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );
                            VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);

                            pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufSize);
                            //note: we preserve pVal for DBGetAttVal realloc
                            pVal = (PUCHAR)pRepsFromRef;
                            Assert(bufSize >= pRepsFromRef->V1.cb);

                            Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );

                            if (     ( pRepsFromRef->V1.ulReplicaFlags & DRS_PER_SYNC )
                                 && !( pRepsFromRef->V1.ulReplicaFlags & DRS_DISABLE_PERIODIC_SYNC )
                                 &&  ( fIsBetweenTime(
                                        &pRepsFromRef->V1.rtSchedule,
                                        timeLastIteration,
                                        timeNow
                                        )
                                     )
                               )
                            {
                                ulSyncFlags = (pRepsFromRef->V1.ulReplicaFlags
                                                & AO_PRIORITY_FLAGS)
                                              | DRS_PER_SYNC
                                              | DRS_ASYNC_OP;

                                if (!(pRepsFromRef->V1.ulReplicaFlags
                                      & DRS_MAIL_REP)
                                    && !(pRepsFromRef->V1.ulReplicaFlags
                                         & DRS_NEVER_NOTIFY)) {
                                    // Tell the source DSA to make sure it has a
                                    // Reps-To for the local DSA.  This ensures
                                    // the source sends us change notifications.
                                    ulSyncFlags |= DRS_ADD_REF;
                                }

                                ulRet = DirReplicaSynchronize(
                                    pNC,
                                    NULL,
                                    &pRepsFromRef->V1.uuidDsaObj,
                                    ulSyncFlags);
                                // Since we're reading the repsfrom, should be able to enqueue
                                Assert( !ulRet );
                            }

                            // are we being signalled to shutdown?

                            if (eServiceShutdown) {
                                DRA_EXCEPT(DRAERR_Shutdown, 0);
                            }
                        }
                    }
                } /* while */
                if(bufSize)
                    THFree(pVal);
            }

            timeLastIteration = timeNow;
        }
        __finally {
            // Close the temporary pDB
            DBClose (pDBTmp, !AbnormalTermination());
        }
    }

    __finally {


        CloseFreeDRAThread (pTHStls, TRUE);

        EndDraTransaction(!AbnormalTermination());

        // Ok, we're all done.  Reschedule ourselves.

        *((DSTIME *)pvParam)      = timeLastIteration;
        *ppvParamNextIteration    = pvParam;
        *pcSecsUntilNextIteration = FIFTEEN_MINUTES;
    }


    return;

} /* SynchronizeReplica */

int
DSTimeTo15MinuteWindow(
    IN  DSTIME  dstime
    )

/*++

Routine Description:

    Determines which 15-minute window during the week that the given DSTIME
    falls into.  Window 0 is Sunday 12am to 12:14am, window 1 is Sunday
    12:15am to 12:29am, etc.

Arguments:

    dstime (IN) - DSTIME to convert.

Return Values:

    The corresponding 15-minute window.

--*/

{
    int         nWindow;
    SYSTEMTIME  systime;

    DSTimeToUtcSystemTime(dstime, &systime);

    nWindow = (systime.wMinute +
               systime.wHour * 60 +
               systime.wDayOfWeek * 24 * 60) / 15;

    return nWindow;
}


BOOL
fIsBetweenTime(
    REPLTIMES * prt,
    DSTIME timeBegin,
    DSTIME timeEnd
    )

/*++

Routine Description:

// fIsBetweenTime - parse the synchronization schedule to see if any of
//  the bits that are set in the schedule are between timeBegin and timeEnd,
//  not including the 15 minute segment specified by tBeginning, and dealing
//  correctly with wrapping around the end of the week.
//
//  this is called only from SynchronizeReplica to see if we need to sync
//  a particular NC source right now.

Arguments:

    prt -
    timeBegin -
    timeEnd -

Return Value:

    BOOL -

--*/

{
    int bBeginning, bBeginByte;
    UCHAR bBeginBitMask;
    int bEnd, bEndByte;
    UCHAR bEndBitMask;
    int nbyte;
    UCHAR * pVal = prt->rgTimes;

    // Convert to 15 minute segment since start of week.
    bBeginning = DSTimeTo15MinuteWindow(timeBegin);
    bEnd       = DSTimeTo15MinuteWindow(timeEnd);

    /*
     * if any bits in the schedule from (bBeginning, bEnd] are set,
     * return TRUE.
     */

    if(bBeginning != bEnd) {
        /* tBeginning and tEnd are not in the same fifteen minute segment.
         * adjust the count to deal with this, being careful to wrap to the
         * next week.
         */
        bBeginning = (bBeginning + 1) % (7 * 24 * 4);
    }

    bBeginByte = bBeginning / 8;
    bBeginBitMask = (0xFF >> (bBeginning % 8)) & 0xFF;
    bEndByte = bEnd / 8;
    bEndBitMask = (0xFF << (7-(bEnd % 8))) & 0xFF;


    if(bBeginByte == bEndByte) {
        /* need to have the bitmask only hit some of the bits in
         * the appropriate byte, as only one byte is in question here.
         */
        bBeginBitMask = (bEndBitMask &= bBeginBitMask);
    }

    if(pVal[bBeginByte] & bBeginBitMask) {
        return TRUE;
    }

    if(bBeginByte == bEndByte) {
        return FALSE;
    }

    if(bBeginByte < bEndByte)
        for(nbyte = bBeginByte+1;nbyte < bEndByte; nbyte++) {
            if(pVal[nbyte]) {
                return TRUE;
            }
        }
    else {
        for(nbyte = bBeginByte+1;nbyte < 84; nbyte++) {
            if(pVal[nbyte]) {
                return TRUE;
            }
        }
        for(nbyte = 0;nbyte < bEndByte; nbyte++) {
            if(pVal[nbyte]) {
                return TRUE;
            }
        }
    }


    if(pVal[bEndByte] & bEndBitMask) {
        return TRUE;
    }

    return FALSE;
} /* fIsBetweenTime */


BOOL
CheckPrimaryDomainFullSyncOnce(
    VOID
    )

/*++

Routine Description:

This code is only called during startup, once.  All machine types call this:
first domain in enterprise
first dc in domain
replica dc in domain

This code is designed to run in the startup thread.  We have a thread state
but not a dbpos.

Check if machine is fully installed
A machine is fully installed when either
1. It is the first machine in its domain
2. It has an uptodate vector, which means it has completed a full sync

Arguments:

    VOID -

Return Value:

    BOOL - true, primary domain is synchronized
           false, try again later

    Exceptions are raised out of this function.

--*/

{
    char szSrcRootDomainSrv[MAX_PATH];
    PDSNAME pdnDomain;
    BOOL    fHasValues = FALSE;
    DBPOS   *pDB;

    // If already synchronized, don't bother
    if (!DsIsBeingBackSynced()) {
        Assert( FALSE );  // SHOULDN'T HAPPEN
        return TRUE;
    }

    // Get the source server. No source server means first machine in domain.
    // First machine is synchronized by definition.
    if ( (GetConfigParam(SRCROOTDOMAINSRV, szSrcRootDomainSrv, MAX_PATH)) ||
         (strlen( szSrcRootDomainSrv ) == 0) )
    {
        return TRUE;
    }

    // Build a DSNAME for the domain NC
    pdnDomain = gAnchor.pDomainDN;
    if ( !pdnDomain )
    {
        // Configuration info missing!
        LogUnhandledError( 0 );
        return FALSE;
    }

    DBOpen (&pDB);
    __try {

        // Look for uptodate vector on Domain NC
        if (DBFindDSName(pDB, pdnDomain))
        {
            // We should not get here, the DRA should have previously
            // confirmed that this object does infact exist.
            DRA_EXCEPT (DRAERR_InternalError, 0);
        }

        fHasValues = DBHasValues( pDB, ATT_REPL_UPTODATE_VECTOR );
    } __finally {

        // Close the temporary pDB
        DBClose (pDB, !AbnormalTermination());
    }

    if (!fHasValues) {
        DPRINT1( 0, "Warning: NC %ws has not completed first sync: DC has not been advertised...\n",
                pdnDomain->StringName );
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_ADUPD_NC_NEVER_SYNCED_WRITE,
                 szInsertDN(pdnDomain),
                 NULL,
                 NULL);
    }

    return fHasValues;
} /* CheckPrimaryDomainFullSyncOnce */


BOOL
DraIsPartitionSynchronized(
    DSNAME *pNC
    )

/*++

Routine Description:

Check whether any nc is synchronized.  To be synchronized,
the system must have replicated from any source since we started.  This
replication may be satisfied by any kind of sync: init sync, scheduled sync, or
a manual sync.

If the partition does not have any sources, this routine returns true.

The KCC may leave dead sources in our list if they are in their "stay of
execution". We should ignore sources to deleted DSA's.

Arguments:

    pNC - Naming context to check

Return Value:

    BOOL -

--*/

{
    BOOL fResult = FALSE;
    DBPOS *pDBTmp;
    ULONG NthValIndex = 0, cSources = 0;
    SYNTAX_INTEGER it;
    UCHAR *pVal;
    ULONG bufSize = 0;
    ULONG len;
    REPLICA_LINK *pRepsFromRef;

    // During install, we haven't even started to sync yet
    if ( DsaIsInstalling() || gResetAfterInstall ) {
        return FALSE;
    }

    // Make sure not called too soon
    if (!gtimeDSAStarted) {
        Assert( !"Called before DSA initialized!" );
        return FALSE;
    }

    // Set up the temporary pDB
    DBOpen (&pDBTmp);
    __try {
        if (FindNC(pDBTmp, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, &it)) {
            Assert( !"Checking for a partition which is not held!" );
            fResult = FALSE;
            __leave;
        }

        // NC not fully held
        if (it &(IT_NC_COMING | IT_NC_GOING)) {
            fResult = FALSE;
            __leave;
        }

        //
        // Get the repsfrom attribute
        //
        while (!(DBGetAttVal(pDBTmp,
                             ++NthValIndex,
                             ATT_REPS_FROM,
                             DBGETATTVAL_fREALLOC,
                             bufSize, &len, &pVal))) {

            bufSize=max(bufSize,len);

            Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );
            VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);

            pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufSize);
            //note: we preserve pVal for DBGetAttVal realloc
            pVal = (PUCHAR)pRepsFromRef;
            Assert(bufSize >= pRepsFromRef->V1.cb);

            Assert( pRepsFromRef->V1.cbOtherDra
                    == MTX_TSIZE(RL_POTHERDRA(pRepsFromRef)) );

            if (DraFindAliveGuid( &(pRepsFromRef->V1.uuidDsaObj) ) != FIND_ALIVE_FOUND) {
                CHAR szUuid1[SZUUID_LEN];
                DPRINT1( 1, "Ignoring deleted source %s.\n",
                         DsUuidToStructuredString(&(pRepsFromRef->V1.uuidDsaObj), szUuid1));
                // Ignore deleted source

                continue;
            }
            cSources++;

            if (pRepsFromRef->V1.timeLastSuccess > gtimeDSAStarted) {
                CHAR szUuid1[SZUUID_LEN];
                DPRINT1( 1, "We have synced with partner DSA %s since start.\n",
                         DsUuidToStructuredString(&(pRepsFromRef->V1.uuidDsaObj), szUuid1));
                            
                fResult = TRUE;
                break;
            }
        }

    } __finally {

        if(bufSize)
            THFree(pVal);

        // Close the temporary pDB
        DBClose (pDBTmp, !AbnormalTermination());
    }

    // If there are no sources, return that we are synchronized
    if (cSources == 0) {
        DPRINT( 1, "There were no partner DSAs to check.\n" );
        fResult = TRUE;
    }

    return fResult;
} /* DraIsPartitionSynchronized */


void
CheckFullSyncProgress(
    IN  void *  pv,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )

/*++

Routine Description:

Check that domain NC has been synchronized atleast once.
Sets IsSynchronized flag when condition is met.
Rescheduled to run periodically as a task queue entry

Arguments:

    pv - not used
    ppvNext -
    pcSecsUntilNextIteration -

Return Value:

    None
    Exceptions are raised out of this function.
    The task queue manager will ignore most of these.

--*/

{
    DWORD ulRet = 0;
    BOOL fSync = FALSE;

    DPRINT( 1, "CheckFullSyncProgress\n" );

    __try {
        __try {
            fSync = CheckPrimaryDomainFullSyncOnce();
            if (fSync) {
                // This routine logs the event
                DsaSetIsSynchronized( TRUE );
            }

            // Note that a false return here means retry
        } __finally {
            // Reschedule if necessary
            if (!fSync) {
                // Helper routine will have logged event
                DPRINT( 1, "Not ready for advertisement yet, rescheduling...\n" );
                if ( NULL != ppvNext ) {
                    // called by Task Scheduler; reschedule in-place
                    *ppvNext = (void *)NULL;
                    *pcSecsUntilNextIteration = SYNC_CHECK_PERIOD_SECS;
                } else {
                    // not called by Task Scheduler; must insert new task
                    InsertInTaskQueueSilent(
                        TQ_CheckFullSyncProgress,
                        (void *)NULL,
                        SYNC_CHECK_PERIOD_SECS,
                        TRUE);
                }
            }
        }
    }
    __except (GetDraException((GetExceptionInformation()), &ulRet)) {
        DPRINT1( 0, "Caught exception %d in task queue function CheckFullSyncProgress\n", ulRet );
        LogUnhandledError( ulRet );
    }
} /* CheckFullSyncProgress */


BOOL
CheckDomainHasSourceInSite(
    THSTATE *pTHS,
    IN DSNAME *pdnDomain
    )

/*++

Routine Description:

Determine if the given domain nc has a source in this site.
We exclude ourselves.

Arguments:

    pTHS -
    pdnDomain -

Return Value:

    BOOL -

--*/

{
    BOOL     fFoundOne = FALSE;
    BOOL     fDSASave = pTHS->fDSA;

    SEARCHARG  SearchArg;
    SEARCHRES  SearchRes;

    FILTER     ObjCatFilter, HasNcFilter, NewHasNcFilter, OldHasNcFilter, AndFilter;
    FILTER     HasPartialNcFilter, OrFilter;

    CLASSCACHE  *pCC;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert( pdnDomain );
    Assert( gAnchor.pSiteDN );

    // Get the class category

    if (    !(pCC = SCGetClassById(pTHS, CLASS_NTDS_DSA))
         || !pCC->pDefaultObjCategory )
    {
        DPRINT( 0, "Couldn't get Class Category for CLASS NTDS DSA!\n" );
        return FALSE;
    }

    //
    // Setup the filter
    //
    RtlZeroMemory( &AndFilter, sizeof( AndFilter ) );
    RtlZeroMemory( &ObjCatFilter, sizeof( HasNcFilter ) );
    RtlZeroMemory( &HasNcFilter, sizeof( HasNcFilter ) );
    RtlZeroMemory( &HasPartialNcFilter, sizeof( HasPartialNcFilter ) );
    RtlZeroMemory( &OrFilter, sizeof( OrFilter ) );

    // This fills the Filters for getting a DC with the correct NC in it's Master NCs.
    FillHasMasterNCsFilters(pdnDomain,
                            &HasNcFilter,
                            &NewHasNcFilter,
                            &OldHasNcFilter);

    HasPartialNcFilter.choice = FILTER_CHOICE_ITEM;
    HasPartialNcFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    HasPartialNcFilter.FilterTypes.Item.FilTypes.ava.type = ATT_HAS_PARTIAL_REPLICA_NCS;
    HasPartialNcFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnDomain->structLen;
    HasPartialNcFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) pdnDomain;

    OrFilter.choice                     = FILTER_CHOICE_OR;
    OrFilter.FilterTypes.Or.count       = 2;
    OrFilter.FilterTypes.Or.pFirstFilter = &HasNcFilter;
    HasNcFilter.pNextFilter = &HasPartialNcFilter;

    // Search on object category because it is indexed
    ObjCatFilter.choice = FILTER_CHOICE_ITEM;
    ObjCatFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjCatFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    ObjCatFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = pCC->pDefaultObjCategory->structLen;
    ObjCatFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) pCC->pDefaultObjCategory;

    AndFilter.choice                    = FILTER_CHOICE_AND;
    AndFilter.FilterTypes.And.count     = 2;
    AndFilter.FilterTypes.And.pFirstFilter = &ObjCatFilter;
    ObjCatFilter.pNextFilter = &OrFilter;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = gAnchor.pSiteDN;
    SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = &AndFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = NULL;  // don't need any attributes
    SearchArg.pSelectionRange = NULL;
    InitCommarg( &SearchArg.CommArg );

    memset( &SearchRes, 0, sizeof(SEARCHRES) );
    SearchRes.CommRes.aliasDeref = FALSE;
    SearchRes.PagedResult.pRestart = NULL;

    // Can't use DirSearch because it expects to open and close the
    // thread state DBPOS. In this case we already have one.
    // Set fDSA to search config container

    pTHS->fDSA = TRUE;
    __try {
        SearchBody( pTHS, &SearchArg, &SearchRes, 0 );
    } __finally {
        pTHS->fDSA = fDSASave;
    }

    SearchRes.CommRes.errCode = pTHS->errCode;
    SearchRes.CommRes.pErrInfo = pTHS->pErrInfo;

    if (  0 == pTHS->errCode )
    {
        DWORD i;
        ENTINFLIST *pEntInfList;

        DPRINT2( 1, "Domain %ws can be sourced from %d servers in this site.\n",
                 pdnDomain->StringName, SearchRes.count );

        // Find atleast one system not ourself
        pEntInfList = &(SearchRes.FirstEntInf);
        for( i = 0; i < SearchRes.count; i++ ) {
            Assert( pEntInfList );
            if (!NameMatched( gAnchor.pDSADN, pEntInfList->Entinf.pName )) {
                // CODE.IMPROVEMENT: check whether source DSA is up
                fFoundOne = TRUE;
                break;
            }
            pEntInfList = pEntInfList->pNextEntInf;
        }
    }
    else
    {
        //
        // This is an unexpected condition
        //
        LogUnhandledError( pTHS->errCode );
        LogUnhandledError( DirErrorToWinError( pTHS->errCode, &(SearchRes.CommRes) ) );
    }

    THClearErrors();

    return fFoundOne;
} /* CheckDomainHasSourceInSite */


BOOL
CheckReadOnlyFullSyncOnce(
    THSTATE *pTHS,
    BOOL fStartup
    )

/*++

Routine Description:

This routine verifies that
    for each partial NCs that this server holds,
        It has fully synced once

Note that there may be a window where the config nc says there are more or
less partitions in the enterprise than what is listed on the nc head.
We ignore these.

Assume we have a thread state and PTHS->pDB is valid

Arguments:

    pTHS - thread state
    fStartup - whether is promotion is at startup or not

Return Value:

    BOOL - true, all conditions satisified
           false, try again later

    Exceptions raised on failure

--*/

{
    DWORD ulRet, level;
    DSNAME *pNC;
    BOOL fSatisfied;
    DWORD dwGCPartitionOccupancy;
    DWORD dwTotalExpected, dwTotalPresent, dwTotalFullSynced;
    DWORD dwTotalInSite, dwPresentInSite, dwFullSyncInSite;
    DWORD fInSite;
    DSNAME **ppNCs = NULL;
    DWORD cNCsInUse = 0, cNCsAlloc = 0;
    CROSS_REF_LIST *pCRL;

    // We used to distinguish between the startup and non-startup cases here.
    // Due to the sequence of operations at startup, it is possible for the
    // non-startup case (triggered by dsa modification) may be put into the
    // task queue before the startup case (triggered by init syncs finishing)
    // has a chance to run. This may result in this routine being run twice,
    // the second time occuring on a system which has already successfully
    // promoted.  That case is identical to the case of rebooting an existing,
    // GC, and we simply return success.

    if (gfWasPreviouslyPromotedGC) {
        // Completed gc promotion before
        // "Once a GC, always a GC"
        // This is essentially a grandfather clause rule which says we will
        // never disable a working GC on reboot.  Since GC's are so essential
        // we can't risk taking out their only one.  Thus we tradeoff GC
        // availability for global knowledge completeness.
        return TRUE;
    }

    dwTotalExpected = 0;
    dwTotalPresent = 0;
    dwTotalFullSynced = 0;
    dwTotalInSite = 0;
    dwPresentInSite = 0;
    dwFullSyncInSite = 0;

    // Build the array of NCs to check first so we don't hold references to
    // the anchor for too long, especially under stress.
    for (pCRL = gAnchor.pCRL; pCRL != NULL; pCRL = pCRL->pNextCR) {
        // We are not interested in non domain partitions
        if ((pCRL->CR.flags & FLAG_CR_NTDS_DOMAIN) == 0) {
            continue;
        }
        if (cNCsInUse == cNCsAlloc) {
            if (ppNCs == NULL) {
                cNCsAlloc = 16;
                ppNCs = THAllocEx( pTHS, cNCsAlloc * sizeof( DSNAME * ) );
            } else {
                cNCsAlloc *= 2;
                ppNCs = THReAllocEx( pTHS, ppNCs, cNCsAlloc * sizeof( DSNAME * ) );
            }
        }
        // ppNCs[cNCsInUse] = pCRL->CR.pNC;
        ppNCs[cNCsInUse] = THAllocEx( pTHS, pCRL->CR.pNC->structLen );
        memcpy( ppNCs[cNCsInUse], pCRL->CR.pNC, pCRL->CR.pNC->structLen );
        cNCsInUse++;
    }

    // Search the config container for naming contexts that should be on this machine

    BeginDraTransaction(SYNC_READ_ONLY);
    __try {

        DWORD iNC;

        for (iNC = 0; iNC < cNCsInUse; iNC++ ) {

            DSNAME *pNC = ppNCs[iNC];
            BOOL fHasSources = FALSE, fHasUTDVec = FALSE;
            SYNTAX_INTEGER it;

            // are we being signalled to shutdown?
            if (eServiceShutdown) {
                DRA_EXCEPT(DRAERR_Shutdown, 0);
            }

            // It is expected to eventually be present on this GC.
            dwTotalExpected++;

            // Are any sources in site?
            if (CheckDomainHasSourceInSite( pTHS, pNC )) {
                dwTotalInSite++;
                fInSite = TRUE;
            } else {
                fInSite = FALSE;
            }

            // Check for NC alive and instantiated

            ulRet = FindNC(pTHS->pDB, pNC,
                           FIND_MASTER_NC | FIND_REPLICA_NC, &it);
            DPRINT2( 2, "FindNC(%ws) = %d\n", pNC->StringName, ulRet );
            if (ulRet) {
                // Tell the user the problem
                DPRINT1( 0, "Warning: NC %ws is not present on this server yet.\n",
                         pNC->StringName );

      LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_ADUPD_GC_NC_MISSING, 
                         szInsertDN(pNC),
                         NULL,
                         NULL);

                continue;
            }

            // Writable partitions aren't included
            if (FMasterIt(it)) {
                dwTotalExpected--;
                if (fInSite) {
                    dwTotalInSite--;
                }
                continue;
            }

            dwTotalPresent++;

            if ( fInSite ) {
                dwPresentInSite++;
            }

            // REPS-FROM present on RO NC indicates not being deleted
            fHasSources = DBHasValues( pTHS->pDB, ATT_REPS_FROM );
            // UTDVECTOR present indicates successfull sync
            fHasUTDVec = DBHasValues( pTHS->pDB, ATT_REPL_UPTODATE_VECTOR );

            if (fHasSources && fHasUTDVec && !(it &(IT_NC_COMING | IT_NC_GOING))) {
                dwTotalFullSynced++;
                if ( fInSite ) {
                    dwFullSyncInSite++;
                }
            } else {
                // Tell the user the problem
      ULONG cbRepsFrom = 0;
      REPLICA_LINK * pRepsFrom = NULL;
      ULONG ulRepsFrom = 0;
      ATTCACHE *pAC = NULL;  
      CHAR pszLastAttempt[SZDSTIME_LEN + 1];

      pAC = SCGetAttById(pTHS, ATT_REPS_FROM);
                if (!pAC) {
                    DRA_EXCEPT(DRAERR_InternalError, DIRERR_ATT_NOT_DEF_IN_SCHEMA);
                }

      while (!DBGetAttVal_AC(pTHS->pDB, ++ulRepsFrom, pAC, 0,
                   0, &cbRepsFrom,
                   (BYTE **) &pRepsFrom)) {  
          LPWSTR pszDSA = NULL;
          LPWSTR pszTransport = NULL;
          Assert(1 == pRepsFrom->dwVersion);

          // potentially fix repsfrom version &  recalc size
          pRepsFrom = FixupRepsFrom(pRepsFrom, &cbRepsFrom);
          
          pszTransport = GetTransportDisplayName(pTHS, &(pRepsFrom->V1.uuidTransportObj));  
          pszDSA = GetNtdsDsaDisplayName(pTHS, &(pRepsFrom->V1.uuidDsaObj));

          if ((pRepsFrom->V1.ulResultLastAttempt==0) || (0 == pRepsFrom->V1.cConsecutiveFailures)) {  
         LogEvent8(DS_EVENT_CAT_GLOBAL_CATALOG,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_ADUPD_NC_SYNC_PROGRESS,
              szInsertDN(pNC),
              szInsertWC(pszDSA),
              pszTransport ? szInsertWC(pszTransport) : szInsertDsMsg(DIRLOG_RPC_MESSAGE),
              szInsertUSN(pRepsFrom->V1.usnvec.usnHighObjUpdate),
              szInsertDSTIME(pRepsFrom->V1.timeLastAttempt,pszLastAttempt),
              szInsertUL(pRepsFrom->V1.ulResultLastAttempt),
              szInsertWin32Msg(pRepsFrom->V1.ulResultLastAttempt),
              NULL);
         DPRINT4( 0, 
             "GC Sync'ed and didn't complete\n\tNC=%S\n\tServer=%S(via %S)\n\tUSN=%d\n",
             pNC->StringName,
             pszDSA,
             pszTransport,    
             pRepsFrom->V1.usnvec.usnHighObjUpdate);
          }
          else
          {
         LogEvent8(DS_EVENT_CAT_GLOBAL_CATALOG,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_ADUPD_NC_SYNC_NO_PROGRESS,
              szInsertDN(pNC),
              szInsertWC(pszDSA),
              pszTransport ? szInsertWC(pszTransport) : szInsertDsMsg(DIRLOG_RPC_MESSAGE),
              szInsertUSN(pRepsFrom->V1.usnvec.usnHighObjUpdate),
              szInsertDSTIME(pRepsFrom->V1.timeLastAttempt,pszLastAttempt),
              szInsertUL(pRepsFrom->V1.cConsecutiveFailures),
              szInsertUL(pRepsFrom->V1.ulResultLastAttempt),
              szInsertWin32Msg(pRepsFrom->V1.ulResultLastAttempt));
         DPRINT5( 0, 
             "GC Sync Failed\n\tNC=%S\n\tServer = %S(via %S)\n\tError=%d\n\tAttempts=%d\n",
             pNC->StringName,
             pszDSA,
             pszTransport,
             pRepsFrom->V1.ulResultLastAttempt,
             pRepsFrom->V1.cConsecutiveFailures);
          }
            
          if (pszDSA) {
         THFreeEx(pTHS,pszDSA);
          }
          if (pszTransport) {
         THFreeEx(pTHS,pszTransport);
          }
          // else error message
          if (pRepsFrom) {
         THFreeEx(pTHS,pRepsFrom);
          }
          cbRepsFrom=0;

      }  

      DPRINT1( 0, "Warning: NC %ws has not fully synced once yet.\n",
          pNC->StringName ); 
            }
        }



    } _finally {
        EndDraTransaction(!AbnormalTermination());
    }

    // If an error occurred in the above detection loop, an exception will
    // have been raised, returning control to the caller.

    // Get the occupancy requirement
    dwGCPartitionOccupancy = GC_OCCUPANCY_DEFAULT;

    GetConfigParam(GC_OCCUPANCY, &dwGCPartitionOccupancy, sizeof(DWORD));

    // ensure we're not past the limits
    if ( dwGCPartitionOccupancy > GC_OCCUPANCY_MAX ) {
        dwGCPartitionOccupancy = GC_OCCUPANCY_MAX;
    }

    DPRINT1( 1, "GC Domain Occupancy: Level:%d\n", dwGCPartitionOccupancy);
    DPRINT3( 1, "  INSITE:   Expected:%d, Present:%d, FullSynced:%d\n",
                dwTotalInSite, dwPresentInSite, dwFullSyncInSite);
    DPRINT3( 1, "  INFOREST: Expected:%d, Present:%d, FullSynced:%d\n",
                dwTotalExpected, dwTotalPresent, dwTotalFullSynced);

    // Are there other domains to acquire? If not, we're done!
    if (dwTotalExpected == 0) {
        return TRUE;
    }

    fSatisfied = TRUE;

    for( level = (GC_OCCUPANCY_MIN + 1);
         (level < (GC_OCCUPANCY_MAX + 1) );
         level++ ) {

        if (level > dwGCPartitionOccupancy) {
            // We have exceeded the occupancy requirement
            break;
        }
        switch (level) {
// 1 - Atleast one readonly nc was added
        case GC_OCCUPANCY_ATLEAST_ONE_ADDED:
            fSatisfied = (dwTotalPresent > 0);
            break;
// 2 - At least one nc synced fully
        case GC_OCCUPANCY_ATLEAST_ONE_SYNCED:
            fSatisfied = (dwTotalFullSynced > 0);
            break;
// 3 - All ncs have been added (at least one synced) IN SITE
        case GC_OCCUPANCY_ALL_IN_SITE_ADDED:
            fSatisfied = (dwPresentInSite == dwTotalInSite);
            break;
// 4 - All nc's synced fully IN SITE
        case GC_OCCUPANCY_ALL_IN_SITE_SYNCED:
            fSatisfied = (dwFullSyncInSite == dwTotalInSite);
            break;
// 5 - All ncs have been added (at least one synced) IN FOREST
        case GC_OCCUPANCY_ALL_IN_FOREST_ADDED:
            fSatisfied = (dwTotalPresent == dwTotalExpected);
            break;
// 6 - All nc's synced fully IN FOREST
        case GC_OCCUPANCY_ALL_IN_FOREST_SYNCED:
            fSatisfied = (dwTotalFullSynced == dwTotalExpected);
            break;
        default:
            Assert( FALSE );
        }
        if (!fSatisfied) {
            break;
        }
    }

    if (!fSatisfied) {
        DPRINT2( 0, "Warning: GC Occupancy requirement not met: requirement is %d; current level is %d\n",
                 dwGCPartitionOccupancy, level - 1 );
        LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_GC_OCCUPANCY_NOT_MET,
                 szInsertUL(dwGCPartitionOccupancy),
                 szInsertUL(level - 1),
                 NULL);
        if ( dwTotalExpected > dwTotalInSite ) {
            //
            // There's at least one NC w/ no intra-site sources.
            // Tell admin to expect the delay until we get a
            // scheduled sync from those sources.
            //
            LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_GC_NO_INTRA_SITE_SOURCES,
                     szInsertUL(dwGCPartitionOccupancy),
                     szInsertUL(level - 1),
                     NULL);
        }
    }

    // Cleanup
    if (ppNCs) {
        DWORD iNC;
        for( iNC = 0; iNC < cNCsInUse; iNC++ ) {
            if (ppNCs[iNC]) {
                THFreeEx(pTHS,ppNCs[iNC]);
            }
        }
        THFreeEx(pTHS,ppNCs);
    }

    return fSatisfied;

} /* CheckReadOnlyFullSyncOnce */


void
CheckGCPromotionProgress(
    IN  void *  pvParam,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )

/*++

Routine Description:

Task queue function to see if all the readonly NCs are here.
When they are, finish GC promotion

Arguments:

    pvParam -
    ppvParamNextIteration -
    pcSecsUntilNextIteration -

Return Value:

    None

Remarks:

    Exceptions are raised out of this function.
    The task queue manager will ignore most of these.

    Multi-Thread Limitation: This function cannot execute
    in parallel with itself, nor it does, should, or would.

--*/

{
    THSTATE *pTHS = pTHStls;
    DWORD ulRet = 0;
    BOOL fStartup;
    BOOL fResched = TRUE;
    BOOL fGcDsa = FALSE;
    BOOL fGiveup = FALSE;       // for debugging only
    DWORD       dwOptions = 0;
    DWORD       cbOptions;
    DWORD *     pdwOptions = &dwOptions;

    // static: valid during entire program lifetime (w/ function scope).
    static DWORD dwStartGcPromotionTime = 0;
    static DWORD dwFailedAttempts = 0;

    fStartup = (BOOL)(pvParam != NULL);

    DPRINT( 1, "CheckGCPromotionProgress\n" );

    if (!dwStartGcPromotionTime) {
        //
        // dwStartGcPromotionTime marks the time at which the promotion
        // has started (typically, the time one set the ntdsDsa
        // options = 1). It is used to potentially short a delayed
        // promotion & force it to complete.
        //
        // Here, we're setting the initial time at which the promotion has
        // started, and reset failed attempts count.
        //
        dwStartGcPromotionTime = GetTickCount();
        dwFailedAttempts = 0;
    }

    __try {

   EnterCriticalSection(&csGCState);
   __try { 

       __try {

      //
      // Check GC conditions:
      //  - read & test ntdsDSa's options.
      //  - see if inbound repl is disabled or the
      //    promotion request has been reverted meanwhile.
      // 

      BeginDraTransaction(SYNC_READ_ONLY);
      __try {

          // Find the DSA object

          if (ulRet = DBFindDSName(pTHS->pDB, gAnchor.pDSADN)) {
         DRA_EXCEPT (DRAERR_InternalError, ulRet);
          }

          if ( 0 != DBGetAttVal( pTHS->pDB, 1, ATT_OPTIONS,
                  DBGETATTVAL_fCONSTANT, sizeof( dwOptions ),
                  &cbOptions, (unsigned char **) &pdwOptions ) ) {
         dwOptions = 0; // 'salright -- no options set
          }
      } _finally {
          EndDraTransaction(!AbnormalTermination());
      }

      fGcDsa = (dwOptions & NTDSDSA_OPT_IS_GC) != 0;

      if (!fGcDsa) {
          //
          // Options indicate that we do not wish to become a GC any longer.
          //
          DPRINT( 0, "CheckGCPromotionProgress: No longer wish to be a GC: task exiting...\n" );
          fResched = FALSE;  // do not reschedule
          if ( !gAnchor.fAmGC ) {
         // Demotion already noted. nothing to do.
         // Just exit.
         __leave;
          }
      } else {

          //
          // GC promotion required.
          // Test conditions for promotion state:
          //  - User promotion force via DelayAdvertisement regkey
          //  - CheckReadOnlyFullSyncOnce
          //

          DWORD dwGCDelayAdvertisement = DEFAULT_GC_DELAY_ADVERTISEMENT;

          // Check if user requested override of delay feature
          // Can be used to abort the task as well since it is read each time.
          // The time we started promotion is recorded in dwStartGcPromotionTime.
          // If the elapsed time of the delay is greater than the delay limit, abort.
          GetConfigParam(GC_DELAY_ADVERTISEMENT, &dwGCDelayAdvertisement, sizeof(DWORD));
          if ( (DifferenceTickTime( GetTickCount(), dwStartGcPromotionTime) / 1000) >
          dwGCDelayAdvertisement ) {
         // No delay, do it right away
         DPRINT( 0, "GC advertisement delay aborted. Promotion occurring now.\n" );
         LogEvent(DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_GC_PROMOTION_CHECKS_DISABLED,
             szInsertUL(dwGCDelayAdvertisement / 60),
             szInsertUL(dwGCDelayAdvertisement % 60),
             NULL);
         fResched = FALSE;
          }
          else {
         fResched = !CheckReadOnlyFullSyncOnce( pTHS, fStartup );
          }
      }

      //
      // Done checking conditions.
      // Now, if no re-scheduling is required, update GC marks.
      //
      if (!fResched) {
          // Do not reschedule task.
          // Update GCness marks right now.
          // Note: this can apply both to promotion & demotion.
          ulRet = UpdateGCAnchorFromDsaOptions( fStartup );
          if ( !gAnchor.fAmGC && fGcDsa){
         //
         // We're still not a GC and ntdsDsaOptions claim that we should be.
         // Thus, we failed to update the GC marks when we should succeed.
         // Note: we really care about fAmGC, rather then the error code.
         // The error code is used only for the log.
         //
         Assert(!"Failed to updated GC marks although we should be ready for it.\n");

         if ( dwFailedAttempts >= MAX_GC_PROMOTION_ATTEMPTS ) {
             //
             // Failed to promote too many times.
             // Quit trying & notify user.
             //
             LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_GC_PROMOTION_FAILED,
                 szInsertUL(dwFailedAttempts),
                 szInsertUL(ulRet),
                 szInsertWin32Msg(ulRet));
             dwFailedAttempts = 0;
             Assert(fResched == FALSE); // give up.
             fGiveup = TRUE;            // for debugging  only (see assert below)
         }
         else {
             //
             // Failed to promote.
             // Try up to MAX_GC_PROMOTION_ATTEMPTS times.
             //
             dwFailedAttempts++;
             fResched = TRUE;        // re-try
         }
          }
      }

       } __finally {

      if ( fResched ) {
          //
          // Reschedule task
          //
          DPRINT1(0, "GC Promotion being delayed for %d minutes.\n",
             (SYNC_CHECK_PERIOD_SECS / 60) );
          LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_GC_PROMOTION_DELAYED,
              szInsertUL(SYNC_CHECK_PERIOD_SECS / 60),
              NULL,
              NULL);
          // Events about retrying are logged in helper function
          if ( NULL != ppvNext ) {
         // called by Task Scheduler; reschedule in-place
         *ppvNext = pvParam;
         *pcSecsUntilNextIteration = SYNC_CHECK_PERIOD_SECS;
          } else {
         // not called by Task Scheduler; must insert new task
         InsertInTaskQueueSilent(
             TQ_CheckGCPromotionProgress,
             pvParam,
             SYNC_CHECK_PERIOD_SECS,
             TRUE);
          }
      } else {
          //
          // Don't Reschedule
          // Reasons:
          //  - GC promotion has completed fine
          //  - or No longer wish to be a GC.
          //  - or disabled inbound repl.
          //  - or giving up promotion attempt.
          // reset start-delay marker (for next re-promotion)
          Assert( gAnchor.fAmGC                                  ||
             ((dwOptions & NTDSDSA_OPT_IS_GC) == 0)         ||
             (dwOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL) ||
             fGiveup );
          dwStartGcPromotionTime = 0;
      }
       }

   }
   __finally {
       LeaveCriticalSection(&csGCState);
   }
    }
    __except (GetDraException((GetExceptionInformation()), &ulRet)) {
        DPRINT1( 0, "Caught exception %d in task queue function CheckGCPromotionProgress\n", ulRet );
        LogUnhandledError( ulRet );
    }

} /* CheckGCPromotion */


DWORD
DraUpgrade(
    THSTATE     *pTHS,
    LONG        lOldDsaVer,
    LONG        lNewDsaVer
    )
/*++

Routine Description:

    Perform DRA Upgrade related operations upon Dsa version upgrade.

    This function is called within the same transaction as the version upgrade
    write. Failure to conduct the operation will result w/ the entire write
    failing. Thus be careful when you decide to fail this.

Arguments:

    pTHS - Thread state
    lOldDsaVer - Old DSA version prior to upgrade
    lNewDsaVer - New DSA version that's going to get commited


Return Value:
    Error in DRAERR error space
    ** Warning: Error may fail DSA installation **

Remarks:
    Assumes pTHS->pDB is on the nTDSdSA object
    Opens a temporary DB cursor.

--*/
{

    DWORD dwErr = ERROR_SUCCESS;
    DBPOS *pDBTmp = NULL;
    ULONG NthValIndex = 0;
    SYNTAX_INTEGER it;
    DSNAME *pNC = NULL;
    ULONG InDnt = pTHS->pDB->DNT;
    ULONG len = 0;
    BOOL fDRASave = pTHS->fDRA;


    Assert(pTHS->JetCache.transLevel > 0);
    Assert(lOldDsaVer < lNewDsaVer);

    if ( DS_BEHAVIOR_WIN2000 == lOldDsaVer ) {
        //
        // Perform all actions upon upgrade FROM Win2K
        //

        //
        // Eliminate stale RO NCs
        //

        // Set up the temporary pDB
        DBOpen (&pDBTmp);
        __try {

            // For each RO NC that we replicate,
            // Find its sources. If no sources exist,
            // mark it for demotion.
            //

            while (!(DBGetAttVal(pTHS->pDB,
                                 ++NthValIndex,
                                 ATT_HAS_PARTIAL_REPLICA_NCS,
                                 0,
                                 0, &len, (PUCHAR *)&pNC))) {

                // seek to NC over temp DBPOS & get its instanceType
                if (dwErr = FindNC(pDBTmp,
                                   pNC,
                                   FIND_REPLICA_NC,
                                   &it)) {
                    // this isn't worth aborting the upgrade over
                    // so mark as success, but assert to notify
                    // developer
                    Assert(!"Failed to find RO NC as specified in ntdsDsa object");
                    dwErr = ERROR_SUCCESS;
                    __leave;
                }

                // If we find that the RO NC has no sources,
                // set the IT_NC_GOING bit.
                //
                if ( !(it & IT_NC_GOING) &&
                     !DBHasValues(pDBTmp, ATT_REPS_FROM)) {

                    // set DRA context
                    pTHS->fDRA = TRUE;

                    DPRINT1(0, "Marking sourceless read-only NC %ls for"
                               " tear down.\n",
                            pNC->StringName);
                    __try {
                        it = (it & ~IT_NC_COMING) | IT_NC_GOING;
                        if (dwErr = ChangeInstanceType(pTHS, pNC, it, DSID(FILENO,__LINE__))) {
                            // this isn't worth aborting the upgrade
                            // so mark as success
                            Assert(!"Failed to change Instance Type for RO NC");
                            dwErr = ERROR_SUCCESS;
                            __leave;
                        }
                    } __finally {
                        // restore DRA context
                        pTHS->fDRA = fDRASave;
                        // restore dnt
                        if (pTHS->pDB->DNT != InDnt) {
                            // seek back to ntdsDsa dnt
                            if (dwErr = DBFindDNT(pTHS->pDB, InDnt)) {
                                // impossible. Abort.
                                DRA_EXCEPT (DRAERR_DBError, dwErr);
                            }   // restore dnt
                        }       // dnt was moved
                    }           // finally

                }               // need to change instance type
            }                   // for each RO NC
        }
        __finally {

            // Close the temporary pDB
            DBClose (pDBTmp, !AbnormalTermination());
        }

        // RO source resolution isn't important enough
        // to kill the upgarde
        Assert(dwErr == ERROR_SUCCESS);

    }       // end of win2k upgrade

    return dwErr;
}


void
CheckInstantiatedNCs(
    IN  void *  pvParam,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )

/*++

Routine Description:

    Taskq wrapper for check instantiated nc's function

    // Make sure the NC exists consistently on
    // the msds-HasInsatantiatedNCs NC list.
    // If it isn't, or it's instanceType is different
    // add it. Otherwise, no-op.
    // Note that AddNCtoDsa->AddInstantiatedNC doesn't run when the DSA is
    // installing.  Thus we need to update this attribute on reboot after install.

    Executed once on success. Reschedules itself on error.

    No exceptions raised out of this function.

Arguments:

    pvParam - 
    ppvNext - 
    pcSecsUntilNextIteration - 

Return Value:

    None

--*/

{
    THSTATE *pTHS = pTHStls;
    DWORD dwErr = 0, i;
    ULONG len = 0;
    DBPOS *pDBTmp;
    DSNAME *pNC = NULL;
    SYNTAX_INTEGER it;
    BOOL fCommit = FALSE;

    DPRINT( 1, "CheckInstantiatedNCs\n" );

    BeginDraTransaction(SYNC_WRITE);
    __try {
        // Find the DSA object
        if (dwErr = DBFindDSName(pTHS->pDB, gAnchor.pDSADN)) {
            DRA_EXCEPT (DRAERR_InternalError, dwErr);
        }

        // Set up the temporary pDB
        DBOpen (&pDBTmp);
        __try {

            // For writeable and readonly NCs...

            for (i = 0; i < ARRAY_SIZE(gAtypeCheck); i++) {
                ULONG NthValIndex = 0;

                // For each NC that we hold locally...

                while (!(DBGetAttVal(pTHS->pDB,
                                     ++NthValIndex,
                                     gAtypeCheck[i].AttrType,
                                     0,
                                     0, &len, (PUCHAR *)&pNC))) {

                    if (dwErr = FindNC(pDBTmp,
                                       pNC,
                                       gAtypeCheck[i].ulFindNCFlags,
                                       &it)) {
                        DRA_EXCEPT(DRAERR_InconsistentDIT, dwErr);
                    }

                    dwErr = AddInstantiatedNC(pTHS, pTHS->pDB, pNC, it);
                    if (dwErr) {
                        DPRINT3( 0, "AddInstantiatedNC(%ws,%d) failed with %d\n",
                                 pNC->StringName, it, dwErr );
                        DRA_EXCEPT(DRAERR_InconsistentDIT, dwErr);
                    }
                    dwErr = DBRepl( pTHS->pDB,pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING);
                    if (dwErr) {
                        DPRINT1( 0, "DBRepl() failed with %d\n", dwErr );
                        DRA_EXCEPT(DRAERR_InconsistentDIT, dwErr);
                    }

                } // while

            } // for

            fCommit = TRUE;
            Assert( !dwErr );
        } __finally {
            // Close the temporary pDB
            DBClose (pDBTmp, fCommit );
        }
    }
    __except (GetDraException((GetExceptionInformation()), &dwErr)) {
        if (dwErr != DRAERR_Busy) {
            DPRINT1( 0, "Caught exception %d in task queue function CheckInstantiatedNCs\n", dwErr );
            LogUnhandledError( dwErr );
        }
    }
    EndDraTransaction( fCommit );

    // Reschedule if failure
    if (!fCommit) {
        // called by Task Scheduler; reschedule in-place
        Assert( NULL != ppvNext );
        *ppvNext = pvParam;
        *pcSecsUntilNextIteration = CHECK_INSTANTIATED_NCS_PERIOD_SECS;
    }

} /* CheckInstantiatedNCs */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\draexist.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       draexist.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Defines DRS object existence functions - client and server.

Author:

    Greg Johnson (gregjohn) 

Revision History:

    Created     <03/04/01>  gregjohn

--*/
#include <NTDSpch.h>
#pragma hdrstop

#include <attids.h>
#include <ntdsa.h>
#include <dsjet.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

#include "dsevent.h"
#include "mdcodes.h"

#include "drs.h"
#include "objids.h"
#include "anchor.h"
#include <drserr.h>                     // for DRA errors
#include <dsexcept.h>                   // for GetDraExcpetion
#include "drautil.h"
#include "drancrep.h"
#include "drameta.h"
#include "ntdsctr.h"                    // for INC and DEC calls to perf counters


#include "debug.h"              // standard debugging header
#define DEBSUB "DRAEXIST:"       // define the subsystem for debugging

#include "drarpc.h"                     // for ReferenceContext and DereferenceContext
#include "drsuapi.h"
#include "drauptod.h"
#include <crypto\md5.h>                 // for Md5

#include "dsconfig.h"
#include "draaudit.h"

#include <fileno.h>
#define  FILENO FILENO_DRAEXIST

#define OBJECT_EXISTENCE_GUID_NUMBER_PER_PACKET 1000

#if DBG
#define DPRINT1GUID(x,y,z) DPRINT1Guid(x,y,z)
DPRINT1Guid(
    USHORT        Verbosity,
    LPSTR         Message,
    GUID          guid
    )
    {
	RPC_STATUS rpcStatus = RPC_S_OK;
	LPWSTR pszGuid = NULL;
	rpcStatus = UuidToStringW(&guid, &pszGuid);
	if (rpcStatus==RPC_S_OK) {
	    DPRINT1(Verbosity, Message, pszGuid);
	    RpcStringFreeW(&pszGuid);
	} else {
	    DPRINT1(Verbosity, Message, L"<UNABLE TO DISPLAY GUID>");
	}
}
#else
#define DPRINT1GUID(x,y,z) 
#endif

BOOL
DraIncludeInObjectExistence(
    DBPOS *                      pDB,
    DB_ERR *                     pdbErr)
/*++

Routine Description:
    
    Check that the object pointed to by pDB is something we want to include
    in the object existence checksums.

Arguments:

    pDB - pDB should be located on object in question
    pdbErr - db_err error values

Return Values:

    TRUE - include it.  FALSE - don't include it or there was an error which
    is stored it pdbErr.

--*/
{

    ULONG instanceType;
    // currently, the only object we don't consider in this
    // code are NC head objects.  NOTE:  For an NC to be
    // lingering, the object which controls deletion of
    // an NC is the cross-ref.
    *pdbErr=DB_success;

    if ((DB_success==(*pdbErr = DBGetSingleValue(pDB,
			       ATT_INSTANCE_TYPE,
			       &instanceType,
			       sizeof(instanceType),
			       NULL)))
	&& (instanceType & IT_NC_HEAD)) {
	// this object is an NC head
	return FALSE;
    }


    if (*pdbErr==DB_success) {
	return TRUE;
    } else {
	return FALSE;
    }

}

DB_ERR
DraGetObjectExistence(
    IN  THSTATE *                pTHS,
    IN  DBPOS *                  pDB,
    IN  GUID                     guidStart,
    IN  UPTODATE_VECTOR *        pUpToDateVecCommon,
    IN  ULONG                    dntNC,
    IN OUT DWORD *               pcGuids,
    OUT  UCHAR                   Md5Digest[MD5DIGESTLEN],
    OUT GUID *                   pNextGuid, 
    OUT GUID *                   prgGuids[]
    )
/*++

Routine Description:
    
    Given a guid and NC to begin with and a UTD, return a checksum and list of guids to
    objects whose creation time is earlier than the UTD and whose objects
    are in the given NC and greater than the start guid in sort order.  Also returns
    a Guid to start the next itteration at.  If DraGetObjectExistence returns success and
    pNextGuid is gNullUuid, then there are no more Guids to iterate.

Arguments:
 
    pTHS - 
    pDB - 
    guidStart - guid to begin search
    pUpToDateVecCommon - utd to date creation times with
    Md5Digest[MD5DIGESTLEN] - returned Md5 checksum
    dntNC - dnt of NC to search
    pNextGuid - returned guid for next loop iteration
    pcGuids - on input, the max number of guids to put in list
	      on output, the number actually found 
    prgGuids[] - returned list of guids

Return Values:

    0 on success or DB_ERR on failure.  On output pNextGuid is only valid on success.

--*/
{

    INDEX_VALUE                      IV[2];
    DB_ERR                           err = 0;
    ULONG                            cGuidAssimilated = 0;
    PROPERTY_META_DATA_VECTOR *      pMetaDataVec = NULL;
    PROPERTY_META_DATA *             pMetaData = NULL;
    ULONG                            cb;
    ULONG                            ulGuidExamined = 0;
    MD5_CTX                          Md5Context;

    // verify input 
    Assert(*prgGuids==NULL);

    // initalize
    MD5Init(
	&Md5Context
	);

    // locate guids
    err = DBSetCurrentIndex(pDB, Idx_NcGuid, NULL, FALSE);
    if (err) {
	return err;
    }
    *prgGuids = THAllocEx(pTHS, *pcGuids*sizeof(GUID));

    // set nc search criteria
    IV[0].cbData = sizeof(ULONG);
    IV[0].pvData = &dntNC;
    if (!memcmp(&guidStart, &gNullUuid, sizeof(GUID))) {
	// no guid to start, so start at beginning of NC 
	err = DBSeek(pDB, IV, 1, DB_SeekGE);
    } else {
	// set guid search criteria
	IV[1].cbData = sizeof(GUID);
	IV[1].pvData = &guidStart;

	// if not found, start at guid greater in order
	err = DBSeek(pDB, IV, 2, DB_SeekGE);
    }

    // while we want to examine more guids
    //       and we have no error (including errors of no objects left)
    //       and we are in the correct NC
    while ((cGuidAssimilated < *pcGuids) && (!err) && (pDB->NCDNT==dntNC)) { 
	// first, is this an object we want to include in our search?
	if (DraIncludeInObjectExistence(pDB, &err)) {

	    // get the meta data of the objects
	    err = DBGetAttVal(pDB, 
			      1, 
			      ATT_REPL_PROPERTY_META_DATA,
			      0, 
			      0, 
			      &cb, 
			      (LPBYTE *) &pMetaDataVec);


	    if (err==DB_success) { 
		pMetaData = ReplLookupMetaData(ATT_WHEN_CREATED,
					       pMetaDataVec, 
					       NULL);

		if (pMetaData==NULL) {
		    Assert(!"Object must have metadata");
		    err = DB_ERR_UNKNOWN_ERROR;
		}
		else { 
		    if (!UpToDateVec_IsChangeNeeded(pUpToDateVecCommon,
						    &pMetaData->uuidDsaOriginating,
						    pMetaData->usnOriginating)) {
			// guid is within the Common utd, copy it into the list and update the digest

			Assert(cGuidAssimilated < *pcGuids);

			// add guid to the list
			GetExpectedRepAtt(pDB, ATT_OBJECT_GUID, &((*prgGuids)[cGuidAssimilated]), sizeof(GUID) );  

			// update the digest
			MD5Update(
			    &Md5Context,
			    (PBYTE) &((*prgGuids)[cGuidAssimilated]),
			    sizeof(GUID)
			    );    

			DPRINT2(1, "OBJECT EXISTENCE:  Assimilating:(%d of %d) - ", cGuidAssimilated, ulGuidExamined);
			DPRINT1GUID(1, "%S\n", (*prgGuids)[cGuidAssimilated]);
			cGuidAssimilated++;
		    }
		    else {
			GUID tmpGuid;
			GetExpectedRepAtt(pDB, ATT_OBJECT_GUID, &tmpGuid, sizeof(GUID) );
			DPRINT1GUID(1, "OBJECT EXISTENCE:  Object (%S) not within common UTD\n", tmpGuid); 
		    }
		    ulGuidExamined++;
		}
	    }
	    if (pMetaDataVec!=NULL) {
		THFreeEx(pTHS, pMetaDataVec);
		pMetaDataVec = NULL;
	    }
	}
	if (err==DB_success) {
	    // move to the next guid
	    err = DBMove(pDB, FALSE, DB_MoveNext);
	}
    }

    // find the next value to examine for the next iteration
    if ((!err) && (pDB->NCDNT==dntNC)) { 
	GetExpectedRepAtt(pDB, ATT_OBJECT_GUID, pNextGuid, sizeof(GUID) );
    }
    else if ((err==DB_ERR_RECORD_NOT_FOUND) || (err==DB_ERR_NO_CURRENT_RECORD)) {
	// no more values to examine
	err = ERROR_SUCCESS; 
	memcpy(pNextGuid, &gNullUuid, sizeof(GUID));
    }
    else {
	memcpy(pNextGuid, &gNullUuid, sizeof(GUID));
    }

    // set return variables
    *pcGuids = cGuidAssimilated;

    Assert((cGuidAssimilated != 0) ||
	   0==memcmp(pNextGuid, &gNullUuid, sizeof(GUID)));

    MD5Final(
	&Md5Context
	);
    memcpy(Md5Digest, Md5Context.digest, MD5DIGESTLEN*sizeof(UCHAR));

    return err;
}

#define LOCATE_GUID_MATCH (0)
#define LOCATE_OUT_OF_SCOPE (1)
#define LOCATE_NOT_FOUND (2)

DWORD
LocateGUID(
    IN     GUID                    guidSearch,
    IN OUT ULONG *                 pulPosition,
    IN     GUID                    rgGuids[],
    IN     ULONG                   cGuids
    )
/*++

Routine Description:
    
    Given a guid, a list of sorted guids, and a position in the list
    return TRUE if the guid is found forward from position, else return
    false.  Update pulPosition to reflect search (for faster subsequent searches)
    
    WARNING:  This routine depends upon the Guid sort order returned from
    a JET index.  It doesn't follow the external definition of UuidCompare, but
    instead uses memcmp.  If this sort order ever changes, this function MUST
    be updated.  

Arguments:

    guidSearch 		- guid to search for
    ulPositionStart 	- position in array to start searching from
    rgGuids     	- array of guids
    cGuids     		- size of array in guids

Return Values:

    true if found, false otherwise.  
    pulPostion -> position found.

--*/
{
    ULONG ul = *pulPosition;
    int compareValue = 1;
    DWORD dwReturn;

    if (cGuids==0) {
	return LOCATE_NOT_FOUND;
    }

    if (!(ul<cGuids)) {
	Assert(!"Cannot evaluate final Guid for Not Found Vs. Out of Scope");
	return LOCATE_OUT_OF_SCOPE;
    }

    while ((ul<cGuids) && (compareValue > 0)) {
	compareValue = memcmp(&guidSearch, &(rgGuids[ul++]), sizeof(GUID));  
    }    

    if (compareValue==0) {
	// found it
	dwReturn = LOCATE_GUID_MATCH;
    }
    else if (compareValue < 0) {
	// didn't find
	dwReturn = LOCATE_NOT_FOUND;
    }
    else { // ul>=cGuids - no more to search and not found
	Assert(ul==cGuids);
	dwReturn = LOCATE_OUT_OF_SCOPE;
    }
    *pulPosition = ul - 1; // last inc went too far, compensate
    return dwReturn;
}

DWORD
DraGetRemoteSingleObjectExistence(
    THSTATE *                    pTHS,
    DSNAME *                     pSource,
    DSNAME *                     pDN
    )
/*++

Routine Description:
    
    Contact pSource and verify the existence of pDN

Arguments:

    pTHS - 
    pSource - DC to verify existence upon
    pDN - object to verify existence of


Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    LPWSTR pszSource = NULL;
    DRS_MSG_VERIFYREQ msgReq;
    DRS_MSG_VERIFYREPLY msgRep;
    DWORD dwVerNamesMsgVerionOut;
    DWORD err = ERROR_SUCCESS;

    memset(&msgRep, 0, sizeof(msgRep));
    memset(&msgReq, 0, sizeof(msgReq));

    msgReq.V1.cNames=1;
    msgReq.V1.dwFlags=DRS_VERIFY_DSNAMES;
    msgReq.V1.RequiredAttrs.attrCount=1;
    msgReq.V1.RequiredAttrs.pAttr = THAllocEx(pTHS, sizeof(ATTR));
    // we just want existence, so pass a bogus attr that all objects will have (guid)
    msgReq.V1.RequiredAttrs.pAttr[0].attrTyp = ATT_OBJECT_GUID;
    msgReq.V1.rpNames = (DSNAME **) THAllocEx(pTHS, sizeof(DSNAME *));
    msgReq.V1.rpNames[0] = pDN;
    msgReq.V1.PrefixTable = ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    pszSource = GuidBasedDNSNameFromDSName(pSource);

    err = I_DRSVerifyNames(pTHS, 
			   pszSource, 
			   NULL, 
			   1, 
			   &msgReq, 
			   &dwVerNamesMsgVerionOut, 
			   &msgRep);

    err = err!=ERROR_SUCCESS ? err : msgRep.V1.error;

    if (msgRep.V1.cNames<1) {
	err = ERROR_GEN_FAILURE;
    }

    if (err==ERROR_SUCCESS) { 
	Assert(msgRep.V1.cNames==1);
       
	if (msgRep.V1.rpEntInf[0].pName==NULL) {
	    err = ERROR_DS_OBJ_NOT_FOUND; 
	} else {
	    // object exists!
	    #if DBG
	    // compare the dn's just in case:
	    if (!NameMatched(pDN, msgRep.V1.rpEntInf[0].pName)) {
		Assert(!"I_DRSVerifyNames failure!\n");
	    }
	    #endif
	    err = ERROR_SUCCESS;
	}
    } 

    THFreeEx(pTHS, msgReq.V1.RequiredAttrs.pAttr);
    THFreeEx(pTHS, msgReq.V1.rpNames);
    if (pszSource) {
	THFreeEx(pTHS, pszSource);
    }
    
    return err;
}

DWORD
DraGetRemoteObjectExistence(
    THSTATE *                    pTHS,
    LPWSTR                       pszServer,
    ULONG                        cGuids,
    GUID                         guidStart,
    UPTODATE_VECTOR *            putodCommon,
    DSNAME *                     pNC,
    UCHAR                        Md5Digest[MD5DIGESTLEN],
    OUT BOOL *                   pfMatch,
    OUT ULONG *                  pcNumGuids,
    OUT GUID *                   prgGuids[]
    )
/*++

Routine Description:
    
    Contact a DC and request Object Existence test using the inputted
    Md5Digest Checksum.  Return results (ie match or guid list)

Arguments:

    pTHS - 
    pszServer - DC to contact 
    cGuids - number of guids in object existence range
    guidStart - guid to begin at
    putodCommon - utd for object exitence
    pNC - nc for object existence
    Md5Digest[MD5DIGESTLEN] - checksum for object existence
    pfMatch - returned bool
    pcNumGuids - returned num of guids
    prgGuids - returned guids


Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    DRS_MSG_EXISTREQ             msgInExist;
    DRS_MSG_EXISTREPLY           msgOutExist;
    DWORD                        dwOutVersion = 0;
    DWORD                        ret = ERROR_SUCCESS;
    UPTODATE_VECTOR *            putodVector = NULL;

    // Call the source for it's checksum/guid list
    memset(&msgInExist, 0, sizeof(DRS_MSG_EXISTREQ));
    memset(&msgOutExist, 0, sizeof(DRS_MSG_EXISTREPLY));

    msgInExist.V1.cGuids = cGuids; 
    msgInExist.V1.guidStart = guidStart;

    // we only need V1 info, so only pass V1 info, convert
    putodVector = UpToDateVec_Convert(pTHS, 1, putodCommon);
    Assert(putodVector->dwVersion==1);
    msgInExist.V1.pUpToDateVecCommonV1 = putodVector; 
    msgInExist.V1.pNC = pNC;  
    memcpy(msgInExist.V1.Md5Digest, Md5Digest, MD5DIGESTLEN*sizeof(UCHAR));  

    // make the call
    ret = I_DRSGetObjectExistence(pTHS, pszServer, &msgInExist, &dwOutVersion, &msgOutExist);

    if ((ret==ERROR_SUCCESS) && (dwOutVersion!=1)) {
	Assert(!"Incorrect version number from GetObjectExistence!");
	DRA_EXCEPT(DRAERR_InternalError,0);
    }

    if (ret==ERROR_SUCCESS) {
	*prgGuids = msgOutExist.V1.rgGuids;
	*pcNumGuids = msgOutExist.V1.cNumGuids;

	*pfMatch=  msgOutExist.V1.dwStatusFlags & DRS_EXIST_MATCH; 
    }
    
    if (putodVector!=NULL) {
	THFreeEx(pTHS, putodVector);
    }

    return ret;
}

DWORD
DraObjectExistenceCheckDelete(
    DBPOS *                      pDB,
    DSNAME *                     pDNDelete
    )
/*++

Routine Description:
    
    Check that the object pointed to by pDB and pDNDelete is a valid
    object for ObjectExistence to delete

Arguments:

    pDB  - should be located on object
    pDNDelete - DSNAME of object (could be looked up here, but calling
		function already had this value) 

Return Values:

    0 - delete-able object
    ERROR - do not delete

--*/
{
    DWORD ret = ERROR_SUCCESS;
    ULONG IsCritical;
    ULONG instanceType;

    ret = NoDelCriticalObjects(pDNDelete, pDB->DNT);
    if (ret) {
	THClearErrors();
	ret = ERROR_DS_CANT_DELETE;
    }

    if (ret==ERROR_SUCCESS) {
	if ((0 == DBGetSingleValue(pDB,
				   ATT_IS_CRITICAL_SYSTEM_OBJECT,
				   &IsCritical,
				   sizeof(IsCritical),
				   NULL))
	    && IsCritical) {
	    // This object is marked as critical.  Fail.
	    ret = ERROR_DS_CANT_DELETE;
	}
    }

    if (ret==ERROR_SUCCESS) {
	if ((0 == DBGetSingleValue(pDB,
				   ATT_INSTANCE_TYPE,
				   &instanceType,
				   sizeof(instanceType),
				   NULL))
	    && (instanceType & IT_NC_HEAD)) {
	    // this object is an NC head
	    ret = ERROR_DS_CANT_DELETE;
	}
    }

    return ret;
}

DWORD 
DraObjectExistenceDelete(
    THSTATE *                    pTHS,
    LPWSTR                       pszServer,
    GUID                         guidDelete,
    ULONG                        dntNC,
    BOOL                         fAdvisoryMode
    )
/*++

Routine Description:
    
    If fAdvisoryMode is false, delete the object guidDelete and/or
    log this attempt/success.  Caller should enter with an open
    transaction in pTHS->pDB and the call will exit with an open
    transaction on all return values, and every attempt will be made
    to exit with a trans even if this function excepts.  

Arguments:

    pTHS - pTHS->pDB should have an open transaction.  
    pszServer - name of Source for logging
    guidDelete - guid of object to delete
    dntNC - NC of object to delete (to locate with index)
    fAdvisoryMode - if TRUE, don't delete, only log message 

Return Values:

    0 on success, Win Error on failure

--*/
{
    INDEX_VALUE                  IV[2];   
    DSNAME *                     pDNDelete = NULL;
    ULONG                        cbDNDelete;
    DWORD                        retDelete = ERROR_SUCCESS;
    DWORD                        retCommitTrans = ERROR_SUCCESS;
    DWORD                        retOpenTrans = ERROR_SUCCESS;

    DBSetCurrentIndex(pTHS->pDB, Idx_NcGuid, NULL, FALSE);
    // locate the guid in the DB
    IV[0].cbData = sizeof(ULONG);
    IV[0].pvData = &dntNC;
    IV[1].cbData = sizeof(GUID);
    IV[1].pvData = &guidDelete;
    retDelete = DBSeek(pTHS->pDB, IV, 2, DB_SeekEQ);
    if (retDelete) {
	if ((retDelete==DB_ERR_NO_CURRENT_RECORD) || (retDelete==DB_ERR_RECORD_NOT_FOUND)) {
	    // it's either an error, or it was deleted during execution.  we
	    // didn't delete it, so log that fact.
	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_LOR_OBJECT_DELETION_FAILED,
		     szInsertWC(L""),
		     szInsertUUID(&guidDelete), 
		     szInsertWC(pszServer));
	    // not a fatal error, continue...
	    return ERROR_SUCCESS;
	} else {  
	    // bad news, log this and except
	    LogEvent8(DS_EVENT_CAT_REPLICATION,
		      DS_EVENT_SEV_ALWAYS,
		      DIRLOG_LOR_OBJECT_DELETION_ERROR_FATAL,
		      szInsertUUID(&guidDelete), 
		      szInsertWC(pszServer),
		      szInsertWin32Msg(retDelete),
		      szInsertUL(retDelete),
		      NULL,
		      NULL,
		      NULL,
		      NULL);
	    DRA_EXCEPT(DRAERR_DBError, retDelete);
	}
    }

    // located object, get object DN
    cbDNDelete = 0;
    retDelete = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
		      0, 0,
		      &cbDNDelete, (PUCHAR *)&pDNDelete);
    if ((retDelete) || (pDNDelete==NULL)) {
	// bad news, log this and except 
	LogEvent8(DS_EVENT_CAT_REPLICATION,
		  DS_EVENT_SEV_ALWAYS,
		  DIRLOG_LOR_OBJECT_DELETION_ERROR_FATAL,
		  szInsertUUID(&guidDelete), 
		  szInsertWC(pszServer),
		  szInsertWin32Msg(retDelete),
		  szInsertUL(retDelete),
		  NULL,
		  NULL,
		  NULL,
		  NULL);
	DRA_EXCEPT(DRAERR_InternalError, retDelete);
    }

    if (fAdvisoryMode) { 
        if (ERROR_SUCCESS == (retDelete = DraObjectExistenceCheckDelete(pTHS->pDB,     
                                                                        pDNDelete))) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_LOR_OBJECT_DELETION_ADVISORY,
                     szInsertWC(pDNDelete->StringName),
                     szInsertUUID(&guidDelete), 
                     szInsertWC(pszServer));	      
        } else { 
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_LOR_OBJECT_DELETION_FAILED_CRITICAL_OBJECT,
                     szInsertWC(pDNDelete->StringName),
                     szInsertUUID(&(pDNDelete->Guid)), 
                     szInsertWC(pszServer)); 
        }
    } else {
	#if DBG 
	{ 
	    GUID guidDeleted;
	    GetExpectedRepAtt(pTHS->pDB, ATT_OBJECT_GUID, &guidDeleted, sizeof(GUID)); 
	    Assert(!memcmp(&guidDelete, &guidDeleted, sizeof(GUID))); 
	}
	#endif

	// Delete it
	DPRINT1GUID(1, "DELETE:  %S\n", guidDelete);

        //
        // A goal of the following code is to try and continue in the face of errors.
        // So if one object can't be deleted for some reason, we'll continue.  Now, to
        // do that, we need to track 3 things.  The success/failure of the deletion, the
        // success/failure of commiting the transaction of that deletion, and the success/
        // failure of opening a new transaction to continue.

        // if the delete and the commit aren't both success, we need to log the deletion failed.
        // if the commit and re-opening of the new transaction aren't both success, we need to bail.
        
        retDelete = DraObjectExistenceCheckDelete(pTHS->pDB,     
                                                  pDNDelete);
        
        if (retDelete!=ERROR_SUCCESS) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_LOR_OBJECT_DELETION_FAILED_CRITICAL_OBJECT,
                     szInsertWC(pDNDelete->StringName),
                     szInsertUUID(&(pDNDelete->Guid)), 
                     szInsertWC(pszServer)); 	
        } else {  
            BOOL fOrigfDRA;
            fOrigfDRA = pTHS->fDRA;  
            
            // okay, delete the object.  Store the result in retDelete.  Note that retDelete get's
            // set correctly on returns and exceptions.
            __try {
                __try {  
                    pTHS->fDRA = TRUE;
                    // Since we're going to use the fGarbCollectASAP flag to DeleteLocalObj, we
                    // need to remove the backlinks on it by hand, since they aren't removed 
                    // if this flag is set - otherwise we get dangling references to non-exitant
                    // objects
                    DBRemoveLinks(pTHS->pDB);
                    retDelete = DeleteLocalObj(pTHS, pDNDelete, TRUE, TRUE, NULL);
                }
                __finally {  
                    pTHS->fDRA = fOrigfDRA;
                } 
            } __except(GetDraException(GetExceptionInformation(), &retDelete)) {	    
                  ;
            } 
            
            // commit\uncommit this delete.  Store the result in retCommitTrans.  Note that
            // retCommitTrans get's set correctly on returns and exceptions.
            __try {
                retCommitTrans = DBTransOut(pTHS->pDB, (retDelete==ERROR_SUCCESS), TRUE);
            } __except(GetDraException(GetExceptionInformation(), &retCommitTrans)) {	    
                  ;
            } 
            
            if (retCommitTrans!=ERROR_SUCCESS) {
                // if we didn't sucesfully get out of the transaction, then our delete failed
                // if they already failed for another reason, log that, otherwise log the trans failure
                retDelete = (retDelete!=ERROR_SUCCESS) ? retDelete : retCommitTrans;
                // and we can't open another transaction if we failed to commit this one.
                retOpenTrans = retCommitTrans;
            } else {
                // okay, we committed the last one, open a new transaction.  Store it in
                // retOpenTrans.  Note that retOpenTrans get set correctly on returns and exceptions.
                __try {
                    retOpenTrans = DBTransIn(pTHS->pDB);
                } __except(GetDraException(GetExceptionInformation(), &retOpenTrans)) {	    
                      ;
                }     
            }
        }
        
        DRA_AUDITLOG_LINGERINGOBJ_REMOVAL(pTHS, pszServer, pDNDelete, 0, retDelete);

	if (retDelete==ERROR_SUCCESS) {  
	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_LOR_OBJECT_DELETION,
		     szInsertWC(pDNDelete->StringName),
		     szInsertUUID(&guidDelete), 
		     szInsertWC(pszServer));
	} else if (retDelete==ERROR_DS_CANT_DELETE) {
	    DPRINT1GUID(1,"Can't delete %S\n", guidDelete);
	    // log can't delete
	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_LOR_OBJECT_DELETION_FAILED,
		     szInsertWC(pDNDelete->StringName),
		     szInsertUUID(&guidDelete), 
		     szInsertWC(pszServer)); 
	} else if (retDelete!=ERROR_SUCCESS) {  
	    LogEvent8(DS_EVENT_CAT_REPLICATION,
		      DS_EVENT_SEV_ALWAYS,
		      DIRLOG_LOR_OBJECT_DELETION_ERROR,
		      szInsertWC(pDNDelete->StringName),
		      szInsertUUID(&guidDelete), 
		      szInsertWC(pszServer),
		      szInsertWin32Msg(retDelete),
		      szInsertUL(retDelete),
		      NULL,
		      NULL,
		      NULL);
	}       
    }
    
    if (pDNDelete!=NULL) {
	THFreeEx(pTHS, pDNDelete);
	pDNDelete = NULL;
    }

    if (retOpenTrans!=ERROR_SUCCESS) {
        // from above, retOpenTrans is the return code for having an open transaction.
        // we cannot continue if we don't have an open transaction.
        DRA_EXCEPT(retOpenTrans, retDelete);
    }
    
    // we have an open transaction.
    Assert(pTHS->pDB->transincount>0);
    Assert(IsValidDBPOS(pTHS->pDB));
    
    return retDelete;
}

DWORD				       
DraDoObjectExistenceMismatch(
    THSTATE *                    pTHS,
    LPWSTR                       pszServer,
    GUID                         rgGuidsDestination[],
    ULONG                        cGuidsDestination,
    GUID                         rgGuidsSource[],
    ULONG                        cGuidsSource,
    BOOL                         fAdvisory,
    ULONG                        dntNC,
    OUT ULONG *                  pulDeleted,
    OUT GUID *                   pguidNext
    )
/*++

Routine Description:
    
    The source and destination mismatch the guid set.  Locate the 
    offending guids on the destination and delete them.  It is possible
    that the source simply has extra guids in this range, in this case
    we will find that the guid list is out of scope, and we will
    set pguidNext and return.

Arguments:

    pTHS - 
    pszServer - name of Source for logging
    rgGuidsDestination[] - guid list from destination	
    cGuidsDestination - count of guids from destination
    rgGuidsSource[] - guid list from source
    cGuidsSource - count of guids from source
    fAdvisory - actually delete, or just log
    dntNC - NC of guids
    pulDeleted - count of object deleted, or logged if fAdvisory
    pguidNext - if out of scope on source list, this is should be start of next guid list

Return Values:

    0 on success, Win Error on failure

--*/
{
    ULONG                        ulGuidsSource = 0;
    ULONG                        ulGuidsDestination = 0;
    ULONG                        ulTotalObjectsDeleted = 0;
    DWORD                        dwLocate = LOCATE_GUID_MATCH;
    DWORD                        ret = ERROR_SUCCESS;

    // checksum mismatch, delete (or in advisory mode simply log) objects
    // which exist in this set of guids, and do not exist in the set
    // retrieved from the source

    // the two lists should be in order, with the source list starting
    // at least at the start of rgGuidsDestination
    if (!((cGuidsDestination==0) // race condition, this is possible
	   ||
	   (cGuidsSource==0) // Source list empty
	   ||  
	   // if we have guids in both lists, then the source must return
	   // a list that begins at least as large as the first destination
	   // guid to ensure progress
	   (0 >= memcmp(&(rgGuidsDestination[0]), &(rgGuidsSource[0]), sizeof(GUID)))
	   )) {
	DRA_EXCEPT(DRAERR_InternalError, 0);
    }

      while ((ulGuidsDestination < cGuidsDestination) && (dwLocate!=LOCATE_OUT_OF_SCOPE)) {
	// search the source's guid list for rgGuidsDestination[ulGuidsDestination]
	// there are 3 return values, either 
	// LOCATE_GUID_MATCH - both source and destination have object
	// LOCATE_NOT_FOUND - guid is not in source list and should be (in order list)
	// LOCATE_OUT_OF_SCOPE - source list is out of scope, ie the guid to be found
	// 			is greater than (in order list) than every guid in the list.
	//			in this case we need to exit the loop and request another
	//                      comparison, this time starting at this guid  
	dwLocate = LocateGUID(rgGuidsDestination[ulGuidsDestination], &ulGuidsSource, rgGuidsSource, cGuidsSource);   
	if (dwLocate==LOCATE_NOT_FOUND) {
	    // if fAdvisory, attempt to delete this object.
	    ret = DraObjectExistenceDelete(pTHS,
					   pszServer,
					   rgGuidsDestination[ulGuidsDestination],
					   dntNC,
					   fAdvisory
					   ); 
	    if (ret==ERROR_SUCCESS) { 
		ulTotalObjectsDeleted++;
		(*pulDeleted)++;
	    }
	    ret = ERROR_SUCCESS;
	} else if (dwLocate==LOCATE_OUT_OF_SCOPE) {
	    DPRINT1GUID(1, "Out of scope on guid:  %S\n", rgGuidsDestination[ulGuidsDestination]); 
	    Assert(ulGuidsDestination!=0);
	    memcpy(pguidNext, &(rgGuidsDestination[ulGuidsDestination]), sizeof(GUID)); 
	} 
	#if DBG
	else {
	    Assert(dwLocate==LOCATE_GUID_MATCH);
	}
	#endif
	ulGuidsDestination++;
    }

    
    return ret;
}

DWORD
DraVerifyObjectHelper(
    THSTATE *                    pTHS,
    UPTODATE_VECTOR *            putodCommon,
    ULONG                        dntNC,
    DSNAME *                     pNC,
    LPWSTR                       pszServer,
    BOOL                         fAdvisory,
    ULONG *                      pulTotal
    )
/*++

Routine Description:
    
    Do the work for IDL_DRSReplicaVerifyObjects

Arguments:

    pTHS - 
    putodCommon -
    dntNC -
    pNC -
    pszServer -
    fAdvisory -
    pulTotal -
    
Return Values:

    0 on success, Win Error on failure

--*/
{
    BOOL                         fComplete          = FALSE;
    DWORD                        ret                = ERROR_SUCCESS;
    ULONG                        cGuids;
    GUID                         guidStart          = gNullUuid;
    MD5_CTX                      Md5Context;
    GUID                         guidNext           = gNullUuid;
    GUID *                       rgGuids            = NULL;
    UPTODATE_VECTOR *            putodVector        = NULL;
    GUID *                       rgGuidsServer      = NULL;
    ULONG                        cGuidsServer       = 0;
    BOOL                         fMatch;
    ULONG                        ulDeleted          = 0;

    // while there are more objects in the NC whose creation is within the merged utd
    while (!fComplete) {
	cGuids = OBJECT_EXISTENCE_GUID_NUMBER_PER_PACKET;
	// get guids and checksums on destination and source
	ret = DraGetObjectExistence(pTHS,
				    pTHS->pDB,
				    guidStart,      
				    putodCommon,
				    dntNC,
				    &cGuids,      
				    (UCHAR *)Md5Context.digest,
				    &guidNext,     
				    &rgGuids);
	if (ret) {  
	    // if this doesn't return, cannot safely continue
	    DRA_EXCEPT(ret,0);
	}

	if (cGuids>0) {
	    // close the open transaction before going off machine
	    __try {
		EndDraTransaction(TRUE);
		ret = DraGetRemoteObjectExistence(pTHS,
						  pszServer,
						  cGuids,
						  ((cGuids > 0) ? rgGuids[0] : gNullUuid), //guidStart
						  putodCommon,
						  pNC,
						  Md5Context.digest,
						  &fMatch,
						  &cGuidsServer,
						  &rgGuidsServer
						  );
	    }
	    __finally {
		BeginDraTransaction(SYNC_WRITE);
	    }

	    
	} else {
	    // if we don't have any guids to examine, then consider it matched
	    // since we're done with our work 
	    fMatch=TRUE;
	    // we aren't going to continue, so guidNext should be NULL
	    Assert(0==memcmp(&guidNext, &gNullUuid, sizeof(GUID)));
	}
	
	if (ret) {  
	    // if this doesn't return, cannot safely continue
	    DRA_EXCEPT(ret,0);
	}

	if (fMatch) {
	    DPRINT(1,"Checksum Matched\n");
	} else {
	    DPRINT(1,"Checksum Mismatched\n");
	    ulDeleted = 0;
	    // objects mismatched, check the lists
	    // if needed, update guidNext
	    ret = DraDoObjectExistenceMismatch(pTHS,
					       pszServer,
					       rgGuids,
					       cGuids,
					       rgGuidsServer,
					       cGuidsServer,
					       fAdvisory,
					       dntNC,
					       &ulDeleted,
					       &guidNext
					       );
	    (*pulTotal) += ulDeleted;
	}
	memcpy(&guidStart, &guidNext, sizeof(GUID));

	if (fNullUuid(&guidNext)) {
	    // No Guid to search for?  Then we're done.
	    fComplete = TRUE;
	}
	// clean up 
	if (putodVector) {
	    THFreeEx(pTHS, putodVector);
	}
	if (rgGuids) {
	    THFreeEx(pTHS, rgGuids);
	    rgGuids = NULL;
	}
    }
    
    return ret;
}

DWORD DraGetRemoteUTD(
    THSTATE *                    pTHS,
    LPWSTR                       pszRemoteServer,
    LPWSTR                       pszNC,
    GUID                         guidRemoteServer,
    UPTODATE_VECTOR **           pputodVectorRemoteServer
    )
/*++

Routine Description:
    
    Retrieve a UTD from a remote server

Arguments:

    pTHS	
    pszRemoteServer - server to retrieve UTD from (GUID based DNS name)
    pszNC - NC of UTD to retrieve
    guidRemoteServer - GUID fo server to retrieve UTD from
    pputodVectorRemoteServer - returned UTD

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    DRS_MSG_GETREPLINFO_REQ      msgInInfo;
    DRS_MSG_GETREPLINFO_REPLY    msgOutInfo;
    DWORD                        dwOutVersion = 0;
    DWORD                        ret = ERROR_SUCCESS;

    memset(&msgInInfo, 0, sizeof(DRS_MSG_GETREPLINFO_REQ));
    memset(&msgOutInfo, 0, sizeof(DRS_MSG_GETREPLINFO_REPLY));

    msgInInfo.V2.InfoType = DS_REPL_INFO_UPTODATE_VECTOR_V1;
    msgInInfo.V2.pszObjectDN = pszNC;
    msgInInfo.V2.uuidSourceDsaObjGuid=guidRemoteServer;

    ret = I_DRSGetReplInfo(pTHS, pszRemoteServer, 2, &msgInInfo, &dwOutVersion, &msgOutInfo); 

    if ((ret==ERROR_SUCCESS) && (
		   (dwOutVersion!=DS_REPL_INFO_UPTODATE_VECTOR_V1) ||
		   (msgOutInfo.pUpToDateVec==NULL) || 
		   (msgOutInfo.pUpToDateVec->dwVersion!=1)
		   )
	) {
	Assert(!"GetReplInfo returned incorrect response!");
	DRA_EXCEPT(DRAERR_InternalError,0);
    } else if (ret==ERROR_SUCCESS) {
	*pputodVectorRemoteServer = UpToDateVec_Convert(pTHS, UPTODATE_VECTOR_NATIVE_VERSION, (UPTODATE_VECTOR *)msgOutInfo.pUpToDateVec);
	Assert((*pputodVectorRemoteServer)->dwVersion==UPTODATE_VECTOR_NATIVE_VERSION);
    }    
    return ret;
}

ULONG
DRS_MSG_REPVERIFYOBJ_V1_Validate(
    DRS_MSG_REPVERIFYOBJ_V1 * pmsg
    )
/*
    typedef struct _DRS_MSG_REPVERIFYOBJ_V1
    {
    [ref]  DSNAME *pNC;
    UUID uuidDsaSrc;
    ULONG ulOptions;
    } 	DRS_MSG_REPVERIFYOBJ_V1;
*/
{
    ULONG ret = DRAERR_Success;
    
    ret = DSNAME_Validate(pmsg->pNC, FALSE);

    if (fNullUuid(&(pmsg->uuidDsaSrc))) {
	ret = DRAERR_InvalidParameter;
    }

    return ret;
}

ULONG
DRSReplicaVerifyObjects_InputValidate(
    DWORD                    dwMsgVersion,
    DRS_MSG_REPVERIFYOBJ *   pmsgVerify
    )
/*
    [notify] ULONG IDL_DRSReplicaVerifyObjects( 
    [ref][in] DRS_HANDLE hDrs,
    [in] DWORD dwVersion,
    [switch_is][ref][in] DRS_MSG_REPVERIFYOBJ *pmsgVerify)
*/
{
    ULONG ret = DRAERR_Success;

    if ( 1 != dwMsgVersion ) {
	ret = DRAERR_InvalidParameter; 
    }

    if (ret==DRAERR_Success) {
	ret = DRS_MSG_REPVERIFYOBJ_V1_Validate(&(pmsgVerify->V1));
    }
    
    return ret;
}


ULONG
IDL_DRSReplicaVerifyObjects(
    IN  DRS_HANDLE              hDrs,
    IN  DWORD                   dwVersion,
    IN  DRS_MSG_REPVERIFYOBJ *  pmsgVerify
    )
/*++

Routine Description:
    
    Verify the existence of all objects on a destination (this) server with objects
    on the source (located in pmsgVerify).  Any objects found which were
    deleted and garbage collected on the source server are either
    deleted and/or logged on the destination depending on 
    advisory mode (in pmsgVerify).
    
    WARNING:  The successfull completion of this routine requires that both destination
    and source sort any two GUIDs in the same order.  If the sort order changes, 
    LocateGUIDPosition must be modified, and a new message version must be created to
    pass to IDL_DRSGetObjectExistence to pass guids in a new sort order.

Arguments:

    hDrs - 
    dwVersion - 
    pmsgVerify - 

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    THSTATE *                    pTHS = pTHStls;
    DWORD                        ret = ERROR_SUCCESS;
    LPWSTR                       pszServer = NULL;
    DSNAME                       dnServer;
    ULONG                        instanceType;
    UPTODATE_VECTOR *            putodThis = NULL;
    UPTODATE_VECTOR *            putodMerge = NULL;
    ULONG                        ulOptions;
    ULONG                        ulTotalDelete = 0;
    ULONG                        dntNC = 0;
    UPTODATE_VECTOR *            putodVector = NULL;

    Assert(pTHS);
    DRS_Prepare(&pTHS, hDrs, IDL_DRSREPLICAVERIFYOBJECTS);
    drsReferenceContext( hDrs );
    INC(pcThread);

    __try { 

	// Init Thread
	if(!(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI))) {
	    // Failed to initialize a THSTATE.
	    DRA_EXCEPT(DRAERR_OutOfMem, 0);
	} 

	if ((ret = DRSReplicaVerifyObjects_InputValidate(dwVersion, 
							 pmsgVerify))!=DRAERR_Success) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    __leave;
	}

	// Check Security Access
	// The ability to do a lingering object scan implies the ability to delete
	// any object in the naming context under controlled circumstances. The execution
	// of this function checks the existence of every object in the remote
	// partition and could result in disclosure of information. We require a high
	// security replication right to execute this function.
	if (!IsDraAccessGranted(pTHS, pmsgVerify->V1.pNC,
				&RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)) {  
	    DRA_EXCEPT(ret, 0);
	}

	// initialize variables
	ulOptions = pmsgVerify->V1.ulOptions;

	// Get source server name
	dnServer.Guid=pmsgVerify->V1.uuidDsaSrc;
	dnServer.NameLen=0;  
	pszServer = GuidBasedDNSNameFromDSName(&dnServer);
	if (pszServer==NULL) {
	    DRA_EXCEPT(DRAERR_InvalidParameter,0);
	}

	// Log Event
	LogEvent(DS_EVENT_CAT_REPLICATION,
		 DS_EVENT_SEV_ALWAYS,
		 (ulOptions & DS_EXIST_ADVISORY_MODE) ? \
		 DIRLOG_LOR_BEGIN_ADVISORY : \
	    DIRLOG_LOR_BEGIN,
	    szInsertWC(pszServer),
	    NULL, 
	    NULL);

	// Retreive UTD's
	ret = DraGetRemoteUTD(pTHS,
			      pszServer,
			      pmsgVerify->V1.pNC->StringName,
			      pmsgVerify->V1.uuidDsaSrc,
			      &putodVector
			      );

	if (ret!=ERROR_SUCCESS) {  
	    DRA_EXCEPT(ret,0);
	}

	BeginDraTransaction(SYNC_WRITE);

	__try {  
	    if (ret = FindNC(pTHS->pDB, pmsgVerify->V1.pNC,
			     FIND_MASTER_NC | FIND_REPLICA_NC, 
			     &instanceType)) {
		DRA_EXCEPT(DRAERR_BadNC, ret);

	    }

	    if (instanceType & (IT_NC_COMING | IT_NC_GOING)) {
		DRA_EXCEPT(DRAERR_NoReplica, instanceType);
	    }
	    // Save the DNT of the NC object  
	    dntNC = pTHS->pDB->DNT;

	    UpToDateVec_Read(pTHS->pDB, instanceType, UTODVEC_fUpdateLocalCursor,
			     DBGetHighestCommittedUSN(), &putodThis);   

	    // merge UTD's
	    UpToDateVec_Merge(pTHS, putodThis, putodVector, &putodMerge); 

	    ret = DraVerifyObjectHelper(pTHS,
					putodMerge,
					dntNC,
					pmsgVerify->V1.pNC,
					pszServer,
					!!(ulOptions & DS_EXIST_ADVISORY_MODE),
					&ulTotalDelete
					);
	}
	__finally {  
	    EndDraTransaction(TRUE);
	} 
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
	;
    }

    DEC(pcThread);
    drsDereferenceContext( hDrs );

    // log success / minor failures here
    if (ret==ERROR_SUCCESS) {
	LogEvent(DS_EVENT_CAT_REPLICATION,
		 DS_EVENT_SEV_ALWAYS,
		 (ulOptions & DS_EXIST_ADVISORY_MODE) ? \
		 DIRLOG_LOR_END_ADVISORY_SUCCESS : \
	    DIRLOG_LOR_END_SUCCESS,
	    szInsertWC(pszServer),
	    szInsertUL(ulTotalDelete), 
	    NULL);
    }
    else {
	LogEvent8(DS_EVENT_CAT_REPLICATION,
		  DS_EVENT_SEV_ALWAYS,
		  (ulOptions & DS_EXIST_ADVISORY_MODE) ? \
		  DIRLOG_LOR_END_ADVISORY_FAILURE : \
	    DIRLOG_LOR_END_FAILURE,
	    szInsertWC(pszServer),
	    szInsertWin32Msg(ret), 
	    szInsertUL(ret),
	    szInsertUL(ulTotalDelete),
	    NULL,
	    NULL,
	    NULL,
	    NULL);  
    }

    if (pszServer) {
	THFreeEx(pTHS, pszServer);
    }
    if (putodVector) {
	THFreeEx(pTHS, putodVector);  
    }
    if (putodThis) {
	THFreeEx(pTHS, putodThis);
    }

    return ret;
}

ULONG
DRS_MSG_EXISTREQ_V1_Validate(
    DRS_MSG_EXISTREQ_V1 * pmsg
    )
/*
typedef struct _DRS_MSG_EXISTREQ_V1
    {
    UUID guidStart;
    DWORD cGuids;
    DSNAME *pNC;
    UPTODATE_VECTOR_V1_WIRE *pUpToDateVecCommonV1;
    UCHAR Md5Digest[ 16 ];
    } 	DRS_MSG_EXISTREQ_V1;
*/
{
    ULONG ret = DRAERR_Success;
    
    ret = DSNAME_Validate(pmsg->pNC, FALSE);

    if (pmsg->pUpToDateVecCommonV1==NULL) {
	ret = DRAERR_InvalidParameter;
    }

    if (fNullUuid(&(pmsg->guidStart))) {
	ret = DRAERR_InvalidParameter;
    }

    return ret;
}

ULONG
DRSGetObjectExistence_InputValidate(
    DWORD                   dwMsgInVersion,
    DRS_MSG_EXISTREQ *      pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_EXISTREPLY *    pmsgOut
    )
/*
    
*/
{
    ULONG ret = DRAERR_Success;

    if ( 1 != dwMsgInVersion ) {
	ret = DRAERR_InvalidParameter; 
    }

    if (ret==DRAERR_Success) {
	ret = DRS_MSG_EXISTREQ_V1_Validate(&(pmsgIn->V1));
    }

    return ret;
}

ULONG
IDL_DRSGetObjectExistence(
    IN  DRS_HANDLE              hDrs,
    IN  DWORD                   dwInVersion,
    IN  DRS_MSG_EXISTREQ *      pmsgIn,
    OUT DWORD *                 pdwOutVersion,
    OUT DRS_MSG_EXISTREPLY *    pmsgOut
    )
/*++

Routine Description:
    
    Calculate a list of guids and compute a checksum.  If checksum matches inputted
    checksum, return DRS_EXIST_MATCH, else return the list of GUIDs.

Arguments:

    hDrs - 
    dwInVersion -
    pmsgIn -
    pdwOutVersion -
    pmsgOut -

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    DWORD                       ret;
    MD5_CTX                     Md5Context;
    ULONG                       dntNC;
    ULONG                       instanceType = 0;
    GUID *                      rgGuids = NULL;
    ULONG                       cGuids = 0;
    THSTATE *                   pTHS = pTHStls;
    UPTODATE_VECTOR *           putodVector = NULL;
    GUID                        GuidNext;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSGETOBJECTEXISTENCE);
    drsReferenceContext( hDrs );
    INC(pcThread);
    __try { 
	*pdwOutVersion=1; 
	memset(pmsgOut, 0, sizeof(*pmsgOut));

	if(!(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI))) {
	    // Failed to initialize a THSTATE.
	    DRA_EXCEPT(DRAERR_OutOfMem, 0);
	}

	if ((ret = DRSGetObjectExistence_InputValidate(dwInVersion, 
						       pmsgIn, 
						       pdwOutVersion, 
						       pmsgOut))!=DRAERR_Success) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    __leave;
	}

	// Check Security Access
	if (!IsDraAccessGranted(pTHS, pmsgIn->V1.pNC,
				&RIGHT_DS_REPL_GET_CHANGES, &ret)) {  
	    DRA_EXCEPT(ret, 0);
	}

	// Calculate checksum/guids
	DBOpen2(TRUE, &pTHS->pDB);
	__try { 
	    if (ret = FindNC(pTHS->pDB, pmsgIn->V1.pNC,
			     FIND_MASTER_NC, 
			     &instanceType)) {
		DRA_EXCEPT(DRAERR_BadNC, ret);
	    }

	    if (instanceType & (IT_NC_COMING | IT_NC_GOING)) {
		DRA_EXCEPT(DRAERR_NoReplica, instanceType);
	    }
	    dntNC = pTHS->pDB->DNT;
	    cGuids = pmsgIn->V1.cGuids; 

	    // Convert to native version
	    putodVector = UpToDateVec_Convert(pTHS, UPTODATE_VECTOR_NATIVE_VERSION, (UPTODATE_VECTOR *)pmsgIn->V1.pUpToDateVecCommonV1);
	    ret = DraGetObjectExistence(pTHS,
					pTHS->pDB,
					pmsgIn->V1.guidStart,
					putodVector,
					dntNC,
					&cGuids,
					(UCHAR *)Md5Context.digest,
					&GuidNext,     
					&rgGuids);
	    //if meta data matches, send the A-OK!
	    //else send guids.
	    if (!memcmp(Md5Context.digest, pmsgIn->V1.Md5Digest, MD5DIGESTLEN*sizeof(UCHAR))) {
		pmsgOut->V1.dwStatusFlags = DRS_EXIST_MATCH;
		pmsgOut->V1.cNumGuids = 0;
		pmsgOut->V1.rgGuids = NULL;
		DPRINT(1, "Get Object Existence Checksum Success.\n");
	    }
	    else {
		pmsgOut->V1.dwStatusFlags = 0;
		pmsgOut->V1.cNumGuids = cGuids;
		pmsgOut->V1.rgGuids = rgGuids;
		DPRINT(1, "Get Object Existence Checksum Failed.\n");
	    } 
	}
	__finally {
	    DBClose(pTHS->pDB, TRUE);
	} 
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
	;
    }

    DEC(pcThread);
    drsDereferenceContext( hDrs );

    // clean up  
    if (putodVector!=NULL) {
	THFreeEx(pTHS, putodVector);
    }

    return ret;
}

DWORD
DraRemoveSingleLingeringObject(
    THSTATE * pTHS,
    DBPOS *   pDB,
    DSNAME *  pSource,
    DSNAME *  pDN
    )
/*++

Routine Description:
    
    If pDN is not found on pSource, then delete pDN from the local database.

Arguments:

    pTHS -
    pDB -
    pSource - DC to verify non-existence of pDN on
    pDN - object to delete

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    DWORD err = ERROR_SUCCESS;
    DSNAME * pNC = NULL;
    DBPOS * pDBSave = NULL;
    BOOL fDRA;
    DSTIME dstimeCreationTime;
    ULONG ulLength = 0;

    // first locate which NC they want to delete this object out of ...
    pNC = FindNCParentDSName(pDN, FALSE, FALSE);	
    if (!pNC) {
	// can't delete it if I don't have it
	err = ERROR_DS_CANT_FIND_EXPECTED_NC;
    }

    if (err==ERROR_SUCCESS) {
       // does the source hold this nc?
       if (!IsMasterForNC(pDB, pSource, pNC)) {
	   // it can't be verified that the source holds that writeable nc!
	   err = ERROR_DS_CANT_FIND_EXPECTED_NC;
       }
    }

    if (err==ERROR_SUCCESS) {
	// find the object
	err = DBFindDSName(pDB, pDN);
    }

    if (err==ERROR_SUCCESS) {
	// note:  a lingering object is an object whose creation has been seen by both DC's
	// but whose deletion was only seen by a single DC because the replication of the 
	// tombstone didn't occur before it's lifetime expired and was garbage collected
	
	// to test for such an object, we would need to compare the UTD vectors of both
	// source and destination to verify that the creation was seen by both DC's (otherwise
	// the object could be a new object that hasn't had a chance to replicate yet)

	// in Win2K, there is no simple way to get another DC's UTD vector, so instead, we will
	// use the fact that any lingering object is at least a single tombstone lifetime old.
	// This keeps the user from deleting brand new objects which just haven't replicated in
	// a working replication scheme.

	// get it's creation time.
	err = DBGetSingleValue(pDB,
			       ATT_WHEN_CREATED,
			       &dstimeCreationTime,
			       sizeof(dstimeCreationTime),
			       NULL);
    }

    if (err==ERROR_SUCCESS) {
	if ((GetSecondsSince1601() - dstimeCreationTime) < (LONG)(gulTombstoneLifetimeSecs ? gulTombstoneLifetimeSecs : DEFAULT_TOMBSTONE_LIFETIME*DAYS_IN_SECS)) { 
	    // how can this object be lingering if the creation time is less than a single tombstone lifetime?
	    err = ERROR_INVALID_PARAMETER;
	}
    }

    if (err==ERROR_SUCCESS) {
	// check to see that pDN is deletable.  This call doesn't check if
	// this is a parent or not - returns success if it's deletable

	// needs pDB located on pDN.
	err = DraObjectExistenceCheckDelete(pDB, pDN);
    }

    if (err==ERROR_SUCCESS) {
	// check if it's a parent (of any object, deleted or not) - we don't delete parents. 
	// will change pDB.
	if (DBHasChildren(pDB, pDB->DNT, TRUE)) {  
	    err = ERROR_DS_CHILDREN_EXIST;
	} 
    }

    if (err==ERROR_SUCCESS) {
	// does this object exist on the source?  returns success if it does
	// and ERROR_DS_OBJ_NOT_FOUND if it doesn't, errors otherwise

	// first end the transaction before we go off machine.	
	__try {
	    EndDraTransaction(TRUE);
	    err = DraGetRemoteSingleObjectExistence(pTHS, pSource, pDN);
	}
	__finally {
	    BeginDraTransaction(SYNC_WRITE);
	    pDB = pTHS->pDB;
	}

	if (err==ERROR_SUCCESS) {
	    // object exists on the source, it's not lingering
	    // we won't delete this object
	    err= ERROR_INVALID_PARAMETER;
	} else if (err==ERROR_DS_OBJ_NOT_FOUND) { 
	    // okay, this is what we were looking for, it's lingering

	    // note:  there exist conditions where this object is not technically lingering
	    // for example, if the object was created over a tombstone lifetime ago and it's
	    // creation never replicated to the source.
	    err = ERROR_SUCCESS;
	}
    }    

    if (err==ERROR_SUCCESS) {
	// okay, delete it! DeleteLocalObj needs pTHS->pDB to be current on pDN

	err = DBFindDSName(pDB, pDN);

	if (err==ERROR_SUCCESS) { 
	    __try {  
		fDRA = pTHS->fDRA;
		pTHS->fDRA = TRUE;
		pDBSave = pTHS->pDB;
		pTHS->pDB = pDB;

                // Since we're going to use the fGarbCollectASAP flag to DeleteLocalObj, we
                // need to remove the backlinks on it by hand, since they aren't removed 
                // if this flag is set - otherwise we get dangling references to non-exitant
                // objects
                DBRemoveLinks(pTHS->pDB);
                err = DeleteLocalObj(pTHS, 
				     pDN, 
				     TRUE, //fPreserveRDN
				     TRUE, //fGarbCollectASAP,
				     NULL);

		//if err==ERROR_SUCCESS then log something here.  
	    }
	    __finally {  
		pTHS->fDRA = fDRA;
		pTHS->pDB = pDBSave;
	    }
	}
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\dramderr.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       dramderr.c
//
//--------------------------------------------------------------------------

/*++

Abstract:   This file contains routines for transporting thread state errors
            across the RPC DRS_* routines.  The main two public routines are:
                draEncodeError()
                draDecodeDraErrorDataAndSetThError()
            the server calls draEncodeError() when it's operation is done, and
            an error may need to be transported back to the client.  The client
            unpacks the error data and has his own thread error state set by
            draDecodeDraErrorDataAndSetThError().

Author:     Brett Shirley (BrettSh)

Notes:      ...

Revision History:

    2001-04-13  Initial creation.

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <drs.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"

#include   "debug.h"                    /* standard debugging header */
#define DEBSUB "DRAMDERR:"              /* define the subsystem for debugging */

#include "drserr.h"
#include "drautil.h"
#include "drauptod.h"
#include "dramail.h"

#include <fileno.h>
#define  FILENO FILENO_DRAMDERR


////////////////////////////////////////////////////////////////////////////////
//
//  WIRE - THREAD_STATE TRANSLATION FUNCTIONS (HELPER FUNCTIONS)
//


void    
draXlateThDirErrToWireDirErr(
    THSTATE *             pTHS,
    DWORD                 prob,
    DIRERR_DRS_WIRE_V1 *  pErrInfo
)
/*++

Routine Description:

    This is a helper function to draEncodeError(), whose primary
    purpose is to just deal with a presumed valid thread state
    error.  There is assumed to be an error if you call this func.
    This routine throws exceptions if the thread error state ins't
    exactly as we'd expect it to be, or there is no more memory.

    Changes to this function should be accompained by changes to her
    sister fuctnion draXlateWireDirErrToThDirErr()
    
    BUGBUG: pNewFilter in the AtrErr is the only thing not transfered,
    if someone ever needs this functionality I suggest they add it
    and increment the error data version.  It would complete the
    robustness of this routine

Arguments:

    pTHS [IN] - This is the error state to pack onto the wire version.
        The error state is in pTHS->errCode & pTHS->pErrInfo.
    prob [IN] - This is the pTHS->errCode.
    pErrInfo [IN] - The on the wire thread error structure to fill im
        and initialize all fields (depending on the prob) of this
        struct.

Return Value:

    None

--*/
{  
    PROBLEMLIST *                    pAttrProbList;
    PROBLEMLIST_DRS_WIRE_V1 *        pAttrProbListDest;
    CONTREF *                        pContRef;
    CONTREF_DRS_WIRE_V1 *            pContRefDest;
    DSA_ADDRESS_LIST *               pDAL;
    DSA_ADDRESS_LIST_DRS_WIRE_V1 *   pDALDest = NULL;
    DSA_ADDRESS_LIST_DRS_WIRE_V1 *   pDALTemp;
    
    ULONG   i;

    // Only supposed to call this in case there is an error state in
    // the thread state (pTHS->errCode and pTHS->pErrInfo)
    Assert(pTHS);
    Assert(pTHS->errCode);
    Assert(pTHS->pErrInfo);
    Assert(prob);
    Assert(pErrInfo);

    switch(prob){
    
    case attributeError:
        // Note: Not deep copied, no need.
        pErrInfo->AtrErr.pObject = pTHS->pErrInfo->AtrErr.pObject;
        pErrInfo->AtrErr.count = pTHS->pErrInfo->AtrErr.count;
        
        // According to DoSetAttError, there will always be at least 1 error.
        Assert(pTHS->pErrInfo->AtrErr.count != 0);
        pAttrProbList = &pTHS->pErrInfo->AtrErr.FirstProblem;
        pAttrProbListDest = &pErrInfo->AtrErr.FirstProblem;
        // Copy the list of problems
        for(i = 0; i < pErrInfo->AtrErr.count; i++){
            
            // First copy all the individual elements.
            pAttrProbListDest->intprob.dsid = pAttrProbList->intprob.dsid;
            pAttrProbListDest->intprob.extendedErr = pAttrProbList->intprob.extendedErr;
            pAttrProbListDest->intprob.extendedData = pAttrProbList->intprob.extendedData;
            pAttrProbListDest->intprob.problem = pAttrProbList->intprob.problem;
            pAttrProbListDest->intprob.type = pAttrProbList->intprob.type;
            pAttrProbListDest->intprob.valReturned = pAttrProbList->intprob.valReturned;
            if(pAttrProbListDest->intprob.valReturned){
                pAttrProbListDest->intprob.Val.valLen = pAttrProbList->intprob.Val.valLen;
                // Note: Not deep copied, no need.
                pAttrProbListDest->intprob.Val.pVal = pAttrProbList->intprob.Val.pVal;
            }

            // Second continue to the next problem if there is one.
            if(pAttrProbList->pNextProblem){
                // There is a next problem, maybe it's world hunger?
                Assert(i < (pErrInfo->AtrErr.count-1));
                pAttrProbListDest->pNextProblem = THAllocEx(pTHS, sizeof(PROBLEMLIST_DRS_WIRE_V1));
                pAttrProbListDest = pAttrProbListDest->pNextProblem;
            } else {
                // All the world's problems have been solved or at 
                // least copied. :)
                Assert(i == (pErrInfo->AtrErr.count-1));
                pAttrProbListDest->pNextProblem = NULL;
            }

        } // end for loop
        Assert(i == pErrInfo->AtrErr.count);
        break;

    case nameError:
        pErrInfo->NamErr.dsid = pTHS->pErrInfo->NamErr.dsid;
        pErrInfo->NamErr.extendedErr = pTHS->pErrInfo->NamErr.extendedErr;
        pErrInfo->NamErr.extendedData = pT