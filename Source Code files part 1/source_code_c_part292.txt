LESTR("Name");

    // Write this big property
    Check( S_OK, pPropStg->WriteMultiple( 1, &cpropspec, &propvar, PID_FIRST_USABLE ));

    // Create a slightly too large property set.

    PropVariantClear( &propvar );
    delete propvar.blob.pBlobData;

    propvar.vt = VT_BLOB;    
    propvar.blob.cbSize = 1024 * 1024;
    propvar.blob.pBlobData = new BYTE[ propvar.blob.cbSize ];
    Check( FALSE, NULL == propvar.blob.pBlobData );

    // Write this too-big property 
    Check( STG_E_MEDIUMFULL, pPropStg->WriteMultiple( 1, &cpropspec, &propvar, PID_FIRST_USABLE ));

    delete propvar.blob.pBlobData;
    RELEASE_INTERFACE( pPropStg );
    
}


void
test_VersionOneNames( IStorage *pstg )
{
    FMTID fmtidInsensitive, fmtidSensitive, fmtidLongNames;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    STATPROPSETSTG statpropsetstg;

    CPropSpec rgcpropspec[2];
    CPropVariant rgcpropvarWrite[2], rgcpropvarRead[2];
    LPOLESTR rgposzNames[2] = { NULL, NULL };
    PROPID rgpropid[2] = { PID_FIRST_USABLE, PID_FIRST_USABLE+1 };

    Status( "PROPSETFLAG_CASE_SENSITIVE flag and long names\n" );

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));

    UuidCreate( &fmtidInsensitive );
    UuidCreate( &fmtidSensitive );
    UuidCreate( &fmtidLongNames );

    // Make two passes, Unicode first, then Ansi.

    for( int iPass = 0; iPass < 2; iPass++ )
    {
        DWORD propsetflagAnsi = 0 == iPass ? 0 : PROPSETFLAG_ANSI;
        ULONG cbLongPropertyName = 1020 * 1024;
        ULONG cchLongPropertyName = 0 == iPass ? cbLongPropertyName/sizeof(OLECHAR) : cbLongPropertyName;

        //  ------------------------
        //  Case insensitive propset
        //  ------------------------

        Check( S_OK, pPropSetStg->Create( fmtidInsensitive, NULL,
                                          PROPSETFLAG_DEFAULT | propsetflagAnsi,
                                          STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                          &pPropStg ));

        // This should still be a version zero (original) propery set.
        CheckFormatVersion( pPropStg, 0);

        rgcpropspec[0] = OLESTR("Name");
        rgcpropspec[1] = OLESTR("name");
        rgcpropvarWrite[0] = (long) 0;
        rgcpropvarWrite[1] = (short) 1;

        // Write two properties with the same name (their the same because this is a
        // case-insensitive property set).

        Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

        // Read the names back.
        Check( S_OK, pPropStg->ReadPropertyNames( 2, rgpropid, rgposzNames ));

        // Since we really only wrote one property, we should only get one name back
        // Note that we get back the first name, but it's the second value!

        Check( 0, ocscmp( rgcpropspec[0].lpwstr, rgposzNames[0] ));
        Check( TRUE, NULL == rgposzNames[1] );

        delete[] rgposzNames[0];
        rgposzNames[0] = NULL;

        // Double check that we really one wrote one property (the second).
        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, VT_I2 == rgcpropvarRead[0].VarType() && rgcpropvarRead[0] == CPropVariant((short) 1) );
        Check( TRUE, VT_I2 == rgcpropvarRead[1].VarType() && rgcpropvarRead[1] == CPropVariant((short) 1) );

        Check( S_OK, pPropStg->Stat( &statpropsetstg ));
        Check( 0, statpropsetstg.grfFlags & PROPSETFLAG_CASE_SENSITIVE );

        RELEASE_INTERFACE( pPropStg );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        //  ----------------------
        //  Case sensitive propset
        //  ----------------------

        Check( S_OK, pPropSetStg->Create( fmtidSensitive, NULL,
                                          PROPSETFLAG_CASE_SENSITIVE | propsetflagAnsi,
                                          STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                          &pPropStg ));

        // Case-sensitivity requires a version 1 property set.
        CheckFormatVersion( pPropStg, 1 );

        // Write the two names that differ only by case.
        Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

        // Read the names back and validate.
        Check( S_OK, pPropStg->ReadPropertyNames( 2, rgpropid, rgposzNames ));
        Check( TRUE, !ocscmp( rgcpropspec[0].lpwstr, rgposzNames[0] ));
        Check( TRUE, !ocscmp( rgcpropspec[1].lpwstr, rgposzNames[1] ));

        delete[] rgposzNames[0]; rgposzNames[0] = NULL;
        delete[] rgposzNames[1]; rgposzNames[1] = NULL;

        // Read the values and validate them too.

        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, VT_I4 == rgcpropvarRead[0].VarType() && rgcpropvarRead[0] == CPropVariant((long) 0) );
        Check( TRUE, VT_I2 == rgcpropvarRead[1].VarType() && rgcpropvarRead[1] == CPropVariant((short) 1) );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        Check( S_OK, pPropStg->Stat( &statpropsetstg ));
        Check( PROPSETFLAG_CASE_SENSITIVE, statpropsetstg.grfFlags & PROPSETFLAG_CASE_SENSITIVE );

        RELEASE_INTERFACE( pPropStg );

        //  -----------------------
        //  Propset with long names
        //  -----------------------

        Check( S_OK, pPropSetStg->Create( fmtidLongNames, NULL,
                                          PROPSETFLAG_DEFAULT | propsetflagAnsi,
                                          STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                          &pPropStg ));

        // So far we haven't done anything that requires a post-original property set.
        CheckFormatVersion( pPropStg, 0 );

        // Write a short name, validate it, and validate that the format version doesn't change.
        rgcpropspec[0] = OLESTR("A short name");
        Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->ReadPropertyNames( 1, rgpropid, rgposzNames ));  // PROPID == 2
        Check( TRUE, !ocscmp( rgcpropspec[0].lpwstr, rgposzNames[0] ));
        CheckFormatVersion( pPropStg, 0 );
        delete[] rgposzNames[0]; rgposzNames[0] = NULL;

        // Now create a really, really, long name.
        rgcpropspec[0].Alloc( cchLongPropertyName );

        for( ULONG i = 0; i < cchLongPropertyName; i++ )
            rgcpropspec[0][i] = OLESTR('a') + ( static_cast<OLECHAR>(i) % 26 );
        rgcpropspec[0][cchLongPropertyName-1] = OLESTR('\0');

        // Write this long name.
        Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

        // The property set's format version should have been automatically bumped up.
        CheckFormatVersion( pPropStg, 1);

        // Read the property using the long name
        Check( S_OK, pPropStg->ReadMultiple( 1, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        rgcpropvarRead[0].Clear();

        // Read and validate the property name.
        Check( S_OK, pPropStg->ReadPropertyNames( 1, &rgpropid[1], rgposzNames )); // PROPID == 3
        Check( TRUE, !ocscmp( rgcpropspec[0].lpwstr, rgposzNames[0] ));
        delete[] rgposzNames[0]; rgposzNames[0] = NULL;

        // Try to write a long, different name.
        rgcpropspec[0][0] = OLESTR('#');
        Check( STG_E_MEDIUMFULL, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

        RELEASE_INTERFACE( pPropStg );

    }   // for( int iPass = 0; iPass < 2; iPass++ )

    RELEASE_INTERFACE( pPropSetStg );

}   // test_VersionOneNames()



void
test_MultipleReader( LPOLESTR ocsDir )
{
    OLECHAR ocsFile[ MAX_PATH ];
    IPropertyBagEx *pBag1 = NULL, *pBag2 = NULL;
    CPropVariant rgcpropvarRead1[ CPROPERTIES_ALL ], rgcpropvarRead2[ CPROPERTIES_ALL ];
    OLECHAR oszPropertyName[] = OLESTR("Simple property");
    IEnumSTATPROPBAG *penum = NULL;
    STATPROPBAG rgstatpropbag[ CPROPERTIES_ALL + 1];
    ULONG cEnum = 0;

    Status( "Multiple stgm_read|stgm_deny_write\n" );

    ocscpy( ocsFile, ocsDir );
    ocscat( ocsFile, OLESTR("test_MultipleReader") );


    Check( S_OK, g_pfnStgCreateStorageEx( ocsFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L, NULL, NULL,
                                     IID_IPropertyBagEx,
                                     reinterpret_cast<void**>(&pBag1) ));


    Check( S_OK, pBag1->WriteMultiple( CPROPERTIES_ALL,
                                       g_rgoszpropnameAll,
                                       g_rgcpropvarAll ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));
    Check( 0, RELEASE_INTERFACE(pBag1) );

    Check( S_OK, g_pfnStgOpenStorageEx( ocsFile,
                                   STGM_READ | STGM_SHARE_DENY_WRITE,
                                   STGFMT_ANY,
                                   0L, NULL, NULL,
                                   IID_IPropertyBagEx,
                                   reinterpret_cast<void**>(&pBag1) ));

    Check( S_OK, g_pfnStgOpenStorageEx( ocsFile,
                                   STGM_READ | STGM_SHARE_DENY_WRITE,
                                   STGFMT_ANY,
                                   0L, NULL, NULL,
                                   IID_IPropertyBagEx,
                                   reinterpret_cast<void**>(&pBag2) ));


    Check( S_OK, pBag2->Enum( NULL, 0, &penum )); //OLESTR(""), 0, &penum ));

    Check( S_OK, penum->Next( CPROPERTIES_ALL, rgstatpropbag, &cEnum ));
    Check( CPROPERTIES_ALL, cEnum );

    Check( S_OK, pBag1->ReadMultiple( CPROPERTIES_ALL, g_rgoszpropnameAll,
                                      rgcpropvarRead1, NULL ));

    Check( S_OK, pBag2->ReadMultiple( CPROPERTIES_ALL, g_rgoszpropnameAll,
                                      rgcpropvarRead2, NULL ));

    for( int i = 0; i < CPROPERTIES_ALL; i++ )
    {
        Check( TRUE, rgcpropvarRead1[i] == g_rgcpropvarAll[i] );
        Check( TRUE, rgcpropvarRead2[i] == g_rgcpropvarAll[i] );

        delete[] rgstatpropbag[i].lpwstrName;
        rgstatpropbag[i].lpwstrName = NULL;
    }


    Check( 0, RELEASE_INTERFACE(penum) );
    Check( 0, RELEASE_INTERFACE(pBag1) );
    Check( 0, RELEASE_INTERFACE(pBag2) );

    return;

}   // test_MultipleReader






void
test_Robustness(OLECHAR *poszDir)
{
    if( PROPIMP_NTFS != g_enumImplementation ) return;

    Status( "NTFS property set robustness\n" );

    HRESULT hr = S_OK;
    IStorage *pStorage = NULL;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    IStorageTest *pPropStgTest = NULL;
    IStream *pStm = NULL;
    FMTID fmtid;
    STATSTG statstg;
    OLECHAR oszFile[ MAX_PATH ];
    OLECHAR oszName[ MAX_PATH ];
    OLECHAR oszUpdateName[ MAX_PATH ];

    CPropSpec rgcpropspec[2];
    CPropVariant rgcpropvarWrite[2], rgcpropvarRead[2];

    ocscpy( oszFile, poszDir );
    ocscat( oszFile, OLESTR("test_Robustness") );

    // Create a property set and put a property into it.

    Check( S_OK, g_pfnStgCreateStorageEx( oszFile, STGM_READWRITE|STGM_CREATE|STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt(g_enumImplementation),
                                     0, NULL, NULL,
                                     DetermineStgIID( g_enumImplementation ),
                                     reinterpret_cast<void**>(&pStorage) ));


    Check( S_OK, pStorage->QueryInterface( IID_IPropertySetStorage,
                                           reinterpret_cast<void**>(&pPropSetStg) ));

    UuidCreate( &fmtid );
    Check( S_OK, pPropSetStg->Create( fmtid, NULL, PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    rgcpropspec[0] = OLESTR("Property Name");
    rgcpropspec[1] = OLESTR("Second property name");

    rgcpropvarWrite[0] = static_cast<long>(23);
    rgcpropvarWrite[1] = OLESTR("Second property value");

    Check( S_OK, pPropStg->WriteMultiple( 1, &rgcpropspec[0], &rgcpropvarWrite[0], PID_FIRST_USABLE ));
    Check( 0, RELEASE_INTERFACE(pPropStg) );

    // Rename the property set's stream to "Updt_*", and create any empty stream
    // in its place.  This simulates a crash during the flush of a property set.

    RtlGuidToPropertySetName( &fmtid, oszName );
    oszName[ 0 ] = OC_PROPSET0;
    wcscpy( oszUpdateName, OLESTR("Updt_") );
    wcscat( oszUpdateName, oszName );

    Check( S_OK, pStorage->RenameElement( oszName, oszUpdateName ));

    Check( S_OK, pStorage->CreateStream( oszName, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pStm ));
    Check( 0, RELEASE_INTERFACE(pStm) );

    // Open the property set in read-only mode, and verify that we can still ready
    // the property.  Since we're opening in read-only, the streams should remain
    // unchanged.

    Check( S_OK, pPropSetStg->Open( fmtid, STGM_READ|STGM_SHARE_EXCLUSIVE, &pPropStg ));

    Check( S_OK, pPropStg->ReadMultiple( 1, &rgcpropspec[0], &rgcpropvarRead[0] ));
    Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
    Check( 0, RELEASE_INTERFACE(pPropStg) );

    // Verify that the streams do not appear to have been changed.

    Check( S_OK, pStorage->OpenStream( oszName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
    Check( S_OK, pStm->Stat( &statstg, STATFLAG_NONAME ));
    Check( TRUE, CULargeInteger(0) == CULargeInteger(statstg.cbSize) );
    Check( 0, RELEASE_INTERFACE(pStm) );

    Check( S_OK, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
    Check( S_OK, pStm->Stat( &statstg, STATFLAG_NONAME ));
    Check( FALSE, CULargeInteger(0) == CULargeInteger(statstg.cbSize) );
    Check( 0, RELEASE_INTERFACE(pStm) );

    // Now open the property set for write.  This should cause the problem to be fixed.

    Check( S_OK, pPropSetStg->Open( fmtid, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pPropStg ));

    // Read the property back
    Check( S_OK, pPropStg->ReadMultiple( 1, &rgcpropspec[0], &rgcpropvarRead[0] ));
    Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );

    // Write another property and read both properties back

    Check( S_OK, pPropStg->WriteMultiple( 1, &rgcpropspec[1], &rgcpropvarWrite[1], PID_FIRST_USABLE ));
    Check( S_OK, pPropStg->ReadMultiple( 2, &rgcpropspec[0], &rgcpropvarRead[0] ));
    Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
    Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
    rgcpropvarRead[1].Clear();

    Check( 0, RELEASE_INTERFACE(pPropStg) );

    // Verify that the streams look corrected.

    Check( S_OK, pStorage->OpenStream( oszName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
    Check( S_OK, pStm->Stat( &statstg, STATFLAG_NONAME ));
    Check( TRUE, CULargeInteger(0) != CULargeInteger(statstg.cbSize) );
    Check( 0, RELEASE_INTERFACE(pStm) );

    Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));

    // Write/read after disabling the stream-rename

    Check( S_OK, pPropSetStg->Create( fmtid, NULL, PROPSETFLAG_DEFAULT, STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_CREATE, &pPropStg ));

    hr = pPropStg->QueryInterface( IID_IStorageTest, reinterpret_cast<void**>(&pPropStgTest) );
    if( SUCCEEDED(hr) )
        Check( S_OK, pPropStgTest->UseNTFS4Streams( TRUE ));
    if( E_NOINTERFACE == hr )
    {
        Status( "   ... Partially skipping, IStorageTest not available (free build?)\n" );
    }
    else
    {
        Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
        Check( S_OK, pPropStg->WriteMultiple( 2, &rgcpropspec[0], &rgcpropvarWrite[0], PID_FIRST_USABLE ));
        Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
        Check( S_OK, pPropStg->Commit( STGC_DEFAULT ));
        Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
        RELEASE_INTERFACE( pPropStgTest );
        Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
        Check( 0, RELEASE_INTERFACE(pPropStg) );

        Check( S_OK, pPropSetStg->Open( fmtid, STGM_READ|STGM_SHARE_DENY_WRITE, &pPropStg ));
        Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );
    }

    // Write to the property set, then cause it to be shutdown and reverted.

    Check( 0, RELEASE_INTERFACE(pPropStg) );
    Check( S_OK, pPropSetStg->Open( fmtid, STGM_SHARE_EXCLUSIVE|STGM_READWRITE, &pPropStg ));

    rgcpropvarWrite[0] = OLESTR("Hello");
    rgcpropvarWrite[1] = OLESTR("World");
    Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    RELEASE_INTERFACE(pPropSetStg);
    Check( 0, RELEASE_INTERFACE(pStorage) );    // Should flush the properties
    Check( STG_E_REVERTED, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
    Check( 0, RELEASE_INTERFACE(pPropStg) );

    Check( S_OK, g_pfnStgOpenStorageEx( oszFile, STGM_READ|STGM_SHARE_DENY_WRITE,
                                   STGFMT_ANY,
                                   0, NULL, NULL,
                                   IID_IPropertySetStorage,
                                   reinterpret_cast<void**>(&pPropSetStg) ));
    Check( S_OK, pPropSetStg->Open( fmtid, STGM_READ|STGM_SHARE_EXCLUSIVE, &pPropStg ));

    Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
    Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
    Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
    Check( 0, RELEASE_INTERFACE(pPropStg) );
    g_pfnFreePropVariantArray( 2, rgcpropvarRead );


    //
    //  Exit
    //

    RELEASE_INTERFACE(pPropSetStg);

    g_pfnFreePropVariantArray( 2, rgcpropvarWrite );
    g_pfnFreePropVariantArray( 2, rgcpropvarRead );

}   // test_Robustness



void
test_EmptyBag( OLECHAR *poszDir )
{
    OLECHAR oszFile[ MAX_PATH ];
    IStorage *pstg = NULL;
    IPropertyBagEx *pbag = NULL;
    PROPVARIANT propvar;
    IEnumSTATPROPBAG *penum = NULL;
    STATPROPBAG statpropbag;
    ULONG cFetched;

    ocscpy( oszFile, poszDir );
    ocscat( oszFile, OLESTR("test_EmptyBag") );

    Check( S_OK, g_pfnStgCreateStorageEx( oszFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L,
                                     NULL,
                                     NULL,
                                     IID_IPropertyBagEx,
                                     (void**) &pbag ));

    PropVariantInit( &propvar );
    OLECHAR *poszName = OLESTR("test");
    Check( S_FALSE, pbag->ReadMultiple( 1, &poszName, &propvar, NULL ));
    Check( VT_EMPTY, propvar.vt );

    Check( S_OK, pbag->Enum( OLESTR(""), 0, &penum ));
    Check( S_FALSE, penum->Next( 1, &statpropbag, &cFetched ));
    Check( 0, cFetched );

    Check( 0, RELEASE_INTERFACE(penum));
    Check( 0, RELEASE_INTERFACE(pbag));

}   // test_EmptyBag


void
test_BagDelete( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertyBagEx *pbag = NULL;
    IEnumSTATPROPBAG* penum = NULL;
    ULONG cFetched = 0;
    ULONG i, j;
    OLECHAR * rgoszDelete[2];

    // Note that some of these names only differ by case, which is legal in a bag
    OLECHAR *rgoszNames[] = { OLESTR("www.microsoft.com/bag/test?prop1"),
                              OLESTR("www.microsoft.com/bag/test?PROP1"),
                              OLESTR("www.microsoft.com/bag/2test?prop1"),
                              OLESTR("www.microsoft.com/bag2/test?prop1") };

    CPropVariant rgcpropvarRead[ ELEMENTS(rgoszNames) + 1 ];
    STATPROPBAG rgstatpropbag[ ELEMENTS(rgoszNames) + 1 ];

    // Can't run this test with STGFMT_FILE, because CFlatStorage
    // is not compatible with it.
    if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
        return;

    Status( "Property bag deletions\n" );

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));
    DeleteBagExProperties( pbag, OLESTR("") );

    //  ------------------------------------------
    //  Delete bag2/test?prop1 by name & by prefix
    //  ------------------------------------------

    for( i = 0; i < 2; i++ )
    {
        ULONG cFetchedExpected = 0;

        switch(i)
        {
        case 0:
            // Delete by name
            rgoszDelete[0] = OLESTR("www.microsoft.com/bag2/test?prop1");
            cFetchedExpected = ELEMENTS(rgoszNames) - 1;
            break;

        case 1:
            // Delete by prefix
            rgoszDelete[0] = OLESTR("www.microsoft.com/bag2/test");
            cFetchedExpected = ELEMENTS(rgoszNames) - 1;
            break;

        default:
            Check( FALSE, TRUE ); //Check( FALSE, 0 == OLESTR("Invalid switch") );

        }   // switch(i)


        Check( S_OK, pbag->WriteMultiple( ELEMENTS(rgoszNames), rgoszNames, g_rgcpropvarAll ));
        Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));
        DeleteBagExProperties( pbag, rgoszDelete[0] );
        Check( S_OK, pbag->Enum( OLESTR(""), 0, &penum ));

        Check( ELEMENTS(rgoszNames) == cFetchedExpected ? S_OK : S_FALSE,
               penum->Next( ELEMENTS(rgoszNames), rgstatpropbag, &cFetched ));

        Check( TRUE, cFetchedExpected == cFetched );
        RELEASE_INTERFACE(penum);

        for( j = 0; j < cFetched; j++ )
        {
            Check( TRUE, !wcscmp(rgoszNames[j], rgstatpropbag[j].lpwstrName) );
            delete [] rgstatpropbag[j].lpwstrName;
        }

    }   // for( i = 0; i < 2; i++ )

    //  -----------------------------------------------
    //  Delete the two "/bag/test" properties by prefix
    //  -----------------------------------------------

    rgoszDelete[0] = OLESTR("www.microsoft.com/bag/test");
    Check( S_OK, pbag->WriteMultiple( ELEMENTS(rgoszNames), rgoszNames, g_rgcpropvarAll ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));
    DeleteBagExProperties( pbag, rgoszDelete[0] );
    Check( S_OK, pbag->Enum( OLESTR(""), 0, &penum ));

    Check( S_FALSE, penum->Next( ELEMENTS(rgoszNames), rgstatpropbag, &cFetched ));
    Check( TRUE, 2 == cFetched );
    RELEASE_INTERFACE(penum);

    for( j = 0; j < cFetched; j++ )
    {
        Check( TRUE, !wcscmp(rgoszNames[j+2], rgstatpropbag[j].lpwstrName) );
        delete [] rgstatpropbag[j].lpwstrName;
    }

    /*
    //  -------------------------
    //  Delete all the properties
    //  -------------------------

    rgoszDelete[0] = NULL;
    Check( S_OK, pbag->WriteMultiple( ELEMENTS(rgoszNames), rgoszNames, g_rgcpropvarAll ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));
    Check( S_OK, pbag->Delete( OLESTR(""), DELETEPROPERTY_MASK));
    Check( S_OK, pbag->Enum( OLESTR(""), 0, &penum ));

    Check( S_FALSE, penum->Next( ELEMENTS(rgoszNames), rgstatpropbag, &cFetched ));
    Check( TRUE, 0 == cFetched );
    RELEASE_INTERFACE(penum);
    */

    pbag->Release();

}   // test_BagDelete


void
test_IPropertyBag( IStorage *pstg )
{
    // Can't run this test with STGFMT_FILE, because CFlatStorage
    // is not compatible with it.
    if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
        return;

    Status( "IPropertyBag\n" );

    IPropertyBagEx *pbagex = NULL;
    IPropertyBag *pbag = NULL;

    ULONG cRefsOriginal = GetRefCount( pstg );

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbagex) ));
    DeleteBagExProperties( pbagex, OLESTR("") );
    RELEASE_INTERFACE(pbagex);

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBag, reinterpret_cast<void**>(&pbag) ));

    VARIANT varWrite, varRead;
    VariantInit( &varWrite );
    VariantInit( &varRead );

    varWrite.vt = VT_I4;
    varWrite.lVal = 1234;

    Check( S_OK, pbag->Write( OLESTR("Variant I4"), &varWrite ));
    Check( S_OK, pbag->Read( OLESTR("Variant I4"), &varRead, NULL ));

    Check( TRUE, varWrite.vt == varRead.vt );
    Check( TRUE, varWrite.lVal == varRead.lVal );

    Check( cRefsOriginal, RELEASE_INTERFACE(pbag) );

}




void
test_BagVtUnknown( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertyBagEx *pbag = NULL;
    ULONG cRefsOriginal = 0;

    // Can't run this test with STGFMT_FILE, because CFlatStorage
    // is not compatible with it.
    if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
        return;

    Status( "VT_UNKNOWN in an IPropertyBagEx\n" );

    pstg->AddRef();
    cRefsOriginal = pstg->Release();

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));
    DeleteBagExProperties( pbag, OLESTR("") );

    CObjectWithPersistStorage *pStgObjectWritten = NULL, *pStgObjectRead = NULL;
    CObjectWithPersistStream *pStmObjectWritten = NULL, *pStmObjectRead = NULL;

    pStgObjectWritten = new CObjectWithPersistStorage( OLESTR("VtUnknown-Storage") );
    pStgObjectRead    = new CObjectWithPersistStorage();

    pStmObjectWritten = new CObjectWithPersistStream( OLESTR("VtUnknown-Stream") );
    pStmObjectRead    = new CObjectWithPersistStream();

    Check( TRUE, NULL != pStgObjectWritten && NULL != pStgObjectRead );
    Check( TRUE, NULL != pStmObjectWritten && NULL != pStmObjectRead );

    VARIANT rgvarRead[2], rgvarWritten[2];

    VariantInit( &rgvarRead[0] );
    VariantInit( &rgvarRead[1] );
    VariantInit( &rgvarWritten[0] );
    VariantInit( &rgvarWritten[1] );

    rgvarWritten[0].vt = VT_UNKNOWN;
    rgvarWritten[0].punkVal = static_cast<IUnknown*>(pStgObjectWritten);

    rgvarWritten[1].vt = VT_BYREF | VT_UNKNOWN;
    IUnknown *punkByRefVal = static_cast<IUnknown*>(pStmObjectWritten);
    rgvarWritten[1].ppunkVal = &punkByRefVal;

    rgvarRead[0].vt = VT_UNKNOWN;
    rgvarRead[0].punkVal = static_cast<IUnknown*>(pStgObjectRead);
    rgvarRead[1].vt = VT_UNKNOWN;
    rgvarRead[1].punkVal = static_cast<IUnknown*>(pStmObjectRead);

    OLECHAR *rgoszName[2] = { OLESTR("VtUnknown (persisted as Storage)"),
                              OLESTR("ByRef VtUnknown (persisted as Stream)") };

    Check( S_OK, pbag->WriteMultiple( 2, rgoszName, reinterpret_cast<PROPVARIANT*>(rgvarWritten) ));
    Check( S_OK, pbag->ReadMultiple( 2, rgoszName, reinterpret_cast<PROPVARIANT*>(rgvarRead), NULL ));

    Check( TRUE, *pStgObjectRead == *pStgObjectWritten );
    Check( TRUE, *pStmObjectRead == *pStmObjectWritten );

    Check( 0, RELEASE_INTERFACE( pStgObjectRead ));
    Check( 0, RELEASE_INTERFACE( pStmObjectRead ));

    PROPVARIANT rgpropvarReadRaw[2];

    PropVariantInit( &rgpropvarReadRaw[0] );
    PropVariantInit( &rgpropvarReadRaw[1] );

    Check( S_OK, pbag->ReadMultiple( 2, rgoszName, rgpropvarReadRaw, NULL ));

    Check( VT_STORED_OBJECT, rgpropvarReadRaw[0].vt );
    Check( VT_STREAMED_OBJECT, rgpropvarReadRaw[1].vt );

    STATSTG statstg;
    Check( S_OK, rgpropvarReadRaw[0].pStorage->Stat( &statstg, STATFLAG_NONAME ));
    Check( TRUE, statstg.clsid == pStgObjectWritten->GetClassID() );

    Check( 0, RELEASE_INTERFACE( pStgObjectWritten ));
    Check( S_OK, PropVariantClear( &rgpropvarReadRaw[0] ));


    CLSID clsid;
    ULONG cbRead;
    Check( S_OK, rgpropvarReadRaw[1].pStream->Read( &clsid, sizeof(clsid), &cbRead ));
    Check( sizeof(clsid), cbRead );
    Check( TRUE, clsid == pStmObjectWritten->GetClassID() );

    Check( 0, RELEASE_INTERFACE( pStmObjectWritten ));
    Check( S_OK, PropVariantClear( &rgpropvarReadRaw[1] ));


    Check( cRefsOriginal, RELEASE_INTERFACE(pbag) );

}   // test_BagVtUnknown


void
test_BagEnum( IStorage *pstg )
{
    IPropertyBagEx *pbag = NULL;
    IEnumSTATPROPBAG *penum = NULL;
    ULONG cFetched;
    ULONG i;
    const OLECHAR * rgoszDelete[] = { OLESTR("") };

    const OLECHAR *rgoszNames[] = { OLESTR("www.microsoft.com/bag/test?prop1"),
                                    OLESTR("www.microsoft.com/bag/test?prop2"),
                                    OLESTR("www.microsoft.com/bag/2test?prop1"),
                                    OLESTR("www.microsoft.com/bag2/test?prop1") };
    STATPROPBAG rgstatpropbag[ ELEMENTS(rgoszNames) + 1 ];

    // Can't run this test with STGFMT_FILE, because CFlatStorage
    // is not compatible with it.
    if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
        return;

    Status( "Property bag enumeration\n" );

    // Initialize the bag
    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));
    DeleteBagExProperties( pbag, OLESTR("") );
    Check( S_OK, pbag->WriteMultiple( ELEMENTS(rgoszNames), rgoszNames, g_rgcpropvarAll ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

    // Try to enum n+1 elements (to get an S_FALSE)
    Check( S_OK, pbag->Enum( NULL, 0, &penum ));
    Check( S_FALSE, penum->Next( ELEMENTS(rgstatpropbag), rgstatpropbag, &cFetched ));
    Check( TRUE, ELEMENTS(rgoszNames) == cFetched );
    for( i = 0; i < cFetched; i++ )
        delete [] rgstatpropbag[i].lpwstrName;
    RELEASE_INTERFACE(penum);

    // Try to enum n elements (should get an S_OK)
    Check( S_OK, pbag->Enum( OLESTR(""), 0, &penum ));
    Check( S_OK, penum->Next( ELEMENTS(rgoszNames), rgstatpropbag, &cFetched ));
    Check( TRUE, ELEMENTS(rgoszNames) == cFetched );
    for( i = 0; i < cFetched; i++ )
        delete [] rgstatpropbag[i].lpwstrName;
    RELEASE_INTERFACE(penum);

    // Enum a subset
    Check( S_OK, pbag->Enum( OLESTR("www.microsoft.com/bag/test"), 0, &penum ));
    Check( S_FALSE, penum->Next( ELEMENTS(rgoszNames), rgstatpropbag, &cFetched ));
    Check( TRUE, 2 == cFetched );
    for( i = 0; i < cFetched; i++ )
        delete [] rgstatpropbag[i].lpwstrName;
    RELEASE_INTERFACE(penum);

    // Enum a non-extant subset
    Check( S_OK, pbag->Enum( OLESTR("dummy"), 0, &penum ));
    Check( S_FALSE, penum->Next( ELEMENTS(rgoszNames), rgstatpropbag, &cFetched ));
    Check( TRUE, 0 == cFetched );
    RELEASE_INTERFACE(penum);

    // Enum a single property
    Check( S_OK, pbag->Enum( OLESTR("www.microsoft.com/bag/test?prop1"), 0, &penum ));
    Check( S_FALSE, penum->Next( 2, rgstatpropbag, &cFetched ));
    Check( 1, cFetched );
    delete[] rgstatpropbag[0].lpwstrName;
    rgstatpropbag[0].lpwstrName = NULL;
    RELEASE_INTERFACE(penum);

    RELEASE_INTERFACE(pbag);


}   // test_BagEnum



void
test_BagCoercion( IStorage *pstg )
{
    IPropertyBag   *pbag = NULL;
    IPropertyBagEx *pbagX = NULL;
    const OLECHAR *rgosz[2];
    PROPVARIANT rgpropvar[2];

    // Can't run this test with STGFMT_FILE, because CFlatStorage
    // is not compatible with it.
    if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
        return;

    Status( "Property bag coercion\n" );

    // Get a bag and a bagex, and clean the bag.

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBag,
                                reinterpret_cast<void**>(&pbag) ));
    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx,
                                reinterpret_cast<void**>(&pbagX) ));

    DeleteBagExProperties( pbagX, OLESTR("") );

    // Initialize the bag with some properties

    rgpropvar[0].vt = VT_I2;
    rgpropvar[0].iVal = 2;
    rgosz[0] = OLESTR("www.microsoft.com/test/i2");

    rgpropvar[1].vt = VT_UI2;
    rgpropvar[1].uiVal = 3;
    rgosz[1] = OLESTR("www.microsoft.com/test/ui2");

    Check( S_OK, pbagX->WriteMultiple( 2, rgosz, rgpropvar ));
    g_pfnFreePropVariantArray( 2, rgpropvar );

    // Read back the properties as (U)I4s with explicit coercion

    rgpropvar[0].vt = VT_I4;
    rgpropvar[1].vt = VT_UI4;

    Check( S_OK, pbagX->ReadMultiple( 2, rgosz, rgpropvar, NULL ));
    Check( TRUE, VT_I4 == rgpropvar[0].vt && 2 == rgpropvar[0].lVal );
    Check( TRUE, VT_UI4 == rgpropvar[1].vt && 3 == rgpropvar[1].ulVal );

    // This is an unrelated test, but while we're here, let's verify that we
    // can't write a PropVariant (non-Variant) type through the Bag interface.

    rgpropvar[0].vt= VT_I8;
    rgpropvar[0].hVal.QuadPart = 1;

    Check( STG_E_INVALIDPARAMETER, pbag->Write( rgosz[0],
                                                reinterpret_cast<VARIANT*>(&rgpropvar[0]) ));

    //--------
    rgpropvar[0].vt = VT_LPSTR;
    rgpropvar[0].pszVal = "Hello, world";
    rgpropvar[1].vt = VT_I4;
    rgpropvar[1].iVal = 123;

    Check( S_OK, pbagX->WriteMultiple( 2, rgosz, rgpropvar ));

    rgpropvar[0].vt = VT_EMPTY;
    rgpropvar[0].pszVal = NULL;
    rgpropvar[1].vt = VT_EMPTY;
    rgpropvar[1].iVal = -1;

    Check( S_OK, pbagX->ReadMultiple( 2, rgosz, rgpropvar, NULL ));
    Check( TRUE, VT_LPSTR == rgpropvar[0].vt
                        && 0==strcmp( "Hello, world", rgpropvar[0].pszVal ) );
    Check( TRUE, VT_I4 == rgpropvar[1].vt && 123 == rgpropvar[1].iVal );
    g_pfnFreePropVariantArray( 2, rgpropvar );

    //-------- Coercing Variant to Variant ------------------

    rgpropvar[0].vt = VT_I4;
    rgpropvar[0].lVal = 123;
    rgpropvar[1].vt = VT_I4;
    rgpropvar[1].lVal = 123;

    Check( S_OK, pbagX->WriteMultiple( 2, rgosz, rgpropvar ));

    rgpropvar[0].vt = VT_BSTR;
    rgpropvar[1].vt = VT_I4;

    Check( S_OK, pbagX->ReadMultiple( 2, rgosz, rgpropvar, NULL ));

    Check( TRUE, VT_BSTR == rgpropvar[0].vt
                        && !wcscmp( L"123", rgpropvar[0].bstrVal ));
    Check( TRUE, VT_I4 == rgpropvar[1].vt && 123 == rgpropvar[1].iVal );
    g_pfnFreePropVariantArray( 2, rgpropvar );


    //-------- Coercing PropVariant To PropVariant ------------
#define TEST_I8_VAL ((LONGLONG)1024*1000*1000*1000+42);


    rgpropvar[0].vt = VT_LPWSTR;
    rgpropvar[0].pwszVal = L"-312";
    rgpropvar[1].vt = VT_I8;
    rgpropvar[1].hVal.QuadPart = TEST_I8_VAL;

    Check( S_OK, pbagX->WriteMultiple( 2, rgosz, rgpropvar ));

    rgpropvar[0].vt = VT_I4;
    rgpropvar[0].pszVal = NULL;
    rgpropvar[1].vt = VT_LPWSTR;
    rgpropvar[1].hVal.QuadPart = -1;

    Check( S_OK, pbagX->ReadMultiple(2, rgosz, rgpropvar, NULL ) );

    Check( TRUE, VT_I4 == rgpropvar[0].vt && -312 == rgpropvar[0].lVal );
    Check( TRUE, VT_LPWSTR == rgpropvar[1].vt
                        && !wcscmp( L"1024000000042", rgpropvar[1].pwszVal ) );
    g_pfnFreePropVariantArray( 2, rgpropvar );


    //-------- Implcit Coercion PropVariant To Variant ------------
    rgpropvar[0].vt = VT_I8;
    rgpropvar[0].hVal.QuadPart = -666;
    rgpropvar[1].vt = VT_VECTOR | VT_LPSTR;
    rgpropvar[1].calpstr.cElems = 5;
    rgpropvar[1].calpstr.pElems = new LPSTR[5];
    rgpropvar[1].calpstr.pElems[0] = "Thirty Days hath September,";
    rgpropvar[1].calpstr.pElems[1] = "April, June and No Wonder?";
    rgpropvar[1].calpstr.pElems[2] = "All the Rest Have Thirty One";
    rgpropvar[1].calpstr.pElems[3] = "Except my dear Grand Mother.";
    rgpropvar[1].calpstr.pElems[4] = "She Has a Bright Red Tricycle.";

    Check( S_OK, pbagX->WriteMultiple( 2, rgosz, rgpropvar ));
    delete rgpropvar[1].calpstr.pElems;
    PropVariantInit(&rgpropvar[0]);
    PropVariantInit(&rgpropvar[1]);

    rgpropvar[0].vt = VT_EMPTY;
    rgpropvar[1].vt = VT_EMPTY;

    Check( S_OK, pbag->Read(rgosz[0], (VARIANT*)&rgpropvar[0], NULL ) );
    Check( S_OK, pbag->Read(rgosz[1], (VARIANT*)&rgpropvar[1], NULL ) );

    Check( TRUE, VT_I4 == rgpropvar[0].vt && -666 == rgpropvar[0].lVal );
    Check( TRUE, (VT_BSTR|VT_ARRAY) == rgpropvar[1].vt );
    g_pfnFreePropVariantArray( 2, rgpropvar );

    //
    // UnCoercible.
    //
    rgpropvar[0].vt = VT_UNKNOWN;
    rgpropvar[0].iVal = 42;   // GARBAGE value; untouched in the error path
    Check( DISP_E_TYPEMISMATCH, pbagX->ReadMultiple( 1, rgosz, rgpropvar, NULL ));
    Check( TRUE, VT_UNKNOWN == rgpropvar[0].vt && 42==rgpropvar[0].iVal );

    RELEASE_INTERFACE(pbagX);
    RELEASE_INTERFACE(pbag);

}   // test_BagCoercion

#define LOAD_VARIANT(var,vartype,field,value) (var).field = (value); (var).vt = vartype

void
test_ByRef( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    FMTID fmtid;

    Status( "ByRef Variants\n" );

    UuidCreate( &fmtid );

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));
    Check( S_OK, pPropSetStg->Create( fmtid, NULL, PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    PROPVARIANT rgvarWrite[17], rgvarRead[17];
    CPropSpec rgcpropspec[17];

    BYTE bVal = 1;
    LOAD_VARIANT(rgvarWrite[0], VT_UI1|VT_BYREF, pbVal, &bVal);
    rgcpropspec[0] = OLESTR("VT_UI1|VT_BYREF");

    SHORT iVal = 2;
    LOAD_VARIANT(rgvarWrite[1], VT_I2|VT_BYREF, piVal, &iVal );
    rgcpropspec[1] = OLESTR("VT_I2|VY_BYREF");

    LONG lVal = 3;
    LOAD_VARIANT(rgvarWrite[2], VT_I4|VT_BYREF, plVal, &lVal );
    rgcpropspec[2] = OLESTR("VT_I4|VY_BYREF");

    FLOAT fltVal = (float)4.1;
    LOAD_VARIANT(rgvarWrite[3], VT_R4|VT_BYREF, pfltVal, &fltVal );
    rgcpropspec[3] = OLESTR("VT_I4|VT_BYREF");

    DOUBLE dblVal = 5.2;
    LOAD_VARIANT(rgvarWrite[4], VT_R8|VT_BYREF, pdblVal, &dblVal );
    rgcpropspec[4] = OLESTR("VT_R8|VT_BYREF");

    VARIANT_BOOL boolVal = VARIANT_TRUE;
    LOAD_VARIANT(rgvarWrite[5], VT_BOOL|VT_BYREF, pboolVal, &boolVal );
    rgcpropspec[5] = OLESTR("VT_BOOL|VT_BYREF");

    SCODE scode = 6;
    LOAD_VARIANT(rgvarWrite[6], VT_ERROR|VT_BYREF, pscode, &scode );
    rgcpropspec[6] = OLESTR("VT_ERROR|VT_BYREF");

    CY cyVal = { 7 };
    LOAD_VARIANT(rgvarWrite[7], VT_CY|VT_BYREF, pcyVal, &cyVal );
    rgcpropspec[7] = OLESTR("VT_CY|VT_BYREF");

    DATE date = 8;
    LOAD_VARIANT(rgvarWrite[8], VT_DATE|VT_BYREF, pdate, &date );
    rgcpropspec[8] = OLESTR("VT_DATE|VT_BYREF");

    BSTR bstrVal = SysAllocString( OLESTR("9") );
    LOAD_VARIANT(rgvarWrite[9], VT_BSTR|VT_BYREF, pbstrVal, &bstrVal );
    rgcpropspec[9] = OLESTR("VT_BSTR|VT_BYREF");

    DECIMAL decVal = { 10, 9, 8, 7, 6 };
    LOAD_VARIANT(rgvarWrite[10], VT_DECIMAL|VT_BYREF, pdecVal, &decVal );
    rgcpropspec[10] = OLESTR("VT_DECIMAL|VT_BYREF");

    CHAR cVal = 11;
    LOAD_VARIANT(rgvarWrite[11], VT_I1 | VT_BYREF, pcVal, &cVal );
    rgcpropspec[11] = OLESTR("VT_I1|VT_BYREF");

    USHORT uiVal = 12;
    LOAD_VARIANT(rgvarWrite[12], VT_UI2 | VT_BYREF, puiVal, &uiVal );
    rgcpropspec[12] = OLESTR("VT_UI2|VT_BYREF");

    ULONG ulVal = 13;
    LOAD_VARIANT(rgvarWrite[13], VT_UI4 | VT_BYREF, pulVal, &ulVal );
    rgcpropspec[13] = OLESTR("VT_UI4|VT_BYREF");

    INT intVal = 14;
    LOAD_VARIANT(rgvarWrite[14], VT_INT | VT_BYREF, pintVal, &intVal );
    rgcpropspec[14] = OLESTR("VT_INT|VT_BYREF");

    UINT uintVal = 15;
    LOAD_VARIANT(rgvarWrite[15], VT_UINT | VT_BYREF, puintVal, &uintVal );
    rgcpropspec[15] = OLESTR("VT_UINT | VT_BYREF");

    CPropVariant cpropvarVal = (long) 16;
    Check( VT_I4, cpropvarVal.vt );
    LOAD_VARIANT(rgvarWrite[16], VT_VARIANT| VT_BYREF, pvarVal, &cpropvarVal );
    rgcpropspec[16] = OLESTR("VT_VARIANT | VT_BYREF");


    Check( S_OK, pPropStg->WriteMultiple( sizeof(rgvarWrite)/sizeof(rgvarWrite[0]),
                                          rgcpropspec,
                                          reinterpret_cast<PROPVARIANT*>(rgvarWrite),
                                          PID_FIRST_USABLE ));

    for( int i = 0; i < sizeof(rgvarRead)/sizeof(rgvarRead[0]); i++ )
        PropVariantInit( &rgvarRead[i] );

    Check( S_OK, pPropStg->ReadMultiple( sizeof(rgvarRead)/sizeof(rgvarRead[0]),
                                         rgcpropspec,
                                         reinterpret_cast<PROPVARIANT*>(rgvarRead) ));

    Check( VT_UI1, rgvarRead[0].vt );
    Check( TRUE, rgvarRead[0].bVal == *rgvarWrite[0].pbVal );

    Check( VT_I2, rgvarRead[1].vt );
    Check( TRUE, rgvarRead[1].iVal == *rgvarWrite[1].piVal );

    Check( VT_I4, rgvarRead[2].vt );
    Check( TRUE, rgvarRead[2].lVal == *rgvarWrite[2].plVal );

    Check( VT_R4, rgvarRead[3].vt );
    Check( TRUE, rgvarRead[3].fltVal == *rgvarWrite[3].pfltVal );

    Check( VT_R8, rgvarRead[4].vt );
    Check( TRUE, rgvarRead[4].dblVal == *rgvarWrite[4].pdblVal );

    Check( VT_BOOL, rgvarRead[5].vt );
    Check( TRUE, rgvarRead[5].boolVal == *rgvarWrite[5].pboolVal );

    Check( VT_ERROR, rgvarRead[6].vt );
    Check( TRUE, rgvarRead[6].scode == *rgvarWrite[6].pscode );

    Check( VT_CY, rgvarRead[7].vt );
    Check( 0, memcmp( &rgvarRead[7].cyVal, rgvarWrite[7].pcyVal, sizeof(CY) ));

    Check( VT_DATE, rgvarRead[8].vt );
    Check( TRUE, rgvarRead[8].date == *rgvarWrite[8].pdate );

    Check( VT_BSTR, rgvarRead[9].vt );
    Check( 0, ocscmp( rgvarRead[9].bstrVal, *rgvarWrite[9].pbstrVal ));

    Check( VT_DECIMAL, rgvarRead[10].vt );
    Check( 0, memcmp( &rgvarRead[10].decVal.scale, &rgvarWrite[10].pdecVal->scale,
                      sizeof(decVal) - sizeof(decVal.wReserved) ));

    Check( VT_I1, rgvarRead[11].vt );
    Check( TRUE, rgvarRead[11].cVal == *rgvarWrite[11].pcVal );

    Check( VT_UI2, rgvarRead[12].vt );
    Check( TRUE, rgvarRead[12].uiVal == *rgvarWrite[12].puiVal );

    Check( VT_UI4, rgvarRead[13].vt );
    Check( TRUE, rgvarRead[13].ulVal == *rgvarWrite[13].pulVal );

    Check( VT_INT, rgvarRead[14].vt );
    Check( TRUE, rgvarRead[14].intVal == *rgvarWrite[14].pintVal );

    Check( VT_UINT, rgvarRead[15].vt );
    Check( TRUE, rgvarRead[15].uintVal == *rgvarWrite[15].puintVal );

    Check( VT_I4, rgvarRead[16].vt );
    Check( TRUE, rgvarRead[16].lVal == rgvarWrite[16].pvarVal->lVal );


    Check( 0, RELEASE_INTERFACE(pPropStg) );
    RELEASE_INTERFACE(pPropSetStg);

    g_pfnFreePropVariantArray( sizeof(rgvarRead)/sizeof(rgvarRead[0]), rgvarRead );
    SysFreeString( bstrVal );

}



void
test_SettingLocalization( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    FMTID fmtid;
    CPropVariant rgcpropvarWrite[3], rgcpropvarRead[3];
    CPropSpec    rgcpropspec[3];
    ULONG cRefsOriginal = GetRefCount( pstg );

    Status( "Changing localization properties\n" );

    UuidCreate( &fmtid );

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));

    for( int i = 0; i < 2; i++ )
    {
        // Create a unicode or ansi property set

        Check( S_OK, pPropSetStg->Create( fmtid, NULL,
                                          0 == i ? PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI,
                                          STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                          &pPropStg ));

        //  ---------------------------
        //  Change the codepage to Ansi
        //  ---------------------------

        // Set the codepage.  This should work because it's currently empty
        // (note that it's also currently Unicode).  Set it to GetACP+1 just
        // to be sure that we can set a non-default codepage.

        rgcpropspec[0] = PID_CODEPAGE;
        rgcpropvarWrite[0] = (short) (GetACP() + 1);
        Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->ReadMultiple( 1, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );

        // Now set the codepage to GetACP so that we can work on it.

        rgcpropvarWrite[0] = (short) GetACP();
        Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->ReadMultiple( 1, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );

        // Write some named properties.  The VT_LPSTR shouldn't get converted to Unicode
        // now that this is an Ansi property set.

        rgcpropvarWrite[0] = "Hello, world";
        rgcpropvarWrite[1].SetBSTR( OLESTR("How are you?") );
        rgcpropspec[0] = PID_FIRST_USABLE;
        rgcpropspec[1] = OLESTR("Second property name");
        Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        // If we stat the IPropertyStorage, it should call itself Ansi.

        STATPROPSETSTG statpropsetstg;
        Check( S_OK, pPropStg->Stat( &statpropsetstg ));
        Check( PROPSETFLAG_ANSI, PROPSETFLAG_ANSI & statpropsetstg.grfFlags );

        // Verify that we can close and re-open it and everything's still the same.

        Check( 0, RELEASE_INTERFACE(pPropStg) );
        Check( S_OK, pPropSetStg->Open( fmtid, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pPropStg ));

        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        Check( S_OK, pPropStg->Stat( &statpropsetstg ));
        Check( PROPSETFLAG_ANSI, PROPSETFLAG_ANSI & statpropsetstg.grfFlags );

        //  ------------------------------
        //  Change the codepage to Unicode
        //  ------------------------------

        // Clear out the property set.

        PROPID propidDictionary = PID_DICTIONARY;
        Check( S_OK, pPropStg->DeleteMultiple( 2, rgcpropspec ));
        Check( S_OK, pPropStg->DeletePropertyNames( 1, &propidDictionary ));

        // Switch to Unicode

        rgcpropvarWrite[0] = (short) CP_WINUNICODE;
        rgcpropspec[0] = PID_CODEPAGE;
        Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->ReadMultiple( 1, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarRead[0] == rgcpropvarWrite[0] );

        // Verify with a Stat

        Check( S_OK, pPropStg->Stat( &statpropsetstg ));
        Check( 0, PROPSETFLAG_ANSI & statpropsetstg.grfFlags );

        // Write & read some properties again.  This time the LPSTR should be converted.

        rgcpropvarWrite[0] = "Hello, world";
        rgcpropvarWrite[1].SetBSTR( OLESTR("How are you?") );
        rgcpropspec[0] = PID_FIRST_USABLE;
        rgcpropspec[1] = OLESTR("Second property name");
        Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        // Close, reopen, and read/stat again

        Check( 0, RELEASE_INTERFACE(pPropStg) );
        Check( S_OK, pPropSetStg->Open( fmtid, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pPropStg ));

        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        Check( S_OK, pPropStg->Stat( &statpropsetstg ));
        Check( 0, PROPSETFLAG_ANSI & statpropsetstg.grfFlags );

        Check( 0, RELEASE_INTERFACE(pPropStg) );

    }   // for( int i = 0; i < 2; i++ )


    //  -----------------------
    //  Validate error checking
    //  -----------------------

    // Create a new property set

    Check( S_OK, pPropSetStg->Create( fmtid, NULL,
                                      0 == i ? PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    // After writing a property, we shouldn't be able to set the codepage or LCID

    rgcpropspec[0] = PID_FIRST_USABLE;
    rgcpropvarWrite[0] = (long) 1234;
    Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    rgcpropspec[0] = PID_CODEPAGE;
    rgcpropvarWrite[0] = (short) 1234;
    Check( STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    rgcpropspec[0] = PID_LOCALE;
    rgcpropvarWrite[0] = (ULONG) 5678;
    Check( STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    // But it's settable after deleting the property

    rgcpropspec[0] = PID_FIRST_USABLE;
    Check( S_OK, pPropStg->DeleteMultiple( 1, rgcpropspec ));

    rgcpropspec[0] = PID_CODEPAGE;
    rgcpropvarWrite[0] = (short) 1234;
    Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    rgcpropspec[1] = PID_LOCALE;
    rgcpropvarWrite[1] = (ULONG) 5678;
    Check( S_OK, pPropStg->WriteMultiple( 1, &rgcpropspec[1], &rgcpropvarWrite[1], PID_FIRST_USABLE ));

    Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPropStg->ReadMultiple(2, rgcpropspec, rgcpropvarRead ));
    Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
    Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );

    // But again it's not writable if there's a name in the dictionary

    rgcpropspec[0] = PID_CODEPAGE;
    rgcpropvarWrite[0] = (short) CP_WINUNICODE;
    Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    PROPID rgpropid[1] = { PID_FIRST_USABLE };
    LPOLESTR rglposz[1] = { OLESTR("Hello") };

    Check( S_OK, pPropStg->WritePropertyNames( 1, rgpropid, rglposz ));

    Check( STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));


    Check( 0, RELEASE_INTERFACE(pPropStg) );
    Check( cRefsOriginal, RELEASE_INTERFACE(pPropSetStg) );

}



void
test_ExtendedTypes( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    FMTID fmtid;

    Status( "Extended Types\n" );

    UuidCreate( &fmtid );

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));
    Check( S_OK, pPropSetStg->Create( fmtid, NULL, PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    CPropVariant rgcpropvarWrite[5], rgcpropvarRead[5];
    CPropSpec rgcpropspec[5];


    rgcpropvarWrite[0] = (CHAR) 1;
    rgcpropspec[0] = OLESTR("VT_I1");

    DECIMAL decVal = { 10, 9, 8, 7, 6 };
    rgcpropvarWrite[1] = decVal;
    rgcpropspec[1] = OLESTR("VT_DECIMAL");

    rgcpropvarWrite[2].SetINT( 2 );
    rgcpropspec[2] = OLESTR("VT_INT");

    rgcpropvarWrite[3].SetUINT( 3 );
    rgcpropspec[3] = OLESTR("VT_UINT");

    rgcpropvarWrite[4][1] = (CHAR) 2;
    rgcpropvarWrite[4][0] = (CHAR) 1;
    rgcpropspec[4] = OLESTR("VT_VECTOR|VT_I1");

    Check( S_OK, pPropStg->WriteMultiple( sizeof(rgcpropvarWrite)/sizeof(rgcpropvarWrite[0]),
                                          rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    for( int i = 0; i < sizeof(rgcpropvarRead)/sizeof(rgcpropvarRead[0]); i++ )
        PropVariantInit( &rgcpropvarRead[i] );
    CheckFormatVersion(pPropStg, PROPSET_WFORMAT_EXPANDED_VTS);


    Check( S_OK, pPropStg->ReadMultiple( sizeof(rgcpropvarRead)/sizeof(rgcpropvarRead[0]),
                                         rgcpropspec,
                                         reinterpret_cast<PROPVARIANT*>(rgcpropvarRead) ));

    Check( rgcpropvarRead[0].vt, rgcpropvarWrite[0].vt );
    Check( TRUE, rgcpropvarWrite[0].cVal == rgcpropvarRead[0].cVal );

    Check( rgcpropvarRead[1].vt, rgcpropvarWrite[1].vt );
    Check( 0, memcmp( &rgcpropvarRead[1].decVal.scale, &rgcpropvarWrite[1].decVal.scale,
                      sizeof(rgcpropvarRead[1].decVal) - sizeof(rgcpropvarRead[1].decVal.wReserved) ));

    Check( rgcpropvarRead[2].vt, rgcpropvarWrite[2].vt );
    Check( rgcpropvarRead[2].intVal, rgcpropvarWrite[2].intVal );

    Check( rgcpropvarRead[3].vt, rgcpropvarWrite[3].vt );
    Check( rgcpropvarRead[3].uintVal, rgcpropvarWrite[3].uintVal );

    Check( TRUE, rgcpropvarRead[4] == rgcpropvarWrite[4] );

    Check( 0, RELEASE_INTERFACE(pPropStg) );
    RELEASE_INTERFACE(pPropSetStg);
}



void
test_StgOnHandle( OLECHAR *poszDir )
{
    HRESULT hr = S_OK;
    OLECHAR oszFile[ MAX_PATH ], oszDir[ MAX_PATH ];
    CPropVariant cpropvarWrite, cpropvarRead;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hDir = INVALID_HANDLE_VALUE;

    IPropertyBagEx *pbag = NULL;

    Status( "StgOpenStorageOnHandle\n" );

    ocscpy( oszFile, poszDir );
    ocscat( oszFile, OLESTR("test_StgOnHandle") );
    ocscpy( oszDir, poszDir );
    ocscat( oszDir, OLESTR("test_StgOnHandle Dir") );

    // Create a storage and put a property in it.

    Check( S_OK, g_pfnStgCreateStorageEx( oszFile, STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                          DetermineStgFmt( g_enumImplementation ),
                                          0, NULL, NULL,
                                          IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));


    OLECHAR *poszPropName = OLESTR("Prop Name");
    cpropvarWrite = (long) 123;  // VT_I4

    Check( S_OK, pbag->WriteMultiple( 1, &poszPropName, &cpropvarWrite ));
    Check( 0, RELEASE_INTERFACE(pbag) );

    // Create a directory and put a property in it too.

    Check( TRUE, CreateDirectory( oszDir, NULL ));

    hDir = CreateFile( oszDir, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                       NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, INVALID_HANDLE_VALUE );
    Check( TRUE, INVALID_HANDLE_VALUE != hDir );

    Check( S_OK, g_pfnStgOpenStorageOnHandle( hDir, STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                              NULL, NULL,
                                              IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));
    CloseHandle( hDir );

    Check( S_OK, pbag->WriteMultiple( 1, &poszPropName, &cpropvarWrite ));
    Check( 0, RELEASE_INTERFACE(pbag) );

    // Open the file and read the properties

    hFile = CreateFile( oszFile, GENERIC_READ|GENERIC_WRITE, 0,
                        NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL );
    Check( TRUE, INVALID_HANDLE_VALUE != hFile );

    Check( S_OK, g_pfnStgOpenStorageOnHandle( hFile, STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                              NULL, NULL,
                                              IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));

    CloseHandle( hFile );

    PropVariantClear( &cpropvarRead );
    Check( S_OK, pbag->ReadMultiple( 1, &poszPropName, &cpropvarRead, NULL ));
    Check( TRUE, cpropvarRead == cpropvarWrite );

    Check( 0, RELEASE_INTERFACE(pbag) );

    // Open the directory and read the properties

    hFile = CreateFile( oszDir, GENERIC_READ|GENERIC_WRITE, 0,
                        NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );
    Check( TRUE, INVALID_HANDLE_VALUE != hFile );

    Check( S_OK, g_pfnStgOpenStorageOnHandle( hFile, STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                              NULL, NULL,
                                              IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));

    CloseHandle( hFile );

    PropVariantClear( &cpropvarRead );
    Check( S_OK, pbag->ReadMultiple( 1, &poszPropName, &cpropvarRead, NULL ));
    Check( TRUE, cpropvarRead == cpropvarWrite );

    Check( 0, RELEASE_INTERFACE(pbag) );


}



void
test_PropsetOnEmptyFile( OLECHAR *poszDir )
{
    HRESULT hr = S_OK;
    OLECHAR oszFile[ MAX_PATH ];
    CPropVariant cpropvarWrite, cpropvarRead;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    IPropertySetStorage *pset = NULL;

    // We only run this test for NFF property sets; there's special code there
    // for the case of a read-only open of an empty file.

    if( PROPIMP_NTFS != g_enumImplementation ) return;
    Status( "Empty file\n" );

    ocscpy( oszFile, poszDir );
    ocscat( oszFile, OLESTR("test_PropsetOnEmptyFile") );

    // Create a file

    hFile = CreateFile( oszFile, GENERIC_READ|GENERIC_WRITE, 0,
                        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE );
    Check( FALSE, INVALID_HANDLE_VALUE == hFile );
    CloseHandle( hFile );

    // Get a read-only property interface on the file.

    Check( S_OK, StgOpenStorageEx( oszFile, STGM_READ|STGM_SHARE_DENY_WRITE,
                                   STGFMT_ANY, 0, NULL, NULL,
                                   IID_IPropertySetStorage,
                                   reinterpret_cast<void**>(&pset) ));

    Check( 0, RELEASE_INTERFACE(pset) );

}

void
test_PropsetOnHGlobal()
{
    HANDLE hglobal = NULL;
    IPropertyStorage *pPropStg = NULL;
    IStream *pStm = NULL;

    Status( "StgCreate/OpenPropStg on CreateStreamOnHGlobal\n" );

    // Build up an IPropertyStorage on a memory block

    hglobal = GlobalAlloc( GHND, 0 );
    Check( FALSE, NULL == hglobal );

    Check( S_OK, CreateStreamOnHGlobal( hglobal, FALSE, &pStm ));
    hglobal = NULL;

    Check( S_OK, StgCreatePropStg( (IUnknown*) pStm, FMTID_NULL, &CLSID_NULL,
                                   PROPSETFLAG_DEFAULT,
                                   0L, // Reserved
                                   &pPropStg ));

    // Write a Unicode string property to the property set

    CPropVariant rgcpropvarWrite[2] = { L"First Value", L"Second Value" };
    CPropSpec rgcpropspec[2] = { L"First Name", L"Second Name" };


    Check( S_OK, pPropStg->WriteMultiple( 1, &rgcpropspec[0], &rgcpropvarWrite[0], PID_FIRST_USABLE ));

    // Close the IPropertyStorage and IStream.

    Check( S_OK, pPropStg->Commit( STGC_DEFAULT )); // Flush to pStm
    Check( 0, RELEASE_INTERFACE(pPropStg) );

    Check( S_OK, GetHGlobalFromStream( pStm, &hglobal ));
    Check( 0, RELEASE_INTERFACE(pStm) );

    // Reopen everything

    Check( S_OK, CreateStreamOnHGlobal( hglobal, FALSE, &pStm ));
    hglobal = NULL;

    Check( S_OK, StgOpenPropStg( (IUnknown*) pStm, FMTID_NULL,
                                 PROPSETFLAG_DEFAULT,
                                 0L, // Reserved
                                 &pPropStg ));

    // Write another property

    Check( S_OK, pPropStg->WriteMultiple( 1, &rgcpropspec[1], &rgcpropvarWrite[1], PID_FIRST_USABLE ));

    // Read and verify the properties

    CPropVariant rgcpropvarRead[2];

    Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
    Check( TRUE, rgcpropvarRead[0] == rgcpropvarWrite[0] );
    Check( TRUE, rgcpropvarRead[1] == rgcpropvarWrite[1] );

    Check( 0, RELEASE_INTERFACE(pPropStg) );
    Check( S_OK, GetHGlobalFromStream( pStm, &hglobal ));
    Check( 0, RELEASE_INTERFACE(pStm) );

    // Reopen everything using a read-only stream.

    Check( S_OK, CreateStreamOnHGlobal( hglobal, TRUE, &pStm ));
    hglobal = NULL;

    CReadOnlyStream ReadOnlyStream( pStm );

    Check( S_OK, StgOpenPropStg( (IUnknown*) &ReadOnlyStream, FMTID_NULL,
                                 PROPSETFLAG_DEFAULT,
                                 0L, // Reserved
                                 &pPropStg ));

    Check( STG_E_ACCESSDENIED, pPropStg->WriteMultiple( 1, &rgcpropspec[1],
           &rgcpropvarWrite[1], PID_FIRST_USABLE ));

    Check( 0, RELEASE_INTERFACE(pPropStg) );
    Check( 0, RELEASE_INTERFACE(pStm) );

}


void
test_SafeArray( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    FMTID fmtid;
    ULONG crefpstg = 0;

    Status( "SafeArrays\n" );

    UuidCreate( &fmtid );

    pstg->AddRef();
    crefpstg = pstg->Release();

    // Get an IPropertyStorage from the input IStorage

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));
    Check( S_OK, pPropSetStg->Create( fmtid, NULL, PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));


    SAFEARRAY *rgpsa[] = { NULL, NULL, NULL }; //, NULL, NULL };
    CPropVariant *rgcpropvar = NULL;
    SAFEARRAYBOUND rgsaBounds[] = { {2,0}, {3,10}, {4,20} };  // [0..1], [10..12], [20..23]
    ULONG cDims = sizeof(rgsaBounds)/sizeof(rgsaBounds[0]);
    ULONG cElems = 0;

    // Create three SafeArrays to test a fixed sized type, a variable sized type
    // (which is also ByRef), and a Variant.

    rgpsa[0] = SafeArrayCreate( VT_I4, 3, rgsaBounds );   // Try both Create and CreateEx
    Check( TRUE, NULL != rgpsa[0] );

    rgpsa[1] = SafeArrayCreateEx( VT_BSTR, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[1] );

    rgpsa[2] = SafeArrayCreateEx( VT_VARIANT, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[2] );

    /*
    rgpsa[3] = SafeArrayCreateEx( VT_I8, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[3] );

    rgpsa[4] = SafeArrayCreateEx( VT_UI8, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[4] );
    */


    // Determine how many elements are in the SafeArrays, and alloc that
    // many PropVariants.  We'll need this for the SafeArray of Variants.

    cElems = CalcSafeArrayElementCount( rgpsa[0] );
    rgcpropvar = new CPropVariant[ cElems ];
    Check( FALSE, NULL == rgcpropvar );

    // Fill in each of the SafeArrays.

    for( ULONG i = 0; i < cElems; i++ )
    {
        LONG rgIndices[3];

        // Map this this element from linear space to bounds space
        CalcSafeArrayIndices( i, rgIndices, rgsaBounds, cDims );

        // Add an I4
        LONG lVal = static_cast<LONG>(i);
        Check( S_OK, SafeArrayPutElement( rgpsa[0], rgIndices, &lVal ));

        // Add a BSTR
        BSTR bstrVal = SysAllocString( OLESTR("0 BSTR Val") );
        *bstrVal = OLESTR('0') + static_cast<OLECHAR>(i);
        Check( S_OK, SafeArrayPutElement( rgpsa[1], rgIndices, bstrVal ));

        // Add a PropVariant that could be an I4 or a BSTR

        if( i & 1 )
            rgcpropvar[i] = (long) i;
        else
            rgcpropvar[i].SetBSTR( bstrVal );   // Copies string

        Check( S_OK, SafeArrayPutElement( rgpsa[2], rgIndices, &rgcpropvar[i] ));

        // The SafeArrays have copied the BSTR, so we can free our local copy
        SysFreeString( bstrVal );

        // Add I8/UI8
        /*
        LONGLONG llVal = i;
        Check( S_OK, SafeArrayPutElement( rgpsa[3], rgIndices, &llVal ));

        llVal += 1000;
        Check( S_OK, SafeArrayPutElement( rgpsa[4], rgIndices, &llVal ));
        */
    }


    VARIANT rgvarWrite[3], rgvarRead[3];
    PROPVARIANT rgpropvarCopy[3];
    CPropSpec rgcpropspec[3];

    // Load the SafeArrays into PropVariants

    LOAD_VARIANT(rgvarWrite[0], VT_ARRAY|VT_I4, parray, rgpsa[0] );
    rgcpropspec[0] = OLESTR("VT_ARRAY|VT_I4");

    LOAD_VARIANT(rgvarWrite[1], VT_BYREF|VT_ARRAY|VT_BSTR, pparray, &rgpsa[1] );
    rgcpropspec[1] = OLESTR("VT_BYREF|VT_ARRAY|VT_BSTR");

    LOAD_VARIANT(rgvarWrite[2], VT_ARRAY|VT_VARIANT, parray, rgpsa[2] );
    rgcpropspec[2] = OLESTR("VT_ARRAY|VT_VARIANT");

    /*
    LOAD_VARIANT(rgvarWrite[3], VT_ARRAY|VT_I8, parray, rgpsa[3] );
    rgcpropspec[3] = OLESTR("VT_ARRAY|VT_I8");

    LOAD_VARIANT(rgvarWrite[4], VT_ARRAY|VT_UI8, parray, rgpsa[4] );
    rgcpropspec[4] = OLESTR("VT_ARRAY|VT_UI8");
    */

    // Write the PropVariant SafeArrays and verify that the propset version in the
    // header gets incremented.

    Check( S_OK, pPropStg->WriteMultiple( sizeof(rgvarWrite)/sizeof(rgvarWrite[0]),
                                          rgcpropspec,
                                          reinterpret_cast<PROPVARIANT*>(rgvarWrite),
                                          PID_FIRST_USABLE ));
    CheckFormatVersion(pPropStg, PROPSET_WFORMAT_EXPANDED_VTS);

    // Test PropVariantCopy by copying each of the PropVariants and comparing the result.

    for( i = 0; i < sizeof(rgvarRead)/sizeof(rgvarRead[0]); i++ )
    {
        PropVariantInit( &rgpropvarCopy[i] );
        Check( S_OK, g_pfnPropVariantCopy( &rgpropvarCopy[i], reinterpret_cast<PROPVARIANT*>(&rgvarWrite[i]) ));
        Check( rgpropvarCopy[i].vt, rgvarWrite[i].vt );

        if( VT_BYREF & rgpropvarCopy[i].vt )
            CompareSafeArrays( *rgpropvarCopy[i].pparray, *rgvarWrite[i].pparray );
        else
            CompareSafeArrays( rgpropvarCopy[i].parray, rgvarWrite[i].parray );

        // As long as we're looping, let's start init-ing the Read array too.
        VariantInit( &rgvarRead[i] );
    }

    // Read back the values that we wrote.

    Check( S_OK, pPropStg->ReadMultiple( sizeof(rgvarRead)/sizeof(rgvarRead[0]),
                                         rgcpropspec,
                                         reinterpret_cast<PROPVARIANT*>(rgvarRead) ));

    // Validate the Read values.  For the second one, the byref should no longer
    // be set.

    Check( rgvarWrite[0].vt, rgvarRead[0].vt );
    CompareSafeArrays( rgvarWrite[0].parray, rgvarRead[0].parray );

    Check( 0, rgvarRead[1].vt & VT_BYREF );
    Check( rgvarWrite[1].vt, rgvarRead[1].vt|VT_BYREF );
    CompareSafeArrays( *rgvarWrite[1].pparray, rgvarRead[1].parray );

    Check( rgvarWrite[2].vt, rgvarRead[2].vt );
    CompareSafeArrays( rgvarWrite[2].parray, rgvarRead[2].parray );

    /*
    Check( rgvarWrite[3].vt, rgvarRead[3].vt );
    CompareSafeArrays( rgvarWrite[3].parray, rgvarRead[3].parray );

    Check( rgvarWrite[4].vt, rgvarRead[4].vt );
    CompareSafeArrays( rgvarWrite[4].parray, rgvarRead[4].parray );
    */

    // Free the safearrays (they're in rgvarWrite, but we don't clear that).
    Check( S_OK, SafeArrayDestroy( rgpsa[0] ));
    Check( S_OK, SafeArrayDestroy( rgpsa[1] ));
    Check( S_OK, SafeArrayDestroy( rgpsa[2] ));
    /*
    Check( S_OK, SafeArrayDestroy( rgpsa[3] ));
    Check( S_OK, SafeArrayDestroy( rgpsa[4] ));
    */

    Check( S_OK, g_pfnFreePropVariantArray( sizeof(rgpropvarCopy)/sizeof(rgpropvarCopy[0]),
                                            reinterpret_cast<PROPVARIANT*>(rgpropvarCopy) ));
    Check( S_OK, g_pfnFreePropVariantArray( sizeof(rgvarRead)/sizeof(rgvarRead[0]),
                                            reinterpret_cast<PROPVARIANT*>(rgvarRead) ));

    Check( S_OK, g_pfnFreePropVariantArray( cElems, rgcpropvar ));


    //  ------------------------------------------------------
    //  Verify that we can't write a safearray with a bad type
    //  ------------------------------------------------------

    LONG rgIndices[] = { 0 };
    VARIANT *pvar;

    rgpsa[0] = SafeArrayCreateVector( VT_VARIANT, 0, 1 );
    Check( TRUE, NULL != rgpsa[0] );
    SafeArrayPtrOfIndex( rgpsa[0], rgIndices, reinterpret_cast<void**>(&pvar) );
    pvar->vt = VT_STREAM;

    rgcpropvar[0].vt = VT_ARRAY | VT_VARIANT;
    rgcpropvar[0].parray = rgpsa[0];
    rgpsa[0] = NULL;


    // In NT5, this returned HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), which was
    // the error that StgConvertVariantToPropertyNoEH got from SafeArrayGetVartype.
    // In Whistler, SafeArrayGetVartype is returning success, so the error doesn't
    // get caught until the recursive call to StgConvertVariantToPropertyNoEH,
    // which returns STATUS_INVALID_PARAMETER, which gets translated into
    // STG_E_INVALIDPARAMETER.

    Check( STG_E_INVALIDPARAMETER,
           pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvar, PID_FIRST_USABLE ));

    // Clear the propvar we just used (which also destroys the safearray)
    Check( S_OK, g_pfnPropVariantClear( &rgcpropvar[0] ) );



    Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvar, PID_FIRST_USABLE ));

    Check( S_OK, g_pfnFreePropVariantArray( 2, rgcpropvar ));



    Check( 0, RELEASE_INTERFACE(pPropStg) );
    Check( crefpstg, RELEASE_INTERFACE(pPropSetStg) );

    delete[] rgcpropvar;
}


void
test_ReadOnlyReservedProperties( IStorage *pStg )
{
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    CPropVariant cpropvar = L"Property Value";
    CPropSpec cpropspec;
    FMTID fmtid;
    ULONG cRefsOriginal = GetRefCount(pStg);

    Status( "Read-only reserved PROPIDs\n" );

    UuidCreate( &fmtid );

    Check( S_OK, pStg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));
    Check( S_OK, pPropSetStg->Create( fmtid, NULL, PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    cpropspec = PID_BEHAVIOR + 1;
    Check( STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, &cpropspec, &cpropvar, PID_FIRST_USABLE ));

    cpropspec = PID_MAX_READONLY;
    Check( STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, &cpropspec, &cpropvar, PID_FIRST_USABLE ));

    cpropspec = PID_MAX_READONLY + 1;
    Check( S_OK, pPropStg->WriteMultiple( 1, &cpropspec, &cpropvar, PID_FIRST_USABLE ));

    Check( 0, RELEASE_INTERFACE(pPropStg) );
    Check( cRefsOriginal, RELEASE_INTERFACE(pPropSetStg) );


}


void
test_LowMemory( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertySetStorage *psetstg = NULL;
    IPropertyStorage *ppropstg = NULL;
    IStorageTest *ptest = NULL;
    CPropSpec rgcpropspec[2];
    CPropVariant rgcpropvarWrite[2], rgcpropvarRead[2];
    int i;

    Status( "Low-memory mapped stream code\n" );

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&psetstg) ));

    for( i = 0; i < 2; i++ )
    {
        DWORD propsetflag = i == 0 ? PROPSETFLAG_DEFAULT : PROPSETFLAG_NONSIMPLE;

        FMTID fmtid;
        UuidCreate( &fmtid );

        Check( S_OK, psetstg->Create( fmtid, NULL, propsetflag,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &ppropstg ));

        // Go into low-memory mode

        hr = ppropstg->QueryInterface( IID_IStorageTest, reinterpret_cast<void**>(&ptest) );
        if( SUCCEEDED(hr) )
            hr = ptest->SimulateLowMemory( TRUE );

        // IStorageTest isn't available in a free build.  As of this writing
        // it's not available in docfile.

        if( E_NOINTERFACE == hr )
        {
            Status( "   ... Partially skipping, IStorageTest not available\n" );
            continue;
        }
        else
            Check( S_OK, hr );


        // Write and read properties

        rgcpropspec[0] = OLESTR("First property");
        rgcpropvarWrite[0] = "Hello, world";
        rgcpropspec[1] = OLESTR("Second property");
        rgcpropvarWrite[1] = "How are you?";

        Check( S_OK, ppropstg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, ppropstg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        // Write, commit, and read

        g_pfnFreePropVariantArray( 2, rgcpropvarWrite );
        rgcpropvarWrite[0] = CBlob( L"go blue" );
        rgcpropvarWrite[1] = static_cast<CLSID>(fmtid);

        Check( S_OK, ppropstg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, ppropstg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));

        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        Check( S_OK, ppropstg->Commit( STGC_DEFAULT ));
        Check( S_OK, ppropstg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        // Write, close, reopen, and read

        g_pfnFreePropVariantArray( 2, rgcpropvarWrite );
        rgcpropvarWrite[0] = 0.1234;
        rgcpropvarWrite[1] = CClipData("Hi");
        Check( S_OK, ppropstg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

        RELEASE_INTERFACE(ptest);
        RELEASE_INTERFACE(ppropstg);

        Check( S_OK, psetstg->Open( fmtid, STGM_READ|STGM_SHARE_EXCLUSIVE, &ppropstg ));
        Check( S_OK, ppropstg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        RELEASE_INTERFACE(ppropstg);

    }   // for( i = 0; i < 2; i++ )

//Exit:

    RELEASE_INTERFACE(ptest);
    RELEASE_INTERFACE(ppropstg);
    RELEASE_INTERFACE(psetstg);

}


void
test_BagOpenMethod( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertyBagEx *pbag = NULL;
    OLECHAR * rgoszDelete[2];
    CPropVariant cpropvar;
    PROPVARIANT propvar;
    VERSIONEDSTREAM VersionedStream;
    GUID guidVersion2;
    OLECHAR *pwszName = { OLESTR("Versioned Stream") };
    IUnknown *punk = NULL;
    IStream *pstm = NULL;
    CHAR rgbStreamDataWrite[50] = "Stream data";
    CHAR rgbStreamDataRead[100];
    ULONG cbRead;
    STATSTG statstg;

    // Can't run this test with STGFMT_FILE, because CFlatStorage
    // is not compatible with it.
    if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
        return;

    Status( "IPropertyBagEx::Open\n" );

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));

    // Create a VersionedStream
    UuidCreate( &VersionedStream.guidVersion );
    VersionedStream.pStream = NULL;
    cpropvar = VersionedStream;

    // Write the versioned stream (causing a stream to be created) and read it back.

    Check( S_OK, pbag->WriteMultiple( 1, &pwszName, &cpropvar ));
    cpropvar.Clear();

    Check( S_OK, pbag->ReadMultiple( 1, &pwszName, &cpropvar, NULL ));
    Check( TRUE, VT_VERSIONED_STREAM == cpropvar.VarType() && NULL != cpropvar.pVersionedStream->pStream );

    // Put some data in the stream and release it.
    Check( S_OK, cpropvar.pVersionedStream->pStream->Write( rgbStreamDataWrite, sizeof(rgbStreamDataWrite), NULL ));

    cpropvar.Clear();

    // Now read that VersionedStream, with the proper GUID
    Check( S_OK, pbag->Open( NULL, pwszName, VersionedStream.guidVersion, 0, IID_IStream, &punk ));
    Check( S_OK, punk->QueryInterface( IID_IStream, reinterpret_cast<void**>(&pstm) ));

    // Verify the data.

    Check( S_OK, pstm->Read( rgbStreamDataRead, sizeof(rgbStreamDataRead), &cbRead ));
    Check( TRUE, cbRead == sizeof(rgbStreamDataWrite) );
    Check( TRUE, 0 == strcmp( rgbStreamDataWrite, rgbStreamDataRead ));

    RELEASE_INTERFACE(pstm);
    RELEASE_INTERFACE(punk);

    // Attempt to read the same VersionedStream with a bad GUID
    UuidCreate( &guidVersion2 );
    Check( STG_E_FILEALREADYEXISTS, pbag->Open( NULL, pwszName, guidVersion2, 0, IID_IStream, &punk ));

    // Attempt with a bad guid again, but this time cause a new property to be created.
    Check( S_OK, pbag->Open( NULL, pwszName, guidVersion2, OPENPROPERTY_OVERWRITE, IID_IStream, &punk ));
    Check( S_OK, punk->QueryInterface( IID_IStream, reinterpret_cast<void**>(&pstm) ));
    Check( S_OK, pstm->Stat( &statstg, STATFLAG_NONAME ));
    Check( TRUE, CULargeInteger(0) == statstg.cbSize );

    RELEASE_INTERFACE(pstm);
    RELEASE_INTERFACE(punk);

    // Show that we can overwrite an existing property of a different type, but only
    // by setting the overwrite flag.

    cpropvar = static_cast<long>(45);
    Check( S_OK, pbag->WriteMultiple( 1, &pwszName, &cpropvar ));
    Check( STG_E_FILEALREADYEXISTS, pbag->Open( NULL, pwszName, guidVersion2, 0, IID_IStream, &punk ));
    Check( S_OK, pbag->Open( NULL, pwszName, guidVersion2, OPENPROPERTY_OVERWRITE, IID_IStream, &punk ));
    RELEASE_INTERFACE(punk);

    // Show that if a property doesn't exist, Open creates it.

    Check( S_OK, pbag->DeleteMultiple( 1, &pwszName, 0 ));
    PropVariantClear( &cpropvar );
    Check( S_FALSE, pbag->ReadMultiple( 1, &pwszName, &cpropvar, NULL ));
    Check( S_OK, pbag->Open( NULL, pwszName, guidVersion2, 0, IID_IStream, &punk ));
    RELEASE_INTERFACE(punk);


    RELEASE_INTERFACE(pbag);

}   // test_BagOpenMethod

void
test_StandaloneAPIs( LPOLESTR ocsDir )
{

    OLECHAR ocsFile[ MAX_PATH + 1 ];
    FMTID fmtidStgPropStg, fmtidStgPropSetStg;

    IStorage *pstg = NULL; //TSafeStorage< IStorage > pstg;

    IStream *pstmInMemory = NULL;
    IStorage *pstgInMemory = NULL;

    IPropertySetStorage *ppropsetstg = NULL; //TSafeStorage< IPropertySetStorage > ppropsetstg;

    CPropVariant rgcpropvar[ CPROPERTIES_ALL ];

    IPropertySetStorage *pPropSetStg;
    IPropertyStorage *pPropStg;
    DWORD propsetflag;
    ULONG cPropertiesAll;

    ULONG ulIndex;

    // Can't run this test with STGFMT_FILE, because CFlatStorage
    // is not compatible with it.
    if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
        return;

    Status( "Standalone API test\n" );

    // Generate FMTIDs.

    UuidCreate( &fmtidStgPropStg );
    UuidCreate( &fmtidStgPropSetStg );

    // Generate a filename from the directory name.

    ocscpy( ocsFile, ocsDir );
    ocscat( ocsFile, OLESTR( "IPropAPIs.stg" ));

    // Create a storage.

    Check( S_OK, g_pfnStgCreateStorageEx( ocsFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L,
                                     NULL,
                                     NULL,
                                     DetermineStgIID( g_enumImplementation ),
                                     (void**) &pstg ));

    // Run the following part of the test twice; once for a simple
    // property set and once for a non-simple.


    for( int i = 0; i < 2; i++ )
    {
        ILockBytes *pLockBytes = NULL;
        IStorage *pstgInMemory = NULL;

        #ifdef _MAC
            Handle hglobal;
            hglobal = NewHandle( 0 );
        #else
            HANDLE hglobal;
            hglobal = GlobalAlloc( GPTR, 0 );
        #endif
        Check( TRUE, NULL != hglobal );

        if( 0 == i )
        {
            // Create simple IPropertyStorage

            Check(S_OK, CreateStreamOnHGlobal( hglobal, TRUE, &pstmInMemory ));

            Check( S_OK, g_pfnStgCreatePropStg( (IUnknown*) pstmInMemory,
                                                fmtidStgPropStg,
                                                &CLSID_NULL,
                                                PROPSETFLAG_ANSI,
                                                0L, // Reserved
                                                &pPropStg ));
        }
        else
        {
            // If we're not allowed to do non-simple, skip out now.

            if( (RESTRICT_SIMPLE_ONLY & g_Restrictions)
                ||
                (RESTRICT_NON_HIERARCHICAL & g_Restrictions) )
            {
                break;
            }

            // Create a non-simple IPropertyStorage

            Check( S_OK, CreateILockBytesOnHGlobal( hglobal, TRUE, &pLockBytes ));

            Check( S_OK, StgCreateDocfileOnILockBytes( pLockBytes,
                                                       STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                                       0,
                                                       &pstgInMemory ));

            Check( S_OK, g_pfnStgCreatePropStg( (IUnknown*) pstgInMemory,
                                                fmtidStgPropStg,
                                                &CLSID_NULL,
                                                PROPSETFLAG_ANSI | PROPSETFLAG_NONSIMPLE,
                                                0,
                                                &pPropStg ));
        }
                                                

        // Write to the property set.

        Check( S_OK, pPropStg->WriteMultiple( 0 == i ? CPROPERTIES_ALL_SIMPLE : CPROPERTIES_ALL,
                                              g_rgcpropspecAll,
                                              g_rgcpropvarAll,
                                              PID_FIRST_USABLE ));
        Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));


        // Read from the property set

        Check( S_OK, pPropStg->ReadMultiple( 0 == i ? CPROPERTIES_ALL_SIMPLE : CPROPERTIES_ALL,
                                              g_rgcpropspecAll,
                                              rgcpropvar ));


        // Compare the properties

        for( ulIndex = 0;
             0 == i ? (ulIndex < CPROPERTIES_ALL_SIMPLE) : (ulIndex < CPROPERTIES_ALL);
             ulIndex++ )
        {
            Check( TRUE, rgcpropvar[ulIndex] == g_rgcpropvarAll[ulIndex] );
            rgcpropvar[ulIndex].Clear();
        }

        pPropStg->Release();
        pPropStg = NULL;

        //  -------------------
        //  Test StgOpenPropStg
        //  -------------------

        // Open the IPropertyStorage

        Check( S_OK, g_pfnStgOpenPropStg( 0 == i
                                            ? (IUnknown*) pstmInMemory
                                            : (IUnknown*) pstgInMemory,
                                          fmtidStgPropStg,
                                          PROPSETFLAG_DEFAULT
                                             | (0 == i ? 0 : PROPSETFLAG_NONSIMPLE),
                                          0L, // Reserved
                                          &pPropStg ));


        // Read from the property set

        Check( S_OK, pPropStg->ReadMultiple( 0 == i ? CPROPERTIES_ALL_SIMPLE : CPROPERTIES_ALL,
                                             g_rgcpropspecAll,
                                             rgcpropvar ));


        // Compare the properties

        for( ulIndex = 0;
             0 == i ? (ulIndex < CPROPERTIES_ALL_SIMPLE) : (ulIndex < CPROPERTIES_ALL);
             ulIndex++ )
        {
            Check( TRUE, rgcpropvar[ulIndex] == g_rgcpropvarAll[ulIndex] );
            rgcpropvar[ulIndex].Clear();
        }

        pPropStg->Release();
        pPropStg = NULL;

        RELEASE_INTERFACE( pstmInMemory );
        RELEASE_INTERFACE( pstgInMemory );
        RELEASE_INTERFACE( pLockBytes );
    }

    //  --------------------------------
    //  Test StgCreatePropSetStg::Create
    //  --------------------------------

    // This is equivalent to the previous tests, but
    // uses StgCreatePropSetStg to create an IPropertySetStorage,
    // and uses that to create a property set.

    // Create the IPropertySetStorage

    Check( S_OK, g_pfnStgCreatePropSetStg( pstg,
                                           0L, // Reserved
                                           &pPropSetStg ));

    // Create an IPropertyStorage.  Create it non-simple, unless the underlying
    // IStorage (i.e. NTFS) doesn't support it.

    if( (RESTRICT_SIMPLE_ONLY & g_Restrictions) || (RESTRICT_NON_HIERARCHICAL & g_Restrictions) )
    {
        propsetflag = PROPSETFLAG_DEFAULT;
        cPropertiesAll = CPROPERTIES_ALL_SIMPLE;
    }
    else
    {
        propsetflag = PROPSETFLAG_NONSIMPLE;
        cPropertiesAll = CPROPERTIES_ALL;
    }

    Check( S_OK, pPropSetStg->Create( fmtidStgPropSetStg,
                                      &CLSID_NULL,
                                      propsetflag,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    // Write to the property set.

    Check( S_OK, pPropStg->WriteMultiple( cPropertiesAll,
                                          g_rgcpropspecAll,
                                          g_rgcpropvarAll,
                                          PID_FIRST_USABLE ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));


    //-----------------------------------------------------------------------
    //  Close it all up and then open it again.
    //  This will exercise the g_pfnStgOpenStorageEx API
    //
    pPropStg->Commit(STGC_DEFAULT);
    pPropStg->Release();
    pPropStg = NULL;
    pPropSetStg->Release();
    pPropSetStg = NULL;
    pstg->Release();
    pstg = NULL;

    Check( S_OK, g_pfnStgOpenStorageEx(   ocsFile,
                                     STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     STGFMT_ANY, //DetermineStgFmt( g_enumImplementation ), // BUGBUG: Use STGFMT_ANY when StgEx can handle it
                                     0L,
                                     NULL,
                                     NULL,
                                     IID_IPropertySetStorage,
                                     (void**) &pPropSetStg ));

    Check( S_OK, pPropSetStg->Open(  fmtidStgPropSetStg,
                                     STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     &pPropStg));

    //pPropSetStg->Release();
    //
    //-----------------------------------------------------------------------

    //
    // Read from the property set
    //
    Check( S_OK, pPropStg->ReadMultiple( cPropertiesAll,
                                         g_rgcpropspecAll,
                                         rgcpropvar ));


    // Compare the properties

    for( ulIndex = 0; ulIndex < cPropertiesAll; ulIndex++ )
    {
        Check( TRUE, rgcpropvar[ulIndex] == g_rgcpropvarAll[ulIndex] );
        rgcpropvar[ulIndex].Clear();
    }

    // Clean up

    RELEASE_INTERFACE( pPropStg );
    RELEASE_INTERFACE( pPropSetStg );

}


//
// IPropertySetStorage tests
//

void
test_IPropertySetStorage_IUnknown(IStorage *pStorage)
{
    // Only use this an IStorage-based property set, since this test
    // assumes that IStorage & IPropertySetStorage are on the same
    // object.

    if( PROPIMP_DOCFILE_IPROP == g_enumImplementation )
    {
        return;
    }

    // Flat can't handle this either, because of the CFlatStorage
    if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
        return;
    

    Status( "IPropertySetStorage::IUnknown\n" );

    //       Check ref counting through different interfaces on object
    //
    //          QI to IPropertySetStorage
    //          QI to IUnknown on IStorage
    //          QI to IUnknown on IPropertySetStorage
    //          QI back to IPropertySetStorage from IUnknown
    //          QI back to IStorage from IPropertySetStorage
    //
    //          Release all.
    //

    IStorage *pStorage2;
    IPropertySetStorage *ppss1, *ppss2, *ppss3;
    IUnknown *punk1,*punk2;
    HRESULT hr=S_OK;

    Check(S_OK, pStorage->QueryInterface(IID_IPropertySetStorage, (void**)&ppss1));
    Check(S_OK, pStorage->QueryInterface(IID_IUnknown, (void **)&punk1));
    Check(S_OK, ppss1->QueryInterface(IID_IUnknown, (void **)&punk2));
    Check(S_OK, ppss1->QueryInterface(DetermineStgIID( g_enumImplementation ), (void **)&pStorage2));
    Check(S_OK, ppss1->QueryInterface(IID_IPropertySetStorage, (void **)&ppss2));
    Check(S_OK, punk1->QueryInterface(IID_IPropertySetStorage, (void **)&ppss3));

    ppss1->AddRef();
    ppss1->Release();

    //pStorage.Release();
    ppss1->Release();
    punk1->Release();
    punk2->Release();
    pStorage2->Release();
    ppss2->Release();
//    void *pvVirtFuncTable = *(void**)ppss3;
    ppss3->Release();


//    Check(STG_E_INVALIDHANDLE, ((IPropertySetStorage*)&pvVirtFuncTable)->QueryInterface(IID_IUnknown, (void**)&punk3));
}


#define INVALID_POINTER     ( (void *) 0xFFFFFFFF )
#define VTABLE_MEMBER_FN(pObj,entry)  ( (*(ULONG ***)(pObj))[ (entry) ] )


//+---------------------------------------------------------
//
//  Template:   Alloc2PageVector
//
//  Purpose:    This function template allocates two pages
//              of memory, and then sets a vector pointer
//              so that its first element is wholy within
//              the first page, and the second element is
//              wholy within the second.  Then, the protection
//              of the second page is set according to the
//              caller-provided parameter.
//
//
//  Inputs:     [TYPE**] ppBase
//                  Points to the beginning of the two pages.
//              [TYPE**] ppVector
//                  Points to the beginning of the vector of TYPEs.
//              [DWORD] dwProtect
//                  The desired protection on the second page
//                  (from the PAGE_* enumeration).
//              [LPWSTR] lpwstr (optional)
//                  If not NULL, used to initialize the vector
//                  elements.
//
//  Output:     TRUE iff successful.
//
//+---------------------------------------------------------


template< class TYPE > BOOL Alloc2PageVector( TYPE** ppBase,
                                              TYPE** ppVector,
                                              DWORD  dwProtect,
                                              TYPE*  pInit )
{
    DWORD dwOldProtect;
    SYSTEM_INFO si;

    GetSystemInfo( &si );

    *ppBase = (TYPE*) VirtualAlloc( NULL, 2 * si.dwPageSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE );
    if( NULL == *ppBase )
        return( FALSE );

    *ppVector = (TYPE*) ( (BYTE*) *ppBase + si.dwPageSize - sizeof(TYPE) );

    if( NULL != pInit )
    {
        memcpy( &((LPWSTR*)*ppVector)[0], pInit, sizeof(TYPE) );
        memcpy( &((LPWSTR*)*ppVector)[1], pInit, sizeof(TYPE) );
    }

    if( !VirtualProtect( (BYTE*) *ppBase + si.dwPageSize, si.dwPageSize, dwProtect, &dwOldProtect ) )
        return( FALSE );

    return( TRUE );
}



void
test_PropVariantValidation( IStorage *pStg )
{

    Status( "PropVariant Validation\n" );

    IPropertySetStorage *pPSStg = NULL; // TSafeStorage< IPropertySetStorage > pPSStg( pStg );
    IPropertyStorage *pPStg = NULL; // TSafeStorage< IPropertyStorage > pPStg;

    CPropVariant cpropvar;
    CLIPDATA     clipdata;
    PROPSPEC     propspec;

    const LPWSTR wszText = L"Unicode Text String";

    FMTID fmtid;
    UuidCreate( &fmtid );

    Check( S_OK, StgToPropSetStg( pStg, &pPSStg ));

    Check(S_OK, pPSStg->Create( fmtid,
                                NULL,
                                PROPSETFLAG_DEFAULT,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                &pPStg ));


    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = 2;

    //  -------------------------------
    //  Test invalid VT_CF Propvariants
    //  -------------------------------

    // NULL clip format.

    clipdata.cbSize = 4;
    clipdata.ulClipFmt = (ULONG) -1;
    clipdata.pClipData = NULL;

    cpropvar = clipdata;

    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    // Too short cbSize.

    ((PROPVARIANT*)&cpropvar)->pclipdata->cbSize = 3;
    Check(STG_E_INVALIDPARAMETER, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    // Too short pClipData (it should be 1 byte, but the pClipData is NULL).

    ((PROPVARIANT*)&cpropvar)->pclipdata->cbSize = 5;
    Check(STG_E_INVALIDPARAMETER, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));


    Check( 0, RELEASE_INTERFACE(pPStg) );
    RELEASE_INTERFACE(pPSStg);
}


void
test_ParameterValidation(IStorage *pStg)
{
    // We only run this test on WIN32 builds, because we need
    // the VirtualAlloc routine.

#ifdef WIN32

    Status( "Parameter Validation\n" );

    IPropertySetStorage *pPSStg = NULL;
    IPropertyStorage *pPStg = NULL;
    FMTID fmtid;

    UuidCreate( &fmtid );

    LPFMTID pfmtidNULL = NULL;
    LPFMTID pfmtidInvalid = (LPFMTID) INVALID_POINTER;
    PAPP_COMPAT_INFO pAppCompatInfo = NULL;

    DWORD dwOldProtect;

    Check( S_OK, StgToPropSetStg( pStg, &pPSStg ));

    // By default, pointer validation is turned off in ole32 (as of Whistler).
    // Enable it for our process so that we can test the checks.

    PAPP_COMPAT_INFO pAppCompatInfoSave = (PAPP_COMPAT_INFO) NtCurrentPeb()->AppCompatInfo;
    APP_COMPAT_INFO AppCompatInfoNew;
    memset( &AppCompatInfoNew, 0, sizeof(AppCompatInfoNew) );
    AppCompatInfoNew.CompatibilityFlags.QuadPart |= KACF_OLE32VALIDATEPTRS;

    NtCurrentPeb()->AppCompatInfo = &AppCompatInfoNew;
    
    NtCurrentPeb()->AppCompatFlags.QuadPart = AppCompatInfoNew.CompatibilityFlags.QuadPart;

    // Define two invalid property names

    OLECHAR oszTooLongName[ CCH_MAXPROPNAMESZ + 1 ];
    LPOLESTR poszTooLongName = oszTooLongName;
    OLECHAR oszTooShortName[] = { L"" };
    LPOLESTR poszTooShortName = oszTooShortName;

    PROPSPEC propspecTooLongName = { PRSPEC_LPWSTR };
    PROPSPEC propspecTooShortName = { PRSPEC_LPWSTR };

    propspecTooLongName.lpwstr = oszTooLongName;
    propspecTooShortName.lpwstr = oszTooShortName;

    for( int i = 0; i < sizeof(oszTooLongName)/sizeof(oszTooLongName[0]); i++ )
        oszTooLongName[i] = OLESTR('a');
    oszTooLongName[ sizeof(oszTooLongName)/sizeof(oszTooLongName[0]) ] = OLESTR('\0');

    // Define several arrays which will be created with special
    // protections.  For all of this vectors, the first element
    // will be in a page to which we have all access rights.  The
    // second element will be in a page for which we have no access,
    // read access, or all access.  The variables are named
    // according to the access rights in the second element.
    // The '...Base' variables are pointers to the base of
    // the allocated memory (and must therefore be freed).
    // The corresponding variables without the "Base" postfix
    // are the vector pointers.

    PROPSPEC       *rgpropspecNoAccessBase,    *rgpropspecNoAccess;
    CPropVariant   *rgcpropvarReadAccessBase,  *rgcpropvarReadAccess;
    CPropVariant   *rgcpropvarNoAccessBase,    *rgcpropvarNoAccess;
    PROPID         *rgpropidNoAccessBase,      *rgpropidNoAccess;
    PROPID         *rgpropidReadAccessBase,    *rgpropidReadAccess;
    LPWSTR         *rglpwstrNoAccessBase,      *rglpwstrNoAccess;
    LPWSTR         *rglpwstrReadAccessBase,    *rglpwstrReadAccess;
    STATPROPSETSTG *rgStatPSStgReadAccessBase, *rgStatPSStgReadAccess;
    STATPROPSTG    *rgStatPStgReadAccessBase,  *rgStatPStgReadAccess;

    PROPSPEC       rgpropspecAllAccess[1];
    CPropVariant   rgcpropvarAllAccess[1];
    PROPID         rgpropidAllAccess[1];
    LPWSTR         rglpwstrAllAccess[1];
    LPWSTR         rglpwstrInvalid[1];
    STATPROPSETSTG rgStatPSStgAllAccess[1];
    STATPROPSTG    rgStatPStgAllAccess[1];

    // Allocate memory for the vectors and set the vector
    // pointers.

    PROPID propidDefault = PID_FIRST_USABLE;
    LPWSTR lpwstrNameDefault = L"Property Name";

    Check(TRUE, Alloc2PageVector( &rgpropspecNoAccessBase,
                                  &rgpropspecNoAccess,
                                  (ULONG) PAGE_NOACCESS,
                                  (PROPSPEC*) NULL ));
    Check(TRUE, Alloc2PageVector( &rgcpropvarReadAccessBase,
                                  &rgcpropvarReadAccess,
                                  (ULONG) PAGE_READONLY,
                                  (CPropVariant*) NULL ));
    Check(TRUE, Alloc2PageVector( &rgcpropvarNoAccessBase,
                                  &rgcpropvarNoAccess,
                                  (ULONG) PAGE_NOACCESS,
                                  (CPropVariant*) NULL ));
    Check(TRUE, Alloc2PageVector( &rgpropidNoAccessBase,
                                  &rgpropidNoAccess,
                                  (ULONG) PAGE_NOACCESS,
                                  &propidDefault ));
    Check(TRUE, Alloc2PageVector( &rgpropidReadAccessBase,
                                  &rgpropidReadAccess,
                                  (ULONG) PAGE_READONLY,
                                  &propidDefault ));
    Check(TRUE, Alloc2PageVector( &rglpwstrNoAccessBase,
                                  &rglpwstrNoAccess,
                                  (ULONG) PAGE_NOACCESS,
                                  &lpwstrNameDefault ));
    Check(TRUE, Alloc2PageVector( &rglpwstrReadAccessBase,
                                  &rglpwstrReadAccess,
                                  (ULONG) PAGE_READONLY,
                                  &lpwstrNameDefault ));
    Check(TRUE, Alloc2PageVector( &rgStatPSStgReadAccessBase,
                                  &rgStatPSStgReadAccess,
                                  (ULONG) PAGE_READONLY,
                                  (STATPROPSETSTG*) NULL ));
    Check(TRUE, Alloc2PageVector( &rgStatPStgReadAccessBase,
                                  &rgStatPStgReadAccess,
                                  (ULONG) PAGE_READONLY,
                                  (STATPROPSTG*) NULL ));

    rglpwstrAllAccess[0] = rglpwstrNoAccess[0] = rglpwstrReadAccess[0] = L"Property Name";

    // Create restricted buffers for misc tests

    BYTE *pbReadOnly = (BYTE*) VirtualAlloc( NULL, 1, MEM_COMMIT, PAGE_READONLY );
    Check( TRUE, pbReadOnly != NULL );

    BYTE *pbNoAccess = (BYTE*) VirtualAlloc( NULL, 1, MEM_COMMIT, PAGE_NOACCESS );


    //  ----------------------------------------
    //  Test IPropertySetStorage::QueryInterface
    //  ----------------------------------------

    IUnknown *pUnk = NULL;

#if 0

    // This test cannot run because CPropertySetStorage::QueryInterface is a virtual
    // function, and since CExposedDocFile is derived from CPropertySetStorage,
    // it is inaccessibl.

    // Invalid REFIID

    Check(E_INVALIDARG, ((CExposedDocFile*)&pPSStg)->CPropertySetStorage::QueryInterface( (REFIID) *pfmtidNULL, (void**)&pUnk ));
    Check(E_INVALIDARG, pPSStg->QueryInterface( (REFIID) *pfmtidInvalid, (void**)&pUnk ));

    // Invalid IUnknown*

    Check(E_INVALIDARG, pPSStg->QueryInterface( IID_IUnknown, NULL ));
    Check(E_INVALIDARG, pPSStg->QueryInterface( IID_IUnknown, (void**) INVALID_POINTER ));
#endif


    //  --------------------------------
    //  Test IPropertySetStorage::Create
    //  --------------------------------

    // Invalid REFFMTID

    Check(E_INVALIDARG, pPSStg->Create( *pfmtidNULL,
                                        NULL,
                                        PROPSETFLAG_DEFAULT,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));

    Check(E_INVALIDARG, pPSStg->Create( *pfmtidInvalid,
                                        NULL,
                                        PROPSETFLAG_DEFAULT,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));

    // Invalid Class ID pointer

    Check(E_INVALIDARG, pPSStg->Create( FMTID_NULL,
                                        (GUID*) INVALID_POINTER,
                                        PROPSETFLAG_DEFAULT,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));

    // Invalid PropSetFlag

    Check(STG_E_INVALIDFLAG, pPSStg->Create( FMTID_NULL,
                                        &CLSID_NULL,
                                        PROPSETFLAG_UNBUFFERED, // Only supported in APIs
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));

    Check(STG_E_INVALIDFLAG, pPSStg->Create( FMTID_NULL,
                                        &CLSID_NULL,
                                        0xffffffff,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));

    // Invalid mode

    Check(STG_E_INVALIDFLAG, pPSStg->Create( FMTID_NULL,
                                        &CLSID_NULL,
                                        PROPSETFLAG_DEFAULT,
                                        STGM_DIRECT | STGM_SHARE_DENY_NONE,
                                        &pPStg ));

    // Invalid IPropertyStorage**

    Check(E_INVALIDARG, pPSStg->Create( FMTID_NULL,
                                        &CLSID_NULL,
                                        PROPSETFLAG_DEFAULT,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        NULL ));

    Check(E_INVALIDARG, pPSStg->Create( FMTID_NULL,
                                        &CLSID_NULL,
                                        PROPSETFLAG_DEFAULT,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        (IPropertyStorage **) INVALID_POINTER ));

    //  ------------------------------
    //  Test IPropertySetStorage::Open
    //  ------------------------------

    // Invalid REFFMTID

    Check(E_INVALIDARG, pPSStg->Open(   *pfmtidNULL,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));

    Check(E_INVALIDARG, pPSStg->Open(   *pfmtidInvalid,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));


    Check(STG_E_INVALIDFLAG, pPSStg->Open( FMTID_NULL, STGM_DIRECT | STGM_SHARE_DENY_NONE, &pPStg ));

    // Invalid IPropertyStorage**

    Check(E_INVALIDARG, pPSStg->Open(   FMTID_NULL,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        NULL ));

    Check(E_INVALIDARG, pPSStg->Open(   FMTID_NULL,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        (IPropertyStorage**) INVALID_POINTER ));

    //  --------------------------------
    //  Test IPropertySetStorage::Delete
    //  --------------------------------

    // Invalid REFFMTID.

    Check(E_INVALIDARG, pPSStg->Delete( *pfmtidNULL ));
    Check(E_INVALIDARG, pPSStg->Delete( (REFFMTID) *pfmtidInvalid ));

    //  ------------------------------
    //  Test IPropertySetStorage::Enum
    //  ------------------------------

    // Invalid IEnumSTATPROPSETSTG

    Check(E_INVALIDARG, pPSStg->Enum( (IEnumSTATPROPSETSTG **) NULL ));
    Check(E_INVALIDARG, pPSStg->Enum( (IEnumSTATPROPSETSTG **) INVALID_POINTER ));


    //  -------------
    //  Test PROPSPEC
    //  -------------

    // Create a PropertyStorage

    Check(S_OK, pPSStg->Create( fmtid,
                                NULL,
                                PROPSETFLAG_DEFAULT,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                &pPStg ));


    // Invalid ulKind

    rgpropspecAllAccess[0].ulKind = (ULONG) -1;
    rgpropspecAllAccess[0].lpwstr = NULL;
    Check(E_INVALIDARG, pPStg->ReadMultiple(   1,
                                               rgpropspecAllAccess,
                                               rgcpropvarAllAccess ));
    Check(E_INVALIDARG, pPStg->WriteMultiple(  1,
                                               rgpropspecAllAccess,
                                               rgcpropvarAllAccess,
                                               2 ));
    Check(E_INVALIDARG, pPStg->DeleteMultiple( 1,
                                               rgpropspecAllAccess ));

    // Too short PROPSPEC

    rgpropspecNoAccess[0].ulKind = PRSPEC_PROPID;
    rgpropspecNoAccess[0].propid = 2;

    Check(E_INVALIDARG, pPStg->ReadMultiple( 2,
                                             rgpropspecNoAccess,
                                             rgcpropvarAllAccess ));

    Check(E_INVALIDARG, pPStg->WriteMultiple( 2,
                                              rgpropspecNoAccess,
                                              rgcpropvarAllAccess,
                                              2 ));

    Check(E_INVALIDARG, pPStg->DeleteMultiple( 2,
                                               rgpropspecNoAccess ));


    //  -------------------------------------
    //  Test IPropertyStorage::QueryInterface
    //  -------------------------------------

    // Invalid REFIID

    Check(E_INVALIDARG, pPStg->QueryInterface( (REFIID) *pfmtidNULL, (void**)&pUnk ));
    Check(E_INVALIDARG, pPStg->QueryInterface( (REFIID) *pfmtidInvalid, (void**)&pUnk ));

    // Invalid IUnknown*

    Check(E_INVALIDARG, pPStg->QueryInterface( IID_IUnknown, NULL ));
    Check(E_INVALIDARG, pPStg->QueryInterface( IID_IUnknown, (void**) INVALID_POINTER ));


    //  -----------------------------------
    //  Test IPropertyStorage::ReadMultiple
    //  -----------------------------------

    rgpropspecAllAccess[0].ulKind = PRSPEC_LPWSTR;
    rgpropspecAllAccess[0].lpwstr = OLESTR("Test Property");

    // Too short count

    Check(S_FALSE, pPStg->ReadMultiple( 0,
                                        rgpropspecAllAccess,
                                        rgcpropvarAllAccess));

    // Too long a count for the PropVariant

    Check(E_INVALIDARG, pPStg->ReadMultiple( 2,
                                             rgpropspecAllAccess,
                                             (PROPVARIANT*) (void*) rgcpropvarReadAccess ));


    // Invalid PropVariant[]

    Check(E_INVALIDARG, pPStg->ReadMultiple( 1,
                                             rgpropspecAllAccess,
                                             NULL ));
    Check(E_INVALIDARG, pPStg->ReadMultiple( 1,
                                             rgpropspecAllAccess,
                                             (LPPROPVARIANT) INVALID_POINTER ));

    // Bad PROPSPECs

    // If we ever add a version-0 property set compatibility mode, we should add this test back.
    // Check(STG_E_INVALIDPARAMETER, pPStg->ReadMultiple( 1, &propspecTooLongName, rgcpropvarAllAccess ));
    Check(STG_E_INVALIDPARAMETER, pPStg->ReadMultiple( 1, &propspecTooShortName, rgcpropvarAllAccess ));

    //  ------------------------------------
    //  Test IPropertyStorage::WriteMultiple
    //  ------------------------------------

    rgpropspecAllAccess[0].ulKind = PRSPEC_LPWSTR;
    rgpropspecAllAccess[0].lpwstr = L"Test Property";
    rgcpropvarAllAccess[0] = (long) 1;

    // Too short count

    Check(S_OK, pPStg->WriteMultiple( 0,
                                     rgpropspecAllAccess,
                                     (PROPVARIANT*)(void*)rgcpropvarAllAccess,
                                     2));

    // Too short PropVariant

    Check(E_INVALIDARG, pPStg->WriteMultiple( 2,
                                              rgpropspecAllAccess,
                                              (PROPVARIANT*)(void*)rgcpropvarNoAccess,
                                              PID_FIRST_USABLE ));

    // Invalid PropVariant[]

    Check(E_INVALIDARG, pPStg->WriteMultiple( 1,
                                              rgpropspecAllAccess,
                                              NULL,
                                              2));
    Check(E_INVALIDARG, pPStg->WriteMultiple( 1,
                                              rgpropspecAllAccess,
                                              (LPPROPVARIANT) INVALID_POINTER,
                                              PID_FIRST_USABLE));

    // Bad PROPSPECs

    // If we ever add a version-0 property set compatibility mode, we should add this test back.
    // Check(STG_E_INVALIDPARAMETER, pPStg->WriteMultiple( 1, &propspecTooLongName, rgcpropvarAllAccess,
    //                                                     PID_FIRST_USABLE ));

    Check(STG_E_INVALIDPARAMETER, pPStg->WriteMultiple( 1, &propspecTooShortName, rgcpropvarAllAccess,
                                                        PID_FIRST_USABLE ));


    //  -------------------------------------
    //  Test IPropertyStorage::DeleteMultiple
    //  -------------------------------------


    // Invalid count

    Check(S_OK, pPStg->DeleteMultiple( 0,
                                       rgpropspecAllAccess ));


    // Bad PROPSPECs
    // If we ever add a version-0 property set compatibility mode, we should add this test back.
    // Check(STG_E_INVALIDPARAMETER, pPStg->DeleteMultiple( 1, &propspecTooLongName ));

    Check(STG_E_INVALIDPARAMETER, pPStg->DeleteMultiple( 1, &propspecTooShortName ));

    //  ----------------------------------------
    //  Test IPropertyStorage::ReadPropertyNames
    //  ----------------------------------------

    // Create a property with the name we're going to use.

    rgpropspecAllAccess[0].ulKind = PRSPEC_LPWSTR;
    rgpropspecAllAccess[0].lpwstr = rglpwstrAllAccess[0];

    Check(S_OK, pPStg->WriteMultiple( 1,
                                      rgpropspecAllAccess,
                                      &rgcpropvarAllAccess[0],
                                      PID_FIRST_USABLE ));

    // Invalid count

    Check(S_FALSE, pPStg->ReadPropertyNames( 0,
                                             rgpropidAllAccess,
                                             rglpwstrAllAccess ));

    // Too short PROPID[] or LPWSTR[]

    Check(E_INVALIDARG, pPStg->ReadPropertyNames( 2,
                                                  rgpropidNoAccess,
                                                  rglpwstrAllAccess ));
    Check(E_INVALIDARG, pPStg->ReadPropertyNames( 2,
                                                  rgpropidAllAccess,
                                                  rglpwstrReadAccess ));

    // Invalid rgpropid[]

    Check(E_INVALIDARG, pPStg->ReadPropertyNames( 1,
                                                  NULL,
                                                  rglpwstrAllAccess ));
    Check(E_INVALIDARG, pPStg->ReadPropertyNames( 1,
                                                  (PROPID*) INVALID_POINTER,
                                                  rglpwstrAllAccess ));

    // Invalid rglpwstr[]

    Check(E_INVALIDARG, pPStg->ReadPropertyNames( 1,
                                                  rgpropidAllAccess,
                                                  NULL ));
    Check(E_INVALIDARG, pPStg->ReadPropertyNames( 1,
                                                  rgpropidAllAccess,
                                                  (LPWSTR*) INVALID_POINTER ));

    //  -----------------------------------------
    //  Test IPropertyStorage::WritePropertyNames
    //  -----------------------------------------

    // Invalid count

    Check(S_OK, pPStg->WritePropertyNames( 0,
                                           NULL,
                                           rglpwstrAllAccess ));

    // Too short PROPID[] or LPWSTR[]

    Check(E_INVALIDARG, pPStg->WritePropertyNames( 2,
                                                   rgpropidNoAccess,
                                                   rglpwstrAllAccess ));
    Check(E_INVALIDARG, pPStg->WritePropertyNames( 2,
                                                   rgpropidAllAccess,
                                                   rglpwstrNoAccess ));
    Check(S_OK, pPStg->WritePropertyNames( 2,
                                           rgpropidAllAccess,
                                           rglpwstrReadAccess ));

    // Invalid rgpropid[]

    Check(E_INVALIDARG, pPStg->WritePropertyNames( 1,
                                                   NULL,
                                                   rglpwstrAllAccess ));
    Check(E_INVALIDARG, pPStg->WritePropertyNames( 1,
                                                   (PROPID*) INVALID_POINTER,
                                                   rglpwstrAllAccess ));

    // Invalid rglpwstr[]

    Check(E_INVALIDARG, pPStg->WritePropertyNames( 1,
                                                   rgpropidAllAccess,
                                                   NULL ));
    Check(E_INVALIDARG, pPStg->WritePropertyNames( 1,
                                                   rgpropidAllAccess,
                                                   (LPWSTR*) INVALID_POINTER ));

    // Invalid name.

    rglpwstrInvalid[0] = NULL;
    Check(E_INVALIDARG, pPStg->WritePropertyNames( 1,
                                                   rgpropidAllAccess,
                                                   rglpwstrInvalid ));

    rglpwstrInvalid[0] = (LPWSTR) INVALID_POINTER;
    Check(E_INVALIDARG, pPStg->WritePropertyNames( 1,
                                                   rgpropidAllAccess,
                                                   rglpwstrInvalid ));

    // Invalid length names

    // If we ever add a version-0 property set compatibility mode, we should add this test back.
    // Check(STG_E_INVALIDPARAMETER, pPStg->WritePropertyNames( 1, rgpropidAllAccess, &poszTooLongName ));
    Check(STG_E_INVALIDPARAMETER, pPStg->WritePropertyNames( 1, rgpropidAllAccess, &poszTooShortName ));


    //  ------------------------------------------
    //  Test IPropertyStorage::DeletePropertyNames
    //  ------------------------------------------

    // Invalid count

    Check(S_OK, pPStg->DeletePropertyNames( 0,
                                            rgpropidAllAccess ));

    // Too short PROPID[]

    Check(E_INVALIDARG, pPStg->DeletePropertyNames( 2,
                                                    rgpropidNoAccess ));
    Check(S_OK, pPStg->DeletePropertyNames( 2,
                                            rgpropidReadAccess ));

    // Invalid rgpropid[]

    Check(E_INVALIDARG, pPStg->DeletePropertyNames( 1,
                                                    NULL ));
    Check(E_INVALIDARG, pPStg->DeletePropertyNames( 1,
                                                    (PROPID*) INVALID_POINTER ));

    //  ---------------------------
    //  Test IPropertyStorage::Enum
    //  ---------------------------

    // Invalid IEnumSTATPROPSTG

    Check(E_INVALIDARG, pPStg->Enum( NULL ));
    Check(E_INVALIDARG, pPStg->Enum( (IEnumSTATPROPSTG**) INVALID_POINTER ));

    //  --------------------------------------
    //  Test IPropertyStorage::SetElementTimes
    //  --------------------------------------

    Check(E_INVALIDARG, pPStg->SetTimes( (FILETIME*) INVALID_POINTER,
                                         NULL, NULL ));
    Check(E_INVALIDARG, pPStg->SetTimes( NULL,
                                         (FILETIME*) INVALID_POINTER,
                                         NULL ));
    Check(E_INVALIDARG, pPStg->SetTimes( NULL, NULL,
                                         (FILETIME*) INVALID_POINTER ));

    //  -------------------------------
    //  Test IPropertyStorage::SetClass
    //  -------------------------------

    Check(E_INVALIDARG, pPStg->SetClass( (REFCLSID) *pfmtidNULL ));
    Check(E_INVALIDARG, pPStg->SetClass( (REFCLSID) *pfmtidInvalid ));

    //  ---------------------------
    //  Test IPropertyStorage::Stat
    //  ---------------------------

    Check(E_INVALIDARG, pPStg->Stat( NULL ));
    Check(E_INVALIDARG, pPStg->Stat( (STATPROPSETSTG*) INVALID_POINTER ));


    //  ------------------------------
    //  Test IEnumSTATPROPSETSTG::Next
    //  ------------------------------

    ULONG cEltFound;
    IEnumSTATPROPSETSTG *pESPSStg = NULL; // TSafeStorage< IEnumSTATPROPSETSTG > pESPSStg;
    Check(S_OK, pPSStg->Enum( &pESPSStg ));

    // Invalid STATPROPSETSTG*

    Check(E_INVALIDARG, pESPSStg->Next( 1, NULL, &cEltFound ));
    Check(E_INVALIDARG, pESPSStg->Next( 1, (STATPROPSETSTG*) INVALID_POINTER, &cEltFound ));

    // Invalid pceltFound

    Check(S_OK, pESPSStg->Next( 1, rgStatPSStgAllAccess, NULL ));
    Check(STG_E_INVALIDPARAMETER, pESPSStg->Next( 2, rgStatPSStgAllAccess, NULL ));
    Check(E_INVALIDARG, pESPSStg->Next( 2, rgStatPSStgAllAccess, (ULONG*) INVALID_POINTER ));

    // Too short STATPROPSETSTG[]

    Check(E_INVALIDARG, pESPSStg->Next( 2, rgStatPSStgReadAccess, &cEltFound ));

    //  -------------------------------
    //  Test IEnumSTATPROPSETSTG::Clone
    //  -------------------------------

    // Invalid IEnumSTATPROPSETSTG**

    Check(E_INVALIDARG, pESPSStg->Clone( NULL ));
    Check(E_INVALIDARG, pESPSStg->Clone( (IEnumSTATPROPSETSTG**) INVALID_POINTER ));


    //  ---------------------------
    //  Test IEnumSTATPROPSTG::Next
    //  ---------------------------

    IEnumSTATPROPSTG *pESPStg = NULL; // TSafeStorage< IEnumSTATPROPSTG > pESPStg;
    Check(S_OK, pPStg->Enum( &pESPStg ));

    // Invalid STATPROPSETSTG*

    Check(E_INVALIDARG, pESPStg->Next( 1, NULL, &cEltFound ));
    Check(E_INVALIDARG, pESPStg->Next( 1, (STATPROPSTG*) INVALID_POINTER, &cEltFound ));

    // Invalid pceltFound

    Check(S_OK, pESPStg->Next( 1, rgStatPStgAllAccess, NULL ));
    Check(STG_E_INVALIDPARAMETER, pESPStg->Next( 2, rgStatPStgAllAccess, NULL ));
    Check(E_INVALIDARG, pESPStg->Next( 2, rgStatPStgAllAccess, (ULONG*) INVALID_POINTER ));

    // Too short STATPROPSTG[]

    Check(E_INVALIDARG, pESPStg->Next( 2, rgStatPStgReadAccess, &cEltFound ));


    //  ----------------------------
    //  Test IEnumSTATPROPSTG::Clone
    //  ----------------------------

    // Invalid IEnumSTATPROPSETSTG**

    Check(E_INVALIDARG, pESPStg->Clone( NULL ));
    Check(E_INVALIDARG, pESPStg->Clone( (IEnumSTATPROPSTG**) INVALID_POINTER ));

    //  --------------------------------------------
    //  Test PropStgNameToFmtId & FmtIdToPropStgName
    //  --------------------------------------------

    // We're done with the IPropertyStorage and IPropertySetStorage
    // now, but we need the pointers for some calls below, so let's
    // free them now.

    RELEASE_INTERFACE(pPStg);
    RELEASE_INTERFACE(pPSStg);

    RELEASE_INTERFACE(pESPStg);


    // In some cases we can't test these APIs, so only test them
    // if we have the function pointers.

    if( g_pfnPropStgNameToFmtId && g_pfnFmtIdToPropStgName )
    {
        OLECHAR oszPropStgName[ CCH_MAX_PROPSTG_NAME+1 ];
        FMTID fmtidPropStgName = FMTID_NULL;

        // Validate the FMTID parm

        Check( E_INVALIDARG, g_pfnPropStgNameToFmtId( oszPropStgName, pfmtidNULL ));
        Check( E_INVALIDARG, g_pfnPropStgNameToFmtId( oszPropStgName, pfmtidInvalid ));
        Check( E_INVALIDARG, g_pfnPropStgNameToFmtId( oszPropStgName, (FMTID*) pbReadOnly ));

        Check( E_INVALIDARG, g_pfnFmtIdToPropStgName( pfmtidNULL, oszPropStgName ));
        Check( E_INVALIDARG, g_pfnFmtIdToPropStgName( pfmtidInvalid, oszPropStgName ));
        Check( S_OK, g_pfnFmtIdToPropStgName( (FMTID*) pbReadOnly, oszPropStgName ));

        // Validate the name parameter

        /*
        Check( STG_E_INVALIDNAME, g_pfnPropStgNameToFmtId( NULL, &fmtidPropStgName ));
        Check( STG_E_INVALIDNAME, g_pfnPropStgNameToFmtId( (LPOLESTR) INVALID_POINTER, &fmtidPropStgName ));
        Check( STG_E_INVALIDNAME, g_pfnPropStgNameToFmtId( (LPOLESTR) pbNoAccess, &fmtidPropStgName));
        Check( S_OK, g_pfnPropStgNameToFmtId( (LPOLESTR) pbReadOnly, &fmtidPropStgName ));

        Check( E_INVALIDARG, g_pfnFmtIdToPropStgName( &fmtidPropStgName, NULL ));
        Check( E_INVALIDARG, g_pfnFmtIdToPropStgName( &fmtidPropStgName, (LPOLESTR) INVALID_POINTER ));
        Check( E_INVALIDARG, g_pfnFmtIdToPropStgName( &fmtidPropStgName, (LPOLESTR) pbReadOnly ));
        */

    }   // if( g_pfnPropStgNameToFmtId && g_pfnFmtIdToPropStgName )

    //  ------------------------------------------
    //  Test StgCreatePropStg, StgOpenPropStg APIs
    //  ------------------------------------------

    // In some cases we can't test these APIs, so only test them
    // if we have the function pointers.

    if( g_pfnStgCreatePropSetStg && g_pfnStgCreatePropStg && g_pfnStgOpenPropStg
        &&
        !(RESTRICT_SIMPLE_ONLY & g_Restrictions) )
    {
        FMTID fmtidPropStgName = FMTID_NULL;
        IStream *pStm = NULL; // TSafeStorage< IStream > pStm;

        // We need a Stream for one of the tests.

        Check( S_OK, pStg->CreateStream( OLESTR( "Parameter Validation" ),
                                         STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                         0L, 0L,
                                         &pStm ));

        // Test the IUnknown

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( NULL, fmtidPropStgName, NULL, PROPSETFLAG_DEFAULT, 0, &pPStg ));
        Check( E_INVALIDARG, g_pfnStgOpenPropStg( NULL, fmtidPropStgName, PROPSETFLAG_DEFAULT, 0L, &pPStg ));

        // Test the FMTID

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( (IUnknown*) pStm, *pfmtidNULL, NULL, PROPSETFLAG_DEFAULT, 0, &pPStg ));
        Check( E_INVALIDARG, g_pfnStgOpenPropStg( (IUnknown*) pStm, *pfmtidNULL, PROPSETFLAG_DEFAULT, 0, &pPStg ));

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( (IUnknown*) pStm, *pfmtidInvalid, NULL, PROPSETFLAG_DEFAULT, 0, &pPStg ));
        Check( E_INVALIDARG, g_pfnStgOpenPropStg( (IUnknown*) pStm, *pfmtidInvalid, PROPSETFLAG_DEFAULT, 0, &pPStg ));

        // Test the CLSID

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( (IUnknown*) pStm, fmtidPropStgName, (CLSID*) pfmtidInvalid, PROPSETFLAG_DEFAULT, 0, &pPStg ));

        // Test grfFlags

        Check( STG_E_INVALIDFLAG, g_pfnStgCreatePropStg( (IUnknown*) pStm, fmtidPropStgName, NULL, 0x8000, 0L, &pPStg ));
        Check( STG_E_INVALIDFLAG, g_pfnStgOpenPropStg( (IUnknown*) pStm, fmtidPropStgName, 0x8000, 0L, &pPStg ));

        Check( E_NOINTERFACE, g_pfnStgCreatePropStg( (IUnknown*) pStm, fmtidPropStgName, NULL, PROPSETFLAG_NONSIMPLE, 0L, &pPStg ));
        Check( E_NOINTERFACE, g_pfnStgCreatePropStg( (IUnknown*) pStg, fmtidPropStgName, NULL, PROPSETFLAG_DEFAULT,   0L, &pPStg ));
        Check( E_NOINTERFACE, g_pfnStgOpenPropStg( (IUnknown*) pStm, fmtidPropStgName, PROPSETFLAG_NONSIMPLE, 0L, &pPStg ));
        Check( E_NOINTERFACE, g_pfnStgOpenPropStg( (IUnknown*) pStg, fmtidPropStgName, PROPSETFLAG_DEFAULT  , 0L, &pPStg ));

        // Test IPropertyStorage**

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( (IUnknown*) pStm, fmtidPropStgName, NULL, PROPSETFLAG_DEFAULT, 0L, NULL ));
        Check( E_INVALIDARG, g_pfnStgOpenPropStg( (IUnknown*) pStm, fmtidPropStgName, PROPSETFLAG_DEFAULT, 0L, NULL ));

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( (IUnknown*) pStm, fmtidPropStgName, NULL, PROPSETFLAG_DEFAULT, 0L, (IPropertyStorage**) INVALID_POINTER ));
        Check( E_INVALIDARG, g_pfnStgOpenPropStg( (IUnknown*) pStm, fmtidPropStgName, PROPSETFLAG_DEFAULT, 0L, (IPropertyStorage**) INVALID_POINTER ));

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( (IUnknown*) pStm, fmtidPropStgName, NULL, PROPSETFLAG_DEFAULT, 0L, (IPropertyStorage**) pbReadOnly ));
        Check( E_INVALIDARG, g_pfnStgOpenPropStg( (IUnknown*) pStm, fmtidPropStgName, PROPSETFLAG_DEFAULT, 0L, (IPropertyStorage**) pbReadOnly ));

        RELEASE_INTERFACE(pStm);

    }   // if( g_pfnStgCreatePropSetStg && g_pfnStgCreatePropStg && g_pfnStgOpenPropStg )

    // If we're not using IStorage::QueryInterface to get an IPropertySetStorage,
    // we must be using the new APIs, so let's test them.

        //  ----------------------------
        //  Test StgCreatePropSetStg API
        //  ----------------------------

    // In some cases we can't test these APIs, so only test them
    // if we have the function pointers.

    if( g_pfnStgCreatePropSetStg && g_pfnStgCreatePropStg && g_pfnStgOpenPropStg )
    {
        // Test the IStorage*

        Check( E_INVALIDARG, g_pfnStgCreatePropSetStg( NULL, 0L, &pPSStg ));
        Check( E_INVALIDARG, g_pfnStgCreatePropSetStg( (IStorage*) INVALID_POINTER, 0L, &pPSStg ));

        // Test the IPropertySetStorage**

        Check( E_INVALIDARG, g_pfnStgCreatePropSetStg( pStg, 0L, NULL ));
        Check( E_INVALIDARG, g_pfnStgCreatePropSetStg( pStg, 0L, (IPropertySetStorage**) INVALID_POINTER ));


        //  -------------------------------------------------------------
        //  Test g_pfnPropVariantCopy, PropVariantClear & FreePropVariantArray
        //  -------------------------------------------------------------

        // PropVariantCopy

        Check( E_INVALIDARG, g_pfnPropVariantCopy( rgcpropvarAllAccess, NULL ));
        Check( E_INVALIDARG, g_pfnPropVariantCopy( rgcpropvarAllAccess, (PROPVARIANT*) INVALID_POINTER ));

        Check( E_INVALIDARG, g_pfnPropVariantCopy( NULL, rgcpropvarAllAccess ));
        Check( E_INVALIDARG, g_pfnPropVariantCopy( (PROPVARIANT*) INVALID_POINTER, rgcpropvarAllAccess ));
        Check( E_INVALIDARG, g_pfnPropVariantCopy( (PROPVARIANT*) pbReadOnly, rgcpropvarAllAccess ));

        // PropVariantClear

        Check( S_OK, g_pfnPropVariantClear( NULL ));
        Check( E_INVALIDARG, g_pfnPropVariantClear( (PROPVARIANT*) INVALID_POINTER ));
        Check( E_INVALIDARG, g_pfnPropVariantClear( (PROPVARIANT*) pbReadOnly ));

        // FreePropVariantArray

        Check( E_INVALIDARG, g_pfnFreePropVariantArray( 1, NULL ));
        Check( E_INVALIDARG, g_pfnFreePropVariantArray( 1, (PROPVARIANT*) INVALID_POINTER ));

        Check( S_OK, g_pfnFreePropVariantArray( 1, (PROPVARIANT*) (void*)rgcpropvarReadAccess ));
        Check( E_INVALIDARG, g_pfnFreePropVariantArray( 2, (PROPVARIANT*) (void*)rgcpropvarReadAccess ));

    }   // if( g_pfnStgCreatePropSetStg && g_pfnStgCreatePropStg && g_pfnStgOpenPropStg )


    //  ----
    //  Exit
    //  ----

    VirtualFree( rgpropspecNoAccessBase, 0, MEM_RELEASE );
    VirtualFree( rgcpropvarReadAccessBase, 0, MEM_RELEASE );
    VirtualFree( rgcpropvarNoAccessBase, 0, MEM_RELEASE );
    VirtualFree( rgpropidNoAccessBase, 0, MEM_RELEASE );
    VirtualFree( rgpropidReadAccessBase, 0, MEM_RELEASE );
    VirtualFree( rglpwstrNoAccessBase, 0, MEM_RELEASE );
    VirtualFree( rglpwstrReadAccessBase, 0, MEM_RELEASE );
    VirtualFree( rgStatPSStgReadAccessBase, 0, MEM_RELEASE );
    VirtualFree( rgStatPStgReadAccessBase, 0, MEM_RELEASE );

    RELEASE_INTERFACE(pPSStg);
    RELEASE_INTERFACE(pPStg);
    RELEASE_INTERFACE(pESPSStg);


    NtCurrentPeb()->AppCompatInfo = pAppCompatInfoSave;

#endif // #ifdef WIN32

}   // test_ParameterValidation(IStorage *pStg)





//       Check creation/open/deletion of property sets (check fmtid and predefined names)
//          Create a property set
//          Try recreate of same
//          Try delete
//          Close the property set
//          Try recreate of same
//          Reopen the property set
//          Try recreate of same
//          Try delete
//          Close the property set
//          Delete the property set
//          Repeat the test once more

void
test_IPropertySetStorage_CreateOpenDelete(IStorage *pStorage)
{
    Status( "IPropertySetStorage::Create/Open/Delete\n" );

    FMTID fmtid;
    PROPSPEC propspec;

    UuidCreate(&fmtid);

    for (int i=0; i<4; i++)
    {
        DWORD propsetflag;


        if( !(g_Restrictions & RESTRICT_SIMPLE_ONLY) )
            propsetflag = (i & 2) == 0 ? PROPSETFLAG_DEFAULT : PROPSETFLAG_NONSIMPLE;
        else
            propsetflag = PROPSETFLAG_DEFAULT;

        {
            IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
            IPropertyStorage *PropStg, *PropStg2;

            Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

            Check( S_OK, pPropSetStg->Create(fmtid,
                    NULL,
                    propsetflag,
                    STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                    &PropStg));

            Check( S_OK, pPropSetStg->Create(fmtid,
                    NULL,
                    propsetflag,
                    STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                    &PropStg2 ));

            Check( STG_E_REVERTED, PropStg->Commit(0) );

            RELEASE_INTERFACE( PropStg );
            RELEASE_INTERFACE( PropStg2 );
            RELEASE_INTERFACE( pPropSetStg );
        }
        {
            IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
            IPropertyStorage *PropStg, *PropStg2;

            Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

            // use STGM_FAILIFTHERE
            Check(STG_E_FILEALREADYEXISTS, pPropSetStg->Create(fmtid,
                    NULL,
                    propsetflag,
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                    &PropStg));

            Check(S_OK, pPropSetStg->Open(fmtid,
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                    &PropStg));

            Check( STG_E_ACCESSDENIED,
                   pPropSetStg->Open(fmtid,
                                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                    &PropStg2));

            Check( STG_E_ACCESSDENIED,
                   pPropSetStg->Create( fmtid,
                                        NULL,
                                        propsetflag,
                                        STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                        &PropStg2));


            // Docfile allows an open element to be deleted (putting open objects
            // in the reverted state).  NTFS doesn't allow the delete though.

            Check( (g_Restrictions & RESTRICT_NON_HIERARCHICAL)
                      ? STG_E_SHAREVIOLATION
                      : S_OK,
                    pPropSetStg->Delete(fmtid) );


            propspec.ulKind = PRSPEC_PROPID;
            propspec.propid = 1000;
            PROPVARIANT propvar;
            propvar.vt = VT_I4;
            propvar.lVal = 12345;

            Check((g_Restrictions & RESTRICT_NON_HIERARCHICAL) ? S_OK : STG_E_REVERTED,
                  PropStg->WriteMultiple(1, &propspec, &propvar, 2)); // force dirty

            RELEASE_INTERFACE(PropStg);
            RELEASE_INTERFACE(pPropSetStg);

            //Check(S_OK, pPropSetStg->Delete(fmtid));
        }
    }

}


void
test_IPropertySetStorage_SummaryInformation(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_NON_HIERARCHICAL ) return;
    Status( "SummaryInformation\n" );
    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    IPropertyStorage *PropStg;
    IStream *pstm;

    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Create(FMTID_SummaryInformation,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &PropStg));

    RELEASE_INTERFACE(PropStg);

    Check(S_OK, pStorage->OpenStream(OLESTR("\005SummaryInformation"),
            NULL,
            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
            0,
            &pstm));

    RELEASE_INTERFACE(pstm);
    RELEASE_INTERFACE(pPropSetStg);
}

//
//       Check STGM_FAILIFTHERE and ~STGM_FAILIFTHERE in following cases
//          Check overwriting simple with extant non-simple
//          Check overwriting simple with simple
//          Check overwriting non-simple with simple
//          Check overwriting non-simple with non-simple

void
test_IPropertySetStorage_FailIfThere(IStorage *pStorage)
{

    // (Use "fale" instead of "fail" in this printf so the output won't
    // alarm anyone with the word "fail" uncessarily).
    Status( "IPropertySetStorage, FaleIfThere\n" );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

    // Iter       0        1          2         3          4        5          6         7
    // Create     simple   nonsimple  simple    nonsimple  simple   nonsimple  simple    nonsimple
    // ReCreate   simple   simple     nonsimple nonsimple  simple   simple     nonsimple nonsimple
    //            failif   failif     failif    failif     overw    overw      overw     overw
    //
    // expected   exists   exists     exists    exists     ok       ok         ok        ok

    for (int i=0; i<8; i++)
    {
        FMTID fmtid;
        IPropertyStorage *PropStg;
        DWORD propsetflagNonSimple = (g_Restrictions & RESTRICT_SIMPLE_ONLY) ? PROPSETFLAG_DEFAULT : PROPSETFLAG_NONSIMPLE;

        UuidCreate(&fmtid);

        Check(S_OK, pPropSetStg->Create(fmtid,
                NULL,
                (i & 1) == 1 ? propsetflagNonSimple : 0,
                STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &PropStg));

        PropStg->Release();

        Check((i&4) == 4 ? S_OK : STG_E_FILEALREADYEXISTS,
            pPropSetStg->Create(fmtid,
                NULL,
                (i & 2) == 2 ? propsetflagNonSimple : 0,
                ( (i & 4) == 4 ? STGM_CREATE : STGM_FAILIFTHERE )
                |
                STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &PropStg));

        if (PropStg)
        {
            PropStg->Release();
        }
    }

    RELEASE_INTERFACE( pPropSetStg );
    Check( cStorageRefs, GetRefCount( pStorage ));
}

//
//
//
//       Bad this pointer.
//          Call all methods with a bad this pointer, check we get STG_E_INVALIDHANDLE
//

void
test_IPropertySetStorage_BadThis(IStorage *pIgnored)
{
    Status( "Bad IPropertySetStorage 'this' pointer\n" );

    IPropertySetStorage *pBad;
    IID iid;
    FMTID fmtid;
    void *pv;
    IPropertyStorage *pps;
    IEnumSTATPROPSETSTG *penm;

    pBad = reinterpret_cast<IPropertySetStorage*>(&iid);

    Check(STG_E_INVALIDHANDLE,pBad->QueryInterface(iid, &pv));
    Check(0, pBad->AddRef());
    Check(0, pBad->Release());
    Check(STG_E_INVALIDHANDLE,pBad->Create( fmtid, NULL, 0, 0, &pps));
    Check(STG_E_INVALIDHANDLE,pBad->Open(fmtid, 0, &pps));
    Check(STG_E_INVALIDHANDLE,pBad->Delete( fmtid ));
    Check(STG_E_INVALIDHANDLE,pBad->Enum( &penm ));

}

//       Transacted mode
//          Create a non-simple property set with one VT_STREAM child, close it
//          Open it in transacted mode
//          Write another VT_STORAGE child
//          Close and revert
//          Check that the second child does not exist.
//          Repeat and close and commit and check the child exists.

void
test_IPropertySetStorage_TransactedMode(IStorage *pStorage)
{
    FMTID fmtid;

    UuidCreate(&fmtid);

    if( g_Restrictions & ( RESTRICT_DIRECT_ONLY | RESTRICT_SIMPLE_ONLY )) return;
    Status( "Transacted Mode\n" );


    {
        //
        // create a substorage "teststg" with a propset
        // create a stream "src" which is then written via VT_STREAM as propid 7fffffff

        CTempStorage pSubStorage(coCreate, pStorage, OLESTR("teststg"));
        IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pSubStorage);
        Check( S_OK, StgToPropSetStg( pSubStorage, &pPropSetStg ));
        IPropertyStorage *pPropSet;
        IStream *pstm;

        Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_NONSIMPLE,
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropSet));

        PROPSPEC ps;
        ps.ulKind = PRSPEC_PROPID;
        ps.propid = 0x7ffffffd;

        Check(S_OK, pStorage->CreateStream(OLESTR("src"), STGM_DIRECT|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
            0,0, &pstm));
        Check(S_OK, pstm->Write(L"billmo", 14, NULL));
        Check(S_OK, pstm->Seek(g_li0, STREAM_SEEK_SET, NULL));

        PROPVARIANT pv;
        pv.vt = VT_STREAM;
        pv.pStream = pstm;
        Check(S_OK, pPropSet->WriteMultiple(1, &ps, &pv, 2)); // copies the stream in

        Check( 0, RELEASE_INTERFACE(pPropSet) );
        Check( 0, RELEASE_INTERFACE(pstm) );
        RELEASE_INTERFACE(pPropSetStg);
    }

    {
        IPropertyStorage *pPropSet;
        // Reopen the propset in transacted and add one with id 0x7ffffffe
        CTempStorage pSubStorage(coOpen, pStorage, OLESTR("teststg"), STGM_TRANSACTED);
        IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pSubStorage);
        Check( S_OK, StgToPropSetStg( pSubStorage, &pPropSetStg ));

        // Create a storage object to copy
        CTempStorage pstgSrc;
        CTempStorage pTestChild(coCreate, pstgSrc, OLESTR("testchild"));

        Check(S_OK, pPropSetStg->Open(fmtid,
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropSet));

        // copy in the storage object
        PROPSPEC ps[2];
        ps[0].ulKind = PRSPEC_PROPID;
        ps[0].propid = 0x7ffffffe;
        ps[1].ulKind = PRSPEC_PROPID;
        ps[1].propid = 0x7ffffff0;

        PROPVARIANT pv[2];
        pv[0].vt = VT_STORAGE;
        pv[0].pStorage = pTestChild;
        pv[1].vt = VT_I4;
        pv[1].lVal = 123;

        Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 2)); // copies the storage in


        pSubStorage->Revert(); // throws away the storage

        // check that property set operations return stg_e_reverted

        Check(STG_E_REVERTED, pPropSet->WriteMultiple(2, ps, pv, 2));
        Check(STG_E_REVERTED, pPropSet->ReadMultiple(1, ps+1, pv+1));
        Check(STG_E_REVERTED, pPropSet->DeleteMultiple(1, ps+1));
        LPOLESTR pstr = L"pstr";
        Check(STG_E_REVERTED, pPropSet->ReadPropertyNames(1, &ps[1].propid, &pstr));
        Check(STG_E_REVERTED, pPropSet->WritePropertyNames(1, &ps[1].propid, &pstr));
        Check(STG_E_REVERTED, pPropSet->DeletePropertyNames(1, &ps[1].propid));
        Check(STG_E_REVERTED, pPropSet->Commit(STGC_DEFAULT));
        Check(STG_E_REVERTED, pPropSet->Revert());
        IEnumSTATPROPSTG *penum;
        Check(STG_E_REVERTED, pPropSet->Enum(&penum));
        FILETIME ft;
        Check(STG_E_REVERTED, pPropSet->SetTimes(&ft, &ft, &ft));
        CLSID clsid;
        Check(STG_E_REVERTED, pPropSet->SetClass(clsid));
        STATPROPSETSTG statpropsetstg;
        Check(STG_E_REVERTED, pPropSet->Stat(&statpropsetstg));

        Check( 0, RELEASE_INTERFACE(pPropSet) );
        RELEASE_INTERFACE(pPropSetStg);
    }

    {
        IPropertyStorage *pPropSet;
        // Reopen the propset in direct mode and check that the
        // second child is not there.

        CTempStorage pSubStorage(coOpen, pStorage, OLESTR("teststg"));
        IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pSubStorage);
        Check( S_OK, StgToPropSetStg( pSubStorage, &pPropSetStg ));

        Check(S_OK, pPropSetStg->Open(fmtid,
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropSet));

        // read out the storage object
        PROPSPEC aps[2];
        aps[0].ulKind = PRSPEC_PROPID;
        aps[0].propid = 0x7ffffffe; // storage not expected
        aps[1].ulKind = PRSPEC_PROPID;
        aps[1].propid = 0x7ffffffd; // stream is expected

        PROPVARIANT apv[2];
                Check(S_FALSE, pPropSet->ReadMultiple(1, aps, apv));
        Check(S_OK, pPropSet->ReadMultiple(2, aps, apv)); // opens the stream
        Check(TRUE, apv[0].vt == VT_EMPTY);
        Check(TRUE, apv[1].vt == VT_STREAM);
        Check(TRUE, apv[1].pStream != NULL);


        WCHAR wcsBillMo[7];
        Check(S_OK, apv[1].pStream->Read(wcsBillMo, 14, NULL));
        Check(TRUE, wcscmp(L"billmo", wcsBillMo) == 0);

        Check( 0, RELEASE_INTERFACE(apv[1].pStream) );
        Check( 0, RELEASE_INTERFACE(pPropSet) );
        RELEASE_INTERFACE(pPropSetStg);
    }
}

//
// test that the buffer is correctly reverted
//

void
test_IPropertySetStorage_TransactedMode2(IStorage *pStorage)
{
    if( g_Restrictions & (RESTRICT_DIRECT_ONLY | RESTRICT_SIMPLE_ONLY )) return;
    Status( "Transacted Mode 2\n" );

    //
    // write and commit a property A
    // write and revert a property B
    // write and commit a property C
    // check that property B does not exist

    FMTID fmtid;
    PROPSPEC ps;
    PROPVARIANT pv;
    IPropertyStorage *pPropStg;

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

    UuidCreate(&fmtid);

    // We'll run this test twice, once with a Create and the other
    // with an Open (this way, we test both of the CPropertyStorage
    // constructors).

    for( int i = 0; i < 2; i++ )
    {
        if( i == 0 )
        {
            Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_NONSIMPLE,
                STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));
        }
        else
        {
            Check(S_OK, pPropSetStg->Open(fmtid,
                STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));
        }

        ps.ulKind = PRSPEC_PROPID;
        ps.propid = 6;
        pv.vt = VT_I4;
        pv.lVal = 1;

        Check(S_OK, pPropStg->WriteMultiple(1, &ps, &pv, 0x2000));
        Check(S_OK, pPropStg->Commit(STGC_DEFAULT));

        ps.propid = 7;
        pv.lVal = 2;

        Check(S_OK, pPropStg->WriteMultiple(1, &ps, &pv, 0x2000));
        Check(S_OK, pPropStg->Revert());

        ps.propid = 8;
        pv.lVal = 3;

        Check(S_OK, pPropStg->WriteMultiple(1, &ps, &pv, 0x2000));
        Check(S_OK, pPropStg->Commit(STGC_DEFAULT));

        ps.propid = 6;
        Check(S_OK, pPropStg->ReadMultiple(1, &ps, &pv));
        Check(TRUE, pv.lVal == 1);
        Check(TRUE, pv.vt == VT_I4);

        ps.propid = 7;
        Check(S_FALSE, pPropStg->ReadMultiple(1, &ps, &pv));

        ps.propid = 8;
        Check(S_OK, pPropStg->ReadMultiple(1, &ps, &pv));
        Check(TRUE, pv.lVal == 3);
        Check(TRUE, pv.vt == VT_I4);

        RELEASE_INTERFACE(pPropStg);

    }   // for( int i = 0; i < 2; i++ )

    RELEASE_INTERFACE(pPropSetStg);
}

void
test_IPropertySetStorage_SubPropertySet(IStorage *pStorage)
{
    FMTID fmtid;
    PROPSPEC ps;
    PROPVARIANT pv;
    IPropertyStorage *pPropStg;
    IPropertySetStorage *pSubSetStg;
    IPropertyStorage *pPropStg2;

    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    Status( "Sub Property Set\n" );

    for (int i=0; i<2; i++)
    {

        IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);

        ULONG cStorageRefs = GetRefCount( pStorage );
        Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

        UuidCreate(&fmtid);


        Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_NONSIMPLE,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

        ps.ulKind = PRSPEC_PROPID;
        ps.propid = 6;
        pv.vt = VT_STORAGE;
        pv.pStorage = NULL;

        Check(S_OK, pPropStg->WriteMultiple(1, &ps, &pv, 0x2000));

        Check(S_OK, pPropStg->ReadMultiple(1, &ps, &pv));


        Check(S_OK, StgToPropSetStg( pv.pStorage, &pSubSetStg ));

        Check(S_OK, pSubSetStg->Create(fmtid, NULL, i==0 ? PROPSETFLAG_NONSIMPLE : PROPSETFLAG_DEFAULT,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg2));

        IStorage *pstgTmp = pv.pStorage;
        pv.pStorage = NULL;

        if (i==1)
        {
            pv.vt = VT_I4;
        }

        Check(S_OK, pPropStg2->WriteMultiple(1, &ps, &pv, 0x2000));

        pPropStg->Release();
        pstgTmp->Release();
        pSubSetStg->Release();
        pPropStg2->Release();

        RELEASE_INTERFACE(pPropSetStg);
        Check( cStorageRefs, GetRefCount(pStorage) );
    }
}

/*
The following sequence of operations:

- open transacted docfile
- open property set inside docfile
- write properties
- commit docfile
- release property set

results in a STG_E_REVERTED error being detected
*/

void
test_IPropertySetStorage_CommitAtRoot(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_DIRECT_ONLY ) return;
    Status( "Commit at root\n" );

    for (int i=0; i<6; i++)
    {
        FMTID fmtid;
        IStorage *pstgT = NULL;

        Check(S_OK, g_pfnStgCreateStorageEx(NULL,
                                       STGM_CREATE | STGM_DELETEONRELEASE | STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                       STGFMT_STORAGE,
                                       0, NULL, NULL,
                                       IID_IStorage,
                                       reinterpret_cast<void**>(&pstgT) ));

        IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
        Check( S_OK, StgToPropSetStg( pstgT, &pPropSetStg ));

        UuidCreate(&fmtid);

        IPropertyStorage *pPropStg = NULL;

        Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_DEFAULT,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

        PROPSPEC propspec;
        propspec.ulKind = PRSPEC_PROPID;
        propspec.propid = 1000;
        PROPVARIANT propvar;
        propvar.vt = VT_I4;
        propvar.lVal = 12345;

        Check(S_OK, pPropStg->WriteMultiple(1, &propspec, &propvar, 2)); // force dirty

        switch (i)
        {
        case 0:
            Check(S_OK, pstgT->Commit(STGC_DEFAULT));
            pstgT->Release();
            pPropStg->Release();
            break;
        case 1:
            Check(S_OK, pstgT->Commit(STGC_DEFAULT));
            pPropStg->Release();
            pstgT->Release();
            break;
        case 2:
            pstgT->Release();
            pPropStg->Release();
            break;
        case 3:
            pPropStg->Commit(STGC_DEFAULT);
            pPropStg->Release();
            pstgT->Release();
            break;
        case 4:
            pPropStg->Commit(STGC_DEFAULT);
            pstgT->Release();
            pPropStg->Release();
            break;
        case 5:
            pPropStg->Release();
            pstgT->Release();
            break;
        }

        Check( 0, RELEASE_INTERFACE(pstgT) );
    }
}

void
test_IPropertySetStorage(IStorage *pStorage)
{
    //       Check ref counting through different interfaces on object

    test_IPropertySetStorage_IUnknown(pStorage);
    test_IPropertySetStorage_CreateOpenDelete(pStorage);
    test_IPropertySetStorage_SummaryInformation(pStorage);
    test_IPropertySetStorage_FailIfThere(pStorage);

    test_IPropertySetStorage_TransactedMode(pStorage);
    test_IPropertySetStorage_TransactedMode2(pStorage);
    test_IPropertySetStorage_SubPropertySet(pStorage);
    test_IPropertySetStorage_CommitAtRoot(pStorage);
}


//  IEnumSTATPROPSETSTG
//
//       Check enumeration of property sets
//
//          Check refcounting and IUnknown
//
//          Create some property sets, predefined and not, simple and not, one through IStorage
//          Enumerate them and check
//              (check fmtid, grfFlags)
//              (check when asking for more than there is: S_FALSE, S_OK)
//          Delete one
//          Reset the enumerator
//          Enumerate them and check
//          Delete one
//
//          Reset the enumeratorA
//          Read one from enumeratorA
//          Clone enumerator -> enumeratorB
//          Loop comparing rest of enumerator contents
//
//          Reset the enumerator
//          Skip all
//          Check none left
//
//          Reset the enumerator
//          Skip all but one
//          Check one left
//
void test_IEnumSTATPROPSETSTG(IStorage *pStorage)
{
    Status( "IEnumSTATPROPSETSTG\n" );

    FMTID afmtid[8];
    CLSID aclsid[8];
    IPropertyStorage *pPropSet;

    memset( afmtid, 0, sizeof(afmtid) );
    memset( aclsid, 0, sizeof(aclsid) );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FILETIME ftStart;

    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    CoFileTimeNow(&ftStart);

    IEnumSTATPROPSETSTG *penum, *penum2;
    STATPROPSETSTG StatBuffer[6];

    Check(S_OK, pPropSetStg->Enum(&penum));
    while( S_OK == penum->Next( 1, &StatBuffer[0], NULL ))
        pPropSetStg->Delete( StatBuffer[0].fmtid );
    RELEASE_INTERFACE( penum );

    Check(S_OK, pPropSetStg->Enum(&penum));
    Check( S_FALSE, penum->Next( 1, &StatBuffer[0], NULL ));
    RELEASE_INTERFACE( penum );

    for (int i=0; i<5; i++)
    {
        ULONG cFetched;

        if (i & 4)
            afmtid[i] = FMTID_SummaryInformation;
        else
            UuidCreate(&afmtid[i]);

        UuidCreate(&aclsid[i]);

        Check(S_OK, pPropSetStg->Create(
            afmtid[i],
            aclsid+i,
            ( (i & 1) && !(g_Restrictions & RESTRICT_SIMPLE_ONLY)  ? PROPSETFLAG_NONSIMPLE : 0)
            |
            ( (i & 2) && !(g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_ANSI : 0),
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropSet));
        pPropSet->Release();

        Check(S_OK, pPropSetStg->Enum(&penum));
        Check( S_FALSE, penum->Next( i+2, &StatBuffer[0], &cFetched ));
        Check( S_OK,    penum->Reset() );
        Check( S_OK,    penum->Next( i+1, &StatBuffer[0], &cFetched ));
        RELEASE_INTERFACE( penum );

    }


    ULONG celt;

    Check(S_OK, pPropSetStg->Enum(&penum));

    IUnknown *punk, *punk2;
    IEnumSTATPROPSETSTG *penum3;
    Check(S_OK, penum->QueryInterface(IID_IUnknown, (void**)&punk));
    Check(S_OK, punk->QueryInterface(IID_IEnumSTATPROPSETSTG, (void**)&penum3));
    Check(S_OK, penum->QueryInterface(IID_IEnumSTATPROPSETSTG, (void**)&punk2));
    Check(TRUE, punk == punk2);
    punk->Release();
    penum3->Release();
    punk2->Release();

    // test S_FALSE
    Check(S_FALSE, penum->Next(6, StatBuffer, &celt));
    Check(TRUE, celt == 5);
    penum->Reset();


    // test reading half out, then cloning, then comparing
    // rest of enumeration with other clone.

    Check(S_OK, penum->Next(3, StatBuffer, &celt));
    Check(TRUE, celt == 3);
    celt = 0;
    Check(S_OK, penum->Clone(&penum2));
    Check(S_OK, penum->Next(2, StatBuffer, &celt));
    Check(TRUE, celt == 2);

    // check the clone
    for (int c=0; c<2; c++)
    {
        STATPROPSETSTG CloneStat;
        Check(S_OK, penum2->Next(1, &CloneStat, NULL));
        Check(TRUE, 0 == memcmp(&CloneStat, StatBuffer+c, sizeof(CloneStat)));
        Check(TRUE, CloneStat.dwOSVersion == PROPSETHDR_OSVERSION_UNKNOWN);
    }

    // check both empty
    celt = 0;
    Check(S_FALSE, penum->Next(1, StatBuffer, &celt));
    Check(TRUE, celt == 0);

    Check(S_FALSE, penum2->Next(1, StatBuffer, &celt));
    Check(TRUE, celt == 0);

    penum->Reset();

    //
    // loop deleting one propset at a time
    // enumerate the propsets checking that correct ones appear.
    //


    for (ULONG d = 0; d<5; d++)
    {
        // d is for delete

        BOOL afFound[5];

        Check(S_FALSE, penum->Next(5+1-d, StatBuffer, &celt));
        Check(TRUE, celt == 5-d );
        penum->Reset();


        memset(afFound, 0, sizeof(afFound));
        for (ULONG iPropSet=0; iPropSet<5; iPropSet++)
        {
            for (ULONG iSearch=0; iSearch<5-d; iSearch++)
            {
                if (0 == memcmp(&StatBuffer[iSearch].fmtid, &afmtid[iPropSet], sizeof(StatBuffer[0].fmtid)))
                {
                    Check(FALSE, afFound[iPropSet]);
                    afFound[iPropSet] = TRUE;
                    break;
                }
            }

            if (iPropSet < d)
                Check(FALSE, afFound[iPropSet]);

            if (iSearch == 5-d)
            {
                Check(TRUE, iPropSet < d);
                continue;
            }

            Check(TRUE, ( (StatBuffer[iSearch].grfFlags & PROPSETFLAG_NONSIMPLE) ? 1u : 0u )
                        ==
                        ( (!(g_Restrictions & RESTRICT_SIMPLE_ONLY) && (iPropSet & 1)) ? 1u : 0u)
                 );

            Check(TRUE, (StatBuffer[iSearch].grfFlags & PROPSETFLAG_ANSI) == 0);

            // We should have a clsid if this is a non-simple property set and we're not disallowing
            // hierarchical storages (i.e. it's not NTFS).

            if( (PROPSETFLAG_NONSIMPLE & StatBuffer[iSearch].grfFlags) && !(RESTRICT_NON_HIERARCHICAL & g_Restrictions) )
                Check(TRUE, StatBuffer[iSearch].clsid == aclsid[iPropSet]);
            else
                Check(TRUE, StatBuffer[iSearch].clsid == CLSID_NULL);

            CheckTime(ftStart, StatBuffer[iSearch].mtime);
            CheckTime(ftStart, StatBuffer[iSearch].atime);
            CheckTime(ftStart, StatBuffer[iSearch].ctime);
        }

        Check(S_OK, pPropSetStg->Delete(afmtid[d]));
        penum->Release();
        Check(S_OK, pPropSetStg->Enum(&penum));
//        Check(S_OK, penum->Reset());
    }

    penum->Release();
    penum2->Release();
    pPropSetStg->Release();

}


//   Creation tests
//
//       Access flags/Valid parameters/Permissions
//          Check readonly cannot be written -
//              WriteProperties, WritePropertyNames
void
test_IPropertyStorage_Access(IStorage *pStorage)
{
    Status( "IPropertyStorage creation (access) tests\n" );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount(pStorage);
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);

    // check by name
    IPropertyStorage *pPropStg;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL, 0,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

//   QueryInterface tests
//          QI to IPropertyStorage
//          QI to IUnknown on IPropertyStorage
//          QI back to IPropertyStorage from IUnknown
//
//          Release all.
    IPropertyStorage *pPropStg2,*pPropStg3;
    IUnknown *punk;

    Check(S_OK, pPropStg->QueryInterface(IID_IPropertyStorage,
        (void**)&pPropStg2));

    Check(S_OK, pPropStg->QueryInterface(IID_IUnknown,
        (void**)&punk));

    Check(S_OK, punk->QueryInterface(IID_IPropertyStorage,
        (void**)&pPropStg3));

    pPropStg3->Release();
    pPropStg2->Release();
    punk->Release();

    PROPSPEC ps;
    ps.ulKind = PRSPEC_LPWSTR;
    ps.lpwstr = OLESTR("testprop");

    PROPVARIANT pv;
    pv.vt = VT_LPSTR;
    pv.pszVal = (LPSTR) "testval";

    Check(S_OK, pPropStg->WriteMultiple(1, &ps, &pv, 2));
    pPropStg->Release();

    Check(S_OK, pPropSetStg->Open(fmtid, STGM_SHARE_EXCLUSIVE | STGM_READ, &pPropStg));
    Check(STG_E_ACCESSDENIED, pPropStg->WriteMultiple(1, &ps, &pv, 2));
    Check(STG_E_ACCESSDENIED, pPropStg->DeleteMultiple(1, &ps));
    PROPID propid=3;
    Check(STG_E_ACCESSDENIED, pPropStg->WritePropertyNames(1, &propid, (LPOLESTR*) &pv.pszVal));
    Check(STG_E_ACCESSDENIED, pPropStg->DeletePropertyNames(1, &propid));
    FILETIME ft;
    Check(STG_E_ACCESSDENIED, pPropStg->SetTimes(&ft, &ft, &ft));
    CLSID clsid;
    Check(STG_E_ACCESSDENIED, pPropStg->SetClass(clsid));

    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
}

//   Creation tests
//       Check VT_STREAM etc not usable with simple.
//

void
test_IPropertyStorage_Create(IStorage *pStorage)
{
    Status( "IPropertyStorage creation (simple/non-simple) tests\n" );

    IPropertySetStorage *pPropSetStg = NULL;
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);

    // check by name
    IPropertyStorage *pPropStg;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_DEFAULT,
                                    STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                    &pPropStg));

    PROPSPEC ps;
    ps.ulKind = PRSPEC_PROPID;
    ps.propid = 2;

    PROPVARIANT pv;
    pv.vt = VT_STREAM;
    pv.pStream = NULL;

    Check(STG_E_PROPSETMISMATCHED, pPropStg->WriteMultiple(1, &ps, &pv, 2000));

    pPropStg->Release();

    Check( cStorageRefs, RELEASE_INTERFACE(pStorage) );
}

//
//
//   Stat (Create four combinations)
//       Check non-simple/simple flag
//       Check ansi/wide fflag
//     Also test clsid on propset

void test_IPropertyStorage_Stat(IStorage *pStorage)
{
    Status( "IPropertyStorage::Stat\n" );

    DWORD dwOSVersion = 0;

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;
    UuidCreate(&fmtid);
    IPropertyStorage *pPropSet;
    STATPROPSETSTG StatPropSetStg;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

    // Calculate the OS Version

#ifdef _MAC
    {
        // Get the Mac System Version (e.g., 7.53).

        OSErr oserr;
        SysEnvRec theWorld;
        oserr = SysEnvirons( curSysEnvVers, &theWorld );
        Check( TRUE, noErr == oserr );

        dwOSVersion = MAKEPSVER( OSKIND_MACINTOSH,
                                 HIBYTE(theWorld.systemVersion),
                                 LOBYTE(theWorld.systemVersion) );

    }
#else
    dwOSVersion = MAKELONG( MAKEWORD(HIBYTE(WINVER), LOBYTE(WINVER)), OSKIND_WIN32 );
#endif


    for (ULONG i=0; i<4; i++)
    {
        FILETIME ftStart;
        CoFileTimeNow(&ftStart);

        memset(&StatPropSetStg, 0, sizeof(StatPropSetStg));
        CLSID clsid;
        UuidCreate(&clsid);

        Check(S_OK, pPropSetStg->Create(fmtid, &clsid,
            ((i & 1) && 0 == (g_Restrictions & RESTRICT_SIMPLE_ONLY)  ? PROPSETFLAG_NONSIMPLE : 0)
            |
            ((i & 2) && 0 == (g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_ANSI : 0),
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));

        CheckStat(pPropSet, fmtid,
                  clsid,
                  (
                     ((i & 1) && !(g_Restrictions & RESTRICT_SIMPLE_ONLY)  ? PROPSETFLAG_NONSIMPLE : 0)
                     |
                     ((i & 2) && !(g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_ANSI : 0)
                  ),
                  ftStart, dwOSVersion );
        pPropSet->Release();

        Check(S_OK, pPropSetStg->Open(fmtid,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));

        CheckStat(pPropSet, fmtid, clsid,
            ((i & 1) && !(g_Restrictions & RESTRICT_SIMPLE_ONLY) ? PROPSETFLAG_NONSIMPLE : 0) |
            ((i & 2) && !(g_Restrictions & RESTRICT_UNICODE_ONLY)? PROPSETFLAG_ANSI : 0), ftStart, dwOSVersion );

        UuidCreate(&clsid);
        Check(S_OK, pPropSet->SetClass(clsid));
        pPropSet->Release();

        Check(S_OK, pPropSetStg->Open(fmtid,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));
        CheckStat(pPropSet, fmtid, clsid,
                  ((i & 1) && !(g_Restrictions & RESTRICT_SIMPLE_ONLY)  ? PROPSETFLAG_NONSIMPLE : 0)
                  |
                  ((i & 2) && !(g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_ANSI : 0), ftStart, dwOSVersion );
        pPropSet->Release();
    }

    RELEASE_INTERFACE(pPropSetStg);

}

//   ReadMultiple
//     Check none found S_FALSE
//
//     Success case non-simple readmultiple
//       Create a non-simple property set
//       Create two sub non-simples
//       Close all
//       Open the non-simple
//       Query for the two sub-nonsimples
//       Try writing to them
//       Close all
//       Open the non-simple
//       Query for the two sub-nonsimples
//       Check read back
//       Close all

void
test_IPropertyStorage_ReadMultiple_Normal(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    Status( "IPropertyStorage::ReadMultiple (normal)\n" );

    IPropertySetStorage *pPropSetStg = NULL;
    FMTID fmtid;
    UuidCreate(&fmtid);
    IPropertyStorage *pPropSet;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Create(fmtid, NULL,
            PROPSETFLAG_NONSIMPLE,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));

    // none found
    PROPSPEC ps[2];

    ps[0].ulKind = PRSPEC_LPWSTR;
    ps[0].lpwstr = L"testname";

    ps[1].ulKind = PRSPEC_PROPID;
    ps[1].propid = 1000;

    PROPVARIANT pv[2];
    PROPVARIANT pvSave[2];
    PROPVARIANT pvExtra[2];

    Check(S_FALSE, pPropSet->ReadMultiple(2, ps, pv));

    PropVariantInit( &pv[0] );
    pv[0].vt = VT_STREAM;
    pv[0].pStream = NULL;

    PropVariantInit( &pv[1] );
    pv[1].vt = VT_STORAGE;
    pv[1].pStorage = NULL;

    memcpy(pvSave, pv, sizeof(pvSave));
    memcpy(pvExtra, pv, sizeof(pvExtra));

    // write the two sub non-simples
    Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 1000));

    // re-open them
    Check(S_OK, pPropSet->ReadMultiple(2, ps, pv));
    Check(TRUE, pv[0].pStream != NULL);
    Check(TRUE, pv[1].pStorage != NULL);

    // check status of write when already open
    Check(S_OK, pPropSet->WriteMultiple(2, ps, pvSave, 1000));


    Check(STG_E_REVERTED, pv[0].pStream->Commit(0));
    Check(STG_E_REVERTED, pv[1].pStorage->Commit(0));
    Check(S_OK, pPropSet->ReadMultiple(2, ps, pvExtra));
    Check(TRUE, pvExtra[0].pStream != NULL);
    Check(TRUE, pvExtra[1].pStorage != NULL);
    Check(S_OK, pvExtra[0].pStream->Commit(0));
    Check(S_OK, pvExtra[1].pStorage->Commit(0));

    pvExtra[0].pStream->Release();
    pvExtra[1].pStorage->Release();

    pv[0].pStream->Release();
    pv[1].pStorage->Release();

    Check(S_OK, pPropSet->ReadMultiple(2, ps, pv));
    Check(TRUE, pv[0].pStream != NULL);
    Check(TRUE, pv[1].pStorage != NULL);

    Check(S_OK, pv[0].pStream->Write("billmotest", sizeof("billmotest"), NULL));
    IStream *pStm;
    Check(S_OK, pv[1].pStorage->CreateStream(OLESTR("teststream"),
        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
        0, 0, &pStm));
    pStm->Release();
    pv[0].pStream->Release();
    pv[1].pStorage->Release();
    pPropSet->Release();

    // re-re-open them
    Check(S_OK, pPropSetStg->Open(fmtid,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));
    Check(S_OK, pPropSet->ReadMultiple(2, ps, pv));
    Check(TRUE, pv[0].pStream != NULL);
    Check(TRUE, pv[0].pStorage != NULL);

    // read the stream and storage and check the contents.
    char szBillMo[32];
    Check(S_OK, pv[0].pStream->Read(szBillMo, 11, NULL));
    Check(TRUE, 0 == strcmp(szBillMo, "billmotest"));
    Check(S_OK, pv[1].pStorage->OpenStream(OLESTR("teststream"), NULL,
        STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &pStm));
    pStm->Release();
    pv[1].pStorage->Release();
    pv[0].pStream->Release();
    pPropSet->Release();

    RELEASE_INTERFACE(pPropSetStg);

}

//
//     CleanupOpenedObjects for ReadMultiple (two iterations one for "VT_STORAGE then VT_STREAM", one for
//              "VT_STREAM then VT_STORAGE")
//       Create property set
//       Create a "VT_STREAM then VT_STORAGE"
//       Open the second one exclusive
//       Formulate a query so that both are read - > will fail but ...
//       Check that the first one is still openable
//

void
test_IPropertyStorage_ReadMultiple_Cleanup(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    Status( "IPropertyStorage::ReadMultiple (cleanup)\n" );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);


    for (LONG i=0;i<2;i++)
    {
        IPropertyStorage * pPropSet;
        Check(S_OK, pPropSetStg->Create(fmtid, NULL,
                PROPSETFLAG_NONSIMPLE,
                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                &pPropSet));

        // none found
        PROPSPEC ps[2];
        ps[0].ulKind = PRSPEC_PROPID;
        ps[0].propid = 1000;
        ps[1].ulKind = PRSPEC_PROPID;
        ps[1].propid = 2000;

        PROPVARIANT pv[2];

        pv[0].vt = (VARTYPE) ( (i == 0) ? VT_STREAM : VT_STORAGE );
        pv[0].pStream = NULL;
        pv[1].vt = (VARTYPE) ( (i == 1) ? VT_STORAGE : VT_STREAM );
        pv[1].pStorage = NULL;

        // write the two sub non-simples

        // OFS gives driver internal error when overwriting a stream with a storage.
        Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 1000));

        // open both
        Check(S_OK, pPropSet->ReadMultiple(2, ps, pv)); // **

        // close the first ONLY and reopen both

        PROPVARIANT pv2[2];

        if (i==0)
            pv[0].pStream->Release();
        else
            pv[0].pStorage->Release();

        // reading both should fail because second is still open
        Check(STG_E_ACCESSDENIED, pPropSet->ReadMultiple(2, ps, pv2));
        // failure should not prevent this from succeeding
        Check(S_OK, pPropSet->ReadMultiple(1, ps, pv2)); // ***

        // cleanup from ** and ***
        if (i==0)
        {
            pv2[0].pStream->Release(); // ***
            pv[1].pStorage->Release(); // **
        }
        else
        {
            pv2[0].pStorage->Release(); // ***
            pv[1].pStream->Release(); // **
        }

        pPropSet->Release();
    }

    RELEASE_INTERFACE(pPropSetStg);
}

//     Reading an inconsistent non-simple
//       Create a non-simple
//       Create a sub-stream/storage
//       Close all
//       Delete the actual stream
//       Read the indirect property -> should not exist.
//

void
test_IPropertyStorage_ReadMultiple_Inconsistent(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    if( PROPIMP_NTFS == g_enumImplementation ) return;

    Status( "IPropertyStorage::ReadMultiple (inconsistent test)\n" );

    IPropertySetStorage *pPropSetStg = NULL;
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);

    IPropertyStorage * pPropSet;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL,
            PROPSETFLAG_NONSIMPLE,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));

    // none found
    PROPSPEC ps[3];
    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = 1000;
    ps[1].ulKind = PRSPEC_PROPID;
    ps[1].propid = 2000;
    ps[2].ulKind = PRSPEC_PROPID;
    ps[2].propid = 3000;

    PROPVARIANT pv[3];

    pv[0].vt = VT_STREAM;
    pv[0].pStream = NULL;
    pv[1].vt = VT_STORAGE;
    pv[1].pStorage = NULL;
    pv[2].vt = VT_UI4;
    pv[2].ulVal = 12345678;

    // write the two sub non-simples
    Check(S_OK, pPropSet->WriteMultiple(3, ps, pv, 1000));
    pPropSet->Release();
    Check(S_OK, pStorage->Commit(STGC_DEFAULT));

    // delete the propsets
    OLECHAR ocsPropsetName[48];

    // get name of the propset storage
    RtlGuidToPropertySetName(&fmtid, ocsPropsetName);

    // open it
    CTempStorage pStgPropSet(coOpen, pStorage, ocsPropsetName);

    // enumerate the non-simple properties.
    IEnumSTATSTG *penum;
    STATSTG stat[4];
    ULONG celt;
    Check(S_OK, pStgPropSet->EnumElements(0, NULL, 0, &penum));
    Check(S_OK, penum->Next(3, stat, &celt));
    penum->Release();


    for (ULONG i=0;i<celt;i++)
    {
        if (ocscmp(OLESTR("CONTENTS"), stat[i].pwcsName) != 0)
                        pStgPropSet->DestroyElement(stat[i].pwcsName);
        delete [] stat[i].pwcsName;
    }
    pStgPropSet.Release();

    Check(S_OK, pPropSetStg->Open(fmtid,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));
    Check(S_OK, pPropSet->ReadMultiple(3, ps, pv));
    Check(TRUE, pv[0].vt == VT_EMPTY);
    Check(TRUE, pv[1].vt == VT_EMPTY);
    Check(TRUE, pv[2].vt == VT_UI4);
    Check(TRUE, pv[2].ulVal == 12345678);
    pPropSet->Release();

    RELEASE_INTERFACE(pPropSetStg);
}

void
test_IPropertyStorage_ReadMultiple(IStorage *pStorage)
{
    test_IPropertyStorage_ReadMultiple_Normal(pStorage);
    test_IPropertyStorage_ReadMultiple_Cleanup(pStorage);
    test_IPropertyStorage_ReadMultiple_Inconsistent(pStorage);
}


//       Overwrite a non-simple property with a simple in a simple propset
void
test_IPropertyStorage_WriteMultiple_Overwrite1(IStorage *pStgBase)
{
    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    if( PROPIMP_NTFS == g_enumImplementation ) return;

    Status( "IPropertyStorage::WriteMultiple (overwrite 1)\n" );

    CTempStorage pStgSimple(coCreate, pStgBase, OLESTR("ov1_simp"));
    CTempStorage pStorage(coCreate, pStgBase, OLESTR("ov1_stg"));
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertySetStorage *pPropSetSimpleStg = NULL;

    FMTID fmtid, fmtidSimple;

    UuidCreate(&fmtid);
    UuidCreate(&fmtidSimple);

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    Check( S_OK, StgToPropSetStg( pStgSimple, &pPropSetSimpleStg ));

    // create a simple set with a non-simple child by copying the contents
    // stream a non-simple to a property set stream (simple)

    // create a nonsimple propset (will contain the contents stream)
    IPropertyStorage * pPropSet;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL,
            PROPSETFLAG_NONSIMPLE,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));
    // none found
    PROPSPEC ps[2];
    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = 1000;
    ps[1].ulKind = PRSPEC_LPWSTR;
    ps[1].lpwstr = OLESTR("foobar");
    PROPVARIANT pv[2];
    pv[0].vt = VT_STREAM;
    pv[0].pStream = NULL;
    pv[1].vt = VT_UI1;
    pv[1].bVal = 66;
    Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 100));

    // invalid parameter
    PROPVARIANT pvInvalid[2];
    PROPSPEC psInvalid[2];

    psInvalid[0].ulKind = PRSPEC_PROPID;
    psInvalid[0].propid = 1000;
    psInvalid[1].ulKind = PRSPEC_PROPID;
    psInvalid[1].propid = 1001;
    pvInvalid[0].vt = (VARTYPE)-99;
    pvInvalid[1].vt = (VARTYPE)-100;

    Check(HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED), pPropSet->WriteMultiple(1, psInvalid, pvInvalid, 100));
    Check(HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED), pPropSet->WriteMultiple(2, psInvalid, pvInvalid, 100));

    pPropSet->Release();

    // create a simple propset (will be overwritten)
    IPropertyStorage * pPropSetSimple;
    Check(S_OK, pPropSetSimpleStg->Create(fmtidSimple, NULL,
            0,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSetSimple));
    pPropSetSimple->Release();

    OLECHAR ocsNonSimple[48];
    OLECHAR ocsSimple[48];
    // get the name of the simple propset
    RtlGuidToPropertySetName(&fmtidSimple, ocsSimple);
    // get the name of the non-simple propset
    RtlGuidToPropertySetName(&fmtid, ocsNonSimple);

    // open non-simple as a storage (will copy the simple to this)
    IStorage *pstgPropSet;
    Check(S_OK, pStorage->OpenStorage(ocsNonSimple, NULL,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, NULL, 0, &pstgPropSet));

    // copy the contents of the non-simple to the propset of the simple
    IStream *pstmNonSimple;
    Check(S_OK, pstgPropSet->OpenStream(OLESTR("CONTENTS"), NULL,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, 0, &pstmNonSimple));

    IStream *pstmSimple;
    Check(S_OK, pStgSimple->OpenStream(ocsSimple,
        NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &pstmSimple));

    ULARGE_INTEGER uli;
    memset(&uli, 0xff, sizeof(uli));

    Check(S_OK, pstmNonSimple->CopyTo(pstmSimple, uli, NULL, NULL));
    pstmSimple->Release();
    pstmNonSimple->Release();
    pstgPropSet->Release();

    // But now the FMTID *in* the simple property set doesn't
    // match the string-ized FMTID which is the Stream's name.  So,
    // rename the Stream to match the property set's FMTID.

    Check(S_OK, pStgSimple->RenameElement( ocsSimple, ocsNonSimple ));

    // now we have a simple propset with a non-simple VT type
    Check(S_OK, pPropSetSimpleStg->Open(fmtid, // Use the non-simple FMTID now
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSetSimple));

    Check(S_FALSE, pPropSetSimple->ReadMultiple(1, ps, pv));
    Check(S_OK, pPropSetSimple->ReadMultiple(2, ps, pv));
    Check(TRUE, pv[0].vt == VT_EMPTY);
    Check(TRUE, pv[1].vt == VT_UI1);
    Check(TRUE, pv[1].bVal == 66);

    RELEASE_INTERFACE( pPropSetSimpleStg );

    pPropSetSimple->Release();
    RELEASE_INTERFACE(pPropSetStg);
}

//       Overwrite a non-simple with a simple in a non-simple
//          check that the non-simple is actually deleted
//       Delete a non-simple
//          check that the non-simple is actually deleted
void
test_IPropertyStorage_WriteMultiple_Overwrite2(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    if( PROPIMP_NTFS == g_enumImplementation ) return;

    Status( "IPropertyStorage::WriteMultiple (overwrite 2)\n" );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);

    IPropertyStorage *pPropSet;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_NONSIMPLE,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropSet));

    // create the non-simple
    PROPSPEC ps[5];
    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = 1000;
    ps[1].ulKind = PRSPEC_PROPID;
    ps[1].propid = 1001;
    ps[2].ulKind = PRSPEC_PROPID;
    ps[2].propid = 1002;
    ps[3].ulKind = PRSPEC_PROPID;
    ps[3].propid = 1003;
    ps[4].ulKind = PRSPEC_PROPID;
    ps[4].propid = 1004;
    PROPVARIANT pv[5];
    pv[0].vt = VT_STORAGE;
    pv[0].pStorage = NULL;
    pv[1].vt = VT_STREAM;
    pv[1].pStream = NULL;
    pv[2].vt = VT_STORAGE;
    pv[2].pStorage = NULL;
    pv[3].vt = VT_STREAM;
    pv[3].pStream = NULL;
    pv[4].vt = VT_STREAM;
    pv[4].pStream = NULL;

    Check(S_OK, pPropSet->WriteMultiple(5, ps, pv, 2000));
    pPropSet->Release();

    // get the name of the propset
    OLECHAR ocsPropsetName[48];
    RtlGuidToPropertySetName(&fmtid, ocsPropsetName);

    IStorage *pstgPropSet;
    Check(S_OK, pStorage->OpenStorage(ocsPropsetName, NULL,
        STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
        NULL, 0, &pstgPropSet));

    // get the names of the non-simple property
    IEnumSTATSTG *penum;
    STATSTG statProp[6];
    ULONG celt;
    Check(S_OK, pstgPropSet->EnumElements(0, NULL, 0, &penum));
    Check(S_OK, penum->Next(5, statProp, &celt));
    Check(TRUE, celt == 5);
    delete [] statProp[0].pwcsName;
    delete [] statProp[1].pwcsName;
    delete [] statProp[2].pwcsName;
    delete [] statProp[3].pwcsName;
    delete [] statProp[4].pwcsName;
    penum->Release();

    // reopen the property set and delete the non-simple
    pstgPropSet->Release();

    Check(S_OK, pPropSetStg->Open(fmtid, STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
        &pPropSet));

    pv[0].vt = VT_LPWSTR;
    pv[0].pwszVal = L"Overwrite1";
    pv[1].vt = VT_LPWSTR;
    pv[1].pwszVal = L"Overwrite2";
    pv[2].vt = VT_LPWSTR;
    pv[2].pwszVal = L"Overwrite3";
    pv[3].vt = VT_LPWSTR;
    pv[3].pwszVal = L"Overwrite4";
    pv[4].vt = VT_LPWSTR;
    pv[4].pwszVal = L"Overwrite5";

    Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 2000));
    Check(S_OK, pPropSet->DeleteMultiple(1, ps+2));
    Check(S_OK, pPropSet->DeleteMultiple(2, ps+3));
    pPropSet->Release();

    // open the propset as storage again and check that the VT_STORAGE is gone.
    Check(S_OK, pStorage->OpenStorage(ocsPropsetName, NULL,
        STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
        NULL, 0, &pstgPropSet));

    // check they were removed
    STATSTG statProp2[5];
    Check(S_OK, pstgPropSet->EnumElements(0, NULL, 0, &penum));
    Check(S_FALSE, penum->Next(5, statProp2, &celt));
    Check(TRUE, celt == 1);   // contents
    delete [] statProp2[0].pwcsName;

    penum->Release();
    pstgPropSet->Release();
    RELEASE_INTERFACE(pPropSetStg);
}

//       Write a VT_STORAGE over a VT_STREAM
//          check for cases: when not already open, when already open(access denied)
//       Write a VT_STREAM over a VT_STORAGE
//          check for cases: when not already open, when already open(access denied)
void
test_IPropertyStorage_WriteMultiple_Overwrite3(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    Status( "IPropertyStorage::WriteMultiple (overwrite 3)\n" );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);

    IPropertyStorage *pPropSet;

    Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_NONSIMPLE,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
        &pPropSet));
    PROPSPEC ps[2];
    ps[0].ulKind = PRSPEC_LPWSTR;
    ps[0].lpwstr = OLESTR("stream_storage");
    ps[1].ulKind = PRSPEC_LPWSTR;
    ps[1].lpwstr = OLESTR("storage_stream");
    PROPVARIANT pv[2];
    pv[0].vt = VT_STREAMED_OBJECT;
    pv[0].pStream = NULL;
    pv[1].vt = VT_STORED_OBJECT;
    pv[1].pStorage = NULL;

    PROPVARIANT pvSave[2];
    pvSave[0] = pv[0];
    pvSave[1] = pv[1];

    Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 1000));

    // swap them around
    PROPVARIANT pvTemp;
    pvTemp = pv[0];
    pv[0] = pv[1];
    pv[1] = pvTemp;
    Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 1000));
    memset(pv, 0, sizeof(pv));
    Check(S_OK, pPropSet->ReadMultiple(2, ps, pv));
    Check(TRUE, pv[0].vt == VT_STORED_OBJECT);
    Check(TRUE, pv[1].vt == VT_STREAMED_OBJECT);
    Check(TRUE, pv[0].pStorage != NULL);
    Check(TRUE, pv[1].pStream != NULL);
    STATSTG stat; stat.type = 0;
    Check(S_OK, pv[0].pStorage->Stat(&stat, STATFLAG_NONAME));
    Check(TRUE, stat.type == STGTY_STORAGE);
    Check(S_OK, pv[1].pStream->Stat(&stat, STATFLAG_NONAME));
    Check(TRUE, stat.type == STGTY_STREAM);

    STATSTG stat2; stat2.type = 0;
    // swap them around again, but this time with access denied
    Check(S_OK, pPropSet->WriteMultiple(2, ps, pvSave, 1000));
    Check(STG_E_REVERTED, pv[0].pStorage->Stat(&stat, STATFLAG_NONAME));
    pv[0].pStorage->Release();
    Check(S_OK, pPropSet->WriteMultiple(2, ps, pvSave, 1000));
    Check(STG_E_REVERTED, pv[1].pStream->Stat(&stat, STATFLAG_NONAME));
    pv[1].pStream->Release();

    pPropSet->Release();
    RELEASE_INTERFACE(pPropSetStg);
}

//
// test using IStorage::Commit to commit the changes in a nested
// property set
//

void
test_IPropertyStorage_Commit(IStorage *pStorage)
{
    if( g_Restrictions & ( RESTRICT_SIMPLE_ONLY | RESTRICT_DIRECT_ONLY) ) return;
    Status( "IPropertyStorage::Commit\n" );

    // 8 scenarios: (simple+non-simple)  * (direct+transacted) * (release only + commit storage + commit propset)
    for (int i=0; i<32; i++)
    {
        CTempStorage pDeeper(coCreate, pStorage, GetNextTest(), (i & 1) ? STGM_TRANSACTED : STGM_DIRECT);
        IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pDeeper);
        FMTID fmtid;

        ULONG cDeeperRefs = GetRefCount( pDeeper );
        Check( S_OK, StgToPropSetStg( pDeeper, &pPropSetStg ));
        UuidCreate(&fmtid);

        IPropertyStorage *pPropSet;

        Check(S_OK, pPropSetStg->Create(fmtid, NULL, (i&8) ? PROPSETFLAG_NONSIMPLE : PROPSETFLAG_DEFAULT,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE | ((i&16) && (i&8) ? STGM_TRANSACTED : STGM_DIRECT),
            &pPropSet));

        PROPSPEC ps;
        ps.ulKind = PRSPEC_PROPID;
        ps.propid = 100;
        PROPVARIANT pv;
        pv.vt = VT_I4;
        pv.lVal = 1234;

        Check(S_OK, pPropSet->WriteMultiple(1, &ps, &pv, 1000));

        memset(&pv, 0, sizeof(pv));
        Check(S_OK, pPropSet->ReadMultiple(1, &ps, &pv));
        Check(TRUE, pv.lVal == 1234);

        pv.lVal = 2345; // no size changes
        Check(S_OK, pPropSet->WriteMultiple(1, &ps, &pv, 1000));

        if (i & 4)
            Check(S_OK, pPropSet->Commit(0));
        if (i & 2)
            Check(S_OK, pStorage->Commit(0));

        Check(0, pPropSet->Release()); // implicit commit if i&2 is false

        if (S_OK == pPropSetStg->Open(fmtid, STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                    &pPropSet))
        {
            memset(&pv, 0, sizeof(pv));
            Check( !((i&16) && (i&8)) || (i&0x1c)==0x1c ? S_OK : S_FALSE, pPropSet->ReadMultiple(1, &ps, &pv));
            if (!((i&16) && (i&8))  || (i&0x1c)==0x1c)
                Check(TRUE, pv.lVal == 2345);

            pPropSet->Release();
        }

        RELEASE_INTERFACE(pPropSetStg);
        Check( cDeeperRefs, GetRefCount( pDeeper ));
    }
}

void
test_IPropertyStorage_WriteMultiple(IStorage *pStorage)
{
    test_IPropertyStorage_WriteMultiple_Overwrite1(pStorage);
    test_IPropertyStorage_WriteMultiple_Overwrite2(pStorage);
    test_IPropertyStorage_WriteMultiple_Overwrite3(pStorage);
    test_IPropertyStorage_Commit(pStorage);

}

// this serves as a test for WritePropertyNames, ReadPropertyNames, DeletePropertyNames
// DeleteMultiple, PropVariantCopy, FreePropVariantArray.

void
test_IPropertyStorage_DeleteMultiple(IStorage *pStorage)
{
    Status( "IPropertyStorage::DeleteMultiple\n" );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);

    IPropertyStorage *pPropSet;

    int PropId = 3;

    for (int type=0; type<2; type++)
    {
        BOOL fSimple = ( type == 0 || (g_Restrictions & RESTRICT_SIMPLE_ONLY) );

        UuidCreate(&fmtid);
        Check(S_OK, pPropSetStg->Create(fmtid,
            NULL,
            fSimple ? PROPSETFLAG_DEFAULT : PROPSETFLAG_NONSIMPLE,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));

        // create and delete each type.

        PROPVARIANT *pVar;

        for (int AtOnce=1; AtOnce <3; AtOnce++)
        {
            CGenProps gp;
            int Actual;
            while (pVar = gp.GetNext(AtOnce, &Actual, FALSE, fSimple ))
            {
                PROPSPEC ps[3];
                PROPID   rgpropid[3];
                LPOLESTR rglpostrName[3];
                OLECHAR  aosz[3][16];

                for (int s=0; s<3; s++)
                {
                    PROPGENPROPERTYNAME( &aosz[s][0], PropId );
                    rgpropid[s] = PropId++;
                    rglpostrName[s] = &aosz[s][0];
                    ps[s].ulKind = PRSPEC_LPWSTR;
                    ps[s].lpwstr = &aosz[s][0];
                }

                for (int l=1; l<Actual; l++)
                {
                    PROPVARIANT VarRead[3];
                    Check(S_FALSE, pPropSet->ReadMultiple(l, ps, VarRead));
                    Check(S_OK, pPropSet->WritePropertyNames(l, rgpropid, rglpostrName));
                    Check(S_FALSE, pPropSet->ReadMultiple(l, ps, VarRead));

                    Check(S_OK, pPropSet->WriteMultiple(l, ps, pVar, 1000));
                    Check(S_OK, pPropSet->ReadMultiple(l, ps, VarRead));
                    Check(S_OK, g_pfnFreePropVariantArray(l, VarRead));
                    Check(S_OK, pPropSet->DeleteMultiple(l, ps));

                    Check(S_FALSE, pPropSet->ReadMultiple(l, ps, VarRead));
                    Check(S_OK, g_pfnFreePropVariantArray(l, VarRead));

                    LPOLESTR rglpostrNameCheck[3];
                    Check(S_OK, pPropSet->ReadPropertyNames(l, rgpropid, rglpostrNameCheck));
                    for (int c=0; c<l; c++)
                    {
                        Check( 0, ocscmp(rglpostrNameCheck[c], rglpostrName[c]) );
                        delete [] rglpostrNameCheck[c];
                    }
                    Check(S_OK, pPropSet->DeletePropertyNames(l, rgpropid));
                    Check(S_FALSE, pPropSet->ReadPropertyNames(l, rgpropid, rglpostrNameCheck));
                }

                g_pfnFreePropVariantArray(Actual, pVar);
                delete pVar;
            }
        }
        pPropSet->Release();
    }

    RELEASE_INTERFACE(pPropSetStg);
}

void
test_IPropertyStorage(IStorage *pStorage)
{
    test_IPropertyStorage_Access(pStorage);
    test_IPropertyStorage_Create(pStorage);
    test_IPropertyStorage_Stat(pStorage);
    test_IPropertyStorage_ReadMultiple(pStorage);
    test_IPropertyStorage_WriteMultiple(pStorage);
    test_IPropertyStorage_DeleteMultiple(pStorage);
}





//
//   Word6.0 summary information
//      Open
//      Read fields
//      Stat
//


void test_Word6(IStorage *pStorage, CHAR *pszTemporaryDirectory)
{

    Status( "Word 6.0 compatibility test\n" );

    extern unsigned char g_achTestDoc[];
    extern unsigned g_cbTestDoc;

    OLECHAR oszTempFile[ MAX_PATH + 1 ];
    CHAR    szTempFile[ MAX_PATH + 1 ];

    strcpy( szTempFile, pszTemporaryDirectory );
    strcat( szTempFile, "word6.doc" );

    PropTest_mbstoocs( oszTempFile, sizeof(oszTempFile), szTempFile );
    PROPTEST_FILE_HANDLE hFile = PropTest_CreateFile( szTempFile );

#ifdef _MAC
    Check(TRUE, (PROPTEST_FILE_HANDLE) -1 != hFile);
#else
    Check(TRUE, INVALID_HANDLE_VALUE != hFile);
#endif

    DWORD cbWritten;


    PropTest_WriteFile(hFile, g_achTestDoc, g_cbTestDoc, &cbWritten);
    Check(TRUE, cbWritten == g_cbTestDoc);

    PropTest_CloseHandle(hFile);

    IStorage *pStg;
    Check(S_OK, g_pfnStgOpenStorageEx(oszTempFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                 STGFMT_ANY,
                                 0, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pStg) ));

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStg);
    IPropertyStorage *pPropStg;

    ULONG cStorageRefs = GetRefCount( pStg );
    Check( S_OK, StgToPropSetStg( pStg, &pPropSetStg ));
    Check(S_OK, pPropSetStg->Open(FMTID_SummaryInformation,
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READ,
                    &pPropStg));

#define WORDPROPS 18

    static struct tagWordTest {
        VARENUM vt;
        void *pv;
    } avt[WORDPROPS] = {
        VT_LPSTR, "Title of the document.",    // PID_TITLE
        VT_LPSTR, "Subject of the document.",  // PID_SUBJECT
        VT_LPSTR, "Author of the document.",   // PID_AUTHOR
        VT_LPSTR, "Keywords of the document.", // PID_KEYWORDS
        VT_LPSTR, "Comments of the document.", // PID_COMMENTS
        VT_LPSTR, "Normal.dot",                // PID_TEMPLATE -- Normal.dot
        VT_LPSTR, "Bill Morel",                // PID_LASTAUTHOR --
        VT_LPSTR, "3",                         // PID_REVNUMBER -- '3'
        VT_EMPTY, 0,                           // PID_EDITTIME -- 3 Minutes FILETIME
        VT_EMPTY, 0,                           // PID_LASTPRINTED -- 04/07/95 12:04 FILETIME
        VT_EMPTY, 0,                           // PID_CREATE_DTM
        VT_EMPTY, 0,                           // PID_LASTSAVE_DTM
        VT_I4, (void*) 1,                      // PID_PAGECOUNT
        VT_I4, (void*) 7,                      // PID_WORDCOUNT
        VT_I4, (void*) 65,                     // PID_CHARCOUNT
        VT_EMPTY, 0,                           // PID_THUMBNAIL
        VT_LPSTR, "Microsoft Word 6.0",        // PID_APPNAME
        VT_I4, 0  };                           // PID_SECURITY

    PROPSPEC propspec[WORDPROPS+2];

    for (int i=2; i<WORDPROPS+2; i++)
    {
        propspec[i].ulKind = PRSPEC_PROPID;
        propspec[i].propid = (PROPID)i;
    }

    PROPVARIANT propvar[WORDPROPS+2];

    Check(S_OK, pPropStg->ReadMultiple(WORDPROPS, propspec+2, propvar+2));

    for (i=2; i<WORDPROPS+2; i++)
    {
        if ( propvar[i].vt != avt[i-2].vt )
        {
            PRINTF( " PROPTEST: 0x%x retrieved type 0x%x, expected type 0x%x\n",
                    i, propvar[i].vt, avt[i-2].vt );
            Check(TRUE, propvar[i].vt == avt[i-2].vt);
        }

        switch (propvar[i].vt)
        {
        case VT_LPSTR:
            Check(TRUE, strcmp(propvar[i].pszVal, (char*)avt[i-2].pv)==0);
            break;
        case VT_I4:
            Check(TRUE, (ULONG_PTR) propvar[i].lVal == (ULONG_PTR)avt[i-2].pv);
            break;
        }
    }

    g_pfnFreePropVariantArray( WORDPROPS, propvar+2 );

    RELEASE_INTERFACE( pPropStg );
    RELEASE_INTERFACE( pPropSetStg );
    Check( 0, RELEASE_INTERFACE(pStg) );
}


void
test_IEnumSTATPROPSTG(IStorage *pstgTemp)
{
    Status( "IEnumSTATPROPSTG\n" );

    PROPID apropid[8];
    LPOLESTR alpostrName[8];
    OLECHAR aosz[8][32];
    PROPID PropId=2;
    PROPSPEC ps[8];

    FMTID fmtid;
    IPropertyStorage *pPropStg;

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pstgTemp);

    ULONG cStorageRefs = GetRefCount( pstgTemp );
    Check( S_OK, StgToPropSetStg( pstgTemp, &pPropSetStg ));
    UuidCreate(&fmtid);

    for (int setup=0; setup<8; setup++)
    {
        alpostrName[setup] = &aosz[setup][0];
    }


    CGenProps gp;

    // simple/non-simple, ansi/wide, named/not named
    for (int outer=0; outer<8; outer++)
    {
        UuidCreate(&fmtid);

        Check(S_OK, pPropSetStg->Create(fmtid, NULL,
            ((outer&4) && !(g_Restrictions & RESTRICT_SIMPLE_ONLY) ? PROPSETFLAG_NONSIMPLE : 0)
            |
            ((outer&2) && !(g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_ANSI : 0),
            STGM_CREATE | STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropStg));


        for (int i=0; i<CPROPERTIES; i++)
        {
            apropid[i] = PropId++;
            if (outer & 1)
            {
                ps[i].ulKind = PRSPEC_LPWSTR;
                PROPGENPROPERTYNAME( aosz[i], apropid[i] );
                ps[i].lpwstr = aosz[i];
            }
            else
            {
                ps[i].ulKind = PRSPEC_PROPID;
                ps[i].propid = apropid[i];
            }
        }

        if (outer & 1)
        {
            Check(S_OK, pPropStg->WritePropertyNames(CPROPERTIES, apropid, alpostrName));
        }

        PROPVARIANT *pVar = gp.GetNext(CPROPERTIES, NULL, TRUE, (outer&4)==0);  // no non-simple
        Check(TRUE, pVar != NULL);

        Check(S_OK, pPropStg->WriteMultiple(CPROPERTIES, ps, pVar, 1000));
        g_pfnFreePropVariantArray(CPROPERTIES, pVar);
        delete pVar;

        // Allocate enough STATPROPSTGs for one more than the actual properties
        // in the set.

        STATPROPSTG StatBuffer[CPROPERTIES+1];
        ULONG celt;
        IEnumSTATPROPSTG *penum, *penum2;

        Check(S_OK, pPropStg->Enum(&penum));

        IUnknown *punk, *punk2;
        IEnumSTATPROPSTG *penum3;
        Check(S_OK, penum->QueryInterface(IID_IUnknown, (void**)&punk));
        Check(S_OK, punk->QueryInterface(IID_IEnumSTATPROPSTG, (void**)&penum3));
        Check(S_OK, penum->QueryInterface(IID_IEnumSTATPROPSTG, (void**)&punk2));
        Check(TRUE, punk == punk2);
        punk->Release();
        penum3->Release();
        punk2->Release();

        // test S_FALSE
        Check(S_FALSE, penum->Next( CPROPERTIES+1, StatBuffer, &celt));
        Check(TRUE, celt == CPROPERTIES);

        CleanStat(celt, StatBuffer);

        penum->Reset();


        // test reading half out, then cloning, then comparing
        // rest of enumeration with other clone.

        Check(S_OK, penum->Next(CPROPERTIES/2, StatBuffer, &celt));
        Check(TRUE, celt == CPROPERTIES/2);
        CleanStat(celt, StatBuffer);
        celt = 0;
        Check(S_OK, penum->Clone(&penum2));
        Check(S_OK, penum->Next(CPROPERTIES - CPROPERTIES/2, StatBuffer, &celt));
        Check(TRUE, celt == CPROPERTIES - CPROPERTIES/2);
        // check the clone
        for (int c=0; c<CPROPERTIES - CPROPERTIES/2; c++)
        {
            STATPROPSTG CloneStat;
            Check(S_OK, penum2->Next(1, &CloneStat, NULL));
            Check(TRUE, IsEqualSTATPROPSTG(&CloneStat, StatBuffer+c));
            CleanStat(1, &CloneStat);
        }

        CleanStat(celt, StatBuffer);

        // check both empty
        celt = 0;
        Check(S_FALSE, penum->Next(1, StatBuffer, &celt));
        Check(TRUE, celt == 0);

        Check(S_FALSE, penum2->Next(1, StatBuffer, &celt));
        Check(TRUE, celt == 0);

        penum->Reset();

        //
        // loop deleting one property at a time
        // enumerate the propertys checking that correct ones appear.
        //
        for (ULONG d = 0; d<CPROPERTIES; d++)
        {
            // d is for delete

            BOOL afFound[CPROPERTIES];
            ULONG cTotal = 0;

            Check(S_OK, penum->Next(CPROPERTIES-d, StatBuffer, &celt));
            Check(TRUE, celt == CPROPERTIES-d);
            penum->Reset();

            memset(afFound, 0, sizeof(afFound));

            for (ULONG iProperty=0; iProperty<CPROPERTIES; iProperty++)
            {

                // Search the StatBuffer for this property.

                for (ULONG iSearch=0; iSearch<CPROPERTIES-d; iSearch++)
                {

                    // Compare this entry in the StatBuffer to the property for which we're searching.
                    // Use the lpstrName or propid, whichever is appropriate for this pass (indicated
                    // by 'outer').

                    if ( ( (outer & 1) == 1 && 0 == ocscmp(StatBuffer[iSearch].lpwstrName, ps[iProperty].lpwstr) )
                         ||
                         ( (outer & 1) == 0 && StatBuffer[iSearch].propid == apropid[iProperty] )
                       )
                    {
                        ASSERT (!afFound[iSearch]);
                        afFound[iSearch] = TRUE;
                        cTotal++;
                        break;
                    }
                }
            }

            CleanStat(celt, StatBuffer);

            Check(TRUE, cTotal == CPROPERTIES-d);

            Check(S_OK, pPropStg->DeleteMultiple(1, ps+d));
            Check(S_OK, penum->Reset());
        }

        penum->Release();
        penum2->Release();

        pPropStg->Release();

    }

    RELEASE_INTERFACE( pPropSetStg );
    Check( cStorageRefs, GetRefCount(pstgTemp) );
}

void
test_MaxPropertyName(IStorage *pstgTemp)
{

    if( PROPIMP_NTFS == g_enumImplementation ) return;
    Status( "Max Property Name length\n" );

    //  ----------
    //  Initialize
    //  ----------

    CPropVariant cpropvar;

    // Create a new storage, because we're going to create
    // well-known property sets, and this way we can be sure
    // that they don't already exist.

    IStorage *pstg = NULL; // TSafeStorage< IStorage > pstg;

    Check(S_OK, pstgTemp->CreateStorage( OLESTR("MaxPropNameTest"),
                                         STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                         0L, 0L,
                                         &pstg ));

    // Generate a new Format ID.

    FMTID fmtid;
    UuidCreate(&fmtid);

    // Get a IPropertySetStorage from the IStorage.

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pstg);
    IPropertyStorage *pPropStg = NULL; // TSafeStorage< IPropertyStorage > pPropStg;
    Check( S_OK, StgToPropSetStg( pstg, &pPropSetStg ));

    //  ----------------------------------
    //  Test the non-SumInfo property set.
    //  ----------------------------------

    // Create a new PropertyStorage.

    Check(S_OK, pPropSetStg->Create(fmtid,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg));

    // Generate a property name which greater than the old max length
    // (NT5 removes the name length limitation, was 255 not including the terminator).

    OLECHAR *poszPropertyName;
    poszPropertyName = new OLECHAR[ (CCH_MAXPROPNAMESZ+1) * sizeof(OLECHAR) ];
    Check(TRUE, poszPropertyName != NULL );

    for( ULONG ulIndex = 0; ulIndex < CCH_MAXPROPNAMESZ; ulIndex++ )
        poszPropertyName[ ulIndex ] = OLESTR('a') + (OLECHAR) ( ulIndex % 26 );
    poszPropertyName[ CCH_MAXPROPNAMESZ ] = OLESTR('\0');


    // Write out a property with this oldmax+1 name.

    PROPSPEC propspec;

    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = poszPropertyName;

    cpropvar = (long) 0x1234;

    Check(S_OK, pPropStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    // Write out a property with a minimum-character name.

    propspec.lpwstr = OLESTR("X");
    Check(S_OK, pPropStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    // Write out a property with a below-minimum-character name.

    propspec.lpwstr = OLESTR("");
    Check(STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    delete [] poszPropertyName;

    Check( 0, RELEASE_INTERFACE(pPropStg ));
    RELEASE_INTERFACE(pPropSetStg);
    Check( 0, RELEASE_INTERFACE(pstg) );

}

void
test_CodePages( LPOLESTR poszDirectory )
{

    if( g_Restrictions & RESTRICT_UNICODE_ONLY ) return;

    // Can't run this test with STGFMT_FILE, because CFlatStorage
    // is not compatible with it.
    if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
        return;

    Status( "Code Page compatibility\n" );

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR oszBadFile[ MAX_PATH ];
    OLECHAR oszGoodFile[ MAX_PATH ];
    OLECHAR oszUnicodeFile[ MAX_PATH ];
    OLECHAR oszMacFile[ MAX_PATH ];
    HRESULT hr = S_OK;

    IStorage *pStgBad = NULL, *pStgGood = NULL, *pStgUnicode = NULL, *pStgMac = NULL; // TSafeStorage< IStorage > pStgBad, pStgGood, pStgUnicode, pStgMac;
    CPropVariant cpropvarWrite, cpropvarRead;

    Check( TRUE, GetACP() == CODEPAGE_DEFAULT );

    //  ------------------------------
    //  Create test ANSI property sets
    //  ------------------------------

    // Create a property set with a bad codepage.

    ocscpy( oszBadFile, poszDirectory );
    ocscat( oszBadFile, OLESTR( "\\BadCP.stg" ));
    CreateCodePageTestFile( oszBadFile, &pStgBad );
    ModifyPropSetCodePage( pStgBad, FMTID_NULL, CODEPAGE_BAD );

    // Create a property set with a good codepage.

    ocscpy( oszGoodFile, poszDirectory );
    ocscat( oszGoodFile, OLESTR("\\GoodCP.stg") );
    CreateCodePageTestFile( oszGoodFile, &pStgGood );
    ModifyPropSetCodePage( pStgGood, FMTID_NULL, CODEPAGE_GOOD );


    // Create a property set that has the OS Kind (in the
    // header) set to "Mac".

    ocscpy( oszMacFile, poszDirectory );
    ocscat( oszMacFile, OLESTR("\\MacKind.stg") );
    CreateCodePageTestFile( oszMacFile, &pStgMac );
    ModifyOSVersion( pStgMac, 0x00010904 );

    //  ---------------------------
    //  Open the Ansi property sets
    //  ---------------------------


    IPropertySetStorage *pPropSetStgBad = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStgBad(pStgBad);
    Check( S_OK, StgToPropSetStg( pStgBad, &pPropSetStgBad ));

    IPropertySetStorage *pPropSetStgGood = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStgGood(pStgGood);
    Check( S_OK, StgToPropSetStg( pStgGood, &pPropSetStgGood ));

    IPropertySetStorage *pPropSetStgMac = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStgMac(pStgMac);
    Check( S_OK, StgToPropSetStg( pStgMac, &pPropSetStgMac ));

    IPropertyStorage *pPropStgBad = NULL, *pPropStgGood = NULL, *pPropStgMac = NULL;

    Check(S_OK, pPropSetStgBad->Open(FMTID_NULL,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStgBad));

    Check(S_OK, pPropSetStgGood->Open(FMTID_NULL,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStgGood));

    Check(S_OK, pPropSetStgMac->Open(FMTID_NULL,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStgMac));

    //  ------------------------------------------
    //  Test BSTRs in the three ANSI property sets
    //  ------------------------------------------

    PROPSPEC propspec;
    PROPVARIANT propvar;
    PropVariantInit( &propvar );

    // Attempt to read by name.

    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = CODEPAGE_TEST_NAMED_PROPERTY;

    Check(S_OK,
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    g_pfnPropVariantClear( &propvar );

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(
        HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
#endif

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));

    // Attempt to write by name.  If this test fails, it may be because
    // the machine doesn't support CODEPAGE_GOOD (this is the case by default
    // on Win95).  To remedy this situation, go to control panel, add/remove
    // programs, windows setup (tab), check MultiLanguage support, then
    // click OK.  You'll have to restart the computer after this.

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
#endif

    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    g_pfnPropVariantClear( &propvar );

    // Attempt to read the BSTR property

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_BSTR_PROPID;

    Check(S_OK,
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    g_pfnPropVariantClear( &propvar );

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
#endif

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));

    // Attempt to write the BSTR property

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
#endif

    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    g_pfnPropVariantClear( &propvar );

    // Attempt to read the BSTR Vector property

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VBSTR_PROPID;

    Check(S_OK,
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    g_pfnPropVariantClear( &propvar );

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
#endif

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));

    // Attempt to write the BSTR Vector property

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
#endif
    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    g_pfnPropVariantClear( &propvar );

    // Attempt to read the Variant Vector which has a BSTR

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VPROPVAR_BSTR_PROPID;

    Check(S_OK,
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    g_pfnPropVariantClear( &propvar );

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
#endif

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));

    // Attempt to write the Variant Vector which has a BSTR

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
#endif

    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    g_pfnPropVariantClear( &propvar );

    // Attempt to read the I4 property.  Reading the bad property set
    // takes special handling, because it will return a different result
    // depending on whether NTDLL is checked or free (the free will work,
    // the checked generates an error in its validation checking).

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = 4;

    Check(S_OK,
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    g_pfnPropVariantClear( &propvar );

    hr = pPropStgBad->ReadMultiple( 1, &propspec, &propvar );
    Check(TRUE, S_OK == hr || HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION) == hr );
    g_pfnPropVariantClear( &propvar );

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));

    // Attempt to write the I4 property

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));

    hr = pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE );
    Check(TRUE, S_OK == hr || HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION) == hr );

    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    g_pfnPropVariantClear( &propvar );


    //  ---------------------------------------
    //  Test LPSTRs in the Unicode property set
    //  ---------------------------------------

    // This test doesn't verify that the LPSTRs are actually
    // written in Unicode.  A manual test is required for that.

    // Create a Unicode property set.  We'll make it
    // non-simple so that we can test a VT_STREAM (which
    // is stored like an LPSTR).

    ocscpy( oszUnicodeFile, poszDirectory );
    ocscat( oszUnicodeFile, OLESTR("\\UnicodCP.stg") );

    Check(S_OK, g_pfnStgCreateStorageEx(oszUnicodeFile,
                                   STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                   DetermineStgFmt( g_enumImplementation ),
                                   0, NULL, NULL,
                                   DetermineStgIID( g_enumImplementation ),
                                   reinterpret_cast<void**>(&pStgUnicode) ));

    IPropertySetStorage *pPropSetStgUnicode = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStgUnicode(pStgUnicode);
    Check( S_OK, StgToPropSetStg( pStgUnicode, &pPropSetStgUnicode ));

    IPropertyStorage *pPropStgUnicode = NULL; // TSafeStorage< IPropertyStorage > pPropStgUnicode;

    Check(S_OK, pPropSetStgUnicode->Create(FMTID_NULL,
                                           &CLSID_NULL,
                                           PROPSETFLAG_NONSIMPLE,
                                           STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                           &pPropStgUnicode));


    // Write/verify an LPSTR property.

    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = OLESTR("LPSTR Property");

    cpropvarWrite = "An LPSTR Property";

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, &cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, &cpropvarRead ));

    Check(0, strcmp( (LPSTR) cpropvarWrite, (LPSTR) cpropvarRead ));
    cpropvarRead.Clear();

    // Write/verify a vector of LPSTR properties

    propspec.lpwstr = OLESTR("Vector of LPSTR properties");

    cpropvarWrite[1] = "LPSTR Property #1";
    cpropvarWrite[0] = "LPSTR Property #0";

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, &cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, &cpropvarRead ));

    Check(0, strcmp( (LPSTR) cpropvarWrite[1], (LPSTR) cpropvarRead[1] ));
    Check(0, strcmp( (LPSTR) cpropvarWrite[0], (LPSTR) cpropvarRead[0] ));
    cpropvarRead.Clear();

    // Write/verify a vector of variants which has an LPSTR

    propspec.lpwstr = OLESTR("Variant Vector with an LPSTR");

    cpropvarWrite[1] = (PROPVARIANT) CPropVariant("LPSTR in a Variant Vector");
    cpropvarWrite[0] = (PROPVARIANT) CPropVariant((long) 22); // an I4
    Check(TRUE,  (VT_VECTOR | VT_VARIANT) == cpropvarWrite.VarType() );

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, &cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, &cpropvarRead ));

    Check(0, strcmp( (LPSTR) cpropvarWrite[1], (LPSTR) cpropvarRead[1] ));
    cpropvarRead.Clear();

    // Write/verify a Stream.

    cpropvarWrite = (IStream*) NULL;
    propspec.lpwstr = OLESTR("An IStream");

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, &cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, &cpropvarRead ));
    cpropvarRead.Clear();

    // There's nothing more we can check for the VT_STREAM property, a manual
    // check is required to verify that it was written correctly.

    RELEASE_INTERFACE(pStgBad);
    RELEASE_INTERFACE(pStgGood);
    RELEASE_INTERFACE(pStgUnicode);
    RELEASE_INTERFACE(pStgMac);
    RELEASE_INTERFACE(pPropSetStgBad);
    RELEASE_INTERFACE(pPropStgBad);
    RELEASE_INTERFACE(pPropStgGood);
    RELEASE_INTERFACE(pPropStgMac);
    RELEASE_INTERFACE(pPropSetStgGood);
    RELEASE_INTERFACE(pPropSetStgMac);
    RELEASE_INTERFACE(pPropSetStgUnicode);
    RELEASE_INTERFACE(pPropStgUnicode);

}

void
test_PropertyInterfaces(IStorage *pstgTemp)
{
    Status( "Property Interface\n" );
    g_nIndent++;

    // this test depends on being first for enumerator
    test_IEnumSTATPROPSETSTG(pstgTemp);

    test_MaxPropertyName(pstgTemp);
    test_IPropertyStorage(pstgTemp);
    test_IPropertySetStorage(pstgTemp);
    test_IEnumSTATPROPSTG(pstgTemp);

    --g_nIndent;
}


//===================================================================
//
//  Function:   test_CopyTo
//
//  Synopsis:   Verify that IStorage::CopyTo copies an
//              un-flushed property set.
//
//              This test creates and writes to a simple property set,
//              a non-simple property set, and a new Storage & Stream,
//              all within the source (caller-provided) Storage.
//
//              It then copies the entire source Storage to the
//              destination Storage, and verifies that all commited
//              data in the Source is also in the destination.
//
//              All new Storages and property sets are created
//              under a new base storage.  The caller can specify
//              if this base Storage is direct or transacted, and
//              can specify if the property sets are direct or
//              transacted.
//
//===================================================================

void test_CopyTo(IStorage *pstgSource,          // Source of the CopyTo
                 IStorage *pstgDestination,     // Destination of the CopyTo
                 ULONG ulBaseStgTransaction,    // Transaction bit for the base storage.
                 ULONG ulPropSetTransaction,    // Transaction bit for the property sets.
                 LPOLESTR oszBaseStorageName )
{
    if( g_Restrictions & RESTRICT_NON_HIERARCHICAL ) return;

    char szMessage[ 128 ];

    sprintf( szMessage, "IStorage::CopyTo (Base Storage is %s, PropSets are %s)\n",
                        ulBaseStgTransaction & STGM_TRANSACTED ? "transacted" : "direct",
                        ulPropSetTransaction & STGM_TRANSACTED ? "transacted" : "direct" );
    Status( szMessage );


    //  ---------------
    //  Local Variables
    //  ---------------

    OLECHAR const *poszTestSubStorage     = OLESTR( "TestStorage" );
    OLECHAR const *poszTestSubStream      = OLESTR( "TestStream" );
    OLECHAR const *poszTestDataPreCommit  = OLESTR( "Test Data (pre-commit)" );
    OLECHAR const *poszTestDataPostCommit = OLESTR( "Test Data (post-commit)" );

    long lSimplePreCommit = 0x0123;
    long lSimplePostCommit = 0x4567;

    long lNonSimplePreCommit  = 0x89AB;
    long lNonSimplePostCommit = 0xCDEF;

    BYTE acReadBuffer[ 80 ];
    ULONG cbRead;

    FMTID fmtidSimple, fmtidNonSimple;

    // Base Storages for the Source & Destination.  All
    // new Streams/Storages/PropSets will be created below here.

    IStorage *pstgBaseSource = NULL;
    IStorage *pstgBaseDestination = NULL;

    IStorage *pstgSub = NULL;   // A sub-storage of the base.
    IStream *pstmSub = NULL;    // A Stream in the sub-storage (pstgSub)

    PROPSPEC propspec;
    PROPVARIANT propvarSourceSimple,
                propvarSourceNonSimple,
                propvarDestination;


    //  -----
    //  Begin
    //  -----

    // Create new format IDs

    UuidCreate(&fmtidSimple);
    UuidCreate(&fmtidNonSimple);

    //  -----------------------
    //  Create the base Storage
    //  -----------------------

    // Create a base Storage for the Source.  All of this test will be under
    // that Storage.

    // In the source Storage.

    Check( S_OK, pstgSource->CreateStorage(
                                oszBaseStorageName,
                                STGM_CREATE | ulBaseStgTransaction | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                0L, 0L,
                                &pstgBaseSource ));


    // And in the destination Storage.

    Check( S_OK, pstgDestination->CreateStorage(
                                oszBaseStorageName,
                                STGM_CREATE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                0L, 0L,
                                &pstgBaseDestination ));



    //  -------------------------------------------
    //  Write data to a new Stream in a new Storage
    //  -------------------------------------------

    // We'll partially verify the CopyTo by checking that this data
    // makes it into the destination Storage.


    // Create a Storage, and then a Stream within it.

    Check( S_OK, pstgBaseSource->CreateStorage(
                                poszTestSubStorage,
                                STGM_CREATE | ulPropSetTransaction | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                0L, 0L,
                                &pstgSub ));

    Check( S_OK, pstgSub->CreateStream(
                            poszTestSubStream,
                            STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            0L, 0L,
                            &pstmSub ));

    // Write data to the Stream.

    Check( S_OK, pstmSub->Write(
                    poszTestDataPreCommit,
                    ( sizeof(OLECHAR)
                      *
                      (ocslen( poszTestDataPreCommit ) + sizeof(OLECHAR))
                    ),
                    NULL ));


    //  ---------------------------------------------------------
    //  Write to a new simple property set in the Source storage.
    //  ---------------------------------------------------------

    IPropertySetStorage *pPropSetStgSource = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStgSource(pstgBaseSource);
    Check( S_OK, StgToPropSetStg( pstgBaseSource, &pPropSetStgSource ));

    IPropertyStorage *pPropStgSource1 = NULL, *pPropStgSource2 = NULL, *pPropStgDestination = NULL;

    // Create a property set mode.

    Check(S_OK, pPropSetStgSource->Create(fmtidSimple,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropStgSource1));

    // Write the property set name (just to test this functionality).

    PROPID pidDictionary = 0;
    OLECHAR *poszPropSetName = OLESTR("Property Set for CopyTo Test");
    Check(TRUE,  CWC_MAXPROPNAMESZ >= ocslen(poszPropSetName) + sizeof(OLECHAR) );

    Check(S_OK, pPropStgSource1->WritePropertyNames( 1, &pidDictionary, &poszPropSetName ));

    // Create a PROPSPEC.  We'll use this throughout the rest of the routine.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = 1000;

    // Create a PROPVARIANT for this test of the Simple case.

    propvarSourceSimple.vt = VT_I4;
    propvarSourceSimple.lVal = lSimplePreCommit;

    // Write the PROPVARIANT to the property set.

    Check(S_OK, pPropStgSource1->WriteMultiple(1, &propspec, &propvarSourceSimple, 2));


    //  ---------------------------------------------------------------
    //  Write to a new *non-simple* property set in the Source storage.
    //  ---------------------------------------------------------------


    // Create a property set.

    Check(S_OK, pPropSetStgSource->Create(fmtidNonSimple,
            NULL,
            PROPSETFLAG_NONSIMPLE,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | ulPropSetTransaction | STGM_READWRITE,
            &pPropStgSource2));

    // Set data in the PROPVARIANT for the non-simple test.

    propvarSourceNonSimple.vt = VT_I4;
    propvarSourceNonSimple.lVal = lNonSimplePreCommit;

    // Write the PROPVARIANT to the property set.

    Check(S_OK, pPropStgSource2->WriteMultiple(1, &propspec, &propvarSourceNonSimple, 2));


    //  -------------------------
    //  Commit everything so far.
    //  -------------------------

    // Commit the sub-Storage.
    Check(S_OK, pstgSub->Commit( STGC_DEFAULT ));

    // Commit the simple property set.
    Check(S_OK, pPropStgSource1->Commit( STGC_DEFAULT ));

    // Commit the non-simple property set.
    Check(S_OK, pPropStgSource2->Commit( STGC_DEFAULT ));

    // Commit the base Storage which holds all of the above.
    Check(S_OK, pstgBaseSource->Commit( STGC_DEFAULT ));


    //  -------------------------------------------------
    //  Write new data to everything but don't commit it.
    //  -------------------------------------------------

    // Write to the sub-storage.
    Check(S_OK, pstmSub->Seek(g_li0, STREAM_SEEK_SET, NULL));
    Check( S_OK, pstmSub->Write(
                    poszTestDataPostCommit,
                    ( sizeof(OLECHAR)
                      *
                      (ocslen( poszTestDataPostCommit ) + sizeof(OLECHAR))
                    ),
                    NULL ));


    // Write to the simple property set.
    propvarSourceSimple.lVal = lSimplePostCommit;
    Check(S_OK, pPropStgSource1->WriteMultiple(1, &propspec, &propvarSourceSimple, 2));

    // Write to the non-simple property set.
    propvarSourceNonSimple.lVal = lNonSimplePostCommit;
    Check(S_OK, pPropStgSource2->WriteMultiple(1, &propspec, &propvarSourceNonSimple, PID_FIRST_USABLE ));


    //  -------------------------------------------
    //  Copy the source Storage to the destination.
    //  -------------------------------------------

    // Release the sub-Storage (which is below the base Storage, and has
    // a Stream with data in it), just to test that the CopyTo can
    // handle it.

    pstgSub->Release();
    pstgSub = NULL;

    Check(S_OK, pstgBaseSource->CopyTo( 0, NULL, NULL, pstgBaseDestination ));


    //  ----------------------------------------------------------
    //  Verify the simple property set in the destination Storage.
    //  ----------------------------------------------------------


    IPropertySetStorage *pPropSetStgDestination = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStgDestination(pstgBaseDestination);
    Check( S_OK, StgToPropSetStg( pstgBaseDestination, &pPropSetStgDestination ));

    // Open the simple property set.

    Check(S_OK, pPropSetStgDestination->Open(fmtidSimple,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropStgDestination));

    // Verify the property set name.

    OLECHAR *poszPropSetNameDestination;
    BOOL   bReadPropertyNamePassed = FALSE;

    Check(S_OK, pPropStgDestination->ReadPropertyNames( 1, &pidDictionary,
                                                        &poszPropSetNameDestination ));
    if( poszPropSetNameDestination  // Did we get a name back?
        &&                          // If so, was it the correct name?
        !ocscmp( poszPropSetName, poszPropSetNameDestination )
      )
    {
        bReadPropertyNamePassed = TRUE;
    }
    delete [] poszPropSetNameDestination;
    poszPropSetNameDestination = NULL;

    Check( TRUE, bReadPropertyNamePassed );

    // Read the PROPVARIANT that we wrote earlier.

    Check(S_OK, pPropStgDestination->ReadMultiple(1, &propspec, &propvarDestination));

    // Verify that it's correct.

    Check(TRUE, propvarDestination.vt   == propvarSourceSimple.vt );
    Check(TRUE, propvarDestination.lVal == lSimplePostCommit);

    Check(S_OK, pPropStgDestination->Commit( STGC_DEFAULT ));
    Check(S_OK, pPropStgDestination->Release());
    pPropStgDestination = NULL;


    //  ----------------------------------------------------------------
    //  Verify the *non-simple* property set in the destination Storage.
    //  ----------------------------------------------------------------

    // Open the non-simple property set.

    Check(S_OK,
          pPropSetStgDestination->Open(fmtidNonSimple,
                STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &pPropStgDestination));

    // Read the PROPVARIANT that we wrote earlier.

    Check(S_OK, pPropStgDestination->ReadMultiple(1, &propspec, &propvarDestination));

    // Verify that they're the same.

    Check(TRUE, propvarDestination.vt   == propvarSourceNonSimple.vt );

    Check(TRUE, propvarDestination.lVal
                ==
                ( STGM_TRANSACTED & ulPropSetTransaction
                  ?
                  lNonSimplePreCommit
                  :
                  lNonSimplePostCommit
                ));

    Check(S_OK, pPropStgDestination->Commit( STGC_DEFAULT ));
    Check(S_OK, pPropStgDestination->Release());
    pPropStgDestination = NULL;

    //  ------------------------------------------------
    //  Verify the test data in the destination Storage.
    //  ------------------------------------------------

    // Now we can release and re-use the Stream pointer that
    // currently points to the sub-Stream in the source docfile.

    Check(STG_E_REVERTED, pstmSub->Commit( STGC_DEFAULT ));
    Check(S_OK, pstmSub->Release());
    pstmSub = NULL;

    // Get the Storage then the Stream.

    Check( S_OK, pstgBaseDestination->OpenStorage(
                                poszTestSubStorage,
                                NULL,
                                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
                                NULL,
                                0L,
                                &pstgSub ));

    Check( S_OK, pstgSub->OpenStream(
                            poszTestSubStream,
                            NULL,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            0L,
                            &pstmSub ));

    // Read the data and compare it against what we wrote.

    Check( S_OK, pstmSub->Read(
                    acReadBuffer,
                    sizeof( acReadBuffer ),
                    &cbRead ));

    OLECHAR const *poszTestData = ( STGM_TRANSACTED & ulPropSetTransaction )
                                  ?
                                  poszTestDataPreCommit
                                  :
                                  poszTestDataPostCommit;

    Check( TRUE, cbRead == sizeof(OLECHAR)
                           *
                           (ocslen( poszTestData ) + sizeof(OLECHAR))
         );

    Check( FALSE, ocscmp( poszTestData, (OLECHAR *) acReadBuffer ));


    //  ----
    //  Exit
    //  ----

    RELEASE_INTERFACE( pPropSetStgSource );
    RELEASE_INTERFACE(pPropStgSource1);
    RELEASE_INTERFACE(pPropStgSource2);
    RELEASE_INTERFACE(pPropStgDestination);
    RELEASE_INTERFACE(pPropSetStgDestination);

    RELEASE_INTERFACE(pstgBaseSource);
    RELEASE_INTERFACE(pstgBaseDestination);

    RELEASE_INTERFACE(pstgSub);
    RELEASE_INTERFACE(pstmSub);

    // We're done.  Don't bother to release anything;
    // they'll release themselves in their destructors.

    return;

}   // test_CopyTo()



//--------------------------------------------------------
//
//  Function:   test_OLESpecTickerExample
//
//  Synopsis:   This function generates the ticker property set
//              example that's used in the OLE Programmer's Reference
//              (when describing property ID 0 - the dictionary).
//
//--------------------------------------------------------


#define PID_SYMBOL  0x7
#define PID_OPEN    0x3
#define PID_CLOSE   0x4
#define PID_HIGH    0x5
#define PID_LOW     0x6
#define PID_LAST    0x8
#define PID_VOLUME  0x9

void test_OLESpecTickerExample( IStorage* pstg )
{
    Status( "Generate the Stock Ticker example from the OLE Programmer's Ref\n" );

    //  ------
    //  Locals
    //  ------

    FMTID fmtid;

    PROPSPEC propspec;

    LPOLESTR oszPropSetName = OLESTR( "Stock Quote" );

    LPOLESTR oszTickerSymbolName = OLESTR( "Ticker Symbol" );
    LPOLESTR oszOpenName   = OLESTR( "Opening Price" );
    LPOLESTR oszCloseName  = OLESTR( "Last Closing Price" );
    LPOLESTR oszHighName   = OLESTR( "High Price" );
    LPOLESTR oszLowName    = OLESTR( "Low Price" );
    LPOLESTR oszLastName   = OLESTR( "Last Price" );
    LPOLESTR oszVolumeName = OLESTR( "Volume" );

    //  ---------------------------------
    //  Create a new simple property set.
    //  ---------------------------------

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pstg);
    IPropertyStorage *pPropStg;

    ULONG cStorageRefs = GetRefCount( pstg );
    Check( S_OK, StgToPropSetStg( pstg, &pPropSetStg ));
    UuidCreate( &fmtid );

    Check(S_OK, pPropSetStg->Create(fmtid,
            NULL,
            PROPSETFLAG_DEFAULT,    // Unicode
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg));


    //  ---------------------------------------------
    //  Fill in the simply property set's dictionary.
    //  ---------------------------------------------

    // Write the property set's name.

    PROPID pidDictionary = 0;
    Check(S_OK, pPropStg->WritePropertyNames(1, &pidDictionary, &oszPropSetName ));

    // Write the High price, forcing the dictionary to pad.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_HIGH;

    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszHighName ));


    // Write the ticker symbol.

    propspec.propid = PID_SYMBOL;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszTickerSymbolName));

    // Write the rest of the dictionary.

    propspec.propid = PID_LOW;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszLowName));

    propspec.propid = PID_OPEN;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszOpenName));

    propspec.propid = PID_CLOSE;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszCloseName));

    propspec.propid = PID_LAST;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszLastName));

    propspec.propid = PID_VOLUME;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszVolumeName));


    // Write out the ticker symbol.

    propspec.propid = PID_SYMBOL;

    PROPVARIANT propvar;
    propvar.vt = VT_LPWSTR;
    propvar.pwszVal = L"MSFT";

    Check(S_OK, pPropStg->WriteMultiple(1, &propspec, &propvar, 2));


    //  ----
    //  Exit
    //  ----

    Check(S_OK, pPropStg->Commit( STGC_DEFAULT ));
    Check(0, pPropStg->Release());
    Check(S_OK, pstg->Commit( STGC_DEFAULT ));
    RELEASE_INTERFACE( pPropSetStg );
    Check( cStorageRefs, GetRefCount(pstg) );

    return;


}  // test_OLESpecTickerExample()


void
test_Office( LPOLESTR wszTestFile )
{
    Status( "Generate Office Property Sets\n" );

    IStorage *pStg = NULL;
    IPropertyStorage *pPStgSumInfo=NULL, *pPStgDocSumInfo=NULL, *pPStgUserDefined=NULL;
    IPropertySetStorage *pPSStg = NULL; // TSafeStorage<IPropertySetStorage> pPSStg;

    PROPVARIANT propvarWrite, propvarRead;
    PROPSPEC    propspec;

    PropVariantInit( &propvarWrite );
    PropVariantInit( &propvarRead );

    // Create the file

    Check( S_OK, g_pfnStgCreateStorageEx( wszTestFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L,
                                     NULL,
                                     NULL,
                                     IID_IPropertySetStorage,
                                     (void**) &pPSStg ));

    // Create the SummaryInformation property set.

    Check(S_OK, pPSStg->Create( FMTID_SummaryInformation,
                                NULL,
                                (g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI,
                                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                &pPStgSumInfo ));

    // Write a Title to the SumInfo property set.

    PropVariantInit( &propvarWrite );
    propvarWrite.vt = VT_LPSTR;
    propvarWrite.pszVal = "Title from PropTest";
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_TITLE;

    Check( S_OK, pPStgSumInfo->WriteMultiple( 1, &propspec, &propvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPStgSumInfo->ReadMultiple( 1, &propspec, &propvarRead ));

    Check( TRUE, propvarWrite.vt == propvarRead.vt );
    Check( FALSE, strcmp( propvarWrite.pszVal, propvarRead.pszVal ));

    g_pfnPropVariantClear( &propvarRead );
    PropVariantInit( &propvarRead );
    pPStgSumInfo->Release();
    pPStgSumInfo = NULL;


    // Create the DocumentSummaryInformation property set.

    Check(S_OK, pPSStg->Create( FMTID_DocSummaryInformation,
                                NULL,
                                (g_Restrictions & RESTRICT_UNICODE_ONLY ) ? PROPSETFLAG_DEFAULT: PROPSETFLAG_ANSI,
                                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                &pPStgDocSumInfo ));

    // Write a word-count to the DocSumInfo property set.

    PropVariantInit( &propvarWrite );
    propvarWrite.vt = VT_I4;
    propvarWrite.lVal = 100;
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_WORDCOUNT;

    Check( S_OK, pPStgDocSumInfo->WriteMultiple( 1, &propspec, &propvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPStgDocSumInfo->ReadMultiple( 1, &propspec, &propvarRead ));

    Check( TRUE, propvarWrite.vt == propvarRead.vt );
    Check( TRUE, propvarWrite.lVal == propvarRead.lVal );

    g_pfnPropVariantClear( &propvarRead );
    PropVariantInit( &propvarRead );
    pPStgDocSumInfo->Release();
    pPStgDocSumInfo = NULL;


    // Create the UserDefined property set.

    Check(S_OK, pPSStg->Create( FMTID_UserDefinedProperties,
                                NULL,
                                (g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI,
                                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                &pPStgUserDefined ));

    // Write named string to the UserDefined property set.

    PropVariantInit( &propvarWrite );
    propvarWrite.vt = VT_LPSTR;
    propvarWrite.pszVal = "User-Defined string from PropTest";
    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = OLESTR("PropTest String");

    Check( S_OK, pPStgUserDefined->WriteMultiple( 1, &propspec, &propvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPStgUserDefined->ReadMultiple( 1, &propspec, &propvarRead ));

    Check( TRUE, propvarWrite.vt == propvarRead.vt );
    Check( FALSE, strcmp( propvarWrite.pszVal, propvarRead.pszVal ));

    g_pfnPropVariantClear( &propvarRead );
    PropVariantInit( &propvarRead );
    pPStgUserDefined->Release();
    pPStgUserDefined = NULL;

    RELEASE_INTERFACE(pPSStg);

    // And we're done!  (Everything releases automatically)

    return;

}


void
test_Office2(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_NON_HIERARCHICAL ) return;
    Status( "Testing Office Property Sets\n" );

    IStorage *pSubStorage = NULL; // TSafeStorage< IStorage > pSubStorage;
    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg;
    IPropertyStorage *pPropStg = NULL; // TSafeStorage< IPropertyStorage > pPropStg;
    CPropSpec cpropspec;

    //  ----------------------------------
    //  Create a sub-storage for this test
    //  ----------------------------------

    Check(S_OK, pStorage->CreateStorage( OLESTR("test_Office2"),
                                         STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                         0, 0, &pSubStorage ));

    Check(S_OK, StgToPropSetStg( pSubStorage, &pPropSetStg ));


    //  --------------------------------------------------------
    //  Test the Create/Delete of the DocumentSummaryInformation
    //  property set (this requires special code because it
    //  has two sections).
    //  --------------------------------------------------------

    // Create & Delete a DSI propset with just the first section.

    Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg));

    pPropStg->Release(); pPropStg = NULL;
    Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));

    // Create & Delete a DSI propset with just the second section

    Check(S_OK, pPropSetStg->Create(FMTID_UserDefinedProperties,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg ));

    pPropStg->Release(); pPropStg = NULL;
    Check(S_OK, pPropSetStg->Delete( FMTID_UserDefinedProperties ));
    Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));


    //  --------------------------------------------
    //  Test the Create/Open of the DSI property set
    //  --------------------------------------------

    // Create & Delete a DocumentSummaryInformation propset with both sections.
    // If you delete the DSI propset first, it should delete both sections.
    // If you delete the UD propset first, the DSI propset should still
    // remain.  We'll loop twice, trying both combinations.

    for( int i = 0; i < 2; i++ )
    {

        // Create the first section.

        Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
                NULL,
                PROPSETFLAG_DEFAULT,
                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &pPropStg));
        pPropStg->Release(); pPropStg = NULL;

        // Create the second section.

        Check(S_OK, pPropSetStg->Create(FMTID_UserDefinedProperties,
                NULL,
                PROPSETFLAG_DEFAULT,
                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &pPropStg));
        pPropStg->Release(); pPropStg = NULL;

        if( i == 0 )
        {
            // Delete the second section, then the first.
            Check(S_OK, pPropSetStg->Delete( FMTID_UserDefinedProperties ));
            Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));
        }
        else
        {
            // Delete the first section, then *attempt* to delete the second.
            Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));
            Check(STG_E_FILENOTFOUND, pPropSetStg->Delete( FMTID_UserDefinedProperties ));
        }
    }   // for( i = 0; i < 2; i++ )

    //  ------------------------------------------------------------------
    //  Verify that we can create the UD propset (the 2nd section) without
    //  harming the first section.
    //  ------------------------------------------------------------------

    {
        CPropSpec rgcpropspec[2];
        CPropVariant rgcpropvarWrite[2];
        CPropVariant cpropvarRead;

        // Create the first section.

        Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
                        NULL,
                        PROPSETFLAG_DEFAULT,
                        STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                        &pPropStg));

        // Write a property to the first section.

        rgcpropspec[0] = OLESTR("Test DSI Property");
        rgcpropvarWrite[0] = (DWORD) 1;
        Check(S_OK, pPropStg->WriteMultiple( 1, rgcpropspec[0], &rgcpropvarWrite[0],
                                             PID_FIRST_USABLE ));
        pPropStg->Release(); pPropStg = NULL;

        // *Create* the second section

        Check(S_OK, pPropSetStg->Create(FMTID_UserDefinedProperties,
                        NULL,
                        PROPSETFLAG_DEFAULT,
                        STGM_SHARE_EXCLUSIVE | STGM_READWRITE | STGM_CREATE,
                        &pPropStg ));

        // Write a property to the second section

        rgcpropspec[1] = OLESTR("Test UD Property");
        rgcpropvarWrite[1] = (DWORD) 2;
        Check(S_OK, pPropStg->WriteMultiple( 1, rgcpropspec[1], &rgcpropvarWrite[1],
                                             PID_FIRST_USABLE ));
        pPropStg->Release(); pPropStg = NULL;

        // Verify the properties from each of the sections.

        Check(S_OK, pPropSetStg->Open(FMTID_DocSummaryInformation,
                        STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                        &pPropStg ));
        Check(S_OK, pPropStg->ReadMultiple( 1, rgcpropspec[0], &cpropvarRead ));
        Check(TRUE, rgcpropvarWrite[0] == cpropvarRead );
        cpropvarRead.Clear();
        pPropStg->Release(); pPropStg = NULL;

        Check(S_OK, pPropSetStg->Open(FMTID_UserDefinedProperties,
                        STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                        &pPropStg ));
        Check(S_OK, pPropStg->ReadMultiple( 1, rgcpropspec[1], &cpropvarRead ));
        Check(TRUE, rgcpropvarWrite[1] == cpropvarRead );
        cpropvarRead.Clear();
        pPropStg->Release(); pPropStg = NULL;
    }

    //  -------------------------------------
    //  Test special properties in DocSumInfo
    //  -------------------------------------

    // This verifies that when we Create a DocSumInfo
    // property set, and write a Vector or LPSTRs,
    // we can read it again.  We test this because
    // Vectors of LPSTRs are a special case in the DocSumInfo,
    // and the Create & Open path are slightly different
    // in CPropertySetStream::_LoadHeader.

    // Create a new property set.

    Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg));

    // Create a vector of LPSTRs.  Make the strings
    // varying lengths to ensure we get plenty of
    // opportunity for alignment problems.

    CPropVariant cpropvarWrite, cpropvarRead;

    cpropvarWrite[3] = "12345678";
    cpropvarWrite[2] = "1234567";
    cpropvarWrite[1] = "123456";
    cpropvarWrite[0] = "12345";
    Check(TRUE,  cpropvarWrite.Count() == 4 );

    // Write the property

    cpropspec = OLESTR("A Vector of LPSTRs");

    Check(S_OK, pPropStg->WriteMultiple( 1, cpropspec, &cpropvarWrite, 2 ));

    // Read the property back.

    Check(S_OK, pPropStg->ReadMultiple( 1, cpropspec, &cpropvarRead ));

    // Verify that we read what we wrote.

    for( i = 0; i < (int) cpropvarWrite.Count(); i++ )
    {
        Check(0, strcmp( (LPSTR) cpropvarWrite[i], (LPSTR) cpropvarRead[i] ));
    }

    //  ----
    //  Exit
    //  ----

    RELEASE_INTERFACE(pSubStorage);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pPropStg);

    return;
}



void test_PropVariantCopy( )
{
    Status( "PropVariantCopy\n" );

    PROPVARIANT propvarCopy;
    PropVariantInit( &propvarCopy );

    VERSIONEDSTREAM VersionedStream;
    UuidCreate( &VersionedStream.guidVersion );
    VersionedStream.pStream = NULL;

    for( int i = 0; i < CPROPERTIES_ALL; i++ )
    {
        Check(S_OK, g_pfnPropVariantCopy( &propvarCopy, &g_rgcpropvarAll[i] )); // g_pfnPropVariantCopy( &propvarCopy, &g_rgcpropvarAll[i] ));
        Check(S_OK, CPropVariant::Compare( &propvarCopy, &g_rgcpropvarAll[i] ));
        g_pfnPropVariantClear( &propvarCopy );

        // If this is a stream, take the opportunity to do a test of vt_versioned_stream.
        if( VT_STREAM == g_rgcpropvarAll[i].vt )
        {
            VersionedStream.pStream = g_rgcpropvarAll[i].pStream;
            CPropVariant cpropvar = VersionedStream;
            Check( S_OK, g_pfnPropVariantCopy( &propvarCopy, &cpropvar ));
            Check( S_OK, CPropVariant::Compare( &propvarCopy, &cpropvar ));
            g_pfnPropVariantClear( &propvarCopy );
        }

    }
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

}



#define PERFORMANCE_ITERATIONS      300
#define STABILIZATION_ITERATIONS    10

void
test_Performance( IStorage *pStg )
{
//#ifndef _MAC

    if( g_Restrictions & RESTRICT_NON_HIERARCHICAL ) return;
    Status( "Performance\n" );

    CPropVariant rgcpropvar[2];
    CPropSpec    rgpropspec[2];

    IPropertySetStorage *pPSStg = NULL; // TSafeStorage< IPropertySetStorage > pPSStg( pStg );
    Check( S_OK, StgToPropSetStg( pStg, &pPSStg ));

    IPropertyStorage *pPStg = NULL; // TSafeStorage< IPropertyStorage > pPStg;
    IStream *pStm = NULL; // TSafeStorage< IStream > pStm;

    FMTID fmtid;
    ULONG ulCount;
    DWORD dwSumTimes;
    FILETIME filetimeStart, filetimeEnd;

    BYTE  *pPropertyBuffer;
    ULONG cbPropertyBuffer;

    UuidCreate( &fmtid );

    rgcpropvar[0][0] = L"I wish I were an Oscar Meyer wiener,";
    rgcpropvar[0][1] = L"That is what I'd truly like to be.";
    rgcpropvar[1][0] = "For if I were an Oscar Meyer wiener,";
    rgcpropvar[1][1] = "Everyone would be in love with me.";

    Check(TRUE,  (VT_LPWSTR | VT_VECTOR) == rgcpropvar[0].VarType() );
    Check(TRUE,  (VT_LPSTR  | VT_VECTOR) == rgcpropvar[1].VarType() );


    //  ----------------
    //  Test an IStorage
    //  ----------------

    // Create a buffer to write which is the same size as
    // the properties in rgcpropvar.

    cbPropertyBuffer =  sizeof(WCHAR)
                        *
                        (2 + wcslen(rgcpropvar[0][0]) + wcslen(rgcpropvar[0][1]));

    cbPropertyBuffer += (2 + strlen(rgcpropvar[1][0]) + strlen(rgcpropvar[1][1]));

    pPropertyBuffer = new BYTE[ cbPropertyBuffer ];

    PRINTF( "        Docfile CreateStream/Write/Release = " );
    dwSumTimes = 0;

    // Perform the test iterations

    for( ulCount = 0;
         ulCount < PERFORMANCE_ITERATIONS + STABILIZATION_ITERATIONS;
         ulCount++ )
    {
        if( ulCount == STABILIZATION_ITERATIONS )
            CoFileTimeNow( &filetimeStart );

        Check(S_OK, pStg->CreateStream(  OLESTR("StoragePerformance"),
                                         STGM_CREATE | STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                         0L, 0L,
                                         &pStm ));

        Check(S_OK, pStm->Write( pPropertyBuffer, cbPropertyBuffer, NULL ));
        pStm->Release(); pStm = NULL;

    }

    CoFileTimeNow( &filetimeEnd );
    filetimeEnd -= filetimeStart;
    PRINTF( "%4.2f ms\n", (float)filetimeEnd.dwLowDateTime
                          /
                          10000 // # of 100 nanosec units in 1 ms
                          /
                          PERFORMANCE_ITERATIONS );

    //  ------------------------------------------------------
    //  Try Creating a Property Set and writing two properties
    //  ------------------------------------------------------

    rgpropspec[0] = OLESTR("First Property");
    rgpropspec[1] = OLESTR("Second Property");

    PRINTF( "        PropSet Create(Overwrite)/WriteMultiple/Release = " );
    dwSumTimes = 0;

    for( ulCount = 0;
         ulCount < PERFORMANCE_ITERATIONS + STABILIZATION_ITERATIONS;
         ulCount++ )
    {
        if( ulCount == STABILIZATION_ITERATIONS )
            CoFileTimeNow( &filetimeStart) ;

        Check(S_OK, pPSStg->Create( fmtid,
                                    NULL,
                                    PROPSETFLAG_DEFAULT | PROPSETFLAG_NONSIMPLE,
                                    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                    &pPStg ));

        Check(S_OK, pPStg->WriteMultiple( 2, rgpropspec, rgcpropvar, PID_FIRST_USABLE ));
        pPStg->Release(); pPStg = NULL;

    }

    CoFileTimeNow( &filetimeEnd );
    filetimeEnd -= filetimeStart;
    PRINTF( "%4.2f ms\n", (float)filetimeEnd.dwLowDateTime
                          /
                          10000     // 100 ns units to 1 ms units
                          /
                          PERFORMANCE_ITERATIONS );



    //  ------------------------------------------------------
    //  WriteMultiple (with named properties) Performance Test
    //  ------------------------------------------------------


    PRINTF( "        WriteMultiple (named properties) = " );

    Check(S_OK, pPSStg->Create( fmtid,
                                NULL,
                                PROPSETFLAG_DEFAULT | PROPSETFLAG_NONSIMPLE,
                                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                &pPStg ));

    for( ulCount = 0;
         ulCount < PERFORMANCE_ITERATIONS + STABILIZATION_ITERATIONS;
         ulCount++ )
    {
        if( ulCount == STABILIZATION_ITERATIONS )
            CoFileTimeNow( &filetimeStart );

        for( int i = 0; i < CPROPERTIES_ALL; i++ )
        {
            Check(S_OK, pPStg->WriteMultiple( 1, &g_rgcpropspecAll[i], &g_rgcpropvarAll[i], PID_FIRST_USABLE ));
        }
        Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

    }

    CoFileTimeNow( &filetimeEnd );
    filetimeEnd -= filetimeStart;
    PRINTF( "%4.2f ms\n", (float) filetimeEnd.dwLowDateTime
                          /
                          10000 // 100 ns units to 1 ms units
                          /
                          PERFORMANCE_ITERATIONS );

    pPStg->Release();
    pPStg = NULL;


    //  --------------------------------------------------------
    //  WriteMultiple (with unnamed properties) Performance Test
    //  --------------------------------------------------------


    {
        CPropSpec rgcpropspecPIDs[ CPROPERTIES_ALL ];

        PRINTF( "        WriteMultiple (unnamed properties) = " );

        Check(S_OK, pPSStg->Create( fmtid,
                                    NULL,
                                    PROPSETFLAG_DEFAULT | PROPSETFLAG_NONSIMPLE,
                                    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                    &pPStg ));

        for( ulCount = 0; ulCount < CPROPERTIES_ALL; ulCount++ )
        {
            rgcpropspecPIDs[ ulCount ] = ulCount + PID_FIRST_USABLE;
        }


        for( ulCount = 0;
             ulCount < PERFORMANCE_ITERATIONS + STABILIZATION_ITERATIONS;
             ulCount++ )
        {
            if( ulCount == STABILIZATION_ITERATIONS )
                CoFileTimeNow( &filetimeStart );

            for( int i = 0; i < CPROPERTIES_ALL; i++ )
            {
                Check(S_OK, pPStg->WriteMultiple( 1, &rgcpropspecPIDs[i], &g_rgcpropvarAll[i], PID_FIRST_USABLE ));
            }
            Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));
        }

        CoFileTimeNow( &filetimeEnd );
        filetimeEnd -= filetimeStart;
        PRINTF( "%4.2f ms\n", (float) filetimeEnd.dwLowDateTime
                              /
                              10000 // 100 ns units to 1 ms units
                              /
                              PERFORMANCE_ITERATIONS );

        pPStg->Release();
        pPStg = NULL;
    }

//#endif // #ifndef _MAC

}   // test_Performance()




//
//  Function:   test_CoFileTimeNow
//
//  This function has nothing to do with the property set code,
//  but a property test happenned to expose a bug in it, so this
//  was just as good a place as any to test the fix.
//


void
test_CoFileTimeNow()
{
#ifndef _MAC    // No need to test this on the Mac, and we can't
                // because it doesn't support SYSTEMTIME.

    Status( "CoFileTimeNow " );

    FILETIME    ftCoFileTimeNow;
    FILETIME    ftCalculated;
    SYSTEMTIME  stCalculated;


    // Test the input validation

    Check(E_INVALIDARG, CoFileTimeNow( NULL ));
    Check(E_INVALIDARG, CoFileTimeNow( (FILETIME*) 0x01234567 ));


    // The bug in CoFileTimeNow caused it to report a time that was
    // 900 ms short, 50% of the time.  So let's just bounds check
    // it several times as a verification.

    for( int i = 0; i < 20; i++ )
    {
        Check(S_OK, CoFileTimeNow( &ftCoFileTimeNow ));
        GetSystemTime(&stCalculated);
        Check(TRUE, SystemTimeToFileTime(&stCalculated, &ftCalculated));
        Check(TRUE, ftCoFileTimeNow <= ftCalculated );

        Check(S_OK, CoFileTimeNow( &ftCoFileTimeNow ));
        Check(TRUE, ftCoFileTimeNow >= ftCalculated );

        // The CoFileTimeNow bug caused it to report the correct
        // time for a second, then the 900 ms short time for a second.
        // So let's sleep in this loop and ensure that we cover both
        // seconds.

        if( g_fVerbose )
            PRINTF( "." );

        Sleep(200);
    }
    PRINTF( "\n" );

#endif  // #ifndef _MAC

}


void
test_PROPSETFLAG_UNBUFFERED( IStorage *pStg )
{
    //  ----------
    //  Initialize
    //  ----------

    if( PROPIMP_DOCFILE_OLE32 != g_enumImplementation
        &&
        PROPIMP_DOCFILE_IPROP != g_enumImplementation )
        return;

    Status( "PROPSETFLAG_UNBUFFERED\n" );

    IStorage *pStgBase = NULL;
    IPropertyStorage *pPropStgUnbuffered = NULL, *pPropStgBuffered = NULL;
    IStream *pstmUnbuffered = NULL, *pstmBuffered = NULL;

    CPropSpec cpropspec;
    CPropVariant cpropvar;

    FMTID fmtidUnbuffered, fmtidBuffered;
    OLECHAR oszPropStgNameUnbuffered[ CCH_MAX_PROPSTG_NAME+1 ],
            oszPropStgNameBuffered[ CCH_MAX_PROPSTG_NAME+1 ];

    // Generate two FMTIDs

    UuidCreate( &fmtidUnbuffered );
    UuidCreate( &fmtidBuffered );

    //  ----------------------------
    //  Create the Property Storages
    //  ----------------------------

    // Create a transacted Storage

    Check( S_OK, pStg->CreateStorage(
                        OLESTR("test_PROPSETFLAG_UNBUFFERED"),
                        STGM_CREATE | STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                        0L, 0L,
                        &pStgBase ));

    // Verify that we have the necessary APIs

    Check( TRUE, g_pfnFmtIdToPropStgName && g_pfnPropStgNameToFmtId
                 && g_pfnStgCreatePropSetStg && g_pfnStgCreatePropStg
                 && g_pfnStgOpenPropStg );

    // What are the property storages' stream names?

    g_pfnFmtIdToPropStgName( &fmtidUnbuffered, oszPropStgNameUnbuffered );
    g_pfnFmtIdToPropStgName( &fmtidBuffered,   oszPropStgNameBuffered );

    // Create Streams for the property storages

    Check( S_OK, pStgBase->CreateStream(
                                oszPropStgNameUnbuffered,
                                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                0L, 0L,
                                &pstmUnbuffered ));

    Check( S_OK, pStgBase->CreateStream(
                                oszPropStgNameBuffered,
                                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                0L, 0L,
                                &pstmBuffered ));


    // Create two direct-mode IPropertyStorages (one buffered, one not)

    Check( S_OK, g_pfnStgCreatePropStg( (IUnknown*) pstmUnbuffered,
                                        fmtidUnbuffered,
                                        &CLSID_NULL,
                                        PROPSETFLAG_UNBUFFERED,
                                        0L, // Reserved
                                        &pPropStgUnbuffered ));
    pPropStgUnbuffered->Commit( STGC_DEFAULT );
    pstmUnbuffered->Release(); pstmUnbuffered = NULL;

    Check( S_OK, g_pfnStgCreatePropStg( (IUnknown*) pstmBuffered,
                                        fmtidBuffered,
                                        &CLSID_NULL,
                                        PROPSETFLAG_DEFAULT,
                                        0L, // Reserved
                                        &pPropStgBuffered ));
    pPropStgBuffered->Commit( STGC_DEFAULT );
    pstmBuffered->Release(); pstmBuffered = NULL;


    //  -------------------------
    //  Write, Commit, and Revert
    //  -------------------------

    // Write to both property storages

    cpropvar = "A Test String";
    cpropspec = OLESTR("Property Name");

    Check( S_OK, pPropStgUnbuffered->WriteMultiple( 1,
                                                    cpropspec,
                                                    &cpropvar,
                                                    PID_FIRST_USABLE ));

    Check( S_OK, pPropStgBuffered->WriteMultiple( 1,
                                                  cpropspec,
                                                  &cpropvar,
                                                  PID_FIRST_USABLE ));

    // Commit the base Storage.  This should only cause
    // the Unbuffered property to be commited.

    pStgBase->Commit( STGC_DEFAULT );

    // Revert the base Storage, and release the property storages.
    // This should cause the property in the buffered property storage
    // to be lost.

    pStgBase->Revert();
    pPropStgUnbuffered->Release(); pPropStgUnbuffered = NULL;
    pPropStgBuffered->Release(); pPropStgBuffered = NULL;

    //  -----------------------------
    //  Re-Open the property storages
    //  -----------------------------

    // Open the property storage Streams

    Check( S_OK, pStgBase->OpenStream( oszPropStgNameUnbuffered,
                                       0L,
                                       STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                       0L,
                                       &pstmUnbuffered ));

    Check( S_OK, pStgBase->OpenStream( oszPropStgNameBuffered,
                                       0L,
                                       STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                       0L,
                                       &pstmBuffered ));

    // Get IPropertyStorage interfaces

    Check( S_OK, g_pfnStgOpenPropStg( (IUnknown*) pstmUnbuffered,
                                      fmtidUnbuffered,
                                      PROPSETFLAG_UNBUFFERED,
                                      0L, // Reserved
                                      &pPropStgUnbuffered ));
    pstmUnbuffered->Release(); pstmUnbuffered = NULL;

    Check( S_OK, g_pfnStgOpenPropStg( (IUnknown*) pstmBuffered,
                                      fmtidBuffered,
                                      PROPSETFLAG_DEFAULT,
                                      0L, // Reserved
                                      &pPropStgBuffered ));
    pstmBuffered->Release(); pstmBuffered = NULL;


    //  --------------------
    //  Validate the results
    //  --------------------

    // We should only find the property in the un-buffered property set.

    cpropvar.Clear();
    Check( S_OK, pPropStgUnbuffered->ReadMultiple( 1, cpropspec, &cpropvar ));
    cpropvar.Clear();
    Check( S_FALSE, pPropStgBuffered->ReadMultiple( 1, cpropspec, &cpropvar ));
    cpropvar.Clear();


}   // test_PROPSETFLAG_UNBUFFERED()


void
test_PropStgNameConversion2()
{
    Status( "FmtIdToPropStgName & PropStgNameToFmtId\n" );

    //  ------
    //  Locals
    //  ------

    FMTID fmtidOriginal, fmtidNew;
    OLECHAR oszPropStgName[ CCH_MAX_PROPSTG_NAME+1 ];

    //  ----------------------------------
    //  Do a simple conversion and inverse
    //  ----------------------------------

    UuidCreate( &fmtidOriginal );
    fmtidNew = FMTID_NULL;

    Check( S_OK, g_pfnFmtIdToPropStgName( &fmtidOriginal, oszPropStgName ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));

    Check( TRUE, fmtidOriginal == fmtidNew );

    //  -----------------------
    //  Check the special-cases
    //  -----------------------

    // Summary Information

    Check( S_OK, g_pfnFmtIdToPropStgName( &FMTID_SummaryInformation, oszPropStgName ));
    Check( 0, ocscmp( oszPropStgName, oszSummaryInformation ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));
    Check( TRUE, FMTID_SummaryInformation == fmtidNew );

    // DocSumInfo (first section)

    Check( S_OK, g_pfnFmtIdToPropStgName( &FMTID_DocSummaryInformation, oszPropStgName ));
    Check( 0, ocscmp( oszPropStgName, oszDocSummaryInformation ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));
    Check( TRUE, FMTID_DocSummaryInformation == fmtidNew );

    // DocSumInfo (second section)

    Check( S_OK, g_pfnFmtIdToPropStgName( &FMTID_UserDefinedProperties, oszPropStgName ));
    Check( 0, ocscmp( oszPropStgName, oszDocSummaryInformation ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));
    Check( TRUE, FMTID_DocSummaryInformation == fmtidNew );

    // GlobalInfo (for PictureIt!)

    Check( S_OK, g_pfnFmtIdToPropStgName( &fmtidGlobalInfo, oszPropStgName ));
    Check( 0, ocscmp( oszPropStgName, oszGlobalInfo ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));
    Check( TRUE, fmtidGlobalInfo == fmtidNew );

    // ImageContents (for PictureIt!)

    Check( S_OK, g_pfnFmtIdToPropStgName( &fmtidImageContents, oszPropStgName ));
    Check( 0, ocscmp( oszPropStgName, oszImageContents ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));
    Check( TRUE, fmtidImageContents == fmtidNew );

    // ImageInfo (for PictureIt!)

    Check( S_OK, g_pfnFmtIdToPropStgName( &fmtidImageInfo, oszPropStgName ));
    Check( 0, ocscmp( oszPropStgName, oszImageInfo ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));
    Check( TRUE, fmtidImageInfo == fmtidNew );


}   // test_PropStgNameConversion()

void
test_PropStgNameConversion( IStorage *pStg )
{
    if( g_Restrictions & RESTRICT_NON_HIERARCHICAL ) return;
    Status( "Special-case property set names\n" );

    //  ------
    //  Locals
    //  ------

    IStorage *pStgSub = NULL;
    IPropertyStorage *pPropStg = NULL;
    IPropertySetStorage *pPropSetStg = NULL;
    IEnumSTATSTG *pEnumStg = NULL;
    IEnumSTATPROPSETSTG *pEnumPropSet = NULL;

    STATSTG rgstatstg[ NUM_WELL_KNOWN_PROPSETS ];
    STATPROPSETSTG rgstatpropsetstg[ NUM_WELL_KNOWN_PROPSETS ];
    UINT i;
    DWORD cEnum;

    BOOL bSumInfo= FALSE,
         bDocSumInfo= FALSE,
         bGlobalInfo= FALSE,
         bImageContents= FALSE,
         bImageInfo= FALSE;


    //  ------------------------------
    //  Create a Storage for this test
    //  ------------------------------

    Check( S_OK, pStg->CreateStorage( OLESTR("Special Cases"),
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      0, 0,
                                      &pStgSub ));

    // And get an IPropertySetStorage

    Check( S_OK, StgToPropSetStg( pStgSub, &pPropSetStg ));


    //  --------------------------------------------------
    //  Create one of each of the well-known property sets
    //  --------------------------------------------------

    Check( S_OK, pPropSetStg->Create( FMTID_SummaryInformation,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    RELEASE_INTERFACE( pPropStg );

    Check( S_OK, pPropSetStg->Create( FMTID_DocSummaryInformation,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    RELEASE_INTERFACE( pPropStg );

    Check( S_OK, pPropSetStg->Create( FMTID_UserDefinedProperties,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    RELEASE_INTERFACE( pPropStg );

    Check( S_OK, pPropSetStg->Create( fmtidGlobalInfo,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    RELEASE_INTERFACE( pPropStg );

    Check( S_OK, pPropSetStg->Create( fmtidImageContents,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    RELEASE_INTERFACE( pPropStg );

    Check( S_OK, pPropSetStg->Create( fmtidImageInfo,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    RELEASE_INTERFACE( pPropStg );


    //  ---------------------------------
    //  Verify the FMTID->Name conversion
    //  ---------------------------------

    // We verify this by enumerating the Storage's streams,
    // and checking for the expected names (e.g., we should see
    // "SummaryInformation", "DocumentSummaryInformation", etc.)

    Check( S_OK, pStgSub->EnumElements( 0, NULL, 0, &pEnumStg ));

    // Get all of the names.

    Check( S_FALSE, pEnumStg->Next( NUM_WELL_KNOWN_PROPSETS,
                                    rgstatstg,
                                    &cEnum ));

    // There should only be WellKnown-1 stream names, since
    // the UserDefined property set is part of the
    // DocumentSummaryInformation stream.

    Check( TRUE, cEnum == NUM_WELL_KNOWN_PROPSETS - 1 );


    for( i = 0; i < cEnum; i++ )
    {
        if( !ocscmp( rgstatstg[i].pwcsName, oszSummaryInformation ))
            bSumInfo= TRUE;
        else if( !ocscmp( rgstatstg[i].pwcsName, oszDocSummaryInformation ))
            bDocSumInfo= TRUE;
        else if( !ocscmp( rgstatstg[i].pwcsName, oszGlobalInfo ))
            bGlobalInfo= TRUE;
        else if( !ocscmp( rgstatstg[i].pwcsName, oszImageContents ))
            bImageContents= TRUE;
        else if( !ocscmp( rgstatstg[i].pwcsName, oszImageInfo ))
            bImageInfo= TRUE;

        delete [] rgstatstg[i].pwcsName;
    }

    // Verify that we found all the names we expected to find.

    Check( TRUE, bSumInfo && bDocSumInfo
                 && bGlobalInfo && bImageContents && bImageInfo );


    RELEASE_INTERFACE( pEnumStg );

    //  ---------------------------------
    //  Verify the Name->FMTID Conversion
    //  ---------------------------------

    // We do this by enumerating the property sets with IPropertySetStorage,
    // and verify that it correctly converts the Stream names to the
    // expected FMTIDs.

    bSumInfo = bDocSumInfo = bGlobalInfo = bImageContents = bImageInfo = FALSE;

    // Get the enumerator.

    Check( S_OK, pPropSetStg->Enum( &pEnumPropSet ));

    // Get all the property sets.

    Check( S_FALSE, pEnumPropSet->Next( NUM_WELL_KNOWN_PROPSETS,
                                        rgstatpropsetstg,
                                        &cEnum ));
    Check( TRUE, cEnum == NUM_WELL_KNOWN_PROPSETS - 1 );


    // Look for each of the expected FMTIDs.  We only look at WellKnown-1,
    // because the UserDefined property set doesn't get enumerated.

    for( i = 0; i < NUM_WELL_KNOWN_PROPSETS - 1; i++ )
    {
        if( rgstatpropsetstg[i].fmtid == FMTID_SummaryInformation )
            bSumInfo = TRUE;
        else if( rgstatpropsetstg[i].fmtid == FMTID_DocSummaryInformation )
            bDocSumInfo = TRUE;
        else if( rgstatpropsetstg[i].fmtid == fmtidGlobalInfo )
            bGlobalInfo = TRUE;
        else if( rgstatpropsetstg[i].fmtid == fmtidImageContents )
            bImageContents = TRUE;
        else if( rgstatpropsetstg[i].fmtid == fmtidImageInfo )
            bImageInfo = TRUE;

    }

    // NOTE:  There is no way(?) to test the name-to-FMTID
    // conversion for the UserDefined property set without
    // calling the conversion function directly, but that
    // function isn't exported on Win95.


    // Verify that we found all of the expected FMTIDs

    Check( TRUE, bSumInfo && bDocSumInfo
                 && bGlobalInfo && bImageContents && bImageInfo );


    RELEASE_INTERFACE( pEnumPropSet );
    RELEASE_INTERFACE( pPropSetStg );
    RELEASE_INTERFACE( pStgSub );

}   // test_PropStgNameConversion()




//-----------------------------------------------------------------------------
//
//  Function:   test_SimpleLeaks
//
//  This is a simple leak test.  It doesn't test all functionality for
//  leaks; it just checks the common path:  create, open, read, write,
//  and delete.
//
//-----------------------------------------------------------------------------

void test_SimpleLeaks( LPOLESTR poszDir )
{
    IStorage *pStg = NULL;
    IPropertySetStorage *pPropSetStg = NULL;
    SYSTEM_PROCESS_INFORMATION spiStart, spiEnd;

    OLECHAR oszTempFile[ MAX_PATH + 1 ];

    ocscpy( oszTempFile, poszDir );
    ocscat( oszTempFile, OLESTR("SimpleLeakTest") );

    Status( "Simple Leak Test " );

    Check( STATUS_SUCCESS, GetProcessInfo(&spiStart) );

    for( long i = 0; i < 1*1000*1000; i++ )
    {
        if( i % (50*1000) == 0 )
            PRINTF( "x");

        CPropSpec rgpropspec[2];
        CPropVariant rgpropvarWrite[2], rgpropvarRead[2];

        IPropertyStorage *pPropStg = NULL;

        Check( S_OK, g_pfnStgCreateStorageEx( oszTempFile,
                                         STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE
                                         |
                                         ( ((i&1) && !(g_Restrictions & RESTRICT_DIRECT_ONLY)) ? STGM_TRANSACTED : STGM_DIRECT ),
                                         DetermineStgFmt( g_enumImplementation ),
                                         0L,
                                         NULL,
                                         NULL,
                                         IID_IPropertySetStorage,
                                         (void**) &pPropSetStg));

        Check( S_OK, pPropSetStg->Create( FMTID_NULL, NULL,
                                          ( (i&2) && !(g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_ANSI : PROPSETFLAG_DEFAULT )
                                          |
                                          ( (i&4) && !(g_Restrictions & RESTRICT_SIMPLE_ONLY)  ? PROPSETFLAG_NONSIMPLE : PROPSETFLAG_DEFAULT ),
                                          STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE
                                          |
                                          ( (i&8) && !(g_Restrictions & RESTRICT_DIRECT_ONLY)  ? STGM_TRANSACTED : STGM_DIRECT ),
                                          &pPropStg ));

        rgpropspec[0] = OLESTR("Property Name");
        rgpropspec[1] = 1000;

        rgpropvarWrite[0] = "Hello, world";
        rgpropvarWrite[1] = (ULONG) 23;

        Check( S_OK, pPropStg->WriteMultiple( 2, rgpropspec, rgpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->Commit( STGC_DEFAULT ));
        Check( 0, pPropStg->Release() );

        Check( S_OK, pPropSetStg->Open( FMTID_NULL,
                                        ( (i&16) && !(g_Restrictions & RESTRICT_DIRECT_ONLY) ? STGM_TRANSACTED : STGM_DIRECT )
                                        |
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPropStg ));

        Check( S_OK, pPropStg->ReadMultiple( 2, rgpropspec, rgpropvarRead ));

        Check( TRUE, rgpropvarRead[0] == rgpropvarWrite[0]
                     &&
                     rgpropvarRead[1] == rgpropvarWrite[1] );

        Check( S_OK, pPropStg->DeleteMultiple( 2, rgpropspec ));
        Check( S_OK, pPropStg->Commit( STGC_DEFAULT ));

        Check( 0, pPropStg->Release() );

        Check( S_OK, pPropSetStg->Delete( FMTID_NULL ));
        Check( 0, pPropSetStg->Release() );

    }

    Check( STATUS_SUCCESS, GetProcessInfo(&spiEnd) );

    if( g_fVerbose )
    {
        PRINTF( "\n" );
        PRINTF( "        process id %I64u\n", (ULONG_PTR) spiEnd.UniqueProcessId );
        PRINTF( "        threads %lu, %lu\n", spiStart.NumberOfThreads, spiEnd.NumberOfThreads );
        PRINTF( "        handles %lu, %lu\n", spiStart.HandleCount, spiEnd.HandleCount );
        PRINTF( "        virtual size %lu, %lu\n", spiStart.VirtualSize, spiEnd.VirtualSize );
        PRINTF( "        peak virtual size %lu, %lu\n", spiStart.PeakVirtualSize, spiEnd.PeakVirtualSize );
        PRINTF( "        working set %lu, %lu\n", spiStart.WorkingSetSize, spiEnd.WorkingSetSize );
        PRINTF( "        peak working set %lu, %lu\n", spiStart.PeakWorkingSetSize, spiEnd.PeakWorkingSetSize );
        PRINTF( "        pagefile usage %lu, %lu\n", spiStart.PagefileUsage, spiEnd.PagefileUsage );
        PRINTF( "        peak pagefile usage %lu, %lu\n", spiStart.PeakPagefileUsage, spiEnd.PeakPagefileUsage );
        PRINTF( "        private memory %lu, %lu\n", spiStart.PrivatePageCount, spiEnd.PrivatePageCount );
        PRINTF( "        quota paged pool %lu, %lu\n", spiStart.QuotaPagedPoolUsage, spiEnd.QuotaPagedPoolUsage );
        PRINTF( "        peak quota paged pool %lu, %lu\n", spiStart.QuotaPeakPagedPoolUsage, spiEnd.QuotaPeakPagedPoolUsage );
        PRINTF( "        quota non-paged pool %lu, %lu\n", spiStart.QuotaNonPagedPoolUsage, spiEnd.QuotaNonPagedPoolUsage );
        PRINTF( "        peak quota non-paged pool %lu, %lu\n", spiStart.QuotaPeakNonPagedPoolUsage, spiEnd.QuotaPeakNonPagedPoolUsage );
    }


    // Ensure that the working set and pagefile usage didn't change by
    // more than 5%

    ULONG ulWorkingSetDifference = spiEnd.WorkingSetSize > spiStart.WorkingSetSize
                                   ? spiEnd.WorkingSetSize - spiStart.WorkingSetSize
                                   : spiStart.WorkingSetSize - spiEnd.WorkingSetSize;

    ULONG ulPagefileUsageDifference = spiEnd.PagefileUsage > spiStart.PagefileUsage
                                      ? spiEnd.PagefileUsage - spiStart.PagefileUsage
                                      : spiStart.PagefileUsage - spiEnd.PagefileUsage;


    Check( TRUE,
                 ( ulWorkingSetDifference == 0
                   ||
                   spiStart.WorkingSetSize/ulWorkingSetDifference >= 20
                 )
                 &&
                 ( ulPagefileUsageDifference == 0
                   ||
                   spiStart.PagefileUsage/ulPagefileUsageDifference >= 20
                 )
         );

}   // test_SimpleLeaks

//-----------------------------------------------------------------------------
//
//  Function:   test_SimpleDocFile
//
//  This function tests PropSet functionality on Simple DocFile.
//  This test comes in multiple phases:
//  1)  A simple docfile is created and a minimal amount of data is stored
//      in it.
//  2)  The docfile is closed and opened again.  The test attempts to write
//      a small string to the property storage in it.  This should succeed.
//      Then it attempts to write a 4K string, which should fail.
//  3)  The docfile is closed and opened again.  The test writes 3 small
//      strings to the prop storage.  This should be successful.
//
//  4)  The docfile is deleted.  A new docfile with a property set storage is
//      created, and more than 4K data is written to it.
//  5)  The docfile is opened and writing additional data to it should fail.
//
//-----------------------------------------------------------------------------

#define FOUR_K_SIZE     0x1000      // Make it at least 4K.
#define THREE_H_SIZE    300         // 300 bytes
#define ONE_H_SIZE      100         // 100 bytes
void
test_SimpleDocFile(LPOLESTR oszDir)
{
    IStorage *pDfStg = NULL;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;

    OLECHAR         oszFile[MAX_PATH];
    CPropSpec       rgPropSpec[3];
    CPropVariant    rgPropVariant[3];
    LPSTR           pFourKString;
    int             i;

    if( RESTRICT_NON_HIERARCHICAL & g_Restrictions ) return;    // NFF doesn't support simp mode
    Status( "Simple-mode docfile\n" );

    //
    // Generate a filename from the directory name.
    //
    ocscpy( oszFile, oszDir );
    ocscat( oszFile, OLESTR( "SimpDoc.stg" ));

    //
    // allocate a buffer with 1 less than 4K
    // and fill it with characters.
    //
    pFourKString = new CHAR[ FOUR_K_SIZE ];
    Check(TRUE, pFourKString != NULL);

    pFourKString[0] = '\0';
    for (i=0; i < ((FOUR_K_SIZE/8)-1); i++)
    {
        strcat(pFourKString,"abcd1234");
    }
    strcat(pFourKString,"abcd123");

    rgPropSpec[0]  = 0x10;
    rgPropSpec[1]  = 0x11;
    rgPropSpec[2]  = 0x12;

    //-------------------
    // 1st Test - setup
    //-------------------
    // Create a Docfile.
    //
    Check( S_OK, g_pfnStgCreateStorageEx( oszFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_SIMPLE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L, NULL, NULL,
                                     DetermineStgIID( g_enumImplementation ),
                                     reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));

    // Test that we can QI between IStorage and IPropertySetStorage

    if( UsingQIImplementation() )
    {
        IStorage *pstg2 = NULL, *pstg3 = NULL;
        IPropertySetStorage *ppropsetstg2 = NULL, *ppropsetstg3 = NULL;
        ULONG cRefs = GetRefCount( pDfStg );

        Check( S_OK, pDfStg->QueryInterface( IID_IStorage, reinterpret_cast<void**>(&pstg2) ));
        Check( S_OK, pstg2->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&ppropsetstg2) ));
        Check( S_OK, ppropsetstg2->QueryInterface( IID_IStorage, reinterpret_cast<void**>(&pstg3) ));
        Check( TRUE, pstg2 == pstg3 );

        Check( S_OK, pstg3->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&ppropsetstg3) ));
        Check( TRUE, ppropsetstg2 == ppropsetstg3 );

        RELEASE_INTERFACE(ppropsetstg3);
        RELEASE_INTERFACE(ppropsetstg2);
        RELEASE_INTERFACE(pstg3);
        Check( cRefs, RELEASE_INTERFACE(pstg2) );
    }

    Check( S_OK, pPropSetStg->Create( FMTID_UserDefinedProperties,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    //
    // Write several strings to the property storage
    //
    rgPropVariant[0] = "Hello, world";
    Check(S_OK, pPropStg->WriteMultiple(1, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    rgPropVariant[0] = "New string for offset 0";
    Check(S_OK, pPropStg->WriteMultiple(1, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    rgPropVariant[1] = "First string for offset 1";
    Check(S_OK, pPropStg->WriteMultiple(3, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    //
    // Release the storages and docfile.
    //
    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //--------------
    // 2nd Test
    //--------------
    //
    // Now Open the DocFile and storages
    // and write a small stream followed by a 4K stream.
    //
    //
    Check(S_OK, g_pfnStgOpenStorageEx(oszFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_SIMPLE,
                                 STGFMT_ANY,
                                 0L, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Open(FMTID_UserDefinedProperties,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

    //
    // Write a small string followed by a string that is at least 4K.
    // The large string write should fail because the simple stream allocates
    // a minimum size stream of 4K, and on an Open will not allow the stream to
    // grow.
    //
    rgPropVariant[0] = "After Open, Hello, world";
    rgPropVariant[1] = pFourKString;
    rgPropVariant[2] = "Another string after the long one";
    Check(S_OK, pPropStg->WriteMultiple(1, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));
    Check(STG_E_INVALIDFUNCTION, pPropStg->WriteMultiple(2, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));
    Check(STG_E_INVALIDFUNCTION, pPropStg->WriteMultiple(3, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));
    Check(S_OK, pPropStg->WriteMultiple(1, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));


    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //--------------
    // 3rd Test
    //--------------
    //
    // Open the DocFile again, and write smaller strings to the same
    // location.
    //
    Check(S_OK, g_pfnStgOpenStorageEx(oszFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_SIMPLE,
                                 STGFMT_ANY,
                                 0, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Open(FMTID_UserDefinedProperties,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

    //
    // The smaller strings can be written because they fit in under the 4K
    // size of the simple stream buffer.
    //
    rgPropVariant[0] = "2nd open, small string";
    rgPropVariant[1] = "small string2";
    rgPropVariant[2] = "small string3";
    Check(S_OK, pPropStg->WriteMultiple(1, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));
    Check(S_OK, pPropStg->WriteMultiple(2, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));
    Check(S_OK, pPropStg->WriteMultiple(3, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //---------------------------------
    // 4th Test - Create Large PropSet
    //---------------------------------
    //
    // Create a Docfile and fill with more than 4K.
    //
    Check( S_OK, g_pfnStgCreateStorageEx( oszFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_SIMPLE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L, NULL, NULL,
                                     DetermineStgIID( g_enumImplementation ),
                                     reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));


    Check( S_OK, pPropSetStg->Create( FMTID_NULL,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    rgPropSpec[0]  = 0x10;
    rgPropSpec[1]  = 0x11;
    rgPropSpec[2]  = 0x12;

    //
    // Write several strings to the property storage
    // The first one is a 4K string.
    //
    rgPropVariant[0] = pFourKString;
    rgPropVariant[1] = "First string for offset 1";
    rgPropVariant[2] = "small string3";
    Check(S_OK, pPropStg->WriteMultiple(3, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    //
    // Release the storages and docfile.
    //
    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //--------------
    // 5th Test
    //--------------
    //
    // Open the DocFile again, and write the same strings in a different
    // order.
    //
    Check(S_OK, g_pfnStgOpenStorageEx(oszFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_SIMPLE,
                                 STGFMT_ANY,
                                 0, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Open(CLSID_NULL,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

    //
    // The smaller strings can be written because they fit in under the 4K
    // size of the simple stream buffer.
    //
    rgPropVariant[0] = "small string0";
    rgPropVariant[1] = "First string for offset 1";
    rgPropVariant[2] = pFourKString;
    Check(S_OK, pPropStg->WriteMultiple(3, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //--------------
    // 6th Test
    //--------------
    //
    // Open the DocFile again, and write larger strings to the same
    // location.  This should fail.
    //
    Check(S_OK, g_pfnStgOpenStorageEx(oszFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_SIMPLE,
                                 STGFMT_ANY,
                                 0, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Open(CLSID_NULL,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

    //
    // Now write the same thing again, only with one extra character.
    // This should fail.
    //
    rgPropVariant[0] = "First string for offset 0";
    rgPropVariant[1] = pFourKString;
    rgPropVariant[2] = "small string00000";
    Check(STG_E_INVALIDFUNCTION, pPropStg->WriteMultiple(3, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    delete [] pFourKString;

    //--------------
    // 7th Test  - - A NON-SIMPLE MODE TEST
    //--------------
    //
    // Create and write to a property set with an element of 400 bytes.
    // Then delete 100 bytes.  Commit the changes.  The property set should
    // have shrunk by at least 100 bytes.
    //
    // allocate a buffer with 300 bytes and fill it.
    // and fill it with characters.
    //
    LPSTR           pThreeHString = NULL;
    LPSTR           pOneHString = NULL;

    //
    // Fill the 3 Hundred Byte String
    //
    pThreeHString = new CHAR[ THREE_H_SIZE ];
    Check(TRUE, pThreeHString != NULL);

    pThreeHString[0] = '\0';
    for (i=0; i < ((THREE_H_SIZE/8)-1); i++)
    {
        strcat(pThreeHString,"abcd1234");
    }
    strcat(pThreeHString,"abc");

    //
    // Fill the 1 Hundred Byte String
    //
    pOneHString = new CHAR[ ONE_H_SIZE ];
    Check(TRUE, pOneHString != NULL);

    pOneHString[0] = '\0';
    for (i=0; i < ((ONE_H_SIZE/8)-1); i++)
    {
        strcat(pOneHString,"xyxy8787");
    }
    strcat(pOneHString,"xyx");

    //
    // Create a Docfile and fill with the string
    //
    Check( S_OK, g_pfnStgCreateStorageEx( oszFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0, NULL, NULL,
                                     DetermineStgIID( g_enumImplementation ),
                                     reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));


    Check( S_OK, pPropSetStg->Create( FMTID_NULL,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    rgPropSpec[0]  = 0x10;
    rgPropSpec[1]  = 0x11;

    //
    // Write the string to the property storage
    //
    rgPropVariant[0] = pThreeHString;
    rgPropVariant[1] = pOneHString;
    Check(S_OK, pPropStg->WriteMultiple(2, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    //
    // Commit the changes and close.
    //
    Check(S_OK, pPropStg->Commit( STGC_DEFAULT ));
    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //
    // Check the size of the property set.
    //
    Check(S_OK, g_pfnStgOpenStorageEx(oszFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                 STGFMT_ANY,
                                 0, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pDfStg) ));

    IStream *pStm;
    STATSTG StatBuf;
    OLECHAR ocsPropSetName[30];
    DWORD   cbStream;

    RtlGuidToPropertySetName(&FMTID_NULL, ocsPropSetName);
    Check(S_OK, pDfStg->OpenStream(
            ocsPropSetName,
            NULL,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            0,
            &pStm));


    Check(S_OK, pStm->Stat( &StatBuf,STATFLAG_NONAME));
    if (StatBuf.cbSize.HighPart != 0)
    {
        printf("FAILURE: test_SimpleDocFile: Test 7: Size High part is not zero\n");
    }
    cbStream = StatBuf.cbSize.LowPart;

    RELEASE_INTERFACE(pStm);

    //
    // Delete
    //
    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Open(CLSID_NULL,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

    Check(S_OK, pPropStg->DeleteMultiple(1, &rgPropSpec[1]));

    //
    // Commit the changes and close.
    //
    Check(S_OK, pPropStg->Commit( STGC_DEFAULT ));
    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //
    // Check the size of the property set.
    //
    Check(S_OK, g_pfnStgOpenStorageEx(oszFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                 STGFMT_ANY,
                                 0, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pDfStg) ));

    RtlGuidToPropertySetName(&FMTID_NULL, ocsPropSetName);
    Check(S_OK, pDfStg->OpenStream(
            ocsPropSetName,
            NULL,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            0,
            &pStm));

    Check(S_OK, pStm->Stat( &StatBuf,STATFLAG_NONAME));
    Check(TRUE, (StatBuf.cbSize.HighPart == 0));

    Check(TRUE, (cbStream - StatBuf.cbSize.LowPart > 100));

    //
    // Release the storages and docfile.
    //

    delete [] pThreeHString;
    delete [] pOneHString;

    RELEASE_INTERFACE(pStm);
    RELEASE_INTERFACE(pDfStg);


}   // test_SimpleDocFile

//-----------------------------------------------------------------------------
//
//  Function:   test_ex_api
//
//  This function tests the StgOpenStorageEx API to make sure it correctly
//  opens an NTFS flat file property set when called with STGFMT_ANY for a
//  property set that was created on an NTFS flat file.
//
//-----------------------------------------------------------------------------
void
test_ex_api(LPOLESTR oszDir)
{
    IStorage *pDfStg = NULL;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;

    OLECHAR         oszFile[MAX_PATH];
    CPropSpec       rgPropSpec[3];
    CPropVariant    rgPropVariant[3];
    LPSTR           pFourKString;
    int             i;
    HRESULT         hr;
    FMTID           fmtidAnsi;

    Status( "Ex API Tests\n" );

    //
    // Generate a filename from the directory name.
    //
    ocscpy( oszFile, oszDir );

    ocscat( oszFile, OLESTR( "StgApi.dat" ));

    //
    // Create a property set storage and a prop storage
    //
    Check( S_OK, g_pfnStgCreateStorageEx( oszFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L,
                                     NULL,
                                     NULL,
                                     IID_IPropertySetStorage,
                                     (void**) &pPropSetStg));

    Check(S_OK,pPropSetStg->Create( FMTID_NULL, NULL,
                                      PROPSETFLAG_DEFAULT,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    //
    // Write a string to it.
    //
    rgPropSpec[0]  = 0x10;
    rgPropVariant[0] = "Hello, world";
    Check(S_OK, pPropStg->WriteMultiple(1, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    //
    // Close it
    //
    pPropStg->Release();
    pPropStg = NULL;
    pPropSetStg->Release();
    pPropSetStg = NULL;

    //
    // Open it.
    //
    Check(S_OK,g_pfnStgOpenStorageEx(   oszFile,
                                     STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     STGFMT_ANY,
                                     0L,
                                     NULL,
                                     NULL,
                                     IID_IPropertySetStorage,
                                     (void**) &pPropSetStg ));
    UuidCreate( &fmtidAnsi );

    //
    // Attempt to create an ANSI prop storage
    //
    Check(S_OK, pPropSetStg->Create( fmtidAnsi, &CLSID_NULL,
                                     PROPSETFLAG_ANSI,
                                     STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     &pPropStg ));

    //
    // Clean up before exiting.
    //

    if (pPropStg)
    {
        pPropStg->Release();
        pPropStg = NULL;
    }

    if (pPropSetStg)
    {
        pPropSetStg->Release();
        pPropSetStg = NULL;
    }
}


void
test_UnsupportedProperties( IStorage *pStg )
{
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    CPropVariant rgcpropvarWrite[2], cpropvarRead;
    CPropSpec    rgcpropspec[2];

    // We can't run this test for STGFMT_FILE because ModifyPropertyType
    // incompatible with CFlatStorage.
    if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
        return;

    Status( "Unsupported VarTypes\n" );

    FMTID fmtid;
    UuidCreate(&fmtid);

    // Start by creating a property set with a couple of properties in it.

    Check( S_OK, StgToPropSetStg( pStg, &pPropSetStg ));
    Check( S_OK, pPropSetStg->Create( fmtid, NULL,
                                      PROPSETFLAG_DEFAULT | PROPSETFLAG_CASE_SENSITIVE,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    rgcpropvarWrite[0] = (long) 1234; // VT_I4
    rgcpropvarWrite[1] = (short) 56;  // VT_I2
    rgcpropspec[0] = PID_FIRST_USABLE;
    rgcpropspec[1] = PID_FIRST_USABLE + 1;

    Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    // Modify the first property so that it has an invalid VT

    RELEASE_INTERFACE( pPropStg );
    ModifyPropertyType( pStg, fmtid, rgcpropspec[0].propid, 0x500 );

    // Try to read that property back (the one with the invalid VT)

    Check( S_OK, pPropSetStg->Open( fmtid, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pPropStg ));
    Check( HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED),
           pPropStg->ReadMultiple( 1, &rgcpropspec[0], &cpropvarRead ));

    // Verify that we can read back the other property

    Check( S_OK, pPropStg->ReadMultiple( 1, &rgcpropspec[1], &cpropvarRead ));
    Check( TRUE, cpropvarRead == rgcpropvarWrite[1] );

    // And verify that we can't write a property with an invalid VT

    rgcpropvarWrite[0].vt = 0x500;
    Check( HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED),
           pPropStg->WriteMultiple( 1, &rgcpropspec[0], &rgcpropvarWrite[0], PID_FIRST_USABLE ));

    RELEASE_INTERFACE( pPropStg );
    RELEASE_INTERFACE( pPropSetStg );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\pstgserv\pch.cxx ===
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <windows.h>
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\pstgserv\pstgserv.cxx ===
#include "pch.cxx"
#include <stdio.h>
#include <ole2.h>
#include <pstgserv.hxx>


HWND            CPropertyStorageServerApp::m_hwnd;
DWORD           CPropertyStorageServerApp::m_dwReg;
CClassFactory  *CPropertyStorageServerApp::m_pClassFactory;
CHAR            CPropertyStorageServerApp::m_szAppName[80];
HINSTANCE       CPropertyStorageServerApp::m_hInstance;
int             CPropertyStorageServerApp::m_nCmdShow;
BOOL            CPropertyStorageServerApp::m_fCloseOnFinalRelease;

EXTERN_C const IID IID_IPropertyStorageServerApp= {0xaf4ae0d1,0xa37f,0x11cf,{0x8d,0x73,0x00,0xaa,0x00,0x4c,0xd0,0x1a}};

__declspec(dllexport)
LONG_PTR FAR PASCAL
CPropertyStorageServerApp::WndProc (HWND hwnd, UINT message,
                                    WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_USER :

            if( m_fCloseOnFinalRelease )
                PostMessage( hwnd, WM_CLOSE, 0, 0 );
            break;

        case WM_CLOSE :

            DestroyWindow( hwnd );
            break;

        case WM_DESTROY :

            CoUninitialize();
            CoRevokeClassObject( m_dwReg );
            delete m_pClassFactory;

            PostQuitMessage (0) ;
            return 0 ;
    }

    return (long) DefWindowProc (hwnd, message, wParam, lParam) ;
}



BOOL
CPropertyStorageServerApp::Init( HANDLE hInstance, HANDLE hPrevInstance,
                                 LPSTR lpszCmdLine, int nCmdShow )
{
    WNDCLASSA wndclass;

    if( strcmp( lpszCmdLine, "/Embedding" )
        &&
        strcmp( lpszCmdLine, "-Embedding" ))
    {
        m_fCloseOnFinalRelease = FALSE;
    }

    sprintf( m_szAppName, "IPropertyStorage Server" );
    m_hInstance = (HINSTANCE) hInstance;
    m_nCmdShow = nCmdShow;

    if( !hPrevInstance )
    {
        wndclass.style          = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc    = CPropertyStorageServerApp::WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = m_hInstance;
        wndclass.hIcon          = LoadIconA( m_hInstance, m_szAppName );
        wndclass.hCursor        = LoadCursorA( NULL, MAKEINTRESOURCEA(32512) ); // IDC_ARROW
        wndclass.hbrBackground  = (HBRUSH) GetStockObject( WHITE_BRUSH );
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = m_szAppName;

        RegisterClassA( &wndclass );
    }

    return( TRUE ); // Successful
}


#ifdef CreateWindowA
#undef CreateWindow
#endif

WORD
CPropertyStorageServerApp::Run( void )
{
    MSG msg;
    HRESULT hr;
    CHAR szErrorMessage[80];

    msg.wParam = 0;

    m_hwnd = CreateWindowA( m_szAppName,
                           "IPropertyStorage Server",
                           WS_OVERLAPPEDWINDOW,
                           CW_USEDEFAULT, CW_USEDEFAULT,
                           CW_USEDEFAULT, CW_USEDEFAULT,
                           NULL, NULL, m_hInstance, NULL );
    if( NULL == m_hwnd )
    {
        sprintf( szErrorMessage, "Failed CreateWindowA (%lu)", GetLastError() );
        goto Exit;
    }

    ShowWindow( m_hwnd, SW_MINIMIZE );
    UpdateWindow( m_hwnd );

    if( FAILED( hr = CoInitialize( NULL )))
    {
        sprintf( szErrorMessage, "Failed CoInitialize (%08x)", hr );
        goto Exit;
    }

    m_pClassFactory = (CClassFactory*) new CClassFactory( m_hwnd );
    if( m_pClassFactory == NULL )
    {
        hr = E_OUTOFMEMORY;
        sprintf( szErrorMessage, "Couldn't create CClassFactory" );
        goto Exit;
    }

    if( FAILED( hr = CoRegisterClassObject( IID_IPropertyStorageServerApp,
                                            m_pClassFactory,
                                            CLSCTX_LOCAL_SERVER,
                                            REGCLS_MULTIPLEUSE,
                                            &m_dwReg )))
    {
        sprintf( szErrorMessage, "Couldn't register class object" );
        goto Exit;
    }

    while( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

Exit:

    return( (WORD) msg.wParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\pstgserv\pssclass.cxx ===
#include "pch.cxx"
#include <windows.h>
#include <ole2.h>

#include "PStgServ.h"
#include "PStgServ.hxx"
#include "global.hxx"  // PropTest global information

const IID IID_IPropertyStorageServer = {0xaf4ae0d0,0xa37f,0x11cf,{0x8d,0x73,0x00,0xaa,0x00,0x4c,0xd0,0x1a}};
const IID IID_IPropertyStorageServer2= {0xaf4ae0d0,0xa37f,0x11cf,{0x8d,0x73,0x00,0xaa,0x00,0x4c,0xd0,0x1b}};

EnumImplementation g_enumImplementation;
DWORD g_Restrictions;

HINSTANCE g_hinstDLL = NULL;

FNSTGCREATEPROPSTG *g_pfnStgCreatePropStg = NULL;
FNSTGOPENPROPSTG *g_pfnStgOpenPropStg = NULL;
FNSTGCREATEPROPSETSTG *g_pfnStgCreatePropSetStg = NULL;
FNFMTIDTOPROPSTGNAME *g_pfnFmtIdToPropStgName = NULL;
FNPROPSTGNAMETOFMTID *g_pfnPropStgNameToFmtId = NULL;
FNPROPVARIANTCLEAR *g_pfnPropVariantClear = NULL;
FNPROPVARIANTCOPY *g_pfnPropVariantCopy = NULL;
FNFREEPROPVARIANTARRAY *g_pfnFreePropVariantArray = NULL;


STDMETHODIMP
CClassFactory::QueryInterface( REFIID riid, void **ppvObject )
{
    IUnknown *pUnk = NULL;

    if( riid == IID_IUnknown
        ||
        riid == IID_IClassFactory
      )
    {
        pUnk = this;
    }

    if( pUnk != NULL )
    {
        pUnk->AddRef();
        *ppvObject = pUnk;
        return S_OK;
    }

    *ppvObject = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CClassFactory::AddRef( void )
{
    return( ++m_cRefs );
}


STDMETHODIMP_(ULONG)
CClassFactory::Release( void )
{
    m_cRefs--;

    if( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}


STDMETHODIMP
CClassFactory::CreateInstance( IUnknown *pUnkOuter,
                               REFIID riid,
                               void **ppvObject )
{
    CPropertyStorageServer *pObj = NULL;

    if( pUnkOuter != NULL )
    {
        return( CLASS_E_NOAGGREGATION );
    }

    pObj = new CPropertyStorageServer( this );
    if( pObj == NULL )
    {
        return( E_OUTOFMEMORY );
    }

    return pObj->QueryInterface( riid, ppvObject );
}


STDMETHODIMP
CClassFactory::LockServer( BOOL fLock )
{
    if( fLock )
    {
        m_cLocks++;
    }
    else
    {
        m_cLocks--;
    }

    if( m_cLocks == 0 )
    {
        PostMessage( m_hWnd, WM_USER, 0, 0 );
    }

    return S_OK;
}


STDMETHODIMP
CPropertyStorageServer::QueryInterface( REFIID riid, void **ppvObject )
{
    *ppvObject = NULL;
    IUnknown *pUnk = NULL;

    if( riid == IID_IUnknown
        ||
        riid == IID_IPropertyStorageServer
      )
    {
        pUnk = this;
    }

    if( pUnk != NULL )
    {
        pUnk->AddRef();
        *ppvObject = pUnk;
        return S_OK;
    }

    *ppvObject = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CPropertyStorageServer::AddRef( void )
{
    return( ++m_cRefs );
}


STDMETHODIMP_(ULONG)
CPropertyStorageServer::Release( void )
{
    if( --m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}


STDMETHODIMP
CPropertyStorageServer::StgOpenPropStg( const OLECHAR *pwcsName,
                                        REFFMTID fmtid,
                                        DWORD grfMode,
                                        IPropertyStorage **pppstg )
{
    HRESULT hr;
    IPropertySetStorage *ppsstg = NULL;

    if( m_pstg )
    {
        m_pstg->Release();
        m_pstg = NULL;
    }

    hr = ::StgOpenStorageEx (
            pwcsName,
            grfMode,
            DetermineStgFmt( g_enumImplementation ),
            0,
            NULL,
            NULL,
            PROPIMP_NTFS == g_enumImplementation ? IID_IFlatStorage : IID_IStorage,
            (void**) &m_pstg );
    if( FAILED(hr) ) goto Exit;

    hr = m_pstg->QueryInterface( IID_IPropertySetStorage, (void**) &ppsstg );
    if( FAILED(hr) ) goto Exit;

    hr = ppsstg->Open( fmtid, grfMode, pppstg );
    if( FAILED(hr) ) goto Exit;

Exit:

    if( FAILED(hr)
        &&
        m_pstg != NULL )
    {
        m_pstg->Release();
        m_pstg = NULL;
    }

    if( ppsstg ) ppsstg->Release();

    return( hr );
}

STDMETHODIMP
CPropertyStorageServer::StgOpenPropSetStg(
                                     const OLECHAR *pwcsName,
                                     DWORD grfMode,
                                     IPropertySetStorage **pppsstg )
{
    HRESULT hr;

    if( m_pstg )
    {
        m_pstg->Release();
        m_pstg = NULL;
    }

    hr = ::StgOpenStorageEx (
            pwcsName,
            grfMode,
            DetermineStgFmt( g_enumImplementation ),
            0,
            NULL,
            NULL,
            PROPIMP_NTFS == g_enumImplementation ? IID_IFlatStorage : IID_IStorage,
            (void**) &m_pstg );
    if( FAILED(hr) ) goto Exit;

    hr = m_pstg->QueryInterface( IID_IPropertySetStorage, (void**) pppsstg );
    if( FAILED(hr) ) goto Exit;

Exit:

    if( FAILED(hr)
        &&
        m_pstg != NULL )
    {
        m_pstg->Release();
        m_pstg = NULL;
    }

    return( hr );
}

STDMETHODIMP
CPropertyStorageServer::MarshalUnknown( IUnknown *punk )
{
    punk->AddRef();
    punk->Release();

    return( S_OK );
}

STDMETHODIMP
CPropertyStorageServer::Initialize( EnumImplementation enumImplementation,
                                    ULONG Restrictions )
{
    HRESULT hr;

    g_enumImplementation = enumImplementation;
    g_Restrictions = Restrictions;


    if( PROPIMP_DOCFILE_IPROP == g_enumImplementation )
    {
        // We're to use the propset APIs from IProp

        g_hinstDLL = LoadLibraryA( "iprop.dll" );
    }
    else
    {
        // We're to use the propset APIs from OLE32

        g_hinstDLL = LoadLibraryA( "ole32.dll" );
    }

    if( NULL == g_hinstDLL )
    {
        hr = ERROR_MOD_NOT_FOUND;
        goto Exit;
    }

    // Get pointers to the functions that we always use
    // (e.g., PropVariantCopy, but not StgCreatePropSetStg)

    hr = ERROR_PROC_NOT_FOUND;

    g_pfnPropVariantCopy = (FNPROPVARIANTCOPY*)
                           GetProcAddress( g_hinstDLL,
                                           "PropVariantCopy" );
    if( NULL == g_pfnPropVariantCopy ) goto Exit;

    g_pfnPropVariantClear = (FNPROPVARIANTCLEAR*)
                            GetProcAddress( g_hinstDLL,
                                            "PropVariantClear" );
    if( NULL == g_pfnPropVariantClear ) goto Exit;

    g_pfnFreePropVariantArray = (FNFREEPROPVARIANTARRAY*)
                                GetProcAddress( g_hinstDLL,
                                                "FreePropVariantArray" );
    if( NULL == g_pfnFreePropVariantArray ) goto Exit;

    g_pfnStgCreatePropSetStg = (FNSTGCREATEPROPSETSTG*)
                               GetProcAddress( g_hinstDLL,
                                               "StgCreatePropSetStg" );
    if( NULL == g_pfnStgCreatePropSetStg ) goto Exit;

    g_pfnStgCreatePropStg = (FNSTGCREATEPROPSTG*)
                            GetProcAddress( g_hinstDLL,
                                            "StgCreatePropStg" );
    if( NULL == g_pfnStgCreatePropStg ) goto Exit;

    g_pfnStgOpenPropStg = (FNSTGOPENPROPSTG*)
                          GetProcAddress( g_hinstDLL,
                                          "StgOpenPropStg" );
    if( NULL == g_pfnStgOpenPropStg ) goto Exit;

    g_pfnFmtIdToPropStgName = (FNFMTIDTOPROPSTGNAME*)
                              GetProcAddress( g_hinstDLL,
                                              "FmtIdToPropStgName" );
    if( NULL == g_pfnFmtIdToPropStgName ) goto Exit;

    g_pfnPropStgNameToFmtId = (FNPROPSTGNAMETOFMTID*)
                              GetProcAddress( g_hinstDLL,
                                              "PropStgNameToFmtId" );
    if( NULL == g_pfnPropStgNameToFmtId ) goto Exit;


    
    hr = S_OK;

Exit:

    return( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\pstgserv\main.cxx ===
#include "pch.cxx"

#include <ole2.h>
#include <stdio.h>
#include <tchar.h>
#include <pstgserv.hxx>

CPropertyStorageServerApp cPropStgServerApp;


const TCHAR tszCLSIDInterface[]    = "{af4ae0d0-a37f-11cf-8d73-00aa004cd01a}";
const TCHAR tszCLSIDApp[]          = "{af4ae0d1-a37f-11cf-8d73-00aa004cd01a}";


void
SelfRegistration( HINSTANCE hinst )
{
    LONG lRet;
    DWORD dwDisposition;

    HKEY hkeyBase = NULL;
    HKEY hkey = NULL;

    LPTSTR tszError = NULL;

    LPTSTR tszServerName = TEXT("PropTest Local Server");
    LPTSTR tszProxyStubName = TEXT("PropTest Local Server Proxy/Stub");
    TCHAR  tszModulePathAndName[ MAX_PATH + 1 ];
    TCHAR  tszKeyName[ MAX_PATH + 1 ];
    LPTSTR tszNumMethods = TEXT("5");


    //  ----------------------------------------
    //  Update the CLSID key for the application
    //  ----------------------------------------

    // Open HKEY_CLASSES_ROOT\CLSID\{af4ae0d1-...1a}

    _tcscpy( tszKeyName, TEXT("CLSID\\") );
    _tcscat( tszKeyName, tszCLSIDApp );

    lRet = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                          tszKeyName,
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkeyBase,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create primary CLSID key");
        goto Exit;
    }

    // Write a name for this CLSID

    lRet = RegSetValueEx( hkeyBase,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszServerName,
                          _tcslen(tszServerName) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set local server name");
        goto Exit;
    }

    // Get this program's path and name

    if( !GetModuleFileName( hinst, tszModulePathAndName,
                            sizeof(tszModulePathAndName)/sizeof(TCHAR) ))
    {
        tszError = TEXT("Couldn't get Module file name");
        goto Exit;
    }

    // Set the LocalServer32 value

    lRet = RegCreateKeyEx(hkeyBase,
                          TEXT("LocalServer32"),
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkey,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create LocalServer32 key");
        goto Exit;
    }


    lRet = RegSetValueEx( hkey,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszModulePathAndName,
                          (1 + _tcslen(tszModulePathAndName) ) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set local server name");
        goto Exit;
    }

    CloseHandle( hkey );
    hkey = NULL;

    CloseHandle( hkeyBase );
    hkeyBase = NULL;


    //  ---------------------------------------
    //  Update the CLSID key for the proxy/stub
    //  ---------------------------------------

    // Set the InProcServer32 value (the proxy/stub)
    // We assume that the proxy/stub has the same name as this
    // local server (except with a dll extension), and we assume
    // that it's in the same path.  We really should have a
    // DllRegisterServer function in the DLL itself that does this,
    // but we do it here instead to save some code.

    _tcscpy( &tszModulePathAndName[ _tcslen(tszModulePathAndName) - 3 ],
             TEXT("dll") );

    _tcscpy( tszKeyName, TEXT("CLSID\\") );
    _tcscat( tszKeyName, tszCLSIDInterface );

    lRet = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                          tszKeyName,
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkeyBase,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create proxy/stub CLSID key");
        goto Exit;
    }

    // Write a name for this CLSID

    lRet = RegSetValueEx( hkeyBase,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszProxyStubName,
                          _tcslen(tszProxyStubName) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set proxy/stub name");
        goto Exit;
    }

    // Set the InproxServer32 value

    lRet = RegCreateKeyEx(hkeyBase,
                          TEXT("InprocServer32"),
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkey,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create InprocServer32 key");
        goto Exit;
    }


    lRet = RegSetValueEx( hkey,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszModulePathAndName,
                          (1 + _tcslen(tszModulePathAndName) ) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set proxy/stub value");
        goto Exit;
    }

    CloseHandle( hkey );
    hkey = NULL;

    CloseHandle( hkeyBase );
    hkeyBase = NULL;

    //  ------------------------
    //  Update the Interface key
    //  ------------------------

    // Open HKEY_CLASSES_ROOT\Interface\{af4ae0d0-...1a}

    _tcscpy( tszKeyName, TEXT("Interface\\") );
    _tcscat( tszKeyName, tszCLSIDInterface );

    lRet = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                          tszKeyName,
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkeyBase,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create interface key");
        goto Exit;
    }



    // Write a name for this IID

    lRet = RegSetValueEx( hkeyBase,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszServerName,
                          _tcslen(tszServerName) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set local server name");
        goto Exit;
    }


    // Set the NumMethods value

    lRet = RegCreateKeyEx(hkeyBase,
                          TEXT("NumMethods"),
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkey,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create NumMethods key");
        goto Exit;
    }

    lRet = RegSetValueEx( hkey,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszNumMethods,
                          (1 + _tcslen(tszNumMethods) ) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set number of methods");
        goto Exit;
    }

    CloseHandle( hkey );
    hkey = NULL;
                        
    // Set the Proxy/Stub CLSID

    lRet = RegCreateKeyEx(hkeyBase,
                          TEXT("ProxyStubClsid32"),
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkey,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create ProxyStubClsid32 key");
        goto Exit;
    }

    lRet = RegSetValueEx( hkey,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszCLSIDInterface,
                          (1 + _tcslen(tszCLSIDInterface) ) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set ProxyStubClsid32");
        goto Exit;
    }

    CloseHandle( hkey );
    hkey = NULL;

    CloseHandle( hkeyBase );
    hkeyBase = NULL;


    //  ----
    //  Exit
    //  ----

Exit:

    if( ERROR_SUCCESS != lRet )
    {
        TCHAR tszErrorMessage[ 256 ];
        _tcscpy( tszErrorMessage, tszError );
        _stprintf( &tszErrorMessage[ _tcslen(tszErrorMessage) ],
                   TEXT("\nError = %lu"), 
                   GetLastError() );
        
        MessageBox( NULL, tszErrorMessage, TEXT("PStgServ (PropTest) Self-Registration Error"), MB_OK );

        if( hkey ) CloseHandle( hkey );
        if( hkeyBase ) CloseHandle( hkeyBase );
    }


    return;

}



int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		    LPSTR lpszCmdLine, int nCmdShow )
{

    if( !strcmp( lpszCmdLine, "/RegServer" )
        ||
        !strcmp( lpszCmdLine, "-RegServer" ))
    {
        SelfRegistration( hInstance );
    }
    else if( cPropStgServerApp.Init(hInstance, hPrevInstance,
                                    lpszCmdLine, nCmdShow) )
    {
        return( cPropStgServerApp.Run() );
    }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\pstgserv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BStrMarshalServer.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_BSTRMARSHALSERVER_DIALOG    102
#define IDR_MAINFRAME                   128
#define IDC_STRING                      1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\pstgserv\proxstub\dllmain.cxx ===
#include <windows.h>

HANDLE g_hInst = NULL;

BOOL   WINAPI   DllMain (HANDLE hInst, 
                        ULONG ul_reason_for_call,
                        LPVOID lpReserved)
{
   g_hInst = hInst;
   return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\pstgserv\proxstub\daytona\makefile.inc ===
############################################################################
#
#   Copyright (C) 1996-1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

MIDL = midl.exe

MIDL_FLAGS= \
 -Zp8 \
 -I$(INCLUDES) \
 -Oi \
 -oldnames \
 -char unsigned \
 -error allocation \
 -error bounds_check \
 -error stub_data \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP) \
 -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES)

SSWITCH=-prefix sstub _

obj\pstgserv.h: ..\pstgserv.idl
     $(MIDL) $(MIDL_FLAGS) -header obj\pstgserv.h ..\pstgserv.idl


DEST_TREE=daytona

allidl:   obj\pstgserv.h

clean:
          -erase obj\pstgserv.h      >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\ascii.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ascii.cxx
//
//  Contents:   char to WCHAR conversion layer
//
//  Notes:      Most of the functions that provide the conversions are
//              here. Note that is layer will not be present for _UNICODE
//              builds 
//
//---------------------------------------------------------------

#ifndef _UNICODE // If UNICODE is defined, none of this is necessary

#include "exphead.cxx"

#include "expdf.hxx"
#include "expiter.hxx"
#include "expst.hxx"
#include "ascii.hxx"

extern "C" {
#include <string.h>
};

//+--------------------------------------------------------------
//
//  Function:   ValidateSNBA, private
//
//  Synopsis:   Validates a char SNB
//
//  Arguments:  [snb] - SNB
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

static SCODE ValidateSNBA(SNB snb)
{
    SCODE sc;
    
    for (;;)
    {
        olChk(ValidatePtrBuffer(snb));
        if (*snb == NULL)
            break;
        olChk(ValidateNameA(*snb, CBMAXPATHCOMPLEN));
        snb++;
    }
    return S_OK;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   SNBToSNBW, private
//
//  Synopsis:   Converts a char SNB to a WCHAR SNB
//
//  Arguments:  [snbIn] - char SNB
//
//  Returns:    WCHAR SNB or NULL
//
//---------------------------------------------------------------

static SNBW SNBToSNBW(SNB snbIn)
{
    ULONG cbStrings = 0;
    SNB snb;
    ULONG cItems = 0;
    SNBW snbw, snbwOut;
    WCHAR *pwcs;
    BYTE *pb;
    
    for (snb = snbIn; *snb; snb++, cItems++)
        cbStrings += (strlen(*snb)+1)*sizeof(WCHAR);
    cItems++;
    pb = new BYTE[(size_t)(cbStrings+sizeof(WCHAR *)*cItems)];
    if (pb == NULL)
        return NULL;
    snbwOut = (SNBW)pb;
    pwcs = (WCHAR *)(pb+sizeof(WCHAR *)*cItems);
    for (snb = snbIn, snbw = snbwOut; *snb; snb++, snbw++)
    {
        *snbw = pwcs;
        _tbstowcs(*snbw, *snb, strlen(*snb)+1);
        pwcs += wcslen(*snbw)+1;
    }
    *snbw = NULL;
    return snbwOut;
}

//+--------------------------------------------------------------
//
//  Function:   CheckAName, public
//
//  Synopsis:   Checks name for illegal characters and length
//
//  Arguments:  [pwcsName] - Name
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------
const char INVALIDCHARS[] = "\\/:!";

SCODE CheckAName(char const *pwcsName)
{
    SCODE sc;
    olDebugOut((DEB_ITRACE, "In  CheckAName(%s)\n", pwcsName));
    if (FAILED(sc = ValidateNameA(pwcsName, CBMAXPATHCOMPLEN)))
        return sc;
    // >= is used because the max len includes the null terminator
    if (strlen(pwcsName) >= CWCMAXPATHCOMPLEN)
        return STG_E_INVALIDNAME;
    for (; *pwcsName; pwcsName++)
        if (strchr(INVALIDCHARS, (int)*pwcsName))
        return STG_E_INVALIDNAME;
    olDebugOut((DEB_ITRACE, "Out CheckAName\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Next, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedIterator::Next(ULONG celt,
                                    STATSTG FAR *rgelt,
                                    ULONG *pceltFetched)
{
    SCODE sc;
    ULONG i;
    ULONG cnt;
    
    olAssert(sizeof(STATSTG) == sizeof(STATSTGW));
    
    olChk(sc = Next(celt, (STATSTGW *)rgelt, &cnt));
    for (i = 0; i<cnt; i++)
        if (rgelt[i].pwcsName)
        _wcstotbs(rgelt[i].pwcsName, (WCHAR *)rgelt[i].pwcsName,
        CWCSTORAGENAME);
    if (pceltFetched)
        *pceltFetched = cnt;
EH_Err:
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Stat, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;
    
    olAssert(sizeof(STATSTG) == sizeof(STATSTGW));
    
    olChk(sc = Stat((STATSTGW *)pstatstg, grfStatFlag));
    if (pstatstg->pwcsName)
        _wcstotbs(pstatstg->pwcsName, (WCHAR *)pstatstg->pwcsName,
        CWCSTORAGENAME);
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Stat, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;    
    olAssert(sizeof(STATSTG) == sizeof(STATSTGW));
    
    // call the virtual (wide char) function
    olChk(sc = this->Stat((STATSTGW *)pstatstg, grfStatFlag));

    if (pstatstg->pwcsName)
        _wcstotbs(pstatstg->pwcsName, (WCHAR *)pstatstg->pwcsName,
        _MAX_PATH);
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateStream, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::CreateStream(char const *pszName,
                                           DWORD grfMode,
                                           DWORD reserved1,
                                           DWORD reserved2,
                                           IStream **ppstm)
{
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    
    olChk(CheckAName(pszName));
    _tbstowcs(wcsName, pszName, CWCSTORAGENAME);
    sc = CreateStream(wcsName, grfMode, reserved1, reserved2, ppstm);
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenStream, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::OpenStream(char const *pszName,
                                         void *reserved1,
                                         DWORD grfMode,
                                         DWORD reserved2,
                                         IStream **ppstm)
{
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    
    olChk(CheckAName(pszName));
    _tbstowcs(wcsName, pszName, CWCSTORAGENAME);
    sc = OpenStream(wcsName, reserved1, grfMode, reserved2, ppstm);
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateStorage, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::CreateStorage(char const *pszName,
                                            DWORD grfMode,
                                            DWORD reserved1,
                                            DWORD reserved2,
                                            IStorage **ppstg)
{
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    
    olChk(CheckAName(pszName));
    _tbstowcs(wcsName, pszName, CWCSTORAGENAME);
    sc = CreateStorage(wcsName, grfMode, reserved1, reserved2, ppstg);
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenStorage, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::OpenStorage(char const *pszName,
                                          IStorage *pstgPriority,
                                          DWORD grfMode,
                                          SNB snbExclude,
                                          DWORD reserved,
                                          IStorage **ppstg)
{
    SNBW snbw;
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    

    olChk(CheckAName(pszName));
    _tbstowcs(wcsName, pszName, CWCSTORAGENAME);
    if (snbExclude)
        olChk(STG_E_INVALIDFUNCTION);
    else
        snbw = NULL;
    sc = OpenStorage(wcsName, pstgPriority, grfMode, snbw,
        reserved, ppstg);
    delete snbw;
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::DestroyElement, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::DestroyElement(char const *pszName)
{
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    
    olChk(CheckAName(pszName));
    _tbstowcs(wcsName, pszName, CWCSTORAGENAME);
    sc = DestroyElement(wcsName);
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::RenameElement, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::RenameElement(char const *pszOldName,
                                            char const *pszNewName)
{
    SCODE sc;
    WCHAR wcsOldName[CWCSTORAGENAME], wcsNewName[CWCSTORAGENAME];
    
    olChk(CheckAName(pszOldName));
    olChk(CheckAName(pszNewName));
    _tbstowcs(wcsOldName, pszOldName, CWCSTORAGENAME);
    _tbstowcs(wcsNewName, pszNewName, CWCSTORAGENAME);
    sc = RenameElement(wcsOldName, wcsNewName);
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CopyTo, public
//
//  Synopsis:   ANSI version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::CopyTo(DWORD ciidExclude,
                                     IID const *rgiidExclude,
                                     SNB snbExclude,
                                     IStorage *pstgDest)
{
    SNBW snbw;
    SCODE sc;
    
    if (snbExclude)
    {
        olChk(ValidateSNBA(snbExclude));
        olMem(snbw = SNBToSNBW(snbExclude));
    }
    else
        snbw = NULL;
    sc = CopyTo(ciidExclude, rgiidExclude, snbw, pstgDest);
    delete snbw;
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::MoveElementTo, public
//
//  Synopsis:   ANSI version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::MoveElementTo(TCHAR const *lpszName,
                                            IStorage *pstgDest,
                                            TCHAR const *lpszNewName,
                                            DWORD grfFlags)
{ 
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    
    olChk(CheckAName(lpszName));
    _tbstowcs(wcsName, lpszName, CWCSTORAGENAME);
    sc = MoveElementTo(wcsName, pstgDest, lpszNewName, grfFlags);
    
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetElementTimes, public
//
//  Synopsis:   ANSI version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::SetElementTimes(TCHAR const *lpszName,
                                              FILETIME const *pctime,
                                              FILETIME const *patime,
                                              FILETIME const *pmtime)
{
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    
    olChk(CheckAName(lpszName));
    _tbstowcs(wcsName, lpszName, CWCSTORAGENAME);
    sc = SetElementTimes(wcsName, pctime, patime, pmtime);
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Function:   DfOpenStorageOnILockBytes, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

HRESULT DfOpenStorageOnILockBytes(ILockBytes *plkbyt,
                                 IStorage *pstgPriority,
                                 DWORD grfMode,
                                 SNB snbExclude,
                                 DWORD reserved,
                                 IStorage **ppstgOpen,
                                 CLSID *pcid)
{
    SNBW snbw;
    SCODE sc;
    
    olChk(ValidatePtrBuffer(ppstgOpen));
    *ppstgOpen = NULL;
    if (snbExclude)
    {
        olChk(ValidateSNBA(snbExclude));
        olMem(snbw = SNBToSNBW(snbExclude)); 
    }
    else
        snbw = NULL;

    sc = DfOpenStorageOnILockBytesW(plkbyt, pstgPriority, grfMode,
                                    snbw, reserved, ppstgOpen, pcid);
    delete snbw;
EH_Err:
    return ResultFromScode(sc);
}

#endif // ifndef _UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\chinst.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996
//
//  File:       chinst.cxx
//
//  Contents:   DocFile child instance management code
//
//---------------------------------------------------------------
 
#include "dfhead.cxx"
#include "h/chinst.hxx"
#include "h/revert.hxx"

// Permissions checked in the less-restrictive rule
#define TCANTSET DF_READ
#define DCANTSET (DF_READ | DF_WRITE)
#define CANTCLEAR (DF_DENYREAD | DF_DENYWRITE)

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::Add, private
//
//  Synopsis:   Registers an instance of a child
//
//  Arguments:  [prv] - Child
//
//---------------------------------------------------------------

void CChildInstanceList::Add(PRevertable *prv)
{
    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::Add(%p)\n", prv));
    prv->_prvNext = _prvHead;
    _prvHead = prv;
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::Add\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CChildInstanceList::FindByName, private
//
//  Synopsis:   Finds a child instance by name
//
//  Arguments:  [pdfn] - Name
//
//  Returns:    Pointer to instance or NULL
//
//----------------------------------------------------------------------------

PRevertable *CChildInstanceList::FindByName(CDfName const *pdfn)
{
    PRevertable *prv;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::FindByName:%p(%ws)\n",
                this, pdfn->GetBuffer()));
    for (prv = _prvHead; prv; prv = prv->_prvNext)
        if (prv->_dfn.IsEqual(pdfn))
            return prv;
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::FindByName\n"));
    return NULL;
}

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::DeleteByName, private
//
//  Synopsis:   Removes an instance from the instance list
//              and reverts it
//
//  Arguments:  [pdfn] - Name or NULL
//
//  Notes:      The entry does not have to exist
//              There can be multiple entries
//              If name is NULL, all entries match
//
//---------------------------------------------------------------

void CChildInstanceList::DeleteByName(CDfName const *pdfn)
{
    PRevertable **pprv;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::DeleteByName(%ws)\n",
                pdfn->GetBuffer()));
    for (pprv = &_prvHead; *pprv; )
        if (NULL == pdfn || (*pprv)->_dfn.IsEqual(pdfn))
        {
            (*pprv)->RevertFromAbove();
            *pprv = (*pprv)->_prvNext;
        }
        else
            pprv = &(*pprv)->_prvNext;
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::DeleteByName\n"));
}

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::RemoveRv, private
//
//  Synopsis:   Removes a specific instance from the instance list
//
//  Arguments:  [prv] - Instance
//
//  Notes:      The entry does not have to exist
//
//---------------------------------------------------------------

void CChildInstanceList::RemoveRv(PRevertable *prvRv)
{
    PRevertable **prv;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::RemoveRv(%p)\n", prvRv));
    for (prv = &_prvHead; *prv; prv = &(*prv)->_prvNext)
        if (*prv == prvRv)
        {
            *prv = (*prv)->_prvNext;
            break;
        }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::RemoveRv\n"));
}

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::IsDenied, private
//
//  Synopsis:   Checks the parent instantiation list for a previous
//              instance of the given child with DENY flags on
//              Also determines whether child mode flags are
//              less restrictive than the parent's
//
//  Arguments:  [pdfn] - Instance name
//              [dfCheck] - Access modes to check for denial
//              [dfAgainst] - Access modes to check against
//
//  Returns:    Appropriate status code
//
//  Notes:      The instance doesn't have to be in the list.
//              If it isn't, it's not denied
//
//---------------------------------------------------------------

SCODE CChildInstanceList::IsDenied(CDfName const *pdfn,
                                   DFLAGS const dfCheck,
                                   DFLAGS const dfAgainst)
{
    PRevertable *prv;
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::IsDenied("
                "%p, %lX, %lX)\n", pdfn, dfCheck, dfAgainst));

    olAssert(pdfn != NULL && aMsg("IsDenied, null name"));

    // Check to see if permissions are less restrictive than
    // parent permissions
    // This checks to see that a child isn't specifying
    // a permission that its parent doesn't
    // For example, giving read permission when the parent
    // doesn't
    if ((~dfAgainst & dfCheck & DCANTSET) 
        ||
        (dfAgainst & ~dfCheck & CANTCLEAR))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    // Check for DENY_*
    olAssert((DF_DENYALL >> DF_DENIALSHIFT) == DF_READWRITE);
    for (prv = _prvHead; prv != NULL; prv = prv->GetNext())
    {
        if (prv->_dfn.IsEqual(pdfn))
        {
            // Check for existing instance with DENY_* mode
            if ((((prv->GetDFlags() & DF_DENYALL) >> DF_DENIALSHIFT) &
                 dfCheck) != 0 ||
            // Check for instance with permission already given that
            // new instance wants to deny
                (((dfCheck & DF_DENYALL) >> DF_DENIALSHIFT) &
                 prv->GetDFlags()) != 0)
            {
                sc = STG_E_ACCESSDENIED;
                break;
            }
        }
    }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::IsDenied\n"));
    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::RenameChild, public
//
//  Synopsis:   Renames the child
//
//  Arguments:  [pdfn] - old name
//              [pdfnName] - new name
//
//  Notes:      The entry might exist
//
//---------------------------------------------------------------

void CChildInstanceList::RenameChild(
        CDfName const *pdfn,
        CDfName const *pdfnNewName)
{
    PRevertable *prv;

    olDebugOut((DEB_ITRACE, "In CChildInstanceList::RenameChild(%p, %p)\n",
                pdfn, pdfnNewName));
    for (prv = _prvHead; prv; prv = prv->_prvNext)
    {
        if (prv->_dfn.IsEqual(pdfn))
        {
            prv->_dfn.Set(pdfnNewName->GetLength(), pdfnNewName->GetBuffer());
            break;
        }
    }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::RenameChild\n"));
}

#ifdef NEWPROPS
//+---------------------------------------------------------------------------
//
//  Member:     CChildInstanceList::FlushBufferedData, private
//
//  Synopsis:   Calls each child, instructing it to flush property data.
//
//  Returns:    SCODE
//
//----------------------------------------------------------------------------

SCODE CChildInstanceList::FlushBufferedData(void)
{
    PRevertable *prv;
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::FlushBufferedData:%p\n",
                this));

    for (prv = _prvHead; prv && sc == S_OK; prv = prv->_prvNext)
    {
        sc = prv->FlushBufferedData();
    }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::FlushBufferedData\n"));
    return sc;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\dfhead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       dfhead.cxx
//
//  Contents:   Precompiled headers
//
//--------------------------------------------------------------------------
#ifdef _MSC_VER
// some of these functions are a nuisance 
#pragma warning (disable:4127)  // conditional expression is constant
#pragma warning (disable:4514)  // unreferenced inline function
#endif

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "h/ole.hxx"
#include "h/ref.hxx"
#include "h/msf.hxx"

#include "h/dfexcept.hxx"
#include "h/cdocfile.hxx"
#include "expdf.hxx"
#include "h/docfilep.hxx"
#include "h/dffuncs.hxx"
#include "h/funcs.hxx"
#include "h/piter.hxx"
#include "h/sstream.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\dffuncs.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996
//
//  File:       dffuncs.cxx
//
//  Contents:   Private support functions for the DocFile code
//
//  Methods:    CopyTo 
//              DeleteContents
//
//---------------------------------------------------------------

#include "dfhead.cxx"


#include "iter.hxx"
#include "h/sstream.hxx"



//+--------------------------------------------------------------
//
//  Method:     CDocFile::DeleteContents, public
//
//  Synopsis:   Deletes all entries in a DocFile recursing on entries
//              with children
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CDocFile::DeleteContents(void)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::DeleteContents()\n"));
    sc = _stgh.DestroyEntry(NULL);
    olDebugOut((DEB_ITRACE, "Out CDocFile::DeleteContents\n"));
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CDocFile::CopyTo, public
//
//  Synopsis:   Copies the contents of one DocFile to another
//
//  Arguments:  [pdfTo] - Destination DocFile
//              [dwFlags] - Control flags
//              [snbExclude] - Partial instantiation list
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


SCODE CDocFile::CopyTo(CDocFile *pdfTo,
                       DWORD dwFlags,
                       SNBW snbExclude)
{
    PDocFileIterator *pdfi;
    SIterBuffer ib;
    CDirectStream *pstFrom = NULL, *pstTo = NULL;
    CDocFile *pdfFromChild = NULL, *pdfToChild = NULL;
    DFLUID dlLUID = DF_NOLUID;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::CopyTo:%p(%p, %lX, %p)\n", this,
               pdfTo, dwFlags, snbExclude));
    olChk(GetIterator(&pdfi));
    for (;;)
    {
        if (FAILED(pdfi->BufferGetNext(&ib)))
            break;

        switch(REAL_STGTY(ib.type))
        {
        case STGTY_STORAGE:
            // Embedded DocFile, create destination and recurse

            olChkTo(EH_pwcsName, GetDocFile(&ib.dfnName, DF_READ, ib.type,
                                            &pdfFromChild));
            // Destination must be a direct docfile
            olChkTo(EH_Reserve, pdfTo->CreateDocFile(&ib.dfnName, DF_WRITE,
                                                     dlLUID, ib.type,
                                                     &pdfToChild));
            if (dwFlags & CDF_EXACT)
                pdfToChild->CopyTimesFrom(pdfFromChild);

            CLSID clsid;
            olChkTo(EH_Create, pdfFromChild->GetClass(&clsid));
            olChkTo(EH_Create, pdfToChild->SetClass(clsid));

            DWORD grfStateBits;
            olChkTo(EH_Create, pdfFromChild->GetStateBits(&grfStateBits));
            olChkTo(EH_Create, pdfToChild->SetStateBits(grfStateBits,
                                                        0xffffffff));


            if ((dwFlags & CDF_ENTRIESONLY) == 0 &&
                !(snbExclude && NameInSNB(&ib.dfnName, snbExclude) ==
                  S_OK))
                olChkTo(EH_Create,
                        pdfFromChild->CopyTo(pdfToChild, dwFlags, NULL));

            pdfFromChild->Release();
            pdfToChild->Release();
            break;

        case STGTY_STREAM:
            olChkTo(EH_pwcsName, GetStream(&ib.dfnName, DF_READ,
                                           ib.type, &pstFrom));
            // Destination must be a direct docfile
            olChkTo(EH_Reserve,
                    pdfTo->CreateStream(&ib.dfnName, DF_WRITE, 
                                        dlLUID, &pstTo));
            if (dwFlags & CDF_EXACT)
                pstTo->CopyTimesFrom(pstFrom);

            if ((dwFlags & CDF_ENTRIESONLY) == 0 &&
                !(snbExclude && 
                  NameInSNB(&ib.dfnName, snbExclude) == S_OK))
                olChkTo(EH_Create, CopyStreamToStream(
                    pstFrom, pstTo));

            pstFrom->Release();
            pstTo->Release();
            break;

        default:
            olAssert(!aMsg("Unknown entry type in CDocFile::CopyTo"));
            break;
        }
    }
    pdfi->Release();
    olDebugOut((DEB_ITRACE, "Out CDocFile::CopyTo\n"));
    return S_OK;

 EH_Create:
    if (REAL_STGTY(ib.type))
        pdfToChild->Release();
    else
        pstTo->Release();
    olAssert(&ib.dfnName);
    olVerSucc(pdfTo->DestroyEntry(&ib.dfnName, TRUE));
    goto EH_Get;
 EH_Reserve:
 EH_Get:
    if (REAL_STGTY(ib.type))
        pdfFromChild->Release();
    else
        pstFrom->Release();
 EH_pwcsName:
    pdfi->Release();
 EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\cdocfile.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996.
//
//  File:       cdocfile.cxx
//
//  Contents:   Implementation of CDocFile methods for DocFiles
//
//---------------------------------------------------------------

#include "dfhead.cxx"

#include "h/vectfunc.hxx"

//+--------------------------------------------------------------
//
//  Member:     PEntry::_dlBase, static private data
//
//  Synopsis:   luid allocation base
//
//  Notes:      Since DF_NOLUID is 0 and ROOT_LUID is 1 we start
//              issuing at 2.
//
//---------------------------------------------------------------

DFLUID PEntry::_dlBase = LUID_BASE;

//+--------------------------------------------------------------
//
//  Member:     CDocFile::InitFromEntry, public
//
//  Synopsis:   Creation/Instantiation constructor for embeddings
//
//  Arguments:  [pstghParent] - Parent handle
//              [pdfn] - Name
//              [fCreate] - Create/Instantiate
//              [dwType] - Type of entry
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


SCODE CDocFile::InitFromEntry(CStgHandle *pstghParent,
                              CDfName const *pdfn,
                              BOOL const fCreate)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::InitFromEntry(%p, %ws, %d)\n",
                pstghParent, pdfn, fCreate));
    if (fCreate)
        sc = pstghParent->CreateEntry(pdfn, STGTY_STORAGE, &_stgh);
    else
        sc = pstghParent->GetEntry(pdfn, STGTY_STORAGE, &_stgh);
    if (SUCCEEDED(sc))
        AddRef();
    olDebugOut((DEB_ITRACE, "Out CDocFile::InitFromEntry\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::CreateDocFile, public
//
//  Synopsis:   Creates a DocFile object in a parent
//
//  Arguments:  [pdfn] - Name of DocFile
//              [df] - Transactioning flags
//              [dlSet] - LUID to set or DF_NOLUID
//              [dwType] - Type of entry
//              [ppdfDocFile] - DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//---------------------------------------------------------------


SCODE CDocFile::CreateDocFile(CDfName const *pdfn,
                              DFLAGS const df,
                              DFLUID dlSet,
                              CDocFile **ppdfDocFile)
{
    CDocFile *pdf;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::CreateDocFile:%p("
                "%ws, %X, %lu, %p)\n", this, pdfn, df, dlSet,
                ppdfDocFile));
    UNREFERENCED_PARM(df);

    if (dlSet == DF_NOLUID)
        dlSet = CDocFile::GetNewLuid();

    olMem(pdf = new CDocFile(dlSet, _pilbBase));

    olChkTo(EH_pdf, pdf->InitFromEntry(&_stgh, pdfn, TRUE));

    *ppdfDocFile = pdf;
    olDebugOut((DEB_ITRACE, "Out CDocFile::CreateDocFile => %p\n",
                SAFE_DREF(ppdfDocFile)));
    return S_OK;

EH_pdf:
    delete pdf;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::GetDocFile, public
//
//  Synopsis:   Instantiates an existing docfile
//
//  Arguments:  [pdfn] - Name of stream
//              [df] - Transactioning flags
//              [dwType] - Type of entry
//              [ppdfDocFile] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//---------------------------------------------------------------


SCODE CDocFile::GetDocFile(CDfName const *pdfn,
                           DFLAGS const df,
                           CDocFile **ppdfDocFile)
{
    CDocFile *pdf;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::GetDocFile:%p("
                "%ws, %X, %p)\n", this, pdfn, df, ppdfDocFile));
    UNREFERENCED_PARM(df);

    DFLUID dl = CDocFile::GetNewLuid();
    olMem(pdf = new CDocFile(dl, _pilbBase));

    olChkTo(EH_pdf, pdf->InitFromEntry(&_stgh, pdfn, FALSE));
    *ppdfDocFile = pdf;
    olDebugOut((DEB_ITRACE, "Out CDocFile::GetDocFile => %p\n",
                *ppdfDocFile));
    return S_OK;

EH_pdf:
    delete pdf;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::Release, public
//
//  Synopsis:   Release resources for a DocFile
//
//---------------------------------------------------------------


void CDocFile::Release(void)
{
    olDebugOut((DEB_ITRACE, "In  CDocFile::Release()\n"));
    olAssert(_cReferences > 0);

    AtomicDec(&_cReferences);
    if (_cReferences == 0)
        delete this;
    olDebugOut((DEB_ITRACE, "Out CDocFile::Release\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::RenameEntry, public
//
//  Synopsis:   Renames a child
//
//  Arguments:  [pdfnName] - Old name
//              [pdfnNewName] - New name
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


SCODE CDocFile::RenameEntry(CDfName const *pdfnName,
                            CDfName const *pdfnNewName)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::RenameEntry(%ws, %ws)\n",
                pdfnName, pdfnNewName));
    sc = _stgh.RenameEntry(pdfnName, pdfnNewName);
    olDebugOut((DEB_ITRACE, "Out CDocFile::RenameEntry\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::DestroyEntry, public
//
//  Synopsis:   Permanently destroys a child
//
//  Arguments:  [pdfnName] - Name of child
//              [fClean] - Ignored
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


SCODE CDocFile::DestroyEntry(CDfName const *pdfnName,
                             BOOL fClean)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::DestroyEntry:%p(%ws, %d)\n",
                this, pdfnName, fClean));
    UNREFERENCED_PARM(fClean);
    sc = _stgh.DestroyEntry(pdfnName);
    olDebugOut((DEB_ITRACE, "Out CDocFile::DestroyEntry\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::IsEntry, public
//
//  Synopsis:   Determines whether the given object is a member
//              of the DocFile
//
//  Arguments:  [pdfnName] - Name
//              [peb] - Entry buffer to fill in
//
//  Returns:    Appropriate status code
//
//  Modifies:   [peb]
//
//---------------------------------------------------------------


SCODE CDocFile::IsEntry(CDfName const *pdfnName,
                        SEntryBuffer *peb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::IsEntry(%ws, %p)\n",
                pdfnName, peb));
    sc = _stgh.IsEntry(pdfnName, peb);
    olDebugOut((DEB_ITRACE, "Out CDocFile::IsEntry => %lu, %lu, %lu\n",
                sc, peb->luid, peb->dwType));
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CDocFile::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//---------------------------------------------------------------

void CDocFile::AddRef(void)
{
    olDebugOut((DEB_ITRACE, "In  CDocFile::AddRef()\n"));
    AtomicInc(&_cReferences);
    olDebugOut((DEB_ITRACE, "Out CDocFile::AddRef, %lu\n", _cReferences));
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::GetTime, public
//
//  Synopsis:   Gets a time
//
//  Arguments:  [wt] - Which time
//              [ptm] - Time return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ptm]
//
//---------------------------------------------------------------

SCODE CDocFile::GetTime(WHICHTIME wt, TIME_T *ptm)
{
    return _stgh.GetTime(wt, ptm);
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::SetTime, public
//
//  Synopsis:   Sets a time
//
//  Arguments:  [wt] - Which time
//              [tm] - New time
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CDocFile::SetTime(WHICHTIME wt, TIME_T tm)
{
    return _stgh.SetTime(wt, tm);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::GetClass, public
//
//  Synopsis:   Gets the class ID
//
//  Arguments:  [pclsid] - Class ID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pclsid]
//
//----------------------------------------------------------------------------

SCODE CDocFile::GetClass(CLSID *pclsid)
{
    return _stgh.GetClass(pclsid);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::SetClass, public
//
//  Synopsis:   Sets the class ID
//
//  Arguments:  [clsid] - New class ID
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------

SCODE CDocFile::SetClass(REFCLSID clsid)
{
    return _stgh.SetClass(clsid);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::GetStateBits, public
//
//  Synopsis:   Gets the state bits
//
//  Arguments:  [pgrfStateBits] - State bits return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pgrfStateBits]
//
//----------------------------------------------------------------------------

SCODE CDocFile::GetStateBits(DWORD *pgrfStateBits)
{
    return _stgh.GetStateBits(pgrfStateBits);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::SetStateBits, public
//
//  Synopsis:   Sets the state bits
//
//  Arguments:  [grfStateBits] - Bits to set
//              [grfMask] - Mask
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------

SCODE CDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    return _stgh.SetStateBits(grfStateBits, grfMask);
}

//+---------------------------------------------------------------------------
//
//  Member:	CDocFile::FindGreaterEntry, public (virtual)
//
//  Synopsis:	Returns the next greater child
//
//  Arguments:	[pdfnKey]  - Previous key
//              [pNextKey] - The found key
//              [pstat]    - Full iterator buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:	[pstat]    - if it is not null
//              [pNextKey] - if it is not null
//
//----------------------------------------------------------------------------

SCODE CDocFile::FindGreaterEntry(CDfName const *pdfnKey,
                                 CDfName *pNextKey,
                                 STATSTGW *pstat)
{
    SID sid, sidChild;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::FindGreaterEntry:%p(%p, %p, %p)\n",
               this, pdfnKey, pNextKey, pstat));
    if (SUCCEEDED(sc = _stgh.GetMS()->GetChild(_stgh.GetSid(), &sidChild)))
    {
        if (sidChild == NOSTREAM)   
            sc = STG_E_NOMOREFILES;
        else if (SUCCEEDED(sc = _stgh.GetMS()->
                           FindGreaterEntry(sidChild, pdfnKey, &sid)))
        {
                sc = _stgh.GetMS()->StatEntry(sid, pNextKey, pstat);
        }
    }
    olDebugOut((DEB_ITRACE, "Out CDocFile::FindGreaterEntry\n"));
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CDocFile::ExcludeEntries, public
//
//  Synopsis:   Excludes the given entries
//
//  Arguments:  [snbExclude] - Entries to exclude
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CDocFile::ExcludeEntries(CDocFile *pdf, SNBW snbExclude)
{
    PDocFileIterator *pdfi;
    CDirectStream *pstChild = NULL;
    CDocFile *pdfChild = NULL;
    SCODE sc;
    SIterBuffer ib;

    olDebugOut((DEB_ITRACE, "In  PDocFile::ExcludeEntries(%p)\n",
                snbExclude));
    olChk(pdf->GetIterator(&pdfi));
    for (;;)
    {
        if (FAILED(pdfi->BufferGetNext(&ib)))
            break;
        if (NameInSNB(&ib.dfnName, snbExclude) == S_OK)
        {
            switch(REAL_STGTY(ib.type))
            {
            case STGTY_STORAGE:
                olChkTo(EH_pwcsName, pdf->GetDocFile(&ib.dfnName, DF_READ |
                                                     DF_WRITE, ib.type,
                                                     &pdfChild));
                olChkTo(EH_Get, pdfChild->DeleteContents());
                pdfChild->Release();
                break;
            case STGTY_STREAM:
                olChkTo(EH_pwcsName, pdf->GetStream(&ib.dfnName, DF_WRITE,
                                                    ib.type, &pstChild));
                olChkTo(EH_Get, pstChild->SetSize(0));
                pstChild->Release();
                break;
            }
        }
    }
    pdfi->Release();
    olDebugOut((DEB_ITRACE, "Out ExcludeEntries\n"));
    return S_OK;

EH_Get:
    if (REAL_STGTY(ib.type))
        pdfChild->Release();
    else
        pstChild->Release();
EH_pwcsName:
    pdfi->Release();
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\dfiter.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996.
//
//  File:       dfiter.cxx
//
//  Contents:   Implementations of CDocFile iterator methods
//
//---------------------------------------------------------------

#include "dfhead.cxx"


#include "h/msfiter.hxx"
#include "iter.hxx"



//+--------------------------------------------------------------
//
//  Member:     CDocFile::GetIterator, public
//
//  Synopsis:   Gets a new iterator
//
//  Arguments:  [ppdfi] - Iterator object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfi]
//
//---------------------------------------------------------------

SCODE CDocFile::GetIterator(PDocFileIterator **ppdfi)
{
    CDocFileIterator *pdfi;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::GetIterator(%p)\n", ppdfi));
    olMem(pdfi = new CDocFileIterator);
    olChkTo(EH_pdfi, pdfi->Init(&_stgh));
    *ppdfi = pdfi;
    olDebugOut((DEB_ITRACE, "Out CDocFile::GetIterator => %p\n", *ppdfi));
    return S_OK;

EH_pdfi:
    delete pdfi;
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\difat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       difat.cxx
//
//  Contents:   Double Indirected Fat Code
//
//  Classes:    None.
//
//  Functions:
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/difat.hxx"
#include "mread.hxx"


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::CDIFat, public
//
//  Synopsis:   CDIFat constructor
//
//  Arguments:  [cbSector] -- size of a sector
//
//--------------------------------------------------------------------------

CDIFat::CDIFat(USHORT cbSector)
:   _pmsParent(NULL),
    _fv( SIDDIF,
         (FSOFFSET) (cbSector / sizeof(SECT)),
         (FSOFFSET) ((cbSector / sizeof(SECT)) - 1) )
{
    msfDebugOut((DEB_TRACE,"In CDIFat constructor\n"));
    _cfsTable = 0;
    msfDebugOut((DEB_TRACE,"Out CDIFat constructor\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:	CDIFat::Empty, public
//
//  Synopsis:	Empty all the control structures of this instance
//
//  Arguments:	None.
//
//  Returns:	void.
//
//----------------------------------------------------------------------------

void CDIFat::Empty(void)
{
    _fv.Empty();
    _pmsParent = NULL;
    _cfsTable = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CIDFat::Flush, private
//
//  Synopsis:   Flush a sector to disk
//
//  Arguments:  none
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Write sector up to parent mstream.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::Flush(void)
{
    return _fv.Flush();
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::GetFatSect, public
//
//  Synopsis:   Given an offset into the Fat chain, return the sector
//              value for that FatSect.
//
//  Arguments:  [oSect] -- offset in Fat chain
//              [psect]  -- pointer to returned sector
//
//  Modifies:   [*psect]
//
//  Returns:    Sector value of FatSect.
//
//  Algorithm:  If sector is stored in the header, retrieve it from
//                  there.
//              If not, retrieve it from the FatVector.
//
//--------------------------------------------------------------------------

SCODE CDIFat::GetFatSect(const FSINDEX oSect, SECT *psect)
{
    SCODE sc = S_OK;
    SECT sectReturn;

    msfDebugOut((DEB_TRACE,"In CDIFat::GetFatSect(%lu)\n",oSect));
    if (oSect < CSECTFAT)
    {
        msfDebugOut((DEB_ITRACE,"Getting sect from header\n"));
        sectReturn = _pmsParent->GetHeader()->GetFatSect(oSect);
    }
    else
    {
        FSINDEX ipfs;
        FSOFFSET isect;

        SectToPair(oSect,&ipfs,&isect);

        msfAssert(ipfs < _cfsTable);

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
        sectReturn = pfs->GetSect(isect);
        _fv.ReleaseTable(ipfs);
    }

    msfDebugOut((DEB_TRACE,"Out CDIFat::GetFatSect(%lu)=>%lu\n",oSect,sectReturn));
    *psect = sectReturn;

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::SetFatSect, public
//
//  Synopsis:   Given an offset into the Fat chain, set the sector
//              value.
//
//  Arguments:  [oSect] -- Offset into fat chain
//              [sect] -- New sector value for that offset.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  If the sector is stored in the header, set it and
//                  flush the header.
//              Otherwise, if the sector will not fit in the current
//                  CFatVector, resize it.
//              Set the sector in the FatVector and flush it.
//
//--------------------------------------------------------------------------

SCODE CDIFat::SetFatSect(const FSINDEX oSect, const SECT sect)
{
    msfDebugOut((DEB_TRACE,"In CDIFat::SetFatSect(%lu,%lu)\n",oSect,sect));
    SCODE sc = S_OK;

    if (oSect < CSECTFAT)
    {
        msfDebugOut((DEB_ITRACE,"Setting sect in header: %lu, %lu\n",oSect,sect));
        _pmsParent->GetHeader()->SetFatSect(oSect, sect);
    }
    else
    {
        FSINDEX ipfs;
        FSOFFSET isect;

        SectToPair(oSect,&ipfs,&isect);
        if (ipfs >= _cfsTable)
        {
            msfChk(Resize(_cfsTable + 1));
        }

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_DIRTY, &pfs));

        pfs->SetSect(isect, sect);
        _fv.ReleaseTable(ipfs);
        
        msfDebugOut((DEB_TRACE,"In CDIFat::SetFatSect(%lu,%lu)\n",oSect,sect));
    }

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::GetSect, public
//
//  Synopsis:   Given an offset into the DIFat chain, return the
//              sector value
//
//  Arguments:  [oSect] -- Offset into DIFat chain.
//              [psect] -- pointer to returned sector
//
//  Modifies:   [*psect]
//
//  Returns:    Sector value for given offset.
//
//  Algorithm:  Retrieve the information from the NextFat fields of
//                  the CFatVector
//
//--------------------------------------------------------------------------

SCODE CDIFat::GetSect(const FSINDEX oSect, SECT *psect)
{
    SCODE sc = S_OK;

    SECT sectReturn;

    msfDebugOut((DEB_TRACE,"In CDIFat::GetSect(%lu)\n",oSect));
    msfAssert(oSect < _cfsTable);

    if (oSect == 0)
    {
        sectReturn = _pmsParent->GetHeader()->GetDifStart();
    }
    else
    {
        CFatSect *pfs;
        msfChk(_fv.GetTable(oSect - 1, FB_NONE, &pfs));

        sectReturn = pfs->GetNextFat(_fv.GetSectTable());
        _fv.ReleaseTable(oSect - 1);
    }

    msfDebugOut((DEB_TRACE,"Out CDIFat::GetSect(%lu)=>%lu\n",oSect,sectReturn));
    *psect = sectReturn;

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::Init, public
//
//  Synopsis:   Init function for previously stored DIFat.
//
//  Arguments:  [pmsParent] -- pointer to stream parent
//              [cFatSect] -- Length of DIFat in sectors
//
//  Returns:    S_OK if call completed properly.
//
//  Algorithm:  Initialize all the variables
//
//--------------------------------------------------------------------------

SCODE CDIFat::Init(CMStream * pmsParent, const FSINDEX cFatSect)
{
    msfDebugOut((DEB_TRACE,"In CDIFat::Init(%lu)\n",cFatSect));
    SCODE sc;

    _pmsParent = pmsParent;
    
    msfChk(_fv.Init(_pmsParent, cFatSect));

    _cfsTable = cFatSect;

    msfDebugOut((DEB_TRACE,"Out CDIFat::Init(%lu)\n",cFatSect));

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::InitConvert, public
//
//  Synopsis:   Init function for conversion
//
//  Arguments:  [pmsParent] -- pointer to stream parent
//              [sectMax] -- Last used sector in existing file  
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  See below
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::InitConvert(CMStream *pmsParent, SECT sectMax)
{
    msfDebugOut((DEB_TRACE,"In CDIFat::InitConvert(%lu)\n",sectMax));
    SCODE sc;

    _pmsParent = pmsParent;

    USHORT cbSector = _pmsParent->GetSectorSize();
    FSOFFSET csectPer = (FSOFFSET) (cbSector / sizeof(SECT));

    FSINDEX csectFat = 0;
    FSINDEX csectFatLast;
    
    FSINDEX csectDif = 0;
    FSINDEX csectDifLast;
    do
    {
        //Number of fat sectors needed to represent:
        //    Number of Data Sectors (sectMax) +
        //    Number of Fat Sectors (csectFat) +
        //    Number of DIF sectors (csectDif) +
        //    Number of Directory Sectors (1)

        //We must use a loop here, since the fat must be large
        //    enough to represent itself and the DIFat.  See
        //    CFat::InitConvert for a more lengthy discussion of
        //    this method.

        csectFatLast = csectFat;
        
        csectFat = (sectMax + csectFatLast + csectDif + 1 + csectPer - 1) /
            csectPer;
        
        csectDifLast = csectDif;

        if (csectFat < CSECTFAT)
        {
            csectDif = 0;
        }
        else
        {
            FSOFFSET ciSect;

            SectToPair(csectFat, &csectDif, &ciSect);
            csectDif++;
        }
    }
    while ((csectDif != csectDifLast) || (csectFat != csectFatLast));

    
    _cfsTable = csectDif;
    
    msfChk(_fv.Init(_pmsParent, _cfsTable));

    _pmsParent->GetHeader()->SetDifLength(_cfsTable);

    if (_cfsTable > 0)
    {
        _pmsParent->GetHeader()->SetDifStart(sectMax);

        FSINDEX i;
        for (i = 0; i < _cfsTable; i++)
        {
            CFatSect *pfs;

            msfChk(_fv.GetTable(i, FB_NEW, &pfs));
            _fv.SetSect(i, sectMax);
            
            sectMax++;
            pfs->SetNextFat(_fv.GetSectTable(),sectMax);
            _fv.ReleaseTable(i);
        }
    }

    msfDebugOut((DEB_TRACE,"Out CDIFat::InitConvert()\n"));

Err:
    return sc;
}





//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::Resize, private
//
//  Synopsis:   Resize an existing DIFat.
//
//  Arguments:  [fsiSize] -- New size for object
//
//  Returns:    S_OK if success
//
//  Algorithm:  
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::Resize(FSINDEX fsiSize)
{
    msfDebugOut((DEB_TRACE,"In CDIFat::Resize(%lu)\n",fsiSize));
    msfAssert(fsiSize == _cfsTable + 1);

    SCODE sc;

    msfChk(_fv.Resize(fsiSize));
    ULONG ipfs;
    ipfs = fsiSize - 1;

    CFatSect *pfs;
    msfChk(_fv.GetTable(ipfs, FB_NEW, &pfs));

    FSINDEX csect;
    csect = _cfsTable;
    _cfsTable = fsiSize;

    SECT sectNew;

    msfChk(_pmsParent->GetFat()->GetFree(1, &sectNew));
    msfChk(_pmsParent->GetFat()->SetNext(sectNew, DIFSECT));           
    
    _fv.SetSect(ipfs, sectNew);
    _fv.ReleaseTable(ipfs);

    if (csect == 0)
    {
        _pmsParent->GetHeader()->SetDifStart(sectNew);
    }
    else
    {
        CFatSect *pfs;
        msfChk(_fv.GetTable(csect - 1, FB_DIRTY, &pfs));

        pfs->SetNextFat(_fv.GetSectTable(),sectNew);
        _fv.ReleaseTable(csect - 1);
    }

    _pmsParent->GetHeader()->SetDifLength(_cfsTable);
    
    msfDebugOut((DEB_TRACE,"Out CDIFat::Resize(%lu)\n",fsiSize));

Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\dir.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996.
//
//  File:       dir.cxx
//
//  Contents:   Directory Functions
//
//---------------------------------------------------------------

#include "msfhead.cxx"


#include "h/dirfunc.hxx"
#include "mread.hxx"

#define DEB_DIR (DEB_ITRACE | 0x00040000)

//+-------------------------------------------------------------------------
//
//  Member:     CMStream::KillStream, public
//
//  Synopsis:   Eliminate a given chain
//
//  Arguments:  [sectStart] -- Beginning of chain to eliminate
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  
//
//  Notes:
//
//--------------------------------------------------------------------------

inline SCODE CMStream::KillStream(SECT sectStart, ULONGLONG ulSize)
{
    CFat *pfat;

    pfat = (ulSize < MINISTREAMSIZE) ?&_fatMini: &_fat;

    return pfat->SetChainLength(sectStart, 0);
}


//+-------------------------------------------------------------------------
//
//  Member:     GetNewDirEntryArray, public
//
//  Synopsis:   Obtain a new array of CDirEntry(s)
//
//  Arguments:  [cbSector] -- size of a sector
//
//  Returns:    New CDirEntry array
//
//  Algorithm:  calculates the number of entries need for the array and
//              allocate it
//
//  Notes:
//
//--------------------------------------------------------------------------

inline CDirEntry* GetNewDirEntryArray(USHORT cbSector)
{
    CDirEntry *temp;

    DIROFFSET cdeEntries = (USHORT) (cbSector / sizeof(CDirEntry));

    temp = new CDirEntry[cdeEntries];
    return temp;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirEntry::Init, public
//
//  Synopsis:   Initializes member data
//
//  Arguments:  [mse] -- multi-stream entry flags for the directory entry
//
//  Returns:    void
//
//  Algorithm:  
//
//  Notes:
//
//--------------------------------------------------------------------------

inline void CDirEntry::Init(MSENTRYFLAGS mse)
{
    msfAssert(sizeof(CDirEntry) == DIRENTRYSIZE);

    memset(this, 0, sizeof(CDirEntry));
    
    msfAssert(mse <= 0xff);
    _mse = (BYTE) mse;
    _bflags = 0;

    _dfn.Set((WORD)0, (BYTE *)NULL);
    _sidLeftSib = _sidRightSib = _sidChild = NOSTREAM;

    if (STORAGELIKE(_mse))
    {
        _clsId = IID_NULL;
        _dwUserFlags = 0;
    }
    if (STREAMLIKE(_mse))
    {
        _sectStart = ENDOFCHAIN;
        _ulSize = 0;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirEntry::CDirEntry, public
//
//  Synopsis:   Constructor for CDirEntry class
//
//  Effects:
//
//  Notes:
//
//--------------------------------------------------------------------------

CDirEntry::CDirEntry()
{
    msfAssert(sizeof(CDirEntry) == DIRENTRYSIZE);
    Init(STGTY_INVALID);
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirSect::Init, public
//
//  Synopsis:   Initializer for directory sectors
//
//  Arguments:  [cdeEntries] -- Number of DirEntries in the sector
//
//  Returns:    S_OK if call completed OK.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirSect::Init(USHORT cbSector)
{
    msfDebugOut((DEB_DIR,"Allocating sector with size %u\n",cbSector));

    DIROFFSET cdeEntries = (USHORT) (cbSector / sizeof(CDirEntry));

    for (ULONG i = 0; i < cdeEntries; i++)
    {
        _adeEntry[i].Init(STGTY_INVALID);
    }

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::CDirectory
//
//  Synopsis:   Default constructor
//
//  Notes:
//
//--------------------------------------------------------------------------

CDirectory::CDirectory(USHORT cbSector)
        : _pmsParent(NULL),
          _dv(cbSector)
{
    _cdsTable = _cdeEntries = 0;
    _sidFirstFree = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:	CDirectory::Empty, public
//
//  Synopsis:	Empty all the control structures of this instance
//
//  Arguments:	None.
//
//  Returns:	void.
//
//----------------------------------------------------------------------------

void CDirectory::Empty(void)
{
    _dv.Empty();
    _pmsParent = NULL;
    _cdsTable = 0;
    _cdeEntries = 0;
    _sidFirstFree = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::GetFree, public
//
//  Synposis:   Locates a free directory entry
//
//  Arguments:  [psid] Stream ID of free directory entry.
//
//  Returns:    S_OK if successful
//
//  Algorithm:  Do a linear search of all available directories.
//              If no free spot is found, resize the directory and
//              perform the search again.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::GetFree(SID* psid)
{
    msfDebugOut((DEB_DIR,"In CDirectory::GetFree()\n"));

    SCODE sc = S_OK;
    CDirSect * pds;

    DIRINDEX ipdsStart;
    DIROFFSET ideStart;

    SidToPair(_sidFirstFree, &ipdsStart, &ideStart);
    while (TRUE)
    {
	DIRINDEX ipds;
        for (ipds = ipdsStart; ipds < _cdsTable; ipds++)
        {
            msfChk(_dv.GetTable(ipds, FB_NONE, &pds));
            for (DIROFFSET ide = ideStart; ide < _cdeEntries; ide++)
            {
                if (pds->GetEntry(ide)->IsFree())
                {
                    msfDebugOut((DEB_ITRACE,"GetFree found sid %lu\n",
                            PairToSid(ipds,ide)));

                    *psid = PairToSid(ipds, ide);
                    _sidFirstFree = *psid + 1;
                    _dv.ReleaseTable(ipds);
                    return S_OK;
                }
            }
            _dv.ReleaseTable(ipds);
            ideStart = 0;
        }
        ipdsStart = ipds;
        msfChk(Resize(_cdsTable+1));
    }

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::FindGreaterEntry
//
//  Synopsis:   finds next entry (for iteration)
//
//  Arguments:  [sidStart]   -- child sid to start looking
//		[pdfn]       -- previous entry name
//		[psidResult] -- place holder for returned sid
//
//  Requires:   sidStart != NOSTREAM
//
//  Returns:    S_OK, STG_E_NOMOREFILES, or other error
//
//  Modifies:   psidResult
//
//  Algorithm:  Iterate by returning the sid that has a name larger
//		than the given name.
//
//  Notes:      This method is called recursively
//
//--------------------------------------------------------------------------

SCODE CDirectory::FindGreaterEntry(SID sidStart, CDfName const *pdfn, 
                                   SID *psidResult)
{
    SCODE sc;
    CDirEntry *pde;
    msfAssert(sidStart != NOSTREAM);

    msfChk(GetDirEntry(sidStart, FB_NONE, &pde));

    int iCmp;
    iCmp = NameCompare(pdfn, pde->GetName());

    if (iCmp < 0)
    {
        //  Since the last name returned is less than this name,
        //  the sid to return must either be to our left or this sid

        SID sidLeft = pde->GetLeftSib();

        //  We can't hold onto sidStart as we recurse, (because we'll ask for
        //  a page each time we recurse)

        ReleaseEntry(sidStart);
        if (sidLeft == sidStart)
        {
            //Corrupt docfile - return error.
            return STG_E_DOCFILECORRUPT;
        }

        if ((sidLeft == NOSTREAM) ||
            (sc = FindGreaterEntry(sidLeft, pdfn, psidResult)) == STG_E_NOMOREFILES)
        {
            //  There was no left child with a name greater than pdfn, so
            //  we return ourself

            *psidResult = sidStart;
            sc = S_OK;
        }
    }
    else
    {
        //  The last name returned is greater than this one, so we've already
        //  returned this sidStart.  Look in the right subtree.

        SID sidRight = pde->GetRightSib();

        //  We can't hold onto sidStart as we recurse, (because we'll ask for
        //  a page each time we recurse)

        ReleaseEntry(sidStart);

        if (sidRight == sidStart)
        {
            //Corrupt docfile - return error.
            return STG_E_DOCFILECORRUPT;
        }

        if (sidRight == NOSTREAM)
            sc = STG_E_NOMOREFILES;
        else
            sc = FindGreaterEntry(sidRight, pdfn, psidResult);
    }
Err:
    return(sc);
}



//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::SetStart, public
//
//  Synopsis:   Set starting sector for a dir entry
//
//  Arguments:  [sid] -- SID of entry to be modified
//              [sect] -- New starting sector for entry
//
//  Returns:    SID of modified entry
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirectory::SetStart(const SID sid, const SECT sect)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetStart(sect);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetChild, public
//
//  Synposis:   Set the child SID of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [sidChild] -- SID of first child of this stream
//
//  Returns:    SID of modified entry
//
//  Algorithm:  Change child field on entry, then write to stream.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetChild(const SID sid, const SID sidChild)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetChild(sidChild);
    ReleaseEntry(sid);

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetSize, public
//
//  Synposis:   Set the size of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [cbSize] -- Size
//
//  Returns:    SID of modified entry
//
//  Algorithm:  Change size field on entry, then write to stream.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetSize(const SID sid, const ULONGLONG cbSize)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetSize(cbSize);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetTime, public
//
//  Synposis:   Set the time of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [tt] - WT_*
//              [nt] - New time
//
//  Returns:    SID of modified entry
//
//  Algorithm:  Change time field on entry, then write to stream.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetTime(const SID sid, WHICHTIME tt, TIME_T nt)
{
    SCODE sc;

    CDirEntry *pde;

    // We don't support ACCESS times, so just ignore sets
    if (tt == WT_ACCESS)
        return S_OK;
    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetTime(tt, nt);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetFlags, public
//
//  Synposis:   Set the flags of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [mse] - New flags
//
//  Returns:    Status code
//
//  Algorithm:  Change Luid field on entry, then write to stream.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetFlags(const SID sid, const MSENTRYFLAGS mse)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetFlags(mse);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetClassId, public
//
//  Synposis:   Set the class ID of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [cls] - Class ID
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetClassId(const SID sid, const GUID cls)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetClassId(cls);
    ReleaseEntry(sid);
 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetUserFlags, public
//
//  Synposis:   Set the user flags of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [dwUserFlags] - Flags
//              [dwMask] - Mask
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetUserFlags(SID const sid,
                                        DWORD dwUserFlags,
                                        DWORD dwMask)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetUserFlags(dwUserFlags, dwMask);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::resize, private
//
//  Synposis:   Resize a directory.
//
//  Effects:    Reallocates space for directory table, copying over
//              old pointers as necessary.  Any new tables needed are
//              created here.
//
//  Arguments:  [uNewsize] -- New size for Directory
//
//  Returns:    void
//
//  Algorithm:  Allocate a new array of pointers of the necessary size.
//              Then, copy over all pointers from old array and allocate
//              new CDirSects for all new tables.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::Resize(DIRINDEX uNewsize)
{
    msfDebugOut((DEB_DIR,"In CDirectory::Resize(%i)\n",uNewsize));
    SCODE sc;

    if (uNewsize == _cdsTable) return S_OK;

    SECT sect;
    //GetESect call will make sure we have enough Fat space.
    msfChk(_pmsParent->GetESect(SIDDIR, uNewsize - 1, &sect));

        msfChk(_pmsParent->SetSize());

    msfChk(_dv.Resize(uNewsize));

    ULONG ipds;
    for (ipds = _cdsTable; ipds < uNewsize; ipds++)
    {
        CDirSect *pds;
        msfChk(_dv.GetTable(ipds, FB_NEW, &pds));
        
        SECT sect;
        msfChk(_pmsParent->GetESect(SIDDIR, ipds, &sect));
        _dv.SetSect(ipds, sect);
        _dv.ReleaseTable(ipds);
    }

    _cdsTable = uNewsize;
    msfChk(_pmsParent->GetHeader()->SetDirLength (_cdsTable));

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::Init, public
//
//  Synposis:   Sets up a Directory instance and reads in all tables
//              from the stream
//
//  Arguments:  [cSect] -- Number of sectors in directory
//
//  Returns:    S_OK if call completed OK.
//              STG_E_READFAULT if not enough bytes were read for
//                                  a DirSector
//              Error code of read if read returned an error.
//
//  Algorithm:  Create array to hold appropriate number of tables.
//              Read in each table from disk.
//
//---------------------------------------------------------------------------

SCODE CDirectory::Init(
        CMStream *pmsParent,
        DIRINDEX cSect)
{
    msfDebugOut((DEB_DIR,"In CDirectory::Init(%lu)\n",cSect));
    SCODE sc;

    _pmsParent = pmsParent;

    _cdeEntries = (DIROFFSET) 
        ( _pmsParent->GetSectorSize() / sizeof(CDirEntry));

    msfChk(_dv.Init(_pmsParent, cSect));

    _cdsTable = cSect;

    msfDebugOut((DEB_DIR,"Out CDirectory::Init()\n"));

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::InitNew, public
//
//  Synposis:   Sets up a new Directory instance for a new Mstream
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//              STG_E_WRITEFAULT if not enough bytes were written.
//              Error code of write if write failed.
//
//  Algorithm:  Write initial DirSector to disk.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::InitNew(CMStream *pmsParent)
{
    SCODE sc;
#ifndef _MSC_VER
    #define ROOT_ENTRY "Root Entry"
    WCHAR *wcsRoot = new WCHAR[sizeof(ROOT_ENTRY)+1];
    _tbstowcs(wcsRoot, ROOT_ENTRY, sizeof(ROOT_ENTRY));
    CDfName const dfnRoot(wcsRoot);
#else
    CDfName const dfnRoot(L"Root Entry");
#endif

    msfDebugOut((DEB_DIR,"In CDirectory::setupnew()\n"));
    _pmsParent = pmsParent;

    _cdeEntries = (DIROFFSET)
        (_pmsParent->GetSectorSize() / sizeof(CDirEntry));

    msfChk(_dv.Init(_pmsParent, 1));

    CDirSect *pds;

    msfChk(_dv.GetTable(0, FB_NEW, &pds));
    _dv.SetSect(0, _pmsParent->GetHeader()->GetDirStart());
    _dv.ReleaseTable(0);

    _cdsTable = 1;

    SID sidRoot;

    msfChk(GetFree(&sidRoot));
    CDirEntry *pdeTemp;

    msfChk(GetDirEntry(sidRoot, FB_DIRTY, &pdeTemp));
    pdeTemp->Init(STGTY_ROOT);

    msfAssert(sidRoot == SIDROOT);

    pdeTemp->SetName(&dfnRoot);

    ReleaseEntry(sidRoot);

    msfDebugOut((DEB_DIR,"Exiting CDirectory::setupnew()\n"));

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::CreateEntry, public
//
//  Synopsis:   Create a new directory entry
//
//  Arguments:  [sidParent] -- SID of parent for new entry
//		[pwcsName] -- Name of new entry
//		[mef] -- Flags for new entry
//		[psidNew] -- Return location for new SID
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Search directory for entry of the same name.  If one
//              is found, return STG_E_FILEALREADYEXISTS.
//              If not, create a new entry and return its SID.
//
//--------------------------------------------------------------------------


SCODE CDirectory::CreateEntry(
	SID sidParent,
	CDfName const *pdfn,
	MSENTRYFLAGS mef,
	SID *psidNew)
{
    SCODE sc;
    SID sidNew;
    CDirEntry *pdeNew;
    SEntryBuffer eb;

    sc = IsEntry(sidParent, pdfn, &eb);
    if (sc != STG_E_FILENOTFOUND)
    {
        if (SUCCEEDED(sc))
            sc = STG_E_FILEALREADYEXISTS;

        return(sc);
    }

    //  Allocate new sid

    msfChk(GetFree(psidNew));
    sidNew = *psidNew;

    msfChk(GetDirEntry(sidNew, FB_DIRTY, &pdeNew));

    //  Initialize new entry

    pdeNew->Init(mef);

    TIME_T timetemp;
    DfGetTOD(&timetemp);

    pdeNew->SetTime(WT_CREATION, timetemp);
    pdeNew->SetTime(WT_MODIFICATION, timetemp);
    pdeNew->SetName(pdfn);

    ReleaseEntry(sidNew);

    //  Insert new entry into the tree

    msfChk(InsertEntry(sidParent, sidNew, pdfn));

Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::RenameEntry, public
//
//  Synopsis:   Rename an entry
//
//  Arguments:  [sidParent] -- Sid of parent of entry to be renamed
//              [pwcsName] -- Old name of entry to be renamed
//              [pwcsName] -- New name
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Remove old entry
//		Rename entry
//		Insert as new entry
//
//  Notes:
//
//--------------------------------------------------------------------------


SCODE CDirectory::RenameEntry(SID const sidParent,
        CDfName const *pdfn,
        CDfName const *pdfnNew)
{
    //  Make sure new name doesn't already exist
    SCODE sc;
    SEntryBuffer eb;

    sc = IsEntry(sidParent, pdfnNew, &eb);
    if (sc != STG_E_FILENOTFOUND)
    {
        if (SUCCEEDED(sc))
        {
            //  Entry did exist - fail this call
            sc = STG_E_ACCESSDENIED;
        }

        return(sc);
    }

    //  We can't just rename in place (because the tree is ordered)

    CDirEntry *pdeRename;
    SEntryBuffer ebRename;

    msfChk(FindEntry(sidParent, pdfn, DEOP_REMOVE, &ebRename));

    sc = GetDirEntry(ebRename.sid, FB_DIRTY, &pdeRename);

    msfAssert(SUCCEEDED(sc) && aMsg("Could get dir entry to rename"));

    msfChk(sc);

    pdeRename->SetName(pdfnNew);

    ReleaseEntry(ebRename.sid);

    //  If this InsertEntry fails, we've potentially lost the entry. This
    //  doesn't matter becase:
    //  a)  The only way we could fail is if we couldn't read or write
    //      the disk (hard error)
    //  b)  No one's going to call RenameEntry anyways
    //  c)  If we're transacted, the whole operation is made robust by
    //      CopyOnWrite mode
    //  d)  If we're direct, we already know we can fail in ways that leave
    //      the Docfile corrupt.

    sc = InsertEntry(sidParent, ebRename.sid, pdfnNew);

    msfAssert(SUCCEEDED(sc) && aMsg("Couldn't reinsert renamed dir entry"));

    msfChk(sc);

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::DestroyAllChildren
//
//  Synopsis:   destroy all child entries
//
//  Effects:    destroys child tree
//
//  Arguments:  [sidParent] -- storage entry
//
//  Returns:    S_OK or error code
//
//  Modifies:   sidParent's entry
//
//  Algorithm:  While there's a child
//		  destroy it
//
//  Notes:	We may want to consider a more efficient implementation
//
//--------------------------------------------------------------------------


SCODE CDirectory::DestroyAllChildren(
	SID const sidParent)
{
    SCODE sc;
    CDirEntry *pdeParent, *pdeChild;
    SID sidChild;
    CDfName dfnChild;

    for (;;)
    {
        CDfName dfnChild;

        msfChk(GetDirEntry(sidParent, FB_NONE, &pdeParent));
        sidChild = pdeParent->GetChild();
        ReleaseEntry(sidParent);

        if (sidChild == NOSTREAM)
            break;

        msfChk(GetDirEntry(sidChild, FB_NONE, &pdeChild));

        dfnChild.Set(pdeChild->GetName());
        ReleaseEntry(sidChild);

        msfChk(DestroyChild(sidParent, &dfnChild));
    }

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::DestroyChild
//
//  Synopsis:   destroy a named child
//
//  Effects:    destroys named child's entry
//
//  Arguments:  [sidParent] -- storage entry
//		[pdfn]      -- child name
//
//  Returns:    S_OK, STG_E_FILENOTFOUND, or other error code
//
//  Modifies:   child's entry
//
//  Algorithm:  Find and remove child
//		Free child entry
//
//--------------------------------------------------------------------------

SCODE CDirectory::DestroyChild(
	SID const sidParent,
        CDfName const *pdfn)
{
    SCODE sc;
    SEntryBuffer ebChild;

    msfAssert(pdfn != NULL);

    //  remove the entry from the tree

    msfChk(FindEntry(sidParent, pdfn, DEOP_REMOVE, &ebChild));

    msfAssert(ebChild.sid != NOSTREAM);

    //  Before we remove this entry, we need to destroy it (including all
    //  its children).  Note that we can't hold onto the entry because it
    //  might have children which get destroyed, which have children which
    //  get destroyed, etc.

    if (STORAGELIKE(ebChild.dwType))
    {
        msfChk(DestroyAllChildren(ebChild.sid));
    }

    CDirEntry *pdeChild;
    msfChk(GetDirEntry(ebChild.sid, FB_DIRTY, &pdeChild));

    if (STREAMLIKE(ebChild.dwType))
    {
        //  Deallocate any used streams
        msfChkTo(EH_Rel, _pmsParent->KillStream(pdeChild->GetStart(),
				                pdeChild->GetSize(IsLargeSector())));
    }

    pdeChild->SetFlags(STGTY_INVALID);
    if (ebChild.sid < _sidFirstFree)
    {
        _sidFirstFree = ebChild.sid;
    }

EH_Rel:
    ReleaseEntry(ebChild.sid);

Err:
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::StatEntry
//
//  Synopsis:   For a given handle, fill in the Multistream specific
//                  information of a STATSTG.
//
//  Arguments:  [sid] -- SID that information is requested on.
//              [pName] -- name of the next key to fill in
//              [pstatstg] -- STATSTG to fill in.
//
//  Returns:    S_OK
//
//  Modifies:   [pName] -- if it is not null
//              [pstatstg] -- if it is not null
//
//  Algorithm:  Fill in time information and size and then return
//
//--------------------------------------------------------------------------


SCODE CDirectory::StatEntry(SID const sid, 
                                     CDfName *pName,
                                     STATSTGW *pstatstg)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_NONE, &pde));
    
    if (pName)
    {
        pName->Set(pde->GetName());
    }
    if (pstatstg)
    {        
        pstatstg->type = pde->GetFlags();
        // allocate memory
        msfChk(DfAllocWCS((WCHAR *)pde->GetName()->GetBuffer(),
                          &pstatstg->pwcsName)); 
        wcscpy(pstatstg->pwcsName, (WCHAR*) pde->GetName()->GetBuffer());

        pstatstg->mtime = pde->GetTime(WT_MODIFICATION);
        pstatstg->ctime = pde->GetTime(WT_CREATION);
        pstatstg->atime = pstatstg->mtime; // don't currently keep access times

        // Don't use REAL_STGTY here because we want this
        // to function properly for both property and non-property builds
        if ((pstatstg->type & STGTY_REAL) == STGTY_STORAGE)
        {
            pstatstg->cbSize.QuadPart = 0;
            pstatstg->clsid = pde->GetClassId();
            pstatstg->grfStateBits = pde->GetUserFlags();
        }
        else
        {
            pstatstg->cbSize.QuadPart = pde->GetSize(IsLargeSector());
            pstatstg->clsid = CLSID_NULL;
            pstatstg->grfStateBits = 0;
        }
    }

Err:
    ReleaseEntry(sid);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::GetDirEntry
//
//  Synopsis:   Get a directory entry with given permissions
//
//  Arguments:  [sid]     -- SID
//              [dwFlags] -- permissions
//              [ppde]    -- placeholder for directory entry
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//--------------------------------------------------------------------------


SCODE CDirectory::GetDirEntry(
	const SID sid,
	const DWORD dwFlags,
	CDirEntry **ppde)
{
    SCODE sc;
    CDirSect *pds;
    DIRINDEX id = sid / _cdeEntries;

    msfChk(_dv.GetTable(id, dwFlags, &pds));

    *ppde = pds->GetEntry((DIROFFSET)(sid % _cdeEntries));

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::ReleaseEntry
//
//  Synopsis:   Releases a directory entry
//
//  Arguments:  [sid]     -- SID
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//--------------------------------------------------------------------------

void CDirectory::ReleaseEntry(SID sid)
{
    _dv.ReleaseTable(sid / _cdeEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\dfstream.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996.
//
//  File:       dfstream.cxx
//
//  Contents:   Implementations of CDocFile stream methods
//
//---------------------------------------------------------------

#include "dfhead.cxx"
#include "h/sstream.hxx"

//+--------------------------------------------------------------
//
//  Method:     CDocFile::CreateStream, public
//
//  Synopsis:   Creates a named stream in a DocFile
//
//  Arguments:  [pwcsName] - Name of the stream
//              [df] - Transactioning flags
//              [dlSet] - LUID to set or DF_NOLUID
//              [ppstStream] - Pointer to storage for the stream pointer
//
//  Returns:    Appropriate error code
//
//  Modifies:   [ppstStream]
//
//---------------------------------------------------------------


SCODE CDocFile::CreateStream(CDfName const *pdfn,
                             DFLAGS const df,
                             DFLUID dlSet,
                             CDirectStream **ppstStream)
{
    SCODE sc;
    CDirectStream *pstm;

    olDebugOut((DEB_ITRACE, "In  CDocFile::CreateStream("
            "%ws, %X, %lu, %p)\n",
                pdfn, df, dlSet, ppstStream));
    UNREFERENCED_PARM(df);

    if (dlSet == DF_NOLUID)
        dlSet = CDirectStream::GetNewLuid();
    olMem(pstm = new CDirectStream(dlSet));    
    olChkTo(EH_pstm, pstm->Init(&_stgh, pdfn, TRUE));

    *ppstStream = pstm;
    olDebugOut((DEB_ITRACE, "Out CDocFile::CreateStream => %p\n",
                *ppstStream));
    return S_OK;

EH_pstm:
    delete pstm;
EH_Err:    
    return sc;
}

//+--------------------------------------------------------------
//
//  Method:     CDocFile::GetStream, public
//
//  Synopsis:   Retrieves an existing stream from a DocFile
//
//  Arguments:  [pwcsName] - Name of the stream
//              [df] - Transactioning flags
//              [dwType] - Type of entry
//              [ppstStream] - Pointer to storage for the stream pointer
//
//  Returns:    Appropriate error code
//
//  Modifies:   [ppstStream]
//
//---------------------------------------------------------------



SCODE CDocFile::GetStream(CDfName const *pdfn,
                          DFLAGS const df,
                          CDirectStream **ppstStream)
{
    SCODE sc;
    CDirectStream *pstm;

    olDebugOut((DEB_ITRACE, "In  CDocFile::GetStream(%ws, %X, %p)\n",
                pdfn, df, ppstStream));
    UNREFERENCED_PARM(df);

    DFLUID dl = CDirectStream::GetNewLuid();
    olMem(pstm = new CDirectStream(dl));
    
    olChkTo(EH_pstm, pstm->Init(&_stgh, pdfn, FALSE));
    *ppstStream = pstm;
    olDebugOut((DEB_ITRACE, "Out CDocFile::GetStream => %p\n",
                *ppstStream));
    return S_OK;

EH_pstm:
    delete pstm;
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\dirp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	DirP.CXX
//
//  Contents:	Private CDirectory child tree methods
//
//  Notes:
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/dirfunc.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::InsertEntry, private
//
//  Synopsis:   insert entry into child tree
//
//  Arguments:  [sidTree] -- storage entry in which to insert entry
//		[sidNew]  -- new entry
//		[pdfnNew] -- new entry name
//
//  Returns:	S_OK, STG_E_FILEALREADYEXISTS, or other error
//
//  Modifies:	sidParent's child tree
//
//  Algorithm:	Search down the binary tree to find the leaf node to which
//		to add the new entry (failing if we find the name already
//		exists).  Along the way we split nodes where needed to keep
//		the tree balanced.
//
//--------------------------------------------------------------------------

SCODE  CDirectory::InsertEntry(
	SID sidTree,
        SID sidNew,
        CDfName const *pdfnNew)
{
    SCODE sc;

    //  To insert the key and keep the tree balanced, we need to know
    //  the parent, grandparent, and greatgrandparent of the node we're
    //  inserting.

    SID sidChild, sidParent, sidGrandParent, sidGreatGrandParent;
    CDirEntry *pdeParent;
    int iCmp = 0;

    //  When we're ready to insert, sidParent will be the entry to which we
    //  attach sidNew

    sidParent = sidGrandParent = sidGreatGrandParent = sidTree;

    //  Begin the search with the root of the child tree

    msfChk(GetDirEntry(sidTree, FB_NONE, &pdeParent));
    sidChild = pdeParent->GetChild();

    //  Search down the child tree to find the correct leaf entry

    while (sidChild != NOSTREAM)
    {
        //  The sidParent entry has a child along the search path, so we
        //  move down the tree (letting go of sidParent and taking hold of
        //  its child)

        ReleaseEntry(sidParent);

        //  Check to see if we need to split this node (nothing is held)

        do
        {
            SID sidLeft, sidRight;
            BOOL fRed;

            {
                CDirEntry *pdeChild;

                msfChk(GetDirEntry(sidChild, FB_NONE, &pdeChild));

                msfAssert(((sidTree != sidParent) ||
                           (pdeChild->GetColor() == DE_BLACK)) &&
                           aMsg("Dir tree corrupt - root child not black!"));

                sidLeft = pdeChild->GetLeftSib();
                sidRight = pdeChild->GetRightSib();

                ReleaseEntry(sidChild);
            }

            if (sidLeft == NOSTREAM || sidRight == NOSTREAM)
                break;

	    {
                CDirEntry *pdeLeft;

                msfChk(GetDirEntry(sidLeft, FB_NONE, &pdeLeft));
                fRed = (pdeLeft->GetColor() == DE_RED);
                ReleaseEntry(sidLeft);
            }

            if (!fRed)
                break;

            {
                CDirEntry *pdeRight;

		msfChk(GetDirEntry(sidRight, FB_NONE, &pdeRight));
		fRed = (pdeRight->GetColor() == DE_RED);
		ReleaseEntry(sidRight);
            }

            if (fRed)
                msfChk(SplitEntry(pdfnNew, sidTree, sidGreatGrandParent,
			          sidGrandParent, sidParent, sidChild,
                                  &sidChild));
        }
        while (FALSE);

        //

        msfAssert(sidChild != NOSTREAM);

        //  Advance the search

        sidGreatGrandParent = sidGrandParent;
        sidGrandParent = sidParent;
        sidParent = sidChild;

        msfChk(GetDirEntry(sidParent, FB_NONE, &pdeParent));

        iCmp = NameCompare(pdfnNew, pdeParent->GetName());

        if (iCmp == 0)
        {
            //  The new name exactly matched an existing name.  Fail.
            msfChkTo(EH_RelParent, STG_E_FILEALREADYEXISTS);
        }

        //  Move down the tree, left or right depending on the comparison

        if (iCmp < 0)
            sidChild = pdeParent->GetLeftSib();
        else
            sidChild = pdeParent->GetRightSib();
    }

    msfAssert(sidChild == NOSTREAM);

    //  We've found the position to insert the new entry.

    //  We're going to dirty sidParent, so we need to change our holding flags
    ReleaseEntry(sidParent);
    msfChk(GetDirEntry(sidParent, FB_DIRTY, &pdeParent));

    if (sidParent == sidTree)
    {
        //  sidParent never made it past sidTree - we must be inserting the
        //  first child into sidTree

        msfAssert(pdeParent->GetChild() == NOSTREAM);

        //  The SplitInsert call below will make sidNew black.
        pdeParent->SetChild(sidNew);
    }
    else
    {
        msfAssert(iCmp != 0);

        //  Use the comparison to determine which side to insert the new entry

        if (iCmp < 0)
        {
            msfAssert(pdeParent->GetLeftSib() == NOSTREAM);
            msfAssert(NameCompare(pdfnNew, pdeParent->GetName()) < 0);

            pdeParent->SetLeftSib(sidNew);
        }
        else
        {
            msfAssert(pdeParent->GetRightSib() == NOSTREAM);
            msfAssert(NameCompare(pdfnNew, pdeParent->GetName()) > 0);

            pdeParent->SetRightSib(sidNew);
        }
    }

EH_RelParent:
    ReleaseEntry(sidParent);

    if (SUCCEEDED(sc))
    {
        SID sidTemp;
        sc = SplitEntry(pdfnNew, sidTree, sidGreatGrandParent, sidGrandParent,
		        sidParent, sidNew, &sidTemp);
    }
Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SplitEntry, private
//
//  Synopsis:   Split 4-node
//
//  Effects:    Passes up red link to parent
//
//  Arguments:  [pdfn]      -- search key
//		[sidTree]   -- child tree sid
//		[sidGreat]  -- greatgrandparent of child to split
//		[sidGrand]  -- grandparent of child to split
//		[sidParent] -- parent of child to split
//		[sidChild]  -- child to split
//		[psid]      -- place holder for tree position
//
//  Returns:	S_OK, or error
//
//  Modifies:	psid, tree
//
//  Algorithm:
//
//  Notes:	
//
//--------------------------------------------------------------------------

SCODE CDirectory::SplitEntry(
	CDfName const *pdfn,
        SID sidTree,
        SID sidGreat,
        SID sidGrand,
        SID sidParent,
        SID sidChild,
        SID *psid)
{
    SCODE sc;
    CDirEntry *pdeChild;
    SID sidLeft, sidRight;

    //  pn is a 4-node;  start split by moving red link up

    //  pn->GetLeft()->SetColor(BLACK);

    msfChk(GetDirEntry(sidChild, FB_DIRTY, &pdeChild));
    sidLeft = pdeChild->GetLeftSib();
    sidRight = pdeChild->GetRightSib();

    //  The root must always be black;  new non-root children are red
    pdeChild->SetColor((sidParent == sidTree) ? DE_BLACK : DE_RED);

    ReleaseEntry(sidChild);

    if (sidLeft != NOSTREAM)
    {
        msfChk(SetColorBlack(sidLeft));
    }

    //  pn->GetRight()->SetColor(BLACK);

    if (sidRight != NOSTREAM)
    {
        msfChk(SetColorBlack(sidRight));
    }

    if (sidParent != sidTree)
    {
        CDirEntry *pdeParent;
        BOOL fRedParent;
        int iCmpParent = 0;

        msfChk(GetDirEntry(sidParent, FB_NONE, &pdeParent));

        fRedParent = (pdeParent->GetColor() == DE_RED);

        if (fRedParent)
            iCmpParent = NameCompare(pdfn, pdeParent->GetName());

        ReleaseEntry(sidParent);

        //  if (pnp->IsRed())

        if (fRedParent)
        {
            int iCmpGrand = 0;

            //  parent is red - adjacent red links are not allowed

            //  Note - grandparent may be sidTree

            if (sidGrand == sidTree)
            {
                iCmpGrand = 1;
            }
            else
            {
                CDirEntry *pdeGrand;
                msfChk(GetDirEntry(sidGrand, FB_DIRTY, &pdeGrand));

                iCmpGrand = NameCompare(pdfn, pdeGrand->GetName());

                //  png->SetColor(RED);
                pdeGrand->SetColor(DE_RED);

                ReleaseEntry(sidGrand);
            }

            //  if ((ikey < png->GetKey()) != (ikey < pnp->GetKey()))

            if ((iCmpGrand < 0) != (iCmpParent < 0))
            {
                /*  two cases:
                //
                //    | |
                //    g g
                //   /   \
                //  p     p
                //   \   /
                //    x x
                //
                //  the red links are oriented differently
                */

                //  pn = Rotate(ikey, png);
                msfChk(RotateEntry(pdfn, sidTree, sidGrand, &sidChild));

                /*
                //      | |
                //      g g
                //     /   \
                //    x     x
                //   /       \
                //  p         p
                */
            }

            //  the red links are now oriented the same - we balance the tree
            //  by rotating

            //  pn = Rotate(ikey, pngg);
            msfChk(RotateEntry(pdfn, sidTree, sidGreat, &sidChild));

            //  pn->SetColor(BLACK);
            msfAssert(sidChild != sidTree);
            msfChk(SetColorBlack(sidChild));
        }
    }

    //  return(pn);
    *psid = sidChild;

    //  The first node's link must always be black.
#if DBG == 1
    CDirEntry *pdeTree;
    msfChk(GetDirEntry(sidTree, FB_NONE, &pdeTree));
    sidChild = pdeTree->GetChild();
    ReleaseEntry(sidTree);

    msfChk(GetDirEntry(sidChild, FB_NONE, &pdeChild));
    msfAssert(pdeChild->GetColor() == DE_BLACK);
    ReleaseEntry(sidChild);
#endif

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::RotateEntry
//
//  Synopsis:   rotation for balancing
//
//  Effects:    rotates localized portion of child tree
//
//  Arguments:  [pdfn] -- search key
//		[sidTree] -- child tree sid
//		[sidParent] -- root of rotation
//		[psid]      -- placeholder for root after rotation
//
//  Returns:    S_OK, or error
//
//  Modifies:   child tree
//
//  Algorithm:
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirectory::RotateEntry(
	CDfName const *pdfn,
        SID sidTree,
        SID sidParent,
        SID *psid)
{
    SCODE sc;
    int iCmp;
    //  PNODE pnc, pngc;
    SID sidChild, sidGrand;

    //  find the child

    CDirEntry *pdeParent, *pdeChild, *pdeGrand;
    msfChk(GetDirEntry(sidParent, FB_DIRTY, &pdeParent));

    if (sidParent == sidTree)
    {
        sidChild = pdeParent->GetChild();
    }
    else
    {
        iCmp = NameCompare(pdfn, pdeParent->GetName());

        if (iCmp < 0)
            sidChild = pdeParent->GetLeftSib();
        else
            sidChild = pdeParent->GetRightSib();
    }

    //  find the grandchild

    msfChkTo(EH_RelParent, GetDirEntry(sidChild, FB_DIRTY, &pdeChild));
    msfAssert(sidChild != sidTree);

    iCmp = NameCompare(pdfn, pdeChild->GetName());

    if (iCmp < 0)
    {
        //  pngc = pnc->GetLeft();
        sidGrand = pdeChild->GetLeftSib();

        msfChkTo(EH_RelChild, GetDirEntry(sidGrand, FB_DIRTY, &pdeGrand));

        /*
        //     |
        //     c
        //    / \
        //   /   \
        //  g     X
        //   \
        //    Y
        */

        //  pnc->SetLeft(pngc->GetRight());
        pdeChild->SetLeftSib(pdeGrand->GetRightSib());

        /*
        //     |
        //     c
        //    / \
        //    |  \
        //  g |   X
        //   \|
        //    Y
        */

        //  pngc->SetRight(pnc);
        pdeGrand->SetRightSib(sidChild);

        /*
        //  g
        //   \
        //    \|
        //     c
        //    / \
        //    |  \
        //    |   X
        //    |
        //    Y
        */
    }
    else
    {
        //  pngc = pnc->GetRight();
        sidGrand = pdeChild->GetRightSib();

        msfChkTo(EH_RelChild, GetDirEntry(sidGrand, FB_DIRTY, &pdeGrand));

        // pnc->SetRight(pngc->GetLeft());
        pdeChild->SetRightSib(pdeGrand->GetLeftSib());

        // pngc->SetLeft(pnc);
        pdeGrand->SetLeftSib(sidChild);
    }


    //  update parent

    if (sidParent == sidTree)
    {
        //  The root must always be black
        pdeGrand->SetColor(DE_BLACK);
        pdeParent->SetChild(sidGrand);
    }
    else
    {
        iCmp = NameCompare(pdfn, pdeParent->GetName());

        if (iCmp < 0)
        {
            //  pnp->SetLeft(pngc);
            pdeParent->SetLeftSib(sidGrand);
        }
        else
        {
            //  pnp->SetRight(pngc);
            pdeParent->SetRightSib(sidGrand);
        }
    }

    ReleaseEntry(sidGrand);

    /*
    //  |
    //  g
    //   \
    //    \
    //     c
    //    / \
    //    |  \
    //    |   X
    //    |
    //    Y
    */

    //  return(pngc);
    *psid = sidGrand;

EH_RelChild:
    ReleaseEntry(sidChild);

EH_RelParent:
    ReleaseEntry(sidParent);

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::FindEntry, private
//
//  Synopsis:	find entry info based on name (optionally removing it)
//
//  Effects:	find - none, remove - takes entry out of child list
//
//  Arguments:	[sidParent] -- sid of parent entry to search
//		[pdfn]      -- name to search for
//		[deop]      -- entry operation (find or remove)
//		[peb]       -- entry information buffer
//
//  Returns:	S_OK, STG_E_FILENOTFOUND, or other error
//
//  Modifies:	peb
//
//  Algorithm:	To find the entry we search down the binary tree.
//		To remove the entry, we need to patch the tree to keep it
//		as a valid binary tree.
//
//--------------------------------------------------------------------------

SCODE  CDirectory::FindEntry(
	SID sidParent,
        CDfName const *pdfn,
        DIRENTRYOP deop,
        SEntryBuffer *peb)
{
    SCODE sc;
    SID sidPrev, sidFind;
    CDirEntry *pdePrev, *pdeFind;
    int iCmp = 0;

    //  Once we've found the right child, sidPrev will be that entry's parent
    //  in the child tree

    sidPrev = sidParent;

    //  Begin the search with the root of the child tree

    msfChk(GetDirEntry(sidPrev, FB_NONE, &pdePrev));
    sidFind = pdePrev->GetChild();

    //  sidPrev is held

    for(;;)
    {
        if (sidFind == NOSTREAM)
        {
            //  we didn't find the child.  fail.
            sc = STG_E_FILENOTFOUND;
            goto EH_RelPrev;
// Removed this line to supress the debug error print.
//	    msfChkTo(EH_RelPrev, STG_E_FILENOTFOUND);
        }

        msfChkTo(EH_RelPrev, GetDirEntry(sidFind, FB_NONE, &pdeFind));

        //  sidPrev and sidFind are held

        int tmpCmp = NameCompare(pdfn, pdeFind->GetName());

        if (tmpCmp == 0)
        {
            //  We found the entry that matches our search name
            break;
        }

        //  The names did not match.  Advance the search down the tree.
        ReleaseEntry(sidPrev);
        pdePrev = pdeFind;
        sidPrev = sidFind;

        //  sidPrev is held

        //  remember the comparison with sidPrev so we can use it to insert
        //  an entry when we patch the tree

        iCmp = tmpCmp;

        if (iCmp < 0)
            sidFind = pdePrev->GetLeftSib();
        else
            sidFind = pdePrev->GetRightSib();
    }

    msfAssert(sidFind != NOSTREAM);

    //  sidFind is held
    //  sidPrev is held

    msfAssert(NameCompare(pdfn, pdeFind->GetName()) == 0);

    //  fill in entry information

    peb->sid = sidFind;
    peb->dwType = pdeFind->GetFlags();
    peb->luid = DF_NOLUID;

    if (deop == DEOP_REMOVE)
    {
        ReleaseEntry(sidFind);
        ReleaseEntry(sidPrev);

        msfChk(GetDirEntry(sidPrev, FB_DIRTY, &pdePrev));
        msfChkTo(EH_RelPrev, GetDirEntry(sidFind, FB_DIRTY, &pdeFind));

        //  Remove the found child from tree (carefully!).  We remove it by
        //  finding another entry in the tree with which to replace it.
        //    sidFind is the node we're removing
        //    sidPrev is the parent of sidFind in the child tree
        //    sidInsert is the entry which will replace sidFind

        SID sidInsert = pdeFind->GetRightSib();

        if (sidInsert == NOSTREAM)
        {
            //  sidFind has no right child, so we can patch the tree by
            //  replacing sidFind with the sidFind's left child

            sidInsert = pdeFind->GetLeftSib();

            //  set the inserted to the right color
            if (sidInsert != NOSTREAM)
            {
                //  we always set the inserted node to black (since the
                //  parent may not exist (we could be inserting at the
                //  root)
                msfChkTo(EH_RelPrev, SetColorBlack(sidInsert));
            }
        }
        else
        {
            CDirEntry *pdeInsert;

            //  The node we're removing has a right child

            msfChkTo(EH_RelFind, GetDirEntry(sidInsert, FB_NONE, &pdeInsert));

            //  sidPrev, sidFind, and sidInsert are all held

            if (pdeInsert->GetLeftSib() != NOSTREAM)
            {
                //  sidFind's right child has a left child.
                //  sidInsert will be the leftmost child of sidFind's right
                //    child (which will keep the tree ordered)

                //  sidPreInsert will be the leftmost child's parent int the
                //    child tree

                SID sidPreInsert = sidInsert;
                CDirEntry *pdePreInsert = pdeInsert;

                //  we wait to assign sidInsert so we can clean up
                msfChkTo(EH_RelIns, GetDirEntry(pdePreInsert->GetLeftSib(),
						FB_NONE, &pdeInsert));

                sidInsert = pdePreInsert->GetLeftSib();

                //  sidPrev, sidFind, sidPreInsert, sidInsert are held

                //  find the leftmost child of sidFind's right child

                SID sidLeft;
                while ((sidLeft = pdeInsert->GetLeftSib()) != NOSTREAM)
                {
                    ReleaseEntry(sidPreInsert);

                    //  sidPrev, sidFind, sidInsert are held

                    sidPreInsert = sidInsert;
                    pdePreInsert = pdeInsert;

                    //  we wait to assign sidInsert to we can clean up
                    msfChkTo(EH_RelIns, GetDirEntry(sidLeft,
						    FB_NONE, &pdeInsert));

                    sidInsert = sidLeft;
                }

                msfAssert(pdeInsert->GetLeftSib() == NOSTREAM);

                //  sidPrev, sidFind, sidPreInsert, sidInsert are held

                //  Remove sidInsert so we can reinsert it in place of sidFind.
                //  We remove sidInsert (which has no left child) by making
                //  sidPreInsert's left child point to sidInsert's right child

                ReleaseEntry(sidPreInsert);
                msfChkTo(EH_RelIns, GetDirEntry(sidPreInsert, FB_DIRTY,
				                &pdePreInsert));

                pdePreInsert->SetLeftSib(pdeInsert->GetRightSib());
                ReleaseEntry(sidPreInsert);

                //  sidPrev, sidFind, sidInsert is held

                //  Begin to replace sidFind with sidInsert by setting the
                //  right child of sidInsert to be the right child of sidFind

                ReleaseEntry(sidInsert);
                msfChkTo(EH_RelFind, GetDirEntry(sidInsert, FB_DIRTY,
						 &pdeInsert));
                pdeInsert->SetRightSib(pdeFind->GetRightSib());
            }
            else
            {
                //  sidFind's right child has no left child, so we can patch
		//  the tree by making sidFind's right child's left child
                //  point to sidFind's left child, and then replacing sidFind
                //  with sidFind's right child.

                ReleaseEntry(sidInsert);
                msfChkTo(EH_RelFind, GetDirEntry(sidInsert, FB_DIRTY,
				                 &pdeInsert));

                //  fall through to do the work
            }

            pdeInsert->SetColor(DE_BLACK);

            //  Complete sidInsert's patching by setting its left child to be
            //  the left child of sidFind

            pdeInsert->SetLeftSib(pdeFind->GetLeftSib());

EH_RelIns:
            ReleaseEntry(sidInsert);
        }

        if (SUCCEEDED(sc))
        {
            if (sidPrev == sidParent)
            {
                //  We're removing the first child;  update sidParent.
                //  We made sure sidInsert is black (above).
                pdePrev->SetChild(sidInsert);
            }
            else if (iCmp < 0)
            {
                pdePrev->SetLeftSib(sidInsert);
            }
            else
                pdePrev->SetRightSib(sidInsert);

            //  make sure sidFind is clean

            pdeFind->SetLeftSib(NOSTREAM);
            pdeFind->SetRightSib(NOSTREAM);
        }
    }

EH_RelFind:
    ReleaseEntry(sidFind);

EH_RelPrev:
    ReleaseEntry(sidPrev);

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::NameCompare, private static
//
//  Synopsis:   name ordering function for child tree
//
//  Arguments:  [pdfn1] - name 1
//              [pdfn2] - name 2
//
//  Requires:   One but not both names cannot may have zero length.
//
//  Returns:    <0 if name 1 < name 2
//               0 if name 1 = name 2
//              >0 if name 1 > name 2
//
//  Algorithm:  To speed the comparision (and to allow zero length names),
//              we first compare the name lengths.  (Shorter names are "less"
//              than longer names).  If the lengths are equal we compare the
//              strings.
//
//--------------------------------------------------------------------------

int CDirectory::NameCompare(CDfName const *pdfn1, CDfName const *pdfn2)
{
    int iCmp = pdfn1->GetLength() - pdfn2->GetLength();

    if (iCmp == 0)
    {
	msfAssert(pdfn1->GetLength() != 0);
	iCmp = dfwcsnicmp((WCHAR *)pdfn1->GetBuffer(),
	    (WCHAR *)pdfn2->GetBuffer(), pdfn1->GetLength());
    }

    return(iCmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::SetColorBlack, private
//
//  Synopsis:   Sets a directory entry to black
//
//  Arguments:  [sid] -- SID of entry to be modified
//
//  Returns:    S_OK or error
//
//  Notes:      Added to reduce code size
//
//--------------------------------------------------------------------------

SCODE  CDirectory::SetColorBlack(const SID sid)
{
    SCODE sc;

    CDirEntry *pde;
    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetColor(DE_BLACK);
    ReleaseEntry(sid);

 Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\docfile.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996.
//
//  File:       docfile.c
//
//  Contents:   DocFile root functions (Stg* functions)
//
//---------------------------------------------------------------

#include "exphead.cxx"

#include "expst.hxx"
#include "h/rexpdf.hxx"
#include "h/docfile.hxx"
#include "ascii.hxx"
#include "logfile.hxx"
#include "h/refilb.hxx"

//+--------------------------------------------------------------
//
//  Function:   DfFromLB, private
//
//  Synopsis:   Starts a root Docfile on an ILockBytes
//
//  Arguments:  [plst] - LStream to start on
//              [df] - Permissions
//              [dwStartFlags] - Startup flags
//              [snbExclude] - Partial instantiation list
//              [ppdfExp] - DocFile return
//              [pcid] - Class ID return for opens
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfExp]
//              [pcid]
//
//---------------------------------------------------------------


SCODE DfFromLB(ILockBytes *plst,
               DFLAGS df,
               DWORD dwStartFlags,
               SNBW snbExclude,
               CExposedDocFile **ppdfExp,
               CLSID *pcid)
{
    SCODE sc, scConv;
    CRootExposedDocFile *prpdf;
    CDFBasis *pdfb=NULL;

    UNREFERENCED_PARM(pcid);
    olDebugOut((DEB_ITRACE, "In  DfFromLB(%p, %X, %lX, %p, %p, %p)\n",
                plst, df, dwStartFlags, snbExclude, ppdfExp, pcid));

    // If we're not creating or converting, do a quick check
    // to make sure that the ILockBytes contains a storage
    if ((dwStartFlags & (RSF_CREATEFLAGS | RSF_CONVERT)) == 0)
        olHChk(StgIsStorageILockBytes(plst));

    if (dwStartFlags & RSF_SECTORSIZE4K)
        df |= DF_LARGE;

    // Make root
    olMem(pdfb = new CDFBasis);
    olMemTo(EH_pdfb, prpdf = new CRootExposedDocFile(pdfb));
    olChkTo(EH_ppcInit, scConv = prpdf->InitRoot(plst, dwStartFlags, df,
            snbExclude));
    *ppdfExp = prpdf;

    olDebugOut((DEB_ITRACE, "Out DfFromLB => %p\n", SAFE_DREF(ppdfExp)));
    return scConv;

EH_ppcInit:
    prpdf->Release();
EH_pdfb:
    delete pdfb;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   StgCreateDocfile, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDAPI StgCreateDocfile(TCHAR const *pszName,
                        DWORD grfMode,
                        DWORD reserved,
                        IStorage **ppstgOpen)
{
    SCODE sc;
    CFileILB *pilb = NULL;    
    int i;

    olDebugOut((DEB_ITRACE, "In  StgCreateDocfile(%p, %lX, %lu, %p)\n",
				pszName, grfMode, reserved, ppstgOpen));

    olChk(ValidatePtrBuffer(ppstgOpen));
    *ppstgOpen = NULL;

    olChk(VerifyPerms(grfMode));
    if ((grfMode & STGM_RDWR) == STGM_READ ||
        (grfMode & (STGM_DELETEONRELEASE | STGM_CONVERT)) ==
        (STGM_DELETEONRELEASE | STGM_CONVERT))
        olErr(EH_Err, STG_E_INVALIDFLAG);    

    pilb = new CFileILB(pszName, grfMode, FALSE);    
    if (!pilb) olErr(EH_Err, STG_E_INSUFFICIENTMEMORY);

    olChk( pilb->Create(grfMode) );

    if ( (grfMode & (STGM_CREATE|STGM_CONVERT)) == STGM_FAILIFTHERE)
        grfMode |= STGM_CREATE; // no file exists, we will 'overwrite' the new
                                // file
    grfMode &= (~STGM_DELETEONRELEASE); // remove the flag

    sc=GetScode(StgCreateDocfileOnILockBytes(pilb, grfMode, reserved,
                                             ppstgOpen));

EH_Err:
    if (pilb) 
    {
        if (FAILED(sc)) i=pilb->ReleaseOnError();
        else            i=pilb->Release();
        olAssert(SUCCEEDED(sc) ? i==1 : i==0);
    }
    olDebugOut((DEB_ITRACE, "Out StgCreateDocfile: *ppstgOpen=%p ret=>%l\n",
                ppstgOpen?(*ppstgOpen):NULL, sc));
    return ResultFromScode(sc);
}



//+--------------------------------------------------------------
//
//  Function:   StgCreateDocfileOnILockBytes, public
//
//  Synopsis:   Creates a root Docfile on an lstream
//
//  Arguments:  [plkbyt] - LStream
//              [grfMode] - Permissions
//              [reserved] - Unused
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//---------------------------------------------------------------

STDAPI StgCreateDocfileOnILockBytes(ILockBytes *plkbyt,
                                    DWORD grfMode,
                                    DWORD reserved,
                                    IStorage **ppstgOpen)
{
    CExposedDocFile *pdfExp;
    SCODE sc;
    DFLAGS df;

    olLog(("--------::In  StgCreateDocFileOnILockBytes(%p, %lX, %lu, %p)\n",
           plkbyt, grfMode, reserved, ppstgOpen));

    olDebugOut((DEB_ITRACE, "In  StgCreateDocfileOnILockBytes("
                "%p, %lX, %lu, %p)\n",
                plkbyt, grfMode, reserved, ppstgOpen));
    TRY
    {
        olChk(ValidatePtrBuffer(ppstgOpen));
        *ppstgOpen = NULL;
        olChk(ValidateInterface(plkbyt, IID_ILockBytes));
        if (reserved != 0)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        if ((grfMode & (STGM_CREATE | STGM_CONVERT)) == 0)
            olErr(EH_Err, STG_E_FILEALREADYEXISTS);
        olChk(VerifyPerms(grfMode));
        if (grfMode & STGM_DELETEONRELEASE)
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        df = ModeToDFlags(grfMode);
        if ((grfMode & (STGM_TRANSACTED | STGM_CONVERT)) ==
            (STGM_TRANSACTED | STGM_CONVERT))
            df |= DF_INDEPENDENT;
        olChkTo(EH_Truncate,
                sc = DfFromLB(plkbyt, df,
                            RSF_CREATE |
                            ((grfMode & STGM_CREATE) ? RSF_TRUNCATE : 0) |
                            ((grfMode & STGM_CONVERT) ? RSF_CONVERT : 0),
                            NULL, &pdfExp, NULL));

        *ppstgOpen = pdfExp;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out StgCreateDocfileOnILockBytes => %p\n",
                ppstgOpen?(*ppstgOpen):NULL));
 EH_Err:
    olLog(("--------::Out StgCreateDocFileOnILockBytes().  *ppstgOpen == %p, ret == %lx\n",
           *ppstgOpen, sc));
    FreeLogFile();
    return ResultFromScode(sc);

 EH_Truncate:
    if ((grfMode & STGM_CREATE) && (grfMode & STGM_TRANSACTED) == 0)
    {
        ULARGE_INTEGER ulSize;

        ULISet32(ulSize, 0);
        olHChk(plkbyt->SetSize(ulSize));
    }
    goto EH_Err;
}


//+--------------------------------------------------------------
//
//  Function:   DfOpenStorageOnILockBytes, public
//
//  Synopsis:   Instantiates a root Docfile from an LStream,
//              converting if necessary
//
//  Arguments:  [plkbyt] - Source LStream
//              [pstgPriority] - For priority reopens
//              [grfMode] - Permissions
//              [snbExclude] - For priority reopens
//              [reserved]
//              [ppstgOpen] - Docfile return
//              [pcid] - Class ID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//              [pcid]
//
//---------------------------------------------------------------

HRESULT DfOpenStorageOnILockBytesW(ILockBytes *plkbyt,
                                   IStorage *pstgPriority,
                                   DWORD grfMode,
                                   SNBW snbExclude,
                                   DWORD reserved,
                                   IStorage **ppstgOpen,
                                   CLSID *pcid)
{
    SCODE sc;
    CExposedDocFile *pdfExp;

    olLog(("--------::In  DfOpenStorageOnILockBytes("
           "%p, %p, %lX, %p, %lu, %p, %p)\n",
           plkbyt, pstgPriority, grfMode, snbExclude, reserved, ppstgOpen,
           pcid));
    olDebugOut((DEB_ITRACE, "In  DfOpenStorageOnILockBytes("
                "%p, %p, %lX, %p, %lu, %p, %p)\n", plkbyt, pstgPriority,
                grfMode, snbExclude, reserved, ppstgOpen, pcid));
    TRY
    {
#ifdef _UNICODE  // do checking if there is an ANSI layer
        olChk(ValidatePtrBuffer(ppstgOpen));
        *ppstgOpen = NULL;
        if (snbExclude) olChk(ValidateSNBW(snbExclude));
#endif /!UNICODE

        olChk(ValidateInterface(plkbyt, IID_ILockBytes));
        if (pstgPriority)
            olChk(ValidateInterface(pstgPriority, IID_IStorage));
        olChk(VerifyPerms(grfMode));
        if (grfMode & STGM_DELETEONRELEASE)
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        if (snbExclude)
        {
            if ((grfMode & STGM_RDWR) != STGM_READWRITE)
                olErr(EH_Err, STG_E_ACCESSDENIED);
        }
        if (reserved != 0)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        if (FAILED(DllIsMultiStream(plkbyt)))
            olErr(EH_Err, STG_E_FILEALREADYEXISTS); //file is not storage obj
        if (pstgPriority)
            olChk(pstgPriority->Release());
        olChk(DfFromLB(plkbyt, ModeToDFlags(grfMode), RSF_OPEN, snbExclude,
                       &pdfExp, pcid));

        *ppstgOpen = pdfExp;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out DfOpenStorageOnILockBytes => %p\n",
                ppstgOpen?(*ppstgOpen):NULL));
EH_Err:
    olLog(("--------::Out DfOpenStorageOnILockBytes().  *ppstgOpen == %p"
           ", ret == %lx\n", *ppstgOpen, sc));
    FreeLogFile();
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   StgCreateStorageEx, public
//
//  Synopsis:   Creates a storage or stream object
//
//  Arguments:  [pwcsName] - pathname of file
//              [grfMode] - open mode flags
//              [stgfmt] -  storage format
//              [grfAttrs] -  reserved
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------

STDAPI StgCreateStorageEx (const WCHAR* pwcsName,
            DWORD grfMode,
            DWORD stgfmt,               // enum
            DWORD grfAttrs,             // reserved
            STGOPTIONS * pStgOptions,
            void * reserved,
            REFIID riid,
            void ** ppObjectOpen)
{
    CExposedDocFile *pdfExp;
    CFileILB *pilb = NULL;
    SCODE sc = S_OK;
    DFLAGS df;
    BOOL fLarge = FALSE;

    olDebugOut((DEB_TRACE, "In  StgCreateStorageEx(%ws, %p, %p, %p, %p)\n",
                pwcsName, grfMode, stgfmt, riid, ppObjectOpen));

    olChk(ValidatePtrBuffer(ppObjectOpen));
    *ppObjectOpen = NULL;

    if (reserved != NULL)
        olErr (EH_Err, STG_E_INVALIDPARAMETER);

    if (grfAttrs != 0)
        olErr (EH_Err, STG_E_INVALIDPARAMETER);

    olChk(VerifyPerms(grfMode));

    if (riid != IID_IStorage)
        olErr (EH_Err, STG_E_INVALIDPARAMETER);

    if (pStgOptions != NULL)
    {
        if (pStgOptions->usVersion > STGOPTIONS_VERSION ||
            pStgOptions->usVersion == 0 ||
            pStgOptions->reserved != 0 ||
            (pStgOptions->ulSectorSize != 512 &&
             pStgOptions->ulSectorSize != 4096) )
        {
            olErr (EH_Err, STG_E_INVALIDPARAMETER);
        }
        if (pStgOptions->ulSectorSize == 4096)
            fLarge = TRUE;
    }

   if (stgfmt != STGFMT_DOCFILE)
        olErr (EH_Err, STG_E_INVALIDPARAMETER);

   olChk(VerifyPerms(grfMode));
   if ((grfMode & STGM_RDWR) == STGM_READ ||
       (grfMode & (STGM_DELETEONRELEASE | STGM_CONVERT)) ==
       (STGM_DELETEONRELEASE | STGM_CONVERT))
       olErr(EH_Err, STG_E_INVALIDFLAG);

   pilb = new CFileILB(pwcsName, grfMode, FALSE);
   if (!pilb) olErr(EH_Err, STG_E_INSUFFICIENTMEMORY);

   olChk( pilb->Create(grfMode) );

   grfMode &= (~STGM_DELETEONRELEASE); // remove the flag
   df = ModeToDFlags(grfMode);

   olChk(DfFromLB(pilb, df, RSF_CREATE |
                            ((grfMode & STGM_CREATE) ? RSF_TRUNCATE : 0) |
                            ((grfMode & STGM_CONVERT) ? RSF_CONVERT : 0) |
                            (fLarge ? RSF_SECTORSIZE4K : 0),
                            NULL, &pdfExp, NULL));

    *ppObjectOpen = pdfExp;

EH_Err:
    if (pilb)
    {
        int i;
        if (FAILED(sc)) i=pilb->ReleaseOnError();
        else            i=pilb->Release();
        olAssert(SUCCEEDED(sc) ? i==1 : i==0);
    }
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\entry.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       entry.cxx
//
//  Contents:   Entry implementations
//
//---------------------------------------------------------------

#include "dfhead.cxx"


//+--------------------------------------------------------------
//
//  Member:     PEntry::CopyTimesFrom, public
//
//  Synopsis:   Copies one entries times to another
//
//  Arguments:  [penFrom] - From
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE PEntry::CopyTimesFrom(PEntry *penFrom)
{
    SCODE sc;
    TIME_T tm;

    olDebugOut((DEB_ITRACE, "In  PEntry::CopyTimesFrom(%p)\n",
                penFrom));
    olChk(penFrom->GetTime(WT_CREATION, &tm));
    olChk(SetTime(WT_CREATION, tm));
    olChk(penFrom->GetTime(WT_MODIFICATION, &tm));
    olChk(SetTime(WT_MODIFICATION, tm));
    olChk(penFrom->GetTime(WT_ACCESS, &tm));
    olChk(SetTime(WT_ACCESS, tm));
    olDebugOut((DEB_ITRACE, "Out PEntry::CopyTimesFrom\n"));
    // Fall through
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\exphead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       exphead.cxx
//
//  Contents:   Precompiled headers
//
//--------------------------------------------------------------------------
#ifdef _MSC_VER
// some of these warnings are a nuisance 
#pragma warning (disable:4514)  // unreferenced inline function
#endif

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "h/ref.hxx"
#include "h/dfexcept.hxx"
#include "h/msf.hxx"
#include "h/docfilep.hxx"
#include "expdf.hxx"
#include "h/funcs.hxx"
#include "h/piter.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\expdf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       expdf.cxx
//
//  Contents:   Exposed DocFile implementation
//
//  Notes:
//              The CExposedDocFile class is the implementation
//              of IStorage. It implements IPropertySetStorage
//              by inheriting from CPropertySetStorage. CPropertySetStorage
//              implements all the functionality of IPropertySetStorage.
//
//              Note that this interface is solely UNICODE, the ASCII layer
//              support which is present if _UNICODE is not defined, provides
//              the overloaded functions that handles the ASCII to Unicode
//              conversion. 
//
//---------------------------------------------------------------------------

// Initialize all the GUID's in ref.hxx
#ifdef INITGUID
#error "Something is Wrong: INIT_GUID should not be defined yet"
#else
#define INITGUID
#include "h/ref.hxx"
#endif

// enable memory leak detection if neccessary
#include "h/dbg.hxx"
 
#include "exphead.cxx"

#include "expdf.hxx"
#include "expst.hxx"
#include "expiter.hxx"
#include "logfile.hxx"
#include "h/rexpdf.hxx"
#include "h/docfilep.hxx"

// Check for proper single-instance flags
#define NOT_SINGLE(md) (((md) & STGM_DENY) != STGM_SHARE_EXCLUSIVE)

#define EnforceSingle(mode) (NOT_SINGLE(mode) ? STG_E_INVALIDFUNCTION : S_OK)
 
//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CExposedDocFile, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pdf] - Public DocFile
//              [pdfb] - DocFile basis
//              [ppc] - Context
//              [fOwnContext] - Whether this object owns the context
//
//---------------------------------------------------------------


CExposedDocFile::CExposedDocFile(CExposedDocFile *pdfParent,
                                 CDocFile *pdf, 
                                 DFLAGS const df,
                                 DFLUID luid,
                                 ILockBytes *pilbBase,
                                 CDfName const *pdfn,
                                 CMStream* pmsBase,
                                 CDFBasis *pdfb)
#ifdef NEWPROPS
#ifdef _MSC_VER
#pragma warning(disable: 4355)
#endif // _MSC_VER
    : CPropertySetStorage(this)
#ifdef _MSC_VER
#pragma warning(default: 4355)
#endif // _MSC_VER
#endif // NEWPROPS
{
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::CExposedDocFile(%p)\n",
                pdf));    
    _pdfb = pdfb;
    _pdfb->AddRef();
    _pdf = pdf;
    _df = df;
    _luid = luid;
    _pdfParent = pdfParent;
     // note: we don't addref here 'cos it is only done in the root
    _pilbBase = pilbBase;
    _pmsBase = pmsBase;
    if (pdfn) _dfn.Set(pdfn->GetLength(), pdfn->GetBuffer());
    else _dfn.Set((WORD)0, (BYTE*)NULL);
    if (!IsRoot())
        _pdfParent->AddChild(this);
    _fDirty = FALSE;
    _cReferences = 1;
    _ulAccessLockBase = 0;
    _sig = CEXPOSEDDOCFILE_SIG;
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::CExposedDocFile\n"));
    
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::~CExposedDocFile, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------

CExposedDocFile::~CExposedDocFile(void)
{
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::~CExposedDocFile\n"));
    olAssert(_cReferences == 0);
    if (_pdfb) _pdfb->Release();
    _sig = CEXPOSEDDOCFILE_SIGDEL;
    if (SUCCEEDED(CheckReverted()))
    {
        if (IsRoot()) {
            olDebugOut((DEB_TRACE, "Destr called for root\n"));
            olAssert(_pilbBase==NULL);  
        }
        else {
            _pdfParent->ReleaseChild(this);
        }
        _cilChildren.DeleteByName(NULL);
        if (_pdf) _pdf->Release();
    }
    olDebugOut((DEB_TRACE, "Out CExposedDocFile::~CExposedDocFile\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Release, public
//
//  Synopsis:   Releases resources for a CExposedDocFile
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CExposedDocFile::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CExposedDocFile::Release()\n", this));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::Release()\n"));
    TRY 
    {
        if (FAILED(Validate())) return 0;
        olAssert(_cReferences > 0);
        lRet = AtomicDec(&_cReferences);
        if (_pdf && !P_TRANSACTED(_df) && SUCCEEDED(CheckReverted()))
        {
            TIME_T tm;
            olVerSucc(DfGetTOD(&tm));
            olVerSucc(_pdf->SetTime(WT_ACCESS, tm));
#ifdef NEWPROPS
            olVerSucc(FlushBufferedData());
#endif
            if (IsDirty())
            {
                olVerSucc(DfGetTOD(&tm));
                olVerSucc(_pdf->SetTime(WT_MODIFICATION, tm));
                if (!IsRoot())
                    _pdfParent->SetDirty();
                olAssert(P_WRITE(_df) &&
                          aMsg("Dirty & Direct but no write access"));
                SetClean();
            }
            if (IsRoot() && P_WRITE(_df))
            {
                SCODE sc;
                sc = _pmsBase->Flush(0);
#if DBG == 1
                if (FAILED(sc))
                {
                olDebugOut((DEB_ERROR,
                            "ILockBytes::Flush() failed in release path "
                            "with error %lx\n", sc));
                }
#endif            
            }
        }
        if (lRet == 0)
        {
            delete this;
        }
        else if (lRet < 0)
            lRet = 0;
    }
    CATCH(CException, e) 
    {
        UNREFERENCED_PARM(e);
        lRet = 0;
    }
    END_CATCH
        
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::Release()\n"));
    olLog(("%p::Out CExposedDocFile::Release().  ret == %lu\n", this, lRet));
    FreeLogFile();
    return (ULONG)lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CheckCopyTo, private
//
//  Synopsis:   Checks for CopyTo legality
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

inline SCODE CExposedDocFile::CheckCopyTo(void)
{
    // it is an error to copy a parent to child
    return _pdfb->GetCopyBase() != NULL &&
        IsAtOrAbove(_pdfb->GetCopyBase()) ? STG_E_ACCESSDENIED : S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::ConvertInternalStream, private
//
//  Synopsis:   Converts an internal stream to a storage
//
//  Arguments:  [pwcsName] - Name
//              [pdfExp] - Destination docfile
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


static WCHAR const wcsIllegalName[] = {'\\','\0'};

SCODE CExposedDocFile::ConvertInternalStream(CExposedDocFile *pdfExp)
{
    CExposedStream *pstFrom=NULL, *pstTo=NULL;
    SCODE sc=S_OK;
    CDfName const dfnIllegal(wcsIllegalName);
    CDfName const dfnContents(wcsContents);

    olDebugOut((DEB_ITRACE, "In CExposedDocFile::ConvertInternalStream(%p)\n",
                pdfExp));

    olChk(GetExposedStream(&dfnIllegal, DF_READWRITE | DF_DENYALL,
                           &pstFrom));
    olChkTo(EH_pstFrom, 
            pdfExp->CreateExposedStream(&dfnContents, DF_WRITE | DF_DENYALL,
                                        &pstTo));
    olChkTo(EH_pstTo, CopyStreamToStream(pstFrom->GetDirectStream(), 
                                         pstTo->GetDirectStream()));
    olChkTo(EH_pstTo, DestroyEntry(&dfnIllegal, FALSE));

    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::ConvertInternalStream\n"));
    // Fall through
EH_pstTo:
    pstTo->Release();
EH_pstFrom:
    pstFrom->Release();
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateEntry, private
//
//  Synopsis:   Creates elements, used in CreateStream, CreateStorage and
//              for properties
//
//  Arguments:  [pwcsName] - Name
//              [dwType] - Entry type
//              [grfMode] - Access mode
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//----------------------------------------------------------------------------

SCODE CExposedDocFile::CreateEntry(WCHAR const *pwcsName,
                                   DWORD dwType,
                                   DWORD grfMode,
                                   void **ppv)
{
    SCODE sc;
    SEntryBuffer eb;
    CDfName dfn;
    BOOL fRenamed = FALSE;
    CExposedStream *pstExp;
    CExposedDocFile *pdfExp;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::CreateEntry:%p("
                "%ws, %lX, %lX, %p)\n", 
                this, pwcsName, dwType, grfMode, ppv));
    olChk(EnforceSingle(grfMode));
    olChk(CheckReverted());
    dfn.Set(pwcsName);

    if (grfMode & (STGM_CREATE | STGM_CONVERT))
    {
        if (FAILED(sc = _pdf->IsEntry(&dfn, &eb)))
        {
            if (sc != STG_E_FILENOTFOUND)
                olErr(EH_Err, sc);
        }
        else if (eb.dwType == dwType && (grfMode & STGM_CREATE))
            olChk(DestroyEntry(&dfn, FALSE));
        else if (eb.dwType == STGTY_STREAM && (grfMode & STGM_CONVERT) &&
                 dwType == STGTY_STORAGE)
        {
            CDfName const dfnIllegal(wcsIllegalName);
            olChk(RenameEntry(&dfn, &dfnIllegal));
            fRenamed = TRUE;
        }
        else
            olErr(EH_Err, STG_E_FILEALREADYEXISTS);
    }

    if (REAL_STGTY(dwType) == STGTY_STREAM)
    {
        olChk(CreateExposedStream(&dfn, ModeToDFlags(grfMode), &pstExp));
        *ppv = pstExp;
    }
    else
    {
        olAssert(REAL_STGTY(dwType) == STGTY_STORAGE);
        olChk(CreateExposedDocFile(&dfn, ModeToDFlags(grfMode), &pdfExp));
        // If we've renamed the original stream for conversion, convert
        if (fRenamed)
        {
            olChkTo(EH_pdfExpInit, ConvertInternalStream(pdfExp));
            sc = STG_S_CONVERTED;
        }
        *ppv = pdfExp;
    }
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::CreateEntry\n"));
    return sc;

EH_pdfExpInit:
    pdfExp->Release();
    olVerSucc(DestroyEntry(&dfn, TRUE));
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenEntry, private
//
//  Synopsis:   Opens elements, used in OpenStream, OpenStorage and
//              for properties
//
//  Arguments:  [pwcsName] - Name
//              [dwType] - Entry type
//              [grfMode] - Access mode
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//----------------------------------------------------------------------------


SCODE CExposedDocFile::OpenEntry(WCHAR const *pwcsName,
                                 DWORD dwType,
                                 DWORD grfMode,
                                 void **ppv)
{
    CDfName dfn;
    SCODE sc;
    CExposedDocFile *pdfExp;
    CExposedStream *pstExp;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::OpenEntry:%p("
                "%ws, %lX, %lX, %p)\n", this, pwcsName, dwType, grfMode, ppv));
    olChk(EnforceSingle(grfMode));
        dfn.Set(pwcsName);


    if (REAL_STGTY(dwType) == STGTY_STREAM)
    {
        olChk(GetExposedStream(&dfn, ModeToDFlags(grfMode), &pstExp));
        *ppv = pstExp;
    }
    else
    {
        olAssert(REAL_STGTY(dwType) == STGTY_STORAGE);
        olChk(GetExposedDocFile(&dfn, ModeToDFlags(grfMode), &pdfExp));
        *ppv = pdfExp;
    }
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::OpenEntry\n"));
    return S_OK;

EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateStream, public
//
//  Synopsis:   Creates a stream
//
//  Arguments:  [pwcsName] - Name
//              [grfMode] - Permissions
//              [reserved1]
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::CreateStream(WCHAR const *pwcsName,
                                            DWORD grfMode,
                                            DWORD reserved1,
                                            DWORD reserved2,
                                            IStream **ppstm)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::CreateStream("
                "%ws, %lX, %lu, %lu, %p)\n", pwcsName, grfMode, reserved1,
                reserved2, ppstm));
    olLog(("%p::In  CExposedDocFile::CreateStream(%ws, %lX, %lu, %lu, %p)\n",
           this, pwcsName, grfMode, reserved1, reserved2, ppstm));
    TRY
    {
        olChk(ValidateOutPtrBuffer(ppstm));
        *ppstm = NULL;
        olChk(CheckWName(pwcsName));

        if (reserved1 != 0 || reserved2 != 0)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        olChk(VerifyPerms(grfMode));
        if (grfMode & (STGM_CONVERT | STGM_TRANSACTED | STGM_PRIORITY |
                       STGM_DELETEONRELEASE))
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        olChk(Validate());
        olChk(CheckCopyTo());
        sc = CreateEntry(pwcsName, STGTY_STREAM, grfMode, (void **)ppstm);
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::CreateStream => %p\n",
                *ppstm));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::CreateStream().  "
           "*ppstm == %p, ret == %lx\n", this, SAFE_DREF(ppstm), sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenStream, public
//
//  Synopsis:   Opens an existing stream
//
//  Arguments:  [pwcsName] - Name
//              [reserved1]
//              [grfMode] - Permissions
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::OpenStream(WCHAR const *pwcsName,
                                          void *reserved1,
                                          DWORD grfMode,
                                          DWORD reserved2,
                                          IStream **ppstm)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::OpenStream("
                "%ws, %p, %lX, %lu, %p)\n", pwcsName, reserved1,
                grfMode, reserved2, ppstm));
    olLog(("%p::In  CExposedDocFile::OpenStream(%ws, %lu %lX, %lu, %p)\n",
           this, pwcsName, reserved1, grfMode, reserved2, ppstm));
    TRY
    {
        olChk(ValidateOutPtrBuffer(ppstm));
        *ppstm = NULL;
        olChk(CheckWName(pwcsName));

        if (reserved1 != NULL || reserved2 != 0)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        olChk(VerifyPerms(grfMode));
        if (grfMode & (STGM_TRANSACTED | STGM_PRIORITY |
                       STGM_DELETEONRELEASE))
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        olChk(Validate());
        sc = OpenEntry(pwcsName, STGTY_STREAM, grfMode, (void **)ppstm);
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::OpenStream => %p\n",
                SAFE_DREF(ppstm)));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::OpenStream().  "
           "*ppstm == %p, ret == %lx\n", this, SAVE_DREF(ppstm), sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateStorage, public
//
//  Synopsis:   Creates an embedded DocFile
//
//  Arguments:  [pwcsName] - Name
//              [grfMode] - Permissions
//              [reserved1]
//              [reserved2]
//              [ppstg] - New DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstg]
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::CreateStorage(WCHAR const *pwcsName,
                                             DWORD grfMode,
                                             DWORD reserved1,
                                             DWORD reserved2,
                                             IStorage **ppstg)
{
    SCODE sc;

    olLog(("%p::In  CExposedDocFile::CreateStorage(%ws, %lX, %lu, %lu, %p)\n",
           this, pwcsName, grfMode, reserved1, reserved2, ppstg));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::CreateStorage:%p("
                "%ws, %lX, %lu, %lu, %p)\n", this, pwcsName, grfMode,
                reserved1, reserved2, ppstg));
    TRY
    {
        olChk(ValidateOutPtrBuffer(ppstg));
        *ppstg = NULL;
        olChk(CheckWName(pwcsName));

        if (reserved1 != 0 || reserved2 != 0)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        olChk(VerifyPerms(grfMode));
        if (grfMode & (STGM_PRIORITY | STGM_DELETEONRELEASE))
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        olChk(Validate());
        olChk(CheckCopyTo());
        sc = CreateEntry(pwcsName, STGTY_STORAGE, grfMode, (void **)ppstg);
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::CreateStorage => %p\n",
                *ppstg));
EH_Err:
    olLog(("%p::Out CExposedDocFile::CreateStorage().  "
           "*ppstg == %p, ret == %lX\n", this, *ppstg, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenStorage, public
//
//  Synopsis:   Gets an existing embedded DocFile
//
//  Arguments:  [pwcsName] - Name
//              [pstgPriority] - Priority reopens
//              [grfMode] - Permissions
//              [snbExclude] - Priority reopens
//              [reserved]
//              [ppstg] - DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstg]
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::OpenStorage(WCHAR const *pwcsName,
                                           IStorage *pstgPriority,
                                           DWORD grfMode,
                                           SNBW snbExclude,
                                           DWORD reserved,
                                           IStorage **ppstg)
{
    SCODE sc;
    CExposedDocFile *pdfExp;

    olLog(("%p::In  CExposedDocFile::OpenStorage(%ws, %p, %lX, %p, %lu, %p)\n",
           this, pwcsName, pstgPriority, grfMode, snbExclude, reserved,
           ppstg));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::OpenStorage:%p("
                "%ws, %p, %lX, %p, %lu, %p)\n", this, pwcsName, pstgPriority,
                grfMode, snbExclude, reserved, ppstg));
    TRY
    {
#ifdef _UNICODE                 // for UNICODE API's we have to do validation, 
                                // else it had been done in the ascii layer 
        olChk(CheckWName(pwcsName));
#endif
        olChk(ValidateOutPtrBuffer(ppstg));
        *ppstg = NULL;
        if (reserved != 0)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        olChk(VerifyPerms(grfMode));
        if (pstgPriority != NULL ||
            (grfMode & (STGM_PRIORITY | STGM_DELETEONRELEASE)))
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        olChk(Validate());
        if (snbExclude != NULL)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        olChk(OpenEntry(pwcsName, STGTY_STORAGE, grfMode, (void **)&pdfExp));
        *ppstg = pdfExp;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::OpenStorage => %p\n",
                *ppstg));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::OpenStorage().  "
           "*ppstg == %p, ret == %lX\n", this, SAFE_DREF(ppstg), sc));
    return sc;

}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::MakeCopyFlags, public
//
//  Synopsis:   Translates IID array into bit fields
//
//  Arguments:  [ciidExclude] - Count of IIDs
//              [rgiidExclude] - IIDs not to copy
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------


DWORD CExposedDocFile::MakeCopyFlags(DWORD ciidExclude,
                                     IID const *rgiidExclude)
{
    DWORD dwCopyFlags;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::MakeCopyFlags(%lu, %p)\n",
                ciidExclude, rgiidExclude));
    // Copy everything by default
    dwCopyFlags = COPY_ALL;
    for (; ciidExclude > 0; ciidExclude--, rgiidExclude++)
        if (IsEqualIID(*rgiidExclude, IID_IStorage))
            dwCopyFlags &= ~COPY_STORAGES;
        else if (IsEqualIID(*rgiidExclude, IID_IStream))
            dwCopyFlags &= ~COPY_STREAMS;
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::MakeCopyFlags\n"));
    return dwCopyFlags;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CopyTo, public
//
//  Synopsis:   Makes a copy of a DocFile
//
//  Arguments:  [ciidExclude] - Length of rgiid array
//              [rgiidExclude] - Array of IIDs to exclude
//              [snbExclude] - Names to exclude
//              [pstgDest] - Parent of copy
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

TSTDMETHODIMP CExposedDocFile::CopyTo(DWORD ciidExclude,
                                      IID const *rgiidExclude,
                                      SNBW snbExclude,
                                      IStorage *pstgDest)
{
    SCODE sc;
    DWORD i;

    olLog(("%p::In  CExposedDocFile::CopyTo(%lu, %p, %p, %p)\n",
           this, ciidExclude, rgiidExclude, snbExclude, pstgDest));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::Copy(%lu, %p, %p, %p)\n",
                ciidExclude, rgiidExclude, snbExclude, pstgDest));

    TRY
    {
        if (snbExclude)
            olChk(ValidateSNBW(snbExclude));
        
        olChk(ValidateInterface(pstgDest, IID_IStorage));
        if (rgiidExclude)
        {
            olAssert(sizeof(IID)*ciidExclude <= 0xffffUL);
            olChk(ValidateBuffer(rgiidExclude,
                                 (size_t)(sizeof(IID)*ciidExclude)));
            for (i = 0; i<ciidExclude; i++)
                olChk(ValidateIid(rgiidExclude[i]));
        }
        olChk(Validate());
        olChk(CheckReverted());
        olAssert(_pdfb->GetCopyBase() == NULL);
        _pdfb->SetCopyBase(this);
#ifdef NEWPROPS
        // Flush all descendant property set buffers so that their
        // underlying Streams (which are about to be copied) are
        // up to date.        
        olChk(FlushBufferedData());
#endif
        olChk(CopyDocFileToIStorage(GetDF(), pstgDest, snbExclude,
                                    MakeCopyFlags(ciidExclude, rgiidExclude)));
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::Copy\n"));

EH_Err:
    _pdfb->SetCopyBase(NULL);

    olLog(("%p::Out ExposedDocFile::CopyTo().  ret == %lX\n",this, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Commit, public
//
//  Synopsis:   Commits transacted changes
//
//  Arguments:  [dwFlags] - DFC_*
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::Commit(DWORD dwFlags)
{
    SCODE sc=S_OK;
    TIME_T tm;

    olLog(("%p::In  CExposedDocFile::Commit(%lX)\n",this, dwFlags));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::Commit(%lX)\n", dwFlags));
    TRY
    {
        if (!VALID_COMMIT(dwFlags))
            olErr(EH_Err, STG_E_INVALIDFLAG);
        olChk(Validate());
        olChk(CheckReverted());
        if (!P_WRITE(_df)) olErr(EH_Err, STG_E_ACCESSDENIED);
        if (IsDirty())
        {
            olChk(DfGetTOD(&tm));
            olChk(_pdf->SetTime(WT_MODIFICATION, tm));
            olChk(_pmsBase->Flush(FLUSH_CACHE(dwFlags)));
            if (!IsRoot()) _pdfParent->SetDirty();
        }
        olChk(DfGetTOD(&tm));
        olChk(_pdf->SetTime(WT_ACCESS, tm));
#ifdef NEWPROPS
        olChk(FlushBufferedData());
#endif
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::Commit\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::Commit().  ret == %lx\n",this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Revert, public
//
//  Synopsis:   Reverts transacted changes
//
//  Returns:    S_OK - for direct mode files, this function
//                     has not effect
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::Revert(void)
{
    // we don't supported transacted files
    // it is stated in the OLE documentation that for direct
    // files, this method has no effect
    return ResultFromScode(S_OK);  
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::EnumElements, public
//
//  Synopsis:   Starts an iterator
//
//  Arguments:  [reserved1]
//              [reserved2]
//              [reserved3]
//              [ppenm] - Enumerator return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppenm]
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::EnumElements(DWORD reserved1,
                                           void *reserved2,
                                           DWORD reserved3,
                                           IEnumSTATSTG **ppenm)
{
    SCODE sc;
    CExposedIterator *pdiExp;
    CDfName dfnTemp;

    olLog(("%p::In  CExposedDocFile::EnumElements(%lu, %p, %lu, %p)\n",
           this, reserved1, reserved2, reserved3, ppenm));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::EnumElements(%p)\n",
                ppenm));
    TRY
    {
	olChk(ValidateOutPtrBuffer(ppenm));
	*ppenm = NULL;
	if (reserved1 != 0 || reserved2 != NULL || reserved3 != 0)
	    olErr(EH_Err, STG_E_INVALIDPARAMETER);
	olChk(Validate());
        olChk(CheckReverted());
	if (!P_READ(_df))
	    olErr(EH_Err, STG_E_ACCESSDENIED);
        olMem(pdiExp = new CExposedIterator(this, &dfnTemp)); 
        *ppenm = pdiExp;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

EH_Err:
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::EnumElements => %p\n",
               SAFE_DREF(ppenm)));
    olLog(("%p::Out CExposedDocFile::EnumElements().  ret == %lx\n",this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::DestroyElement, public
//
//  Synopsis:   Permanently deletes an element of a DocFile
//
//  Arguments:  [pwcsName] - Name of element
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::DestroyElement(WCHAR const *pwcsName)
{
    SCODE sc;
    CDfName dfn;

    olLog(("%p::In  CExposedDocFile::DestroyElement(%ws)\n", this, pwcsName));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::DestroyElement(%ws)\n",
                pwcsName));
    TRY
    {
        olChk(CheckWName(pwcsName));
        olChk(Validate());
        dfn.Set(pwcsName);
        olChk(DestroyEntry(&dfn, FALSE));
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::DestroyElement\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::DestroyElement().  ret == %lx\n",
           this, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::MoveElementTo, public
//
//  Synopsis:   Move an element of a DocFile to an IStorage
//
//  Arguments:  [pwcsName] - Current name
//              [ptcsNewName] - New name
//
//  Returns:    Appropriate status code
//
//  Algorithm:  Open source as storage or stream (whatever works)
//              Create appropriate destination
//              Copy source to destination
//              Set create time of destination equal to create time of source
//              If appropriate, delete source
//
//---------------------------------------------------------------

TSTDMETHODIMP CExposedDocFile::MoveElementTo(WCHAR const *pwcsName,
                                             IStorage *pstgParent,
                                             TCHAR const *ptcsNewName,
                                             DWORD grfFlags)
{
    IUnknown *punksrc = NULL;
    SCODE sc;

    olLog(("%p::In  CExposedDocFile::MoveElementTo(%ws, %p, %s, %lu)\n",
           this, pwcsName, pstgParent, ptcsNewName, grfFlags));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::MoveElementTo("
                "%ws, %p, %s, %lu)\n",
                pwcsName, pstgParent, ptcsNewName, grfFlags));
    TRY
    {
        IUnknown *punkdst = NULL;
        IStorage *pstgsrc;
        STATSTG statstg;

        olChk(CheckWName(pwcsName));
        olChk(Validate());
        olChk(VerifyMoveFlags(grfFlags));

        //  determine source type (determine its type)

        sc = OpenStorage(pwcsName, (IStorage*)NULL,
                         STGM_DIRECT| STGM_READ| STGM_SHARE_EXCLUSIVE,
                         (SNBW)NULL, (DWORD)NULL, &pstgsrc);

        if (SUCCEEDED(sc))
        {
            HRESULT hr;

            //  It's a storage
            punksrc = pstgsrc;

            IStorage *pstgdst;
            olHChkTo(EH_UnkSrc, pstgsrc->Stat(&statstg, STATFLAG_NONAME));

            hr = pstgParent->CreateStorage(ptcsNewName,
                                           STGM_DIRECT |
                                           STGM_WRITE |
                                           STGM_SHARE_EXCLUSIVE
                                           | STGM_FAILIFTHERE,
                                           0, 0, &pstgdst);
            if (DfGetScode(hr) == STG_E_FILEALREADYEXISTS &&
                grfFlags == STGMOVE_COPY)
            {
                hr = pstgParent->OpenStorage(ptcsNewName,
                                             NULL,
                                             STGM_DIRECT |
                                             STGM_WRITE |
                                             STGM_SHARE_EXCLUSIVE,
                                             NULL,
                                             0, &pstgdst);
            }
            olHChkTo(EH_UnkSrc, hr);

            punkdst = pstgdst;

            sc = DfGetScode(pstgsrc->CopyTo(0, NULL, NULL, pstgdst));
        }
        else if (sc == STG_E_FILENOTFOUND)
        {
            //  Try opening it as a stream

            IStream *pstmsrc, *pstmdst;
            olChk(OpenStream(pwcsName, (void *)NULL,
                             STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                             (DWORD)NULL, &pstmsrc));

            //  It's a stream
            punksrc = pstmsrc;

            olHChkTo(EH_UnkSrc, pstmsrc->Stat(&statstg, STATFLAG_NONAME));

            olHChkTo(EH_UnkSrc,
                     pstgParent->CreateStream(ptcsNewName,
                                              STGM_DIRECT |
                                              STGM_WRITE |
                                              STGM_SHARE_EXCLUSIVE |
                                              (grfFlags == STGMOVE_MOVE ?
                                               STGM_FAILIFTHERE :
                                               STGM_CREATE),
                                              0, 0, &pstmdst));

            punkdst = pstmdst;

            ULARGE_INTEGER cb;
            cb.QuadPart = 0xFFFFFFFFFFFFFFFF;
            sc = DfGetScode(pstmsrc->CopyTo(pstmdst, cb, NULL, NULL));
        }
        else
            olChk(sc);

        punkdst->Release();

        if (SUCCEEDED(sc))
        {
            //  Make destination create time match source create time
            //  Note that we don't really care if this call succeeded.

            pstgParent->SetElementTimes(ptcsNewName, &statstg.ctime,
                                        NULL, NULL);

            if ((grfFlags & STGMOVE_COPY) == STGMOVE_MOVE)
                sc = DestroyElement(pwcsName);
        }

        if (FAILED(sc))
        {
            //  The copy/move failed, so get rid of the partial result.

            pstgParent->DestroyElement(ptcsNewName);
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::MoveElementTo\n"));
    // Fall through
EH_UnkSrc:
    if (punksrc)
        punksrc->Release();
EH_Err:
    olLog(("%p::Out CExposedDocFile::MoveElementTo().  ret == %lx\n",
           this, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::RenameElement, public
//
//  Synopsis:   Renames an element of a DocFile
//
//  Arguments:  [pwcsName] - Current name
//              [pwcsNewName] - New name
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::RenameElement(WCHAR const *pwcsName,
                                             WCHAR const *pwcsNewName)
{
    SCODE sc;
    CDfName dfnOld, dfnNew;

    olLog(("%p::In  CExposedDocFile::RenameElement(%ws, %ws)\n",
           this, pwcsName, pwcsNewName));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::RenameElement(%ws, %ws)\n",
               pwcsName, pwcsNewName));
    TRY
    {
        olChk(Validate());
        olChk(CheckWName(pwcsName));
        olChk(CheckWName(pwcsNewName));
        dfnOld.Set(pwcsName);
        dfnNew.Set(pwcsNewName);
        olChk(RenameEntry(&dfnOld, &dfnNew));
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::RenameElement\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::RenameElement().  ret == %lx\n",
           this, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetElementTimes, public
//
//  Synopsis:   Sets element time stamps
//
//  Arguments:  [pwcsName] - Name
//              [pctime] - create time
//              [patime] - access time
//              [pmtime] - modify time
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::SetElementTimes(WCHAR const *pwcsName,
                                               FILETIME const *pctime,
                                               FILETIME const *patime,
                                               FILETIME const *pmtime)
{
    SCODE sc;
    CDfName dfn;
    CDocFile *pdf;

    olLog(("%p::In  CExposedDocFile::SetElementTimes(%ws, %p, %p, %p)\n",
           this, pwcsName, pctime, patime, pmtime));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::SetElementTimes:%p("
                "%ws, %p, %p, %p)\n", this, pwcsName, pctime, patime, pmtime));
    TRY
    {
        if (pwcsName)
            olChk(CheckWName(pwcsName));
        else  // function is meant to work on root storage
        {
            olAssert(FALSE && 
                     aMsg("SetTimes on root storage is not supported!\n"));
            // SetElementTimes on root storage is not portable
            // since it calls set filetimes. 
            return ResultFromScode(STG_E_UNIMPLEMENTEDFUNCTION);        
        }
        olChk(Validate());
        
        if (pctime)
            olChk(ValidateBuffer(pctime, sizeof(FILETIME)));
        if (patime)
            olChk(ValidateBuffer(patime, sizeof(FILETIME)));
        if (pmtime)
            olChk(ValidateBuffer(pmtime, sizeof(FILETIME)));
        dfn.Set(pwcsName);
        olChk(CheckReverted());
        if (!P_WRITE(_df) || _cilChildren.FindByName(&dfn) != NULL)
            olErr(EH_Err, STG_E_ACCESSDENIED);
        olChk(_pdf->GetDocFile(&dfn, DF_WRITE, &pdf));

        if (pctime)
            olChkTo(EH_pdf, pdf->SetTime(WT_CREATION, *pctime));
        if (pmtime)
            olChkTo(EH_pdf, pdf->SetTime(WT_MODIFICATION, *pmtime));
        if (patime)
            olChkTo(EH_pdf, pdf->SetTime(WT_ACCESS, *patime));
        SetDirty();
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::SetElementTimes\n"));
    // Fall thru
EH_pdf:
    pdf->Release();
EH_Err:
    olLog(("%p::Out CExposedDocFile::SetElementTimes().  ret == %lx\n",
           this, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetClass, public
//
//  Synopsis:   Sets storage class
//
//  Arguments:  [clsid] - class id
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::SetClass(REFCLSID clsid)
{
    SCODE sc;

    olLog(("%p::In  CExposedDocFile::SetClass(?)\n", this));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::SetClass:%p(?)\n", this));
    TRY
    {
        olChk(Validate());
        olChk(ValidateBuffer(&clsid, sizeof(CLSID)));
        olChk(CheckReverted());
        if (!P_WRITE(_df))
            olErr(EH_Err, STG_E_ACCESSDENIED);
        olChk(_pdf->SetClass(clsid));
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::SetClass\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::SetClass().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetStateBits, public
//
//  Synopsis:   Sets state bits
//
//  Arguments:  [grfStateBits] - state bits
//              [grfMask] - state bits mask
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    SCODE sc;

    olLog(("%p::In  CExposedDocFile::SetStateBits(%lu, %lu)\n", this,
           grfStateBits, grfMask));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::SetStateBits:%p("
                "%lu, %lu)\n", this, grfStateBits, grfMask));
    TRY
    {
        olChk(Validate());
        olChk(CheckReverted());
        if (!P_WRITE(_df))
            olErr(EH_Err, STG_E_ACCESSDENIED);
        olChk(_pdf->SetStateBits(grfStateBits, grfMask));
        SetDirty();
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::SetStateBits\n"));
    // fall thru
EH_Err:
    olLog(("%p::Out CExposedDocFile::SetStateBits().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Stat, public virtual
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//---------------------------------------------------------------

TSTDMETHODIMP CExposedDocFile::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;    

    // root storage should be handled by virtual funcs in CRootExposedDocFile
    olAssert(!IsRoot());        
    olLog(("%p::In  CExposedDocFile::Stat(%p)\n", this, pstatstg));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::Stat(%p)\n", pstatstg));
    TRY
    {
        olChkTo(EH_RetSc, ValidateOutBuffer(pstatstg, sizeof(STATSTGW)));
        olChk(VerifyStatFlag(grfStatFlag));
        olChk(CheckReverted());
        olChk(_pdf->GetTime(WT_CREATION, &pstatstg->ctime));
        olChk(_pdf->GetTime(WT_MODIFICATION, &pstatstg->mtime));
        pstatstg->atime.dwLowDateTime = pstatstg->atime.dwHighDateTime = 0;
        olChk(_pdf->GetClass(&pstatstg->clsid));
        olChk(_pdf->GetStateBits(&pstatstg->grfStateBits));
        pstatstg->pwcsName = NULL;
        if ((grfStatFlag & STATFLAG_NONAME) == 0)
        {
            olChk(DfAllocWCS((WCHAR *)_dfn.GetBuffer(), &pstatstg->pwcsName));
            wcscpy(pstatstg->pwcsName, (WCHAR *)_dfn.GetBuffer());
        }
        pstatstg->grfMode = DFlagsToMode(_df);
        pstatstg->type = STGTY_STORAGE;
        ULISet32(pstatstg->cbSize, 0); // irelevant for storage obj
        pstatstg->grfLocksSupported = 0;
        pstatstg->reserved = 0;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::Stat\n"));
EH_Err:
    if (FAILED(sc))
        memset(pstatstg, 0, sizeof(STATSTGW));
EH_RetSc:
    olLog(("%p::Out CExposedDocFile::Stat().  *pstatstg == %p  ret == %lx\n",
           this, *pstatstg, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedDocFile::AddRef(void)
{
    ULONG ulRet;

    olLog(("%p::In  CExposedDocFile::AddRef()\n", this));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::AddRef()\n"));
    TRY
    {
        if (FAILED(Validate()))
            return 0;
        AtomicInc(&_cReferences);
        ulRet = _cReferences;
    }
    CATCH(CException, e)
    {
        UNREFERENCED_PARM(e);
        ulRet = 0;
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::AddRef\n"));
    olLog(("%p::Out CExposedDocFile::AddRef().  ret == %lu\n", this, ulRet));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    olLog(("%p::In  CExposedDocFile::QueryInterface(?, %p)\n",
           this, ppvObj));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::QueryInterface(?, %p)\n",
                ppvObj));
    TRY
    {
        olChk(ValidateOutPtrBuffer(ppvObj));
        *ppvObj = NULL;
        olChk(ValidateIid(iid));
        olChk(Validate());
        olChk(CheckReverted());
        if ( IsEqualIID(iid, IID_IStorage) || IsEqualIID(iid, IID_IUnknown) )
        {
            olChk(CExposedDocFile::AddRef());
            *ppvObj = (IStorage*) this;
        }
#ifdef NEWPROPS
        else if (IsEqualIID(iid, IID_IPropertySetStorage))
        {
            olChk(CExposedDocFile::AddRef());
            *ppvObj = (IPropertySetStorage *) this;            
        }
#endif

        else
            olErr(EH_Err, E_NOINTERFACE);
        sc = S_OK;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::QueryInterface => %p\n",
                ppvObj));
EH_Err:
    olLog(("%p::Out CExposedDocFile::QueryInterface().  *ppvObj == %p  ret == %lx\n",
           this, SAFE_DREF(ppvObj), sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Method:     CExposedDocFile::CopyDStreamToIStream, private
//
//  Synopsis:   Copies a CDirectStream to an IStream
//
//  Arguments:  [pstFrom] - CDirectStream
//              [pstTo]   - IStream
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


SCODE CExposedDocFile::CopyDStreamToIStream(CDirectStream *pstFrom,
                                            IStream *pstTo)
{
    BYTE *pbBuffer; 
    SCODE sc; 
    ULONG cbRead, cbWritten;
    ULONGLONG cbPos;
    ULARGE_INTEGER cbSize;

    // This is part of CopyTo and therefore we are allowed to
    // fail with out-of-memory
    olMem(pbBuffer = new BYTE[STREAMBUFFERSIZE]);

    // Set destination size for contiguity
    pstFrom->GetSize(&cbSize.QuadPart);

    //  Don't need to SetAccess0 here because pstTo is an IStream
    olHChk(pstTo->SetSize(cbSize));

    // Copy between streams
    cbPos = 0;
    for (;;)
    {
        olChk(pstFrom->ReadAt(cbPos, pbBuffer, STREAMBUFFERSIZE,
                               (ULONG STACKBASED *)&cbRead));
        if (cbRead == 0) // EOF
            break;

        //  Don't need to SetAccess0 here because pstTo is an IStream
        olHChk(pstTo->Write(pbBuffer, cbRead, &cbWritten));
        if (cbRead != cbWritten)
            olErr(EH_Err, STG_E_WRITEFAULT);
        cbPos += cbWritten;
    }
    sc = S_OK;

EH_Err:
    delete [] pbBuffer;
    return sc;
}

//+--------------------------------------------------------------
//
//  Method:     CExposedDocFile::CopyDocFileToIStorage, private
//
//  Synopsis:   Copies a docfile's contents to an IStorage
//
//  Arguments:  [pdfFrom] - From
//              [pstgTo] - To
//              [snbExclude] - Names to not copy
//              [dwCopyFlags] - Bitwise flags for types of objects to copy
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CExposedDocFile::CopyDocFileToIStorage(CDocFile *pdfFrom,
                                             IStorage *pstgTo,
                                             SNBW snbExclude,
                                             DWORD dwCopyFlags)
{
    PDocFileIterator *pdfi;
    SIterBuffer ib;
    CDirectStream *pstFrom = NULL;
    IStream *pstTo = NULL;
    CDocFile *pdfFromChild = NULL;
    IStorage *pstgToChild = NULL;
    SCODE sc;
    TCHAR atcName[CWCSTORAGENAME];
    CLSID clsid;
    DWORD grfStateBits;

    olDebugOut((DEB_ITRACE, "In  CopyDocFileToIStorage:%p(%p, %p, %p, %lX)\n",
                this, pdfFrom, pstgTo, snbExclude, dwCopyFlags));

    olChk(pdfFrom->GetClass(&clsid));

    olHChk(pstgTo->SetClass(clsid));

    olChk(pdfFrom->GetStateBits(&grfStateBits));

    olHChk(pstgTo->SetStateBits(grfStateBits, 0xffffffff));

    olChk(pdfFrom->GetIterator(&pdfi));

    for (;;)
    {
        sc = pdfi->BufferGetNext(&ib);

        if (sc == STG_E_NOMOREFILES)
            break;
        else if (FAILED(sc))
            olErr(EH_pdfi, sc);

        if (snbExclude && NameInSNB(&ib.dfnName, snbExclude) == S_OK)
            continue;

        if ((ib.type == STGTY_STORAGE && (dwCopyFlags & COPY_STORAGES) == 0) ||
            (ib.type == STGTY_STREAM && (dwCopyFlags & COPY_STREAMS) == 0)
            )
            continue;

        switch(ib.type)
        {
        case STGTY_STORAGE:
            // Embedded DocFile, create destination and recurse

            sc = pdfFrom->GetDocFile(&ib.dfnName, DF_READ,
                                     ib.type, &pdfFromChild);
            olChkTo(EH_pdfi, sc);

            WTOT(atcName, (WCHAR *)ib.dfnName.GetBuffer(), CWCSTORAGENAME);

            //  Don't need to SetAccess0 here because pstgTo is an IStorage.

            sc = DfGetScode(pstgTo->CreateStorage(atcName, STGM_WRITE |
                                                  STGM_SHARE_EXCLUSIVE |
                                                  STGM_FAILIFTHERE,
                                                  0, 0, &pstgToChild));
            if (sc == STG_E_FILEALREADYEXISTS)
                olHChkTo(EH_Get, pstgTo->OpenStorage(atcName, NULL,
                                                     STGM_WRITE |
                                                     STGM_SHARE_EXCLUSIVE,
                                                     NULL, 0, &pstgToChild));
            else if (FAILED(sc))
                olErr(EH_Get, sc);
            olChkTo(EH_Create,
                  CopyDocFileToIStorage(pdfFromChild, pstgToChild, NULL,
                                        dwCopyFlags));
            pdfFromChild->Release();
            pstgToChild->Release();
            break;

        case STGTY_STREAM:
            sc = pdfFrom->GetStream(&ib.dfnName, DF_READ, ib.type, &pstFrom);
            olChkTo(EH_pdfi, sc);
            WTOT(atcName, (WCHAR *)ib.dfnName.GetBuffer(), CWCSTORAGENAME);

            //  Don't need to SetAccess0 here because pstgTo is an IStorage.

            olHChkTo(EH_Get,
                     pstgTo->CreateStream(atcName, STGM_WRITE |
                                          STGM_SHARE_EXCLUSIVE |
                                          STGM_CREATE,
                                          0, 0, &pstTo));
            olChkTo(EH_Create, CopyDStreamToIStream(pstFrom, pstTo));
            pstFrom->Release();
            pstTo->Release();
            break;


        default:
            olAssert(!aMsg("Unknown type in CopyDocFileToIStorage"));
            break;
        }
    }
    pdfi->Release();
    olDebugOut((DEB_ITRACE, "Out CopyDocFileToIStorage\n"));
    return S_OK;

EH_Create:
    if (ib.type == STGTY_STORAGE)
        pstgToChild->Release();
    else
        pstTo->Release();
    olVerSucc(pstgTo->DestroyElement(atcName));
EH_Get:
    if (ib.type == STGTY_STORAGE)
        pdfFromChild->Release();
    else
        pstFrom->Release();
EH_pdfi:
    pdfi->Release();
EH_Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::SwitchToFile, public
//
//  Synopsis:   Switches the underlying file to another file
//
//  Arguments:  [ptcsFile] - New file name
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------


STDMETHODIMP CExposedDocFile::SwitchToFile(TCHAR *ptcsFile)
{
    UNREFERENCED_PARM(ptcsFile);
    olAssert(FALSE && aMsg("Unimplemented Function called!\n"));
    return ResultFromScode(STG_E_UNIMPLEMENTEDFUNCTION);
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateExposedStream, private
//
//  Synopsis:   Creates an Exposed Stream
//              This is a private function that creates the exposed stream.
//              It is splitted out as a function so that the code can be 
//              reused.
//
//  Arguments:  [pdfnName] name of entry
//              [df] doc file flags
//              [ppStream] returned ExposedStream
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------


SCODE CExposedDocFile::CreateExposedStream( CDfName const *pdfnName,
                                            DFLAGS const df,
                                            CExposedStream **ppStream)
{
    CExposedStream *pstExp = NULL;
    CDirectStream *pstDirect = NULL;
    SCODE sc = S_OK;
    
    olChk(CheckReverted());
    if (!P_WRITE(_df)) olErr(EH_Err, STG_E_ACCESSDENIED);
 
    olChk(_cilChildren.IsDenied(pdfnName, df, _df));
    olChk(_pdf->CreateStream(pdfnName, df, DF_NOLUID, &pstDirect));
    
    //  As soon as we have a base we dirty ourself (in case
    //  we get an error later) so that we'll flush properly.
    SetDirty();
    olMemTo(EH_pst, pstExp = new CExposedStream());
    olChkTo(EH_pstExp, pstExp->Init(pstDirect, this, 
                                    df, pdfnName, (ULONG)NULL));
    *ppStream = pstExp;
    return S_OK;

EH_pstExp:
    delete pstExp;
EH_pst:
    pstDirect->Release();
    olVerSucc(DestroyEntry(pdfnName, TRUE));
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::GetExposedStream, private
//
//  Synopsis:   Gets an existing exposed stream
//              This is a private function that gets the exposed stream.
//              It is splitted out as a function so that the code can be 
//              reused.
//
//  Arguments:  [pdfnName] name of entry
//              [df] doc file flags
//              [ppStream] returned ExposedStream
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------


SCODE CExposedDocFile::GetExposedStream( CDfName const *pdfnName,
                                         DFLAGS const df,
                                         CExposedStream **ppStream)
{
    CExposedStream *pstExp = NULL;
    CDirectStream *pstDirect = NULL;
    SCODE sc = S_OK;
    
    olChk(CheckReverted());
    if (!P_READ(_df)) olErr(EH_Err, STG_E_ACCESSDENIED);

    // Check permissions
    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChk(_pdf->GetStream(pdfnName, df, DF_NOLUID, &pstDirect));
    
    olMemTo(EH_pst, pstExp = new CExposedStream());
    olChkTo(EH_pstExp, pstExp->Init(pstDirect, this, 
                                    df, pdfnName, (ULONG)NULL));
    *ppStream = pstExp;
    return S_OK;

EH_pstExp:
    delete pstExp;
EH_pst:
    pstDirect->Release();
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	CExposedDocFile::DestroyEntry, private
//
//  Synopsis:	Destroys an entry and removes it from the children
//              list.
//
//---------------------------------------------------------------
SCODE CExposedDocFile::DestroyEntry( CDfName const *pdfnName, 
                                     BOOL fClean)
{
    SCODE sc=S_OK;
    olChk(CheckReverted());
    if (!P_WRITE(_df)) olErr(EH_Err, STG_E_ACCESSDENIED);

    olChk(_pdf->DestroyEntry(pdfnName, fClean));
    _cilChildren.DeleteByName(pdfnName);
    SetDirty();

    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	CExposedDocFile::CreateExposedDocFile, private
//
//  Synopsis:	Creates an embedded DocFile
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [ppdfDocFile] - New DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//---------------------------------------------------------------

SCODE CExposedDocFile::CreateExposedDocFile(CDfName const *pdfnName,
                                            DFLAGS const df,
                                            CExposedDocFile **ppdfDocFile)
{
    SCODE sc;
    CDocFile *pdf=NULL;
    SEntryBuffer eb;

    olChk(CheckReverted());    

    if (!P_WRITE(_df)) olErr(EH_Err, STG_E_ACCESSDENIED);
    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChkTo(EH_Reserve, _pdf->CreateDocFile(pdfnName, df, DF_NOLUID,
                                            &pdf));

    //  As soon as we have a base we dirty ourself (in case
    //  we get an error later) so that we'll flush properly.
    SetDirty();
    eb.luid = pdf->GetLuid();
    olAssert(eb.luid != DF_NOLUID && aMsg("DocFile id is DF_NOLUID!"));
    olMemTo(EH_pdf,
            *ppdfDocFile = new CExposedDocFile(this, pdf, df, eb.luid,
                    _pilbBase, pdfnName, _pmsBase, _pdfb));
    return S_OK;

EH_pdf:
    pdf->Release();
    olVerSucc(_pdf->DestroyEntry(pdfnName, TRUE));
    return sc;
EH_Reserve:
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	CExposedDocFile::GetExposedDocFile, private
//
//  Synopsis:	Retrieves an embedded DocFile
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [ppdfDocFile] - New DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//---------------------------------------------------------------

SCODE CExposedDocFile::GetExposedDocFile( CDfName const *pdfnName,
                                          DFLAGS const df,
                                          CExposedDocFile **ppdfDocFile)
{
    CDocFile *pdf;
    SCODE sc;
    SEntryBuffer eb;

    olChk(CheckReverted());
    if (!P_READ(_df))    olErr(EH_Err, STG_E_ACCESSDENIED);

    // Check to see if an instance with DENY_* exists
    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChk(_pdf->GetDocFile(pdfnName, df, &pdf));
    eb.luid = pdf->GetLuid();
    olAssert(eb.luid != DF_NOLUID && aMsg("DocFile id is DF_NOLUID!"));
    olMemTo(EH_pdf,
            *ppdfDocFile = new CExposedDocFile(this, pdf, df, eb.luid,
                    _pilbBase, pdfnName, _pmsBase, _pdfb));    
    return S_OK;

EH_pdf:
    pdf->Release();
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::RenameEntry, public
//
//  Synopsis:   Renames an element of a DocFile
//
//  Arguments:  [pdfnName] - Current name
//              [pdfnNewName] - New name
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CExposedDocFile::RenameEntry(CDfName const *pdfnName,
                                   CDfName const *pdfnNewName)
{
    SCODE sc;

    olChk(CheckReverted());
    if (!P_WRITE(_df)) 
        sc = STG_E_ACCESSDENIED;
    else
    {
        sc = _pdf->RenameEntry(pdfnName, pdfnNewName);
        if (SUCCEEDED(sc))
        {
            _cilChildren.RenameChild(pdfnName, pdfnNewName);
            SetDirty();
        }
    }

    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::RevertFromAbove, public virtual from
//                                              PRevertable
//
//  Synopsis:   Parent has asked for reversion
//
//---------------------------------------------------------------

void CExposedDocFile::RevertFromAbove(void)
{
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::RevertFromAbove:%p()\n", this));
    _df |= DF_REVERTED;

    _cilChildren.DeleteByName(NULL);

    _pdf->Release();
#if DBG == 1
    _pdf = NULL;
#endif
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::RevertFromAbove\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::IsAtOrAbove, public
//
//  Synopsis:   Determines whether the given docfile is an ancestor
//              of this docfile
//
//  Arguments:  [pdf] - Docfile to check
//
//  Returns:    TRUE or FALSE
//
//---------------------------------------------------------------

BOOL CExposedDocFile::IsAtOrAbove(CExposedDocFile *pdf)
{
    CExposedDocFile *pdfPar = this;

    olAssert(SUCCEEDED(CheckReverted()));

    do
    {
        if (pdfPar == pdf)
            break;
    }
    while (pdfPar = pdfPar->_pdfParent);
    return pdfPar == pdf;
}

#ifdef NEWPROPS
//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::GetStorage, public IPrivateStorage
//
//  Synopsis:   Returns the IStorage for this object.
//
//  Notes:      This member is called by CPropertyStorage.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(IStorage *)
CExposedDocFile::GetStorage(VOID)
{
    return this;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::FlushBufferedData
//                              : public, virtual : PRevertable
//
//  Synopsis:   Flush buffered data in any child streams.
//
//---------------------------------------------------------------

SCODE CExposedDocFile::FlushBufferedData(void)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, 
                "In CExposedDocFile::FlushBufferedData:%p()\n", this));

    sc = _cilChildren.FlushBufferedData();

    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::FlushBufferedData\n"));

    return sc;
}

#endif  // #ifdef NEWPROPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\expiter.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       expiter.cxx
//
//  Contents:   CExposedIterator implementation
//
//---------------------------------------------------------------

#include "exphead.cxx"

#include "expiter.hxx"
#include "h/sstream.hxx"

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::CExposedIterator, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [ppdf] - Public Docfile
//              [pKey] - Initial cursor (doc file name)
//
//---------------------------------------------------------------

CExposedIterator::CExposedIterator(CExposedDocFile *ppdf, CDfName *pKey)
{
    olDebugOut((DEB_ITRACE, "In  CExposedIterator::CExposedIterator("
            "%p, %p)\n", ppdf, pKey));
    _dfnKey.Set(pKey);
    _ppdf = ppdf;
    // keep a ref, so that the pointer is valid throughout life time
    // of iterator
    _ppdf->AddRef();
    _cReferences = 1;
    _sig = CEXPOSEDITER_SIG;
    olDebugOut((DEB_ITRACE,
                "Out CExposedIterator::CExposedIterator\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::~CExposedIterator, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------

CExposedIterator::~CExposedIterator(void)
{
    olDebugOut((DEB_ITRACE, "In  CExposedIterator::~CExposedIterator\n"));
    _sig = CEXPOSEDITER_SIGDEL;    
    olAssert(_cReferences == 0);    
    if (_ppdf) _ppdf->Release();    
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::~CExposedIterator\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Next, public
//
//  Synopsis:   Gets N entries from an iterator
//
//  Arguments:  [celt] - Count of elements
//              [rgelt] - Array for element return
//              [pceltFetched] - If non-NULL, contains the number of
//                      elements fetched
//
//  Returns:    Appropriate status code
//
//  Modifies:   [rgelt]
//              [pceltFetched]
//
//---------------------------------------------------------------

SCODE CExposedIterator::Next(ULONG celt,
                             STATSTGW FAR *rgelt,
                             ULONG *pceltFetched)
{
    SCODE sc;
    STATSTGW stat, *pelt = rgelt;    
    ULONG celtDone;
    CDfName dfnInitial;

    olDebugOut((DEB_ITRACE, "In CExposedIterator::Next(%lu, %p, %p)\n", 
                celt, rgelt, pceltFetched));
    
    TRY
    {
        if (pceltFetched)
        {
            olChk(ValidateBuffer(pceltFetched, sizeof(ULONG)));
            *pceltFetched = 0;
        }
        else if (celt > 1)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        olAssert(0xffffUL/sizeof(STATSTGW) >= celt);
        olChkTo(EH_RetSc, 
                ValidateOutBuffer(rgelt, sizeof(STATSTGW)*celt));
        memset(rgelt, 0, (size_t)(sizeof(STATSTGW)*celt));
        olChk(Validate());
        olChk(_ppdf->CheckReverted());
            
        dfnInitial.Set(&_dfnKey); // preserve initial key to reset on failure
        for (; pelt<rgelt+celt; pelt++)
        {
            sc = _ppdf->FindGreaterEntry(&_dfnKey, NULL, &stat);
            if (FAILED(sc))
            {
                if (sc == STG_E_NOMOREFILES)   sc = S_FALSE;
                break;
            }
            _dfnKey.Set(stat.pwcsName); // advance key
                
            stat.grfMode = 0;
            stat.grfLocksSupported = 0;
            stat.reserved = 0;
            *pelt = stat;
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    // Can't move this down because dfnInitial isn't set for all EH_Err cases        
    if (FAILED(sc)) _dfnKey.Set(&dfnInitial);
            
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::Next => %lX\n", sc));
EH_Err:
    celtDone = pelt-rgelt;
    if (FAILED(sc))
    {
        ULONG i;

        for (i = 0; i<celtDone; i++)
        delete[] rgelt[i].pwcsName;
        memset(rgelt, 0, (size_t)(sizeof(STATSTGW)*celt));
    }
    else if (pceltFetched)
        *pceltFetched = celtDone;
EH_RetSc:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Skip, public
//
//  Synopsis:   Skips N entries from an iterator
//
//  Arguments:  [celt] - Count of elements
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedIterator::Skip(ULONG celt)
{
    SCODE sc;
    CDfName dfnNext;

    olDebugOut((DEB_ITRACE, "In  CExposedIterator::Skip(%lu)\n", celt));
    TRY
    {
        olChk(Validate());
        olChk(_ppdf->CheckReverted());        
        for (; celt>0; celt--)
        {
            sc = _ppdf->FindGreaterEntry(&_dfnKey, &dfnNext, NULL);
            if (FAILED(sc))
            {
                if (sc == STG_E_NOMOREFILES)
                    sc = S_FALSE;
                break;
            }
            _dfnKey.Set(&dfnNext); // advance the cursor
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::Skip\n"));
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Reset, public
//
//  Synopsis:   Rewinds the iterator
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedIterator::Reset(void)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CExposedIterator::Reset()\n"));

    TRY
    {
        olChk(Validate());        
        _dfnKey.Set((WORD)0, (BYTE*)NULL);  // set to smallest key
        sc = _ppdf->CheckReverted();
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    olDebugOut((DEB_ITRACE, "Out CExposedIterator::Reset\n"));
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Clone, public
//
//  Synopsis:   Clones this iterator
//
//  Arguments:  [ppenm] - Clone return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppenm]
//
//---------------------------------------------------------------

STDMETHODIMP CExposedIterator::Clone(IEnumSTATSTG **ppenm)
{
    SCODE sc;
    CExposedIterator *piExp;

    olDebugOut((DEB_ITRACE, "In  CExposedIterator::Clone(%p)\n", ppenm));
    TRY
    {
	olChk(ValidateOutPtrBuffer(ppenm));
	*ppenm = NULL;
	olChk(Validate());
        olChk(_ppdf->CheckReverted());
        olMem(piExp = new CExposedIterator(_ppdf, &_dfnKey));
	*ppenm = piExp;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::Clone => %p\n",
                SAFE_DREF(ppenm)));
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Release, public
//
//  Synopsis:   Releases resources for the iterator
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CExposedIterator::Release(void)
{
    ULONG lRet;

    olDebugOut((DEB_ITRACE, "In  CExposedIterator::Release()\n"));
    TRY
    {
        if (FAILED(Validate()))
            return 0;
        olAssert(_cReferences > 0);
        lRet = --(_cReferences);
        if (_cReferences <= 0)
            delete this;
    }
    CATCH(CException, e)
    {
        UNREFERENCED_PARM(e);
        lRet = 0;
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::Release\n"));
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CExposedIterator::AddRef(void)
{
    ULONG ulRet;

    olDebugOut((DEB_ITRACE, "In  CExposedIterator::AddRef()\n"));
    TRY
    {
        if (FAILED(Validate())) return 0;
        ulRet = ++(_cReferences);
    }
    CATCH(CException, e)
    {
        UNREFERENCED_PARM(e);
        ulRet = 0;
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::AddRef\n"));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//---------------------------------------------------------------

STDMETHODIMP CExposedIterator::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CExposedIterator::QueryInterface(?, %p)\n",
                ppvObj));
    TRY
    {
        olChk(Validate());
        olChk(ValidateOutPtrBuffer(ppvObj));
        *ppvObj = NULL;
        olChk(_ppdf->CheckReverted());
        olChk(ValidateIid(iid));
        if (IsEqualIID(iid, IID_IEnumSTATSTG) || IsEqualIID(iid, IID_IUnknown))
        {
            *ppvObj = this;
            AddRef();
            sc = S_OK;
        }
        else 
        {
            sc = E_NOINTERFACE;
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::QueryInterface => %p\n",
                SAFE_DREF(ppvObj)));
EH_Err:
    return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\iter.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       iter.cxx
//
//  Contents:   CDocFileIterator implementation
//
//---------------------------------------------------------------

#include "dfhead.cxx"


#include "h/msfiter.hxx"
#include "iter.hxx"



//+--------------------------------------------------------------
//
//  Member:     CDocFileIterator::CDocFileIterator, public
//
//  Synopsis:   Empty object ctor
//
//---------------------------------------------------------------

CDocFileIterator::CDocFileIterator(void)
{
    olDebugOut((DEB_ITRACE, "In  CDocFileIterator::CDocFileIterator()\n"));
    _pi = NULL;
    olDebugOut((DEB_ITRACE, "Out CDocFileIterator::CDocFileIterator\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CDocFileIterator::Init
//
//  Synopsis:   Constructor
//
//  Arguments:  [ph] - Multistream handle
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CDocFileIterator::Init(CStgHandle *ph)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFileIterator::Init(%p)\n", ph));
    if (FAILED(sc = ph->GetIterator(&_pi)))
        _pi = NULL;
    olDebugOut((DEB_ITRACE, "Out CDocFileIterator::Init\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFileIterator::~CDocFileIterator
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------

CDocFileIterator::~CDocFileIterator(void)
{
    olDebugOut((DEB_ITRACE, "In  CDocFileIterator::~CDocFileIterator\n"));
    if (_pi)
        _pi->Release();
    olDebugOut((DEB_ITRACE, "Out CDocFileIterator::~CDocFileIterator\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CDocFileIterator::GetNext
//
//  Synopsis:   Get the next entry
//
//  Arguments:  [pstatstg] - Buffer to return information in
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//---------------------------------------------------------------


SCODE CDocFileIterator::GetNext(STATSTGW *pstatstg)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFileIterator::GetNext(%p)\n", pstatstg));

    if (FAILED(sc = _pi->GetNext(pstatstg)))
    {
#if DEVL == 1
        // Null the name to clean up some debug prints
        pstatstg->pwcsName = NULL;
#endif
    }

    olDebugOut((DEB_ITRACE, "Out CDocFileIterator::GetNext => %ws, %ld\n",
                pstatstg->pwcsName, pstatstg->type));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFileIterator::BufferGetNext, public
//
//  Synopsis:   Fast, fixed-space version of GetNext
//
//  Arguments:  [pib] - Buffer to fill in
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pib]
//
//---------------------------------------------------------------


SCODE CDocFileIterator::BufferGetNext(SIterBuffer *pib)
{
    return _pi->BufferGetNext(pib);
}


//+--------------------------------------------------------------
//
//  Member:     CDocFileIterator::Release, public
//
//  Synopsis:   Releases resources for an iterator
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

void CDocFileIterator::Release(void)
{
    olDebugOut((DEB_ITRACE, "In  CDocFileIterator::Release()\n"));
    delete this;
    olDebugOut((DEB_ITRACE, "Out CDocFileIterator::Release\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\funcs.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       funcs.cxx
//
//  Contents:   Generic DocFile support functions
//
//  Functions:  ModeToTFlags
//              CheckName
//              wcsdup
//              VerifyPerms
//
//---------------------------------------------------------------

#include "dfhead.cxx"

//+--------------------------------------------------------------
//
//  Function:   ModeToDFlags, private
//
//  Synopsis:   Translates STGM flags to DF flags
//
//  Arguments:  [dwModeFlags]
//
//  Returns:    DF_*
//
//---------------------------------------------------------------

DFLAGS ModeToDFlags(DWORD const dwModeFlags)
{
    DFLAGS df;

    olDebugOut((DEB_ITRACE, "In  ModeToDFlags(%lX)\n", dwModeFlags));
    if ((dwModeFlags & STGM_TRANSACTED) == 0)
        df = DF_DIRECT;
    else
        df = DF_TRANSACTED;
    if ((dwModeFlags & STGM_TRANSACTED) &&
        (dwModeFlags & STGM_PRIORITY) == 0 &&
        (dwModeFlags & STGM_DENY) != STGM_SHARE_DENY_WRITE &&
        (dwModeFlags & STGM_DENY) != STGM_SHARE_EXCLUSIVE)
        df |= DF_INDEPENDENT;
    switch(dwModeFlags & STGM_RDWR)
    {
    case STGM_READ:
        df |= DF_READ;
        break;
    case STGM_WRITE:
        df |= DF_WRITE;
        break;
    case STGM_READWRITE:
        df |= DF_READWRITE;
        break;
    default:
        olAssert(FALSE);
        break;
    }
    switch(dwModeFlags & STGM_DENY)
    {
    case STGM_SHARE_DENY_READ:
        df |= DF_DENYREAD;
        break;
    case STGM_SHARE_DENY_WRITE:
        df |= DF_DENYWRITE;
        break;
    case STGM_SHARE_EXCLUSIVE:
        df |= DF_DENYALL;
        break;
        // Default is deny none
    }
    if (dwModeFlags & STGM_PRIORITY)
        df |= DF_PRIORITY;
    olDebugOut((DEB_ITRACE, "Out ModeToDFlags => %lX\n", df));
    return df;
}

//+--------------------------------------------------------------
//
//  Function:   DFlagsToMode, private
//
//  Synopsis:   Converts the read/write/denials/transacted/priority
//              to STGM flags
//
//  Arguments:  [df] - DFlags
//
//  Returns:    STGM flags
//
//---------------------------------------------------------------

DWORD DFlagsToMode(DFLAGS const df)
{
    DWORD dwMode;

    olDebugOut((DEB_ITRACE, "In  DFlagsToMode(%X)\n", df));
    if (P_READ(df))
        if (P_WRITE(df))
            dwMode = STGM_READWRITE;
        else
            dwMode = STGM_READ;
    else if (P_WRITE(df))
        dwMode = STGM_WRITE;
    // Must have either read or write, so no else

    if (P_DENYREAD(df))
        if (P_DENYWRITE(df))
            dwMode |= STGM_SHARE_EXCLUSIVE;
        else
            dwMode |= STGM_SHARE_DENY_READ;
    else if (P_DENYWRITE(df))
        dwMode |= STGM_SHARE_DENY_WRITE;
    else
        dwMode |= STGM_SHARE_DENY_NONE;

    if (P_TRANSACTED(df))
        dwMode |= STGM_TRANSACTED;

    if (P_PRIORITY(df))
        dwMode |= STGM_PRIORITY;

    olDebugOut((DEB_ITRACE, "Out DFlagsToMode\n"));
    return dwMode;
}

//+--------------------------------------------------------------
//
//  Function:   VerifyPerms, private
//
//  Synopsis:   Checks flags to see if they are valid
//
//  Arguments:  [grfMode] - Permissions
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE VerifyPerms(DWORD grfMode)
{
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  VerifyPerms(%lX)\n", grfMode));

    // Check for valid flags
    if ((grfMode & STGM_RDWR) > STGM_READWRITE ||
        (grfMode & STGM_DENY) > STGM_SHARE_DENY_NONE ||
        (grfMode & ~(STGM_RDWR | STGM_DENY | STGM_DIRECT | STGM_TRANSACTED |
                     STGM_PRIORITY | STGM_CREATE | STGM_CONVERT |
                     STGM_FAILIFTHERE | STGM_DELETEONRELEASE)))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    // We don't support these modes
    if (grfMode & (STGM_PRIORITY|STGM_TRANSACTED|STGM_SIMPLE))
    {
        olAssert( FALSE && 
            aMsg("Unsupported feature of reference implemention called"));
        return STG_E_INVALIDFUNCTION;
    }
    
    // Check to make sure only one existence flag is specified
    // FAILIFTHERE is zero so it can't be checked
    if ((grfMode & (STGM_CREATE | STGM_CONVERT)) ==
        (STGM_CREATE | STGM_CONVERT))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    // If not transacted and not priority, you can either be
    // read-only deny write or read-write deny all
    if ((grfMode & (STGM_TRANSACTED | STGM_PRIORITY)) == 0)
    {
        if ((grfMode & STGM_RDWR) == STGM_READ)
        {
            //  we're asking for read-only access

            if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE &&
                (grfMode & STGM_DENY) != STGM_SHARE_DENY_WRITE)
            {
                //  Can't allow others to have write access
                olErr(EH_Err, STG_E_INVALIDFLAG);
            }
        }
        else
        {
            //  we're asking for write access

            if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE)
            {
                //  Can't allow others to have any access
                olErr(EH_Err, STG_E_INVALIDFLAG);
            }
        }
    }
    olDebugOut((DEB_ITRACE, "Out VerifyPerms\n"));
    // Fall through
EH_Err:
    return sc;
}



//+--------------------------------------------------------------
//
//  Function:   wcsdup, public
//
//  Synopsis:   Duplicates a WCHAR string
//
//  Arguments:  [pwcs] - String
//
//  Returns:    Pointer to new string or Appropriate status code
//
//---------------------------------------------------------------

WCHAR * __cdecl wcsdup(WCHAR const *pwcs)
{
    WCHAR *pwcsNew;

    olDebugOut((DEB_ITRACE, "In  wcsdup(%ws)\n", pwcs));
    pwcsNew = new WCHAR[wcslen(pwcs)+1];
    if (pwcsNew == NULL)
        return NULL;
    wcscpy(pwcsNew, pwcs);
    olDebugOut((DEB_ITRACE, "Out wcsdup => %p\n", pwcsNew));
    return pwcsNew;
}



//+--------------------------------------------------------------
//
//  Function:   ValidateSNBW
//
//  Synopsis:   Validates SNB memory
//
//  Arguments:  [snb] - SNB
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------
#ifdef _UNICODE
SCODE ValidateSNBW(SNBW snb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  ValidateSNB(%p)\n", snb));
    for (;;)
    {
        olChk(ValidatePtrBuffer(snb));
        if (*snb == NULL)
            break;
        olChk(ValidateNameW(*snb, CWCMAXPATHCOMPLEN));
        snb++;
    }
    olDebugOut((DEB_ITRACE, "Out ValidateSNB\n"));
    return S_OK;
EH_Err:
    return sc;
}
#endif // ifdef _UNICODE
//+--------------------------------------------------------------
//
//  Function:   CheckWName, public
//
//  Synopsis:   Checks name for illegal characters and length
//
//  Arguments:  [pwcsName] - Name
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

#ifdef _UNICODE
WCHAR wcsInvalid[] = { '\\', '/', ':', '!','\0' };

SCODE CheckWName(WCHAR const *pwcsName)
{
    SCODE sc;
    olDebugOut((DEB_ITRACE, "In  CheckWName(%s)\n", pwcsName));
    if (FAILED(sc = ValidateNameW(pwcsName, CBMAXPATHCOMPLEN)))
        return sc;
    // >= is used because the max len includes the null terminator
    if (wcslen(pwcsName) >= CWCMAXPATHCOMPLEN)
        return STG_E_INVALIDNAME;
    for (; *pwcsName; pwcsName++)
    {
        if ( wcschr(wcsInvalid, *pwcsName) )
            return STG_E_INVALIDNAME;
    }
    olDebugOut((DEB_ITRACE, "Out CheckWName\n"));
    return S_OK;
} 
#else  // validation done in ascii layer already

#define CheckWName(pwcsName) (S_OK)

#endif // ifdef _UNICODE

//+--------------------------------------------------------------
//
//  Function:   CopyDStreamToDStream
//
//  Synopsis:   Copies the contents of a stream to another stream
//
//  Arguments:  [pstFrom] - Stream to copy from
//              [pstTo] - Stream to copy to
//
//  Returns:    Appropriate status code
//
//  Notes:      This function may fail due to out of memory.  It
//              may not be used by callers who must not fail due
//              to out of memory.
//
//              This function does not check permissions
//              for write in the to streams.
//
//---------------------------------------------------------------

SCODE CopyStreamToStream(CDirectStream *pstFrom, 
                         CDirectStream *pstTo)
{
    BYTE *pbBuffer;
    SCODE sc;
    ULONG cbRead, cbWritten;
    ULONGLONG cbSize, cbPos;

    // Set destination size for contiguity    
    pstFrom->GetSize(&cbSize);
    olChk(pstTo->SetSize(cbSize));

    // We're allowed to fail due to out of memory
    olMem(pbBuffer = new BYTE[STREAMBUFFERSIZE]);

    // Copy between streams
    cbPos = 0;
    for (;;)
    {
        olChkTo(EH_pbBuffer,
                pstFrom->ReadAt(cbPos, pbBuffer, STREAMBUFFERSIZE,
                                 (ULONG STACKBASED *)&cbRead));
        if (cbRead == 0) // EOF
            break;
        olChkTo(EH_pbBuffer,
                pstTo->WriteAt(cbPos, pbBuffer, cbRead,
                                (ULONG STACKBASED *)&cbWritten));
        if (cbRead != cbWritten)
            olErr(EH_Err, STG_E_WRITEFAULT);
        cbPos += cbWritten;
    }
    delete pbBuffer;
    return S_OK;

EH_pbBuffer:
    delete pbBuffer;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   NameInSNB, private
//
//  Synopsis:   Determines whether the given name is in the SNB
//
//  Arguments:  [dfn] - Name
//              [snb] - SNB
//
//  Returns:    S_OK or S_FALSE
//
//---------------------------------------------------------------

SCODE NameInSNB(CDfName const *dfn, SNBW snb)
{
    SCODE sc = S_FALSE;

    olDebugOut((DEB_ITRACE, "In  NameInSNB(%ws, %p)\n", dfn, snb));
    TRY
    {
        for (; *snb; snb++)
            if (dfwcsnicmp((WCHAR *)dfn->GetBuffer(), (WCHAR *)*snb,
                dfn->GetLength()) == 0)
            {
                sc = S_OK;
                break;
            }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out NameInSNB\n"));
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\header.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       header.cxx
//
//  Contents:   Code to manage MSF header
//
//  Classes:    Defined in header.hxx
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#include "h/dfver.h"

// Function set [uArg] to the byte order of the machine.
//
// it will return 0xFFFE on Little Endian (== the disk order)
// and 0xFEFF on Big Endian

const BYTE abDiskByteOrder[]= {0xFE, 0xFF};

inline void SetMachineByteOrder(USHORT *pUShort)
{
    memcpy(pUShort, abDiskByteOrder, sizeof(abDiskByteOrder));
}

CMSFHeader::CMSFHeader(USHORT uSectorShift)
{
    msfAssert((CSECTFATREAL != CSECTFAT) || (sizeof(CMSFHeader) == HEADERSIZE));
    _uSectorShift = uSectorShift;
    _uMiniSectorShift = MINISECTORSHIFT;
    _ulMiniSectorCutoff = MINISTREAMSIZE;

    _clid = IID_NULL;

    SetMachineByteOrder(&_uByteOrder);

    _uMinorVersion = rmm;
    _uDllVersion = (USHORT) (uSectorShift > SECTORSHIFT512 ? rmjlarge : rmj);

    for (SECT sect = 0; sect < CSECTFAT; sect ++)
    {
        _sectFat[sect] = FREESECT;
    }

    SetDifLength(0);
    SetDifStart(ENDOFCHAIN);

    SetFatLength(1);
    SetFatStart(SECTFAT);
    SetDirStart(SECTDIR);

    SetMiniFatLength(0);
    SetMiniFatStart(ENDOFCHAIN);

    _signature = 0;
    _usReserved = 0;
    _ulReserved1 = 0;
    _csectDir = (uSectorShift > SECTORSHIFT512) ? 1 : 0;

    //  Write DocFile signature
    memcpy(abSig, SIGSTG, CBSIGSTG);
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckSignature, private
//
//  Synopsis:   Checks the given memory against known signatures
//
//  Arguments:  [pb] - Pointer to memory to check
//
//  Returns:    S_OK - Current signature
//              S_FALSE - Beta 2 signature, but still successful
//              Appropriate status code
//
//----------------------------------------------------------------------------

//Identifier for first bytes of Beta 2 Docfiles
const BYTE SIGSTG_B2[] = {0x0e, 0x11, 0xfc, 0x0d, 0xd0, 0xcf, 0x11, 0xe0};
const BYTE CBSIGSTG_B2 = sizeof(SIGSTG_B2);

SCODE CheckSignature(BYTE *pb)
{
    SCODE sc;

    msfDebugOut((DEB_ITRACE, "In  CheckSignature(%p)\n", pb));

    // Check for ship Docfile signature first
    if (memcmp(pb, SIGSTG, CBSIGSTG) == 0)
        sc = S_OK;

    // Check for Beta 2 Docfile signature
    else if (memcmp(pb, SIGSTG_B2, CBSIGSTG_B2) == 0)
        sc = S_FALSE;

    else
        sc = STG_E_INVALIDHEADER;

    msfDebugOut((DEB_ITRACE, "Out CheckSignature => %lX\n", sc));
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMSFHeader::Validate, public
//
//  Synopsis:   Validate a header.
//
//  Returns:    S_OK if header is valid.
//
//--------------------------------------------------------------------------

SCODE CMSFHeader::Validate(VOID) const
{
    SCODE sc;
    USHORT uShift;

    sc = CheckSignature((BYTE *)abSig);
    if (sc == S_OK)
    {
        uShift = GetSectorShift();

        // Check file format verson number
        if (GetDllVersion() > rmjlarge)
            return STG_E_OLDDLL;

        // check for invalid sector shifts
        if ((uShift != SECTORSHIFT512 && uShift != SECTORSHIFT4K) ||
            GetMiniSectorShift() != MINISECTORSHIFT )
        {
            return STG_E_DOCFILECORRUPT;
        }
    }
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\expst.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       expst.cxx
//
//  Contents:   CExposedStream code
//
//  Notes:      See the header file expst.hxx for details
//
//--------------------------------------------------------------------------

#include "exphead.cxx"

#include "expst.hxx"
#include "logfile.hxx"

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::CExposedStream, public
//
//  Synopsis:   Empty object constructor
//
//---------------------------------------------------------------


CExposedStream::CExposedStream()
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::CExposedStream()\n"));
    _cReferences = 0;
    _ulAccessLockBase = 0;
    _ulPos = 0;
    _pst = NULL;
    _pdfParent = NULL;
    _fDirty = FALSE;
#ifdef NEWPROPS
    _pb = NULL;
    _cbUsed = 0;
    _cbOriginalStreamSize = 0;
    _fChangePending = FALSE;
#endif

    olDebugOut((DEB_ITRACE, "Out CExposedStream::CExposedStream\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Init, public
//
//  Synopsis:   Base constructor
//
//  Arguments:  [pst] - Direct stream
//              [pdfParent] - the storage parent
//              [df]  - Permission flags
//              [pdfn] - name of stream
//              [ulPos] - offset
//
//  Returns:    Appropriate status code
//  
//  Note:       We add "this" as a child to the parent to
//              1) Check for multiple instantiation of a child
//              2) Uses the RevertFromAbove() function to check
//                 for reverted state.
//
//---------------------------------------------------------------

SCODE CExposedStream::Init(CDirectStream *pst,
                           CExposedDocFile* pdfParent,
                           const DFLAGS df,
                           const CDfName *pdfn,
                           const ULONGLONG ulPos)
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Init("
                "%p, %lu)\n", pst, ulPos));    
    _ulPos = ulPos;
    _pst = pst;
    _pdfParent = pdfParent;
    _df = df;
    _dfn.Set(pdfn->GetLength(), pdfn->GetBuffer());
    olAssert(pdfParent);
    _pdfParent->AddChild(this);
    _cReferences = 1;
    _sig = CEXPOSEDSTREAM_SIG;
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Init\n"));
    return S_OK;
}


//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Read, public
//
//  Synopsis:   Read from a stream
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return number of bytes read
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Read(VOID HUGEP *pb, ULONG cb, ULONG *pcbRead)
{
    SCODE sc;
    ULONG cbRead = 0;

    olLog(("%p::In  CExposedStream::Read(%p, %lu, %p)\n",
           this, pb, cb, pcbRead));
    olDebugOut((DEB_ITRACE, "In CExposedStream::Read(%p,%lu,%p)\n",
                 pb, cb, pcbRead));
    TRY
    {
        if (pcbRead)
            olChkTo(EH_BadPtr, ValidateOutBuffer(pcbRead, sizeof(ULONG)));
        olChk(ValidateHugeOutBuffer(pb, cb));
        olChk(Validate());
        olChk(CheckReverted());

        if (!P_READ(_df))
            sc = STG_E_ACCESSDENIED;
        else
            sc = _pst->ReadAt(_ulPos, pb, cb,
                              (ULONG STACKBASED *)&cbRead);
        _ulPos+=cbRead;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Read => %lu\n", cbRead));

EH_Err:
    if (pcbRead)
    {
        *pcbRead = cbRead;
        olLog(("%p::Out CExposedStream::Read() *pcbRead==%lu, ret=%lx\n",
               this, SAFE_DREF(pcbRead), sc));
    }
    else
    {
        olLog(("%p::Out CExposedStream::Read().  ret == %lx\n", this, sc));
    }

EH_BadPtr:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Write, public
//
//  Synopsis:   Write to a stream
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to write
//              [pcbWritten] - Return of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbWritten]
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Write(
        VOID const HUGEP *pb,
        ULONG cb,
        ULONG *pcbWritten)
{
    SCODE sc;
    ULONG cbWritten = 0;

    olLog(("%p::In  CExposedStream::Write(%p, %lu, %p)\n",
           this, pb, cb, pcbWritten));
    olDebugOut((DEB_ITRACE, 
                "In CExposedStream::Write(%p, %lu, %p)\n",
                pb, cb, pcbWritten));
    TRY
    {
        if (pcbWritten)
        {
            olChkTo(EH_BadPtr, 
                    ValidateOutBuffer(pcbWritten, sizeof(ULONG)));
        }
        olChk(ValidateHugeBuffer(pb, cb));
        olChk(Validate());
        olChk(CheckReverted());
        if (!P_WRITE(_df))
            sc = STG_E_ACCESSDENIED;
        else
        {
            sc = _pst->WriteAt(_ulPos, pb, cb,
                               (ULONG STACKBASED *)&cbWritten);
            if (SUCCEEDED(sc))
                SetDirty();
        }
        _ulPos += cbWritten;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Write => %lu\n",
                cbWritten));
EH_Err:
    if (pcbWritten)
    {
        *pcbWritten = cbWritten;
        olLog(("%p::Out CExposedStream::Write().  *pcbWritten == %lu, ret = %lx\n",
               this, *pcbWritten, sc));
    }
    else
    {
        olLog(("%p::Out CExposedStream::Write().  ret == %lx\n",this, sc));
    }

EH_BadPtr:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Seek, public
//
//  Synopsis:   Seek to a point in a stream
//
//  Arguments:  [dlibMove] - Offset to move by
//              [dwOrigin] - SEEK_SET, SEEK_CUR, SEEK_END
//              [plibNewPosition] - Return of new offset
//
//  Returns:    Appropriate status code
//
//  Modifies:   [plibNewPosition]
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Seek(LARGE_INTEGER dlibMove,
                                  DWORD dwOrigin,
                                  ULARGE_INTEGER *plibNewPosition)
{
    SCODE sc;
    LONGLONG lMove;
    ULARGE_INTEGER ulPos;

    olDebugOut((DEB_ITRACE, "In  CExposedStream::Seek(%ld%ld, %lu, %p)\n",
                dlibMove.QuadPart, dwOrigin, plibNewPosition));
    TRY
    {
        if (plibNewPosition)
        {
            olChk(ValidateOutBuffer(plibNewPosition, sizeof(ULARGE_INTEGER)));
            ULISet32(*plibNewPosition, 0);
        }
        if (dwOrigin != STREAM_SEEK_SET && dwOrigin != STREAM_SEEK_CUR &&
            dwOrigin != STREAM_SEEK_END)
            olErr(EH_Err, STG_E_INVALIDFUNCTION);

        lMove = dlibMove.QuadPart;
        olChk(Validate());
        olChk(CheckReverted());
        ULISet32(ulPos, _ulPos);
        switch(dwOrigin)
        {
        case STREAM_SEEK_SET:
            ulPos.QuadPart = lMove;
            break;
        case STREAM_SEEK_END:
            ULONGLONG cbSize;
            olChk(GetSize(&cbSize));
            if (lMove < 0)
            {
                if ((ULONGLONG)(-lMove) > cbSize)
                    olErr(EH_Err, STG_E_INVALIDFUNCTION);
            }
            ulPos.QuadPart = cbSize+lMove;
            break;
        case STREAM_SEEK_CUR:
            if (lMove < 0)
            {
                if ((ULONGLONG)(-lMove) > _ulPos)
                    olErr(EH_Err, STG_E_INVALIDFUNCTION);
            }
            ulPos.QuadPart = _ulPos+lMove;
            break;
        }
        _ulPos = ulPos.QuadPart;
        if (plibNewPosition)
            *plibNewPosition = ulPos;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Seek => %lu%lu\n",
                ulPos.QuadPart));
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::SetSize, public
//
//  Synopsis:   Sets the size of a stream
//
//  Arguments:  [ulNewSize] - New size
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------
SCODE CExposedStream::SetSize(ULONGLONG cb)
{    
    olDebugOut((DEB_ITRACE, "In CExposedStream::SetSize(%lu%lu)\n", cb));
    SCODE sc;
    TRY
    {
        olChk(Validate());
        olChk(CheckReverted());
        if (!P_WRITE(_df))
            sc = STG_E_ACCESSDENIED;
        else
        {
            olChk(_pst->SetSize(cb));
            SetDirty();
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

EH_Err:    
    olDebugOut((DEB_ITRACE, "Out  CExposedStream::SetSize()\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::SetSize, public
//
//  Synopsis:   Sets the size of a stream
//
//  Arguments:  [ulNewSize] - New size
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedStream::SetSize(ULARGE_INTEGER ulNewSize)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CExposedStream::SetSize(%lu%lu)\n",
                ulNewSize.QuadPart));
    TRY
    {
        olChk(SetSize(ulNewSize.QuadPart));
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::SetSize\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::SetSize().  ret == %lx\n", this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::CopyTo, public
//
//  Synopsis:   Copies information from one stream to another
//
//  Arguments:  [pstm] - Destination
//              [cb] - Number of bytes to copy
//              [pcbRead] - Return number of bytes read
//              [pcbWritten] - Return number of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//              [pcbWritten]
//
//  Notes:      We do our best to handle overlap correctly.  This allows
//              CopyTo to be used to insert and remove space within a
//              stream.
//
//              In the error case, we make no gurantees as to the
//              validity of pcbRead, pcbWritten, or either stream's
//              seek position.
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::CopyTo(IStream *pstm,
                                    ULARGE_INTEGER cb,
                                    ULARGE_INTEGER *pcbRead,
                                    ULARGE_INTEGER *pcbWritten)
{
    SCODE sc;
    ULONGLONG ulCopySize;
    ULONGLONG ulSrcSize;
    ULONGLONG ulSrcOrig;
    ULARGE_INTEGER uliDestOrig;
    LARGE_INTEGER liDestPos;
    BYTE *pb = NULL;
    BOOL fOverlap;
    ULONG ulBytesCopied = 0;

    olDebugOut((DEB_TRACE, "In  CExposedStream::CopyTo("
                "%p, %lu%lu, %p, %p)\n", pstm, cb.QuadPart,
                pcbRead, pcbWritten));

    TRY
    {        
        if (pcbRead) // okay to set to NULL => not interested
        {
            olChk(ValidateOutBuffer(pcbRead, sizeof(ULARGE_INTEGER)));
            ULISet32(*pcbRead, 0);
        }
        if (pcbWritten) // okay to set to NULL => not interested
        {
            olChk(ValidateOutBuffer(pcbWritten, sizeof(ULARGE_INTEGER)));
            ULISet32(*pcbWritten, 0);
        }

        olChk(ValidateInterface(pstm, IID_IStream));
        olChk(Validate());
        olChk(CheckReverted());

        ulCopySize = cb.QuadPart;

        //  We can only copy what's available in the source stream
        
        olChk(GetSize(&ulSrcSize));

        ulSrcOrig = _ulPos;
        if (ulSrcSize < ulSrcOrig)
        {
            //  Nothing in source to copy
            ulCopySize = 0;
        }
        else if ((ulSrcSize - ulSrcOrig) < ulCopySize)
        {
            //  Shrink ulCopySize to fit bytes in source
            ulCopySize = ulSrcSize - ulSrcOrig;
        }

        //  3.  We can only copy what will fit in the destination

        LISet32(liDestPos, 0);
        olHChk(pstm->Seek(liDestPos, STREAM_SEEK_CUR, &uliDestOrig));

        //  We are allowed to fail here with out-of-memory
        olMem(pb = new BYTE[STREAMBUFFERSIZE]);

        // Since we have no reliable way to determine if the source and
        // destination represent the same stream, we assume they
        // do and always handle overlap.

        fOverlap = (uliDestOrig.QuadPart > ulSrcOrig &&
                    uliDestOrig.QuadPart < ulSrcOrig + ulCopySize);

        ULONGLONG ulSrcCopyOffset = 0;
        ULONGLONG ulDstCopyOffset = 0;
        if (fOverlap)
        {
            //  We're going to copy back to front, so determine the
            //  stream end positions
            ulSrcCopyOffset = ulSrcOrig + ulCopySize;

            //  uliDestOrig is the destination starting offset
            ulDstCopyOffset = uliDestOrig.QuadPart + ulCopySize;
        }

        while (ulCopySize > 0)
        {
            //  We can only copy up to STREAMBUFFERSIZE bytes at a time
            ULONG cbPart = (ULONG) min(ulCopySize, STREAMBUFFERSIZE);

            if (fOverlap)
            {
                //  We're copying back to front so we need to seek to
                //  set up the streams correctly

                ulSrcCopyOffset -= cbPart;
                ulDstCopyOffset -= cbPart;

                //  Set source stream position
                _ulPos = ulSrcCopyOffset;

                //  Set destination stream position
                liDestPos.QuadPart = ulDstCopyOffset;
                olHChk(pstm->Seek(liDestPos, STREAM_SEEK_SET, NULL));
            }

            {
                ULONG ulRead;
                olHChk(Read(pb, cbPart, &ulRead));
                if (cbPart != ulRead)
                {
                    //  There was no error, but we were unable to read cbPart
                    //  bytes.  Something's wrong (the underlying ILockBytes?)
                    //  but we can't control it;  just return an error.
                    olErr(EH_Err, STG_E_READFAULT);
                }
            }


            {
                ULONG ulWritten;
                olHChk(pstm->Write(pb, cbPart, &ulWritten));
                if (cbPart != ulWritten)
                {
                    //  There was no error, but we were unable to write
                    //  ulWritten bytes.  We can't trust the pstm
                    //  implementation, so all we can do here is return
                    //  an error.
                    olErr(EH_Err, STG_E_WRITEFAULT);
                }
            }

            olAssert(ulCopySize >= cbPart);
            ulCopySize -= cbPart;
            ulBytesCopied += cbPart;
        }

        if (fOverlap)
        {
            //  Set the seek pointers to the correct location
            _ulPos = ulSrcOrig + ulBytesCopied;

            liDestPos.QuadPart = uliDestOrig.QuadPart + ulBytesCopied;
            olHChk(pstm->Seek(liDestPos, STREAM_SEEK_SET, NULL));
        }

        if (pcbRead)
            ULISet32(*pcbRead, ulBytesCopied);
        if (pcbWritten)
            ULISet32(*pcbWritten, ulBytesCopied);
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::CopyTo => %lu, %lu\n",
                pcbRead ? pcbRead->QuadPart : 0,
                pcbWritten ? pcbWritten->QuadPart : 0));
    // Fall through
EH_Err:
    delete [] pb;
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Release, public
//
//  Synopsis:   Releases a stream
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedStream::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CExposedStream::Release()\n", this));
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Release()\n"));
    TRY
    {
        if (FAILED(Validate()))
            return 0;
        olAssert(_cReferences > 0);
        lRet = AtomicDec(&_cReferences);
        if (lRet == 0)
        {
            Commit(0); //  flush data
            delete this;
        }
        else if (lRet < 0)
            lRet = 0;
    }
    CATCH(CException, e)
    {
        UNREFERENCED_PARM(e);
        lRet = 0;
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Release\n"));
    olLog(("%p::Out CExposedStream::Release().  ret == %lu\n", this, lRet));
    FreeLogFile();
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//---------------------------------------------------------------

 
STDMETHODIMP_(SCODE) CExposedStream::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;

    olLog(("%p::In  CExposedStream::Stat(%p)\n", this, pstatstg));
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Stat(%p)\n",
                pstatstg));
    TRY
    {
        olChkTo(EH_RetSc, ValidateOutBuffer(pstatstg, sizeof(STATSTGW)));
        olChk(VerifyStatFlag(grfStatFlag));
        olChk(Validate());
        olChk(CheckReverted());
        pstatstg->grfMode = DFlagsToMode(_df);

        pstatstg->clsid = CLSID_NULL;  // irrelevant for streams
        pstatstg->grfStateBits = 0;    // irrelevant for streams
        pstatstg->type = STGTY_STREAM;
        pstatstg->grfLocksSupported = 0;
        pstatstg->reserved = 0;

        // we null these values 'cos they are not interesting for
        // direct streams ...
        pstatstg->ctime.dwLowDateTime = pstatstg->ctime.dwHighDateTime = 0;
        pstatstg->mtime.dwLowDateTime = pstatstg->mtime.dwHighDateTime = 0;
        pstatstg->atime.dwLowDateTime = pstatstg->atime.dwHighDateTime = 0;
        pstatstg->pwcsName = NULL;
        if ((grfStatFlag & STATFLAG_NONAME) == 0)
        {                       // fill in name
            olChk(DfAllocWCS((WCHAR *)_dfn.GetBuffer(), 
                             &pstatstg->pwcsName));
            wcscpy(pstatstg->pwcsName, (WCHAR *)_dfn.GetBuffer());
        }
        ULONGLONG cbSize;
        GetSize(&cbSize);
        pstatstg->cbSize.QuadPart = cbSize;        
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Stat\n"));
EH_Err:
    if (FAILED(sc))
        memset(pstatstg, 0, sizeof(STATSTGW));
EH_RetSc:
    olLog(("%p::Out CExposedStream::Stat().  ret == %lx\n",
           this, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Clone, public
//
//  Synopsis:   Clones a stream
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Clone(IStream **ppstm)
{
    CExposedStream *pst;
    SCODE sc;

    olLog(("%p::In  CExposedStream::Clone(%p)\n", this, ppstm));
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Clone(%p)\n", ppstm));
    TRY
    {
        olChk(ValidateOutPtrBuffer(ppstm));
        *ppstm = NULL;
        olChk(Validate());
        olChk(CheckReverted());
        olMemTo(EH_pst, pst = new CExposedStream);
        olChkTo(EH_pst, pst->Init(_pst, _pdfParent, _df, &_dfn, _ulPos));
        _pst->AddRef();
        *ppstm = pst;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Clone => %p\n", *ppstm));
    return ResultFromScode(sc);

EH_pst:
    delete pst;
EH_Err:
    olLog(("%p::Out CExposedStream::Clone(). *ppstm == %p, ret == %lx\n",
           this, SAFE_DREFppstm, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CExposedStream::AddRef(void)
{
    ULONG ulRet;

    olLog(("%p::In  CExposedStream::AddRef()\n", this));
    olDebugOut((DEB_ITRACE, "In  CExposedStream::AddRef()\n"));
    TRY
    {
        if (FAILED(Validate()))
            return 0;
        AtomicInc(&_cReferences);
        ulRet = _cReferences;
    }
    CATCH(CException, e)
    {
        UNREFERENCED_PARM(e);
        ulRet = 0;
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::AddRef\n"));
    olLog(("%p::Out CExposedStream::AddRef().  ret == %lu\n", this, ulRet));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::LockRegion, public
//
//  Synopsis:   Nonfunctional
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedStream::LockRegion(ULARGE_INTEGER libOffset,
                                        ULARGE_INTEGER cb,
                                        DWORD dwLockType)
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::LockRegion("
                "%lu, %lu\n", cb.QuadPart, dwLockType));
    olDebugOut((DEB_ITRACE, "Out CExposedStream::LockRegion\n"));
    olLog(("%p::INVALID CALL TO CExposedStream::LockRegion()\n"));
    UNREFERENCED_PARM(libOffset);
    UNREFERENCED_PARM(cb);
    UNREFERENCED_PARM(dwLockType);
    olAssert(FALSE && aMsg("function not implemented!"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::UnlockRegion, public
//
//  Synopsis:   Nonfunctional
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedStream::UnlockRegion(ULARGE_INTEGER libOffset,
                                          ULARGE_INTEGER cb,
                                          DWORD dwLockType)
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::UnlockRegion(%lu, %lu)\n",
                cb.QuadPart, dwLockType));
    olDebugOut((DEB_ITRACE, "Out CExposedStream::UnlockRegion\n"));
    olLog(("%p::INVALID CALL TO CExposedStream::UnlockRegion()\n"));
    UNREFERENCED_PARM(libOffset);
    UNREFERENCED_PARM(cb);
    UNREFERENCED_PARM(dwLockType);
    olAssert(FALSE && aMsg("function not implemented!"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Commit, public
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Commit(DWORD grfCommitFlags)
{
    SCODE sc;
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Commit(%lu)\n",
                grfCommitFlags));
    olLog(("%p::In  CExposedStream::Commit(%lx)\n", this, grfCommitFlags));

    TRY
    {
        olChk(Validate());
        olChk(CheckReverted());
        
        if (_fDirty)
        {   //  We're a stream so we must have a parent
            //  We dirty all parents up to the next 
            //  transacted storage
            _pdfParent->SetDirty();
            sc = _pdfParent->GetBaseMS()
                ->Flush(FLUSH_CACHE(grfCommitFlags));               
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Commit\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::Commit().  ret == %lx", this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Revert, public
//
//  Synopsis:   No-op in current implementation
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Revert(void)
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Revert()\n"));
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Revert\n"));

    olLog(("%p::In  CExposedStream::Revert()\n", this));
    olLog(("%p::Out CExposedStream::Revert().  ret == %lx", this, S_OK));

    return ResultFromScode(STG_E_UNIMPLEMENTEDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    olLog(("%p::In  CExposedStream::QueryInterface(?, %p)\n",
           this, ppvObj));
    olDebugOut((DEB_ITRACE, "In  CExposedStream::QueryInterface(?, %p)\n",
                ppvObj));
    TRY
    {
        olChk(ValidateOutPtrBuffer(ppvObj));
        *ppvObj = NULL;
        olChk(ValidateIid(iid));
        olChk(Validate());
        olChk(CheckReverted());
        if (IsEqualIID(iid, IID_IStream) || IsEqualIID(iid, IID_IUnknown))
        {
            olChk(AddRef());
            *ppvObj = this;
        }
        else
            olErr(EH_Err, E_NOINTERFACE);
        sc = S_OK;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::QueryInterface => %p\n",
                ppvObj));
EH_Err:
    olLog(("%p::Out CExposedStream::QueryInterface().  *ppvObj == %p, ret == %lx\n",
           this, *ppvObj, sc));
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:	CExposedStream::RevertFromAbove, public (virtual)
//
//  Synopsis:	Parent has asked for reversion
//
//---------------------------------------------------------------


void CExposedStream::RevertFromAbove(void)
{
    msfDebugOut((DEB_ITRACE, 
                 "In CExposedStream::RevertFromAbove:%p()\n", this));
    _df |= DF_REVERTED;
    _pst->Release();
#if DBG == 1
    _pst = NULL;
#endif
    msfDebugOut((DEB_ITRACE, "Out CExposedStream::RevertFromAbove\n"));
}

#ifdef NEWPROPS
//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Open
//
//  Synopsis:   Opens mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Gets the size of the underlying stream and reads it
//              into memory so that it can be "mapped." 
//
//--------------------------------------------------------------------

VOID CExposedStream::Open(IN VOID *powner, OUT LONG *phr)
{
    LONG& sc = *phr;
    sc = S_OK;

    // If given a pointer to the owner of this mapped stream,
    // save it. This could be NULL. (i.e. when called from ReOpen)
    if( NULL != powner  )
        _powner = (BYTE*) powner;
  
    if (_pb == NULL)
    { 
        ULONGLONG ulSize;
        VOID *pv;
        _cbUsed = 0;
        olChk(CheckReverted());
        _pst->GetSize(&ulSize);

        if (ulSize > CBMAXPROPSETSTREAM)
            olErr(EH_Err, STG_E_INVALIDHEADER);

        _cbOriginalStreamSize = (ULONG) ulSize;
        _cbUsed = _cbOriginalStreamSize;
        olMemTo(EH_Err, pv = new BYTE[_cbOriginalStreamSize]);
        _pb = (BYTE*) pv;
        olChkTo(EH_Read, 
                    _pst->ReadAt(0, pv, _cbOriginalStreamSize, &_cbUsed));
        olAssert(_cbOriginalStreamSize == _cbUsed && 
                 "CExposedStream did not read in all the info!");

        // Notify our owner that we have new data
        if (*phr == S_OK && _powner != NULL && 0 != _cbUsed)
        {
            *phr = RtlOnMappedStreamEvent((VOID*)_powner, pv, _cbUsed );
        }

    }
    olDebugOut((DEB_PROP_MAP, "CExposedStream(%X):Open returns normally\n", this));
    return;

// Error handling
EH_Read:
    delete[] _pb;
    _pb = NULL;
    _cbUsed = 0;

EH_Err:
    olDebugOut((DEB_PROP_MAP, 
                "CExposedStream(%X):Open exception returns %08X\n", 
                this, *phr));
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Close
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Does nothing because the object may be mapped in
//              another process.
//
//--------------------------------------------------------------------

VOID CExposedStream::Close(OUT LONG *phr)
{
    // Write the changes.  We don't need to Commit them,
    // they will be implicitely committed when the 
    // Stream is Released.

    *phr = Write();

    if( FAILED(*phr) )
    {
        olDebugOut( (DEB_PROP_MAP, 
                     "CPubStream(%08X)::Close exception returns %08X\n", 
                     this, *phr));
    }

    return;    
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::ReOpen
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Combined open and map.
//
//--------------------------------------------------------------------

VOID CExposedStream::ReOpen(IN OUT VOID **ppv, OUT LONG *phr)
{
    *ppv = NULL;
    Open( (void*)NULL,          // unspecified owner
          phr);
    if ( SUCCEEDED(*phr) )
        *ppv = _pb;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Quiesce
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Meaningless for docfile mapped stream.
//
//--------------------------------------------------------------------

VOID CExposedStream::Quiesce(VOID)
{
    olAssert(_pb != NULL);
    DfpdbgCheckUnusedMemory();
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Map
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Return the address of the "mapping" buffer.
//
//--------------------------------------------------------------------

VOID CExposedStream::Map(BOOLEAN fCreate, VOID **ppv) 
{ 
    UNREFERENCED_PARM(fCreate);
    olAssert(_pb != NULL); 
    DfpdbgCheckUnusedMemory();
    *ppv = _pb; 
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Unmap
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Unmapping is merely zeroing the pointer.  We don't
//              flush because that's done explicitly by the 
//              CPropertyStorage class.
//              
//
//--------------------------------------------------------------------

VOID CExposedStream::Unmap(BOOLEAN fFlush, VOID **pv)
{
    UNREFERENCED_PARM(fFlush);
    DfpdbgCheckUnusedMemory();
    *pv = NULL;    
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Flush
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//              Flush the memory property set to disk and commit it.
//
//--------------------------------------------------------------------

VOID CExposedStream::Flush(OUT LONG *phr)
{
    *phr = S_OK;
    // write out any data we have cached to the stream
    if (S_OK == (*phr = Write()))     
    {
        // commit the stream
        (*phr) = Commit(STGC_DEFAULT);
    }

    return;    
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::GetSize
//
//  Synopsis:   Returns size of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//--------------------------------------------------------------------

ULONG CExposedStream::GetSize(OUT LONG *phr)
{
    *phr = S_OK;
    if (_pb == NULL)
        Open((void*)NULL,       // unspecified owner
             phr);

    if( SUCCEEDED(*phr) )
    {
        olAssert(_pb != NULL); 
        DfpdbgCheckUnusedMemory();
    }
    
    return _cbUsed;    
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::SetSize
//
//  Synopsis:   Sets size of "map." Called by 
//              NtCreatePropertySet et al.
//
//  Arguments:  [cb] -- requested size.
//		[fPersistent] -- FALSE if expanding in-memory read-only image
//              [ppv] -- new mapped address.
//
//  Signals:    Not enough disk space.
//
//
//--------------------------------------------------------------------

VOID  CExposedStream::SetSize(ULONG cb, IN BOOLEAN fPersistent, 
                              VOID **ppv, OUT LONG *phr)
{
    *phr = S_OK;
    LONG& sc=*phr;
    BYTE *pbNew;

    olAssert(cb != 0);    
    DfpdbgCheckUnusedMemory();
    olChk(CheckReverted());

    //
    // if we are growing the data, we should grow the stream
    //
    if (fPersistent && cb > _cbUsed)
    {
        olChk(_pst->SetSize(cb));
    }

    olMem(pbNew = new BYTE[cb]);
        
    memcpy(pbNew, _pb, (cb < _cbUsed) ? cb : _cbUsed); // smaller of the 2
    delete[] _pb;
    
    _pb = pbNew;
    _cbUsed = cb;
    *ppv = _pb;
            
    DfpdbgFillUnusedMemory();

EH_Err:
    olDebugOut((DEB_PROP_MAP, "CPubStream(%08X):SetSize %s returns hr=%08X\n",
        this, *phr != S_OK ? "exception" : "", *phr));
    return;
}


//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::QueryTimeStamps
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CExposedStream::QueryTimeStamps(STATPROPSETSTG *pspss, 
                                     BOOLEAN fNonSimple) const
{    
    UNREFERENCED_PARM(fNonSimple);
    UNREFERENCED_PARM(pspss);    
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::QueryModifyTime
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::QueryModifyTime(OUT LONGLONG *pll) const
{
    UNREFERENCED_PARM(pll);   
    return (FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::QuerySecurity
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::QuerySecurity(OUT ULONG *pul) const
{
    UNREFERENCED_PARM(pul);   
    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::IsWriteable
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::IsWriteable() const
{
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::SetChangePending
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

#if DBGPROP
BOOLEAN CExposedStream::SetChangePending(BOOLEAN f)
{
    _fChangePending = f;
    return(_fChangePending);
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::IsNtMappedStream
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

#if DBGPROP
BOOLEAN CExposedStream::IsNtMappedStream(VOID) const
{
    return FALSE;
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::GetHandle
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

HANDLE CExposedStream::GetHandle(VOID) const
{
    return INVALID_HANDLE_VALUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::SetModified
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CExposedStream::SetModified(VOID)
{
    _fDirty = TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::IsModified
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::IsModified(VOID) const
{
    return _fDirty;
}

#if DBG
//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::DfpdbgFillUnusedMemory
//
//--------------------------------------------------------------------

VOID CExposedStream::DfpdbgFillUnusedMemory(VOID)
{
    if (_pb == NULL)
        return;

    BYTE * pbEndPlusOne = _pb + BytesCommitted();

    for (BYTE *pbUnused = _pb + _cbUsed;
         pbUnused < pbEndPlusOne;
         pbUnused++)
    {
        *pbUnused = (BYTE)(DWORD)pbUnused;
    }
}


//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::DfpdbgCheckUnusedMemory
//
//--------------------------------------------------------------------

VOID CExposedStream::DfpdbgCheckUnusedMemory(VOID)
{

    if (_pb == NULL)
        return;

    if (_cbUsed == 0)
        return;

    BYTE * pbEndPlusOne = _pb + BytesCommitted();

    for (BYTE *pbUnused =  _pb + _cbUsed;
         pbUnused < pbEndPlusOne;
         pbUnused ++)
    {
        olAssert(*pbUnused == (BYTE)(DWORD)pbUnused);
    }
}

#endif    // DBG


//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Write, private
//
//  Synopsis:   Writes a mapped view of an exposed Stream to the
//              underlying Stream.  Used by RtlCreatePropertySet et al.
//
//  Notes:      The Stream is not commited.  To commit the Stream, in
//              addition to writing it, the Flush method should be used.
//              The Commit is omitted so that it can be skipped in
//              the Property Set Close path, thus eliminating a
//              performance penalty.
//
//--------------------------------------------------------------------

HRESULT CExposedStream::Write(VOID)
{
    HRESULT hr;
    ULONG cbWritten;

    if (!_fDirty ||!_pb)
    {
        olDebugOut((DEB_PROP_MAP,
                 "CExposedStream(%08X):Flush returns with not-dirty\n", this));

        // flushing a stream which isn't a property stream
        // this could be optimized by propagating a 'no property streams'
        // flag up the storage hierachy such that FlushBufferedData is
        // not even called for non-property streams.
        return S_OK;     
    }
    
    hr=CheckReverted();
    if (S_OK!=hr) goto Exit;
    olAssert( _pst != NULL );
    olAssert( _pb != NULL );
    olAssert( _powner != NULL );

    // notify our owner that we are about to perform a write
    hr = RtlOnMappedStreamEvent( (void*)_powner, (void*) _pb, _cbUsed );
    if ( S_OK != hr ) goto Exit;

    hr = _pst->WriteAt(0, _pb, _cbUsed, &cbWritten);

    if( S_OK != hr ) goto Exit;
    // notify our owner that we are done with the write
    hr = RtlOnMappedStreamEvent( (VOID*)_powner, (VOID *) _pb, _cbUsed );
    if( S_OK != hr ) goto Exit;
    
    if (_cbUsed < _cbOriginalStreamSize)
    {
        // if the stream is shrinking, this is a good time to do it.
        hr = _pst->SetSize(_cbUsed);
        if (S_OK!=hr) goto Exit;
    }

Exit:
    if (hr == S_OK || hr == STG_E_REVERTED)
    {
        _fDirty = FALSE;
    }

    olDebugOut((DEB_PROP_MAP, "CPubStream(%08X):Flush %s returns hr=%08X\n",
        this, hr != S_OK ? "exception" : "", hr));

    return hr;
}

//+--------------------------------------------------------------
//
//  Member:         CExposedStream::FlushBufferedData, public
//
//  Synopsis:   Flush out the property buffers.
//
//---------------------------------------------------------------

SCODE CExposedStream::FlushBufferedData()
{
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  CExposedStream::FlushBufferedData:%p()\n", 
                this));

    Flush(&sc);

    olDebugOut((DEB_PROP_MAP, 
                "CExposedStream(%08X):FlushBufferedData returns %08X\n",
                this, sc));

    return sc;
}

#endif // ifdef NEWPROPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\mem.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       mem.cxx
//
//  Contents:   IMalloc interface implementations
//              Note that these functions do little more than
//              the normal delete and new. They are provided
//              so that existing code can be ported to the ref.
//              impl. easily.
//
//---------------------------------------------------------------

#ifndef __MEM__C__
#define __MEM__C__

#include "exphead.cxx"

#include "h/mem.hxx"
#include "memory.h"
#include "h/dfexcept.hxx"

static CAllocator theAllocator;  // global allocator

//+--------------------------------------------------------------
//
//  Function:   CoGetMalloc, public
//
//  Synopsis:   Retrieves a pointer to the default OLE task memory 
//              allocator (which supports the system implementation 
//              of the IMalloc interface) so applications can call 
//              its methods to manage memory.
//
//  Arguments:  [dwMemContext] - Indicates if memory is private or shared 
//              [ppMalloc] - Receives pointer to memory allocator on return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppMalloc]
//
//---------------------------------------------------------------

STDAPI 
CoGetMalloc( DWORD dwMemContext, LPMALLOC * ppMalloc )
{
    if (FAILED(ValidatePtrBuffer(ppMalloc))
         || dwMemContext != 1)
        return ResultFromScode(E_INVALIDARG);
    else 
    {
        *ppMalloc = &theAllocator;
        return S_OK;
    }
}

//+--------------------------------------------------------------
//
//  Function:   CoTaskMemAlloc, public
//
//  Synopsis:   Allocates a block of task memory in the same way 
//              that IMalloc::Alloc does. 
//
//  Arguments:  [cb] - Size in bytes of memory block to be allocated
//
//  Returns:    Allocated memory block
//                     Indicates memory block allocated successfully.
//              NULL
//                     Indicates insufficient memory available.
//
//  Modifies:   [ppMalloc]
//
//---------------------------------------------------------------
STDAPI_(LPVOID) 
CoTaskMemAlloc( ULONG cb )
{
    return theAllocator.Alloc(cb);
}

//+--------------------------------------------------------------
//
//  Function:   CoTaskMemFree, public
//
//  Synopsis:   Frees a block of task memory previously allocated 
//              through a call to the CoTaskMemAlloc or 
//              CoTaskMemRealloc function.
//
//  Arguments:  [pv] - Points to memory block to be freed
//
//  Modifies:   nothing
//
//---------------------------------------------------------------
STDAPI_(void) 
CoTaskMemFree( void* pv )
{
    theAllocator.Free(pv);
}


//+--------------------------------------------------------------
//
//  Function:   CoTaskMemRealloc, public
//
//  Synopsis:   Changes the size of a previously allocated block 
//              of task memory.
//
//  Arguments:  [pv] - Points to memory block to be reallocated
//              [cb] - Size in bytes of block to be reallocated
//
//  Returns:    Reallocated memory block
//                      Indicates memory block successfully reallocated.
//              NULL
//                      Indicates insufficient memory or cb is zero 
//                      and pv is not NULL.
//
//  Modifies:   nothing
//
//---------------------------------------------------------------

STDAPI_(LPVOID) 
CoTaskMemRealloc( LPVOID pv, ULONG cb )
{
    return theAllocator.Realloc(pv, cb);
}

//+---------------------------------------------------------------------------
//
//  Member: CAllocator::QueryInterface, public
//
//  Synopsis:   Standard QI
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//
//----------------------------------------------------------------------------

STDMETHODIMP CAllocator::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;

    if (IsEqualIID(iid, IID_IMalloc) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IMalloc *) this;
        CAllocator::AddRef();
    }
    else
        sc = E_NOINTERFACE;

    return ResultFromScode(sc);
}


//+---------------------------------------------------------------------------
//
//  Member: CAllocator::AddRef, public
//
//  Synopsis:   Add reference
//
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAllocator::AddRef(void)
{
    //return ++_cRefs;
    return 1;  // return a dummy value
}


//+---------------------------------------------------------------------------
//
//  Member: CAllocator::Release, public
//
//  Synopsis:   Release
//
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAllocator::Release(void)
{
    return 0; // return a dummy value
}

//+---------------------------------------------------------------------------
//
//  Member: CAllocator::Alloc, public
//
//  Synopsis:   Allocate memory
//
//  Arguments:  [cb] -- Number of bytes to allocate
//
//  Returns:    Pointer to block, NULL if failure
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void *) CAllocator::Alloc ( ULONG cb )
{
    // make sure the retuned value is 8 byte aligned
    return (void *) new LONGLONG[ (cb+7)/sizeof(LONGLONG) ];
}

//+---------------------------------------------------------------------------
//
//  Member: CAllocator::Realloc, public
//
//  Synopsis:   Resize the block given
//
//  Arguments:  [pv] -- Pointer to block to realloc
//              [cb] -- New size for block
//
//  Returns:    Pointer to new block, NULL if failure
//
//  Note:       The current implementation will copy cb # of
//              bytes to the new block, even if the old block
//              has size smaller then cb.
//              ==> potential problems esp if pv is at a
//              memory boundary.
//----------------------------------------------------------------------------

STDMETHODIMP_(void *) 
CAllocator::Realloc( void *pv, ULONG cb )
{
    void* pvNew=NULL;
    if (!pv)                    
        pvNew = Alloc(cb);         
    else
    {
        // make sure the new pointer is 8-byte aligned
        pvNew = (void *) (new LONGLONG [(cb+7)/sizeof(LONGLONG)]);
        if (pvNew)
        {
            memcpy(pvNew, pv, cb);
            delete[] pv;
        }
    }
    return pvNew;
}

//+---------------------------------------------------------------------------
//
//  Member: CSmAllocator::Free, public
//
//  Synopsis:   Free a memory block
//
//  Arguments:  [pv] -- Pointer to block to free
//
//  Returns:    void
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void) CAllocator::Free(void *pv)
{
    delete[] pv;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAllocator::GetSize, public
//
//  Synopsis:	Return the size of the given block
//
//  Arguments:	[pv] -- Block to get size of
//
//  Returns:	(should) Size of block pointer to by 
//              (now) 0
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAllocator::GetSize(void * pv)
{
    UNREFERENCED_PARM(pv);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAllocator::DidAlloc, public
//
//  Synopsis:	Return '1' if this heap allocated pointer at pv
//
//  Arguments:	[pv] -- Pointer to block
//
//  Returns:	'1' == This heap allocated block.
//              '0' == This heap did not allocate block.
//              '-1' == Could not determine if this heap allocated block.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(int) CAllocator::DidAlloc(void FAR * pv)
{
    UNREFERENCED_PARM(pv);
    return -1;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAllocator::HeapMinimize, public
//
//  Synopsis:	Minimize the heap
//
//  Arguments:	None.
//
//  Returns:    void.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void) CAllocator::HeapMinimize(void)
{
    // do nothing;
    return;
}

#endif // __MEM__C__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\fat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       fat.cxx
//
//  Contents:   Allocation functions for MStream
//
//  Classes:    None. (defined in fat.hxx)
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/difat.hxx"
#include "h/sstream.hxx"
#include "mread.hxx"


//+-------------------------------------------------------------------------
//
//  Method:     CFatSect::Init, public
//
//  Synopsis:   CFatSect initialization function
//
//  Effects:    [uEntries] -- Number of entries in sector
//
//  Algorithm:  Allocate an array of SECT with size uEntries from
//              the heap.
//
//--------------------------------------------------------------------------

SCODE CFatSect::Init(FSOFFSET uEntries)
{
    msfDebugOut((DEB_FAT,"In CFatSect constructor\n"));

    //This assumes that FREESECT is always 0xFFFFFFFF
    memset(_asectEntry, 0xFF, uEntries * sizeof(SECT));

    msfDebugOut((DEB_FAT,"Out CFatSect constructor\n"));
    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CFatSect::InitCopy, public
//
//  Synopsis:   Initialization function for copying FatSects
//
//  Arguments:  [fsOld] -- Reference to FatSect to be copies
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  Allocate a new array of SECT and copy old
//                  information in.
//
//--------------------------------------------------------------------------

SCODE CFatSect::InitCopy(USHORT uSize, CFatSect& fsOld)
{
    msfDebugOut((DEB_FAT,"In CFatSect copy constructor\n"));
    msfDebugOut((DEB_FAT,"This = %p,  fsOld = %p\n",this,&fsOld));

    msfDebugOut((DEB_FAT,"Sector size is %u sectors\n",uSize));

    memcpy(_asectEntry,fsOld._asectEntry,sizeof(SECT)*uSize);
    msfDebugOut((DEB_FAT,"Out CFatSect copy constructor\n"));
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::CFat, public
//
//  Synopsis:   CFat constructor.
//
//  Arguments:  [pmsParent] -- Pointer to parent multistream.
//
//  Algorithm:  Set uFatEntries to match parent MS header info.
//              Initialize all member variables.
//
//  Notes:
//
//--------------------------------------------------------------------------

CFat::CFat(SID sid, USHORT cbSector, USHORT uSectorShift)
: _fv( sid,
       (USHORT) (cbSector >> 2),  // 4 bytes per entry
       (USHORT) (cbSector >> 2) ), 
  // left shift this amount for FAT
  _uFatShift((USHORT) (uSectorShift - 2) ),   
  // (# entries per sector) - 1
  _uFatMask( (USHORT) ((cbSector >> 2) - 1)), 
  _sid(sid),
  _pmsParent(NULL),
  _sectFirstFree( (SECT) 0),
  _sectMax(ENDOFCHAIN)
{
}




//+---------------------------------------------------------------------------
//
//  Member:	CFat::Empty, public
//
//  Synopsis:	Empty all the control structures of this instance
//
//  Arguments:	None.
//
//  Returns:	void.
//
//----------------------------------------------------------------------------

void CFat::Empty(void)
{
    _fv.Empty();
    _pmsParent = NULL;
    _cfsTable = 0;
    _ulFreeSects = MAX_ULONG;
    _sectFirstFree = 0;
    _sectMax = ENDOFCHAIN;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::~CFat, public
//
//  Synopsis:   CFat Destructor
//
//  Algorithm:  delete dynamically allocated storage
//
//  Notes:
//
//--------------------------------------------------------------------------

CFat::~CFat()
{
    msfDebugOut((DEB_FAT,"In CFat destructor.  Size of fat is %lu\n",_cfsTable));

    msfDebugOut((DEB_FAT,"Exiting CFat destructor\n"));
}


//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetFree, private
//
//  Synposis:   Locate and return a free sector in the FAT
//
//  Effects:    May modify full bit on full sectors
//
//  Arguments:  [psectRet] -- Pointer to return value
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  Do a linear search of all tables until a free sector is
//              found.  If all tables are full, extend the FAT by one
//              sector.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::GetFree(ULONG ulCount, SECT *psectRet)
{
    FSINDEX ipfs;
    FSOFFSET isect;
    SECT sectRetval = ENDOFCHAIN;
    SCODE sc;
    
    SECT sectLast = ENDOFCHAIN;
    FSINDEX ipfsLast;
    FSOFFSET isectLast;
    
    *psectRet = ENDOFCHAIN;
    
    
    while (TRUE)
    {
        if (_ulFreeSects == MAX_ULONG)
        {
            msfChk(CountFree(&_ulFreeSects));
        }
#if DBG == 1
        else
        {
            ULONG ulFree;
            msfChk(CountFree(&ulFree));
            msfAssert((ulFree == _ulFreeSects) &&
                    aMsg("Free count doesn't match cached value."));
        }
#endif
        
        while (ulCount > _ulFreeSects)
        {
#if DBG == 1
            ULONG ulFree = _ulFreeSects;
#endif
            
            msfChk(Resize(_cfsTable +
                    ((ulCount - _ulFreeSects + _fv.GetSectTable() - 1) >>
                     _uFatShift)));
            
#if DBG == 1
            msfAssert(_ulFreeSects > ulFree &&
                aMsg("Number of free sectors didn't increase after Resize."));
#endif
        }
        
        FSOFFSET isectStart;
        FSINDEX ipfsStart;
        
        SectToPair(_sectFirstFree, &ipfsStart, &isectStart);
        
        for (ipfs = ipfsStart; ipfs < _cfsTable; ipfs++)
        {
            CVectBits *pfb = _fv.GetBits(ipfs);
            if ((pfb == NULL) || (!pfb->full))
            {
                CFatSect *pfs;
                msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
                if (pfb != NULL)
                {
                    isectStart = pfb->firstfree;
                }
                
                for (isect = isectStart; isect < _fv.GetSectTable(); isect++)
                {
                    SECT sectCurrent = pfs->GetSect(isect);
                    SECT sectNew = PairToSect(ipfs, isect);
                    
                    
                    if (sectCurrent == FREESECT)
                    {
                        msfAssert(_ulFreeSects != MAX_ULONG &&
                                aMsg("Free sect count not set"));
                        
                        _ulFreeSects--;
                        
                        sectRetval = sectNew;
                        
                        if (pfb != NULL)
                        {
                            olAssert(isect+1 < USHRT_MAX);
                            pfb->firstfree = (USHORT) (isect + 1);
                        }
                        
                        msfAssert(sectRetval >= _sectFirstFree &&
                                aMsg("Found free sector before _sectFirstFree"));
                        _sectFirstFree = sectRetval + 1;
                        
                        pfs->SetSect(isect, ENDOFCHAIN);
                        msfChkTo(Err_Rel, _fv.SetDirty(ipfs));
                        
                        if (sectLast != ENDOFCHAIN)
                        {
                            if (ipfsLast == ipfs)
                            {
                                pfs->SetSect(isectLast, sectRetval);
                            }
                            else
                            {
                                CFatSect *pfsLast;
                                
                                msfChkTo(Err_Rel, _fv.GetTable(
                                        ipfsLast,
                                        FB_DIRTY,
                                        &pfsLast));
                                
                                pfsLast->SetSect(isectLast, sectRetval);
                                _fv.ReleaseTable(ipfsLast);
                            }
                        }
                        
                        if (*psectRet == ENDOFCHAIN)
                        {
                            *psectRet = sectRetval;
                        }
                        
                        ulCount--;
                        
                        if (ulCount == 0)
                        {
                            _fv.ReleaseTable(ipfs);

                            if (sectRetval >= _sectMax)
                            {
                                _sectMax = sectRetval + 1;
                            }
                            return S_OK;
                        }
                        else
                        {
                            sectLast = sectRetval;
                            ipfsLast = ipfs;
                            isectLast = isect;
                        }
                    }
                }
                _fv.ReleaseTable(ipfs);
                if (pfb != NULL)
                {
                    pfb->full = TRUE;
                }
            }
            isectStart = 0;
        }
        if (sectRetval >= _sectMax)
        {
            _sectMax = sectRetval + 1;
        }
    }
    msfAssert(0 &&
            aMsg("GetFree exited improperly."));
    sc = STG_E_ABNORMALAPIEXIT;
    
 Err:
    return sc;
    
 Err_Rel:
    _fv.ReleaseTable(ipfs);
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetLength, public
//
//  Synposis:   Return the length of a fat chain.
//
//  Arguments:  [sect] -- Sector to begin count at.
//
//  Returns:    Length of the chain, in sectors
//
//  Algorithm:  Traverse the chain until ENDOFCHAIN is reached.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::GetLength(SECT sect, ULONG * pulRet)
{
    msfDebugOut((DEB_FAT,"In CFat::GetLength(%lu)\n",sect));
    SCODE sc = S_OK;

    ULONG csect = 0;

    while (sect != ENDOFCHAIN)
    {
        msfChk(GetNext(sect, &sect));
        csect++;
    }

    msfDebugOut((DEB_FAT,"FAT: GetLength returned %u\n",csect));
    *pulRet =  csect;
Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::Init, public
//
//  Synposis:   Sets up a FAT, reading data from an existing stream
//
//  Effects:    Changes all _apfsTable entries, _cfsTable, and all
//              flags fields
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Read size from first FAT in stream.
//              Resize array to necessary size.
//              Read in FAT sectors sequentially.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::Init(CMStream *pmsParent, FSINDEX cFatSect, BOOL fConvert)
{
    SCODE sc;
    UNREFERENCED_PARM(fConvert);
    msfDebugOut((DEB_FAT,"CFat::setup thinks the FAT is size %lu\n",cFatSect));

    _pmsParent = pmsParent;

    msfChk(_fv.Init(_pmsParent, cFatSect));

    _cfsTable = cFatSect;

    USHORT cbSectorSize;
    cbSectorSize = _pmsParent->GetSectorSize();
    InitRangeLocksSector();

    _ulFreeSects = MAX_ULONG;

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::InitConvert, public
//
//  Synopsis:   Init function used for conversion
//
//  Arguments:  [sectData] -- number of sectors used by file
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CFat::InitConvert(CMStream *pmsParent, SECT sectData)
{
    SCODE sc;
    msfDebugOut((DEB_FAT,"Doing conversion\n"));
    _pmsParent = pmsParent;

    msfAssert((sectData != 0) &&
            aMsg("Attempt to convert zero length file."));

    SECT sectMax = 0;
    FSINDEX csectFat = 0;
    FSINDEX csectLast;

    InitRangeLocksSector();

    if (_sid == SIDFAT)
    {
        SECT sectTotal;

        //Since the fat needs to represent itself, we can't determine
        //   the actual number of sectors needed in one pass.  We
        //   therefore loop, factoring in the number of fat sectors
        //   at each iteration, until we reach a stable state.
        //
        //As an example, consider the case where each fat sector represents
        //   128 sectors and the file being converted is 128 sectors long.
        //   There will be no DIFat - therefore, we have 128 sectors needed
        //   on the first pass, which will require 1 fat sector to
        //   represent them.  On the second pass, we discover that we
        //   actually need 2 fat sectors, since we now have 129 total
        //   sectors to allocate space for.  The third pass will result
        //   in a stable state.
        do
        {
            csectLast = csectFat;
            sectTotal = sectData + _pmsParent->GetHeader()->GetDifLength() +
                csectFat + 1;
            csectFat = (sectTotal + _fv.GetSectTable() - 1) >> _uFatShift;
        }
        while (csectLast != csectFat);
        sectMax = sectData + _pmsParent->GetHeader()->GetDifLength();
    }
    else
    {
        //The minifat doesn't need to represent itself, so we can
        //  compute the number of sectors needed in one pass.
        sectMax = sectData;
        csectFat = (sectMax + _fv.GetSectTable() -1) >> _uFatShift;
    }

    msfChk(_fv.Init(_pmsParent, csectFat));

    FSINDEX i;

    if (_sid == SIDMINIFAT)
    {
        SECT sectFirst;
        msfChk(_pmsParent->GetFat()->Allocate(csectFat, &sectFirst));

        _pmsParent->GetHeader()->SetMiniFatStart(sectFirst);

        _pmsParent->GetHeader()->SetMiniFatLength(csectFat);
    }


    for (i = 0; i < csectFat; i++)
    {
        CFatSect *pfs;

        msfChk(_fv.GetTable(i, FB_NEW, &pfs));
        if (_sid == SIDFAT)
        {
            _fv.SetSect(i, sectMax + i);
            _pmsParent->GetDIFat()->SetFatSect(i, sectMax + i);
        }
        else
        {
            SECT sect;
            msfChk(_pmsParent->GetESect(_sid, i, &sect));
            _fv.SetSect(i, sect);
        }

        _fv.ReleaseTable(i);
    }


    _cfsTable = csectFat;

    if (_sid != SIDMINIFAT)
    {

        _pmsParent->GetHeader()->SetFatLength(_cfsTable);

        SECT sect;

        if (sectData > 1)
        {
            for (sect = 0; sect < sectData - 2; sect++)
            {
                msfChk(SetNext(sect, sect + 1));
            }

            msfChk(SetNext(sectData - 2, ENDOFCHAIN));
            msfChk(SetNext(sectData - 1, 0));
        }
        else
        {
            //In the event that the file to be converted is less
            //  than one sector long, we don't need to create a
            //  real chain, just a single terminated sector.
            msfChk(SetNext(0, ENDOFCHAIN));
        }


        for (sect = sectData; sect < sectMax; sect++)
        {
            msfChk(SetNext(sect, DIFSECT));
        }

        for (ULONG j = 0; j < csectFat; j++)
        {
            msfChk(SetNext(sectMax + j, FATSECT));
        }

        //Set up directory chain.
        msfChk(SetNext(sectMax + i, ENDOFCHAIN));

        _pmsParent->GetHeader()->SetDirStart(sectMax + i);

        _ulFreeSects = (_cfsTable << _uFatShift) - (sectMax + csectFat + 1);
    }
    else
    {
        for (SECT sect = 0; sect < sectData -1; sect++)
        {
            msfChk(SetNext(sect, sect + 1));
        }
        msfChk(SetNext(sectData - 1, ENDOFCHAIN));
        _ulFreeSects = (_cfsTable << _uFatShift) - sectData;
    }

        msfChk(_pmsParent->SetSize());

Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFat::InitNew, public
//
//  Synposis:   Sets up a FAT for a newly created multi-strean
//
//  Effects:    Changes all _apfsTable entries, _cfsTable, and all
//              flags fields
//
//  Arguments:  [pmsparent] -- pointer to parent Mstream
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Set parent pointer.
//              Allocate 1 sector for FAT and 1 for Directory.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::InitNew(CMStream *pmsParent)
{
    msfDebugOut((DEB_FAT,"In CFat::InitNew()\n"));
    SCODE sc;

    _pmsParent = pmsParent;

    FSINDEX count;
    if (SIDMINIFAT == _sid)
        count = _pmsParent->GetHeader()->GetMiniFatLength();
    else
        count = _pmsParent->GetHeader()->GetFatLength();

    msfDebugOut((DEB_FAT,"Setting up Fat of size %lu\n",count));

    msfChk(_fv.Init(_pmsParent, count));

    _cfsTable = count;

    InitRangeLocksSector();
    if (SIDFAT == _sid)
    {
        FSINDEX ipfs;
        FSOFFSET isect;
        CFatSect *pfs;

        SectToPair(_pmsParent->GetHeader()->GetFatStart(), &ipfs, &isect);
        msfChk(_fv.GetTable(ipfs, FB_NEW, &pfs));
        _fv.SetSect(ipfs, _pmsParent->GetHeader()->GetFatStart());
        _fv.ReleaseTable(ipfs);

        msfChk(SetNext(_pmsParent->GetHeader()->GetFatStart(), FATSECT));
        msfDebugOut((DEB_ITRACE,"Set sector %lu (FAT) to ENDOFCHAIN\n",_pmsParent->GetHeader()->GetFatStart()));

        msfChk(SetNext(_pmsParent->GetHeader()->GetDirStart(), ENDOFCHAIN));
        msfDebugOut((DEB_ITRACE,"Set sector %lu (DIR) to ENDOFCHAIN\n",_pmsParent->GetHeader()->GetDirStart()));
        _ulFreeSects = (count << _uFatShift) - 2;
    }
    else
    {
        _ulFreeSects = 0;
    }

        msfChk(_pmsParent->SetSize());

    msfDebugOut((DEB_FAT,"Exiting CFat::setupnew()\n"));

Err:
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::Resize, private
//
//  Synposis:   Resize FAT, both in memory and in the file
//
//  Effects:    Modifies _cfsTable, _apfsTable, and all flags fields
//
//  Arguments:  [ulSize] -- New size (in # of tables) for FAT
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Allocate new array of new size.
//              Copy over all old pointers.
//              Allocate new tables for any necessary.
//
//  Notes:               This routine currently cannot reduce the size of a fat
                                                                     
//---------------------------------------------------------------------------

SCODE CFat::Resize(ULONG ulSize)
{
    msfDebugOut((DEB_FAT,"In CFat::Resize(%lu)\n",ulSize));
    SCODE sc;

    if (ulSize == _cfsTable)
    {
        return S_OK;
    }

    ULONG csect = _cfsTable;

    msfAssert(ulSize > _cfsTable &&
            aMsg("Attempted to shrink Fat"));

    // 512byte sector docfiles are restricted to 2G for now
    if (_pmsParent->GetSectorShift() == SECTORSHIFT512 &&
        ulSize > _ipfsRangeLocks)
        return STG_E_DOCFILETOOLARGE;

    ULONG ipfs;
    SECT sectNew = ENDOFCHAIN;

    CFat *pfat = _pmsParent->GetFat();


    if (_sid == SIDFAT)
    {

        //Make sure we have enough space for all of the sectors
        //  to be allocated.

        ULONG csectFat = ulSize - _cfsTable;
        ULONG csectPerDif = (1 << _uFatShift) - 1;
        ULONG csectDif = (csectFat + csectPerDif - 1) / csectPerDif;


        //Assuming all the free sectors are at the end of the file,
        //   we need a file csectNew sectors long to hold them.

        ULONG csectOld, csectNew;

        msfChk(FindMaxSect(&csectOld));

        csectNew = csectOld + csectFat + csectDif;

        ULARGE_INTEGER cbSize;
        
        cbSize.QuadPart = ConvertSectOffset(
                csectNew,
                0,
                _pmsParent->GetSectorShift());

        msfHChk(_pmsParent->GetILB()->SetSize(cbSize));

        //If we are the fat, we have enough space in the file for
        //  ourselves at this point.
    }
    else
    {
        if (_cfsTable == 0)
        {
            msfChk(pfat->Allocate(ulSize, &sectNew));
            _pmsParent->GetHeader()->SetMiniFatStart(sectNew);
        }
        else
        {
            sectNew = _pmsParent->GetHeader()->GetMiniFatStart();

            SECT sectLast;
            msfChk(pfat->GetESect(sectNew, ulSize - 1, &sectLast));

        }

        msfChk(_pmsParent->SetSize());


        msfChk(pfat->GetSect(sectNew, csect, &sectNew));

        //If we are the Minifat, we have enough space in the underlying
        //  file for ourselves at this point.
    }


    _fv.Resize(ulSize);


    for (ipfs = csect; ipfs < ulSize; ipfs++)
    {
        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NEW, &pfs));
        _cfsTable = ipfs + 1;
        _ulFreeSects += (1 << _uFatShift);

        if (_sid == SIDFAT)
        {
            if (ipfs == _ipfsRangeLocks)
            {
                CVectBits *pfb;
                pfs->SetSect(_isectRangeLocks, ENDOFCHAIN);

                pfb = _fv.GetBits(_ipfsRangeLocks);
                if (pfb != NULL && pfb->full == FALSE &&
                    _isectRangeLocks == pfb->firstfree)
                {
                    pfb->firstfree = _isectRangeLocks + 1;
                }

                _ulFreeSects--;
            }

            msfChk(pfat->GetFree(1, &sectNew));

            msfChk(_pmsParent->GetDIFat()->SetFatSect(ipfs, sectNew));
            msfChk(pfat->SetNext(sectNew, FATSECT));
        }

        msfAssert(sectNew != ENDOFCHAIN &&
                aMsg("Bad sector returned for fatsect."));

        _fv.SetSect(ipfs, sectNew);
        _fv.ReleaseTable(ipfs);

        if (_sid == SIDMINIFAT)
        {
            msfChk(pfat->GetNext(sectNew, &sectNew));
        }
    }

    msfDebugOut((DEB_FAT,"CFat::Resize() - all new objects allocated\n"));

    if (SIDMINIFAT == _sid)
        _pmsParent->GetHeader()->SetMiniFatLength(_cfsTable);
    else
        _pmsParent->GetHeader()->SetFatLength(_cfsTable);


    //This setsize should only shrink the file.
#if DBG == 1
    STATSTG stat;

    msfHChk(_pmsParent->GetILB()->Stat(&stat, STATFLAG_NONAME));
#endif

        msfChk(_pmsParent->SetSize());

#if DBG == 1
    STATSTG statNew;

    msfHChk(_pmsParent->GetILB()->Stat(&statNew, STATFLAG_NONAME));

    msfAssert(statNew.cbSize.QuadPart <= stat.cbSize.QuadPart);
#endif

    msfDebugOut((DEB_FAT,"Out CFat::Resize(%lu)\n",ulSize));

Err:
    return sc;
}






//+-------------------------------------------------------------------------
//
//  Member:     CFat::Extend, private
//
//  Synposis:   Increase the size of an existing chain
//
//  Effects:    Modifies ulSize sectors within the fat.  Causes one or
//              more sector writes.
//
//  Arguments:  [sect] -- Sector ID of last sector in chain to be extended
//              [ulSize] -- Number of sectors to add to chain
//
//  Requires:   sect must be at the end of a chain.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Use calls to GetFree to allocate chain.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::Extend(SECT sect, ULONG ulSize)
{
    SCODE sc;

    msfDebugOut((DEB_FAT,"In CFat::Extend(%lu,%lu)\n",sect,ulSize));
    SECT sectTemp;

    msfChk(GetFree(ulSize, &sectTemp));
    msfChk(SetNext(sect, sectTemp));

    msfDebugOut((DEB_FAT,"Out CFat::Extend()\n"));

Err:
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetNext, public
//
//  Synposis:   Returns the next sector in a chain, given a sector
//
//  Arguments:  [sect] -- Sector ID of any sector in a chain.
//
//  Returns:    Sector ID of next sector in chain, ENDOFCHAIN if at end
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::GetNext(const SECT sect, SECT * psRet)
{
    SCODE sc;

    FSINDEX ipfs;
    FSOFFSET isect;

    msfAssert(sect <= MAXREGSECT &&
            aMsg("Called GetNext() on invalid sector"));

    SectToPair(sect, &ipfs, &isect);
    CFatSect *pfs;
    msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

    *psRet = pfs->GetSect(isect);

    _fv.ReleaseTable(ipfs);

    msfAssert(sect != *psRet &&
            aMsg("Detected loop in fat chain."));
    return S_OK;

Err:
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::SetNext, private
//
//  Synposis:   Set the next sector in a chain
//
//  Effects:    Modifies a single entry within the fat.
//
//  Arguments:  [sectFirst] -- Sector ID of first sector
//              [sectNext] -- Sector ID of next sector
//
//  Returns:    void
//
//  Notes:
//
//---------------------------------------------------------------------------
SCODE CFat::SetNext(SECT sectFirst, SECT sectNext)
{
    FSINDEX ipfs;
    FSOFFSET isect;
    SCODE sc;


    //  creating infinite loops is a no-no
    msfAssert(sectFirst != sectNext &&
            aMsg("Attempted to create loop in Fat chain"));
    msfAssert(sectFirst <= MAXREGSECT &&
            aMsg("Called SetNext on invalid sector"));

    SectToPair(sectFirst, &ipfs, &isect);

    CFatSect *pfs;

    msfChk(_fv.GetTable(ipfs, FB_DIRTY, &pfs));

    pfs->SetSect(isect,sectNext);

    _fv.ReleaseTable(ipfs);

    if (sectNext == FREESECT)
    {
        CVectBits *pfb;
        pfb = _fv.GetBits(ipfs);

        if ((pfb != NULL) &&
            ((pfb->full == TRUE) || (isect < pfb->firstfree)))
        {
            pfb->full = FALSE;
            pfb->firstfree = isect;
        }

        if (sectFirst == _sectMax - 1)
        {
            _sectMax = ENDOFCHAIN;
        }
        if (sectFirst < _sectFirstFree)
        {
            _sectFirstFree = sectFirst;
        }

        if (_ulFreeSects != MAX_ULONG)
        {
                _ulFreeSects++;
        }
    }

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::CountFree, private
//
//  Synposis:   Count and return the number of free sectors in the Fat
//
//  Arguments:  void.
//
//  Returns:    void.
//
//  Algorithm:  Do a linear search of the Fat, counting free sectors.
//              If a FatSect has its full bit set, it is not necessary
//              to search that FatSect.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::CountFree(ULONG * pulRet)
{
    msfDebugOut((DEB_FAT,"In CFat::CountFree()\n"));
    SCODE sc = S_OK;

    FSINDEX ipfs;
    ULONG csectFree=0;
    FSOFFSET isectStart;
    FSINDEX ipfsStart;

    SectToPair(_sectFirstFree, &ipfsStart, &isectStart);

    for (ipfs = ipfsStart; ipfs < _cfsTable; ipfs++)
    {
        CVectBits *pfb = _fv.GetBits(ipfs);

        if ((pfb == NULL) || (!pfb->full))
        {
            msfDebugOut((DEB_FAT,"Checking table %lu\n",ipfs));
            CFatSect *pfs;
            msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

            if (pfb != NULL)
            {
                isectStart = pfb->firstfree;
            }

            FSOFFSET isect;
            for (isect = isectStart; isect < _fv.GetSectTable(); isect++)
            {
                SECT sectCurrent = pfs->GetSect(isect);
                
                if (sectCurrent == FREESECT)
                {
                    csectFree++;
                }
            }
            _fv.ReleaseTable(ipfs);
        }
        isectStart = 0;
    }
    msfDebugOut((DEB_FAT,"Countfree returned %lu\n",csectFree));
    *pulRet = csectFree;

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetSect, public
//
//  Synposis:   Return the nth sector in a chain
//
//  Arguments:  [sect] -- Sector ID of beginning of chain
//              [uNum] -- indicator of which sector is to be returned
//              [psectReturn] -- Pointer to storage for return value
//
//  Returns:    S_OK.
//
//  Algorithm:  Linearly traverse chain until numth sector
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::GetSect(SECT sect, ULONG ulNum, SECT * psectReturn)
{
    msfDebugOut((DEB_FAT,"In CFat::GetSect(%lu,%lu)\n",sect,ulNum));

    SCODE sc = S_OK;

    if (ulNum == 0)
    {
        msfDebugOut((DEB_FAT,"Out CFat::GetSect()=>%lu\n",sect));
    }
    else if ((SIDFAT == _sid) &&
             (_pmsParent->GetHeader()->GetFatStart() == sect))
    {
        msfChk(_pmsParent->GetDIFat()->GetFatSect(ulNum, &sect));
    }
    else for (ULONG i = 0; i < ulNum; i++)
    {
        msfChk(GetNext(sect, &sect));
        if (sect > MAXREGSECT)
        {
            //The stream isn't long enough, so stop.
            msfAssert(sect == ENDOFCHAIN &&
                    aMsg("Found invalid sector in fat chain."));
            break;
        }
    }

    *psectReturn = sect;
    msfDebugOut((DEB_FAT,"Out CFat::GetSect()=>%lu\n",sect));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetESect
//
//  Synposis:   Return the nth sector in a chain, extending the chain
//              if necessary.
//
//  Effects:    Modifies fat (via Extend) if necessary
//
//  Arguments:  [sect] -- Sector ID of beginning of chain
//              [ulNum] -- Indicates which sector is to be returned
//              [psectReturn] -- Pointer to storage for return value
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Linearly search chain until numth sector is found.  If
//              the chain terminates early, extend it as necessary.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::GetESect(SECT sect, ULONG ulNum, SECT *psectReturn)
{
    msfDebugOut((DEB_FAT,"In CFat::GetESect(%lu,%lu)\n",sect,ulNum));

    SCODE sc = S_OK;

    ULONG i = 0;
    while (i < ulNum)
    {
        SECT temp;
        msfChk(GetNext(sect, &temp));

        msfAssert(temp != FREESECT &&
                aMsg("FREESECT found in chain."));

        if (temp == ENDOFCHAIN)
        {

            //The stream isn't long enough, so extend it somehow.
            ULONG need = ulNum - i;

            msfAssert((SIDMINIFAT == _sid ||
                    sect != _pmsParent->GetHeader()->GetFatStart()) &&
                    aMsg("Called GetESect on Fat chain"));
            msfChk(Extend(sect,need));
        }
        else
        {
            sect = temp;
            i++;
        }
    }

    msfDebugOut((DEB_FAT,"Exiting GetESect with result %lu\n",sect));
    *psectReturn = sect;

Err:
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::SetChainLength, private
//
//  Synposis:   Set the length of a fat chain.  This is used to reduce
//              the length of the chain only.  To extend a chain, use
//              Extend or GetESect
//
//  Effects:    Modifies the fat
//
//  Arguments:  [sectStart] -- Sector to begin at (head of chain)
//              [uLength] -- New length for chain
//
//  Returns:    void.
//
//  Algorithm:  Traverse chain until uLength is reached or the chain
//              terminates.  If it terminates prematurely, return with
//              no other action.  Otherwise, deallocate all remaining
//              sectors in the chain.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::SetChainLength(SECT sectStart, ULONG ulLength)
{
    msfDebugOut((DEB_FAT,"In CFat::SetChainLength(%lu,%lu)\n",sectStart,ulLength));
    SCODE sc;

    if (sectStart == ENDOFCHAIN) return S_OK;

    for (ULONG ui = 0; ui < ulLength; ui++)
    {
        msfChk(GetNext(sectStart, &sectStart));
        if (sectStart == ENDOFCHAIN) return S_OK;
    }

    msfAssert(sectStart != ENDOFCHAIN &&
            aMsg("Called SetChainLength is ENDOFCHAIN start"));

    SECT sectEnd;
    sectEnd = sectStart;

    msfChk(GetNext(sectStart, &sectStart));
    if (ulLength != 0)
    {
        msfChk(SetNext(sectEnd, ENDOFCHAIN));
    }
    else
    {
        msfChk(SetNext(sectEnd, FREESECT));
    }

    while (sectStart != ENDOFCHAIN)
    {
        SECT sectTemp;
        msfChk(GetNext(sectStart, &sectTemp));
        msfChk(SetNext(sectStart, FREESECT));
        sectStart = sectTemp;
    }
    msfDebugOut((DEB_FAT,"Out CFat::SetChainLength()\n"));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CFat::FindLast, private
//
//  Synopsis:   Find last used sector in a fat
//
//  Returns:    Location of last used sector
//
//  Algorithm:  Perform a backward linear search until a non-free
//              sector is found.
//
//  Notes:      Used for shadow fats only.
//
//--------------------------------------------------------------------------

SCODE CFat::FindLast(SECT * psectRet)
{
    SCODE sc = S_OK;
    FSINDEX ipfs = _cfsTable;
    SECT sect = 0;

    while (ipfs > 0)
    {
        ipfs--;

        FSOFFSET isect = _fv.GetSectTable();

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

        while (isect > 0)
        {
            isect--;

            SECT sectCurrent = pfs->GetSect(isect);
                
            if (ipfs == _ipfsRangeLocks && isect == _isectRangeLocks)
                sectCurrent = FREESECT;

            if (sectCurrent != FREESECT)
            {
                msfDebugOut((DEB_FAT,"FindLast returns %lu\n",PairToSect(ipfs,isect)));
                sect = PairToSect(ipfs, (FSOFFSET) (isect + 1));
                break;
            }
        }

        _fv.ReleaseTable(ipfs);
        if (sect != 0)
            break;
    }

    *psectRet = sect;
Err:
    return sc;
}





//+-------------------------------------------------------------------------
//
//  Method:     CFat::FindMaxSect, private
//
//  Synopsis:   Return last used sector in current Fat.
//
//  Arguments:  None.
//
//  Returns:    Last used sector in current Fat
//
//--------------------------------------------------------------------------

SCODE CFat::FindMaxSect(SECT *psectRet)
{
    SCODE sc = S_OK;

    if (_sectMax == ENDOFCHAIN)
    {
        msfChk(FindLast(psectRet));
    }
    else
    {
#if DBG == 1
        SECT sectLast;
        msfChk(FindLast(&sectLast));
#endif
        *psectRet = _sectMax;
    }

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CFat::Contig, public
//
//  Synposis:   Create contiguous sector table
//
//  Effects:    Creates new CSegment.
//
//  Arguments:  [sect] -- Starting sector for table to begin
//              [ulength] -- Runlength in sectors of table to produce
//
//  Returns:    Pointer to a Segment table
//
//  Algorithm:  Perform calls to CFat::GetNext().  Any call that is
//              1 higher than the previous represents contiguous blocks.
//              Construct the Segment table on that basis.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE  CFat::Contig(
        SSegment STACKBASED *aseg,
        SECT sect,
        ULONG ulLength)
{
    msfDebugOut((DEB_ITRACE,"In CFat::Contig(%lu,%lu)\n",sect,ulLength));
    SCODE sc = S_OK;
    SECT stemp = sect;
    ULONG ulCount = 1;
    USHORT iseg = 0;

    msfAssert(sect != ENDOFCHAIN &&
            aMsg("Called Contig with ENDOFCHAIN start"));

    aseg[iseg].sectStart = sect;
    aseg[iseg].cSect = 1;

    while ((ulLength > 1) && (iseg < CSEG))
    {
        msfAssert(sect != ENDOFCHAIN &&
                aMsg("Contig found premature ENDOFCHAIN"));

        FSINDEX ipfs;
        FSOFFSET isect;

        SectToPair(sect, &ipfs, &isect);

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
        sect = pfs->GetSect(isect);
        _fv.ReleaseTable(ipfs);

        if (sect == ENDOFCHAIN)
        {
            //Allocate new sectors.

            SECT sectNew;
            msfChk(GetFree(ulLength - 1, &sectNew));
            msfChk(SetNext(stemp, sectNew));
            sect = sectNew;
        }

        if (sect != (stemp + 1))
        {
            aseg[iseg].cSect = ulCount;
            ulCount = 1;
            iseg++;
            aseg[iseg].sectStart = sect;
            stemp = sect;
        }
        else
        {
            ulCount++;
            stemp = sect;
        }
        ulLength--;
    }

    if (iseg < CSEG)
    {
        aseg[iseg].cSect = ulCount;
        aseg[iseg + 1].sectStart = ENDOFCHAIN;
    }
    else
    {
        aseg[iseg].sectStart = FREESECT;
    }

    msfDebugOut((DEB_ITRACE,"Exiting Contig()\n"));

Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\msfhead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	msfhead.cxx
//
//  Contents:	Precompiled headers
//
//--------------------------------------------------------------------------

// some of these functions are a nuisance 
#ifdef _MSC_VER
#pragma warning (disable:4127)  // conditional expression is constant
#pragma warning (disable:4514)  // unreferenced inline function
#endif

#include "h/msf.hxx"
#include "h/header.hxx"
#include "h/vect.hxx"
#include "h/page.hxx"
#include "h/vectfunc.hxx"
#include "h/fat.hxx"
#include "h/dir.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\msf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       msf.cxx
//
//  Contents:   Entry points for MSF DLL
//
//  Classes:    None.
//
//  Functions:  DllMuliStreamFromStream
//              DllConvertStreamToMultiStream
//              DllReleaseMultiStream
//              DllGetScratchMultiStream
//              DllIsMultiStream
//
//--------------------------------------------------------------------------
#include "msfhead.cxx"
#include "h/handle.hxx"


//+-------------------------------------------------------------------------
//
//  Function:  DllMultiStreamFromStrea
//
//  Synopsis:   Create a new multistream instance from an existing stream.
//              This is used to reopen a stored multi-stream.
//
//  Effects:    Creates a new CMStream instance
//
//  Arguments:  [ppms] -- Pointer to storage for return of multistream
//              [pplstStream] -- Stream to be used by multi-stream for
//                           reads and writes
//		[dwFlags] - Startup flags
//
//  Returns:    STG_E_INVALIDHEADER if signature on pStream does not
//                  match.
//              STG_E_UNKNOWN if there was a problem in setup.
//              S_OK if call completed OK.
//
//  Algorithm:  Check the signature on the pStream and on the contents
//              of the pStream.  If either is a mismatch, return
//              STG_E_INVALIDHEADER.
//              Create a new CMStream instance and run the setup function.
//              If the setup function fails, return STG_E_UNKNOWN.
//              Otherwise, return S_OK.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllMultiStreamFromStream(CMStream **ppms,
			       ILockBytes **pplstStream,
			       DWORD dwFlags)
{
    SCODE sc;
    CMStream *temp;


    BOOL fConvert = ((dwFlags & RSF_CONVERT) != 0);
    BOOL fTruncate = ((dwFlags & RSF_TRUNCATE) != 0);
    BOOL fCreate = ((dwFlags & RSF_CREATE) != 0);


    msfDebugOut((DEB_ITRACE,"In DllMultiStreamFromStream\n"));

    temp = new CMStream(pplstStream, dwFlags & RSF_SECTORSIZE4K ?
                        SECTORSHIFT4K : SECTORSHIFT512);
    msfMem(temp);

    STATSTG stat;
    (*pplstStream)->Stat(&stat, STATFLAG_NONAME);
    msfDebugOut((DEB_ITRACE,"Size is: %lu\n",stat.cbSize.QuadPart));

    do
    {
        if ((stat.cbSize.QuadPart != 0) && (fConvert))
        {
            msfChk(temp->InitConvert());
            break;
        }

        if ((stat.cbSize.QuadPart == 0 && fCreate) || (fTruncate))
        {
            msfChk(temp->InitNew());
            break;
        }
        msfChk(temp->Init());
    }
    while (FALSE);

    *ppms = temp;

    msfDebugOut((DEB_ITRACE,"Leaving DllMultiStreamFromStream\n"));

    if (fConvert && stat.cbSize.QuadPart != 0)
    {
        return STG_S_CONVERTED;
    }

    return S_OK;

Err:
     delete temp;
     return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:   DllReleaseMultiStream
//
//  Synopsis:   Release a CMStream instance
//
//  Effects:    Deletes a multi-stream instance
//
//  Arguments:  [pms] -- pointer to object to be deleted
//
//  Returns:    S_OK.
//
//  Modifies:   Deletes the object pointed to by pMultiStream
//
//  Algorithm:  Delete the passed in pointer.
//
//  Notes:
//
//--------------------------------------------------------------------------

void DllReleaseMultiStream(CMStream *pms)
{
    msfDebugOut((DEB_TRACE,"In DllReleaseMultiStream(%p)\n",pms));
    delete pms;
    msfDebugOut((DEB_TRACE,"Out DllReleaseMultiStream()\n"));
}





//+-------------------------------------------------------------------------
//
//  Function:   DllIsMultiStream
//
//  Synopsis:   Check a given Lstream to determine if it is a valid
//              multistream.
//
//  Arguments:  [plst] -- Pointer to lstream to check
//
//  Returns:    S_OK if lstream is a valid multistream
//              STG_E_UNKNOWN otherwise
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllIsMultiStream(ILockBytes *plst)
{
    SCODE sc;
    CMSFHeader *phdr;

    phdr = new CMSFHeader(SECTORSHIFT512);
    msfMem(phdr);

    ULONG ulTemp;

    ULARGE_INTEGER ulOffset;
    ULISet32(ulOffset, 0);
    msfHChk(plst->ReadAt(ulOffset, phdr, sizeof(CMSFHeader), &ulTemp));
    phdr->ByteSwap();  // swap to machine format if neccessary

    if (ulTemp != sizeof(CMSFHeader))
    {
        msfErr(Err, STG_E_UNKNOWN);
    }

    msfChk(phdr->Validate());

Err:
    delete phdr;
    return sc;
}

#if DEVL == 1

//The following is a private function so I can set the debug level easily.
VOID SetInfoLevel(ULONG x)
{
    msfInfoLevel=x;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\page.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	page.cxx
//
//  Contents:	Paging code for MSF
//
//  Classes:	Defined in page.hxx
//
//  Functions:	
//
//----------------------------------------------------------------------------

#include "msfhead.cxx"



#include "mread.hxx"

//+---------------------------------------------------------------------
//
//  Member:	CMSFPage::Byteswap, public
//
//  Synopsis:	Byteswap the elments of the page
//
//  Algorithm:  Call the corresponding byteswap routine depending on the 
//              actual type of the Mutli-stream.
//
//----------------------------------------------------------------------

void CMSFPage::ByteSwap(void)
{
    CPagedVector* pVect = GetVector();
    if (pVect->GetParent()->GetHeader()->DiffByteOrder())
    {
        switch (_sid) 
        {
        case SIDDIR:
            ((CDirSect *)_ab)->
                ByteSwap( ((CDirVector*)pVect)->GetSectorSize() );        
        break;
        case SIDFAT:            
        case SIDMINIFAT:
        case SIDDIF:
            ((CFatSect *)_ab)->
                ByteSwap( ((CFatVector*)pVect)->GetSectBlock() );
            break;
        default:
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::CMSFPageTable, public
//
//  Synopsis:	CMSFPageTable constructor.
//
//  Arguments:	[pmsParent] -- Pointer to multistream for this page table.
//
//  Notes:	
//
//----------------------------------------------------------------------------

CMSFPageTable::CMSFPageTable( CMStream *const pmsParent,
                              const ULONG cMinPages,
                              const ULONG cMaxPages)
    : _pmsParent(pmsParent), _cActivePages(0), _cPages(0),
      _pmpCurrent(NULL),
      _cbSector(pmsParent->GetSectorSize()),
      _cMinPages(cMinPages), _cMaxPages(cMaxPages),
      _cReferences(1)    
{
}

//+---------------------------------------------------------------------------
//
//  Member:	CMSFPage::CMSFPage, public
//
//  Synopsis:	CMSFPage default constructor
//
//----------------------------------------------------------------------------

CMSFPage::CMSFPage(CMSFPage *pmp)
{
    if (pmp == NULL)
    {
        SetChain(this, this);
    }
    else
    {
        SetChain(pmp->GetPrev(), pmp);
        GetPrev()->SetNext(this);
        GetNext()->SetPrev(this);
    }

    SetSid(NOSTREAM);
    SetOffset(0);
    SetSect(ENDOFCHAIN);
    SetFlags(0);
    SetVector(NULL);
    _cReferences = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::~CMSFPageTable, public
//
//  Synopsis:	CMSFPageTable destructor
//
//----------------------------------------------------------------------------

CMSFPageTable::~CMSFPageTable()
{
    if (_pmpCurrent != NULL)
    {
        CMSFPage *pmp = _pmpCurrent;
        CMSFPage *pmpNext;

        while (pmp != pmp->GetNext())
        {
            pmpNext = pmp->GetNext();
#if DBG == 1
            msfAssert(!pmp->IsInUse() &&
                    aMsg("Active page left at page table destruct time."));

#endif
            delete pmp;
            pmp = pmpNext;
        }
        delete pmp;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::Init, public
//
//  Synopsis:	Initialize a CMSFPageTable
//
//  Arguments:	[cPages] -- Number of pages to preallocate.
//
//  Returns:	Appropriate status code
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::Init(void)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE, "In  CMSFPageTable::Init:%p()\n", this));

    for (ULONG i = 0; i < _cMinPages; i++)
    {
        CMSFPage *pmp;

        msfMem(pmp = GetNewPage());
        _pmpCurrent = pmp;
    }
    _cPages = _cMinPages;
    _cActivePages = 0;

    msfDebugOut((DEB_ITRACE, "Out CMSFPageTable::Init\n"));

 Err:

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FlushPage, public
//
//  Synopsis:	Flush a page
//
//  Arguments:	[pmp] -- Pointer to page to flush
//
//  Returns:	Appropriate status code
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::FlushPage(CMSFPage *pmp)
{
    SCODE sc = S_OK;

    pmp->AddRef();

    CMStream *pms;
    pms = pmp->GetVector()->GetParent();

    //Flush the page, reset the dirty bit.

    msfAssert((pmp->GetSect() != ENDOFCHAIN) &&
            aMsg("Page location not set - don't know where to flush to."));

    ULONG ulRet;

    ILockBytes *pilb;
    ULARGE_INTEGER ul;
    ul.QuadPart = ConvertSectOffset(
            pmp->GetSect(),
            0,
            pms->GetSectorShift());

    pilb = pms->GetILB();

    pmp->ByteSwap();            // convert to disk format 
                                // (if neccessary)                 
    msfHChk(pilb->WriteAt(
            ul,
            (BYTE *)(pmp->GetData()),
            _cbSector,
            &ulRet));
    
    pmp->ByteSwap();            // convert to back to machine format 
                                // (if neccessary)
    pmp->ResetDirty();

 Err:
    pmp->Release();
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::GetFreePage, public
//
//  Synopsis:	Return a pointer to a free page.
//
//  Arguments:	[ppmp] -- Pointer to storage for return pointer
//
//  Returns:	Appropriate status code
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::GetFreePage(CMSFPage **ppmp)
{
    SCODE sc = S_OK;
    CMSFPage *pmp;
    if (_cPages > _cActivePages)
    {
        //We have some unused page already allocated.  Find and return it.
        pmp = _pmpCurrent;

        do
        {
            pmp = pmp->GetNext();
        }
        while ((pmp != _pmpCurrent) && (pmp->GetSid() != NOSTREAM));

        msfAssert((pmp->GetSid() == NOSTREAM) &&
                aMsg("Expected empty page, none found."));

        *ppmp = pmp;
        _cActivePages++;
    }
    else if (_cPages == _cMaxPages)
    {
        msfMem(pmp = FindSwapPage());
        msfDebugOut((DEB_IERROR, "Got swap page %p\n",pmp));

        msfAssert((pmp->GetVector() != NULL) &&
                aMsg("FindSwapPage returned unowned page."));

        msfDebugOut((DEB_IERROR, "Freeing page %lu from vector %p\n",
                pmp->GetOffset(), pmp->GetVector()));


        if (pmp->IsDirty())
        {
            msfChk(FlushPage(pmp));
            msfAssert(!pmp->IsDirty() &&
                    aMsg("Page remained dirty after flush call"));
        }

        pmp->GetVector()->FreeTable(pmp->GetOffset());
#if DBG == 1
        pmp->SetVector(NULL);
#endif
        *ppmp = pmp;
    }
    else
    {
        //Create a new page and return it.
        pmp = GetNewPage();
        if (pmp != NULL)
        {
            *ppmp = pmp;
            _cActivePages++;
            _cPages++;
        }
        else
        {
            msfMem(pmp = FindSwapPage());
            if (pmp->IsDirty())
            {
                msfChk(FlushPage(pmp));
                msfAssert(!pmp->IsDirty() &&
                        aMsg("Page remained dirty after flush call"));
            }
            pmp->GetVector()->FreeTable(pmp->GetOffset());
#if DBG == 1
            pmp->SetVector(NULL);
#endif
            *ppmp = pmp;
        }
    }

 Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FindPage, public
//
//  Synopsis:	Find and return a given page
//
//  Arguments:  [ppv] -- Pointer to vector of page to return
//              [sid] -- SID of page to return
//              [ulOffset] -- Offset of page to return
//              [ppmp] -- Location to return pointer
//
//  Returns:	Appropriate status code
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::FindPage(
        CPagedVector *ppv,
        SID sid,
        ULONG ulOffset,
        CMSFPage **ppmp)
{
    SCODE sc;
    CMSFPage *pmp = _pmpCurrent;

    do
    {
        if ((pmp->GetVector() == ppv) && (pmp->GetOffset() == ulOffset))
        {
            //Bingo!

            *ppmp = pmp;
            return STG_S_FOUND;
        }

        pmp = pmp->GetNext();
    }
    while (pmp != _pmpCurrent);

    //The page isn't currently in memory.  Get a free page and
    //bring it into memory.

    msfChk(GetFreePage(&pmp));

    msfAssert((pmp->GetVector() == NULL) &&
            aMsg("Attempting to reassign owned page."));
    pmp->SetVector(ppv);
    pmp->SetSid(sid);
    pmp->SetOffset(ulOffset);
    pmp->SetSect(ENDOFCHAIN);

    *ppmp = pmp;

 Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::GetPage, public
//
//  Synopsis:	Find and return a given page
//
//  Arguments:	[sid] -- SID of page to return
//              [ulOffset] -- Offset of page to return
//              [ppmp] -- Location to return pointer
//
//  Returns:	Appropriate status code
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::GetPage(
        CPagedVector *ppv,
        SID sid,
        ULONG ulOffset,
        CMSFPage **ppmp)
{
    SCODE sc;

    *ppmp = NULL;
    msfChk(FindPage(ppv, sid, ulOffset, ppmp));

    (*ppmp)->AddRef();

    if (sc != STG_S_FOUND)
    {
        ULONG ulRet;
        SECT sect;

        msfChk(ppv->GetParent()->GetSect(sid, ulOffset, &sect));
        (*ppmp)->SetSect(sect);

        CMStream *pms = (*ppmp)->GetVector()->GetParent();
        
        ULARGE_INTEGER ul;
        ul.QuadPart = ConvertSectOffset(
                (*ppmp)->GetSect(),
                0,
                pms->GetSectorShift());

        msfAssert(pms->GetILB() != NULL &&
                  aMsg("NULL ILockBytes - missing SetAccess?"));

        msfHChk(pms->GetILB()->ReadAt(ul, (BYTE *)((*ppmp)->GetData()),
                _cbSector, &ulRet));
        (*ppmp)->ByteSwap();
    }

 Err:
    if (*ppmp != NULL)
    {
        (*ppmp)->Release();
    }

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::ReleasePage, public
//
//  Synopsis:	Release a given page
//
//  Arguments:	[sid] -- SID of page to release
//              [ulOffset] -- Offset of page to release
//
//----------------------------------------------------------------------------

void CMSFPageTable::ReleasePage(CPagedVector *ppv, SID sid, ULONG ulOffset)
{
    SCODE sc;
    CMSFPage *pmp;

    sc = FindPage(ppv, sid, ulOffset, &pmp);

    if (SUCCEEDED(sc))
    {
        pmp->Release();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::Flush, public
//
//  Synopsis:	Flush dirty pages to disk
//
//  Returns:	Appropriate status code
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::Flush(void)
{
    SCODE sc = S_OK;

    CMSFPage *pmp = _pmpCurrent;

    //We use pmpLast in case FlushPage changes _pmpCurrent.
    CMSFPage *pmpLast = _pmpCurrent;

    do
    {
        if ((pmp->IsDirty()) && !(pmp->IsInUse()))
        {
            msfChk(FlushPage(pmp));
        }

        pmp = pmp->GetNext();

    }
    while (pmp != pmpLast);

 Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FreePages, public
//
//  Synopsis:	Free all the pages associated with a vector.
//
//  Arguments:	[ppv] -- Pointer to vector to free pages for.
//
//----------------------------------------------------------------------------

void CMSFPageTable::FreePages(CPagedVector *ppv)
{
    CMSFPage *pmp = _pmpCurrent;

    do
    {
        if (pmp->GetVector() == ppv)
        {
            pmp->SetSid(NOSTREAM);
            pmp->SetVector(NULL);
            pmp->ResetDirty();
            _cActivePages--;
        }
        pmp = pmp->GetNext();
    }
    while (pmp != _pmpCurrent);

}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FindSwapPage, private
//
//  Synopsis:	Find a page to swap out.
//
//  Arguments:	None.
//
//  Returns:	Pointer to page to swap out.
//
//----------------------------------------------------------------------------

CMSFPage * CMSFPageTable::FindSwapPage(void)
{
#if DBG == 1
    ULONG cpInUse = 0;
#endif

    while (TRUE)
    {
        if (!_pmpCurrent->IsInUse())
        {
            DWORD dwFlags;

            dwFlags = _pmpCurrent->GetFlags();
            _pmpCurrent->SetFlags(dwFlags & ~FB_TOUCHED);
            _pmpCurrent = _pmpCurrent->GetNext();

            if (!(dwFlags & FB_TOUCHED))
            {
                return _pmpCurrent->GetPrev();
            }
        }
        else
        {
            _pmpCurrent = _pmpCurrent->GetNext();
        }
#if DBG == 1
        cpInUse++;
        msfAssert((cpInUse < 3 * _cPages) &&
                aMsg("No swappable pages."));
#endif

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\mstream.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:           mstream.cxx
//
//  Contents:       Mstream operations
//
//  Classes:        None. (defined in mstream.hxx)
//
//--------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/dirfunc.hxx"
#include "h/sstream.hxx"
#include "h/difat.hxx"
#include "h/msfiter.hxx"
#include <time.h>
#include "mread.hxx"
#include "h/docfilep.hxx"


#if DEVL == 1

DECLARE_INFOLEVEL(msf, DEB_ERROR)

#endif

#define MINPAGES 6
#define MAXPAGES 128

extern "C" WCHAR const wcsContents[] = 
	{'C','O','N','T','E','N','T','S','\0'};
extern "C" CDfName const dfnContents(wcsContents);
SCODE ILBFlush(ILockBytes *pilb, BOOL fFlushCache);

//+---------------------------------------------------------------------------
//
//  Function:	GetBuffer, public
//
//  Synopsis:	Gets a chunk of memory to use as a buffer
//
//  Arguments:	[cbMin] - Minimum size for buffer
//              [cbMax] - Maximum size for buffer
//              [ppb] - Buffer pointer return
//              [pcbActual] - Actual buffer size return
//
//  Returns:	Appropriate status code
//
//  Modifies:	[ppb]
//              [pcbActual]
//
//  Algorithm:  Attempt to dynamically allocate [cbMax] bytes
//              If that fails, halve allocation size and retry
//              If allocation size falls below [cbMin], fail
//
//  Notes:	Buffer should be released with FreeBuffer
//
//----------------------------------------------------------------------------

SCODE GetBuffer(USHORT cbMin, USHORT cbMax, BYTE **ppb, USHORT *pcbActual)
{
    USHORT cbSize;
    BYTE *pb;
    
    msfDebugOut((DEB_ITRACE, "In  GetBuffer(%hu, %hu, %p, %p)\n",
                 cbMin, cbMax, ppb, pcbActual));
    msfAssert(cbMin > 0);
    msfAssert(cbMax >= cbMin);
    msfAssert(ppb != NULL);
    msfAssert(pcbActual != NULL);
    
    cbSize = cbMax;
    for (;;)
    {
        pb = new BYTE[cbSize];
        if (pb == NULL)
        {
            cbSize >>= 1;
            if (cbSize < cbMin)
                break;
        }
        else
        {
            *pcbActual = cbSize;
            break;
        }
    }

    *ppb = pb;
    
    msfDebugOut((DEB_ITRACE, "Out GetBuffer => %p, %hu\n", *ppb, *pcbActual));
    return pb == NULL ? STG_E_INSUFFICIENTMEMORY : S_OK;
}

// Define the safe buffer size
#define SCRATCHBUFFERSIZE ((USHORT) 4096)
static BYTE s_buf[SCRATCHBUFFERSIZE];
static LONG s_bufRef = 0;



//+---------------------------------------------------------------------------
//
//  Function:	GetSafeBuffer, public
//
//  Synopsis:	Gets a buffer by first trying GetBuffer and if that fails,
//              returning a pointer to statically allocated storage.
//              Guaranteed to return a pointer to some storage.
//
//  Arguments:	[cbMin] - Minimum buffer size
//              [cbMax] - Maximum buffer size
//              [ppb] - Buffer pointer return
//              [pcbActual] - Actual buffer size return
//
//  Modifies:	[ppb]
//              [pcbActual]
//
//----------------------------------------------------------------------------

void GetSafeBuffer(USHORT cbMin, USHORT cbMax, BYTE **ppb, USHORT *pcbActual)
{
    msfAssert(cbMin > 0);
    msfAssert(cbMin <= SCRATCHBUFFERSIZE &&
              aMsg("Minimum too large for GetSafeBuffer"));
    msfAssert(cbMax >= cbMin);
    msfAssert(ppb != NULL);
    msfAssert(s_bufRef == 0 &&
              aMsg("Tried to use scratch buffer twice"));

    if (cbMax <= SCRATCHBUFFERSIZE ||
        FAILED(GetBuffer(cbMin, cbMax, ppb, pcbActual)))
    {
        s_bufRef = 1;
        *ppb = s_buf;
        *pcbActual = min(cbMax, SCRATCHBUFFERSIZE);
    }
    msfAssert(*ppb != NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:	FreeBuffer, public
//
//  Synopsis:	Releases a buffer allocated by GetBuffer or GetSafeBuffer
//
//  Arguments:	[pb] - Buffer
//
//----------------------------------------------------------------------------

void FreeBuffer(BYTE *pb)
{
    if (pb == s_buf)
    {
        msfAssert((s_bufRef == 1) && aMsg("Bad safe buffer ref count"));
        s_bufRef = 0;
    }
    else
        delete [] pb;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::CMStream, public
//
//  Synopsis:   CMStream constructor
//
//  Arguments:  [pplstParent] -- Pointer to ILockBytes pointer of parent
//              [plGen] -- Pointer to LUID Generator to use.
//                         Note:  May be NULL, in which case a new
//              [uSectorShift] -- Sector shift for this MStream
//
//--------------------------------------------------------------------------


CMStream::CMStream(
    ILockBytes **pplstParent,
    USHORT uSectorShift)
    :_uSectorShift(uSectorShift),
     _uSectorSize( (USHORT) (1 << uSectorShift) ),
     _uSectorMask((USHORT) (_uSectorSize - 1)),
     _pplstParent(pplstParent),
     _hdr(uSectorShift),
     _fatDif( (USHORT) (1<<uSectorShift) ),
     _fat(SIDFAT, (USHORT) (1<<uSectorShift), uSectorShift),
     _dir((USHORT) (1 << uSectorShift)),
     _fatMini(SIDMINIFAT, (USHORT) (1 << uSectorShift), uSectorShift)
{
    
    _pdsministream = NULL;
    _pmpt = NULL;
}




//+-------------------------------------------------------------------------
//
//  Method:     CMStream::InitCommon, private
//
//  Synopsis:   Common code for initialization routines.
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm: 
//
//--------------------------------------------------------------------------

SCODE  CMStream::InitCommon(VOID)
{
    msfDebugOut((DEB_ITRACE,"In CMStream InitCommon()\n"));
    SCODE sc = S_OK;

    msfAssert(_pmpt == NULL);
    msfMem(_pmpt = new CMSFPageTable(this, MINPAGES, MAXPAGES));
    msfChk(_pmpt->Init());

    msfDebugOut((DEB_ITRACE,"Leaving CMStream InitCommon()\n"));

    return sc;

Err:
    delete _pmpt;
    _pmpt = NULL;        
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMStream::GetESect, private
//
//  Synopsis:   For a given SID and sect, return the location of that
//              sector in the multistream.
//
//  Arguments:  [sid] -- SID of sector to locate
//              [sect] -- Offset into chain to locate
//              [psect] -- Pointer to return location.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  Notes:     
//
//----------------------------------------------------------------------------

SCODE CMStream::GetESect(SID sid, SECT sect, SECT *psect)
{
    SCODE sc = S_OK;

    SECT start;

    if (sid == SIDFAT)
    {
        msfChk(_fatDif.GetFatSect(sect, &start));
    }
    else if (sid == SIDDIF)
    {
        msfChk(_fatDif.GetSect(sect, &start));
    }
    else
    {
        start = GetStart(sid);
        msfChk(_fat.GetESect(start, sect, &start));
    }

    *psect = start;
Err:
    return sc;
										}

//+---------------------------------------------------------------------------
//
//  Member:	CMStream::Empty, public
//
//  Synopsis:	Empty all of the control structures of this CMStream
//
//  Arguments:	None.
//
//  Returns:	void.
//
//----------------------------------------------------------------------------


void CMStream::Empty(void)
{
    _fat.Empty();
    _fatMini.Empty();
    _fatDif.Empty();
    _dir.Empty();
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::~CMStream, public
//
//  Synopsis:   CMStream destructor
//
//--------------------------------------------------------------------------

 CMStream::~CMStream()
{

    msfDebugOut((DEB_ITRACE,"In CMStream destructor\n"));


    if (_pdsministream != NULL)
    {
        _pdsministream->Release();
    }

    if (_pmpt != NULL)
    {
        _pmpt->Release();
    }

    msfDebugOut((DEB_ITRACE,"Leaving CMStream destructor\n"));
}


//+-------------------------------------------------------------------------
//
//  Member:     CMStream::GetIterator, public
//
//  Synposis:   Create a new iterator for a given handle.
//
//  Effects:    Creates a new CMSFIterator
//
//  Arguments:  [sidParent] -- SID of entry to iterate over
//              [ppitRetval] -- Location for return of iterator pointer
//
//  Returns:    S_OK
//
//  Algorithm:  Create new iterator with parent of 'this' and nsi as given
//              by handle.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE  CMStream::GetIterator(
    SID const sidParent,
    CMSFIterator **ppitRetval)
{
    SCODE sc;

    msfDebugOut((DEB_TRACE,"In CMStream::GetIterator()\n"));

    SID sidChild;
    msfChk(_dir.GetChild(sidParent, &sidChild));

    msfDebugOut((DEB_ITRACE, "Getting an iterator for SID = %lu, "
                 "sidChild is %lu\n", sidParent, sidChild));
    msfMem(*ppitRetval = new CMSFIterator(GetDir(), sidChild));
    msfDebugOut((DEB_TRACE,"Leaving CMStream::GetIterator()\n"));

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMStream::Init, public
//
//  Synposis:   Set up an mstream instance from an existing stream
//
//  Effects:    Modifies Fat and Directory
//
//  Arguments:  void.
//
//  Returns:    S_OK if call completed OK.
//              Error of Fat or Dir setup otherwise.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE  CMStream::Init(VOID)
{
    ULONG ulTemp;
    SCODE sc;
    ULARGE_INTEGER ulOffset;


    msfDebugOut((DEB_ITRACE,"In CMStream::Init()\n"));


    msfChk(InitCommon());


    ULISet32(ulOffset, 0);
    msfHChk((*_pplstParent)->ReadAt(ulOffset, (BYTE *)(&_hdr),
                                    sizeof(CMSFHeader), &ulTemp));
    _hdr.ByteSwap();  // swap to memory/machine format if neccessary

    _uSectorShift = _hdr.GetSectorShift();
    _uSectorSize = (USHORT) (1 << _uSectorShift);
    _uSectorMask = (USHORT) (_uSectorSize - 1);

    if (ulTemp != sizeof(CMSFHeader))
    {
        msfErr(Err,STG_E_INVALIDHEADER);
    }

    msfChk(_hdr.Validate());

    msfChk(_fatDif.Init(this, _hdr.GetDifLength()));
    msfChk(_fat.Init(this, _hdr.GetFatLength(), 0));

    FSINDEX fsiLen;
    if (_uSectorShift > SECTORSHIFT512)
        fsiLen = _hdr.GetDirLength ();
    else
        msfChk(_fat.GetLength(_hdr.GetDirStart(), &fsiLen));
    msfChk(_dir.Init(this, fsiLen));

    msfChk(_fatMini.Init(this, _hdr.GetMiniFatLength(), 0));

    ULONGLONG ulSize;
    msfChk(_dir.GetSize(SIDMINISTREAM, &ulSize));
    msfMem(_pdsministream = new CDirectStream(MINISTREAM_LUID));
    _pdsministream->InitSystem(this, SIDMINISTREAM, ulSize);

    msfDebugOut((DEB_TRACE,"Out CMStream::Init()\n"));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CMStream::InitNew, public
//
//  Synposis:   Set up a brand new mstream instance
//
//  Effects:    Modifies FAT and Directory
//
//  Arguments:  [fDelay] -- If TRUE, then the parent LStream
//                  will be truncated at the time of first
//                  entrance to COW, and no writes to the
//                  LStream will happen before then.
//
//  Returns:    S_OK if call completed OK.
//
//---------------------------------------------------------------------------

SCODE CMStream::InitNew(VOID)
{
    SCODE sc;

    msfDebugOut((DEB_ITRACE,"In CMStream::InitNew()\n"));


    msfChk(InitCommon());

    ULARGE_INTEGER ulTmp;

    ulTmp.QuadPart = 0;
    (*_pplstParent)->SetSize(ulTmp);

    msfChk(_fatDif.InitNew(this));
    msfChk(_fat.InitNew(this));
    msfChk(_dir.InitNew(this));

    msfChk(_fatMini.InitNew(this));
        
    ULONGLONG ulSize;
    msfChk(_dir.GetSize(SIDMINISTREAM, &ulSize));

    msfMem(_pdsministream = new CDirectStream(MINISTREAM_LUID));
    _pdsministream->InitSystem(this, SIDMINISTREAM, ulSize);

        
    msfChk(Flush(0));
        

    msfDebugOut((DEB_TRACE,"Out CMStream::InitNew()\n"));
    return S_OK;

Err:
    Empty();

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::ConvertILB, private
//
//  Synopsis:	Copy the first sector of the underlying ILockBytes
//                      out to the end.
//
//  Arguments:	[sectMax] -- Total number of sectors in the ILockBytes
//
//  Returns:	Appropriate status code
//
//----------------------------------------------------------------------------

SCODE  CMStream::ConvertILB(SECT sectMax)
{
    SCODE sc;
    BYTE *pb;
    USHORT cbNull;

    GetSafeBuffer(GetSectorSize(), GetSectorSize(), &pb, &cbNull);

    ULONG ulTemp;

    ULARGE_INTEGER ulTmp;
    ULISet32(ulTmp, 0);

    msfHChk((*_pplstParent)->ReadAt(ulTmp, pb, GetSectorSize(), &ulTemp));

    ULARGE_INTEGER ulNewPos;
    ulNewPos.QuadPart = (ULONGLONG)(sectMax) << GetSectorShift();

    msfHChk((*_pplstParent)->WriteAt(
        ulNewPos,
        pb,
        GetSectorSize(),
        &ulTemp));

Err:
    FreeBuffer(pb);
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::InitConvert, public
//
//  Synopsis:   Init function used in conversion of files to multi
//              streams.
//
//  Arguments:  [fDelayConvert] -- If true, the actual file is not
//                                 touched until a BeginCopyOnWrite()
//
//  Returns:    S_OK if everything completed OK.
//
//  Algorithm:  *Finish This*
//
//  Notes:	We are allowed to fail here in low memory
//
//--------------------------------------------------------------------------

SCODE CMStream::InitConvert(VOID)
{
    SCODE sc;

    SECT sectMax;
    
    msfChk(InitCommon());

    STATSTG stat;
    (*_pplstParent)->Stat(&stat, STATFLAG_NONAME);


    sectMax = (SECT)((stat.cbSize.QuadPart + GetSectorSize() - 1) >>
        GetSectorShift());

    SECT sectMaxMini = 0;
    BOOL fIsMini;
    fIsMini = FALSE;

    //If the CONTENTS stream will be in the Minifat, compute
    //  the number of Minifat sectors needed.
    if (stat.cbSize.QuadPart < MINISTREAMSIZE)
    {
        sectMaxMini = (SECT)((stat.cbSize.QuadPart + 
                       MINISECTORSIZE - 1) >> MINISECTORSHIFT);
        fIsMini = TRUE;
    }

    
    msfChk(_fatDif.InitConvert(this, sectMax));
    msfChk(_fat.InitConvert(this, sectMax));
    msfChk(_dir.InitNew(this));
    msfChk(fIsMini ? _fatMini.InitConvert(this, sectMaxMini)
           : _fatMini.InitNew(this));


    SID sid;

    msfChk(CreateEntry(SIDROOT, &dfnContents, STGTY_STREAM, &sid));
    msfChk(_dir.SetSize(sid, stat.cbSize.QuadPart));

    if (!fIsMini)
        msfChk(_dir.SetStart(sid, sectMax - 1));
    else
    {
        msfChk(_dir.SetStart(sid, 0));
        msfChk(_dir.SetStart(SIDMINISTREAM, sectMax - 1));
        msfChk(_dir.SetSize(SIDMINISTREAM, stat.cbSize.QuadPart));
    } 

    ULONGLONG ulMiniSize;
    msfChk(_dir.GetSize(SIDMINISTREAM, &ulMiniSize));
    msfMem(_pdsministream = new CDirectStream(MINISTREAM_LUID));
    _pdsministream->InitSystem(this, SIDMINISTREAM, ulMiniSize);

    msfChk(ConvertILB(sectMax));

    msfChk(Flush(0));

    return S_OK;

Err:
    Empty();

    return sc;
}




//+-------------------------------------------------------------------------
//
//  Method:     CMStream::GetName, public
//
//  Synopsis:   Given a handle, return the current name of that entry
//
//  Arguments:  [sid] -- SID to find name for.
//
//  Returns:    Pointer to name.
//
//--------------------------------------------------------------------------


SCODE  CMStream::GetName(SID const sid, CDfName *pdfn)
{
    return _dir.GetName(sid, pdfn);
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::FlushHeader, public
//
//  Synopsis:   Flush the header to the LStream.
//
//  Arguments:  [uForce] -- Flag to determine if header should be
//                          flushed while in copy on write mode.
//
//  Returns:    S_OK if call completed OK.
//              S_OK if the MStream is in copy on write mode or
//                  is Unconverted and the header was not flushed.
//
//  Algorithm:  Write the complete header out to the 0th position of
//              the LStream.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE  CMStream::FlushHeader(USHORT uForce)
{
    ULONG ulTemp;
    SCODE sc;

    UNREFERENCED_PARM(uForce);
    msfDebugOut((DEB_ITRACE,"In CMStream::FlushHeader()\n"));

    ULARGE_INTEGER ulOffset;
    ULISet32(ulOffset, 0);
    _hdr.ByteSwap(); // swap to disk format if neccessary
    sc = DfGetScode((*_pplstParent)->
		    WriteAt(ulOffset, (BYTE *)(&_hdr),
			    sizeof(CMSFHeader), &ulTemp));
    _hdr.ByteSwap(); // swap to memort/machine format if neccessary
    msfDebugOut((DEB_ITRACE,"Out CMStream::FlushHeader()\n"));
    return sc;
}





//+-------------------------------------------------------------------------
//
//  Member:     CMStream::MWrite, public
//
//  Synposis:   Do multiple sector writes
//
//  Effects:    Causes multiple stream writes.  Modifies fat and directory
//
//  Arguments:  [ph] -- Handle of stream doing write
//              [start] -- Starting sector to write
//              [oStart] -- offset into sector to begin write at
//              [end] -- Last sector to write
//              [oEnd] -- offset into last sector to write to
//              [buffer] -- Pointer to buffer into which data will be written
//              [ulRetVal] -- location to return number of bytes written
//
//  Returns:    Error code of any failed call to parent write
//              S_OK if call completed OK.
//
//  Modifies:   ulRetVal returns the number of bytes written
//
//  Algorithm:  Using a segment table, perform writes on parent stream
//              until call is completed.
//
//  Notes:
//
//---------------------------------------------------------------------------



SCODE CMStream::MWrite(
    SID sid,
    BOOL fIsMini,
    ULONGLONG ulOffset,
    VOID const HUGEP *pvBuffer,
    ULONG ulCount,
    CStreamCache *pstmc,
    ULONG *pulRetval)
{
    SCODE sc;
    BYTE const HUGEP *pbBuffer = (BYTE const HUGEP *) pvBuffer;

    USHORT cbSector = GetSectorSize();
    CFat *pfat = &_fat;
    USHORT uShift = GetSectorShift();
    ULONG ulLastBytes = 0;

    ULARGE_INTEGER ulOff;
    ulOff.QuadPart = 0;

    ULONGLONG ulOldSize = 0;
    
    //  Check if it's a small stream and whether this is a real 
    //  multistream.

    if ((fIsMini) &&
        (SIDMINISTREAM != sid))
    {
        msfAssert(sid <= MAXREGSID &&
                  aMsg("Invalid SID in MWrite"));
        //  This stream is stored in the ministream

        cbSector = MINISECTORSIZE;
        uShift = MINISECTORSHIFT;
        pfat = GetMiniFat();
    }

    USHORT uMask = (USHORT) (cbSector - 1);

    SECT start = (SECT)(ulOffset >> uShift);
    OFFSET oStart = (OFFSET)(ulOffset & uMask);

    SECT end = (SECT)((ulOffset + ulCount - 1) >> uShift);
    OFFSET oEnd = (OFFSET)((ulOffset + ulCount - 1) & uMask);

    msfDebugOut((DEB_ITRACE,"In CMStream::MWrite(%lu,%u,%lu,%u)\n",
                 start,oStart,end,oEnd));

    ULONG bytecount;
    ULONG total = 0;

    msfChk(_dir.GetSize(sid, &ulOldSize));



    msfAssert(end != 0xffffffffL);

    if (end < start)
    {
        *pulRetval = total + ulLastBytes;
        goto Err;
    }

    ULONG ulRunLength;
    ulRunLength = end - start + 1;
    SECT sectSidStart;

    USHORT offset;
    offset = oStart;

    while (TRUE)
    {
        SSegment segtab[CSEG + 1];
        SECT sect;

        if (start > pstmc->GetOffset())
        {
            msfChk(pfat->GetESect(
                pstmc->GetSect(),
                start - pstmc->GetOffset(),
                &sect));
        }
        else if (start == pstmc->GetOffset())
        {
            sect = pstmc->GetSect();
        }
        else
        {
            msfChk(_dir.GetStart(sid, &sectSidStart));
            msfChk(pfat->GetESect(sectSidStart, start, &sect));
        }

        msfChk(pfat->Contig(
            (SSegment STACKBASED *) segtab,
            sect,
            ulRunLength));

        USHORT oend = (USHORT) (cbSector - 1);
        ULONG i = 0;
        SECT sectStart = ENDOFCHAIN;
        for (USHORT iseg = 0; iseg < CSEG;)
        {
            sectStart = segtab[iseg].sectStart;
            i = segtab[iseg].cSect;

            if (i > ulRunLength)
                i = ulRunLength;

            ulRunLength -= i;
            start += i;

            iseg++;
            if (segtab[iseg].sectStart == ENDOFCHAIN)
            {
                msfAssert(ulRunLength==0);
                oend = oEnd;
            }

            ULONG ulSize = ((i - 1) << uShift) - offset + oend + 1;

            msfDebugOut((
                DEB_ITRACE,
                "Calling lstream WriteAt(%lu,%p,%lu)\n",
                ConvertSectOffset(sectStart,offset,uShift),
                pbBuffer,
                ulSize));

            if (GetMiniFat() == pfat)
            {
                sc = _pdsministream->CDirectStream::WriteAt(
                    (sectStart << uShift) + offset,
                    pbBuffer, ulSize,
                    (ULONG STACKBASED *)&bytecount);
            }
            else
            {
                ulOff.QuadPart = ConvertSectOffset(sectStart, offset,
                                                   uShift);
                sc = DfGetScode((*_pplstParent)->WriteAt(ulOff, pbBuffer,
                                                         ulSize, &bytecount));
            }

            total += bytecount;

            //Check if this write is the last one in the stream,
            //   and that the stream ends as a partial sector.
            //If so, fill out the remainder of the sector with
            //   something.
            if ((0 == ulRunLength) && (total + ulOffset > ulOldSize) &&
                (((total + ulOffset) & (GetSectorSize() - 1)) != 0))
            {
                //This is the last sector and the stream has grown.
                ULONG csectOld = (SECT)((ulOldSize + GetSectorSize() - 1) >>
                    GetSectorShift());

                ULONG csectNew = (SECT)((total + ulOffset + GetSectorSize() - 1) >>
                    GetSectorShift());

                if (csectNew > csectOld)
                {
                    msfAssert(!fIsMini &&
                              aMsg("Small stream grew in MWrite"));
                    
                    SECT sectLast = sectStart + i - 1;
                    
                    msfVerify(SUCCEEDED(SecureSect(
                        sectLast,
                        total + ulOffset,
                        FALSE)));
                }
            }
            
            if (0 == ulRunLength || FAILED(sc))
            {
                break;
            }

            pbBuffer = pbBuffer + bytecount;
            offset = 0;
        }

        pstmc->SetCache(start -1, sectStart + i - 1);
        
        if (0 == ulRunLength || FAILED(sc))
        {
            *pulRetval = total + ulLastBytes;
            msfDebugOut((
                DEB_TRACE,
                "Out CMStream::MWrite()=>%lu, retval = %lu\n",
                sc,
                total));
            break;
        }
    }

Err:
    //  We need this flush of the directory structures because we may have
    //  remapped the first sector in a chain.

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMStream::Flush, public
//
//  Synopsis:	Flush control structures.
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//----------------------------------------------------------------------------


SCODE CMStream::Flush(BOOL fFlushCache)
{
    SCODE sc = S_OK;

    msfChk(_dir.Flush());
    msfChk(_fatMini.Flush());
    msfChk(_fat.Flush());
    msfChk(_fatDif.Flush());
    
    msfChk(FlushHeader(HDR_NOFORCE));
    msfChk(ILBFlush(*_pplstParent, fFlushCache));
Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Function:   ILBFlush
//
//  Synopsis:   Flush as thoroughly as possible
//
//  Effects:    Flushes ILockBytes
//
//  Arguments:  [pilb]        - ILockBytes to flush
//              [fFlushCache] - Flush thoroughly iff TRUE
//
//  Returns:    SCODE
//
//  Algorithm:
//
//--------------------------------------------------------------------------

SCODE ILBFlush(ILockBytes *pilb, BOOL fFlushCache)
{    
    SCODE sc;
    UNREFERENCED_PARM(fFlushCache);  // no cache used here

    msfDebugOut((DEB_ITRACE, "In ILBFlushCache(%p)\n", pilb));

    sc = DfGetScode(pilb->Flush());

    msfDebugOut((DEB_ITRACE, "Out ILBFlushCache()\n"));

    return(sc);
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::SecureSect, public
//
//  Synopsis:	Zero out the unused portion of a sector
//
//  Arguments:	[sect] -- Sector to zero out
//              [ulSize] -- Size of stream
//              [fIsMini] -- TRUE if stream is in ministream
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMStream::SecureSect(
    const SECT sect,
    const ULONGLONG ulSize,
    const BOOL fIsMini)
{
    SCODE sc = S_OK;
    BYTE *pb = NULL;
    
    ULONG cbSect = fIsMini ? MINISECTORSIZE : GetSectorSize();
    
    msfAssert(ulSize != 0);
        
    OFFSET ulOffset = (OFFSET)((ulSize - 1) % cbSect) + 1;
    
    ULONG cb = cbSect - ulOffset;
    
    msfAssert(cb != 0);
    
    // We can use any initialized block of memory here.  The header
    // is available and is the correct size, so we use that.
    pb = (BYTE *)&_hdr;

    ULONG cbWritten;
    
    if (!fIsMini)
    {
        ULARGE_INTEGER ulOff;
        ulOff.QuadPart = ConvertSectOffset( sect, ulOffset,
                                    GetSectorShift());
        
        msfChk(DfGetScode((*_pplstParent)->
                          WriteAt( ulOff, pb, cb, &cbWritten)));
    }
    else
    {
        msfChk(_pdsministream->WriteAt(
            (sect << MINISECTORSHIFT) + ulOffset,
            pb, cb, (ULONG STACKBASED *)&cbWritten));
    }
        
    if (cbWritten != cb)
    {
        sc = STG_E_WRITEFAULT;
    }
    
Err:
    
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\msfiter.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       msfiter.cxx
//
//  Contents:   Iterator code for MSF
//
//  Classes:    None. (Defined in iter.hxx)
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/dirfunc.hxx"
#include "h/msfiter.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CMSFIterator::GetNext, public
//
//  Synposis:   Fill in a stat buffer for the next iteration entry
//
//  Effects:    Modifies _sidCurrent
//
//  Arguments:  [pstat] - Stat buffer
//
//  Returns:    S_OK if call completed OK.
//              STG_E_NOMOREFILES if no next entry was found.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CMSFIterator::GetNext(STATSTGW *pstat)
{
    SCODE sc;
    SID sidNext;
    msfDebugOut((DEB_TRACE,"In CMSFIterator::GetNext()\n"));

    if (_sidChildRoot == NOSTREAM)
        msfChk(STG_E_NOMOREFILES);

    msfChk(_pdir->FindGreaterEntry(_sidChildRoot, &_dfnCurrent, &sidNext));

    //  We found another child
    CDirEntry *pde;

    msfChk(_pdir->GetDirEntry(sidNext, FB_NONE, &pde));
    pstat->type = pde->GetFlags();

    //Note:  The casting below assumes that DfName is always a
    //          wide character string.  If we at some point in
    //          the future convert to a system where this is not
    //          true, this code needs to be updated.

    msfChk(DfAllocWCS((WCHAR *)pde->GetName()->GetBuffer(), &pstat->pwcsName));
    wcscpy(pstat->pwcsName, (WCHAR *)pde->GetName()->GetBuffer());

    pstat->ctime = pde->GetTime(WT_CREATION);
    pstat->mtime = pde->GetTime(WT_MODIFICATION);

    //Don't currently keep access times
    pstat->atime = pstat->mtime;

    if ((pstat->type & STGTY_REAL) == STGTY_STORAGE)
    {
        pstat->cbSize.QuadPart = 0;
        pstat->clsid = pde->GetClassId();
        pstat->grfStateBits = pde->GetUserFlags();
    }
    else
    {
        pstat->cbSize.QuadPart = pde->GetSize(_pdir->IsLargeSector());
        pstat->clsid = CLSID_NULL;
        pstat->grfStateBits = 0;
    }

    // update our iterator
    _dfnCurrent.Set(pde->GetName());

    _pdir->ReleaseEntry(sidNext);

    msfDebugOut((DEB_TRACE,"Leaving CMSFIterator::GetNext()\n"));
    // Fall through
Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	CMSFIterator::BufferGetNext, public
//
//  Synopsis:	Fast, fixed-size buffer version of GetNext
//		for iterations that don't care about having
//		full stat info and an allocated name
//
//  Arguments:	[pib] - Buffer to fill in
//
//  Returns:	Appropriate status code
//
//  Modifies:	[pib]
//
//---------------------------------------------------------------


SCODE CMSFIterator::BufferGetNext(SIterBuffer *pib)
{
    SCODE sc;
    SID sidNext;
    CDirEntry *pdeNext;

    msfDebugOut((DEB_ITRACE, "In  CMSFIterator::BufferGetNext(%p)\n", pib));

    if (_sidChildRoot == NOSTREAM)
        msfChk(STG_E_NOMOREFILES);

    msfChk(_pdir->FindGreaterEntry(_sidChildRoot, &_dfnCurrent, &sidNext));

    msfChk(_pdir->GetDirEntry(sidNext, FB_NONE, &pdeNext));
    pib->type = pdeNext->GetFlags();
    pib->dfnName = *(pdeNext->GetName());

    //  update our iterator
    _dfnCurrent.Set(pdeNext->GetName());

    _pdir->ReleaseEntry(sidNext);
    msfDebugOut((DEB_ITRACE, "Out CMSFIterator::BufferGetNext\n"));
    // Fall through
Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\rexpdf.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       rpubdf.cxx
//
//  Contents:   CRootPubDocFile implementation
//
//---------------------------------------------------------------

#include "dfhead.cxx"

#include "h/header.hxx"
#include "h/rexpdf.hxx"
#include "dfbasis.hxx"
#include "h/tchar.h"

// Priority mode lock permissions
#define PRIORITY_PERMS DF_READ

//+--------------------------------------------------------------
//
//  Member:     CRootExposedDocFile::CRootExposedDocFile, public
//
//  Synopsis:   Ctor - Initializes empty object
//
//---------------------------------------------------------------


CRootExposedDocFile::CRootExposedDocFile(CDFBasis *pdfb) :
    CExposedDocFile(NULL, NULL, 0, ROOT_LUID, NULL, NULL, NULL, pdfb)
{
    olDebugOut((DEB_ITRACE, "CRootExposedDocFile constructor called\n"));
}


//+--------------------------------------------------------------
//
//  Member:     CRootExposedDocFile::Init, private
//
//  Synopsis:   Dependent root initialization
//
//  Arguments:  [plstBase] - Base
//              [snbExclude] - Limited instantiation exclusions
//              [dwStartFlags] - Startup flags
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CRootExposedDocFile::Init( ILockBytes *plstBase,
                                 SNBW snbExclude,
                                 DWORD const dwStartFlags)
{
    CDocFile *pdf;
    SCODE sc;
    CMStream *pms;

    olDebugOut((DEB_ITRACE, "In  CRootExposedDocFile::Init()\n"));
    if (snbExclude)
    {
        olChk(DllMultiStreamFromStream(&pms, &plstBase, dwStartFlags));
        olMemTo(EH_pms,
                pdf = new CDocFile(pms, SIDROOT, ROOT_LUID, _pilbBase));
        pdf->AddRef();
        olChkTo(EH_pdf, pdf->ExcludeEntries(pdf, snbExclude));
        olChkTo(EH_pdf, pms->Flush(0));
        pdf->Release();
    }
    plstBase->AddRef();
    _pilbBase = plstBase;
    olDebugOut((DEB_ITRACE, "Out CRootExposedDocFile::Init()\n"));
    return S_OK;

EH_pdf:
    pdf->Release();
EH_pms:
    DllReleaseMultiStream(pms);
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CRootExposedDocFile::InitRoot, public
//
//  Synopsis:   Initialising a root storage
//
//  Arguments:  [plstBase] - Base LStream
//              [dwStartFlags] - How to start things
//              [df] - Transactioning flags
//              [snbExclude] - Parital instantiation list
//              [ppdfb] - Basis pointer return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfb]
//
//---------------------------------------------------------------

SCODE CRootExposedDocFile::InitRoot( ILockBytes *plstBase,
                                     DWORD const dwStartFlags,
                                     DFLAGS const df,
                                     SNBW snbExclude)
{
    CDocFile *pdfBase;
    SCODE sc, scConv = S_OK;
    STATSTG statstg;

    olDebugOut((DEB_ITRACE, "In  CRootExposedDocFile::InitRoot("
                "%p, %lX, %lX, %p)\n",
                plstBase, dwStartFlags, df, snbExclude));    

    // Exclusion only works with a plain open
    olAssert(snbExclude == NULL ||
             (dwStartFlags & (RSF_CREATEFLAGS | RSF_CONVERT)) == 0);

    olHChk(plstBase->Stat(&statstg, STATFLAG_NONAME));

    olChkTo(EH_GetPriority,    
            Init(plstBase, snbExclude, dwStartFlags));    
    
    scConv = DllMultiStreamFromStream(&_pmsBase, &_pilbBase,
                                      dwStartFlags);
    if (scConv == STG_E_INVALIDHEADER)
        scConv = STG_E_FILEALREADYEXISTS;
    olChkTo(EH_pfstScratchInit, scConv);
    
    olMemTo(EH_pmsBase,
            pdfBase = new CDocFile(_pmsBase, SIDROOT, ROOT_LUID, _pilbBase));

    pdfBase->AddRef();
    
    _pdf = pdfBase;
    _df = df;
    olDebugOut((DEB_ITRACE, "Out CRootExposedDocFile::InitRoot\n"));
    return scConv;    
    
EH_pmsBase:
    DllReleaseMultiStream(_pmsBase);

EH_pfstScratchInit:
EH_GetPriority:
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CRootExposedDocFile::~CRootExposedDocFile, 
//                                      public virutal
//
//  Synopsis:   dtor (virtual)
//
//---------------------------------------------------------------


CRootExposedDocFile::~CRootExposedDocFile(void)
{
    olDebugOut((DEB_TRACE, "In CRootExposedDocFile::~CRootExposedDocFile\n"));

    olAssert(_cReferences == 0);

    if (SUCCEEDED(CheckReverted()))
    {
        if (_pilbBase) {
            _pilbBase->Release();
            _pilbBase = NULL;
        }
    }
    olDebugOut((DEB_TRACE, "Out CRootExposedDocFile::~CRootExposedDocFile\n"));
}

//+-------------------------------------------------------------------
//
//  Member:     CRootExposedDocFile::Stat, public 
//                                         virtual fr. CExposedDocFile
//
//  Synopsis:   Fills in a stat buffer from the base LStream
//
//  Arguments:  [pstatstg] - Stat buffer
//              [grfStatFlag] - Stat flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//--------------------------------------------------------------------


SCODE CRootExposedDocFile::Stat(STATSTGW *pstatstgw, DWORD grfStatFlag)
{
    SCODE sc;
    STATSTG *pstatstg= (STATSTG*)pstatstgw;

    olDebugOut((DEB_ITRACE, "In  CRootExposedDocFile::Stat(%p, %lu)\n",
                pstatstg, grfStatFlag));
    olChk(ValidateOutBuffer(pstatstg, sizeof(STATSTGW)));
    olChk(VerifyStatFlag(grfStatFlag));
    olChk(CheckReverted());
    olHChk(_pilbBase->Stat(pstatstg, grfStatFlag));    
    pstatstg->type = STGTY_STORAGE;
    ULISet32(pstatstg->cbSize, 0);  //  size undefined for storage obj
    pstatstg->grfLocksSupported = 0;
    pstatstg->reserved = 0;
    if (pstatstg->pwcsName)
    {
        // pilbBase returns either wide or ansi names depending on
        // system type, so we have to convert to ANSI char if neccessay
        WCHAR *pwcs;
        olChkTo(EH_pwcsName,
                DfAllocWC(_tcslen(pstatstg->pwcsName)+1, &pwcs));
        TTOW(pstatstg->pwcsName, pwcs, _tcslen(pstatstg->pwcsName)+1);
        delete[] pstatstg->pwcsName;
        pstatstgw->pwcsName = pwcs;
    }
    pstatstg->grfMode = DFlagsToMode(_df);
    olChkTo(EH_pwcsName, _pdf->GetClass(&pstatstg->clsid));
    olChkTo(EH_pwcsName, _pdf->GetStateBits(&pstatstg->grfStateBits));
    olDebugOut((DEB_ITRACE, "Out CRootExposedDocFile::Stat\n"));
    return S_OK;

EH_pwcsName:
    if (pstatstg->pwcsName)
    delete[] pstatstg->pwcsName;
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\refilb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	refilb.cxx
//
//  Contents:	Reference ILockBytes class
//
//  Classes:	CFileILB
//
//  Notes:      This Class always call single byte I/O routines
//              because most systems only have support for single byte
//              I/O. This makes the code more portable.
//
//----------------------------------------------------------------------------


#include "msfhead.cxx"
#include <errno.h>
#include "h/refilb.hxx"
#include <stdio.h>
#include <stdlib.h>

#include <sys/stat.h>
#include "time.hxx"
#include "h/tchar.h"

#ifdef _WIN32
#include <io.h> // to get definition of wunlink
#else
#include <unistd.h>
// get the correct stat structure
#endif

#include <stdlib.h>
#include "h/ole.hxx"

DECLARE_INFOLEVEL(ol, DEB_ERROR)

static int filenum = 0;

char * GetTempFileName(void)
{
    char *psz = new char[_MAX_PATH +1];
    strcpy(psz, "dft");

    _itoa(filenum, psz + 3, 10);
    filenum++;
    return psz;
}

CFileILB::CFileILB(const TCHAR *pszName,
                   DWORD grfMode,
                   BOOL fOpenFile/* =TRUE */)
{
    _pszName = NULL;

    _fDelete = FALSE;
    if (pszName == NULL)
    {
         _pszName = GetTempFileName();
         _unlink(_pszName);            // make sure file is over written
         _fDelete |= ILB_DELETEONERR;  // don't want to keep scratch files
    }
    else
    {
        _pszName = new char[_MAX_PATH + 1];
        TTOS(pszName, _pszName, _tcslen(pszName)+1);
    }

    if (grfMode & STGM_DELETEONRELEASE)
        _fDelete |= ILB_DELETEONRELEASE;
    _f = NULL;
    if (fOpenFile)
    {
        // disregard if file is already there
	Create(STGM_CREATE|STGM_READWRITE);
        // got to open the file with this option
        olAssert(_f && "CFileILB could not open the file!");
    }
    _ulRef = 1;
}

static const char pcszReadOnly[] ="rb";
static const char pcszReadWrite[] = "r+b";
static const char pcszWrite[] = "w+b";

SCODE CFileILB::Create(DWORD grfMode)
{
    char const *pszMode = pcszReadOnly; // default

    if (grfMode & STGM_READWRITE)
        pszMode = pcszReadWrite;
    else
        olDebugOut((DEB_ITRACE, "CFileILB::Create called with Read Only!!\n"));

    _f = fopen(_pszName, pszMode);
    if (_f)                     // open succeeded
    {
        if ((grfMode & (STGM_CREATE|STGM_CONVERT) ) == STGM_FAILIFTHERE)
            return STG_E_FILEALREADYEXISTS;
    }
    else if (errno==EACCES && (grfMode & STGM_CONVERT))
    {
        olDebugOut((DEB_ERROR,"Access Denied in CFileILB::Create\n"));
        return STG_E_ACCESSDENIED;
    }
    else
    {
        // the file does not exists, create the file
        _f = fopen(_pszName, pcszWrite);
        if (_f==NULL)
        {
            // we could not create the file for some reason
            // return the appropriate error code
            if (errno== EACCES)
                return STG_E_ACCESSDENIED;
            else
            {
                return STG_E_INVALIDNAME; // assume it is an invalid name
            }
        }
        else
        {
            // the newly create file should be deleted on error
            _fDelete |= ILB_DELETEONERR;
        }
    }
    return S_OK;
}

SCODE CFileILB::Open(DWORD grfMode)
{
    char const *pszMode = pcszReadOnly; // default

    // this means an null named file
    olAssert( (_fDelete & ILB_DELETEONERR)==0 );
                                                  // has been opened
    if (grfMode & STGM_READWRITE)
        pszMode = pcszReadWrite;
    else
        olDebugOut((DEB_ITRACE, "CFileILB::Open called with Read Only!!\n"));

    _f = fopen(_pszName, pszMode);
    if (_f == NULL)
    {
        if (errno==EACCES) return STG_E_ACCESSDENIED;
        else if (errno==ENOENT) return STG_E_FILENOTFOUND;
        else return STG_E_INVALIDNAME; // we assume that the name is invalid
    }

    return S_OK;
}

CFileILB::~CFileILB()
{
    if (_f)
        fclose(_f);
    if (_fDelete & ILB_DELETEONRELEASE)
    {
         // nothing we can do if the file cannot be deleted somehow
         // since the ref impl. is not multi-thread safe
        _unlink(_pszName);
    }
    delete _pszName;
}

STDMETHODIMP CFileILB::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;
    UNREFERENCED_PARM(riid);
    olAssert(FALSE && aMsg("function not implemented!"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

STDMETHODIMP_(ULONG) CFileILB::AddRef(void)
{
    AtomicInc(&_ulRef);
    return(_ulRef);
}

STDMETHODIMP_(ULONG) CFileILB::Release(void)
{
    AtomicDec(&_ulRef);
    olDebugOut( (DEB_ITRACE, "CFileILB::Release => %lx\n", _ulRef) );
    if (_ulRef > 0)
        return(_ulRef);
    delete this;

    return(0);
}

ULONG CFileILB::ReleaseOnError(void)
{
    // this function should be not used otherwise
    olAssert(_ulRef == 1);

    // Delete the file if it is a file we just created
    if (_fDelete & ILB_DELETEONERR)
        _fDelete |= ILB_DELETEONRELEASE;
    return( Release() );
}

ULONG CFileILB::Seek (ULONGLONG ulPos)
{
    ULONG ulRet = 0;

    if (ulPos > MAX_ULONG)
    {
        fseek(_f, MAX_ULONG, SEEK_SET);
        while (ulPos > MAX_ULONG)
        {
            ulPos -= MAX_ULONG;
            if (ulPos > MAX_ULONG)
                ulRet = fseek(_f, MAX_ULONG, SEEK_CUR);
            else
                ulRet = fseek(_f, (long) ulPos, SEEK_CUR);
        }
    }
    else ulRet = fseek(_f, (long) ulPos, SEEK_SET);
    
    return ulRet;
}

STDMETHODIMP CFileILB::ReadAt(ULARGE_INTEGER ulPosition,

        VOID HUGEP *pb,
        ULONG cb,
        ULONG *pcbRead)
{
    Seek (ulPosition.QuadPart);

    *pcbRead = fread(pb, 1, cb, _f);
    return NOERROR;
}

STDMETHODIMP CFileILB::WriteAt(ULARGE_INTEGER ulPosition,
        VOID const HUGEP *pb,
        ULONG cb,
        ULONG FAR *pcbWritten)
{
    Seek (ulPosition.QuadPart);

    *pcbWritten = fwrite(pb, 1, cb, _f);
    return NOERROR;
}

STDMETHODIMP CFileILB::Flush(void)
{
    fflush(_f);
    return NOERROR;
}

STDMETHODIMP CFileILB::SetSize(ULARGE_INTEGER ulNewSize)
{
    LONGLONG cbNewSize = ulNewSize.QuadPart;
    LONGLONG cbCurrentSize = _filelengthi64 (_fileno(_f));
    if(-1 == cbCurrentSize)
        return STG_E_SEEKERROR;

    if(cbCurrentSize < cbNewSize)
    {                                       // Increase the Size
        Seek (cbNewSize-1);

        if(1 != fwrite("", 1, 1, _f))
            return STG_E_WRITEFAULT;
    }
    else if(cbCurrentSize > cbNewSize)
    {                                       // Decrease the Size
        //  OS specific: file truncation.
    }
    return NOERROR;
}

STDMETHODIMP CFileILB::LockRegion(ULARGE_INTEGER libOffset,
                                  ULARGE_INTEGER cb,
                                  DWORD dwLockType)
{
    UNREFERENCED_PARM(dwLockType);
    UNREFERENCED_PARM(cb);
    UNREFERENCED_PARM(libOffset);
    olAssert(FALSE && aMsg("function not implemented!"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}


STDMETHODIMP CFileILB::UnlockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
{
    UNREFERENCED_PARM(dwLockType);
    UNREFERENCED_PARM(cb);
    UNREFERENCED_PARM(libOffset);
    olAssert(FALSE && aMsg("function not implemented!"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}


STDMETHODIMP CFileILB::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    memset(pstatstg, 0, sizeof(STATSTG));

    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
         char pchTemp[_MAX_PATH+1];
        _fullpath(pchTemp, _pszName, _MAX_PATH+1);
        pstatstg->pwcsName = new TCHAR[strlen(pchTemp)+1];
        STOT(pchTemp, pstatstg->pwcsName, strlen(pchTemp)+1);
    }

    pstatstg->type = STGTY_LOCKBYTES;

    fseek(_f, 0, SEEK_END);
    pstatstg->cbSize.QuadPart = ftell(_f);

    // just return a default, the function that calls this should fill in
    // the structure.
    pstatstg->grfMode = STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE;

    struct _stat buf;
    int result = _stat(_pszName, &buf);
    if (!result)  // fill in zeros
    {
        pstatstg->atime.dwLowDateTime = pstatstg->atime.dwHighDateTime = 0;
        pstatstg->mtime.dwLowDateTime = pstatstg->mtime.dwHighDateTime = 0;
        pstatstg->ctime.dwLowDateTime = pstatstg->ctime.dwHighDateTime = 0;
    }
    else
    {
        TimeTToFileTime(&buf.st_atime, &pstatstg->atime);
        TimeTToFileTime(&buf.st_mtime, &pstatstg->mtime);
        TimeTToFileTime(&buf.st_ctime, &pstatstg->ctime);
    }
    return NOERROR;
}

EXTERN_C STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return (memcmp(&rguid1, &rguid2, sizeof(GUID)) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\h\dfver.h ===
#define rmj		3
#define rmm		62
#define rup		0
#define rmjlarge 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\sstream.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:           sstream.cxx
//
//  Contents:       Stream operations for Mstream project
//
//  Classes:        None. (defined in sstream.hxx)
//
//--------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/dirfunc.hxx"
#include "h/sstream.hxx"
#include <time.h>
#include "mread.hxx"

#define DEB_STREAM (DEB_ITRACE | 0x00020000)


//+--------------------------------------------------------------
//
//  Member:	CDirectStream::CDirectStream, public
//
//  Synopsis:	Empty object constructor
//
//  Arguments:  [dl] - LUID
//
//---------------------------------------------------------------

CDirectStream::CDirectStream(DFLUID dl)
    : PEntry(dl) 
{
    _cReferences = 0;
}


//+--------------------------------------------------------------
//
//  Member:	CDirectStream::InitSystem, public
//
//  Synopsis:	Initializes special system streams like the ministream
//
//  Arguments:	[pms] - Multistream
//		[sid] - SID
//		[cbSize] - size
//
//---------------------------------------------------------------

void CDirectStream::InitSystem(CMStream *pms,
			       SID sid,
			       ULONGLONG cbSize)
{
    _stmh.Init(pms, sid);
    _ulSize = _ulOldSize = cbSize;
    AddRef();
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectStream::Init, public
//
//  Synopsis:   CDirectStream constructor
//
//  Arguments:  [pstgh] - Parent
//		[pdfn] - Name of entry
//		[fCreate] - Create or get
//
//  Returns:	Appropriate status code
//
//--------------------------------------------------------------------------

SCODE CDirectStream::Init(
        CStgHandle *pstgh,
        CDfName const *pdfn,
        BOOL const fCreate)
{
    SCODE sc;

    if (fCreate)
        sc = pstgh->CreateEntry(pdfn, STGTY_STREAM, &_stmh);
    else
        sc = pstgh->GetEntry(pdfn, STGTY_STREAM, &_stmh);
    if (SUCCEEDED(sc))
    {
	sc = _stmh.GetSize(&_ulSize);
	_ulOldSize = _ulSize;
        if (SUCCEEDED(sc))
            AddRef();
    }
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectStream::~CDirectStream, public
//
//  Synopsis:   CDirectStream destructor
//
//  Notes:
//
//--------------------------------------------------------------------------

CDirectStream::~CDirectStream()
{
    msfAssert(_cReferences == 0);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectStream::ReadAt, public
//
//  Synposis:   Reads binary data from a linear single stream
//
//  Arguments:  [ulOffset] -- Position to be read from
//
//              [pBuffer] -- Pointer to the area into which the data
//                           will be read.
//              [ulCount] --  Indicates the number of bytes to be read
//              [pulRetval] -- Area into which return value will be stored
//
//  Returns:    Error Code of parent MStream call
//
//  Algorithm:  Calculate start and end sectors and offsets, then
//              pass call up to parent MStream.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CDirectStream::ReadAt(
        ULONGLONG ulOffset,
        VOID HUGEP *pBuffer,
        ULONG ulCount,
        ULONG STACKBASED *pulRetval)
{
    msfDebugOut((DEB_TRACE,"In CDirectStream::ReadAt(%lu,%p,%lu)\n",
                           ulOffset,pBuffer,ulCount));

    SCODE sc = S_OK;

    CMStream *pms = _stmh.GetMS();


    //  Check for offset beyond stream size and zero count

    if ((ulOffset >= _ulSize) || (0 == ulCount))
    {
        *pulRetval = 0;
        return S_OK;
    }

    if (ulOffset + ulCount > _ulSize)
    {
        msfDebugOut((DEB_ITRACE,"Truncating Read: ulOffset = %lu, ulCount = %lu, _ulSize = %lu\n",
                                ulOffset,ulCount,_ulSize));
        ulCount = (ULONG)(_ulSize - ulOffset);
    }


    //  Stream is stored in ministream if size < MINISTREAMSIZE
    //  and this is not a scratch stream.


    SID sid = _stmh.GetSid();
    CFat *pfat = pms->GetFat();
    USHORT cbSector = pms->GetSectorSize();
    USHORT uShift = pms->GetSectorShift();
    USHORT uMask = pms->GetSectorMask();



    if ((_ulSize < MINISTREAMSIZE) &&
        (sid != SIDMINISTREAM))
    {
        msfAssert(sid <= MAXREGSID);

        //  This stream is stored in the ministream

        cbSector = MINISECTORSIZE;
        uShift = MINISECTORSHIFT;
        uMask = (USHORT) (cbSector - 1);
        pfat = pms->GetMiniFat();
    }

    SECT start = (SECT)(ulOffset >> uShift);
    OFFSET oStart = (OFFSET)(ulOffset & uMask);

    SECT end = (SECT)((ulOffset + ulCount - 1) >> uShift);
    OFFSET oEnd = (OFFSET)((ulOffset + ulCount - 1) & uMask);

    ULONG total = 0;

    ULONG cSect = end - start + 1;

    SECT sectSidStart;

    USHORT offset;
    offset = oStart;

    while (TRUE)
    {
        SECT sect;
        
        if (start > _stmc.GetOffset())
        {
            msfChk(pfat->GetSect(
                    _stmc.GetSect(),
                    start - _stmc.GetOffset(),
                    &sect));
        }
        else if (start == _stmc.GetOffset())
        {
            sect = _stmc.GetSect();
        }
        else
        {
            msfChk(pms->GetDir()->GetStart(sid, &sectSidStart));
            msfChk(pfat->GetSect(sectSidStart, start, &sect));
        }

        SSegment segtab[CSEG + 1];

        msfChk(pfat->Contig(
            (SSegment STACKBASED *) segtab,
            sect,
            cSect));

        USHORT oend = (USHORT) (cbSector - 1);
        for (USHORT iseg = 0; iseg < CSEG;)
        {
            msfDebugOut((DEB_ITRACE,"Segment:  (%lu,%lu)\n",segtab[iseg].sectStart,segtab[iseg].cSect));
            SECT sectStart = segtab[iseg].sectStart;
            ULONG i = segtab[iseg].cSect;
            cSect -= i;
            start += i;

            iseg++;
            if (segtab[iseg].sectStart == ENDOFCHAIN)
                oend = oEnd;

            ULONG ulSize = ((i - 1) << uShift) - offset + oend + 1;

            ULONG bytecount;
            SCODE sc;

            if (pms->GetMiniFat() == pfat)
            {
                sc = pms->GetMiniStream()->CDirectStream::ReadAt(
                                            (sectStart << uShift) + offset,
                                             pBuffer, ulSize,
					    (ULONG STACKBASED *)&bytecount);
            }
            else
            {
                ULARGE_INTEGER ulOffset;
                ULISet32(ulOffset, ConvertSectOffset(sectStart,offset,uShift));
                sc = DfGetScode(pms->GetILB()->ReadAt(ulOffset,
                                                      (BYTE *)pBuffer, ulSize,
                                                      &bytecount));
            }

            total += bytecount;
            if ((0 == cSect) || (FAILED(sc)))
            {
                _stmc.SetCache(start - 1, sectStart + i - 1);
                *pulRetval = total;
                msfDebugOut((DEB_TRACE,
                    "Leaving CDirectStream::ReadAt()=>%lu, ret is %lu\n",
                     sc,*pulRetval));
                return sc;
            }

            pBuffer = (BYTE HUGEP *)pBuffer + bytecount;
            offset = 0;
        }
    }

    msfDebugOut((DEB_ERROR,"In CDirectStream::ReadAt - reached end of function\n"));
Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectStream::Write, public
//
//  Synposis:   Writes binary data from a linear single stream
//
//  Effects:    Modifies _ulSeekPos.  May cause modification in parent
//                  MStream.
//
//  Arguments:  [pBuffer] -- Pointer to the area from which the data
//                           will be written.
//              [ulCount] --  Indicates the number of bytes to be written
//              [pulRetval] -- Pointer to area in which number of bytes
//                              will be returned
//
//  Returns:    Error code of MStream call.
//
//  Algorithm:  Calculate sector and offset for beginning and end of
//              write, then pass call up to MStream.
//
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CDirectStream::WriteAt(
        ULONGLONG ulOffset,
        VOID const HUGEP *pBuffer,
        ULONG ulCount,
        ULONG STACKBASED *pulRetval)
{
    msfDebugOut((DEB_TRACE,"In CDirectStream::WriteAt(%lu,%p,%lu)\n",ulOffset,pBuffer,ulCount));

    *pulRetval = 0;

    if (0 == ulCount)
        return S_OK;

    SCODE sc;
    CMStream *pms = _stmh.GetMS();
    msfAssert(pms != NULL);
    
    if (ulOffset + ulCount > _ulSize)
    {
        if (_ulSize > MINISTREAMSIZE)
        {
        }
        else
        {
            msfChk(SetSize(ulOffset + ulCount));
        }
    }

    //  This should be an inline call to MWrite

    msfChk(pms->MWrite(
            _stmh.GetSid(),
            (_ulSize < MINISTREAMSIZE),
            ulOffset,
            pBuffer,
            ulCount,
            &_stmc,
            pulRetval));

    msfAssert(*pulRetval == ulCount);

    msfDebugOut((DEB_TRACE,"Leaving CDirectStream::WriteAt()==>%lu, ret is %lu\n",sc,*pulRetval));

Err:
    if (ulOffset + *pulRetval > _ulSize)
    {
        SCODE scSet;
        
        _ulSize = ulOffset + *pulRetval;
        scSet = pms->GetDir()->SetSize(_stmh.GetSid(), _ulSize);
        if (SUCCEEDED(sc) && FAILED(scSet))
        {
            sc = scSet;
        }
    }
    
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectStream::SetSize, public
//
//  Synposis:   Set the size of a linear stream
//
//  Effects:    Modifies _ulSize.  May cause change in parent MStream.
//
//  Arguments:  [ulNewSize] -- New size for stream
//
//  Returns:    Error code returned by MStream call.
//
//  Algorithm:  Pass call up to parent.
//
//  Notes:      When changing the size of a stream, we need to be concerned
//              with the cases where each stream is either zero length,
//  stored in the ministream, or stored in a regular stream.  The following
//  grid shows the actions that we must perform in each case:
//
//                      New Sector Count (Cn)
//
//                      0               S               L
//      O       ------------------------------------------------
//      l       | same size     | allocate Cn   | allocate Cn
//      d   0   |  (fast out)   | small sectors | large sectors
//              ------------------------------------------------
//      S       | small         | Co > Cn:      | cbCopy = cbOld
//      e   S   |  setchain(Cn) |  small        | large allocate Cn
//      c       |               |   setchain(Cn)| copy bytes
//      t       |               | Cn > Co:      | small setchain(0)
//      o       |               |  extend small | copy data
//      r       ------------------------------------------------
//          L   | large         | cbCopy = cbNew| Co > Cn:
//      C       |  setchain(Cn) | small         |  large setchain(Cn)
//      o       |               |  allocate Cn  | Cn > Co:
//      u       |               | copy bytes    |  extend large
//      n       |               | large         |
//      t       |               |  setchain(0)  |
//              |               | copy data     |
//     (Co)     ------------------------------------------------
//
//  where S indicates small sectors, L indicates large sectors, and Cx
//  represents count of sectors.  For example, the middle box represents
//  doing a setsize on a stream which is currently stored in a small
//  stream in Co small sectors and which will end up in a large stream
//  with Cn sectors.
//
//---------------------------------------------------------------------------


SCODE CDirectStream::SetSize(ULONGLONG cbNewSize)
{
    msfDebugOut((DEB_TRACE,"In CDirectStream::SetSize(%lu)\n",cbNewSize));

    SCODE sc = S_OK;
    BYTE *pBuf = NULL;
    SID sid = _stmh.GetSid();
    CMStream *pms = _stmh.GetMS();
    msfAssert(sid <= MAXREGSID);
    CDirectory *pdir = pms->GetDir();
    SECT sectOldStart = ENDOFCHAIN;
    
    if (_ulSize == cbNewSize)
    {
        return S_OK;
    }

    USHORT cbpsOld = pms->GetSectorSize();
                                        //  Count of Bytes Per Sector
    USHORT cbpsNew = cbpsOld;
    CFat *pfatOld = pms->GetFat();
    CFat *pfatNew = pfatOld;

    if (SIDMINISTREAM != sid)
    {

        if (cbNewSize < MINISTREAMSIZE)
        {
            cbpsNew = MINISECTORSIZE;
            pfatNew = pms->GetMiniFat();
        }

        if (_ulSize < MINISTREAMSIZE)
        {
            cbpsOld = MINISECTORSIZE;
            pfatOld = pms->GetMiniFat();
        }
    }

    ULONG csectOld = (ULONG)(_ulSize + cbpsOld - 1) / (ULONG) cbpsOld;
    ULONG csectNew = (ULONG)(cbNewSize + cbpsNew - 1) / (ULONG) cbpsNew;

    msfAssert(sid <= MAXREGSID);
    SECT sectstart;
    msfChk(pdir->GetStart(sid, &sectstart));

    msfDebugOut((DEB_ITRACE,"pdbOld size is %lu\n\tSid is %lu\n\tStart is %lu\n",
                _ulSize,sid,sectstart));
    msfDebugOut((DEB_ITRACE,"CMStream::SetSize() needs %lu %u byte sectors\n",
                 csectNew, cbpsNew));
    msfDebugOut((DEB_ITRACE,"SetSize() currently has %lu %u byte sectors\n",
                 csectOld, cbpsOld));

    USHORT cbCopy;
    cbCopy = 0;
    if (cbpsOld != cbpsNew)
    {
        //  Sector sizes are different, so we'll copy the data
        msfAssert((cbNewSize > _ulSize ? _ulSize : cbNewSize) < 0x10000);
        cbCopy =(USHORT)(cbNewSize > _ulSize ? _ulSize : cbNewSize);
    }


    if (cbCopy > 0)
    {
        msfDebugOut((DEB_ITRACE,"Copying between fat and minifat\n"));
        GetSafeBuffer(cbCopy, cbCopy, &pBuf, &cbCopy);
        msfAssert((pBuf != NULL) && aMsg("Couldn't get scratch buffer"));

        ULONG ulRetVal;
        sc = ReadAt(0, pBuf, cbCopy, (ULONG STACKBASED *)&ulRetVal);
        if ((FAILED(sc)) ||
            ((ulRetVal != cbCopy) ? (sc = STG_E_UNKNOWN) : 0))
        {
            msfErr(Err, sc);
        }

        //The cache is no longer valid, so empty it.
        _stmc.SetCache(MAX_ULONG, ENDOFCHAIN);
        
        //Save start sector so we can free it later.
        sectOldStart = sectstart;
        
        msfChk(pfatNew->Allocate(csectNew, &sectstart));
    }
    else
    {
        SECT dummy;

        if ((csectOld > csectNew))
        {
            msfChk(pfatOld->SetChainLength(sectstart, csectNew));
            if (0 == csectNew)
            {
                sectstart = ENDOFCHAIN;
            }

            //If this turns out to be a common case, we can
            //   sometimes keep the cache valid here.
            _stmc.SetCache(MAX_ULONG, ENDOFCHAIN);
        }
        else if (0 == csectOld)
        {
            msfAssert(_stmc.GetOffset() == MAX_ULONG);
            msfChk(pfatNew->Allocate(csectNew, &sectstart));
        }
        else if (csectNew > csectOld)
        {
            ULONG start = csectNew - 1;

            if (start > _stmc.GetOffset())
            {
                msfChk(pfatNew->GetESect(
                        _stmc.GetSect(),
                        start - _stmc.GetOffset(),
                        &dummy));
            }
            else if (start != _stmc.GetOffset())
            {
                msfChk(pfatNew->GetESect(sectstart, start, &dummy));
            }
        }
    }


    //  Resize the ministream, if necessary
    if (((MINISECTORSIZE == cbpsOld) && (csectOld > 0)) ||
        ((MINISECTORSIZE == cbpsNew) && (csectNew > 0)))
    {
        msfChk(pms->SetMiniSize());
    }
    
    msfChk(pms->SetSize());

    //If we fail on either of these operations and cbCopy != 0,
    //   we will have data loss.  Ick.
    msfChk(pdir->SetStart(sid, sectstart));

    //If we fail here, were in trouble.
    msfChk(pdir->SetSize(sid, cbNewSize));

    _ulSize = cbNewSize;

    if (cbCopy > 0)
    {
        //  now copy the data
        ULONG ulRetVal;

        msfAssert(cbCopy <= _ulSize);
        msfChk(WriteAt(0, pBuf, cbCopy, (ULONG STACKBASED *)&ulRetVal));

        if (ulRetVal != cbCopy)
        {
            msfErr(Err, STG_E_UNKNOWN);
        }

        msfChk(pfatOld->SetChainLength(sectOldStart, 0));
        msfChk(pms->SetMiniSize());
        msfChk(pms->SetSize());
    }

    if (((csectNew > csectOld) || (cbCopy > 0)) &&
        ((cbNewSize & (cbpsNew - 1)) != 0))
    {
        SECT sectLast;
        if (csectNew - 1 > _stmc.GetOffset())
        {
            msfChk(pfatNew->GetSect(
                    _stmc.GetSect(),
                    (csectNew - 1) - _stmc.GetOffset(),
                    &sectLast));
        }
        else
        {
            msfChk(pfatNew->GetSect(sectstart, csectNew - 1, &sectLast));
        }
            
        msfVerify(SUCCEEDED(pms->SecureSect(
                sectLast,
                cbNewSize,
                (cbNewSize < MINISTREAMSIZE) && (sid != SIDMINISTREAM))));
    }
Err:
    FreeBuffer(pBuf);
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CDirectStream::Release, public
//
//  Synopsis:	Decrements the ref count and frees if necessary
//
//----------------------------------------------------------------------------


void CDirectStream::Release(VOID)
{
    msfDebugOut((DEB_TRACE,"In CDirectStream::Release()\n"));
    msfAssert(_cReferences > 0);

    AtomicDec(&_cReferences);
    if (_cReferences == 0)
        delete this;
    msfDebugOut((DEB_TRACE,"Out CDirectStream::Release()\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CDirectStream::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//---------------------------------------------------------------


void CDirectStream::AddRef(void)
{
    msfDebugOut((DEB_ITRACE, "In  CDirectStream::AddRef()\n"));
    AtomicInc(&_cReferences);
    msfDebugOut((DEB_ITRACE, "Out CDirectStream::AddRef, %lu\n",
                 _cReferences));
}

//+---------------------------------------------------------------------------
//
//  Member:	CDirectStream::GetSize, public
//
//  Synopsis:	Gets the size of the stream
//
//  Arguments:	[pulSize] - Size return
//
//  Modifies:	[pulSize]
//
//----------------------------------------------------------------------------

void CDirectStream::GetSize(ULONGLONG *pulSize)
{
    *pulSize = _ulSize;
}

//+--------------------------------------------------------------
//
//  Member:	CDirectStream::GetTime, public
//
//  Synopsis:	Gets a time
//
//  Arguments:	[wt] - Which time
//		[ptm] - Time return
//
//  Returns:	Appropriate status code
//
//  Modifies:	[ptm]
//
//---------------------------------------------------------------

SCODE CDirectStream::GetTime(WHICHTIME wt, TIME_T *ptm)
{
    return _stmh.GetTime(wt, ptm);
}

//+--------------------------------------------------------------
//
//  Member:	CDirectStream::SetTime, public
//
//  Synopsis:	Sets a time
//
//  Arguments:	[wt] - Which time
//		[tm] - New time
//
//  Returns:	Appropriate status code
//
//---------------------------------------------------------------

SCODE CDirectStream::SetTime(WHICHTIME wt, TIME_T tm)
{
    return _stmh.SetTime(wt, tm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\storage.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       storage.cxx
//
//  Contents:   Contains generic storage APIs
//
//---------------------------------------------------------------


#include "h/ref.hxx"
#include "h/dfexcept.hxx"
#include "h/msf.hxx"
#include "h/docfile.hxx"
#include "h/storagep.h"
#include "h/refilb.hxx"
#include "h/ole.hxx"
#include "h/funcs.hxx"

#ifdef _MSC_VER
#pragma warning (disable:4514)  // unreferenced inline function 
#endif

#define MAKE_ERR(c) MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, c)

//+--------------------------------------------------------------
//
//  Function:   StgOpenStorage, public
//
//  Synopsis:   Instantiates a root storage from a file
//              by binding to the appropriate implementation
//              and starting things up
//
//  Arguments:  [pwcsName] - Name
//              [pstgPriority] - Priority mode reopen IStorage
//              [grfMode] - Permissions
//              [snbExclude] - Exclusions for priority reopen
//              [reserved]
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//---------------------------------------------------------------

STDAPI StgOpenStorage(TCHAR const *pwcsName,
		      IStorage *pstgPriority,
		      DWORD grfMode,
		      SNB snbExclude,
		      DWORD reserved,
		      IStorage **ppstgOpen)
{
    SCODE sc;
    int i;

    if (!pwcsName)
        return ResultFromScode(STG_E_INVALIDNAME);

    CFileILB *pilb = new CFileILB(pwcsName, grfMode, FALSE); 
    
    olDebugOut((DEB_TRACE, "In  StgOpenStorage(%p, %p, %lX, %p, %lx, %p)\n",
                pwcsName, pstgPriority, grfMode, snbExclude, 
                reserved, ppstgOpen));    

    if (!pilb) return ResultFromScode(STG_E_INSUFFICIENTMEMORY);
    olChk(VerifyPerms(grfMode));
    olChk(pilb->Open(grfMode));

    sc = GetScode( StgOpenStorageOnILockBytes(
        pilb, pstgPriority, grfMode, snbExclude, reserved, ppstgOpen) );
    
EH_Err:
    if (FAILED(sc)) i=pilb->ReleaseOnError();
    else i=pilb->Release();
    olAssert(SUCCEEDED(sc) ? i==1 : i==0);    
    olDebugOut((DEB_TRACE,"Out StgOpenStorage: ppstgOpen=%p ret=> %lX\n",
        (ppstgOpen)?(*ppstgOpen) : NULL, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Function:   StgOpenStorageOnILockBytes, public
//
//  Synopsis:   Instantiates a root storage from an ILockBytes
//              by binding to the appropriate implementation
//              and starting things up
//
//  Arguments:  [plkbyt] - Source ILockBytes
//              [pstgPriority] - For priority reopens
//              [grfMode] - Permissions
//              [snbExclude] - For priority reopens
//              [reserved]
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//---------------------------------------------------------------

STDAPI StgOpenStorageOnILockBytes(ILockBytes *plkbyt,
				  IStorage *pstgPriority,
				  DWORD grfMode,
				  SNB snbExclude,
				  DWORD reserved,
				  IStorage **ppstgOpen)
{
    CLSID cid;
#ifndef _UNICODE
    return DfOpenStorageOnILockBytes(plkbyt, pstgPriority, grfMode,
                                     snbExclude, reserved, ppstgOpen,
                                     &cid);
#else
    return DfOpenStorageOnILockBytesW(plkbyt, pstgPriority, grfMode,
                                     snbExclude, reserved, ppstgOpen,
                                     &cid);
#endif
}

//+--------------------------------------------------------------
//
//  Function:   StgIsStorageFile, public
//
//  Synopsis:   Determines whether the named file is a storage or not
//
//  Arguments:  [pwcsName] - Filename
//
//  Returns:    S_OK, S_FALSE or error codes
//
//---------------------------------------------------------------

//Identifier for first bytes of Beta 2 Docfiles
const BYTE SIGSTG_B2[] = {0x0e, 0x11, 0xfc, 0x0d, 0xd0, 0xcf, 0x11, 0xe0};
const BYTE CBSIGSTG_B2 = sizeof(SIGSTG_B2);

STDAPI StgIsStorageFile(TCHAR const *pwcsName)
{
    SCODE sc;
    int i=0;
    CFileILB* pilb = NULL;

    olChk(ValidateNameW(pwcsName, CBMAXPATHCOMPLEN));
    olMem(pilb = new CFileILB(pwcsName, (DWORD)NULL, FALSE));
    olChk(pilb->Open(STGM_READ));
    sc = GetScode( StgIsStorageILockBytes(pilb) );

EH_Err:
    if (pilb != NULL) 
        i=pilb->Release();
    olAssert(i==0);  // should not have any more reference to it
    olDebugOut((DEB_TRACE, "Out StgIsStorageFile: ret=> %lx\n", sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Function:   StgIsStorageILockBytes, public
//
//  Synopsis:   Determines whether the ILockBytes is a storage or not
//
//  Arguments:  [plkbyt] - The ILockBytes
//
//  Returns:    S_OK, S_FALSE or error codes
//
//---------------------------------------------------------------

STDAPI StgIsStorageILockBytes(ILockBytes *plkbyt)
{
    HRESULT hr;
    SCODE sc;
    SStorageFile stgfile;
    ULONG cbRead;
    ULARGE_INTEGER ulOffset;

    TRY
    {
	if (FAILED(sc = ValidateInterface(plkbyt, IID_ILockBytes)))
	    return ResultFromScode(sc);
	ULISet32(ulOffset, 0);
	hr = plkbyt->ReadAt(ulOffset, &stgfile, sizeof(stgfile), &cbRead);
        if (FAILED(GetScode(hr)))
	    return hr;
    }
    CATCH(CException, e)
    {
	return ResultFromScode(e.GetErrorCode());
    }
    END_CATCH

    if (cbRead == sizeof(stgfile))
    {        
        if ((memcmp((void *)stgfile.abSig, SIGSTG, CBSIGSTG) == 0) ||
            (memcmp((void *)stgfile.abSig, SIGSTG_B2, CBSIGSTG_B2) == 0))
            return ResultFromScode(S_OK);
    }
    return ResultFromScode(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\vect.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	vect.cxx
//
//  Contents:	Vector common code.
//
//  Classes:	
//
//  Functions:	
//
//----------------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/vect.hxx"



//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::Init, public
//
//  Synopsis:   CPagedVector initialization function
//
//  Arguments:  [ulSize] -- size of vector
//
//  Algorithm:  Allocate an array of pointer of size ulSize
//              For each cell in the array, allocate a CFatSect
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CPagedVector::Init(CMStream *pmsParent, ULONG ulSize)
{
    msfDebugOut((DEB_ITRACE,"In CPagedVector::CPagedVector(%lu)\n",ulSize));
    SCODE sc = S_OK;
    _pmsParent = pmsParent;
    _pmpt = _pmsParent->GetPageTable();

    msfAssert(_pmpt != NULL);

    USHORT i;

    //  We don't bother allocating more than necessary here
    _ulAllocSize = _ulSize = ulSize;

    if (_ulSize > 0)
    {

        msfMem(_amp = GetNewPageArray(ulSize));
        for (i = 0; i < _ulSize; i++)
        {
            _amp[i] = NULL;
        }
        msfMem(_avb = GetNewVectBits(ulSize));
    }

    msfDebugOut((DEB_ITRACE,"Out CPagedVector::CPagedVector()\n"));
    return S_OK;

Err:
    //In the error case, discard whatever vectors we were able to allocate
    //   and return S_OK.
    delete [] _amp;
    _amp = NULL;

    delete [] _avb;
    _avb = NULL;

    return S_OK;

}

//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::~CPagedVector, public
//
//  Synopsis:   CPagedVector constructor
//
//  Algorithm:  Delete the pointer array.
//
//  Notes:
//
//--------------------------------------------------------------------------

CPagedVector::~CPagedVector()
{
    delete [] _amp;
    delete [] _avb;
}


//+---------------------------------------------------------------------------
//
//  Member:	CPagedVector::Empty, public
//
//  Synopsis:	Discard the storage associated with this vector.
//
//  Arguments:	None.
//
//  Returns:	void.
//
//----------------------------------------------------------------------------

void CPagedVector::Empty(void)
{
    if (_pmpt != NULL)
    {
        _pmpt->FreePages(this);
    }
    delete [] _amp;
    delete [] _avb;
    _amp = NULL;
    _avb = NULL;
    _pmpt = NULL;
    _ulAllocSize = _ulSize = 0;
    _pmsParent = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:	CPagedVector::Flush, public
//
//  Synopsis:	Flush the dirty pages for this vector
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//----------------------------------------------------------------------------

SCODE CPagedVector::Flush(void)
{
    SCODE sc;
    SCODE scRet = S_OK;

    if (_ulSize > 0)
    {
        if (_amp != NULL)
        {
            for (USHORT i = 0; i < _ulSize; i++)
            {
                if ((_amp[i] != NULL) && (_amp[i]->IsDirty()))
                {
                    sc = _pmpt->FlushPage(_amp[i]);
                    if ((FAILED(sc)) && (SUCCEEDED(scRet)))
                    {
                        scRet = sc;
                    }
                }
            }
        }
        else
        {
            scRet = _pmpt->Flush();
        }
    }

    return scRet;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::GetTable, public
//
//  Synopsis:   Return a pointer to a page for the given index
//              into the vector.
//
//  Arguments:  [iTable] -- index into vector
//              [ppmp] -- Pointer to return location
//
//  Returns:    S_OK if call completed OK.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CPagedVector::GetTable(
        const FSINDEX iTable,
        DWORD dwFlags,
        void **ppmp)
{
    SCODE sc = S_OK;
    CMSFPage *pmp;

    msfAssert((_pmsParent->GetILB() != NULL) &&
            aMsg("Null ILB found on GetTable - need SetAccess call?"));

    // docfile is corrupted with an invalid iTable size
    if (iTable >= _ulSize)
    {
	msfErr(Err, STG_E_DOCFILECORRUPT);
 
    }     

    if ((_amp == NULL) || (_amp[iTable] == NULL))
    {
        if (dwFlags & FB_NEW)
        {
            //We know that the page isn't in the page table,
            //  so we can just get a free page an allocate it
            //  ourselves.

            msfChk(_pmpt->GetFreePage(&pmp));

            pmp->SetVector(this);
            pmp->SetSid(_sid);
            pmp->SetOffset(iTable);
            pmp->SetSect(ENDOFCHAIN);

            sc = STG_S_NEWPAGE;
            dwFlags = (dwFlags & ~FB_NEW) | FB_DIRTY;
        }
        else
        {
            msfChk(_pmpt->GetPage(this, _sid, iTable, &pmp));
            msfAssert((pmp->GetVector() == this) &&
                    aMsg("GetPage returned wrong page."));
        }

        
        if (_amp != NULL)
        {
            _amp[iTable] = pmp;
        }

    }
    else
    {
        pmp = _amp[iTable];
        msfAssert((pmp->GetVector() == this) &&
                aMsg("Cached page has wrong vector pointer"));
    }

    pmp->AddRef();
    
    if (((dwFlags & FB_DIRTY) && !(pmp->IsDirty())) &&
        (sc != STG_S_NEWPAGE))
    {
        //If we are not a newly created page, and we are being
        //   dirtied for the first time, make sure that our
        //   _sect field is correct.
        //
        //Newly created pages have to have their sect set manually
        //  _before_ being released.  This is very important.

            pmp->SetSect(ENDOFCHAIN);
            
            SECT sect;
            msfChkTo(Err_Rel, _pmsParent->GetESect(
                    pmp->GetSid(),
                    pmp->GetOffset(),
                    &sect));

            pmp->SetSect(sect);
    }

    pmp->SetFlags(pmp->GetFlags() | dwFlags | FB_TOUCHED);
    msfAssert((pmp->GetVector() == this) &&
            aMsg("GetTable returned wrong page."));    
    *ppmp = pmp->GetData();

Err:
    return sc;
    
Err_Rel:
    pmp->Release();
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CPagedVector::SetDirty, public
//
//  Synopsis:	Set the dirty bit on the specified page
//
//  Arguments:	[iTable] -- Table to set bit on
//
//  Notes:  This function is always called on a page with an
//              open reference.  Therefore, the page is
//              guaranteed to be in the page table, and that
//              FindPage call should never return an error.
//
//----------------------------------------------------------------------------

SCODE CPagedVector::SetDirty(ULONG iTable)
{
    SCODE sc = S_OK;
    CMSFPage *pmp;

    
    if (_amp == NULL)
    {

        msfChk(_pmpt->FindPage(this, _sid, iTable, &pmp));
        msfAssert(sc == STG_S_FOUND);
        msfAssert(pmp->IsInUse() &&
                aMsg("Called SetDirty on page not in use."));
    }
    else
    {
        msfAssert(_amp != NULL);
        msfAssert(_amp[iTable] != NULL);
        pmp = _amp[iTable];
    }

    if (!pmp->IsDirty())
    {
        //We are not a newly created page, and we are being
        //   dirtied for the first time, make sure that our
        //   _sect field is correct.
        //

        pmp->AddRef();

            pmp->SetSect(ENDOFCHAIN);
            
            SECT sect;
            msfChkTo(Err_Rel, _pmsParent->GetESect(
                    pmp->GetSid(),
                    pmp->GetOffset(),
                    &sect));

            pmp->SetSect(sect);
        
        pmp->Release();
    }

    pmp->SetDirty();

 Err:
    return sc;
    
 Err_Rel:
    pmp->Release();
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::Resize, public
//
//  Synopsis:   Resize a CPagedVector
//
//  Arguments:  [ulSize] -- Size of new vector
//
//  Algorithm:  Create new pointer array of size ulSize.
//              For each entry in old array, copy the pointer over.
//
//  Notes:
//
//--------------------------------------------------------------------------

#define LARGETHRESHOLD  1024
#define VECTORBLOCK     1024    //  Must be power of 2

SCODE CPagedVector::Resize(FSINDEX ulSize)
{
    msfDebugOut((DEB_ITRACE,"In CPagedVector::CPagedVector(%lu)\n",ulSize));

    msfAssert(ulSize >= _ulSize);
    msfAssert(_ulSize <= _ulAllocSize);
    msfAssert(((VECTORBLOCK & (VECTORBLOCK - 1)) == 0) &&
              aMsg("VECTORBLOCK must be power of 2"));

    msfAssert(!((_amp == NULL) && (_avb != NULL)) &&
            aMsg("Resize precondition failed."));
            
    if (ulSize > _ulAllocSize)
    {
        //  We don't have room in the existing vector;  grow it
        ULONG ulNewAllocSize = ulSize;

        if (ulNewAllocSize > LARGETHRESHOLD)
        {
            //  We're dealing with a large vector;  grow it a VECTORBLOCK
            //  at a time
            ulNewAllocSize = (ulNewAllocSize + VECTORBLOCK - 1) &
                             ~(VECTORBLOCK - 1);
        }

        CMSFPage **amp = GetNewPageArray(ulNewAllocSize);
        CVectBits *avb = GetNewVectBits(ulNewAllocSize);

        //  Can't fail after this point

        _ulAllocSize = ulNewAllocSize;

        //  Copy over the old entries

        
        if ((amp != NULL) && (avb != NULL))
        {
            if ((_amp != NULL) && (_avb != NULL))
            {
                //  Both allocations succeeded
                for (ULONG iamp = 0; iamp < _ulSize; iamp++)
                {
                    amp[iamp] = _amp[iamp];
                    avb[iamp] = _avb[iamp];
                }
            }
            else if (_amp != NULL)
            {
                for (ULONG iamp = 0; iamp < _ulSize; iamp++)
                {
                    amp[iamp] = _amp[iamp];
                }
            }
            else
            {
                for (ULONG iamp = 0; iamp < _ulSize; iamp++)
                {
                    amp[iamp] = NULL;
                }
            }
        }
        else
        {
            //  At least one of the allocations failed
            delete [] avb;
            avb = NULL;

            delete [] amp;
            amp = NULL;
        }

        //  Delete the old vector and put in the new one (if any).
        //  In the error case, throw away the vectors we are currently
        //  holding (since they are of insufficient size) and return S_OK.

        delete [] _amp;
        _amp = amp;

        delete [] _avb;
        _avb = avb;
    }

    if (_amp != NULL)
    {
        //  Initialize the new elements in the vector

        for (ULONG iamp = _ulSize; iamp < ulSize; iamp++)
            _amp[iamp] = NULL;
    }

    _ulSize = ulSize;

    msfDebugOut((DEB_ITRACE,"Out CPagedVector resize constructor\n"));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\time.cxx ===
#include "h/ref.hxx"
#include "time.hxx"
#include "h/ole.hxx"
#include <limits.h>
#include <assert.h>

// Number of seconds difference betwen FILETIME (since 1601 00:00:00) 
// and time_t (since 1970 00:00:00)
//
// This should be a constant difference between the 2 time formats
//
#ifdef __GNUC__	// cater to differences of compiler syntax
const LONGLONG ci64DiffFTtoTT=11644473600LL; 
#else				//  __GNUC__
const LONGLONG ci64DiffFTtoTT=11644473600;
#endif				//  __GNUC__

STDAPI_(void) FileTimeToTimeT(const FILETIME *pft, time_t *ptt)
{
    ULONGLONG llFT = pft->dwHighDateTime;
    llFT = (llFT << 32) | (pft->dwLowDateTime);
    // convert to seconds 
    // (note that all fractions of seconds will be lost)
    llFT = llFT/10000000;       
    llFT -= ci64DiffFTtoTT;         // convert to time_t 
    assert(llFT <= ULONG_MAX);
    *ptt = (time_t) llFT;
}

STDAPI_(void) TimeTToFileTime(const time_t *ptt, FILETIME *pft)
{
    ULONGLONG llFT = *ptt;
    llFT += ci64DiffFTtoTT;         // convert to file time
    // convert to nano-seconds
    for (int i=0; i<7; i++)         // mulitply by 10 7 times
    {        
        llFT = llFT << 1;           // llFT = 2x
        llFT += (llFT << 2);        // llFT = 4*2x + 2x = 10x
    }
    pft->dwLowDateTime  = (DWORD) (llFT & 0xffffffff);
    pft->dwHighDateTime = (DWORD) (llFT >> 32);
}

#ifdef _MSC_VER
#pragma warning(disable:4514)
// disable warning about unreferenced inline functions
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\wchar.c ===
/*
*
*       Copyright (c) 1985-1996, Microsoft Corporation. All Rights Reserved.
*
*       Character functions (to and from wide characters)
*
******************************************************************************
*/

#include "h/wchar.h"
#include <errno.h>

#ifndef _tbstowcs
#ifndef _WIN32                /* others */
#define _tbstowcs sbstowcs
#define _wcstotbs wcstosbs 
#else /* _WIN32 */
#define _tbstowcs mbstowcs
#define _wcstotbs wcstombs 
#endif /* _WIN32 */
#endif

#define ERROR_INVALID_PARAMETER 87L

/*
** Converts a single byte i.e. ascii string to the wide char format 
**
** NOTE: This function does NOT handle multibyte characters!
**       It should be used only when wchar_t is not 2 bytes and
**       we cannot use the standard functions
**
*/

#ifndef _MSC_VER
size_t sbstowcs(WCHAR *pwcs, const char *s, size_t n )
{
	size_t count=0;

	/* if destintation string exists, fill it in */
	if (pwcs)
	{
		while (count < n)
		{
			*pwcs = (WCHAR) ( (unsigned char)s[count]);
			if (!s[count])
				return count;
			count++;
			pwcs++;
		}
		return count;
	}
	else { /* pwcs == NULL, get size only, s must be NUL-terminated */
		return strlen(s);
	}
}
#endif

/***
*size_t wcstosbs() - Convert wide char string to single byte char string.
*
*Purpose:
*       Convert a wide char string into the equivalent multibyte char string 
*       [ANSI].
*
*Entry:
*       char *s            = pointer to destination char string
*       const WCHAR *pwc = pointer to source wide character string
*       size_t           n = maximum number of bytes to store in s
*
*Exit:
*       If s != NULL, returns    (size_t)-1 (if a wchar cannot be converted)
*       Otherwise:       Number of bytes modified (<=n), not including
*                    the terminating NUL, if any.
* 
*Exceptions
*       Returns (size_t)-1 if s is NULL or invalid mb character encountered.
*
*******************************************************************************/

size_t __cdecl wcstosbs( char * s, const WCHAR * pwcs, size_t n)
{
	size_t count=0;
        /* if destination string exists, fill it in */
 	if (s)
	{
		while(count < n)
		{
		    if (*pwcs > 255)  /* validate high byte */
		    {
			errno = EILSEQ;
			return (size_t)-1;  /* error */
		    }
		    s[count] = (char) *pwcs;

 		    if (!(*pwcs++))
			return count;
    		    count++;
	        }
		return count;
        } else { /* s == NULL, get size only, pwcs must be NUL-terminated */
	        const WCHAR *eos = pwcs;
		while (*eos++);
		return ( (size_t) (eos - pwcs -1));
	}
}


/******
*	WCHAR *wcscat(dst, src) - concatenate (append) one wide character string
*       to another
*
*Purpose:
*       Concatenates src onto the end of dest.  Assumes enough
*       space in dest.
*
*Entry:
*       WCHAR *dst - wide character string to which "src" is to be appended
*       const WCHAR *src - wide character string to append to end of "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

WCHAR * __cdecl wcscat(WCHAR * dst, const WCHAR * src)
{
    WCHAR * cp = dst;

    while( *cp )
            ++cp;       /* Find end of dst */

    wcscpy(cp,src);     /* Copy src to end of dst */

    return dst;         /* return dst */

}


/***
*WCHAR *wcscpy(dst, src) - copy one wide character string over another
*
*Purpose:
*       Copies the wide character string src into the spot specified by
*       dest; assumes enough room.
*
*Entry:
*       WCHAR * dst - wide character string over which "src" is to be copied
*       const WCHAR * src - string to be copied over "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*******************************************************************************/

WCHAR * __cdecl wcscpy(WCHAR * dst, const WCHAR * src)
{
    WCHAR * cp = dst;
#ifdef _MSC_VER
#pragma warning(disable:4706) // assignment within conditional expression
#endif //_MSC_VER

    while( *cp++ = *src++ )
            ;               /* Copy src over dst */

#ifdef _MSC_VER
#pragma warning(default:4706)
#endif //_MSC_VER
    return dst;
}


/***
*wcslen - return the length of a null-terminated string
*
*Purpose:
*       Finds the number of wide characters in the given wide character
*       string, not including the final null character.
*
*Entry:
*       const wchat_t * str - string whose length is to be computed
*
*Exit:
*       length of the string "str", exclusive of the final null wide character
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcslen(const WCHAR * str)
{
    WCHAR *string = (WCHAR *) str;

    while( *string )
            string++;

    return string - str;
}




/***
*wcsnicmp.c - compare first n characters of two wide character strings with
*             case insensitivity
*
*       Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines wcsnicmp() - compare first n characters of two wide character
*       strings for lexical order with case insensitivity.
*
*Revision History:
*
*******************************************************************************/

/***
*WCHAR wcUp(wc) - upper case wide character
*
*/

static WCHAR wcUp(WCHAR wc)
{
    if ('a' <= wc && wc <= 'z')
        wc += (WCHAR)('A' - 'a');

    return(wc);
}

/***
*int wcsnicmp(first, last, count) - compare first count wide characters of wide
*       character strings with case insensitivity.
*
*Purpose:
*       Compares two wide character strings for lexical order.  The comparison
*       stops after: (1) a difference between the strings is found, (2) the end
*       of the strings is reached, or (3) count characters have been
*       compared.
*
*Entry:
*       char *first, *last - wide character strings to compare
*       unsigned count - maximum number of wide characters to compare
*
*Exit:
*       returns <0 if first < last
*       returns  0 if first == last
*       returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcsnicmp(const WCHAR * first, const WCHAR * last, size_t count)
{
      if (!count)
              return 0;

      while (--count && *first && wcUp(*first) == wcUp(*last))
              {
              first++;
              last++;
              }

      return wcUp(*first) - wcUp(*last);
}

/***
*wcscmp - compare two WCHAR string
*        returning less than, equal to, or greater than
* 
*Purpose:
*       wcscmp compares two wide-character strings and returns an integer
*       to indicate whether the first is less than the second, the two are
*       equal, or whether the first is greater than the second.
*
*       Comparison is done wchar_t by wchar_t on an UNSIGNED basis, which is to
*       say that Null wchar_t(0) is less than any other character.
*
*Entry:
*       const WCHAR * src - string for left-hand side of comparison
*       const WCHAR * dst - string for right-hand side of comparison
*
*Exit:
*       returns -1 if src <  dst
*       returns  0 if src == dst
*       returns +1 if src >  dst
*
*Exceptions:
*
******************************************************************************/

int __cdecl wcscmp ( const WCHAR * src, const WCHAR * dst )
{
    int ret = 0 ;
    
    while( ! (ret = (int)(*src - *dst)) && *dst)
        ++src, ++dst;

    if ( ret < 0 )
        ret = -1 ;
    else if ( ret > 0 )
        ret = 1 ;
    
    return( ret );
}



/***
*WCHAR *wcschr(string, c) - search a string for a WCHAR character
*
*Purpose:
*       Searches a WCHAR string for a given WCHAR character,
*       which may be the null character L'\0'.
*
*Entry:
*       WCHAR *string - WCHAR string to search in
*       WCHAR c - WCHAR character to search for
*
*Exit:
*       returns pointer to the first occurence of c in string
*       returns NULL if c does not occur in string
*
*Exceptions:
*
******************************************************************************/

WCHAR * __cdecl wcschr ( const WCHAR * string, WCHAR ch )
{
    while (*string && *string != (WCHAR)ch)
        string++;
    
    if (*string == (WCHAR)ch)
        return((WCHAR *)string);
    return(NULL);
}

/***
*WCHAR *wcsncpy(dest, source, count) - copy at most n wide characters
*
*Purpose:
*       Copies count characters from the source string to the
*       destination.  If count is less than the length of source,
*       NO NULL CHARACTER is put onto the end of the copied string.
*       If count is greater than the length of sources, dest is padded
*       with null characters to length count (wide-characters).
*
*
*Entry:
*       WCHAR *dest - pointer to destination
*       WCHAR *source - source string for copy
*       size_t count - max number of characters to copy
*
*Exit:
*       returns dest
*
*Exceptions:
*
*******************************************************************************/

WCHAR* __cdecl wcsncpy ( WCHAR * dest, const WCHAR * source, size_t count )
{
    WCHAR *start = dest;
    
    while (count && (*dest++ = *source++))    /* copy string */
        count--;

    if (count)                              /* pad out with zeroes */
        while (--count)
            *dest++ = (WCHAR)'\0';
    
    return(start);
}


#include <assert.h>

/* NOTE: this function is really only converting to US ansi (i.e.
        single byte!)

       Note that the returned values are slightly different,
       but that does not matter in the reference implementation */
 
int STDCALL WideCharToMultiByte(
    unsigned int CodePage,              /* code page */
    unsigned long dwFlags,              /* performance and mapping flags */
    const WCHAR* lpWideCharStr,	/* address of wide-character string */
    int cchWideChar,            /* number of characters in string */
    char* lpMultiByteStr,	/* address of buffer for new string */
    int cchMultiByte,           /* size of buffer  */
    const char* lpDefaultChar,	/* addr of default for unmappable chars */
    int* lpUsedDefaultChar 	/* addr of flag set when default char. used */
   )
{
    /* only support UNICODE or US ANSI */
    if ((CodePage!=0) && (CodePage!=1252)) 
    {
        /* assert(0); */
        return 0;
    }    
    /* the following 2 parameters are not used */
    dwFlags;
    lpDefaultChar;

    if (lpUsedDefaultChar) 
        *lpUsedDefaultChar=0;

    if (cchMultiByte)
    {
        /* copy upto the smaller of the 2 strings */
        int nConvert = cchMultiByte;
        int nConverted;
        if (cchWideChar!=-1 && nConvert>cchWideChar)
            nConvert = cchWideChar;
        nConverted = _wcstotbs(lpMultiByteStr, lpWideCharStr, nConvert);
        if ( (nConverted < cchMultiByte) && (!lpMultiByteStr[nConverted]))
            nConverted++;
        return nConverted;
    }
    else /* calculate length */
    {
        if (cchWideChar!=-1) 
            return (cchWideChar);
        return (_wcstotbs(NULL, lpWideCharStr, 0)+1);
    }
}

/*
 NOTE: This function is really only converting from US ansi (i.e.
       single byte!) It might not work with other locale

       Note that the returned values are slightly different,
       but that does not matter in the reference implementation 
*/

int STDCALL MultiByteToWideChar(
    unsigned int CodePage,              /* code page */
    unsigned long dwFlags,              /* character-type options  */
    const char * lpMultiByteStr,	/* address of string to map  */
    int cchMultiByte,           /* number of characters in string  */
    WCHAR* lpWideCharStr,	/* address of wide-character buffer  */
    int cchWideChar             /* size of buffer  */
   )
{
    /* only support UNICODE or US ANSI */
    if ((CodePage!=0) && (CodePage!=1252))
    { 
        /*assert(0); */
        return 0;
    }
    dwFlags;  /* we are not using this parameter */
    if (!cchWideChar)  /* return size required */
    {
        if (cchMultiByte != -1) 
            return cchMultiByte;
        else
            /* plus one to include null character */
            return (_tbstowcs(NULL, lpMultiByteStr, cchWideChar)+1);
    }
    else  
    {
        /* nConvert is the smaller size of the two strings */
        int nConvert=cchWideChar;
        int nConverted;
        if (cchMultiByte!=-1 && nConvert>cchMultiByte) 
            nConvert = cchMultiByte;  /* prevent copying too much */
        nConverted = _tbstowcs(lpWideCharStr, lpMultiByteStr, nConvert);
        if ((nConverted < cchWideChar) && (!lpWideCharStr[nConverted]))
            nConverted++; /* include null character */
        return nConverted;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\h\props.h ===
/* FILE: prop.h*/

/* Description: This is the exported include file that should be         */
/*              included to declare and make use of the property         */
/*              set Interfaces (IPropertyStorage and IPropertySetStorage */

#ifndef _PROP_H_
#define _PROP_H_

#include "ref.hxx"
#include "tchar.h"
#include "../props/olechar.h"

typedef double DATE;

typedef union tagCY {
    struct _split {
#if BIGENDIAN                   /* big end in first */
        long Hi;
        unsigned long Lo;
#else                           /* little end in first */
        unsigned long Lo;
        long          Hi;
#endif
    } split;                    /* need to name this to make it portable */
    LONGLONG int64;             /* the above split is need to be compatiable */
                                /* with the def of the union */
} CY;

typedef OLECHAR *BSTR;
typedef BSTR *LPBSTR;
/* 0 == FALSE, -1 == TRUE */

typedef short VARIANT_BOOL;

/* for backward compatibility */
typedef VARIANT_BOOL _VARIANT_BOOL;
#define VARIANT_TRUE ((VARIANT_BOOL)0xffff)
#define VARIANT_FALSE ((VARIANT_BOOL)0)

typedef struct  tagBLOB
{
    ULONG cbSize;
    BYTE *pBlobData;
} BLOB;
typedef struct tagBLOB *LPBLOB;

typedef unsigned short VARTYPE;

typedef struct  tagCLIPDATA
{
    ULONG cbSize;      // includes sizeof(ulClipFmt)
    long ulClipFmt;
    BYTE *pClipData;
} CLIPDATA;


/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 *
 *
 *  VT_EMPTY            [V]   [P]     nothing
 *  VT_NULL             [V]   [P]     SQL style Null
 *  VT_I2               [V][T][P][S]  2 byte signed int
 *  VT_I4               [V][T][P][S]  4 byte signed int
 *  VT_R4               [V][T][P][S]  4 byte real
 *  VT_R8               [V][T][P][S]  8 byte real
 *  VT_CY               [V][T][P][S]  currency
 *  VT_DATE             [V][T][P][S]  date
 *  VT_BSTR             [V][T][P][S]  OLE Automation string
 *  VT_DISPATCH         [V][T][P][S]  IDispatch *
 *  VT_ERROR            [V][T][P][S]  SCODE
 *  VT_BOOL             [V][T][P][S]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]  VARIANT *
 *  VT_UNKNOWN          [V][T]   [S]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S]  16 byte fixed point
 *  VT_I1                  [T]        signed char
 *  VT_UI1              [V][T][P][S]  unsigned char
 *  VT_UI2                 [T][P]     unsigned short
 *  VT_UI4                 [T][P]     unsigned short
 *  VT_I8                  [T][P]     signed 64-bit int
 *  VT_UI8                 [T][P]     unsigned 64-bit int
 *  VT_INT                 [T]        signed machine int
 *  VT_UINT                [T]        unsigned machine int
 *  VT_VOID                [T]        C style void
 *  VT_HRESULT             [T]        Standard return type
 *  VT_PTR                 [T]        pointer type
 *  VT_SAFEARRAY           [T]        (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]        C style array
 *  VT_USERDEFINED         [T]        user defined type
 *  VT_LPSTR               [T][P]     null terminated string
 *  VT_LPWSTR              [T][P]     wide null terminated string
 *  VT_FILETIME               [P]     FILETIME
 *  VT_BLOB                   [P]     Length prefixed bytes
 *  VT_STREAM                 [P]     Name of the stream follows
 *  VT_STORAGE                [P]     Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]     Stream contains an object
 *  VT_STORED_OBJECT          [P]     Storage contains an object
 *  VT_BLOB_OBJECT            [P]     Blob contains an object
 *  VT_CF                     [P]     Clipboard format
 *  VT_CLSID                  [P]     A Class ID
 *  VT_VECTOR                 [P]     simple counted array
 *  VT_ARRAY            [V]           SAFEARRAY*
 *  VT_BYREF            [V]           void* for local use
 */

enum VARENUM
{	VT_EMPTY	= 0,
	VT_NULL	= 1,
	VT_I2	= 2,
	VT_I4	= 3,
	VT_R4	= 4,
	VT_R8	= 5,
	VT_CY	= 6,
	VT_DATE	= 7,
	VT_BSTR	= 8,
	VT_DISPATCH	= 9,
	VT_ERROR	= 10,
	VT_BOOL	= 11,
	VT_VARIANT	= 12,
	VT_UNKNOWN	= 13,
	VT_DECIMAL	= 14,
	VT_I1	= 16,
	VT_UI1	= 17,
	VT_UI2	= 18,
	VT_UI4	= 19,
	VT_I8	= 20,
	VT_UI8	= 21,
	VT_INT	= 22,
	VT_UINT	= 23,
	VT_VOID	= 24,
	VT_HRESULT	= 25,
	VT_PTR	= 26,
	VT_SAFEARRAY	= 27,
	VT_CARRAY	= 28,
	VT_USERDEFINED	= 29,
	VT_LPSTR	= 30,
	VT_LPWSTR	= 31,
	VT_FILETIME	= 64,
	VT_BLOB	= 65,
	VT_STREAM	= 66,
	VT_STORAGE	= 67,
	VT_STREAMED_OBJECT	= 68,
	VT_STORED_OBJECT	= 69,
	VT_BLOB_OBJECT	= 70,
	VT_CF	= 71,
	VT_CLSID	= 72,
	VT_VECTOR	= 0x1000,
	VT_ARRAY	= 0x2000,
	VT_BYREF	= 0x4000,
	VT_RESERVED	= 0x8000,
	VT_ILLEGAL	= 0xffff,
	VT_ILLEGALMASKED	= 0xfff,
	VT_TYPEMASK	= 0xfff
};
typedef ULONG PROPID;

/* Macro to calculate the size of the above pClipData */
#define CBPCLIPDATA(clipdata)  \
    ( (clipdata).cbSize - sizeof((clipdata).ulClipFmt) )

typedef GUID   FMTID;
typedef const FMTID& REFFMTID;

/* Well-known Property Set Format IDs*/
extern const FMTID FMTID_SummaryInformation;
extern const FMTID FMTID_DocSummaryInformation;
extern const FMTID FMTID_UserDefinedProperties;

inline BOOL operator==(REFFMTID g1, REFFMTID g2)
{ return IsEqualGUID(g1, g2); }
inline BOOL operator!=(REFFMTID g1, REFFMTID g2)
{ return !IsEqualGUID(g1, g2); }

/* Flags for IPropertySetStorage::Create*/
#define	PROPSETFLAG_DEFAULT	( 0 )

#define	PROPSETFLAG_NONSIMPLE	( 1 )

#define	PROPSETFLAG_ANSI	( 2 )

/* FORWARD REFERENCES */
interface IPropertyStorage;
interface IEnumSTATPROPSTG;
interface IEnumSTATPROPSETSTG;

typedef  IPropertyStorage  *LPPROPERTYSTORAGE;

typedef struct tagPROPVARIANT PROPVARIANT;

typedef struct  tagCAUB
{
    ULONG cElems;
    unsigned char  *pElems;
} CAUB;

typedef struct  tagCAI
{
    ULONG cElems;
    short  *pElems;
} CAI;

typedef struct  tagCAUI
{
    ULONG cElems;
    USHORT  *pElems;
} CAUI;

typedef struct  tagCAL
{
    ULONG cElems;
    long  *pElems;
} CAL;

typedef struct  tagCAUL
{
    ULONG cElems;
    ULONG  *pElems;
} CAUL;

typedef struct  tagCAFLT
{
    ULONG cElems;
    float  *pElems;
} CAFLT;

typedef struct  tagCADBL
{
    ULONG cElems;
    double  *pElems;
} CADBL;

typedef struct  tagCACY
{
    ULONG cElems;
    CY  *pElems;
} CACY;
 
typedef struct  tagCADATE
{
    ULONG cElems;
    DATE  *pElems;
} CADATE;

typedef struct  tagCABSTR
{
    ULONG cElems;
    BSTR  *pElems;
} CABSTR;

typedef struct  tagCABOOL
{
    ULONG cElems;
    VARIANT_BOOL  *pElems;
} CABOOL;

typedef struct  tagCASCODE
{
    ULONG cElems;
    SCODE  *pElems;
} CASCODE;

typedef struct  tagCAPROPVARIANT
{
    ULONG cElems;
    PROPVARIANT  *pElems;
} CAPROPVARIANT;

typedef struct  tagCAH
{
    ULONG cElems;
    LARGE_INTEGER  *pElems;
} CAH;

typedef struct  tagCAUH
{
    ULONG cElems;
    ULARGE_INTEGER  *pElems;
} CAUH;

typedef struct  tagCALPSTR
{
    ULONG cElems;
    LPSTR  *pElems;
} CALPSTR;

typedef struct  tagCALPWSTR
{
    ULONG cElems;
    LPWSTR  *pElems;
} CALPWSTR;

typedef struct  tagCAFILETIME
{
    ULONG cElems;
    FILETIME  *pElems;
} CAFILETIME;

typedef struct  tagCACLIPDATA
{
    ULONG cElems;
    CLIPDATA  *pElems;
} CACLIPDATA;

typedef struct  tagCACLSID
{
    ULONG cElems;
    CLSID  *pElems;
} CACLSID;

/* Disable the warning about the obsolete member named 'bool'*/
/* 'bool', 'true', 'false', 'mutable', 'explicit', & 'typename'*/
/* are reserved keywords*/
#ifdef _MSC_VER
#pragma warning(disable:4237)
#endif

struct  tagPROPVARIANT
{
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    union 
    {
        UCHAR bVal;
        short iVal;
        USHORT uiVal;
        VARIANT_BOOL boolVal;
        long lVal;
        ULONG ulVal;
        float fltVal;
        SCODE scode;
        LARGE_INTEGER hVal;
        ULARGE_INTEGER uhVal;
        double dblVal;
        CY cyVal;
        DATE date;
        FILETIME filetime;
        CLSID  *puuid;
        BLOB blob;
        CLIPDATA  *pclipdata;
        IStream  *pStream;
        IStorage  *pStorage;
        BSTR bstrVal;
        LPSTR pszVal;
        LPWSTR pwszVal;
        CAUB caub;
        CAI cai;
        CAUI caui;
        CABOOL cabool;
        CAL cal;
        CAUL caul;
        CAFLT caflt;
        CASCODE cascode;
        CAH cah;
        CAUH cauh;
        CADBL cadbl;
        CACY cacy;
        CADATE cadate;
        CAFILETIME cafiletime;
        CACLSID cauuid;
        CACLIPDATA caclipdata;
        CABSTR cabstr;
        CALPSTR calpstr;
        CALPWSTR calpwstr;
        CAPROPVARIANT capropvar;
    };
};
typedef struct tagPROPVARIANT  *LPPROPVARIANT;

/* Reserved global Property IDs */
#define	PID_DICTIONARY	( 0 )

#define	PID_CODEPAGE	( 0x1 )

#define	PID_FIRST_USABLE	( 0x2 )

#define	PID_FIRST_NAME_DEFAULT	( 0xfff )

#define	PID_LOCALE	( 0x80000000 )

#define	PID_MODIFY_TIME	( 0x80000001 )

#define	PID_SECURITY	( 0x80000002 )

#define	PID_ILLEGAL	( 0xffffffff )

/* Property IDs for the SummaryInformation Property Set */

#define PIDSI_TITLE               0x00000002L  /* VT_LPSTR*/
#define PIDSI_SUBJECT             0x00000003L  /* VT_LPSTR*/
#define PIDSI_AUTHOR              0x00000004L  /* VT_LPSTR*/
#define PIDSI_KEYWORDS            0x00000005L  /* VT_LPSTR*/
#define PIDSI_COMMENTS            0x00000006L  /* VT_LPSTR*/
#define PIDSI_TEMPLATE            0x00000007L  /* VT_LPSTR*/
#define PIDSI_LASTAUTHOR          0x00000008L  /* VT_LPSTR*/
#define PIDSI_REVNUMBER           0x00000009L  /* VT_LPSTR*/
#define PIDSI_EDITTIME            0x0000000aL  /* VT_FILETIME (UTC)*/
#define PIDSI_LASTPRINTED         0x0000000bL  /* VT_FILETIME (UTC)*/
#define PIDSI_CREATE_DTM          0x0000000cL  /* VT_FILETIME (UTC)*/
#define PIDSI_LASTSAVE_DTM        0x0000000dL  /* VT_FILETIME (UTC)*/
#define PIDSI_PAGECOUNT           0x0000000eL  /* VT_I4*/
#define PIDSI_WORDCOUNT           0x0000000fL  /* VT_I4*/
#define PIDSI_CHARCOUNT           0x00000010L  /* VT_I4*/
#define PIDSI_THUMBNAIL           0x00000011L  /* VT_CF*/
#define PIDSI_APPNAME             0x00000012L  /* VT_LPSTR*/
#define PIDSI_DOC_SECURITY        0x00000013L  /* VT_I4*/
#define	PRSPEC_INVALID	( 0xffffffff )

#define	PRSPEC_LPWSTR	( 0 )

#define	PRSPEC_PROPID	( 1 )

typedef struct  tagPROPSPEC
{
    ULONG ulKind;
    union 
    {
        PROPID propid;
        LPOLESTR lpwstr;
    };
} PROPSPEC;

typedef struct  tagSTATPROPSTG
{
    LPOLESTR lpwstrName;
    PROPID propid;
    VARTYPE vt;
} STATPROPSTG;


inline WORD OSVERHI(DWORD dwOSVer)
{
    return (WORD) (dwOSVer >> 16);
}
inline WORD OSVERLOW(DWORD dwOSVer)
{
    return (WORD) (dwOSVer & ((unsigned)~((DWORD) 0) >> 16));
}

#ifndef LOBYTE  
/* code from MSDN */
#define LOBYTE(a) (BYTE) ((a) & ((unsigned)~0>>CHAR_BIT))
#define HIBYTE(a) (BYTE) ((unsigned)(a) >> CHAR_BIT)
#endif

/* Macros for parsing the OS Version of the Property Set Header*/
#define PROPSETHDR_OSVER_KIND(dwOSVer)      OSVERHI( (dwOSVer) )
#define PROPSETHDR_OSVER_MAJOR(dwOSVer)     LOBYTE( OSVERLOW( (dwOSVer) ))
#define PROPSETHDR_OSVER_MINOR(dwOSVer)     HIBYTE( OSVERLOW( (dwOSVer) ))
#define PROPSETHDR_OSVERSION_UNKNOWN        0xFFFFFFFF

typedef struct  tagSTATPROPSETSTG
{
    FMTID fmtid;
    CLSID clsid;
    DWORD grfFlags;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD dwOSVersion;
} STATPROPSETSTG;


EXTERN_C const IID IID_IPropertyStorage;

/****************************************************************
 *
 *           Header for interface: IPropertyStorage
 *
 ****************************************************************/

interface IPropertyStorage : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
        /* [in] */ ULONG cpspec,
        /* [in] */ const PROPSPEC  rgpspec[  ],
        /* [out] */ PROPVARIANT  rgpropvar[  ]) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE WriteMultiple( 
        /* [in] */ ULONG cpspec,
        /* [in] */ const PROPSPEC  rgpspec[  ],
        /* [in] */ const PROPVARIANT  rgpropvar[  ],
        /* [in] */ PROPID propidNameFirst) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE DeleteMultiple( 
        /* [in] */ ULONG cpspec,
        /* [in] */ const PROPSPEC  rgpspec[  ]) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE ReadPropertyNames( 
        /* [in] */ ULONG cpropid,
        /* [in] */ const PROPID  rgpropid[  ],
        /* [out] */ LPOLESTR  rglpwstrName[  ]) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE WritePropertyNames( 
        /* [in] */ ULONG cpropid,
        /* [in] */ const PROPID  rgpropid[  ],
        /* [in] */ const LPOLESTR  rglpwstrName[  ]) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE DeletePropertyNames( 
        /* [in] */ ULONG cpropid,
        /* [in] */ const PROPID  rgpropid[  ]) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        /* [in] */ DWORD grfCommitFlags) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Revert( void) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Enum( 
        /* [out] */ IEnumSTATPROPSTG  **ppenum) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE SetTimes( 
        /* [in] */ const FILETIME  *pctime,
        /* [in] */ const FILETIME  *patime,
        /* [in] */ const FILETIME  *pmtime) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE SetClass( 
        /* [in] */ REFCLSID clsid) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        /* [out] */ STATPROPSETSTG  *pstatpsstg) = 0;
        
};

/****************************************************************
 *
 *           Header for interface: IPropertySetStorage
 *
 ****************************************************************/

EXTERN_C const IID IID_IPropertySetStorage;

interface IPropertySetStorage : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Create( 
        /* [in] */ REFFMTID rfmtid,
        /* [in] */ const CLSID  *pclsid,
        /* [in] */ DWORD grfFlags,
        /* [in] */ DWORD grfMode,
        /* [out] */ IPropertyStorage  **ppprstg) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Open( 
        /* [in] */ REFFMTID rfmtid,
        /* [in] */ DWORD grfMode,
        /* [out] */ IPropertyStorage  **ppprstg) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Delete( 
        /* [in] */ REFFMTID rfmtid) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Enum( 
        /* [out] */ IEnumSTATPROPSETSTG  **ppenum) = 0;
        
};

typedef  IPropertySetStorage  *LPPROPERTYSETSTORAGE;

/****************************************************************
 *
 *           Header for interface: IEnumSTATPROPSTG
 *
 ****************************************************************/

typedef  IEnumSTATPROPSTG  *LPENUMSTATPROPSTG;
EXTERN_C const IID IID_IEnumSTATPROPSTG;

interface IEnumSTATPROPSTG : public IUnknown
{
public:
    virtual  HRESULT STDMETHODCALLTYPE Next( 
        /* [in] */ ULONG celt,
        /* [out] */ STATPROPSTG  *rgelt,
        /* [out] */ ULONG  *pceltFetched) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Skip( 
        /* [in] */ ULONG celt) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IEnumSTATPROPSTG  **ppenum) = 0;
    
};

typedef  IEnumSTATPROPSETSTG  *LPENUMSTATPROPSETSTG;

EXTERN_C const IID IID_IEnumSTATPROPSETSTG;


/****************************************************************
 *
 *           Header for interface: IEnumSTATPROPSETSTG
 *
 ****************************************************************/

interface IEnumSTATPROPSETSTG : public IUnknown
{
public:
    virtual  HRESULT STDMETHODCALLTYPE Next( 
        /* [in] */ ULONG celt,
        /* [out] */ STATPROPSETSTG  *rgelt,
        /* [out] */ ULONG  *pceltFetched) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Skip( 
        /* [in] */ ULONG celt) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IEnumSTATPROPSETSTG  **ppenum) = 0;
        
};

#ifdef __cplusplus
extern "C" {
#endif

STDAPI PropVariantCopy( PROPVARIANT * pvarDest, 
                        const PROPVARIANT * pvarSrc );
STDAPI PropVariantClear( PROPVARIANT * pvar );

STDAPI FreePropVariantArray( ULONG cVariants, PROPVARIANT * rgvars );

STDAPI_(void) SysFreeString(BSTR bstr);
STDAPI_(BSTR) SysAllocString(LPOLECHAR pwsz);

#ifdef __cplusplus
};
#endif

#include <memory.h>
#ifdef __cplusplus
inline void PropVariantInit ( PROPVARIANT * pvar )
{
    memset ( pvar, 0, sizeof(PROPVARIANT) );
}
#else
#define PropVariantInit(pvar) memset ( pvar, 0, sizeof(PROPVARIANT) )
#endif


#endif /*#ifndef  _PROP_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\h\storagep.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       storagep.h
//
//  Contents:   Internal storage information
//
//--------------------------------------------------------------------------

#ifndef __STORAGEP_H__
#define __STORAGEP_H__

// The byte combination that identifies that a file is a storage of
// some kind

const BYTE SIGSTG[] = {0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1};
const BYTE CBSIGSTG = sizeof(SIGSTG);

// The first portion of a storage file
struct SStorageFile
{
    BYTE	abSig[CBSIGSTG];		//  Signature
    CLSID	_clid;				//  Class Id
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\h\storage.h ===
/*
 +---------------------------------------------------------------
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1996.
 *
 *  File:       storage.h
 *
 *  Contents:   This is the main file to include to use the reference
 *              implementation.
 *
 *  Note:       Some of the defintions have been changed to TCHAR
 *              instead of WCHAR, to add support for ANSI APIs.
 *              TCHAR becomes WCHAR with _UNICODE defined, and char
 *              otherwise. (See tchar.h for details).
 *
 *--------------------------------------------------------------- 
 */


#ifndef _STORAGE_H_
#define _STORAGE_H_

#include "ref.hxx"
#include "tchar.h"


/****** Storage Error Codes *************************************************/

/* DOS-based error codes */
#define STG_E_INVALIDFUNCTION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x01)

#define STG_E_FILENOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x02)

#define STG_E_PATHNOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x03)

#define STG_E_TOOMANYOPENFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x04)

#define STG_E_ACCESSDENIED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x05)

#define STG_E_INVALIDHANDLE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x06)

#define STG_E_INSUFFICIENTMEMORY \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x08)

#define STG_E_INVALIDPOINTER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x09)

#define STG_E_NOMOREFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x12)

#define STG_E_DISKISWRITEPROTECTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x13)

#define STG_E_SEEKERROR \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x19)

#define STG_E_SHAREVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x20)

#define STG_E_WRITEFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1d)

#define STG_E_READFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1e)

#define STG_E_LOCKVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x21)

#define STG_E_FILEALREADYEXISTS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x50)

#define STG_E_INVALIDPARAMETER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x57)

#define STG_E_MEDIUMFULL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x70)

#define STG_E_ABNORMALAPIEXIT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfa)

#define STG_E_INVALIDHEADER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfb)

#define STG_E_INVALIDNAME \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfc)

#define STG_E_UNKNOWN \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfd)

#define STG_E_UNIMPLEMENTEDFUNCTION\
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfe)

#define STG_E_INVALIDFLAG \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xff)

/* Standard storage error codes */
#define STG_E_INUSE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x100)

#define STG_E_NOTCURRENT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x101)

#define STG_E_REVERTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x102)

#define STG_E_CANTSAVE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x103)

#define STG_E_OLDFORMAT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x104)
	
#define STG_E_OLDDLL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x105)

#define STG_E_SHAREREQUIRED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x106)

#define STG_E_NOTFILEBASEDSTORAGE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x107)

#define STG_E_DOCFILECORRUPT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x109)

#define STG_E_BADBASEADDRESS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x110)

#define STG_E_DOCFILETOOLARGE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x111)

/* Information returns */
#define STG_S_CONVERTED \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x200)

#define STG_S_BUFFEROVERFLOW \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x201)

#define STG_S_TRYOVERWRITE \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x202)    


/****** Storage types *******************************************************/

#ifndef HUGEP
#define HUGEP
#endif

#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT		0x00000000L

/* not used in ref, but defined here for error checking etc. */
#define STGM_TRANSACTED		0x00010000L
#define STGM_SIMPLE             0x08000000L
#define STGM_NOSCRATCH          0x00100000L

#define STGM_READ		0x00000000L
#define STGM_WRITE		0x00000001L
#define STGM_READWRITE		0x00000002L

#define STGM_SHARE_DENY_NONE	0x00000040L
#define STGM_SHARE_DENY_READ	0x00000030L
#define STGM_SHARE_DENY_WRITE	0x00000020L
#define STGM_SHARE_EXCLUSIVE	0x00000010L

#define STGM_PRIORITY		0x00040000L
#define STGM_DELETEONRELEASE	0x04000000L

#define STGM_CREATE		0x00001000L
#define STGM_CONVERT		0x00020000L
#define STGM_FAILIFTHERE	0x00000000L

/* Storage commit types */
typedef enum tagSTGC
{
    STGC_DEFAULT = 0,
    STGC_OVERWRITE  = 1,
    STGC_ONLYIFCURRENT  = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4
} STGC;

/* Stream name block definitions */
typedef TCHAR FAR* FAR* SNB;

#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif

/* Storage stat buffer */

typedef struct FARSTRUCT tagSTATSTG
{
    TCHAR FAR* pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
} STATSTG;


/* Storage element types */
typedef enum tagSTGTY
{
    STGTY_STORAGE   = 1,
    STGTY_STREAM    = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY  = 4
} STGTY;

typedef enum tagSTREAM_SEEK
{
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2
} STREAM_SEEK;

typedef enum tagLOCKTYPE
{
    LOCK_WRITE      = 1,
    LOCK_EXCLUSIVE  = 2,
    LOCK_ONLYONCE   = 4
} LOCKTYPE;

typedef enum tagSTGMOVE
{
    STGMOVE_MOVE    = 0,
    STGMOVE_COPY    = 1
} STGMOVE;

typedef enum tagSTATFLAG
{
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1
} STATFLAG;

#define STGFMT_STORAGE          0
#define STGFMT_FILE             3
#define STGFMT_ANY              4
#define STGFMT_DOCFILE          5

// STG initialization options for StgCreateStorageEx
#define STGOPTIONS_VERSION 2

typedef struct tagSTGOPTIONS
{
    USHORT usVersion;            // Versions 1 and 2 supported
    USHORT reserved;             // must be 0 for padding
    ULONG ulSectorSize;          // docfile header sector size (512)
    const TCHAR *pwcsTemplateFile;  // version 2 or above
} STGOPTIONS;

/****** Storage Enumerators *************************************************/

#define LPENUMSTATSTG        IEnumSTATSTG FAR*

#undef  INTERFACE
#define INTERFACE   IEnumSTATSTG

DECLARE_INTERFACE_(IEnumSTATSTG, IUnknown)
{
    /* *** IUnknown methods *** */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* *** IENUMSTATSTG methods *** */
    STDMETHOD(Next) (THIS_ ULONG celt, STATSTG FAR * rgelt, ULONG FAR *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATSTG FAR *FAR *ppenm) PURE;
};


/****** ILockBytes Interface ************************************************/

#define LPLOCKBYTES     ILockBytes FAR*

#undef  INTERFACE
#define INTERFACE   ILockBytes

DECLARE_INTERFACE_(ILockBytes, IUnknown)
{
    /* *** IUnknown methods *** */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* *** ILockBytes methods *** */
    STDMETHOD(ReadAt) (THIS_ ULARGE_INTEGER ulOffset,
             VOID HUGEP *pv,
             ULONG cb,
             ULONG FAR *pcbRead) PURE;
    STDMETHOD(WriteAt) (THIS_ ULARGE_INTEGER ulOffset,
              VOID const HUGEP *pv,
              ULONG cb,
              ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Flush) (THIS) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER cb) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                   ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};


/****** IStream Interface ***************************************************/


#define LPSTREAM        IStream FAR*

#undef  INTERFACE
#define INTERFACE   IStream

DECLARE_INTERFACE_(IStream, IUnknown)
{
    /* *** IUnknown methods *** */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* *** IStream methods *** */
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv,
		     ULONG cb, ULONG FAR *pcbRead) PURE;
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv,
            ULONG cb,
            ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove,
               DWORD dwOrigin,
               ULARGE_INTEGER FAR *plibNewPosition) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize) PURE;
    STDMETHOD(CopyTo) (THIS_ IStream FAR *pstm,
             ULARGE_INTEGER cb,
             ULARGE_INTEGER FAR *pcbRead,
             ULARGE_INTEGER FAR *pcbWritten) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
    STDMETHOD(Clone)(THIS_ IStream FAR * FAR *ppstm) PURE;
};


/****** IStorage Interface **************************************************/

#define LPSTORAGE       IStorage FAR*

#undef  INTERFACE
#define INTERFACE   IStorage

DECLARE_INTERFACE_(IStorage, IUnknown)
{
    /* *** IUnknown methods *** */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* *** IStorage methods *** */
    STDMETHOD(CreateStream) (THIS_ const TCHAR FAR* pwcsName,
                   DWORD grfMode,
                   DWORD reserved1,
                   DWORD reserved2,
                   IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(OpenStream) (THIS_ const TCHAR FAR* pwcsName,
		 void FAR *reserved1,
                 DWORD grfMode,
                 DWORD reserved2,
                 IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(CreateStorage) (THIS_ const TCHAR FAR* pwcsName,
                DWORD grfMode,
                DWORD reserved1,
                DWORD reserved2,
                IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(OpenStorage) (THIS_ const TCHAR FAR* pwcsName,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(CopyTo) (THIS_ DWORD ciidExclude,
 		       IID const FAR *rgiidExclude,
 		       SNB snbExclude,
 		       IStorage FAR *pstgDest) PURE;
    STDMETHOD(MoveElementTo) (THIS_ TCHAR const FAR* lpszName,
    			      IStorage FAR *pstgDest,
                              TCHAR const FAR* lpszNewName,
                              DWORD grfFlags) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(EnumElements) (THIS_ DWORD reserved1,
                 void FAR *reserved2,
                 DWORD reserved3,
                 IEnumSTATSTG FAR *FAR *ppenm) PURE;
    STDMETHOD(DestroyElement) (THIS_ const TCHAR FAR* pwcsName) PURE;
    STDMETHOD(RenameElement) (THIS_ const TCHAR FAR* pwcsOldName,
                const TCHAR FAR* pwcsNewName) PURE;
    STDMETHOD(SetElementTimes) (THIS_ const TCHAR FAR *lpszName,
    			        FILETIME const FAR *pctime,
                                FILETIME const FAR *patime,
                                FILETIME const FAR *pmtime) PURE;
    STDMETHOD(SetClass) (THIS_ REFCLSID clsid) PURE;
    STDMETHOD(SetStateBits) (THIS_ DWORD grfStateBits, DWORD grfMask) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};


/****** IRootStorage Interface **********************************************/

#define LPROOTSTORAGE       IRootStorage FAR*

#undef  INTERFACE
#define INTERFACE   IRootStorage

DECLARE_INTERFACE_(IRootStorage, IUnknown)
{
    /* *** IUnknown methods *** */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* *** IRootStorage methods *** */
    STDMETHOD(SwitchToFile) (THIS_ LPTSTR lpstrFile) PURE;
};

/****** Storage API Prototypes ********************************************/
#ifdef __cplusplus
extern "C" {
#endif

STDAPI StgCreateDocfile(const TCHAR FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen);
STDAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorage(const TCHAR FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR * FAR *ppstgOpen);
STDAPI StgIsStorageFile(const TCHAR FAR* pwcsName);
STDAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt);

STDAPI StgCreateStorageEx (const TCHAR* pwcsName,
        DWORD grfMode,
        DWORD stgfmt,              // enum
        DWORD grfAttrs,            // reserved
        STGOPTIONS * pStgOptions,
        void * reserved,
        REFIID riid,
        void ** ppObjectOpen);

/****** Malloc API's ********************************************/
interface IMalloc;
#define LPMALLOC  IMalloc FAR*

STDAPI CoGetMalloc( DWORD dwMemContext, LPMALLOC * ppMalloc );
STDAPI_(LPVOID) CoTaskMemAlloc( ULONG cb );
STDAPI_(void) CoTaskMemFree( void* pv );
STDAPI_(LPVOID) CoTaskMemRealloc( LPVOID pv, ULONG cb );

#ifdef __cplusplus
};
#endif

/****** IMalloc Interface **********************************************/
#undef  INTERFACE
#define INTERFACE IMalloc

DECLARE_INTERFACE_(IMalloc, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /*** IMallic methods ***/
    STDMETHOD_(void*,Alloc)    ( ULONG cb) PURE;
    STDMETHOD_(void *,Realloc) ( void *pv, ULONG cb) PURE;    
    STDMETHOD_(void,Free)      ( void *pv) PURE;
    STDMETHOD_(ULONG,GetSize)  ( void *pv) PURE;
    STDMETHOD_(int,DidAlloc)   ( void *pv) PURE;
    STDMETHOD_(void,HeapMinimize)( void ) PURE;
};

#define MEMCTX_TASK 1  /* the only supported flag for CoGetMalloc */

#endif /* ifndef _STORAGE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\ntprop.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1992-1996
//
// File:        ntprop.cxx
//
// Contents:    OLE Appendix B property set support.
//
//
//---------------------------------------------------------------------------

#include "pch.cxx" 

#define CCH_MAP         (1 << CBIT_CHARMASK)            // 32
#define CHARMASK        (CCH_MAP - 1)                   // 0x1f

// we use static array instead of string literals because some systems
// have 4 bytes string literals, and would not produce the correct result
// for REF's 2 byte Unicode convention
// 
OLECHAR aocMap[CCH_MAP + 1] = {'a','b','c','d','e','f','g',
                               'h','i','j','k','l','m','n',
                               'o','p','q','r','s','t','u',
                               'v','w','x','y','z',
                               '0','1','2','3','4','5','\0'};

#define CALPHACHARS  (1 + (OLECHAR)'z' - (OLECHAR)'a')

GUID guidSummary =
    { 0xf29f85e0,
      0x4ff9, 0x1068,
      { 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9 } };

OLECHAR oszSummary[] = {'S','u','m','m','a','r','y',
                        'I','n','f','o','r','m','a','t','i','o','n','\0'};

GUID guidDocumentSummary =
    { 0xd5cdd502,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

OLECHAR oszDocumentSummary[] = {'D','o','c','u','m','e','n','t',
                                'S','u','m','m','a','r','y',
                                'I','n','f','o','r','m','a','t','i','o','n',
                                '\0'};

// Note that user defined properties are placed in section 2 with the below
// GUID as the FMTID -- alas, we did not expect Office95 to actually use it.

GUID guidDocumentSummarySection2 =
    { 0xd5cdd505,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

// *Global Info*

OLECHAR oszGlobalInfo[] = {'G','l','o','b','a','l',' ','I','n','f','o','\0'};

GUID guidGlobalInfo =
    { 0x56616F00,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

// *Image Contents*

OLECHAR oszImageContents[] = {'I','m','a','g','e',' ',
                              'C','o','n','t','e','n','t','s','\0'};

GUID guidImageContents =
    { 0x56616500,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

// *Image Info*

OLECHAR oszImageInfo[] = {'I','m','a','g','e',' ','I','n','f','o'};

GUID guidImageInfo =
    { 0x56616500,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };


__inline OLECHAR
MapChar(IN ULONG i)
{
    return((OLECHAR) aocMap[i & CHARMASK]);
}


//+--------------------------------------------------------------------------
// Function:    RtlGuidToPropertySetName
//
// Synopsis:    Map property set GUID to null-terminated UNICODE name string.
//
//              The awcname parameter is assumed to be a buffer with room for
//              CWC_PROPSETSZ (28) UNICODE characters.  The first character
//              is always WC_PROPSET0 (0x05), as specified by the OLE Appendix
//              B documentation.  The colon character normally used as an NT
//              stream name separator is not written to the caller's buffer.
//
//              No error is possible.
//
// Arguments:   IN GUID *pguid        -- pointer to GUID to convert
//              OUT OLECHAR aocname[] -- output string buffer
//
// Returns:     count of non-NULL characters in the output string buffer
//---------------------------------------------------------------------------

ULONG PROPSYSAPI PROPAPI
RtlGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[])
{
    ULONG cbitRemain = CBIT_BYTE;
    OLECHAR *poc = aocname;

#ifdef BIGENDIAN                // since we go thru it byte by byte
    GUID guidSwapped = *pguid;  // we have to swap it for big endian
    ByteSwap(&guidSwapped);
    BYTE *pb = (BYTE *) &guidSwapped;
#else
    BYTE *pb = (BYTE *) pguid;
#endif
    BYTE *pbEnd = pb + sizeof(GUID);    

    *poc++ = OC_PROPSET0;

    //  -----------------------
    //  Check for special-cases
    //  -----------------------

    // Note: CCH_PROPSET includes the OC_PROPSET0, and sizeof(osz...)
    // includes the trailing '\0', so sizeof(osz...) is ok because the
    // OC_PROPSET0 character compensates for the trailing NULL character.

    // Is this the SummaryInformation propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszSummary)/sizeof(OLECHAR));

    if (*pguid == guidSummary)
    {
        RtlCopyMemory(poc, oszSummary, sizeof(oszSummary));
        return(sizeof(oszSummary)/sizeof(OLECHAR));
    }

    // Is this The DocumentSummaryInformation or User-Defined propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszDocumentSummary)/sizeof(OLECHAR));

    if (*pguid == guidDocumentSummary || *pguid == guidDocumentSummarySection2)
    {
        RtlCopyMemory(poc, oszDocumentSummary, sizeof(oszDocumentSummary));
        return(sizeof(oszDocumentSummary)/sizeof(OLECHAR));
    }

    // Is this the Global Info propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszGlobalInfo)/sizeof(OLECHAR));
    if (*pguid == guidGlobalInfo)
    {
        RtlCopyMemory(poc, oszGlobalInfo, sizeof(oszGlobalInfo));
        return(sizeof(oszGlobalInfo)/sizeof(OLECHAR));
    }

    // Is this the Image Contents propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszImageContents)/sizeof(OLECHAR));
    if (*pguid == guidImageContents)
    {
        RtlCopyMemory(poc, oszImageContents, sizeof(oszImageContents));
        return(sizeof(oszImageContents)/sizeof(OLECHAR));
    }

    // Is this the Image Info propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszImageInfo)/sizeof(OLECHAR));
    if (*pguid == guidImageInfo)
    {
        RtlCopyMemory(poc, oszImageInfo, sizeof(oszImageInfo));
        return(sizeof(oszImageInfo)/sizeof(OLECHAR));
    }


    //  ------------------------------
    //  Calculate the string-ized GUID
    //  ------------------------------

    // If this is a big-endian system, we need to convert
    // the GUID to little-endian for the conversion.
#if BIGENDIAN
    GUID guidByteSwapped = *pguid;
    PropByteSwap( &guidByteSwapped );
    pguid = &guidByteSwapped;
#endif

    // Point to the beginning and ending of the GUID
    pb = (BYTE*) pguid;
    pbEnd = pb + sizeof(*pguid);

    // Walk 'pb' through each byte of the GUID.

    while (pb < pbEnd)
    {
        ULONG i = *pb >> (CBIT_BYTE - cbitRemain);

        if (cbitRemain >= CBIT_CHARMASK)
        {
            *poc = MapChar(i);
            if (cbitRemain == CBIT_BYTE && *poc >= (OLECHAR)'a' 
                && *poc <= ((OLECHAR)'z'))
            {
                *poc += (OLECHAR) ( ((OLECHAR)'A') - ((OLECHAR)'a') );
            }
            poc++;
            cbitRemain -= CBIT_CHARMASK;
            if (cbitRemain == 0)
            {
                pb++;
                cbitRemain = CBIT_BYTE;
            }
        }
        else
        {
            if (++pb < pbEnd)
            {
                i |= *pb << cbitRemain;
            }
            *poc++ = MapChar(i);
            cbitRemain += CBIT_BYTE - CBIT_CHARMASK;
        }
    }
    *poc = 0;
    return(CCH_PROPSET);

}


//+--------------------------------------------------------------------------
// Function:    RtlPropertySetNameToGuid
//
// Synopsis:    Map non null-terminated UNICODE string to a property set GUID.
//
//              If the name is not properly formed as per
//              RtlGuidToPropertySetName(), STATUS_INVALID_PARAMETER is
//              returned.  The pguid parameter is assumed to point to a buffer
//              with room for a GUID structure.
//
// Arguments:   IN ULONG cocname     -- count of OLECHARs in string to convert
//              IN OLECHAR aocname[] -- input string to convert
//              OUT GUID *pguid      -- pointer to buffer for converted GUID
//
// Returns:     NTSTATUS
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlPropertySetNameToGuid(
    IN ULONG cocname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    OLECHAR const *poc = aocname;

    if (poc[0] == OC_PROPSET0)
    {
        //  -----------------------
        //  Check for Special-Cases 
        //  -----------------------

        // Note: cocname includes the OC_PROPSET0, and sizeof(osz...)
        // includes the trailing OLESTR('\0'), but the comparison excludes both
        // the leading OC_PROPSET0 and the trailing '\0'.

        // Is this SummaryInformation?
        if (cocname == sizeof(oszSummary)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszSummary, cocname - 1) == 0)
        {
            *pguid = guidSummary;
            return(STATUS_SUCCESS);
        }

        // Is this DocumentSummaryInformation?
        if (cocname == sizeof(oszDocumentSummary)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszDocumentSummary, cocname - 1) == 0)
        {
            *pguid = guidDocumentSummary;
            return(STATUS_SUCCESS);
        }

        // Is this Global Info?
        if (cocname == sizeof(oszGlobalInfo)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszGlobalInfo, cocname - 1) == 0)
        {
            *pguid = guidGlobalInfo;
            return(STATUS_SUCCESS);
        }

        // Is this Image Info?
        if (cocname == sizeof(oszImageInfo)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszImageInfo, cocname - 1) == 0)
        {
            *pguid = guidImageInfo;
            return(STATUS_SUCCESS);
        }

        // Is this Image Contents?
        if (cocname == sizeof(oszImageContents)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszImageContents, cocname - 1) == 0)
        {
            *pguid = guidImageContents;
            return(STATUS_SUCCESS);
        }

        //  ------------------
        //  Calculate the GUID
        //  ------------------

        // None of the special-cases hit, so we must calculate
        // the GUID from the name.

        if (cocname == CCH_PROPSET)
        {
            ULONG cbit;
            BYTE *pb = (BYTE *) pguid - 1;

            RtlZeroMemory(pguid, sizeof(*pguid));
            for (cbit = 0; cbit < CBIT_GUID; cbit += CBIT_CHARMASK)
            {
                ULONG cbitUsed = cbit % CBIT_BYTE;
                ULONG cbitStored;
                OLECHAR oc;

                if (cbitUsed == 0)
                {
                    pb++;
                }

                oc = *++poc - (OLECHAR)'A'; // assume upper case 
                // for wchar (unsigned) -ve values becomes a large number
                // but for char, which is signed, -ve is -ve
                if (oc > CALPHACHARS || oc < 0)
                {
                    // oops, try lower case
                    oc += (OLECHAR) ( ((OLECHAR)'A') - ((OLECHAR)'a'));
                    if (oc > CALPHACHARS || oc < 0)
                    {
                        // must be a digit
                        oc += ((OLECHAR)'a') - ((OLECHAR)'0') + CALPHACHARS;
                        if (oc > CHARMASK)
                        {
                            goto fail;                  // invalid character
                        }
                    }
                }
                *pb |= (BYTE) (oc << cbitUsed);

                cbitStored = min(CBIT_BYTE - cbitUsed, CBIT_CHARMASK);

                // If the translated bits wouldn't all fit in the current byte

                if (cbitStored < CBIT_CHARMASK)
                {
                    oc >>= CBIT_BYTE - cbitUsed;

                    if (cbit + cbitStored == CBIT_GUID)
                    {
                        if (oc != 0)
                        {
                            goto fail;                  // extra bits
                        }
                        break;
                    }
                    pb++;

                    *pb |= (BYTE) oc;
                }
            }
            Status = STATUS_SUCCESS;
        }
    }
#ifdef BIGENDIAN
    ByteSwap(pguid);            // on big endian, we will generate a guid 
                                // with the wrong byteorder, so we have to
                                // swap it  
#endif
    return(Status);

fail:
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\ntpropb.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1994
//
// File:        ntpropb.cxx
//
// Contents:    Property set implementation based on OLE Appendix B.
//
//---------------------------------------------------------------------------

#include "pch.cxx"

#include "h/propvar.hxx"

#define Dbg     DEBTRACE_NTPROP 
#define DbgS(s) (NT_SUCCESS(s)? Dbg : DEBTRACE_ERROR)


#if DBG
ULONG DebugLevel = DEBTRACE_ERROR;
//ULONG DebugLevel = DEBTRACE_ERROR | DEBTRACE_CREATESTREAM;
//ULONG DebugLevel = DEBTRACE_ERROR | MAXULONG;
ULONG DebugIndent;
ULONG cAlloc;
ULONG cFree;
#endif

UNICODECALLOUTS UnicodeCallouts =
{
    WIN32_UNICODECALLOUTS
};


//+---------------------------------------------------------------------------
// Function:    RtlSetUnicodeCallouts, public
//
// Synopsis:    Set the Unicode conversion function pointers
//
// Arguments:   [pUnicodeCallouts]	-- Unicode callouts table
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID PROPSYSAPI PROPAPI
RtlSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts)
{
    UnicodeCallouts = *pUnicodeCallouts;
}

//+---------------------------------------------------------------------------
// Function:    RtlCreatePropertySet, public
//
// Synopsis:    Allocate and initialize a property set context
//
// Arguments:   [ms]            -- Nt Mapped Stream
//              [Flags]         -- *one* of READ/WRITE/CREATE/CREATEIF/DELETE
//              [pguid]         -- property set guid (create only)
//              [pclsid]        -- CLASSID of propset code (create only)
//              [ma]            -- caller's memory allocator
//		[LocaleId]	-- Locale Id (create only)
//              [pOSVersion]    -- pointer to the OS Version header field
//              [pCodePage]     -- pointer to new/returned CodePage of propset
//              [pnp]           -- pointer to returned property set context
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlCreatePropertySet(
    IN NTMAPPEDSTREAM ms,           // Nt Mapped Stream
    IN USHORT Flags,                // *one* of READ/WRITE/CREATE/CREATEIF/DELETE
    OPTIONAL IN GUID const *pguid,  // property set guid (create only)
    OPTIONAL IN GUID const *pclsid, // CLASSID of propset code (create only)
    IN NTMEMORYALLOCATOR ma,	    // caller's memory allocator
    IN ULONG LocaleId,		    // Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion, // OS Version from the propset header
    IN OUT USHORT *pCodePage,       // IN: CodePage of property set (create only)
                                    // OUT: CodePage of property set (always)
    OUT NTPROP *pnp)                // pointer to return prop set context
{
    NTSTATUS Status;
    CMappedStream *pmstm = (CMappedStream *) ms;
    CPropertySetStream *ppsstm = NULL;
    BOOLEAN fOpened = FALSE;

    DebugTrace(0, Dbg, ("RtlCreatePropertySet(ms=%x, f=%x, codepage=%x)\n",
                        ms,
                        Flags,
                        *pCodePage));

    *pnp = NULL;
    Status = STATUS_INVALID_PARAMETER;

    if( pOSVersion != NULL )
        *pOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;

    // Validate the input flags

    if (Flags & ~(CREATEPROP_MODEMASK | CREATEPROP_NONSIMPLE))
    {
        DebugTrace(0, DbgS(Status), (
            "RtlCreatePropertySet(ms=%x, Flags=%x) ==> bad flags!\n",
             ms,
             Flags));
        goto Exit;
    }

    switch (Flags & CREATEPROP_MODEMASK)
    {
        case CREATEPROP_DELETE:
        case CREATEPROP_CREATE:
        case CREATEPROP_CREATEIF:
        case CREATEPROP_WRITE:
            if (!pmstm->IsWriteable())
            {
                Status = STATUS_ACCESS_DENIED;
                goto Exit;
            }
            // FALLTHROUGH

        case CREATEPROP_READ:
	    if (ma == NULL)
	    {
                goto Exit;
	    }
            break;

        default:
            DebugTrace(0, DbgS(Status), (
                "RtlCreatePropertySet(ms=%x, Flags=%x) ==> invalid mode!\n",
                 ms,
                 Flags));
            goto Exit;
    }

    ppsstm = new CPropertySetStream(
                            Flags,
                            pmstm,
			    (PMemoryAllocator *) ma);
    if (ppsstm == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }
    else
    {
        ppsstm->Open(pguid, pclsid, LocaleId,
                     pOSVersion,
                     *pCodePage,
                     &Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        *pCodePage = ppsstm->GetCodePage();
        *pnp = (NTPROP) ppsstm;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // If we created a CPropertySetStream object, but
    // the overall operation failed, we must close/delete
    // the object.  Note that we must do this after
    // the above unlock, since ppsstm will be gone after
    // this.

    if (!NT_SUCCESS(Status) && ppsstm != NULL)
    {
        RtlClosePropertySet((NTPROP) ppsstm);
    }

    DebugTrace(0, DbgS(Status), (
        "RtlCreatePropertySet() ==> ms=%x, s=%x\n--------\n",
        *pnp,
        Status));
    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    RtlClosePropertySet, public
//
// Synopsis:    Delete a property set context
//
// Arguments:   [np]      -- property set context
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlClosePropertySet(
    IN NTPROP np)               // property set context
{
    NTSTATUS Status = STATUS_SUCCESS;
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    DebugTrace(0, Dbg, ("RtlClosePropertySet(np=%x)\n", np));

    ppsstm->Close(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    delete ppsstm;

    DebugTrace(0, DbgS(Status), ("RtlClosePropertySet() ==> s=%x(%x)\n", STATUS_SUCCESS, Status));
    return(STATUS_SUCCESS);
}

//+---------------------------------------------------------------------------
// Function:    RtlOnMappedStreamEvent, public
//
// Synopsis:    Handle a MappedStream event.  Every such
//              event requires a byte-swap of the property set
//              headers.
//
// Arguments:   [np]      -- property set context
//              [pbuf]    -- property set buffer
//              [cbstm]   -- size of mapped stream (or CBSTM_UNKNOWN)
//
// NOTE:        It is assumed that the caller has already taken
//              the CPropertySetStream::Lock.
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlOnMappedStreamEvent(
    IN VOID * np,               // property set context (an NTPROP)
    IN VOID *pbuf,              // property set buffer
    IN ULONG cbstm )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    DebugTrace(0, Dbg, ("RtlOnMappedStreamEvent(np=%x)\n", np));

    // Byte-swap the property set headers.
    ppsstm->ByteSwapHeaders((PROPERTYSETHEADER*) pbuf, cbstm, &Status );
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    DebugTrace(0, DbgS(Status), ("RtlOnMappedStreamEvent() ==> s=%x\n", Status));
    return(Status);

}   // RtlOnMappedStreamEvent()

//+---------------------------------------------------------------------------
// Function:    RtlFlushPropertySet, public
//
// Synopsis:    Flush property set changes to disk
//
// Arguments:   [np]      -- property set context
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlFlushPropertySet(
    IN NTPROP np)               // property set context
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;

    DebugTrace(0, Dbg, ("RtlFlushPropertySet(np=%x)\n", np));

    if (ppsstm->IsModified())
    {
        ppsstm->ReOpen(&Status);           // Reload header/size info
        if( !NT_SUCCESS(Status) ) goto Exit;

        ppsstm->Validate(&Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        ppsstm->Flush(&Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        ppsstm->Validate(&Status);
        if( !NT_SUCCESS(Status) ) goto Exit;
    }

    DebugTrace(0, DbgS(Status), ("RtlFlushPropertySet() ==> s=%x\n--------\n", Status));
Exit:
    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    MapNameToPropId, private
//
// Synopsis:    Find an available propid and map it to the passed name
//
// Arguments:   [ppsstm]        -- property set stream
//              [CodePage]      -- property set codepage
//              [aprs]          -- array of property specifiers
//              [cprop]         -- count of property specifiers
//              [iprop]         -- index of propspec with name to map
//              [pidStart]      -- first PROPID to start mapping attempts
//              [pstatus]       -- NTSTATUS code
//
// Returns:     PROPID mapped to passed name
//
// Note:        Find the first unused propid starting at pidStart.
//---------------------------------------------------------------------------

PROPID
MapNameToPropId(
    IN CPropertySetStream *ppsstm,    // property set stream
    IN USHORT CodePage,
    IN PROPSPEC const aprs[],         // array of property specifiers
    IN ULONG cprop,
    IN ULONG iprop,
    IN PROPID pidStart,
    OUT NTSTATUS *pstatus)
{
    PROPID pid = PID_ILLEGAL;
    OLECHAR const *poszName;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(aprs[iprop].ulKind == PRSPEC_LPWSTR);
    poszName = aprs[iprop].lpwstr;

#ifdef LITTLEENDIAN             // this check will only work for litte Endian
    PROPASSERT(IsOLECHARString(poszName, MAXULONG));
#endif
    for (pid = pidStart; ; pid++)
    {
        ULONG i;
        OLECHAR aocName[CCH_MAXPROPNAMESZ];
        ULONG cbName = sizeof(aocName);

        // The caller must specify a starting propid of 2 or larger, and we
        // must not increment into the reserved propids.

        if (pid == PID_DICTIONARY ||
            pid == PID_CODEPAGE ||
            pid < PID_FIRST_USABLE)
        {
            *pstatus = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        // Do not assign any propids that explitly appear in the array of
        // propspecs involved in this RtlSetProperties call, nor any propids
        // that are associated with any names in the propspec array.

        for (i = 0; i < cprop; i++)
        {
            if (i != iprop)             // skip the entry we are mapping
            {
                // Is the current PID in Propspec[]?
                if (aprs[i].ulKind == PRSPEC_PROPID &&
                    aprs[i].propid == pid)
                {
                    goto nextpid;       // skip colliding pid
                }

                // Is the current PID already used in the property set?
                if (aprs[i].ulKind == PRSPEC_LPWSTR &&
                    ppsstm->QueryPropid(aprs[i].lpwstr, pstatus) == pid)
                {
                    goto nextpid;       // skip colliding pid
                }
                if (!NT_SUCCESS(*pstatus)) goto Exit;
            }
        } // for (i = 0; i < cprop; i++)

        // Do not assign any propids that currently map to any name.
        // Note that the property name we are mapping does not appear in the
        // dictionary -- the caller checked for this case already.

        if (!ppsstm->QueryPropertyNameBuf(pid, aocName, &cbName, pstatus))
        {
            // The property name could not be found in the dictionary
            ULONG cbT;
	    SERIALIZEDPROPERTYVALUE const *pprop;

            // was the name not found due to an error in QueryProperyBuf?
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            // Do not assign any propids that currently have a property value.

            pprop = ppsstm->GetValue(pid, &cbT, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            if (pprop == NULL)
            {
                DebugTrace(0, Dbg, (
		    "MapNameToPropId(Set Entry: pid=%x, name=L'%ws')\n",
                    pid,
                    poszName));

                // Add the caller-provided name to the dictionary, using
                // the PID that we now know is nowhere in use.
                ppsstm->SetPropertyNames(1, &pid, &poszName, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                ppsstm->Validate(pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                break;
            }   // if (pprop == NULL)
        }   // if (!ppsstm->QueryPropertyNameBuf(pid, awcName, 
          
nextpid:
        ;
    } // for (pid = pidStart; ; pid++)

Exit:
    return(pid);
}


//+---------------------------------------------------------------------------
// Function:    ConvertVariantToPropInfo, private
//
// Synopsis:    Convert variant property values to PROPERTY_INFORMATION values
//
// Arguments:   [ppsstm]        -- property set stream
//              [cprop]         -- property count
//              [pidNameFirst]  -- first PROPID for new named properties
//              [aprs]          -- array of property specifiers
//              [apid]          -- buffer for array of propids
//              [avar]          -- array of PROPVARIANTs
//              [apinfo]        -- output array of property info
//
// Returns:     none
//
//---------------------------------------------------------------------------

VOID
ConvertVariantToPropInfo(
    IN CPropertySetStream *ppsstm,    // property set stream
    IN ULONG cprop,                   // property count
    IN PROPID pidNameFirst,           // first PROPID for new named properties
    IN PROPSPEC const aprs[],         // array of property specifiers
    OPTIONAL OUT PROPID apid[],       // buffer for array of propids
    OPTIONAL IN PROPVARIANT const avar[],// array of properties+values
    OUT PROPERTY_INFORMATION *apinfo, // output array of property info
    OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;
    USHORT CodePage = ppsstm->GetCodePage();
    PROPID pidStart = pidNameFirst;
    ULONG iprop;

    for (iprop = 0; iprop < cprop; iprop++)
    {
	PROPID pid;
	ULONG cbprop;

	switch(aprs[iprop].ulKind)
	{
	case PRSPEC_LPWSTR:
	{
	    PROPASSERT(IsOLECHARString(aprs[iprop].lpwstr, MAXULONG));
	    pid = ppsstm->QueryPropid(aprs[iprop].lpwstr, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    if (pid == PID_ILLEGAL && avar != NULL)
	    {
		pid = MapNameToPropId(
				ppsstm,
				CodePage,
				aprs,
				cprop,
				iprop,
				pidStart,
                                pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

		pidStart = pid + 1;
	    }
	    break;
	}

	case PRSPEC_PROPID:
	    pid = aprs[iprop].propid;
	    break;

	default:
	    PROPASSERT(!"Bad ulKind");
	    *pstatus = STATUS_INVALID_PARAMETER;
            goto Exit;

	    break;
	}

	if (apid != NULL)
	{
	    apid[iprop] = pid;
	}

	// RtlConvertVariantToProperty returns NULL on overflow and
	// Raises on bad data.

	cbprop = 0;             // Assume property deletion
	if (pid != PID_ILLEGAL && avar != NULL)
	{
	    RtlConvertVariantToProperty(
			    &avar[iprop],
			    CodePage,
			    NULL,
			    &cbprop,
			    pid,
			    FALSE,
                            pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
	    PROPASSERT(cbprop == DwordAlign(cbprop));
	}
	apinfo[iprop].cbprop = cbprop;
	apinfo[iprop].pid = pid;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}

//+---------------------------------------------------------------------------
// Function:    RtlSetProperties, public
//
// Synopsis:    Set property values for a property set
//
// Arguments:   [np]            -- property set context
//              [cprop]         -- property count
//              [pidNameFirst]  -- first PROPID for new named properties
//              [aprs]          -- array of property specifiers
//              [apid]          -- buffer for array of propids
//              [avar]          -- array of PROPVARIANTs
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlSetProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID pidNameFirst,     // first PROPID for new named properties
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL IN PROPVARIANT const avar[]) // array of properties+values
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    NTSTATUS Status = STATUS_SUCCESS;

    PROPERTY_INFORMATION apinfoStack[6];
    PROPERTY_INFORMATION *apinfo = apinfoStack;

    DebugTrace(0, Dbg, (
        "RtlSetProperties(np=%x,cprop=%x,pidNameFirst=%x,aprs=%x,apid=%x)\n",
        np,
        cprop,
        pidNameFirst,
        aprs,
        apid));

    if( !NT_SUCCESS(Status) ) goto Exit;


    // Is the stack-based apinfo big enough?
    if (cprop > sizeof(apinfoStack)/sizeof(apinfoStack[0]))
    {
        // No - we need to allocate an apinfo.
        apinfo = new PROPERTY_INFORMATION[cprop];
        if (NULL == apinfo)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
    }

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;
    
    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;
    
    ConvertVariantToPropInfo(
        ppsstm,
        cprop,
        pidNameFirst,
        aprs,
        apid,
        avar,
        apinfo,
        &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;
        
    ppsstm->SetValue(cprop, avar, apinfo, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;
    
    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----
    
Exit:
    // If we allocated a temporary apinfo buffer, free it.
    if (cprop > sizeof(apinfoStack)/sizeof(apinfoStack[0]))
    {
        delete [] apinfo;
    }

    DebugTrace(0, DbgS(Status), (
        "RtlSetProperties() ==> status=%x\n--------\n",
        Status));
    
    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    RtlQueryProperties, public
//
// Synopsis:    Query property values from a property set
//
// Arguments:   [np]             -- property set context
//              [cprop]          -- property count
//              [aprs]           -- array of property specifiers
//              [apid]           -- buffer for array of propids
//              [avar]           -- array of PROPVARIANTs
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    IN OUT PROPVARIANT *avar,   // IN: array of uninitialized PROPVARIANTs,
                                // OUT: may contain pointers to alloc'd memory
    OUT ULONG *pcpropFound)     // count of property values retrieved
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    SERIALIZEDPROPERTYVALUE const *pprop = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG iprop;

    DebugTrace(0, Dbg, (
        "RtlQueryProperties(np=%x, cprop=%x, aprs=%x, apid=%x)\n",
        np,
        cprop,
        aprs,
        apid));

    // Initialize the variant array enough to allow it to be cleaned up
    // by the caller (even on partial failure).

    *pcpropFound = 0;

    // Zero-ing out the caller-provided PropVariants, essentially
    // sets them all to VT_EMPTY.  It also zeros out the data portion,
    // which prevents cleanup problems in error paths.

    RtlZeroMemory(avar, cprop * sizeof(avar[0]));

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    for (iprop = 0; iprop < cprop; iprop++)
    {
        OLECHAR *poc;
        PROPID pid;
        ULONG cbprop;
    
        switch(aprs[iprop].ulKind)
        {
        case PRSPEC_LPWSTR:
            poc = aprs[iprop].lpwstr;
            pid = ppsstm->QueryPropid(poc, &Status);
            if( !NT_SUCCESS(Status) ) goto Exit;
            break;

        case PRSPEC_PROPID:
            pid = aprs[iprop].propid;
            break;

        default:
            PROPASSERT(!"Bad ulKind");
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        pprop = ppsstm->GetValue(pid, &cbprop, &Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        if (pprop != NULL)
        {
            (*pcpropFound)++;
            RtlConvertPropertyToVariant( pprop,
                                         ppsstm->GetCodePage(),
                                         &avar[iprop],
                                         ppsstm->GetAllocator(),
                                         &Status);
            if( !NT_SUCCESS(Status) ) goto Exit;
        }
        if (apid != NULL)
        {
            apid[iprop] = pid;
        }
    }   // for (iprop = 0; iprop < cprop; iprop++)

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if( !NT_SUCCESS(Status) )
    {
        CleanupVariants(avar, cprop, ppsstm->GetAllocator());
    }

    DebugTrace(0, DbgS(Status), (
        "RtlQueryProperties() ==> s=%x\n--------\n",
        Status));

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    RtlEnumerateProperties, public
//
// Synopsis:    Enumerate properties in a property set
//
// Arguments:   [np]             -- property set context
//              [cskip]          -- count of properties to skip
//              [pcprop]         -- pointer to property count
//              [Flags]          -- flags: No Names (propids only), etc.
//              [asps]           -- array of STATPROPSTGs
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumerateProperties(
    IN NTPROP np,               // property set context
    IN ULONG Flags,             // flags: No Names (propids only), etc.
    IN ULONG *pkey,             // count of properties to skip
    IN OUT ULONG *pcprop,       // pointer to property count
    OPTIONAL OUT PROPSPEC aprs[],// IN: array of uninitialized PROPSPECs
                                 // OUT: may contain pointers to alloc'd strings
    OPTIONAL OUT STATPROPSTG asps[]) // IN: array of uninitialized STATPROPSTGs
                                // OUT: may contain pointers to alloc'd strings
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    SERIALIZEDPROPERTYVALUE const *pprop = NULL;
    PROPSPEC *pprs;
    STATPROPSTG *psps;
    PROPID *ppidBase = NULL;
    ULONG i;
    ULONG cpropin;

    PROPID apidStack[20];
    PROPID *ppid;
    ULONG cprop;
    PMemoryAllocator *pma = ppsstm->GetAllocator();

    DebugTrace(0, Dbg, (
        "RtlEnumerateProperties(np=%x, f=%x, key=%x, cprop=%x, aprs=%x, asps=%x)\n",
        np,
        Flags,
        *pkey,
        *pcprop,
        aprs,
        asps));

    cpropin = *pcprop;

    // Eliminate confusion for easy cleanup

    if (aprs != NULL)
    {
        // Set all the PropSpecs to PROPID (which require
        // no cleanup).

        for (i = 0; i < cpropin; i++)
        {
            aprs[i].ulKind = PRSPEC_PROPID;
        }
    }

    // Zero all pointers in the array for easy cleanup

    if (asps != NULL)
    {
        RtlZeroMemory(asps, cpropin * sizeof(asps[0]));
    }

    ppidBase = NULL;

    cprop = ppsstm->ReOpen(&Status);   // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    if (cprop > cpropin)
    {
	cprop = cpropin;
    }

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppid = NULL;
    if (aprs != NULL || asps != NULL)
    {
	ppid = apidStack;
	if (cprop > sizeof(apidStack)/sizeof(apidStack[0]))
	{
	    ppidBase = new PROPID[cprop];
	    if (ppidBase == NULL)
	    {
		Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit;
	    }
	    ppid = ppidBase;
	}
    }

    ppsstm->EnumeratePropids(pkey, &cprop, ppid, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    *pcprop = cprop;

    if (ppid != NULL)
    {
        psps = asps;
	pprs = aprs;
	while (cprop-- > 0)
	{
	    OLECHAR aocName[CCH_MAXPROPNAMESZ];
	    ULONG cbName;
	    ULONG cbprop;
	    BOOLEAN fHasName;
	    
	    PROPASSERT(*ppid != PID_DICTIONARY && *ppid != PID_CODEPAGE);
	    fHasName = FALSE;

	    if ((Flags & ENUMPROP_NONAMES) == 0)
	    {
		cbName = sizeof(aocName);
		fHasName = ppsstm->QueryPropertyNameBuf(
					*ppid,
					aocName,
					&cbName,
                                        &Status);
                if( !NT_SUCCESS(Status) ) goto Exit;
	    }

	    if (pprs != NULL)
	    {
		PROPASSERT(pprs->ulKind == PRSPEC_PROPID);
		if (fHasName)
		{
		    pprs->lpwstr = ppsstm->DuplicatePropertyName(
						aocName,
						cbName,
                                                &Status);
                    if( !NT_SUCCESS(Status) ) goto Exit;
		    PROPASSERT(pprs->lpwstr != NULL);

		    // Make this assignment *after* memory allocation
		    // succeeds so we free only valid pointers in below
		    // cleanup code.
		    pprs->ulKind = PRSPEC_LPWSTR;
		}
		else
		{
		    pprs->propid = *ppid;
		}
		pprs++;

	    }   // if (pprs != NULL)

	    if (psps != NULL)
	    {
		pprop = ppsstm->GetValue(*ppid, &cbprop, &Status);
                if( !NT_SUCCESS(Status) ) goto Exit;

		PROPASSERT(psps->lpwstrName == NULL);
		if (fHasName)
		{
		    psps->lpwstrName = ppsstm->DuplicatePropertyName(
						aocName,
						cbName,
                                                &Status);
                    if( !NT_SUCCESS(Status) ) goto Exit;
                    PROPASSERT(psps->lpwstrName != NULL);
		}
		psps->propid = *ppid;
		psps->vt = (VARTYPE) PropByteSwap(pprop->dwType);
		psps++;

	    }   // if (psps != NULL)
	    
            ppid++;

	}   // while (cprop-- > 0)
    }   // if (ppid != NULL)

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    delete [] ppidBase;

    if (!NT_SUCCESS(Status))
    {
        PMemoryAllocator *pma = ppsstm->GetAllocator();

        if (aprs != NULL)
        {
            for (i = 0; i < cpropin; i++)
            {
                if (aprs[i].ulKind == PRSPEC_LPWSTR)
                {
                    pma->Free(aprs[i].lpwstr);
                    aprs[i].ulKind = PRSPEC_PROPID;
                }
            }
        }

        if (asps != NULL)
        {
            for (i = 0; i < cpropin; i++)
            {
                if (asps[i].lpwstrName != NULL)
                {
                    pma->Free(asps[i].lpwstrName);
                    asps[i].lpwstrName = NULL;
                }
            }
        }
    }   // if (!NT_SUCCESS(Status))

#if DBG
    if (NT_SUCCESS(Status))
    {
	if (aprs != NULL)
	{
	    for (i = 0; i < cpropin; i++)
	    {
		if (aprs[i].ulKind == PRSPEC_LPWSTR)
		{
		    PROPASSERT(aprs[i].lpwstr != NULL);
		    PROPASSERT(ocslen(aprs[i].lpwstr) > 0);
		}
	    }
	}
	if (asps != NULL)
	{
	    for (i = 0; i < cpropin; i++)
	    {
		if (asps[i].lpwstrName != NULL)
		{
		    PROPASSERT(ocslen(asps[i].lpwstrName) > 0);
		}
	    }
	}
    }
#endif // DBG

    DebugTrace(0, DbgS(Status), (
        "RtlEnumerateProperties() ==> key=%x, cprop=%x, s=%x\n--------\n",
        *pkey,
        *pcprop,
        Status));

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    RtlQueryPropertyNames, public
//
// Synopsis:    Read property names for PROPIDs in a property set
//
// Arguments:   [np]             -- property set context
//              [cprop]          -- property count
//              [apid]           -- array of PROPIDs
//              [aposz]          -- array of pointers to OLECHAR strings
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    OUT OLECHAR *aposz[])         // OUT pointers to allocated strings
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusQuery = STATUS_SUCCESS;

    DebugTrace(0, Dbg, (
        "RtlQueryPropertyNames(np=%x, cprop=%x, apid=%x, aposz=%x)\n",
        np,
        cprop,
        apid,
        aposz));

    RtlZeroMemory(aposz, cprop * sizeof(aposz[0]));

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    // we'will save the status from the following call. If there are no
    // other errors, we'll return it to the caller (it might contain a useful
    // success code
    ppsstm->QueryPropertyNames(cprop, apid, aposz, &StatusQuery);
    if( !NT_SUCCESS(StatusQuery) )
    {
        Status = StatusQuery;
        goto Exit;
    }

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    DebugTrace(
        0,
        Status == STATUS_BUFFER_ALL_ZEROS? Dbg : DbgS(Status),
        ("RtlQueryPropertyNames() ==> s=%x\n--------\n", Status));

    if( NT_SUCCESS(Status) )
        Status = StatusQuery;

    return(Status); 


}   // RtlQueryPropertyNames()


//+---------------------------------------------------------------------------
// Function:    RtlSetPropertyNames, public
//
// Synopsis:    Write property names for PROPIDs in a property set
//
// Arguments:   [np]             -- property set context
//              [cprop]          -- property count
//              [apid]           -- array of PROPIDs
//              [aposz]          -- array of pointers to OLECHAR strings
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    IN OLECHAR const * const aposz[]) // pointers to property names
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;

    DebugTrace(0, Dbg, (
        "RtlSetPropertyNames(np=%x, cprop=%x, apid=%x, aposz=%x)\n",
        np,
        cprop,
        apid,
        aposz));

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->SetPropertyNames(cprop, apid, aposz, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    DebugTrace(0, DbgS(Status), ("RtlSetPropertyNames() ==> s=%x\n--------\n", Status));
    return(Status);

}   // RtlSetPropertyNames()


//+---------------------------------------------------------------------------
// Function:    RtlSetPropertySetClassId, public
//
// Synopsis:    Set the property set's ClassId
//
// Arguments:   [np]    -- property set context
//              [pspss] -- pointer to STATPROPSETSTG
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertySetClassId(
    IN NTPROP np,               // property set context
    IN GUID const *pclsid)      // new CLASSID of propset code
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;

    DebugTrace(0, Dbg, ("RtlSetPropertySetClassId(np=%x)\n", np));

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->SetClassId(pclsid, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    DebugTrace(0, DbgS(Status), ("RtlSetPropertySetClassId() ==> s=%x\n--------\n", Status));
    return(Status);

}   // RtlSetPropertySetClassId()


//+---------------------------------------------------------------------------
// Function:    RtlQueryPropertySet, public
//
// Synopsis:    Query the passed property set
//
// Arguments:   [np]    -- property set context
//              [pspss] -- pointer to STATPROPSETSTG
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertySet(
    IN NTPROP np,               // property set context
    OUT STATPROPSETSTG *pspss)  // buffer for property set stat information
{
    NTSTATUS Status = STATUS_SUCCESS;
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    DebugTrace(0, Dbg, ("RtlQueryPropertySet(np=%x, pspss=%x)\n", np, pspss));
    RtlZeroMemory(pspss, sizeof(*pspss));

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->QueryPropertySet(pspss, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    DebugTrace(0, DbgS(Status), ("RtlQueryPropertySet() ==> s=%x\n--------\n", Status));
    return(Status);

}   // RtlQueryPropertySet()

inline BOOLEAN
_Compare_VT_BOOL(VARIANT_BOOL bool1, VARIANT_BOOL bool2)
{
    // Allow any non-zero value to match any non-zero value

    return((bool1 == FALSE) == (bool2 == FALSE));
}


BOOLEAN
_Compare_VT_CF(CLIPDATA *pclipdata1, CLIPDATA *pclipdata2)
{
    BOOLEAN fSame;

    if (pclipdata1 != NULL && pclipdata2 != NULL)
    {
        if (fSame =
            pclipdata1->cbSize == pclipdata2->cbSize &&
            pclipdata1->ulClipFmt == pclipdata2->ulClipFmt)
        {
            if (pclipdata1->pClipData != NULL && pclipdata2->pClipData != NULL)
            {
                fSame = memcmp(
                            pclipdata1->pClipData,
                            pclipdata2->pClipData,
                            CBPCLIPDATA(*pclipdata1)
                              ) == 0;
            }
            else
            {
                // They're the same if both are NULL, or if
                // they have a zero length (if they have a zero
                // length, either one may or may not be NULL, but they're
                // still considered the same).

                fSame = pclipdata1->pClipData == pclipdata2->pClipData
                        ||
                        CBPCLIPDATA(*pclipdata1) == 0;
            }
        }
    }
    else
    {
        fSame = pclipdata1 == pclipdata2;
    }
    return(fSame);
}


//+---------------------------------------------------------------------------
// Function:    RtlCompareVariants, public
//
// Synopsis:    Compare two passed PROPVARIANTs -- case sensitive for strings
//
// Arguments:   [CodePage]      -- CodePage
//              [pvar1]         -- pointer to PROPVARIANT
//              [pvar2]         -- pointer to PROPVARIANT
//
// Returns:     TRUE if identical, else FALSE
//---------------------------------------------------------------------------

STDAPI_(BOOLEAN) PROPSYSAPI PROPAPI
RtlCompareVariants(
    USHORT CodePage,
    PROPVARIANT const *pvar1,
    PROPVARIANT const *pvar2)
{
    if (pvar1->vt != pvar2->vt)
    {
        return(FALSE);
    }

    BOOLEAN fSame;
    ULONG i;

    switch (pvar1->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        fSame = TRUE;
        break;

#ifdef PROPVAR_VT_I1
    case VT_I1:
#endif
    case VT_UI1:
        fSame = pvar1->bVal == pvar2->bVal;
        break;

    case VT_I2:
    case VT_UI2:
        fSame = pvar1->iVal == pvar2->iVal;
        break;

    case VT_BOOL:
        fSame = _Compare_VT_BOOL(pvar1->boolVal, pvar2->boolVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        fSame = pvar1->lVal == pvar2->lVal;
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:        
        fSame = (pvar1->hVal.QuadPart == pvar2->hVal.QuadPart);
        break;

    case VT_CLSID:
        fSame = memcmp(pvar1->puuid, pvar2->puuid, sizeof(CLSID)) == 0;
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        if (fSame = pvar1->blob.cbSize == pvar2->blob.cbSize)
        {
            fSame = memcmp(
                        pvar1->blob.pBlobData,
                        pvar2->blob.pBlobData,
                        pvar1->blob.cbSize) == 0;
        }
        break;

    case VT_CF:
        fSame = _Compare_VT_CF(pvar1->pclipdata, pvar2->pclipdata);
        break;

    case VT_BSTR:
        if (pvar1->bstrVal != NULL && pvar2->bstrVal != NULL)
        {
            if (fSame = BSTRLEN(pvar1->bstrVal) == BSTRLEN(pvar2->bstrVal))
            {
                fSame = memcmp(
                            pvar1->bstrVal,
                            pvar2->bstrVal,
                            BSTRLEN(pvar1->bstrVal)) == 0;
            }
        }
        else
        {
            fSame = pvar1->bstrVal == pvar2->bstrVal;
        }
        break;

    case VT_LPSTR:
        if (pvar1->pszVal != NULL && pvar2->pszVal != NULL)
        {
            fSame = strcmp(pvar1->pszVal, pvar2->pszVal) == 0;
        }
        else
        {
            fSame = pvar1->pszVal == pvar2->pszVal;
        }
        break;

    case VT_LPWSTR:
        if (pvar1->pwszVal != NULL && pvar2->pwszVal != NULL)
        {
            fSame = Prop_wcscmp(pvar1->pwszVal, pvar2->pwszVal) == 0;
        }
        else
        {
            fSame = pvar1->pwszVal == pvar2->pwszVal;
        }
        break;

#ifdef PROPVAR_VT_I1
    case VT_VECTOR | VT_I1:
#endif
    case VT_VECTOR | VT_UI1:
        if (fSame = pvar1->caub.cElems == pvar2->caub.cElems)
        {
            fSame = memcmp(
                        pvar1->caub.pElems,
                        pvar2->caub.pElems,
                        pvar1->caub.cElems * sizeof(pvar1->caub.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
        if (fSame = pvar1->cai.cElems == pvar2->cai.cElems)
        {
            fSame = memcmp(
                        pvar1->cai.pElems,
                        pvar2->cai.pElems,
                        pvar1->cai.cElems * sizeof(pvar1->cai.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_BOOL:
        if (fSame = pvar1->cabool.cElems == pvar2->cabool.cElems)
        {
            for (i = 0; i < pvar1->cabool.cElems; i++)
            {
                fSame = _Compare_VT_BOOL(
                                pvar1->cabool.pElems[i],
                                pvar2->cabool.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        if (fSame = pvar1->cal.cElems == pvar2->cal.cElems)
        {
            fSame = memcmp(
                        pvar1->cal.pElems,
                        pvar2->cal.pElems,
                        pvar1->cal.cElems * sizeof(pvar1->cal.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        if (fSame = pvar1->cah.cElems == pvar2->cah.cElems)
        {
            fSame = memcmp(
                        pvar1->cah.pElems,
                        pvar2->cah.pElems,
                        pvar1->cah.cElems *
                            sizeof(pvar1->cah.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_CLSID:
        if (fSame = (pvar1->cauuid.cElems == pvar2->cauuid.cElems))
        {
            fSame = memcmp(
                        pvar1->cauuid.pElems,
                        pvar2->cauuid.pElems,
                        pvar1->cauuid.cElems *
                            sizeof(pvar1->cauuid.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_CF:
        if (fSame = pvar1->caclipdata.cElems == pvar2->caclipdata.cElems)
        {
            for (i = 0; i < pvar1->caclipdata.cElems; i++)
            {
                fSame = _Compare_VT_CF(
                                &pvar1->caclipdata.pElems[i],
                                &pvar2->caclipdata.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_BSTR:
        if (fSame = (pvar1->cabstr.cElems == pvar2->cabstr.cElems))
        {
            for (i = 0; i < pvar1->cabstr.cElems; i++)
            {
                if (pvar1->cabstr.pElems[i] != NULL &&
                    pvar2->cabstr.pElems[i] != NULL)
                {
                    if (fSame =
                            BSTRLEN(pvar1->cabstr.pElems[i]) ==
                            BSTRLEN(pvar2->cabstr.pElems[i]))
                    {
                        fSame = memcmp(
                                    pvar1->cabstr.pElems[i],
                                    pvar2->cabstr.pElems[i],
                                    BSTRLEN(pvar1->cabstr.pElems[i])) == 0;
                    }
                }
                else
                {
                    fSame = pvar1->cabstr.pElems[i] == pvar2->cabstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_LPSTR:
        if (fSame = (pvar1->calpstr.cElems == pvar2->calpstr.cElems))
        {
            for (i = 0; i < pvar1->calpstr.cElems; i++)
            {
                if (pvar1->calpstr.pElems[i] != NULL &&
                    pvar2->calpstr.pElems[i] != NULL)
                {
                    fSame = strcmp(
                                pvar1->calpstr.pElems[i],
                                pvar2->calpstr.pElems[i]) == 0;
                }
                else
                {
                    fSame = pvar1->calpstr.pElems[i] == 
                            pvar2->calpstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        if (fSame = pvar1->calpwstr.cElems == pvar2->calpwstr.cElems)
        {
            for (i = 0; i < pvar1->calpwstr.cElems; i++)
            {
                if (pvar1->calpwstr.pElems[i] != NULL &&
                    pvar2->calpwstr.pElems[i] != NULL)
                {
                    fSame = Prop_wcscmp(
                                pvar1->calpwstr.pElems[i],
                                pvar2->calpwstr.pElems[i]) == 0;
                }
                else
                {
                    fSame = pvar1->calpwstr.pElems[i] == 
                            pvar2->calpwstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        if (fSame = pvar1->capropvar.cElems == pvar2->capropvar.cElems)
        {
            for (i = 0; i < pvar1->capropvar.cElems; i++)
            {
                fSame = RtlCompareVariants(
                                CodePage,
                                &pvar1->capropvar.pElems[i],
                                &pvar2->capropvar.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT Comparison");
        fSame = FALSE;
        break;

    }
    return(fSame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\olechar.h ===
/* +======================================================

  File:       olechar.h 

  Purpose:    Provide wrappers for string-related
              functions so that the Ansi or Unicode function
              is called, whichever is appropriate for the
              current OLECHAR definition. 

              This file is similar to "tchar.h", except 
              that it covers OLECHARs rather than TCHARs .

  +====================================================== */


#ifndef _OLECHAR_H_ 
#define _OLECHAR_H_ 


#ifndef _UNICODE 
#define OLE2ANSI   1    /* this 2 macros are synonmous for the reference
                           implementation */  
#endif

#define ocslen      _tcslen
#define ocscpy      _tcscpy
#define ocscmp      _tcscmp
#define ocscat      _tcscat
#define ocschr      _tcschr
#define soprintf    _tprintf
#define oprintf     _tprintf
#define ocsnicmp    _tcsnicmp

#endif /* !_OLECHAR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pch.cxx
//
//  Contents:   Precompiled header includes.
//
//--------------------------------------------------------------------------
#include "olechar.h"

#include "h/windef.h"

#include "h/propset.hxx"    // for PROPID_CODEPAGE
#include "h/propapi.h"

#include "../h/propstm.hxx"  // Declaration for CMappedStream i/f that
                        // is used to let the ntdll implementation of
                        // OLE properties access the underlying stream data.


#include "../h/msf.hxx"
#include "../expdf.hxx"
#include "../expst.hxx"

#include "psetstg.hxx"  // CPropertySetStorage which implements
                        // IPropertySetStorage for docfile

#include "utils.hxx"



#include "propstg.hxx"

#include "propdbg.hxx"

#include "h/propmac.hxx"
#include "h/propvar.hxx"

extern WCHAR const wcsContents[];
extern const GUID GUID_NULL;

#define DFMAXPROPSETSIZE (256*1024)

#if DBG
#define DfpVerify(x) { BOOL f=x; GetLastError(); DfpAssert(f);}
#else
#define DfpVerify(x) x
#endif

#ifndef STG_E_PROPSETMISMATCHED
#define STG_E_PROPSETMISMATCHED 0x800300F0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\h\tchar.h ===
/*
 *---------------------------------------------------------------------------
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1996.
 *
 *  File:	tchar.h
 *
 *  Contents:	Mapping between wide characters and normal character types
 *              for functions used in the reference implementation
 *----------------------------------------------------------------------------
 */

#ifndef __TCHAR_DEFINED
#define __TCHAR_DEFINED
#include "ref.hxx"
#include "wchar.h"

#ifdef _UNICODE

typedef WCHAR TCHAR;
#define OLESTR(str) L##str

#else  /* _UNICODE */

typedef char TCHAR;
#define OLESTR(str) str

#endif /* _UNICODE */

typedef TCHAR * LPTSTR;
typedef TCHAR OLECHAR, *LPOLECHAR, *LPOLESTR;

/* Define some macros to handle declaration of strings with literals */
/* Since we stray from the default 4 byte wchar_t in UNIX, we have to
   to something different than the usual L"ssd" literals */

/* #define DECLARE_OLESTR(ocsName, len, contents) \ */
/*         LPOLESTR ocsName[len]=OLESTR(contents) */

/* #else */

#ifdef _UNICODE
#define DECLARE_OLESTR(ocsName, pchContents)                       \
        OLECHAR ocsName[sizeof(pchContents)+1];                    \
        _tbstowcs(ocsName, pchContents, sizeof(pchContents)+1)     

#define INIT_OLESTR(ocsName, pchContents) \
        _tbstowcs(ocsName, pchContents, sizeof(pchContents)+1)     

#define DECLARE_CONST_OLESTR(cocsName, pchContents)                     \
        OLECHAR temp##cocsName[sizeof(pchContents)+1];                  \
        _tbstowcs(temp##cocsName, pchContents, sizeof(pchContents)+1);  \
        const LPOLESTR cocsName = temp##cocsName
        
#else  /* non  _UNICODE */

#define DECLARE_OLESTR(ocsName, pchContents)             \
        OLECHAR ocsName[]=pchContents

#define INIT_OLESTR(ocsName, pchContents) \
        strcpy(ocsName, pchContents);

#define DECLARE_CONST_OLESTR(ocsName, pchContents)       \
        const LPOLESTR ocsName=pchContents 

#endif /* _UNICODE */

#define DECLARE_WIDESTR(wcsName, pchContents)                      \
        WCHAR wcsName[sizeof(pchContents)+1];                      \
        _tbstowcs(wcsName, pchContents, sizeof(pchContents)+1)



#ifndef _UNICODE                /*---- non unicode ------  */

#define _tcscpy   strcpy
#define _tcscmp   strcmp
#define _tcslen   strlen
#define _tcsnicmp _strnicmp
#define _tcscat   strcat
#define _itot     _itoa
#define _T(str)   str

#ifdef _WIN32

/* Io functions */
#define _tfopen    fopen
#define _tunlink   _unlink
#define _tfullpath _fullpath
#define _tstat     _stat

#else /* _WIN32 */

#define _tfopen   fopen
#define _tunlink  unlink        /* T-types mapping */
#define _unlink   unlink        /* non-win32 mapping */
#define _stat stat
#define _tstat stat
#define _strnicmp(s1,s2,n) strncasecmp(s1,s2,n)
 
/* note that we assume there is enough space in this case */
#define _tfullpath(longname, shortname, len)    realpath(shortname, longname) 
#define _fullpath(longname, shortname, len)    realpath(shortname, longname) 

#endif /* _MSC_VER */

/* copying wchar/char and TCHAR */
#ifdef _MSC_VER
#define WTOT(T, W, count) wcstombs(T, W, count) 
#define TTOW(T, W, count) mbstowcs(W, T, count)
#else /* _MSC_VER */
#define WTOT(T, W, count) wcstosbs(T, W, count)
#define TTOW(T, W, count) sbstowcs(W, T, count)
#endif /* _MSC_VER */

#define STOT(S, T, count) strcpy(T, S)
#define TTOS(T, S, count) strcpy(S, T)

#else                          /* _UNICODE   ---- unicode  ------ */

/* NOTE: unicode APIs on non win32 systems are not tested or implemented */

#define _tcscpy   wcscpy
#define _tcscmp   wcscmp
#define _tcslen   wcslen
#define _tcscat   wcscat
#define _tcsnicmp wcsnicmp
#define _itot     _itow
#define _T(str)   L##str

/* Io functions */
#define _tfopen    _wfopen
#define _tunlink   _wunlink
#define _tfullpath _wfullpath
#define _tstat     _wstat

#ifdef _UNIX                    /* map win32 I/O API's to other O.S. */
#define _unlink unlink
#define _fullpath(longname, shortname, len)    realpath(shortname, longname) 
#define _stat stat
#define _strnicmp(s1,s2,n) strncasecmp(s1,s2,n)
#endif

/* converting between wchar and TCHAR */
#define WTOT(T, W, count) wcsncpy(T, W, count) 
#define TTOW(T, W, count) wcsncpy(W, T, count)

/* converting between a char and TCHAR */
#define WTOT(T, W, count) wcsncpy(T, W, count) 
#define TTOW(T, W, count) wcsncpy(W, T, count)

#define STOT(S, T, count) _tbstowcs(T, S, count)
#define TTOS(T, S, count) _wcstotbs(S, T, count)

#endif /* #ifndef _UNICODE, #else ... */



#ifndef _WIN32                /* others */
#define _tbstowcs sbstowcs
#define _wcstotbs wcstosbs 
#else /* _WIN32 */
#define _tbstowcs mbstowcs
#define _wcstotbs wcstombs 
#endif /* _WIN32 */

#ifndef _MSC_VER
#include <assert.h>   
inline void  _itoa(int v, char* string, int radix)
{
	if (radix!=10) assert(FALSE);  /* only handle base 10 */
	sprintf(string, "%d", v);
}
#endif /* _MSC_VER */

#endif  /* #ifndef __TCHAR_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\h\wchar.h ===
/*+---------------------------------------------------------------------------
**
** File:        WChar.h
**
** Contents:    Defines wide character equivalents for standard functions
**              usually in strings.h and ctypes.h
**
** Note:        These routines uses WCHAR which is unsigned short (2 bytes)
**              They are not compatible with some systems that uses 4 bytes
**              wide characters
**--------------------------------------------------------------------------*/

#ifndef __WCHAR__H__
#define __WCHAR__H__

#define _WSTRING_DEFINED // prevent incompatibility with <string.h>
#include <stdlib.h>

#if !defined(FLAT) || defined(OLE32)
#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef unsigned short WCHAR, *LPWSTR;
typedef const WCHAR* LPCWSTR;

/* use an alias */
#define _wcsnicmp wcsnicmp

/* Unicode Byte Order Mark (BOM) for Unicode text files */
#define BOM 0xFEFF

/* Padding constant and macro for localized buffer allocation*/
#define INTL_PADDING_VALUE 3
#define INTL_PADDING(cb) (INTL_PADDING_VALUE * (cb))

long     __cdecl wcsatol(const WCHAR *wsz);
int	 __cdecl wcsatoi(const WCHAR *wsz);
WCHAR *  __cdecl wcscat(WCHAR *wsz1, const WCHAR *wsz2);
WCHAR *  __cdecl wcschr ( const WCHAR * string, WCHAR ch );
int      __cdecl wcscmp(const WCHAR *wsz1, const WCHAR *wsz2);
int      __cdecl wcsicmp(const WCHAR *wsz1, const WCHAR *wsz2);
int      __cdecl wcscoll(const WCHAR * wsz1, const WCHAR * wsz2);
WCHAR *  __cdecl wcscpy(WCHAR *wsz1, WCHAR const *wsz2);
WCHAR *  __cdecl wcsitoa(int ival, WCHAR *wsz, int radix);
size_t   __cdecl wcslen(WCHAR const *wsz);
WCHAR *  __cdecl wcsltoa(long lval, WCHAR *wsz, int radix);
WCHAR *  __cdecl wcslwr(WCHAR *wsz);
int      __cdecl wcsncmp(const WCHAR *wsz1, const WCHAR *wsz2, size_t count);
int      __cdecl wcsnicmp(const WCHAR *wsz1, const WCHAR *wsz2, size_t count);
WCHAR *  __cdecl wcsncpy ( WCHAR * dest, const WCHAR * source, size_t count );
WCHAR *  __cdecl wcsrchr(const WCHAR * wcs, WCHAR wc);
WCHAR *  __cdecl wcsupr(WCHAR *wsz);
WCHAR *  __cdecl wcswcs(const WCHAR *wsz1, const WCHAR *wsz2);
size_t   __cdecl wcstosbs( char * s, const WCHAR * pwcs, size_t n);
size_t   __cdecl sbstowcs(WCHAR *wcstr, const char *mbstr, size_t count);

#ifndef STDCALL
#ifdef _WIN32
#define STDCALL __stdcall
#else
#define STDCALL
#endif
#endif

extern int STDCALL MultiByteToWideChar(
    unsigned int CodePage,              /* code page */
    unsigned long dwFlags,              /* character-type options  */
    const char * lpMultiByteStr,	/* address of string to map  */
    int cchMultiByte,           /* number of characters in string  */
    WCHAR* lpWideCharStr,	/* address of wide-character buffer  */
    int cchWideChar             /* size of buffer  */
   );	

extern int STDCALL WideCharToMultiByte(
    unsigned int CodePage,              /* code page */
    unsigned long dwFlags,              /* performance and mapping flags */
    const WCHAR* lpWideCharStr,	/* address of wide-character string */
    int cchWideChar,            /* number of characters in string */
    char* lpMultiByteStr,	/* address of buffer for new string */
    int cchMultiByte,           /* size of buffer  */
    const char* lpDefaultChar,	/* addr of default for unmappable chars */
    int* lpUsedDefaultChar 	/* addr of flag set when default char. used */
   );

#ifdef __cplusplus
}
#endif

#endif /* !defined(FLAT) || defined(OLE32) */

#endif  /* __WCHAR__H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\qsort.h ===
/* qsort routine */
/* we have this routine because apparently some version of the 
   standard libraries don't work, possibly because REF passes
   in unaligned pointers */
#ifdef __cplusplus
extern "C" { 
#endif  
void ref_qsort (
   void *base,
   unsigned num,
   unsigned width,
   int (*comp)(const void *, const void *)
);
#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\propstg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       propstg.cxx
//
//  Contents:   Class that directly implements IPropertyStorage
//
//  Classes:    CCoTaskAllocator
//              CPropertyStorage
//
//  Notes:      For methods that state 'if successful returns S_OK,
//              otherwise error code', the possible error codes include:
//
//                  STG_E_INVALIDHANDLE
//                  STG_E_INSUFFICIENTMEMORY
//                  STG_E_MEDIUMFULL
//                  STG_E_REVERTED
//                  STG_E_INVALIDPARAMETER                  
//                  STG_E_INVALIDFLAG
//
//--------------------------------------------------------------------------

#include "pch.cxx"

DECLARE_INFOLEVEL(prop, DEB_ERROR)
 
//+-------------------------------------------------------------------
//
//  Member:     CCoTaskAllocator::Allocate, Free.
//
//  Synopsis:   Allocation routines called by RtlQueryProperties.
//
//  Notes:
//
//--------------------------------------------------------------------

CCoTaskAllocator g_CoTaskAllocator;

void *
CCoTaskAllocator::Allocate(ULONG cbSize)
{
    return(CoTaskMemAlloc(cbSize));
}

void
CCoTaskAllocator::Free(void *pv)
{
    CoTaskMemFree(pv);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::CPropertyStorage
//
//  Synopsis:   Constructor used to create a property storage on disk.
//
//  Arguments:  [pstg] -- storage object to be parent
//              [rfmtid] -- format id for new property set.
//              [pclsid] -- pointer to class id
//              [grfFlags] -- flags
//              [grfMode] -- mode
//              [phr] -- HRESULT assumed to be STG_E_INSUFFICIENTMEMORY
//                       on entry. Will be HRESULT reflecting result on exit.
//              
//  Notes:      Get a CPropertySetStream initialized with the correct
//              type of map (i.e. docfile or native.)
//              If non-simple mode, create a storage with name derived
//              from rfmtid and then a contents sub-stream.
//              If simple mode, create a stream of a name derived from
//              rfmtid.
//
//              Does not clean up on failure: this is done by the
//              destructor.
//
//--------------------------------------------------------------------

CPropertyStorage::CPropertyStorage(
                IPrivateStorage *pprivstg,
                REFFMTID      rfmtid,
                const CLSID   *pclsid,
                DWORD         grfFlags,
                DWORD         grfMode,
                HRESULT       *phr)
{
    HRESULT & hr = *phr;
    CPropSetName psn(rfmtid);  // acts as Probe(&rfmtid, sizeof(rfmtid));
    BOOL fCreated = FALSE;
    IStorage *pstg = pprivstg->GetStorage();

    Initialize();

    if (grfFlags & PROPSETFLAG_NONSIMPLE)
    {
        hr = STG_E_UNIMPLEMENTEDFUNCTION;
        PROPASSERT(FALSE && "Unsupported function in reference called!\n" );
        return;                        
    }

    if (grfFlags & ~PROPSETFLAG_ANSI)
    {
        hr = STG_E_INVALIDFLAG;
        return;
    }

    // check for any mode flags disallowed in Create.
    if (grfMode & (STGM_PRIORITY | STGM_CONVERT |
                   STGM_SIMPLE | STGM_DELETEONRELEASE))
    {
        hr = STG_E_INVALIDFLAG;
        return;
    }

    _grfFlags = grfFlags;
    _grfAccess = 3 & grfMode;
    _grfShare = 0xF0 & grfMode;

    // Is this the special-case second-section property set?
    _fUserDefinedProperties = ( rfmtid == FMTID_UserDefinedProperties ) ? TRUE : FALSE;

    if (_grfAccess != STGM_READWRITE)
    {
        hr = STG_E_INVALIDFLAG;
        return;
    }

    if (_grfFlags & PROPSETFLAG_ANSI)
    {
        _usCodePage = GetACP();
    }

    int i=0;
    while (i<=1)
    {
        // Create the property set stream in pstg.
        // The second section of the DocumentSummaryInformation Property Set
        // is a special-case.
        
        if( IsEqualGUID( rfmtid, FMTID_UserDefinedProperties ))
        {
            hr = _CreateDocumentSummary2Stream( pstg, psn, grfMode, &fCreated );
        }
        else
        {
            hr = pstg->CreateStream(psn.GetPropSetName(), grfMode, 0, 0, &_pstmPropSet);
            if( hr == S_OK )
                fCreated = TRUE;
        }
        
        if (hr == S_OK)
        {
            break;
        }
        else
        {
            PropDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::CPropertyStorage"
                     " - CreateStream(%ls) attempt %d, hr=%08X\n", this, psn.GetPropSetName(), i+1, hr));
            
            
            if (hr != STG_E_FILEALREADYEXISTS)
            {
                break;
            }
            else
                if (i == 0 && (grfMode & STGM_CREATE) == STGM_CREATE)
                {
                    pstg->DestroyElement(psn.GetPropSetName());
                }
        } // if (hr == S_OK) ... else
        
        i++;
    }

    if (hr == S_OK)
    {
        hr = InitializePropertyStream(CREATEPROP_CREATE,
                                      &rfmtid,
                                      pclsid);
    }

    if (hr != S_OK && fCreated)
    {
        //
        // if we fail after creating the property set in storage, cleanup.
        // 
        pstg->DestroyElement(psn.GetPropSetName());
    }

}



//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::_CreateDocumentSummary2Stream
//
//  Synopsis:   Open the "DocumentSummaryInformation" stream, creating
//              it if necessary.
//
//  Arguments:  [pstg] -- container storage
//              [psn] -- the property set name
//              [grfMode] -- mode of the property set
//              [fCreated] -- TRUE if Stream is created, FALSE if opened.
//
//  Notes:      This special case is necessary because this property set
//              is the only one in which we support more than one section.
//              For this property set, if the caller Creates the second
//              Section, we must not *Create* the Stream, because that would
//              lost the first Section.  So, we must open it.
//
//              This routine is only called when creating the second
//              Section.  The first Section is created normally (note
//              that if the client creates the first section, the second
//              section is lost).
//
//              Also note that it may not be possible to open the Stream,
//              since it may already be opened.  This is significant
//              because it may not be obvious to the caller.  I.e.,
//              to a client of IPropertyStorage, the 2 sections are
//              distinct property sets, and you would think that you could
//              open them for simultaneous write.
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::_CreateDocumentSummary2Stream( IStorage *      pstg,
                                                 CPropSetName &  psn,
                                                 DWORD           grfMode,
                                                 BOOL *          pfCreated )
{

    HRESULT hr;
    DWORD   grfOpenMode = grfMode & ~(STGM_CREATE | STGM_CONVERT);

    *pfCreated = FALSE;

    hr = pstg->OpenStream( psn.GetPropSetName(), NULL, grfOpenMode, 0L, &_pstmPropSet );

    // If the file wasn't there, try a create.

    if( hr == STG_E_FILENOTFOUND )
    {
        hr = pstg->CreateStream(psn.GetPropSetName(), grfMode, 0, 0, &_pstmPropSet);

        if( SUCCEEDED( hr ))
        {
            *pfCreated = TRUE;
        }
    }

    return( hr );

} // CPropertyStorage::_CreateDocumentSummary2Stream()




//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::CPropertyStorage
//
//  Synopsis:   Constructor used to open a property storage on disk.
//
//  Arguments:  [pstg] -- container storage
//              [rfmtid] -- FMTID of property set to open
//              [grfMode] -- mode of the property set
//              [fDelete] -- Delete this property set from its stream
//              [phr] -- HRESULT returned here.
//
//  Notes:      Does not clean up on failure: this is done by the
//              destructor.
//
//--------------------------------------------------------------------

CPropertyStorage::CPropertyStorage(
                IPrivateStorage *pprivstg,
                REFFMTID  rfmtid,
                DWORD     grfMode,
                BOOL      fDelete,
                HRESULT  *phr)
{
    HRESULT &hr = *phr;
    CPropSetName psn(rfmtid);
    IStorage *pstgParent;
    IStorage *pstg = pprivstg->GetStorage();
    USHORT createprop = 0L;

    Initialize();

    _grfAccess = 3 & grfMode;
    _grfShare = 0xF0 & grfMode;

    // Is this the special-case second-section property set?
    _fUserDefinedProperties = ( rfmtid == FMTID_UserDefinedProperties ) ? TRUE : FALSE;

    // check for any mode flags disallowed in Open.
    if (grfMode & (STGM_CREATE | STGM_PRIORITY | STGM_CONVERT | STGM_TRANSACTED | 
                   STGM_SIMPLE | STGM_DELETEONRELEASE))
    {
        hr = STG_E_INVALIDFLAG;
        return;
    }

    hr = pstg->OpenStream(psn.GetPropSetName(), NULL, _grfAccess | _grfShare,
            0, &_pstmPropSet);

    if (hr == S_OK)
    {
        pstgParent = pstg;
    }


    // Determine the CREATEPROP flags.
    if( fDelete )
    {
        createprop = CREATEPROP_DELETE;
    }
    else
    {
        createprop = (S_OK == IsWriteable() ? 
                      CREATEPROP_WRITE : CREATEPROP_READ);
    }

    if (hr == S_OK)
    {
        // sets up _usCodePage
        hr = InitializePropertyStream(
                createprop,
                &rfmtid,
                NULL);

    }

}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Initialize
//
//  Synopsis:   Initialize members to known values.
//
//--------------------------------------------------------------------

VOID CPropertyStorage::Initialize(VOID)
{
    _ulSig = PROPERTYSTORAGE_SIG;
    _cRefs = 1;
    _pstgPropSet = NULL;
    _pstmPropSet = NULL;
    _dwOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;
    _np = NULL;
    _ms = NULL;
    _usCodePage = CP_WINUNICODE;
    _grfFlags = 0;
    _grfAccess = 0;
    _grfShare = 0;
    _fUserDefinedProperties = FALSE;

}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::InitializePropertyStream.
//
//  Synopsis:   Initialize the storage-type specific members.
//
//  Arguments:  [Flags] -- Flags for RtlCreatePropertySet: CREATEPROP_*
//              [pguid] -- FMTID, in for create only.
//              [pclsid] -- Class id, in for create only.
//                              
//  Returns:    HRESULT
//
//  Requires:
//              _pstmPropSet -- The IStream of the main property set stream.
//
//  Modifies:   _ms         (NTMAPPEDSTREAM) 
//
//                          (assumed NULL on entry) will be NULL or valid on exit
//
//                          if _fNative, then _ms is CNtMappedStream*
//                          if !_fNative, then _ms is CMappedStream* of CExposedStream
//
//              _np         (NTPROP)         aka CPropertySetStream
//
//                          (assumed NULL on entry) will be NULL or valid on exit
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::InitializePropertyStream(
    USHORT Flags,
    const GUID *pguid,
    GUID const *pclsid)
{
    HRESULT hr;

    CExposedStream *pexpstm = (CExposedStream*)_pstmPropSet;
    PROPASSERT(pexpstm->Validate() != STG_E_INVALIDHANDLE );
    _ms =  (CMappedStream*)pexpstm;
    hr = S_OK;
    PropDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::InitializePropertyStream"
             " - using CExposedDocfile as CMappedStream\n", this));

    NTSTATUS Status;
    
    Status = RtlCreatePropertySet(
        _ms,
        Flags,
        pguid,
        pclsid,
        (NTMEMORYALLOCATOR) & g_CoTaskAllocator,
        GetUserDefaultLCID(),
        &_dwOSVersion,
        &_usCodePage,
        &_np);
    
    if (!NT_SUCCESS(Status))
    {
        PropDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::InitializePropertyStream"
                 " - RtlCreatePropertySet Status=%08X\n", this, Status));
    }
    
    if (NT_SUCCESS(Status))
    {
            if (_usCodePage != CP_WINUNICODE)
                _grfFlags |= PROPSETFLAG_ANSI; // for Stat
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }
    

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::~CPropertyStorage
//
//  Synopsis:   Free up object resources.
//
//  Notes:      Cleans up even from partial construction.
//
//--------------------------------------------------------------------

CPropertyStorage::~CPropertyStorage()
{
    _ulSig = PROPERTYSTORAGE_SIGDEL; // prevent someone else deleting it

    if (_np != NULL)
    {
//        RtlFlushPropertySet(_np);
        RtlClosePropertySet(_np);
    }

    if (_pstmPropSet != NULL)
        _pstmPropSet->Release();

    if (_pstgPropSet != NULL)
        _pstgPropSet->Release();

}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::QueryInterface, AddRef, Release
//
//  Synopsis:   IUnknown members
//
//  Notes:      IPropertyStorage supports IPropertyStorage and IUnknown
//
//--------------------------------------------------------------------


HRESULT CPropertyStorage::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = ValidateRef()))
        return(hr);

    // Validate the inputs

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    //  -----------------
    //  Perform the Query
    //  -----------------

    *ppvObject = NULL;

    if (IsEqualIID(riid,IID_IPropertyStorage) || IsEqualIID(riid,IID_IUnknown))
    {
        *ppvObject = (IPropertyStorage *)this;
        CPropertyStorage::AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return(hr);
}

ULONG   CPropertyStorage::AddRef(void)
{
    if (S_OK != ValidateRef())
        return(0);

    InterlockedIncrement(&_cRefs);
    return(_cRefs);
}

ULONG   CPropertyStorage::Release(void)
{
    LONG lRet;

    if (S_OK != ValidateRef())
        return(0);

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;    // this will do a flush if dirty
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::ReadMultiple
//
//  Synopsis:   Read properties from the property set.
//
//  Arguments:  [cpspec] -- Count of PROPSPECs in [rgpspec]
//              [rgpspec] -- Array of PROPSPECs
//              [rgpropvar] -- Array of PROPVARIANTs to be filled in
//                             with callee allocated data.
//              
//  Returns:    S_FALSE if none found
//              S_OK if >=1 found
//              FAILED(hr) otherwise.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::ReadMultiple(
    ULONG                   cpspec,
    const PROPSPEC          rgpspec[],
    PROPVARIANT             rgpropvar[])
{
    NTSTATUS Status;
    HRESULT hr;
    ULONG   cpropFound;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsReadable()))
        goto errRet;

    // Validate inputs

    if (0 == cpspec)
    {
        hr = S_FALSE;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPSPEC( cpspec, rgpspec )))
        goto errRet;

    if (S_OK != (hr = ValidateOutRGPROPVARIANT( cpspec, rgpropvar )))
        goto errRet;

    //  -------------------
    //  Read the Properties
    //  -------------------

    Status = RtlQueryProperties(
                    _np,
                    cpspec,
                    rgpspec,
                    NULL,   // don't want PROPID's
                    rgpropvar,
                    &cpropFound);

    if (NT_SUCCESS(Status))
    {
        if (cpropFound == 0)
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }

    //  ----
    //  Exit
    //  ----

errRet:            
    PropDbg((DEB_PROP_EXIT, 
             "CPropertyStorage(%08X)::ReadMultiple(cpspec=%d, rgpspec=%08X, "
             "rgpropvar=%08X) returns %08X\n",
             this, cpspec, rgpspec, rgpropvar, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::_WriteMultiple, private
//
//  Synopsis:   Write the properties to the property set.  Allows
//              a NULL rgpropvar pointer for deletion case.
//
//  Arguments:  [cpspec] -- count of PROPSPECs and PROPVARIANTs in
//                          [rgpspec] and [rgpropvar]
//
//              [rgpspec] -- pointer to array of PROPSPECs
//
//              [rgpropvar] -- pointer to array of PROPVARIANTs with
//                           the values to write.
//
//              [propidNameFirst] -- id below which not to assign
//                           ids for named properties.
//
//              
//  Returns:    S_OK,   -- all requested data was written.
//              Errors  -- 
//
//  Modifies:
//
//  Derivation:
//
//  Notes:
//              This routine assumes the object has been validated
//              and is writeable.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::_WriteMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[],
                const PROPVARIANT       rgpropvar[],
                PROPID                  propidNameFirst)
{
    HRESULT             hr;
    NTSTATUS            Status;
    CStackPropIdArray   spia;

    if (S_OK != (hr = spia.Init(cpspec)))
        return(hr);

    Status = RtlSetProperties(_np,   // property set context
                cpspec,             // property count
                propidNameFirst,    // first propid for new named props
                rgpspec,            // array of property specifiers
                spia.GetBuf(),      // buffer for array of propids
                rgpropvar);

    if (!NT_SUCCESS(Status))
    {
        hr = DfpNtStatusToHResult(Status);
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::WriteMultiple
//
//  Synopsis:   Write properties.
//
//  Arguments:  [cpspec] -- count of PROPSPECs and PROPVARIANTs in
//                          [rgpspec] and [rgpropvar]
//              [rgpspec] -- pointer to array of PROPSPECs
//              [rgpropvar] -- pointer to array of PROPVARIANTs with
//                           the values to write.
//              [propidNameFirst] -- id below which not to assign
//                           ids for named properties.
//
//  Returns:    S_OK,   -- all requested data was written.
//              Errors  -- accordingly
//
//  Notes:      Checks that rgpropvar is not NULL, then calls
//              _WriteMultiple.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::WriteMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[],
                const PROPVARIANT       rgpropvar[],
                PROPID                  propidNameFirst)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate the inputs

    if (0 == cpspec)
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPSPEC( cpspec, rgpspec )))
        goto errRet;

    if (S_OK != (hr = ValidateInRGPROPVARIANT( cpspec, rgpropvar )))
        goto errRet;

    //  --------------------
    //  Write the Properties
    //  --------------------

    hr = _WriteMultiple(cpspec, rgpspec, rgpropvar, propidNameFirst);
    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;
        
        for (ULONG i=0; hr == S_OK && i < cpspec; i++)
        {
            hr = _WriteMultiple(1, rgpspec+i, rgpropvar+i, propidNameFirst);
        }
    }

    //  ----
    //  Exit
    //  ----

errRet:

    PropDbg((DEB_PROP_EXIT, 
             "CPropertyStorage(%08X)::WriteMultiple(cpspec=%d, rgpspec=%08X, "
             "rgpropvar=%08X, propidNameFirst=%d) returns %08X\n",
             this, cpspec, rgpspec, rgpropvar, propidNameFirst, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::DeleteMultiple
//
//  Synopsis:   Delete properties.
//
//  Arguments:  [cpspec] -- count of PROPSPECs and PROPVARIANTs in
//                          [rgpspec] and [rgpropvar]
//              [rgpspec] -- pointer to array of PROPSPECs
//
//  Returns:    S_OK,   -- all requested data was deleted.
//              Errors  -- 
//
//  Notes:      Checks that rgpropvar is not NULL, then calls
//              _WriteMultiple.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::DeleteMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[])
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate the inputs

    if (0 == cpspec)
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPSPEC( cpspec, rgpspec )))
        goto errRet;

    //  ---------------------
    //  Delete the Properties
    //  ---------------------

    hr = _WriteMultiple(cpspec, rgpspec, NULL, 2);
    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;
        
        for (ULONG i=0; hr == S_OK && i < cpspec; i++)
        {
            hr = _WriteMultiple(1, rgpspec+i, NULL, 2);
        }
    }

    //  ----
    //  Exit
    //  ----

errRet:

    PropDbg((DEB_PROP_EXIT, 
             "CPropertyStorage(%08X)::DeleteMultiple(cpspec=%d, rgpspec=%08X) "
             "returns %08X\n",
             this, cpspec, rgpspec, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::ReadPropertyNames
//
//  Synopsis:   Attempt to read names for all identified properties.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//              [rglpstrName] -- Pointer to array of [cpropid] LPOLESTRs
//
//  Returns:    S_OK -- success, one or more names returned
//              S_FALSE -- success, no names returned
//              STG_E_INVALIDHEADER -- no propid->name mapping property
//              other errors -- STG_E_INSUFFICIENTMEMORY etc
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::ReadPropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[],
                LPOLESTR                rglpwstrName[])
{
    HRESULT hr;
    NTSTATUS Status;

    //  --------
    //  Validate
    //  --------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsReadable()))
        goto errRet;

    // Validate the inputs

    if (0 == cpropid)
    {
        hr = S_FALSE;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPID( cpropid, rgpropid )))
        goto errRet;

    if (S_OK != (hr = ValidateOutRGLPOLESTR( cpropid, rglpwstrName )))
        goto errRet;

    //  --------------
    //  Read the Names
    //  --------------

    Status = RtlQueryPropertyNames(_np, cpropid, rgpropid, rglpwstrName);
    if (Status == STATUS_NOT_FOUND)
        hr = STG_E_INVALIDHEADER;
    else
    if (Status == STATUS_BUFFER_ALL_ZEROS)
        hr = S_FALSE;
    else
    if (!NT_SUCCESS(Status))
        hr = DfpNtStatusToHResult(Status);

    //  ----
    //  Exit
    //  ----

errRet:

    PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::ReadPropertyNames(cpropid=%d, rgpropid=%08X, "
                            "rglpwstrName=%08X) returns %08X\n",
                            this, cpropid, rgpropid, rglpwstrName, hr));

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::_WritePropertyNames
//
//  Synopsis:   Internal function used by WritePropertyNames and
//              DeletePropertyNames.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//              [rglpstrName] -- Pointer to array of [cpropid] LPOLESTRs
//
//  Returns:    S_OK if successful, otherwise error code.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::_WritePropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[],
                const LPOLESTR          rglpwstrName[])
{
    NTSTATUS Status;

    Status = RtlSetPropertyNames(_np, cpropid, rgpropid, 
                                  (OLECHAR const* const*) rglpwstrName);
    return NT_SUCCESS(Status) ? S_OK : DfpNtStatusToHResult(Status);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::WritePropertyNames
//
//  Synopsis:   Attempt to write names for all identified properties.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//              [rglpstrName] -- Pointer to array of [cpropid] LPOLESTRs
//
//  Returns:    S_OK -- success, otherwise error code.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::WritePropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[],
                const LPOLESTR          rglpwstrName[])
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate inputs

    if (0 == cpropid)
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPID( cpropid, rgpropid )))
        goto errRet;

    if (S_OK != (hr = ValidateInRGLPOLESTR( cpropid, rglpwstrName )))
        goto errRet;

    //  ---------------
    //  Write the Names
    //  ---------------

    hr = _WritePropertyNames(cpropid, rgpropid, rglpwstrName);
    
    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;
        
        for (ULONG i=0; hr == S_OK && i < cpropid; i++)
        {
            hr = _WritePropertyNames(1, rgpropid+i, rglpwstrName+i);
        }
    }

    //  ----
    //  Exit
    //  ----

errRet:

    PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::WritePropertyNames(cpropid=%d, rgpropid=%08X, "
                            "rglpwstrName=%08X) returns %08X\n",
                            this, cpropid, rgpropid, rglpwstrName, hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::DeletePropertyNames
//
//  Synopsis:   Attempt to delete names for all identified properties.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//
//  Returns:    S_OK -- success, otherwise error.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::DeletePropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[])
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate the inputs

    if( 0 == cpropid )
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPID( cpropid, rgpropid )))
        goto errRet;

    //  ----------------
    //  Delete the Names
    //  ----------------

    hr = _WritePropertyNames(cpropid, rgpropid, NULL);
    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;
        
        for (ULONG i=0; hr == S_OK && i < cpropid; i++)
        {
            hr = _WritePropertyNames(1, rgpropid+i, NULL);
        }
    }

    //  ----
    //  Exit
    //  ----

errRet:
    PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::DeletePropertyNames(cpropid=%d, rgpropid=%08X) "
                            "returns %08X\n",
                            this, cpropid, rgpropid, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Commit
//
//  Synopsis:   Flush and/or commit the property set
//
//  Arguments:  [grfCommittFlags] -- Commit flags.
//
//  Returns:    S_OK -- success, otherwise error.
//
//  Notes:      For both simple and non-simple, this flushes the
//              memory image to disk subsystem.  In addition,
//              for non-simple transacted-mode property sets, this
//              performs a commit on the property set.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Commit(DWORD grfCommitFlags)
{
    HRESULT  hr;
    NTSTATUS Status;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate the inputs

    if (S_OK != (hr = VerifyCommitFlags(grfCommitFlags)))
        goto errRet;

    //  --------------------------
    //  Commit the PropertyStorage
    //  --------------------------

    Status = RtlFlushPropertySet(_np); 
    if (!NT_SUCCESS(Status))
    {
        hr = DfpNtStatusToHResult(Status);
    }

    //  ----
    //  Exit
    //  ----

errRet:
    PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::Commit(grfCommitFlags=%08X) "
                            "returns %08X\n",
                            this, grfCommitFlags, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Revert
//
//  Synopsis:   For non-simple property sets, revert it.
//
//  Returns:    S_OK if successful.  STG_E_UNIMPLEMENTEDFUNCTION for
//              simple property sets.
//
//  Notes:      For non-simple property sets, call the underlying
//              storage's Revert and re-open the 'contents' stream.
//              
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Revert()
{
    HRESULT hr;

    hr = Validate();

    PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::Revert() "
                            "returns %08X\n",
                            this, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Enum
//
//  Synopsis:   Create an enumerator over the property set.
//
//  Arguments:  [ppenum] -- where to return the IEnumSTATPROPSTG *
//              
//  Returns:    S_OK or error.
//
//  Notes:      The constructor of CEnumSTATPROPSTG creates a
//              CStatArray which reads the entire property set and
//              which can be shared when IEnumSTATPROPSTG::Clone is
//              used.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Enum(IEnumSTATPROPSTG **    ppenum)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    if (S_OK != (hr = IsReadable()))
        return(hr);

    if (S_OK != (hr = IsReverted()))
        return(hr);

    // Validate the inputs

    VDATEPTROUT( ppenum, IEnumSTATPROPSTG* );

    //  ----------------------
    //  Create the Enumeration
    //  ----------------------

    *ppenum = NULL;

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppenum = new CEnumSTATPROPSTG(_np, &hr);
    if (FAILED(hr))
    {
        delete (CEnumSTATPROPSTG*) *ppenum;
        *ppenum = NULL;
    }

    //  ----
    //  Exit
    //  ----

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::SetTimes
//
//  Synopsis:   Set the given times on the underlying storage
//
//  Arguments:  [pctime] -- creation time
//              [patime[ -- access time
//              [pmtime] -- modify time
//
//  Returns:    S_OK or error.
//
//  Notes:
//              (non-simple only)  Only the times supported by the
//              underlying docfile implementation are
//              supported.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::SetTimes(
                FILETIME const *        pctime,
                FILETIME const *        patime,
                FILETIME const *        pmtime)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate the inputs

    VDATEPTRIN_LABEL( pctime, FILETIME, errRet, hr );
    VDATEPTRIN_LABEL( patime, FILETIME, errRet, hr );
    VDATEPTRIN_LABEL( pmtime, FILETIME, errRet, hr );

    // since we only support non-simple, this function does not
    // do anything

    //  ----
    //  Exit
    //  ----

errRet:
    PropDbg((DEB_PROP_EXIT, 
             "CPropertyStorage(%08X)::SetTimes("
             "pctime=%08X, patime=%08X, pmtime=%08X) returns %08X\n",
             this, pctime, patime, pmtime, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::SetClass
//
//  Synopsis:   Sets the class of the property set.
//
//  Arguments:  [clsid] -- class id to set.
//              
//  Returns:    S_OK or error.
//
//  Notes:      Have clsid set into the property set stream.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::SetClass(REFCLSID clsid)
{
    HRESULT hr;
    NTSTATUS Status;
    DBGBUF(buf);

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate the inputs

    GEN_VDATEREADPTRIN_LABEL(&clsid, CLSID, E_INVALIDARG, errRet, hr);

    //  -------------
    //  Set the CLSID
    //  -------------

    // Set it in the property set header

    Status = RtlSetPropertySetClassId(_np, &clsid);
    if (!NT_SUCCESS(Status))
        hr = DfpNtStatusToHResult(Status);

    //  ----
    //  Exit
    //  ----

errRet:

    if( E_INVALIDARG != hr )
    {
        PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::SetClass(clsid=%s) "
                                "returns %08X\n",
                                this, DbgFmtId(clsid, buf), hr));
    }
    else
    {
        PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::SetClass(clsid@%08X) "
                                "returns %08X\n",
                                this, &clsid, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Stat
//
//  Synopsis:   Get STATPROPSETSTG about the property set.
//
//  Arguments:  [p] -- STATPROPSETSTG *
//              
//  Returns:    S_OK if successful, error otherwise.  On failure,
//              *p is all zeros.
//
//  Notes:      See spec.  Gets times from underlying storage or stream
//              using IStorage or IStream ::Stat.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Stat(STATPROPSETSTG * p)
{
    HRESULT hr;
    NTSTATUS Status;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsReadable()))
        goto errRet;

    // Validate inputs

    VDATEPTROUT_LABEL(p, STATPROPSETSTG, errRet, hr);

    //  ------------
    //  Get the Stat
    //  ------------

    ZeroMemory(p, sizeof(*p));

    // returns mtime, ansi flag, clsid, fmtid
    Status = RtlQueryPropertySet(_np, p);
    if (NT_SUCCESS(Status))
    {
        STATSTG statstg;

        hr = S_OK;
        hr = _pstmPropSet->Stat(&statstg, STATFLAG_NONAME);

        if (hr == S_OK)
        {
            p->mtime = statstg.mtime;
            p->ctime = statstg.ctime;
            p->atime = statstg.atime;
            p->grfFlags = _grfFlags;
            p->dwOSVersion = _dwOSVersion;
        }
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }

    if (FAILED(hr))
    {
        ZeroMemory(p, sizeof(*p));
    }

    //  ----
    //  Exit
    //  ----

errRet:
    PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::Stat(STATPROPSETSTG *p = %08X) "
                            "returns %08X\n",
                            this, p, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CStatArray::CStatArray
//
//  Synopsis:   Read in the enumeration using RtlEnumerateProperties
//
//  Arguments:  [np] -- the NTPROP to use
//              [phr] -- S_OK on success, error otherwise.
//              
//  Notes:      Retry getting number of properties and reading all of
//              them into a caller-allocated buffer until it fits.
//
//--------------------------------------------------------------------

CStatArray::CStatArray(NTPROP np, HRESULT *phr)
{
    NTSTATUS Status;
    ULONG ulKeyZero;
    ULONG cpropAllocated;

    _cRefs = 1;
    _psps = NULL;

    do
    {
        //  when *pkey == 0, *pcprop == MAXULONG, aprs == NULL and asps == NULL on input,
        // *pcprop will be the total count of properties in the enumeration set.  OLE needs to 
        // allocate memory and enumerate out of the cached PROPID+propname list.

        ulKeyZero = 0;
        _cpropActual = MAX_ULONG;

        delete [] _psps;
        _psps = NULL;

        Status = RtlEnumerateProperties(
                np,
                ENUMPROP_NONAMES,
                &ulKeyZero,
                &_cpropActual,
                NULL,   // aprs
                NULL);

        if (!NT_SUCCESS(Status))
            break;
        
        cpropAllocated = _cpropActual + 1;

        _psps = new STATPROPSTG [ cpropAllocated ];
        if (_psps == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ulKeyZero = 0;
        Status = RtlEnumerateProperties(
                np,
                0,
                &ulKeyZero,
                &cpropAllocated,
                NULL,   // aprs
                _psps);
    } while (NT_SUCCESS(Status) && cpropAllocated != _cpropActual);

    *phr = NT_SUCCESS(Status) ? S_OK : DfpNtStatusToHResult(Status);
}

//+-------------------------------------------------------------------
//
//  Member:     CStatArray::~CStatArray
//
//  Synopsis:   Deallocated the object's data.
//
//--------------------------------------------------------------------

CStatArray::~CStatArray()
{
    if (_psps != NULL)
    {
        CleanupSTATPROPSTG(_cpropActual, _psps);
    }
    delete [] _psps;
}

//+-------------------------------------------------------------------
//
//  Member:     CStatArray::NextAt
//
//  Synopsis:   Read from the internal STATPROPSTG array.
//
//  Effects:    The cursor is passed in, and this function acts
//              as a IEnumXX::Next would behave if the current cursor
//              was [ipropNext].
//
//  Arguments:  [ipropNext] -- index of cursor to use
//              [pspsDest] -- if NULL, emulate read's effect on cursor.
//                            if non-NULL, return data with cursor effect.
//              [pceltFetched] -- buffer for count fetched
//              
//  Returns:    STATUS_SUCCESS if successful, otherwise
//              STATUS_INSUFFICIENT_RESOURCES.
//
//  Notes:      
//
//--------------------------------------------------------------------

NTSTATUS
CStatArray::NextAt(ULONG ipropNext, STATPROPSTG *pspsDest, ULONG *pceltFetched)
{
    ULONG   ipropLastPlus1;

    //
    // Copy the requested number of elements from the cache
    // (including strings, the allocation of which may fail.)
    //

    ipropLastPlus1 = ipropNext + *pceltFetched;
    if (ipropLastPlus1 > _cpropActual)
    {
        ipropLastPlus1 = _cpropActual;
    }

    *pceltFetched = ipropLastPlus1 - ipropNext;

    if (pspsDest != NULL)
        return CopySTATPROPSTG(*pceltFetched, pspsDest, _psps + ipropNext);
    else
        return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::CEnumSTATPROPSTG
//
//  Synopsis:   Constructor for object that has cursor over CStatArray
//              and implements IEnumSTATPROPSTG, used by
//              CPropertyStorage::Enum.
//
//  Arguments:  [np] -- the NTPROP to use
//              [phr] -- where to put the HRESULT
//
//--------------------------------------------------------------------

CEnumSTATPROPSTG::CEnumSTATPROPSTG(NTPROP np, HRESULT *phr)
{
    _ulSig = ENUMSTATPROPSTG_SIG;
    _cRefs = 1;

    _psa = new CStatArray(np, phr);

    _ipropNext = 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::CEnumSTATPROPSTG
//
//  Synopsis:   Constructor which is used by IEnumSTATPROPSTG::Clone.
//
//  Arguments:  [other] -- the CEnumSTATPROPSTG to copy
//              [phr] -- the error code.
//              
//  Notes:      Since the CStatArray actually contains the object this
//              just adds to the ref count.
//
//--------------------------------------------------------------------

CEnumSTATPROPSTG::CEnumSTATPROPSTG(const CEnumSTATPROPSTG & other, HRESULT *phr)
{

    _ulSig = ENUMSTATPROPSTG_SIG;
    _cRefs = 1;

    _psa = other._psa;
    _psa->AddRef();

    _ipropNext = other._ipropNext;

    *phr = S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::~CEnumSTATPROPSTG
//
//  Synopsis:   Deallocated storage.
//
//  Arguments:
//              
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------

CEnumSTATPROPSTG::~CEnumSTATPROPSTG()
{
    _ulSig = ENUMSTATPROPSTG_SIGDEL;    // prevent another thread doing it - kinda

    if (_psa != NULL)
        _psa->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::QueryInterface
//
//  Synopsis:   Respond to IEnumSTATPROPSTG and IUnknown.
//
//  Returns:    S_OK  or E_NOINTERFACE
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    *ppvObject = NULL;

    if (S_OK != (hr = Validate()))
        return(hr);

    if (IsEqualIID(riid, IID_IEnumSTATPROPSTG))
    {
        *ppvObject = (IEnumSTATPROPSTG *)this;
        AddRef();
    }
    else
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = (IUnknown *)this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::AddRef
//
//  Synopsis:   Add 1 to ref count.
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSTG::AddRef(void)
{
    if (S_OK != Validate())
        return(0);

    InterlockedIncrement(&_cRefs);
    return(_cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Release
//
//  Synopsis:   Subtract 1 from ref count and delete if 0.
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSTG::Release(void)
{
    LONG lRet;

    if (S_OK != Validate())
        return(0);

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}

//+-------------------------------------------------------------------
//
//  Function:   CopySTATPROPSTG
//
//  Synopsis:   Copy out the range of elements from [pspsSrc] to
//              [pspsDest].
//
//  Arguments:  [celt] -- count of elements to copy
//              [pspsDest] -- where to copy to, always filled with
//                          zeros before anything else (helps cleanup
//                          case.)
//
//              [pspsSrc] -- where to copy from
//
//  Returns:    STATUS_SUCCESS if ok, otherwise
//              STATUS_INSUFFICIENT_RESOURCES in which case there
//              may be pointers that need deallocating.  Use
//              CleanupSTATPROPSTG to do that.
//
//--------------------------------------------------------------------

NTSTATUS
CopySTATPROPSTG(ULONG celt,
            STATPROPSTG * pspsDest,
            const STATPROPSTG * pspsSrc)
{
    memset(pspsDest, 0, sizeof(*pspsDest) * celt);

    while (celt)
    {
        *pspsDest = *pspsSrc;

        if (pspsSrc->lpwstrName != NULL)
        {
            pspsDest->lpwstrName = (LPOLESTR)CoTaskMemAlloc(
                sizeof(OLECHAR)*(1+ocslen(pspsSrc->lpwstrName)));
            if (pspsDest->lpwstrName != NULL)
            {
                ocscpy(pspsDest->lpwstrName,
                       pspsSrc->lpwstrName);
            }
            else
            {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        celt--;
        pspsDest++;
        pspsSrc++;
    }

    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------
//
//  Member:     CleanupSTATPROPSTG
//
//  Synopsis:   Free any elements in the passed array.
//
//  Arguments:  [celt] -- number of elements to examine.
//              [psps] -- array of STATPROPSTG to examine.
//              
//  Notes:      Zeros them out too.
//
//--------------------------------------------------------------------

VOID
CleanupSTATPROPSTG(ULONG celt, STATPROPSTG * psps)
{
    while (celt)
    {
        CoTaskMemFree(psps->lpwstrName);
        memset(psps, 0, sizeof(*psps));
        celt--;
        psps++;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Next
//
//  Synopsis:   Get the next [celt] STATPROPSTGs from the enumerator.
//
//  Arguments:  [celt] -- count requested.
//              [rgelt] -- where to return them
//              [pceltFetched] -- buffer for returned-count.
//                  if pceltFetched==NULL && celt != 1 -> STG_E_INVALIDPARAMETER
//                  if pceltFetched!=NULL && celt == 0 -> S_OK
//
//  Returns:    S_OK if successful, otherwise error.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Next(
             ULONG                   celt,
             STATPROPSTG *           rgelt,
             ULONG *                 pceltFetched)
{
    HRESULT hr;
    NTSTATUS Status;
    ULONG   celtFetched = celt;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate the inputs

    if (NULL == pceltFetched)
    {
        if (celt != 1)
            return(STG_E_INVALIDPARAMETER);
    }
    else
    {
        VDATEPTROUT( pceltFetched, ULONG );
        *pceltFetched = 0;
    }

    if( 0 == celt )
        return( S_OK );

    if( !IsValidPtrOut(rgelt, celt * sizeof(rgelt[0])) )
        return( E_INVALIDARG );


    //  -----------------------
    //  Perform the enumeration
    //  -----------------------

    if (celt == 0)
        return(hr);

    Status = _psa->NextAt(_ipropNext, rgelt, &celtFetched);

    if (NT_SUCCESS(Status))
    {
        _ipropNext += celtFetched;

        if (pceltFetched != NULL)
            *pceltFetched = celtFetched;

        hr = celtFetched == celt ? S_OK : S_FALSE;
    }
    else
    {
        CleanupSTATPROPSTG(celt, rgelt);
        hr = DfpNtStatusToHResult(Status);
    }

    return(hr);
    
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Skip
//
//  Synopsis:   Skip the next [celt] elements in the enumeration.
//
//  Arguments:  [celt] -- number of elts to skip
//              
//  Returns:    S_OK if skipped [celt] elements
//              S_FALSE if skipped < [celt] elements
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Skip(ULONG celt)
{
    HRESULT hr;
    ULONG celtFetched = celt;

    if (S_OK != (hr = Validate()))
        return(hr);

    _psa->NextAt(_ipropNext, NULL, &celtFetched);

    _ipropNext += celtFetched;

    return celtFetched == celt ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Reset
//
//  Synopsis:   Set cursor to beginnging of enumeration.
//
//  Returns:    S_OK otherwise STG_E_INVALIDHANDLE.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Reset()
{
    HRESULT hr;

    if (S_OK != (hr = Validate()))
        return(hr);

    _ipropNext = 0;

    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Clone
//
//  Synopsis:   Creates an IEnumSTATPROPSTG with same cursor
//              as this.
//
//  Arguments:  S_OK or error.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Clone(IEnumSTATPROPSTG ** ppenum)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate the input

    VDATEPTROUT( ppenum, IEnumSTATPROPSTG* );

    //  --------------------
    //  Clone the enumerator
    //  --------------------

    *ppenum = NULL;

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppenum = new CEnumSTATPROPSTG(*this, &hr);

    if (FAILED(hr))
    {
        delete (CEnumSTATPROPSTG*)*ppenum;
        *ppenum = NULL;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\psetstg.cxx ===
//+-------------------------------------------------------------------------
// 
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       psetstg.cxx
//
//  Contents:   Implementation of common class DocFile
//              IPropertySetStorage
//
//  Classes:    CPropertySetStorage
//              CEnumSTATPROPSETSTG
//
//  Notes:      
//
//--------------------------------------------------------------------------

#include "pch.cxx"

#include "prophdr.hxx"

//
// debugging support
//
#if DBG
CHAR *
DbgFmtId(REFFMTID rfmtid, CHAR *pszBuf)
{
    PropSprintfA(pszBuf, "rfmtid=%08X.%04X.%04X.%02X.%02X.%02X.%02X.%02X.%02X.%02X.%02X",
        rfmtid.Data1,
        rfmtid.Data2,
        rfmtid.Data3,
        rfmtid.Data4[0],
        rfmtid.Data4[1],
        rfmtid.Data4[2],
        rfmtid.Data4[3],
        rfmtid.Data4[4],
        rfmtid.Data4[5],
        rfmtid.Data4[6],
        rfmtid.Data4[7]);

    return(pszBuf);
}

CHAR *  
DbgMode(DWORD grfMode, CHAR *psz)
{
    *psz = 0;

    if (grfMode & STGM_TRANSACTED)
        strcat(psz, "STGM_TRANSACTED | ");
    else
        strcat(psz, "STGM_DIRECT | ");

    if (grfMode & STGM_SIMPLE)
        strcat(psz, "STGM_SIMPLE | ");

    switch (grfMode & 3)
    {
    case STGM_READ:
        strcat(psz, "STGM_READ |");
        break;
    case STGM_WRITE:
        strcat(psz, "STGM_WRITE |");
        break;
    case STGM_READWRITE:
        strcat(psz, "STGM_READWRITE |");
        break;
    default:
        strcat(psz, "BAD grfMode |");
        break;
    }

    switch (grfMode & 0x70)
    {
    case STGM_SHARE_DENY_NONE:
        strcat(psz, "STGM_SHARE_DENY_NONE |");
        break;
    case STGM_SHARE_DENY_READ:
        strcat(psz, "STGM_SHARE_DENY_READ |");
        break;
    case STGM_SHARE_DENY_WRITE:
        strcat(psz, "STGM_SHARE_DENY_WRITE |");
        break;
    case STGM_SHARE_EXCLUSIVE:
        strcat(psz, "STGM_SHARE_EXCLUSIVE |");
        break;
    default:
        strcat(psz, "BAD grfMode | ");
        break;
    }

        
    if (grfMode & STGM_PRIORITY)
        strcat(psz, "STGM_PRIORITY | ");

    if (grfMode & STGM_DELETEONRELEASE)
        strcat(psz, "STGM_DELETEONRELEASE | ");

    if (grfMode & STGM_NOSCRATCH)
        strcat(psz, "STGM_NOSCRATCH | ");

    if (grfMode & STGM_CREATE)
        strcat(psz, "STGM_CREATE | ");

    if (grfMode & STGM_CONVERT)
        strcat(psz, "STGM_CONVERT | ");

    if (grfMode & STGM_FAILIFTHERE)
        strcat(psz, "STGM_FAILIFTHERE | ");

    return(psz);
}

CHAR *
DbgFlags(DWORD grfFlags, CHAR *psz)
{
    strcpy(psz, "grfFlags=");

    if (grfFlags & PROPSETFLAG_NONSIMPLE)
        strcat(psz, "PROPSETFLAG_NONSIMPLE |");
    else
        strcat(psz, "PROPSETFLAG_SIMPLE |");

    if (grfFlags & PROPSETFLAG_ANSI)
        strcat(psz, "PROPSETFLAG_ANSI |");
    else
        strcat(psz, "PROPSETFLAG_WIDECHAR |");

    return(psz);
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::QueryInterface, AddRef, Release
//
//  Synopsis:   IUnknown members
//
//  Notes:      Send the calls to the root.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    if (S_OK != (hr = Validate()))
        return(hr);

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    //  -----
    //  Query
    //  -----

    return(_pprivstg->GetStorage()->QueryInterface(riid, ppvObject));
}

ULONG   CPropertySetStorage::AddRef(void)
{
    if (S_OK !=  Validate())
        return(0);
    return(_pprivstg->GetStorage()->AddRef());
}

ULONG   CPropertySetStorage::Release(void)
{
    if (S_OK != Validate())
        return(0);
    return(_pprivstg->GetStorage()->Release());
}


//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Create
//
//  Synopsis:   Create a property set for outermost client of
//              IPropertSetStorage.
//
//  Arguments:  Passed through to CPropertyStorage ctor.
//              
//  Returns:    S_OK or failure code.
//
//  Notes:      Create a new CPropertyStorage object which will
//              implement IPropertyStorage.  The _pprivstg parameter
//              passed into CPropertyStorage::CPropertyStorage is
//              used to create (via QI) a matching type of mapped
//              stream for docfile properies
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Create( REFFMTID                rfmtid,
                                     const CLSID *           pclsid,
                                     DWORD                   grfFlags,
                                     DWORD                   grfMode,
                                     IPropertyStorage **     ppprstg)
{
    HRESULT hr;
    DBGBUF(buf1);
    DBGBUF(buf2);
    DBGBUF(buf3);

    //  ----------
    //  Validation
    //  ----------

    if (S_OK != (hr = Validate()))
        goto errRet;

    GEN_VDATEREADPTRIN_LABEL(&rfmtid, FMTID, E_INVALIDARG, errRet, hr);
    GEN_VDATEPTRIN_LABEL(pclsid, CLSID, E_INVALIDARG, errRet, hr);
    GEN_VDATEPTROUT_LABEL( ppprstg, IPropertyStorage*, E_INVALIDARG, errRet, hr);


    //  ---------------------------
    //  Create the Property Storage
    //  ---------------------------

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppprstg = NULL;

    *ppprstg = new CPropertyStorage(_pprivstg,
                                    rfmtid,
                                    pclsid,
                                    grfFlags,
                                    grfMode,
                                    &hr);
    if (FAILED(hr))
    {
        delete (CPropertyStorage*) *ppprstg;
        *ppprstg = NULL;
    }

    //  ----
    //  Exit
    //  ----

errRet:
    if( E_INVALIDARG != hr )
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Create(%s, %s, %s, retif=%08X, hr = %08X\n",
            this, DbgFmtId(rfmtid, buf1), DbgFlags(grfFlags, buf2), DbgMode(grfMode, buf3), *ppprstg, hr));
    }
    else
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Create(%08X, %s, %s, retif=%08X, hr = %08X\n",
            this, &rfmtid, DbgFlags(grfFlags, buf2), DbgMode(grfMode, buf3), ppprstg, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Open
//
//  Synopsis:   Open a property set for outermost client.
//
//  Arguments:  passed through to CPropertyStorage ctor.
//              
//  Returns:    S_OK or error.
//
//  Notes:      Creates a CPropertyStorage which will use the passed
//              pstg to create a mapped stream of the correct type
//              in its implementation.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Open(   REFFMTID                rfmtid,
                                     DWORD                   grfMode,
                                     IPropertyStorage **     ppprstg)
{
    HRESULT hr;
    DBGBUF(buf1);
    DBGBUF(buf2);

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'
    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate inputs
    GEN_VDATEREADPTRIN_LABEL(&rfmtid, FMTID, E_INVALIDARG, errRet, hr);
    GEN_VDATEPTROUT_LABEL( ppprstg, IPropertyStorage*, E_INVALIDARG, errRet, hr);

    //  -------------------------
    //  Open the Property Storage
    //  -------------------------

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppprstg = NULL;

    *ppprstg = new CPropertyStorage(_pprivstg, rfmtid, grfMode,
                                    FALSE, // Don't delete this section
                                    &hr);

    if (FAILED(hr))
    {
        delete (CPropertyStorage*) *ppprstg;
        *ppprstg = NULL;
    }

    //  ----
    //  Exit
    //  ----

errRet:

    if( E_INVALIDARG != hr )
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Open(%s, %s) retif=%08X, hr=%08X\n",
            this, DbgFmtId(rfmtid, buf1), DbgMode(grfMode, buf2), *ppprstg, hr));
    }
    else
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Open(), hr=%08X\n",
            this, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Delete
//
//  Synopsis:   Delete the specified property set.
//
//  Arguments:  [rfmtid] -- format id of property set to delete.
//              
//  Returns:    S_OK if successful, error otherwise.
//
//  Notes:      Get the matching name and try the element deletion.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Delete( REFFMTID  rfmtid)
{
    HRESULT hr;
    DBGBUF(buf);

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'
    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the input
    GEN_VDATEREADPTRIN_LABEL(&rfmtid, FMTID, E_INVALIDARG, errRet, hr);

    //  --------------------------
    //  Delete the PropertyStorage
    //  --------------------------

    // Check for the special-case

    if( IsEqualIID( rfmtid, FMTID_UserDefinedProperties ))
    {

        // This property set is actually the second section of the Document
        // Summary Information property set.  We must delete this
        // section, but we can't delete the Stream because it 
        // still contain the first section.

        CPropertyStorage* pprstg;
        
        pprstg = new CPropertyStorage(_pprivstg,
                                      rfmtid,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      TRUE, // Delete this section.
                                      &hr);

        if (pprstg != NULL)
        {
            pprstg->Release();
        }
        pprstg = NULL;
    
    }   // if( IsEqualIID( rfmtid, FMTID_DocSummaryInformation2 ))

    else
    {
        // This is not a special case, so we can just delete
        // the Stream.  Note that if the rfmtid represents the first
        // section of the DocumentSummaryInformation set, we might be
        // deleting the second section here as well.

        CPropSetName psn(rfmtid);

        hr = _pprivstg->GetStorage()->DestroyElement(psn.GetPropSetName());

    }   // if( IsEqualIID( rfmtid, FMTID_DocSummaryInformation2 )) ... else

    //  ----
    //  Exit
    //  ----

errRet:

    if( E_INVALIDARG != hr )
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Delete(%s) hr = %08X\n",
            this, DbgFmtId(rfmtid, buf), hr));
    }
    else
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Delete(%08X) hr = %08X\n",
            this, &rfmtid, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Enum
//
//  Synopsis:   Create an enumerator over the property set
//
//  Arguments:  [ppenum] -- where to return the pointer to the
//                          enumerator.
//
//  Returns:    S_OK if ok, error otherwise.
//
//  Notes:      [ppenum] is NULL on error.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Enum(   IEnumSTATPROPSETSTG **  ppenum)
{

    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'
    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the input
    GEN_VDATEPTROUT_LABEL( ppenum, IEnumSTATPROPSETSTG*, E_INVALIDARG, errRet, hr);

    //  --------------------
    //  Create the enuerator
    //  --------------------

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppenum = NULL; // for access violation

    *ppenum = new CEnumSTATPROPSETSTG(_pprivstg->GetStorage(), &hr);

    if (FAILED(hr))
    {
        delete (CEnumSTATPROPSETSTG*) *ppenum;
        *ppenum = NULL;
    }

    //  ----
    //  Exit
    //  ----

errRet:

    if( E_INVALIDARG != hr )
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Enum(retif=%08X), hr = %08X\n",
            this, *ppenum, hr));
    }
    else
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Enum(), hr = %08X\n",
            this, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG
//
//  Synopsis:   Constructor which is used to implement
//              IPropertySetStorage::Enum
//
//  Arguments:  [pstg] -- the storage of the container to enumerate.
//              [phr] -- place to return HRESULT, S_OK or error.
//
//  Notes:      We use an STATSTG enumerator over the actual storage
//              to get the information about the property sets.
//
//--------------------------------------------------------------------


CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG(IStorage *pstg, HRESULT *phr)
{
    HRESULT & hr = *phr;

    _ulSig = ENUMSTATPROPSETSTG_SIG;
    _cRefs = 1;
    hr = pstg->EnumElements(FALSE, NULL, 0, &_penumSTATSTG);
    if (FAILED(hr))
        _penumSTATSTG = NULL;
    _cstatTotalInArray = 0;
    _istatNextToRead = 0;

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG
//
//  Synopsis:   Copy constructor which is used to implement
//              IEnumSTATPROPSETSTG::Clone.
//
//  Arguments:  [Other] -- The CEnumSTATPROPSETSTG to clone.
//              [phr] -- place to return HRESULT, S_OK or error.
//  
//--------------------------------------------------------------------

CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG(   CEnumSTATPROPSETSTG &Other,
                                            HRESULT *phr)
{
    HRESULT & hr = *phr;

    _ulSig = ENUMSTATPROPSETSTG_SIG;
    _cRefs = 1;
    _cstatTotalInArray = 0;
    _istatNextToRead = Other._istatNextToRead;
    
    hr = Other._penumSTATSTG->Clone(&_penumSTATSTG);
    if (hr == S_OK)
    {
        // Copy the data in the buffer
        memcpy(_statarray, Other._statarray, sizeof(_statarray));
        _cstatTotalInArray = Other._cstatTotalInArray;

        // Copy the strings in the buffer
        for (ULONG i=0; i<_cstatTotalInArray; i++)
        {
            _statarray[i].pwcsName =
                (OLECHAR*)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(Other._statarray[i].pwcsName)+1));
            if (_statarray[i].pwcsName == NULL)
            {
                _cstatTotalInArray = i;
                hr = STG_E_INSUFFICIENTMEMORY;
                break;
            }
            else
            {
                ocscpy(_statarray[i].pwcsName, Other._statarray[i].pwcsName);
            }
        }
    }
    // note: destructor will cleanup the the strings or enumerator left behind
    //       in the error case
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::~CEnumSTATPROPSETSTG
//
//  Synopsis:   Delete the enumerator.
//
//  Notes:      Just releases the contained IEnumSTATSTG
//
//--------------------------------------------------------------------

CEnumSTATPROPSETSTG::~CEnumSTATPROPSETSTG()
{
    _ulSig = ENUMSTATPROPSETSTG_SIGDEL;

    if (_penumSTATSTG != NULL)
        _penumSTATSTG->Release();

    CleanupStatArray();

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::QueryInterface, AddRef, Release
//
//  Synopsis:   IUnknown
//
//  Arguments:  The usual thing.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    if (S_OK != (hr = Validate()))
        return(hr);

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IEnumSTATPROPSETSTG))
    {
        *ppvObject = (IEnumSTATPROPSETSTG *)this;
        CEnumSTATPROPSETSTG::AddRef();
    }
    else
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = (IUnknown *)this;
        CEnumSTATPROPSETSTG::AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return(hr);
    
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::AddRef
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSETSTG::AddRef(void)
{
    if (S_OK != Validate())
        return(0);

    InterlockedIncrement(&_cRefs);
    return(_cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Release
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSETSTG::Release(void)
{
    LONG lRet;

    if (S_OK != Validate())
        return(0);

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Next
//
//  Synopsis:   Implement IEnumSTATPROPSETSTG for docfile.
//
//  Arguments:  [celt] -- Count of elements to attempt to retrieve.
//              [rgelt] -- Where to put the results.  Must be valid for at least
//                         celt * sizeof(STATPROPSETSTG) bytes in length.
//              [pceltFetched] -- Count of elements returned is put here if
//                  the pointer is non-null.  If celt > 1, pceltFetched must
//                  be valid non-NULL.  If pcelt is non-NULL, it must be valid.
//                  if pcelt is NULL, celt must be 1.
//
//  Returns:    S_OK if ok, error otherwise.
//
//  Notes:      We use a stack buffer to get more stuff per call to
//              underlying storage IEnumSTATSTG::Next.  We then copy
//              data from the STATSTG's to STATPROPSETSTG's.
//
//              An outer loop enumerates into statarray and then an
//              inner loop copies each batch into the [rgelt] buffer.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Next(ULONG                   celt,
                                  STATPROPSETSTG *        rgelt,
                                  ULONG *                 pceltFetched)
{
    HRESULT hr;
    ULONG celtCallerTotal;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate inputs

    if (NULL == pceltFetched)
    {
        if (1 != celt)
            return(STG_E_INVALIDPARAMETER);
    }
    else
    {
        VDATEPTROUT( pceltFetched, ULONG );
        *pceltFetched = 0;
    }

    if (0 == celt)
        return(hr);

    if( !IsValidPtrOut(rgelt, celt * sizeof(rgelt[0])) )
        return( E_INVALIDARG );


    //  -----------------------
    //  Perform the enumeration
    //  -----------------------

    celtCallerTotal = 0;

    //
    // we do this loop until we have what the caller wanted or error, or
    // no more.
    //
    do
    {
        //
        // If our internal buffer is empty, we (re)load it
        //
        if (_istatNextToRead == _cstatTotalInArray)
        {
            if (_cstatTotalInArray != 0)
                CleanupStatArray();

            hr = _penumSTATSTG->Next(sizeof(_statarray)/sizeof(_statarray[0]),
                    _statarray,
                    &_cstatTotalInArray);
        }

        // S_OK or S_FALSE indicate that we got something
        if (SUCCEEDED(hr))
        {
            //
            // we loop reading out of this buffer until either we have
            // all that the caller asked for, or we have exhausted the
            // buffer.
            //
            for (; celtCallerTotal < celt &&
                   _istatNextToRead < _cstatTotalInArray ;
                   _istatNextToRead++)
            {
                OLECHAR *pocsName = _statarray[_istatNextToRead].pwcsName;
                BOOL fDone = FALSE;

                PROPASSERT(pocsName != NULL);

                if (pocsName[0] == 5)
                {
                    // *** get fmtid *** //

                    if (!NT_SUCCESS(RtlPropertySetNameToGuid(
                                    ocslen(pocsName), pocsName, &rgelt->fmtid)))
                    {
                        ZeroMemory(&rgelt->fmtid, sizeof(rgelt->fmtid));
                    }
    
                    // *** get clsid *** //
                    // *** get grfFlags *** //
    
                    if (_statarray[_istatNextToRead].type == STGTY_STORAGE)
                    {
                        rgelt->clsid = _statarray[_istatNextToRead].clsid;
                        rgelt->grfFlags = PROPSETFLAG_NONSIMPLE;
                    }
                    else
                    {
                        ZeroMemory(&rgelt->clsid, sizeof(rgelt->clsid));
                        rgelt->grfFlags = 0;
                    }
    
                    // *** get mtime *** //
                    rgelt->mtime = _statarray[_istatNextToRead].mtime;
    
                    // *** get ctime *** //
                    rgelt->ctime = _statarray[_istatNextToRead].ctime;
    
                    // *** get atime *** //
                    rgelt->atime = _statarray[_istatNextToRead].atime;

                    // *** default the OS Version *** //
                    rgelt->dwOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;
    
                    rgelt ++;
                    celtCallerTotal ++;
                }
            }
        }
    }
    while (celtCallerTotal < celt && hr == S_OK);

    if (SUCCEEDED(hr))
    {
        hr = celt == celtCallerTotal ? S_OK : S_FALSE;
        PROPASSERT(hr == S_OK || celtCallerTotal < celt);

        if (pceltFetched != NULL)
            *pceltFetched = celtCallerTotal;
    }
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Skip
//
//  Synopsis:   Skip the requested number of elements.
//
//  Arguments:  [celt] -- number to skip.
//
//  Returns:    S_OK if all skipped, S_FALSE if less than requested
//              number skipped, error otherwise.
//
//  Notes:      
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Skip(ULONG celt)
{
    HRESULT hr;
    STATPROPSETSTG stat;
    ULONG celtCallerTotal = 0;

    if (S_OK != (hr = Validate()))
        return(hr);

    do
    {
        hr = Next(1, &stat, NULL);
    } while ( hr == S_OK && ++celtCallerTotal < celt );

    if (SUCCEEDED(hr))
        hr = celt == celtCallerTotal ? S_OK : S_FALSE;

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::CleanupStatArray
//
//  Synopsis:   Free any strings in the array.
//
//--------------------------------------------------------------------

VOID CEnumSTATPROPSETSTG::CleanupStatArray()
{
    for (ULONG i=0; i<_cstatTotalInArray; i++)
    {
        CoTaskMemFree(_statarray[i].pwcsName);
        _statarray[i].pwcsName = NULL;
    }
    _istatNextToRead = 0;
    _cstatTotalInArray = 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Reset
//
//  Synopsis:   Reset the enumerator.
//
//  Notes:      Merely resetting the underlying enumerator should be
//              adequate,
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Reset()
{
    HRESULT hr;

    if (S_OK != (hr = Validate()))
        return(hr);

    hr = _penumSTATSTG->Reset();
    if (hr == S_OK)
    {
        CleanupStatArray();
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Clone
//
//  Synopsis:   Copy the enumeration state of this enumerator.
//
//  Arguments:  [ppenum] -- where to put the pointer to the clone
//
//  Returns:    S_OK if ok, error otherwise.
//
//  Notes:      We end up just calling IEnumSTATSTG::Clone in the
//              CEnumSTATPROPSETSTG constructor.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Clone(IEnumSTATPROPSETSTG **     ppenum)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate inputs

    VDATEPTROUT( ppenum, IEnumSTATPROPSETSTG* );

    //  --------------------
    //  Clone the enumerator
    //  --------------------

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppenum = new CEnumSTATPROPSETSTG(*this, &hr);
    if (FAILED(hr))
    {
        delete (CEnumSTATPROPSETSTG*) *ppenum;
        *ppenum = NULL;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\propvar.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993
//
// File:        propvar.cxx
//
// Contents:    PROPVARIANT manipulation code
//
//
//---------------------------------------------------------------------------

#include "pch.cxx"

#ifndef newk
#define newk(Tag, pCounter)     new
#endif

extern "C" UNICODECALLOUTS UnicodeCallouts;

// The below variant types are supported in property set streams.  In addition,
// the variants found in an array of variants (VT_VECTOR | VT_VARIANT) can only
// contain the types listed below as legal for arrays.  Nested vectors of
// VT_VARIANT are specifically *allowed*.
//
// dd    xx  symbolic name	     field		  size
// --   ---  -------------	     -----		  ----
// -1 - ffff VT_ILLEGAL		     <none>		  can't legally be stored
//
//  0 - x00  VT_EMPTY		     <none>		  0
//  1 - x01  VT_NULL		     <none>		  0
//
// 16 - x10  VT_I1                   CHAR cVal            sizeof(char)
// 17 - x11  VT_UI1		     UCHAR bVal		  sizeof(char)
//
//  2 - x02  VT_I2		     short iVal		  sizeof(short)
// 18 - x12  VT_UI2		     USHORT uiVal	  sizeof(short)
// 11 - x0b  VT_BOOL		     VARIANT_BOOL boolVal sizeof(short)
//
//  3 - x03  VT_I4		     long lVal		  sizeof(long)
// 19 - x13  VT_UI4		     ULONG ulVal	  sizeof(long)
//  4 - x04  VT_R4		     float fltVal	  sizeof(long)
// 10 - x0a  VT_ERROR		     SCODE scode	  sizeof(long)
//
// 20 - x14  VT_I8		     LARGE_INTEGER hVal	  sizeof(ll)
// 21 - x15  VT_UI8		   ULARGE_INTEGER uhVal	  sizeof(ll)
//  5 - x05  VT_R8		     double dblVal	  sizeof(ll)
//  6 - x06  VT_CY		     CY cyVal		  sizeof(ll)
//  7 - x07  VT_DATE		     DATE date		  sizeof(ll)
// 64 - x40  VT_FILETIME	     FILETIME filetime	  sizeof(ll)
//
// 72 - x48  VT_CLSID		     CLSID *puuid	  sizeof(GUID)
//
// 65 - x41  VT_BLOB		     BLOB blob		  counted array of bytes
// 70 - x46  VT_BLOB_OBJECT	     BLOB blob		  counted array of bytes
// 71 - x47  VT_CF		     CLIPDATA *pclipdata    " + ulClipFmt
// 66 - x42  VT_STREAM		     LPSTR pszVal	  counted array of bytes
// 68 - x44  VT_STREAMED_OBJECT      LPSTR pszVal	  counted array of bytes
// 67 - x43  VT_STORAGE		     LPSTR pszVal	  counted array of bytes
// 69 - x45  VT_STORED_OBJECT	     LPSTR pszVal	  counted array of bytes
//  8 - x08  VT_BSTR		     BSTR bstrVal	  counted array of bytes
// 30 - x1e  VT_LPSTR		     LPSTR pszVal	  counted array of bytes
//
// 31 - x1f  VT_LPWSTR		     LPWSTR pwszVal	  counted array of WCHARs
//
//    x1010  VT_VECTOR | VT_I1	     CAC cac		  cElems * sizeof(char)
//    x1011  VT_VECTOR | VT_UI1	     CAUB caub		  cElems * sizeof(char)
//
//    x1002  VT_VECTOR | VT_I2	     CAI cai		  cElems * sizeof(short)
//    x1012  VT_VECTOR | VT_UI2	     CAUI caui		  cElems * sizeof(short)
//    x100b  VT_VECTOR | VT_BOOL     CABOOL cabool	  cElems * sizeof(short)
//
//    x1003  VT_VECTOR | VT_I4	     CAL cal		  cElems * sizeof(long)
//    x1013  VT_VECTOR | VT_UI4	     CAUL caul		  cElems * sizeof(long)
//    x1004  VT_VECTOR | VT_R4	     CAFLT caflt	  cElems * sizeof(long)
//    x100a  VT_VECTOR | VT_ERROR    CAERROR cascode	  cElems * sizeof(long)
//
//    x1014  VT_VECTOR | VT_I8	     CAH cah		  cElems * sizeof(ll)
//    x1015  VT_VECTOR | VT_UI8	     CAUH cauh		  cElems * sizeof(ll)
//    x1005  VT_VECTOR | VT_R8	     CADBL cadbl	  cElems * sizeof(ll)
//    x1006  VT_VECTOR | VT_CY	     CACY cacy		  cElems * sizeof(ll)
//    x1007  VT_VECTOR | VT_DATE     CADATE cadate	  cElems * sizeof(ll)
//    x1040  VT_VECTOR | VT_FILETIME CAFILETIME cafiletime cElems * sizeof(ll)
//
//    x1048  VT_VECTOR | VT_CLSID    CACLSID cauuid	  cElems * sizeof(GUID)
//
//    x1047  VT_VECTOR | VT_CF	  CACLIPDATA caclipdata   cElems cntarray of bytes
//    x1008  VT_VECTOR | VT_BSTR     CABSTR cabstr	  cElems cntarray of bytes
//    x101e  VT_VECTOR | VT_LPSTR    CALPSTR calpstr	  cElems cntarray of bytes
//
//    x101f  VT_VECTOR | VT_LPWSTR   CALPWSTR calpwstr	  cElems cntarray of WCHAR
//
//    x100c  VT_VECTOR | VT_VARIANT  CAPROPVARIANT capropvar cElems variants
//							   (recurse on each)


//+---------------------------------------------------------------------------
// Function:    RtlpConvertToUnicode, private
//
// Synopsis:    Convert a MultiByte string to a Unicode string
//
// Arguments:   [pch]        -- pointer to MultiByte string
//              [cb]         -- byte length of MultiByte string
//              [CodePage]   -- property set codepage
//              [ppwc]       -- pointer to returned pointer to Unicode string
//              [pcb]        -- returned byte length of Unicode string
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
RtlpConvertToUnicode(
    IN CHAR const *pch,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT WCHAR **ppwc,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    WCHAR *pwszName;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pch != NULL);
    PROPASSERT(ppwc != NULL);
    PROPASSERT(pcb != NULL);

    *ppwc = NULL;
    *pcb = 0;

    ULONG cwcName;

    PROPASSERT(UnicodeCallouts.pfnMultiByteToWideChar != NULL);

    pwszName = NULL;
    cwcName = 0;
    while (TRUE)
    {
	cwcName = (*UnicodeCallouts.pfnMultiByteToWideChar)(
				    CodePage,
				    0,			// dwFlags
				    pch,
				    cb,
				    pwszName,
				    cwcName);
	if (cwcName == 0)
	{
	    delete [] pwszName;
            // If there was an error, assume that it was a code-page
            // incompatibility problem.
            StatusError(pstatus, "RtlpConvertToUnicode: MultiByteToWideChar error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}
	if (pwszName != NULL)
	{
	    DebugTrace(0, DEBTRACE_PROPERTY, (
		"RtlpConvertToUnicode: pch='%s'[%x] pwc='%ws'[%x->%x]\n",
		pch,
		cb,
		pwszName,
		*pcb,
		cwcName * sizeof(WCHAR)));
	    break;
	}
	*pcb = cwcName * sizeof(WCHAR);
	*ppwc = pwszName = (WCHAR *) newk(mtPropSetStream, NULL) CHAR[*pcb];
	if (pwszName == NULL)
	{
	    StatusNoMemory(pstatus, "RtlpConvertToUnicode: no memory");
            goto Exit;
	}
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+---------------------------------------------------------------------------
// Function:    RtlpConvertToMultiByte, private
//
// Synopsis:    Convert a Unicode string to a MultiByte string
//
// Arguments:   [pwc]        -- pointer to Unicode string
//              [cb]         -- byte length of Unicode string
//              [CodePage]   -- property set codepage
//              [ppch]       -- pointer to returned pointer to MultiByte string
//              [pcb]        -- returned byte length of MultiByte string
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
RtlpConvertToMultiByte(
    IN WCHAR const *pwc,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT CHAR **ppch,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    ULONG cbName;
    CHAR *pszName;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pwc != NULL);
    PROPASSERT(ppch != NULL);
    PROPASSERT(pcb != NULL);

    *ppch = NULL;
    *pcb = 0;


    PROPASSERT(UnicodeCallouts.pfnWideCharToMultiByte != NULL);

    pszName = NULL;
    cbName = 0;
    while (TRUE)
    {
	cbName = (*UnicodeCallouts.pfnWideCharToMultiByte)(
				    CodePage,
				    0,			// dwFlags
				    pwc,
				    cb/sizeof(WCHAR),
				    pszName,
				    cbName,
				    NULL,		// lpDefaultChar
				    NULL);		// lpUsedDefaultChar
	if (cbName == 0)
	{
	    delete [] pszName;
            // If there was an error, assume that it was a code-page
            // incompatibility problem.
            StatusError(pstatus, "RtlpConvertToMultiByte: WideCharToMultiByte error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}
	if (pszName != NULL)
	{
	    DebugTrace(0, DEBTRACE_PROPERTY, (
		"RtlpConvertToMultiByte: pwc='%ws'[%x] pch='%s'[%x->%x]\n",
		pwc,
		cb,
		pszName,
		*pcb,
		cbName));
	    break;
	}
	*pcb = cbName;
	*ppch = pszName = newk(mtPropSetStream, NULL) CHAR[cbName];
	if (pszName == NULL)
	{
	    StatusNoMemory(pstatus, "RtlpConvertToMultiByte: no memory");
            goto Exit;
	}
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+---------------------------------------------------------------------------
// Function:    RtlConvertVariantToProperty, private
//
// Synopsis:    Convert a PROPVARIANT to a SERIALIZEDPROPERTYVALUE
//
// Arguments:   [pvar]       -- pointer to PROPVARIANT
//              [CodePage]   -- property set codepage
//              [pprop]      -- pointer to SERIALIZEDPROPERTYVALUE
//              [pcb]        -- pointer to remaining stream length,
//			        updated to actual property size on return
//              [pid]	     -- propid
//              [fVariantVector] -- TRUE if recursing on VT_VECTOR | VT_VARIANT
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     NULL if buffer too small, else input [pprop] argument
//---------------------------------------------------------------------------


// Define a macro which sets a variable named 'cbByteSwap', but
// only on big-endian builds.  This value is not needed on little-
// endian builds (because byte-swapping is not necessary).

#ifdef BIGENDIAN
#define CBBYTESWAP(cb) cbByteSwap = cb
#elif LITTLEENDIAN
#define CBBYTESWAP(cb)
#else
#error Either BIGENDIAN or LITTLEENDIAN must be set.
#endif


SERIALIZEDPROPERTYVALUE *
RtlConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    //  ------
    //  Locals
    //  ------
    CHAR *pchConvert = NULL;

    ULONG count;
    BYTE *pbdst;
    ULONG cbch = 0;
    ULONG cbchdiv = 0;
    ULONG cb = 0;

    // Size of byte-swapping units (e.g. 2 to swap a WORD).
    INT   cbByteSwap = 0;

    ULONG const *pcount = NULL;
    VOID const *pv = NULL;
    LONG *pclipfmt = NULL;
    BOOLEAN fCheckNullSource = (BOOLEAN) ((pvar->vt & VT_VECTOR) != 0);
    BOOLEAN fIllegalType = FALSE;
    VOID **ppv;

    //  -------------------------------------------------------
    //  Analyze the PropVariant, and store information about it
    //  in fIllegalType, cb, pv, pcount, count, pclipfmt,
    //  fCheckNullSource, cbch, chchdiv, and ppv.
    //  -------------------------------------------------------

    switch (pvar->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
	fIllegalType = fVariantVector;
	break;

#ifdef PROPVAR_VT_I1
    case VT_I1:
        AssertByteField(cVal);          // VT_I1
#endif
    case VT_UI1:
        AssertByteField(bVal);          // VT_UI1
	cb = sizeof(pvar->bVal);
	pv = &pvar->bVal;
	break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
	AssertShortField(iVal);	        // VT_I2
	AssertShortField(uiVal);        // VT_UI2
	AssertShortField(boolVal);      // VT_BOOL
	cb = sizeof(pvar->iVal);
	pv = &pvar->iVal;

        // If swapping, swap as a WORD
        CBBYTESWAP(cb);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
	AssertLongField(lVal);		// VT_I4
	AssertLongField(ulVal);		// VT_UI4
	AssertLongField(fltVal);		// VT_R4
	AssertLongField(scode);		// VT_ERROR
	cb = sizeof(pvar->lVal);
	pv = &pvar->lVal;

        // If swapping, swap as a DWORD
        CBBYTESWAP(cb);
	break;

    case VT_I8:
    case VT_UI8:
    case VT_FILETIME:
	AssertLongLongField(hVal);		// VT_I8
	AssertLongLongField(uhVal);		// VT_UI8
	AssertLongLongField(filetime);	// VT_FILETIME
	cb = sizeof(pvar->hVal);
	pv = &pvar->hVal;

        // If swapping, swap each DWORD independently.
        CBBYTESWAP(sizeof(DWORD));
	break;

    case VT_R8:
    case VT_CY:
    case VT_DATE:
	AssertLongLongField(dblVal);    // VT_R8
	AssertLongLongField(cyVal);     // VT_CY
	AssertLongLongField(date);      // VT_DATE
	cb = sizeof(pvar->dblVal);
	pv = &pvar->dblVal;

        // If swapping, swap as a LONGLONG (64 bits).
        CBBYTESWAP(cb);
	break;

    case VT_CLSID:
	AssertStringField(puuid);       // VT_CLSID
	cb = sizeof(GUID);
	pv = pvar->puuid;
	fCheckNullSource = TRUE;

        // If swapping, special handling is required.
        CBBYTESWAP( CBBYTESWAP_UID );
	break;

    case VT_CF:

        // Validate the PropVariant
	if (pvar->pclipdata == NULL
            ||
            pvar->pclipdata->cbSize < sizeof(pvar->pclipdata->ulClipFmt) )
	{
	    StatusInvalidParameter(pstatus, "RtlConvertVariantToProperty: pclipdata NULL");
            goto Exit;
	}

        // How many bytes should we copy?
	cb = CBPCLIPDATA( *(pvar->pclipdata) );

        // Identify the value for this property's count field.
        // (which includes sizeof(ulClipFmt))
	count = pvar->pclipdata->cbSize;
	pcount = &count;

        // Identify the clipdata's format & data
	pclipfmt = &pvar->pclipdata->ulClipFmt;
	pv = pvar->pclipdata->pClipData;

	fCheckNullSource = TRUE;

        // Note that no byte-swapping of 'pv' is necessary.
	break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
	fIllegalType = fVariantVector;
	pcount = &pvar->blob.cbSize;
	cb = *pcount;
	pv = pvar->blob.pBlobData;
	fCheckNullSource = TRUE;

        // Note that no byte-swapping of 'pv' is necessary.
	break;

    case VT_LPSTR:
	PROPASSERT(
	    pvar->pszVal == NULL ||
	    IsAnsiString(pvar->pszVal, MAXULONG));
	// FALLTHROUGH

    case VT_BSTR:
	count = 0;	// allow NULL pointer
	pv = pvar->pszVal;

	AssertStringField(bstrVal);	// VT_BSTR
	AssertStringField(pszVal);	// VT_LPSTR

        // We have the string for an LPSTR, BSTR
        // property pointed to by 'pv'.  Now we'll perform any
        // Ansi/Unicode conversions and byte-swapping that's
        // necessary (putting the result in 'pv').

	if (pv == NULL)
	{
	    fCheckNullSource = TRUE;
	}

	else
	if (pvar->vt == VT_LPSTR)
	{
	    count = strlen((char *) pv) + 1;

            // If the propset is Unicode, convert the LPSTR to Unicode.

	    if (CodePage == CP_WINUNICODE)
	    {
                // Convert to Unicode.

		PROPASSERT(IsAnsiString((CHAR const *) pv, count));
		RtlpConvertToUnicode( (CHAR const *) pv,
                                      count, CP_ACP,
                                      // Variants are in the system codepage
                                      (WCHAR **) &pchConvert,
                                      &count,
                                      pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                // 'pv' always has the ready-to-serialize string.
		pv = pchConvert;

                // This unicode string may require byte-swapping.
                CBBYTESWAP( sizeof(WCHAR) );
	    }
	}   // else if (pvar->vt == VT_LPSTR)

	else
	{
            // If this is a BSTR, increment the count to include
            // the string terminator.
	    if (pvar->vt == VT_BSTR)
	    {
		count = BSTRLEN(pv);

                // Verify that the input BSTR is terminated.
		if (pvar->bstrVal[count/sizeof(OLECHAR)] != ((OLECHAR)'\0'))
		{
		    PROPASSERT(pvar->bstrVal[count/sizeof(OLECHAR)] == OLESTR('\0'));
		    StatusInvalidParameter(pstatus,
			"RtlConvertVariantToProperty: bad BSTR null char");
                    goto Exit;
		}

                // Increment the count to include the terminator.
		count += sizeof(OLECHAR);
	    }
	    else
	    {
		count = (Prop_wcslen((WCHAR *) pv) + 1) * sizeof(WCHAR);
		PROPASSERT(IsUnicodeString((WCHAR const *) pv, count));
	    }

            // See if this BSTR requires conversion to the propset's code page      

            if (CodePage != CP_WINUNICODE   // Ansi property set
                &&
                OLECHAR_IS_UNICODE      // BSTRs are Unicode
                )
	    {
                // A Unicode to Ansi conversion is required.

                PROPASSERT( IsUnicodeString( (WCHAR*)pv, count ));

		RtlpConvertToMultiByte(
				(WCHAR const *) pv,
				count,
				CodePage,
				&pchConvert,
				&count,
                                pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
		pv = pchConvert;
	    }
            else if (CodePage == CP_WINUNICODE   // Unicode property set,
                     &&
                     pvar->vt == VT_BSTR         // a BSTR property, and
                     &&
                     !OLECHAR_IS_UNICODE         // BSTRs are Ansi.
                )
            {
                // An Ansi to Unicode conversion is required.

                PROPASSERT(IsAnsiString((CHAR const *) pv, count));
                PROPASSERT(sizeof(OLECHAR) == sizeof(CHAR));

                RtlpConvertToUnicode(
                    (CHAR const *) pv,
                    count,
                    CP_ACP, // In-mem BSTR is in system CP
                    (WCHAR **) &pchConvert,
                    &count,
                    pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                // 'pv' always holds the ready-to-serialize value.
                pv = pchConvert;

                // This unicode string may require swapping.
                CBBYTESWAP( sizeof(WCHAR) );
            }

            else
            if (CodePage == CP_WINUNICODE)
            {
                // No conversion is required (i.e., both 'pv' and the 
                // property set are Unicode).  But we must remember
                // to perform a byte-swap (if byte-swapping is necessary).

                CBBYTESWAP( sizeof(WCHAR) );
            }
	}   // if (pv == NULL) ... else if ... else

        // Validate 'pv'.

#ifdef LITTLEENDIAN
        PROPASSERT( NULL == pv
                    ||
                    CodePage == CP_WINUNICODE && IsUnicodeString((WCHAR*)pv, count)
                    ||
                    CodePage != CP_WINUNICODE && IsAnsiString((CHAR*)pv, count) );
#endif

	cb = count;
	pcount = &count;
	break;

    case VT_LPWSTR:
	AssertStringField(pwszVal);		// VT_LPWSTR
	PROPASSERT(
	    pvar->pwszVal == NULL ||
	    IsUnicodeString(pvar->pwszVal, MAXULONG));

        pv = pvar->pwszVal;
	if (pv == NULL)
	{
	    count = 0;
	    fCheckNullSource = TRUE;
	}
	else
	{
            // Calculate the [length] field.
	    count = Prop_wcslen(pvar->pwszVal) + 1;

            // If byte-swapping will be necessary to get to the serialized
            // format, we'll do so in units of WCHARs.

            CBBYTESWAP( sizeof(WCHAR) );
	}

	cb = count * sizeof(WCHAR);
	pcount = &count;
	break;

    // Vector properties:

#ifdef PROPVAR_VT_I1
    case VT_VECTOR | VT_I1:
	AssertByteVector(cac);		// VT_I1
#endif
    case VT_VECTOR | VT_UI1:
	AssertByteVector(caub);		// VT_UI1
	pcount = &pvar->caub.cElems;
	cb = *pcount * sizeof(pvar->caub.pElems[0]);
	pv = pvar->caub.pElems;
	break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
	AssertShortVector(cai);		// VT_I2
	AssertShortVector(caui);        // VT_UI2
	AssertShortVector(cabool);      // VT_BOOL
	pcount = &pvar->cai.cElems;
	cb = *pcount * sizeof(pvar->cai.pElems[0]);
	pv = pvar->cai.pElems;

        // If swapping, swap as WORDs
        CBBYTESWAP(sizeof(pvar->cai.pElems[0]));
	break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
	AssertLongVector(cal);		// VT_I4
	AssertLongVector(caul);		// VT_UI4
	AssertLongVector(caflt);        // VT_R4
	AssertLongVector(cascode);      // VT_ERROR
	pcount = &pvar->cal.cElems;
	cb = *pcount * sizeof(pvar->cal.pElems[0]);
	pv = pvar->cal.pElems;

        // If swapping, swap as DWORDs
        CBBYTESWAP(sizeof(pvar->cal.pElems[0]));
	break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_FILETIME:
	AssertLongLongVector(cah);      // VT_I8
	AssertLongLongVector(cauh);     // VT_UI8
	AssertLongLongVector(cafiletime);// VT_FILETIME
	pcount = &pvar->cah.cElems;
	cb = *pcount * sizeof(pvar->cah.pElems[0]);
	pv = pvar->cah.pElems;

        // If swapping, swap as DWORDs
        CBBYTESWAP(sizeof(DWORD));
	break;

    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
	AssertLongLongVector(cadbl);    // VT_R8
	AssertLongLongVector(cacy);     // VT_CY
	AssertLongLongVector(cadate);   // VT_DATE
	pcount = &pvar->cah.cElems;
	cb = *pcount * sizeof(pvar->cadbl.pElems[0]);
	pv = pvar->cadbl.pElems;

        // If swapping, swap as LONGLONGs (8 bytes)
        CBBYTESWAP(sizeof(pvar->cadbl.pElems[0]));
	break;


    case VT_VECTOR | VT_CLSID:
	AssertVarVector(cauuid, sizeof(GUID));
	pcount = &pvar->cauuid.cElems;
	cb = *pcount * sizeof(pvar->cauuid.pElems[0]);
	pv = pvar->cauuid.pElems;

        // If swapping, special handling is required.
        CBBYTESWAP( CBBYTESWAP_UID );
	break;

    case VT_VECTOR | VT_CF:
	cbch = sizeof(CLIPDATA);
	cbchdiv = sizeof(BYTE);
	goto stringvector;

    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
	cbchdiv = cbch = sizeof(BYTE);
	goto stringvector;

    case VT_VECTOR | VT_LPWSTR:
	cbchdiv = cbch = sizeof(WCHAR);
	goto stringvector;

    case VT_VECTOR | VT_VARIANT:
	cbch = MAXULONG;
stringvector:
	AssertVarVector(caclipdata, sizeof(CLIPDATA));	// VT_CF
	AssertStringVector(cabstr);                     // VT_BSTR
	AssertStringVector(calpstr);			// VT_LPSTR
	AssertStringVector(calpwstr);			// VT_LPWSTR
	AssertVarVector(capropvar, sizeof(PROPVARIANT));// VT_VARIANT

	pcount = &pvar->calpstr.cElems;
	ppv = (VOID **) pvar->calpstr.pElems;
	break;

    default:
	DebugTrace(0, DEBTRACE_ERROR, (
	    "RtlConvertVariantToProperty: unsupported vt=%x\n",
	    pvar->vt));
	StatusInvalidParameter(pstatus, "RtlConvertVariantToProperty: bad type");
        goto Exit;

    }   // switch (pvar->vt)

    // At this point we've analyzed the PropVariant, and stored
    // information about it in various local variables.  Now we
    // can use this information to serialize the propvar.

    // Early exit if this is an illegal type.

    if (fIllegalType)
    {
	StatusInvalidParameter(pstatus, "RtlConvertVariantToProperty: Illegal VarType");
        goto Exit;
    }

    // Set pbdst to point into the serialization buffer, or to 
    // NULL if there is no such buffer.

    if (pprop == NULL)
    {
	pbdst = NULL;
    }
    else
    {
	pbdst = pprop->rgb;
    }

    // Is this a Vector of Strings/Variants/CFs?
    if (cbch != 0)
    {
        // Yes.

	ULONG cElems;

	PROPASSERT(pcount != NULL);
	PROPASSERT(*pcount == 0 || ppv != NULL);
        PROPASSERT(0 == cbByteSwap);

	// Start calculating the serialized size.  Include the sizes
        // of the VT & element count.

	cb = sizeof(ULONG) + sizeof(ULONG);

        // Is this a Variant Vector?
	if (cbch != MAXULONG)
	{
	    // No.  Include each element's length field.
	    cb += *pcount * sizeof(ULONG);
	}

        // Is there room in the caller's buffer for everything
        // counted so far?
	if (*pcb < cb)
	{
            // No - we won't serialize the data, but we will continue
            // to calculate cb.
	    pprop = NULL;
	}

        // Write the count of vector elements.
	if (pprop != NULL)
	{
	    *(ULONG *) pbdst = PropByteSwap((ULONG) *pcount);
	    pbdst += sizeof(ULONG);
	}

        // Walk through the vector and write the elements.

	for (cElems = *pcount; cElems > 0; cElems--)
	{
	    ULONG cbcopy = 0;

            // Switch on the size of the element.
	    switch (cbch)
	    {
                //
                // VT_VARIANT
                //
		case MAXULONG:
		    cbcopy = MAXULONG;

                    // Perform a recursive serialization
		    RtlConvertVariantToProperty(
				(PROPVARIANT *) ppv,
				CodePage,
				NULL,
				&cbcopy,
				PID_ILLEGAL,
				TRUE,
                                pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

		    break;

                //
                //  VT_CF
                //
		case sizeof(CLIPDATA):

                    // We copy cbSize-sizeof(ulClipFmt) bytes.

                    if( ((CLIPDATA *) ppv)->cbSize < sizeof(ULONG) )
                    {
                        StatusInvalidParameter(pstatus, "RtlConvertVariantToProperty: short cbSize on VT_CF");
                        goto Exit;
                    }
                    else
                    {
                        cbcopy = CBPCLIPDATA( *(CLIPDATA*) ppv );
                    }

                    // But increment cb to to include sizeof(ulClipFmt)
                    cb += sizeof(ULONG);
		    break;

                //
                //  VT_LPWSTR
                //
		case sizeof(WCHAR):
		    if (*ppv != NULL)
		    {
			PROPASSERT(IsUnicodeString((WCHAR const *) *ppv, MAXULONG));
			cbcopy = (Prop_wcslen((WCHAR *) *ppv) + 1) * sizeof(WCHAR);
			pv = *ppv;

                        // If byte-swapping is necessary, swap in units of WCHARs
                        CBBYTESWAP( sizeof(WCHAR) );

		    }
		    break;

                //
                //  VT_LPSTR/VT_BSTR
                //
		default:
		    PROPASSERT(cbch == sizeof(BYTE));
		    PROPASSERT(pchConvert == NULL);
		    if (*ppv != NULL)
		    {
			pv = *ppv;

                        // Is this a BSTR?
			if (pvar->vt == (VT_VECTOR | VT_BSTR))
			{
                            // Initialize the # bytes to copy.
			    cbcopy = BSTRLEN(pv);

                            // Verify that the BSTR is terminated.
			    if (((OLECHAR const *) pv)
                                [cbcopy/sizeof(OLECHAR)] != ( (OLECHAR)'\0'))
			    {
				PROPASSERT(
                                    ((OLECHAR const *) pv)
                                    [cbcopy/sizeof(OLECHAR)] == ((OLECHAR)'\0'));
				StatusInvalidParameter(
                                    pstatus,
                                    "RtlConvertVariantToProperty: bad BSTR"
                                    "array null char"); 
                                goto Exit;
			    }

                            // Also copy the string terminator.
			    cbcopy += sizeof(OLECHAR);

                            // If the propset and the BSTR are in mismatched
                            // codepages (one's Unicode, the other's Ansi),
                            // correct the BSTR now.  In any case, the correct
                            // string is in 'pv'.

			    if (CodePage != CP_WINUNICODE   // Ansi property set
                                &&
                                OLECHAR_IS_UNICODE)         // Unicode BSTR
			    {
                                PROPASSERT(IsUnicodeString((WCHAR*)pv, cbcopy));

				RtlpConvertToMultiByte(
						(WCHAR const *) pv,
						cbcopy,
						CodePage,
						&pchConvert,
						&cbcopy,
                                                pstatus);
                                if( !NT_SUCCESS(*pstatus) ) goto Exit;

				pv = pchConvert;
			    }

                            else
                            if (CodePage == CP_WINUNICODE   // Unicode property set
                                &&
                                !OLECHAR_IS_UNICODE)        // Ansi BSTRs
                            {
                                PROPASSERT(IsAnsiString((CHAR const *) pv, cbcopy));

                                RtlpConvertToUnicode(
		                                (CHAR const *) pv,
		                                cbcopy,
		                                CP_ACP, // In-mem BSTR is in system CP
		                                (WCHAR **) &pchConvert,
		                                &cbcopy,
                                                pstatus);
                                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                // The Unicode string must have the proper byte order
                                CBBYTESWAP( sizeof(WCHAR) );

                                pv = pchConvert;

                            }

                            else
                            if (CodePage == CP_WINUNICODE )
                            {
                                // Both the BSTR and the property set are Unicode.
                                // No conversion is required, but byte-swapping
                                // is (if byte-swapping is enabled).

                                CBBYTESWAP( sizeof(WCHAR) );
                            }

			}   // if (pvar->vt == (VT_VECTOR | VT_BSTR))

                        // Otherwise it's an LPSTR
			else
			{
			    PROPASSERT(IsAnsiString((char const *) pv, MAXULONG));
			    PROPASSERT(pvar->vt == (VT_VECTOR | VT_LPSTR));
			    cbcopy = strlen((char *) pv) + 1; // + trailing null

			    if (CodePage == CP_WINUNICODE)
			    {
				PROPASSERT(IsAnsiString(
						(CHAR const *) pv,
						cbcopy));
				RtlpConvertToUnicode(
						(CHAR const *) pv,
						cbcopy,
						CP_ACP,
						(WCHAR **) &pchConvert,
						&cbcopy,
                                                pstatus);
                                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                // If byte-swapping, we'll do so with the WCHARs
                                CBBYTESWAP( sizeof(WCHAR) );

				pv = pchConvert;
			    }   
			}   // if (pvar->vt == (VT_VECTOR | VT_BSTR)) ... else
		    }   // if (*ppv != NULL)

                    // In the end, pv should be in the codepage of
                    // the property set.

#ifdef LITTLEENDIAN
                    PROPASSERT( NULL == pv
                                ||
                                CodePage == CP_WINUNICODE && IsUnicodeString((WCHAR*)pv, cbcopy)
                                ||
                                CodePage != CP_WINUNICODE && IsAnsiString((CHAR*)pv, cbcopy));
#endif

		    break;

	    }   // switch (cbch)
	    
            // Add the size of this vector element to the property total
	    cb += DwordAlign(cbcopy);

            // Will there be enough room for this vector element?

	    if (*pcb < cb)
	    {
                // No - we'll continue (thus calculating the total size
                // necessary), but we won't write to the caller's buffer.
		pprop = NULL;
	    }

            // Is this a vector of Variants?

	    if (cbch == MAXULONG)
	    {
                // Yes.  Convert this variant.
		if (pprop != NULL)
		{
		    RtlConvertVariantToProperty(
				(PROPVARIANT *) ppv,
				CodePage,
				(SERIALIZEDPROPERTYVALUE *) pbdst,
				&cbcopy,
				PID_ILLEGAL,
				TRUE,
                                pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;
		    pbdst += cbcopy;
		}
		ppv = (VOID **) Add2Ptr(ppv, sizeof(PROPVARIANT));
	    }   // if (cbch == MAXULONG)

	    else
	    {
                // This is a vector of something other than Variants.

		PROPASSERT(
		    cbch == sizeof(BYTE) ||
		    cbch == sizeof(WCHAR) ||
		    cbch == sizeof(CLIPDATA));

		PROPASSERT(cbchdiv == sizeof(BYTE) || cbchdiv == sizeof(WCHAR));

                // Are we writing the serialized property?
		if (pprop != NULL)
		{
                    ULONG cbVectElement;

                    // Calculate the length of the vector element.
                    cbVectElement = (ULONG) cbcopy/cbchdiv;

                    // Is this a ClipData?
		    if (cbch == sizeof(CLIPDATA))
		    {
                        // Adjust the length to include sizeof(ulClipFmt)
                        cbVectElement += sizeof(ULONG);

                        // Write the vector element length.
                        *(ULONG *) pbdst = PropByteSwap( cbVectElement );

                        // Advance pbdst & write the clipboard format.
			pbdst += sizeof(ULONG);
			*(ULONG *) pbdst = PropByteSwap( ((CLIPDATA *) ppv)->ulClipFmt );
		    }
                    else    // This isn't a ClipFormat vector element.
                    {
                        // Write the vector element length.
		        *(ULONG *) pbdst = PropByteSwap( cbVectElement );
                    }

                    // Advance pbdst & write the property data.
		    pbdst += sizeof(ULONG);
		    RtlCopyMemory(
				pbdst,
				cbch == sizeof(CLIPDATA)?
				  ((CLIPDATA *) ppv)->pClipData :
				  pv,
				cbcopy);

                    // Zero out the pad bytes.
		    RtlZeroMemory(pbdst + cbcopy, DwordRemain(cbcopy));

                    // If byte-swapping is necessary, do so now.
                    PBSBuffer( pbdst, DwordAlign(cbcopy), cbByteSwap );

                    // Advance pbdst to the next property.
		    pbdst += DwordAlign(cbcopy);

		}   // if (pprop != NULL)

                // Advance ppv to point into the PropVariant at the
                // next element in the array.

		if (cbch == sizeof(CLIPDATA))
		{
		    ppv = (VOID **) Add2Ptr(ppv, sizeof(CLIPDATA));
		}
		else
		{
		    ppv++;
		    delete [] pchConvert;
		    pchConvert = NULL;
		}
	    }   // if (cbch == MAXULONG) ... else
	}   // for (cElems = *pcount; cElems > 0; cElems--)
    }   // if (cbch != 0)    // STRING/VARIANT/CF VECTOR property

    else
    {
        // This isn't a vector, or if it is, the elements
        // aren't Strings, Variants, or CFs.

	ULONG cbCopy = cb;

        // Adjust cb (the total serialized buffer size) for
        // pre-data.

	if (pvar->vt != VT_EMPTY)
	{   // Allow for the VT
	    cb += sizeof(ULONG);
	}
	if (pcount != NULL)
	{   // Allow for the count field
	    cb += sizeof(ULONG);
	}
	if (pclipfmt != NULL)
	{   // Allow for the ulClipFmt field.
	    cb += sizeof(ULONG);
	}

        // Is there room in the caller's buffer?
	if (*pcb < cb)
	{   // No - calculate cb but don't write anything.
	    pprop = NULL;
	}

        // 'pv' should point to the source data.  If it does, then
        // we'll copy it into the property set.  If it doesn't but
        // it should, then we'll report an error.

	if (pv != NULL || fCheckNullSource)
	{
	    ULONG cbZero = DwordRemain(cbCopy);

            // Do we have a destination (propset) buffer?

	    if (pprop != NULL)
	    {
                // Does this property have a count field?
		if (pcount != NULL)
		{
                    // Write the count & advance pbdst
		    *(ULONG *) pbdst = PropByteSwap( *pcount );
		    pbdst += sizeof(ULONG);
		}

                // Is this a VT_CF?
		if (pclipfmt != NULL)
		{
                    // Write the ClipFormat & advance pbdst
		    *(ULONG *) pbdst = PropByteSwap( (DWORD) *pclipfmt );
		    pbdst += sizeof(ULONG);
		}
	    }

            // Are we missing the source data?
	    if (pv == NULL)
	    {
		// The Source pointer is NULL.  If cbCopy != 0, the passed
		// VARIANT is not properly formed.

		if (cbCopy != 0)
		{
		    StatusInvalidParameter(pstatus, "RtlConvertVariantToProperty: bad NULL");
                    goto Exit;
		}
	    }
	    else if (pprop != NULL)
	    {
                // We have a non-NULL source & destination.
                // First, copy the bytes from the former to the latter.

		RtlCopyMemory(pbdst, pv, cbCopy);

                // Then, if necessary, swap the bytes in the property
                // set (leaving the PropVariant bytes untouched).

                PBSBuffer( (VOID*) pbdst, cbCopy, cbByteSwap );
	    }

            // Did we write the serialization?
	    if (pprop != NULL)
	    {
                // Zero the padding bytes.
		RtlZeroMemory(pbdst + cbCopy, cbZero);

		// Canonicalize VARIANT_BOOLs.  We do this here because
		// we don't want to muck with the caller's buffer directly.

		if ((pvar->vt & ~VT_VECTOR) == VT_BOOL)
		{
		    VARIANT_BOOL *pvb = (VARIANT_BOOL *) pbdst;
		    VARIANT_BOOL *pvbEnd = &pvb[cbCopy/sizeof(*pvb)];

		    while (pvb < pvbEnd)
		    {
			if (*pvb
                            &&
                            PropByteSwap(*pvb) != VARIANT_TRUE)
			{
			    DebugTrace(0, DEBTRACE_ERROR, (
				"Patching VARIANT_TRUE value: %hx --> %hx\n",
				*pvb,
				VARIANT_TRUE));

                            *pvb = PropByteSwap( (VARIANT_BOOL) VARIANT_TRUE );
			}
			pvb++;
		    }
		}
	    }   // if (pprop != NULL)
	}
    }   // if (cbch != 0) ... else    // non - STRING/VARIANT/CF VECTOR property

    // Set the VT in the serialized buffer now that all size
    // checks completed.

    if (pprop != NULL && pvar->vt != VT_EMPTY)
    {
        // When byte-swapping the VT, treat it as a DWORD
        // (it's a WORD in the PropVariant, but a DWORD when
        // serialized).

	pprop->dwType = PropByteSwap( (DWORD) pvar->vt );
    }

    // Update the caller's copy of the total size.
    *pcb = DwordAlign(cb);

Exit:

    delete [] pchConvert;
    return(pprop);

}


//+---------------------------------------------------------------------------
// Function:    RtlConvertPropertyToVariant, private
//
// Synopsis:    Convert a SERIALIZEDPROPERTYVALUE to a PROPVARIANT
//
// Arguments:   [pprop]         -- pointer to SERIALIZEDPROPERTYVALUE
//              [PointerDelta]	-- adjustment to pointers to get user addresses
//              [fConvertNullStrings] -- map NULL strings to empty strings
//              [CodePage]	-- property set codepage
//              [pvar]          -- pointer to PROPVARIANT
//              [pma]		-- caller's memory allocation routine
//              [pstatus]       -- pointer to NTSTATUS code
//
//---------------------------------------------------------------------------

#define ADJUSTPOINTER(ptr, delta, type)
VOID
RtlConvertPropertyToVariant( IN SERIALIZEDPROPERTYVALUE const *pprop,
                             IN USHORT CodePage,
                             OUT PROPVARIANT *pvar,
                             IN PMemoryAllocator *pma,
                             OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    //  ------
    //  Locals
    //  ------

    // Buffers which must be freed before exiting.
    CHAR *pchConvert = NULL, *pchByteSwap = NULL;

    VOID **ppv = NULL;
    VOID *pv = NULL;
    ULONG cbskip = sizeof(ULONG);
    ULONG cb = 0;

    // Size of byte-swapping units (must be signed).
    INT cbByteSwap = 0;

    BOOLEAN fPostAllocInit = FALSE;
    BOOLEAN fNullLegal = (BOOLEAN) ( (PropByteSwap(pprop->dwType) & VT_VECTOR) != 0 );
    const BOOLEAN fConvertToEmpty = FALSE;

    //  ---------------------------------------------------------
    //  Based on the VT, calculate cch, ppv, pv, cbskip,
    //  cb, fPostAllocInit, fNullLegal, & fConvertToEmpty
    //  ---------------------------------------------------------

    // Set the VT in the PropVariant.  Note that in 'pprop' it's a
    // DWORD, but it's a WORD in 'pvar'.

    pvar->vt = (VARTYPE) PropByteSwap(pprop->dwType);

    switch (pvar->vt)
    {
	case VT_EMPTY:
	case VT_NULL:
	    break;

#ifdef PROPVAR_VT_I1
        case VT_I1:
            AssertByteField(cVal);          // VT_I1
#endif
	case VT_UI1:
	    AssertByteField(bVal);          // VT_UI1
	    cb = sizeof(pvar->bVal);
	    pv = &pvar->bVal;
	    break;

	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
	    AssertShortField(iVal);         // VT_I2
	    AssertShortField(uiVal);        // VT_UI2
	    AssertShortField(boolVal);      // VT_BOOL
	    cb = sizeof(pvar->iVal);
	    pv = &pvar->iVal;

            // If swapping, swap as a WORD
            CBBYTESWAP(cb);
	    break;

	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_ERROR:
	    AssertLongField(lVal);          // VT_I4
	    AssertLongField(ulVal);         // VT_UI4
	    AssertLongField(fltVal);        // VT_R4
	    AssertLongField(scode);         // VT_ERROR
	    cb = sizeof(pvar->lVal);
	    pv = &pvar->lVal;

            // If swapping, swap as a DWORD
            CBBYTESWAP(cb);
	    break;

	case VT_I8:
	case VT_UI8:
	case VT_FILETIME:
	    AssertLongLongField(hVal);		// VT_I8
	    AssertLongLongField(uhVal);		// VT_UI8
	    AssertLongLongField(filetime);	// VT_FILETIME
	    cb = sizeof(pvar->hVal);
	    pv = &pvar->hVal;

            // If swapping, swap as a pair of DWORDs
            CBBYTESWAP(sizeof(DWORD));
	    break;

	case VT_R8:
	case VT_CY:
	case VT_DATE:
	    AssertLongLongField(dblVal);	// VT_R8
	    AssertLongLongField(cyVal);		// VT_CY
	    AssertLongLongField(date);		// VT_DATE
	    cb = sizeof(pvar->dblVal);
	    pv = &pvar->dblVal;

            // If swapping, swap as a LONGLONG
            CBBYTESWAP(cb);
	    break;

	case VT_CLSID:
	    AssertStringField(puuid);		// VT_CLSID
	    cb = sizeof(GUID);
	    ppv = (VOID **) &pvar->puuid;
	    cbskip = 0;

            // If swapping, special handling is required
            CBBYTESWAP( CBBYTESWAP_UID );
	    break;

	case VT_CF:

            // Allocate a CLIPDATA buffer
	    pvar->pclipdata = (CLIPDATA *) pma->Allocate(sizeof(CLIPDATA));
	    if (pvar->pclipdata == NULL)
	    {
		StatusKBufferOverflow(pstatus, "RtlConvertPropertyToVariant: no memory for CF");
                goto Exit;
	    }
            RtlZeroMemory( pvar->pclipdata, sizeof(CLIPDATA) );

            // Set the size (includes sizeof(ulClipFmt))
	    pvar->pclipdata->cbSize = PropByteSwap( ((CLIPDATA *) pprop->rgb)->cbSize );
            if( pvar->pclipdata->cbSize < sizeof(pvar->pclipdata->ulClipFmt) )
            {
                StatusError(pstatus, "RtlConvertPropertyToVariant:  Invalid VT_CF cbSize",
                            STATUS_INTERNAL_DB_CORRUPTION);
                goto Exit;
            }

            // Set the # bytes-to-copy.  We can't use the CBPCLIPDATA macro
            // here because it assumes that the CLIPDATA parameter is correctly
            // byte-swapped.
	    cb = PropByteSwap( *(DWORD*) pprop->rgb ) - sizeof(pvar->pclipdata->ulClipFmt);

            // Set the ClipFormat itself.
	    pvar->pclipdata->ulClipFmt = PropByteSwap( ((CLIPDATA *) pprop->rgb)->ulClipFmt );

            // Prepare for the alloc & copy.  Put the buffer pointer
            // in pClipData, & skip the ulClipFmt in the copy.
	    ppv = (VOID **) &pvar->pclipdata->pClipData;
	    cbskip += sizeof(ULONG);

            // It's legal for cb to be 0.
            fNullLegal = TRUE;

            // Adjust to the user-mode pointer (Kernel only)
	    ADJUSTPOINTER(pvar->pclipdata, PointerDelta, CLIPDATA *);

	    break;

	case VT_BLOB:
	case VT_BLOB_OBJECT:
	    cb = pvar->blob.cbSize = PropByteSwap( *(ULONG *) pprop->rgb );
	    ppv = (VOID **) &pvar->blob.pBlobData;
	    fNullLegal = TRUE;
	    break;

	case VT_BSTR:
	case VT_LPSTR:
	    AssertStringField(bstrVal);		// VT_BSTR
	    AssertStringField(pszVal);		// VT_LPSTR

            // [length field] bytes should be allocated
	    cb = PropByteSwap( *(ULONG *) pprop->rgb );

            // When a buffer is allocated, it's pointer will go
            // in *ppv.
	    ppv = (VOID **) &pvar->pszVal;

            // Is this a non-empty string?
	    if (cb != 0)
	    {
                // Is the serialized value one that should be
                // an Ansi string in the PropVariant?

		if (pvar->vt == VT_LPSTR        // It's an LPSTR (always Ansi), or
                    ||
                    pvar->vt == VT_BSTR         // It's a BSTR and
                    &&
                    !OLECHAR_IS_UNICODE )       //    BSTRs are Ansi.
		{
                    // If the propset is Unicode, we must do a
                    // conversion to Ansi.

		    if (CodePage == CP_WINUNICODE)
		    {
                        WCHAR *pwsz = (WCHAR *) Add2ConstPtr(pprop->rgb, sizeof(ULONG));

                        // If necessary, swap the WCHARs.  'pwsz' will point to
                        // the correct (system-endian) string either way.  If an
                        // alloc is necessary, 'pchByteSwap' will point to the new
                        // buffer.

                        PBSInPlaceAlloc( &pwsz, (WCHAR**) &pchByteSwap, pstatus );
                        if( !NT_SUCCESS( *pstatus )) goto Exit;
			PROPASSERT(IsUnicodeString( pwsz, cb));

                        // Convert the properly-byte-ordered string in 'pwsz'
                        // into MBCS, putting the result in pchConvert.

			RtlpConvertToMultiByte(
				    pwsz,
				    cb,
				    CP_ACP,  // Use the system default codepage
				    &pchConvert,
				    &cb,
                                    pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
		    }
		}   // if (pvar->vt == VT_LPSTR) ...

                // Otherwise, even though this string may be
                // Ansi in the Property Set, it must be Unicode
                // in the PropVariant.

		else
		{
                    // If necessary, convert to Unicode

		    if (CodePage != CP_WINUNICODE)
		    {
			PROPASSERT(
			    IsAnsiString(
				    (CHAR const *)
					Add2ConstPtr(pprop->rgb, sizeof(ULONG)),
				    cb));

			RtlpConvertToUnicode(
				    (CHAR const *)
					Add2ConstPtr(pprop->rgb, sizeof(ULONG)),
				    cb,
				    CodePage,
				    (WCHAR **) &pchConvert,
				    &cb,
                                    pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

		    }   // if (CodePage != CP_WINUNICODE)
                    else
                    {
                        // The value is Unicode both the property set
                        // and the PropVariant.  If byte-swapping is
                        // necessary, we'll do so in units of WCHARs.

                        CBBYTESWAP( sizeof(WCHAR) );
                    }

		}   // if (pvar->vt == VT_LPSTR) ... else

                // If this is a BSTR property, verify that it is terminated
                // appropriately.

		if (VT_BSTR == pvar->vt)
		{
                    BSTR bstr = ( NULL == pchConvert )
                                ? (BSTR) Add2ConstPtr(pprop->rgb, sizeof(ULONG))
                                : (BSTR) pchConvert;

                    // On little-endian machines, validate the string.
#ifdef LITTLEENDIAN
                    PROPASSERT( IsOLECHARString( bstr, MAXULONG ));
#endif

                    // Validate the bstr.  Note that even though this bstr may
                    // be byte-swapped, this 'if' block still works because
                    // ByteSwap('\0') == ('\0').


                    if( (cb & (sizeof(OLECHAR) - 1)) != 0
                        &&
                        OLECHAR_IS_UNICODE
                        ||
                        bstr[cb/sizeof(OLECHAR) - 1] != ((OLECHAR)'\0') )
                    {
                        StatusError(pstatus, "RtlConvertPropertyToVariant:  Invalid BSTR Property",
                                     STATUS_INTERNAL_DB_CORRUPTION);
                        goto Exit;
                    }
		}   // if (VT_BSTR == pvar->vt)
	    }   // if (cb != 0)

	    fNullLegal = TRUE;
	    break;

	case VT_LPWSTR:
	    fNullLegal = TRUE;
	    AssertStringField(pwszVal);		// VT_LPWSTR
	    cb = PropByteSwap( *(ULONG *) pprop->rgb ) * sizeof(WCHAR);
	    ppv = (VOID **) &pvar->pwszVal;

            // If byte-swapping will be necessary, do so for the WCHARs
            CBBYTESWAP( sizeof(WCHAR) );

	    break;

#ifdef PROPVAR_VT_I1
	case VT_VECTOR | VT_I1:
            AssertByteVector(cac);              // VT_I1
#endif
	case VT_VECTOR | VT_UI1:
	    AssertByteVector(caub);		// VT_UI1
	    pvar->caub.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->caub.cElems * sizeof(pvar->caub.pElems[0]);
	    ppv = (VOID **) &pvar->caub.pElems;
	    break;

	case VT_VECTOR | VT_I2:
	case VT_VECTOR | VT_UI2:
	case VT_VECTOR | VT_BOOL:
	    AssertShortVector(cai);		// VT_I2
	    AssertShortVector(caui);		// VT_UI2
	    AssertShortVector(cabool);		// VT_BOOL
	    pvar->cai.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cai.cElems * sizeof(pvar->cai.pElems[0]);
	    ppv = (VOID **) &pvar->cai.pElems;

            // If swapping, swap as a WORD
            CBBYTESWAP(sizeof(pvar->cai.pElems[0]));
	    break;

	case VT_VECTOR | VT_I4:
	case VT_VECTOR | VT_UI4:
	case VT_VECTOR | VT_R4:
	case VT_VECTOR | VT_ERROR:
	    AssertLongVector(cal);		// VT_I4
	    AssertLongVector(caul);		// VT_UI4
	    AssertLongVector(caflt);		// VT_R4
	    AssertLongVector(cascode);		// VT_ERROR
	    pvar->cal.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cal.cElems * sizeof(pvar->cal.pElems[0]);
	    ppv = (VOID **) &pvar->cal.pElems;

            // If byte swapping, swap as DWORDs
            CBBYTESWAP(sizeof(pvar->cal.pElems[0]));
	    break;

	case VT_VECTOR | VT_I8:
	case VT_VECTOR | VT_UI8:
	case VT_VECTOR | VT_FILETIME:
	    AssertLongLongVector(cah);		// VT_I8
	    AssertLongLongVector(cauh);		// VT_UI8
	    AssertLongLongVector(cafiletime);	// VT_FILETIME
	    pvar->cah.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cah.cElems * sizeof(pvar->cah.pElems[0]);
	    ppv = (VOID **) &pvar->cah.pElems;

            // If byte swapping, swap as DWORDs
            CBBYTESWAP(sizeof(DWORD));
	    break;

	case VT_VECTOR | VT_R8:
	case VT_VECTOR | VT_CY:
	case VT_VECTOR | VT_DATE:
	    AssertLongLongVector(cadbl);	// VT_R8
	    AssertLongLongVector(cacy);		// VT_CY
	    AssertLongLongVector(cadate);	// VT_DATE
	    pvar->cadbl.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cadbl.cElems * sizeof(pvar->cadbl.pElems[0]);
	    ppv = (VOID **) &pvar->cadbl.pElems;

            // If byte swapping, swap as LONGLONGs
            CBBYTESWAP(sizeof(pvar->cah.pElems[0]));
	    break;


	case VT_VECTOR | VT_CLSID:
	    AssertVarVector(cauuid, sizeof(GUID));
	    pvar->cauuid.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cauuid.cElems * sizeof(pvar->cauuid.pElems[0]);
	    ppv = (VOID **) &pvar->cauuid.pElems;

            // If byte swapping, special handling is required.
            CBBYTESWAP( CBBYTESWAP_UID );
	    break;

	case VT_VECTOR | VT_CF:

            // Set the count of clipdatas
	    pvar->caclipdata.cElems = PropByteSwap( *(ULONG *) pprop->rgb );

            // How much should we allocate for caclipdata.pElems, & where
            // should that buffer pointer go?
	    cb = pvar->caclipdata.cElems * sizeof(pvar->caclipdata.pElems[0]);
	    ppv = (VOID **) &pvar->caclipdata.pElems;

            // We need to do work after pElems is allocated.
	    fPostAllocInit = TRUE;
	    break;

	case VT_VECTOR | VT_BSTR:
	case VT_VECTOR | VT_LPSTR:
	    AssertStringVector(cabstr);     // VT_BSTR
	    AssertStringVector(calpstr);    // VT_LPSTR

            // Put the element count in the PropVar
	    pvar->calpstr.cElems = PropByteSwap( *(ULONG *) pprop->rgb );

            // An array of cElems pointers should be alloced
	    cb = pvar->calpstr.cElems * sizeof(CHAR*);

            // Show where the array of pointers should go.
	    ppv = (VOID **) &pvar->calpstr.pElems;

            // Additional allocs will be necessary after the vector
            // is alloced.
	    fPostAllocInit = TRUE;

	    break;

	case VT_VECTOR | VT_LPWSTR:
	    AssertStringVector(calpwstr);	// VT_LPWSTR
	    pvar->calpwstr.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->calpwstr.cElems * sizeof(ULONG);
	    ppv = (VOID **) &pvar->calpwstr.pElems;
	    fPostAllocInit = TRUE;
	    break;

	case VT_VECTOR | VT_VARIANT:
	    AssertVariantVector(capropvar);	// VT_VARIANT
	    pvar->capropvar.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->capropvar.cElems * sizeof(PROPVARIANT);
	    ppv = (VOID **) &pvar->capropvar.pElems;
	    fPostAllocInit = TRUE;
     	    break;

	default:
	    DebugTrace(0, DEBTRACE_ERROR, (
		"RtlConvertPropertyToVariant: unsupported vt=%x\n",
		pvar->vt));
	    StatusInvalidParameter(pstatus, "RtlConvertPropertyToVariant: bad type");
            goto Exit;

    }   // switch (pvar->vt)

    //  ------------------------------------------------------
    //  We've now analyzed the serialized property and learned
    //  about it, now we can put it into the PropVariant.
    //  ------------------------------------------------------

    // Is this a simple, unaligned scalar?

    if (pv != NULL)
    {
        // Yes.  All we need to do is copy some bytes.
	PROPASSERT(pchConvert == NULL);
	RtlCopyMemory(pv, pprop->rgb, cb);

        // We also might need to byte-swap them (but only in the PropVar).
        PBSBuffer( pv, cb, cbByteSwap );
    }

    // Otherwise, we need to allocate memory, to which the
    // PropVariant will point.

    else if (ppv != NULL)
    {
	*ppv = NULL;

	if (!fConvertToEmpty && cb == 0)    // Kernel only
	{
	    if (!fNullLegal)
	    {
		StatusInvalidParameter(pstatus, "RtlConvertPropertyToVariant: bad NULL");
                goto Exit;
	    }
	}

        else
	{

	    PROPASSERT(cb != 0 || fConvertToEmpty);

            // Allocate the necessary buffer (which we figured out in the
            // switch above).  For vector properties, 
            // this will just be the pElems buffer at this point.
            // For singleton BSTR properties, we'll skip this allocate
            // altogether; they're allocated with SysStringAlloc.

            if( VT_BSTR != pvar->vt  )
            {
		*ppv = pma->Allocate(max(1, cb));
		if (*ppv == NULL)
		{
		    StatusKBufferOverflow(pstatus, "RtlConvertPropertyToVariant: no memory");
                    goto Exit;
		}
            }

            // Can we load the PropVariant with a simple copy?
	    if (!fPostAllocInit)
	    {
                // Yes - all we need is a copy (and an implicit
                // alloc for BSTRs).

                if (VT_BSTR == pvar->vt)
		{
                    // We do the copy with the OleAutomation routine
                    // (which does an allocation too).
                    // If byte-swapping is necessary, the switch block
                    // already took care of it, leaving the buffer in
                    // 'pchConvert'.

                    PROPASSERT( NULL == *ppv );
                    *ppv = (*UnicodeCallouts.pfnSysAllocString)(
                                            ( pchConvert != NULL )
                                                ? (OLECHAR *) pchConvert
                                                : (OLECHAR *) (pprop->rgb + cbskip) );
		    if (*ppv == NULL)
		    {
		        StatusKBufferOverflow(pstatus, "RtlConvertPropertyToVariant: no memory");
                        goto Exit;
		    }
		}
                else
                {
                    // Copy the property into the PropVariant.
		    RtlCopyMemory(
			    *ppv,
			    pchConvert != NULL?
				(BYTE const *) pchConvert : pprop->rgb + cbskip,
			    cb);

                }

                // If necessary, byte-swap the property (only in the PropVar).
                PBSBuffer( *ppv, cb, cbByteSwap );

	    }   // if (!fPostAllocInit)

	    else
	    {
                // We must do more than just a copy.
                // (Thus this is a vector of strings, variants, or CFs).

		ULONG cElems = pvar->calpstr.cElems;

                // Initialize the source pointer to point just beyond
                // the element count.

		BYTE const *pbsrc = pprop->rgb + sizeof(ULONG);

		// Zero all pointers in the pElems array for easy caller cleanup
		ppv = (VOID **) *ppv;
		RtlZeroMemory(ppv, cb);

                // Handle Variants, ClipFormats, & Strings separately.

		if (pvar->vt == (VT_VECTOR | VT_VARIANT))
		{
		    PROPVARIANT *pvarT = (PROPVARIANT *) ppv;

		    while (cElems-- > 0)
		    {
			ULONG cbelement;

			RtlConvertPropertyToVariant(
                            (SERIALIZEDPROPERTYVALUE const *) pbsrc,
                            CodePage,
                            pvarT,
                            pma,
                            pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                        
			cbelement = PropertyLength(
					(SERIALIZEDPROPERTYVALUE const *) pbsrc,
					MAXULONG,
					CPSS_VARIANTVECTOR,
                                        pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                        
			pbsrc += cbelement;
			pvarT++;
		    }
		}   // if (pvar->vt == (VT_VECTOR | VT_VARIANT))

		else if (pvar->vt == (VT_VECTOR | VT_CF))
		{
                    // Set pcd to &pElems[0]
		    CLIPDATA *pcd = (CLIPDATA *) ppv;

                    // Loop through pElems
		    while (cElems-- > 0)
		    {
                        // What is the size of the clipdata (including sizeof(ulClipFmt))?
                        pcd->cbSize = PropByteSwap( ((CLIPDATA *) pbsrc)->cbSize );
                        if( pcd->cbSize < sizeof(pcd->ulClipFmt) )
                        {
                            StatusError(pstatus, "RtlConvertPropertyToVariant:  Invalid VT_CF cbSize",
                                        STATUS_INTERNAL_DB_CORRUPTION);
                            goto Exit;
                        }

                        // How many bytes should we copy to pClipData?
			cb = CBPCLIPDATA( *pcd );

                        // Set the ClipFormat & advance pbsrc to the clipdata.
			pcd->ulClipFmt = PropByteSwap( ((CLIPDATA *) pbsrc)->ulClipFmt );
			pbsrc += 2 * sizeof(ULONG);

                        // Copy the ClipData into the PropVariant

			pcd->pClipData = NULL;
			if (cb > 0)
			{
                            // Get a buffer for the clip data.
			    pcd->pClipData = (BYTE *) pma->Allocate(cb);
			    if (pcd->pClipData == NULL)
			    {
				StatusKBufferOverflow(pstatus, "RtlConvertPropertyToVariant: no memory for CF[]");
                                goto Exit;
			    }

                            // Copy the clipdata into pElems[i].pClipData
			    RtlCopyMemory(pcd->pClipData, pbsrc, cb);
			    ADJUSTPOINTER(pcd->pClipData, PointerDelta, BYTE *);

			}   // if (cb > 0)

                        // Move pcd to &pElems[i+1], and advance the buffer pointer.
			pcd++;
			pbsrc += DwordAlign(cb);

		    }   // while (cElems-- > 0)
		}   // else if (pvar->vt == (VT_VECTOR | VT_CF))

		else    // This is a vector of some kind of string.
		{
                    // Assume that characters are CHARs
		    ULONG cbch = sizeof(char);

		    if (pvar->vt == (VT_VECTOR | VT_LPWSTR))
		    {
                        // Characters are WCHARs
			cbch = sizeof(WCHAR);

                        // If byte-swapping is enabled, LPWSTRs must have
                        // their WCHARs swapped.
                        CBBYTESWAP( sizeof(WCHAR) );
		    }

		    while (cElems-- > 0)
		    {
			ULONG cbcopy;

			cbcopy = cb = PropByteSwap( *((ULONG *) pbsrc) ) * cbch;
			pbsrc += sizeof(ULONG);
			pv = (VOID *) pbsrc;
			PROPASSERT(*ppv == NULL);
			PROPASSERT(pchConvert == NULL);

			if (fConvertToEmpty || cb != 0)
			{
                            // Do we have actual data to work with?
			    if (cb != 0)
			    {
                                // Special BSTR pre-processing ...
				if (pvar->vt == (VT_VECTOR | VT_BSTR))
				{
                                    // If the propset & in-memory BSTRs are of
                                    // different Unicode-ness, convert now.

				    if (CodePage != CP_WINUNICODE   // Ansi PropSet
                                        &&
                                        OLECHAR_IS_UNICODE )        // Unicode BSTRs
				    {
                                        PROPASSERT(IsAnsiString((CHAR*) pv, cb));
					RtlpConvertToUnicode(
						    (CHAR const *) pv,
						    cb,
						    CodePage,
						    (WCHAR **) &pchConvert,
						    &cbcopy,
                                                    pstatus);
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
					pv = pchConvert;
				    }

                                    else
                                    if (CodePage == CP_WINUNICODE   // Unicode PropSet
                                        &&
                                        !OLECHAR_IS_UNICODE )       // Ansi BSTRs
                                    {
                                        // If byte-swapping is necessary, the string from
                                        // the propset must be swapped before it can be
                                        // converted to MBCS.  If such a conversion
                                        // is necessary, a new buffer is alloced and 
                                        // put in pchByteSwap.  Either way, 'pv' points
                                        // to the correct string.

                                        PBSInPlaceAlloc( (WCHAR**) &pv,
                                                         (WCHAR**) &pchByteSwap,
                                                         pstatus );
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
			                PROPASSERT(IsUnicodeString((WCHAR*)pv, cb));

                                        // Convert the Unicode string from the property
                                        // set to Ansi.

			                RtlpConvertToMultiByte(
				                    (WCHAR const *) pv,
				                    cb,
				                    CP_ACP,  // Use the system default codepage
				                    &pchConvert,
				                    &cbcopy,
                                                    pstatus);
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                        // 'pv' always has the correct string.
                                        pv = pchConvert;
                                    }
                                    else
                                    if (CodePage == CP_WINUNICODE)
                                    {
                                        // Both the BSTR is unicode in the property set,
                                        // and must remain unicode in the PropVariant.
                                        // But byte-swapping may still be necessary.

                                        CBBYTESWAP( sizeof(WCHAR) );
                                    }
                                                            

#ifdef LITTLEENDIAN
                                    PROPASSERT( IsOLECHARString((BSTR)pv, cbcopy ));
#endif
                                    // Verify that the BSTR is valid.
                                    if( (cbcopy & (sizeof(OLECHAR)-1)) != 0
                                        &&
                                        OLECHAR_IS_UNICODE
                                        ||
                                        ((OLECHAR const *)
                                         pv)[cbcopy/sizeof(OLECHAR) - 1] !=
                                        ((OLECHAR)'\0') )
                                    {
                                        StatusError(
                                            pstatus, 
                                            "RtlConvertPropertyToVariant:"
                                            "  Invalid BSTR element",
                                            STATUS_INTERNAL_DB_CORRUPTION);
                                        goto Exit;
                                    }

				}   // if (pvar->vt == (VT_VECTOR | VT_BSTR))

                                // Special LPSTR pre-processing
				else if (pvar->vt == (VT_VECTOR | VT_LPSTR))
				{
                                    // LPSTRs are always Ansi.  If the string
                                    // is Unicode in the propset, convert now.

				    if (CodePage == CP_WINUNICODE)
				    {
                                        // If byte-swapping is necessary, the string from
                                        // the propset must be swapped before it can be
                                        // converted to MBCS.  If such a conversion
                                        // is necessary, a new buffer is alloced and 
                                        // put in pchByteSwap.  Either way, 'pv' points
                                        // to the correct string.

                                        PBSInPlaceAlloc( (WCHAR**) &pv, (WCHAR**) &pchByteSwap,
                                                      pstatus );
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
					PROPASSERT(IsUnicodeString((WCHAR*)pv, cb));

                                        // Convert to Ansi.
					RtlpConvertToMultiByte(
						    (WCHAR const *) pv,
						    cb,
						    CP_ACP,     // Use the system default codepage
						    &pchConvert,
						    &cbcopy,
                                                    pstatus);
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                        pv = pchConvert;
				    }

                                    PROPASSERT( IsAnsiString( (CHAR const *)pv, cbcopy ));
				}   // else if (pvar->vt == (VT_VECTOR | VT_LPSTR))
			    }   // if (cb != 0)


                            // Allocate memory in the PropVariant and copy
                            // the string.

                            if( (VT_BSTR | VT_VECTOR) == pvar->vt )
                            {
                                // For BSTRs, the allocate/copy is performed
                                // by SysStringAlloc.

                                *ppv = (*UnicodeCallouts.pfnSysAllocString)( (BSTR) pv );
				if (*ppv == NULL)
				{
				    StatusKBufferOverflow(pstatus, "RtlConvertPropertyToVariant: no memory for BSTR element");
                                    goto Exit;
				}

                                // The BSTR length should be the property length
                                // minus the NULL.
                                PROPASSERT( BSTRLEN(*ppv) == cbcopy - sizeof(OLECHAR) );

                            }   // if( VT_BSTR == pvar->vt )

                            else
                            {
                                // Allocate a buffer in the PropVariant
				*ppv = pma->Allocate(max(1, cbcopy));
				if (*ppv == NULL)
				{
				    StatusKBufferOverflow(pstatus, "RtlConvertPropertyToVariant: no memory for string element");
                                    goto Exit;
				}

                                // Copy from the propset buffer to the PropVariant
				RtlCopyMemory(*ppv, pv, cbcopy);

                            }   // if( VT_BSTR == pvar->vt ) ... else

                            // If necessary, byte-swap in the PropVariant to get
                            // the proper byte-ordering.
                            PBSBuffer( *ppv, cbcopy, cbByteSwap );

                            // Adjust the PropVar element ptr to user-space (kernel only)
			    ADJUSTPOINTER(*ppv, PointerDelta, VOID *);

                            // Move, within the propset buffer, to the
                            // next element in the vector.
			    pbsrc += DwordAlign(cb);

                            // Delete the temporary buffers

                            delete[] pchByteSwap;
                            pchByteSwap = NULL;

			    delete [] pchConvert;
			    pchConvert = NULL;

			}   // if (fConvertToEmpty || cb != 0)

                        // Move, within the PropVariant, to the next
                        // element in the vector.
			ppv++;

		    }   // while (cElems-- > 0)
		}   // else if (pvar->vt == (VT_VECTOR | VT_CF)) ... else
	    }   // if (!fPostAllocInit) ... else

	    ADJUSTPOINTER(*ppvK, PointerDelta, VOID *);

	}   // if (!fConvertToEmpty && cb == 0) ... else
    }   // else if (ppv != NULL)

Exit:

    delete[] pchByteSwap;
    delete [] pchConvert;
}


//+---------------------------------------------------------------------------
// Function:    CleanupVariants, private
//
// Synopsis:    Free all memory used by an array of PROPVARIANT
//
// Arguments:   [pvar]          -- pointer to PROPVARIANT
//              [cprop]         -- property count
//              [pma]		-- caller's memory free routine
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CleanupVariants(
    IN PROPVARIANT *pvar,
    IN ULONG cprop,
    IN PMemoryAllocator *pma)
{
    while (cprop-- > 0)
    {
	VOID *pv = NULL;
	VOID **ppv = NULL;

	ULONG cElems;

	switch (pvar->vt)
	{
	case VT_CF:
	    pv = pvar->pclipdata;
	    if (pv != NULL && pvar->pclipdata->pClipData)
	    {
		pma->Free(pvar->pclipdata->pClipData);
	    }
	    break;

	case VT_BLOB:
	case VT_BLOB_OBJECT:
	    pv = pvar->blob.pBlobData;
	    break;

	case VT_BSTR:
	case VT_CLSID:
	case VT_LPSTR:
	case VT_LPWSTR:
	    AssertStringField(puuid);		// VT_CLSID
	    AssertStringField(bstrVal);		// VT_BSTR
	    AssertStringField(pszVal);		// VT_LPSTR
	    AssertStringField(pwszVal);		// VT_LPWSTR
	    pv = pvar->pszVal;
	    break;

	// Vector properties:

#ifdef PROPVAR_VT_I1
	case VT_VECTOR | VT_I1:
	    AssertByteVector(cac);			// VT_I1
#endif
	case VT_VECTOR | VT_UI1:
	case VT_VECTOR | VT_I2:
	case VT_VECTOR | VT_UI2:
	case VT_VECTOR | VT_BOOL:
	case VT_VECTOR | VT_I4:
	case VT_VECTOR | VT_UI4:
	case VT_VECTOR | VT_R4:
	case VT_VECTOR | VT_ERROR:
	case VT_VECTOR | VT_I8:
	case VT_VECTOR | VT_UI8:
	case VT_VECTOR | VT_R8:
	case VT_VECTOR | VT_CY:
	case VT_VECTOR | VT_DATE:
	case VT_VECTOR | VT_FILETIME:
	case VT_VECTOR | VT_CLSID:
	    AssertByteVector(caub);			// VT_UI1
	    AssertShortVector(cai);			// VT_I2
	    AssertShortVector(caui);			// VT_UI2
	    AssertShortVector(cabool);			// VT_BOOL
	    AssertLongVector(cal);			// VT_I4
	    AssertLongVector(caul);			// VT_UI4
	    AssertLongVector(caflt);			// VT_R4
	    AssertLongVector(cascode);			// VT_ERROR
	    AssertLongLongVector(cah);			// VT_I8
	    AssertLongLongVector(cauh);			// VT_UI8
	    AssertLongLongVector(cadbl);		// VT_R8
	    AssertLongLongVector(cacy);			// VT_CY
	    AssertLongLongVector(cadate);		// VT_DATE
	    AssertLongLongVector(cafiletime);		// VT_FILETIME
	    AssertVarVector(cauuid, sizeof(GUID));	// VT_CLSID
	    pv = pvar->cai.pElems;
	    break;

	case VT_VECTOR | VT_CF:
	    {
		CLIPDATA *pcd;

		cElems = pvar->caclipdata.cElems;
		pv = pcd = pvar->caclipdata.pElems;
		while (cElems-- > 0)
		{
		    if (pcd->pClipData != NULL)
		    {
			pma->Free(pcd->pClipData);
		    }
		    pcd++;
		}
	    }
	    break;

	case VT_VECTOR | VT_BSTR:
	case VT_VECTOR | VT_LPSTR:
	case VT_VECTOR | VT_LPWSTR:
	    AssertStringVector(cabstr);			// VT_BSTR
	    AssertStringVector(calpstr);		// VT_LPSTR
	    AssertStringVector(calpwstr);		// VT_LPWSTR
	    cElems = pvar->calpstr.cElems;
	    ppv = (VOID **) pvar->calpstr.pElems;
	    break;

	case VT_VECTOR | VT_VARIANT:
	    CleanupVariants(
		    pvar->capropvar.pElems,
		    pvar->capropvar.cElems,
		    pma);
	    pv = pvar->capropvar.pElems;
	    break;

	}   // switch (pvar->vt)

	if (ppv != NULL)			// STRING VECTOR property
	{
            // Save the vector of pointers
	    pv = (VOID *) ppv;

            // Free the vector elements
	    while (cElems-- > 0)
	    {
		if (*ppv != NULL)
		{
                    if( (VT_BSTR | VT_VECTOR) == pvar->vt )
                    {
                        (*UnicodeCallouts.pfnSysFreeString)( (BSTR) *ppv );
                    }
                    else
                    {
		        pma->Free((BYTE *) *ppv);
                    }
		}
		ppv++;
	    }

            // Free the vector of pointers.
            pma->Free(pv);
            pv = NULL;

	}   // if (ppv != NULL)

	if (pv != NULL)
	{
            if( VT_BSTR == pvar->vt )
            {
                (*UnicodeCallouts.pfnSysFreeString)( (BSTR) pv );
            }
            else
            {
                pma->Free((BYTE *) pv);
            }
        }

	pvar->vt = VT_EMPTY;

        // Move on to the next PropVar in the vector.
	pvar++;

    }   // while (cprop-- > 0)
}


//+--------------------------------------------------------------------------
// Function:    PropertyLength
//
// Synopsis:    compute the length of a property including the variant type
//
// Arguments:   [pprop]         -- property value
//              [cbbuf]         -- max length of accessible memory at pprop
//              [flags]		-- CPropertySetStream flags
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     length of property
//---------------------------------------------------------------------------

ULONG
PropertyLength(
    SERIALIZEDPROPERTYVALUE const *pprop,
    ULONG cbbuf,
    BYTE flags,
    OUT NTSTATUS *pstatus)
{
    ULONG const *pl = (ULONG const *) pprop->rgb;
    ULONG cElems = 1;
    ULONG cbremain = cbbuf;
    ULONG cb = 0, cbch;
    BOOLEAN fIllegalType = FALSE;

    *pstatus = STATUS_SUCCESS;

    if (cbremain < CB_SERIALIZEDPROPERTYVALUE)
    {
        StatusOverflow(pstatus, "PropertyLength: dwType");
        goto Exit;
    }
    cbremain -= CB_SERIALIZEDPROPERTYVALUE;
    if( PropByteSwap(pprop->dwType) & VT_VECTOR )
    {
        if (cbremain < sizeof(ULONG))
        {
            StatusOverflow(pstatus, "PropertyLength: cElems");
            goto Exit;
        }
        cbremain -= sizeof(ULONG);
        cElems = PropByteSwap( *pl++ );
    }
    if( PropByteSwap(pprop->dwType) == (VT_VECTOR | VT_VARIANT) )
    {
	while (cElems-- > 0)
	{
	    cb = PropertyLength(
			(SERIALIZEDPROPERTYVALUE const *) pl,
			cbremain,
			flags | CPSS_VARIANTVECTOR,
                        pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
	    pl = (ULONG const *) Add2ConstPtr(pl, cb);
	    cbremain -= cb;
        }
    }
    else
    {
        cbch = sizeof(WCHAR);

        switch( PropByteSwap(pprop->dwType) & VT_TYPEMASK)
        {
        case VT_EMPTY:
        case VT_NULL:
            fIllegalType = (flags & CPSS_VARIANTVECTOR) != 0;
            break;

#ifdef PROPVAR_VT_I1
        case VT_I1:
#endif
        case VT_UI1:
            pl = (ULONG const *) Add2ConstPtr(pl, DwordAlign(cElems * sizeof(BYTE)));
            break;

        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
            pl = (ULONG const *) Add2ConstPtr(pl, DwordAlign(cElems * sizeof(USHORT)));
            break;

        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_ERROR:
            pl = (ULONG const *) Add2ConstPtr(pl, cElems * sizeof(ULONG));
            break;

        case VT_I8:
        case VT_UI8:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_FILETIME:
            pl = (ULONG const *) Add2ConstPtr(pl, cElems * sizeof(LONGLONG));
            break;

        case VT_CLSID:
            pl = (ULONG const *) Add2ConstPtr(pl, cElems * sizeof(GUID));
            break;

        case VT_BLOB:
        case VT_BLOB_OBJECT:
            // FALLTHROUGH

        case VT_CF:
        case VT_BSTR:
        case VT_LPSTR:
            cbch = sizeof(BYTE);
            // FALLTHROUGH

        case VT_LPWSTR:
            while (cElems-- > 0)
            {
                if (cbremain < sizeof(ULONG) ||
                    cbremain < (cb = sizeof(ULONG) + DwordAlign(PropByteSwap(*pl) * cbch)))
                {
                    StatusOverflow(pstatus, "PropertyLength: String/BLOB/CF");
                    goto Exit;
                }

#ifdef LITTLEENDIAN
		PROPASSERT(
		    (PropByteSwap(pprop->dwType) & VT_TYPEMASK) != VT_LPWSTR
                     ||
		     IsUnicodeString( (WCHAR const *) &pl[1],
				       PropByteSwap(*pl) * sizeof(WCHAR)));
#endif

                pl = (ULONG const *) Add2ConstPtr(pl, cb);
                cbremain -= cb;
            }
            break;

        default:
	    fIllegalType = TRUE;
            break;
        }
    }
    if (fIllegalType)
    {
        StatusInvalidParameter(pstatus, "PropertyLength: Illegal VarType");
        goto Exit;
    }
    cb = (BYTE *) pl - (BYTE *) pprop;
    if (cbbuf < cb)
    {
        StatusOverflow(pstatus, "PropertyLength: cb");
        goto Exit;
    }

    // Make sure PropertyLength works when limited to an exact size buffer.
    PROPASSERT(cb == cbbuf || PropertyLength(pprop, cb, flags, pstatus) == cb);

    //  ----
    //  Exit
    //  ----

Exit:

    // Normalize the error return value.
    if( !NT_SUCCESS(*pstatus) )
        cb = 0;

    return(cb);
}


//+--------------------------------------------------------------------------
// Function:    PBSCopy
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine copies the source to the destination, 
//              byte-swapping as it copies.
//
// Arguments:   [VOID*] pvDest
//                  Pointer to the target (swapped) buffer.
//                  This must be pre-allocated by the caller.
//              [VOID*] pvSource
//                  Pointer to the original buffer.
//              [ULONG] cbSize
//                  Size in bytes of the buffer.
//              [ULONG] cbByteSwap
//                  Size of byte-swapping units.
//
// Returns:     None.
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSCopy( OUT VOID *pvDest,
              IN VOID const *pvSource,
              IN ULONG cbCopy,
              IN LONG cbByteSwap )
{
    PROPASSERT( (cbCopy & 1) == 0 );
    PROPASSERT( pvDest != NULL && pvSource != NULL );

    memcpy( pvDest, pvSource, cbCopy );
    PBSBuffer( pvDest, cbCopy, cbByteSwap );
}

#endif  // BIGENDIAN


//+--------------------------------------------------------------------------
// Function:    PBSAllocAndCopy
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine allocs a buffer, and swaps the bytes from
//              the source buffer into the destination.
//
// Arguments:   [VOID**] ppvDest (out)
//                  On success will point to the swapped buffer.
//              [VOID*] pvSource (in)
//                  Pointer to the original buffer.
//              [ULONG] cbSize (in)
//                  Size in bytes of the buffer.
//              [LONG] cbByteSwap (in)
//                  Size of byte-swapping units.
//              [NTSTATUS*] pstatus (out)
//                  NTSTATUS code.
//
// Returns:     None.
//
// Note:        The caller is responsible for freeing *ppvDest
//              (using ::delete).
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSAllocAndCopy( OUT VOID **ppvDest,
                      IN VOID const *pvSource,
                      ULONG cbSize,
                      LONG cbByteSwap,
                      OUT NTSTATUS *pstatus)
{
    ULONG cchString;

    //  -----
    //  Begin
    //  -----

    *pstatus = STATUS_SUCCESS;
    PROPASSERT( ppvDest != NULL && pvSource != NULL );

    // Allocate a buffer.
    *ppvDest = new BYTE[ cbSize ];
    if( NULL == *ppvDest )
    {
        *pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Swap/copy the bytes.
    PBSCopy( *ppvDest, pvSource, cbSize, cbByteSwap );

    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // PBSAllocAndCopy

#endif // BIGENDIAN

//+--------------------------------------------------------------------------
// Function:    PBSInPlaceAlloc
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine takes a WCHAR array, allocates a new buffer,
//              and swaps the original array into the new buffer.
//              
//
// Arguments:   [WCHAR**] ppwszResult
//                  IN: *ppwszResult points to string to be swapped.
//                  OUT: *ppwszResult points to the swapped string.
//              [WCHAR**] ppwszBuffer
//                  *ppwszBuffer points to the buffer which was allocated
//                  for the swapped bytes (should be the same as *ppwszResult).
//                  *ppwszBuffer must be NULL in input, and must be freed
//                  by the caller (using ::delete).
//              [NTSTATUS*] pstatus
//                  NTSTATUS code.
//
// Returns:     None.
//
// On input, *ppwszResult contains the original string.
// An equivalently sized buffer is allocated in *ppwszBuffer,
// and *ppwszResult is byte-swapped into it.  *ppwszResult
// is then set to the new *ppwszBuffer.
//
// It doesn't appear to useful to have both buffer parameters,
// but it makes it easier on the caller in certain circumstances;
// *ppwszResult always points to the correct string, whether the
// build is BIGENDIAN (alloc & swap takes place) or the build
// is LITTLEENDIAN (nothing happes, so *ppwszResult continues
// to point to the proper string).  The LITTLEENDIAN version of
// this function is implemented as an inline routine.
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSInPlaceAlloc( IN OUT WCHAR** ppwszResult,
                      OUT WCHAR** ppwszBuffer,
                      OUT NTSTATUS *pstatus )
{
    //  ------
    //  Locals
    //  ------

    WCHAR *pwszNewBuffer;

    // Pointers which will walk through the input buffers.
    WCHAR *pwszOriginal, *pwszSwapped;

    //  -----
    //  Begin
    //  -----

    *pstatus = STATUS_SUCCESS;

    // Allocate a new buffer.
    pwszNewBuffer = new WCHAR[ Prop_wcslen(*ppwszResult) + 1 ];
    if( NULL == pwszNewBuffer )
    {
        *pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Swap the WCHARs into the new buffer.

    pwszOriginal = *ppwszResult;
    pwszSwapped = pwszNewBuffer;

    do
    {
        *pwszSwapped = PropByteSwap(*pwszOriginal++);
    }   while( *pwszSwapped++ != L'\0' );

    // If the caller wants a special pointer to the new buffer,
    // set it now.

    if( NULL != ppwszBuffer )
    {
        PROPASSERT( NULL== *ppwszBuffer );
        *ppwszBuffer = pwszNewBuffer;
    }

    // Also point *ppwszResult to the new buffer.
    *ppwszResult = pwszNewBuffer;


    //  ----
    //  Exit
    //  ----

Exit:
    return;
}   // PropByteSwap( WCHAR**, WCHAR**, NTSTATUS*)

#endif // BIGENDIAN


//+--------------------------------------------------------------------------
// Function:    PBSBuffer
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine takes a buffer and byte-swaps it.  The caller
//              specifies the size of the buffer, and the granularity of
//              the byte-swapping.
//
// Arguments:   [VOID*] pv
//                  Pointer to the buffer to be swapped.
//              [ULONG] cbSize
//                  Size in bytes of the buffer.
//              [ULONG] cbByteSwap
//                  Size of byte-swapping units.
//
// Returns:     None.
//
// For example, an array of 4 WORDs could be swapped with:
//
//      PBSBuffer( (VOID*) aw, 4, sizeof(WORD) );
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSBuffer( IN OUT VOID *pv,
                IN ULONG cbSize,
                IN ULONG cbByteSwap )
{
    ULONG ulIndex;

    // What kind of swapping should be do?

    switch( cbByteSwap )
    {
        // No swapping required

        case 0:
        case( sizeof(BYTE) ):

            // Nothing to do.
            break;

        // Swap WORDs

        case( sizeof(WORD) ):
            
            for( ulIndex = 0; ulIndex < cbSize/sizeof(WORD); ulIndex++ )
                ByteSwap( &((WORD*)pv)[ulIndex] );
            break;

        // Swap DWORDs

        case( sizeof(DWORD) ):

            for( ulIndex = 0; ulIndex < cbSize/sizeof(DWORD); ulIndex++ )
                ByteSwap( &((DWORD*)pv)[ulIndex] );
            break;

        // Swap LONGLONGs

        case( sizeof(LONGLONG) ):

            for( ulIndex = 0; ulIndex < cbSize/sizeof(LONGLONG); ulIndex++ )
                 ByteSwap( &((LONGLONG*)pv)[ulIndex] );
            break;

        // Swap GUIDs

        case CBBYTESWAP_UID:

            for( ulIndex = 0; ulIndex < cbSize/sizeof(GUID); ulIndex++ )
                ByteSwap( &((GUID*)pv)[ulIndex] );
            break;

        // Error

        default:
            PROPASSERT( !"Invalid generic byte-swap size" );
    }
}   // PropByteSwap( VOID*, ULONG, ULONG )

#endif // BIGENDIAN

DEFINE_CBufferAllocator__Allocate
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\qsort.c ===
/***
*qsort.c - quicksort algorithm; qsort() library function for sorting arrays
*
*       Copyright (c) 1985-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       To implement the qsort() routine for sorting arrays.
*      
*       This routine has been modified to suit the reference implementation
*
*******************************************************************************/
#include "qsort.h"

/* prototypes for local routines */
static void shortsort(char *lo, char *hi, unsigned width,
                 int (*comp)(const void *, const void *));
static void swap(char *p, char *q, unsigned int width);

/* this parameter defines the cutoff between using quick sort and
   insertion sort for arrays; arrays with lengths shorter or equal to the
   below value use insertion sort */

#define CUTOFF 8            /* testing shows that this is good value */


/***
*ref_qsort(base, num, wid, comp) - quicksort function for sorting arrays
*
*Purpose:
*       quicksort the array of elements
*       side effects:  sorts in place
*
*Entry:
*       char *base = pointer to base of array
*       unsigned num  = number of elements in the array
*       unsigned width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

/* sort the array between lo and hi (inclusive) */

void ref_qsort (
    void *base,
    unsigned num,
    unsigned width,
    int (*comp)(const void *, const void *)
    )
{
    char *lo, *hi;              /* ends of sub-array currently sorting */
    char *mid;                  /* points to middle of subarray */
    char *loguy, *higuy;        /* traveling pointers for partition step */
    unsigned size;              /* size of the sub-array */
    char *lostk[30], *histk[30];
    int stkptr;                 /* stack for saving sub-array to be processed */

    /* Note: the number of stack entries required is no more than
       1 + log2(size), so 30 is sufficient for any array */

    if (num < 2 || width == 0)
        return;                 /* nothing to do */

    stkptr = 0;                 /* initialize stack */

    lo = (char *) base;
    hi = (char *)base + width * (num-1);        /* initialize limits */

    /* this entry point is for pseudo-recursion calling: setting
       lo and hi and jumping to here is like recursion, but stkptr is
       prserved, locals aren't, so we preserve stuff on the stack */
recurse:

    size = (hi - lo) / width + 1;        /* number of el's to sort */

    /* below a certain size, it is faster to use a O(n^2) sorting method */
    if (size <= CUTOFF) {
         shortsort(lo, hi, width, comp);
    }
    else {
        /* First we pick a partititioning element.  The efficiency of the
           algorithm demands that we find one that is approximately the
           median of the values, but also that we select one fast.  Using
           the first one produces bad performace if the array is already
           sorted, so we use the middle one, which would require a very
           wierdly arranged array for worst case performance.  Testing shows
           that a median-of-three algorithm does not, in general, increase
           performance. */

        mid = lo + (size / 2) * width;      /* find middle element */
        swap(mid, lo, width);               /* swap it to beginning of array */

        /* We now wish to partition the array into three pieces, one
           consisiting of elements <= partition element, one of elements
           equal to the parition element, and one of element >= to it.  This
           is done below; comments indicate conditions established at every
           step. */

        loguy = lo;
        higuy = hi + width;

        /* Note that higuy decreases and loguy increases on every iteration,
           so loop must terminate. */
        for (;;) {
            /* lo <= loguy < hi, lo < higuy <= hi + 1,
               A[i] <= A[lo] for lo <= i <= loguy,
               A[i] >= A[lo] for higuy <= i <= hi */

            do  {
                loguy += width;
            } while (loguy <= hi && comp(loguy, lo) <= 0);

            /* lo < loguy <= hi+1, A[i] <= A[lo] for lo <= i < loguy,
               either loguy > hi or A[loguy] > A[lo] */

            do  {
                higuy -= width;
            } while (higuy > lo && comp(higuy, lo) >= 0);

            /* lo-1 <= higuy <= hi, A[i] >= A[lo] for higuy < i <= hi,
               either higuy <= lo or A[higuy] < A[lo] */

            if (higuy < loguy)
                break;

            /* if loguy > hi or higuy <= lo, then we would have exited, so
               A[loguy] > A[lo], A[higuy] < A[lo],
               loguy < hi, highy > lo */

            swap(loguy, higuy, width);

            /* A[loguy] < A[lo], A[higuy] > A[lo]; so condition at top
               of loop is re-established */
        }

        /*     A[i] >= A[lo] for higuy < i <= hi,
               A[i] <= A[lo] for lo <= i < loguy,
               higuy < loguy, lo <= higuy <= hi
           implying:
               A[i] >= A[lo] for loguy <= i <= hi,
               A[i] <= A[lo] for lo <= i <= higuy,
               A[i] = A[lo] for higuy < i < loguy */

        swap(lo, higuy, width);     /* put partition element in place */

        /* OK, now we have the following:
              A[i] >= A[higuy] for loguy <= i <= hi,
              A[i] <= A[higuy] for lo <= i < higuy
              A[i] = A[lo] for higuy <= i < loguy    */

        /* We've finished the partition, now we want to sort the subarrays
           [lo, higuy-1] and [loguy, hi].
           We do the smaller one first to minimize stack usage.
           We only sort arrays of length 2 or more.*/

        if ( higuy - 1 - lo >= hi - loguy ) {
            if (lo + width < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy - width;
                ++stkptr;
            }                           /* save big recursion for later */

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           /* do small recursion */
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               /* save big recursion for later */
            }

            if (lo + width < higuy) {
                hi = higuy - width;
                goto recurse;           /* do small recursion */
            }
        }
    }

    /* We have sorted the array, except for any pending sorts on the stack.
       Check if there are any, and do them. */

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           /* pop subarray from stack */
    }
    else
        return;                 /* all subarrays done */
}


/***
*shortsort(hi, lo, width, comp) - insertion sort for sorting short arrays
*
*Purpose:
*       sorts the sub-array of elements between lo and hi (inclusive)
*       side effects:  sorts in place
*       assumes that lo < hi
*
*Entry:
*       char *lo = pointer to low element to sort
*       char *hi = pointer to high element to sort
*       unsigned width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void shortsort (
    char *lo,
    char *hi,
    unsigned width,
    int (*comp)(const void *, const void *)
    )
{
    char *p, *max;

    /* Note: in assertions below, i and j are alway inside original bound of
       array to sort. */

    while (hi > lo) {
        /* A[i] <= A[j] for i <= j, j > hi */
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            /* A[i] <= A[max] for lo <= i < p */
            if (comp(p, max) > 0) {
                max = p;
            }
            /* A[i] <= A[max] for lo <= i <= p */
        }

        /* A[i] <= A[max] for lo <= i <= hi */

        swap(max, hi, width);

        /* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

        hi -= width;

        /* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}


/***
*swap(a, b, width) - swap two elements
*
*Purpose:
*       swaps the two array elements of size width
*
*Entry:
*       char *a, *b = pointer to two elements to swap
*       unsigned width = width in bytes of each array element
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void swap (
    char *a,
    char *b,
    unsigned width
    )
{
    char tmp;

    if ( a != b )
        /* Do the swap one character at a time to avoid potential alignment
           problems. */
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\propstm.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993
//
// File:        propstm.cxx
//
// Contents:    property set value extraction code
//
// The OLE 2.0 Appendix B property set specifies multiple sections in the
// property stream specification.  Multiple sections were intended to allow
// the schema associated with the property set to evolve over a period of
// time, but there is no reason that new PROPIDs cannot serve the same
// purpose.  The current implementation of the property stream is limited to
// one section, except for the Office DocumentSummaryInformation property
// set's specific use of a second section.  Other property sets with multiple
// sections can only be accessed in read-only mode, and then only for the
// first property section. The current implementation of property set stream
// is built around a class called CPropertySetStream.  The various details of
// the OLE property spec is confined to this class. This class encapsulates a
// stream implementation (CMappedStream). This is different from other 
// stream implementations in that the fundamental mechanism provided
// for acessing the contents is Map/Unmap rather than Read/Write.  
//
//---------------------------------------------------------------------------

#include "pch.cxx"

#ifdef _UNIX
#define qsort ref_qsort
#include "qsort.h"
#endif

#define Dbg     DEBTRACE_PROPERTY

#define szX     "x"     // allows radix change for offsets & sizes
//#define szX   "d"     // allows radix change for offsets & sizes

#ifndef newk
#define newk(Tag, pCounter)     new
#endif

#ifndef IsDwordAligned
#define IsDwordAligned(p)       (((ULONG) (p) & (sizeof(ULONG) - 1)) == 0)
#endif

#ifndef DwordRemain
#define DwordRemain(cb) \
        ((sizeof(ULONG) - ((cb) % sizeof(ULONG))) % sizeof(ULONG))
#endif


// Macro to create the OS Version field of the
// property set header.
#define MAKEPSVER(oskind, major, minor)  \
        (((oskind) << 16) | ((minor) << 8) | (major))

// we specify a new 'OS' type for the reference implementation
#define CURRENT_OSKIND OSKIND_REF
// reference implementation starts at version 1.00
#define CURRENT_OSVER 0x01

#define PROPSETVER_CURRENT \
    MAKEPSVER(CURRENT_OSKIND, CURRENT_OSVER >> 8, CURRENT_OSVER & 0xff) 
#define PROPSETVER_WIN310  MAKEPSVER(OSKIND_WINDOWS, 3, 10)
#define PROPSETVER_WIN333  MAKEPSVER(OSKIND_WIN32, 3, 0x33)



extern GUID guidSummary;
extern GUID guidDocumentSummary;
extern GUID guidDocumentSummarySection2;

#define CP_DEFAULT_NONUNICODE   1252 // ANSI Latin1 (US, Western Europe)

extern "C" UNICODECALLOUTS UnicodeCallouts;
#define CP_CREATEDEFAULT(state)	(*UnicodeCallouts.pfnGetACP)()

#if DBGPROP
#define StatusCorruption(pstatus, szReason)             \
            _StatusCorruption(szReason " ", pstatus)
#else
#define StatusCorruption(pstatus, szReason)             \
            _StatusCorruption(pstatus)
#endif


VOID RtlpConvertToUnicode(
    IN CHAR const *pch,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT WCHAR **ppwc,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus);


#if DBGPROP

#define CB_VALUEDISPLAY 8       // Number of bytes to display
#define CB_VALUESTRING  (CB_VALUEDISPLAY * 3 + 3)       // "xx xx xx xx...\0"

char *
ValueToString(SERIALIZEDPROPERTYVALUE const *pprop, ULONG cbprop, char buf[])
{
    char *p = buf;
    BYTE const *pb = pprop->rgb;
    BOOLEAN fOverflow = FALSE;
    static char szDots[] = "...";

    if (cbprop >= FIELD_OFFSET(SERIALIZEDPROPERTYVALUE, rgb))
    {
        cbprop -= FIELD_OFFSET(SERIALIZEDPROPERTYVALUE, rgb);
        if (cbprop > CB_VALUEDISPLAY)
        {
            cbprop = CB_VALUEDISPLAY;
            fOverflow = TRUE;
        }
        while (cbprop-- > 0)
        {
            if (p != buf)
            {
                *p++ = ' ';
            }
            p += PropSprintfA( p, "%02.2x", *pb++ );
        }
    }
    *p =  '\0';
    PROPASSERT(p - buf + sizeof(szDots) <= CB_VALUESTRING);
    if (fOverflow)
    {
        strcpy(p, szDots);
    }
    return(buf);
}


#define CB_VARIANT_TO_STRING 35

char *
VariantToString(PROPVARIANT const &var, char buf[], ULONG cbprop)
{
    char *p = buf;

    PROPASSERT( cbprop >= CB_VARIANT_TO_STRING );


    // Add the VT to the output buffer.

    p += PropSprintfA( p, "vt=%04.4x", var.vt );
    p += PropSprintfA( p, ", val=(%08.8x, %08.8x)", var.uhVal.QuadPart );
   
    *p =  '\0';
    PROPASSERT( (p - buf) == CB_VARIANT_TO_STRING);
    return(buf);
}

#endif


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapOffsetToAddress, private
//
// Synopsis:    maps an offset to an address
//
// Arguments:   [Offset]        -- the offset in the section
//
// Returns:     ptr to the offset mapped
//+--------------------------------------------------------------------------

inline VOID *
CPropertySetStream::_MapOffsetToAddress(ULONG Offset) const
{
    PROPASSERT(_cSection != 0);

    return(Add2Ptr(_GetSectionHeader(), Offset));
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_DictionaryEntryLength
//
// Synopsis:    Calculate the length of an entry in the
//              dictionary.  This is non-trivial because
//              it is codepage-dependent.
//
// Arguments:   [pent] -- pointer to a dictionary entry.
//
//
// Returns:     The entry's length.
//+--------------------------------------------------------------------------


inline ULONG
CPropertySetStream::_DictionaryEntryLength(
    IN ENTRY UNALIGNED const * pentArg
    ) const
{
#if i386 == 0                   // copy into an aligned structure
    ENTRY ent;                  // allocate on stack -> faster
    ENTRY *pent=&ent;
    memcpy(pent, pentArg, sizeof(ENTRY));
#else
    ENTRY UNALIGNED const *pent = pentArg;
#endif
    // If this is a Unicode property set, it should be DWORD-aligned.
    PROPASSERT( _CodePage != CP_WINUNICODE
                ||
                IsDwordAligned( (ULONG) pent ));

    // The size consists of the length of the
    // PROPID and character count ...

    ULONG ulSize = CB_ENTRY;

    // Plus the length of the string ...

    ulSize += PropByteSwap( pent->cch ) * 
            ( _CodePage == CP_WINUNICODE
                          ? sizeof( WCHAR )
                          : sizeof( CHAR )
                         );

    // Plus, possibly, padding to make the entry DWORD-aligned
    // (for Unicode property sets).

    if( _CodePage == CP_WINUNICODE )
    {
        ulSize = DwordAlign( ulSize );
    }

    return( ulSize );
}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_NextDictionaryEntry
//
// Synopsis:    Given a pointer to an entry in the dictionary,
//              create a pointer to the next entry.
//
// Arguments:   [pent] -- pointer to a dictionary entry.
//
// Returns:     Pointer to the next entry.  If the input
//              points to the last entry in the dictionary,
//              then return a pointer to just beyond the
//              end of the dictionary.
//+--------------------------------------------------------------------------


inline ENTRY UNALIGNED *
CPropertySetStream::_NextDictionaryEntry(
    IN ENTRY UNALIGNED const * pent
    ) const
{   

    return (ENTRY UNALIGNED *)
           Add2Ptr( pent, _DictionaryEntryLength( pent ));

}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_SignalCorruption
//
// Synopsis:    possibly PROPASSERT and return data corrupt error
//
// Arguments:   [szReason]              -- string explanation (DBGPROP only)
//              [pstatus]               -- NTSTATUS code.
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_StatusCorruption(
#if DBGPROP
    char *szReason,
#endif
    OUT NTSTATUS *pstatus
    ) const
{
#if DBGPROP
    DebugTrace(0, DEBTRACE_ERROR, (
        "_StatusCorruption(%s, psstm=%lx, mapstm=%lx, %s, flags=%x)\n",
        szReason,
        this,
        KERNELSELECT(&_mstm, _pmstm),
        KERNELSELECT("Kernel", _MSTM(IsNtMappedStream)()? "Nt" : "DocFile"),
        _Flags));

    PROPASSERTMSG(szReason, FALSE);
    DebugTrace(0, DEBTRACE_WARN, (
        "_StatusCorruption(%s, psstm=%lx, mapstm=%lx, %s, flags=%x)\n",
        szReason,
        this,
        KERNELSELECT(&_mstm, _pmstm),
        KERNELSELECT("Kernel", _MSTM(IsNtMappedStream)()? "Nt" : "DocFile"),
        _Flags));
    if (DebugLevel & DEBTRACE_WARN)
    {
        PROPASSERTMSG(szReason, FALSE);
    }

#endif // DBGPROP

    *pstatus = STATUS_INTERNAL_DB_CORRUPTION;
    return;
}


//+--------------------------------------------------------------------------
// Function:    _PropMoveMemory
//
// Synopsis:    call DebugTrace and RtlMoveMemory
//
// Arguments:   [pszReason]             -- string explanation (Debug only)
//              [pvSection]             -- base of section (Debug only)
//              [pvDst]                 -- destination
//              [pvSrc]                 -- source
//              [cbMove]                -- byte count to move
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
#define PropMoveMemory(pszReason, pvSection, pvDst, pvSrc, cbMove) \
        _PropMoveMemory(pszReason, pvSection, pvDst, pvSrc, cbMove)
#else
#define PropMoveMemory(pszReason, pvSection, pvDst, pvSrc, cbMove) \
        _PropMoveMemory(pvDst, pvSrc, cbMove)
#endif

inline VOID
_PropMoveMemory(
#if DBGPROP
    char *pszReason,
    VOID *pvSection,
#endif
    VOID *pvDst,
    VOID const *pvSrc,
    ULONG cbMove)
{
    DebugTrace(0, Dbg, (
        "%s: Moving Dst=%lx(%l" szX ") Src=%lx(%l" szX ") Size=%l" szX "\n",
        pszReason,
        pvDst,
        (BYTE *) pvDst - (BYTE *) pvSection,
        pvSrc,
        (BYTE *) pvSrc - (BYTE *) pvSection,
        cbMove));
    RtlMoveMemory(pvDst, pvSrc, cbMove);
}


inline BOOLEAN
IsReadOnlyPropertySet(BYTE flags, BYTE state)
{
    return(
	(flags & CREATEPROP_MODEMASK) == CREATEPROP_READ ||
	(state & CPSS_USERDEFINEDDELETED) ||
	(state & (CPSS_MULTIPLESECTIONS | CPSS_DOCUMENTSUMMARYINFO)) ==
	    CPSS_MULTIPLESECTIONS);
}


inline BOOLEAN
IsReadOnlyPropid(PROPID pid)
{
    return(
        pid == PID_DICTIONARY ||
        pid == PID_CODEPAGE ||
        pid == PID_LOCALE ||
        pid == PID_MODIFY_TIME ||
        pid == PID_SECURITY);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::CStreamChunkList
//
// Synopsis:    constructor
//
// Arguments:   [cChunks]               -- count of chunks that will be needed
//
// Returns:     None
//+--------------------------------------------------------------------------

CStreamChunkList::CStreamChunkList(
    ULONG cChunks,
    CStreamChunk *ascnk) :
    _cMaxChunks(cChunks),
    _cChunks(0),
    _ascnk(ascnk),
    _fDelete(FALSE)
{
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::Delete
//
// Synopsis:    destructor
//
// Arguments:   None
//
// Returns:     None
//+--------------------------------------------------------------------------

inline
VOID
CStreamChunkList::Delete(VOID)
{
    if (_fDelete)
    {
        delete [] _ascnk;
    }
#if DBGPROP
    _cMaxChunks = _cChunks = 0;
    _ascnk = NULL;
    _fDelete = FALSE;
#endif
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::GetChunk
//
// Synopsis:    retrieves a chunk given the index
//
// Arguments:   [i]          -- index of the chunk to retrieve
//
// Returns:     specified chunk pointer
//+--------------------------------------------------------------------------

inline
CStreamChunk const *
CStreamChunkList::GetChunk(ULONG i) const
{
    PROPASSERT(i < _cChunks);
    PROPASSERT(i < _cMaxChunks);
    PROPASSERT(_ascnk != NULL);
    return(&_ascnk[i]);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::Count
//
// Synopsis:    returns the count of chunks
//
// Arguments:   None
//
// Returns:    the number of chunks.
//+--------------------------------------------------------------------------

inline ULONG
CStreamChunkList::Count(VOID) const
{
    return(_cChunks);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::GetFreeChunk
//
// Synopsis:    gets a unused chunk descriptor
//
// Arguments:   [pstatus]   -- NTSTATUS code
//
// Returns:     a ptr to a stream chunk descriptor.
//              This will be NULL if there was an
//              error.
//+--------------------------------------------------------------------------

CStreamChunk *
CStreamChunkList::GetFreeChunk(OUT NTSTATUS *pstatus)
{
    CStreamChunk *pscnk = NULL;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_cChunks < _cMaxChunks);
    if (_ascnk == NULL)
    {
        PROPASSERT(_cChunks == 0);
        _ascnk = newk(mtPropSetStream, NULL) CStreamChunk[_cMaxChunks];
        if (_ascnk == NULL)
        {
            StatusNoMemory(pstatus, "GetFreeChunk");
            goto Exit;
        }
        _fDelete = TRUE;
    }

    pscnk = &_ascnk[_cChunks++];

    //  ----
    //  Exit
    //  ----

Exit:

    return( pscnk );
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::AssertCbChangeTotal
//
// Synopsis:    make sure the computed cbChangeTotal is correct for the chunk
//
// Arguments:   None
//
// Returns:     Nothing
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CStreamChunkList::AssertCbChangeTotal(
    CStreamChunk const *pscnk,
    ULONG cbChangeTotal) const
{
    ULONG cb = 0;
    ULONG i;

    for (i = 0; i < Count(); i++)
    {
        CStreamChunk const *pscnkT = GetChunk(i);

        cb += pscnkT->cbChange;
        if (pscnk == pscnkT)
        {
            PROPASSERT(cb == cbChangeTotal);
            return;
        }
    }
    PROPASSERT(i < Count());
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnChunkCompare
//
// Synopsis:    qsort helper to compare chunks in the chunk list.
//
// Arguments:   [pscnk1]        -- pointer to chunk1
//              [pscnk2]        -- pointer to chunk2
//
// Returns:     difference
//+--------------------------------------------------------------------------

INT __cdecl
fnChunkCompare(VOID const *pscnk1, VOID const *pscnk2)
{
    return(((CStreamChunk const *) pscnk1)->oOld -
           ((CStreamChunk const *) pscnk2)->oOld);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::SortByStartAddress
//
// Synopsis:    sort all the chunks that are being modified in a stream in the
//              ascending order.
//
// Arguments:   None
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CStreamChunkList::SortByStartAddress(VOID)
{
    DebugTrace(0, Dbg, ("Sorting %l" szX " Chunks @%lx\n", _cChunks, _ascnk));

    qsort(_ascnk, _cChunks, sizeof(_ascnk[0]), fnChunkCompare);

#if DBGPROP
    LONG cbChangeTotal;
    ULONG i;

    cbChangeTotal = 0;
    for (i = 0; i < _cChunks; i++)
    {
        cbChangeTotal += _ascnk[i].cbChange;

        DebugTrace(0, Dbg, (
            "Chunk[%l" szX "] oOld=%l" szX " cbChange=%s%l" szX
                " cbChangeTotal=%s%l" szX "\n",
            i,
            _ascnk[i].oOld,
            _ascnk[i].cbChange < 0? "-" : "",
            _ascnk[i].cbChange < 0? -_ascnk[i].cbChange : _ascnk[i].cbChange,
            cbChangeTotal < 0? "-" : "",
            cbChangeTotal < 0? -cbChangeTotal : cbChangeTotal));
    }
#endif
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetFormatidOffset
//
// Synopsis:    Get a pointer to the (first) section header
//
// Arguments:   None
//
// Returns:     pointer to section header
//+--------------------------------------------------------------------------

inline FORMATIDOFFSET *
CPropertySetStream::_GetFormatidOffset(ULONG iSection) const
{
    return(&((FORMATIDOFFSET *) Add2Ptr(_pph, sizeof(*_pph)))[iSection]);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetSectionHeader
//
// Synopsis:    Get a pointer to the (first) section header
//
// Arguments:   None
//
// Returns:     pointer to section header
//+--------------------------------------------------------------------------

inline PROPERTYSECTIONHEADER *
CPropertySetStream::_GetSectionHeader(VOID) const
{
    return((PROPERTYSECTIONHEADER *) Add2Ptr(_pph, _oSection));
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetSectionHeader
//
// Synopsis:    Get a pointer to the specified section header
//
// Arguments:   [iSection]      -- section number
//              [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     pointer to specified section header
//+--------------------------------------------------------------------------

PROPERTYSECTIONHEADER *
CPropertySetStream::_GetSectionHeader(ULONG iSection, OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;
    PROPERTYSECTIONHEADER *psh = NULL;

    ULONG oSection = 0;                 // Assume no header
    ULONG cbstm = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Don't assume *any* class variables (except _pph) are loaded yet!

    PROPASSERT(_HasPropHeader() || iSection == 0);

    if (_HasPropHeader())
    {
        PROPASSERT(iSection < _pph->reserved );
        oSection = MAXULONG;
        if (cbstm >= CB_PROPERTYSETHEADER + (iSection + 1) * CB_FORMATIDOFFSET)
        {
            oSection = _GetFormatidOffset(iSection)->dwOffset;
        }
    }
    if (oSection != MAXULONG &&
        cbstm >= oSection + CB_PROPERTYSECTIONHEADER)
    {
        psh = (PROPERTYSECTIONHEADER *) Add2Ptr(_pph, oSection);

        if( cbstm >= oSection + psh->cbSection )
        {
            goto Exit;
        }
        else
        {
            psh = NULL;
        }
    }

    StatusCorruption(pstatus, "GetSectionHeader(i): stream size");

    //  ----
    //  Exit
    //  ----

Exit:

    return(psh);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_SearchForCodePage, private
//
// Synopsis:    Searches a section of a property set for the code page.
//
//              This routine searches for the code page by iterating
//              through the PID/Offset array in search of
//              PID_CODEPAGE.  The difference between calling
//              this routine, and calling GetValue(PID_CODEPAGE),
//              is that this routine does not assume that the
//              property set is formatted correctly; it only assumes
//              that the PID/Offset array is correct.
//
//              Note that this routine is like a specialized _LoadProperty(),
//              the important difference is that this routine must use
//              unaligned pointers, since it cannot assume that the
//              property set is aligned properly.
//
// Pre-Conditions:
//              The PID/Offset array is correct.
//              &&
//              _oSection & _cSection are set correctly.
//
// Post-Conditions:
//              If PID_CODEPAGE exists, it is put into _CodePage.
//              If it doesn't exist, _CodePage is left unchanged.
//
// Arguments:   [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     None.
//+-------------------------------------------------------------------------
VOID
CPropertySetStream::_SearchForCodePage( OUT NTSTATUS *pstatus )
{

    PROPERTYSECTIONHEADER UNALIGNED *psh;
    PROPERTYIDOFFSET UNALIGNED      *ppo;
    PROPERTYIDOFFSET UNALIGNED      *ppoMax;
#if i386 == 0
    PROPERTYSECTIONHEADER shCopy;
#endif
    PROPERTYSECTIONHEADER *pshCopy;
    ULONG cbstm;

    *pstatus = STATUS_SUCCESS;

    // Verify the pre-conditions.

    PROPASSERT( _oSection != 0 );
    PROPASSERT( _cSection != 0 );

    // It's invalid to call any function on a deleted
    // DocSumInfo user-defined (section section) section.

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	StatusAccessDenied(pstatus, "GetValue: deleted");
        goto Exit;
    }

    // Get the section's header and first & last PID/Offset pointers.
    // We can't use _LoadPropertyOffsetPointers, because it assumes
    // alignment.


    psh = _GetSectionHeader();    

#if i386 == 0
    memcpy(&shCopy, psh, sizeof(shCopy));
    // note that the copy should not be used to access rgprop, which
    // is a variable sized char arr.
    pshCopy=&shCopy; 
#else
    pshCopy = psh;   // okay to access unaligned on i386
#endif

    cbstm = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (cbstm < _oSection + CB_PROPERTYSECTIONHEADER
        || cbstm < _oSection + CB_PROPERTYSECTIONHEADER
           + pshCopy->cProperties * CB_PROPERTYIDOFFSET
        || cbstm < _oSection + pshCopy->cbSection)
    {
        StatusCorruption(pstatus, "_SearchForCodePage: stream size");
        goto Exit;
    }

    ppo = (PROPERTYIDOFFSET UNALIGNED *) 
        Add2Ptr(psh, CB_PROPERTYSECTIONHEADER);

    ppoMax = ppo + pshCopy->cProperties;

    // Search the PID/Offset array for PID_CODEPAGE

    for ( ; ppo < ppoMax; ppo++)
    {
        if (PIDOFFSET_GetPropid(ppo) == PID_CODEPAGE)
        {
            SERIALIZEDPROPERTYVALUE UNALIGNED *pprop;
            pprop = (SERIALIZEDPROPERTYVALUE *)
                    _MapOffsetToAddress( PIDOFFSET_GetOffset(ppo) );

            // Get the real address of serialized property.

            // Check for corruption.

            if ( ( ( PIDOFFSET_GetOffset(ppo) + 
                    CB_SERIALIZEDPROPERTYVALUE + sizeof(DWORD) )
                   >
                   pshCopy->cbSection
                 )
                 ||
                 PropByteSwap(SPV_GetType(pprop)) != VT_I2
               )
            {
                StatusCorruption(pstatus, "_SearchForCodePage");
                goto Exit;
            }

            // Set the member code page from the serialized property.
            // (The codepage is an I2).

            // we do memcpy to avoid alignment problems
            memcpy(&_CodePage, SPV_GetRgb(pprop), sizeof(_CodePage));
            _CodePage = PropByteSwap(_CodePage);

            break;

        }   // if (PIDOFFSET_GetPropid(ppo) == PID_CODEPAGE)
    }   // for ( ; ppo < ppoMax; ppo++)

    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_SearchForCodePage()


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapAddressToOffset, private
//
// Synopsis:    maps an address to an offset
//
// Arguments:   [pvAddr]        -- the address in the section
//
// Returns:     section-relative offset for passed pointer
//+--------------------------------------------------------------------------

inline ULONG
CPropertySetStream::_MapAddressToOffset(VOID const *pvAddr) const
{
    PROPASSERT(_cSection != 0);

    // Get a ptr to the section header.
    VOID const *pvSectionHeader = _GetSectionHeader();

    PROPASSERT((BYTE const *) pvAddr >= (BYTE const *) pvSectionHeader);
    return((BYTE const *) pvAddr - (BYTE const *) pvSectionHeader);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapAbsOffsetToAddress, private
//
// Synopsis:    maps an address to an offset
//
// Arguments:   [oAbsolute]      -- the absolute offset
//
// Returns:     a ptr to the offset mapped
//+--------------------------------------------------------------------------

inline VOID *
CPropertySetStream::_MapAbsOffsetToAddress(ULONG oAbsolute) const
{
    return(Add2Ptr(_pph, oAbsolute));
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapAddressToAbsOffset, private
//
// Synopsis:    maps an address to an offset
//
// Arguments:   [pvAddr]        -- the address
//
// Returns:     the absolute offset
//+--------------------------------------------------------------------------

inline ULONG
CPropertySetStream::_MapAddressToAbsOffset(VOID const *pvAddr) const
{
    PROPASSERT((BYTE const *) pvAddr >= (BYTE *) _pph);
    return((BYTE const *) pvAddr - (BYTE *) _pph);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::CPropertySetStream
//
// Synopsis:    constructor for property set class
//
// Arguments:UK [Flags] -- NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
//            K [pscb]          -- SCB for property stream
//            K [pirpc]         -- pointer to Irp Context
//            K [State]         -- CPSS_PROPHEADER
//           U  [pmstm]         -- mapped stream implementation
//           U  [pma]           -- caller's memory allocator
//
// Returns:     None
//---------------------------------------------------------------------------

CPropertySetStream::CPropertySetStream(
    IN USHORT Flags,	// NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
    IN CMappedStream *pmstm,    // mapped stream impelementation
    IN PMemoryAllocator *pma    // caller's memory allocator
    ) 
    :
    _Flags((BYTE) Flags),
    _State(0),
    _pmstm(pmstm),
    _pma(pma),
    _pph(NULL)
{
    _CodePage = CP_CREATEDEFAULT(_State);       // Default if not present
    PROPASSERT(_Flags == Flags);                // Should fit in a byte
    _oSection = 0;
    _cSection = 0;
    _cbTail   = 0;
        
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::Close
//
// Synopsis:    shutdown property set prior to calling destructor
//
// Arguments:   [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::Close(OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    // Validate the byte-order (_pph could be NULL in certain
    // close scenarios, e.g. an RtlCreatePropertySet fails).
    PROPASSERT(NULL == _pph || PROPSET_BYTEORDER == _pph->wByteOrder);
    PROPASSERT(
        (_Flags & CREATEPROP_MODEMASK) != CREATEPROP_READ ||
        !IsModified());

    _MSTM(Unmap)(IsModified(), (VOID **) &_pph);

    _MSTM(Close)(pstatus);
//  if( !NT_SUCCESS(*pstatus) ) goto Exit;

//Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::Open
//
// Synopsis:    Open property set image
//
// Arguments:   None
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::Open(
    IN GUID const *pfmtid,	    // property set fmtid
    OPTIONAL IN GUID const *pclsid, // CLASSID of propset code (create only)
    IN ULONG LocaleId,		    // Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion, // OS Version from header
    IN USHORT CodePage,             // CodePage of property set (create only)
    OUT NTSTATUS *pstatus
    )
{
    *pstatus = STATUS_SUCCESS;
    LOADSTATE LoadState;
    PROPASSERT(!_IsMapped());

    if( pOSVersion != NULL )
        *pOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;

    // Open the underlying stream which holds the property set.
    // We give it a callback pointer so that it can call
    // RtlOnMappedStreamEvent.

    _MSTM(Open)(this, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Load the header, including fixing the in-memory image of
    // poorly-formatted property sets.

    LoadState = _LoadHeader(pfmtid, _Flags & CREATEPROP_MODEMASK, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (LoadState != LOADSTATE_DONE)
    {
	switch (_Flags & CREATEPROP_MODEMASK)
	{
	    case CREATEPROP_READ:
	    case CREATEPROP_WRITE:
    		if (LoadState == LOADSTATE_FAIL)
		{
		    StatusCorruption(pstatus, "Open: _LoadHeader");
                    goto Exit;
		}
		PROPASSERT(
		    LoadState == LOADSTATE_BADFMTID ||
		    LoadState == LOADSTATE_USERDEFINEDNOTFOUND);
		DebugTrace(0, DEBTRACE_ERROR, (
		    "_LoadHeader: LoadState=%x\n", LoadState));

                *pstatus = STATUS_PROPSET_NOT_FOUND;
		goto Exit;
	}

        _Create(
            pfmtid,
            pclsid,
	    LocaleId,
            CodePage,
	    LoadState,
            pstatus
            );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

    }   // if (LoadState != LOADSTATE_DONE)

    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    if (_HasPropHeader() &&
        (_pph->dwOSVer == PROPSETVER_WIN310 ||
         _pph->dwOSVer == PROPSETVER_WIN333))
    {
        DebugTrace(0, DEBTRACE_PROPPATCH, (
            "Open(%s) downlevel: %x\n",
            (_Flags & CREATEPROP_MODEMASK) == CREATEPROP_READ? "Read" : "Write",
            _Flags));
        _State |= CPSS_DOWNLEVEL;
    }

    if ((_Flags & CREATEPROP_MODEMASK) != CREATEPROP_READ)
    {
        if (_State & CPSS_PACKEDPROPERTIES)
        {
            StatusAccessDenied(pstatus, "Open: writing Unaligned propset");
            goto Exit;
        }
        if ((_State & (CPSS_MULTIPLESECTIONS | CPSS_DOCUMENTSUMMARYINFO)) ==
	    CPSS_MULTIPLESECTIONS)
        {
            StatusAccessDenied(pstatus, "Open: writing unknown multiple section propset");
            goto Exit;
        }
    }

    // Return the OS Version to the caller.

    if( pOSVersion != NULL )
        *pOSVersion = _pph->dwOSVer;

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::ReOpen
//
// Synopsis:    ReOpen property set image
//
// Arguments:   [pstatus]       -- Pointer to NSTATUS code.
//
// Returns:     Number of properties.
//---------------------------------------------------------------------------

ULONG
CPropertySetStream::ReOpen(OUT NTSTATUS *pstatus)
{
    LOADSTATE LoadState;
    PROPERTYSECTIONHEADER const *psh;
    ULONG cProperties = 0;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());

    _MSTM(ReOpen)((VOID **) &_pph, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	goto Exit;
    }

    LoadState = _LoadHeader(NULL,
                            CREATEPROP_READ,  // all we need is !create
                            pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (LoadState != LOADSTATE_DONE)
    {
	DebugTrace(0, DEBTRACE_ERROR, (
	    "ReOpen: LoadState=%lx\n",
	    LoadState));
        StatusCorruption(pstatus, "ReOpen: _LoadHeader");
        goto Exit;
    }

    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    psh = _GetSectionHeader();
    PROPASSERT(psh != NULL);

    cProperties = psh->cProperties;

    //  ----
    //  Exit
    //  ----

Exit:

    return( cProperties );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_InitSection
//
// Synopsis:    Initialize a section header and the default properties.
//
// Arguments:   [pfo]		-- pointer to section info
//		[LocaleId]	-- Locale Id
//
// Returns:     None
//---------------------------------------------------------------------------

        // Serialized Code-Page size
#define CB_CODEPAGE         (sizeof(ULONG) + DwordAlign(sizeof(USHORT)))

        // Serialized Locale ID (LCID) size.
#define CB_LOCALE	    (sizeof(ULONG) + sizeof(ULONG))

        // Minimum section size (minimum has Code Page & LCID)
#define CB_MINSECTIONSIZE   (CB_PROPERTYSECTIONHEADER   \
                             + 2 * CB_PROPERTYIDOFFSET  \
                             + CB_CODEPAGE              \
                             + CB_LOCALE)

        // Minimum serialized dictionary size (a dict with no entries).
#define CB_EMPTYDICTSIZE    (sizeof(DWORD)) // Entry count

        // Minimum User-Defined section size (in DocumentSummaryInformation propset).
        // (Must include an empty dictionary & a PID/Offset for it.)
#define CB_MINUSERDEFSECTIONSIZE                    \
                            (CB_MINSECTIONSIZE      \
                             +                      \
                             CB_PROPERTYIDOFFSET    \
                             +                      \
                             CB_EMPTYDICTSIZE)

VOID
CPropertySetStream::_InitSection(
    IN FORMATIDOFFSET *pfo,
    IN ULONG LocaleId,
    IN BOOL  fCreateDictionary  // Create an empty dictionary?
    )
{
    PROPERTYSECTIONHEADER *psh;

    ULONG ulPropIndex;     // Index into the PID/Offset array.
    DWORD dwPropValOffset; // The offset to where the next prop val will be written.
                           // Pointer to a serialized property value.
    SERIALIZEDPROPERTYVALUE *pprop;

    psh = (PROPERTYSECTIONHEADER *) _MapAbsOffsetToAddress(pfo->dwOffset);

    // Set the property count and section size in the section header.
    // This must account for the Code Page and Locale ID properties, and
    // might need to account for an empty dictionary property.
    // dwPropValOffset identifies the location of the next property value
    // to be written.

    if( fCreateDictionary )
    {
        // Three properties:  Code Page, LCID, and Dictionary.

        psh->cProperties = 3;
        dwPropValOffset  = CB_PROPERTYSECTIONHEADER + 3 * CB_PROPERTYIDOFFSET;
        psh->cbSection   = CB_MINUSERDEFSECTIONSIZE;
    }
    else
    {
        // Two properties:  Code Page and LCID (no dictionary).

        psh->cProperties = 2;
        dwPropValOffset  = CB_PROPERTYSECTIONHEADER + 2 * CB_PROPERTYIDOFFSET;
        psh->cbSection   = CB_MINSECTIONSIZE;
    }


    ulPropIndex = 0;

    // If requested by the caller, create a dictionary property, but
    // leave the dictionary empty.  We always create this first.  It shouldn't
    // matter where it's located, but Office95 requires it
    // and it doesn't do any harm to put it there.

    if( fCreateDictionary )
    {
        // Fill in the PID/Offset table.

        psh->rgprop[ ulPropIndex ].propid = PID_DICTIONARY;
        psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

        // Fill in the property value.

        pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr( psh, dwPropValOffset );
        pprop->dwType = 0L; // For the dictonary, this is actually the entry count.

        // Advance the table & value indices.

        ulPropIndex++;
        dwPropValOffset += CB_EMPTYDICTSIZE;

    }   // if( fCreateDictionary )


    // Write the code page.  We write a zero first to initialize
    // the padding bytes.
    
    psh->rgprop[ ulPropIndex ].propid = PID_CODEPAGE;
    psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

    pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr( psh, dwPropValOffset );
    pprop->dwType = PropByteSwap((DWORD) VT_I2);
    *(DWORD *) pprop->rgb = 0;   // Zero out extra two bytes.
    *(WORD  *) pprop->rgb = PropByteSwap( _CodePage );
    
    ulPropIndex++;
    dwPropValOffset += CB_CODEPAGE;


    // Write the Locale ID.

    psh->rgprop[ ulPropIndex ].propid = PID_LOCALE;
    psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

    pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr(psh, dwPropValOffset );
    pprop->dwType = PropByteSwap( (DWORD) VT_UI4 );
    *(DWORD *) pprop->rgb = PropByteSwap( (DWORD) LocaleId );

}




//+---------------------------------------------------------------------------
// Member:      CPropertySetStream:: _MultiByteToWideChar, private
//
// Synopsis:    Convert a MultiByte string to a Unicode string,
//              using the _pma memory allocator if necessary.
//
// Arguments:   [pch]        -- pointer to MultiByte string
//              [cb]         -- byte length of MultiByte string
//                              (-1 if null terminated)
//              [CodePage]   -- Codepage of input string.
//              [ppwc]       -- pointer to pointer to converted string
//                              (if *ppwc is NULL, it will be alloced,
//                              if non-NULL, *ppwc must be *pcb bytes long).
//              [pcb]        -- IN:  byte length of *ppwc
//                              OUT: byte length of Unicode string.
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
CPropertySetStream::_MultiByteToWideChar(
    IN CHAR const *pch,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT WCHAR **ppwc,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    // Did we allocate *ppwc?
    BOOL fAlloc = FALSE;

    //  --------------
    //  Initialization
    //  --------------

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pch != NULL);
    PROPASSERT(ppwc != NULL);
    PROPASSERT(pcb != NULL);

    PROPASSERT(IsAnsiString(pch, ((ULONG)-1 == cb ) ? MAXULONG : cb));

    PROPASSERT(NULL != *ppwc || 0 == *pcb);
    PROPASSERT(UnicodeCallouts.pfnMultiByteToWideChar != NULL);

    //  ------------------
    //  Convert the String
    //  ------------------

    // We will pass through this loop once (if the caller provided a buffer
    // or twice (otherwise).

    while (TRUE)
    {
        // Attempt to convert the string.

	*pcb = (*UnicodeCallouts.pfnMultiByteToWideChar)(
				    CodePage,   // Source codepage
				    0,          // Flags
				    pch,        // Source string
				    cb,         // Source string length
				    *ppwc,      // Target string
				    *pcb);      // Size of target string buffer

        // The converted length should never be zero.
	if (0 == *pcb)
	{
            // If we alloced a buffer, free it now.
            if( fAlloc )
            {
	        _pma->Free( *ppwc );
                *ppwc = NULL;
            }

            // If there was an error, assume that it was a code-page
            // incompatibility problem.

            StatusError(pstatus, "_MultiByteToWideChar error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}

        // There was no error.  If we provided a non-NULL buffer,
        // then the conversion was performed and we're done.

	*pcb *= sizeof(WCHAR);  // cch => cb
	if (*ppwc != NULL)
	{
	    DebugTrace(0, DEBTRACE_PROPERTY, (
		"_MultiByteToWideChar: pch='%s'[%x] pwc='%ws'[%x->%x]\n",
		pch,
		cb,
		*ppwc,
		*pcb,
		*pcb * sizeof(WCHAR)));
	    break;
	}

        // We haven't actually the string yet.  Now that
        // we know the length, we can allocate a buffer and try the
        // conversion for real.

	*ppwc = (WCHAR *) _pma->Allocate( *pcb );
	if (NULL == *ppwc)
	{
	    StatusNoMemory(pstatus, "_MultiByteToWideChar: no memory");
            goto Exit;
	}
        fAlloc = TRUE;

    }   // while(TRUE)

    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_MultiByteToWideChar



//+---------------------------------------------------------------------------
// Member:      CPropertySetStream::_WideCharToMultiByte, private
//
// Synopsis:    Convert a Unicode string to a MultiByte string,
//              using the _pma memory allocator if necessary.
//
// Arguments:   [pwc]        -- pointer to Unicode string
//              [cch]        -- character length of Unicode string
//                              (-1 if null terminated)
//              [CodePage]   -- codepage of target string
//              [ppch]       -- pointer to pointer to converted string
//                              (if *ppch is NULL, it will be alloced,
//                              if non-NULL, *ppch must be *pcb bytes long).
//              [pcb]        -- IN:  byte length of *ppch
//                              OUT: byte length of MultiByte string
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
CPropertySetStream::_WideCharToMultiByte(
    IN WCHAR const *pwc,
    IN ULONG cch,
    IN USHORT CodePage,
    OUT CHAR **ppch,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    // Did we allocate *ppch?
    BOOL fAlloc = FALSE;

    //  --------------
    //  Initialization
    //  --------------

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pwc != NULL);
    PROPASSERT(ppch != NULL);
    PROPASSERT(pcb != NULL);

    PROPASSERT(IsUnicodeString(pwc, ((ULONG)-1 == cch ) ? MAXULONG : cch*sizeof(WCHAR)));

    PROPASSERT(NULL != *ppch || 0 == *pcb);
    PROPASSERT(UnicodeCallouts.pfnWideCharToMultiByte != NULL);

    //  ------------------
    //  Convert the String
    //  ------------------

    // We will pass through this loop once (if the caller provided a buffer
    // or twice (otherwise).

    while (TRUE)
    {
        // Attempt the conversion.
	*pcb = (*UnicodeCallouts.pfnWideCharToMultiByte)(
				    CodePage,       // Codepage to convert to
				    0,              // Flags
				    pwc,            // Source string
				    cch,            // Size of source string
				    *ppch,          // Target string
				    *pcb,           // Size of target string buffer
				    NULL,           // lpDefaultChar
				    NULL);          // lpUsedDefaultChar

        // A converted length of zero indicates an error.
	if (0 == *pcb)
	{
            // If we allocated a buffer in this routine, free it.
            if( fAlloc )
            {
	        _pma->Free( *ppch );
                *ppch = NULL;
            }

            // If there was an error, assume that it was a code-page
            // incompatibility problem.

            StatusError(pstatus, "_WideCharToMultiByte: WideCharToMultiByte error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}

        // If we have a non-zero length, and we provided a buffer,
        // then we're done (successfully).

	if (*ppch != NULL)
	{
	    DebugTrace(0, DEBTRACE_PROPERTY, (
		"_WideCharToMultiByte: pwc='%ws'[%x] pch='%s'[%x->%x]\n",
		pwc,
		cch,
		*ppch,
		*pcb,
		*pcb));
	    break;
	}

        // There were no errors, but we need to allocate a buffer
        // to do the actual conversion.

	*ppch = (CHAR*) _pma->Allocate( *pcb );
	if (*ppch == NULL)
	{
	    StatusNoMemory(pstatus, "_WideCharToMultiByte: no memory");
            goto Exit;
	}
        fAlloc = TRUE;

    }   // while (TRUE)


    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_WideCharToMultiByte


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::ByteSwapHeaders
//
// Synopsis:    Byte-swap the headers of a property set header
//              (both the propset header and any section headers).
//
// Arguments:   [PROPERTYSETHEADER*] pph
//                  Pointer to the beginning of the property set.
//              [ULONG] cbstm
//                  Total size of the property stream.
//              [NTSTATUS*] pstatus
//                  Pointer to NTSTATUS code.
//
// Pre-Conditions:
//              There are no more than two sections.
//
//              Note that this routine does not assume anything
//              about the current state of the CPropertySetStream
//              (it accesses no member variables).
//
// Post-Conditions:
//              If the byte-order indicator is valid, the
//              propset and section headers are byte-swapped
//
// Returns:     None.  *pstatus will only be non-successful
//              if the Stream was too small for the property set
//              (i.e, the property set is corrupt).  If the caller
//              knows this not to be the case, then it can assume
//              that this routine will return STATUS_SUCCESS.
//
//---------------------------------------------------------------------------

VOID
CPropertySetStream::ByteSwapHeaders( IN PROPERTYSETHEADER *pph,
                                     IN DWORD cbstm,
                                     OUT NTSTATUS *pstatus )
{
#if LITTLEENDIAN

    *pstatus = STATUS_SUCCESS;
    return;

#else
    
    //  ------
    //  Locals
    //  ------

    ULONG cSections;
    ULONG ulIndex, ulSectionIndex;

    // pfoPropSet points into pph, pfoReal is a local copy
    // in the system's endian-ness.
    FORMATIDOFFSET *pfoPropSet, pfoReal[2];

    // Pointers into pph.
    PROPERTYSECTIONHEADER *psh = NULL;
    PROPERTYIDOFFSET *po = NULL;

    // Are we converting *to* the system's endian-ness?
    BOOL fToSystemEndian;

    //  ----------
    //  Initialize
    //  ----------

    *pstatus = STATUS_SUCCESS;
    PROPASSERT( NULL != pph );
    PROPASSERT(PROPSET_BYTEORDER == pph->wByteOrder
               ||
               PROPSET_BYTEORDER == ByteSwap( pph->wByteOrder )
              );


    //  ----------------------------
    //  Swap the Property Set header
    //  ----------------------------

    // Validate the stream length.
    if( sizeof(*pph) > cbstm )
    {
        StatusCorruption(pstatus, "CPropertySetStream::ByteSwapHeaders: PropertySet header size");
        goto Exit;
    }

    // Swap the fields in place.
    PropByteSwap( &pph->wByteOrder );
    PropByteSwap( &pph->wFormat );
    PropByteSwap( &pph->dwOSVer );
    PropByteSwap( &pph->clsid );
    PropByteSwap( &pph->reserved );

    // Are we converting to little-endian?
    if( PROPSET_BYTEORDER == pph->wByteOrder)
        fToSystemEndian = TRUE;
    else
    {
        fToSystemEndian = FALSE;
        PROPASSERT( PROPSET_BYTEORDER == PropByteSwap(pph->wByteOrder) );
    }

    // Get the correctly-endianed section count and validate.

    cSections = fToSystemEndian ? pph->reserved
                                : PropByteSwap( pph->reserved );

    if( cSections > 2 )
    {
        StatusCorruption(pstatus, "CPropertySetStream::ByteSwapHeaders: PropertySet header size");
        goto Exit;
    }

    //  -------------------------
    //  Swap the per-section data
    //  -------------------------

    pfoPropSet = (FORMATIDOFFSET*) ((BYTE*) pph + sizeof(*pph));
    
    for( ulSectionIndex = 0; ulSectionIndex < cSections; ulSectionIndex++ )
    {
        ULONG cbSection, cProperties;

        //  ------------------------------
        //  Swap the FormatID/Offset entry
        //  ------------------------------

        // Is the Stream long enough for the array?
        if( cbstm < (ULONG) &pfoPropSet[ulSectionIndex]
                    + sizeof(*pfoPropSet)
                    - (ULONG) pph )
        {
            StatusCorruption(pstatus,
                             "CPropertySetStream::_ByteSwapHeaders: FormatID/Offset size");
            goto Exit;
        }

        // Swap this FMTID/Offset entry in place.
        PropByteSwap( &pfoPropSet[ulSectionIndex].fmtid );
        PropByteSwap( &pfoPropSet[ulSectionIndex].dwOffset );

        // Get a local copy of this array entry.
        // Since we just swapped these values, we may need to swap the
        // local copies back in order to make them usable.

        pfoReal[ ulSectionIndex ].fmtid    = pfoPropSet[ulSectionIndex].fmtid;
        pfoReal[ ulSectionIndex ].dwOffset = pfoPropSet[ulSectionIndex].dwOffset;

        if( !fToSystemEndian )
        {
            PropByteSwap( &pfoReal[ulSectionIndex].fmtid );
            PropByteSwap( &pfoReal[ulSectionIndex].dwOffset );
        }


        //  -----------------------
        //  Swap the section header
        //  -----------------------

        // Locate the section header and the first entry in the
        // PID/Offset table.

        psh = (PROPERTYSECTIONHEADER*)
              ( (BYTE*) pph + pfoReal[ ulSectionIndex ].dwOffset );
        
        po = (PROPERTYIDOFFSET*)
             ( (BYTE*) psh + sizeof(psh->cbSection) + sizeof(psh->cProperties) );

        // Validate that we can see up to the PID/Offset table.
        if( cbstm < (ULONG) ((BYTE*) po - (BYTE*) pph) )
        {
            StatusCorruption(pstatus,
                             "CPropertySetStream::ByteSwapHeaders: Section header size");
            goto Exit;
        }

        // Swap the two fields at the top of the section header,
        // and make local copies.  Again, we may need to swap the
        // local copies to make them usable.

        cbSection = psh->cbSection = PropByteSwap(psh->cbSection);
        cProperties = psh->cProperties = PropByteSwap( psh->cProperties );

        if( !fToSystemEndian)
        {
            PropByteSwap( &cbSection );
            PropByteSwap( &cProperties );
        }

        //  -------------------------
        //  Swap the PID/Offset table
        //  -------------------------

        // Validate that we can see the whole table.
        if( cbstm < (BYTE*) po - (BYTE*) pph + cProperties * sizeof(*po) )
        {
            StatusCorruption(pstatus,
                             "CPropertySetStream::ByteSwapHeaders: Section header size");
            goto Exit;
        }

        // Swap each of the array entries.
        for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )
        {
            PropByteSwap( &po[ulIndex].propid );
            PropByteSwap( &po[ulIndex].dwOffset );
        }

    }   // for( ulSectionIndex = 0; ulSectionIndex < cSections, ulIndex++ )

    //  ----
    //  Exit
    //  ----

Exit:

    return;

#endif // #if LITTLEENDIAN ... #else

}   // CPropertySetStream::ByteSwapHeaders


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CreateUserDefinedSection
//
// Synopsis:    Create second property section
//
// Arguments:   [LoadState]	-- _LoadHeader returned state
//		[LocaleId]	-- Locale Id
//              [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     TRUE if LoadState handled successfully.  If TRUE,
//              *pstatus will be STATUS_SUCCESS.
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_CreateUserDefinedSection(
    IN LOADSTATE LoadState,
    IN ULONG LocaleId,
    OUT NTSTATUS *pstatus)
{
    BOOL fSuccess = FALSE;
    FORMATIDOFFSET *pfo;
    ULONG cbstmNew;
    PROPERTYSECTIONHEADER *psh;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_State & CPSS_USERDEFINEDPROPERTIES);
    switch (_Flags & CREATEPROP_MODEMASK)
    {
    case CREATEPROP_CREATEIF:
    case CREATEPROP_CREATE:
	if (LoadState == LOADSTATE_USERDEFINEDNOTFOUND)
	{
	    ULONG cbmove;

	    PROPASSERT(_cSection == 1);
	    pfo = _GetFormatidOffset(0);
	    PROPASSERT(pfo->fmtid == guidDocumentSummary);
	    PROPASSERT(IsDwordAligned(pfo->dwOffset));

            // Get a pointer to the first section header, using the 
            // FmtID/Offset array.

	    psh = (PROPERTYSECTIONHEADER *) _MapAbsOffsetToAddress(pfo->dwOffset);

            // Determine if we need to move the first section back in order
            // to make room for this new entry in the FmtID/Offset array.

	    cbmove = 0;
	    if (pfo->dwOffset < CB_PROPERTYSETHEADER + 2 * CB_FORMATIDOFFSET)
	    {
		cbmove = CB_PROPERTYSETHEADER + 2*CB_FORMATIDOFFSET - pfo->dwOffset;
	    }

            // How big should the Stream be?

	    cbstmNew = pfo->dwOffset            // The offset of the first section
                            +
			    cbmove              // Room for new FormatID/Offset array entry
                            +                   // Size of first section
			    DwordAlign(psh->cbSection)
                            +                   // Size of User-Defined section.
			    CB_MINUSERDEFSECTIONSIZE;

            // Set the stream size.

	    _MSTM(SetSize)(cbstmNew, TRUE, (VOID **) &_pph, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    // reload all pointers into mapped image:

	    pfo = _GetFormatidOffset(0);
	    psh = (PROPERTYSECTIONHEADER *) _MapAbsOffsetToAddress(pfo->dwOffset);

	    if (cbmove != 0)
	    {
		// Move section back to make room for new FORMATIDOFFSET entry

		PropMoveMemory(
			"_AddSection",
			psh,
			Add2Ptr(psh, cbmove),
			psh,
			psh->cbSection);

		pfo->dwOffset += cbmove;
		PROPASSERT(IsDwordAligned(pfo->dwOffset));
	    }

	    psh->cbSection = DwordAlign(psh->cbSection);

            PROPASSERT(_oSection == 0);
	    PROPASSERT(_cSection == 1);
	    PROPASSERT(_pph->reserved == 1);

	    _cSection++;
	    _pph->reserved++;

	    _oSection = pfo->dwOffset + psh->cbSection;
	    pfo = _GetFormatidOffset(1);
	    pfo->fmtid = guidDocumentSummarySection2;
	    pfo->dwOffset = _oSection;
	    _InitSection(pfo,
                         LocaleId,
                         TRUE ); // Create an empty dictionary.

	    fSuccess = TRUE;
	}
	break;

    case CREATEPROP_DELETE:
	PROPASSERT(
	    LoadState == LOADSTATE_USERDEFINEDDELETE ||
	    LoadState == LOADSTATE_USERDEFINEDNOTFOUND);
	if (LoadState == LOADSTATE_USERDEFINEDDELETE)
	{
	    PROPASSERT(_cSection == 2);
	    PROPASSERT(_pph->reserved == 2);
	    pfo = _GetFormatidOffset(1);
	    RtlZeroMemory(pfo, sizeof(*pfo));

	    _cSection--;
	    _pph->reserved--;
	    pfo = _GetFormatidOffset(0);
	    PROPASSERT(pfo->fmtid == guidDocumentSummary);
	    PROPASSERT(IsDwordAligned(pfo->dwOffset));
	    psh = (PROPERTYSECTIONHEADER *)
			_MapAbsOffsetToAddress(pfo->dwOffset);
	    psh->cbSection = DwordAlign(psh->cbSection);
	    cbstmNew = pfo->dwOffset + psh->cbSection;

	    _MSTM(SetSize)(cbstmNew, TRUE, (VOID **) &_pph, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            
	}
	_State |= CPSS_USERDEFINEDDELETED;

	fSuccess = TRUE;
        break;

    default:
	PROPASSERT(!"_Flags: bad open mode");
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return( fSuccess );
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_Create
//
// Synopsis:    Create property set image
//
// Arguments:   [pfmtid]        -- format id
//              [pclsid]        -- class id
//		[LocaleId]	-- Locale Id
//              [CodePage]      -- CodePage
//		[LoadState]	-- _LoadHeader returned state
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::_Create(
    IN GUID const *pfmtid,
    OPTIONAL IN GUID const *pclsid,
    IN ULONG LocaleId,		    // Locale Id (create only)
    IN USHORT CodePage,
    IN LOADSTATE LoadState,
    OUT NTSTATUS *pstatus
    )
{
    ULONG cb;
    FORMATIDOFFSET *pfo;

    *pstatus = STATUS_SUCCESS;

    _SetModified();

    // Set the size of the stream to correspond to the header for the
    // property set as well as the section.

    _CodePage = CodePage;
    ULONG cSectionT = 1;

    // Are we creating the UserDefined property set
    // (the second section of the DocumentSummaryInformation
    // property set)?

    if (_State & CPSS_USERDEFINEDPROPERTIES)
    {
        // Create the UD propset, and set the cSection.
        // If this routine returns TRUE, it means that
        // the first section already existed, and we're done.
        // Otherwise, we must continue and create the first section.

	if (_CreateUserDefinedSection(LoadState, LocaleId, pstatus))
	{
            // If we get here, we know that *pstatus is Success.

	    if (pclsid != NULL)
	    {
		_pph->clsid = *pclsid;
	    }
	    goto Exit;
	}
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

	cSectionT = 2;
    }

    // Calculate the exact size of the Stream (we know exactly
    // what it will be because we only initialize the set(s) with
    // fixed size data).

    PROPASSERT( 1 <= cSectionT && cSectionT <= 2 );
    cb = CB_PROPERTYSETHEADER       // The size of the propset header.
         +                          // The size of the FmtID/Offset array
         cSectionT * CB_FORMATIDOFFSET
         +
         CB_MINSECTIONSIZE          // The size of the first section
         +                          // Maybe the size of the User-Defined section
         ( cSectionT <= 1 ? 0 : CB_MINUSERDEFSECTIONSIZE );


    DebugTrace(0, Dbg, ("SetSize(%x) init\n", cb));

    // Set the size of the stream 
    _MSTM(SetSize)(cb, TRUE, (VOID **) &_pph, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // And get a mapping of the Stream.
    _MSTM(Map)(TRUE, (VOID **) &_pph);
    RtlZeroMemory(_pph, cb);            // Zeros classid, fmtid(s), etc

    // Initialize the header

    _pph->wByteOrder = 0xfffe;
    //_pph->wFormat = 0;                // RtlZeroMemory does this
    PROPASSERT(_pph->wFormat == 0);
    _pph->dwOSVer = PROPSETVER_CURRENT;
    if (pclsid != NULL)
    {
	_pph->clsid = *pclsid;
    }
    _pph->reserved = cSectionT;

    // Initialize the format id offset for the section(s).

    pfo = _GetFormatidOffset(0);
    pfo->dwOffset = CB_PROPERTYSETHEADER + cSectionT * CB_FORMATIDOFFSET;

    // Are we creating the second section of the DocSumInfo property set?

    if (cSectionT == 2)
    {
        // We need to initialize any empty first section.

	pfo->fmtid = guidDocumentSummary;

	_InitSection(pfo,
                     LocaleId,
                     FALSE); // Don't create an empty dictionary.

        // Advance the FmtID/Offset table pointer to the second entry,
        // and set it's offset to just beyond the first section.

	pfo = _GetFormatidOffset(1);
	pfo->dwOffset = CB_PROPERTYSETHEADER +
			cSectionT * CB_FORMATIDOFFSET +
			CB_MINSECTIONSIZE;
    }

    // Initialize the requested property set.

    PROPASSERT(pfmtid != NULL);
    pfo->fmtid = *pfmtid;
    _InitSection(pfo,
                 LocaleId,
                           // TRUE => Create an empty dictionary
                 pfo->fmtid == guidDocumentSummarySection2 );

    _cSection = cSectionT;
    _oSection = pfo->dwOffset;


    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_Create


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_LoadHeader
//
// Synopsis:    verify header of a property set and read the code page
//
// Arguments:   [pfmtid]        -- format id
//		[Mode]		-- open mode
//              [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     LOADSTATE
//---------------------------------------------------------------------------

LOADSTATE
CPropertySetStream::_LoadHeader(
    OPTIONAL IN GUID const *pfmtid,
    IN BYTE Mode,
    OUT NTSTATUS *pstatus)
{
    LOADSTATE loadstate = LOADSTATE_FAIL;
    ULONG cbstm, cbMin;
    PROPERTYSECTIONHEADER *psh;
    FORMATIDOFFSET const *pfo;
    BOOLEAN fSummaryInformation = FALSE;
#if DBGPROP
    BOOLEAN fFirst = _pph == NULL;
#endif

    *pstatus = STATUS_SUCCESS;

    PROPASSERT((_State & CPSS_USERDEFINEDDELETED) == 0);

    // If this is one of the DocSumInfo property sets,
    // we need to set some _State bits.  If this is an
    // Open, rather than a Create, pfmtid may be NULL.
    // In that case, we'll set these bits after the open
    // (since we can then get the fmtid from the header).

    if( pfmtid != NULL && *pfmtid == guidDocumentSummary )
    {
        _State |= CPSS_DOCUMENTSUMMARYINFO;
    }

    if (pfmtid != NULL && *pfmtid == guidDocumentSummarySection2)
    {
	_State |= CPSS_USERDEFINEDPROPERTIES;
    }
    else
    {
        // If this isn't the UD property set, the Mode
        // better not be "Delete" (all other property sets
        // are deleted simply be deleting the underlying
        // stream).

	if (Mode == CREATEPROP_DELETE)
	{
	    DebugTrace(0, Dbg, ("_LoadHeader: CREATEPROP_DELETE\n"));
	    StatusInvalidParameter(pstatus, "_LoadHeader: CREATEPROP_DELETE");
            goto Exit;
	}
	if (Mode == CREATEPROP_CREATE)
	{
	    goto Exit;  // We're going to overwrite it anyway
	}
    }

    // Get the size of the underlying stream.
    cbstm = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Map the serialized property set to a pointer.
    _MSTM(Map)(FALSE, (VOID **) &_pph);

    cbMin = _ComputeMinimumSize(cbstm, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // The following assert should technically ASSERT equality.  However,
    // to avoid unmapping and closing sections for every property operation,
    // we allow shrinks to fail when other instances of the same property
    // set are active.  So we on occasion will legitimately see streams larger
    // than necessary.  The wasted space will be cleaned up when the property
    // set is next modified.

    //PROPASSERT(cbMin == cbstm);
    PROPASSERT(cbMin <= cbstm);
    DebugTrace(0, KERNELSELECT(Dbg, Dbg | DEBTRACE_CREATESTREAM), (
        "ComputeMinimumSize: cbMin=%l" szX " cbstm=%l" szX " cbUnused=%l" szX "\n",
        cbMin,
        cbstm,
        cbstm - cbMin));

    _oSection = 0;
    _cSection = 1;
    _cbTail = 0;

    if (_HasPropHeader())
    {
	// The first expression must be TRUE before we can dereference _pph
	// for the second expression.

        if (cbstm < CB_PROPERTYSETHEADER + CB_FORMATIDOFFSET ||
	    cbstm < CB_PROPERTYSETHEADER + _pph->reserved * CB_FORMATIDOFFSET ||
            _pph->wByteOrder != 0xfffe ||
            _pph->wFormat != 0 ||
            _pph->reserved < 1)
        {
            _cSection = 0;		// Mark property set invalid
            DebugTrace(0, cbstm != 0? DEBTRACE_ERROR : Dbg, (
                "_LoadHeader: %s (ver=%lx)\n",
                cbstm == 0? "Empty Stream" :
		    cbstm < CB_PROPERTYSETHEADER + CB_FORMATIDOFFSET?
			"Stream too small for header" :
		    _pph->wByteOrder != 0xfffe? "Bad wByteOrder field" :
		    _pph->wFormat != 0? "Bad wFormat field" :
		    _pph->reserved < 1? "Bad reserved field" :
                    "Bad dwOSVer field",
                _pph != NULL? _pph->dwOSVer : 0));
            goto Exit;
        }

        // Now that we've loaded the property set, check again
        // to see if this is a SumInfo or DocSumInfo set.

        pfo = _GetFormatidOffset(0);
	if (pfo->fmtid == guidDocumentSummary)
	{
	    _State |= CPSS_DOCUMENTSUMMARYINFO;
	}
        else if (pfo->fmtid == guidSummary)
        {
            fSummaryInformation = TRUE;
        }

        // If what we're after is the property set in the
        // second section, verify that it's there.

        if (_State & CPSS_USERDEFINEDPROPERTIES)
	{
            // Ensure that this is the second section of
            // the DocSumInfo property set; that's the only
            // two-section property set we support.

	    if ((_State & CPSS_DOCUMENTSUMMARYINFO) == 0)
	    {
		DebugTrace(0, DEBTRACE_ERROR, ("Not DocumentSummaryInfo 1st FMTID\n"));
		goto Exit;
	    }

            // Verify that this proeprty set has two sections, and that
            // the second section is the UD propset.

	    if (_pph->reserved < 2 ||
		(pfo = _GetFormatidOffset(1))->fmtid != guidDocumentSummarySection2)
	    {
		DebugTrace(
			0,
			_pph->reserved < 2? Dbg : DEBTRACE_ERROR,
			("Bad/missing 2nd section FMTID\n"));
		loadstate = LOADSTATE_USERDEFINEDNOTFOUND;
                goto Exit;
	    }
	}
	else if (pfmtid != NULL)
        {
            // This isn't the UserDefined property set, so it
            // should be the first section, so it should match
            // the caller-requested format ID.

            if (*pfmtid != pfo->fmtid)
            {
                // The propset's FmtID doesn't match, but maybe that's
                // because it's a MacWord6 SumInfo property set, in which
                // the FmtID isn't byte-swapped.  Otherwise, it's a problem.

                if( OSKIND_MACINTOSH == PROPSETHDR_OSVER_KIND(_pph->dwOSVer)
                    &&
                    guidSummary == *pfmtid
                    &&
                    IsEqualFMTIDByteSwap( *pfmtid, pfo->fmtid )
                  )
                {
                    fSummaryInformation = TRUE;
                }
                else
	        {
                    _cSection = 0;
	            DebugTrace(0, DEBTRACE_ERROR, ("Bad FMTID\n"));
                    loadstate = LOADSTATE_BADFMTID;
                    goto Exit;
	        }
            }   // if (*pfmtid != pfo->fmtid)
        }   // else if (pfmtid != NULL)

        _oSection = pfo->dwOffset;
        _cSection = _pph->reserved;

    }   // if (_HasPropHeader())

    psh = _GetSectionHeader();

    if (cbstm < _oSection + CB_PROPERTYSECTIONHEADER ||
        psh->cbSection < CB_PROPERTYSECTIONHEADER +
            psh->cProperties * CB_PROPERTYIDOFFSET ||
        cbstm < _oSection + CB_PROPERTYSECTIONHEADER +
            psh->cProperties * CB_PROPERTYIDOFFSET ||
        cbstm < _oSection + psh->cbSection)
    {
        _cSection = 0;
        DebugTrace(0, Dbg, ("_LoadHeader: too small for section\n"));
        goto Exit;
    }

    if (_HasPropHeader())
    {
        // Scan the property set for a code page, and set _CodePage.
        
        _SearchForCodePage( pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // If we have multiple sections, record the tail length
        // (the size of the property set beyond this section).

	if (_cSection > 1)
	{
	    _State |= CPSS_MULTIPLESECTIONS;
	    _cbTail = cbMin - (_oSection + psh->cbSection);
	    DebugTrace(0, Dbg, ("_LoadHeader: cbTail=%x\n", _cbTail));
	}

        // Fix all the problems we know how to fix in the in-memory
        // representation of the property set.

        if (fSummaryInformation || (_State & CPSS_DOCUMENTSUMMARYINFO))
        {
	    if (fSummaryInformation)
	    {
		_FixSummaryInformation(&cbstm, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
	    }

	    _FixPackedPropertySet( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }

	if (Mode == CREATEPROP_DELETE)
	{
	    loadstate = LOADSTATE_USERDEFINEDDELETE;
            goto Exit;
	}
    }

    //  ----
    //  Exit
    //  ----

    loadstate = LOADSTATE_DONE;

Exit:

    return( loadstate );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixSummaryInformation
//
// Synopsis:    Fix up the memory image of a SummaryInformation propset,
//              except for packing or padding problems (which are fixed
//              in _FixPackedPropertySet).
//
// Arguments:   [pcbstm]    - The size of the mapped stream.  This may
//                            be updated by this routine.
//              [pstatus]   - Pointer to NTSTATUS code.
//
// Returns:     None
//---------------------------------------------------------------------------

#define PID_THUMBNAIL	0x00000011  // SummaryInformation thumbnail property

VOID
CPropertySetStream::_FixSummaryInformation(IN OUT ULONG *pcbstm,
                                           OUT NTSTATUS *pstatus)
{
    PROPERTYSECTIONHEADER *psh;
    PROPERTYIDOFFSET *ppo, *ppoMax;

    *pstatus = STATUS_SUCCESS;

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    //  Look for the MS Publisher problem.  Pub only writes
    //  a Thumbnail, but it sets the section size too short (by 4 bytes).
    //  Pub95 has the additional problem that it doesn't DWORD-align the
    //  section and stream size.  We fix both of these problems below.

    // Skip all of this processing unless it looks like the Publisher problem.

    if (psh != NULL && *pcbstm == _oSection + psh->cbSection + sizeof(ULONG))
    {
        // Look for the thumbnail property.

	for ( ; ppo < ppoMax; ppo++)
	{
	    if (ppo->propid == PID_THUMBNAIL)
	    {
		SERIALIZEDPROPERTYVALUE const *pprop;

                // If this property isn't properly aligned, then ignore it.

		if (ppo->dwOffset & (sizeof(DWORD) - 1))
		{
		    break;
		}

                // Get a pointer to the property.

		pprop = (SERIALIZEDPROPERTYVALUE *)
			    _MapOffsetToAddress(ppo->dwOffset);

                // Look specifically for the Publisher's Thumbnail property.
                // If this is a Publisher set, the lengths won't add
                // up correctly.  For the lengths to add up correctly,
                // the offset of the property, plus
                // the length of the thumbnail, plus the size of the VT
                // DWORD and the size of the length DWORD should be the
                // size of the Section.  But In the case of Publisher,
                // the section length is 4 bytes short.

		if (PropByteSwap(pprop->dwType) == VT_CF                // It's in a clipboard format
                    &&                                                  // For Windows
		    *(ULONG *) &pprop->rgb[sizeof(ULONG)] == PropByteSwap((ULONG)MAXULONG)
                    &&
		    ppo->dwOffset +                                     // And the lengths don't add up
			PropByteSwap( *(ULONG *) pprop->rgb ) +
			(3 - 2) * sizeof(ULONG) == psh->cbSection)
		{
                    // We've found the Publisher problem.

                    // For Pub95 files, we must dword-align the section
                    // and stream size.  We don't change the size of the underlying
                    // stream, however, just the mapping.  This is because if the caller
                    // doesn't make any explicit changes, we don't want the mapped Stream
                    // to be modified.  We do this step before fixing the section-size
                    // problem, so if it should fail we haven't touched anything.

                    if( !IsDwordAligned( *pcbstm ))
                    {
                        // Increase the size of the buffer, and reload the
                        // psh pointer.

                        *pcbstm += DwordRemain(*pcbstm);
    	                _MSTM(SetSize)(*pcbstm,             // The new size
                                       FALSE,               // Don't update the underlying stream
                                       (VOID **) &_pph,     // The new mapping
                                       pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // Align the section size.

                        psh->cbSection += DwordRemain(psh->cbSection);
                    }

                    // Now correct the section size.

		    DebugTrace(0, DEBTRACE_PROPPATCH, (
			"_FixSummaryInformation: Patch section size: %x->%x\n",
			psh->cbSection,
			psh->cbSection + sizeof(ULONG)));

                    psh->cbSection += sizeof(ULONG);

		}   // if (pprop->dwType == VT_CF ...

		break;

	    }   // if (ppo->propid == PID_THUMBNAIL)
	}   // for ( ; ppo < ppoMax; ppo++)
    }   // if (psh != NULL && cbstm == _oSection + psh->cbSection + sizeof(ULONG))

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixPackedPropertySet
//
// Synopsis:    Align the memory image of a propset.
//
// Algorithm:   We need to move the properties within the
//              property set so that they are properly aligned,
//              and we need to adjust the PID/Offset array accordingly.
//              This is complicated by the fact that we may have to 
//              grow some propertes (which are not properly padded
//              for alignement) and at the same time we may have to
//              shrink some properties (which are over-padded).
//
//              To handle these two constraints, and to 
//              avoid growing the underlying stream any more
//              than necessary, we process the property set in
//              two phases.  In the Compaction phase, we shrink
//              properties which are over-padded.  In the Expansion
//              phase, we grow properties which are under-padded.
//              For example, say we have a property set with 3
//              properties, all of which should be 4 bytes.  But
//              say they are currently 2, 4, and 6 bytes.  Thus
//              we must grow the first property, hold the second
//              constant, and shrink the third property.  In this
//              example, after the Compaction phase, the 3 properties
//              will be 2, 4, and 4 bytes.  After the Expansion phase,
//              the properties will be 4, 4, and 4 bytes.
//
//              To do all of this, we make a copy of the PID/Offset
//              array (apoT) and sort it.  We then proceed to make
//              two arrays of just offsets (no PIDs) - aopropShrink
//              and aopropFinal.  aopropShrink holds the offset for
//              each property after the Compaction phase.  aopropFinal
//              holds the offset for each property after the
//              Expansion phase.  (Note that each of these phases
//              could be skipped if they aren't necessary.)
//
//              Finally, we perform the Compaction and Expansion,
//              using aopropShrink and aopropFinal, respectively,
//              as our guide.
//
// Arguments:   [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     None
//---------------------------------------------------------------------------

INT __cdecl fnOffsetCompare(VOID const *ppo1, VOID const *ppo2);

// DocumentSummaryInformation special case properties (w/packed vector elements)
#define PID_HEADINGPAIR 0x0000000c // heading pair (VT_VECTOR | VT_VARIANT):
					// {VT_LPSTR, VT_I4} pairs
#define PID_DOCPARTS	0x0000000d // docparts (VT_VECTOR | VT_LPSTR)
//#define PID_HLINKS	0x00000015 // hlinks vector

VOID
CPropertySetStream::_FixPackedPropertySet(OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    BOOLEAN fPacked = FALSE;
    BOOLEAN fDocSummaryInfo = FALSE;
#if DBGPROP
    BOOLEAN fExpandDocSummaryInfo = FALSE;
#endif
    PROPERTYSECTIONHEADER *psh = NULL;
    PROPERTYIDOFFSET *ppoT, *ppoTMax;
    PROPERTYIDOFFSET *ppo, *ppoBase, *ppoMax;

    PROPERTYIDOFFSET *apoT = NULL;

    ULONG *aopropShrink = NULL;
    ULONG *aopropFinal = NULL;
    ULONG cbprop;
    ULONG cCompact, cExpand;
    ULONG *poprop = NULL;

#if i386 == 0
    SERIALIZEDPROPERTYVALUE *ppropbuf = NULL;
#endif
    ULONG cbtotal = 0;
    ULONG cbpropbuf;
    //  -----
    //  Begin
    //  -----

    *pstatus = STATUS_SUCCESS;

    // Determine if this is the first section of the DocSumInfo
    // property set.
    if ((_State & (CPSS_USERDEFINEDPROPERTIES | CPSS_DOCUMENTSUMMARYINFO)) ==
	 CPSS_DOCUMENTSUMMARYINFO)
    {
	fDocSummaryInfo = TRUE;
    }

    // Get pointers into this section's header.
    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // We know it's packed if the section-length isn't aligned.
    fPacked = !IsDwordAligned(psh->cbSection);

    // If we don't already know it's packed, check each of the properties in 
    // the PID/Offset array to see if one is not properly aligned, if so we'll
    // assume that it's packed.  Also, if this is an Ansi DocSumInfo property set,
    // (first section), we'll assume that the HeadingPair and DocParts properties
    // are packed (vectors).
   
    if (!fPacked && psh != NULL)
    {
	for (ppo = ppoBase; ppo < ppoMax; ppo++)
	{
	    if ( !IsDwordAligned(ppo->dwOffset)
                 ||
		 ( fDocSummaryInfo
                   &&
                   _CodePage != CP_WINUNICODE
                   &&
		   ( ppo->propid == PID_HEADINGPAIR
                     ||
		     ppo->propid == PID_DOCPARTS
                   )
                 )
               )
	    {
		fPacked = TRUE;
		break;
	    }
	}
    }

    //  ----------------------------------------------------
    //  Fix the properties if they are packed or if there is
    //  unnecessary padding.
    //  ----------------------------------------------------

    // If we know there's a problem, set a _State flag
    // now.  If we can fix the problem below, we'll clear it.
    // Otherwise, the rest of the Class will know that there's
    // an unresolved problem.

    if (fPacked)
    {
	DebugTrace(0, DEBTRACE_PROPPATCH, (
	    "_FixPackedPropertySet: packed properties\n"));
        _State |= CPSS_PACKEDPROPERTIES;
    }


    //  ---------------------------------------------------------
    //  Create apoT (a sorted array of PID/Offsets), aopropShrink
    //  (the offsets for the Compaction phase) and aopropFinal
    //  (the offsets for the Expansion phase).
    //  ---------------------------------------------------------

    // Create a buffer for a temporary PID/Offset array.

    apoT = newk(mtPropSetStream, NULL) PROPERTYIDOFFSET[psh->cProperties + 1];
    if (apoT == NULL)
    {
	*pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Copy the PID/offset pairs from the property set to the
    // temporary PID/Offset array.

    RtlCopyMemory(
	    apoT,
	    psh->rgprop,
	    psh->cProperties * CB_PROPERTYIDOFFSET);

    // Mark the end of the temporary array.

    ppoTMax = apoT + psh->cProperties;
    ppoTMax->propid = PID_ILLEGAL;
    ppoTMax->dwOffset = psh->cbSection;

    // Sort the PID/Offset array by offset and check for overlapping values:

    qsort(apoT, psh->cProperties, sizeof(apoT[0]), fnOffsetCompare);

    // Create two arrays which will hold property offsets.
    // aopropShrink holds the offsets for the Compaction phase where
    // we shrink the property set.  aopropFinal holds the offsets
    // of the final property set, which will be achieved in the
    // Expansion phase.

    aopropShrink = newk(mtPropSetStream, NULL) ULONG[psh->cProperties + 1];
    if (aopropShrink == NULL)
    {
	*pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    aopropFinal = newk(mtPropSetStream, NULL) ULONG[psh->cProperties + 1];
    if (aopropFinal == NULL)
    {
	*pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

#if i386 == 0
    // On non-x86 machines, we can't directly access unaligned
    // properties.  So, allocate enough (aligned) memory to hold
    // the largest unaligned property.  We'll copy properties here
    // when we need to access them.

    cbpropbuf = 0;

    for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
    {
	if (!IsDwordAligned(ppoT->dwOffset))
	{
	    cbprop = DwordAlign(ppoT[1].dwOffset - ppoT->dwOffset);
	    if (cbpropbuf < cbprop)
	    {
		cbpropbuf = cbprop;
	    }
	}
    }

    if (cbpropbuf != 0)
    {
	ppropbuf = (SERIALIZEDPROPERTYVALUE *)
			newk(mtPropSetStream, NULL) BYTE[cbpropbuf];
	if (ppropbuf == NULL)
	{
	    *pstatus = STATUS_NO_MEMORY;
            goto Exit;
	}
    }
#endif  // i386==0


    //  ----------------------------------------------
    //  Iterate through the properties, filling in the
    //  entries of aopropShrink and aopropFinal.
    //  ----------------------------------------------

    // We'll also count the number of compacts and expands
    // necessary.

    aopropShrink[0] = aopropFinal[0] = apoT[0].dwOffset;
    PROPASSERT(IsDwordAligned(aopropShrink[0]));
    cExpand = 0;
    cCompact = 0;

    for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
    {
	SERIALIZEDPROPERTYVALUE *pprop;
	BOOLEAN fDocSumLengthComputed = FALSE;
        ULONG cbpropOriginal;

        // How much space does the property take up in the current
        // property set?

	cbpropOriginal = cbprop = ppoT[1].dwOffset - ppoT->dwOffset;
	pprop = (SERIALIZEDPROPERTYVALUE *)
		    _MapOffsetToAddress(ppoT->dwOffset);

#if i386 == 0
        // If necessary, put this property into an aligned buffer.

	if (!IsDwordAligned(ppoT->dwOffset))
	{
	    DebugTrace(0, Dbg, (
		"_FixPackedPropertySet: unaligned pid=%x off=%x\n",
		ppoT->propid,
		ppoT->dwOffset));
	    PROPASSERT(DwordAlign(cbprop) <= cbpropbuf);
	    RtlCopyMemory((VOID *) ppropbuf, pprop, cbprop);
	    pprop = ppropbuf;
	}
#endif
        // Calculate the actual length of this property, including
        // the necessary padding.  This might be bigger than the
        // property's current length (if the propset wasn't properly
        // padded), and it might be smaller than the property's current
        // length (if the propset was over-padded).

	if (ppoT->propid == PID_DICTIONARY)
	{
            // Get the size of the dictionary.

	    cbprop = DwordAlign(_DictionaryLength(
				    (DICTIONARY const *) pprop,
				    cbprop,
                                    pstatus));
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
	}
	else
	{
	    ULONG cbpropT;

            // Ansi DocSumInfo property sets have two vector properties
            // which are packed.  If this is one of those properties,
            // we won't fix it yet, but we'll compute the size required
            // when the elements are un-packed.

	    if (fDocSummaryInfo && _CodePage != CP_WINUNICODE)
	    {
		if (ppoT->propid == PID_HEADINGPAIR)
		{
		    fDocSumLengthComputed = _FixHeadingPairVector(
					    PATCHOP_COMPUTESIZE,
					    pprop,
					    &cbpropT);
		}
		else
		if (ppoT->propid == PID_DOCPARTS)
		{
		    fDocSumLengthComputed = _FixDocPartsVector(
					    PATCHOP_COMPUTESIZE,
					    pprop,
					    &cbpropT);
		}
	    }

            // If we computed a length above, use it, otherwise calculate
            // the length using the standard rules (we've already checked
            // for the special cases).

	    if (fDocSumLengthComputed)
	    {
		cbprop = cbpropT;
#if DBGPROP
		fExpandDocSummaryInfo = TRUE;
#endif
	    }
	    else
	    {
		cbprop = PropertyLength(pprop, DwordAlign(cbprop), 0, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
	    }

	}   // if (ppoT->propid == PID_DICTIONARY) ... else

	PROPASSERT(IsDwordAligned(cbprop));

        // Now that we know the actual cbprop, use it to update the
        // *next* entry in the two arrays of correct offsets.
        //
        // We want aopropFinal to hold the final, correct offsets,
        // so we'll use cbprop to calculate this array.
        // But for aopropShrink, we only want it to differ from
        // the original array (apoT) when a property is shrinking,
        // so we'll use min(cbNew,cbOld) for this array.

        poprop = &aopropShrink[ ppoT - apoT ]; // 1st do aopropShrink
        poprop[1] = poprop[0] + min(cbprop, cbpropOriginal);

        poprop = &aopropFinal[ ppoT - apoT ];  // 2nd do aopropFinal
        poprop[1] = poprop[0] + cbprop;

	DebugTrace(0, Dbg, (
	    "_FixPackedPropertySet: pid=%x off=%x->%x\n",
	    ppoT->propid,
	    ppoT->dwOffset,
	    poprop[0],
	    poprop[0] < ppoT->dwOffset?
		" (compact)" :
		poprop[0] > ppoT->dwOffset? " (expand)" : ""));


        // Is this compaction or an expansion?
        // If we computed the doc-sum length, we count it as
        // an expansion, even if the total property size didn't change,
        // because we need the expand the elements within the vector.

	if (cbprop < cbpropOriginal)
	{
	    cCompact++;
	}
	else
	if (cbprop > cbpropOriginal || fDocSumLengthComputed)
	{
	    cExpand++;
	}
    }   // for (ppoT = apoT; ppoT < ppoTMax; ppoT++)


    //  -------------------------------
    //  Compact/Expand the Property Set
    //  -------------------------------

    // We've now generated the complete aopropShrink and aopropFinal
    // offset arrays.  Now, if necessary, let's expand and/or compact
    // the property set to match these offsets.

    if (cExpand || cCompact)
    {
	ULONG cbstm;
	LONG cbdelta;

	cbstm = _oSection + psh->cbSection + _cbTail;
	cbdelta = aopropFinal[psh->cProperties] - psh->cbSection;

	DebugTrace(0, Dbg, (
	    "_FixPackedPropertySet: cbstm=%x cbdelta=%x cexpand=%x ccompact=%x\n",
	    cbstm,
	    cbdelta,
	    cExpand,
	    cCompact));

        //  -----------------------------
        //  Grow the Stream if necessary.
        //  -----------------------------

        if (cbdelta > 0)
	{
	    DebugTrace(0, Dbg, (
		"SetSize(%x) _FixPackedPropertySet grow %x bytes\n",
		cbstm + cbdelta,
		cbdelta));
             
            // On the set-size, say that this is a non-persistent
            // change, so that the underlying Stream isn't modified.
            // At this point, we don't know if this change should remain
            // permanent (if the caller closes without making any changes
            // the file should remain un-changed). 

	    _MSTM(SetSize)(
		    cbstm + cbdelta,
                    FALSE,   // Not persistent
		    (VOID **) &_pph,
                    pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    // reload all pointers into mapped image:

	    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    // If there's another section after this one, move it back
	    // to the end of the stream now, which will create room for
            // our expansion.

	    if (_cbTail != 0)
	    {
		VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

		PropMoveMemory(
			"_FixPackedPropertySet(_cbTail:grow)",
			psh,
			Add2Ptr(pvSrc, cbdelta),
			pvSrc,
			_cbTail);
	    }
	}   // if (cbdelta > 0)

        // This previous step (growing the Stream), was the last one which can
        // fail.  We're about to modify the actual property set (we've been
        // working only with temporary buffers so far).  So we're always guaranteed
        // a good property set, or the original set, we'll never end up with a
        // half-updated set.


        //  ----------------
        //  Compaction Phase
        //  ----------------

        // Compact the property set if necessary.  I.e., adjust
        // the property set buffer so that it matches aopropShrink.

        if (cCompact > 0)
	{
	    // Start at the beginning and move each property up.

	    poprop = aopropShrink;
	    for (ppoT = apoT; ppoT < ppoTMax; ppoT++, poprop++)
	    {
		if (*poprop != ppoT->dwOffset)
		{
		    PROPASSERT(*poprop < ppoT->dwOffset);
		    PROPASSERT(poprop[1] > *poprop);

		    // We're compacting; the property should not grow!

		    PROPASSERT(
			poprop[1] - *poprop <=
			ppoT[1].dwOffset - ppoT->dwOffset);

		    PropMoveMemory(
			    "_FixPackedPropertySet(compact)",
			    psh,
			    Add2Ptr(psh, *poprop),
			    Add2Ptr(psh, ppoT->dwOffset),
			    poprop[1] - *poprop);
		}
	    }   // for (ppoT = apoT; ppoT < ppoTMax; ppoT++, poprop++)
	}   // if (cCompact > 0)


        //  ---------------
        //  Expansion phase
        //  ---------------

        // Recall that, whether or not we just did a compaction, aopropShrink
        // holds the property set offsets as they currently exist in the
        // property set.

        if (cExpand > 0)
        {
	    // Start at the end and move each property back.
            // The 'poprop' gives us the final correct offset
            // of the current property.

            LONG lOffsetIndex;
	    poprop = &aopropFinal[psh->cProperties - 1];

            // Start at the second-to-last entry in the arrays of offsets
            // (the last entry is an artificially added one to mark the end of the
            // property set).

	    for (lOffsetIndex = ppoTMax - apoT - 1, ppoT = ppoTMax - 1;
                 lOffsetIndex >=0;
                 lOffsetIndex--, poprop--, ppoT--)
	    {
                // Get a pointer to the final location of this
                // property.

		SERIALIZEDPROPERTYVALUE *pprop;
		pprop = (SERIALIZEDPROPERTYVALUE *)
			    Add2Ptr(psh, *poprop);

		if (*poprop != aopropShrink[ lOffsetIndex ])
		{
		    ULONG cbCopy, cbOld;
			
		    PROPASSERT(*poprop > aopropShrink[ lOffsetIndex ]);
		    PROPASSERT(poprop[1] > *poprop);
                    PROPASSERT(aopropShrink[ lOffsetIndex+1 ] > aopropShrink[ lOffsetIndex ]);

                    // How many bytes should we copy?  The minimum size of the property
                    // calculated using the old and new offsets.

		    cbCopy = poprop[1] - poprop[0];
		    cbOld = aopropShrink[ lOffsetIndex+1 ]
                            - aopropShrink[ lOffsetIndex+0 ];

		    if (cbCopy > cbOld)
		    {
			cbCopy = cbOld;
		    }

                    // Copy the property from its old location
                    // (psh+aopropShrink[lOffsetIndex]) to its new location
                    // (pprop == psh+*poprop).

		    DebugTrace(0, DEBTRACE_PROPPATCH, (
			"_FixPackedPropertySet:move pid=%x off=%x->%x "
			    "cb=%x->%x cbCopy=%x z=%x @%x\n",
			ppoT->propid,
			ppoT->dwOffset,
			*poprop,
			cbOld,
			poprop[1] - *poprop,
			cbCopy,
			DwordRemain(cbCopy),
			_MapAddressToOffset(Add2Ptr(pprop, cbCopy))));

		    PropMoveMemory(
			    "_FixPackedPropertySet(expand)",
			    psh,
			    pprop,
			    Add2Ptr(psh, aopropShrink[ lOffsetIndex ]),
			    cbCopy);
		    RtlZeroMemory(
			    Add2Ptr(pprop, cbCopy),
			    DwordRemain(cbCopy));

		}   // if (*poprop != ppoT->dwOffset)

                // If this is an older DocSumInfo property set,
                // and this property is one of the vector values,
                // we must expand the vector elements now that we've
                // room for it.

		if (fDocSummaryInfo && _CodePage != CP_WINUNICODE)
		{
		    ULONG cbpropT;

		    if (ppoT->propid == PID_HEADINGPAIR)
		    {
			_FixHeadingPairVector(
					PATCHOP_EXPAND,
					pprop,
					&cbpropT);
		    }
		    else
		    if (ppoT->propid == PID_DOCPARTS)
		    {
			_FixDocPartsVector(
					PATCHOP_EXPAND,
					pprop,
					&cbpropT);
		    }
		}   // if (fDocSummaryInfo)
	    }   // for (ppoT = ppoTMax; --ppoT >= apoT; popropNew--)
	}   // if (cExpand != 0)



        //  ---------------------------------------------------------
	//  Patch the section size and the moved properties' offsets.
        //  ---------------------------------------------------------

	DebugTrace(0, DEBTRACE_PROPPATCH, (
	    "_FixPackedPropertySet: Patch section size %x->%x\n",
	    psh->cbSection,
	    psh->cbSection + cbdelta));

	psh->cbSection += cbdelta;

        // Iterate through the original PID/Offset array to update the
        // offsets.

	for (ppo = ppoBase; ppo < ppoMax; ppo++)
	{
            // Search the temporary PID/Offset array (which has the updated
            // offsets) for ppo->propid.

	    for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
	    {
		if (ppo->propid == ppoT->propid)
		{
                    // We've found ppo->propid in the temporary PID/Offset
                    // array.  Copy the offset value from the temporary array
                    // to the actual array in the property set.

		    PROPASSERT(ppo->dwOffset == ppoT->dwOffset);
		    ppo->dwOffset = aopropFinal[ppoT - apoT];
#if DBGPROP
		    if (ppo->dwOffset != ppoT->dwOffset)
		    {
			DebugTrace(0, DEBTRACE_PROPPATCH, (
			    "_FixPackedPropertySet: Patch propid %x"
				" offset=%x->%x\n",
			    ppo->propid,
			    ppoT->dwOffset,
			    ppo->dwOffset));
		    }   // if (ppo->dwOffset != ppoT->dwOffset)
#endif
		    break;

		}   // if (ppo->propid == ppoT->propid)
	    }   // for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
	}   // for (ppo = ppoBase; ppo < ppoMax; ppo++)

        //  ------------
        //  Fix the tail
        //  ------------


        // If we have a tail, fix it's offset in the FmtID/Offset
        // array.  Also, if we've overall shrunk this section, bring
        // the tail in accordingly.

        if (_cbTail != 0)
	{
	    if (cbdelta < 0)
	    {
		VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

		PropMoveMemory(
			"_FixPackedPropertySet(_cbTail:shrink)",
			psh,
			Add2Ptr(pvSrc, cbdelta),
			pvSrc,
			_cbTail);
	    }

	    _PatchSectionOffsets(cbdelta);

	}   // if (_cbTail != 0)


        // If we get to this point we've successfully un-packed (or
        // un-over-padded) the property set, so we can clear the
        // state flag.

	_State &= ~CPSS_PACKEDPROPERTIES;

    }   // if (cExpand || cCompact)


    //  ----
    //  Exit
    //  ----

Exit:

    delete [] apoT;
    delete [] aopropShrink;
    delete [] aopropFinal;

#if i386 == 0
    delete [] (BYTE *) ppropbuf;
#endif // i386

}   // CPropertySetStream::_FixPackedPropertySet()


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixDocPartsVector
//
// Synopsis:    Align the memory image of a DocParts vector
//              The DocParts property is part of the DocSumInfo
//              property set (first section).  It is a vector
//              of strings, and in Ansi property sets it's packed
//              and must be un-packed.
//
// Arguments:	[PatchOp]	-- patch request
//		[pprop]         -- property value to be patched or sized
//		[pcbprop]	-- pointer to computed property length
//
// Returns:     TRUE if property type and all elements meet expectations;
//		FALSE on error
//
// Note:	Operate on a DocumentSummaryInformation first section property,
//		PID_DOCPARTS.  This property is assumed to be an array of
//		VT_LPSTRs.
//
//		PATCHOP_COMPUTESIZE merely computes the size required to unpack
//		the property, and must assume it is currently unaligned.
//
//		PATCHOP_ALIGNLENGTHS patches all VT_LPSTR lengths to DWORD
//		multiples, and may rely on the property already being aligned.
//
//		PATCHOP_EXPAND expands the property from the Src to Dst buffer,
//		moving elements to DWORD boundaries, and patching VT_LPSTR
//		lengths to DWORD multiples.  The Src buffer is assumed to be
//		unaligned, and the Dst buffer is assumed to be properly sized.
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixDocPartsVector(
    IN PATCHOP PatchOp,
    IN OUT SERIALIZEDPROPERTYVALUE *pprop,
    OUT ULONG *pcbprop)
{
    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(pprop != NULL);
    PROPASSERT(pcbprop != NULL);

    // If the property is a variant vector,
    // it's in an ANSI property set, and
    // there are an even number of elements, ...

    if ( PropByteSwap(pprop->dwType) == (VT_VECTOR | VT_LPSTR)
         &&
         _CodePage != CP_WINUNICODE)
    {
	ULONG cString;
	VOID *pv;

	cString = PropByteSwap( *(DWORD *) pprop->rgb );
	pv = Add2Ptr(pprop->rgb, sizeof(DWORD));

	if (_FixDocPartsElements(PatchOp, cString, pv, pv, pcbprop))
	{
	    *pcbprop += CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);
	    return(TRUE);
	}
    }
    return(FALSE);	// Not a recognizable DocParts vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixDocPartsElements
//
// Synopsis:    Recursively align the memory image of DocParts elements
//
// Arguments:	[PatchOp]	-- patch request
//		[cString]	-- count of strings remaining in the vector
//		[pvDst]		-- aligned overlapping destination buffer
//		[pvSrc]		-- unaligned overlapping source buffer
//		[pcbprop]	-- pointer to computed property length
//
// Returns:     TRUE if all remaining elements meet expectations;
//		FALSE on error
//
// Note:        The pvDst & pvSrc buffers must be in property-set
//              byte order (little endian).
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixDocPartsElements(
    IN PATCHOP PatchOp,
    IN ULONG cString,
    OUT VOID *pvDst,
    IN VOID UNALIGNED const *pvSrc,
    OUT ULONG *pcbprop)
{
    ULONG cb;
    
    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(pvDst >= pvSrc);
    PROPASSERT(PatchOp != PATCHOP_ALIGNLENGTHS || pvDst == pvSrc);

    if (cString == 0)
    {
	*pcbprop = 0;
	return(TRUE);
    }
    DWORD dwTemp;
    memcpy(&dwTemp, pvSrc, sizeof(DWORD));
    cb = sizeof(DWORD) + PropByteSwap( dwTemp );

    // If the caller serialized the vector properly, all we need to do is
    // to round up the string lengths to DWORD multiples, so readers that
    // treat these vectors as byte-aligned get faked out.  We expect
    // readers will not have problems with a DWORD aligned length, and a
    // '\0' character a few bytes earlier than the length indicates.

    if (PatchOp == PATCHOP_ALIGNLENGTHS)
    {
	cb = DwordAlign(cb);	// Caller says it's already aligned
    }
    if (_FixDocPartsElements(
		PatchOp,
		cString - 1,
		Add2Ptr(pvDst, DwordAlign(cb)),
		(VOID UNALIGNED const *) Add2ConstPtr(pvSrc, cb),
		pcbprop))
    {
	*pcbprop += DwordAlign(cb);

	if (PatchOp == PATCHOP_EXPAND)
	{
	    PropMoveMemory(
		    "_FixDocPartsElements",
		    _GetSectionHeader(),
		    pvDst,
		    pvSrc,
		    cb);
	    RtlZeroMemory(Add2Ptr(pvDst, cb), DwordRemain(cb));

	    DebugTrace(0, DEBTRACE_PROPPATCH, (
		"_FixDocPartsElements: Move(%x:%s) "
		    "cb=%x->%x off=%x->%x z=%x @%x\n",
		cString,
		Add2Ptr(pvDst, sizeof(ULONG)),
		cb - sizeof(ULONG),
		DwordAlign(cb) - sizeof(ULONG),
		_MapAddressToOffset(pvSrc),
		_MapAddressToOffset(pvDst),
		DwordRemain(cb),
		_MapAddressToOffset(Add2Ptr(pvDst, cb))));
	}
	if (PatchOp != PATCHOP_COMPUTESIZE)
	{
	    PROPASSERT(
		PatchOp == PATCHOP_ALIGNLENGTHS ||
		PatchOp == PATCHOP_EXPAND);

	    DebugTrace(0, DEBTRACE_PROPPATCH, (
		"_FixDocPartsElements: Patch(%x:%s) cb=%x->%x\n",
		cString,
		Add2Ptr(pvDst, sizeof(ULONG)),
		*(ULONG *) pvDst,
		DwordAlign(*(ULONG *) pvDst)));

            // put in the length
	    *(ULONG *) pvDst = 
                PropByteSwap( (DWORD) DwordAlign( PropByteSwap(*(ULONG *) pvDst) ) );
	}
	return(TRUE);
    }
    return(FALSE);	// Not a recognizable DocParts vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixHeadingPairVector
//
// Synopsis:    Align the memory image of a HeadingPair vector.
//              The HeadingPair property is part of the DocSumInfo
//              property set (first section).  It's a vector of
//              Variants, where the elements are alternating
//              strings and I4s (the string is a heading name,
//              and the I4 is the count of DocumentParts in that
//              heading).  In Ansi property sets, these elements
//              are packed, and must be un-packed.
//
// Arguments:	[PatchOp]	-- patch request
//		[pprop]         -- property value to be patched or sized
//		[pcbprop]	-- pointer to computed property length
//
// Returns:     TRUE if property and all elements meet expectations;
//		FALSE on error
//
// Note:	Operate on a DocumentSummaryInformation first section property,
//		PID_HEADINGPAIR.  This property is assumed to be an array of
//		VT_VARIANTs with an even number of elements.  Each pair must
//		consist of a VT_LPSTR followed by a VT_I4.
//
//		PATCHOP_COMPUTESIZE merely computes the size required to unpack
//		the property, and must assume it is currently unaligned.
//
//		PATCHOP_ALIGNLENGTHS patches all VT_LPSTR lengths to DWORD
//		multiples, and may rely on the property already being aligned.
//
//		PATCHOP_EXPAND expands the property from the Src to Dst buffer,
//		moving elements to DWORD boundaries, and patching VT_LPSTR
//		lengths to DWORD multiples.  The Src buffer is assumed to be
//		unaligned, and the Dst buffer is assumed to be properly sized.
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixHeadingPairVector(
    IN PATCHOP PatchOp,
    IN OUT SERIALIZEDPROPERTYVALUE *pprop,
    OUT ULONG *pcbprop)
{
    ULONG celem;
    ULONG cbprop = 0;

    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(pprop != NULL);
    PROPASSERT(pcbprop != NULL);

    // If the property is a variant vector, and
    // there are an even number of elements, ...

    if( PropByteSwap(pprop->dwType) == (VT_VECTOR | VT_VARIANT)
        &&
	( (celem = PropByteSwap(*(ULONG *) pprop->rgb) ) & 1) == 0
        &&
        _CodePage != CP_WINUNICODE)
    {
	pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr(pprop->rgb, sizeof(ULONG));

	if (_FixHeadingPairElements(PatchOp, celem/2, pprop, pprop, pcbprop))
	{
	    *pcbprop += CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);
	    return(TRUE);
	}
    }
    return(FALSE);	// Not a recognizable HeadingPair vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixHeadingPairElements
//
// Synopsis:    Recursively align the memory image of HeadingPair elements
//
// Arguments:	[PatchOp]	-- patch request
//		[cPairs]	-- count of heading pairs remaining
//		[ppropDst]	-- aligned overlapping destination buffer
//		[ppropSrc]	-- unaligned overlapping source buffer
//		[pcbprop]	-- pointer to computed property length
//
// Returns:     TRUE if all remaining elements meet expectations;
//		FALSE on error
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixHeadingPairElements(
    IN PATCHOP PatchOp,
    IN ULONG cPairs,
    OUT SERIALIZEDPROPERTYVALUE *ppropDst,
    IN SERIALIZEDPROPERTYVALUE UNALIGNED const *ppropSrc,
    OUT ULONG *pcbprop)
{
    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(ppropDst >= ppropSrc);
    PROPASSERT(PatchOp != PATCHOP_ALIGNLENGTHS || ppropDst == ppropSrc);

    if (cPairs == 0)
    {
	*pcbprop = 0;
	return(TRUE);
    }

    // If the first element of the pair is a VT_LPSTR, ...
    if( PropByteSwap(SPV_GetType(ppropSrc)) == VT_LPSTR )
    {
	ULONG cb;

	// Compute size of the string element.
        DWORD dwStrLen;
        memcpy(&dwStrLen, SPV_GetRgb(ppropSrc), sizeof(DWORD));
        dwStrLen = PropByteSwap(dwStrLen);
        
	cb = CB_SERIALIZEDPROPERTYVALUE  
            +
            sizeof(ULONG)
            +
            dwStrLen;

	// If the caller serialized the vector properly, all we need to do is
	// to round up the string lengths to DWORD multiples, so readers that
	// treat these vectors as byte-aligned get faked out.  We expect
	// readers will not have problems with a DWORD aligned length, and a
	// '\0' character a few bytes earlier than the length indicates.

	if (PatchOp == PATCHOP_ALIGNLENGTHS)
	{
	    cb = DwordAlign(cb);	// Caller says it's already aligned
	}

	// and if the second element of the pair is a VT_I4, ...

	if ( PropByteSwap( (DWORD) VT_I4 )
             ==
             SPV_GetType( 
                         (SERIALIZEDPROPERTYVALUE UNALIGNED const *)
                         Add2ConstPtr(ppropSrc, cb)
             ))
	{
	    cb += CB_SERIALIZEDPROPERTYVALUE + sizeof(DWORD);

	    if (_FixHeadingPairElements(
			    PatchOp,
			    cPairs - 1,
			    (SERIALIZEDPROPERTYVALUE *)
				    Add2Ptr(ppropDst, DwordAlign(cb)),
			    (SERIALIZEDPROPERTYVALUE UNALIGNED const *)
				    Add2ConstPtr(ppropSrc, cb),
			    pcbprop))
	    {
		*pcbprop += DwordAlign(cb);

		if (PatchOp == PATCHOP_EXPAND)
		{
		    // Move the unaligned VT_I4 property back in memory to an
		    // aligned boundary, move the string back to a (possibly
		    // different) aligned boundary, zero the space in between
		    // the two and patch the string length to be a DWORD
		    // multiple to fake out code that expects vector elements
		    // to be byte aligned.

		    // Adjust byte count to include just the string element.

		    cb -= CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);

		    // Move the VT_I4 element.

		    PropMoveMemory(
			    "_FixHeadingPairElements:I4",
			    _GetSectionHeader(),
			    Add2Ptr(ppropDst, DwordAlign(cb)),
			    Add2ConstPtr(ppropSrc, cb),
			    CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG));

		    // Move the VT_LPSTR element.

		    PropMoveMemory(
			    "_FixHeadingPairElements:LPSTR",
			    _GetSectionHeader(),
			    ppropDst,
			    ppropSrc,
			    cb);

		    // Zero the space in between.

		    RtlZeroMemory(Add2Ptr(ppropDst, cb), DwordRemain(cb));

		    DebugTrace(0, DEBTRACE_PROPPATCH, (
		        "_FixHeadingPairElements: Move(%x:%s) "
			    "cb=%x->%x off=%x->%x z=%x @%x\n",
		        cPairs,
		        &ppropDst->rgb[sizeof(ULONG)],
		        PropByteSwap( *(ULONG *) ppropDst->rgb ),
		        DwordAlign(PropByteSwap( *(ULONG *) ppropDst->rgb )),
		        _MapAddressToOffset(ppropSrc),
		        _MapAddressToOffset(ppropDst),
		        DwordRemain(cb),
		        _MapAddressToOffset(Add2Ptr(ppropDst, cb))));
		}

		if (PatchOp != PATCHOP_COMPUTESIZE)
		{
		    PROPASSERT(
			PatchOp == PATCHOP_ALIGNLENGTHS ||
			PatchOp == PATCHOP_EXPAND);
#ifdef DBGPROP
		    SERIALIZEDPROPERTYVALUE const *ppropT =
			(SERIALIZEDPROPERTYVALUE const *)
			    Add2Ptr(ppropDst, DwordAlign(cb));
#endif
		    DebugTrace(0, DEBTRACE_PROPPATCH, (
			"_FixHeadingPairElements: Patch(%x:%s) "
			    "cb=%x->%x, vt=%x, %x\n",
			cPairs,
			&ppropDst->rgb[sizeof(ULONG)],
			PropByteSwap( *(ULONG *) ppropDst->rgb ),
			DwordAlign( PropByteSwap( *(ULONG *) ppropDst->rgb )),
			PropByteSwap( ppropT->dwType ),
			PropByteSwap( *(ULONG *) ppropT->rgb )));

		    // Patch the string length to be a DWORD multiple.
                    // and we have to put back the swapped length

		    *(ULONG *) ppropDst->rgb
                        = PropByteSwap( (DWORD) DwordAlign( PropByteSwap( *(ULONG *) ppropDst->rgb )));
		}
		return(TRUE);
	    }
	}
    }
    return(FALSE);	// Not a recognizable HeadingPair vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropertySet
//
// Synopsis:    Return the classid for the property set code
//
// Arguments:   [pspss]         -- pointer to buffer for output
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::QueryPropertySet(OUT STATPROPSETSTG *pspss,
                                     OUT NTSTATUS       *pstatus) const
{
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    if ((_State & CPSS_USERDEFINEDDELETED) || _cSection < 1)
    {
	StatusAccessDenied(pstatus, "QueryPropertySet: deleted or no section");
        goto Exit;
    }
    _MSTM(QueryTimeStamps)(
                pspss,
                (BOOLEAN) ((_Flags & CREATEPROP_NONSIMPLE) != 0));
    pspss->clsid = _pph->clsid;
    pspss->fmtid = _GetFormatidOffset(
			    (_State & CPSS_USERDEFINEDPROPERTIES)? 1 : 0)->fmtid;
    pspss->grfFlags = _CodePage == CP_WINUNICODE?
        PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI;

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::SetClassId
//
// Synopsis:    Set the classid for the property set code
//
// Arguments:   [pclsid]        -- pointer to new ClassId
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::SetClassId(IN GUID const *pclsid,
                               OUT NTSTATUS  *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    if (IsReadOnlyPropertySet(_Flags, _State))
    {
	StatusAccessDenied(pstatus, "SetClassId: deleted or read-only");
        goto Exit;
    }

    _SetModified();
    _pph->clsid = *pclsid;

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::EnumeratePropids
//
// Synopsis:    enumerates the property ids in a prop set
//
// Arguments:   [pkey]     -- pointer to bookmark (0 implies beginning)
//              [pcprop]   -- on input: size; on output: # of props returned.
//              [apropids] -- output buffer
//              [pstatus]  -- pointer to NTSTATUS code
//
// Returns:     TRUE if more properties are available
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::EnumeratePropids(
    IN OUT ULONG *pkey,
    IN OUT ULONG  *pcprop,
    OPTIONAL OUT PROPID *apropids,
    OUT NTSTATUS *pstatus)
{
    PROPERTYIDOFFSET *ppo, *ppoStart, *ppoMax;
    ULONG cprop = 0;
    BOOLEAN fMorePropids = FALSE;
    PROPID propidPrev = *pkey;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	StatusAccessDenied(pstatus, "EnumeratePropids: deleted");
        goto Exit;
    }

    if (_LoadPropertyOffsetPointers(&ppoStart, &ppoMax, pstatus) == NULL)
    {
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }
    else
    {
        if (propidPrev != 0)    // if not first call, start w/last propid
        {
            for (ppo = ppoStart; ppo < ppoMax; ppo++)
            {
                if (ppo->propid == propidPrev)
                {
                    ppoStart = ++ppo;
                    break;
                }
            }
        }
        for (ppo = ppoStart; ppo < ppoMax; ppo++)
        {
            if (ppo->propid != PID_DICTIONARY &&
                ppo->propid != PID_CODEPAGE &&
                ppo->propid != PID_LOCALE)
            {
                if (cprop >= *pcprop)
                {
                    fMorePropids = TRUE;
                    break;
                }
                if (apropids != NULL)
                {
                    apropids[cprop] = ppo->propid;
                }
                cprop++;
                propidPrev = ppo->propid;
            }
        }
    }
    *pkey = propidPrev;
    *pcprop = cprop;

    //  ----
    //  Exit
    //  ----

Exit:

    return(fMorePropids);
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_LoadPropertyOffsetPointers
//
// Synopsis:    Load start and (past) end pointers to PROPERTYIDOFFSET array
//
// Arguments:   [pppo]          -- pointer to base of PROPERTYIDOFFSET array
//              [pppoMax]       -- pointer past end of PROPERTYIDOFFSET array
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     Pointer to Section Header, NULL if section not present
//              or if there was an error.
//---------------------------------------------------------------------------

PROPERTYSECTIONHEADER *
CPropertySetStream::_LoadPropertyOffsetPointers(
    OUT PROPERTYIDOFFSET **pppo,
    OUT PROPERTYIDOFFSET **pppoMax,
    OUT NTSTATUS *pstatus)
{
    PROPERTYSECTIONHEADER *psh;
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());

    if (_cSection != 0)
    {
        psh = _GetSectionHeader();
        ULONG cbstm = _MSTM(GetSize)(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (cbstm < _oSection + CB_PROPERTYSECTIONHEADER ||
            cbstm < _oSection + CB_PROPERTYSECTIONHEADER +
                psh->cProperties * CB_PROPERTYIDOFFSET ||
            cbstm < _oSection + psh->cbSection)
        {
            StatusCorruption(pstatus, "LoadPropertyOffsetPointers: stream size");
            goto Exit;
        }
        *pppo = psh->rgprop;
        *pppoMax = psh->rgprop + psh->cProperties;
    }

    //  ----
    //  Exit
    //  ----

Exit:
    if( !NT_SUCCESS(*pstatus) )
        psh = NULL;

    return(psh);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_LoadProperty
//
// Synopsis:    return a pointer to the specified property value
//
// Arguments:   [propid]        -- property id for property
//              [pcbprop]       -- pointer to return property size, 0 on error
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     SERIALIZEDPROPERTYVALUE * -- NULL if not present
//---------------------------------------------------------------------------

SERIALIZEDPROPERTYVALUE *
CPropertySetStream::_LoadProperty(
    IN PROPID propid,
    OUT OPTIONAL ULONG *pcbprop,
    OUT NTSTATUS *pstatus )
{
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase, *ppoMax;
    SERIALIZEDPROPERTYVALUE *pprop = NULL;

    *pstatus = STATUS_SUCCESS;

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (psh != NULL)
    {
        for (ppo = ppoBase; ppo < ppoMax; ppo++)
        {
            if (IsDwordAligned(ppo->dwOffset)
                &&
                ppo->dwOffset >= CB_PROPERTYSECTIONHEADER
                                 +
                                 psh->cProperties * CB_PROPERTYIDOFFSET
                &&
                psh->cbSection >= ppo->dwOffset + CB_SERIALIZEDPROPERTYVALUE)
            {

                if (ppo->propid != propid)
                {
                    continue;
                }
                pprop = (SERIALIZEDPROPERTYVALUE *)
                    _MapOffsetToAddress(ppo->dwOffset);

                if (pcbprop != NULL)
                {
                    ULONG cb;

                    cb = psh->cbSection - ppo->dwOffset;
                    if (propid == PID_DICTIONARY)
                    {
                        *pcbprop = _DictionaryLength(
                                        (DICTIONARY const *) pprop,
                                        cb,
                                        pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                    }
                    else
                    {
			*pcbprop = PropertyLength(pprop, cb, 0, pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
		    }
                }
                if (pcbprop == NULL ||
                    psh->cbSection >= ppo->dwOffset + *pcbprop)
                {
                    // Success
                    goto Exit;
                }
            }

            pprop = NULL;
            StatusCorruption(pstatus, "LoadProperty: property offset");
            goto Exit;
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return(pprop);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::GetValue
//
// Synopsis:    return a pointer to the specified property value
//
// Arguments:   [propid]        -- property id of property
//              [pcbprop]       -- pointer to returned property length
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     pointer to property value
//---------------------------------------------------------------------------

SERIALIZEDPROPERTYVALUE const *
CPropertySetStream::GetValue(
    IN PROPID propid,
    OUT ULONG *pcbprop,
    OUT NTSTATUS *pstatus)
{
    SERIALIZEDPROPERTYVALUE *pprop = NULL;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	StatusAccessDenied(pstatus, "GetValue: deleted");
        goto Exit;
    }
    if (propid == PID_DICTIONARY)
    {
	DebugTrace(0, DEBTRACE_ERROR, ("GetValue: PID_DICTIONARY\n"));
	StatusInvalidParameter(pstatus, "GetValue: PID_DICTIONARY");
        goto Exit;
    }

    pprop = NULL;
    if (propid == PID_SECURITY || propid == PID_MODIFY_TIME)
    {
        SERIALIZEDPROPERTYVALUE aprop[2];

        PROPASSERT(sizeof(aprop) >= sizeof(ULONG) + sizeof(LONGLONG));

        aprop[0].dwType = PropByteSwap( (DWORD) VT_EMPTY );
        if (propid == PID_SECURITY)
        {
            if (_MSTM(QuerySecurity)((ULONG *) aprop[0].rgb))
            {
                aprop[0].dwType = PropByteSwap( (DWORD) VT_UI4 );
                *pcbprop = 2 * sizeof(ULONG);
            }
        }
        else // (propid == PID_MODIFY_TIME)
        {
            LONGLONG ll;

            if (_MSTM(QueryModifyTime)(&ll))
            {
                PropByteSwap(&ll);
                memcpy(aprop[0].rgb, &ll, sizeof(LONGLONG)); 
                aprop[0].dwType = PropByteSwap( (DWORD) VT_FILETIME );
                *pcbprop = sizeof(ULONG) + sizeof(LONGLONG);
            }
        }

        if( VT_EMPTY != PropByteSwap(aprop[0].dwType)  )
        {
            pprop = (SERIALIZEDPROPERTYVALUE *)
                newk(mtPropSetStream, NULL) BYTE[*pcbprop];

            if (pprop == NULL)
            {
                StatusNoMemory(pstatus, "GetValue: no memory");
                goto Exit;
            }
            DebugTrace(0, Dbg, (
		"GetValue: pprop=%lx, vt=%lx, cb=%lx\n",
                pprop,
                PropByteSwap( aprop[0].dwType ),
                *pcbprop));
            RtlCopyMemory(pprop, aprop, *pcbprop);
        }
    }   // if (propid == PID_SECURITY || propid == PID_MODIFY_TIME)

    else
    {
	pprop = _LoadProperty(propid, pcbprop, pstatus);
        if( !NT_SUCCESS(*pstatus) )
        {
            pprop = NULL;
            goto Exit;
        }
    }   // if (propid == PID_SECURITY || propid == PID_MODIFY_TIME) ... else

#if DBGPROP
    if (pprop == NULL)
    {
        DebugTrace(0, Dbg, ("GetValue: propid=%lx pprop=NULL\n", propid));
    }
    else
    {
        char valbuf[CB_VALUESTRING];

        DebugTrace(0, Dbg, (
            "GetValue: propid=%lx pprop=%l" szX " vt=%hx val=%s cb=%l" szX "\n",
            propid,
	    _MapAddressToOffset(pprop),
            PropByteSwap( pprop->dwType ),
            ValueToString(pprop, *pcbprop, valbuf),
            *pcbprop));
    }
#endif

    //  ----
    //  Exit
    //  ----

Exit:

    return(pprop);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::SetValue
//
// Synopsis:    update/add/delete property values
//
// Arguments:   [cprop]         -- count of properties
//              [avar]          -- PROPVARIANT array
//              [apinfo]        -- PROPERTY_INFORMATION array
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//
// Note:        All the properties in the apinfo array can be classified into
//              one of the following categories:
//
//              PROPOP_IGNORE:
//                No change.  Deleting a non-existent property or the same
//                propid appears later in the apinfo array.
//
//              PROPOP_DELETE:
//                Deletion of an existing property.  Remove the
//                PROPERTYIDOFFSET structure from the property offset array and
//                and pack the remaining entries.  Delete the property value
//                and pack remaining property values
//
//              PROPOP_INSERT:
//                Addition of a new property.  Insert the new PROPERTYIDOFFSET
//                structure at the end of the property offset array.  Insert
//                the new property value at the end of the section/stream.
//
//              PROPOP_MOVE:
//                A property whose value needs to be updated out of place
//                because of a change in the property value's size.  A property
//                value is moved to the end of the section if it grows or
//                shrinks across a DWORD boundary.  The existing value is
//                removed from the section and the remaining values are packed.
//                Then, the new value is inserted at the end of the section.
//                The idea here is to move variable length properties that are
//                being changed frequently as near as possible to the end of
//                the stream to minimize the cost of maintaining a packed set
//                of property values.  Note that the property offset structure
//                is not moved around in the array.
//
//              PROPOP_UPDATE:
//                A property whose value can be updated in-place.  The property
//                value's new size is equal to the old size.  There are a
//                number of variant types that take up a fixed amount of space,
//                e.g., VT_I4, VT_R8 etc.  This would also apply to any
//                variable length property that is updated without changing
//                the property value's size across a DWORD boundary.
//
//              Note that while the property offset array is itself packed out
//              of necessity (to conform to the spec), there may be unused
//              entries at the end of the array that are not compressed out of
//              the stream when properties are deleted.  The unused space is
//              detected and reused when new properties are added later.
//---------------------------------------------------------------------------

#define CCHUNKSTACK     (sizeof(ascnkStack)/sizeof(ascnkStack[0]))

VOID
CPropertySetStream::SetValue(
    IN ULONG cprop,
    IN PROPVARIANT const avar[],
    IN PROPERTY_INFORMATION *apinfo,
    OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    CStreamChunk ascnkStack[6];

    ULONG cpoReserve;
    ULONG cDelete, cInsert, cMove, cUpdate;

#if DBGPROP
    ULONG cIgnore;
    char valbuf[CB_VALUESTRING];
    KERNELSELECT(
    char valbuf2[CB_VALUESTRING],
    char varbuf[CB_VARIANT_TO_STRING]);
#endif

    ULONG iprop;
    ULONG cbstm;
    LONG cbChange, cbInsertMove;
    PROPERTYSECTIONHEADER *psh;
    CStreamChunk *pscnk0 = NULL;
    ULONG cbNewSize;
    

    //  ----------
    //  Initialize
    //  ----------

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    // Worst case, we will need chunks for:
    //  - the possible growth of the PROPERTYIDOFFSET array,
    //  - one for EACH property that is being modified,
    //  - and one chunk to mark the end of the property data.

    CStreamChunkList scl(
                        1 + cprop + 1,
                        1 + cprop + 1 <= CCHUNKSTACK? 
			ascnkStack : ((CStreamChunk*)NULL) );

    PROPASSERT(_IsMapped());


    // Validate that this property set can be written to.
    if (IsReadOnlyPropertySet(_Flags, _State))
    {
        StatusAccessDenied(pstatus, "SetValue: deleted or read-only");
        goto Exit;
    }

    // Mark the propset dirty.
    _SetModified();


    psh = _GetSectionHeader();

    cpoReserve = 0;
    cDelete = cInsert = cMove = cUpdate = 0;
#if DBGPROP
    cIgnore = 0;
#endif
    cbInsertMove = cbChange = 0;

    pscnk0 = scl.GetFreeChunk(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    pscnk0->oOld = 0;
    pscnk0->cbChange = 0;
    PROPASSERT(pscnk0 == scl.GetChunk(0));

    cbstm = _oSection + psh->cbSection + _cbTail;
    PROPASSERT( cbstm <= _MSTM(GetSize)(pstatus) && NT_SUCCESS(*pstatus) );
    PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

    //  ------------------------
    //  Classify all the updates
    //  ------------------------

    // Each update gets classified as ignore, delete, insert, move,
    // or update.
    // Lookup the old value for each of the properties specified and
    // compute the current size.

    for (iprop = 0; iprop < cprop; iprop++)
    {
        ULONG i;
        ULONG cbPropOld;
        SERIALIZEDPROPERTYVALUE const *pprop = NULL;

        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

        if (IsReadOnlyPropid(apinfo[iprop].pid))
        {
	    if (cprop != 1 ||
		apinfo[0].pid != PID_DICTIONARY ||
		apinfo[0].cbprop == 0 ||
                ( avar == NULL || avar[0].vt != VT_DICTIONARY )
               )
	    {
		DebugTrace(0, DEBTRACE_ERROR, (
		    "SetValue: read-only propid=%lx\n",
		    apinfo[iprop].pid));
		StatusInvalidParameter(pstatus, "SetValue: read-only PROPID");
                goto Exit;
	    }
        }

        if (apinfo[iprop].pid != PID_ILLEGAL)
        {
            pprop = _LoadProperty(apinfo[iprop].pid, &cbPropOld, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);
        }

        // If this propid appears later in the array, ignore it.

        for (i = iprop + 1; i < cprop; i++)
        {
            if (apinfo[i].pid == apinfo[iprop].pid)
            {
#if DBGPROP
                cIgnore++;
#endif
                apinfo[iprop].operation = PROPOP_IGNORE;
                break;
            }
        }

        // If this propid appears only once or if it's the last instance,
        // load the property and compute its size.

        if (i == cprop)
        {
            VOID *pvStart = NULL;

            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);
            if (pprop != NULL)
            {
                ULONG cbPropNew;

                PROPASSERT(apinfo[iprop].pid != PID_DICTIONARY);
                if (apinfo[iprop].cbprop == 0)
                {
                    DebugTrace(0, Dbg, (
                        "SetValue: Deleting propid=%lx oOld=%l" szX
                            " vt=%hx val=%s cb=%l" szX "\n",
                        apinfo[iprop].pid,
                        _MapAddressToOffset(pprop),
                        PropByteSwap( pprop->dwType ),
                        ValueToString(pprop, cbPropOld, valbuf),
                        cbPropOld));

                    cbPropNew = 0;
                    cDelete++;
                    apinfo[iprop].operation = PROPOP_DELETE;
                }
                else
                {
                    DebugTrace(0, Dbg, (
                        "SetValue: Modifying propid=%lx oOld=%l" szX
                            " vt=%hx-->%hx cb=%l" szX "-->%l" szX " val=%s-->%s\n",
                        apinfo[iprop].pid,
                        _MapAddressToOffset(pprop),
                        PropByteSwap( pprop->dwType ),
			KERNELSELECT(
				PropByteSwap( apinfo[iprop].pprop->dwType ),
				avar[iprop].vt),
                        cbPropOld,
                        apinfo[iprop].cbprop,
                        ValueToString(pprop, cbPropOld, valbuf),
			KERNELSELECT(
			    ValueToString(
				    apinfo[iprop].pprop,
				    apinfo[iprop].cbprop,
				    valbuf2),
			    VariantToString(
				    avar[iprop],
				    varbuf,
				    sizeof( varbuf )))));

                    cbPropNew = apinfo[iprop].cbprop;
                    if (cbPropOld != cbPropNew)
                    {
                        cbInsertMove += apinfo[iprop].cbprop;
                        cMove++;
                        apinfo[iprop].operation = PROPOP_MOVE;
                    }
                    else
                    {
                        cUpdate++;
                        apinfo[iprop].operation = PROPOP_UPDATE;
                    }
                }

                if (apinfo[iprop].operation != PROPOP_UPDATE)
                {
                    // Update the list of chunks that need to be adjusted
                    CStreamChunk *pscnk = scl.GetFreeChunk(pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    pscnk->oOld = _MapAddressToOffset(pprop);
                    pscnk->cbChange = - (LONG) cbPropOld;
                }

                // Stream size change
                cbChange += cbPropNew - cbPropOld;
            }

            // Delete non-existent property:

            else if (apinfo[iprop].cbprop == 0)
            {
#if DBGPROP
                cIgnore++;
#endif
                PROPASSERT(apinfo[iprop].pid != PID_DICTIONARY);
                apinfo[iprop].operation = PROPOP_IGNORE;
            }

            // Insert new property:

            else
            {
                DebugTrace(0, Dbg, (
                    "SetValue: Inserting new propid=%lx vt=%hx "
                        "cbNew=%l" szX " val=%s\n",
                    apinfo[iprop].pid,
                    KERNELSELECT(
			    PropByteSwap( apinfo[iprop].pprop->dwType ),
			    avar[iprop].vt),
                    apinfo[iprop].cbprop,
                    KERNELSELECT(
			ValueToString(
			    apinfo[iprop].pprop,
			    apinfo[iprop].cbprop,
			    valbuf),
			VariantToString(
			    avar[iprop],
			    varbuf,
			    sizeof( varbuf )))));

                PROPASSERT(apinfo[iprop].pid != PID_ILLEGAL);

                cbInsertMove += apinfo[iprop].cbprop;
                cbChange += apinfo[iprop].cbprop;

                cInsert++;
                apinfo[iprop].operation = PROPOP_INSERT;
            }
            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);
        }

    }

    DebugTrace(0, Dbg, ("SetValue: Total Props %l" szX "\n", cprop));
    DebugTrace(0, Dbg, (
        "SetValue: Delete=%l" szX " Insert=%l" szX " Move=%l" szX
            " Update=%l" szX " Ignore=%l" szX "\n",
        cDelete,
        cInsert,
        cMove,
        cUpdate,
        cIgnore));

    PROPASSERT(cDelete + cInsert + cMove + cUpdate + cIgnore == cprop);
    PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

    // If we need to grow the property offset array, detect any unused
    // entries at the end of the array that are available for reuse.
    // and adjust the size difference to reflect the reuse.

    if (cInsert > cDelete)
    {
        ULONG cpoReuse, cpoExpand;

        cpoExpand = cInsert - cDelete;
        cpoReuse = _CountFreePropertyOffsets(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (cpoReuse > cpoExpand)
        {
            cpoReuse = cpoExpand;
        }
        cpoExpand -= cpoReuse;

        // If adding a small number of new entries, but not reusing any old
        // ones, add 10% more reserved entries (but only up to 10 more) to
        // avoid having to continually grow the property offset array for
        // clients that insist on adding a few properties at a time.

        // We don't do this for the User-Defined property set, however,
        // because older apps assume that the dictionary immediately follows
        // the last entry in the PID/Offset array.

        if (cpoExpand >= 1 && cpoExpand <= 2 && cpoReuse == 0
            &&
            !(_State & CPSS_USERDEFINEDPROPERTIES)
           )
        {
           cpoReserve = 1 + min(psh->cProperties, 90)/10;
           cpoExpand += cpoReserve;
        }
        DebugTrace(0, Dbg, (
            "SetValue: Reusing %l" szX " offsets, Expanding %l" szX
                " offsets\n",
            cpoReuse,
            cpoExpand));

        pscnk0->oOld = CB_PROPERTYSECTIONHEADER +
               (psh->cProperties + cpoReuse) * CB_PROPERTYIDOFFSET;
        pscnk0->cbChange = cpoExpand * CB_PROPERTYIDOFFSET;
        cbChange += cpoExpand * CB_PROPERTYIDOFFSET;
        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

    }   // if (cInsert > cDelete)

    // Do we instead need to *shrink* the PID/Offset array?
    // If so, don't shrink any more than necessary.  We'll
    // leave up to min(10%,10) blank entries.
    // Also, if this is the User-Defined property set,
    // there can never be any unused entries (for compatibility
    // with older apps), so we do a complete shrink.

    else if (cInsert < cDelete)
    {
        ULONG cpoRemove = 0;
        ULONG cpoDelta = cDelete - cInsert;

        // How many blank entries do we already have?
        ULONG cpoCurBlankEntries = _CountFreePropertyOffsets( pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if( _State & CPSS_USERDEFINEDPROPERTIES )
        {
            cpoRemove = cpoDelta;
        }
        else
        {
            // How many blank entries can we have?
            ULONG cpoMaxBlankEntries;
            cpoMaxBlankEntries = 1 + min(psh->cProperties - cpoDelta, 90)/10;

            // If, after deleting the properties, we'd have too many,
            // remove only enough to get us down to the max allowable.

            if( cpoCurBlankEntries + cpoDelta
                >
                cpoMaxBlankEntries
              )
            {
                cpoRemove = cpoCurBlankEntries + cpoDelta - cpoMaxBlankEntries;
            }
        }   // if( _State & CPSS_USERDEFINEDPROPERTIES )

        // Should we remove any PID/Offset entries?

        if( cpoRemove > 0 )
        {
            // Start removing at cpoRemove entries from the end of the PID/Offset array
            pscnk0->oOld = CB_PROPERTYSECTIONHEADER
                           +
                           (psh->cProperties + cpoCurBlankEntries - cpoRemove)
                           *
                           CB_PROPERTYIDOFFSET;

            // Remove the bytes of the cpoRemove entries.
            pscnk0->cbChange = - (LONG) (cpoRemove * CB_PROPERTYIDOFFSET );

            // Adjust the size of the section equivalently.
            cbChange += pscnk0->cbChange;
        }

    }   // else if (cInsert < cDelete)

    PROPASSERT(
        cbstm + cbChange >=
        _oSection + CB_PROPERTYSECTIONHEADER +
        (psh->cProperties + cInsert - cDelete) * CB_PROPERTYIDOFFSET +
	_cbTail);

    // If we need to grow the stream, do it now.

    if (cbChange > 0)
    {
        if (cbstm + cbChange > CBMAXPROPSETSTREAM)
        {
            StatusDiskFull(pstatus, "SetValue: 256k limit");
            goto Exit;
        }

        DebugTrace(0, Dbg, (
            "SetSize(%x) SetValue grow\n",
            cbstm + cbChange));

        _MSTM(SetSize)(cbstm + cbChange, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // reload all pointers into mapped image:

        psh = _GetSectionHeader();
        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

	// If there's another section after this one, move it back to the
	// end of the stream now.

	if (_cbTail != 0)
	{
	    VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

	    PropMoveMemory(
		    "SetValue(_cbTail:grow)",
		    psh,
		    Add2Ptr(pvSrc, cbChange),
		    pvSrc,
		    _cbTail);
	}
    }

    // From this point on, the operation should succeed.
    // If necessary, the stream has already been grown.

    if (cDelete + cInsert + cMove != 0)
    {
        // Delete and compact property offsets in the section header.

        if (cDelete + cMove != 0)
        {
            _DeleteMovePropertyOffsets(apinfo, cprop, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            psh->cProperties -= cDelete;
        }
        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

        // Use the last chunk to mark the section end, and sort the chunks
        // in ascending order by start offset.

        CStreamChunk *pscnk = scl.GetFreeChunk(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        pscnk->oOld = psh->cbSection;
        pscnk->cbChange = 0;

        scl.SortByStartAddress();

        // If we're reducing the number of properties, we may be shrinking
        // the PID/Offset array.  So, update that array now, since
        // we may remove some bytes at the end of it when we compact
        // the stream.

        if( cDelete > cInsert )
        {
            _UpdatePropertyOffsets( &scl, pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }

        // Compact the Stream following the directions in the
        // chunk list.

        _CompactStream(&scl);

        // If the number of properties is holding constant or increasing,
        // we can update the PID/Offset array now (because _CompactStream
        // allocated any necessary space for us).

        if( cDelete <= cInsert )
        {
            _UpdatePropertyOffsets( &scl, pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }

        // Set the new section size to include the deleted and inserted
        // property offsets, and the deleted property values.

        psh->cbSection += cbChange;

        // Insert new property offsets at the end of the array.

        if (cInsert + cMove != 0)
        {
            _InsertMovePropertyOffsets(
                                apinfo,
                                cprop,
                                psh->cbSection - cbInsertMove,
                                cpoReserve,
                                pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            psh->cProperties += cInsert;
        }

        PROPASSERT(cbstm + cbChange == _oSection + psh->cbSection + _cbTail);
	if (_cbTail != 0)
	{
	    // There's another section after this one; if we're shrinking
	    // the stream, move it up to the new end of the stream now.

	    if (cbChange < 0)
	    {
		VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

		PropMoveMemory(
			"SetValue(_cbTail:shrink)",
			psh,
			Add2Ptr(pvSrc, cbChange),
			pvSrc,
			_cbTail);
	    }
	    _PatchSectionOffsets(cbChange);
	}
    }   // if (cDelete + cInsert + cMove != 0)

    // Copy the new values.

    // NOTE: It might seem unnecessary to delay the in-place updates until
    // this for loop.  We do not perform the in-place updates while
    // classifying the changes because unmapping, remapping and changing
    // the size required for handling other updates can fail.  In the event
    // of such a failure, the update would not be atomic.  By delaying the
    // in-place updates, we provide some degree of atomicity.

    if (cInsert + cUpdate + cMove != 0)
    {
	BOOLEAN fDocSummaryInfo = FALSE;

	if ((_State &
             (CPSS_USERDEFINEDPROPERTIES | CPSS_DOCUMENTSUMMARYINFO)) ==
	     CPSS_DOCUMENTSUMMARYINFO)
	{
	    fDocSummaryInfo = TRUE;
	}
        
        for (iprop = 0; iprop < cprop; iprop++)
        {
            // Find property in the offset array and copy in the new value.
            if (apinfo[iprop].operation == PROPOP_INSERT ||
                apinfo[iprop].operation == PROPOP_UPDATE ||
                apinfo[iprop].operation == PROPOP_MOVE)
            {
                SERIALIZEDPROPERTYVALUE *pprop=NULL;
                ULONG cbprop;
                PROPID propid = apinfo[iprop].pid;

                pprop = _LoadProperty(propid, NULL, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
                PROPASSERT(pprop != NULL);

                // Special case for SetPropertyNames dictionary creation:

                if (propid == PID_DICTIONARY)
                {
                    PROPASSERT(CB_SERIALIZEDPROPERTYVALUE == CB_DICTIONARY);
                    PROPASSERT(apinfo[iprop].cbprop == CB_SERIALIZEDPROPERTYVALUE);
                    PROPASSERT(avar[iprop].vt == VT_DICTIONARY);
                    ((DICTIONARY *) pprop)->cEntries = 0;
                }   // if (propid == PID_DICTIONARY)
                else
                {

                    // In User, serialize the PROPVARIANT in avar
                    // directly into the mapped stream.  

                    cbprop = apinfo[iprop].cbprop;
                    pprop = RtlConvertVariantToProperty(
                                    &avar[iprop],
                                    _CodePage,
                                    pprop,
                                    &cbprop,
                                    apinfo[iprop].pid,
                                    FALSE,
                                    pstatus
                                    );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    PROPASSERT(pprop != NULL);
                    PROPASSERT(cbprop == DwordAlign(cbprop));
                    PROPASSERT(cbprop == apinfo[iprop].cbprop);

		    // If writing a DocumentSummaryInformation property
		    // for which an alignment hack is provided, hack it now.

		    if (fDocSummaryInfo && _CodePage != CP_WINUNICODE)
		    {
                        // The two vectors in the DocSumInfo property set
                        // (if Ansi) are un-packed, but we'll adjust the lengths
                        // so that if a propset reader expects them to be packed,
                        // it will still work.  E.g., a one character string will
                        // have a length of 4, with padding of NULL characters.

			ULONG cbpropT;

			if (propid == PID_HEADINGPAIR)
			{
			    _FixHeadingPairVector(
					    PATCHOP_ALIGNLENGTHS,
					    pprop,
					    &cbpropT);
			}
			else
			if (propid == PID_DOCPARTS)
			{
			    _FixDocPartsVector(
					    PATCHOP_ALIGNLENGTHS,
					    pprop,
					    &cbpropT);
			}
		    }
                    DebugTrace(0, Dbg, (
                        "SetValue:Insert: pph=%x pprop=%x cb=%3l" szX
                            " vt=%4x val=%s o=%x oEnd=%x\n",
                        _pph,
                        pprop,
                        apinfo[iprop].cbprop,
                        PropByteSwap(pprop->dwType),
                        ValueToString(pprop, apinfo[iprop].cbprop, valbuf),
                        _MapAddressToOffset(pprop),
                        _MapAddressToOffset(pprop) + apinfo[iprop].cbprop));

                }   // if (propid == PID_DICTIONARY) ... else
            }   // if (apinfo[iprop].operation == PROPOP_INSERT || ...
        }   // for (iprop = 0; iprop < cprop; iprop++)
    }   // if (cInsert + cUpdate + cMove != 0)

    // If we need to shrink the stream or if we are cleaning up after a
    // previous shrink that failed, do it last.

    cbNewSize = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (cbNewSize != cbstm + cbChange)
    {
        DebugTrace(0, Dbg, (
            "SetSize(%x) SetValue shrink\n",
            cbstm + cbChange));
        _MSTM(SetSize)(cbstm + cbChange, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    scl.Delete();

}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CountFreePropertyOffsets, private
//
// Synopsis:    counts available (free) property offsets at and of array
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     count of available property offsets at and of array
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_CountFreePropertyOffsets(OUT NTSTATUS *pstatus)
{
    PROPERTYIDOFFSET *ppo, *ppoMax;
    PROPERTYSECTIONHEADER const *psh;
    ULONG oMin = MAXULONG;
    ULONG oEnd;
    ULONG cFree = 0;

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (psh != NULL)
    {
        for ( ; ppo < ppoMax; ppo++)
        {
            if (oMin > ppo->dwOffset)
            {
                oMin = ppo->dwOffset;
            }
        }
    }
    if (oMin == MAXULONG)
    {
        goto Exit;
    }
    PROPASSERT(psh != NULL);
    oEnd = CB_PROPERTYSECTIONHEADER + psh->cProperties * CB_PROPERTYIDOFFSET;
    PROPASSERT(oEnd <= oMin);

    cFree = (oMin - oEnd)/CB_PROPERTYIDOFFSET;

Exit:

    return( cFree );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_DeleteMovePropertyOffsets, private
//
// Synopsis:    updates the offsets following the changes to the stream
//
// Arguments:   [apinfo]        -- array of property information
//              [cprop]         -- number of properties
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_DeleteMovePropertyOffsets(
    IN PROPERTY_INFORMATION const *apinfo,
    IN ULONG cprop,
    OUT NTSTATUS *pstatus)
{
    ULONG i;
    ULONG cDelete;
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase, *ppoMax;

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    // Remove the deleted properties

    DebugTrace(0, Dbg, ("Marking deleted/moved property offsets\n"));
    cDelete = 0;
    for (i = 0; i < cprop; i++)
    {
        if (apinfo[i].operation == PROPOP_DELETE ||
            apinfo[i].operation == PROPOP_MOVE)
        {
            for (ppo = ppoBase; ppo < ppoMax; ppo++)
            {
                if (ppo->propid == apinfo[i].pid)
                {
                    DebugTrace(0, Dbg, (
                        "%sing propid=%lx oOld=%l" szX "\n",
                        apinfo[i].operation == PROPOP_DELETE? "Delet" : "Mov",
                        ppo->propid,
                        ppo->dwOffset));
                    if (apinfo[i].operation == PROPOP_DELETE)
                    {
                        cDelete++;
                        ppo->dwOffset = MAXULONG;
                    }
                    else
                    {
                        ppo->dwOffset = 0;
                    }
                    break;
                }
            }
        }
    }

    // scan once and compact the property offset array.

    if (cDelete > 0)
    {
        PROPERTYIDOFFSET *ppoDst = ppoBase;

        DebugTrace(0, Dbg, ("Compacting %l" szX " deleted props\n", cDelete));
        for (ppo = ppoBase; ppo < ppoMax; ppo++)
        {
            if (ppo->dwOffset != MAXULONG)
            {
                if (ppo > ppoDst)
                {
                    *ppoDst = *ppo;
                }
                DebugTrace(0, Dbg, (
                    "%sing propid=%lx oOld=%l" szX "\n",
                    ppo > ppoDst? "Compact" : "Preserv",
                    ppo->propid,
                    ppo->dwOffset));
                ppoDst++;
            }
        }
        PROPASSERT(cDelete == (ULONG) (ppoMax - ppoDst));
        DebugTrace(0, Dbg, ("Zeroing %l" szX " entries\n", cDelete));
        RtlZeroMemory(ppoDst, (BYTE *) ppoMax - (BYTE *) ppoDst);
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_UpdatePropertyOffsets, private
//
// Synopsis:    update property offsets in section header
//
// Arguments:   [pscl]          -- list of chunks in stream that were changed
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_UpdatePropertyOffsets(
    IN CStreamChunkList const *pscl,
    OUT NTSTATUS *pstatus)
{
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoMax;

    // Update the offsets for the existing properties.
    DebugTrace(0, Dbg, ("Updating existing property offsets\n"));

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    for ( ; ppo < ppoMax; ppo++)
    {
        if (ppo->dwOffset != 0)
        {
#if DBGPROP
            ULONG oOld = ppo->dwOffset;
#endif
            ppo->dwOffset = _GetNewOffset(pscl, ppo->dwOffset);

            DebugTrace(0, Dbg, (
                "UpdatePropertyOffsets: propid=%lx offset=%l" szX "-->%l" szX"\n",
                ppo->propid,
                oOld,
                ppo->dwOffset));
        }
    }

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_InsertMovePropertyOffsets, private
//
// Synopsis:    updates the offsets following the changes to the stream
//
// Arguments:   [apinfo]        -- array of property information
//              [cprop]         -- number of properties
//              [oInsert]       -- offset in section for new properties
//              [cpoReserve]    -- newly reserved property offsets to zero
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_InsertMovePropertyOffsets(
    IN PROPERTY_INFORMATION const *apinfo,
    IN ULONG cprop,
    IN ULONG oInsert,
    IN ULONG cpoReserve,
    OUT NTSTATUS *pstatus)
{
    ULONG i;
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase, *ppoMax;

    *pstatus = STATUS_SUCCESS;

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    // Insert the new property offsets at the end.
    DebugTrace(0, Dbg, ("Inserting/Moving/Zeroing property offsets\n"));

    for (i = 0; i < cprop; i++)
    {
        if (apinfo[i].operation == PROPOP_INSERT)
        {
            ppo = ppoMax++;
            ppo->propid = apinfo[i].pid;
        }
        else if (apinfo[i].operation == PROPOP_MOVE)
        {
            for (ppo = ppoBase; ppo < ppoMax; ppo++)
            {
                if (ppo->propid == apinfo[i].pid)
                {
                    PROPASSERT(ppo->dwOffset == 0);
                    break;
                }
            }
        }
        else
        {
            continue;
        }

        PROPASSERT(ppo->propid == apinfo[i].pid);
        ppo->dwOffset = oInsert;
        oInsert += apinfo[i].cbprop;

        DebugTrace(0, Dbg, (
            "%sing propid=%lx offset=%l" szX " size=%l" szX "\n",
            apinfo[i].operation == PROPOP_INSERT? "Insert" : "Mov",
            ppo->propid,
            ppo->dwOffset,
            apinfo[i].cbprop));
    }
    DebugTrace(0, Dbg, (
        "Zeroing %x property offsets o=%l" szX " size=%l" szX "\n",
        cpoReserve,
        _MapAddressToOffset(ppoMax),
        cpoReserve * CB_PROPERTYIDOFFSET));
    RtlZeroMemory(ppoMax, cpoReserve * CB_PROPERTYIDOFFSET);

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CompactStream, private
//
// Synopsis:    compact all of the property stream chunks
//
// Arguments:   [pscl]          -- list of chunks in stream that were changed
//
// Returns:     None
//
// Note:
//      Each chunk structure represents a contiguous range of the stream to be
//      completely removed or added.  A terminating chunk is appended to
//      transparently mark the end of the data stream.  The unmodified data
//      after each chunk (except the last one) must be preserved and compacted
//      as necessary.  Chunk structures contain section-relative offsets.
//
//      Invariants:
//      - Only the first chunk can represent an insertion; subsequent chunks
//        always represent deletions.
//      - The first chunk can never cause a deletion, but it might not cause
//        any change at all.
//      - The last chunk is a dummy used to mark the end of the stream.
//
//      Algorithm:
//      In the optimal case without insertions, each chunk's trailing data can
//      be moved ahead (compacted) individually in ascending chunk index order.
//      If the first chunk represents an insertion, then some consecutive
//      number of data blocks must be moved back (in *descending* chunk index
//      order) to make room for the insertion.
//
//      Walk the chunk array to find the first point where the accumulated size
//      change is less than or equal to zero.
//
//      After (possibly) compacting a single range in descending chunk index
//      order, compact all remaining chunks in ascending chunk index order.
//
//      Example: the first chunk inserts 18 bytes for new property offsets
//      (apo'[]), and the second two delete 10 bytes each (chnk1 & chnk2).
//      There are four chunks in the array, and three blocks of data to move.
//
//                   oOld   cbChange | AccumulatedChange  oNew
//      chunk[0]:     38      +18    |      +18            38  (apo'[])
//      chunk[1]:     48      -10    |       +8            50  (chnk1)
//      chunk[2]:     6c      -10    |       -8            74  (chnk2)
//      chunk[3]:     8c        0    |       -8            84  (end)
//
//      Data blocks are moved in the following sequence to avoid overlap:
//      DstOff  SrcOff  cbMove | Chunk#
//        60      58      14   |    1  chnk1/data2: descending pass (Dst > Src)
//        50      38      10   |    0  apo'[]/data1: descending pass (Dst > Src)
//        74      7c      10   |    2  chnk2/data3: ascending pass  (Dst < Src)
//
//      SrcOff = oOld - min(cbChange, 0)
//      DstOff = SrcOff + AccumulatedChange
//      cbMove = chnk[i+1].oOld - SrcOff
//
//      Before compacting:
//                   0           38      48      58         6c      7c      8c
//                   |            |       |       |          |       |       |
//                   V            V   10  V  -10  V    14    V  -10  V   10  V
//      +----+-------+----+-------+-------+-------+----------+-------+-------+
//      | ph | afo[] | sh | apo[] | data1 | chnk1 |  data2   | chnk2 | data3 |
//      +----+-------+----+-------+-------+-------+----------+-------+-------+
//
//      After compacting:
//                   0           38          50      60         74      84
//                   |            |           |       |          |       |
//                   V            V    +18    V   10  V    14    V   10  V
//      +----+-------+----+-------+-----------+-------+----------+-------+
//      | ph | afo[] | sh | apo[] |   apo'[]  | data1 |  data2   | data3 |
//      +----+-------+----+-------+-----------+-------+----------+-------+
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_CompactStream(
    IN CStreamChunkList const *pscl)
{
    ULONG i, iMax, iAscend;
    LONG cbChangeTotal, cbChangeTotalAscend;
    CStreamChunk const *pscnk;

    // Subtract one to avoid operating on the terminating chunk directly.

    iMax = pscl->Count() - 1;

    // If the first chunk does not indicate an insertion, the first for loop is
    // exited with i == 0.
    //
    // If the first chunk represents an insertion, either i == iMax or i itself
    // indexes the first chunk that can be compacted normally (in ascending
    // chunk index order).  In either case, we compact in descending chunk
    // index order starting just below i.

    DebugTrace(0, Dbg, (
        "CompactStream: %l" szX " chunks @%lx\n",
        pscl->Count(),
        pscl->GetChunk(0)));

    cbChangeTotal = 0;
    for (i = 0; i < iMax; i++)
    {
        pscnk = pscl->GetChunk(i);
        PROPASSERT(i == 0 || pscnk->cbChange < 0);
        if (cbChangeTotal + pscnk->cbChange <= 0)
        {
            break;
        }
        cbChangeTotal += pscnk->cbChange;
    }
    iAscend = i;                                // save ascending order start
    cbChangeTotalAscend = cbChangeTotal;

    DebugTrace(0, Dbg, ("CompactStream: iAscend=%l" szX "\n", iAscend));

    // First compact range in descending chunk index order if necessary:

    while (i-- > 0)
    {
        pscnk = pscl->GetChunk(i);
        PROPASSERT(i == 0 || pscnk->cbChange < 0);

        DebugTrace(0, Dbg, ("CompactStream: descend: i=%l" szX "\n", i));
#if DBGPROP
        pscl->AssertCbChangeTotal(pscnk, cbChangeTotal);
#endif
        _CompactChunk(pscnk, cbChangeTotal, pscl->GetChunk(i + 1)->oOld);
        cbChangeTotal -= pscnk->cbChange;
    }

    // Compact any remaining chunks in ascending chunk index order.

    cbChangeTotal = cbChangeTotalAscend;
    for (i = iAscend; i < iMax; i++)
    {
        pscnk = pscl->GetChunk(i);
        PROPASSERT(i == 0 || pscnk->cbChange < 0);

        DebugTrace(0, Dbg, ("CompactStream: ascend: i=%l" szX "\n", i));
        cbChangeTotal += pscnk->cbChange;
#if DBGPROP
        pscl->AssertCbChangeTotal(pscnk, cbChangeTotal);
#endif
        _CompactChunk(pscnk, cbChangeTotal, pscl->GetChunk(i + 1)->oOld);
    }
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CompactChunk, private
//
// Synopsis:    Compact the data block following one chunk
//
// Arguments:   [pscnk]         -- pointer to stream chunk
//              [cbChangeTotal] -- Bias for this chunk
//              [oOldNext]      -- offset of next chunk
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_CompactChunk(
    IN CStreamChunk const *pscnk,
    IN LONG cbChangeTotal,
    IN ULONG oOldNext)
{
    LONG cbDelta = cbChangeTotal + min(pscnk->cbChange, 0);

    DebugTrace(0, Dbg, (
        "CompactChunk(pscnk->oOld=%l" szX ", pscnk->cbChange=%s%l" szX "\n"
            "       cbChangeTotal=%s%l" szX
            ", cbDelta=%s%l" szX                        
            ", oOldNext=%l" szX ")\n",
        pscnk->oOld,
        pscnk->cbChange < 0? "-" : "",
        pscnk->cbChange < 0? -pscnk->cbChange : pscnk->cbChange,
        cbChangeTotal < 0? "-" : "",
        cbChangeTotal < 0? -cbChangeTotal : cbChangeTotal,
        cbDelta < 0? "-" : "",                          
        cbDelta < 0? -cbDelta : cbDelta,                
        oOldNext));

    if (cbChangeTotal != 0)
    {
        ULONG oSrc;
        VOID const *pvSrc;

        oSrc = pscnk->oOld - min(pscnk->cbChange, 0);
        pvSrc = _MapOffsetToAddress(oSrc);
        PropMoveMemory(
                "CompactChunk",
                _GetSectionHeader(),
                (VOID *) Add2ConstPtr(pvSrc, cbChangeTotal),
                pvSrc,
                oOldNext - oSrc);
    }
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_PatchSectionOffsets, private
//
// Synopsis:    patch section offsets after moving data around
//
// Arguments:   [cbChange]      -- size delta
//
// Returns:     none
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_PatchSectionOffsets(
    LONG cbChange)
{
    ULONG i;

    for (i = 0; i < _cSection; i++)
    {
	FORMATIDOFFSET *pfo;

	pfo = _GetFormatidOffset(i);
	if (pfo->dwOffset > _oSection)
	{
	    DebugTrace(0, DEBTRACE_PROPPATCH, (
		"PatchSectionOffsets(%x): %l" szX " + %l" szX " --> %l" szX "\n",
		i,
		pfo->dwOffset,
		cbChange,
		pfo->dwOffset + cbChange));
	    pfo->dwOffset += cbChange;
	}
    }
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetNewOffset, private
//
// Synopsis:    gets the new address
//
// Arguments:   [pscl]          -- list of stream chunks that were changed
//              [oOld]          -- old offset
//
// Returns:     new offset
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_GetNewOffset(
    IN CStreamChunkList const *pscl,
    IN ULONG oOld) const
{
    // The Chunk list is sorted by start offsets.  Locate the chunk to which
    // the old offset belongs, then use the total change undergone by the chunk
    // to compute the new offset.

    ULONG i;
    ULONG iMax = pscl->Count();
    LONG cbChangeTotal = 0;

    for (i = 0; i < iMax; i++)
    {
        CStreamChunk const *pscnk = pscl->GetChunk(i);
        if (pscnk->oOld > oOld)
        {
            break;
        }
        cbChangeTotal += pscnk->cbChange;
        if (pscnk->oOld == oOld)
        {
            PROPASSERT(pscnk->cbChange >= 0);
            break;
        }
    }
    PROPASSERT(i < iMax);
    DebugTrace(0, Dbg, (
        "GetNewOffset: %l" szX " + %l" szX " --> %l" szX "\n",
        oOld,
        cbChangeTotal,
        oOld + cbChangeTotal));
    return(oOld + cbChangeTotal);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ComputeMinimumSize, private
//
// Synopsis:    computes the minimum possible size of a property set stream
//
// Arguments:   [cbstm]         -- actual stream size
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     computed highest offset in use
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_ComputeMinimumSize(
    IN ULONG cbstm,
    OUT NTSTATUS *pstatus)
{
    ULONG oMax = 0;
    *pstatus = STATUS_SUCCESS;

    // Don't assume *any* class variables except _pph are loaded yet!

    if (_pph != NULL && cbstm != 0)
    {
        ULONG cbMin;
        ULONG i;
        ULONG cSection;

        cSection = 1;
        cbMin = 0;

        if (_HasPropHeader())
        {
            cSection = _pph->reserved;
            cbMin = CB_PROPERTYSETHEADER + cSection * CB_FORMATIDOFFSET;
        }
        oMax = cbMin;

        // Add the size of each section

        for (i = 0; i < cSection; i++)
        {
            ULONG oSectionEnd;

            PROPERTYSECTIONHEADER const *psh = _GetSectionHeader(i, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            cbMin += psh->cbSection;
            oSectionEnd = _MapAddressToAbsOffset(psh) + psh->cbSection;
            if (oMax < oSectionEnd)
            {
                oMax = oSectionEnd;
            }
        }
        PROPASSERT(oMax <= cbstm);
        PROPASSERT(cbMin <= oMax);
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // oMax may have been set before an error occurred.
    // In this case, set it to zero.

    if( !NT_SUCCESS(*pstatus) )
        oMax = 0;

    return(oMax);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_DictionaryLength
//
// Synopsis:    compute length of property set dictionary
//
// Arguments:   [pdy]           -- pointer to dictionary
//              [cbbuf]         -- maximum length of accessible memory at pdy
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     Byte-granular count of bytes in dictionary
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_DictionaryLength(
    IN DICTIONARY const *pdy,
    IN ULONG cbbuf,
    OUT NTSTATUS *pstatus ) const
{
    ENTRY UNALIGNED const *pent;
    ULONG cbDict = CB_DICTIONARY;
    ULONG i;

    *pstatus = STATUS_SUCCESS;

    for (i = 0, pent = &pdy->rgEntry[0];
         i < PropByteSwap( pdy->cEntries );
         i++, pent = _NextDictionaryEntry( pent ))
    {
        if (cbbuf < cbDict + CB_ENTRY ||
            cbbuf < _DictionaryEntryLength( pent ))
        {
            StatusCorruption(pstatus, "_DictionaryLength: section size");
            goto Exit;
        }

        cbDict += _DictionaryEntryLength( pent );
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return(cbDict);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_PropertyNameLength
//
// Synopsis:    compute length (*byte* count) of a property name
//
// Arguments:   [pvName]        -- property name, in the codepage of
//                                 the property set
//              [pcbName]       -- pointer to returned byte length of name
//
// Returns:     TRUE if name length is valid; else FALSE
//
// Note:        The OLE 2.0 format mandates that the null be included as part
//              of the length of the name that is stored in the dictionary.
//              If the propset uses the Unicode code page, names contain
//              WCHARs, otherwise they contain CHARs.  In either case, the
//              length is a byte count that includes the L'\0' or '\0'.
//
//              Also note that this routine does not concern itself with
//              the byte-order of the name:  for Ansi names, it's irrelevant;
//              and for Unicode names, L'\0' == PropByteSwap(L'\0').
//
//+--------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_PropertyNameLength(
    IN VOID const *pvName,
    OUT ULONG *pcbName) const
{
    ULONG cch;

    if (_CodePage == CP_WINUNICODE)
    {
        cch = Prop_wcslen((WCHAR const *) pvName) + 1;
        *pcbName = cch * sizeof(WCHAR);
    }
    else
    {
        *pcbName = cch = strlen((char const *) pvName) + 1;
    }
    return(cch > 1 && cch <= CCH_MAXPROPNAMESZ );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ComparePropertyNames
//
// Synopsis:    Compare two property names.
//
// Pre-Conditions:
//              The property names are in the codepage of the
//              property set.
//
// Arguments:   [pvName1]       -- property name 1
//              [pvName2]       -- property name 2
//              [fSameByteOrder]-- TRUE: names are both big- or little-endian
//                                 FALSE: 2n\d name is wrong endian
//              [cbName]        -- byte count of name length
//                                 (includes terminator)
//
// Returns:     TRUE if names are equal
//+--------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_ComparePropertyNames(
    IN VOID const *pvName1,
    IN VOID const *pvName2,
    IN BOOL fSameByteOrder,
    IN ULONG cbName) const
{
    if (_CodePage == CP_WINUNICODE)
    {
        // On big-endian systems, when the second name
        // is byte-swapped, we'll byte-swap it into a new
        // buffer to use for the comparisson.

#ifdef BIGENDIAN
        WCHAR awcByteSwap[ CCH_MAXPROPNAMESZ ];
        if( !fSameByteOrder )
        {
            ULONG ulIndex = 0;
            PROPASSERT( (WCHAR)'\0' == ByteSwap( (WCHAR) '\0'));

            do
            {
                awcByteSwap[ ulIndex ] = 
                    ByteSwap( ((WCHAR*)pvName2)[ ulIndex ] );
            } while (awcByteSwap[ulIndex++] != (WCHAR)'\0');
        }
#endif // BIGENDIAN 

        return(Prop_wcsnicmp(
                    (WCHAR const *) pvName1,
#ifdef BIGENDIAN
                    fSameByteOrder ? (WCHAR const *) pvName2
                                   : awcByteSwap,
#else
                    (WCHAR const * ) pvName2,
#endif
                    cbName / sizeof(WCHAR) ) == 0);

    }   // if (_CodePage == CP_WINUNICODE)

    else
    {
        return(_strnicmp(
                    (char const *) pvName1,
                    (char const *) pvName2,
                    cbName) == 0);
    }   // if (_CodePage == CP_WINUNICODE) ... else
}

    

//+---------------------------------------------------------------------------
// Function:    CPropertySetStream::DuplicatePropertyName
//
// Synopsis:    Duplicate an OLECHAR property name string
//
// Arguments:   [poszName]  -- input string
//              [cbName]    -- count of bytes in string (includes null)
//              [pstatus]   -- pointer to NTSTATUS code
//
// Returns:     pointer to new string
//---------------------------------------------------------------------------

OLECHAR *
CPropertySetStream::DuplicatePropertyName(
    IN OLECHAR const *poszName,
    IN ULONG cbName,
    OUT NTSTATUS *pstatus) const
{
    OLECHAR *poc = NULL;
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(cbName != 0);
    PROPASSERT(IsOLECHARString(poszName, cbName));

    if (cbName != 0)
    {
        PROPASSERT((ocslen(poszName) + 1) * sizeof(OLECHAR) == cbName);

        poc = (OLECHAR *) _pma->Allocate(cbName);

        if (NULL == poc)
        {
            StatusNoMemory(pstatus, "DuplicatePropertyName: no memory");
            goto Exit;
        }
        RtlCopyMemory(poc, poszName, cbName);
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return(poc);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropid
//
// Synopsis:    translate a property name to a property id using the
//              dictionary on the property stream
//
// Arguments:   [poszName]      -- name of property
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     propid for property if found; PID_ILLEGAL if not found
//---------------------------------------------------------------------------

PROPID
CPropertySetStream::QueryPropid(
    IN OLECHAR const *poszName,
    OUT NTSTATUS *pstatus )
{
    //  ------
    //  Locals
    //  ------

    ULONG cbname;
    DICTIONARY const *pdy;
    ENTRY UNALIGNED const *pent;
    ULONG cdye;
    ULONG cbDict;               // BYTE granular size!
    VOID const *pvName=NULL;
    PROPID propid = PID_ILLEGAL;

    //  ----------
    //  Initialize
    //  ----------

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_HasPropHeader());
    PROPASSERT(_IsMapped());
    PROPASSERT( IsOLECHARString( poszName, MAXULONG ));
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);


    // Make sure this isn't a UD propset which has been deleted.
    if (_State & CPSS_USERDEFINEDDELETED)
    {
        StatusAccessDenied(pstatus, "QueryPropid: deleted");
        goto Exit;
    }

    // Put the name into pvName, converting it if
    // necessary to the code-page of the property set.

    pvName = poszName;
    if (_CodePage == CP_WINUNICODE  // Property set is Unicode
        &&
        !OLECHAR_IS_UNICODE )       // Name is in Ansi
    {
        // Convert the caller-provided name from the system
        // Ansi codepage to Unicode.

        ULONG cb = 0;
        pvName = NULL;
        _OLECHARToWideChar( poszName, (ULONG)-1, CP_ACP,
                            (WCHAR**)&pvName, &cb, pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // If necessary, swap the WCHARs of the Unicode string.
        //PropByteSwap( (WCHAR*) pvName, cb, sizeof(WCHAR) );
    }

    else
    if (_CodePage != CP_WINUNICODE  // Property set is Ansi
        &&
        OLECHAR_IS_UNICODE )        // Name is in Unicode
    {
        // Convert the caller-provided name from Unicode
        // to the propset's Ansi codepage.

        ULONG cb = 0;
        pvName = NULL;
        _OLECHARToMultiByte( poszName, (ULONG)-1, _CodePage,
                             (CHAR**)&pvName, &cb, pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    // How long is this property name (in bytes)?

    if (!_PropertyNameLength(pvName, &cbname))
    {
        // The length is invalid.
        StatusInvalidParameter(pstatus, "QueryPropid: name length");
        goto Exit;
    }

    // Get a pointer to the raw dictionary.

    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Is there a dictionary?

    if (pdy != NULL)
    {
        // Yes - there is a dictionary.

        PROPERTYSECTIONHEADER const *psh = _GetSectionHeader();

        // Search the dictionary for an entry name matching
        // pvName.

        for (cdye = PropByteSwap(pdy->cEntries), pent = &pdy->rgEntry[0];
             cdye > 0;
             cdye--, pent = _NextDictionaryEntry( pent ))
        {
            // Is the length of this dictionary entry valid?
            if ( _MapAddressToOffset(pent) + _DictionaryEntryLength( pent )
                 > psh->cbSection
               )
            {
                StatusCorruption(pstatus, "QueryPropid: section size");
                goto Exit;
            }

            // If the byte-length matches what we're looking for,
            // and the names compare successfully, then we're done.

            if ( CCh2CB(PropByteSwap( ENTRY_GetCch(pent) )) == cbname
                 &&
                 _ComparePropertyNames(pvName, ENTRY_GetSz(pent),
                                       FALSE, // pvName, pent->sz could be dif Endians
                                       cbname)
               )
            {
                propid = PropByteSwap( ENTRY_GetPropid(pent) );
                break;
            }
        }   // for (cdye = PropByteSwap(pdy->cEntries), pent = &pdy->rgEntry[0]; ...

        PROPASSERT(cdye > 0 || pent == Add2ConstPtr(pdy, cbDict));

    }   // if (pdy != NULL)

    //  ----
    //  Exit
    //  ----

Exit:
    // If we did an alloc on the name to munge it,
    // delete that buffer now.  We must cast pvName
    // as a non-const in order for the compiler to accept
    // the free call.
    
    if( pvName != poszName )
        _pma->Free( (VOID*) pvName );
    
    return(propid);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropertyNameBuf
//
// Synopsis:    convert from a property id to a property name using the
//              dictionary in the property set, and putting the result 
//              in a caller-provided buffer.
//
// Arguments:   [propid]        -- property id to look up
//              [aocName]       -- output buffer
//              [pcbName]       -- IN:  length of aocName;
//                                 OUT: actual length of name
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     TRUE if name is found in dictionary
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::QueryPropertyNameBuf(
    IN PROPID propid,
    OUT OLECHAR *aocName,
    IN OUT ULONG *pcbName,
    OUT NTSTATUS *pstatus)
{
    BOOL fFound = FALSE;
    DICTIONARY const *pdy;
    ULONG cbDict;               // BYTE granular size!

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(propid != PID_DICTIONARY);
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);
    PROPASSERT(NULL != aocName);

    // Ensure that this isn't an already-deleted UD propset.
    if (_State & CPSS_USERDEFINEDDELETED)
    {
        StatusAccessDenied(pstatus, "QueryPropertyNameBuf: deleted");
        goto Exit;
    }

    // Get a pointer to the raw dictionary.

    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Is there a dictionary?
    if (pdy != NULL)
    {
        // Yes - the dictionary was found.

        ULONG cdye;
        ENTRY UNALIGNED const *pent;
        VOID const *pvDictEnd;

        // Get pointers to the first and last+1 entries.

        pent = pdy->rgEntry;
        pvDictEnd = Add2ConstPtr(pdy, cbDict);

        // Scan through the dictionary, searching for 'propid'.

        for (cdye = PropByteSwap(pdy->cEntries), pent = &pdy->rgEntry[0];
             cdye > 0;
             cdye--, pent = _NextDictionaryEntry( pent ))
        {
            // Make sure this entry doesn't go off the end of the
            // dictionary.

            if (Add2ConstPtr(pent, _DictionaryEntryLength( pent )) > pvDictEnd)
            {
                StatusCorruption(pstatus, "QueryPropertyNameBuf: dictionary entry size");
                goto Exit;
            }

            // Is this the PID we're looking for?
            if (PropByteSwap(ENTRY_GetPropid(pent)) == propid)
            {
                // Yes.  Copy or convert the name into the caller's
                // buffer.

                // Is a Unicode to Ansi conversion required?
                if (_CodePage == CP_WINUNICODE      // Property set is Unicode
                    &&
                    !OLECHAR_IS_UNICODE )           // Caller's buffer is Ansi
                {
                    WCHAR *pwszName = (WCHAR*) ENTRY_GetSz(pent);

                    // If we're byte-swapping, alloc a new buffer, swap
                    // pwszName into it (getting the string into system-endian
                    // byte-order), and point pwszName to the result.

                    PBSInPlaceAlloc( &pwszName, NULL, pstatus );
                    if( !NT_SUCCESS( *pstatus )) goto Exit;

                    // Convert the Unicode string in the property set
                    // to the system default codepage.

                    _WideCharToOLECHAR( pwszName, (ULONG)-1, CP_ACP,
                                        &aocName, pcbName, pstatus );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    // If we allocated a buffer for byte-swapping,
                    // we don't need it any longer.

                    if( pwszName != (WCHAR*) ENTRY_GetSz(pent) )
                        delete pwszName;
                }

                // Or is an Ansi to Unicode conversion required?
                else
                if (_CodePage != CP_WINUNICODE      // Property set is Ansi
                    &&
                    OLECHAR_IS_UNICODE )            // Caller's buffer is Unicode
                {
                    // Convert the Ansi property set name from the
                    // propset's codepage to Unicode.

                    _MultiByteToOLECHAR( (CHAR*) ENTRY_GetSz(pent), 
                                        (ULONG)-1, _CodePage,
                                         &aocName, pcbName, pstatus );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;
                }

                // Otherwise, no conversion of the name is required
                else
                {
                    ULONG ulEntryLen= CCh2CB(PropByteSwap(ENTRY_GetCch(pent)));
                    // Copy the name into the caller's buffer.
                    RtlCopyMemory(aocName, ENTRY_GetSz(pent),
                                  min(ulEntryLen, *pcbName));

                    // Swap the name to the correct endian
                    // (This will do nothing if OLECHARs are CHARs).
                    PBSBuffer( aocName,
                               min( CCh2CB(PropByteSwap( ENTRY_GetCch(pent) )),
                                    *pcbName),
                               sizeof(OLECHAR) );

                    // Tell the caller the actual size of the name.
                    *pcbName = ulEntryLen;
                }

                PROPASSERT( NULL == aocName || IsOLECHARString( aocName, MAXULONG ));
                fFound = TRUE;
                break;

            }   // if (ENTRY_GetPropid(pent) == propid)
        }   // for (cdye = pdy->cEntries, pent = &pdy->rgEntry[0]; ...

        PROPASSERT(fFound || pent == pvDictEnd);

    }   // if (pdy != NULL)

    //  ----
    //  Exit
    //  ----

Exit:

    return( fFound );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropertyNames
//
// Synopsis:    query dictionary names for the passed property ids.
//
// Arguments:   [cprop]          -- count of name to propid mappings to change
//              [apid]           -- array of property ids
//              [aposz]          -- array of pointers to the new names
//              [pstatus]        -- pointer to NTSTATUS code
//
// Returns:     TRUE if the property exists.
//+--------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::QueryPropertyNames(
    IN ULONG cprop,
    IN PROPID const *apid,
    OUT OLECHAR *aposz[],
    OUT NTSTATUS *pstatus)
{
    DICTIONARY const *pdy;
    ULONG cbDict;               // BYTE granular size!
    ULONG iprop;
    BOOLEAN fFound = FALSE;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_HasPropHeader());
    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    // If this is an attempt to access a deleted UD
    // propset, exit now.
    if (_State & CPSS_USERDEFINEDDELETED)
    {
        StatusAccessDenied(pstatus, "QueryPropertyNames: deleted");
        goto Exit;
    }

    // Validate the input array of strings.
    for (iprop = 0; iprop < cprop; iprop++)
    {
        PROPASSERT(aposz[iprop] == NULL);
    }

    // Get a pointer to the beginning of the dictionary
    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Did we get a dictionary?
    if (pdy != NULL)
    {
        // Yes, the dictionary exists.

        ULONG i;
        ENTRY UNALIGNED const *pent;

        // Iterate through each of the entries in the dictionary.

        for (i = 0, pent = &pdy->rgEntry[0];
             i < PropByteSwap( pdy->cEntries );
             i++, pent = _NextDictionaryEntry( pent ))
        {
            // Scan the input array of PIDs to see if one matches
            // this dictionary entry.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                if( PropByteSwap(ENTRY_GetPropid(pent)) == apid[iprop] )
                {
                    // We've found an entry in the dictionary
                    // that's in the input PID array.  Put the property's
                    // name in the caller-provided array (aposz).

                    PROPASSERT(aposz[iprop] == NULL);

                    // Do we need to convert to Unicode?

                    if (_CodePage != CP_WINUNICODE      // Ansi property set
                        &&
                        OLECHAR_IS_UNICODE)             // Unicode property names
                    {
                        ULONG cbName = 0;
                        _MultiByteToOLECHAR( ENTRY_GetSz(pent), 
                                            (ULONG)-1, _CodePage,
                                            &aposz[iprop], &cbName, pstatus );
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                    }

                    // Or, do we need to convert to Ansi?
                    else
                    if (_CodePage == CP_WINUNICODE      // Unicode property set
                        &&
                        !OLECHAR_IS_UNICODE)            // Ansi property names
                    {
                        ULONG cbName = 0;
                        WCHAR *pwszName = (WCHAR*) ENTRY_GetSz(pent);

                        // If necessary, swap the Unicode name in the dictionary,
                        // pointing pwszName to the new, byte-swapped, buffer.

                        PBSInPlaceAlloc( &pwszName, NULL, pstatus );
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // And convert to Ansi.
                        _WideCharToOLECHAR( pwszName, (ULONG)-1, CP_ACP,
                                            &aposz[iprop], &cbName, pstatus );
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // If we alloced a new buffer for byte-swapping,
                        // we can free it now.

                        if( pwszName != (WCHAR*) ENTRY_GetSz(pent) )
                            delete pwszName;

                    }   // else if (_CodePage == CP_WINUNICODE ...

                    // Otherwise, both the propset & in-memory property names
                    // are both Unicode or both Ansi, so we can just do 
                    // an alloc & copy.

                    else
                    {
                        aposz[iprop] = 
                            DuplicatePropertyName( (OLECHAR *) 
                                                  ENTRY_GetSz(pent),
                                                  CCh2CB(PropByteSwap(ENTRY_GetCch(pent))), 
                                                         pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // If necessary, swap the in-memory copy.
                        PBSBuffer( (OLECHAR*) aposz[iprop],
                                   CCh2CB( PropByteSwap( pent->cch )),
                                   sizeof(OLECHAR) );

                    }   // if (_CodePage != CP_WINUNICODE ... else if ... else

                    PROPASSERT( IsOLECHARString( aposz[iprop], MAXULONG ));

                    fFound = TRUE;

                }   // if (PropByteSwap(ENTRY_GetPropid(pent) == apid[iprop])
            }   // for (iprop = 0; iprop < cprop; iprop++)
        }   // for (i = 0, pent = &pdy->rgEntry[0];

        PROPASSERT(pent == Add2ConstPtr(pdy, cbDict));

    }   // if (pdy != NULL)

    //  ----
    //  Exit
    //  ----

Exit:

    // If the property name simply didn't exist, return
    // a special success code.

    if( !fFound && NT_SUCCESS(*pstatus) )
	    *pstatus = STATUS_BUFFER_ALL_ZEROS;

    return( fFound );

}   // CPropertySetStream::QueryPropertyNames



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::SetPropertyNames
//
// Synopsis:    changes dictionary entry names associated with property ids.
//
// Arguments:   [cprop]         -- count of name to propid mappings to change
//              [apid]          -- array of property ids
//              [aposz]         -- array of pointers to the new names
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//
// Note:        Attempting to set a property name for a property that does not
//              exist in the property set is not an error.
//
//              Attempting to set a property name or property id that would
//		result in a duplicate name or property id causes the existing
//		entry(ies) to be replaced.
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::SetPropertyNames(
    IN ULONG cprop,
    IN const PROPID *apid,
    IN OPTIONAL OLECHAR const * const aposz[],
    OUT NTSTATUS *pstatus )
{

    //  ------
    //  Locals
    //  ------

    DICTIONARY *pdy = NULL;
    ULONG cbDictOld = 0;            // Byte granular Old dictionary size
    ULONG cbDictOldD = 0;           // Dword granular Old dictionary size
    ULONG iprop = 0;
    ULONG i = 0;
    ULONG cDel, cAdd;
    LONG cbDel, cbAdd;          // Byte granular sizes
    LONG cbChangeD;             // Dword granular size
    ENTRY UNALIGNED *pent;
    BOOLEAN fDupPropid = FALSE;
    BOOLEAN fDupName = FALSE;
    BOOLEAN fDeleteByName = FALSE;
    BOOLEAN fDeleteAll = FALSE;
    VOID **appvNames = NULL;

    ULONG cbstm;
    ULONG oDictionary;
    ULONG cbTail;
    ULONG cbNewSize;

    //  ----------
    //  Initialize
    //  ----------

    *pstatus = STATUS_SUCCESS;

    DebugTrace(0, Dbg, (
        "SetPropertyNames(cprop=%x, apid=%x, apwsz=%x)\n",
        cprop,
        apid,
        aposz));

    PROPASSERT(_HasPropHeader());
    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    //  --------
    //  Validate
    //  --------

    // Verify that this propset is modifiable.
    if (IsReadOnlyPropertySet(_Flags, _State))
    {
        StatusAccessDenied(pstatus, "SetPropertyNames: deleted or read-only");
        goto Exit;
    }

    // Verify that none of the names are illegally long.

    if (aposz != NULL)
    {
        for (iprop = 0; iprop < cprop; iprop++)
        {
            PROPASSERT( IsOLECHARString( aposz[iprop], MAXULONG ));

            if (ocslen( aposz[iprop] ) > CCH_MAXPROPNAME)
            {
                StatusInvalidParameter(pstatus, "SetPropertyNames:  Name is too long" );
                goto Exit;
            }
        }
    }   // if (apwsz != NULL)

    //  ----------------------------------------------------------------
    //  If necessary, convert each of the caller-provided names:
    //  to Unicode (if the property set is Unicode) or Ansi (otherwise).
    //  ----------------------------------------------------------------

    // In the end, appvNames will have the names in the same codepage
    // as the property set.

    appvNames = (VOID **) aposz;
    if (appvNames != NULL)
    {
        // Do we need to convert the caller's names to Ansi?

        if( _CodePage != CP_WINUNICODE  // Property set is Ansi
            &&
            OLECHAR_IS_UNICODE )        // Caller's names are Unicode
        {
            // Allocate an array of cprop string pointers.

            appvNames = (VOID **) newk(mtPropSetStream, NULL) char *[cprop];
            if (appvNames == NULL)
            {
                StatusNoMemory(pstatus, "SetpropertyNames: Ansi Name Pointers");
                goto Exit;
            }
            RtlZeroMemory(appvNames, cprop * sizeof(appvNames[0]));

            // Convert the caller-provided property names from Unicode to
            // the property set's codepage.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                ULONG cb = 0;
                appvNames[iprop] = NULL;
                _OLECHARToMultiByte( (OLECHAR*) aposz[iprop], (ULONG)-1, _CodePage,
                                     (CHAR**) &appvNames[iprop], &cb, pstatus );
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
            }
        }   // if( _CodePage != CP_WINUNICODE ...

        // Or, do we need to convert the caller's names to Unicode?

        if( _CodePage == CP_WINUNICODE  // Property set is Unicode
            &&
            !OLECHAR_IS_UNICODE  )      // Caller's names are Ansi
        {
            // Allocate an array of cprop string pointers.

            appvNames = (VOID **) newk(mtPropSetStream, NULL) WCHAR *[cprop];
            if (appvNames == NULL)
            {
                StatusNoMemory(pstatus, "SetpropertyNames: Unicode Name Pointers");
                goto Exit;
            }
            RtlZeroMemory(appvNames, cprop * sizeof(appvNames[0]));

            // Convert the caller-provided property names from the system
            // default Ansi codepage to Unicode.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                ULONG cb = 0;
                appvNames[iprop] = NULL;
                _OLECHARToWideChar( (OLECHAR*) aposz[iprop], (ULONG)-1, CP_ACP,
                                    (WCHAR**) &appvNames[iprop], &cb, pstatus );
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
            }
        }   // if( _CodePage == CP_WINUNICODE )
    }   // if (appvNames != NULL)
    

    //  -----------------------------------------------------
    //  Compute total size of entries to be modified or added
    //  -----------------------------------------------------

    cbAdd = 0;
    cAdd = 0;
    for (iprop = 0; iprop < cprop; iprop++)
    {
        // Did the caller give us no array of names?  If so, 
        // it means that the name for this PID is to be deleted.

        if (appvNames == NULL)
	{
            // If the PID is for the dictionary, then it must be the
            // only entry in apid, and it indicates that we're going to
            // delete all the names in the dictionary.

	    if (apid[iprop] == PID_DICTIONARY)
	    {
		if (cprop != 1)
		{
		    StatusInvalidParameter(pstatus, "SetPropertyNames: DeleteAll parms");
                    goto Exit;
		}
		fDeleteAll = TRUE;
	    }
        }

        // Otherwise, we're setting a new name for this PID.

	else
        {
            ULONG cbname;

            // Validate the caller-provided length.

            if (!_PropertyNameLength(appvNames[iprop], &cbname))
            {
                StatusInvalidParameter(pstatus, "SetPropertyNames: name length");
                goto Exit;
            }

            // See if this propid or name appears later in the array.

            for (i = iprop + 1; i < cprop; i++)
            {
                ULONG cbname2;

                if (apid[i] == apid[iprop])
                {
                    fDupPropid = TRUE;
                    break;
                }

                _PropertyNameLength(appvNames[i], &cbname2);

                if (cbname == cbname2 &&
                    _ComparePropertyNames(
                                appvNames[iprop],
                                appvNames[i],
                                TRUE, // Both names are in the same byte-order
                                cbname))
                {
                    fDupName = TRUE;
                    break;
                }
            }

            // If this propid appears only once or if it's the last instance,
            // count it.  If the property set is Unicode, include DWORD padding.

            if (i == cprop)
            {
                DebugTrace(0, Dbg, (
                    _CodePage == CP_WINUNICODE?
                        "Adding New Entry: propid=%lx  L'%ws'\n" :
                        "Adding New Entry: propid=%lx  '%s'\n",
                    apid[iprop],
                    appvNames[iprop]));

                cAdd++;

                cbAdd += CB_ENTRY + cbname;
                if( _CodePage == CP_WINUNICODE )
                {
                    cbAdd = DwordAlign( cbAdd );
                }
            }
        }
    }
    PROPASSERT( _CodePage == CP_WINUNICODE ? IsDwordAligned( cbAdd ) : TRUE );


    //  ---------------------------------------------
    //  Get the dictionary, creating it if necessary.
    //  ---------------------------------------------

    _SetModified();

    for (i = 0; ; i++)
    {
        PROPERTY_INFORMATION pinfo;
        PROPVARIANT var;

        pdy = (DICTIONARY *) _LoadProperty(PID_DICTIONARY, &cbDictOld, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (pdy != NULL)
        {
            break;
        }
        PROPASSERT(i == 0);
        if (cprop == 0 || appvNames == NULL)
        {
            // no dictionary and we are deleting or doing nothing -- return
            goto Exit;
        }
        // create dictionary if it doesn't exist
        DebugTrace(0, Dbg, ("Creating empty dictionary\n"));

        PROPASSERT(CB_SERIALIZEDPROPERTYVALUE == CB_DICTIONARY);
        pinfo.cbprop = CB_SERIALIZEDPROPERTYVALUE;
        pinfo.pid = PID_DICTIONARY;

        var.vt = VT_DICTIONARY;
        SetValue(1, &var, &pinfo, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        Validate(pstatus);     // Make sure dictionary was properly created
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
        DebugTrace(0, Dbg, ("Created empty dictionary\n"));

    }   // for (i = 0; ; i++)

    //  ----------------------------------------------------------------
    //  Compute total size of existing entries to be modified or deleted
    //  ----------------------------------------------------------------

    // Walk the dictionary looking for entries which are referenced
    // in the caller's 'apid' array or 'appvNames' array.

    cbDel = 0;
    cDel = 0;
    for (i = 0, pent = &pdy->rgEntry[0];
         i < PropByteSwap( pdy->cEntries );
         i++, pent = _NextDictionaryEntry( pent ))
    {
        DebugTrace(0, Dbg, (
            _CodePage == CP_WINUNICODE?
                "Dictionary Entry @%lx: propid=%lx L'%ws'\n" :
                "Dictionary Entry @%lx: propid=%lx '%s'\n",
            pent,
            PropByteSwap( ENTRY_GetPropid(pent) ),
            pent->sz ));

        // For this dictionary entry, walk the caller's
        // 'apid' and 'appvNames' arrays, looking for a match.

        for (iprop = 0; iprop < cprop; iprop++)
        {
            // If we get to the bottom of this 'for' loop,
            // then we know that we've found an entry to delete.
            // If fDeleteAll, or the PID in apid matches this
            // dictionary entry, then we can fall to the bottom.
            // Otherwise, the following 'if' block checks the
            // name in 'appvNames' against this dictionary entry.

            if (!fDeleteAll
                &&
                apid[iprop] != PropByteSwap( ENTRY_GetPropid(pent) ))
            {
                // The caller's PID didn't match this dictionary entry,
                // does the name?

                ULONG cbname;

                // If we have no names from the caller, then we obviously
                // don't have a match, and we can continue on to check this
                // dictionary entry against the next of the caller's PIDs.

                if (appvNames == NULL)
                {
                    continue;
                }

                // Or, if this name from the caller doesn't match this
                // dictionary entry, we again can continue on to check
                // the next of the caller's properties.

                _PropertyNameLength(appvNames[iprop], &cbname);
                if (cbname != CCh2CB( PropByteSwap( ENTRY_GetCch(pent) ))
                    ||
                    !_ComparePropertyNames(
                            appvNames[iprop],
                            ENTRY_GetSz(pent),
                            FALSE,  // appvNames & pent->sz may be dif endians.
                            cbname)
                   )
                {
                    continue;
                }
                fDeleteByName = TRUE;

            }   // if (!fDeleteAll ...

            // If we reach this point, we're going to delete this entry
            // in the dictionary.  So update cDel & cbDel.

            DebugTrace(0, Dbg, (
                "Deleting Entry (%s) @%lx: propid=%lx\n",
                fDeleteAll? "DeleteAll" :
                    apid[iprop] == PropByteSwap(ENTRY_GetPropid(pent))
                                ? "replace by propid"
                                : "replace by name",
                pent,
                PropByteSwap( ENTRY_GetPropid(pent) )));

            cDel++;
            cbDel += _DictionaryEntryLength( pent );

            // We don't need to continue through the caller's arrays,
            // we can move on to the next dictionary entry.

            break;

        }   // for (iprop = 0; iprop < cprop; iprop++)
    }   // for (i = 0, pent = &pdy->rgEntry[0]; ...

    PROPASSERT(pent == Add2Ptr(pdy, cbDictOld));
    PROPASSERT( _CodePage == CP_WINUNICODE ? IsDwordAligned( cbDel ) : TRUE );


    cbDictOldD = DwordAlign(cbDictOld);
    cbChangeD = DwordAlign(cbDictOld + cbAdd - cbDel) - cbDictOldD;

    cbstm = _oSection + _GetSectionHeader()->cbSection + _cbTail;
    oDictionary = _MapAddressToOffset(pdy);
    cbTail;

    cbTail = cbstm - (_oSection + oDictionary + cbDictOldD);

    //  --------------------------------------------------------
    //  Before we change anything, grow the stream if necessary.
    //  --------------------------------------------------------

    if (cbChangeD > 0)
    {
        DebugTrace(0, Dbg, (
            "SetSize(%x) dictionary grow\n", cbstm + cbChangeD));
        if (cbstm + cbChangeD > CBMAXPROPSETSTREAM)
        {
            StatusDiskFull(pstatus, "SetPropertyNames: 256k limit");
            goto Exit;
        }

        _MSTM(SetSize)(cbstm + cbChangeD, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // reload all pointers into mapped image:

        pdy = (DICTIONARY *) _MapOffsetToAddress(oDictionary);

        // move everything after the dictionary back by cbChangeD bytes.

        PropMoveMemory(
            "SetPropertyNames:TailBack",
            _GetSectionHeader(),
            Add2Ptr(pdy, cbDictOldD + cbChangeD),
            Add2Ptr(pdy, cbDictOldD),
            cbTail);
    }

    //  -------------------------------------------------------------------
    //  Walk through the existing dictionary and compact unmodified entries
    //  toward the front.  New and modified entries will be appended later.
    //  -------------------------------------------------------------------

    VOID *pvSrc;
    VOID *pvDst;
    ULONG cbCopy;

    pvDst = pvSrc = pent = &pdy->rgEntry[0];
    cbCopy = 0;

    if (!fDeleteAll)
    {
        ULONG cb;

        for (i = 0; i < PropByteSwap(pdy->cEntries); i++)
        {
            for (iprop = 0; iprop < cprop; iprop++)
            {
                if( apid[iprop] == PropByteSwap(ENTRY_GetPropid(pent)) )
                {
                    break;
                }
                if (fDeleteByName)      // if deleting any properties by name
                {
                    ULONG cbname;

                    _PropertyNameLength(appvNames[iprop], &cbname);
                    if (cbname == CCh2CB( PropByteSwap( ENTRY_GetCch(pent) ))
                        &&
                        _ComparePropertyNames(
                                appvNames[iprop],
                                ENTRY_GetSz(pent),
                                FALSE,  // appvNames & pent->sz may be dif endians
                                cbname)
                       )
                    {
                        break;          // found an entry to be removed.
                    }
                }
            }   // for (iprop = 0; iprop < cprop; iprop++)

            cb = _DictionaryEntryLength( pent );
            pent = _NextDictionaryEntry( pent );

            if (iprop == cprop)     // keep the dictionary entry
            {
                cbCopy += cb;
            }
            else                    // remove the dictionary entry
            {
                if (cbCopy != 0)
                {
                    if (pvSrc != pvDst)
                    {
                        PropMoveMemory(
                            "SetPropertyNames:Compact",
                            _GetSectionHeader(),
                            pvDst,
                            pvSrc,
                            cbCopy);
                    }
                    pvDst = Add2Ptr(pvDst, cbCopy);
                    cbCopy = 0;
                }
                pvSrc = pent;
            }
        }   // for (i = 0; i < PropByteSwap(pdy->cEntries); i++)

        // Compact last chunk and point past compacted entries.

        if (cbCopy != 0 && pvSrc != pvDst)
        {
            PropMoveMemory(
                "SetPropertyNames:CompactLast",
                _GetSectionHeader(),
                pvDst,
                pvSrc,
                cbCopy);
        }
        pent = (ENTRY UNALIGNED *) Add2Ptr(pvDst, cbCopy);

    }   // if (!fDeleteAll)

    pdy->cEntries = PropByteSwap( PropByteSwap(pdy->cEntries) - cDel );

    //  ------------------------------------
    //  Append new and modified entries now.
    //  ------------------------------------

    if (appvNames != NULL)
    {
        // Add each name to the property set.

        for (iprop = 0; iprop < cprop; iprop++)
        {
            // See if this propid appears later in the array.

            i = cprop;
            if (fDupPropid)
            {
                for (i = iprop + 1; i < cprop; i++)
                {
                    if (apid[i] == apid[iprop])
                    {
                        break;
                    }
                }
            }

            // See if this name appears later in the array.

            if (i == cprop && fDupName)
            {
                ULONG cbname;

                _PropertyNameLength(appvNames[iprop], &cbname);

                for (i = iprop + 1; i < cprop; i++)
                {
                    ULONG cbname2;

                    _PropertyNameLength(appvNames[i], &cbname2);

                    if (cbname == cbname2 &&
                        _ComparePropertyNames(
                            appvNames[iprop],
                            appvNames[i],
                            TRUE,   // Both names are the same endian
                            cbname))
                    {
                        break;
                    }
                }
            }

            // If this propid appears only once or if it's the last instance,
            // append the mapping entry.

            if (i == cprop)
            {
                ULONG cbname;

                // Set the PID & character-count fields for this entry.
                _PropertyNameLength(appvNames[iprop], &cbname);
                ENTRY_SetPropid(pent, PropByteSwap( apid[iprop] ) );
                ENTRY_SetCch(pent, PropByteSwap( CB2CCh( cbname ) ) );

                // Copy the name into the dictionary.
                RtlCopyMemory(ENTRY_GetSz(pent), appvNames[iprop], cbname);

                // If this is a Unicode property set, we need to correct
                // the byte-order.

                if( CP_WINUNICODE == _CodePage )
                {
                    PBSBuffer( ENTRY_GetSz(pent), cbname, sizeof(WCHAR) );
                }

                // Zero-out the pad bytes.

		RtlZeroMemory(
			Add2Ptr(pent->sz, cbname),
			DwordRemain((ULONG) pent->sz + cbname));
                
                pent = _NextDictionaryEntry( pent );
            }
        }   // for (iprop = 0; iprop < cprop; iprop++)

        // We've added all the names, now let's update the entry count.
        pdy->cEntries = PropByteSwap( PropByteSwap(pdy->cEntries) + cAdd );

    }   // if (appvNames != NULL)

    // Zero the possible partial DWORD at the end of the dictionary.

    {
        ULONG cb = (ULONG) ((BYTE *) pent - (BYTE *) pdy);
        PROPASSERT(DwordAlign(cb) == cbDictOldD + cbChangeD);
        RtlZeroMemory(pent, DwordRemain(cb));
    }


    //  -----------------------------------------------------
    //  Adjust the remaining property offsets in the section.
    //  -----------------------------------------------------

    PROPERTYIDOFFSET *ppo, *ppoMax;
    PROPERTYSECTIONHEADER *psh;

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    // Don't rely on the dictionary being the first property.
    // Skip PID_DICTIONARY and adjust every other higher entry.

    for ( ; ppo < ppoMax; ppo++)
    {
        if (ppo->dwOffset > oDictionary)
        {
            ppo->dwOffset += cbChangeD;
            PROPASSERT(ppo->propid != PID_DICTIONARY);
        }
    }

    // Update the size of the section
    psh->cbSection += cbChangeD;

    if (cbChangeD < 0)
    {
        // move everything after the dictionary forward by cbChangeD bytes.

        PropMoveMemory(
            "SetPropertyNames:TailUp",
            _GetSectionHeader(),
            Add2Ptr(pdy, cbDictOldD + cbChangeD),
            Add2Ptr(pdy, cbDictOldD),
            cbTail);
    }
    if (_cbTail != 0)
    {
	_PatchSectionOffsets(cbChangeD);
    }

    // If we need to shrink the stream or if we are cleaning up after a
    // previous shrink that failed, do it last.

    cbNewSize = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if ( cbNewSize != cbstm + cbChangeD)
    {
        DebugTrace(0, Dbg, (
            "SetSize(%x) dictionary shrink\n",
            cbstm + cbChangeD));
        _MSTM(SetSize)(cbstm + cbChangeD, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // If we had to convert the array of names into a different
    // codepage, delete those temporary buffers now.

    if (appvNames != NULL && appvNames != (VOID **) aposz)
    {
        for (iprop = 0; iprop < cprop; iprop++)
        {
            _pma->Free( appvNames[iprop] );
        }
        delete [] (char **) appvNames;
    }

    DebugTrace(0, Dbg, ("SetPropertyNames() ==> s=%x\n", STATUS_SUCCESS));
    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ValidateStructure
//
// Synopsis:    validate property set structure
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CPropertySetStream::_ValidateStructure(OUT NTSTATUS *pstatus)
{
    PROPID propid;
    ULONG cb;

    OLECHAR aocName[ CCH_MAXPROPNAMESZ];
    ULONG cbName;

    *pstatus = STATUS_SUCCESS;

    // Walk through properties to make sure all properties are consistent
    // and are contained within the section size.  A NULL return value
    // means _LoadProperty walked the entire section, so we can quit then.

    for (propid = PID_CODEPAGE; propid != PID_ILLEGAL; propid++)
    {
        SERIALIZEDPROPERTYVALUE const *pprop;

        pprop = GetValue(propid, &cb, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (NULL == pprop)
        {
            break;
        }
    }

    // Walk through dictionary entries to make sure all entries are consistent
    // and are contained within the dictionary size.  A FALSE return value
    // means QueryPropertyNameBuf walked the entire dictionary, so quit then.

    for (propid = PID_CODEPAGE + 1; propid != PID_ILLEGAL; propid++)
    {
        BOOL fExists;
        cb = 0;

        cbName = sizeof(aocName);
        fExists = QueryPropertyNameBuf(propid, aocName, &cbName, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if( !fExists )
        {
            break;
        }
    }

    if (_cSection > 1)
    {
	FORMATIDOFFSET const *pfo;

	if (_cSection != 2)
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: csection(%x) != 2",
		_cSection));
	    StatusCorruption(pstatus, "_ValidateStructure: csection != 2");
            goto Exit;
	}
	pfo = _GetFormatidOffset(0);
	if (pfo->fmtid != guidDocumentSummary)
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: DocumentSummary[0] fmtid"));
	    StatusCorruption(pstatus, "_ValidateStructure: DocumentSummary[0] fmtid");
            goto Exit;
	}
	if (!IsDwordAligned(pfo->dwOffset))
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: dwOffset[0] = %x",
		pfo->dwOffset));
	    StatusCorruption(pstatus, "_ValidateStructure: dwOffset[0]");
            goto Exit;
	}

	pfo = _GetFormatidOffset(1);
	if (pfo->fmtid != guidDocumentSummarySection2)
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: DocumentSummary[1] fmtid"));
	    StatusCorruption(pstatus, "_ValidateStructure: DocumentSummary[1] fmtid");
            goto Exit;
	}
	if (!IsDwordAligned(pfo->dwOffset))
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: dwOffset[1] = %x",
		pfo->dwOffset));
	    StatusCorruption(pstatus, "_ValidateStructure: dwOffset[1]");
            goto Exit;
	}
    }   // if (_cSection > 1)

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnPropidCompare
//
// Synopsis:    qsort helper to compare propids in a PROPERTYIDOFFSET array.
//
// Arguments:   [ppo1]          -- pointer to PROPERTYIDOFFSET 1
//              [ppo2]          -- pointer to PROPERTYIDOFFSET 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

#if DBGPROP
INT __cdecl
fnPropidCompare(VOID const *ppo1, VOID const *ppo2)
{
    return(((PROPERTYIDOFFSET const *) ppo1)->propid -
           ((PROPERTYIDOFFSET const *) ppo2)->propid);
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnOffsetCompare
//
// Synopsis:    qsort helper to compare offsets in a PROPERTYIDOFFSET array.
//
// Arguments:   [ppo1]          -- pointer to PROPERTYIDOFFSET 1
//              [ppo2]          -- pointer to PROPERTYIDOFFSET 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

INT __cdecl
fnOffsetCompare(VOID const *ppo1, VOID const *ppo2)
{
    return(((PROPERTYIDOFFSET const *) ppo1)->dwOffset -
           ((PROPERTYIDOFFSET const *) ppo2)->dwOffset);
}


//+--------------------------------------------------------------------------
// Member:      GetStringLength
//
// Synopsis:    return length of possibly unicode string.
//
// Arguments:   [CodePage]   -- TRUE if string is Unicode
//              [pwsz]       -- pointer to string
//              [cb]         -- MAXULONG or string length with L'\0' or '\0'
//
// Returns:     length of string in bytes including trailing L'\0' or '\0'
//+--------------------------------------------------------------------------

ULONG
GetStringLength(
    IN USHORT CodePage,
    IN WCHAR const *pwsz,
    IN ULONG cb)
{
    ULONG i;

    if (CodePage == CP_WINUNICODE)
    {
        for (i = 0; i < cb/sizeof(WCHAR); i++)
        {
            if (pwsz[i] == L'\0')
            {
                break;
            }
        }
        PROPASSERT(cb == MAXULONG || cb == (i + 1) * sizeof(WCHAR));
        return((i + 1) * sizeof(WCHAR));
    }
    else
    {
        char *psz = (char *) pwsz;

        for (i = 0; i < cb; i++)
        {
            if (psz[i] == '\0')
            {
                break;
            }
        }
        PROPASSERT(cb == MAXULONG || cb == (i + 1) * sizeof(char));
        return((i + 1) * sizeof(char));
    }
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ValidateProperties
//
// Synopsis:    validate properties
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CPropertySetStream::_ValidateProperties(OUT NTSTATUS *pstatus) const
{
    PROPERTYIDOFFSET *apo = NULL;
    PROPERTYSECTIONHEADER const *psh = _GetSectionHeader();
    static ULONG cValidate = 0;
    ULONG cbwasted = 0;
    ULONG cbtotal = 0;

    *pstatus = STATUS_SUCCESS;

    cValidate++;
    DebugTrace(0, DEBTRACE_PROPVALIDATE, (
	"_ValidateProperties(%x ppsstm=%x state=%x pph=%x)\n",
	cValidate,
	this,
	_State,
	_pph));

    if (psh->cProperties != 0)
    {
        PROPERTYIDOFFSET *ppo, *ppoMax;

        apo = newk(mtPropSetStream, NULL) PROPERTYIDOFFSET[psh->cProperties + 1];
        if (apo == NULL)
        {
            *pstatus = STATUS_NO_MEMORY;
            goto Exit;
        }

        RtlCopyMemory(
                apo,
                psh->rgprop,
                psh->cProperties * CB_PROPERTYIDOFFSET);

        ppoMax = apo + psh->cProperties;
        ppoMax->propid = PID_ILLEGAL;
        ppoMax->dwOffset = psh->cbSection;

        // Sort by property id and check for duplicate propids:

        qsort(apo, psh->cProperties, sizeof(apo[0]), fnPropidCompare);

        for (ppo = apo; ppo < ppoMax; ppo++)
        {
            if (ppo->propid == PID_ILLEGAL ||
                ppo->propid == ppo[1].propid)
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateProperties(bad propid=%x @%x)\n",
                    ppo->propid,
                    ppo->dwOffset));
                StatusCorruption(pstatus, "_ValidateProperties: bad or dup propid");
                goto Exit;
            }
        }

        // Sort by offset and check for overlapping values:

        qsort(apo, psh->cProperties, sizeof(apo[0]), fnOffsetCompare);

        cbtotal = _oSection;
        for (ppo = apo; ppo < ppoMax; ppo++)
        {
	    ULONG cbdiff, cbprop, cbpropraw;
	    SERIALIZEDPROPERTYVALUE const *pprop;

	    cbprop = MAXULONG;
	    cbpropraw = cbprop;
	    cbdiff = ppo[1].dwOffset - ppo->dwOffset;
            if (IsDwordAligned(ppo->dwOffset) &&
                IsDwordAligned(ppo[1].dwOffset))
            {
                pprop = (SERIALIZEDPROPERTYVALUE const *)
                            _MapOffsetToAddress(ppo->dwOffset);

                if (ppo->propid == PID_DICTIONARY)
                {
                    cbprop = _DictionaryLength(
                                    (DICTIONARY const *) pprop,
                                    cbdiff,
                                    pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

		    cbpropraw = cbprop;
		    cbprop = DwordAlign(cbprop);
                }
		else
		{
		    cbprop = PropertyLength(pprop, cbdiff, 0, pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;
		    cbpropraw = cbprop;
		}
		DebugTrace(0, DEBTRACE_PROPVALIDATE, (
		    "_ValidateProperties(%x) i=%x cb=%x/%x/%x @%x/%x pid=%x\n",
		    cValidate,
		    ppo - apo,
		    cbprop,
		    cbdiff,
		    ppo->dwOffset,
		    pprop,
		    ppo->propid));
                cbtotal += cbdiff;

                // Technically, the OLE spec allows extra unused space
                // between properties, but this implementation never
                // writes out streams with space between properties.

                if (cbdiff == cbprop)
                {
                    continue;
                }
            }
            DebugTrace(0, DEBTRACE_ERROR, (
                "_ValidateProperties(bad value length: propid=%x @%x/%x cb=%x/%x/%x ppsstm=%x)\n",
                ppo->propid,
                ppo->dwOffset,
		pprop,
		cbpropraw,
		cbprop,
		cbdiff,
		this));
            StatusCorruption(pstatus, "_ValidateProperties: bad property length");
            goto Exit;

        }   // for (ppo = apo; ppo < ppoMax; ppo++)

    }   // if (psh->cProperties != 0)

    //  ----
    //  Exit
    //  ----

Exit:

    delete [] apo;

    DebugTrace(0, cbwasted != 0? 0 : Dbg, (
        "_ValidateProperties(wasted %x bytes, total=%x)\n",
        cbwasted,
        cbtotal));

}
#endif


#if DBGPROP
typedef struct tagENTRYVALIDATE         // ev
{
    ENTRY UNALIGNED const *pent;
    CPropertySetStream const *ppsstm;
} ENTRYVALIDATE;
#endif


//+--------------------------------------------------------------------------
// Member:      fnEntryPropidCompare
//
// Synopsis:    qsort helper to compare propids in a ENTRYVALIDATE array.
//
// Arguments:   [pev1]          -- pointer to ENTRYVALIDATE 1
//              [pev2]          -- pointer to ENTRYVALIDATE 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

#if DBGPROP
INT __cdecl
fnEntryPropidCompare(VOID const *pev1, VOID const *pev2)
{
    return( ENTRY_GetPropid( ((ENTRYVALIDATE const *) pev1)->pent) -
            ENTRY_GetPropid( ((ENTRYVALIDATE const *) pev2)->pent) );
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnEntryNameCompare
//
// Synopsis:    qsort helper to compare names in a ENTRYVALIDATE array.
//
// Arguments:   [pev1]          -- pointer to ENTRYVALIDATE 1
//              [pev2]          -- pointer to ENTRYVALIDATE 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

#if DBGPROP
INT __cdecl
fnEntryNameCompare(VOID const *pev1, VOID const *pev2)
{
    ENTRY UNALIGNED const *pent1;
    ENTRY UNALIGNED const *pent2;
    INT rc;

    pent1 = ((ENTRYVALIDATE const *) pev1)->pent;
    pent2 = ((ENTRYVALIDATE const *) pev2)->pent;

    rc = PropByteSwap(ENTRY_GetCch(pent1)) - PropByteSwap(ENTRY_GetCch(pent2));
    if (rc == 0)
    {
        rc = !((ENTRYVALIDATE const *) pev1)->ppsstm->_ComparePropertyNames(
                    ENTRY_GetSz(pent1),
                    ENTRY_GetSz(pent2),
                    TRUE,       // Both names have the same byte-order
                    ( (ENTRYVALIDATE const *)
                      pev1
                    )->ppsstm->CCh2CB(PropByteSwap( ENTRY_GetCch(pent1))));
    }
    return(rc);
}
#endif


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ValidateDictionary
//
// Synopsis:    validate property set dictionary
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CPropertySetStream::_ValidateDictionary(OUT NTSTATUS *pstatus)
{
    DICTIONARY const *pdy;
    ULONG cbDict;               // BYTE granular size!

    ENTRYVALIDATE *aev = NULL;
    ENTRYVALIDATE *pev, *pevMax;
    PROPERTYSECTIONHEADER const *psh;
    ENTRY UNALIGNED const *pent;
    ENTRY entMax;
    VOID const *pvDictEnd;

    *pstatus = STATUS_SUCCESS;

    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (pdy != NULL && PropByteSwap(pdy->cEntries) != 0)
    {
        aev = newk (mtPropSetStream, NULL)
                   ENTRYVALIDATE[ PropByteSwap(pdy->cEntries) + 1 ];
        if (aev == NULL)
        {
            *pstatus = STATUS_NO_MEMORY;
            goto Exit;
        }

        psh = _GetSectionHeader();
        pent = pdy->rgEntry;
        pvDictEnd = Add2ConstPtr(pdy, cbDict);
        pevMax = aev + PropByteSwap( pdy->cEntries );

        for (pev = aev; pev < pevMax; pev++)
        {
            ULONG cb = _DictionaryEntryLength( pent );

            if (Add2ConstPtr(pent, cb) > pvDictEnd)
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateDictionary(bad entry size for propid=%x)\n",
                    PropByteSwap( ENTRY_GetPropid(pev->pent) )));
                StatusCorruption(pstatus, "ValidateDictionary: entry size");
                goto Exit;
            }
            pev->pent = pent;
            pev->ppsstm = this;

#if DBGPROP
#if LITTLEENDIAN
            if (_CodePage == CP_WINUNICODE)
            {
                PROPASSERT(IsUnicodeString((WCHAR const *) ENTRY_GetSz(pent),
                                            CCh2CB(PropByteSwap(ENTRY_GetCch(pent) ))));
            }
            else
            {
                PROPASSERT(IsAnsiString((char const *) ENTRY_GetSz(pent),
                                        CCh2CB( PropByteSwap(ENTRY_GetCch(pent) ))));
            }
#endif //  LITTLEENDIAN
#endif //  DBGPROP

            pent = _NextDictionaryEntry( pent );
        }
        if ((VOID const *) pent != pvDictEnd)
        {
            StatusCorruption(pstatus, "ValidateDictionary: end offset");
            goto Exit;
        }
        entMax.cch = 0;
        entMax.propid = PID_ILLEGAL;
        pevMax->pent = &entMax;
        pevMax->ppsstm = this;

        // Sort by property id and check for duplicate propids:

        qsort(aev, PropByteSwap(pdy->cEntries), sizeof(aev[0]), fnEntryPropidCompare);

        for (pev = aev; pev < pevMax; pev++)
        {
            if (PID_ILLEGAL == PropByteSwap( ENTRY_GetPropid(pev->pent))
                ||
                PropByteSwap( ENTRY_GetPropid(pev[1].pent) ) 
                == PropByteSwap( ENTRY_GetPropid(pev->pent) ))
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateDictionary(bad propid=%x)\n",
                    PropByteSwap( ENTRY_GetPropid(pev->pent) )));
                StatusCorruption(pstatus, "_ValidateDictionary: bad or dup propid");
                goto Exit;
            }
        }

        // Sort by property name and check for duplicate names:

        qsort(aev, PropByteSwap(pdy->cEntries), sizeof(aev[0]), fnEntryNameCompare);

        for (pev = aev; pev < pevMax; pev++)
        {
            if ( ENTRY_GetCch(pev->pent) == 0
                ||
                ( ENTRY_GetCch(pev->pent) == ENTRY_GetCch(pev[1].pent)
                  &&
                  _ComparePropertyNames(
                         ENTRY_GetSz(pev->pent),
                         ENTRY_GetSz(pev[1].pent),
                         TRUE,              // Names are the same byte-order
                         CCh2CB(PropByteSwap(ENTRY_GetCch(pev->pent))))
                )
               )
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateDictionary(bad name for propid=%x)\n",
                    PropByteSwap( ENTRY_GetPropid(pev->pent) )));
                StatusCorruption(pstatus, "_ValidateDictionary: bad or dup name");
                goto Exit;
            }
        }   // for (pev = aev; pev < pevMax; pev++)
    }   // if (pdy != NULL && pdy->cEntries != 0)

    //  ----
    //  Exit
    //  ----

Exit:

    delete [] aev;

}
#endif  // DBGPROP


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::Validate
//
// Synopsis:    validate entire property stream
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP

BOOLEAN fValidatePropSets = KERNELSELECT(DBG, TRUE);

VOID
CPropertySetStream::Validate(OUT NTSTATUS *pstatus)
{
    if (fValidatePropSets && (_State & CPSS_USERDEFINEDDELETED) == 0)
    {
        ULONG cbstm = _MSTM(GetSize)(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // Walk through section headers to make sure all sections are contained
        // within the stream size.

        if (_ComputeMinimumSize(cbstm, pstatus) != 0)
        {
            // If an error had occurred in the above call,
            // it would have returned zero.

            _ValidateStructure( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            _ValidateProperties( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            _ValidateDictionary( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            _ComputeMinimumSize(cbstm, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }
    }   // if (fValidatePropSets && (_State & CPSS_USERDEFINEDDELETED) == 0)

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\stgvarb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       StgVarB.cxx
//
//  Contents:   C++ Base wrapper for PROPVARIANT.
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#include <ctype.h>

/* right now only US ansi support */
EXTERN_C 
STDAPI_(UINT) GetACP(VOID)
{ return 1252; }  /* Latin 1 (US, Western Europe) */

#if DBGPROP

BOOLEAN
IsUnicodeString(WCHAR const *pwszname, ULONG cb)
{
    if (cb != 0)
    {
    	for (ULONG i = 0; pwszname[i] != (OLECHAR)'\0'; i++)
	    {
    	}

        // If cb isn't MAXULONG we verify that cb is at least as
        // big as the string.  We can't check for equality, because
        // there are some property sets in which the length field
        // for a string may include several zero padding bytes.
        
        PROPASSERT(cb == MAXULONG || (i + 1) * sizeof(WCHAR) <= cb);
    }
    return(TRUE);
}


BOOLEAN
IsAnsiString(CHAR const *pszname, ULONG cb)
{
    if (cb != 0)
    {
    	for (ULONG i = 0; pszname[i] != '\0'; i++)
    	{
    	}

        // If cb isn't MAXULONG we verify that cb is at least as
        // big as the string.  We can't check for equality, because
        // there are some property sets in which the length field
        // for a string may include several zero padding bytes.
        
     	PROPASSERT(cb == MAXULONG || i + 1 <= cb);
    }
    return(TRUE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\h\windef.h ===
#ifndef _WINDEF_H__
#define _WINDEF_H__

#include "../../h/props.h"
#include "ntstatus.h"  /* status codes */

#ifdef _WIN32
#define WINAPI STDMETHODCALLTYPE
#else
#define WINAPI
#endif

/* these parameter modifiers are for informational purposes only */
#define IN 
#define OUT
#define OPTIONAL
#define UNALIGNED
#define CP_WINUNICODE 1200  /* 0x04b0 */

typedef void* PVOID;
typedef PVOID HANDLE;
typedef VOID *NTPROP;
typedef VOID *NTMAPPEDSTREAM;

#define INVALID_HANDLE_VALUE ((HANDLE) -1)

/* no multithread protect in reference implementation as yet */
inline long InterlockedIncrement(long *pulArg)
{ return ++(*pulArg); }
inline long InterlockedDecrement(long *pulArg)
{ return --(*pulArg); }

/* right now only US ansi support */
EXTERN_C STDAPI_(UINT) GetACP(VOID);
typedef ULONG LCID, *PLCID;
inline LCID GetUserDefaultLCID(void)
{
    /* Windows Code Page 1252 :(LANG_ENGLISH,SUBLANG_ENGLISH_US) */
    return 0x409; 
}

#define CP_ACP 0

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#define wsprintfA sprintf
#define wvsprintfA vsprintf

inline void OutputDebugString(LPSTR sz)
{
    printf("%s", sz);
}

#include <assert.h>
#define Win4Assert assert

#define TEXT(x) _T(x)

/* memory manupulation routines */
#define RtlCopyMemory(dest,src,count)    memcpy(dest, src, count)
#define RtlZeroMemory(dest, len)         memset(dest, 0, len)
#define RtlMoveMemory(dest, src, count)  memmove(dest, src, count)

#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))

#define WINVER 0x400

inline LONG CompareFileTime(
    const FILETIME *lpFileTime1,	/* pointer to first file time */
    const FILETIME *lpFileTime2 	/* pointer to second file time */
   )
{
    LONG ldiff = lpFileTime1->dwHighDateTime - lpFileTime2->dwHighDateTime;
    if (ldiff == 0)
        ldiff = lpFileTime1->dwLowDateTime - lpFileTime2->dwLowDateTime;
    if (ldiff > 0) 
        ldiff = 1;
    else if (ldiff < 0) 
        ldiff = -1;
    return ldiff;
}

#define MAKELONG(a, b)      ( (LONG)( ((WORD) (a)) | \
                                      ((DWORD) ((WORD) (b)))<< 16) )

#endif  /* _WINDEF_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\utils.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       utils.cxx
//
//  Contents:   Utility classes/functions for property implementation.
//
//  Classes:    CPropSetName -- wraps buffer and conversion of fmtids
//              CStackBuffer -- utility class that allows a small number
//                              of items be on stack, but more be on heap.
//
//  Functions:  PropVariantClear
//              FreePropVariantArray
//              AllocAndCopy
//              PropVariantCopy
//              PropSysAllocString
//              PropSysFreeString
//
//
//--------------------------------------------------------------------------

#include "pch.cxx"

//+-------------------------------------------------------------------
//
//  Member:     CPropSetName::CPropSetName
//
//  Synopsis:   Initialize internal buffer with converted FMTID
//
//  Arguments:  [rfmtid] -- FMTID to convert
//
//--------------------------------------------------------------------

CPropSetName::CPropSetName(REFFMTID rfmtid)
{
    RtlGuidToPropertySetName(&rfmtid, _oszName);
}

//+-------------------------------------------------------------------
//
//  Member:     CStackBuffer::Init
//
//  Synopsis:   Determine whether the class derived from this one
//              needs to have additional buffer allocated on the
//              heap and allocate it if neccessary.  Otherwise, if
//              there is space, use the internal buffer in the
//              derived class.
//
//  Arguments:  [cElements] -- the number of elements required.
//
//  Returns:    S_OK if buffer available
//              STG_E_INSUFFICIENTMEMORY if stack buffer was not
//                  big enough AND heap allocation failed.
//
//  Notes:      To be called directly by client after the derived
//              classes constructor initialized CStackBuffer.
//
//--------------------------------------------------------------------

HRESULT CStackBuffer::Init(ULONG cElements)
{
    if (cElements > _cStackElements)
    {
        _pbHeapBuf = new BYTE[cElements * _cbElementSize];
        if (_pbHeapBuf == NULL)
        {
            return(STG_E_INSUFFICIENTMEMORY);
        }
    }
    return(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   PropVariantClear
//
//  Synopsis:   Deallocates the members of the PROPVARIANT that require
//              deallocation.
//
//  Arguments:  [pvarg] - variant to clear
//
//  Returns:    S_OK if successful,
//              STG_E_INVALIDPARAMETER if any part of the variant has
//                  an unknown vt type.  (In this case, ALL the elements
//                  that can be freed, will be freed.)
//
//  Modifies:   [pvarg] - the variant is left with vt = VT_EMPTY
//
//--------------------------------------------------------------------------

STDAPI PropVariantClear(PROPVARIANT *pvarg)
{

    ULONG l;
    HRESULT hr = S_OK;

    if (pvarg == NULL)
        return(hr);

    switch (pvarg->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_ILLEGAL:

#ifdef PROPVAR_VT_I1
    case VT_I1:
#endif
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_I8:
    case VT_UI8:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
        break;

    case VT_BSTR:
        if (pvarg->bstrVal != NULL)
            PropSysFreeString( pvarg->bstrVal );
        break;

    case VT_BOOL:
    case VT_ERROR:
    case VT_FILETIME:
        break;

    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_CLSID:
        PROPASSERT((void**)&pvarg->pszVal == (void**)&pvarg->pwszVal);
        PROPASSERT((void**)&pvarg->pszVal == (void**)&pvarg->puuid);
        CoTaskMemFree(pvarg->pszVal); // ptr at 0
        break;
        
    case VT_CF:
        if (pvarg->pclipdata != NULL)
        {
            CoTaskMemFree(pvarg->pclipdata->pClipData); // ptr at 8
            CoTaskMemFree(pvarg->pclipdata);
        }
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        CoTaskMemFree(pvarg->blob.pBlobData); //ptr at 4
        break;

#ifdef PROPVAR_VT_I1
    case (VT_VECTOR | VT_I1):
#endif
    case (VT_VECTOR | VT_UI1):
    case (VT_VECTOR | VT_I2):
    case (VT_VECTOR | VT_UI2):
    case (VT_VECTOR | VT_I4):
    case (VT_VECTOR | VT_UI4):
    case (VT_VECTOR | VT_I8):
    case (VT_VECTOR | VT_UI8):
    case (VT_VECTOR | VT_R4):
    case (VT_VECTOR | VT_R8):
    case (VT_VECTOR | VT_CY):
    case (VT_VECTOR | VT_DATE):

FreeArray:
        PROPASSERT((void**)&pvarg->caub.pElems == (void**)&pvarg->cai.pElems);
        CoTaskMemFree(pvarg->caub.pElems);
        break;

    case (VT_VECTOR | VT_BSTR):
        if (pvarg->cabstr.pElems != NULL)
        {
            for (l=0; l< pvarg->cabstr.cElems; l++)
            {
                if (pvarg->cabstr.pElems[l] != NULL)
                {
                    PropSysFreeString( pvarg->cabstr.pElems[l] );
                }
            }
        }
        goto FreeArray;

    case (VT_VECTOR | VT_BOOL):
    case (VT_VECTOR | VT_ERROR):
        goto FreeArray;

    case (VT_VECTOR | VT_LPSTR):
    case (VT_VECTOR | VT_LPWSTR):
        if (pvarg->calpstr.pElems != NULL)
        for (l=0; l< pvarg->calpstr.cElems; l++)
        {
            CoTaskMemFree(pvarg->calpstr.pElems[l]);
        }
        goto FreeArray;

    case (VT_VECTOR | VT_FILETIME):
    case (VT_VECTOR | VT_CLSID):
        goto FreeArray;

    case (VT_VECTOR | VT_CF):
        if (pvarg->caclipdata.pElems != NULL)
            for (l=0; l< pvarg->caclipdata.cElems; l++)
            {
                CoTaskMemFree(pvarg->caclipdata.pElems[l].pClipData);
            }
        goto FreeArray;

    case (VT_VECTOR | VT_VARIANT):
        if (pvarg->capropvar.pElems != NULL)
            hr = FreePropVariantArray(pvarg->capropvar.cElems, pvarg->capropvar.pElems);
        goto FreeArray;

    default:
        hr = STG_E_INVALIDPARAMETER;
        break;
    }

    //  We have all of the important information about the variant, so
    //  let's clear it out.
    //
    PropVariantInit(pvarg);

    return (hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreePropVariantArray, public
//
//  Synopsis:   Frees a value array returned from ReadMultiple
//
//  Arguments:  [cval] - Number of elements
//              [rgvar] - Array
//
//  Returns:    S_OK if all types recognised and all freeable items were freed.
//              STG_E_INVALID_PARAMETER if one or more types were not
//              recognised but all items are freed too.
//
//  Notes:      Even if a vt-type is not understood, all the ones that are
//              understood are freed.  The error code will indicate
//              if *any* of the members were illegal types.
//
//----------------------------------------------------------------------------

STDAPI FreePropVariantArray (
        ULONG cVariants,
        PROPVARIANT *rgvars)
{
    HRESULT hr = S_OK;

    if (rgvars != NULL)
        for ( ULONG I=0; I < cVariants; I++ )
            if (STG_E_INVALIDPARAMETER == PropVariantClear ( rgvars + I ))
                hr = STG_E_INVALIDPARAMETER;

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   AllocAndCopy
//
//  Synopsis:   Allocates enough memory to copy the passed data into and
//              then copies the data into the new buffer.
//
//  Arguments:  [cb] -- number of bytes of data to allocate and copy
//              [pvData]  --  the source of the data to copy
//              [phr] -- optional pointer to an HRESULT set to
//                       STG_E_INSUFFICIENTMEMORY if memory could
//                       not be allocated.
//              
//
//  Returns:    NULL if no memory could be allocated,
//              Otherwise, pointer to allocated and copied data.
//
//--------------------------------------------------------------------

void * AllocAndCopy(ULONG cb, void * pvData, HRESULT *phr = NULL)
{
    PROPASSERT(cb!=0);
    void * pvNew  =  CoTaskMemAlloc(cb);
    if (pvNew != NULL)
    {
        memcpy(pvNew, pvData, cb);
    }
    else
    {
        if (phr != NULL)
        {
            *phr = STG_E_INSUFFICIENTMEMORY;
        }
    }
    return(pvNew);
}

//+-------------------------------------------------------------------
//
//  Function:   SysAllocString
//              SysFreeString
//
//  Synopsis:   Exported BSTR allocation and deallocation routines
//
//
//--------------------------------------------------------------------
STDAPI_(void) SysFreeString(BSTR bstr)
{
    if (bstr)
    {
	BYTE* pab = (BYTE*) bstr;
	delete[] (pab - sizeof(DWORD));
    }
}

STDAPI_(BSTR) SysAllocString(LPOLECHAR pwsz)
{
    if (!pwsz) return NULL;

    DWORD cch = _tcslen(pwsz);

    /* a BSTR points to a DWORD length, followed by the string */
    BYTE *pab = new BYTE[sizeof(DWORD) + ((cch+1)*sizeof(OLECHAR))];

    if (pab) 
    {
        *((DWORD*) pab) = cch*sizeof(OLECHAR);
        pab += sizeof(DWORD);
        _tcscpy( (LPOLECHAR)pab, pwsz );
    }
    return ((BSTR) pab);
}

//+---------------------------------------------------------------------------
//
//  Table:      g_TypeSizes, g_TypeSizesB
//
//  Synopsis:   Tables containing byte sizes and flags for various VT_ types.
//
//----------------------------------------------------------------------------

#define BIT_VECTNOALLOC 0x80    // the VT_VECTOR with this type does not
                                // use heap allocation

#define BIT_SIMPNOALLOC 0x40    // the non VT_VECTOR with this type does not
                                // use heap allocation

#define BIT_INVALID     0x20    // marks an invalid type

#define BIT_SIZEMASK    0x1F    // mask for size of underlying type

const unsigned char g_TypeSizes[] =
{                     BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_EMPTY= 0,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_NULL      = 1,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  2,                    //VT_I2        = 2,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  4,                    //VT_I4        = 3,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  4,                    //VT_R4        = 4,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  8,                    //VT_R8        = 5,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(CY),           //VT_CY        = 6,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(DATE),         //VT_DATE      = 7,
                                                           sizeof(BSTR),         //VT_BSTR      = 8,
        BIT_INVALID |                                      0,                    //VT_DISPATCH  = 9,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(SCODE),        //VT_ERROR     = 10,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(VARIANT_BOOL), //VT_BOOL      = 11,
                                                           sizeof(PROPVARIANT),  //VT_VARIANT   = 12,
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_UNKNOWN   = 13,
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    // 14
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    // 15
#ifdef PROPVAR_VT_I1
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  1,                    //VT_I1        = 16,
#else
        BIT_INVALID /*BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  1,*/ | 0,             //VT_I1        = 16,
#endif
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  1,                    //VT_UI1       = 17,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  2,                    //VT_UI2       = 18,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  4,                    //VT_UI4       = 19,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  8,                    //VT_I8        = 20,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  8,                    //VT_UI8       = 21,
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_INT  = 22,
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_UINT = 23,
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_VOID = 24,
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_HRESULT      = 25,
        BIT_INVALID |                                      0,                    //VT_PTR  = 26,
        BIT_INVALID |                                      0,                    //VT_SAFEARRAY    = 27,
        BIT_INVALID |                                      0,                    //VT_CARRAY       = 28,
        BIT_INVALID |                                      0,                    //VT_USERDEFINED  = 29,
                                                           sizeof(LPSTR),        //VT_LPSTR        = 30,
                                                           sizeof(LPWSTR)        //VT_LPWSTR       = 31,
};

const unsigned char g_TypeSizesB[] =
{
    // NOTE: vectors of types marked ** are determined dynamically
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(FILETIME),     //VT_FILETIME     = 64,
                                                           0,                    //**VT_BLOB = 65,
                                                           0,                    //**VT_STREAM       = 66,
                                                           0,                    //**VT_STORAGE      = 67,
                                                           0,                    //**VT_STREAMED_OBJECT      = 68,
                                                           0,                    //**VT_STORED_OBJECT        = 69,
                                                           0,                    //**VT_BLOB_OBJECT  = 70,
                                                           sizeof(CLIPDATA),     //VT_CF   = 71,
                                        BIT_VECTNOALLOC |  sizeof(CLSID)         //VT_CLSID        = 72
};

//+---------------------------------------------------------------------------
//
//  Function:   PropVariantCopy, public
//
//  Synopsis:   Copies a PROPVARIANT
//
//  Arguments:  [pDest] -- the destination PROPVARIANT
//              [pvarg] - the source PROPVARIANT
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------

STDAPI PropVariantCopy ( PROPVARIANT * pDest, const PROPVARIANT * pvarg )
{
    HRESULT     hr = S_OK;
    register unsigned char TypeInfo;
    register int iBaseType;

    // handle the simple types quickly
    iBaseType = pvarg->vt & ~VT_VECTOR;

    if (iBaseType <= VT_LPWSTR)
    {
        TypeInfo = g_TypeSizes[iBaseType];
    }
    else
    if (VT_FILETIME <= iBaseType && iBaseType <= VT_CLSID)
    {
        TypeInfo = g_TypeSizesB[iBaseType-VT_FILETIME];
    }
    else
    {
        hr = STG_E_INVALIDPARAMETER;
        goto errRet;
    }

    if ((TypeInfo & BIT_INVALID) != 0)
    {
        hr = STG_E_INVALIDPARAMETER;
        goto errRet;
    }

    *pDest = *pvarg;

    if ((pvarg->vt & VT_VECTOR) == 0)
    {
        // handle non-vector types

        if ((TypeInfo & BIT_SIMPNOALLOC) == 0)
        {
            void * pvAllocated = (void*)-1;

            switch (pvarg->vt)
            {
            case VT_BSTR:
                pvAllocated = pDest->bstrVal = PropSysAllocString( pvarg->bstrVal );
                break;

            case VT_LPSTR:
                if (pvarg->pszVal != NULL)
                    pvAllocated = pDest->pszVal = (CHAR *)
                        AllocAndCopy(strlen(pvarg->pszVal)+1, pvarg->pszVal);
                break;
            case VT_LPWSTR:
                if (pvarg->pwszVal != NULL)
                {
                    ULONG cbString = (Prop_wcslen(pvarg->pwszVal)+1) * sizeof(WCHAR);
                    pvAllocated = pDest->pwszVal = (WCHAR *)
                        AllocAndCopy(cbString, pvarg->pwszVal);
                }
                break;
            case VT_CLSID:
                if (pvarg->puuid != NULL)
                    pvAllocated = pDest->puuid = (GUID *)
                        AllocAndCopy(sizeof(*(pvarg->puuid)), pvarg->puuid);
                break;
                
            case VT_CF:
                // first check if CLIPDATA is present
                if (pvarg->pclipdata != NULL)
                {
                    // yes ... copy the clip data structure

                    pvAllocated = pDest->pclipdata = (CLIPDATA*)AllocAndCopy(
                        sizeof(*(pvarg->pclipdata)), pvarg->pclipdata);

                    // did we allocate the CLIPDATA ?
                    if (pvAllocated != NULL)
                    {
                        // yes ... initialize the destination.
                        pDest->pclipdata->pClipData = NULL;

                        // Is the input valid?
                        if (NULL == pvarg->pclipdata->pClipData
                            &&
                            0 != CBPCLIPDATA(*pvarg->pclipdata))
                        {
                            // no ... the input is not valid
                            hr = STG_E_INVALIDPARAMETER;
                        }

                        // Is there is any actual clip data ?
                        else if (0 != CBPCLIPDATA(*pvarg->pclipdata))
                        {
                            // yes ... copy the actual clip data
                            pvAllocated = pDest->pclipdata->pClipData =
                                (BYTE*)AllocAndCopy(CBPCLIPDATA(*pvarg->pclipdata),
                                         pvarg->pclipdata->pClipData);
                        }
                    }   // if (pvAllocated != NULL)
                }   // if (pvarg->pclipdata != NULL)
                break;

            case VT_BLOB:
            case VT_BLOB_OBJECT:
                if (pvarg->blob.pBlobData != NULL && pvarg->blob.cbSize != 0)
                {
                    pvAllocated = pDest->blob.pBlobData = (BYTE *)
                        AllocAndCopy(pvarg->blob.cbSize,
                                     pvarg->blob.pBlobData);
                }
                else 
                {
                    // if the cbsize is 0 or pBlobData is NULL, make
                    // sure both values are consistent in the destination
                    pDest->blob.pBlobData = NULL;
                    pDest->blob.cbSize = 0;
                }
                break;

            case VT_VARIANT:
                // drop through - this merely documents that VT_VARIANT has been thought of.

            default:
                //PROPASSERT(!"Unexpected non-vector type in PropVariantCopy");
                hr = STG_E_INVALIDPARAMETER;
                goto errRet;
            }

            if( FAILED(hr) )
                goto errRet;

            if (pvAllocated == NULL)
            {
                hr = STG_E_INSUFFICIENTMEMORY;
                goto errRet;
            }
        }   // if ((TypeInfo & BIT_SIMPNOALLOC) == 0)
    }   // if ((pvarg->vt & VT_VECTOR) == 0)

    else
    {
        ULONG cbType = TypeInfo & BIT_SIZEMASK;
        if (cbType == 0)
        {
            hr = STG_E_INVALIDPARAMETER;
            goto errRet;
        }

        // handle the vector types

        // this depends on the pointer and count being in the same place in
        // each of CAUI1 CAI2 etc

        // allocate the array for pElems
        if (pvarg->caub.pElems == NULL || pvarg->caub.cElems == 0)
        {
            PROPASSERT( hr == S_OK );
            goto errRet; // not really an error
        }

        void *pvAllocated = pDest->caub.pElems = (BYTE *)
            AllocAndCopy(cbType * pvarg->caub.cElems, pvarg->caub.pElems);

        if (pvAllocated == NULL)
        {
            hr = STG_E_INSUFFICIENTMEMORY;
            goto errRet;
        }

        if ((TypeInfo & BIT_VECTNOALLOC) != 0)
        {
            // the vector needs no further allocation
            PROPASSERT( hr == S_OK );
            goto errRet;
        }

        ULONG l;

        // vector types that require allocation ...
        // we first zero out the pointers so that we can use PropVariantClear
        // to clean up in the error case

        switch (pvarg->vt)
        {
        case (VT_VECTOR | VT_BSTR):
            // initialize for error case
            for (l=0; l< pvarg->cabstr.cElems; l++)
            {
                pDest->cabstr.pElems[l] = NULL;
            }
            break;

        case (VT_VECTOR | VT_LPSTR):
        case (VT_VECTOR | VT_LPWSTR):
            // initialize for error case
            for (l=0; l< pvarg->calpstr.cElems; l++)
            {
                pDest->calpstr.pElems[l] = NULL;
            }
            break;

        case (VT_VECTOR | VT_CF):
            // initialize for error case
            for (l=0; l< pvarg->caclipdata.cElems; l++)
            {
                pDest->caclipdata.pElems[l].pClipData  = NULL;
            }
            break;

        case (VT_VECTOR | VT_VARIANT):
            // initialize for error case
            for (l=0; l< pvarg->capropvar.cElems; l++)
            {
                pDest->capropvar.pElems[l].vt = VT_ILLEGAL;
            }
            break;

        default:
            PROPASSERT(!"Internal error: Unexpected type in PropVariantCopy");
            CoTaskMemFree(pvAllocated);
            hr = STG_E_INVALIDPARAMETER;
            goto errRet;
        }

        // now do the vector copy...

        switch (pvarg->vt)
        {
        case (VT_VECTOR | VT_BSTR):
            for (l=0; l< pvarg->cabstr.cElems; l++)
            {
                if (pvarg->cabstr.pElems[l] != NULL)
                {
                    pDest->cabstr.pElems[l] = PropSysAllocString( pvarg->cabstr.pElems[l]);
                    if (pDest->cabstr.pElems[l]  == NULL)
                    {
                        hr = STG_E_INSUFFICIENTMEMORY;
                        break;
                    }
                }
            }
            break;

        case (VT_VECTOR | VT_LPWSTR):
            for (l=0; l< pvarg->calpwstr.cElems; l++)
            {
                if (pvarg->calpwstr.pElems[l] != NULL)
                {

                    pDest->calpwstr.pElems[l] = (LPWSTR)AllocAndCopy(
                        sizeof(WCHAR)*(Prop_wcslen(pvarg->calpwstr.pElems[l])+1),
                        pvarg->calpwstr.pElems[l],
                        &hr);

                    if (hr != S_OK)
                        break;
                }
            }
            break;

        case (VT_VECTOR | VT_LPSTR):
            for (l=0; l< pvarg->calpstr.cElems; l++)
            {
                if (pvarg->calpstr.pElems[l] != NULL)
                {
                    pDest->calpstr.pElems[l] = (LPSTR)AllocAndCopy(
                        strlen(pvarg->calpstr.pElems[l])+1,
                        pvarg->calpstr.pElems[l],
                        &hr);

                    if (hr != S_OK)
                        break;
                }
            }
            break;

        case (VT_VECTOR | VT_CF):
            for (l=0; l< pvarg->caclipdata.cElems; l++)
            {
                // Is the input valid?
                if (NULL == pvarg->caclipdata.pElems[l].pClipData
                    &&
                    0 != CBPCLIPDATA(pvarg->caclipdata.pElems[l] ))
                {
                    hr = STG_E_INVALIDPARAMETER;
                    break;
                }

                // Is there data to copy?
                if (0 != CBPCLIPDATA(pvarg->caclipdata.pElems[l]))
                {
                    pDest->caclipdata.pElems[l].pClipData  = (BYTE*)AllocAndCopy(
                        CBPCLIPDATA(pvarg->caclipdata.pElems[l]),
                        pvarg->caclipdata.pElems[l].pClipData,
                        &hr);

                    if (hr != S_OK)
                        break;
                }
            }
            break;

        case (VT_VECTOR | VT_VARIANT):
            for (l=0; l< pvarg->capropvar.cElems; l++)
            {
                hr = PropVariantCopy(pDest->capropvar.pElems + l,
                                     pvarg->capropvar.pElems + l);
                if (hr != S_OK)
                {
                    break;
                }
            }
            break;

        default:
            PROPASSERT(!"Internal error: Unexpected type in PropVariantCopy");
            CoTaskMemFree(pvAllocated);
            hr = STG_E_INVALIDPARAMETER;
            goto errRet;
        }

        if (hr != S_OK)
        {
            PropVariantClear(pDest);
            goto errRet;
        }
    }

errRet:

    if (hr != S_OK)
    {
        // VT_EMPTY
        PROPASSERT(VT_EMPTY == 0);
        memset(pDest, 0, sizeof(*pDest));
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   NtStatusToScode, public
//
//  Synopsis:   Attempts to map an NTSTATUS code to an SCODE
//
//  Arguments:  [nts] - NTSTATUS
//
//  Returns:    Appropriate status code
//
//  History:    29-Jun-93       DrewB   Created
//
//  Notes:      Assumes [nts] is an error code
//              This function is by no means exhaustively complete
//
//----------------------------------------------------------------------------

SCODE NtStatusToScode(NTSTATUS nts)
{
    SCODE sc;

    PropDbg((DEB_ITRACE, "In  NtStatusToScode(%lX)\n", nts));

    switch(nts)
    {
    case STATUS_INVALID_PARAMETER:
    case STATUS_INVALID_PARAMETER_MIX:
    case STATUS_INVALID_PARAMETER_1:
    case STATUS_INVALID_PARAMETER_2:
    case STATUS_INVALID_PARAMETER_3:
    case STATUS_INVALID_PARAMETER_4:
    case STATUS_INVALID_PARAMETER_5:
    case STATUS_INVALID_PARAMETER_6:
    case STATUS_INVALID_PARAMETER_7:
    case STATUS_INVALID_PARAMETER_8:
    case STATUS_INVALID_PARAMETER_9:
    case STATUS_INVALID_PARAMETER_10:
    case STATUS_INVALID_PARAMETER_11:
    case STATUS_INVALID_PARAMETER_12:
        sc = STG_E_INVALIDPARAMETER;
        break;

    case STATUS_DUPLICATE_NAME:
    case STATUS_DUPLICATE_OBJECTID:
    case STATUS_OBJECTID_EXISTS:
    case STATUS_OBJECT_NAME_COLLISION:
        sc = STG_E_FILEALREADYEXISTS;
        break;

    case STATUS_NO_SUCH_DEVICE:
    case STATUS_NO_SUCH_FILE:
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_NOT_A_DIRECTORY:
    case STATUS_FILE_IS_A_DIRECTORY:
    case STATUS_PROPSET_NOT_FOUND:
    case STATUS_NOT_FOUND:
    case STATUS_OBJECT_TYPE_MISMATCH:
        sc = STG_E_FILENOTFOUND;
        break;

    case STATUS_OBJECT_NAME_INVALID:
    case STATUS_OBJECT_PATH_SYNTAX_BAD:
    case STATUS_OBJECT_PATH_INVALID:
    case STATUS_NAME_TOO_LONG:
        sc = STG_E_INVALIDNAME;
        break;

    case STATUS_ACCESS_DENIED:
        sc = STG_E_ACCESSDENIED;
        break;

    case STATUS_NO_MEMORY:
    case STATUS_INSUFFICIENT_RESOURCES:
        sc = STG_E_INSUFFICIENTMEMORY;
        break;

    case STATUS_INVALID_HANDLE:
    case STATUS_FILE_INVALID:
    case STATUS_FILE_FORCED_CLOSED:
        sc = STG_E_INVALIDHANDLE;
        break;

    case STATUS_INVALID_DEVICE_REQUEST:
    case STATUS_INVALID_SYSTEM_SERVICE:
    case STATUS_NOT_IMPLEMENTED:
        sc = STG_E_INVALIDFUNCTION;
        break;

    case STATUS_NO_MEDIA_IN_DEVICE:
    case STATUS_UNRECOGNIZED_MEDIA:
    case STATUS_DISK_CORRUPT_ERROR:
    case STATUS_DATA_ERROR:
        sc = STG_E_WRITEFAULT;
        break;

    case STATUS_OBJECT_PATH_NOT_FOUND:
        sc = STG_E_PATHNOTFOUND;
        break;

    case STATUS_SHARING_VIOLATION:
        sc = STG_E_SHAREVIOLATION;
        break;

    case STATUS_FILE_LOCK_CONFLICT:
    case STATUS_LOCK_NOT_GRANTED:
        sc = STG_E_LOCKVIOLATION;
        break;

    case STATUS_DISK_FULL:
        sc = STG_E_MEDIUMFULL;
        break;

    case STATUS_ACCESS_VIOLATION:
    case STATUS_INVALID_USER_BUFFER:
        sc = STG_E_INVALIDPOINTER;
        break;

    case STATUS_TOO_MANY_OPENED_FILES:
        sc = STG_E_TOOMANYOPENFILES;
        break;

    case STATUS_DIRECTORY_NOT_EMPTY:
        sc = WIN32_SCODE(ERROR_DIR_NOT_EMPTY);
        break;

    case STATUS_DELETE_PENDING:
        sc = STG_E_REVERTED;
        break;

    case STATUS_INTERNAL_DB_CORRUPTION:
        sc = STG_E_INVALIDHEADER;
        break;

    case STATUS_UNSUCCESSFUL:
        sc = E_FAIL;
        break;
        
    case STATUS_UNMAPPABLE_CHARACTER:
        sc = HRESULT_FROM_WIN32( ERROR_NO_UNICODE_TRANSLATION );
        break;

    default:
        PropDbg((DEB_ERROR, "NtStatusToScode: Unknown status %lX\n", nts));

        sc = HRESULT_FROM_NT(nts);
        break;
    }

    PropDbg((DEB_ITRACE, "Out NtStatusToScode => %lX\n", sc));
    return sc;
}

#if DBG!=0

ULONG
DbgPrint(
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    CHAR Buffer[512];
    int cb;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);
    cb = PropVsprintfA(Buffer, Format, arglist);
    if (cb == -1) {             // detect buffer overflow
        cb = sizeof(Buffer);
        Buffer[sizeof(Buffer) - 2] = '\n';
        Buffer[sizeof(Buffer) - 1] = '\0';
    }

    OutputDebugString(Buffer);

    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\h\propapi.h ===
/*+-------------------------------------------------------------------------  
 * 
 *  Microsoft Windows   
 *  Copyright (C) Microsoft Corporation, 1992 - 1996.  
 *  
 *  File:       propapi.h   
 *   
 *  Contents:   Definitions of Nt property api.   
 *   
 *--------------------------------------------------------------------------*/

#ifndef _PROPAPI_H_
#define _PROPAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

/**/
/* typedef the function prototypes necessary*/
/* for the UNICODECALLOUTS structure.*/
/**/

typedef UINT (WINAPI FNGETACP)(VOID);

typedef int (WINAPI FNMULTIBYTETOWIDECHAR)(
    IN UINT CodePage,
    IN DWORD dwFlags,
    IN LPCSTR lpMultiByteStr,
    IN int cchMultiByte,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar);

typedef int (WINAPI FNWIDECHARTOMULTIBYTE)(
    IN UINT CodePage,
    IN DWORD dwFlags,
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpMultiByteStr,
    IN int cchMultiByte,
    IN LPCSTR lpDefaultChar,
    IN LPBOOL lpUsedDefaultChar);

typedef STDAPI_(BSTR) FNSYSALLOCSTRING(
    OLECHAR FAR* pwsz);

typedef STDAPI_(VOID) FNSYSFREESTRING(
    BSTR pwsz);

/**/
/* The UNICODECALLOUTS structure holds function*/
/* pointers for routines needed by the property*/
/* set routines in NTDLL.*/
/**/

typedef struct _UNICODECALLOUTS
{
    FNGETACP              *pfnGetACP;
    FNMULTIBYTETOWIDECHAR *pfnMultiByteToWideChar;
    FNWIDECHARTOMULTIBYTE *pfnWideCharToMultiByte;
    FNSYSALLOCSTRING      *pfnSysAllocString;
    FNSYSFREESTRING       *pfnSysFreeString;
} UNICODECALLOUTS;


/**/
/* Define the default UNICODECALLOUTS*/
/* values.*/
/**/

#define WIN32_UNICODECALLOUTS \
    GetACP,                   \
    MultiByteToWideChar,      \
    WideCharToMultiByte,      \
    SysAllocString,         \
    SysFreeString

# define PROPSYSAPI
# define PROPAPI

# define PropFreeHeap(h, z, p) CoTaskMemFree(p)

# define PROPASSERT assert

#define PROPASSERTMSG(szReason, f) assert( (szReason && FALSE) || (f))

# define PropSprintfA wsprintfA
# define PropVsprintfA wvsprintfA

#define WC_PROPSET0     ((WCHAR) 0x0005)
#define OC_PROPSET0     ((OLECHAR) 0x0005)

#define CBIT_BYTE       8
#define CBIT_GUID       (CBIT_BYTE * sizeof(GUID))
#define CBIT_CHARMASK   5

/* Allow for OC_PROPSET0 and a GUID mapped to a 32 character alphabet */
#define CCH_PROPSET        (1 + (CBIT_GUID + CBIT_CHARMASK-1)/CBIT_CHARMASK)
#define CCH_PROPSETSZ      (CHC_PROPSET + 1)            /* allow null*/
#define CCH_PROPSETCOLONSZ (1 + CHC_PROPSET + 1)        /* allow colon and null*/

/* Define the max property name in units of characters
   (and synonomously in wchars). */
#define CCH_MAXPROPNAME    255                          /* Matches Shell &
                                                           Office */
#define CCH_MAXPROPNAMESZ  (CWC_MAXPROPNAME + 1)        /* allow null */
#define CWC_MAXPROPNAME    CCH_MAXPROPNAME
#define CWC_MAXPROPNAMESZ  CCH_MAXPROPNAMESZ


/*+--------------------------------------------------------------------------*/
/* Property Access APIs:                                                     */
/*---------------------------------------------------------------------------*/

typedef VOID *NTPROP;
typedef VOID *NTMAPPEDSTREAM;
typedef VOID *NTMEMORYALLOCATOR;


VOID PROPSYSAPI PROPAPI
RtlSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts);

ULONG PROPSYSAPI PROPAPI
RtlGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[]);

NTSTATUS PROPSYSAPI PROPAPI
RtlPropertySetNameToGuid(
    IN ULONG cwcname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid);


/* RtlCreatePropertySet Flags:*/

#define CREATEPROP_READ         0x0000 /* request read access (must exist)*/
#define CREATEPROP_WRITE        0x0001 /* request write access (must exist)*/
#define CREATEPROP_CREATE       0x0002 /* create (overwrite if exists)*/
#define CREATEPROP_CREATEIF     0x0003 /* create (open existing if exists)*/
#define CREATEPROP_DELETE       0x0004 /* delete*/
#define CREATEPROP_MODEMASK     0x000f /* open mode mask*/

#define CREATEPROP_NONSIMPLE    0x0010 /* Is non-simple propset (in a storage)*/


/* RtlCreateMappedStream Flags:*/

#define CMS_READONLY      0x00000000    /* Opened for read-only*/
#define CMS_WRITE         0x00000001    /* Opened for write access*/
#define CMS_TRANSACTED    0x00000002    /* Is transacted*/


NTSTATUS PROPSYSAPI PROPAPI
RtlCreatePropertySet(
    IN NTMAPPEDSTREAM ms,       /* Nt mapped stream*/
    IN USHORT Flags,	/* NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE*/
    OPTIONAL IN GUID const *pguid, /* property set guid (create only)*/
    OPTIONAL IN GUID const *pclsid,/* CLASSID of propset code (create only)*/
    IN NTMEMORYALLOCATOR ma,	/* memory allocator of caller*/
    IN ULONG LocaleId,		/* Locale Id (create only)*/
    OPTIONAL OUT ULONG *pOSVersion,/* OS Version field in header.*/
    IN OUT USHORT *pCodePage,   /* IN: CodePage of property set (create only)*/
                                /* OUT: CodePage of property set (always)*/
    OUT NTPROP *pnp);           /* Nt property set context*/

NTSTATUS PROPSYSAPI PROPAPI
RtlClosePropertySet(
    IN NTPROP np);              /* property set context*/

#define CBSTM_UNKNOWN   ((ULONG) -1)
NTSTATUS PROPSYSAPI PROPAPI
RtlOnMappedStreamEvent(
    IN VOID *pv,               /* property set context */
    IN VOID *pbuf,             /* property set buffer */
    IN ULONG cbstm );          /* size of underlying stream or CBSTM_UNKNOWN */
                                                                           
NTSTATUS PROPSYSAPI PROPAPI
RtlFlushPropertySet(
    IN NTPROP np);              /* property set context*/

NTSTATUS PROPSYSAPI PROPAPI
RtlSetProperties(
    IN NTPROP np,               /* property set context*/
    IN ULONG cprop,             /* property count*/
    IN PROPID pidNameFirst,     /* first PROPID for new named properties*/
    IN PROPSPEC const aprs[],   /* array of property specifiers*/
    OPTIONAL OUT PROPID apid[], /* buffer for array of propids*/
    OPTIONAL IN PROPVARIANT const avar[]);/* array of properties with values*/

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryProperties(
    IN NTPROP np,               /* property set context*/
    IN ULONG cprop,             /* property count*/
    IN PROPSPEC const aprs[],   /* array of property specifiers*/
    OPTIONAL OUT PROPID apid[], /* buffer for array of propids*/
    IN OUT PROPVARIANT *avar,   /* IN: array of uninitialized PROPVARIANTs,*/
                                /* OUT: may contain pointers to alloc'd memory*/
    OUT ULONG *pcpropFound);    /* count of property values retrieved*/



#define ENUMPROP_NONAMES        0x00000001      /* return property IDs only*/

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumerateProperties(
    IN NTPROP np,               /* property set context*/
    IN ULONG Flags,             /* flags: No Names (propids only), etc.*/
    IN OUT ULONG *pkey,         /* bookmark; caller set to 0 before 1st call*/
    IN OUT ULONG *pcprop,       /* pointer to property count*/
    OPTIONAL OUT PROPSPEC aprs[],/* IN: array of uninitialized PROPSPECs*/
                                /* OUT: may contain pointers to alloc'd strings*/
    OPTIONAL OUT STATPROPSTG asps[]);
                                /* IN: array of uninitialized STATPROPSTGs*/
                                /* OUT: may contain pointers to alloc'd strings*/

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertyNames(
    IN NTPROP np,               /* property set context*/
    IN ULONG cprop,             /* property count*/
    IN PROPID const *apid,      /* PROPID array*/
    OUT OLECHAR *apwsz[]          /* OUT pointers to allocated strings*/
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertyNames(
    IN NTPROP np,               /* property set context*/
    IN ULONG cprop,             /* property count*/
    IN PROPID const *apid,      /* PROPID array*/
    IN OLECHAR const * const apwsz[] /* pointers to property names*/
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertySetClassId(
    IN NTPROP np,               /* property set context*/
    IN GUID const *pclsid       /* new CLASSID of propset code*/
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertySet(
    IN NTPROP np,               /* property set context*/
    OUT STATPROPSETSTG *pspss   /* buffer for property set stat information*/
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumeratePropertySets(
    IN HANDLE hstg,             /* structured storage handle*/
    IN BOOLEAN fRestart,        /* restart scan*/
    IN OUT ULONG *pcspss,       /* pointer to count of STATPROPSETSTGs*/
    IN OUT GUID *pkey,          /* bookmark*/
    OUT STATPROPSETSTG *pspss   /* array of STATPROPSETSTGs*/
    );

#ifdef __cplusplus
}
#endif

#endif /* ifndef _PROPAPI_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\props\h\ntstatus.h ===
/*

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ntstatus.h

Abstract:

    Constant definitions for the NTSTATUS values.

Notes:

    This file is from the NT SDK, a lot of these error codes are not
    being used in the reference implementation.

*/

#ifndef _NTSTATUS_
#define _NTSTATUS_

/////////////////////////////////////////////////////////////////////////
//
// Standard Success values
//
//
/////////////////////////////////////////////////////////////////////////


//
// The success status codes 0 - 63 are reserved for wait completion status.
//
#define STATUS_SUCCESS \
    ((NTSTATUS)0x00000000L)

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the status code of facility
//
//
// Define the facility codes
//
 
//
// MessageId: STATUS_IMAGE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
//  {Machine Type Mismatch}
//  The image file %s is valid, but is for a machine type other than the current machine. Select OK to continue, or CANCEL to fail the DLL load.
//
#define STATUS_IMAGE_MACHINE_TYPE_MISMATCH ((NTSTATUS)0x4000000EL)


//
// MessageId: STATUS_BUFFER_OVERFLOW
//
// MessageText:
//
//  {Buffer Overflow}
//  The data was too large to fit into the specified buffer.
//
#define STATUS_BUFFER_OVERFLOW           ((NTSTATUS)0x80000005L)

//
// MessageId: STATUS_UNSUCCESSFUL
//
// MessageText:
//
//  {Operation Failed}
//  The requested operation was unsuccessful.
//
#define STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)

//
// MessageId: STATUS_NOT_IMPLEMENTED
//
// MessageText:
//
//  {Not Implemented}
//  The requested operation is not implemented.
//
#define STATUS_NOT_IMPLEMENTED           ((NTSTATUS)0xC0000002L)

//
// MessageId: STATUS_ACCESS_VIOLATION
//
// MessageText:
//
//  The instruction at "0x%08lx" referenced memory at "0x%08lx". The memory
//  could not be "%s".
//
#define STATUS_ACCESS_VIOLATION          ((NTSTATUS)0xC0000005L)    // winnt ntsubauth

//
// MessageId: STATUS_UNRECOGNIZED_MEDIA
//
// MessageText:
//
//  {Unknown Disk Format}
//  The disk in drive %s is not formatted properly.
//  Please check the disk, and reformat if necessary.
//
#define STATUS_UNRECOGNIZED_MEDIA        ((NTSTATUS)0xC0000014L)

//
// MessageId: STATUS_INVALID_HANDLE
//
// MessageText:
//
//  An invalid HANDLE was specified.
//
#define STATUS_INVALID_HANDLE            ((NTSTATUS)0xC0000008L)    // winnt

//
// MessageId: STATUS_INVALID_PARAMETER
//
// MessageText:
//
//  An invalid parameter was passed to a service or function.
//
#define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)

//
// MessageId: STATUS_NO_SUCH_DEVICE
//
// MessageText:
//
//  A device which does not exist was specified.
//
#define STATUS_NO_SUCH_DEVICE            ((NTSTATUS)0xC000000EL)


//
// MessageId: STATUS_NO_SUCH_FILE
//
// MessageText:
//
//  {File Not Found}
//  The file %s does not exist.
//
#define STATUS_NO_SUCH_FILE              ((NTSTATUS)0xC000000FL)

//
// MessageId: STATUS_INVALID_DEVICE_REQUEST
//
// MessageText:
//
//  The specified request is not a valid operation for the target device.
//
#define STATUS_INVALID_DEVICE_REQUEST    ((NTSTATUS)0xC0000010L)

//
// MessageId: STATUS_NO_MEDIA_IN_DEVICE
//
// MessageText:
//
//  {No Disk}
//  There is no disk in the drive.
//  Please insert a disk into drive %s.
//
#define STATUS_NO_MEDIA_IN_DEVICE        ((NTSTATUS)0xC0000013L)

//
// MessageId: STATUS_NO_MEDIA_IN_DEVICE
//
// MessageText:
//
//  {No Disk}
//  There is no disk in the drive.
//  Please insert a disk into drive %s.
//
#define STATUS_NO_MEDIA_IN_DEVICE        ((NTSTATUS)0xC0000013L)

//
// MessageId: STATUS_UNRECOGNIZED_MEDIA
//
// MessageText:
//
//  {Unknown Disk Format}
//  The disk in drive %s is not formatted properly.
//  Please check the disk, and reformat if necessary.
//
#define STATUS_UNRECOGNIZED_MEDIA        ((NTSTATUS)0xC0000014L)

//
// MessageId: STATUS_UNABLE_TO_DELETE_SECTION
//
// MessageText:
//
//  Specified section cannot be deleted.
//
#define STATUS_UNABLE_TO_DELETE_SECTION  ((NTSTATUS)0xC000001BL)

//
// MessageId: STATUS_INVALID_SYSTEM_SERVICE
//
// MessageText:
//
//  An invalid system service was specified in a system service call.
//
#define STATUS_INVALID_SYSTEM_SERVICE    ((NTSTATUS)0xC000001CL)

//
// MessageId: STATUS_NO_MEMORY
//
// MessageText:
//
//  {Not Enough Quota}
//  Not enough virtual memory or paging file quota is available to complete
//  the specified operation.
//
#define STATUS_NO_MEMORY                 ((NTSTATUS)0xC0000017L)    // winnt

//
// MessageId: STATUS_ACCESS_DENIED
//
// MessageText:
//
//  {Access Denied}
//  A process has requested access to an object, but has not been granted
//  those access rights.
//
#define STATUS_ACCESS_DENIED             ((NTSTATUS)0xC0000022L)

//
// MessageId: STATUS_OBJECT_TYPE_MISMATCH
//
// MessageText:
//
//  {Wrong Type}
//  There is a mismatch between the type of object required by the requested
//  operation and the type of object that is specified in the request.
//
#define STATUS_OBJECT_TYPE_MISMATCH      ((NTSTATUS)0xC0000024L)

//
// MessageId: STATUS_INVALID_PARAMETER_MIX
//
// MessageText:
//
//  An invalid combination of parameters was specified.
//
#define STATUS_INVALID_PARAMETER_MIX     ((NTSTATUS)0xC0000030L)

//
// MessageId: STATUS_DISK_CORRUPT_ERROR
//
// MessageText:
//
//  {Corrupt Disk}
//  The file system structure on the disk is corrupt and unusable.
//  Please run the Chkdsk utility on the volume %s.
//
#define STATUS_DISK_CORRUPT_ERROR        ((NTSTATUS)0xC0000032L)

//
// MessageId: STATUS_OBJECT_NAME_INVALID
//
// MessageText:
//
//  Object Name invalid.
//
#define STATUS_OBJECT_NAME_INVALID       ((NTSTATUS)0xC0000033L)

//
// MessageId: STATUS_OBJECT_NAME_NOT_FOUND
//
// MessageText:
//
//  Object Name not found.
//
#define STATUS_OBJECT_NAME_NOT_FOUND     ((NTSTATUS)0xC0000034L)


//
// MessageId: STATUS_OBJECT_NAME_COLLISION
//
// MessageText:
//
//  Object Name already exists.
//
#define STATUS_OBJECT_NAME_COLLISION     ((NTSTATUS)0xC0000035L)

//
// MessageId: STATUS_OBJECT_PATH_INVALID
//
// MessageText:
//
//  Object Path Component was not a directory object.
//
#define STATUS_OBJECT_PATH_INVALID       ((NTSTATUS)0xC0000039L)

//
// MessageId: STATUS_OBJECT_PATH_NOT_FOUND
//
// MessageText:
//
//  {Path Not Found}
//  The path %s does not exist.
//
#define STATUS_OBJECT_PATH_NOT_FOUND     ((NTSTATUS)0xC000003AL)

//
// MessageId: STATUS_OBJECT_PATH_SYNTAX_BAD
//
// MessageText:
//
//  Object Path Component was not a directory object.
//
#define STATUS_OBJECT_PATH_SYNTAX_BAD    ((NTSTATUS)0xC000003BL)

//
// MessageId: STATUS_DATA_ERROR
//
// MessageText:
//
//  {Data Error}
//  An error in reading or writing data occurred.
//
#define STATUS_DATA_ERROR                ((NTSTATUS)0xC000003EL)

//
// MessageId: STATUS_NO_SUCH_FILE
//
// MessageText:
//
//  {File Not Found}
//  The file %s does not exist.
//
#define STATUS_NO_SUCH_FILE              ((NTSTATUS)0xC000000FL)

//
// MessageId: STATUS_SHARING_VIOLATION
//
// MessageText:
//
//  A file cannot be opened because the share access flags are
//  incompatible.
//
#define STATUS_SHARING_VIOLATION         ((NTSTATUS)0xC0000043L)

//
// MessageId: STATUS_FILE_LOCK_CONFLICT
//
// MessageText:
//
//  A requested read/write cannot be granted due to a conflicting file lock.
//
#define STATUS_FILE_LOCK_CONFLICT        ((NTSTATUS)0xC0000054L)

//
// MessageId: STATUS_LOCK_NOT_GRANTED
//
// MessageText:
//
//  A requested file lock cannot be granted due to other existing locks.
//
#define STATUS_LOCK_NOT_GRANTED          ((NTSTATUS)0xC0000055L)

//
// MessageId: STATUS_DELETE_PENDING
//
// MessageText:
//
//  A non close operation has been requested of a file object with a
//  delete pending.
//
#define STATUS_DELETE_PENDING            ((NTSTATUS)0xC0000056L)

//
// MessageId: STATUS_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
//  This error indicates that the requested operation cannot be
//  completed due to a catastrophic media failure or on-disk data
//  structure corruption.
//
#define STATUS_INTERNAL_DB_CORRUPTION    ((NTSTATUS)0xC00000E4L)


//
// MessageId: STATUS_DISK_FULL
//
// MessageText:
//
//  An operation failed because the disk was full.
//
#define STATUS_DISK_FULL                 ((NTSTATUS)0xC000007FL)

//
// MessageId: STATUS_FILE_INVALID
//
// MessageText:
//
//  The volume for a file has been externally altered such that the
//  opened file is no longer valid.
//
#define STATUS_FILE_INVALID              ((NTSTATUS)0xC0000098L)

//
// MessageId: STATUS_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the API.
//
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)     // ntsubauth


//
// MessageId: STATUS_FILE_INVALID
//
// MessageText:
//
//  The volume for a file has been externally altered such that the
//  opened file is no longer valid.
//
#define STATUS_FILE_INVALID              ((NTSTATUS)0xC0000098L)

//
// MessageId: STATUS_FILE_FORCED_CLOSED
//
// MessageText:
//
//  The specified file has been closed by another process.
//
#define STATUS_FILE_FORCED_CLOSED        ((NTSTATUS)0xC00000B6L)

//
// MessageId: STATUS_FILE_IS_A_DIRECTORY
//
// MessageText:
//
//  The file that was specified as a target is a directory and the caller
//  specified that it could be anything but a directory.
//
#define STATUS_FILE_IS_A_DIRECTORY       ((NTSTATUS)0xC00000BAL)

//
// MessageId: STATUS_DUPLICATE_NAME
//
// MessageText:
//
//  A duplicate name exists on the network.
//
#define STATUS_DUPLICATE_NAME            ((NTSTATUS)0xC00000BDL)

//
// Status codes raised by the Cache Manager which must be considered as
// "expected" by its callers.
//
//
// MessageId: STATUS_INVALID_USER_BUFFER
//
// MessageText:
//
//  An access to a user buffer failed at an "expected" point in time.
//  This code is defined since the caller does not want to accept
//  STATUS_ACCESS_VIOLATION in its filter.
//
#define STATUS_INVALID_USER_BUFFER       ((NTSTATUS)0xC00000E8L)

//
// MessageId: STATUS_INVALID_PARAMETER_1
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the first argument.
//
#define STATUS_INVALID_PARAMETER_1       ((NTSTATUS)0xC00000EFL)

//
// MessageId: STATUS_INVALID_PARAMETER_2
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the second argument.
//
#define STATUS_INVALID_PARAMETER_2       ((NTSTATUS)0xC00000F0L)

//
// MessageId: STATUS_INVALID_PARAMETER_3
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the third argument.
//
#define STATUS_INVALID_PARAMETER_3       ((NTSTATUS)0xC00000F1L)

//
// MessageId: STATUS_INVALID_PARAMETER_4
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the fourth argument.
//
#define STATUS_INVALID_PARAMETER_4       ((NTSTATUS)0xC00000F2L)

//
// MessageId: STATUS_INVALID_PARAMETER_5
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the fifth argument.
//
#define STATUS_INVALID_PARAMETER_5       ((NTSTATUS)0xC00000F3L)

//
// MessageId: STATUS_INVALID_PARAMETER_6
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the sixth argument.
//
#define STATUS_INVALID_PARAMETER_6       ((NTSTATUS)0xC00000F4L)

//
// MessageId: STATUS_INVALID_PARAMETER_7
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the seventh argument.
//
#define STATUS_INVALID_PARAMETER_7       ((NTSTATUS)0xC00000F5L)

//
// MessageId: STATUS_INVALID_PARAMETER_8
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the eighth argument.
//
#define STATUS_INVALID_PARAMETER_8       ((NTSTATUS)0xC00000F6L)

//
// MessageId: STATUS_INVALID_PARAMETER_9
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the ninth argument.
//
#define STATUS_INVALID_PARAMETER_9       ((NTSTATUS)0xC00000F7L)

//
// MessageId: STATUS_INVALID_PARAMETER_10
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the tenth argument.
//
#define STATUS_INVALID_PARAMETER_10      ((NTSTATUS)0xC00000F8L)

//
// MessageId: STATUS_INVALID_PARAMETER_11
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the eleventh argument.
//
#define STATUS_INVALID_PARAMETER_11      ((NTSTATUS)0xC00000F9L)

//
// MessageId: STATUS_INVALID_PARAMETER_12
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the twelfth argument.
//
#define STATUS_INVALID_PARAMETER_12      ((NTSTATUS)0xC00000FAL)

//
// MessageId: STATUS_DIRECTORY_NOT_EMPTY
//
// MessageText:
//
//  Indicates that the directory trying to be deleted is not empty.
//
#define STATUS_DIRECTORY_NOT_EMPTY       ((NTSTATUS)0xC0000101L)

//
// MessageId: STATUS_FILE_CORRUPT_ERROR
//
// MessageText:
//
//  {Corrupt File}
//  The file or directory %s is corrupt and unreadable.
//  Please run the Chkdsk utility.
//
#define STATUS_FILE_CORRUPT_ERROR        ((NTSTATUS)0xC0000102L)

//
// MessageId: STATUS_NOT_A_DIRECTORY
//
// MessageText:
//
//  A requested opened file is not a directory.
//

//
// MessageId: STATUS_NOT_A_DIRECTORY
//
// MessageText:
//
//  A requested opened file is not a directory.
//
#define STATUS_NOT_A_DIRECTORY           ((NTSTATUS)0xC0000103L)

//
// MessageId: STATUS_NAME_TOO_LONG
//
// MessageText:
//
//  A specified name string is too long for its intended use.
//
#define STATUS_NAME_TOO_LONG             ((NTSTATUS)0xC0000106L)

//
// MessageId: STATUS_BUFFER_ALL_ZEROS
//
// MessageText:
//
//  Specified buffer contains all zeros.
//
#define STATUS_BUFFER_ALL_ZEROS          ((NTSTATUS)0x00000117L)

//
// MessageId: STATUS_TOO_MANY_OPENED_FILES
//
// MessageText:
//
//  Too many files are opened on a remote server.  This error should only
//  be returned by the NT redirector on a remote drive.
//
#define STATUS_TOO_MANY_OPENED_FILES     ((NTSTATUS)0xC000011FL)

//
// MessageId: STATUS_UNMAPPABLE_CHARACTER
//
// MessageText:
//
//  No mapping for the Unicode character exists in the target multi-byte code page.
//
#define STATUS_UNMAPPABLE_CHARACTER      ((NTSTATUS)0xC0000162L)

//
// MessageId: STATUS_NOT_FOUND
//
// MessageText:
//
//  The object was not found.
//
#define STATUS_NOT_FOUND                 ((NTSTATUS)0xC0000225L)

//
// MessageId: STATUS_DUPLICATE_OBJECTID
//
// MessageText:
//
//  The attempt to insert the ID in the index failed because the
//  ID is already in the index.
//
#define STATUS_DUPLICATE_OBJECTID        ((NTSTATUS)0xC000022AL)

//
// MessageId: STATUS_OBJECTID_EXISTS
//
// MessageText:
//
//  The attempt to set the object's ID failed because the object
//  already has an ID.
//
#define STATUS_OBJECTID_EXISTS           ((NTSTATUS)0xC000022BL)

//
// MessageId: STATUS_PROPSET_NOT_FOUND
//
// MessageText:
//
//  The property set specified does not exist on the object.
//
#define STATUS_PROPSET_NOT_FOUND         ((NTSTATUS)0xC0000230L)

#endif // _NTSTATUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\proptest\cpropvar.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       cpropvar.cxx
//
//---------------------------------------------------------------

#include "cpropvar.hxx"
#include "chresult.hxx"
#include <stdio.h>
#include "../../h/tchar.h"

 
// this function is from refstg
BOOLEAN STDCALL 
RtlCompareVariants(
    USHORT CodePage,
    PROPVARIANT const *pvar1,
    PROPVARIANT const *pvar2);


DEFINE_CPROPVARIANT_ASSIGNMENT_OPERATOR(LPSTR, LPSTR);
DEFINE_CPROPVARIANT_CONVERSION_OPERATOR(LPSTR, calpstr, pszVal );

DEFINE_CPROPVARIANT_ASSIGNMENT_OPERATOR(LPWSTR, LPWSTR);
DEFINE_CPROPVARIANT_CONVERSION_OPERATOR(LPWSTR, calpwstr, pwszVal );

DEFINE_CPROPVARIANT_ASSIGNMENT_OPERATOR(CF, CLIPDATA&);
DEFINE_CPROPVARIANT_ASSIGNMENT_OPERATOR(CF, CClipData&);
DEFINE_CPROPVARIANT_ASSIGNMENT_OPERATOR(CLSID, CLSID);


CPropVariant::CPropVariant( VARENUM v, ULONG cElements)
{
    Init(v, cElements);
}

void CPropVariant::Init(
    VARENUM v,
    ULONG cElements)
{
    ULONG cbElement;
    BOOLEAN fZero = FALSE;

    // Ignore vector flag.  This constructor is always for vectors only.

    vt = v | VT_VECTOR;

    switch (vt)
    {
    case VT_VECTOR | VT_UI1:
        cbElement = sizeof(caub.pElems[0]);
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        cbElement = sizeof(cai.pElems[0]);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        cbElement = sizeof(cal.pElems[0]);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        cbElement = sizeof(cah.pElems[0]);
        break;

    case VT_VECTOR | VT_CLSID:
        cbElement = sizeof(GUID);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_CF:
        cbElement = sizeof(CLIPDATA);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
    case VT_VECTOR | VT_LPWSTR:
        cbElement = sizeof(VOID *);
        fZero = TRUE;
        break; 

    case VT_VECTOR | VT_VARIANT:
        cbElement = sizeof(PROPVARIANT);
        ASSERT(VT_EMPTY == 0);
        fZero = TRUE;
        break;

    default:
        ASSERT(!"CAllocStorageVariant -- Invalid vector type");
        vt = VT_EMPTY;
        break;
    }
    if (vt != VT_EMPTY)
    {
        caub.cElems = 0;
        caub.pElems = (BYTE *) CoTaskMemAlloc(cElements * cbElement);
        if (caub.pElems != NULL)
        {
            if (fZero)
            {
                memset(caub.pElems, 0, cElements * cbElement);
            }
            caub.cElems = cElements;
        }
    }
}


VOID *
CPropVariant::_AddStringToVector(
    unsigned pos,
    VOID *pv,
    ULONG cb)
{
    ASSERT(vt == (VT_VECTOR | VT_BSTR)   ||
           vt == (VT_VECTOR | VT_LPSTR)  ||
           vt == (VT_VECTOR | VT_LPWSTR) ||
           vt == (VT_VECTOR | VT_CF) );
    ASSERT(calpstr.pElems != NULL);

    if (pos >= calpstr.cElems)
    {
        char **ppsz = calpstr.pElems;

        calpstr.pElems =
            (char **) CoTaskMemAlloc((pos + 1) * sizeof(calpstr.pElems[0]));
        if (calpstr.pElems == NULL)
        {
            calpstr.pElems = ppsz;
            return(NULL);
        }
        memcpy(calpstr.pElems, ppsz, calpstr.cElems * sizeof(calpstr.pElems[0]));
        memset(
            &calpstr.pElems[calpstr.cElems],
            0,
            ((pos + 1) - calpstr.cElems) * sizeof(calpstr.pElems[0]));
        calpstr.cElems = pos + 1;
        CoTaskMemFree(ppsz);
    }

    LPSTR psz;

    if( (VT_VECTOR | VT_BSTR) == vt )
    {
        psz = (LPSTR) SysAllocString( (BSTR) pv );
        if (psz == NULL)
        {
            return(NULL);
        }

        if (calpstr.pElems[pos] != NULL)
        {
            SysFreeString((BSTR) calpstr.pElems[pos]);
        }
        calpstr.pElems[pos] = psz;
    }
    else
    {
        psz = (LPSTR) CoTaskMemAlloc((VT_BSTR == (vt & ~VT_VECTOR) )
                                       ? cb + sizeof(ULONG)
                                       : cb );
        if (psz == NULL)
        {
            return(NULL);
        }

        memcpy(psz, pv, cb);

        if (calpstr.pElems[pos] != NULL)
        {
            CoTaskMemFree(calpstr.pElems[pos]);
        }
        calpstr.pElems[pos] = psz;
    }


    return(calpstr.pElems[pos]);
}


VOID *
CPropVariant::_AddScalerToVector(
    unsigned pos,
    VOID *pv,
    ULONG cb)
{
    ASSERT(calpstr.pElems != NULL);

    if (pos >= calpstr.cElems)
    {
        char **ppsz = calpstr.pElems;

        calpstr.pElems =
            (char **) CoTaskMemAlloc((pos + 1) * cb);
        if (calpstr.pElems == NULL)
        {
            calpstr.pElems = ppsz;
            return(NULL);
        }
        memset(
            calpstr.pElems,
            0,
            ((pos + 1) - calpstr.cElems) * cb);
        memcpy(calpstr.pElems, ppsz, calpstr.cElems * cb);
        calpstr.cElems = pos + 1;
        CoTaskMemFree(ppsz);
    }


    memcpy( (BYTE*)calpstr.pElems + pos*cb, pv, cb );
    return( (BYTE*)calpstr.pElems + pos*cb );

}
void
CPropVariant::SetLPSTR(
    char const *psz,
    unsigned pos)
{
    if (vt != (VT_VECTOR | VT_LPSTR))
    {
        PropVariantClear( this );
        new (this) CPropVariant(VT_LPSTR, pos);
    }
    _AddStringToVector(pos, (VOID *) psz, strlen(psz) + 1);
}


void
CPropVariant::SetLPWSTR(
    WCHAR const *pwsz,
    unsigned pos)
{
    if (vt != (VT_VECTOR | VT_LPWSTR))
    {
        PropVariantClear( this );
        new (this) CPropVariant(VT_LPWSTR, pos);
    }
    _AddStringToVector(pos, (VOID *) pwsz,
                       sizeof(WCHAR) * (wcslen(pwsz) + 1) );
}


void
CPropVariant::SetCF(
    const CLIPDATA *pclipdata,
    unsigned pos)
{
    CLIPDATA *pclipdataNew;

    if (vt != (VT_VECTOR | VT_CF))
    {
        PropVariantClear( this );
        new (this) CPropVariant(VT_CF, pos);
    }

    pclipdataNew = (CLIPDATA*) _AddScalerToVector(pos, (VOID *) pclipdata, sizeof(CLIPDATA) );

    if( NULL != pclipdataNew
        &&
        NULL != pclipdata )
    {
        pclipdataNew->pClipData = (BYTE*) CoTaskMemAlloc( CBPCLIPDATA(*pclipdata) );
        if( NULL == pclipdataNew->pClipData )
        {
            ASSERT( !"Couldn't allocate pclipdataNew" );
            return;
        }
        else
        {
            pclipdataNew->cbSize = pclipdata->cbSize;
            pclipdataNew->ulClipFmt = pclipdata->ulClipFmt;

            memcpy( pclipdataNew->pClipData,
                    pclipdata->pClipData,
                    CBPCLIPDATA(*pclipdata) );
            return;
        }
    }
}


void
CPropVariant::SetBSTR(
    const BSTR pbstr,
    unsigned int pos)
{
    if (vt != (VT_VECTOR | VT_BSTR))
    {
        PropVariantClear( this );
        new (this) CPropVariant(VT_BSTR, pos+1);
    }
    _AddStringToVector(pos, (VOID *) pbstr,
                       sizeof(OLECHAR) * (ocslen(pbstr) + 1) );
}


BSTR
CPropVariant::GetBSTR( int nSubscript )
{
    ASSERT( vt & VT_VECTOR );
    ASSERT( vt == (VT_BSTR | VT_VECTOR) );
    ASSERT( wReserved1 > 0 );

    if( wReserved1 > 0
        &&
        cabstr.cElems > 0
        &&
        wReserved1 <= cabstr.cElems )
    {
        int nSubscript = wReserved1 - 1;
        wReserved1 = INVALID_SUBSCRIPT;
        return( cabstr.pElems[ nSubscript ] );
    }
    else
        return( NULL );
}

CPropVariant & CPropVariant::operator=(LPPROPVARIANT lppropvar) 
{
    if( INVALID_SUBSCRIPT == wReserved1 )
    {
        ASSERT( INVALID_SUBSCRIPT != wReserved1 );
        PropVariantClear(this);
	Init();
        return (*this);
    }
    else
    {
        if( !(vt & VT_VECTOR)
            ||
            (vt & ~VT_VECTOR) != VT_VARIANT )
        {
            USHORT wReserved1Save = wReserved1;
            PropVariantClear(this);
	    Init(VT_VARIANT, wReserved1Save );
            wReserved1 = wReserved1Save;
        }

        SetLPPROPVARIANT( lppropvar, wReserved1 - 1 );
        wReserved1 = INVALID_SUBSCRIPT;
        return (*this);
    }
}
        

CPropVariant::operator LPPROPVARIANT()
{
    if( vt & VT_VECTOR )
    {
        if( wReserved1 > 0
            &&
            capropvar.cElems > 0
            &&
            wReserved1 <= capropvar.cElems )
        {
            int nSubscript = wReserved1 - 1;
            wReserved1 = INVALID_SUBSCRIPT;
            return( &capropvar.pElems[ nSubscript ] );
        }
        else
        {
            ASSERT( INVALID_SUBSCRIPT == wReserved1 );
            return( (LPPROPVARIANT) this );
        }
    }
    else
        return( (LPPROPVARIANT) this );
}


void
CPropVariant::SetLPPROPVARIANT( LPPROPVARIANT lppropvar, unsigned pos )
{
    if (vt != (VT_VECTOR | VT_VARIANT))
    {
        PropVariantClear( this );
        new (this) CPropVariant(VT_VARIANT, pos + 1);
    }
    
    if (pos >= capropvar.cElems)
    {
        LPPROPVARIANT rgpropvar = capropvar.pElems;

        capropvar.pElems =
            (PROPVARIANT *) CoTaskMemAlloc((pos + 1) * sizeof(capropvar.pElems[0]));
        if (capropvar.pElems == NULL)
        {
            capropvar.pElems = rgpropvar;
            return;
        }
        memcpy(capropvar.pElems, rgpropvar, capropvar.cElems * sizeof(capropvar.pElems[0]));
        memset(
            &capropvar.pElems[capropvar.cElems],
            0,
            ((pos + 1) - capropvar.cElems) * sizeof(capropvar.pElems[0]));
        capropvar.cElems = pos + 1;
        CoTaskMemFree(rgpropvar);
    }

    PropVariantClear( &capropvar.pElems[pos] );
    PropVariantCopy( &capropvar.pElems[pos], lppropvar );

    return;

}

void CPropVariant::Init(const CLIPDATA *p)
{
    Init();

    if( NULL == p )
        return;

    pclipdata = (CLIPDATA*) CoTaskMemAlloc( sizeof(CLIPDATA) );
    if( NULL == pclipdata )
    {
        return;
    }

    pclipdata->cbSize = p->cbSize;
    pclipdata->ulClipFmt = p->ulClipFmt;
    pclipdata->pClipData = NULL;

    if( sizeof(pclipdata->ulClipFmt) > p->cbSize )
    {
	Init();
        return;
    }


    if( NULL != p->pClipData )
    {
        pclipdata->pClipData = (BYTE*) CoTaskMemAlloc( pclipdata->cbSize
                                                      - sizeof(pclipdata->ulClipFmt) );
        if( NULL == pclipdata->pClipData )
            return;

        memcpy( pclipdata->pClipData, p->pClipData, pclipdata->cbSize - sizeof(pclipdata->ulClipFmt) );
    }

    vt = VT_CF;

}

void
CPropVariant::SetCLSID( const CLSID &clsid )
{
    PropVariantClear( this );

    puuid = (CLSID*) CoTaskMemAlloc( sizeof(CLSID) );
    if( NULL == puuid )
    {
        assert(FALSE && "out of memory!");
        exit(-1);
    }

    *puuid = clsid;
    vt = VT_CLSID;
}


void
CPropVariant::SetCLSID(
    const CLSID &clsid,
    unsigned pos)
{
    CLSID *pclsidNew;

    if (vt != (VT_VECTOR | VT_CLSID))
    {
        PropVariantClear( this );
        new (this) CPropVariant(VT_CLSID, pos);
    }

    pclsidNew = (CLSID*) _AddScalerToVector(pos, (VOID *) &clsid, sizeof(CLSID) );

    if( NULL != pclsidNew )
    {
        *pclsidNew = clsid;
    }
}


HRESULT
CPropVariant::Compare( PROPVARIANT *ppropvar1, PROPVARIANT *ppropvar2 )
{
    if( RtlCompareVariants( CP_ACP,     // Ignored,
                            ppropvar1,
                            ppropvar2 ))
    {
        return( S_OK );
    }
    else
    {
        return( S_FALSE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\proptest\proptest.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:         proptest.cxx
//
//  Description:  This is the main file for all the tests
//                of Property set interfaces.
//
//---------------------------------------------------------------

//
//                             IPropertyStorage tests
//

// NOTE: we require more headers here just for convenience of 
// the test program, for other programs only "props.h" should be
// needed.

#ifndef _UNIX
#define INITGUID
#endif // _UNIX

#include "../../props/h/windef.h"
#include "../../h/props.h"

#include "../../props/h/propapi.h"
#include "../../props/h/propset.hxx"

#include "cpropvar.hxx"
#include "../../props/h/propmac.hxx"
#include "../../time.hxx"
#include "proptest.hxx"


#include <sys/types.h>
#include <sys/stat.h>
#ifdef _WIN32
#include <direct.h>  // _mkdir is stored here in win32
#endif

//  -------
//  Globals
//  -------
#ifndef _UNIX
// again for static linkage, these symbols will be duplicated.

OLECHAR aocMap[33], oszSummary[19], oszDocumentSummary[27];

GUID guidSummary =
    { 0xf29f85e0,
      0x4ff9, 0x1068,
      { 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9 } };

GUID guidDocumentSummary =
    { 0xd5cdd502,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

GUID guidDocumentSummary2 =
    { 0xd5cdd505,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };
#else
extern LPOLESTR aocMap, oszSummary, oszDocumentSummary;
extern GUID guidSummary, guidDocumentSummary, guidDocumentSummary2;
#endif // _UNIX

LARGE_INTEGER g_li0;

CPropVariant  g_rgcpropvarAll[ CPROPERTIES_ALL ];
CPropSpec     g_rgcpropspecAll[ CPROPERTIES_ALL ];
char g_szPropHeader[] = "  propid/name          propid    cb   type value\n";
char g_szEmpty[] = "";
BOOL g_fVerbose = FALSE;

/* just a uuid that we use to create new uuids */
GUID g_curUuid = 
{ /* e4ecf7f0-e587-11cf-b10d-00aa005749e9 */
    0xe4ecf7f0,
    0xe587,
    0x11cf,
    {0xb1, 0x0d, 0x00, 0xaa, 0x00, 0x57, 0x49, 0xe9}
};

#define TEST_STANDARD           0x1
#define TEST_WORD6              0x2
#define TEST_INTEROP_W          0x4
#define TEST_INTEROP_R          0x8

__inline OLECHAR
MapChar(IN ULONG i)
{
    return((OLECHAR) aocMap[i & CHARMASK]);
}

//
// We simulate uuidcreate by incrementing a global uuid
// each time the function is called.
//
void UuidCreate (
    OUT GUID * pUuid
    )
{
    g_curUuid.Data1++;          
    *pUuid = g_curUuid;         // member to member copy
}

#ifndef _UNIX

//+--------------------------------------------------------------------------
// Function:    RtlGuidToPropertySetName
//
// Synopsis:    Map property set GUID to null-terminated OLECODE name string.
//
//              The aocname parameter is assumed to be a buffer with room for
//              CCH_PROPSETSZ (28) OLECHARs.  The first character
//              is always OC_PROPSET0 (0x05), as specified by the OLE Appendix
//              B documentation.  The colon character normally used as an NT
//              stream name separator is not written to the caller's buffer.
//
//              No error is possible.
// Arguments:   IN GUID *pguid        -- pointer to GUID to convert
//              OUT OLECHAR aocname[] -- output string buffer
//
// Returns:     count of non-NULL characters in the output string buffer
//---------------------------------------------------------------------------

ULONG PROPSYSAPI PROPAPI
RtlGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[])
{
    BYTE *pb = (BYTE *) pguid;
    BYTE *pbEnd = pb + sizeof(*pguid);
    ULONG cbitRemain = CBIT_BYTE;
    OLECHAR *poc = aocname;

    *poc++ = OC_PROPSET0;

    // Note: CCH_PROPSET includes the OC_PROPSET0, and sizeof(osz...)
    // includes the trailing L'\0', so sizeof(osz...) is ok because the
    // OC_PROPSET0 character compensates for the trailing NULL character.

    ASSERT(CCH_PROPSET >= sizeof(oszSummary)/sizeof(OLECHAR));
    if (*pguid == guidSummary)
    {
        RtlCopyMemory(poc, oszSummary, sizeof(oszSummary));
        return(sizeof(oszSummary)/sizeof(OLECHAR));
    }

    ASSERT(CCH_PROPSET >= sizeof(oszDocumentSummary)/sizeof(OLECHAR));
    if (*pguid == guidDocumentSummary || *pguid == guidDocumentSummary2)
    {
        RtlCopyMemory(poc, oszDocumentSummary, sizeof(oszDocumentSummary));
        return(sizeof(oszDocumentSummary)/sizeof(OLECHAR));
    }

    while (pb < pbEnd)
    {
        ULONG i = *pb >> (CBIT_BYTE - cbitRemain);

        if (cbitRemain >= CBIT_CHARMASK)
        {
            *poc = MapChar(i);
            if (cbitRemain == CBIT_BYTE && 
                *poc >= ((OLECHAR)'a') && 
                *poc <= ((OLECHAR)'z') )
            {
                *poc += (OLECHAR) ((OLECHAR)('A') - (OLECHAR)('a'));
            }
            poc++;

            cbitRemain -= CBIT_CHARMASK;
            if (cbitRemain == 0)
            {
                pb++;
                cbitRemain = CBIT_BYTE;
            }
        }
        else
        {
            if (++pb < pbEnd)
            {
                i |= *pb << cbitRemain;
            }
            *poc++ = MapChar(i);
            cbitRemain += CBIT_BYTE - CBIT_CHARMASK;
        }
    }
    *poc = (OLECHAR)'\0';
    return(CCH_PROPSET);
}
#endif // #ifndef _UNIX

#define Check(x,y) _Check(x,y, __LINE__)


void Cleanup(); // forward declaration

//+=================================================================
//
//  Function:   _Check
//  
//  Synopsis:   Verify that the actual HR is the expected
//              value.  If not, report an error and exit.
//
//  Inputs:     [HRESULT] hrExpected
//                  What we expected
//              [HRESULT] hrActual
//                  The actual HR of the previous operation.
//              [int] line
//                  The line number of the operation.
//  
//  Outputs:    None.
//  
//+=================================================================


void _Check(HRESULT hrExpected, HRESULT hrActual, int line)
{
    if (hrExpected != hrActual)
    {
        printf("\nFailed with hr=%08x at line %d (expected hr=%08x in proptest.cxx)\n",
               hrActual, line, hrExpected );
        Cleanup();
    }
}

OLECHAR * GetNextTest()
{
    static int nTest;
    static CHAR pchBuf[10];
    static OLECHAR pocs[10];

    sprintf(pchBuf, "%d", nTest++);
    STOT(pchBuf, pocs, strlen(pchBuf)+1);

    return(pocs);
}

void Now(FILETIME *pftNow)
{
    DfGetTOD(pftNow);
}


enum CreateOpen
{
    Create, Open
};

IStorage *_pstgTemp=NULL;
IStorage *_pstgTempCopyTo=NULL;  // _pstgTemp is copied to _pstgTempCopyTo

class CTempStorage
{
public:
    CTempStorage(DWORD grfMode = STGM_DIRECT | STGM_CREATE)
    {
        Check(S_OK, (_pstgTemp->CreateStorage(GetNextTest(), grfMode | 
            STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0,
            &_pstg)));
    }


    CTempStorage(CreateOpen co, IStorage *pstgParent, 
                 OLECHAR *pocsChild, DWORD grfMode = STGM_DIRECT)
    {
        if (co == Create)
            Check(S_OK, pstgParent->CreateStorage(pocsChild,
                grfMode | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0,
                &_pstg));
        else
            Check(S_OK, pstgParent->OpenStorage(pocsChild, NULL,
                grfMode | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0,
                &_pstg));
    }

    ~CTempStorage()
    {
        if (_pstg != NULL)
            _pstg->Release();
    }


    IStorage * operator -> ()
    {
        return(_pstg);
    }

    operator IStorage * ()
    {
        return(_pstg);
    }

    void Release()
    {
        if (_pstg != NULL)
        {
            _pstg->Release();
            _pstg = NULL;
        }
    }

private:
    static unsigned int _iName;

    IStorage *  _pstg;
};

unsigned int CTempStorage::_iName;

class CGenProps
{
public:
    CGenProps() : _vt((VARENUM)2) {}
    PROPVARIANT * GetNext(int HowMany, int *pActual, BOOL fWrapOk = FALSE, BOOL fNoNonSimple = TRUE);
    
private:
    BOOL        _GetNext(PROPVARIANT *pVar, BOOL fWrapOk, BOOL fNoNonSimple);
    VARENUM     _vt;

};


PROPVARIANT * CGenProps::GetNext(int HowMany, int *pActual, BOOL fWrapOk, BOOL fNoNonSimple)
{
    PROPVARIANT *pVar = new PROPVARIANT[HowMany];

    if (pVar == NULL)
        return(NULL);
    int l;	
    for (l=0; l<HowMany && _GetNext(pVar + l, fWrapOk, fNoNonSimple); l++) { };

    if (pActual)
        *pActual = l;

    if (l == 0)
    {
        delete pVar;
        return(NULL);
    }

    return(pVar);
}

BOOL CGenProps::_GetNext(PROPVARIANT *pVar, BOOL fWrapOk, BOOL fNoNonSimple)
{
    if (_vt == (VT_VECTOR | VT_CLSID)+1)
    {
        if (!fWrapOk)
            return(FALSE);
        else
            _vt = (VARENUM)2;
    }

    PROPVARIANT Var;
    BOOL fFirst = TRUE;

    do
    {
        GUID *pg;

        if (!fFirst)
        {
            PropVariantClear(&Var);
        }

        fFirst = FALSE;

        memset(&Var, 0, sizeof(Var));
        Var.vt = _vt;

        (*((int*)&_vt))++;

        switch (Var.vt)
        {
        case VT_LPSTR:
                Var.pszVal = (LPSTR)CoTaskMemAlloc(6);
                strcpy(Var.pszVal, "lpstr");
                break;
        case VT_LPWSTR:
                DECLARE_WIDESTR(wcsTemp, "lpwstr");            
                Var.pwszVal = (LPWSTR)CoTaskMemAlloc(14);
                wcscpy(Var.pwszVal, wcsTemp);
                break;
        case VT_CLSID:
                pg = (GUID*)CoTaskMemAlloc(sizeof(GUID));
                UuidCreate(pg);
                Var.puuid = pg;
                break;
        case VT_CF:
                Var.pclipdata = (CLIPDATA*)CoTaskMemAlloc(sizeof(CLIPDATA));
                Var.pclipdata->cbSize = 10;
                Var.pclipdata->pClipData = (BYTE*)CoTaskMemAlloc(10);
                Var.pclipdata->ulClipFmt = 0;
                break;
        }
    } while ( (fNoNonSimple && 
               (Var.vt == VT_STREAM || Var.vt == VT_STREAMED_OBJECT ||
                Var.vt == VT_STORAGE || Var.vt == VT_STORED_OBJECT)) || 
             Var.vt == (VT_VECTOR | VT_VARIANT) || 
             Var.vt == (VT_VECTOR | VT_CF) || 
             Var.vt == (VT_VECTOR | VT_BSTR) || 
             S_OK != PropVariantCopy(pVar, &Var) );  // Is valid propvariant ?

    PropVariantClear(&Var);

    return(TRUE);
}

VOID
CleanStat(ULONG celt, STATPROPSTG *psps)
{
    while (celt--)
    {
        CoTaskMemFree(psps->lpwstrName);
        psps++;
    }
}



HRESULT
PopulateRGPropVar( CPropVariant rgcpropvar[],
                   CPropSpec    rgcpropspec[] )
{
    HRESULT hr = E_FAIL;
    int  i;
    ULONG ulPropIndex = 0;
    CLIPDATA clipdataNull, clipdataNonNull;

    // Initialize the PropVariants

    for( i = 0; i < CPROPERTIES_ALL; i++ )
    {
        rgcpropvar[i].Clear();
    }

    // Create a UI1 property

    DECLARE_OLESTR(ocsUI1, "UI1 Property" );   
    rgcpropspec[ulPropIndex] = ocsUI1;
    rgcpropvar[ulPropIndex] = (UCHAR) 39; // 0x27
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_UI1 );
    ulPropIndex++;

    // Create an I2 property

    DECLARE_OLESTR(ocsI2, "I2 Property" );   
    rgcpropspec[ulPropIndex] = ocsI2;
    rgcpropvar[ulPropIndex] = (SHORT) -502; // 0xfe0a
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_I2 );
    ulPropIndex++;

    // Create a UI2 property
    DECLARE_OLESTR(ocsUI2,  "UI2 Property" );
    rgcpropspec[ulPropIndex] =  ocsUI2;
    rgcpropvar[ulPropIndex] = (USHORT) 502; // 01f6
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_UI2 );
    ulPropIndex++;

    // Create a BOOL property
    DECLARE_OLESTR(ocsBool, "Bool Property" );
    rgcpropspec[ulPropIndex] = ocsBool;
    rgcpropvar[ulPropIndex].SetBOOL( VARIANT_TRUE ); // 0xFFFF
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_BOOL );
    ulPropIndex++;

    // Create a I4 property

    DECLARE_OLESTR(ocsI4, "I4 Property" );
    rgcpropspec[ulPropIndex] = ocsI4;
    rgcpropvar[ulPropIndex] = (long) -523; // 0xFFFFFDF5
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_I4 );
    ulPropIndex++;

    // Create a UI4 property
    DECLARE_OLESTR(ocsUI4, "UI4 Property" );
    rgcpropspec[ulPropIndex] = ocsUI4;
    rgcpropvar[ulPropIndex] = (ULONG) 530; // 0x212
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_UI4 );
    ulPropIndex++;

    // Create a R4 property
    DECLARE_OLESTR(ocsR4,  "R4 Property" );
    rgcpropspec[ulPropIndex] = ocsR4;
    rgcpropvar[ulPropIndex] = (float) 5.37; // 0x40abd70a ?
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_R4 );
    ulPropIndex++;

    // Create an ERROR property
    DECLARE_OLESTR(ocsErr, "ERROR Property" );
    rgcpropspec[ulPropIndex] = ocsErr;
                                // 0x800030002
    rgcpropvar[ulPropIndex].SetERROR( STG_E_FILENOTFOUND );
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_ERROR );
    ulPropIndex++;

    // Create an I8 property

    LARGE_INTEGER large_integer;
    large_integer.LowPart = 551; // 0x227
    large_integer.HighPart = 30; // 0x1E
    DECLARE_OLESTR(ocsI8, "I8 Property" );
    rgcpropspec[ulPropIndex] = ocsI8;
    rgcpropvar[ulPropIndex] = large_integer;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_I8 );
    ulPropIndex++;

    // Create a UI8 property

    ULARGE_INTEGER ularge_integer;
    ularge_integer.LowPart = 561; // 0x231
    ularge_integer.HighPart = 30; // 0x1E
    DECLARE_OLESTR(ocsUI8, "UI8 Property" );
    rgcpropspec[ulPropIndex] = ocsUI8;
    rgcpropvar[ulPropIndex] = ularge_integer;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_UI8 );
    ulPropIndex++;

    // Create an R8 property
    DECLARE_OLESTR( ocsR8, "R8 Property" );
    rgcpropspec[ulPropIndex] = ocsR8;
    rgcpropvar[ulPropIndex] = (double) 571.36; // 4081dae1:47ae147b
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_R8 );
    ulPropIndex++;

    // Create a CY property

    CY cy;
    cy.int64 = 578;             // 0x242
    DECLARE_OLESTR(ocsCY, "Cy Property" );
    rgcpropspec[ulPropIndex] = ocsCY;
    rgcpropvar[ulPropIndex] = cy;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_CY );
    ulPropIndex++;

    // Create a DATE property
    DECLARE_OLESTR(ocsDate, "DATE Property" );
    rgcpropspec[ulPropIndex] = ocsDate;
    rgcpropvar[ulPropIndex].SetDATE( 587 );
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_DATE );
    ulPropIndex++;

    // Create a FILETIME property

    FILETIME filetime;
    filetime.dwLowDateTime = 0x767c0570;
    filetime.dwHighDateTime = 0x1bb7ecf;
    DECLARE_OLESTR(ocsFT, "FILETIME Property" );
    rgcpropspec[ulPropIndex] = ocsFT;
    rgcpropvar[ulPropIndex] = filetime;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_FILETIME );
    ulPropIndex++;

    // Create a CLSID property

    DECLARE_OLESTR(ocsCLSID, "CLSID Property" );
    rgcpropspec[ulPropIndex] = ocsCLSID;
    //  f29f85e0-4ff9-1068-ab91-08002b27b3d9
    rgcpropvar[ulPropIndex] = FMTID_SummaryInformation;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_CLSID );
    ulPropIndex++;


    // Create a vector of CLSIDs
    DECLARE_OLESTR(ocsVectCLSID, "CLSID Vector Property" );
    rgcpropspec[ulPropIndex] = ocsVectCLSID;
    //  f29f85e0-4ff9-1068-ab91-08002b27b3d9
    rgcpropvar[ulPropIndex][0] = FMTID_SummaryInformation;    
    rgcpropvar[ulPropIndex][1] = FMTID_DocSummaryInformation;
    rgcpropvar[ulPropIndex][2] = FMTID_UserDefinedProperties;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_CLSID | VT_VECTOR );
    ulPropIndex++;

    // Create a BSTR property
    DECLARE_OLESTR(ocsBSTR, "BSTR");
    DECLARE_OLESTR(ocsBSTRVal, "BSTR Value");
    rgcpropspec[ulPropIndex] = ocsBSTR;
    rgcpropvar[ulPropIndex].SetBSTR( ocsBSTRVal );
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_BSTR );
    ulPropIndex++;

    // Create a BSTR Vector property
    DECLARE_OLESTR(ocsBSTRVect, "BSTR Vector");
    rgcpropspec[ulPropIndex] = ocsBSTRVect;
    DECLARE_OLESTR(ocsBSTRVectElt, "# - BSTR Vector Element");
    for( i = 0; i < 3; i++ )
    {
        OLECHAR *olestrElement = ocsBSTRVectElt;
        olestrElement[0] = (OLECHAR) i%10 + (OLECHAR)'0';
        rgcpropvar[ulPropIndex].SetBSTR( olestrElement, i );
    }

    ASSERT( rgcpropvar[ulPropIndex].VarType() == (VT_BSTR | VT_VECTOR) );
    ulPropIndex++;

    // Create a variant vector BSTR property.
    DECLARE_OLESTR(ocsBSTRVariantVect, "BSTR Variant Vector");
    DECLARE_OLESTR(ocsBSTRVariantVectElt, "# - Vector Variant Vector");
    rgcpropspec[ulPropIndex ] = ocsBSTRVariantVect;
    
    for( i = 0; i < 3; i++ )
    {
        if( i == 0 )
        {
            rgcpropvar[ulPropIndex][0] = 
                (PROPVARIANT*) CPropVariant((long) 0x1234);
        }
        else
        {
            CPropVariant cpropvarBSTR;
            cpropvarBSTR.SetBSTR( ocsBSTRVariantVectElt );
            (cpropvarBSTR.GetBSTR())[0] = (OLECHAR) i%10 + (OLECHAR)'0';
            rgcpropvar[ulPropIndex][i] = (PROPVARIANT*) cpropvarBSTR;
        }
    }

    ASSERT( rgcpropvar[ulPropIndex].VarType() == (VT_VARIANT | VT_VECTOR) );
    ulPropIndex++;

    // Create an LPSTR property
    DECLARE_OLESTR(ocsLPSTRP, "LPSTR Property");
    rgcpropspec[ulPropIndex] = ocsLPSTRP;
    rgcpropvar[ulPropIndex]  = "LPSTR Value";
    
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_LPSTR );
    ulPropIndex++;

    // Create some ClipFormat properties
    DECLARE_OLESTR(ocsClipName, "ClipFormat property");
    rgcpropspec[ ulPropIndex ] = ocsClipName;
    DECLARE_WIDESTR(wcsClipData, "Clipboard Data");
    rgcpropvar[ ulPropIndex ]  = CClipData( wcsClipData );
    ASSERT( rgcpropvar[ ulPropIndex ].VarType() == VT_CF );
    ulPropIndex++;

    DECLARE_OLESTR(ocsEmptyClipName,
                   "Empty ClipFormat property (NULL pointer)"); 
    rgcpropspec[ ulPropIndex ] = ocsEmptyClipName;
    clipdataNull.cbSize = 4;
    clipdataNull.ulClipFmt = (ULONG) -1; // 0xffff
    clipdataNull.pClipData = NULL;
    rgcpropvar[ ulPropIndex ] = clipdataNull;
    ASSERT( rgcpropvar[ ulPropIndex ].VarType() == VT_CF );
    ulPropIndex++;

    DECLARE_OLESTR(ocsEmptyClipNameNotNull,
                   "Empty ClipFormat property (non-NULL pointer)"); 
    rgcpropspec[ ulPropIndex ] = ocsEmptyClipNameNotNull;
    clipdataNonNull.cbSize = 4;
    clipdataNonNull.ulClipFmt = (ULONG) -1; // 0xffff
    clipdataNonNull.pClipData = (BYTE*) CoTaskMemAlloc(0);
    rgcpropvar[ ulPropIndex ] = clipdataNonNull;
    ASSERT( rgcpropvar[ ulPropIndex ].VarType() == VT_CF );
    ulPropIndex++;


    // Create a vector of ClipFormat properties

    CClipData cclipdataEmpty;
    cclipdataEmpty.Set( (ULONG) -1, "", 0 );
    DECLARE_OLESTR(ocsClipArr, "ClipFormat Array Property");
    rgcpropspec[ ulPropIndex ] = ocsClipArr;
    DECLARE_OLESTR(ocsElt1, "Clipboard Date element 1");
    DECLARE_OLESTR(ocsElt2, "Clipboard Date element 2");     
    rgcpropvar[ ulPropIndex ][0] = CClipData( ocsElt1 );
    rgcpropvar[ ulPropIndex ][1] = cclipdataEmpty;
    rgcpropvar[ ulPropIndex ][2] = clipdataNull;
    rgcpropvar[ ulPropIndex ][3] = clipdataNonNull;
    rgcpropvar[ ulPropIndex ][4] = CClipData( ocsElt2 );

    ASSERT( rgcpropvar[ulPropIndex].VarType() == (VT_CF | VT_VECTOR) );
    ASSERT( rgcpropvar[ulPropIndex].Count() == 5 );
    ulPropIndex++;

    // Create an LPSTR|Vector property (e.g., the DocSumInfo
    // Document Parts array).
    DECLARE_OLESTR(ocsLPSTRorVect, "LPSTR|Vector property");
    rgcpropspec[ ulPropIndex ] = ocsLPSTRorVect;
    rgcpropvar[ ulPropIndex ][0] = "LPSTR Element 0";
    rgcpropvar[ ulPropIndex ][1] = "LPSTR Element 1";

    ASSERT( rgcpropvar[ulPropIndex].VarType() == (VT_LPSTR | VT_VECTOR) );
    ulPropIndex++;

    // Create an LPWSTR|Vector property
    
    DECLARE_OLESTR(ocsLPWSTRVect, "LPWSTR|Vector property");
    DECLARE_WIDESTR(ocslpwvElt1, "LPWSTR Element 0");
    DECLARE_WIDESTR(ocslpwvElt2, "LPWSTR Element 1");    
    rgcpropspec[ ulPropIndex ] = ocsLPWSTRVect;
    rgcpropvar[ ulPropIndex ][0] = ocslpwvElt1;
    rgcpropvar[ ulPropIndex ][1] = ocslpwvElt2;

    ASSERT( rgcpropvar[ulPropIndex].VarType() == (VT_LPWSTR | VT_VECTOR) );
    ulPropIndex++;

    // Create a DocSumInfo HeadingPairs array.
    DECLARE_OLESTR(ocsPairArr, "HeadingPair array");
    rgcpropspec[ ulPropIndex ] = ocsPairArr; 

    rgcpropvar[ ulPropIndex ][0] = (PROPVARIANT*) CPropVariant( "Heading 0" );
    rgcpropvar[ ulPropIndex ][1] = (PROPVARIANT*) CPropVariant( (long) 1 );
    rgcpropvar[ ulPropIndex ][2] = (PROPVARIANT*) CPropVariant( "Heading 1" );
    rgcpropvar[ ulPropIndex ][3] = (PROPVARIANT*) CPropVariant( (long) 1 );

    ASSERT( rgcpropvar[ulPropIndex].VarType() == (VT_VARIANT | VT_VECTOR) );
    ulPropIndex++;

    // Create some NULL (but extant) properties
    DECLARE_OLESTR(ocsEmptyLPSTR, "Empty LPSTR");
    rgcpropspec[ulPropIndex] = ocsEmptyLPSTR;
    rgcpropvar[ulPropIndex]  = "";
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_LPSTR );
    ulPropIndex++;

    DECLARE_OLESTR(ocsEmptyLPWSTR, "Empty LPWSTR");    
    DECLARE_WIDESTR(wcsEmpty, "");
    rgcpropspec[ulPropIndex] = ocsEmptyLPWSTR;
    rgcpropvar[ulPropIndex]  = wcsEmpty;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_LPWSTR );
    ulPropIndex++;


    DECLARE_OLESTR(ocsEmptyBLOB, "Empty BLOB");
    rgcpropspec[ulPropIndex] = ocsEmptyBLOB;
    rgcpropvar[ulPropIndex] = CBlob(0);
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_BLOB );
    ulPropIndex++;

    DECLARE_OLESTR(ocsEmptyBSTR, "Empty BSTR");
    DECLARE_OLESTR(ocsEmpty, "");
    rgcpropspec[ulPropIndex] = ocsEmptyBSTR;
    rgcpropvar[ulPropIndex].SetBSTR( ocsEmpty );
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_BSTR );
    ulPropIndex++;

    //  ----
    //  Exit
    //  ----

    CoTaskMemFree( clipdataNonNull.pClipData );
    memset( &clipdataNonNull, 0, sizeof(clipdataNonNull) );
   
    ASSERT( CPROPERTIES_ALL == ulPropIndex );
    hr = S_OK;
    return(hr);
}


//+---------------------------------------------------------------
//
//  Function:   test_WriteReadAllProperties
//
//  Synopsis:   This test simply creates two new property
//              sets in a new file (one Ansi and one Unicode),
//              writes all the properties in g_rgcpropvarAll,
//              reads them back, and verifies that it reads what
//              it wrote.
//
//  Outputs:    None.
//
//+---------------------------------------------------------------

void
test_WriteReadAllProperties(ULONG ulTestOptions )
{
    FMTID fmtidAnsi, fmtidUnicode;
    TSafeStorage< IStorage > pstg;
    TSafeStorage< IPropertySetStorage > ppropsetstg;
    TSafeStorage< IPropertyStorage > ppropstgAnsi;
    TSafeStorage< IPropertyStorage > ppropstgUnicode;

    CPropVariant rgcpropvarAnsi[ CPROPERTIES_ALL ];
    CPropVariant rgcpropvarUnicode[ CPROPERTIES_ALL ];

    printf( "   Simple Write/Read Test\n" );

    //  -----------------------
    //  Create the Property Set
    //  -----------------------

    // Generate FMTIDs.

    fmtidAnsi = IID_IPropertyStorage;
    fmtidUnicode = IID_IPropertySetStorage;

    // Generate a filename from the directory name.

    DECLARE_OLESTR(ocsFile, "AllProps.stg" );

    if (! (ulTestOptions & TEST_INTEROP_R))
    {
        // Create the Docfile.
        printf("        Writing into file ... \n");

        Check( S_OK, StgCreateDocfile( ocsFile,
                                       STGM_CREATE | 
                                       STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                       0L,
                                       &pstg ));
    
        // Get the IPropertySetStorage
        
        Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, 
                                           (void**)&ppropsetstg ));
    
        // Create a Property Storage
        
        Check( S_OK, ppropsetstg->Create( fmtidAnsi,
                                          &CLSID_NULL,
                                          PROPSETFLAG_DEFAULT,
                                          STGM_READWRITE | 
                                          STGM_SHARE_EXCLUSIVE,
                                          &ppropstgAnsi ));
        
        Check( S_OK, ppropsetstg->Create( fmtidUnicode,
                                          &CLSID_NULL,
                                          PROPSETFLAG_ANSI,
                                          STGM_READWRITE | 
                                          STGM_SHARE_EXCLUSIVE,
                                          &ppropstgUnicode ));
        
        Check( S_OK, ppropstgAnsi->WriteMultiple( CPROPERTIES_ALL,
                                                  (PROPSPEC*)g_rgcpropspecAll,
                                                  (PROPVARIANT*)g_rgcpropvarAll,
                                                  PID_FIRST_USABLE ));

        Check( S_OK, ppropstgUnicode->WriteMultiple( CPROPERTIES_ALL,
                                                     (PROPSPEC*)g_rgcpropspecAll,
                                                     (PROPVARIANT*)g_rgcpropvarAll,
                                                     PID_FIRST_USABLE ));      
    }
    else
    {
        // open it
        printf("        opening file ... \n");

        Check(S_OK, StgOpenStorage( ocsFile,
                                    (IStorage*) NULL,
                                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE,  
                                    (SNB) 0,
                                    (DWORD) 0,
                                    &pstg ));

        // Get the IPropertySetStorage
        
        Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, 
                                           (void**)&ppropsetstg ));
    
        // Open the Property Storage

        Check(S_OK, ppropsetstg->Open(fmtidUnicode,
                                      STGM_SHARE_EXCLUSIVE | 
                                      STGM_DIRECT | STGM_READWRITE,
                                      &ppropstgUnicode));
        Check(S_OK, ppropsetstg->Open(fmtidAnsi,
                                      STGM_SHARE_EXCLUSIVE | 
                                      STGM_DIRECT | STGM_READWRITE,
                                      &ppropstgAnsi));
    }    

    printf("        Verifying file ... \n");
    // either way, read it and make sure it is right
    Check( S_OK, ppropstgAnsi->ReadMultiple( CPROPERTIES_ALL,
                                             (PROPSPEC*)g_rgcpropspecAll,
                                             (PROPVARIANT*)rgcpropvarAnsi ));

    Check( S_OK, ppropstgUnicode->ReadMultiple( CPROPERTIES_ALL,
                                                (PROPSPEC*)g_rgcpropspecAll,
                                                (PROPVARIANT*)rgcpropvarUnicode ));
        
    //  ----------------------
    //  Compare the properties
    //  ----------------------
    
    for( int i = 0; i < (int)CPROPERTIES_ALL; i++ )
    {
        Check( TRUE, rgcpropvarAnsi[i] == g_rgcpropvarAll[i]
                     &&
                     rgcpropvarUnicode[i] == g_rgcpropvarAll[i] );
    }
    
}   // test_WriteReadProperties




//
// DOCFILE -- run all tests on DocFile
//
// IPropertySetStorage tests
//      

void
test_IPropertySetStorage_IUnknown(IStorage *pStorage)
{
    printf( "   IPropertySetStorage::IUnknown\n" );

    //       Check ref counting through different interfaces on object
    //      
    //          QI to IPropertySetStorage
    //          QI to IUnknown on IStorage
    //          QI to IUnknown on IPropertySetStorage
    //          QI back to IPropertySetStorage from IUnknown
    //          QI back to IStorage from IPropertySetStorage
    //      
    //          Release all.
    //

    IStorage *pStorage2;
    IPropertySetStorage *ppss1, *ppss2, *ppss3;
    IUnknown *punk1,*punk2;

    Check(S_OK, pStorage->QueryInterface(IID_IPropertySetStorage, (void**)&ppss1));
    Check(S_OK, pStorage->QueryInterface(IID_IUnknown, (void **)&punk1));
    Check(S_OK, ppss1->QueryInterface(IID_IUnknown, (void **)&punk2));
    Check(S_OK, ppss1->QueryInterface(IID_IStorage, (void **)&pStorage2));
    Check(S_OK, ppss1->QueryInterface(IID_IPropertySetStorage, (void **)&ppss2));
    Check(S_OK, punk1->QueryInterface(IID_IPropertySetStorage, (void **)&ppss3));

    ppss1->AddRef();
    ppss1->Release();

    //pStorage.Release();
    ppss1->Release();
    punk1->Release();
    punk2->Release();
    pStorage2->Release();
    ppss2->Release();
    ppss3->Release();

}


#define INVALID_POINTER     ( (void *) 0xFFFFFFFF )
#define VTABLE_MEMBER_FN(pObj,entry)  ( (*(ULONG ***)(pObj))[ (entry) ] )


//+---------------------------------------------------------
//
//  Template:   Alloc2PageVector
//
//  Purpose:    This function template allocates two pages
//              of memory, and then sets a vector pointer
//              so that its first element is wholy within
//              the first page, and the second element is 
//              wholy within the second.  Then, the protection
//              of the second page is set according to the
//              caller-provided parameter.
//
//
//  Inputs:     [TYPE**] ppBase
//                  Points to the beginning of the two pages.
//              [TYPE**] ppVector
//                  Points to the beginning of the vector of TYPEs.
//              [DWORD] dwProtect
//                  The desired protection on the second page
//                  (from the PAGE_* enumeration).
//              [LPWSTR] lpwstr (optional)
//                  If not NULL, used to initialize the vector
//                  elements.
//
//  Output:     TRUE iff successful.
//
//+---------------------------------------------------------


template< class TYPE > BOOL Alloc2PageVector( TYPE** ppBase,
                                              TYPE** ppVector,
                                              DWORD  dwProtect,
                                              TYPE*  pInit )
{
    DWORD dwOldProtect;
    SYSTEM_INFO si;

    GetSystemInfo( &si );

    *ppBase = (TYPE*) VirtualAlloc( NULL, 2 * si.dwPageSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE );
    if( NULL == *ppBase )
        return( FALSE );

    *ppVector = (TYPE*) ( (BYTE*) *ppBase + si.dwPageSize - sizeof(TYPE) );

    if( NULL != pInit )
    {
        memcpy( &((LPWSTR*)*ppVector)[0], pInit, sizeof(TYPE) );
        memcpy( &((LPWSTR*)*ppVector)[1], pInit, sizeof(TYPE) );
    }

    if( !VirtualProtect( (BYTE*) *ppBase + si.dwPageSize, si.dwPageSize, dwProtect, &dwOldProtect ) )
        return( FALSE );

    return( TRUE );
}



void
test_PropVariantValidation( IStorage *pStg )
{

    printf( "   PropVariant Validation\n" );

    TSafeStorage< IPropertySetStorage > pPSStg( pStg );
    TSafeStorage< IPropertyStorage > pPStg;

    CPropVariant cpropvar;
    CLIPDATA     clipdata;
    PROPSPEC     propspec;

    DECLARE_WIDESTR(wszText, "Unicode Text String");

    FMTID fmtid;
    UuidCreate( &fmtid );

    Check(S_OK, pPSStg->Create( fmtid,
                                NULL,
                                PROPSETFLAG_DEFAULT,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                &pPStg ));


    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = 2;

    //  -------------------------------
    //  Test invalid VT_CF Propvariants
    //  -------------------------------

    // NULL clip format.

    clipdata.cbSize = 4;
    clipdata.ulClipFmt = (ULONG) -1;
    clipdata.pClipData = NULL;

    cpropvar = clipdata;

    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    // Too short cbSize.

    ((PROPVARIANT*)cpropvar)->pclipdata->cbSize = 3;
    Check(STG_E_INVALIDPARAMETER, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    // Too short pClipData (it should be 1 byte, but the pClipData is NULL).

    ((PROPVARIANT*)cpropvar)->pclipdata->cbSize = 5;
    Check(STG_E_INVALIDPARAMETER, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));


}

//       Check creation/open/deletion of property sets (check fmtid and predefined names)
//          Create a property set
//          Try recreate of same
//          Try delete
//          Close the property set
//          Try recreate of same 
//          Reopen the property set
//          Try recreate of same
//          Try delete
//          Close the property set
//          Delete the property set
//          Repeat the test once more

void
test_IPropertySetStorage_CreateOpenDelete(IStorage *pStorage)
{
    printf( "   IPropertySetStorage::Create/Open/Delete\n" );

    FMTID fmtid;
    PROPSPEC propspec;

    UuidCreate(&fmtid);
    int i;
    for (i=0; i<4; i++)
    {
        {
            TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
            IPropertyStorage *PropStg, *PropStg2;
            
            Check(S_OK, pPropSetStg->Create(fmtid,
                                            NULL,
                                            PROPSETFLAG_DEFAULT,
                                            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                            &PropStg));
            Check(S_OK, pPropSetStg->Create(
                fmtid,
                NULL,
                PROPSETFLAG_DEFAULT,
                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &PropStg2));
            
            Check(STG_E_REVERTED, PropStg->Commit(0));
            
            PropStg->Release();
            PropStg2->Release();
        }        
        {
            TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
            IPropertyStorage *PropStg, *PropStg2;
            
            // use STGM_FAILIFTHERE
            Check(STG_E_FILEALREADYEXISTS, 
                  pPropSetStg->Create(fmtid,
                                      NULL,
                                      PROPSETFLAG_DEFAULT,
                                      STGM_SHARE_EXCLUSIVE | STGM_DIRECT | 
                                      STGM_READWRITE,
                                      &PropStg));
            
            Check(S_OK, 
                  pPropSetStg->Open(fmtid,
                                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | 
                                    STGM_READWRITE,
                                    &PropStg));
            
            Check(STG_E_ACCESSDENIED, 
                  pPropSetStg->Create(fmtid,
                                      NULL,
                                      PROPSETFLAG_DEFAULT,
                                      STGM_SHARE_EXCLUSIVE | STGM_DIRECT | 
                                      STGM_READWRITE,
                                      &PropStg2));
        
            Check(S_OK, 
                  pPropSetStg->Delete(fmtid));
        
            propspec.ulKind = PRSPEC_PROPID;
            propspec.propid = 1000;
            PROPVARIANT propvar;
            propvar.vt = VT_I4;
            propvar.lVal = 12345;
            Check(STG_E_REVERTED, 
                  PropStg->WriteMultiple(1, &propspec, &propvar, 
                                     2)); // force dirty
        
            PropStg->Release();
        }
    }

    //  --------------------------------------------------------
    //  Test the Create/Delete of the DocumentSummaryInformation
    //  property set (this requires special code because it
    //  has two sections).
    //  --------------------------------------------------------

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    TSafeStorage< IPropertyStorage> pPropStg1, pPropStg2;

    // Create & Delete a DSI propset with just the first section.

    Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg1));

    pPropStg1->Release(); pPropStg1 = NULL;
    Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));

    // Create & Delete a DSI propset with just the second section

    Check(S_OK, pPropSetStg->Create(FMTID_UserDefinedProperties,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg1 ));

    pPropStg1->Release(); pPropStg1 = NULL;
    Check(S_OK, pPropSetStg->Delete( FMTID_UserDefinedProperties ));

    // Create & Delete a DocumentSummaryInformation propset with both sections.  
    // If you delete the DSI propset first, it should delete both sections.
    // If you delete the UD propset first, the DSI propset should still
    // remain.  We'll loop twice, trying both combinations.

    for( i = 0; i < 2; i++ )
    {

        // Create the first section, which implicitely creates
        // the second section.

        Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
                NULL,
                PROPSETFLAG_DEFAULT,
                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &pPropStg1));

        pPropStg1->Release(); pPropStg1 = NULL;

        if( i == 0 )
        {
            Check(S_OK, pPropSetStg->Delete( FMTID_UserDefinedProperties ));
            Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));
        }
        else
        {
            Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));
            Check(STG_E_FILENOTFOUND, pPropSetStg->Delete( FMTID_UserDefinedProperties ));
        }
    }   // for( i = 0; i < 2; i++ )

    //  -------------------------------------
    //  Test special properties in DocSumInfo
    //  -------------------------------------

    // This verifies that when we Create a DocSumInfo
    // property set, and write a Vector or LPSTRs,
    // we can read it again.  We test this because 
    // Vectors of LPSTRs are a special case in the DocSumInfo,
    // and the Create & Open path are slightly different
    // in CPropertySetStream::_LoadHeader.

    // Create a new property set.

    Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg1));

    // Create a vector of LPSTRs.  Make the strings
    // varying lengths to ensure we get plenty of
    // opportunity for alignment problems.

    CPropVariant cpropvarWrite, cpropvarRead;

    cpropvarWrite[3] = "12345678";
    cpropvarWrite[2] = "1234567";
    cpropvarWrite[1] = "123456";
    cpropvarWrite[0] = "12345";
    ASSERT( cpropvarWrite.Count() == 4 );

    // Write the property
    DECLARE_OLESTR(ocsVect, "A Vector of LPSTRs");
    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = ocsVect;

    Check(S_OK, pPropStg1->WriteMultiple( 1, &propspec, cpropvarWrite, 2 ));

    // Read the property back.

    Check(S_OK, pPropStg1->ReadMultiple( 1, &propspec, cpropvarRead ));

    // Verify that we read what we wrote.

    for( i = 0; i < (int) cpropvarWrite.Count(); i++ )
    {
        Check(0, strcmp( (LPSTR) cpropvarWrite[i], (LPSTR) cpropvarRead[i] ));
    }

}


void
test_IPropertySetStorage_SummaryInformation(IStorage *pStorage)
{
    printf( "   SummaryInformation\n" );
    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    IPropertyStorage *PropStg;
    IStream *pstm;

    Check(S_OK, pPropSetStg->Create(FMTID_SummaryInformation,
            NULL,
            PROPSETFLAG_DEFAULT, // simple, wide
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &PropStg));

    PropStg->Release();
    DECLARE_OLESTR(ocsSummary, "\005SummaryInformation");
    Check(S_OK, pStorage->OpenStream(ocsSummary,
            NULL,
            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
            0,
            &pstm));

    pstm->Release();
}

//
//       Check STGM_FAILIFTHERE and ~STGM_FAILIFTHERE in following cases
//          Check overwriting simple with simple

void
test_IPropertySetStorage_FailIfThere(IStorage *pStorage)
{
    // (Use "fale" instead of "fail" in this printf so the output won't
    // alarm anyone with the word "fail" uncessarily).
    printf( "   IPropertySetStorage, FaleIfThere\n" );

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);

    // Iter       0        1          2         3          4        5          6         7
    // Create     simple   nonsimple  simple    nonsimple  simple   nonsimple  simple    nonsimple
    // ReCreate   simple   simple     nonsimple nonsimple  simple   simple     nonsimple nonsimple
    //            failif   failif     failif    failif     overw    overw      overw     overw
    //
    // expected   exists   exists     exists    exists     ok       ok         ok        ok

    for (int i=0; i<8; i++)
    {
        FMTID fmtid;
        IPropertyStorage *PropStg;


        UuidCreate(&fmtid);

        Check(S_OK, pPropSetStg->Create(fmtid,
                NULL,
                0,
                STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &PropStg));

        PropStg->Release();

        Check((i&4) == 4 ? S_OK : STG_E_FILEALREADYEXISTS,
            pPropSetStg->Create(fmtid,
                NULL,
                0,
                ( (i & 4) == 4 ? STGM_CREATE : STGM_FAILIFTHERE) |
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &PropStg));

        if (PropStg)
        {
            PropStg->Release();
        }
    }
}

void
test_IPropertySetStorage(IStorage *pStorage)
{
    //       Check ref counting through different interfaces on object
    test_IPropertySetStorage_IUnknown(pStorage);
    test_IPropertySetStorage_CreateOpenDelete(pStorage);
    test_IPropertySetStorage_SummaryInformation(pStorage);
    test_IPropertySetStorage_FailIfThere(pStorage);
}

//  IEnumSTATPROPSETSTG
//
//       Check enumeration of property sets
//      
//          Check refcounting and IUnknown
//      
//          Create some property sets, predefined and not, simple and not, one through IStorage
//          Enumerate them and check
//              (check fmtid, grfFlags)
//              (check when asking for more than there is: S_FALSE, S_OK)
//          Delete one
//          Reset the enumerator
//          Enumerate them and check
//          Delete one
//      
//          Reset the enumeratorA
//          Read one from enumeratorA
//          Clone enumerator -> enumeratorB
//          Loop comparing rest of enumerator contents
//      
//          Reset the enumerator
//          Skip all
//          Check none left
//      
//          Reset the enumerator
//          Skip all but one
//          Check one left
//

void CheckTime(const FILETIME &ftStart, const FILETIME &ftPropSet)
{
    FILETIME ftNow;
    Now(&ftNow);

    if (ftPropSet.dwLowDateTime == 0 && ftPropSet.dwHighDateTime == 0)
    {
        return;
    }

    // if ftPropSet < ftStart || ftNow < ftPropSet, error
    ASSERT (!(CompareFileTime(&ftPropSet, &ftStart) == -1 ||
              CompareFileTime(&ftNow, &ftPropSet) == -1));
}

void test_IEnumSTATPROPSETSTG(IStorage *pStorage)
{
    printf( "   IEnumSTATPROPSETSTG\n" );

    FMTID afmtid[8];
    CLSID aclsid[8];
    IPropertyStorage *pPropSet;

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FILETIME ftStart;

    Now(&ftStart);

    pPropSetStg->Delete(FMTID_SummaryInformation);

    for (int i=0; i<5; i++)
    {
        if (i & 4)
            afmtid[i] = FMTID_SummaryInformation;
        else
            UuidCreate(&afmtid[i]);

        UuidCreate(&aclsid[i]);

        Check(S_OK, pPropSetStg->Create(afmtid[i], aclsid+i,
             ((i & 2) ? PROPSETFLAG_ANSI : 0),
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropSet));
        pPropSet->Release();
    }


    STATPROPSETSTG StatBuffer[6];
    ULONG celt;
    IEnumSTATPROPSETSTG *penum, *penum2;

    Check(S_OK, pPropSetStg->Enum(&penum));

    IUnknown *punk, *punk2;
    IEnumSTATPROPSETSTG *penum3;
    Check(S_OK, penum->QueryInterface(IID_IUnknown, (void**)&punk));
    Check(S_OK, punk->QueryInterface(IID_IEnumSTATPROPSETSTG, (void**)&penum3));
    Check(S_OK, penum->QueryInterface(IID_IEnumSTATPROPSETSTG, (void**)&punk2));
    ASSERT(punk == punk2);
    punk->Release();
    penum3->Release();
    punk2->Release();

    // test S_FALSE
    Check(S_FALSE, penum->Next(6, StatBuffer, &celt));
    ASSERT(celt == 5);
    penum->Reset();


    // test reading half out, then cloning, then comparing
    // rest of enumeration with other clone.

    Check(S_OK, penum->Next(3, StatBuffer, &celt));
    ASSERT(celt == 3);
    celt = 0;
    Check(S_OK, penum->Clone(&penum2));
    Check(S_OK, penum->Next(2, StatBuffer, &celt));
    ASSERT(celt == 2);
    // check the clone
    for (int c=0; c<2; c++)
    {
        STATPROPSETSTG CloneStat;
        Check(S_OK, penum2->Next(1, &CloneStat, NULL));
        Check(TRUE, 0 == memcmp(&CloneStat, StatBuffer+c, sizeof(CloneStat)));
        Check(TRUE, CloneStat.dwOSVersion == PROPSETHDR_OSVERSION_UNKNOWN);
    }

    // check both empty
    celt = 0;
    Check(S_FALSE, penum->Next(1, StatBuffer, &celt));
    ASSERT(celt == 0);

    Check(S_FALSE, penum2->Next(1, StatBuffer, &celt));
    ASSERT(celt == 0);

    penum->Reset();

    //
    // loop deleting one propset at a time
    // enumerate the propsets checking that correct ones appear.
    //
    for (ULONG d = 0; d<5; d++)
    {
        // d is for delete

        BOOL afFound[5];

        Check(S_OK, penum->Next(5-d, StatBuffer, &celt));
        ASSERT(celt == 5-d);
        penum->Reset();
    
        memset(afFound, 0, sizeof(afFound));
        for (ULONG iPropSet=0; iPropSet<5; iPropSet++)
        {
            ULONG iSearch;	
            for (iSearch=0; iSearch<5-d; iSearch++)
            {
                if (0 == memcmp(&StatBuffer[iSearch].fmtid, 
                                &afmtid[iPropSet], 
                                sizeof(StatBuffer[0].fmtid)))
                {
                    ASSERT (!afFound[iPropSet]);
                    afFound[iPropSet] = TRUE;
                    break;
                }
            }
            if (iPropSet < d)
            {
                ASSERT(!afFound[iPropSet]);
            }
            if (iSearch == 5-d)
            {
                ASSERT(iPropSet < d);
                continue;
            }
            ASSERT( ( (StatBuffer[iSearch].grfFlags 
                           & PROPSETFLAG_NONSIMPLE)  == 0 ) ); 
            ASSERT((StatBuffer[iSearch].grfFlags & PROPSETFLAG_ANSI) == 0);
            if (StatBuffer[iSearch].grfFlags & PROPSETFLAG_NONSIMPLE)
            {
                ASSERT(StatBuffer[iSearch].clsid == aclsid[iPropSet]);
            }
            else
            {
                ASSERT(StatBuffer[iSearch].clsid == CLSID_NULL);
            }
            CheckTime(ftStart, StatBuffer[iSearch].mtime);
            CheckTime(ftStart, StatBuffer[iSearch].atime);
            CheckTime(ftStart, StatBuffer[iSearch].ctime);
        }

        Check(S_OK, pPropSetStg->Delete(afmtid[d]));
        Check(S_OK, penum->Reset());
    }

    penum->Release();
    penum2->Release();

}


//   Creation tests
//
//       Access flags/Valid parameters/Permissions
//          Check readonly cannot be written -
//              WriteProperties, WritePropertyNames
void
test_IPropertyStorage_Access(IStorage *pStorage)
{
    printf( "   IPropertyStorage creation (access) tests\n" );

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    UuidCreate(&fmtid);

    // check by name
    IPropertyStorage *pPropStg;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL, 0, 
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

//   QueryInterface tests
//          QI to IPropertyStorage
//          QI to IUnknown on IPropertyStorage
//          QI back to IPropertyStorage from IUnknown
//      
//          Release all.
    IPropertyStorage *pPropStg2,*pPropStg3;
    IUnknown *punk;

    Check(S_OK, pPropStg->QueryInterface(IID_IPropertyStorage, 
        (void**)&pPropStg2));
    Check(S_OK, pPropStg->QueryInterface(IID_IUnknown, 
        (void**)&punk));
    Check(S_OK, punk->QueryInterface(IID_IPropertyStorage, 
        (void**)&pPropStg3));
    pPropStg3->Release();
    pPropStg2->Release();
    punk->Release();

    PROPSPEC ps;
    ps.ulKind = PRSPEC_LPWSTR;
    DECLARE_OLESTR(ocsTestProp, "testprop");
    ps.lpwstr = ocsTestProp;
    PROPVARIANT pv;
    pv.vt = VT_LPWSTR;
    DECLARE_CONST_OLESTR(ocsTestVal, "testval");
    LPOLESTR ocsTest = ocsTestVal;
    DECLARE_WIDESTR(wcsTestVal, "testval");
    pv.pwszVal = wcsTestVal;
    Check(S_OK, pPropStg->WriteMultiple(1, &ps, &pv, 2));
    pPropStg->Release();
    Check(S_OK, pPropSetStg->Open(fmtid, STGM_SHARE_EXCLUSIVE | STGM_READ,
                                  &pPropStg)); 
    Check(STG_E_ACCESSDENIED, pPropStg->WriteMultiple(1, &ps, &pv, 2));
    Check(STG_E_ACCESSDENIED, pPropStg->DeleteMultiple(1, &ps));
    PROPID propid=3;
    Check(STG_E_ACCESSDENIED, pPropStg->WritePropertyNames(1, &propid, 
                                                           &ocsTestVal));
    Check(STG_E_ACCESSDENIED, pPropStg->DeletePropertyNames(1, &propid));
    FILETIME ft;
    Check(STG_E_ACCESSDENIED, pPropStg->SetTimes(&ft, &ft, &ft));
    CLSID clsid;
    Check(STG_E_ACCESSDENIED, pPropStg->SetClass(clsid));

    pPropStg->Release();
}

//   Creation tests
//       Check VT_STREAM etc not usable with simple.

void 
test_IPropertyStorage_Create(IStorage *pStorage)
{
    printf( "   IPropertyStorage creation tests\n" );
    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    UuidCreate(&fmtid);

    // check by name
    IPropertyStorage *pPropStg;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL, 0 /* simple */, 
        STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));
    PROPSPEC ps;
    ps.ulKind = PRSPEC_PROPID;
    ps.propid = 2;
    PROPVARIANT pv;
    pv.vt = VT_STREAM;
    pv.pStream = NULL;
    // the ref impl. does not recognize VT_STREAM, and will thus
    // treat it as a invalid type.
    Check(STG_E_INVALIDPARAMETER, 
          pPropStg->WriteMultiple(1, &ps, &pv, 2000));  
    // 
    pPropStg->Release();
}


void
CheckStat(  IPropertyStorage *pPropSet, REFFMTID fmtid, 
            REFCLSID clsid, ULONG PropSetFlag,
            const FILETIME & ftStart, DWORD dwOSVersion )
{
    STATPROPSETSTG StatPropSetStg;
    Check(S_OK, pPropSet->Stat(&StatPropSetStg));

    Check(TRUE, StatPropSetStg.fmtid == fmtid);
    Check(TRUE, StatPropSetStg.clsid == clsid);
    Check(TRUE, StatPropSetStg.grfFlags == PropSetFlag);
    Check(TRUE, StatPropSetStg.dwOSVersion == dwOSVersion);
    CheckTime(ftStart, StatPropSetStg.mtime);
    CheckTime(ftStart, StatPropSetStg.ctime);
    CheckTime(ftStart, StatPropSetStg.atime);
}

//
//   
//   Stat (Create four combinations)
//       Check ansi/wide fflag
//     Also test clsid on propset

void test_IPropertyStorage_Stat(IStorage *pStorage)
{
    printf( "   IPropertyStorage::Stat\n" );

    DWORD dwOSVersion = 0;

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;
    UuidCreate(&fmtid);
    IPropertyStorage *pPropSet;
    STATPROPSETSTG StatPropSetStg;

    // Calculate the OS Version

#ifdef _MAC_
#error Do not know how to calculate the OS Version for the macintosh.
#endif

    dwOSVersion = MAKELONG( 0x0100, OSKIND_REF );

    for (ULONG i=0; i<4; i++)
    {
        FILETIME ftStart;
        DfGetTOD(&ftStart);

        memset(&StatPropSetStg, 0, sizeof(StatPropSetStg));
        CLSID clsid;
        UuidCreate(&clsid);
        Check(S_OK, pPropSetStg->Create(fmtid, &clsid,
            ((i & 2) ? PROPSETFLAG_ANSI : 0),
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));

        CheckStat(pPropSet, fmtid, clsid, 
                  ((i & 2) ? PROPSETFLAG_ANSI : 0), ftStart, dwOSVersion );
        pPropSet->Release();

        Check(S_OK, pPropSetStg->Open(fmtid, 
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));
        CheckStat(pPropSet, fmtid, clsid, 
                  ((i & 2) ? PROPSETFLAG_ANSI : 0), ftStart, dwOSVersion );

        pPropSet->Release();

        Check(S_OK, pPropSetStg->Open(fmtid, 
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));
        CheckStat(pPropSet, fmtid, clsid, 
            ((i & 2) ? PROPSETFLAG_ANSI : 0), ftStart, dwOSVersion );
        pPropSet->Release();
    }
}

//
// test using IStorage::Commit to commit the changes in a nested
// property set
//

void
test_IPropertyStorage_Commit(IStorage *pStorage)
{
    printf( "   IPropertyStorage::Commit\n" );

    // create another level of storage

    SCODE sc;

    // 8 scenarios: simple  * direct * (release only + commit storage + commit
    // propset)
    // note: some scenarios might repeat since there is no
    // non-simple/transacted cases
    for (int i=0; i<32; i++)
    {
        CTempStorage pDeeper(Create, pStorage, GetNextTest(), 
            STGM_DIRECT);
        TSafeStorage< IPropertySetStorage > pPropSetStg(pDeeper);
    
        FMTID fmtid;
        UuidCreate(&fmtid);
    
        IPropertyStorage *pPropSet;
        if (S_OK != (sc = pPropSetStg->Create(
            fmtid, NULL, 
            PROPSETFLAG_DEFAULT,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE | 
            STGM_DIRECT,
             &pPropSet)))
        {
            Check(S_OK, sc);
        }
              
        PROPSPEC ps;
        ps.ulKind = PRSPEC_PROPID;
        ps.propid = 100;
        PROPVARIANT pv;
        pv.vt = VT_I4;
        pv.lVal = 1234;
    
        Check(S_OK, pPropSet->WriteMultiple(1, &ps, &pv, 1000));
    
        PropVariantClear(&pv);
        Check(S_OK, pPropSet->ReadMultiple(1, &ps, &pv));
        ASSERT(pv.vt==VT_I4);
        ASSERT(pv.lVal == 1234);

        pv.lVal = 2345; // no size changes
        Check(S_OK, pPropSet->WriteMultiple(1, &ps, &pv, 1000));

        if (i & 4)
            Check(S_OK, pPropSet->Commit(0));
        if (i & 2)
            Check(S_OK, pStorage->Commit(0));

        Check(0, pPropSet->Release()); // implicit commit if i&2 is false

        if (S_OK == pPropSetStg->Open(fmtid, STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                    &pPropSet))
        {
            PropVariantClear(&pv);
            Check( S_OK, pPropSet->ReadMultiple(1, &ps, &pv));
            ASSERT(pv.vt == VT_I4);
            ASSERT(pv.lVal == 2345);
            pPropSet->Release();
        }
    }
}

void
test_IPropertyStorage_WriteMultiple(IStorage *pStorage)
{
    test_IPropertyStorage_Commit(pStorage);
}

// this serves as a test for WritePropertyNames, ReadPropertyNames, DeletePropertyNames
// DeleteMultiple, PropVariantCopy, FreePropVariantArray.

void
test_IPropertyStorage_DeleteMultiple(IStorage *pStorage)
{
    printf( "   IPropertyStorage::DeleteMultiple\n" );

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);

    FMTID fmtid;
    UuidCreate(&fmtid);

    IPropertyStorage *pPropSet;

    int PropId = 3;

    UuidCreate(&fmtid);
    Check(S_OK, pPropSetStg->Create(
        fmtid,
        NULL, PROPSETFLAG_DEFAULT,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
        &pPropSet));
    
    // create and delete each type.
    
    PROPVARIANT *pVar;
        
    for (int AtOnce=1; AtOnce <3; AtOnce++)
    {
        CGenProps gp;
        int Actual;
        while (pVar = gp.GetNext(AtOnce, &Actual, FALSE, TRUE))
        {
            PROPSPEC ps[3];
            PROPID   rgpropid[3];
            LPOLESTR rglpostrName[3];
            OLECHAR    aosz[3][16];
            char pchTemp [16];

            for (int s=0; s<3; s++)
            {                
                sprintf(pchTemp, "prop%d", PropId );
                STOT(pchTemp, aosz[s], strlen(pchTemp)+1);
                rgpropid[s] = PropId++;
                rglpostrName[s] = &aosz[s][0];
                ps[s].ulKind = PRSPEC_LPWSTR;
                ps[s].lpwstr = &aosz[s][0];
            }

            for (int l=1; l<Actual; l++)
            {                
                PROPVARIANT VarRead[3];
                Check(S_FALSE, pPropSet->ReadMultiple(l, ps, VarRead));
                Check(S_OK, pPropSet->
                      WritePropertyNames(l, rgpropid, rglpostrName));
                Check(S_FALSE, pPropSet->ReadMultiple(l, ps, VarRead));
                
                Check(S_OK, pPropSet->WriteMultiple(l, ps, pVar, 1000));
                Check(S_OK, pPropSet->ReadMultiple(l, ps, VarRead));
                Check(S_OK, FreePropVariantArray(l, VarRead));
                Check(S_OK, pPropSet->DeleteMultiple(l, ps));
                Check(S_FALSE, pPropSet->ReadMultiple(l, ps, VarRead));
                Check(S_OK, FreePropVariantArray(l, VarRead));

                LPOLESTR rglpostrNameCheck[3];
                Check(S_OK, pPropSet->
                      ReadPropertyNames(l, rgpropid, rglpostrNameCheck));

                for (int c=0; c<l; c++)
                {
                    ASSERT(ocscmp(rglpostrNameCheck[c], rglpostrName[c])==0);
                    CoTaskMemFree(rglpostrNameCheck[c]);
                }
                Check(S_OK, pPropSet->DeletePropertyNames(l, rgpropid));
                Check(S_FALSE, pPropSet->ReadPropertyNames(l, rgpropid, 
                                                           rglpostrNameCheck));
            }
            
            FreePropVariantArray(Actual, pVar);
            delete pVar;
        }
    }
    pPropSet->Release();
}

void
test_IPropertyStorage(IStorage *pStorage)
{
    test_IPropertyStorage_Access(pStorage);
    test_IPropertyStorage_Create(pStorage);
    test_IPropertyStorage_Stat(pStorage);
    test_IPropertyStorage_WriteMultiple(pStorage);
    test_IPropertyStorage_DeleteMultiple(pStorage);
}



//
//   Word6.0 summary information
//      Open
//      Read fields
//      Stat
//

#define W6TEST "w6test.doc"

void test_Word6(IStorage *pStorage)
{
    printf( "   Word 6.0 compatibility test\n" );

    extern unsigned char g_achTestDoc[];
    extern unsigned g_cbTestDoc;
    OLECHAR ocsTempFile[MAX_PATH+1];

    FILE *f = fopen(W6TEST, "w+b");
    int nWritten = fwrite(g_achTestDoc, 1, g_cbTestDoc, f);
    ASSERT(nWritten == (int)g_cbTestDoc);
    fclose(f);

    STOT(W6TEST, ocsTempFile, strlen(W6TEST)+1);
    IStorage *pStg;
    Check(S_OK, StgOpenStorage(ocsTempFile, 
                               (IStorage*)NULL,
                               (DWORD) STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                               0, 
                               0, 
                               &pStg));

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStg);
    IPropertyStorage *pPropStg;

    Check(S_OK, pPropSetStg->Open(FMTID_SummaryInformation,
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READ,
                    &pPropStg));

#define WORDPROPS 18

    static struct tagWordTest {
        VARENUM vt;
        void *pv;
    } avt[WORDPROPS] = {
        VT_LPSTR, "Title of the document.",    // PID_TITLE                                 
        VT_LPSTR, "Subject of the document.",  // PID_SUBJECT                               
        VT_LPSTR, "Author of the document.",   // PID_AUTHOR                                
        VT_LPSTR, "Keywords of the document.", // PID_KEYWORDS                              
        VT_LPSTR, "Comments of the document.", // PID_COMMENTS                              
        VT_LPSTR, "Normal.dot",                // PID_TEMPLATE -- Normal.dot                
        VT_LPSTR, "Bill Morel",                // PID_LASTAUTHOR --                         
        VT_LPSTR, "3",                         // PID_REVNUMBER -- '3'                      
        VT_EMPTY, 0,                           // PID_EDITTIME -- 3 Minutes FILETIME        
        VT_EMPTY, 0,                           // PID_LASTPRINTED -- 04/07/95 12:04 FILETIME
        VT_EMPTY, 0,                           // PID_CREATE_DTM                            
        VT_EMPTY, 0,                           // PID_LASTSAVE_DTM                          
        VT_I4, (void*) 1,                      // PID_PAGECOUNT                             
        VT_I4, (void*) 7,                      // PID_WORDCOUNT                             
        VT_I4, (void*) 65,                     // PID_CHARCOUNT                             
        VT_EMPTY, 0,                           // PID_THUMBNAIL
        VT_LPSTR, "Microsoft Word 6.0",        // PID_APPNAME
        VT_I4, 0  };                           // PID_SECURITY

    PROPSPEC propspec[WORDPROPS+2];
    int i;
    for (i=2; i<WORDPROPS+2; i++)
    {
        propspec[i].ulKind = PRSPEC_PROPID;
        propspec[i].propid = (PROPID)i;
    }

    PROPVARIANT propvar[WORDPROPS+2];

    Check(S_OK, pPropStg->ReadMultiple(WORDPROPS, propspec+2, propvar+2));

    for (i=2; i<WORDPROPS+2; i++)
    {
        if ( propvar[i].vt != avt[i-2].vt )
        {
            printf( " PROPTEST: 0x%x retrieved type 0x%x, expected type 0x%x\n",
                    i, propvar[i].vt, avt[i-2].vt );
            ASSERT(propvar[i].vt == avt[i-2].vt);
        }

        switch (propvar[i].vt)
        {
        case VT_LPSTR:
            ASSERT(strcmp(propvar[i].pszVal, (char*)avt[i-2].pv)==0);
            break;
        case VT_I4:
            ASSERT(propvar[i].lVal == (int)avt[i-2].pv);
            break;
        }
    }
    FreePropVariantArray( WORDPROPS, propvar+2 );    
    pPropStg->Release();
    pStg->Release();

    //_unlink("w6test");
}

BOOL
IsEqualSTATPROPSTG(const STATPROPSTG *p1, const STATPROPSTG *p2)
{
    BOOL f1 = p1->propid == p2->propid;
    BOOL f2 = p1->vt == p2->vt;
    BOOL f3 = (p1->lpwstrName == NULL && p2->lpwstrName == NULL) ||
              ((p1->lpwstrName != NULL && p2->lpwstrName != NULL) &&
               ocscmp(p1->lpwstrName, p2->lpwstrName) == 0);
    return(f1 && f2 && f3);
}

void
test_IEnumSTATPROPSTG(IStorage *pstgTemp)
{
    printf( "   IEnumSTATPROPSTG\n" );

    PROPID apropid[8];
    LPOLESTR alpostrName[8];
    OLECHAR aosz[8][32];
    PROPID PropId=2;
    PROPSPEC ps[8];
    char pchTemp[32];

    FMTID fmtid;
    IPropertyStorage *pPropStg;

    TSafeStorage< IPropertySetStorage > pPropSetStg(pstgTemp);

    UuidCreate(&fmtid);

    for (int setup=0; setup<8; setup++)
    {
        alpostrName[setup] = &aosz[setup][0];
    }


    CGenProps gp;

    // simple/simple, ansi/wide, named/not named
    for (int outer=0; outer<8; outer++)
    {
        Check(S_OK, pPropSetStg->Create(fmtid, NULL,
            ((outer&2) ? PROPSETFLAG_ANSI : 0),
            STGM_CREATE | STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropStg));


        for (int i=0; i<CPROPERTIES; i++)
        {
            apropid[i] = PropId++;
            if (outer & 1)
            {
                ps[i].ulKind = PRSPEC_LPWSTR;
                sprintf(pchTemp, "prop%d\0", apropid[i]);
                STOT(pchTemp, aosz[i], strlen(pchTemp)+1);
                ps[i].lpwstr = aosz[i];
            }
            else
            {
                ps[i].ulKind = PRSPEC_PROPID;
                ps[i].propid = apropid[i];
            }
        }

        if (outer & 1)
        {
            Check(S_OK, pPropStg->WritePropertyNames(CPROPERTIES, apropid, alpostrName));
        }
        
        PROPVARIANT *pVar = gp.GetNext(CPROPERTIES, NULL, TRUE, TRUE); 
        ASSERT(pVar != NULL);

        Check(S_OK, pPropStg->WriteMultiple(CPROPERTIES, ps, pVar, 1000));
        FreePropVariantArray(CPROPERTIES, pVar);
        delete pVar;

        // Allocate enough STATPROPSTGs for one more than the actual properties
        // in the set.

        STATPROPSTG StatBuffer[CPROPERTIES+1];
        ULONG celt;
        IEnumSTATPROPSTG *penum, *penum2;
    
        Check(S_OK, pPropStg->Enum(&penum));
    
        IUnknown *punk, *punk2;
        IEnumSTATPROPSTG *penum3;
        Check(S_OK, penum->QueryInterface(IID_IUnknown, (void**)&punk));
        Check(S_OK, punk->QueryInterface(IID_IEnumSTATPROPSTG, (void**)&penum3));
        Check(S_OK, penum->QueryInterface(IID_IEnumSTATPROPSTG, (void**)&punk2));
        ASSERT(punk == punk2);
        punk->Release();
        penum3->Release();
        punk2->Release();
    
        // test S_FALSE
        Check(S_FALSE, penum->Next( CPROPERTIES+1, StatBuffer, &celt));
        ASSERT(celt == CPROPERTIES);

        CleanStat(celt, StatBuffer);

        penum->Reset();
    
    
        // test reading half out, then cloning, then comparing
        // rest of enumeration with other clone.

        Check(S_OK, penum->Next(CPROPERTIES/2, StatBuffer, &celt));
        ASSERT(celt == CPROPERTIES/2);
        CleanStat(celt, StatBuffer);
        celt = 0;
        Check(S_OK, penum->Clone(&penum2));
        Check(S_OK, penum->Next(CPROPERTIES - CPROPERTIES/2, StatBuffer, &celt));
        ASSERT(celt == CPROPERTIES - CPROPERTIES/2);
        // check the clone
        for (int c=0; c<CPROPERTIES - CPROPERTIES/2; c++)
        {
            STATPROPSTG CloneStat;
            Check(S_OK, penum2->Next(1, &CloneStat, NULL));
            ASSERT(IsEqualSTATPROPSTG(&CloneStat, StatBuffer+c));
            CleanStat(1, &CloneStat);
        }
    
        CleanStat(celt, StatBuffer);

        // check both empty
        celt = 0;
        Check(S_FALSE, penum->Next(1, StatBuffer, &celt));
        ASSERT(celt == 0);
    
        Check(S_FALSE, penum2->Next(1, StatBuffer, &celt));
        ASSERT(celt == 0);
    
        penum->Reset();
    
        //
        // loop deleting one property at a time
        // enumerate the propertys checking that correct ones appear.
        //
        for (ULONG d = 0; d<CPROPERTIES; d++)
        {
            // d is for delete
    
            BOOL afFound[CPROPERTIES];
            ULONG cTotal = 0;

            Check(S_OK, penum->Next(CPROPERTIES-d, StatBuffer, &celt));
            ASSERT(celt == CPROPERTIES-d);
            penum->Reset();
        
            memset(afFound, 0, sizeof(afFound));

            for (ULONG iProperty=0; iProperty<CPROPERTIES; iProperty++)
            {

                // Search the StatBuffer for this property.

                for (ULONG iSearch=0; iSearch<CPROPERTIES-d; iSearch++)
                {

                    // Compare this entry in the StatBuffer to the property for which we're searching.
                    // Use the lpstrName or propid, whichever is appropriate for this pass (indicated
                    // by 'outer').

                    if ( ( (outer & 1) == 1 && 0 == ocscmp(StatBuffer[iSearch].lpwstrName, ps[iProperty].lpwstr) )
                         ||
                         ( (outer & 1) == 0 && StatBuffer[iSearch].propid == apropid[iProperty] )
                       )
                    {
                        ASSERT (!afFound[iSearch]);
                        afFound[iSearch] = TRUE;
                        cTotal++;
                        break;
                    }
                }
            }

            CleanStat(celt, StatBuffer);

            ASSERT(cTotal == CPROPERTIES-d);

            Check(S_OK, pPropStg->DeleteMultiple(1, ps+d));
            Check(S_OK, penum->Reset());
        }
    
        penum->Release();
        penum2->Release();

        pPropStg->Release();

    }
}

void
test_MaxPropertyName(IStorage *pstgTemp)
{

    printf( "   Max Property Name length\n" );

    //  ----------
    //  Initialize
    //  ----------

    CPropVariant cpropvar;

    // Create a new storage, because we're going to create
    // well-known property sets, and this way we can be sure
    // that they don't already exist.

    TSafeStorage< IStorage > pstg;
    DECLARE_OLESTR(ocsMaxProp, "MaxPropNameTest");
    Check(S_OK, pstgTemp->CreateStorage( ocsMaxProp,
                                         STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                         0L, 0L,
                                         &pstg ));

    // Generate a new Format ID.

    FMTID fmtid;
    UuidCreate(&fmtid);

    // Get a IPropertySetStorage from the IStorage.

    TSafeStorage< IPropertySetStorage > pPropSetStg(pstg);
    TSafeStorage< IPropertyStorage > pPropStg;

    //  ----------------------------------
    //  Test the non-SumInfo property set.
    //  ----------------------------------

    // Create a new PropertyStorage.

    Check(S_OK, pPropSetStg->Create(fmtid,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg));

    // Generate a property name which is max+1 characters.
    OLECHAR *poszPropertyName;
    poszPropertyName = (OLECHAR*) 
        CoTaskMemAlloc( (CCH_MAXPROPNAMESZ+1) * sizeof(OLECHAR) );
    Check(TRUE, poszPropertyName != NULL );

    for( ULONG ulIndex = 0; ulIndex < CCH_MAXPROPNAMESZ; ulIndex++ )
        poszPropertyName[ ulIndex ] = (OLECHAR)'a' + (OLECHAR) ( ulIndex % 26 );
    poszPropertyName[ CCH_MAXPROPNAMESZ ] = (OLECHAR)0;  // terminating null


    // Write out a property with this max+1 name.

    PROPSPEC propspec;

    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = poszPropertyName;

    cpropvar = (long) 0x1234;

    Check(STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    // Write out a property with a max-character name (we create a max-
    // char name by terminating the previously-used string one character
    // earlier).

    poszPropertyName[ CWC_MAXPROPNAME ] = 0;
    Check(S_OK, pPropStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    // Write out a property with a minimum-character name.
    DECLARE_OLESTR(ocsX, "X");
    propspec.lpwstr = ocsX;
    Check(S_OK, pPropStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    // Write out a property with a below-minimum-character name.
    DECLARE_OLESTR(ocsEmpty, ""); 
    propspec.lpwstr = ocsEmpty;
    Check(STG_E_INVALIDPARAMETER, 
          pPropStg->WriteMultiple( 1, &propspec,
                                   cpropvar,
                                   PID_FIRST_USABLE));
    CoTaskMemFree( poszPropertyName );
}

#define CODEPAGE_TEST_NAMED_PROPERTY     "Named Property"
#define CODEPAGE_TEST_UNNAMED_BSTR_PROPID   3
#define CODEPAGE_TEST_UNNAMED_I4_PROPID     4
#define CODEPAGE_TEST_VBSTR_PROPID          7
#define CODEPAGE_TEST_VPROPVAR_BSTR_PROPID  9

void
CreateCodePageTestFile( LPOLESTR poszFileName, 
                        IStorage **ppStg,
                        BOOL fUseUnicode)
{
    ASSERT( poszFileName != NULL );

    //  --------------
    //  Initialization
    //  --------------

    TSafeStorage< IPropertySetStorage > pPSStg;
    TSafeStorage< IPropertyStorage > pPStg;

    PROPSPEC propspec;
    CPropVariant cpropvar;

    *ppStg = NULL;

    OLECHAR poszActualFile[MAX_PATH];
    ocscpy(poszActualFile, poszFileName);

    // assume the path name has enough space, change the last character
    // of the filename
    int len = ocslen(poszActualFile);
    if (!fUseUnicode) 
    {
        
        poszActualFile[len]='a';
        poszActualFile[len+1]=0;
    }
    else
    {
        poszActualFile[len]='w';
        poszActualFile[len+1]=0;
    }

    Check(S_OK, StgCreateDocfile( poszActualFile,
                                  STGM_CREATE | STGM_READWRITE |
                                  STGM_SHARE_EXCLUSIVE,  
                                  0,
                                  ppStg ));

    // Get an IPropertySetStorage

    Check(S_OK, (*ppStg)->QueryInterface( IID_IPropertySetStorage, (void**)&pPSStg ));

    // Create an IPropertyStorage (ANSI or UNICODE)  
    DWORD psFlag= (fUseUnicode) ? 0 : PROPSETFLAG_ANSI ;

    Check(S_OK, pPSStg->Create( FMTID_NULL,
                                NULL,
                                psFlag,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                &pPStg ));

    //  ----------------------
    //  Write a named property
     //  ----------------------

    // Write a named I4 property

    propspec.ulKind = PRSPEC_LPWSTR;
    DECLARE_OLESTR(ocsNamed,  CODEPAGE_TEST_NAMED_PROPERTY);
    propspec.lpwstr = ocsNamed;

    cpropvar = (LONG) 0x12345678;
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    //  --------------------------
    //  Write singleton properties
    //  --------------------------

    // Write an un-named BSTR.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_BSTR_PROPID;
    DECLARE_OLESTR(ocsBSTR, "BSTR Property");
    cpropvar.SetBSTR( ocsBSTR );
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    // Write an un-named I4

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_I4_PROPID;

    cpropvar = (LONG) 0x76543210;
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    //  -----------------------
    //  Write vector properties
    //  -----------------------

    // Write a vector of BSTRs.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VBSTR_PROPID;
    DECLARE_OLESTR(ocsElt0, "BSTR Element 0");
    DECLARE_OLESTR(ocsElt1, "BSTR Element 1");
    
    cpropvar.SetBSTR( ocsElt1, 1 );
    cpropvar.SetBSTR( ocsElt0, 0 );
    ASSERT( (VT_VECTOR | VT_BSTR) == cpropvar.VarType() );
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    //  -------------------------------
    //  Write Variant Vector Properties
    //  -------------------------------

    // Write a variant vector that has a BSTR

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VPROPVAR_BSTR_PROPID;

    CPropVariant cpropvarT;
    DECLARE_OLESTR(ocsPropVect, "PropVar Vector BSTR");
    cpropvarT.SetBSTR( ocsPropVect );
    cpropvar[1] = (LPPROPVARIANT) cpropvarT;
    cpropvar[0] = (LPPROPVARIANT) CPropVariant((long) 44);
    ASSERT( (VT_VARIANT | VT_VECTOR) == cpropvar.VarType() );
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

}   // CreateCodePageTestFile()


void
OpenCodePageTestFile( LPOLESTR poszFileName, 
                      IStorage **ppStg,
                      BOOL fUseUnicode)
{
    OLECHAR poszActualFile[MAX_PATH];
    ocscpy(poszActualFile, poszFileName);

    // assume the path name has enough space, change the last character
    // of the filename
    int len = ocslen(poszActualFile);
    if (!fUseUnicode) 
    {
        poszActualFile[len]='a';
        poszActualFile[len+1]=0;
    }
    else
    {
        poszActualFile[len]='w';
        poszActualFile[len+1]=0;
    }    

    Check(S_OK, StgOpenStorage( poszActualFile,
                                (IStorage*) NULL,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,  
                                (SNB) 0,
                                (DWORD) 0,
                                ppStg ));
}

void
ModifyPropSetCodePage( IStorage *pStg, ULONG ulCodePage )
{

    ASSERT( pStg != NULL );

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR aocPropSetName[ 32 ];
    DWORD dwOffset = 0;
    DWORD dwcbSection = 0;
    DWORD dwcProperties = 0;
    ULONG ulcbWritten = 0;

    LARGE_INTEGER   liSectionOffset, liCodePageOffset;

    TSafeStorage< IStream > pStm;

    CPropVariant cpropvar;

    // Open the Stream

    RtlGuidToPropertySetName( &FMTID_NULL, aocPropSetName );
    Check(S_OK, pStg->OpenStream( aocPropSetName,
                                  (VOID*)NULL,
                                  STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                                  (DWORD)NULL,
                                  &pStm ));

    // Seek past the propset header and the format ID.

    liSectionOffset.HighPart = 0;
    liSectionOffset.LowPart = sizeof(PROPERTYSETHEADER) + sizeof(FMTID);
    Check(S_OK, pStm->Seek(liSectionOffset, STREAM_SEEK_SET, NULL ));

    // Move to the beginning of the property set.

    liSectionOffset.HighPart = 0;
    Check(S_OK, pStm->Read( &liSectionOffset.LowPart, sizeof(DWORD), NULL ));
    PropByteSwap(&liSectionOffset.LowPart);

    Check(S_OK, pStm->Seek( liSectionOffset, STREAM_SEEK_SET, NULL ));

    // Get the section size & property count.

    Check(S_OK, pStm->Read( &dwcbSection, sizeof(DWORD), NULL ));
    PropByteSwap( &dwcbSection );

    Check(S_OK, pStm->Read( &dwcProperties, sizeof(DWORD), NULL ));
    PropByteSwap( &dwcProperties );

    // Scan for the PID_CODEPAGE property.
    ULONG ulIndex; 
    for(ulIndex = 0; ulIndex < dwcProperties; ulIndex++ )
    {
        PROPID propid;
        DWORD dwOffset;

        // Read in the PROPID
        Check(S_OK, pStm->Read( &propid, sizeof(PROPID), NULL ));

        // Is it the codepage?
        if( PropByteSwap(propid) == PID_CODEPAGE )
            break;

        // Read in this PROPIDs offset (we don't need it, but we want
        // to seek past it.
        Check(S_OK, pStm->Read( &dwOffset, sizeof(dwOffset), NULL ));
    }

    // Verify that the above for loop terminated because we found
    // the codepage.
    Check( TRUE, ulIndex < dwcProperties );

    // Move to the code page.

    liCodePageOffset.HighPart = 0;
    Check(S_OK, pStm->Read( &liCodePageOffset.LowPart, sizeof(DWORD), NULL ));
    PropByteSwap( &liCodePageOffset.LowPart );

    liCodePageOffset.LowPart += liSectionOffset.LowPart + sizeof(ULONG); // Move past VT too.
    ASSERT( liSectionOffset.HighPart == 0 );

    Check(S_OK, pStm->Seek( liCodePageOffset, STREAM_SEEK_SET, NULL ));

    // this is so that you can manually verify what was read
    // i.e. that it is the code page
    WORD wCodePage;                                          
    Check(S_OK, pStm->Read( &wCodePage, sizeof(WORD), NULL));
    Check(S_OK, pStm->Seek( liCodePageOffset, STREAM_SEEK_SET, NULL )); 
    
    // Write the new code page.
    wCodePage = PropByteSwap( (WORD) ((ulCodePage << 16) >> 16) );
    Check(S_OK, pStm->Write( &wCodePage, sizeof(wCodePage), &ulcbWritten ));
    Check(TRUE, ulcbWritten == sizeof(wCodePage) );

    //pStm->Commit(0);   
}   // ModifyPropSetCodePage()

void
ModifyOSVersion( IStorage* pStg, DWORD dwOSVersion )
{

    ASSERT( pStg != NULL );

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR aocPropSetName[ 32 ];
    ULONG ulcbWritten = 0;

    LARGE_INTEGER   liOffset;
    PROPERTYSETHEADER propsetheader;
    TSafeStorage< IStream > pStm;

    // Open the Stream

    RtlGuidToPropertySetName( &FMTID_NULL, aocPropSetName );
    Check(S_OK, pStg->OpenStream( aocPropSetName,
                                  (VOID*)NULL,
                                  STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                                  (DWORD)NULL,
                                  &pStm ));


    // Seek to the OS Version field in the header.

    liOffset.HighPart = 0;
    propsetheader;  // avoid compiler warning of unref'd var.
    liOffset.LowPart = sizeof(propsetheader.wByteOrder) + sizeof(propsetheader.wFormat);
    Check(S_OK, pStm->Seek( liOffset, STREAM_SEEK_SET, NULL ));

    // Set the new OS Version
    PropByteSwap( &dwOSVersion );
    Check(S_OK, pStm->Write( &dwOSVersion, sizeof(dwOSVersion), &ulcbWritten ));
    Check(TRUE, ulcbWritten == sizeof(dwOSVersion) );

}   // ModifyOSVersion()


#define CODEPAGE_DEFAULT    0x04e4  // US English
#define CODEPAGE_GOOD       0x0000  // Present on a US English machine
#define CODEPAGE_BAD        0x9999  // Non-existent code page

void
test_CodePages( LPOLESTR poszDirectory, 
                ULONG ulTestOptions, 
                BOOL fTestUnicode)
{

    printf( "   Code Page compatibility -- " );

    if (ulTestOptions & TEST_INTEROP_R)
        printf("Verify Read, ");
    else 
        printf("Write & Read, ");
    if (fTestUnicode)
        printf("UNICODE files\n");
    else
        printf("ASCII files\n");

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR oszBadFile[ MAX_PATH ];
    OLECHAR oszGoodFile[ MAX_PATH ];
    OLECHAR oszUnicodeFile[ MAX_PATH ];
    OLECHAR oszMacFile[ MAX_PATH ];
    HRESULT hr = S_OK;

    TSafeStorage< IStorage > pStgBad, pStgGood, pStgUnicode, pStgMac;
    CPropVariant cpropvarWrite, cpropvarRead;

    Check( TRUE, GetACP() == CODEPAGE_DEFAULT );
    
    //  ------------------------------
    //  Create test property sets
    //  ------------------------------

    // Create a property set with a bad codepage.
#ifdef _WIN32
    DECLARE_OLESTR(ocsBad, "\\badcp.sg");
    ocscpy( oszBadFile, poszDirectory );    
    ocscat( oszBadFile, ocsBad );
#else
    DECLARE_OLESTR(ocsBad, "badcp.sg");
    ocscpy( oszBadFile, ocsBad );
#endif
    if (! (ulTestOptions & TEST_INTEROP_R))
    {
        CreateCodePageTestFile( oszBadFile, &pStgBad, fTestUnicode );
        if (!fTestUnicode)
        {                       
            // modification of code page is only
            // interesting for ansi property sets,
            // otherwise it will result in in error
            ModifyPropSetCodePage( pStgBad, CODEPAGE_BAD );
        }
    }
    else 
        OpenCodePageTestFile( oszBadFile, &pStgBad, fTestUnicode );

    // Create a property set with a good codepage.

#ifdef _WIN32
    ocscpy( oszGoodFile, poszDirectory );
    DECLARE_OLESTR(ocsGood, "\\goodcp.sg");
    ocscat( oszGoodFile, ocsGood );
#else
    DECLARE_OLESTR(ocsGood, "goodcp.sg");
    ocscpy( oszGoodFile, ocsGood );
#endif

    if (! (ulTestOptions & TEST_INTEROP_R))
    {
        CreateCodePageTestFile( oszGoodFile, &pStgGood, fTestUnicode );
        // We can only modify code page of ansi property sets; Modfiying 
        // code page of UNICODE pages will result in a INVALID_HEADER
        // 'cos it will treat strings as wide chars instead of single-byte
        if (!fTestUnicode)
        {
            ModifyPropSetCodePage( pStgGood, CODEPAGE_GOOD );
        }
    }
    else 
        OpenCodePageTestFile( oszGoodFile, &pStgGood, fTestUnicode );

    // Create a property set that has the OS Kind (in the
    // header) set to "Mac".

#ifdef _WIN32
    DECLARE_OLESTR(ocsMac, "\\mackind.sg");
    ocscpy( oszMacFile, poszDirectory );
    ocscat( oszMacFile, ocsMac );
#else
    DECLARE_OLESTR(ocsMac, "mackind.sg");
    ocscpy( oszMacFile, ocsMac );
#endif
    
    if (! (ulTestOptions & TEST_INTEROP_R))
    {
        CreateCodePageTestFile( oszMacFile, &pStgMac, fTestUnicode );        
        ModifyOSVersion( pStgMac, 0x00010904 );
    }
    else
        OpenCodePageTestFile( oszMacFile, &pStgMac, fTestUnicode );

    //  ---------------------------
    //  Open the Ansi property sets
    //  ---------------------------

    TSafeStorage< IPropertySetStorage > pPropSetStgBad(pStgBad);
    TSafeStorage< IPropertySetStorage > pPropSetStgGood(pStgGood);
    TSafeStorage< IPropertySetStorage > pPropSetStgMac(pStgMac);

    TSafeStorage< IPropertyStorage > pPropStgBad, pPropStgGood, pPropStgMac;

    Check(S_OK, pPropSetStgBad->Open(FMTID_NULL,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStgBad));

    Check(S_OK, pPropSetStgGood->Open(FMTID_NULL,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStgGood));

    Check(S_OK, pPropSetStgMac->Open(FMTID_NULL,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStgMac));
    
    PROPSPEC propspec;
    PROPVARIANT propvar;
    PropVariantInit( &propvar );

    // ASSUMPTION: all three files are created all together by
    //    proptest, they will all be ansi or they will all be
    //    unicode.
    //
    // For UNICODE APIs, when the code page is not Unicode, it will
    // try and translate it to unicode and thus result in an error

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = 1;        // propid for code page indicator
    Check(S_OK, pPropStgGood->ReadMultiple( 1, &propspec, &propvar));

    HRESULT pStgBadHr = S_OK;   // default
    if (propvar.iVal == (SHORT) CODEPAGE_GOOD) 
    {                           // files created in Ansi
#ifdef _UNICODE
        pStgBadHr = HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
#endif
    }

    // Since we are doing interoperability testing and pStgBad with
    // a wrong codepage number will result in a invalid_header error,
    // we change it back to normal to get rid of the error.
    //
    // Also, we only change it when the current code page is bad,
    // otherwise, we leave it as it is.
    //
    // We know that the correct number to put in is 1252 'cos we only
    // change the code page for ansi property sets.
    if (propvar.iVal == (SHORT) CODEPAGE_BAD)
        ModifyPropSetCodePage( pStgBad, 1252 );  

    //  ------------------------------------------
    //  Test BSTRs in the three property sets
    //  ------------------------------------------
    // Attempt to read by name.

    propspec.ulKind = PRSPEC_LPWSTR;
    DECLARE_OLESTR(ocsCP_test, CODEPAGE_TEST_NAMED_PROPERTY);
    propspec.lpwstr = ocsCP_test;

    CPropVariant cpropvar=(LONG) 0x12345678;

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));
    PropVariantClear( &propvar );

    Check(pStgBadHr, 
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));    
    PropVariantClear( &propvar );

    Check(S_OK, 
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));    
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));
    

    // Attempt to write by name.

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(pStgBadHr,
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    PropVariantClear( &propvar );

    // Attempt to read the BSTR property

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_BSTR_PROPID;

    DECLARE_OLESTR(ocsBSTR, "BSTR Property");
    cpropvar.SetBSTR( ocsBSTR );
    Check(S_OK, 
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));

    PropVariantClear( &propvar );
    Check(pStgBadHr, 
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
    PropVariantClear( &propvar );
    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));

    // Attempt to write the BSTR property

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(pStgBadHr,
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    PropVariantClear( &propvar );

    // Attempt to read the BSTR Vector property

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VBSTR_PROPID;
    DECLARE_OLESTR(ocsElt0, "BSTR Element 0");
    DECLARE_OLESTR(ocsElt1, "BSTR Element 1");    
    cpropvar.SetBSTR( ocsElt1, 1 );
    cpropvar.SetBSTR( ocsElt0, 0 );
    ASSERT( (VT_VECTOR | VT_BSTR) == cpropvar.VarType() );

    Check(S_OK, 
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));

    PropVariantClear( &propvar );
    Check(pStgBadHr, 
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
    
    PropVariantClear(&propvar);
    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));

    // Attempt to write the BSTR Vector property

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(pStgBadHr,
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    PropVariantClear( &propvar );
    
    // Attempt to read the Variant Vector which has a BSTR
    CPropVariant cpropvarT;
    DECLARE_OLESTR(ocsPropVect, "PropVar Vector BSTR");
    cpropvarT.SetBSTR( ocsPropVect );
    cpropvar[1] = (LPPROPVARIANT) cpropvarT;
    cpropvar[0] = (LPPROPVARIANT) CPropVariant((long) 44);
    ASSERT( (VT_VARIANT | VT_VECTOR) == cpropvar.VarType() );

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VPROPVAR_BSTR_PROPID;

    Check(S_OK, 
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));
    PropVariantClear( &propvar );
    Check(pStgBadHr, 
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
    
    PropVariantClear(&propvar);
    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));

    // Attempt to write the Variant Vector which has a BSTR

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(pStgBadHr,
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    PropVariantClear( &propvar );

    // Attempt to read the I4 property.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_I4_PROPID;
    Check(S_OK, 
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    cpropvar = (LONG) 0x76543210;
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));
    PropVariantClear( &propvar );

    hr = pPropStgBad->ReadMultiple( 1, &propspec, &propvar );
    Check(TRUE, S_OK == hr || pStgBadHr == hr );
    PropVariantClear( &propvar );

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));

    // Attempt to write the I4 property

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));

    hr = pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE );
    Check(TRUE, S_OK == hr || pStgBadHr == hr );

    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    PropVariantClear( &propvar );

    //  ---------------------------------------
    //  Test LPSTRs in the Unicode property set
    //  ---------------------------------------

    // This test doesn't verify that the LPSTRs are actually
    // written in Unicode.  A manual test is required for that.

    // Create a Unicode property set.  We'll make it
    // non-simple so that we can test a VT_STREAM (which
    // is stored like an LPSTR).
#ifdef _WIN32
    DECLARE_OLESTR(ocsUni, "\\UnicodCP.stg");
    ocscpy( oszUnicodeFile, poszDirectory );
    ocscat( oszUnicodeFile, ocsUni);
#else
    DECLARE_OLESTR(ocsUni, "UnicodCP.stg");
    ocscpy( oszUnicodeFile, ocsUni );
#endif

    Check(S_OK, StgCreateDocfile(oszUnicodeFile,
                                 STGM_CREATE | STGM_READWRITE |
                                 STGM_SHARE_EXCLUSIVE, 
                                 (DWORD)NULL,
                                 &pStgUnicode));

    TSafeStorage< IPropertySetStorage > pPropSetStgUnicode(pStgUnicode);
    TSafeStorage< IPropertyStorage > pPropStgUnicode;
    Check(S_OK, pPropSetStgUnicode->Create(FMTID_NULL,
                                           &CLSID_NULL,
                                           PROPSETFLAG_DEFAULT,
                                           STGM_CREATE | STGM_SHARE_EXCLUSIVE
                                           | STGM_READWRITE, 
                                           &pPropStgUnicode));


    // Write/verify an LPSTR property.

    propspec.ulKind = PRSPEC_LPWSTR;
    DECLARE_OLESTR(ocsLPSTR, "LPSTR Property");
    propspec.lpwstr = ocsLPSTR;

    cpropvarWrite = "An LPSTR Property";

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, cpropvarRead ));

    Check(0, strcmp( (LPSTR) cpropvarWrite, (LPSTR) cpropvarRead ));
    cpropvarRead.Clear();

    // Write/verify a vector of LPSTR properties
    DECLARE_OLESTR(ocsVectLPSTR, "Vector of LPSTR properties"); 
    propspec.lpwstr = ocsVectLPSTR;

    cpropvarWrite[1] = "LPSTR Property #1";
    cpropvarWrite[0] = "LPSTR Property #0";

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, cpropvarRead ));

    Check(0, strcmp( (LPSTR) cpropvarWrite[1], (LPSTR) cpropvarRead[1] ));
    Check(0, strcmp( (LPSTR) cpropvarWrite[0], (LPSTR) cpropvarRead[0] ));
    cpropvarRead.Clear();

    // Write/verify a vector of variants which has an LPSTR
    DECLARE_OLESTR(ocsVariantWithLPSTR, "Variant Vector with an LPSTR");
    propspec.lpwstr = ocsVariantWithLPSTR;

    cpropvarWrite[1] = (LPPROPVARIANT) CPropVariant("LPSTR in a Variant Vector");
    cpropvarWrite[0] = (LPPROPVARIANT) CPropVariant((long) 22); // an I4
    ASSERT( (VT_VECTOR | VT_VARIANT) == cpropvarWrite.VarType() );

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, cpropvarRead ));

    Check(0, strcmp( (LPSTR) cpropvarWrite[1], (LPSTR) cpropvarRead[1] ));
    cpropvarRead.Clear();

}

void
test_PropertyInterfaces(IStorage *pstgTemp)
{
    // this test depends on being first for enumerator
    test_IEnumSTATPROPSETSTG(pstgTemp);

    test_MaxPropertyName(pstgTemp);
    test_IPropertyStorage(pstgTemp);
    test_IPropertySetStorage(pstgTemp);
    test_IEnumSTATPROPSTG(pstgTemp);
}


//===================================================================
//
//  Function:   test_CopyTo
//
//  Synopsis:   Verify that IStorage::CopyTo copies an
//              un-flushed property set.
//
//              This test creates and writes to a simple property set,
//              a non-simple property set, and a new Storage & Stream,
//              all within the source (caller-provided) Storage.
//
//              It then copies the entire source Storage to the
//              destination Storage, and verifies that all commited
//              data in the Source is also in the destination.
//  
//              All new Storages and property sets are created
//              under a new base storage.  The caller can specify
//              if this base Storage is direct or transacted, and
//              can specify if the property sets are direct or
//              transacted.
//
//===================================================================

void test_CopyTo(IStorage *pstgSource,          // Source of the CopyTo
                 IStorage *pstgDestination,     // Destination of the CopyTo
                 ULONG ulBaseStgTransaction,    // Transaction bit for the base storage.
                 ULONG ulPropSetTransaction,    // Transaction bit for the property sets.
                 LPOLESTR oszBaseStorageName )
{
    printf( "   IStorage::CopyTo (Base Storage is %s, PropSets are %s)\n",
            ulBaseStgTransaction & STGM_TRANSACTED ? "transacted" : "directed",
            ulPropSetTransaction & STGM_TRANSACTED ? "transacted" : "directed" );


    //  ---------------
    //  Local Variables
    //  ---------------
    
    DECLARE_OLESTR(poszTestSubStorage     ,"TestStorage" );
    DECLARE_OLESTR(poszTestSubStream      ,"TestStream" );
    DECLARE_OLESTR(poszTestDataPreCommit  ,"Test Data (pre-commit)" );
    DECLARE_OLESTR(poszTestDataPostCommit ,"Test Data (post-commit)");
    
    long lSimplePreCommit = 0x0123;
    long lSimplePostCommit = 0x4567;

    long lNonSimplePreCommit  = 0x89AB;
    long lNonSimplePostCommit = 0xCDEF;

    BYTE acReadBuffer[ 80 ];
    ULONG cbRead;

    FMTID fmtidSimple, fmtidNonSimple;

    // Base Storages for the Source & Destination.  All
    // new Streams/Storages/PropSets will be created below here.

    TSafeStorage< IStorage > pstgBaseSource;
    TSafeStorage< IStorage > pstgBaseDestination;

    TSafeStorage< IStorage > pstgSub;   // A sub-storage of the base.
    TSafeStorage< IStream >  pstmSub;   // A Stream in the sub-storage (pstgSub)

    PROPSPEC propspec;
    PROPVARIANT propvarSourceSimple,
                propvarDestination;


    //  -----
    //  Begin
    //  -----

    // Create new format IDs

    UuidCreate(&fmtidSimple);
    UuidCreate(&fmtidNonSimple);

    //  -----------------------
    //  Create the base Storage
    //  -----------------------

    // Create a base Storage for the Source.  All of this test will be under
    // that Storage.

    // In the source Storage.

    Check( S_OK, pstgSource->CreateStorage(
                                oszBaseStorageName,
                                STGM_CREATE | ulBaseStgTransaction | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                0L, 0L,
                                &pstgBaseSource ));


    // And in the destination Storage.

    Check( S_OK, pstgDestination->CreateStorage(
                                oszBaseStorageName,
                                STGM_CREATE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                0L, 0L,
                                &pstgBaseDestination ));



    //  -------------------------------------------
    //  Write data to a new Stream in a new Storage
    //  -------------------------------------------

    // We'll partially verify the CopyTo by checking that this data
    // makes it into the destination Storage.


    // Create a Storage, and then a Stream within it.

    Check( S_OK, pstgBaseSource->CreateStorage(
                                poszTestSubStorage,
                                STGM_CREATE | ulPropSetTransaction | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                0L, 0L,
                                &pstgSub ));

    Check( S_OK, pstgSub->CreateStream(
                            poszTestSubStream,
                            STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            0L, 0L,
                            &pstmSub ));

    // Write data to the Stream.

    Check( S_OK, pstmSub->Write(
                    poszTestDataPreCommit,
                    ( sizeof(OLECHAR)
                      *
                      ( ocslen(poszTestDataPreCommit) + sizeof( OLECHAR ))
                    ),
                    NULL ));


    //  ---------------------------------------------------------
    //  Write to a new simple property set in the Source storage.
    //  ---------------------------------------------------------

    TSafeStorage< IPropertySetStorage > pPropSetStgSource(pstgBaseSource);
    TSafeStorage< IPropertyStorage >    pPropStgSource1,
                                        pPropStgSource2,
                                        pPropStgDestination;

    // Create a property set mode.

    Check(S_OK, pPropSetStgSource->Create(fmtidSimple,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropStgSource1));

    // Write the property set name (just to test this functionality).

    PROPID pidDictionary = 0;
    DECLARE_CONST_OLESTR(cposzPropSetName, "Property Set for CopyTo Test");
    ASSERT( CWC_MAXPROPNAMESZ >= ocslen(cposzPropSetName) + sizeof(OLECHAR) );
    
    Check(S_OK, pPropStgSource1->WritePropertyNames( 1, &pidDictionary,
                                                     &cposzPropSetName )); 

    // Create a PROPSPEC.  We'll use this throughout the rest of the routine.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = 1000;

    // Create a PROPVARIANT for this test of the Simple case.

    propvarSourceSimple.vt = VT_I4;
    propvarSourceSimple.lVal = lSimplePreCommit;

    // Write the PROPVARIANT to the property set.

    Check(S_OK, pPropStgSource1->WriteMultiple(1, &propspec, &propvarSourceSimple, 2));



    //  -------------------------
    //  Commit everything so far.
    //  -------------------------

    // Commit the sub-Storage.
    Check(S_OK, pstgSub->Commit( STGC_DEFAULT ));

    // Commit the simple property set.
    Check(S_OK, pPropStgSource1->Commit( STGC_DEFAULT ));

    // Commit the base Storage which holds all of the above.
    Check(S_OK, pstgBaseSource->Commit( STGC_DEFAULT ));


    //  -------------------------------------------------
    //  Write new data to everything but don't commit it.
    //  -------------------------------------------------

    // Write to the sub-storage.
    Check(S_OK, pstmSub->Seek(g_li0, STREAM_SEEK_SET, NULL));
    Check( S_OK, pstmSub->Write(
                    poszTestDataPostCommit,
                    ( sizeof(OLECHAR)
                      *
                      (ocslen( poszTestDataPostCommit ) + sizeof(OLECHAR))
                    ),
                    NULL ));

    // Write to the simple property set.
    propvarSourceSimple.lVal = lSimplePostCommit;
    Check(S_OK, pPropStgSource1->WriteMultiple(1, &propspec, &propvarSourceSimple, 2));

    //  -------------------------------------------
    //  Copy the source Storage to the destination.
    //  -------------------------------------------

    // Release the sub-Storage (which is below the base Storage, and has
    // a Stream with data in it), just to test that the CopyTo can
    // handle it.

    pstgSub->Release();
    pstgSub = NULL;

    Check(S_OK, pstgBaseSource->CopyTo( 0, NULL, NULL, pstgBaseDestination ));


    //  ----------------------------------------------------------
    //  Verify the simple property set in the destination Storage.
    //  ----------------------------------------------------------


    TSafeStorage< IPropertySetStorage > pPropSetStgDestination(pstgBaseDestination);

    // Open the simple property set.

    Check(S_OK, pPropSetStgDestination->Open(fmtidSimple,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropStgDestination));

    // Verify the property set name.

    OLECHAR *poszPropSetNameDestination;
    BOOL   bReadPropertyNamePassed = FALSE;

    Check(S_OK, pPropStgDestination->
          ReadPropertyNames( 1, &pidDictionary, &poszPropSetNameDestination ));
    if( poszPropSetNameDestination  // Did we get a name back?
        &&                          // If so, was it the correct name?
        !ocscmp( cposzPropSetName, poszPropSetNameDestination )
      )
    {
        bReadPropertyNamePassed = TRUE;
    }
    CoTaskMemFree( poszPropSetNameDestination );
    poszPropSetNameDestination = NULL;

    Check( TRUE, bReadPropertyNamePassed );

    // Read the PROPVARIANT that we wrote earlier.

    Check(S_OK, pPropStgDestination->ReadMultiple(1, &propspec, &propvarDestination));

    // Verify that it's correct.

    Check(TRUE, propvarDestination.vt   == propvarSourceSimple.vt );
    Check(TRUE, propvarDestination.lVal == lSimplePostCommit);

    Check(S_OK, pPropStgDestination->Commit( STGC_DEFAULT ));
    Check(S_OK, pPropStgDestination->Release());
    pPropStgDestination = NULL;


    //  ------------------------------------------------
    //  Verify the test data in the destination Storage.
    //  ------------------------------------------------

    // Now we can release and re-use the Stream pointer that
    // currently points to the sub-Stream in the source docfile.

    Check(STG_E_REVERTED, pstmSub->Commit( STGC_DEFAULT ));
    Check(S_OK, pstmSub->Release());
    pstmSub = NULL;

    // Get the Storage then the Stream.

    Check( S_OK, pstgBaseDestination->OpenStorage(
                                poszTestSubStorage,
                                NULL,
                                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
                                NULL,
                                0L,
                                &pstgSub ));

    Check( S_OK, pstgSub->OpenStream(
                            poszTestSubStream,
                            NULL,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            0L,
                            &pstmSub ));

    // Read the data and compare it against what we wrote.

    Check( S_OK, pstmSub->Read(
                    acReadBuffer,
                    sizeof( acReadBuffer ),
                    &cbRead ));

    OLECHAR const *poszTestData =   ( STGM_TRANSACTED & ulPropSetTransaction )
                                  ?
                                  poszTestDataPreCommit
                                  :
                                  poszTestDataPostCommit;

    Check( TRUE, cbRead == sizeof(OLECHAR)
                           *
                           (ocslen( poszTestData ) + sizeof(OLECHAR))
         );

    Check( FALSE, ocscmp( poszTestData, (OLECHAR *) acReadBuffer ));


    //  ----
    //  Exit
    //  ----

    // We're done.  Don't bother to release anything;
    // they'll release themselves in their destructors.

    return;

}   // test_CopyTo()



//--------------------------------------------------------
//
//  Function:   test_OLESpecTickerExample
//
//  Synopsis:   This function generates the ticker property set
//              example that's used in the OLE Programmer's Reference
//              (when describing property ID 0 - the dictionary).
//
//--------------------------------------------------------


#define PID_SYMBOL  0x7
#define PID_OPEN    0x3
#define PID_CLOSE   0x4
#define PID_HIGH    0x5
#define PID_LOW     0x6
#define PID_LAST    0x8
#define PID_VOLUME  0x9

void test_OLESpecTickerExample( IStorage* pstg )
{
    printf( "   Generate the Stock Ticker property set example from the OLE Programmer's Ref\n" );

    //  ------
    //  Locals
    //  ------

    FMTID fmtid;

    PROPSPEC propspec;

    DECLARE_CONST_OLESTR(coszPropSetName, "Stock Quote" );
    DECLARE_CONST_OLESTR(coszTickerSymbolName, "Ticker Symbol" );
    DECLARE_CONST_OLESTR(coszOpenName, "Opening Price" );
    DECLARE_CONST_OLESTR(coszCloseName, "Last Closing Price" );
    DECLARE_CONST_OLESTR(coszHighName, "High Price" );
    DECLARE_CONST_OLESTR(coszLowName, "Low Price" );
    DECLARE_CONST_OLESTR(coszLastName, "Last Price" );
    DECLARE_CONST_OLESTR(coszVolumeName, "Volume" );

    //  ---------------------------------
    //  Create a new simple property set.
    //  ---------------------------------

    TSafeStorage< IPropertySetStorage > pPropSetStg(pstg);
    IPropertyStorage *pPropStg;

    UuidCreate( &fmtid );

    Check(S_OK, pPropSetStg->Create(fmtid,
            NULL,
            PROPSETFLAG_DEFAULT,    // Unicode
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg));


    //  ---------------------------------------------
    //  Fill in the simply property set's dictionary.
    //  ---------------------------------------------

    // Write the property set's name.

    PROPID pidDictionary = 0;
    Check(S_OK, pPropStg->WritePropertyNames(1, &pidDictionary, &coszPropSetName ));

    // Write the High price, forcing the dictionary to pad.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_HIGH;

    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszHighName ));


    // Write the ticker symbol.

    propspec.propid = PID_SYMBOL;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszTickerSymbolName));

    // Write the rest of the dictionary.

    propspec.propid = PID_LOW;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszLowName));

    propspec.propid = PID_OPEN;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszOpenName));
    
    propspec.propid = PID_CLOSE;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszCloseName));
    
    propspec.propid = PID_LAST;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszLastName));
    
    propspec.propid = PID_VOLUME;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszVolumeName));


    // Write out the ticker symbol.

    propspec.propid = PID_SYMBOL;

    PROPVARIANT propvar;
    propvar.vt = VT_LPWSTR;
    DECLARE_WIDESTR(wszMSFT, "MSFT");
    propvar.pwszVal = wszMSFT;

    Check(S_OK, pPropStg->WriteMultiple(1, &propspec, &propvar, 2));


    //  ----
    //  Exit
    //  ----

    Check(S_OK, pPropStg->Commit( STGC_DEFAULT ));
    Check(S_OK, pPropStg->Release());
    Check(S_OK, pstg->Commit( STGC_DEFAULT ));

    return;


}  // test_OLESpecTickerExample()


void
test_Office( LPOLESTR wszTestFile )
{

    printf( "   Generate Office Property Sets\n" );

    TSafeStorage<IStorage> pStg;
    TSafeStorage<IPropertyStorage> pPStgSumInfo, pPStgDocSumInfo, pPStgUserDefined;

    PROPVARIANT propvarWrite, propvarRead;
    PROPSPEC    propspec;

    PropVariantInit( &propvarWrite );
    PropVariantInit( &propvarRead );

    // Create the DocFile

    Check(S_OK, StgCreateDocfile(  wszTestFile,
                                   STGM_DIRECT | STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                   0,
                                   &pStg));

    // Create the SummaryInformation property set.

    TSafeStorage<IPropertySetStorage> pPSStg( pStg );
    Check(S_OK, pPSStg->Create( FMTID_SummaryInformation,
                                NULL,
                                PROPSETFLAG_ANSI,
                                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                &pPStgSumInfo ));

    // Write a Title to the SumInfo property set.

    PropVariantInit( &propvarWrite );
    propvarWrite.vt = VT_LPSTR;
    propvarWrite.pszVal = "Title from PropTest";
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_TITLE;

    Check( S_OK, pPStgSumInfo->WriteMultiple( 1, &propspec, &propvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPStgSumInfo->ReadMultiple( 1, &propspec, &propvarRead ));

    Check( TRUE, propvarWrite.vt == propvarRead.vt );
    Check( FALSE, strcmp( propvarWrite.pszVal, propvarRead.pszVal ));

    PropVariantClear( &propvarRead );
    PropVariantInit( &propvarRead );
    pPStgSumInfo->Release();
    pPStgSumInfo = NULL;


    // Create the DocumentSummaryInformation property set.

    Check(S_OK, pPSStg->Create( FMTID_DocSummaryInformation,
                                NULL,
                                PROPSETFLAG_ANSI,
                                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                &pPStgDocSumInfo ));

    // Write a word-count to the DocSumInfo property set.

    PropVariantInit( &propvarWrite );
    propvarWrite.vt = VT_I4;
    propvarWrite.lVal = 100;
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_WORDCOUNT;

    Check( S_OK, pPStgDocSumInfo->WriteMultiple( 1, &propspec, &propvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPStgDocSumInfo->ReadMultiple( 1, &propspec, &propvarRead ));

    Check( TRUE, propvarWrite.vt == propvarRead.vt );
    Check( TRUE, propvarWrite.lVal == propvarRead.lVal );

    PropVariantClear( &propvarRead );
    PropVariantInit( &propvarRead );
    pPStgDocSumInfo->Release();
    pPStgDocSumInfo = NULL;


    // Create the UserDefined property set.

    Check(S_OK, pPSStg->Create( FMTID_UserDefinedProperties,
                                NULL,
                                PROPSETFLAG_ANSI,
                                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                &pPStgUserDefined ));

    // Write named string to the UserDefined property set.

    PropVariantInit( &propvarWrite );
    propvarWrite.vt = VT_LPSTR;
    propvarWrite.pszVal = "User-Defined string from PropTest";
    propspec.ulKind = PRSPEC_LPWSTR;
    DECLARE_OLESTR(ocsTest, "PropTest String");
    propspec.lpwstr = ocsTest;

    Check( S_OK, pPStgUserDefined->WriteMultiple( 1, &propspec, &propvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPStgUserDefined->ReadMultiple( 1, &propspec, &propvarRead ));

    Check( TRUE, propvarWrite.vt == propvarRead.vt );
    Check( FALSE, strcmp( propvarWrite.pszVal, propvarRead.pszVal ));

    PropVariantClear( &propvarRead );
    PropVariantInit( &propvarRead );
    pPStgUserDefined->Release();
    pPStgUserDefined = NULL;


    // And we're done!  (Everything releases automatically)

    return;

}


inline BOOL operator == ( FILETIME &ft1, FILETIME &ft2 )
{
    return( ft1.dwHighDateTime == ft2.dwHighDateTime
            &&
            ft1.dwLowDateTime  == ft2.dwLowDateTime );
}

inline BOOL operator != ( FILETIME &ft1, FILETIME &ft2 )
{
    return( ft1.dwHighDateTime != ft2.dwHighDateTime
            ||
            ft1.dwLowDateTime  != ft2.dwLowDateTime );
}


inline BOOL operator > ( FILETIME &ft1, FILETIME &ft2 )
{
    return( ft1.dwHighDateTime >  ft2.dwHighDateTime
            ||
            ft1.dwHighDateTime == ft2.dwHighDateTime
            &&
            ft1.dwLowDateTime  > ft2.dwLowDateTime );
}

inline BOOL operator < ( FILETIME &ft1, FILETIME &ft2 )
{
    return( ft1.dwHighDateTime <  ft2.dwHighDateTime
            ||
            ft1.dwHighDateTime == ft2.dwHighDateTime
            &&
            ft1.dwLowDateTime  <  ft2.dwLowDateTime );
}

inline BOOL operator >= ( FILETIME &ft1, FILETIME &ft2 )
{
    return( ft1 > ft2
            ||
            ft1 == ft2 );
}

inline BOOL operator <= ( FILETIME &ft1, FILETIME &ft2 )
{
    return( ft1 < ft2
            ||
            ft1 == ft2 );
}



FILETIME operator - ( FILETIME &ft1, FILETIME &ft2 )
{
    FILETIME ftDiff;

    if( ft1 < ft2 )
    {
        ftDiff.dwLowDateTime  = 0;
        ftDiff.dwHighDateTime = 0;
    }

    else if( ft1.dwLowDateTime >= ft2.dwLowDateTime )
    {
        ftDiff.dwLowDateTime  = ft1.dwLowDateTime  - ft2.dwLowDateTime;
        ftDiff.dwHighDateTime = ft1.dwHighDateTime - ft2.dwHighDateTime;
    }
    else
    {
        ftDiff.dwLowDateTime = ft1.dwLowDateTime - ft2.dwLowDateTime;
        ftDiff.dwLowDateTime = (DWORD) -1 - ftDiff.dwLowDateTime;

        ftDiff.dwHighDateTime = ft1.dwHighDateTime - ft2.dwHighDateTime - 1;
    }

    return( ftDiff );
}




void test_PropVariantCopy( )
{
    printf( "   PropVariantCopy\n" );

    PROPVARIANT propvarCopy;
    PropVariantInit( &propvarCopy );

    for( int i = 0; i < CPROPERTIES_ALL; i++ )
    {
        Check(S_OK, PropVariantCopy( &propvarCopy, &g_rgcpropvarAll[i] ));
        Check(S_OK, CPropVariant::Compare( &propvarCopy, &g_rgcpropvarAll[i]
            ));
        PropVariantClear( &propvarCopy );
    }

}

char* oszft(FILETIME *pft)
{
    static char szBuf[32];
    szBuf[0] = '\0';
    sprintf(szBuf, "(H)%x (L)%x", pft->dwLowDateTime, 
            pft->dwHighDateTime);
    return szBuf;
}

void PrintOC(char *ocsStr)
{
    // simple subsitute to print both WIDE and BYTE chars
    for (  ;*ocsStr; ocsStr++)
        printf("%c", (char) *(ocsStr));
}

void PrintOC(WCHAR *ocsStr)
{
    // simple subsitute to print both WIDE and BYTE chars
    for (  ;*ocsStr; ocsStr++)
        if ( (int) *ocsStr < (int) 0xff)        // in range
            printf("%c", (char) *(ocsStr));
        else
            printf("[%d]", *ocsStr);
}

void DumpTime(WCHAR *pszName, FILETIME *pft)
{
    PrintOC(pszName);
    printf("(H)%x (L)%x\n", 
           pft->dwHighDateTime,
           pft->dwLowDateTime);
}

void DumpTime(char *pszName, FILETIME *pft)
{
    printf("%s (H)%x (L)%x\n", 
           pszName,
           pft->dwHighDateTime,
           pft->dwLowDateTime);
}

VOID
PrintGuid(GUID *pguid)
{
    printf(
        "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        pguid->Data1,
        pguid->Data2,
        pguid->Data3,
        pguid->Data4[0],
        pguid->Data4[1],
        pguid->Data4[2],
        pguid->Data4[3],
        pguid->Data4[4],
        pguid->Data4[5],
        pguid->Data4[6],
        pguid->Data4[7]);
}


VOID
ListPropSetHeader(
    STATPROPSETSTG *pspss,
    OLECHAR *poszName)
{
    BOOLEAN fDocumentSummarySection2;
    OLECHAR oszStream[80];      // should be enough

    fDocumentSummarySection2 = (BOOLEAN)
	memcmp(&pspss->fmtid, &FMTID_UserDefinedProperties, sizeof(GUID)) == 0;

    printf(" Property set ");
    PrintGuid(&pspss->fmtid);

    RtlGuidToPropertySetName(&pspss->fmtid, oszStream);

    printf("\n  %s Name ",
           (pspss->grfFlags & PROPSETFLAG_NONSIMPLE)?
	    "Embedding" : "Stream");
    PrintOC(oszStream);
    if (poszName != NULL || fDocumentSummarySection2)
    {
        printf(" (");
        if (poszName != NULL)
            PrintOC(poszName);
        else
            printf("User defined properties");
        printf(")");
    }
    printf("\n");

    if (pspss->grfFlags & PROPSETFLAG_NONSIMPLE)
    {
	DumpTime("  Create Time ", &pspss->ctime);
    }
    DumpTime("  Modify Time ", &pspss->mtime);
    if (pspss->grfFlags & PROPSETFLAG_NONSIMPLE)
    {
	DumpTime("  Access Time ", &pspss->atime);
    }
}




typedef enum _PUBLICPROPSET
{
    PUBPS_UNKNOWN = 0,
    PUBPS_SUMMARYINFO = 3,
    PUBPS_DOCSUMMARYINFO = 4,
    PUBPS_USERDEFINED = 5,
} PUBLICPROPSET;


#define BSTRLEN(bstrVal)      *((ULONG *) bstrVal - 1)
ULONG
SizeProp(PROPVARIANT *pv)
{
    ULONG j;
    ULONG cbprop = 0;

    switch (pv->vt)
    {
    default:
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_UI1:
        cbprop = sizeof(pv->bVal);
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        cbprop = sizeof(pv->iVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        cbprop = sizeof(pv->lVal);
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        cbprop = sizeof(pv->hVal);
        break;

    case VT_CLSID:
        cbprop = sizeof(*pv->puuid);
        break;

    case VT_BLOB_OBJECT:
    case VT_BLOB:
        cbprop = pv->blob.cbSize + sizeof(pv->blob.cbSize);
        break;

    case VT_CF:
        cbprop = sizeof(pv->pclipdata->cbSize) +
                 pv->pclipdata->cbSize;
        break;

    case VT_BSTR:
	// count + string
	cbprop = sizeof(ULONG);
	if (pv->bstrVal != NULL)
	{
	    cbprop += BSTRLEN(pv->bstrVal);
	}
	break;

    case VT_LPSTR:
	// count + string + null char
	cbprop = sizeof(ULONG);
	if (pv->pszVal != NULL)
	{
	    cbprop += strlen(pv->pszVal) + 1;
	}
	break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_LPWSTR:
	// count + string + null char
	cbprop = sizeof(ULONG);
	if (pv->pwszVal != NULL)
	{
	    cbprop += sizeof(pv->pwszVal[0]) * (wcslen(pv->pwszVal) + 1);
	}
	break;

    //  vectors
    case VT_VECTOR | VT_UI1:
        cbprop = sizeof(pv->caub.cElems) +
             pv->caub.cElems * sizeof(pv->caub.pElems[0]);
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        cbprop = sizeof(pv->cai.cElems) +
             pv->cai.cElems * sizeof(pv->cai.pElems[0]);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        cbprop = sizeof(pv->cal.cElems) +
             pv->cal.cElems * sizeof(pv->cal.pElems[0]);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        cbprop = sizeof(pv->cah.cElems) +
             pv->cah.cElems * sizeof(pv->cah.pElems[0]);
        break;

    case VT_VECTOR | VT_CLSID:
        cbprop = sizeof(pv->cauuid.cElems) +
             pv->cauuid.cElems * sizeof(pv->cauuid.pElems[0]);
        break;

    case VT_VECTOR | VT_CF:
        cbprop = sizeof(pv->caclipdata.cElems);
        for (j = 0; j < pv->caclipdata.cElems; j++)
        {
            cbprop += sizeof(pv->caclipdata.pElems[j].cbSize) +
                      DwordAlign(pv->caclipdata.pElems[j].cbSize);
        }
        break;

    case VT_VECTOR | VT_BSTR:
	cbprop = sizeof(pv->cabstr.cElems);
	for (j = 0; j < pv->cabstr.cElems; j++)
	{
	    // count + string + null char
	    cbprop += sizeof(ULONG);
	    if (pv->cabstr.pElems[j] != NULL)
	    {
		cbprop += DwordAlign(BSTRLEN(pv->cabstr.pElems[j]));
	    }
	}
	break;

    case VT_VECTOR | VT_LPSTR:
	cbprop = sizeof(pv->calpstr.cElems);
	for (j = 0; j < pv->calpstr.cElems; j++)
	{
	    // count + string + null char
	    cbprop += sizeof(ULONG);
	    if (pv->calpstr.pElems[j] != NULL)
	    {
		cbprop += DwordAlign(strlen(pv->calpstr.pElems[j]) + 1);
	    }
	}
	break;

    case VT_VECTOR | VT_LPWSTR:
	cbprop = sizeof(pv->calpwstr.cElems);
	for (j = 0; j < pv->calpwstr.cElems; j++)
	{
	    // count + string + null char
	    cbprop += sizeof(ULONG);
	    if (pv->calpwstr.pElems[j] != NULL)
	    {
		cbprop += DwordAlign(
			sizeof(pv->calpwstr.pElems[j][0]) *
			(wcslen(pv->calpwstr.pElems[j]) + 1));
	    }
	}
	break;

    case VT_VECTOR | VT_VARIANT:
        cbprop = sizeof(pv->calpwstr.cElems);
        for (j = 0; j < pv->calpwstr.cElems; j++)
        {
            cbprop += SizeProp(&pv->capropvar.pElems[j]);
        }
        break;
    }
    return(DwordAlign(cbprop) + DwordAlign(sizeof(pv->vt)));
}


PUBLICPROPSET
GuidToPropSet(GUID *pguid)
{
    PUBLICPROPSET pubps = PUBPS_UNKNOWN;
	
    if (pguid != NULL)
    {
	if (memcmp(pguid, &FMTID_SummaryInformation, sizeof(GUID)) == 0)
	{
	    pubps = PUBPS_SUMMARYINFO;
	}
	else if (memcmp(pguid, &FMTID_DocSummaryInformation, sizeof(GUID)) == 0)
	{
	    pubps = PUBPS_DOCSUMMARYINFO;
	}
	else if (memcmp(pguid, &FMTID_UserDefinedProperties, sizeof(GUID)) == 0)
	{
	    pubps = PUBPS_USERDEFINED;
	}
    }
    return(pubps);
}


char
PrintableChar(char ch)
{
    if (ch < ' ' || ch > '~')
    {
        ch = '.';
    }
    return(ch);
}


VOID
DumpHex(BYTE *pb, ULONG cb, ULONG base)
{
    char *pszsep;
    ULONG r, i, cbremain;
    int fZero = FALSE;
    int fSame = FALSE;

    for (r = 0; r < cb; r += 16)
    {
        cbremain = cb - r;
        if (r != 0 && cbremain >= 16)
        {
            if (pb[r] == 0)
            {
                ULONG j;

                for (j = r + 1; j < cb; j++)
                {
                    if (pb[j] != 0)
                    {
                        break;
                    }
                }
                if (j == cb)
                {
                    fZero = TRUE;
                    break;
                }
            }
            if (memcmp(&pb[r], &pb[r - 16], 16) == 0)
            {
                fSame = TRUE;
                continue;
            }
        }
        if (fSame)
        {
            printf("\n\t  *");
            fSame = FALSE;
        }
        unsigned int iLimit =  (cbremain > 16) ? 16 : cbremain;
        for (i = 0; i < iLimit; i++)
        {
            pszsep = " ";
            if ((i % 8) == 0)           // 0 or 8
            {
                pszsep = "  ";
                if (i == 0)             // 0
                {
		    // start a new line
		    printf("%s    %04x:", r == 0? "" : "\n", r + base);
		    pszsep = " ";
                }
            }
            printf("%s%02x", pszsep, pb[r + i]);
        }
        if (i != 0)
        {
            printf("%*s", 3 + (16 - i)*3 + ((i <= 8)? 1 : 0), "");
            for (i = 0; i < iLimit; i++)
            {
                printf("%c", PrintableChar(pb[r + i]));
            }
        }
    }
    if (r != 0)
    {
        printf("\n");
    }
    if (fZero)
    {
        printf("    Remaining %lx bytes are zero\n", cbremain);
    }
}


// Property Id's for Summary Info
#define PID_TITLE		0x00000002L	// VT_LPSTR
#define PID_SUBJECT		0x00000003L	// VT_LPSTR
#define PID_AUTHOR		0x00000004L	// VT_LPSTR
#define PID_KEYWORDS		0x00000005L	// VT_LPSTR
#define PID_COMMENTS		0x00000006L	// VT_LPSTR
#define PID_TEMPLATE		0x00000007L	// VT_LPSTR
#define PID_LASTAUTHOR		0x00000008L	// VT_LPSTR
#define PID_REVNUMBER		0x00000009L	// VT_LPSTR
#define PID_EDITTIME		0x0000000aL	// VT_FILETIME
#define PID_LASTPRINTED		0x0000000bL	// VT_FILETIME
#define PID_CREATE_DTM		0x0000000cL	// VT_FILETIME
#define PID_LASTSAVE_DTM	0x0000000dL	// VT_FILETIME
#define PID_PAGECOUNT		0x0000000eL	// VT_I4
#define PID_WORDCOUNT		0x0000000fL	// VT_I4
#define PID_CHARCOUNT		0x00000010L	// VT_I4
#define PID_THUMBNAIL		0x00000011L	// VT_CF
#define PID_APPNAME		0x00000012L	// VT_LPSTR
#define PID_SECURITY_DSI	0x00000013L	// VT_I4

// Property Id's for Document Summary Info
#define PID_CATEGORY		0x00000002L	// VT_LPSTR
#define PID_PRESFORMAT		0x00000003L	// VT_LPSTR
#define PID_BYTECOUNT		0x00000004L	// VT_I4
#define PID_LINECOUNT		0x00000005L	// VT_I4
#define PID_PARACOUNT		0x00000006L	// VT_I4
#define PID_SLIDECOUNT		0x00000007L	// VT_I4
#define PID_NOTECOUNT		0x00000008L	// VT_I4
#define PID_HIDDENCOUNT		0x00000009L	// VT_I4
#define PID_MMCLIPCOUNT		0x0000000aL	// VT_I4
#define PID_SCALE		0x0000000bL	// VT_BOOL
#define PID_HEADINGPAIR		0x0000000cL	// VT_VECTOR | VT_VARIANT
#define PID_DOCPARTS		0x0000000dL	// VT_VECTOR | VT_LPSTR
#define PID_MANAGER		0x0000000eL	// VT_LPSTR
#define PID_COMPANY		0x0000000fL	// VT_LPSTR
#define PID_LINKSDIRTY		0x00000010L	// VT_BOOL
#define PID_CCHWITHSPACES	0x00000011L	// VT_I4
#define PID_GUID		0x00000012L	// VT_LPSTR
#define PID_SHAREDDOC		0x00000013L	// VT_BOOL
#define PID_LINKBASE		0x00000014L	// VT_LPSTR
#define PID_HLINKS		0x00000015L	// VT_VECTOR | VT_VARIANT
#define PID_HYPERLINKSCHANGED	0x00000016L	// VT_BOOL

VOID
DisplayProps(
    GUID *pguid,
    ULONG cprop,
    PROPID apid[],
    STATPROPSTG asps[],
    FULLPROPSPEC afps[],
    PROPVARIANT *av,
    BOOLEAN fsumcat,
    ULONG *pcbprop)
{
    PROPVARIANT *pv;
    PROPVARIANT *pvend;
    STATPROPSTG *psps;
    FULLPROPSPEC *pfps, *pfpsLast = NULL;
    BOOLEAN fVariantVector;
    PUBLICPROPSET pubps;
    DECLARE_OLESTR(ocsNull,"");

    ASSERT(asps == NULL || afps == NULL);
    fVariantVector = (asps == NULL && afps == NULL);

    pubps = GuidToPropSet(pguid);
    pvend = &av[cprop];
    for (pv = av, psps = asps, pfps = afps; pv < pvend; pv++, psps++, pfps++)
    {
        ULONG j;
        ULONG cbprop;
        PROPID propid;
        OLECHAR *postrName;
        char *psz;
        BOOLEAN fNewLine = TRUE;
        int ccol;
        static char szNoFormat[] = " (no display format)";
        char achvt[19 + 8 + 1];

        cbprop = SizeProp(pv);
        *pcbprop += cbprop;

        postrName = NULL;
        if (asps != NULL)
        {
            propid = psps->propid;
            postrName = psps->lpwstrName;
        }
        else if (afps != NULL)          // If multiple propsets are possible
        {
            if (pfpsLast == NULL ||     // print unique GUIDs only
                memcmp(
                    &pfps->guidPropSet,
                    &pfpsLast->guidPropSet,
                    sizeof(pfps->guidPropSet)) != 0)
            {
                OLECHAR oszStream[80];

		printf("%s Guid: ", pfpsLast == NULL? "" : "\n");
		PrintGuid(&pfps->guidPropSet);

		pubps = GuidToPropSet(&pfps->guidPropSet);
                RtlGuidToPropertySetName(&pfps->guidPropSet, oszStream);

                printf( " Name: " ); 
		PrintOC(oszStream);
                printf( "%s", pubps == PUBPS_USERDEFINED?
			g_szEmpty : " (User defined properties)");
                pfpsLast = pfps;
            }
            if (pfps->psProperty.ulKind == PRSPEC_PROPID)
            {
                propid = pfps->psProperty.propid;
            }
            else
            {
                propid = PID_ILLEGAL;
                postrName = pfps->psProperty.lpwstr;
            }
        }
        else
        {
            ASSERT(apid != NULL);
            propid = apid[0];
        }

        printf(" ");
        ccol = 0;

        if (propid != PID_ILLEGAL)
        {
            printf(" %04x", propid);
            ccol += 5;
            if (propid & (0xf << 28))
            {
                ccol += 4;
            }
            else if (propid & (0xf << 24))
            {
                ccol += 3;
            }
            else if (propid & (0xf << 20))
            {
                ccol += 2;
            }
            else if (propid & (0xf << 16))
            {
                ccol++;
            }
        }
        if (postrName != NULL)
        {
            printf(" '");
	    PrintOC(postrName);
            printf("' ");
	    ccol += ocslen(postrName) + 3;
        }
        else if (fVariantVector)
        {
            ULONG i = pv - av;
                
            printf("[%x]", i);
            do
            {
                ccol++;
                i >>= 4;
            } while (i != 0);
            ccol += 2;
        }
        else
        {
            psz = NULL;

            switch (propid)
            {
                case PID_LOCALE:               psz = "Locale";           break;
                case PID_SECURITY:             psz = "SecurityId";       break;
                case PID_MODIFY_TIME:          psz = "ModifyTime";       break;
                case PID_CODEPAGE:             psz = "CodePage";         break;
                case PID_DICTIONARY:           psz = "Dictionary";       break;
            }
            if (psz == NULL)
		switch (pubps)
		{
		case PUBPS_SUMMARYINFO:
		    switch (propid)
		    {
		    case PID_TITLE:              psz = "Title";          break;
		    case PID_SUBJECT:            psz = "Subject";        break;
		    case PID_AUTHOR:             psz = "Author";         break;
		    case PID_KEYWORDS:           psz = "Keywords";       break;
		    case PID_COMMENTS:           psz = "Comments";       break;
		    case PID_TEMPLATE:           psz = "Template";       break;
		    case PID_LASTAUTHOR:         psz = "LastAuthor";     break;
		    case PID_REVNUMBER:          psz = "RevNumber";      break;
		    case PID_EDITTIME:           psz = "EditTime";       break;
		    case PID_LASTPRINTED:        psz = "LastPrinted";    break;
		    case PID_CREATE_DTM:         psz = "CreateDateTime"; break;
		    case PID_LASTSAVE_DTM:       psz = "LastSaveDateTime";break;
		    case PID_PAGECOUNT:          psz = "PageCount";      break;
		    case PID_WORDCOUNT:          psz = "WordCount";      break;
		    case PID_CHARCOUNT:          psz = "CharCount";      break;
		    case PID_THUMBNAIL:          psz = "ThumbNail";      break;
		    case PID_APPNAME:            psz = "AppName";        break;
		    case PID_DOC_SECURITY:       psz = "Security";       break;

		    }
		    break;

		case PUBPS_DOCSUMMARYINFO:
		    switch (propid)
		    {
		    case PID_CATEGORY:          psz = "Category";        break;
		    case PID_PRESFORMAT:        psz = "PresFormat";      break;
		    case PID_BYTECOUNT:         psz = "ByteCount";       break;
		    case PID_LINECOUNT:         psz = "LineCount";       break;
		    case PID_PARACOUNT:         psz = "ParaCount";       break;
		    case PID_SLIDECOUNT:        psz = "SlideCount";      break;
		    case PID_NOTECOUNT:         psz = "NoteCount";       break;
		    case PID_HIDDENCOUNT:       psz = "HiddenCount";     break;
		    case PID_MMCLIPCOUNT:       psz = "MmClipCount";     break;
		    case PID_SCALE:             psz = "Scale";           break;
		    case PID_HEADINGPAIR:       psz = "HeadingPair";     break;
		    case PID_DOCPARTS:          psz = "DocParts";        break;
		    case PID_MANAGER:           psz = "Manager";         break;
		    case PID_COMPANY:           psz = "Company";         break;
		    case PID_LINKSDIRTY:        psz = "LinksDirty";      break;
		    case PID_CCHWITHSPACES:     psz = "CchWithSpaces";   break;
		    case PID_GUID:              psz = "Guid";            break;
		    case PID_SHAREDDOC:         psz = "SharedDoc";       break;
		    case PID_LINKBASE:          psz = "LinkBase";        break;
		    case PID_HLINKS:            psz = "HLinks";          break;
		    case PID_HYPERLINKSCHANGED:	psz = "HyperLinksChanged";break;
		    }
		    break;
            }
            if (psz != NULL)
            {
                printf(" %s", psz);
                ccol += strlen(psz) + 1;
            }
        }
#define CCOLPROPID 20
        if (ccol != CCOLPROPID)
	{
	    if (ccol > CCOLPROPID)
	    {
		ccol = -1;
	    }
            printf("%s%*s", ccol == -1? "\n" : "", CCOLPROPID - ccol, "");
	}
        printf(" %08x  %04x  %04x ", propid, cbprop, pv->vt);

        psz = "";
        switch (pv->vt)
        {
        default:
            psz = achvt;
            sprintf(psz, "Unknown (vt = %hx)", pv->vt);
            break;

        case VT_EMPTY:
            printf("EMPTY");
            break;

        case VT_NULL:
            printf("NULL");
            break;

        case VT_UI1:
            printf("UI1 = %02lx", pv->bVal);
            psz = "";
            break;

        case VT_I2:
            psz = "I2";
            goto doshort;

        case VT_UI2:
            psz = "UI2";
            goto doshort;

        case VT_BOOL:
            psz = "BOOL";
doshort:
            printf("%s = %04hx", psz, pv->iVal);
            psz = g_szEmpty;
            break;

        case VT_I4:
            psz = "I4";
            goto dolong;

        case VT_UI4:
            psz = "UI4";
            goto dolong;

        case VT_R4:
            psz = "R4";
            goto dolong;

        case VT_ERROR:
            psz = "ERROR";
dolong:
            printf("%s = %08lx", psz, pv->lVal);
            psz = g_szEmpty;
            break;

        case VT_I8:
            psz = "I8";
            goto dotwodword;

        case VT_UI8:
            psz = "UI8";
dotwodword:
            printf( "%s = %08lx:%08lx",
                   psz,
                   pv->hVal.HighPart,
                   pv->hVal.LowPart );
            psz = g_szEmpty;
            break;

        case VT_R8:
            psz = "R8";
            goto dolonglong;

        case VT_CY:
            psz = "R8";
            goto dolonglong;

        case VT_DATE:
            psz = "R8";
dolonglong:
            printf(
                "%s = %08lx:%08lx",
                psz,
                (pv->cyVal).split.Hi,
                (pv->cyVal).split.Lo);
            psz = g_szEmpty;
            break;

        case VT_FILETIME:
            DumpTime("FILETIME =\n\t  ", &pv->filetime);
            fNewLine = FALSE;           // skip newline printf
            break;

        case VT_CLSID:
            printf("CLSID =\n\t  ");
            PrintGuid(pv->puuid);
            break;

        case VT_BLOB:
            psz = "BLOB";
            goto doblob;

        case VT_BLOB_OBJECT:
            psz = "BLOB_OBJECT";
doblob:
            printf("%s (cbSize %x)", psz, pv->blob.cbSize);
            if (pv->blob.cbSize != 0)
            {
                printf(" =\n");
                DumpHex(pv->blob.pBlobData, pv->blob.cbSize, 0);
            }
            psz = g_szEmpty;
            break;

        case VT_CF:
            printf(
                "CF (cbSize %x, ulClipFmt %x)\n",
                pv->pclipdata->cbSize,
                pv->pclipdata->ulClipFmt);
            DumpHex(pv->pclipdata->pClipData,
                    pv->pclipdata->cbSize - sizeof(pv->pclipdata->ulClipFmt),
                    0);
            break;

        case VT_STREAM:
            psz = "STREAM";
            goto dostring;

        case VT_STREAMED_OBJECT:
            psz = "STREAMED_OBJECT";
            goto dostring;

        case VT_STORAGE:
            psz = "STORAGE";
            goto dostring;

        case VT_STORED_OBJECT:
            psz = "STORED_OBJECT";
            goto dostring;

        case VT_BSTR:
            printf(
		"BSTR (cb = %04lx)%s\n",
		pv->bstrVal == NULL? 0 : BSTRLEN(pv->bstrVal),
		pv->bstrVal == NULL? " NULL" : g_szEmpty);
            if (pv->bstrVal != NULL)
	    {
		DumpHex(
		    (BYTE *) pv->bstrVal,
		    BSTRLEN(pv->bstrVal) + sizeof(WCHAR),
		    0);
	    }
            break;

        case VT_LPSTR:
            psz = "LPSTR";
            printf(
		"%s = %s%s%s",
		psz,
		pv->pszVal == NULL? g_szEmpty : "'",
		pv->pszVal == NULL? "NULL" : pv->pszVal,
		pv->pszVal == NULL? g_szEmpty : "'");
	    psz = g_szEmpty;
            break;

        case VT_LPWSTR:
            psz = "LPWSTR";
dostring:
            printf(
		"%s = %s",
		psz,
		pv->pwszVal == NULL? g_szEmpty : "'");
            if ( pv->pwszVal == NULL)
                printf("NULL");
            else
                PrintOC(pv->pwszVal);
            printf("%s", pv->pwszVal == NULL? g_szEmpty : "'");
            psz = g_szEmpty;
            break;

        //  vectors

        case VT_VECTOR | VT_UI1:
            printf("UI1[%x] =", pv->caub.cElems);
            for (j = 0; j < pv->caub.cElems; j++)
            {
                if ((j % 16) == 0)
                {
                    printf("\n    %02hx:", j);
                }
                printf(" %02hx", pv->caub.pElems[j]);
            }
            break;

        case VT_VECTOR | VT_I2:
            psz = "I2";
            goto doshortvector;

        case VT_VECTOR | VT_UI2:
            psz = "UI2";
            goto doshortvector;

        case VT_VECTOR | VT_BOOL:
            psz = "BOOL";
doshortvector:
            printf("%s[%x] =", psz, pv->cai.cElems);
            for (j = 0; j < pv->cai.cElems; j++)
            {
                if ((j % 8) == 0)
                {
                    printf("\n    %04hx:", j);
                }
                printf(" %04hx", pv->cai.pElems[j]);
            }
            psz = g_szEmpty;
            break;

        case VT_VECTOR | VT_I4:
            psz = "I4";
            goto dolongvector;

        case VT_VECTOR | VT_UI4:
            psz = "UI4";
            goto dolongvector;

        case VT_VECTOR | VT_R4:
            psz = "R4";
            goto dolongvector;

        case VT_VECTOR | VT_ERROR:
            psz = "ERROR";
dolongvector:
            printf("%s[%x] =", psz, pv->cal.cElems);
            for (j = 0; j < pv->cal.cElems; j++)
            {
                if ((j % 4) == 0)
                {
                    printf("\n    %04x:", j);
                }
                printf(" %08lx", pv->cal.pElems[j]);
            }
            psz = g_szEmpty;
            break;

        case VT_VECTOR | VT_I8:
            psz = "I8";
            goto dolonglongvector;

        case VT_VECTOR | VT_UI8:
            psz = "UI8";
            goto dolonglongvector;

        case VT_VECTOR | VT_R8:
            psz = "R8";
            goto dolonglongvector;

        case VT_VECTOR | VT_CY:
            psz = "CY";
            goto dolonglongvector;

        case VT_VECTOR | VT_DATE:
            psz = "DATE";
dolonglongvector:
            printf("%s[%x] =", psz, pv->cah.cElems);
            for (j = 0; j < pv->cah.cElems; j++)
            {
                if ((j % 2) == 0)
                {
                    printf("\n    %04x:", j);
                }
                printf(
                    " %08lx:%08lx",
                    pv->cah.pElems[j].HighPart,
                    pv->cah.pElems[j].LowPart);
            }
            psz = g_szEmpty;
            break;

        case VT_VECTOR | VT_FILETIME:
            printf("FILETIME[%x] =\n", pv->cafiletime.cElems);
            for (j = 0; j < pv->cafiletime.cElems; j++)
            {
		printf("    %04x: ", j);
		DumpTime(ocsNull, &pv->cafiletime.pElems[j]);
            }
            fNewLine = FALSE;           // skip newline printf
            break;

        case VT_VECTOR | VT_CLSID:
            printf("CLSID[%x] =", pv->cauuid.cElems);
            for (j = 0; j < pv->cauuid.cElems; j++)
            {
                printf("\n    %04x: ", j);
                PrintGuid(&pv->cauuid.pElems[j]);
            }
            break;

        case VT_VECTOR | VT_CF:
            printf("CF[%x] =", pv->caclipdata.cElems);
            for (j = 0; j < pv->caclipdata.cElems; j++)
            {
                printf("\n    %04x: (cbSize %x, ulClipFmt %x) =\n",
                    j,
                    pv->caclipdata.pElems[j].cbSize,
                    pv->caclipdata.pElems[j].ulClipFmt);
                DumpHex(
                    pv->caclipdata.pElems[j].pClipData,
                    pv->caclipdata.pElems[j].cbSize - sizeof(pv->caclipdata.pElems[j].ulClipFmt),
		    0);
            }
            break;

        case VT_VECTOR | VT_BSTR:
            printf("BSTR[%x] =", pv->cabstr.cElems);
            for (j = 0; j < pv->cabstr.cElems; j++)
            {
		BSTR bstr = pv->cabstr.pElems[j];

                printf(
		    "\n    %04x: cb = %04lx%s\n",
		    j,
		    bstr == NULL? 0 : BSTRLEN(pv->cabstr.pElems[j]),
		    bstr == NULL? " NULL" : g_szEmpty);
		if (bstr != NULL)
		{
		    DumpHex((BYTE *) bstr, BSTRLEN(bstr) + sizeof(WCHAR), 0);
		}
            }
            break;

        case VT_VECTOR | VT_LPSTR:
            printf("LPSTR[%x] =", pv->calpstr.cElems);
            for (j = 0; j < pv->calpstr.cElems; j++)
            {
		CHAR *psz = pv->calpstr.pElems[j];

                printf(
		    "\n    %04x: %s%s%s",
		    j,
		    psz == NULL? g_szEmpty : "'",
		    psz == NULL? "NULL" : psz,
		    psz == NULL? g_szEmpty : "'");
            }
            break;

        case VT_VECTOR | VT_LPWSTR:
            printf("LPWSTR[%x] =", pv->calpwstr.cElems);
            for (j = 0; j < pv->calpwstr.cElems; j++)
            {
		WCHAR *pwsz = pv->calpwstr.pElems[j];
                printf( "\n     %04x: %s",
                        j, pv->pwszVal == NULL? g_szEmpty : "'");
                if ( pwsz == NULL)
                    printf("NULL");
                else
                    PrintOC(pwsz);
                printf("%s", pwsz == NULL? g_szEmpty : "'");       
            }
            break;

        case VT_VECTOR | VT_VARIANT:
            printf("VARIANT[%x] =\n", pv->capropvar.cElems);
            DisplayProps(
		    pguid,
                    pv->capropvar.cElems,
                    &propid,
                    NULL,
                    NULL,
                    pv->capropvar.pElems,
		    fsumcat,
                    pcbprop);
            fNewLine = FALSE;           // skip newline printf
            break;
        }
        if (*psz != '\0')
        {
            printf("%s", psz);
            if (pv->vt & VT_VECTOR)
            {
                printf("[%x]", pv->cal.cElems);
            }
            printf("%s", szNoFormat);
        }
        if (!fVariantVector && apid != NULL && apid[pv - av] != propid)
        {
            printf(" (bad PROPID: %04x)", apid[pv - av]);
            fNewLine = TRUE;
        }
        if (asps != NULL && pv->vt != psps->vt)
        {
            printf(" (bad STATPROPSTG VARTYPE: %04x)", psps->vt);
            fNewLine = TRUE;
        }
        if (fNewLine)
        {
            printf("\n");
        }
    }
}

STATPROPSTG aspsStatic[] = {
    { NULL, PID_CODEPAGE,    VT_I2 },
    { NULL, PID_MODIFY_TIME, VT_FILETIME },
    { NULL, PID_SECURITY,    VT_UI4 },
};
#define CPROPSTATIC      (sizeof(aspsStatic)/sizeof(aspsStatic[0]))


#define CB_STREAM_OVERHEAD      28
#define CB_PROPSET_OVERHEAD     (CB_STREAM_OVERHEAD + 8)
#define CB_PROP_OVERHEAD        8

HRESULT
DumpOlePropertySet(
    IPropertySetStorage *ppsstg,
    STATPROPSETSTG *pspss,
    ULONG *pcprop,
    ULONG *pcbprop)
{
    HRESULT hr;
    IEnumSTATPROPSTG *penumsps = NULL;
    IPropertyStorage *pps;
    ULONG cprop, cbpropset;
    PROPID propid;
    OLECHAR *poszName;
    ULONG ispsStatic;

    *pcprop = *pcbprop = 0;
    hr = ppsstg->Open(
        pspss->fmtid,
        STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
        &pps);

    if (FAILED(hr))
        return (hr);

    propid = PID_DICTIONARY;
    
    hr = pps->ReadPropertyNames(1, &propid, &poszName);
    if( S_FALSE == hr )
        hr = S_OK;
    Check( S_OK, hr );

    ListPropSetHeader(pspss, poszName);
    if (poszName != NULL)
    {
	CoTaskMemFree(poszName);
    }

    cprop = cbpropset = 0;

    Check(S_OK, pps->Enum(&penumsps) );

    ispsStatic = 0;
    hr = S_OK;
    while (hr == S_OK)
    {
	STATPROPSTG sps;
	PROPSPEC propspec;
	PROPVARIANT propvar;
	ULONG count;

	hr = S_FALSE;
	if (ispsStatic == 0)
	{
	    hr = penumsps->Next(1, &sps, &count);
	}

	if (hr != S_OK)
	{
	    if (hr == S_FALSE)
	    {
		hr = S_OK;
		if (ispsStatic >= CPROPSTATIC)
		{
		    break;
		}
		sps = aspsStatic[ispsStatic];
		ispsStatic++;
		count = 1;
	    }
            Check( S_OK, hr );
	}
	PropVariantInit(&propvar);
	if (sps.lpwstrName != NULL)
	{
	    propspec.ulKind = PRSPEC_LPWSTR;
	    propspec.lpwstr = sps.lpwstrName;
	}
	else
	{
	    propspec.ulKind = PRSPEC_PROPID;
	    propspec.propid = sps.propid;
	}

        hr = pps->ReadMultiple(1, &propspec, &propvar);
	if (hr == S_FALSE)
	{
	    if (g_fVerbose)
	    {
		printf(
		    "%s(%u, %x) vt=%x returned hr=%x\n",
		    "IPropertyStorage::ReadMultiple",
		    ispsStatic,
		    propspec.propid,
		    propvar.vt,
		    hr);
	    }
	    ASSERT(propvar.vt == VT_EMPTY);
	    hr = S_OK;
	}
        Check( S_OK, hr );

	if (ispsStatic == 0 || propvar.vt != VT_EMPTY)
	{
	    ASSERT(count == 1);
	    cprop += count;
	    if (cprop == 1)
	    {
		printf(g_szPropHeader);
	    }

	    DisplayProps(
		    &pspss->fmtid,
		    1,
		    NULL,
		    &sps,
		    NULL,
		    &propvar,
		    FALSE,
		    &cbpropset);
	    PropVariantClear(&propvar);
	}
	if (sps.lpwstrName != NULL)
	{
	    CoTaskMemFree(sps.lpwstrName);
	}
    }
    if (penumsps != NULL)
    {
	penumsps->Release();
    }
    pps->Release();
    if (cprop != 0)
    {
	cbpropset += CB_PROPSET_OVERHEAD + cprop * CB_PROP_OVERHEAD;
	printf("  %04x bytes in %u properties\n\n", cbpropset, cprop);
    }
    *pcprop = cprop;
    *pcbprop = cbpropset;
    return(hr);
}


HRESULT
DumpOlePropertySets(
    IStorage *pstg,
    OLECHAR *aocpath)
{

    HRESULT hr = S_OK;
    IPropertySetStorage *ppsstg;
    ULONG cbproptotal = 0;
    ULONG cproptotal = 0;
    ULONG cpropset = 0;
    IID IIDpsstg = IID_IPropertySetStorage;

    Check(S_OK, pstg->QueryInterface(IID_IPropertySetStorage, (void **) &ppsstg) );

    {
	IEnumSTATPROPSETSTG *penumspss = NULL;

	Check(S_OK, ppsstg->Enum(&penumspss) );

	while (hr == S_OK)
	{
	    STATPROPSETSTG spss;
	    ULONG count;
	    BOOLEAN fDocumentSummarySection2;

	    hr = penumspss->Next(1, &spss, &count);

	    if (hr != S_OK)
	    {
		if (hr == S_FALSE)
		{
		    hr = S_OK;
		}

                Check( S_OK, hr );
		break;
	    }
	    ASSERT(count == 1);

	    fDocumentSummarySection2 = FALSE;
	    while (TRUE)
	    {
		ULONG cprop, cbprop;
                HRESULT hr;

		DumpOlePropertySet(
				ppsstg,
				&spss,
				&cprop,
				&cbprop);
                if ( STG_E_FILENOTFOUND == hr 
                     && fDocumentSummarySection2 )
                {
                    hr = S_OK;
                }

		cpropset++;
		cproptotal += cprop;
		cbproptotal += cbprop;

		if (memcmp(&spss.fmtid, &guidDocumentSummary, sizeof(GUID)))
		{
		    break;
		}
		spss.fmtid = FMTID_UserDefinedProperties;
		fDocumentSummarySection2 = TRUE;
	    }
	}

	if (penumspss != NULL)
	{
	    penumspss->Release();
	}
	ppsstg->Release();
    }
    if ((cbproptotal | cproptotal | cpropset) != 0)
    {
	printf(
	    " %04x bytes in %u properties in %u property sets\n",
	    cbproptotal,
	    cproptotal,
	    cpropset);
    }
    return(hr);
}

inline ULONG min(ULONG ul1, ULONG ul2)
{
    if (ul1 > ul2) return ul2;
    else return ul1;
}

NTSTATUS
DumpOleStream(
    LPSTREAM pstm,
    ULONG cb)
{
    ULONG cbTotal = 0;

    while (TRUE)
    {
	ULONG cbOut;
	BYTE ab[4096];

	Check(S_OK, pstm->Read(ab, min(cb, sizeof(ab)), &cbOut) );
	if (cbOut == 0)
	{
	    break;
	}
	if (g_fVerbose)
	{
	    DumpHex(ab, cbOut, cbTotal);
	}
	cb -= cbOut;
	cbTotal += cbOut;
    }
    return(STATUS_SUCCESS);
}

VOID
DumpOleStorage(
    IStorage *pstg,
    LPOLESTR aocpath )
{
    LPENUMSTATSTG penum;
    STATSTG ss;
    char *szType;
    OLECHAR *pocChild;
    HRESULT hr;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    Check( S_OK, DumpOlePropertySets(pstg, aocpath) );
    Check( S_OK, pstg->EnumElements(0, NULL, 0, &penum) );

    pocChild = &aocpath[ocslen(aocpath)];

    // Continue enumeration until IEnumStatStg::Next returns non-S_OK

    while (TRUE)
    {
	ULONG ulCount;

        // Enumerate one element at a time
        hr = penum->Next(1, &ss, &ulCount);
        if( S_FALSE == hr )
            break;
        else
            Check( S_OK, hr );

        // Select the human-readable type of object to display
        switch (ss.type)
        {
	    case STGTY_STREAM:    szType = "Stream";    break;
	    case STGTY_STORAGE:   szType = "Storage";   break;
	    case STGTY_LOCKBYTES: szType = "LockBytes"; break;
	    case STGTY_PROPERTY:  szType = "Property";  break;
	    default:              szType = "<Unknown>"; break;
        }
	if (g_fVerbose)
	{
	    printf(
		"Type=%hs Size=%lx Mode=%lx LocksSupported=%lx StateBits=%lx",
		szType,
		ss.cbSize.LowPart,
		ss.grfMode,
		ss.grfLocksSupported,
		ss.grfStateBits);
            PrintOC(aocpath);
            PrintOC(ss.pwcsName);
            printf("\n");
	    printf("ss.clsid = ");
	    PrintGuid(&ss.clsid);
	    printf("\n");
	}

        // If a stream, output the data in hex format.

        CoTaskMemFree(ss.pwcsName);
    }
    penum->Release();
    return;
}


//+---------------------------------------------------------
//
//  Function:   MungePropertyStorage
//  
//  Synopsis:   This routine munges the properties in a
//              Property Storage.  The values of the properties
//              remain the same, but the underlying serialization
//              is new (the properties are read, the property
//              storage is deleted, and the properties are
//              re-written).
//
//  Inputs:     [IPropertySetStorage*] ppropsetgstg (in)
//                  The Property Storage container.
//              [FMTID] fmtid
//                  The Property Storage to munge.
//
//  Returns:    None.
//
//  Note:       Property names in the dictionary for which
//              there is no property are not munged.
//
//+---------------------------------------------------------

#define MUNGE_PROPVARIANT_STEP  10  

void
MungePropertyStorage( IPropertySetStorage *ppropsetstg,
                      FMTID fmtid )
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    ULONG celt, ulIndex;
    TSafeStorage< IPropertyStorage > ppropstg;

    IEnumSTATPROPSTG *penumstatpropstg=NULL;

    PROPVARIANT *rgpropvar = NULL;
    STATPROPSTG *rgstatpropstg = NULL;
    ULONG        cProperties = 0;

    // Allocate an array of PropVariants.  We may grow this later.
    rgpropvar = (PROPVARIANT*) CoTaskMemAlloc( MUNGE_PROPVARIANT_STEP * sizeof(*rgpropvar) );
    Check( FALSE, NULL == rgpropvar );

    // Allocate an array of STATPROPSTGs.  We may grow this also.
    rgstatpropstg = (STATPROPSTG*) CoTaskMemAlloc( MUNGE_PROPVARIANT_STEP * sizeof(*rgstatpropstg) );
    Check( FALSE, NULL == rgstatpropstg );

    //  -----------------
    //  Get an Enumerator
    //  -----------------

    // Open the Property Storage.  We may get an error if we're attempting
    // the UserDefined propset.  If it's file-not-found, then simply return,
    // it's not an error, and there's nothing to do.

    hr = ppropsetstg->Open( fmtid,
                            STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            &ppropstg );
    if( FMTID_UserDefinedProperties == fmtid
        &&
        STG_E_FILENOTFOUND == hr )
    {
        goto Exit;
    }
    Check( S_OK, hr );

    // Get an Enumerator
    Check(S_OK, ppropstg->Enum( &penumstatpropstg ));


    //  --------------------------------------------
    //  Read & delete in all of the properties/names
    //  --------------------------------------------

    // Get the first property from the enumerator
    hr = penumstatpropstg->Next( 1, &rgstatpropstg[cProperties], &celt );
    Check( TRUE, S_OK == hr || S_FALSE == hr );

    // Iterate through the properties.
    while( celt > 0 )
    {
        PROPSPEC propspec;
        propspec.ulKind = PRSPEC_PROPID;
        propspec.propid = rgstatpropstg[cProperties].propid;

        // Read and delete the property

        Check(S_OK, ppropstg->ReadMultiple( 1, &propspec, &rgpropvar[cProperties] ));
        Check(S_OK, ppropstg->DeleteMultiple( 1, &propspec ));

        // If there is a property name, delete it also.

        if( NULL != rgstatpropstg[cProperties].lpwstrName )
        {
            // We have a name.
            Check(S_OK, ppropstg->DeletePropertyNames( 1, &rgstatpropstg[cProperties].propid ));
        }

        // Increment the property count.
        cProperties++;

        // Do we need to grow the arrays?

        if( 0 != cProperties
            &&
            (cProperties % MUNGE_PROPVARIANT_STEP) == 0 )
        {
            // Yes - they must be reallocated.

            rgpropvar = (PROPVARIANT*)
                        CoTaskMemRealloc( rgpropvar,
                                          ( (cProperties + MUNGE_PROPVARIANT_STEP)
                                            *
                                            sizeof(*rgpropvar) 
                                          ));
            Check( FALSE, NULL == rgpropvar );

            rgstatpropstg = (STATPROPSTG*)
                            CoTaskMemRealloc( rgstatpropstg,
                                              ( (cProperties + MUNGE_PROPVARIANT_STEP)
                                                 *
                                                 sizeof(*rgstatpropstg)
                                              ));
            Check( FALSE, NULL == rgstatpropstg );
        }

        // Move on to the next property.
        hr = penumstatpropstg->Next( 1, &rgstatpropstg[cProperties], &celt );
        Check( TRUE, S_OK == hr || S_FALSE == hr );

    }   // while( celt > 0 )


    //  -------------------------------------
    //  Write the properties & names back out
    //  -------------------------------------

    for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )
    {

        // Write the property.

        PROPSPEC propspec;
        propspec.ulKind = PRSPEC_PROPID;
        propspec.propid = rgstatpropstg[ ulIndex ].propid;

        Check(S_OK, ppropstg->WriteMultiple(1, &propspec, &rgpropvar[ulIndex], PID_FIRST_USABLE ));

        // If this property has a name, write it too.
        if( rgstatpropstg[ ulIndex ].lpwstrName != NULL )
        {
            Check(S_OK, ppropstg->WritePropertyNames(
                                            1,
                                            &rgstatpropstg[ulIndex].propid, 
                                            &rgstatpropstg[ulIndex].lpwstrName ));
        }

    }   // for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )


    //  ----
    //  Exit
    //  ----

Exit:

    if( penumstatpropstg )
    {
        penumstatpropstg->Release();
        penumstatpropstg = NULL;
    }

    // Free the PropVariants
    if( rgpropvar )
    {
        FreePropVariantArray( cProperties, rgpropvar );
        CoTaskMemFree( rgpropvar );
    }

    // Free the property names
    if( rgstatpropstg )
    {
        for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )
        {
            if( NULL != rgstatpropstg[ ulIndex ].lpwstrName )
            {
                CoTaskMemFree( rgstatpropstg[ ulIndex ].lpwstrName );
            }
        }   // for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )

        CoTaskMemFree( rgstatpropstg );
    }


}   // MungePropertyStorage

//+---------------------------------------------------------
//
//  Function:   MungeStorage
//
//  Synopsis:   This routine munges the property sets in a
//              Storage.  The properties themselves are not
//              modified, but the serialized bytes are.
//              For each property set, all the properties are
//              read, the property set is deleted, and
//              the properties are re-written.
//
//  Inputs:     [IStorage*] pstg (in)
//                  The Storage to munge.
//
//  Returns:    None.
//
//  Note:       This routine only munges simple property
//              sets.
//
//+---------------------------------------------------------

void
MungeStorage( IStorage *pstg )
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    ULONG celt;

    STATPROPSETSTG statpropsetstg;
    STATSTG statstg;

    TSafeStorage< IPropertySetStorage > ppropsetstg;
    TSafeStorage< IPropertyStorage > ppropstg;

    IEnumSTATPROPSETSTG *penumstatpropsetstg;
    IEnumSTATSTG *penumstatstg;
    
    //  -----------------------------------------------
    //  Munge each of the property sets in this Storage
    //  -----------------------------------------------

    // Get the IPropertySetStorage interface
    Check(S_OK, pstg->QueryInterface( IID_IPropertySetStorage, (VOID**) &ppropsetstg ));

    // Get a property storage enumerator
    Check(S_OK, ppropsetstg->Enum( &penumstatpropsetstg ));

    // Get the first STATPROPSETSTG
    hr = penumstatpropsetstg->Next( 1, &statpropsetstg, &celt );
    Check( TRUE, S_OK == hr || S_FALSE == hr );

    // Loop through the STATPROPSETSTGs.
    while( celt > 0 )
    {
        // Is this a simple property storage (we don't
        // handle non-simple sets)?

        if( !(statpropsetstg.grfFlags & PROPSETFLAG_NONSIMPLE) )
        {
            // Munge the Property Storage.
            MungePropertyStorage( ppropsetstg, statpropsetstg.fmtid );
        }

        // Get the next STATPROPSETSTG
        // If we just did the first section of the DocSumInfo
        // property set, then attempt the second section

        if( FMTID_DocSummaryInformation == statpropsetstg.fmtid )
        {                                                         
            statpropsetstg.fmtid = FMTID_UserDefinedProperties;
        }
        else
        {
            hr = penumstatpropsetstg->Next( 1, &statpropsetstg, &celt );
            Check( TRUE, S_OK == hr || S_FALSE == hr );
        }
    }

    // We're done with the Property Storage enumerator.
    penumstatpropsetstg->Release();
    penumstatpropsetstg = NULL;

    //  ------------------------------------------
    //  Recursively munge each of the sub-storages
    //  ------------------------------------------

    // Get the IEnumSTATSTG enumerator
    Check(S_OK, pstg->EnumElements( 0L, NULL, 0L, &penumstatstg ));

    // Get the first STATSTG structure.
    hr = penumstatstg->Next( 1, &statstg, &celt );
    Check( TRUE, S_OK == hr || S_FALSE == hr );

    // Loop through the elements of this Storage.
    while( celt > 0 )
    {
        // Is this a sub-Storage which must be
        // munged?

        if( STGTY_STORAGE & statstg.type  // This is a Storage
            &&
            0x20 <= *statstg.pwcsName )   // But not a system Storage.
        {
            // We'll munge it.
            IStorage *psubstg;
            
            // Open the sub-storage.
            Check(S_OK, pstg->OpenStorage( statstg.pwcsName,
                                           NULL,
                                           STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                           NULL,
                                           0L,
                                           &psubstg ));

            // Munge the sub-storage.
            MungeStorage( psubstg );
            psubstg->Release();
            psubstg = NULL;
        }

        CoTaskMemFree(statstg.pwcsName);
        // Move on to the next Storage element.
        hr = penumstatstg->Next( 1, &statstg, &celt );
        Check( TRUE, S_OK == hr || S_FALSE == hr );
    }

    penumstatstg->Release();
    penumstatstg = NULL;


}   // MungeStorage

void
DisplayUsage( LPSTR pszCommand )
{
    printf("\n");
    printf("   Usage:  %s [[options] <test directory>] [file-commands]\n", pszCommand );
    printf("\n");
    printf("   The <test directory> is required in order to run tests, but is\n" );
    printf("   not required for the file-commands.\n" );
    printf("\n");
    printf("   Options:\n" );
    printf("      /w enables the Word 6 compatibility test\n");
    printf("      /iw creates a file for interop test\n");
    printf("      /ir verfies the file created for interop test\n" );    
    printf("\n");
    printf("   File-commands:\n" );
    printf("      /g<file> specifies a file to be munGed\n" );
    printf("          (propsets are read, deleted, & re-written)\n" );
    printf("      /d<file> specifies a file to be Dumped\n" );
    printf("          (propsets are dumped to stdout)\n" );
    printf("\n");
    printf("   Examples:\n" );
    printf("      %s c:\\test\n", pszCommand );
    printf("      %s -iw c:\\test\n", pszCommand );
    printf("      %s -dMyFile.doc\n", pszCommand );
    printf("      %s -gMyFile.doc\n", pszCommand );
    printf("\n");
    return;
}

//
//   Interoperability test
//
//   test_interop_write writes in a doc file
//   test_interop_read reads it in and verifies that it is right.
typedef struct tagInteropTest {
    VARENUM vt;
    void *pv;
} interopStruct;

const int cInteropPROPS=18;

static interopStruct  
avtInterop[cInteropPROPS] = {
    VT_LPSTR, "Title of the document.",                                  
    VT_LPSTR, "Subject of the document.",                                
    VT_LPSTR, "Author of the document.",                                 
    VT_LPSTR, "Keywords of the document.",                               
    VT_LPSTR, "Comments of the document.",                               
    VT_LPSTR, "Normal.dot",                
    VT_LPSTR, "Mr. Unknown",               
    VT_LPSTR, "3",                         
    VT_EMPTY, 0,                           
    VT_EMPTY, 0,                           
    VT_EMPTY, 0,                           
    VT_EMPTY, 0,                           
    VT_I4, (void*) 1,                                                   
    VT_I4, (void*) 7,                                                   
    VT_I4, (void*) 65,                                                  
    VT_EMPTY, 0,                           
    VT_LPSTR, "Reference",                 
    VT_I4, (void*) 1121                            
};


void test_interop_write()
{
    printf( "   Interoperability - write \n" );

    DECLARE_OLESTR(szFile, "t_interop");

    IStorage *pStg;
    Check(S_OK, 
          StgCreateDocfile(szFile, 
                           STGM_CREATE| STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                           (DWORD)NULL, &pStg));

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStg);
    IPropertyStorage *pPropStg;

    Check(S_OK, pPropSetStg->Create(FMTID_SummaryInformation, NULL, 0,
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                    &pPropStg));

    PROPSPEC propspec[cInteropPROPS+2];
    int i;
    for (i=2; i<cInteropPROPS+2; i++)
    {
        propspec[i].ulKind = PRSPEC_PROPID;
        propspec[i].propid = (PROPID)i;
    }

    PROPVARIANT propvar[cInteropPROPS+2];

    for (i=2; i<cInteropPROPS+2; i++)
    {
        propvar[i].vt = avtInterop[i-2].vt;
        switch (avtInterop[i-2].vt)
        {
        case VT_LPSTR:
            propvar[i].pszVal = (char*)avtInterop[i-2].pv;
            break;
        case VT_I4:
            propvar[i].lVal = (int)avtInterop[i-2].pv;
            break;
        default: 
            break;
        }
    }
    Check(S_OK, 
          pPropStg->WriteMultiple(cInteropPROPS, propspec+2, 
                                        propvar+2, 2) );
    pPropStg->Release();
    pStg->Release();
}

void test_interop_read()
{
    printf( "   Interoperability - read \n" );

    DECLARE_OLESTR(szFile, "t_interop");

    IStorage *pStg;
    Check(S_OK, StgOpenStorage(szFile, NULL,
                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &pStg));

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStg);
    IPropertyStorage *pPropStg;

    Check(S_OK, pPropSetStg->Open(FMTID_SummaryInformation,
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READ,
                    &pPropStg));

    PROPSPEC propspec[cInteropPROPS+2];
    int i;
    for (i=2; i<cInteropPROPS+2; i++)
    {
        propspec[i].ulKind = PRSPEC_PROPID;
        propspec[i].propid = (PROPID)i;
    }

    PROPVARIANT propvar[cInteropPROPS+2];

    Check(S_OK, pPropStg->ReadMultiple(cInteropPROPS, propspec+2, propvar+2));

    for (i=2; i<cInteropPROPS+2; i++)
    {
        if ( propvar[i].vt != avtInterop[i-2].vt )
        {
            printf( " PROPTEST: 0x%x retrieved type 0x%x, expected type 0x%x\n",
                    i, propvar[i].vt, avtInterop[i-2].vt );
            ASSERT(propvar[i].vt == avtInterop[i-2].vt);
        }
        
        switch (propvar[i].vt) 
        {
        case VT_LPSTR:
            ASSERT(strcmp(propvar[i].pszVal, (char*)avtInterop[i-2].pv)==0);
            break;
        case VT_I4:
            ASSERT(propvar[i].lVal == (int)avtInterop[i-2].pv);
            break; 
        }
        PropVariantClear(propvar+i);
    }

    pPropStg->Release();
    pStg->Release();
}

void Cleanup()
{
    ULONG ul;
    // Clean up and exit.
    if (_pstgTemp)
    {
        ul = _pstgTemp->Release();
        assert(ul==0 && "_pstgTemp ref counting is wrong!");
    }
    if (_pstgTempCopyTo)
    {
        ul = _pstgTempCopyTo->Release();
        assert( 0 == ul 
           && "_pstgTempCopyTo ref counting is wrong!");
    }
}

int main(int argc, char *argv[])
{
    int nArgIndex;
#ifndef _UNIX
    INIT_OLESTR(oszSummary, "SummaryInformation");
    INIT_OLESTR(aocMap, "abcdefghijklmnopqrstuvwxyz012345");
    INIT_OLESTR( oszDocumentSummary, "DocumentSummaryInformation");
#endif

    ULONG ulTestOptions = 0L;
    BOOL  fOffice97TestDoc = FALSE;
    CHAR* pszFileToMunge = NULL;
    CHAR* pszFileToDump = NULL;

    printf("Property Set Tests\n");

    // Check for command-line switches
    if( 2 > argc )
    {
        printf("Too few arguments\n");
        DisplayUsage( argv[0] );
        exit(0);
    }

    for( nArgIndex = 1; nArgIndex < argc; nArgIndex++ )
    {
        if( argv[nArgIndex][0] == '/'
            ||
            argv[nArgIndex][0] == '-'
          )
        {
            BOOL fNextArgument = FALSE;

            for( int nOptionSubIndex = 1;
                 argv[nArgIndex][nOptionSubIndex] != '\0' && !fNextArgument;
                 nOptionSubIndex++
                )
            {
                switch( argv[nArgIndex][nOptionSubIndex] )
                {                                    
                case 'w':
                case 'W':
                    ulTestOptions |= TEST_WORD6;
                    break;
                    
                case '?':
                    DisplayUsage(argv[0]);
                    exit(1);
                    
                case 'i':    
                    if (argv[nArgIndex][nOptionSubIndex+1]=='w')
                        ulTestOptions |= TEST_INTEROP_W;
                    else if (argv[nArgIndex][nOptionSubIndex+1]=='r')
                        ulTestOptions |= TEST_INTEROP_R;
                    else
                    {
                        DisplayUsage(argv[0]);
                        printf("You must specify 'r' or 'w' for interop!\n");
                        exit(-1);
                    }

                    nOptionSubIndex++;
                    break;                            

                case 'd':
                case 'D':
                    if( NULL != pszFileToDump )
                    {
                        printf( "Error:  Only one file may be dumped\n" );
                        DisplayUsage( argv[0] );
                    }
                    else
                    {
                        pszFileToDump = &argv[nArgIndex][nOptionSubIndex+1];
                        fNextArgument = TRUE;
                    }
                    
                    if( '\0' == *pszFileToDump )
                    {
                        printf( "Error:  Missing filename for dump option\n" );
                        DisplayUsage( argv[0] );
                        exit(1);
                    }
                    break;

                case 'g':
                case 'G':

                    if( NULL != pszFileToMunge )
                    {
                        printf( "Error:  Only one file may be munged\n" );
                        DisplayUsage( argv[0] );
                        exit(1);
                    }
                    else
                    {
                        pszFileToMunge = &argv[nArgIndex][nOptionSubIndex+1];
                        fNextArgument = TRUE;
                    }
                    
                    if( '\0' == *pszFileToMunge )
                    {
                        printf( "Error:  Missing filename for munge option\n" );
                        DisplayUsage( argv[0] );
                        exit(1);
                    }
                    break;
                    
                default:
                    printf( "Option '%c' ignored\n", 
                            argv[nArgIndex][nOptionSubIndex] );
                    break;

                }   // switch( argv[nArgIndex][1] )

            }   // for( int nOptionSubIndex = 1; ...
        }   // if( argv[nArgIndex][0] == '/'
        else
        {
            break;
        }
    }   // for( ULONG nArgIndex = 2; nArgIndex < argc; nArgIndex++ )


    // If any other command-line parameters were given, ignore them.

    for( int nExtraArg = nArgIndex+1; nExtraArg < argc; nExtraArg++ )
    {
        printf( "Illegal argument ignored:  %s\n", argv[nExtraArg] );
    }

    OLECHAR ocsFile[256], ocsTest[256], ocsTest2[256], ocsTestOffice[256];
    CHAR szDir[256];
    HRESULT hr;
    IStorage *pstg;

    int i=0;

    if ( NULL != pszFileToDump )
    {
        printf("DUMPING: %s\n", pszFileToDump);
        printf("========================\n");        
        STOT( pszFileToDump, ocsFile, strlen(pszFileToDump)+1 );
        Check(S_OK, StgOpenStorage( ocsFile,
                                    (IStorage*)NULL,
                                    (DWORD)STGM_DIRECT | STGM_READWRITE | 
                                    STGM_SHARE_EXCLUSIVE,
                                    NULL,
                                    0L,
                                    &pstg ));
        DumpOleStorage( pstg, ocsFile );
        Check(0, pstg->Release()); // ensure we released the last reference
        exit(0);
    }

    // Is there a file to munge?
    if ( NULL != pszFileToMunge )
    {
        STOT(pszFileToMunge, ocsFile, strlen(pszFileToMunge)+1 );
        Check(S_OK, StgOpenStorage( ocsFile,
                                    NULL,
                                    (DWORD) STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                    NULL,
                                    0L,
                                    &pstg ));
        MungeStorage( pstg );
        PrintOC(ocsFile);
        printf( " successfully munged\n");
        Check(0, pstg->Release());
        exit(0);
    }

    // Verify that the user provided a directory path.

    if (nArgIndex >= argc)
    {
        printf( "Test directory not provided on command-line\n" );
        DisplayUsage( argv[0] );
        exit(1);
    }

    // Verify that the user-provided directory path
    // exists

    struct _stat filestat;
    if (_stat(argv[nArgIndex], &filestat)!=0 || 
        !(filestat.st_mode && S_IFDIR))
    {
        printf("Error in opening %s as a directory", argv[nArgIndex] );
        exit(1);
    }

#ifdef _WIN32  // don't bother to create a directory for test files on UNIX
               // since there are some problems with creating files with 
               // path names

    if (!(ulTestOptions & TEST_INTEROP_R) && !(ulTestOptions & TEST_INTEROP_W))
    {
        // Find an new directory name to use for temporary
        // files ("testdirX", where "X" is a number).
        do
        {
            strcpy(szDir, argv[nArgIndex]);
            sprintf(strchr(szDir,0), "\\testdir%d", i++);
        } while ( (_mkdir(szDir, 0x744) == -1) && (i<20) );      
    
        if (i>=20) 
        {
            printf("Too many testdirX subdirectories, delete some and re-run\n");
            exit(-1);
        }
    }
    else 
    {
        // use current directory for interop testing
        szDir[0] = '.';
        szDir[1] = 0;
    }
#endif


#ifdef _WIN32
    printf( "Generated files will be put in \"%s\"\n", szDir );
    // Create "tesdoc"
    STOT(szDir, ocsFile, strlen(szDir)+1);

    ocscpy(ocsTest, ocsFile);
    DECLARE_OLESTR(ocsTestDoc, "\\testdoc");
    ocscat(ocsTest, ocsTestDoc);
#else
    DECLARE_OLESTR(ocsTestDoc, "testdoc");
    ocscpy(ocsTest, ocsTestDoc);
#endif

    hr = StgCreateDocfile(ocsTest, STGM_DIRECT | STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                          0, &_pstgTemp);
    if (hr != S_OK)
    {
        printf("Can't create %s\n", ocsTest);
        exit(1);
    }

    // Create "testdoc2"
#ifdef _WIN32
    DECLARE_OLESTR(ocsTestDoc2,"\\testdoc2");
    ocscpy(ocsTest2, ocsFile);
    ocscat(ocsTest2, ocsTestDoc2); 
#else
    DECLARE_OLESTR(ocsTestDoc2,"testdoc2");
    ocscpy(ocsTest2, ocsTestDoc2);
#endif

    hr = StgCreateDocfile(ocsTest2, STGM_CREATE | STGM_READWRITE |
                          STGM_SHARE_EXCLUSIVE,
                          0, &_pstgTempCopyTo);
    if (hr != S_OK)
    {
        printf("Can't create %ls\n", ocsTest);
        exit(1);
    }

    Check(S_OK, PopulateRGPropVar( g_rgcpropvarAll, g_rgcpropspecAll ));

    printf( "\nStandard Tests\n" );
    printf(   "--------------\n" );

    test_WriteReadAllProperties(ulTestOptions);

    test_PropertyInterfaces(_pstgTemp);

    // test with Unicode, then ansi files

    test_CodePages(ocsFile, ulTestOptions, TRUE);
    test_CodePages(ocsFile, ulTestOptions, FALSE);     

    // Test the IStorage::CopyTo operation, using all combinations of 
    // direct and transacted mode for the base and PropSet storages.

    for( int iteration = 0; iteration < 4; iteration++ )
    {
        DECLARE_OLESTR(aocStorageName, "#0 Test CopyTo");
        aocStorageName[1] = (OLECHAR) iteration + (OLECHAR)'0';

        test_CopyTo( _pstgTemp, _pstgTempCopyTo,
                     STGM_DIRECT,
                     STGM_DIRECT,
                     aocStorageName );
    }


    // Generate the stock ticker property set example
    // from the OLE programmer's reference spec.
    test_OLESpecTickerExample( _pstgTemp );

#ifdef _WIN32
    ocscpy(ocsTestOffice, ocsFile);
    DECLARE_OLESTR(ocsOffice, "\\Office");
    ocscat(ocsTestOffice, ocsOffice);
#else
    DECLARE_OLESTR(ocsOffice, "Office");
    ocscpy(ocsTestOffice, ocsOffice);
#endif

    test_Office( ocsTestOffice );
    test_PropVariantValidation( _pstgTemp );
    test_PropVariantCopy();

    if( ulTestOptions )
    {
        printf( "\nOptional Tests\n" );
        printf(   "--------------\n" );

        // If requested, test for compatibility with Word 6.0 files.

        if ( ulTestOptions & TEST_WORD6 )
            test_Word6(_pstgTemp);

        if ( ulTestOptions & TEST_INTEROP_W)
        {
            test_interop_write();
        }
        if ( ulTestOptions & TEST_INTEROP_R)
        {
            test_interop_read();
        }

    }   // if( ulTestOptions )

    Cleanup();

    printf("\nPASSED\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\proptest\testdoc.cxx ===
unsigned char g_achTestDoc[] = {
    0xd0,0xcf,0x11,0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x03,0x00,0xfe,0xff,0x09,0x00,//........>.......
    0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x03,0x00,0x00,0x00,//................
    0x01,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x52,0x00,0x6f,0x00,0x6f,0x00,0x74,0x00,0x20,0x00,0x45,0x00,0x6e,0x00,0x74,0x00,//R.o.o.t. .E.n.t.
    0x72,0x00,0x79,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//r.y.............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x16,0x00,0x05,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x03,0x00,0x00,0x00,//................
    0x00,0x09,0x02,0x00,0x00,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,//...............F
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x7f,0xd9,0x7b,//............P..{
    0x1a,0x05,0xba,0x01,0x06,0x00,0x00,0x00,0x40,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,//........@.......
    0x01,0x00,0x43,0x00,0x6f,0x00,0x6d,0x00,0x70,0x00,0x4f,0x00,0x62,0x00,0x6a,0x00,//..C.o.m.p.O.b.j.
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x12,0x00,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//........n.......
    0x57,0x00,0x6f,0x00,0x72,0x00,0x64,0x00,0x44,0x00,0x6f,0x00,0x63,0x00,0x75,0x00,//W.o.r.d.D.o.c.u.
    0x6d,0x00,0x65,0x00,0x6e,0x00,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//m.e.n.t.........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x1a,0x00,0x02,0x01,0xff,0xff,0xff,0xff,0x04,0x00,0x00,0x00,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0xb5,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x4f,0x00,0x62,0x00,0x6a,0x00,0x65,0x00,0x63,0x00,0x74,0x00,0x50,0x00,0x6f,0x00,//O.b.j.e.c.t.P.o.
    0x6f,0x00,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//o.l.............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x16,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x81,0x8f,0x87,0x7a,0x04,0xba,0x01,0x00,0x81,0x8f,0x87,//........z.......
    0x7a,0x04,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//z...............
    0x02,0x00,0x00,0x00,0xfd,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,//................
    0x07,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x08,0x00,0x00,0x00,//................
    0x09,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x05,0x00,0x53,0x00,0x75,0x00,0x6d,0x00,0x6d,0x00,0x61,0x00,0x72,0x00,0x79,0x00,//..S.u.m.m.a.r.y.
    0x49,0x00,0x6e,0x00,0x66,0x00,0x6f,0x00,0x72,0x00,0x6d,0x00,0x61,0x00,0x74,0x00,//I.n.f.o.r.m.a.t.
    0x69,0x00,0x6f,0x00,0x6e,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//i.o.n...........
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x28,0x00,0x02,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//(...............
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0xdd,0x01,0x00,0x00,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x01,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,//................
    0x05,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x08,0x00,0x00,0x00,//................
    0x09,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x0c,0x00,0x00,0x00,//................
    0x0d,0x00,0x00,0x00,0x0e,0x00,0x00,0x00,0x17,0x00,0x00,0x00,0x10,0x00,0x00,0x00,//................
    0x11,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x13,0x00,0x00,0x00,0x14,0x00,0x00,0x00,//................
    0x15,0x00,0x00,0x00,0x16,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,0x18,0x00,0x00,0x00,//................
    0x19,0x00,0x00,0x00,0x1a,0x00,0x00,0x00,0x1b,0x00,0x00,0x00,0x1c,0x00,0x00,0x00,//................
    0x1d,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x1f,0x00,0x00,0x00,0x20,0x00,0x00,0x00,//............ ...
    0x21,0x00,0x00,0x00,0x22,0x00,0x00,0x00,0x23,0x00,0x00,0x00,0x24,0x00,0x00,0x00,//!..."...#...$...
    0x25,0x00,0x00,0x00,0x26,0x00,0x00,0x00,0x27,0x00,0x00,0x00,0x28,0x00,0x00,0x00,//%...&...'...(...
    0x29,0x00,0x00,0x00,0x2a,0x00,0x00,0x00,0x2b,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,//)...*...+...,...
    0x2d,0x00,0x00,0x00,0x2e,0x00,0x00,0x00,0x2f,0x00,0x00,0x00,0x30,0x00,0x00,0x00,//-......./...0...
    0x31,0x00,0x00,0x00,0x32,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x34,0x00,0x00,0x00,//1...2...3...4...
    0x35,0x00,0x00,0x00,0x36,0x00,0x00,0x00,0x37,0x00,0x00,0x00,0x38,0x00,0x00,0x00,//5...6...7...8...
    0x39,0x00,0x00,0x00,0x3a,0x00,0x00,0x00,0x3b,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,//9...:...;...<...
    0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x02,0x00,0x00,0x00,0xab,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0xca,0x00,0x00,0x00,//................
    0x05,0x00,0x00,0x00,0xeb,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x0d,0x01,0x00,0x00,//................
    0x04,0x00,0x00,0x00,0x2f,0x01,0x00,0x00,0x08,0x00,0x00,0x00,0x4f,0x01,0x00,0x00,//..../.......O...
    0x01,0x00,0x00,0x00,0x62,0x01,0x00,0x00,0x0f,0x00,0x00,0x00,0x68,0x01,0x00,0x00,//....b.......h...
    0x10,0x00,0x00,0x00,0x70,0x01,0x00,0x00,0x12,0x00,0x00,0x00,0x78,0x01,0x00,0x00,//....p.......x...
    0x0e,0x00,0x00,0x00,0x93,0x01,0x00,0x00,0x09,0x00,0x00,0x00,0x9b,0x01,0x00,0x00,//................
    0x13,0x00,0x00,0x00,0xa5,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,//................
    0x4e,0x6f,0x72,0x6d,0x61,0x6c,0x2e,0x64,0x6f,0x74,0x00,0x1e,0x00,0x00,0x00,0x17,//Normal.dot......
    0x00,0x00,0x00,0x54,0x69,0x74,0x6c,0x65,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,//...Title of the 
    0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,0x00,0x00,0x00,0x19,0x00,//document........
    0x00,0x00,0x53,0x75,0x62,0x6a,0x65,0x63,0x74,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,//..Subject of the
    0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,0x00,0x00,0x00,0x1a,// document.......
    0x00,0x00,0x00,0x4b,0x65,0x79,0x77,0x6f,0x72,0x64,0x73,0x20,0x6f,0x66,0x20,0x74,//...Keywords of t
    0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,0x00,0x00,//he document.....
    0x00,0x1a,0x00,0x00,0x00,0x43,0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x73,0x20,0x6f,0x66,//.....Comments of
    0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,// the document...
    0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x41,0x75,0x74,0x68,0x6f,0x72,0x20,0x6f,0x66,//.......Author of
    0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,// the document...
    0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x42,0x69,0x6c,0x6c,0x20,0x4d,0x6f,0x72,0x65,//.......Bill More
    0x6c,0x00,0x02,0x00,0x00,0x00,0xe4,0x04,0x03,0x00,0x00,0x00,0x07,0x00,0x00,0x00,//l...............
    0x03,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x13,0x00,0x00,0x00,//....A...........
    0x4d,0x69,0x63,0x72,0x6f,0x73,0x6f,0x66,0x74,0x20,0x57,0x6f,0x72,0x64,0x20,0x36,//Microsoft Word 6
    0x2e,0x30,0x00,0x03,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x02,//.0..............
    0x00,0x00,0x00,0x33,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd0,0xcf,0x11,//...3............
    0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x03,0x00,0xfe,0xff,0x09,0x00,0x06,0x00,0x00,//.....>..........
    0x73,0x64,0x66,0x6f,0x69,0x68,0x73,0x64,0x66,0x0d,0xff,0xff,0xff,0xff,0xff,0xff,//sdfoihsdf.......
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x03,0x00,0x01,0x00,//................
    0x01,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x52,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..R.............
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,//..j.......j.....
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..j.............
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..j.............
    0x00,0x00,0x08,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x08,0x00,0x00,0x08,0x00,//..........~.....
    0x00,0x00,0x86,0x08,0x00,0x00,0x0e,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,//..........j.....
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,//..j.......j.....
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..j.............
    0x00,0x00,0x08,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x2a,0x00,//..............*.
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x46,0x6f,0x6f,0x20,0x42,0x61,0x72,0x0d,0x0d,0x73,0x64,0x66,0x6b,0x6a,0x68,0x73,//Foo Bar..sdfkjhs
    0x64,0x66,0x6b,0x6a,0x68,0x73,0x64,0x66,0x20,0x0d,0x73,0x20,0x64,0x6a,0x6b,0x73,//dfkjhsdf .s djks
    0x61,0x66,0x64,0x6c,0x6a,0x73,0x61,0x66,0x64,0x0d,0x73,0x64,0x66,0x6c,0x6b,0x68,//afdljsafd.sdflkh
    0x6a,0x73,0x66,0x61,0x64,0x6c,0x68,0x73,0x66,0x61,0x64,0x0d,0x73,0x64,0x66,0x68,//jsfadlhsfad.sdfh
    0xfe,0xff,0x00,0x00,0x03,0x33,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//.....3..........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xe0,0x85,0x9f,0xf2,//................
    0xf9,0x4f,0x68,0x10,0xab,0x91,0x08,0x00,0x2b,0x27,0xb3,0xd9,0x30,0x00,0x00,0x00,//.Oh.....+'..0...
    0xad,0x01,0x00,0x00,0x0e,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x98,0x00,0x00,0x00,//................
    0x01,0x00,0xfe,0xff,0x03,0x0a,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x09,0x02,0x00,//................
    0x00,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x1c,0x00,0x00,0x00,//...........F....
    0x4d,0x69,0x63,0x72,0x6f,0x73,0x6f,0x66,0x74,0x20,0x57,0x6f,0x72,0x64,0x20,0x36,//Microsoft Word 6
    0x2e,0x30,0x20,0x44,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x00,0x0a,0x00,0x00,0x00,//.0 Document.....
    0x4d,0x53,0x57,0x6f,0x72,0x64,0x44,0x6f,0x63,0x00,0x10,0x00,0x00,0x00,0x57,0x6f,//MSWordDoc.....Wo
    0x72,0x64,0x2e,0x44,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x36,0x00,0xf4,0x39,//rd.Document.6..9
    0xb2,0x71,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd0,0xcf,//.q..............
    0x11,0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xdc,0xa5,0x68,0x00,0x45,0xc0,0x09,0x04,0x00,0x00,0x24,0x00,0x65,0x00,0x00,0x00,//..h.E.....$.e...
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x09,0x03,0x00,0x00,//................
    0xb5,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//....J...........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x6a,0x00,0x00,0x00,//............j...
    0x00,0x08,0x00,0x00,0x6a,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//....j...j.......
    0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//j.......j.......
    0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x14,0x00,0x00,0x00,//j.......j.......
    0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x94,0x08,0x00,0x00,0x36,0x00,0x00,0x00,//............6...
    0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xca,0x08,0x00,0x00,0x0a,0x00,0x00,0x00,//................
    0xd4,0x08,0x00,0x00,0x0a,0x00,0x00,0x00,0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x97,0x0b,0x00,0x00,0x31,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//....1...........
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x09,0x00,0x00,0x02,0x00,0x00,0x00,//................
    0x0a,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x09,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x0a,0x09,0x00,0x00,0x52,0x00,0x00,0x00,0x5c,0x09,0x00,0x00,0xec,0x00,0x00,0x00,//....R...\.......
    0x48,0x0a,0x00,0x00,0xec,0x00,0x00,0x00,0x34,0x0b,0x00,0x00,0x1e,0x00,0x00,0x00,//H.......4.......
    0xc8,0x0b,0x00,0x00,0x58,0x00,0x00,0x00,0x20,0x0c,0x00,0x00,0x95,0x00,0x00,0x00,//....X... .......
    0x52,0x0b,0x00,0x00,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//R...E...........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//........j.......
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x03,0x00,0x00,0x09,0x03,0x00,0x00,0x19,0x03,0x00,0x00,0x4a,0x03,0x00,0x00,//............J...
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,//................
    0x00,0x03,0x00,0x00,0x08,0x03,0x00,0x00,0x09,0x03,0x00,0x00,0x1a,0x03,0x00,0x00,//................
    0x2a,0x03,0x00,0x00,0x3c,0x03,0x00,0x00,0x4a,0x03,0x00,0x00,0xfe,0x00,0x01,0xc0,//*...<...J.......
    0x21,0xf0,0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,//!......!......!.
    0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,0x00,0xfe,//.....!......!...
    0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...!............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x06,//................
    0x0e,0x00,0x0f,0x00,0x08,0x00,0x01,0x00,0x4b,0x00,0x0f,0x00,0x00,0x00,0x00,0x00,//........K.......
    0x1a,0x00,0x00,0x40,0xf1,0xff,0x02,0x00,0x1a,0x00,0x06,0x4e,0x6f,0x72,0x6d,0x61,//...@.......Norma
    0x6c,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x61,0x09,0x04,0x00,0x00,0x00,0x00,0x00,//l.......a.......
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x00,//..............".
    0x41,0x40,0xf2,0xff,0xa1,0x00,0x22,0x00,0x16,0x44,0x65,0x66,0x61,0x75,0x6c,0x74,//A@...."..Default
    0x20,0x50,0x61,0x72,0x61,0x67,0x72,0x61,0x70,0x68,0x20,0x46,0x6f,0x6e,0x74,0x00,// Paragraph Font.
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4a,0x00,//..............J.
    0x00,0x00,0x02,0x00,0xff,0xff,0xff,0xff,0x02,0x00,0xff,0xff,0xff,0xff,0x01,0x00,//................
    0x04,0x20,0xff,0xff,0x01,0x00,0x00,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00,0x00,//. ........J.....
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x28,0x00,0x00,0x00,//............(...
    0x3a,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00,0x01,0xc0,0x21,//:...H...J......!
    0xf0,0x00,0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x01,//.....!.....!....
    0xc0,0x21,0xf0,0x00,0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x03,0x00,0x00,0x4a,0x03,//.!.....!......J.
    0x00,0x00,0x02,0x00,0x00,0x03,0x00,0x00,0x4a,0x03,0x00,0x00,0x03,0x00,0x2a,0x00,//........J.....*.
    0x0a,0x42,0x69,0x6c,0x6c,0x20,0x4d,0x6f,0x72,0x65,0x6c,0x1c,0x43,0x3a,0x5c,0x75,//.Bill Morel.C:\u
    0x73,0x65,0x72,0x73,0x5c,0x64,0x65,0x66,0x61,0x75,0x6c,0x74,0x5c,0x74,0x65,0x73,//sers\default\tes
    0x74,0x64,0x6f,0x63,0x2e,0x64,0x6f,0x63,0xff,0x40,0x5c,0x5c,0x4d,0x53,0x50,0x52,//tdoc.doc.@\\MSPR
    0x49,0x4e,0x54,0x33,0x35,0x5c,0x31,0x2f,0x31,0x30,0x34,0x39,0x20,0x43,0x4f,0x52,//INT35\1/1049 COR
    0x50,0x41,0x20,0x31,0x34,0x31,0x42,0x39,0x37,0x00,0x4e,0x65,0x30,0x30,0x3a,0x00,//PA 141B97.Ne00:.
    0x77,0x69,0x6e,0x73,0x70,0x6f,0x6f,0x6c,0x00,0x48,0x50,0x20,0x4c,0x61,0x73,0x65,//winspool.HP Lase
    0x72,0x4a,0x65,0x74,0x20,0x49,0x49,0x49,0x53,0x69,0x20,0x50,0x6f,0x73,0x74,0x53,//rJet IIISi PostS
    0x63,0x72,0x69,0x70,0x74,0x20,0x76,0x35,0x32,0x2e,0x33,0x00,0x5c,0x5c,0x4d,0x53,//cript v52.3.\\MS
    0x50,0x52,0x49,0x4e,0x54,0x33,0x35,0x5c,0x31,0x2f,0x31,0x30,0x34,0x39,0x20,0x43,//PRINT35\1/1049 C
    0x4f,0x52,0x50,0x41,0x20,0x31,0x34,0x31,0x42,0x39,0x37,0x00,0x20,0x03,0x50,0x03,//ORPA 141B97. .P.
    0x7c,0x00,0x70,0x00,0x13,0xdd,0x01,0x00,0x01,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,//|.p...........o.
    0x64,0x00,0x01,0x00,0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,//d.....,.........
    0x00,0x00,0x4c,0x65,0x74,0x74,0x65,0x72,0x00,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,//..Letter......o.
    0x64,0x00,0x01,0x00,0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,//d.....,.........
    0x00,0x00,0x4c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//..L.............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x52,0x49,0x56,0x20,0x00,0x00,0x00,//........PRIV ...
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x18,0x00,0x00,0x00,0x00,0x00,0x20,0x4e,0x20,0x4e,0x20,0x4e,0x00,0x00,0x10,0x27,//...... N N N...'
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5c,0x5c,0x4d,0x53,0x50,0x52,0x49,0x4e,//........\\MSPRIN
    0x54,0x33,0x35,0x5c,0x31,0x2f,0x31,0x30,0x34,0x39,0x20,0x43,0x4f,0x52,0x50,0x41,//T35\1/1049 CORPA
    0x20,0x31,0x34,0x31,0x42,0x39,0x37,0x00,0x20,0x03,0x50,0x03,0x7c,0x00,0x70,0x00,// 141B97. .P.|.p.
    0x13,0xdd,0x01,0x00,0x01,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,0x64,0x00,0x01,0x00,//..........o.d...
    0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x4c,0x65,//..,...........Le
    0x74,0x74,0x65,0x72,0x00,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,0x64,0x00,0x01,0x00,//tter......o.d...
    0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x4c,0x00,//..,...........L.
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x50,0x52,0x49,0x56,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//....PRIV .......
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,//................
    0x00,0x00,0x20,0x4e,0x20,0x4e,0x20,0x4e,0x00,0x00,0x10,0x27,0x00,0x00,0x00,0x00,//.. N N N...'....
    0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x00,0x48,0x00,0x00,0x00,0x48,0x00,0x00,0x00,//........H...H...
    0x08,0x00,0x01,0x00,0x01,0x00,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0x00,//......H.........
    0x00,0x00,0x02,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x17,//...@............
    0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x49,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x21,//...H...I...J...!
    0x00,0x09,0x03,0x00,0x00,0x00,0x00,0x21,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x20,//.......!....... 
    0x00,0x19,0x03,0x00,0x00,0x00,0x00,0x20,0x00,0x07,0x03,0x00,0x00,0x00,0x00,0x20,//....... ....... 
    0x00,0x08,0x03,0x00,0x00,0x00,0x00,0x31,0x00,0x15,0x16,0x90,0x01,0x00,0x00,0x54,//.......1.......T
    0x69,0x6d,0x65,0x73,0x20,0x4e,0x65,0x77,0x20,0x52,0x6f,0x6d,0x61,0x6e,0x00,0x0c,//imes New Roman..
    0x16,0x90,0x01,0x02,0x00,0x53,0x79,0x6d,0x62,0x6f,0x6c,0x00,0x0b,0x26,0x90,0x01,//.....Symbol..&..
    0x00,0x00,0x41,0x72,0x69,0x61,0x6c,0x00,0x22,0x00,0x04,0x00,0x31,0x08,0x8a,0x18,//..Arial."...1...
    0x00,0x00,0xd0,0x02,0x00,0x00,0x68,0x01,0x00,0x00,0x00,0x00,0x40,0x34,0xf4,0x85,//......h.....@4..
    0x05,0x3b,0xf4,0xa5,0x04,0x3b,0xf4,0xa5,0x03,0x00,0x03,0x00,0x00,0x00,0x07,0x00,//.;...;..........
    0x00,0x00,0x41,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x83,0x10,//..A.............
    0x05,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x01,0x00,0x04,0x00,//........A.......
    0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x74,0x03,0x00,0x00,0x00,0x00,//..........t.....
    0x95,0x00,0x00,0x00,0x16,0x54,0x69,0x74,0x6c,0x65,0x20,0x6f,0x66,0x20,0x74,0x68,//.....Title of th
    0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x18,0x53,0x75,0x62,0x6a,//e document..Subj
    0x65,0x63,0x74,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,//ect of the docum
    0x65,0x6e,0x74,0x2e,0x19,0x4b,0x65,0x79,0x77,0x6f,0x72,0x64,0x73,0x20,0x6f,0x66,//ent..Keywords of
    0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x19,0x43,// the document..C
    0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x73,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x64,//omments of the d
    0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x17,0x41,0x75,0x74,0x68,0x6f,0x72,0x20,//ocument..Author 
    0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,//of the document.
    0x0a,0x42,0x69,0x6c,0x6c,0x20,0x4d,0x6f,0x72,0x65,0x6c,0x00,0x00,0x00,0x00,0x00,//.Bill Morel.....
    0x00,0x00,0x00,0x00,0x00,0xd0,0xcf,0x11,0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff //................
};

unsigned int g_cbTestDoc = sizeof(g_achTestDoc)/sizeof(g_achTestDoc[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\reftest\reftest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	reftest.cxx
//
//  Contents:	Reference tests
//
//  Classes:	
//
//  Functions:	
//
//----------------------------------------------------------------------------
#ifdef _MSC_VER
#define INITGUID
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "../../h/storage.h"

// enable debugging features of memory allocation
#include "../../h/dbg.hxx"

#ifdef _MSC_VER
#undef INITGUID
#endif

#include "refilb.hxx"

#ifndef _WIN32 
#include <unistd.h>
#else
#include <io.h>
#endif

#define STGP(x) STGM_SHARE_EXCLUSIVE | x
#define STMP(x) STGM_SHARE_EXCLUSIVE | x
#define ROOTP(x) STGP(x)

#define EXIT_BADSC 1

int g_fTestInterop = 0;

#define olHChk(e) \
     if FAILED(sc = e) \
         goto EH_Err

#define olChk(e) olHChk(e)

#include <assert.h>
#define olAssert assert

#ifdef NDEBUG
#define verify(exp) 1
#else
#define verify(exp) assert(exp)
#endif

#define ULIGetLow(ui) (ui.LowPart)

//
// some global variables used by all the tests
//
OLECHAR ocsDRT   [ sizeof("drt.dfl")+1 ];
OLECHAR ocsChild [ sizeof("Child")  +1 ];
OLECHAR ocsChild1[ sizeof("Child1") +1 ];
OLECHAR ocsChild2[ sizeof("Child2") +1 ];
OLECHAR ocsStream[ sizeof("Stream") +1 ];
OLECHAR ocsRenamedStream[ sizeof("RenamedStream") +1 ];
OLECHAR ocsRenamedChild[ sizeof("RenamedChild") +1 ];

void error(int code, char *fmt, ...)
{
    va_list args;
    
    args = va_start(args, fmt);
    printf("** Fatal error **: ");
    vprintf(fmt, args);    
    va_end(args);
    exit(code);
}


BOOL IsEqualTime(FILETIME ttTime, FILETIME ttCheck)
{
    return ttTime.dwLowDateTime == ttCheck.dwLowDateTime &&
        ttTime.dwHighDateTime == ttCheck.dwHighDateTime;
}


SCODE t_create(BOOL fTestStorage, BOOL fLarge)
{
    IStorage *pstgRoot, *pstgChild, *pstgChild2;
    IStream *pstm;
    SCODE sc;
    ILockBytes *pilb=NULL;
    
    if (!fTestStorage)
    {
       printf("Testing Create ILB\n");

       pilb = new CFileILB(ocsDRT, (DWORD)NULL);
       if (pilb == NULL)
           error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
       
       //  create a storage on the ILockBytes
       olHChk( StgCreateDocfileOnILockBytes( pilb, 
                                            STGM_READWRITE | 
                                            STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                            0, &pstgRoot));
    }
    else if (fLarge)
    {
       STGOPTIONS stgoptions;
       stgoptions.usVersion = STGOPTIONS_VERSION;
       stgoptions.reserved = 0;
       stgoptions.ulSectorSize = 4096;
       stgoptions.pwcsTemplateFile = NULL;

       printf("Testing Create large storage\n");
       olHChk(StgCreateStorageEx ( ocsDRT, 
			       STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                   STGFMT_DOCFILE,
                   0, &stgoptions, 
			       0, IID_IStorage, (void **) &pstgRoot));
    }
    else
    {
       printf("Testing Create storage\n");
       olHChk(StgCreateDocfile(ocsDRT,
                   STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                   0, &pstgRoot));
    }
    
    olHChk(pstgRoot->CreateStorage(ocsChild, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    
    olHChk(pstgChild->CreateStorage(ocsChild2, STGP(STGM_READWRITE), 0, 0,
                                    &pstgChild2));
    
    olHChk(pstgChild2->CreateStream(ocsStream, STMP(STGM_READWRITE), 0, 0,
                                    &pstm));
    
    pstm->Release();
    olHChk(pstgChild2->Commit(0));
    pstgChild2->Release();
    
    olHChk(pstgChild->Commit(0));
    pstgChild->Release();
    
    pstgRoot->Release();
    if (pilb) pilb->Release();
    
EH_Err:
    return sc;
}

SCODE t_open(BOOL fTestStorage, BOOL fLarge)
{
    SCODE sc;
    IStorage *pstgRoot, *pstgChild, *pstgChild2;
    IStream *pstm;
    ILockBytes *pilb=NULL;
    if (!fTestStorage)
    {
       printf("Testing Open ILB\n");
       pilb = new CFileILB(ocsDRT, (DWORD)NULL);
       if (pilb == NULL)
	  error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
       
       //  create a storage on the ILockBytes
       olHChk(StgCreateDocfileOnILockBytes(pilb,
					   STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
					   0, &pstgRoot));
    }
    else if (fLarge)
    {
       STGOPTIONS stgoptions;
       stgoptions.usVersion = STGOPTIONS_VERSION;
       stgoptions.reserved = 0;
       stgoptions.ulSectorSize = 4096;
       stgoptions.pwcsTemplateFile = NULL;

       printf("Testing Open large storage\n");
       olHChk(StgCreateStorageEx ( ocsDRT,
                   STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                   STGFMT_DOCFILE,
                   0, &stgoptions,
                   0, IID_IStorage, (void **) &pstgRoot));
    }
    else 
    {
        //  create a storage
        printf("Testing Open storage\n");
        olHChk(StgCreateDocfile(ocsDRT, 
                                STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                0, &pstgRoot));				
    }
    
    olHChk(pstgRoot->CreateStorage(ocsChild, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    olHChk(pstgChild->CreateStorage(ocsChild2, STGP(STGM_READWRITE), 0, 0,
                                    &pstgChild2));
    olHChk(pstgChild2->CreateStream(ocsStream, STMP(STGM_READWRITE), 0, 0,
                                    &pstm));
    pstm->Release();
    pstgChild2->Release();
    pstgChild->Release();
    
    olHChk(pstgRoot->Commit(0));
    pstgRoot->Release();

    if (!fTestStorage)
    {
        olHChk(StgOpenStorageOnILockBytes(pilb, NULL,
                                          ROOTP(STGM_READWRITE), NULL, 0, &pstgRoot));
    }
    else 
    {
        olHChk(StgOpenStorage(ocsDRT,			
                              NULL, ROOTP(STGM_READWRITE), NULL, 0,
                              &pstgRoot));
    }
    
    olHChk(pstgRoot->OpenStorage(
        ocsChild,
        NULL,
        STGP(STGM_READWRITE),
        NULL,
        0,
        &pstgChild));
    
    olHChk(pstgChild->OpenStorage(
        ocsChild2,
        NULL,
        STGP(STGM_READWRITE),
        NULL,
        0,
        &pstgChild2));
    
    olHChk(pstgChild2->OpenStream(
        ocsStream,
        NULL,
        STMP(STGM_READWRITE),
        0,
        &pstm));
    
    pstm->Release();
    pstgChild2->Release();
    pstgChild->Release();
    pstgRoot->Release();
    if (pilb) pilb->Release();
    
EH_Err:
    return sc;
}  // t_open



SCODE t_addref(BOOL fTestStorage, BOOL fLarge)
{
    SCODE sc;
    IStorage *pstg;
    IStream *pstm;
    ULONG ul;
    ILockBytes *pilb=NULL;
    
    if (!fTestStorage)
    {
		printf("Testing Addref ILB\n");
        pilb = new CFileILB(ocsDRT, (DWORD)NULL);
        if (pilb == NULL)
            error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
        
        //  create a storage on the ILockBytes    
        olHChk(StgCreateDocfileOnILockBytes(pilb,
                                            STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                            0, &pstg));
    }
    else if (fLarge)
    {
       STGOPTIONS stgoptions;
       stgoptions.usVersion = STGOPTIONS_VERSION;
       stgoptions.reserved = 0;
       stgoptions.ulSectorSize = 4096;
       stgoptions.pwcsTemplateFile = NULL;

       printf("Testing AddRef large storage\n");
       olHChk(StgCreateStorageEx ( ocsDRT,
                   STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                   STGFMT_DOCFILE,
                   0, &stgoptions,
                   0, IID_IStorage, (void **) &pstg));
    }
    else 
    {
		printf("Testing Addref Storage\n");
        olHChk(StgCreateDocfile(ocsDRT,
                                STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                0, &pstg));
    }
    
    olHChk(pstg->CreateStream( ocsStream, STMP(STGM_READWRITE),
                               0, 0, &pstm));
    
    if ((ul = pstm->AddRef()) != 2)
        error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstm->Release()) != 1)
        error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    pstm->Release();
    if ((ul = pstg->AddRef()) != 2)
        error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstg->Release()) != 1)
        error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    
    pstg->Release();
    if (pilb) pilb->Release();
EH_Err:
    return sc;
} // t_addref

SCODE t_dmodify(BOOL fTestStorage, BOOL fLarge)
{
    SCODE sc;
    IStorage *pstgRoot, *pstgChild, *pstgChild2;
    IStream *pstm;
    ILockBytes *pilb=NULL;

    DECLARE_OLESTR(ocs88, "88");
    DECLARE_OLESTR(ocs84, "84");
    DECLARE_OLESTR(ocs92, "92");
    DECLARE_OLESTR(ocs64, "64");
    DECLARE_OLESTR(ocs32, "32");
    DECLARE_OLESTR(ocs96, "96");
    DECLARE_OLESTR(ocs80, "80");
    
    if (!fTestStorage)
    {
		printf("Testing Modify ILB\n");
        pilb = new CFileILB(ocsDRT, (DWORD)NULL);
        if (pilb == NULL)
            error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
	
        //  create a storage on the ILockBytes  
        olHChk(StgCreateDocfileOnILockBytes(pilb, 
                                            STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 
                                            0, &pstgRoot));
    }
    else if (fLarge)
    {
       STGOPTIONS stgoptions;
       stgoptions.usVersion = STGOPTIONS_VERSION;
       stgoptions.reserved = 0;
       stgoptions.ulSectorSize = 4096;
       stgoptions.pwcsTemplateFile = NULL;

       printf("Testing Modify large storage\n");
       olHChk(StgCreateStorageEx ( ocsDRT,
                   STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                   STGFMT_DOCFILE,
                   0, &stgoptions,
                   0, IID_IStorage, (void **) &pstgRoot));
    }
    else {
		printf("Testing Modify Storage\n");
        olHChk(StgCreateDocfile(ocsDRT, 
                                STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 
                                0, &pstgRoot));
    }
    
    olHChk(pstgRoot->CreateStorage(ocsChild, STGP(STGM_READWRITE), 0,
                                   0, &pstgChild));
    olHChk(pstgChild->CreateStorage(ocsChild2, STGP(STGM_READWRITE), 0,
                                    0, &pstgChild2));
    olHChk(pstgChild2->CreateStream(
        ocsStream, STMP(STGM_READWRITE), 0, 0, &pstm));
    pstm->Release();
    
    // Test renaming a closed stream
    olHChk(pstgChild2->RenameElement(ocsStream, ocsRenamedStream));
    
    // Test destroying a stream
    olHChk(pstgChild2->DestroyElement(ocsRenamedStream));
    
    // Test renaming an open stream
    olHChk(pstgChild2->CreateStream(
        ocsStream,
        STMP(STGM_READWRITE),
        0,
        0,
        &pstm));
    
    olHChk(pstgChild2->RenameElement(ocsStream, ocsRenamedStream));
    
    olHChk(pstgChild2->DestroyElement(ocsRenamedStream));
    pstm->Release();
    
    pstgChild2->Release();
    
    // Test renaming a storage
    olHChk(pstgChild->RenameElement(ocsChild2, ocsRenamedChild));
    
    olHChk(pstgChild->CreateStream(
        ocsStream,
        STMP(STGM_READWRITE),
        0,
        0,
        &pstm));
    
    pstm->Release();
    olHChk(pstgChild->DestroyElement(ocsStream));
    
    // Test SetElementTimes
    FILETIME tm;
    STATSTG stat;
    
    tm.dwLowDateTime = 0x12345678;
    tm.dwHighDateTime = 0x9abcdef0;
    
    // Set when element not open
    olHChk(pstgChild->SetElementTimes(ocsRenamedChild, &tm, NULL, NULL));
    olHChk(pstgChild->SetElementTimes(ocsRenamedChild, NULL, &tm, NULL));
    olHChk(pstgChild->SetElementTimes(ocsRenamedChild, NULL, NULL, &tm));
    
    olHChk(pstgChild->OpenStorage(
        ocsRenamedChild,
        NULL,
        STMP(STGM_READWRITE),
        NULL,
        0,
        &pstgChild2));
    olHChk(pstgChild2->Stat(&stat, STATFLAG_NONAME));
    if (!IsEqualTime(stat.ctime, tm) ||
        !IsEqualTime(stat.mtime, tm))
        error(EXIT_BADSC, "Times don't match those set by SetElementTimes\n");
    
    // Test SetClass and SetStateBits
    olHChk(pstgChild2->SetClass(IID_IStorage));
    olHChk(pstgChild2->SetStateBits(0xff00ff00, 0xffffffff));
    olHChk(pstgChild2->SetStateBits(0x00880088, 0xeeeeeeee));
    olHChk(pstgChild2->Stat(&stat, STATFLAG_NONAME));
    if (!IsEqualCLSID(stat.clsid, IID_IStorage))
        error(EXIT_BADSC, "Class ID set improperly\n");
    if (stat.grfStateBits != 0x11881188)
        error(EXIT_BADSC, "State bits set improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0x11881188);
    pstgChild2->Release();
    
    pstgChild->Release();
    
    olHChk(pstgRoot->Revert());
    
    olHChk(pstgRoot->Commit(0));
    
    olHChk(pstgRoot->DestroyElement(ocsChild));
    
    olHChk(pstgRoot->CreateStream(
        ocsStream,
        STMP(STGM_READWRITE),
        0,
        0,
        &pstm));
    
    ULARGE_INTEGER ulSize;
    ULISet32(ulSize, 65536);
    
    olHChk(pstm->SetSize(ulSize));
    pstm->Release();
    olHChk(pstgRoot->DestroyElement(ocsStream));
    olHChk(pstgRoot->CreateStream(
        ocsStream,
        STMP(STGM_READWRITE),
        0,
        0,
        &pstm));
    
    olHChk(pstm->SetSize(ulSize));
    pstm->Release();
    
    pstgRoot->Release();
    
    if (pilb) pilb->Release();
    
    if (!fTestStorage)
    {
        pilb = new CFileILB((TCHAR*)NULL, (DWORD)NULL);
        if (pilb == NULL)
            error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
	
        //  create a storage on the ILockBytes		
        olHChk(StgCreateDocfileOnILockBytes(pilb,
                                            STGM_READWRITE |
                                            STGM_CREATE    |
                                            STGM_SHARE_EXCLUSIVE,
                                            0, &pstgRoot));
    }
    else 
    {
        olHChk(StgCreateDocfile(ocsDRT,
                                STGM_READWRITE |
                                STGM_CREATE    |
                                STGM_SHARE_EXCLUSIVE,
                                0, &pstgRoot));		
    }
    
    //  removal cases
    //    1) no right child

    olHChk(pstgRoot->CreateStorage(ocs64, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    olHChk(pstgRoot->CreateStorage(ocs32, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    
    olHChk(pstgRoot->DestroyElement(ocs64));
    
    //    2) right child has no left child
    
    olHChk(pstgRoot->CreateStorage(ocs64, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    olHChk(pstgRoot->DestroyElement(ocs32));
    
    //    3) right child has left child
    
    olHChk(pstgRoot->CreateStorage(ocs96, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    olHChk(pstgRoot->CreateStorage(ocs80, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    
    olHChk(pstgRoot->DestroyElement(ocs64));
    
    //    4) right child's left child has children
    
    olHChk(pstgRoot->CreateStorage(ocs88, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    olHChk(pstgRoot->CreateStorage(ocs84, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    olHChk(pstgRoot->CreateStorage(ocs92, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    olHChk(pstgRoot->DestroyElement(ocs80));
    
    pstgRoot->Release();
    
    if (pilb) pilb->Release();
EH_Err:
    return sc;
}


SCODE t_stat(BOOL fTestStorage, BOOL fLarge)
{
    SCODE sc;
    IStorage *pstgRoot, *pstgChild;
    IStream *pstm;
    STATSTG stat;
    ILockBytes *pilb=NULL;
    
    if (!fTestStorage)
    { 
		printf("Testing Stat ILB\n");
        pilb = new CFileILB(ocsDRT, (DWORD)NULL);
        if (pilb == NULL)
            error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
	
        //  create a storage on the ILockBytes
	
        olHChk(StgCreateDocfileOnILockBytes(pilb,
                                            STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                            0, &pstgRoot));
    }
    else if (fLarge)
    {
       STGOPTIONS stgoptions;
       stgoptions.usVersion = STGOPTIONS_VERSION;
       stgoptions.reserved = 0;
       stgoptions.ulSectorSize = 4096;
       stgoptions.pwcsTemplateFile = NULL;

       printf("Testing Stat large storage\n");
       olHChk(StgCreateStorageEx ( ocsDRT,
                   STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                   STGFMT_DOCFILE,
                   0, &stgoptions,
                   0, IID_IStorage, (void **) &pstgRoot));
    }
    else 
    {		
		printf("Testing Stat Storage\n");
        //  create a storage 		
        olHChk(StgCreateDocfile(ocsDRT,
                                STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                0, &pstgRoot));
    }
    
    olHChk(pstgRoot->CreateStorage(ocsChild, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    olHChk(pstgChild->CreateStream(
        ocsStream,
        STMP(STGM_READWRITE),
        0,
        0,
        &pstm));
    
    olHChk(pstm->Stat(&stat, 0));
    delete [] stat.pwcsName;
    
    olHChk(pstm->Stat(&stat, STATFLAG_NONAME));
    
    pstm->Release();
    
    olHChk(pstgChild->Stat(&stat, 0));
    delete [] stat.pwcsName;
    
    olHChk(pstgChild->Stat(&stat, STATFLAG_NONAME));
    
    pstgChild->Release();
    
    olHChk(pstgRoot->Stat(&stat, 0));
    
    delete[] stat.pwcsName;
    
    olHChk(pstgRoot->Stat(&stat, STATFLAG_NONAME));
    
    pstgRoot->Release();
    if (pilb) pilb->Release();
EH_Err:
    return sc;
}

static char NUMBERS[] = "12345678901234567890123456789012345678901234567890";

SCODE t_stream(BOOL fTestStorage, BOOL fCreate, BOOL fLarge)
{
    SCODE sc;
    IStorage *pstg=NULL, *pstg1=NULL, *pstg2=NULL, *pstg3=NULL;
    IStream *pstm=NULL, *pstmC=NULL, *pstm1=NULL, *pstm2=NULL;
    char buf[sizeof(NUMBERS)*2];
    ULONG cb;
    ULARGE_INTEGER ulPos, ulSize;
    LARGE_INTEGER lPos;
    ILockBytes *pilb=NULL;
    int i=0;

    DECLARE_OLESTR(ocsStorage1,        "Storage1");
    DECLARE_OLESTR(ocsStorage1Stream1, "Storage1Stream1");
    DECLARE_OLESTR(ocsStorage2,        "Storage2");
    DECLARE_OLESTR(ocsStorage2Storage1, "Storage2Storage1");
    DECLARE_OLESTR(ocsStorage3Stream1, "Storage3Stream1");

    if (fCreate)
    {
        if (!fTestStorage)
        {
            printf("Testing streams for ILB\n");
            pilb = new CFileILB(ocsDRT, (DWORD)NULL);
            if (pilb == NULL)
                error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
	      
            //  create a storage on the ILockBytes
            olHChk(StgCreateDocfileOnILockBytes(pilb,
                                                STGM_READWRITE |
                                                STGM_CREATE    |
                                                STGM_SHARE_EXCLUSIVE,
                                                0, &pstg));
        }
        else if (fLarge)
        {
            STGOPTIONS stgoptions;
            stgoptions.usVersion = STGOPTIONS_VERSION;
            stgoptions.reserved = 0;
            stgoptions.ulSectorSize = 4096;
            stgoptions.pwcsTemplateFile = NULL;

            printf("Testing streams for large storage\n");
            olHChk(StgCreateStorageEx ( ocsDRT,
                   STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                   STGFMT_DOCFILE,
                   0, &stgoptions,
                   0, IID_IStorage, (void **) &pstg));
        }
        else
        {
            printf("Testing streams for Storage\n");
            //  create a storage on the ILockBytes
            olHChk(StgCreateDocfile(ocsDRT,
                                    STGM_READWRITE | STGM_CREATE 
                                    | STGM_SHARE_EXCLUSIVE,
                                    0, &pstg));
        }
	 
        olHChk(pstg->CreateStream( ocsStream,
				   STMP(STGM_READWRITE), 0, 0, &pstm));
        olHChk(pstg->CreateStorage( ocsStorage1,
				    STMP(STGM_READWRITE), 0, 0, &pstg1));
        olHChk(pstg1->CreateStream( ocsStorage1Stream1,
				    STMP(STGM_READWRITE), 0, 0, &pstm1));
        olHChk(pstg->CreateStorage( ocsStorage2,
				    STMP(STGM_READWRITE), 0, 0, &pstg2));
        olHChk(pstg2->CreateStorage( ocsStorage2Storage1,
				     STMP(STGM_READWRITE), 0, 0, &pstg3));
        olHChk(pstg3->CreateStream( ocsStorage3Stream1,
				    STMP(STGM_READWRITE), 0, 0, &pstm2));
        for (i=0; i<20; i++)
            olHChk(pstm->Write(NUMBERS, sizeof(NUMBERS), &cb));
        for (i=0; i<20; i++)
            olHChk(pstm2->Write(NUMBERS, sizeof(NUMBERS), &cb));
	 
        olHChk(pstm->Commit(0));
        unsigned long ul;
        if ((ul = pstm->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if ((ul = pstm1->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if ((ul = pstm2->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if ((ul = pstg->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if ((ul = pstg1->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if ((ul = pstg2->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if ((ul = pstg3->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if (pilb)
            verify (0 == pilb->Release());
        return sc;
    }
    
    if (!fTestStorage)
    {
        pilb = new CFileILB(ocsDRT, (DWORD)NULL);
        if (pilb == NULL)
            error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
        
        //  create a storage on the ILockBytes
        olHChk(StgOpenStorageOnILockBytes(pilb, NULL,
                                          ROOTP(STGM_READWRITE), NULL, 0, 
                                          &pstg));
    }
    else
    {
        olHChk(StgOpenStorage(ocsDRT,			
                              NULL, ROOTP(STGM_READWRITE), NULL, 0,
                              &pstg));
    }
    
    olHChk(pstg->OpenStream( ocsStream, NULL,
                             STMP(STGM_READWRITE), 0, &pstm));
    olHChk(pstg->OpenStorage( ocsStorage1, NULL,
                              STMP(STGM_READWRITE), 0, 0, &pstg1));
    olHChk(pstg1->OpenStream( ocsStorage1Stream1, NULL,
                              STMP(STGM_READWRITE), 0, &pstm1));
    olHChk(pstg->OpenStorage( ocsStorage2, NULL,
                              STMP(STGM_READWRITE), 0, 0, &pstg2));
    olHChk(pstg2->OpenStorage( ocsStorage2Storage1, 0, 
                               STMP(STGM_READWRITE), 0, 0, &pstg3));
    olHChk(pstg3->OpenStream( ocsStorage3Stream1, 0,
                              STMP(STGM_READWRITE), 0, &pstm2));

    lPos.QuadPart = 0;    
    olHChk(pstm->Seek(lPos, STREAM_SEEK_SET, &ulPos));
    if (ulPos.QuadPart != 0)
        error(EXIT_BADSC, "Incorrect seek, ptr is %lu\n", ulPos.QuadPart);
    for (i=0; i<20; i++)
    {
        olHChk(pstm->Read(buf, sizeof(NUMBERS), &cb));
        if (strcmp(buf, NUMBERS))
            error(EXIT_BADSC, "Incorrect stream contents\n");
    }

    ulPos.QuadPart = 0;    
    olHChk(pstm2->Seek(lPos, STREAM_SEEK_SET, &ulPos));
    if (ulPos.QuadPart != 0)
        error(EXIT_BADSC, "Incorrect seek, ptr is %lu\n", ulPos.QuadPart);
    for (i=0; i<20; i++)
    {
        olHChk(pstm2->Read(buf, sizeof(NUMBERS), &cb));
        if (strcmp(buf, NUMBERS))
            error(EXIT_BADSC, "Incorrect stream contents\n");
    }
    
    if (!g_fTestInterop)
    {   // some tests that changes the contents
        ULISet32(ulSize, sizeof(NUMBERS)/2);
        olHChk(pstm->SetSize(ulSize));
        olHChk(pstm->Seek(lPos, STREAM_SEEK_SET, NULL));
        
        olHChk(pstm->Read(buf, sizeof(NUMBERS), &cb));
    
        if (cb != sizeof(NUMBERS)/2)
            error(EXIT_BADSC, "SetSize failed to size stream properly\n");
        if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2))
            error(EXIT_BADSC, "SetSize corrupted contents\n");
        olHChk(pstm->Clone(&pstmC));
        olHChk(pstm->Seek(lPos, STREAM_SEEK_SET, NULL));
        olHChk(pstm->CopyTo(pstmC, ulSize, NULL, NULL));
        olHChk(pstm->Seek(lPos, STREAM_SEEK_SET, NULL));
        
        ULISet32(ulSize, sizeof(NUMBERS)&~1);
        olHChk(pstm->CopyTo(pstmC, ulSize, NULL, NULL));
        olHChk(pstm->Seek(lPos, STREAM_SEEK_SET, NULL));
        olHChk(pstm->Read(buf, (sizeof(NUMBERS)&~1)*2, &cb));
        if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2) ||
            memcmp(buf+sizeof(NUMBERS)/2, NUMBERS, sizeof(NUMBERS)/2) ||
            memcmp(buf+(sizeof(NUMBERS)&~1), NUMBERS, sizeof(NUMBERS)/2) ||
            memcmp(buf+3*(sizeof(NUMBERS)/2), NUMBERS, sizeof(NUMBERS)/2))
            error(EXIT_BADSC, "Stream contents incorrect\n");
        verify( 0 == pstmC->Release());
    }

EH_Err:

    if (pstm) verify( 0 == pstm->Release() );
    if (pstm1) verify( 0 == pstm1->Release() );
    if (pstm2) verify( 0 == pstm2->Release() );
    if (pstg) verify( 0 == pstg->Release() );
    if (pstg1) verify( 0 == pstg1->Release() );
    if (pstg2) verify( 0 == pstg2->Release() );
    if (pstg3) verify( 0 == pstg3->Release() );
    
    if (pilb) verify( 0 == pilb->Release() );

    return sc;
}

SCODE t_stgmisc(BOOL fLarge)
{
    SCODE sc;
    IStorage *pstg;
    FILE *f;

    _unlink("drt.dfl");
    // create zero byte file
    f= fopen("drt.dfl", "w+b");
    fclose(f);


    olAssert(StgIsStorageFile(ocsDRT)==S_FALSE);

    _unlink("drt.dfl");

    if (fLarge)
    {
       STGOPTIONS stgoptions;
       stgoptions.usVersion = STGOPTIONS_VERSION;
       stgoptions.reserved = 0;
       stgoptions.ulSectorSize = 4096;
       stgoptions.pwcsTemplateFile = NULL;

       olHChk(StgCreateStorageEx ( ocsDRT,
                   STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                   STGFMT_DOCFILE,
                   0, &stgoptions,
                   0, IID_IStorage, (void **) &pstg));
    }
    else
        olHChk(StgCreateDocfile(ocsDRT, 
                            STGM_READWRITE|STGM_CREATE|STGM_SHARE_EXCLUSIVE,
                            0, 
                            &pstg));

    olAssert(StgIsStorageFile(ocsDRT)==S_OK);
    pstg->Release();

EH_Err:
    return sc;
}

SCODE t_large ()
{
    IStorage *pstg = NULL;
    IStream *pstm = NULL;
    SCODE sc = S_OK;

    STGOPTIONS stgoptions;
    stgoptions.usVersion = STGOPTIONS_VERSION;
    stgoptions.reserved = 0;
    stgoptions.ulSectorSize = 4096;
    stgoptions.pwcsTemplateFile = NULL;

    olChk(StgCreateStorageEx ( _T("large.dfl"),
                   STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                   STGFMT_DOCFILE,
                   0, &stgoptions,
                   0, IID_IStorage, (void **) &pstg));

    olChk(pstg->CreateStream( _T("large"),
                   STGM_READWRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm));

    ULARGE_INTEGER ulSize;
    ulSize.QuadPart = MAX_ULONG + (ULONGLONG) sizeof(NUMBERS);

    olChk(pstm->SetSize(ulSize));

    for (ULONG i=0; i < MAX_ULONG/sizeof(NUMBERS) + 1; i++)
    {
        ULONG cb;
        olChk(pstm->Write(NUMBERS, sizeof(NUMBERS), &cb));
    }

    olChk(pstg->Commit(STGC_DEFAULT));

EH_Err:
    if (pstm != NULL)
        pstm->Release();
    if (pstg != NULL)
        pstg->Release();

    return sc;
}

void terminate(void)
{
	printf("Terminate() called!\n");
	exit(-1);
}

int main(int argc, char** argv)
{
    SCODE sc;
    int fCreate=0;

    // change the following line to whatever number to detect mem leaks
    //_CrtSetBreakAlloc(146);

    // initialize the strings
    INIT_OLESTR(ocsDRT,    "drt.dfl");
    INIT_OLESTR(ocsChild,  "Child");
    INIT_OLESTR(ocsChild1, "Child1");
    INIT_OLESTR(ocsChild2, "Child2");
    INIT_OLESTR(ocsStream, "Stream");
    INIT_OLESTR(ocsRenamedStream, "RenamedStream");
    INIT_OLESTR(ocsRenamedChild,  "RenamedChild");

    printf("Reference storage tests:\n");
    printf("Optional features:\n");
    printf("Use '%s c' to create a test file\n", argv[0]);
    printf("Use '%s r' to verify read of the test file\n", argv[0]);
    printf("-----\n");

    if (argc==2) {
        printf(" * Interops testing --- ");
        
        if (*(argv[1])=='c')	 {
            printf("Create\n");
            fCreate=1;
        }
        else if (*(argv[1])=='r')
            printf("Read\n");
        else {
            printf("Wrong args: usage\nreftest [c|r]\nc - Create\nr - read\n");
            return 0;
        }
        
	g_fTestInterop = 1;
    }

    if (g_fTestInterop)
    {
        olChk(t_stream(FALSE, fCreate, FALSE));
        printf("\nTests passed successfully.\n");
        exit(0);
    }

    printf("\nTesting ILockBytes\n\n");

    olChk(t_create(FALSE, FALSE));
    olChk(t_open(FALSE, FALSE));
    olChk(t_addref(FALSE, FALSE));
    olChk(t_stream(FALSE, TRUE, FALSE));
    olChk(t_stat(FALSE, FALSE));
    olChk(t_dmodify(FALSE, FALSE));
    
    printf("\nTesting Storage\n\n");
    olChk(t_create(TRUE, FALSE));
    olChk(t_open(TRUE, FALSE));
    olChk(t_addref(TRUE, FALSE));
    olChk(t_dmodify(TRUE, FALSE));
    olChk(t_stream(TRUE, TRUE, FALSE));
    olChk(t_stat(TRUE, FALSE));
    olChk(t_stgmisc(FALSE));

    printf("\nTesting large Storage\n\n");
    olChk(t_create(TRUE, TRUE));
    olChk(t_open(TRUE, TRUE));
    olChk(t_addref(TRUE, TRUE));
    olChk(t_dmodify(TRUE, TRUE));
    olChk(t_stream(TRUE, TRUE, TRUE));
    olChk(t_stat(TRUE, TRUE));
    olChk(t_stgmisc(TRUE));
#ifdef TEST_LARGE
    olChk(t_large());
#endif
    
    printf("\nTests passed successfully.\n");
    return 0;
    
EH_Err:
    printf("Tests failed with error %lX\n",sc);
    return EXIT_BADSC;
}

#ifdef _MSC_VER
// some of these functions are a nuisance 
#pragma warning (disable:4127)  // conditional expression is constant
#pragma warning (disable:4514)  // unreferenced inline function
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\reftest\refilb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	refilb.cxx
//
//  Contents:	Reference ILockBytes class
//
//  Classes:	CFileILB
//
//  Notes:      This Class always call single byte I/O routines
//              because most systems only have support for single byte
//              I/O. This makes the code more portable.
//
//----------------------------------------------------------------------------

#include <errno.h>
#include "refilb.hxx"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/stat.h>
#include "time.hxx"

#ifdef _WIN32
#include <io.h> // to get definition of wunlink
#else
#include <unistd.h>
#define _stat stat
#define _tstat stat
#endif

#include <stdlib.h>
#include <assert.h>

#ifdef PRINT_TRACE
#define TRACE(x) printf(x)
#else
#define TRACE(x)
#endif

static int filenum = 0;

char * GetTempFileName(void)
{
    char *psz = new char[_MAX_PATH +1];
    strcpy(psz, "dft");

    _itoa(filenum, psz + 3, 10);
    filenum++;
    return psz;
}

CFileILB::CFileILB(const TCHAR *pszName,
                   DWORD grfMode,
                   BOOL fOpenFile/* =TRUE */)
{
    _pszName = NULL;

    _fDelete = FALSE;
    if (pszName == NULL)
    {
         _pszName = GetTempFileName();
         _unlink(_pszName);            // make sure file is over written
         _fDelete |= ILB_DELETEONERR;  // don't want to keep scratch files
    }
    else
    {
        _pszName = new char[_MAX_PATH + 1];
        TTOS(pszName, _pszName, _tcslen(pszName)+1);
    }

    if (grfMode & STGM_DELETEONRELEASE)
        _fDelete |= ILB_DELETEONRELEASE;
    _f = NULL;
    if (fOpenFile)
    {
        // disregard if file is already there
	Create(STGM_CREATE|STGM_READWRITE);
        // got to open the file with this option
        assert(_f && "CFileILB could not open the file!");
    }
    _ulRef = 1;
}

static const char pcszReadOnly[] ="rb";
static const char pcszReadWrite[] = "r+b";
static const char pcszWrite[] = "w+b";

SCODE CFileILB::Create(DWORD grfMode)
{
    char const *pszMode = pcszReadOnly; // default

    if (grfMode & STGM_READWRITE)
        pszMode = pcszReadWrite;
    else
        TRACE("CFileILB::Create called with Read Only!!\n");

    _f = fopen(_pszName, pszMode);
    if (_f)                     // open succeeded
    {
        if ((grfMode & (STGM_CREATE|STGM_CONVERT) ) == STGM_FAILIFTHERE)
            return STG_E_FILEALREADYEXISTS;
    }
    else if (errno==EACCES && (grfMode & STGM_CONVERT))
    {
        TRACE("Access Denied in CFileILB::Create\n");
        return STG_E_ACCESSDENIED;
    }
    else
    {
        // the file does not exists, create the file
        _f = fopen(_pszName, pcszWrite);
        if (_f==NULL)
        {
            // we could not create the file for some reason
            // return the appropriate error code
            if (errno== EACCES)
                return STG_E_ACCESSDENIED;
            else
            {
                return STG_E_INVALIDNAME; // assume it is an invalid name
            }
        }
        else
        {
            // the newly create file should be deleted on error
            _fDelete |= ILB_DELETEONERR;
        }
    }
    return S_OK;
}

SCODE CFileILB::Open(DWORD grfMode)
{
    char const *pszMode = pcszReadOnly; // default

    assert( (_fDelete & ILB_DELETEONERR)==0 ); // this means an null named file
                                                  // has been opened
    if (grfMode & STGM_READWRITE)
        pszMode = pcszReadWrite;
    else
        TRACE( "CFileILB::Open called with Read Only!!\n");

    _f = fopen(_pszName, pszMode);
    if (_f == NULL)
    {
        if (errno==EACCES) return STG_E_ACCESSDENIED;
        else if (errno==ENOENT) return STG_E_FILENOTFOUND;
        else return STG_E_INVALIDNAME; // we assume that the name is invalid
    }

    return S_OK;
}

CFileILB::~CFileILB()
{
    if (_f)
        fclose(_f);
    if (_fDelete & ILB_DELETEONRELEASE)
    {
         // nothing we can do if the file cannot be deleted somehow
         // since the ref impl. is not multi-thread safe
        _unlink(_pszName);
    }
    delete _pszName;
}

STDMETHODIMP CFileILB::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;
    UNREFERENCED_PARM(riid);
    //olAssert(FALSE && "function not implemented!");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

STDMETHODIMP_(ULONG) CFileILB::AddRef(void)
{
    _ulRef++;
    return(_ulRef);
}

STDMETHODIMP_(ULONG) CFileILB::Release(void)
{
    _ulRef--;
    TRACE("CFileILB::Release%lx\n");
    if (_ulRef > 0)
        return(_ulRef);
    delete this;

    return(0);
}

ULONG CFileILB::ReleaseOnError(void)
{
    // this function should be not used otherwise
    assert(_ulRef == 1);

    // Delete the file if it is a file we just created
    if (_fDelete & ILB_DELETEONERR)
        _fDelete |= ILB_DELETEONRELEASE;
    return( Release() );
}

STDMETHODIMP CFileILB::ReadAt(ULARGE_INTEGER ulPosition,

        VOID HUGEP *pb,
        ULONG cb,
        ULONG *pcbRead)
{
    fseek(_f, ulPosition.QuadPart, SEEK_SET);

    *pcbRead = fread(pb, 1, cb, _f);
    return NOERROR;
}

STDMETHODIMP CFileILB::WriteAt(ULARGE_INTEGER ulPosition,
        VOID const HUGEP *pb,
        ULONG cb,
        ULONG FAR *pcbWritten)
{
    fseek(_f, ulPosition.QuadPart, SEEK_SET);

    *pcbWritten = fwrite(pb, 1, cb, _f);
    return NOERROR;
}

STDMETHODIMP CFileILB::Flush(void)
{
    fflush(_f);
    return NOERROR;
}

STDMETHODIMP CFileILB::SetSize(ULARGE_INTEGER ulNewSize)
{
    LONGLONG cbNewSize = ulNewSize.QuadPart;
    LONGLONG cbCurrentSize = ftell(_f);
    if(-1 == cbCurrentSize)
        return STG_E_SEEKERROR;

    if(cbCurrentSize < cbNewSize)
    {                                       // Increase the Size
        fseek(_f, cbNewSize-1, SEEK_SET);
        if(1 != fwrite("", 1, 1, _f))
            return STG_E_WRITEFAULT;
    }
    else if(cbCurrentSize > cbNewSize)
    {                                       // Decrease the Size
        //  OS specific: file truncation.
    }
    return NOERROR;
}

STDMETHODIMP CFileILB::LockRegion(ULARGE_INTEGER libOffset,
                                  ULARGE_INTEGER cb,
                                  DWORD dwLockType)
{
    UNREFERENCED_PARM(dwLockType);
    UNREFERENCED_PARM(cb);
    UNREFERENCED_PARM(libOffset);
    assert(FALSE && "function not implemented!");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}


STDMETHODIMP CFileILB::UnlockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
{
    UNREFERENCED_PARM(dwLockType);
    UNREFERENCED_PARM(cb);
    UNREFERENCED_PARM(libOffset);
    assert(FALSE && "function not implemented!");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}


STDMETHODIMP CFileILB::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    memset(pstatstg, 0, sizeof(STATSTG));

    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
         char pchTemp[_MAX_PATH+1];
        _fullpath(pchTemp, _pszName, _MAX_PATH+1);
        pstatstg->pwcsName = new TCHAR[strlen(pchTemp)+1];
        STOT(pchTemp, pstatstg->pwcsName, strlen(pchTemp)+1);
    }

    pstatstg->type = STGTY_LOCKBYTES;

    fseek(_f, 0, SEEK_END);
    (pstatstg->cbSize).QuadPart = ftell(_f);

    // just return a default, the function that calls this should fill in
    // the structure.
    pstatstg->grfMode = STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE;

    struct _stat buf;
    int result = _stat(_pszName, &buf);
    if (!result)  // fill in zeros
    {
        pstatstg->atime.dwLowDateTime = pstatstg->atime.dwLowDateTime = 0;
        pstatstg->mtime.dwLowDateTime = pstatstg->mtime.dwLowDateTime = 0;
        pstatstg->ctime.dwLowDateTime = pstatstg->ctime.dwLowDateTime = 0;
    }
    else
    {
        TimeTToFileTime(&buf.st_atime, &pstatstg->atime);
        TimeTToFileTime(&buf.st_mtime, &pstatstg->mtime);
        TimeTToFileTime(&buf.st_ctime, &pstatstg->ctime);
    }
    return NOERROR;
}

EXTERN_C STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return (memcmp(&rguid1, &rguid2, sizeof(GUID)) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\stgdrt\headers.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       headers.cxx
//
//  Contents:   Frequently used headers
//
//--------------------------------------------------------------------------

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../../h/storage.h"
#include "drt.hxx"
#include "wrap.hxx"
#include "util.hxx"
#include "strlist.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\stgdrt\ilb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	ilbmem.cx
//
//  Contents:	ILockBytes memory implementation
//
//  Classes:	CMapBytes
//
//--------------------------------------------------------------------------

#include "headers.cxx"

#include <memory.h>
#include "ilb.hxx"

#if DBG == 1
#ifndef _UNIX // on unix we use static lib, so the symbol is defined
DECLARE_INFOLEVEL(ol, DEB_ERROR);
#endif
#endif

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::CMapBytes, public
//
//  Synopsis:   constructor
//
//  Effects:    initialize member variables
//
//  Derivation: ILockBytes
//
//  Notes:      Returns a fully initialized CMapBytes (ref count == 1)
//
//--------------------------------------------------------------------------

CMapBytes::CMapBytes(void)
{
    _ulSize = 0;
    _pv = 0;

    _ulRef = 1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::QueryInterface, public
//
//  Arguments:	[riid] - interface id
//		[ppvObj] - place holder for interface
//
//  Returns:    Always fails
//
//  Derivation: ILockBytes
//
//  Notes:      Not used in tests
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::AddRef, public
//
//  Synopsis:	add reference
//
//  Returns:    post reference count
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMapBytes::AddRef(void)
{
    _ulRef++;
    return(_ulRef);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Release, public
//
//  Synopsis:	release reference
//
//  Effects:	deletes object when reference count reaches zero
//
//  Returns:	post reference count
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMapBytes::Release(void)
{
    _ulRef--;

    if (_ulRef > 0)
        return(_ulRef);

    free(_pv);

    delete this;

    return(0);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::ReadAt
//
//  Synopsis:   Reads bytes from memory
//
//  Arguments:  [ulOffset] - byte offset
//		[pv]       - input buffer
//		[cb]       - count of bytes to read
//		[pcbRead]  - count of bytes read
//
//  Returns:    SCODE
//
//  Modifies:   pv, pcbRead
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::ReadAt(ULARGE_INTEGER uliOffset,
			       VOID HUGEP *pv,
			       ULONG cb,
			       ULONG *pcbRead)
{
    olAssert(ULIGetHigh(uliOffset) == 0);

    ULONG ulOffset = ULIGetLow(uliOffset);
    if (ulOffset >= _ulSize)
    {
        //  truncate read
        cb = 0;
    }
    else if (cb > (_ulSize - ulOffset))
    {
        //  truncate range that exceeds size
        cb = _ulSize - ulOffset;
    }

    memcpy(pv, (void*)(((BYTE*)_pv) + ulOffset), (size_t) cb);
    *pcbRead = cb;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::WriteAt, public
//
//  Synopsis:	Writes bytes to memory
//
//  Effects:	May change memory size
//
//  Arguments:	[uliOffset]  - byte offset
//		[pv]         - output buffer
//		[cb]         - count of bytes to write
//		[pcbWritten] - count of bytes written
//
//  Returns:	SCODE
//
//  Modifies:	pcbWritten
//
//  Derivation: ILockBytes
//
//  Notes:	This implementation doesn't write partial buffers.
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::WriteAt(ULARGE_INTEGER uliOffset,
				VOID const HUGEP *pv,
				ULONG cb,
				ULONG FAR *pcbWritten)
{
    olAssert(ULIGetHigh(uliOffset) == 0);

    ULONG ulOffset = ULIGetLow(uliOffset);
    HRESULT hr;

    if (ulOffset + cb > _ulSize)
    {
        //  increase memory buffer to accomodate write

        ULARGE_INTEGER uliSize;

        ULISetHigh(uliSize, 0);
        ULISetLow(uliSize, ulOffset + cb);
        hr = SetSize(uliSize);

        if (FAILED(DfGetScode(hr)))
        {
            //  don't bother writing partial buffers

            *pcbWritten = 0;
            return hr;
        }
    }

    memcpy((void *)(((BYTE*)_pv) + ulOffset), pv, (size_t) cb);
    *pcbWritten = cb;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Flush, public
//
//  Synopsis:	flushes memory - not appropriate for this implementation
//
//  Effects:	none
//
//  Returns:    SUCCESS_SUCCESS
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::Flush(void)
{
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::GetSize, public
//
//  Synopsis:	gets memory buffer size
//
//  Arguments:	[pcb] - size place holder
//
//  Returns:	SUCCESS_SUCCESS
//
//  Modifies:	pcb
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::GetSize(ULARGE_INTEGER FAR *pcb)
{
    ULISetHigh(*pcb, 0);
    ULISetLow(*pcb, _ulSize);
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::SetSize, public
//
//  Synopsis:	sets memory buffer size
//
//  Effects:	may change buffer size
//
//  Arguments:	[ulicb] - new memory size
//
//  Returns:	SCODE
//
//  Derivation: ILockBytes
//
//  Algorithm:  realloc the buffer
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::SetSize(ULARGE_INTEGER ulicb)
{
    olAssert(ULIGetHigh(ulicb) == 0);

    ULONG cb = ULIGetLow(ulicb);

    if (cb == _ulSize)
        return NOERROR;

    void *pv = realloc(_pv, (size_t) cb);

    if ((cb > 0) && (pv == NULL))
    {
        //  Unable to allocate memory
        //  Leave current memory and size alone

        return ResultFromScode(E_OUTOFMEMORY);
    }

    _pv = pv;
    _ulSize = cb;

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::LockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Effects:	asserts if called
//
//  Arguments:	[libOffset]  - lock range offset
//		[cb]         - lock range size
//		[dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::LockRegion(ULARGE_INTEGER libOffset,
				   ULARGE_INTEGER cb,
				   DWORD dwLockType)
{
    olAssert(0 && "Can't lock CMapBytes");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::UnLockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Effects:	asserts if called
//
//  Arguments:	[libOffset]  - lock range offset
//		[cb]         - lock range size
//		[dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::UnlockRegion(ULARGE_INTEGER libOffset,
				     ULARGE_INTEGER cb,
				     DWORD dwLockType)
{
    olAssert(0 && "Can't unlock CMapBytes");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Stat, public
//
//  Synopsis:	Provide instance information
//
//  Arguments:	[pstatstg]    - status buffer
//		[grfStatFlag] - status flags
//
//  Returns:	SCODE
//
//  Modifies:	pstatstg
//
//  Derivation: ILockBytes
//
//  Notes:	No time stamps
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    memset(pstatstg, 0, sizeof(STATSTG));

    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        static char const abName[] = "Memory";

        HRESULT hr;

        if (FAILED(DfGetScode(hr = drtMemAlloc(sizeof(abName),
                                             (void **) &pstatstg->pwcsName))))
            return hr;

        memcpy(pstatstg->pwcsName, abName, sizeof(abName));
    }

    pstatstg->type = STGTY_LOCKBYTES;

    ULISetHigh(pstatstg->cbSize, 0);
    ULISetLow(pstatstg->cbSize, _ulSize);

    pstatstg->grfMode = STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\stgdrt\drt.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       drt.cxx
//
//  Contents:   DRT main routine
//
//---------------------------------------------------------------

#include "headers.cxx"
#include "../../h/dbg.hxx"

#include "tests.hxx"
#include "illeg.hxx"

// Test flags and type
typedef ULONG FLAGS;

#define TF_NONE                 0x00000000

// Suppression flags
#define TF_SUPPRESS             0x0000FFFF
#define TFS_ILLEGITIMATE        0x00000001
#define TFS_16BIT               0x00000002

// Enabling flags
#define TF_ENABLE               0xFFFF0000
#define TFE_DIRECT              0x00010000
#define TFE_ANY                 (TFE_DIRECT)

// Pointer to a test function
typedef void (*TestFn)(void);

static struct
{
    char *pszName;
    char *pszDesc;
    TestFn tfn;
    FLAGS flags;
} tests[] =
{
    "Create",   "Creation",
        t_create, TFE_ANY,
    "Open",     "Opening",
        t_open, TFE_ANY,
    "AddRef",   "AddRef/Release",
        t_addref, TFE_ANY,
    "DModify",  "Direct modifications",
        t_dmodify, TFE_DIRECT,
    "Stat",     "Stat",
        t_stat, TFE_ANY,
    "Stream",   "Stream operations",
        t_stream, TFE_ANY,
    "Enum",     "Enumerator operations",
        t_enum, TFE_ANY,
    "StgCopyTo", "IStorage::CopyTo",
        t_stgcopyto, TFE_ANY,
    "MoveCopy", "IStorage::MoveElementTo",
        t_movecopy, TFE_ANY,
    "ILockBytes", "ILockBytes usage",
        t_ilb, TFE_ANY,
    "StgMisc",  "Miscellaneous Stg functions",
        t_stgmisc, TFE_ANY,
    "IllStg", "Illegitimate IStorage calls", 
        i_storage, TFE_ANY | TFS_ILLEGITIMATE,
    "IllStm", "Illegitimate IStream calls",
        i_stream, TFE_ANY | TFS_ILLEGITIMATE,
    "IllEnum", "Illegitimate enumerator calls",
        i_enum, TFE_ANY | TFS_ILLEGITIMATE
};
#define NTESTS (sizeof(tests)/sizeof(tests[0]))

DWORD dwRootDenyWrite = STGM_SHARE_DENY_WRITE;
BOOL fVerbose = FALSE;
OLECHAR atcDrtDocfile[_MAX_PATH];

static BOOL fRun[NTESTS];
#ifdef FLAT
static FLAGS flTests = TF_NONE;
#else
static FLAGS flTests = TF_NONE | TFS_16BIT;
#endif

static void Initialize(void)
{
    SetData();
}

static void Uninitialize(void)
{
    UnsetData();
}

static int FindTest(char *pszName)
{
    int i, cchName;

    cchName = strlen(pszName);
    for (i = 0; i<NTESTS; i++)
        if (!_strnicmp(pszName, tests[i].pszName, cchName))
            return i;
    return -1;
}

static void RunTests(void)
{
    int i;

    for (i = 0; i<NTESTS; i++)
        // For a test to run:
        // 1)  fRun[test] must be TRUE
        // 2)  No suppression flags can be set that are not set in flTests
        // 3)  At least one enabling flag must be set that is set in flTests
        if (fRun[i] &&
            (tests[i].flags & ~flTests & TF_SUPPRESS) == 0 &&
            (tests[i].flags & flTests & TF_ENABLE) != 0)
        {
            out("\n----- Test #%2d - %s -----\n", i+1, tests[i].pszDesc);
            tests[i].tfn();
            CleanData();
        }
}

static void Usage(void)
{
    int i;

    printf("Usage: drt [options]\n");
    printf("Options are:\n");
    printf("  -h        - This message\n");
    printf("  -d        - Suppress direct tests\n");
    printf("  -i        - Enable illegitimate tests\n");
    printf("  -v        - Display test output\n");
    printf("  -#[+|-]<number>   - Turn test <number> on (+) or off (-)\n");
    printf("                      No number means all\n");
    printf("  -n[+|-]<prefix>   - Turn test <prefix> on or off\n");
    printf("  -N<file>  - Set file to use for tests\n");
    printf("Prefix can be any prefix of:\n");
    printf("HR=%lx\n", E_INVALIDARG);
    for (i = 0; i<NTESTS; i++)
        printf("  %s\n", tests[i].pszName);
    exit(1);
}

int __cdecl main(int argc, char **argv)
{
    int i, iTest;
    BOOL fDirect = TRUE;

    // change the following line to set mem check breakpoints
    // on win32, using debug CRT.
    //_CrtSetBreakAlloc();

    for (i = 0; i<NTESTS; i++)
        fRun[i] = TRUE;
    ATOOLE(pszDRTDF, atcDrtDocfile, _MAX_PATH);
    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case '#':
                if (sscanf(argv[0]+3, "%d", &iTest) != 1)
                    iTest = -1;
                else
                    iTest--;
                for (i = 0; i<NTESTS; i++)
                    if (iTest == -1 || iTest == i)
                        fRun[i] = argv[0][2] == '+';
                break;
            case 'd':
                fDirect = FALSE;
                break;
            case 'i':
                flTests |= TFS_ILLEGITIMATE;
                break;
            case 'n':
                iTest = FindTest(argv[0]+3);
                if (iTest >= 0)
                    fRun[iTest] = argv[0][2] == '+';
                break;
            case 'N':
                ATOOLE(argv[0]+2, atcDrtDocfile, _MAX_PATH);
                break;
            case 'v':
                fVerbose = TRUE;
                break;

            case 'h':
            default:
                Usage();
            }
        }
        else
            Usage();
    }

    Initialize();

    if (fDirect)
    {
        out("\n---------- Direct ----------\n");
        dwRootDenyWrite = STGM_SHARE_EXCLUSIVE;
        flTests |= TFE_DIRECT;
        RunTests();
        flTests &= ~TFE_DIRECT;
    }

    printf("Storage DRT - PASSED\n");

    Uninitialize();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\stgdrt\illeg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	illeg.cxx
//
//  Contents:	Illegitimate tests
//
//----------------------------------------------------------------------------

#include "headers.cxx"

#ifdef _WIN32
#include <io.h>
#else 
#include <unistd.h>
#include "winio.hxx"
#endif

#include <fcntl.h>
#ifdef _WIN32
#include <sys\types.h>
#include <sys\stat.h>
#else // war of the slashes
#include <sys/types.h> 
#include <sys/stat.h>
#endif

#include "illeg.hxx"

void i_storage(void)
{
    WStorage *pwstg;
    IStorage *pstg, *pstg2;
    WStorage *pw1;
    IStream *pstm;

    IllResult("StgCreateDocfile with NULL ppstg",
             StgCreateDocfile(NULL, ROOTP(STGM_READWRITE), 0, NULL));
    IllResult("StgCreateDocfile with non-zero reserved",
             StgCreateDocfile(NULL, ROOTP(STGM_READWRITE), 1, &pstg));
    IllResult("StgCreateDocfile with illegal permissions",
             StgCreateDocfile(NULL, 0, 0, &pstg));

    int fd;
    fd = _creat(OlecsOut(DRTDF), _S_IREAD);
    if (fd<0)
        error(EXIT_BADSC, "Unable to create file '%s'\n", OlecsOut(DRTDF));
    _close(fd);
    IllResult("StgCreateDocfile with STGM_WRITE over read-only file",
             StgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pstg));
    _chmod(OlecsOut(DRTDF), _S_IREAD | _S_IWRITE);

    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE)|STGM_CREATE, 0, &pw1);
    pw1->Commit(0);
    pw1->Unwrap();

    IllResult("StgOpenStorage with NULL ppstg",
             StgOpenStorage(DRTDF, NULL, ROOTP(STGM_READWRITE), NULL, 0, NULL));
    IllResult("StgOpenStorage with NULL name",
             StgOpenStorage(NULL, NULL, STGP(WSTG_READWRITE), NULL, 0, &pstg));
    IllResult("StgOpenStorage with illegal permissions",
             StgOpenStorage(DRTDF, NULL, 0xffffffff, NULL, 0, &pstg));
    IllResult("StgOpenStorage with non-zero reserved",
             StgOpenStorage(DRTDF, NULL, ROOTP(STGM_READWRITE), NULL,
                            1, &pstg));

    fd = _creat(OlecsOut(DRTDF), _S_IREAD | _S_IWRITE);
    if (fd<0) error(EXIT_BADSC, "Unable to create file '%s'\n", OlecsOut(DRTDF));
    _close(fd);

#if WIN32 != 300
    IllResult("StgOpenStorage on non-docfile",
             StgOpenStorage(DRTDF, NULL, ROOTP(STGM_READWRITE), NULL,
                            0, &pstg));
#endif

    DECLARE_OLESTR(ocsNoName, "NoName");
    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE) | STGM_CREATE, 0, &pwstg);
    pstg = pwstg->GetI();
    IllResult("OpenStream that doesn't exist",
             pstg->OpenStream(ocsNoName, 0, STMP(STGM_READWRITE),
                              0, &pstm));
    IllResult("OpenStorage that doesn't exist",
             pstg->OpenStorage(ocsNoName, NULL, STGP(STGM_READWRITE),
                               NULL, 0, &pstg2));
    pwstg->Unwrap();
}

#define STREAMSIZE 128

void i_stream(void)
{
    WStorage *pwstg;
    WStream *pwstm;
    IStream *pstm;
    BYTE bBuffer[STREAMSIZE];
    ULONG cbRead;
    LARGE_INTEGER liSeek;    
    ULARGE_INTEGER uliSize;    

    DECLARE_OLESTR(ocsStream, "Stream");
    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pwstg);
    pwstg->CreateStream(ocsStream, STMP(STGM_READ), 0, 0, &pwstm);
    pstm = pwstm->GetI();
    
    IllResult("Read with NULL buffer",
             pstm->Read(NULL, STREAMSIZE, NULL));
    fExitOnFail = FALSE;
    pwstm->Read(bBuffer, STREAMSIZE, &cbRead);
    fExitOnFail = TRUE;
    if (cbRead != 0)
        error(EXIT_BADSC, "Read %lu bytes on zero-length stream\n", cbRead);

    IllResult("Write with NULL buffer",
             pstm->Write(NULL, STREAMSIZE, NULL));
    IllResult("Write on read-only stream",
             pstm->Write(bBuffer, STREAMSIZE, NULL));

    LISet32(liSeek, 0);
    IllResult("Seek with invalid origin",
             pstm->Seek(liSeek, (DWORD)(~STREAM_SEEK_SET), NULL));
#ifdef _MSC_VER
#pragma warning(disable:4245)
    // LISet32 in objbase.h has a bug that issues warning for negative values
#endif
    LISet32(liSeek, (ULONG) -1);
#ifdef _MSC_VER
#pragma warning(default:4245)
#endif
    IllResult("Seek before beginning",
             pstm->Seek(liSeek, STREAM_SEEK_CUR, NULL));

    ULISet32(uliSize, STREAMSIZE);
    IllResult("SetSize on read-only stream",
             pstm->SetSize(uliSize));
    
    pwstm->Unwrap();
    pwstg->Unwrap();
}

void i_enum(void)
{
    WStorage *pwstg;
    IStorage *pstg;
    IEnumSTATSTG *penm;
    
    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pwstg);
    pstg = pwstg->GetI();
    
    IllResult("EnumElements with NULL ppenm",
             pstg->EnumElements(0, NULL, 0, NULL));
    IllResult("EnumElements with non-zero reserved1",
             pstg->EnumElements(1, NULL, 0, &penm));
    IllResult("EnumElements with non-zero reserved2",
             pstg->EnumElements(0, (void *)1, 0, &penm));
    IllResult("EnumElements with non-zero reserved3",
             pstg->EnumElements(0, NULL, 1, &penm));
    
    pwstg->Unwrap();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\reftest\time.cxx ===
#include "../../h/storage.h"
#include "time.hxx"
#include <limits.h>
#include <assert.h>

// Number of seconds difference betwen FILETIME (since 1601 00:00:00) 
// and time_t (since 1970 00:00:00)
//
// This should be a constant difference between the 2 time formats
//
const LONGLONG ci64DiffFTtoTT=11644473600; 

STDAPI_(void) FileTimeToTimeT(const FILETIME *pft, time_t *ptt)
{
    ULONGLONG llFT = pft->dwHighDateTime;
    llFT = (llFT << 32) | (pft->dwLowDateTime);
    // convert to seconds 
    // (note that all fractions of seconds will be lost)
    llFT = llFT/10000000;       
    llFT -= ci64DiffFTtoTT;         // convert to time_t 
    assert(llFT <= ULONG_MAX);
    *ptt = (time_t) llFT;
}

STDAPI_(void) TimeTToFileTime(const time_t *ptt, FILETIME *pft)
{
    ULONGLONG llFT = *ptt;
    llFT += ci64DiffFTtoTT;         // convert to file time
    // convert to nano-seconds
    for (int i=0; i<7; i++)         // mulitply by 10 7 times
    {        
        llFT = llFT << 1;           // llFT = 2x
        llFT += (llFT << 2);        // llFT = 4*2x + 2x = 10x
    }
    pft->dwLowDateTime  = (DWORD) (llFT & 0xffffffff);
    pft->dwHighDateTime = (DWORD) (llFT >> 32);
}

#pragma warning(disable:4514)
// disable warning about unreferenced inline functions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\stgdrt\strlist.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	strlist.cxx
//
//  Contents:	CStrList implementation
//
//---------------------------------------------------------------

#include "headers.cxx"

#include <string.h>

//+--------------------------------------------------------------
//
//  Member:	CStrList::CStrList, public
//
//  Synopsis:	Ctor
//
//---------------------------------------------------------------

CStrList::CStrList(void)
{
    _pseHead = NULL;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::~CStrList, public
//
//  Synopsis:	Dtor
//
//---------------------------------------------------------------

CStrList::~CStrList(void)
{
    Empty();
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Add, public
//
//  Synopsis:	Adds a string to the list
//
//  Arguments:	[ptcs] - String
//
//  Returns:	Pointer to entry or NULL
//
//---------------------------------------------------------------

SStrEntry *CStrList::Add(OLECHAR *ptcs)
{
    SStrEntry *pse;

    // One char of string already counted in sizeof
    pse = (SStrEntry *)new
        char[sizeof(SStrEntry)+olecslen(ptcs)*sizeof(OLECHAR)];
    if (pse == NULL)
	return NULL;
    pse->pseNext = _pseHead;
    pse->psePrev = NULL;
    if (_pseHead)
	_pseHead->psePrev = pse;
    _pseHead = pse;
    olecscpy(pse->atc, ptcs);
    return pse;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Remove, public
//
//  Synopsis:	Removes an entry from the list
//
//  Arguments:	[pse] - Entry
//
//---------------------------------------------------------------

void CStrList::Remove(SStrEntry *pse)
{
    if (pse->psePrev)
	pse->psePrev->pseNext = pse->pseNext;
    else
	_pseHead = pse->pseNext;
    if (pse->pseNext)
	pse->pseNext->psePrev = pse->psePrev;
    delete pse;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Find, public
//
//  Synopsis:	Attempts to find a string in the list
//
//  Arguments:	[ptcs] - String
//
//  Returns:	Entry or NULL
//
//---------------------------------------------------------------

SStrEntry *CStrList::Find(OLECHAR *ptcs)
{
    SStrEntry *pse;

    for (pse = _pseHead; pse; pse = pse->pseNext)
	if (!olecscmp(ptcs, pse->atc))
	    return pse;
    return NULL;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Empty, public
//
//  Synopsis:	Frees all elements in list
//
//---------------------------------------------------------------

void CStrList::Empty(void)
{
    SStrEntry *pse;

    while (_pseHead)
    {
	pse = _pseHead->pseNext;
	delete _pseHead;
	_pseHead = pse;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\stgdrt\tests.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	tests.cxx
//
//  Contents:	DRT tests
//
//---------------------------------------------------------------
#ifdef _WIN32
// for win32 env, we use dll's and therefore have to define the GUIDs
#define INITGUID
#endif

#include "headers.cxx"

#include "tests.hxx"
#include "ilb.hxx"

void t_create(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;
    
    DECLARE_OLESTR(ocsChild, "Child");
    DECLARE_OLESTR(ocsChild2, "Child2");
    DECLARE_OLESTR(ocsStream, "Stream");

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(ocsChild, STGP(WSTG_READWRITE), 0, 0,
			    &pstgChild);
    pstgChild->CreateStorage(ocsChild2, STGP(WSTG_READWRITE), 0, 0,
			     &pstgChild2);
    pstgChild2->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild2->Commit(0);
    pstgChild2->Unwrap();
    pstgChild->Commit(0);
    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dChild2(sStream))");
    pstgRoot->Unwrap();
}

void t_open(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		     0, &pstgRoot);
    CreateStructure(pstgRoot->GetI(), "dChild(dChild2(sStream))");
    pstgRoot->Commit(0);
    pstgRoot->Unwrap();

    DECLARE_OLESTR(ocsChild, "Child");
    DECLARE_OLESTR(ocsChild2, "Child2");
    DECLARE_OLESTR(ocsStream, "Stream");

    WStgOpenStorage(DRTDF, NULL, ROOTP(WSTG_READWRITE), NULL,
		    0, &pstgRoot);
    pstgRoot->OpenStorage(ocsChild, NULL, STGP(WSTG_READWRITE), NULL, 0,
			  &pstgChild);
    pstgChild->OpenStorage(ocsChild2, NULL, STGP(WSTG_READWRITE), NULL, 0,
			   &pstgChild2);
    pstgChild2->OpenStream(ocsStream, NULL, STMP(WSTG_READWRITE), 0,
			   &pstm);
    pstm->Unwrap();
    pstgChild2->Unwrap();
    pstgChild->Unwrap();
    pstgRoot->Unwrap();
}

void t_addref(void)
{
    WStorage *pstg;
    WStream *pstm;
    ULONG ul;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstg);

    DECLARE_OLESTR(ocsChild, "Child");
    DECLARE_OLESTR(ocsChild2, "Child2");
    DECLARE_OLESTR(ocsStream, "Stream");

    pstg->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0, &pstm);
#ifndef FLAT
    if ((ul = pstm->AddRef()) != 2)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstm->Release()) != 1)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    pstm->Unwrap();
    if ((ul = pstg->AddRef()) != 2)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstg->Release()) != 1)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
#else
    if ((ul = pstm->AddRef()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstm->Release()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    pstm->Unwrap();
    if ((ul = pstg->AddRef()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstg->Release()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
#endif
    pstg->Unwrap();
}

void t_dmodify(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;
    ULONG cbSize1, cbSize2;

    DECLARE_OLESTR(ocsChild, "Child");
    DECLARE_OLESTR(ocsChild2, "Child2");
    DECLARE_OLESTR(ocsStream, "Stream");

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(ocsChild, STGP(WSTG_READWRITE), 0,
                            0, &pstgChild);
    pstgChild->CreateStorage(ocsChild2, STGP(WSTG_READWRITE), 0,
			     0, &pstgChild2);
    pstgChild2->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Unwrap();
    VerifyStructure(pstgChild2->GetI(), "sStream");

    // Test renaming a closed stream
    DECLARE_OLESTR(ocsRenamedStream, "RenamedStream");
    pstgChild2->RenameElement(ocsStream, ocsRenamedStream);
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");

    // Test destroying a stream
    pstgChild2->DestroyElement(ocsRenamedStream);

    pstgChild2->Unwrap();
    VerifyStructure(pstgChild->GetI(), "dChild2()");

    // Test renaming a storage
    DECLARE_OLESTR(ocsRenamedChild, "RenamedChild");
    pstgChild->RenameElement(ocsChild2, ocsRenamedChild);
    pstgChild->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild->DestroyElement(ocsStream);

    // Test SetElementTimes
    FILETIME tm;
    STATSTG stat;

    tm.dwLowDateTime = 0x12345678;
    tm.dwHighDateTime = 0x01bcdef0;

    // Set when element not open
    pstgChild->SetElementTimes(ocsRenamedChild, &tm, NULL, NULL);
    pstgChild->SetElementTimes(ocsRenamedChild, NULL, &tm, NULL);
    pstgChild->SetElementTimes(ocsRenamedChild, NULL, NULL, &tm);

    pstgChild->OpenStorage(ocsRenamedChild, NULL, STMP(WSTG_READWRITE),
                           NULL, 0, &pstgChild2);
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualTime(stat.ctime, tm) ||
        !IsEqualTime(stat.mtime, tm))
        error(EXIT_BADSC, "Times don't match those set by SetElementTimes\n");

    // Test SetClass and SetStateBits
    pstgChild2->SetClass(IID_IStorage);
    fExitOnFail = FALSE;
    pstgChild2->SetStateBits(0xff00ff00, 0xffffffff);
    pstgChild2->SetStateBits(0x00880088, 0xeeeeeeee);
    fExitOnFail = TRUE;
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualCLSID(stat.clsid, IID_IStorage))
        error(EXIT_BADSC, "Class ID set improperly\n");
    if (stat.grfStateBits != 0x11881188)
        errorprint("State bits set improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0x11881188);
    pstgChild2->Unwrap();

    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Revert();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Commit(0);
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->DestroyElement(ocsChild);
    VerifyStructure(pstgRoot->GetI(), "");

    // Verify that space is reclaimed after modifications
    pstgRoot->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->SetSize(65536);
    pstm->Unwrap();
    cbSize1 = Length(DRTDF);
    pstgRoot->DestroyElement(ocsStream);
    pstgRoot->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->SetSize(65536);
    pstm->Unwrap();
    cbSize2 = Length(DRTDF);
    if (cbSize1 != cbSize2)
        error(EXIT_BADSC, "Space is not being reclaimed, original %lu, "
              "now %lu\n", cbSize1, cbSize2);

    pstgRoot->Unwrap();

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgRoot);

    //  removal cases
    //    1) no right child

    CreateStructure(pstgRoot->GetI(), "d64,d32");
    VerifyStructure(pstgRoot->GetI(), "d64,d32");
    DECLARE_OLESTR(ocs64, "64");
    pstgRoot->DestroyElement(ocs64);
    VerifyStructure(pstgRoot->GetI(), "d32");

    //    2) right child has no left child

    CreateStructure(pstgRoot->GetI(), "d64");
    VerifyStructure(pstgRoot->GetI(), "d32,d64");
    DECLARE_OLESTR(ocs32, "32");
    pstgRoot->DestroyElement(ocs32);
    VerifyStructure(pstgRoot->GetI(), "d64");

    //    3) right child has left child

    CreateStructure(pstgRoot->GetI(), "d96,d80");
    VerifyStructure(pstgRoot->GetI(), "d64,d80,d96");
    pstgRoot->DestroyElement(ocs64);
    VerifyStructure(pstgRoot->GetI(), "d80,d96");

    //    4) right child's left child has children

    CreateStructure(pstgRoot->GetI(), "d88,d84,d92");
    VerifyStructure(pstgRoot->GetI(), "d80,d84,d88,d92,d96");
    DECLARE_OLESTR(ocs80, "80");
    pstgRoot->DestroyElement(ocs80);
    VerifyStructure(pstgRoot->GetI(), "d84,d88,d92,d96");

    pstgRoot->Unwrap();

}

void t_stat(void)
{
    WStorage *pstgRoot, *pstgChild;
    WStream *pstm;
    STATSTG stat;
    DECLARE_OLESTR(ocsChild, "Child");
    DECLARE_OLESTR(ocsStream, "Stream");

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(ocsChild, STGP(WSTG_READWRITE), 0, 0,
			    &pstgChild);
    pstgChild->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0, &pstm);

    pstm->Stat(&stat, 0);
    VerifyStat(&stat, ocsStream, STGTY_STREAM, STMP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstm->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STREAM, STMP(WSTG_READWRITE));

    pstm->Unwrap();

    pstgChild->Stat(&stat, 0);
    VerifyStat(&stat, ocsChild, STGTY_STORAGE, STGP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstgChild->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STORAGE, STGP(WSTG_READWRITE));

    pstgChild->Unwrap();

    pstgRoot->Stat(&stat, 0);
    OLECHAR atcFullPath[_MAX_PATH+1];
    GetFullPath(DRTDF, atcFullPath, _MAX_PATH+1);
    VerifyStat(&stat, atcFullPath, STGTY_STORAGE, ROOTP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstgRoot->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STORAGE, ROOTP(WSTG_READWRITE));

    pstgRoot->Unwrap();
}

static char NUMBERS[] = "12345678901234567890123456789012345678901234567890";

void t_stream(void)
{
    WStorage *pstg;
    WStream *pstm, *pstmC;
    char buf[sizeof(NUMBERS)*2];
    ULONG cb, ulPos;
    DECLARE_OLESTR(ocsStream, "Stream");

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE, 0, &pstg);
    pstg->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Write(NUMBERS, sizeof(NUMBERS), &cb);
    pstm->Commit(0);
    pstm->Seek(0, WSTM_SEEK_SET, &ulPos);
    if (ulPos != 0)
	error(EXIT_BADSC, "Incorrect seek, ptr is %lu\n", ulPos);
    pstm->Read(buf, sizeof(NUMBERS), &cb);
    if (strcmp(buf, NUMBERS))
	error(EXIT_BADSC, "Incorrect stream contents\n");
    pstm->SetSize(sizeof(NUMBERS)/2);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    fExitOnFail = FALSE;
    pstm->Read(buf, sizeof(NUMBERS), &cb);
    fExitOnFail = TRUE;
    if (cb != sizeof(NUMBERS)/2)
	error(EXIT_BADSC, "SetSize failed to size stream properly\n");
    if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2))
	error(EXIT_BADSC, "SetSize corrupted contents\n");
    pstm->Clone(&pstmC);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->CopyTo(pstmC, sizeof(NUMBERS)/2, NULL, NULL);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->CopyTo(pstmC, sizeof(NUMBERS)&~1, NULL, NULL);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->Read(buf, (sizeof(NUMBERS)&~1)*2, &cb);
    if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+sizeof(NUMBERS)/2, NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+(sizeof(NUMBERS)&~1), NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+3*(sizeof(NUMBERS)/2), NUMBERS, sizeof(NUMBERS)/2))
	error(EXIT_BADSC, "Stream contents incorrect\n");
    pstmC->Unwrap();
    pstm->Unwrap();
    pstg->Unwrap();
}

// Number of entries for enumeration test
#define ENUMENTRIES 10

// Flag indicating a name has already shown up in enumeration,
// must not conflict with STGTY_*
#define ENTRY_SEEN 0x100

// Check the validity of an enumeration element
static void elt_check(STATSTG *pstat, CStrList *psl)
{
    SStrEntry *pse;

    pse = psl->Find(pstat->pwcsName);
    if (pse == NULL)
        error(EXIT_BADSC, "Spurious element '%s'\n", pstat->pwcsName);
    else if ((pse->user.dw & ~ENTRY_SEEN) != pstat->type)
        error(EXIT_BADSC, "Element '%s' has wrong type - "
              "has %lX vs. %lX\n", pstat->pwcsName, pstat->type,
              pse->user.dw & ~ENTRY_SEEN);
    else if (pse->user.dw & ENTRY_SEEN)
        error(EXIT_BADSC, "Element '%s' has already been seen\n",
              pstat->pwcsName);
    pse->user.dw |= ENTRY_SEEN;
}

// Do final validity checks for enumeration
static void enum_list_check(CStrList *psl)
{
    SStrEntry *pse;

    for (pse = psl->GetHead(); pse; pse = pse->pseNext)
    {
        if ((pse->user.dw & ENTRY_SEEN) == 0)
            error(EXIT_BADSC, "Element '%s' not found\n", pse->atc);
        pse->user.dw &= ~ENTRY_SEEN;
    }
}

void t_enum(void)
{
    int i;    
    char pchName[CWCSTORAGENAME];
    OLECHAR atcName[CWCSTORAGENAME];
    WStorage *pstg, *pstg2;
    WStream *pstm;
    SStrEntry *pse;
    CStrList sl;

    // Create some entries to enumerate
    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE, 0, &pstg);
    for (i = 0; i<ENUMENTRIES; i++)
    {
	sprintf(pchName, "Name%d", rand());
        STOT(pchName, atcName, strlen(pchName)+1);
	pse = sl.Add(atcName);
	if (rand()%100 < 50)
	{
	    pse->user.dw = STGTY_STORAGE;
	    pstg->CreateStorage(atcName, STGP(WSTG_READWRITE), 0, 0, &pstg2);
	    pstg2->Unwrap();
	}
	else
	{
	    pse->user.dw = STGTY_STREAM;
	    pstg->CreateStream(atcName, STMP(WSTG_READWRITE), 0, 0, &pstm);
	    pstm->Unwrap();
	}
    }

    WEnumSTATSTG *penm;
    STATSTG stat[2*ENUMENTRIES];
    SCODE sc;

    // Test plain, single element enumeration
    pstg->EnumElements(0, NULL, 0, &penm);
    for (;;)
    {
	sc = DfGetScode(penm->Next(1, stat, NULL));
	if (sc == S_FALSE)
	    break;
        elt_check(stat, &sl);
        drtMemFree(stat->pwcsName);

    }
    enum_list_check(&sl);

    ULONG cFound;

    // Test rewind and multiple element enumeration with too many elements
    penm->Reset();
    sc = DfGetScode(penm->Next(ENUMENTRIES*2, stat, &cFound));
    if (sc != S_FALSE)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_FALSE\n", ScText(sc), sc);
    if (cFound != ENUMENTRIES)
        error(EXIT_BADSC, "Enumerator found %lu entries instead of "
              "%d entries\n", cFound, ENUMENTRIES);
    for (; cFound > 0; cFound--)
    {
        elt_check(&stat[cFound-1], &sl);
        drtMemFree(stat[cFound-1].pwcsName);
    }
    enum_list_check(&sl);

    // Test skip and multiple enumeration with exact number of elements
    penm->Reset();
    penm->Skip(ENUMENTRIES/2);
    sc = DfGetScode(penm->Next(ENUMENTRIES-ENUMENTRIES/2, stat, &cFound));
    if (sc != S_OK)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_OK\n", ScText(sc), sc);
    if (cFound != ENUMENTRIES-ENUMENTRIES/2)
        error(EXIT_BADSC, "Enumerator found %lu entries instead of "
              "%d entries\n", cFound, ENUMENTRIES-ENUMENTRIES/2);
    for (; cFound > 0; cFound--)
    {
        elt_check(&stat[cFound-1], &sl);
        drtMemFree(stat[cFound-1].pwcsName);
    }
    sc = DfGetScode(penm->Next(1, stat, NULL));
    if (sc != S_FALSE)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_FALSE\n", ScText(sc), sc);

    penm->Unwrap();
    pstg->Unwrap();
}

#define SCT_CLASSID IID_ILockBytes
#define SCT_STATEBITS 0xfef1f0f0

void t_stgcopyto(void)
{
    WStorage *pstgFrom, *pstgTo;
    STATSTG statFrom, statTo;

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgFrom);
    pstgFrom->Stat(&statFrom, 0);

    // Set some interesting values to make sure they're copied
    pstgFrom->SetClass(SCT_CLASSID);
    fExitOnFail = FALSE;
    pstgFrom->SetStateBits(SCT_STATEBITS, 0xffffffff);
    fExitOnFail = TRUE;

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgTo);
    CreateStructure(pstgFrom->GetI(), "dA(dB(dC(sA,sB,sC),sCs),sBs),sAs");
    CreateStructure(pstgTo->GetI(), "dA(dY(sZ),sBs)");

    pstgFrom->CopyTo(0, NULL, NULL, pstgTo);

    VerifyStructure(pstgTo->GetI(),
		    "dA(dB(dC(sA,sB,sC),sCs),dY(sZ),sBs),sAs");
    pstgTo->Stat(&statTo, 0);
    if (!IsEqualCLSID(statTo.clsid, SCT_CLASSID))
        error(EXIT_BADSC, "Class ID mismatch after copy\n");
    if (statTo.grfStateBits != SCT_STATEBITS)
        errorprint("State bits mismatch: has %lX vs. %lX\n",
              statTo.grfStateBits, SCT_STATEBITS);

    pstgFrom->Unwrap();
    pstgTo->Unwrap();
    if (Exists(statFrom.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statFrom.pwcsName);
    drtMemFree(statFrom.pwcsName);
    if (Exists(statTo.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statTo.pwcsName);
    drtMemFree(statTo.pwcsName);
}

void t_stgmisc(void)
{
    WStorage *pstg;
    SCODE sc;
    STATSTG stat;

    // Can't make this call in transacted mode because we want
    // the storage signature to make it into the file right away
    WStgCreateDocfile(DRTDF, WSTG_READWRITE | WSTG_CREATE |
	WSTG_SHARE_EXCLUSIVE, 0, &pstg);

    sc = DfGetScode(WStgIsStorageFile(DRTDF));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Open file - Should be a storage object\n");
    pstg->Unwrap();
    sc = DfGetScode(WStgIsStorageFile(DRTDF));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Closed file - Should be a storage object\n");
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
	    WSTG_DELETEONRELEASE, 0, &pstg);
    pstg->Stat(&stat, 0);
    if (!Exists(stat.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not created\n", stat.pwcsName);
    pstg->Unwrap();
    if (Exists(stat.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted on release\n",
	    stat.pwcsName);
    drtMemFree(stat.pwcsName);
}

void t_ilb(void)
{
    WStorage *pstg;
    SCODE sc;
    //  create an ILockBytes

    ILockBytes *pilb = new CMapBytes();
    if (pilb == NULL)
	error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");

    //  create a storage on the ILockBytes

    WStgCreateDocfileOnILockBytes(pilb,
				  WSTG_READWRITE |
                                  WSTG_CREATE    |
                                  WSTG_SHARE_EXCLUSIVE,
                                  0, &pstg);

    //  verify the ILockBytes

    sc = DfGetScode(WStgIsStorageILockBytes(pilb));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Open ILockBytes - Should be a storage object\n");

    //  release the storage

    pstg->Unwrap();

    //  verify the ILockBytes

    sc = DfGetScode(WStgIsStorageILockBytes(pilb));

    if (sc == S_FALSE)
	error(EXIT_BADSC, "Released ILockBytes - Should be a storage object\n");

    //  open the ILockBytes

    WStgOpenStorageOnILockBytes(pilb, NULL, ROOTP(WSTG_READWRITE),
				NULL, 0, &pstg);


    //  release the storage

    pstg->Unwrap();

    //  release the ILockBytes

    pilb->Release();
}

void t_movecopy(void)
{
    WStorage *pstgFrom, *pstgTo;
    STATSTG statFrom, statTo;

    //  create a source
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgFrom);
    pstgFrom->Stat(&statFrom, 0);

    //  create a destination
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgTo);
    pstgTo->Stat(&statTo, 0);

    //  populate source
    CreateStructure(pstgFrom->GetI(), "dA(dB(dC(sA,sB,sC),sCs),sBs),sAs");

    DECLARE_OLESTR(ocsM, "M");
    DECLARE_OLESTR(ocsA, "A");
    //  move a storage
    pstgFrom->MoveElementTo(ocsA, pstgTo, ocsM, STGMOVE_MOVE);
    VerifyStructure(pstgFrom->GetI(),
                    "sAs");
    VerifyStructure(pstgTo->GetI(),
                    "dM(dB(dC(sA,sB,sC),sCs),sBs)");

    //  copy a stream
    DECLARE_OLESTR(ocsBs, "Bs");
    DECLARE_OLESTR(ocsAs, "As");
    pstgFrom->MoveElementTo(ocsAs, pstgTo, ocsBs, STGMOVE_COPY);
    VerifyStructure(pstgFrom->GetI(),
                    "sAs");
    VerifyStructure(pstgTo->GetI(),
                    "dM(dB(dC(sA,sB,sC),sCs),sBs),sBs");

    pstgFrom->Unwrap();
    pstgTo->Unwrap();
    if (Exists(statFrom.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statFrom.pwcsName);
    drtMemFree(statFrom.pwcsName);
    if (Exists(statTo.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statTo.pwcsName);
    drtMemFree(statTo.pwcsName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\stgdrt\util.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	util.cxx
//
//  Contents:	DRT support routines
//
//---------------------------------------------------------------

#include "headers.cxx"

#include <stdarg.h>
#ifdef _WIN32
#include <direct.h>
#include <io.h>
#else
#include "winio.hxx"
#endif

#define DEFAULT_DATA_DIR "."

BOOL fExitOnFail = TRUE;

char szOrigDir[_MAX_PATH] = ".";

// Preserve the current directory and change
// directory into the data directory
void SetData(void)
{
    char *pszDataDir;

    _getcwd(szOrigDir, _MAX_PATH);
    pszDataDir = getenv("DRTDATA");
    if (pszDataDir == NULL)
	pszDataDir = DEFAULT_DATA_DIR;
    _chdir(pszDataDir);
}

// Clean up the data directory
void CleanData(void)
{
    _unlink(pszDRTDF);
}

// Restore the original directory
void UnsetData(void)
{
    _chdir(szOrigDir);
}

// Output a message if fVerbose is true
void out(char *fmt, ...)
{
    va_list args;

    if (fVerbose)
    {
	va_start(args, fmt);
	vprintf(fmt, args);
	va_end(args);
    }
}

//  internal error print
void _errorprint (char *fmt, va_list args)
{
    printf("** Fatal error **: ");
    vprintf(fmt, args);
}

//  error print
void errorprint (char *fmt, ...)
{
    va_list args;

    va_start (args, fmt);

    _errorprint (fmt, args);

    va_end (args);
}

// Print out an error message and terminate the DRT
void error(int code, char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);

    _errorprint (fmt, args);

    va_end(args);
    CleanData();
    UnsetData();
    exit(code);
}


// Converts a TCHAR string to a char pointer in a temporary buffer
// This implementation treats the conversion buffer as a circular
// buffer so more than one string can be held (depending on the size
// of the strings)

#define BUFSIZE 1024

char *OlecsOut(OLECHAR const *ptcs)
{
#ifdef OLEWIDECHAR
    static char szBuffer[BUFSIZE];
    static char *pszBuf = szBuffer;
    char *pszTmp;

    if (ptcs == NULL)
        return NULL;
    if (wcslen(ptcs) >= (size_t)(BUFSIZE-(pszBuf-szBuffer)))
        pszBuf = szBuffer;
    OLETOA(ptcs, pszBuf, BUFSIZE);
    szBuffer[BUFSIZE-1] = 0;
    pszTmp = pszBuf;
    pszBuf += strlen(pszBuf)+1;
    return pszTmp;
#else
    return (char *)ptcs;
#endif
}

typedef struct
{
    SCODE sc;
    char *text;
} StatusCodeText;

static StatusCodeText scodes[] =
{
    S_OK, "S_OK",
    S_FALSE, "S_FALSE",
    STG_E_INVALIDFUNCTION, "STG_E_INVALIDFUNCTION",
    STG_E_FILENOTFOUND, "STG_E_FILENOTFOUND",
    STG_E_PATHNOTFOUND, "STG_E_PATHNOTFOUND",
    STG_E_TOOMANYOPENFILES, "STG_E_TOOMANYOPENFILES",
    STG_E_ACCESSDENIED, "STG_E_ACCESSDENIED",
    STG_E_INVALIDHANDLE, "STG_E_INVALIDHANDLE",
    STG_E_INSUFFICIENTMEMORY, "STG_E_INSUFFICIENTMEMORY",
    STG_E_INVALIDPOINTER, "STG_E_INVALIDPOINTER",
    STG_E_NOMOREFILES, "STG_E_NOMOREFILES",
    STG_E_DISKISWRITEPROTECTED, "STG_E_DISKISWRITEPROTECTED",
    STG_E_SEEKERROR, "STG_E_SEEKERROR",
    STG_E_WRITEFAULT, "STG_E_WRITEFAULT",
    STG_E_READFAULT, "STG_E_READFAULT",
    STG_E_SHAREVIOLATION, "STG_E_SHAREVIOLATION",
    STG_E_LOCKVIOLATION, "STG_E_LOCKVIOLATION",
    STG_E_FILEALREADYEXISTS, "STG_E_FILEALREADYEXISTS",
    STG_E_INVALIDPARAMETER, "STG_E_INVALIDPARAMETER",
    STG_E_MEDIUMFULL, "STG_E_MEDIUMFULL",
    STG_E_ABNORMALAPIEXIT, "STG_E_ABNORMALAPIEXIT",
    STG_E_INVALIDHEADER, "STG_E_INVALIDHEADER",
    STG_E_INVALIDNAME, "STG_E_INVALIDNAME",
    STG_E_UNKNOWN, "STG_E_UNKNOWN",
    STG_E_UNIMPLEMENTEDFUNCTION, "STG_E_UNIMPLEMENTEDFUNCTION",
    STG_E_INVALIDFLAG, "STG_E_INVALIDFLAG",
    STG_E_INUSE, "STG_E_INUSE",
    STG_E_NOTCURRENT, "STG_E_NOTCURRENT",
    STG_E_REVERTED, "STG_E_REVERTED",
    STG_E_CANTSAVE, "STG_E_CANTSAVE",
    STG_E_OLDFORMAT, "STG_E_OLDFORMAT",
    STG_E_OLDDLL, "STG_E_OLDDLL",
    STG_E_SHAREREQUIRED, "STG_E_SHAREREQUIRED",
    STG_E_NOTFILEBASEDSTORAGE, "STG_E_NOTFILEBASEDSTORAGE",
    STG_S_CONVERTED, "STG_S_CONVERTED"
};
#define NSCODETEXT (sizeof(scodes)/sizeof(scodes[0]))

// Convert a status code to text
char *ScText(SCODE sc)
{
    int i;

    for (i = 0; i<NSCODETEXT; i++)
	if (scodes[i].sc == sc)
	    return scodes[i].text;
    return "?";
}

// Output a call result and check for failure
HRESULT Result(HRESULT hr)
{
    SCODE sc;

    sc = DfGetScode(hr);
    out(" - %s (0x%lX)\n", ScText(sc), sc);
    if (FAILED(sc) && fExitOnFail)
        error(EXIT_BADSC, "Unexpected call failure\n");
    return hr;
}

// Perform Result() when the expectation is failure
HRESULT IllResult(char *pszText, HRESULT hr)
{
    SCODE sc;

    sc = DfGetScode(hr);
    out("%s - %s (0x%lX)\n", pszText, ScText(sc), sc);
    if (SUCCEEDED(sc) && fExitOnFail)
        error(EXIT_BADSC, "Unexpected call success\n");
    return hr;
}

// Check whether a given storage has a certain
// structure or not
// Structure is given as a string with elements:
//   <Type><Name><Options>[,...]
//   Type - d for docfile and s for stream
//   Name - Characters up to a '(' or ','
//   Options - For a docfile, you can specify a recursive check
//     in parentheses
//
// Example:  dDocfile(sStream,dDocfile)
char *VerifyStructure(IStorage *pstg, char *pszStructure)
{
    char szName[CWCSTORAGENAME], *psz;
    IStorage *pstgChild;
    char chType;
    SCODE sc;
    CStrList sl;
    SStrEntry *pse;
    IEnumSTATSTG *penm;
    STATSTG stat;
    OLECHAR atcName[CWCSTORAGENAME];

    if (FAILED(sc = DfGetScode(pstg->EnumElements(0, NULL, 0, &penm))))
	error(EXIT_BADSC, "VerifyStructure: Unable to create enumerator - "
	      "%s (0x%lX)\n", ScText(sc), sc);
    for (;;)
    {
	sc = DfGetScode(penm->Next(1, &stat, NULL));
	if (sc == S_FALSE)
	    break;
	else if (FAILED(sc))
	    error(EXIT_BADSC, "VerifyStructure: Unable to enumerate - "
	      "%s (0x%lX)\n", ScText(sc), sc);
	pse = sl.Add(stat.pwcsName);
	if (pse == NULL)
	    error(EXIT_OOM, "VerifyStructure: Unable to allocate string\n");
	pse->user.dw = stat.type;
	drtMemFree(stat.pwcsName);
    }
    penm->Release();
    while (*pszStructure && *pszStructure != ')')
    {
	chType = *pszStructure++;
	psz = szName;
	while (*pszStructure && *pszStructure != '(' &&
	       *pszStructure != ')' && *pszStructure != ',')
	    *psz++ = *pszStructure++;
	*psz = 0;
        ATOOLE(szName, atcName, CWCSTORAGENAME);
	pse = sl.Find(atcName);
	if (pse == NULL)
	    error(EXIT_BADSC, "VerifyStructure: '%s' not found\n", szName);
	switch(chType)
	{
	case 'd':
	    if (pse->user.dw != STGTY_STORAGE)
		error(EXIT_BADSC, "VerifyStructure: '%s' is not a storage\n",
		      szName);
	    sc = DfGetScode(pstg->OpenStorage(atcName, NULL,
                                              STGP(STGM_READWRITE), NULL,
                                              0, &pstgChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "VerifyStructure: can't open storage "
		      "'%s' - %s\n", szName, ScText(sc));
	    if (*pszStructure == '(')
		pszStructure = VerifyStructure(pstgChild, pszStructure+1)+1;
	    pstgChild->Release();
	    break;
	case 's':
	    if (pse->user.dw != STGTY_STREAM)
		error(EXIT_BADSC, "VerifyStructure: '%s' is not a stream\n",
		      szName);
	    break;
	}
	sl.Remove(pse);
	if (*pszStructure == ',')
	    pszStructure++;
    }
    for (pse = sl.GetHead(); pse; pse = pse->pseNext)
	error(EXIT_BADSC, "VerifyStructure: additional member '%s'\n",
	      OlecsOut(pse->atc));
    return pszStructure;
}

// Creates a structure using the same syntax
// as VerifyStructure
char *CreateStructure(IStorage *pstg, char *pszStructure)
{
    char szName[CWCSTORAGENAME], *psz;
    IStorage *pstgChild;
    IStream *pstmChild;
    char chType;
    SCODE sc;
    OLECHAR atcName[CWCSTORAGENAME];

    while (*pszStructure && *pszStructure != ')')
    {
	chType = *pszStructure++;
	psz = szName;
	while (*pszStructure && *pszStructure != '(' &&
	       *pszStructure != ')' && *pszStructure != ',')
	    *psz++ = *pszStructure++;
	*psz = 0;
        ATOOLE(szName, atcName, CWCSTORAGENAME);
	switch(chType)
	{
	case 'd':
	    sc = DfGetScode(pstg->CreateStorage(atcName, STGP(STGM_READWRITE),
                                                0, 0, &pstgChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "CreateStructure: can't create storage "
		      "'%s' - %s\n", szName, ScText(sc));
	    if (*pszStructure == '(')
		pszStructure = CreateStructure(pstgChild, pszStructure+1)+1;
	    pstgChild->Release();
	    break;
	case 's':
	    sc = DfGetScode(pstg->CreateStream(atcName, STMP(STGM_READWRITE),
                                               0, 0, &pstmChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "CreateStructure: can't create stream "
		      "'%s' - %s\n", szName, ScText(sc));
	    pstmChild->Release();
	    break;
	}
	if (*pszStructure == ',')
	    pszStructure++;
    }
    pstg->Commit(0);
    return pszStructure;
}

// Verifies the fields of a STATSTG
void VerifyStat(STATSTG *pstat, OLECHAR *ptcsName, DWORD type, DWORD grfMode)
{
    if (ptcsName == NULL)
    {
        if (pstat->pwcsName != NULL)
	    error(EXIT_BADSC, "Stat name should be NULL - is %p\n",
                  pstat->pwcsName);
    }
    else if (olecscmp(pstat->pwcsName, ptcsName))
	error(EXIT_BADSC, "Stat name mismatch - has '%s' vs. '%s'\n",
	      OlecsOut(pstat->pwcsName), OlecsOut(ptcsName));
    if (pstat->type != type)
	error(EXIT_BADSC, "Stat type mismatch - has %lu vs. %lu\n",
	      pstat->type, type);
    if (pstat->grfMode != grfMode)
	error(EXIT_BADSC, "Stat mode mismatch - has 0x%lX vs. 0x%lX\n",
	      pstat->grfMode, grfMode);
}

// Checks on a file's existence
BOOL Exists(OLECHAR* ocsFile)
{   
    char pszFile[_MAX_PATH];
    TTOS(ocsFile, pszFile, _tcslen(ocsFile)+1);
    FILE *f=fopen(pszFile, "r");
    BOOL fExists= (f!=NULL);
    if (f!=NULL) fclose(f);
    return (fExists);
}

// Gets a file's length
ULONG Length(OLECHAR *ocsFile)
{
    ULONG cb;
    char pszFile[_MAX_PATH];
    TTOS(ocsFile, pszFile, _tcslen(ocsFile)+1);

    FILE *f=fopen(pszFile, "r");
    if (!f) 
	error(EXIT_BADSC, "Length: Unable to open '%s'\n", pszFile);
    int rcode=fseek(f, 0, SEEK_END);
    if (rcode!=0)
	error(EXIT_BADSC, "Length: Unable to get length for '%s'\n",
	      pszFile);
    cb= (ULONG) ftell(f);
    fclose(f);

    return cb;
}

// Equality for FILETIME
BOOL IsEqualTime(FILETIME ttTime, FILETIME ttCheck)
{
#ifdef _UNIX
    #ifdef LONGLONG
    #error "LONGLONG should not be defined"
    #else
    #define LONGLONG time_t
    #endif
#endif
    //  File times can be off by as much as 2 seconds due to FAT rounding
    LONGLONG tmTime = *(LONGLONG *)&ttTime;
    LONGLONG tmCheck = *(LONGLONG *)&ttCheck;
    LONGLONG tmDelta = tmTime - tmCheck;
#ifdef _UNIX
    #undef LONGLONG
#endif
#ifndef _UNIX
    return tmDelta < 20000000i64 && tmDelta > -2i64 ;
#else
    return tmDelta < 2; // time_t is in seconds
#endif
}

// Get a fully qualified path for a file name
void GetFullPath(TCHAR *ocsFile, TCHAR *ocsPath, int len)
{
    char pszPath[_MAX_PATH+1], pszFile[_MAX_PATH+1];
    TTOS(ocsFile, pszFile, _tcslen(ocsFile)+1);
    _fullpath(pszPath, pszFile, len);
    STOT(pszPath, ocsPath, strlen(pszPath)+1);
}

//  Memory helper functions

HRESULT drtMemAlloc(ULONG ulcb, void **ppv)
{
    HRESULT hr;
    IMalloc *pMalloc = NULL;

    if (SUCCEEDED(DfGetScode(hr = CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        *ppv = pMalloc->Alloc(ulcb);
        pMalloc->Release();

        if (*ppv == NULL)
            return ResultFromScode(E_OUTOFMEMORY);
    }

    return hr;
}

void drtMemFree(void *pv)
{
    IMalloc FAR* pMalloc;
    if (SUCCEEDED(GetScode(CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        pMalloc->Free(pv);
        pMalloc->Release();
    }
}

#ifdef _MSC_VER
#pragma pack(1)
#endif

struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};

#ifdef _MSC_VER
#pragma pack()
#endif

char *GuidText(GUID const *pguid)
{
    static char buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    sprintf(buf, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\simp\simpenm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       simpenm.cxx
//
//  Contents:   SimpEnumSTATSTG class implementation
//
//  Classes:    CSimpEnumSTATSTG
//
//  Functions:  
//
//  History:     04-May-96       HenryLee       Created
//
//----------------------------------------------------------------------------

#include "simphead.cxx"
#pragma hdrstop
#include <expparam.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::QueryInterface, public
//
//  Synopsis:   Init function
//
//  Arguments:  [riid] -- reference to desired interface ID
//              [ppvObj] -- output pointer to interface
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSimpEnumSTATSTG::QueryInterface (REFIID riid, void **ppvObj)
{
    simpDebugOut((DEB_ITRACE,"In  CSimpEnumSTATSTG::QueryInterface %p\n",this));

    SCODE sc = S_OK;

    SIMP_VALIDATE(QueryInterface(riid, ppvObj));

    *ppvObj = NULL;

    if (riid == IID_IEnumSTATSTG || riid == IID_IUnknown)
    { 
        *ppvObj = this;
        AddRef ();
    }
    else
        sc = E_NOINTERFACE;

    simpDebugOut((DEB_ITRACE, "Out CSimpEnumSTATSTG::QueryInterface\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::AddRef, public
//
//  Synopsis:
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpEnumSTATSTG::AddRef ()
{
    simpDebugOut((DEB_TRACE, "In  CSimpEnumSTATSTG::AddRef()\n"));
    simpAssert(_cReferences > 0);

    LONG lRet = AtomicInc(&_cReferences);

    simpDebugOut((DEB_TRACE, "Out CSimpEnumSTATSTG::AddRef()\n"));
    return (ULONG) lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::Release, public
//
//  Synopsis:   
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpEnumSTATSTG::Release ()
{
    simpDebugOut((DEB_TRACE, "In  CSimpEnumSTATSTG::Release()\n"));
    simpAssert(_cReferences > 0);

    LONG lRet = AtomicDec(&_cReferences);
    if (lRet == 0)
    {
        delete this;
    }

    simpDebugOut((DEB_TRACE, "Out CSimpEnumSTATSTG::Release()\n"));
    return (ULONG) lRet;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::Next, public
//
//  Synopsis:
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpEnumSTATSTG::Next (ULONG celt,  STATSTG *rgelt,
                                     ULONG *pceltFetched) 
{
    SCODE sc = S_OK;
    simpDebugOut((DEB_TRACE, "In  CSimpEnumSTATSTG::Next()\n"));

    if (celt != 1 || rgelt == NULL)
        return STG_E_INVALIDPARAMETER;

    if (pceltFetched)
        *pceltFetched = 0;

    if (_pdflCurrent == _pdfl && _pdfl != NULL)
        _pdflCurrent = _pdflCurrent->GetNext();   // skip the root directory

    if (_pdflCurrent != NULL)
    {
        memset (rgelt, 0, sizeof(STATSTG));
        rgelt->pwcsName = (WCHAR *) CoTaskMemAlloc (
            _pdflCurrent->GetName()->GetLength()+sizeof(WCHAR));

        if (rgelt->pwcsName)
        {
            memcpy (rgelt->pwcsName, _pdflCurrent->GetName()->GetBuffer(),
                _pdflCurrent->GetName()->GetLength());
            rgelt->pwcsName[_pdflCurrent->GetName()->GetLength()/
                            sizeof(WCHAR)] = L'\0';
            rgelt->cbSize.LowPart = _pdflCurrent->GetSize();
            rgelt->cbSize.HighPart = 0;
            rgelt->type = STGTY_STREAM;

            _pdflCurrent = _pdflCurrent->GetNext();
            if (pceltFetched)
                *pceltFetched = 1;
        }
        else
            sc = STG_E_INSUFFICIENTMEMORY;

    }
    else  // end of list
    {
        sc = S_FALSE;
    }

    simpDebugOut((DEB_TRACE, "Out CSimpEnumSTATSTG::Next()\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::Skip, public
//
//  Synopsis:
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpEnumSTATSTG::Skip (ULONG celt)
{
    simpDebugOut((DEB_TRACE, "In  CSimpEnumSTATSTG::Skip()\n"));
    SCODE sc = STG_E_INVALIDFUNCTION;

    simpDebugOut((DEB_TRACE, "Out CSimpEnumSTATSTG::Skip()\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::Reset, public
//
//  Synopsis:
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpEnumSTATSTG::Reset (void)
{
    SCODE sc = S_OK;
    simpDebugOut((DEB_TRACE, "In  CSimpEnumSTATSTG::Reset()\n"));

    _pdflCurrent = _pdfl; 

    simpDebugOut((DEB_TRACE, "Out CSimpEnumSTATSTG::Reset()\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::Clone, public
//
//  Synopsis:
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpEnumSTATSTG::Clone (IEnumSTATSTG **ppenum)
{
    SCODE sc = S_OK;
    simpDebugOut((DEB_TRACE, "In  CSimpEnumSTATSTG::Clone()\n"));

    if (ppenum == NULL)
        return STG_E_INVALIDPARAMETER;

    if ((*ppenum = new CSimpEnumSTATSTG (_pdfl, _pdflCurrent)) == NULL)
        sc = STG_E_INSUFFICIENTMEMORY;

    simpDebugOut((DEB_TRACE, "Out CSimpEnumSTATSTG::Clone()\n"));
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\stgdrt\wrap.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	wrap.cxx
//
//  Contents:	Wrapper implementations
//
//---------------------------------------------------------------

#include "headers.cxx"

// Retrieve interface pointer for possibly NULL objects
#define SAFEI(obj) ((obj) ? (obj)->GetI() : NULL)

//+--------------------------------------------------------------
//
//  IStorage wrappers
//
//---------------------------------------------------------------

WStorage *WStorage::Wrap(IStorage *pistg)
{
    WStorage *wstg;

    wstg = new WStorage(pistg);
    if (wstg == NULL)
	error(EXIT_OOM, "Unable to wrap IStorage\n");
    return wstg;
}

WStorage::WStorage(IStorage *pstg)
{
    // Note:  takes ownership of pstg
    _pstg = pstg;
}

WStorage::~WStorage(void)
{
    if (_pstg)
	Release();
}

void WStorage::Unwrap(void)
{
    delete this;
}

HRESULT WStorage::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IStorage %p::QueryInterface(riid, %p)", _pstg, ppvObj);
    return Result(_pstg->QueryInterface(riid, ppvObj));
}

ULONG WStorage::AddRef(void)
{
    ULONG ul;

    ul = _pstg->AddRef();
    out("IStorage %p::AddRef() - %lu\n", _pstg, ul);
    return ul;
}

ULONG WStorage::Release(void)
{
    ULONG ul;

    ul = _pstg->Release();
    out("IStorage %p::Release() - %lu\n", _pstg, ul);
    if (ul == 0)
	_pstg = NULL;
    return ul;
}

HRESULT WStorage::CreateStream(const OLECHAR * pwcsName,
			     const DWORD grfMode,
			     DWORD reserved1,
			     DWORD reserved2,
			     WStream **ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStorage %p::CreateStream(%s, 0x%lX, %lu, %lu, %p)", _pstg,
	OlecsOut(pwcsName), grfMode, reserved1, reserved2, ppstm);
    hr = Result(_pstg->CreateStream(pwcsName, grfMode, reserved1,
                                    reserved2, &pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

HRESULT WStorage::OpenStream(const OLECHAR * pwcsName,
			   void *reserved1,
			   const DWORD grfMode,
			   DWORD reserved2,
			   WStream **ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStorage %p::OpenStream(%s, %p, 0x%lX, %lu, %p)", _pstg,
	OlecsOut(pwcsName), reserved1, grfMode, reserved2, ppstm);
    hr = Result(_pstg->OpenStream(pwcsName, reserved1, grfMode,
				 reserved2, &pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

HRESULT WStorage::CreateStorage(const OLECHAR * pwcsName,
			      const DWORD grfMode,
			      DWORD reserved1,
                              DWORD reserved2,
			      WStorage **ppstg)
{
    HRESULT hr;
    IStorage *pistg;

    out("IStorage %p::CreateStorage(%s, 0x%lX, %lu, %lu, %p)", _pstg,
        OlecsOut(pwcsName), grfMode, reserved1, reserved2, ppstg);
    hr = Result(_pstg->CreateStorage(pwcsName, grfMode, reserved1,
                                     reserved2, &pistg));
    *ppstg = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStorage::OpenStorage(const OLECHAR * pwcsName,
			    WStorage *pstgPriority,
			    const DWORD grfMode,
			    SNB snbExclude,
			    DWORD reserved,
			    WStorage **ppstg)
{
    HRESULT hr;
    IStorage *pistg;

    out("IStorage %p::OpenStorage(%s, %p, 0x%lX, %p, %lu, %p)", _pstg,
	OlecsOut(pwcsName), SAFEI(pstgPriority), grfMode,
	snbExclude, reserved, ppstg);
    hr = Result(_pstg->OpenStorage(pwcsName, (IStorage*) SAFEI(pstgPriority),
                                   grfMode, snbExclude,
                                   reserved, &pistg));
    *ppstg = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStorage::CopyTo(DWORD ciidExclude,
		       IID *rgiidExclude,
		       SNB snbExclude,
		       WStorage *pstgDest)
{
    out("IStorage %p::CopyTo(%lu, %p, %p, %p)", _pstg, ciidExclude,
	rgiidExclude, snbExclude, pstgDest->GetI());
    return Result(_pstg->CopyTo(ciidExclude, rgiidExclude, snbExclude,
                                pstgDest->GetI()));
}

HRESULT WStorage::MoveElementTo(OLECHAR const FAR* lpszName,
    			WStorage FAR *pstgDest,
                        OLECHAR const FAR* lpszNewName,
                        DWORD grfFlags)
{
    out("IStorage %p::MoveElementTo(%p, %p, %p, %lu)", _pstg, lpszName,
	pstgDest->GetI(), lpszNewName, grfFlags);
    return Result(_pstg->MoveElementTo(lpszName, pstgDest->GetI(),
                                       lpszNewName, grfFlags));
}

HRESULT WStorage::Commit(const DWORD grfCommitFlags)
{
    out("IStorage %p::Commit(0x%lX)", _pstg, grfCommitFlags);
    return Result(_pstg->Commit(grfCommitFlags));
}

HRESULT WStorage::Revert(void)
{
    out("IStorage %p::Revert()", _pstg);
    return Result(_pstg->Revert());
}

HRESULT WStorage::EnumElements(DWORD reserved1,
			     void *reserved2,
			     DWORD reserved3,
			     WEnumSTATSTG **ppenm)
{
    HRESULT hr;
    IEnumSTATSTG *pienm;

    out("IStorage %p::EnumElements(%lu, %p, %lu, %p)", _pstg,
	reserved1, reserved2, reserved3, ppenm);
    hr = Result(_pstg->EnumElements(reserved1, reserved2, reserved3, &pienm));
    *ppenm = WEnumSTATSTG::Wrap(pienm);
    return hr;
}

HRESULT WStorage::DestroyElement(const OLECHAR * pwcsName)
{
    out("IStorage %p::DestroyElement(%s)", _pstg, OlecsOut(pwcsName));
    return Result(_pstg->DestroyElement(pwcsName));
}

HRESULT WStorage::RenameElement(const OLECHAR * pwcsOldName,
			      const OLECHAR * pwcsNewName)
{
    out("IStorage %p::RenameElement(%s, %s)", _pstg, OlecsOut(pwcsOldName),
	OlecsOut(pwcsNewName));
    return Result(_pstg->RenameElement(pwcsOldName, pwcsNewName));
}

HRESULT WStorage::SetElementTimes(const OLECHAR *lpszName,
                                FILETIME const *pctime,
                                FILETIME const *patime,
                                FILETIME const *pmtime)
{
    out("IStorage %p::SetElementTimes(%s, %p, %p, %p)", _pstg,
        OlecsOut(lpszName), pctime, patime, pmtime);
    return Result(_pstg->SetElementTimes(lpszName, pctime, patime, pmtime));
}

HRESULT WStorage::SetClass(REFCLSID clsid)
{
    out("IStorage %p::SetClass(%s)", _pstg, GuidText(&clsid));
    return Result(_pstg->SetClass(clsid));
}

HRESULT WStorage::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    out("IStorage %p::SetStateBits(0x%lX, 0x%lX)", _pstg, grfStateBits,
        grfMask);
    return Result(_pstg->SetStateBits(grfStateBits, grfMask));
}

HRESULT WStorage::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    out("IStorage %p::Stat(%p, %lu)", _pstg, pstatstg, grfStatFlag);
    return Result(_pstg->Stat(pstatstg, grfStatFlag));
}

//+--------------------------------------------------------------
//
//  IStream wrappers
//
//---------------------------------------------------------------

WStream *WStream::Wrap(IStream *pistm)
{
    WStream *wstm;

    wstm = new WStream(pistm);
    if (wstm == NULL)
	error(EXIT_OOM, "Unable to wrap IStream\n");
    return wstm;
}

WStream::WStream(IStream *pstm)
{
    // Note:  takes ownership of pstm
    _pstm = pstm;
}

WStream::~WStream(void)
{
    if (_pstm)
	Release();
}

void WStream::Unwrap(void)
{
    delete this;
}

HRESULT WStream::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IStream %p::QueryInterface(riid, %p)", _pstm, ppvObj);
    return Result(_pstm->QueryInterface(riid, ppvObj));
}

ULONG WStream::AddRef(void)
{
    ULONG ul;

    ul = _pstm->AddRef();
    out("IStream %p::AddRef() - %lu\n", _pstm, ul);
    return ul;
}

ULONG WStream::Release(void)
{
    ULONG ul;

    ul = _pstm->Release();
    out("IStream %p::Release() - %lu\n", _pstm, ul);
    if (ul == 0)
	_pstm = NULL;
    return ul;
}

HRESULT WStream::Read(VOID *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr;

    out("IStream %p::Read(%p, %lu, %p)", _pstm, pv, cb, pcbRead);
    hr = _pstm->Read(pv, cb, pcbRead);
    if (pcbRead)
	out(" - %lu bytes", *pcbRead);
    Result(hr);
    if (pcbRead && *pcbRead != cb && fExitOnFail)
	error(EXIT_BADSC, "Couldn't read data\n");
    return hr;
}

HRESULT WStream::Write(VOID *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT hr;

    out("IStream %p::Write(%p, %lu, %p)", _pstm, pv, cb, pcbWritten);
    hr = _pstm->Write(pv, cb, pcbWritten);
    if (pcbWritten)
	out(" - %lu bytes", *pcbWritten);
    Result(hr);
    if (pcbWritten && *pcbWritten != cb && fExitOnFail)
	error(EXIT_BADSC, "Couldn't write data\n");
    return hr;
}

HRESULT WStream::Seek(LONG dlibMove,
		    DWORD dwOrigin,
		    ULONG *plibNewPosition)
{
    HRESULT hr;
    LARGE_INTEGER dlib;
    ULARGE_INTEGER plib;

    out("IStream %p::Seek(%ld, %lu, %p)", _pstm, dlibMove, dwOrigin,
	plibNewPosition);
    LISet32(dlib, dlibMove);
    hr = _pstm->Seek(dlib, dwOrigin, &plib);
    if (plibNewPosition)
    {
        *plibNewPosition = ULIGetLow(plib);
	out(" - ptr %lu", *plibNewPosition);
    }
    return Result(hr);
}

HRESULT WStream::SetSize(ULONG libNewSize)
{
    ULARGE_INTEGER lib;
    
    out("IStream %p::SetSize(%lu)", _pstm, libNewSize);
    ULISet32(lib, libNewSize);
    return Result(_pstm->SetSize(lib));
}

HRESULT WStream::Commit(const DWORD dwFlags)
{
    out("IStream %p:Commit(%lu)", _pstm, dwFlags);
    return Result(_pstm->Commit(dwFlags));
}

HRESULT WStream::CopyTo(WStream *pstm,
		      ULONG cb,
		      ULONG *pcbRead,
		      ULONG *pcbWritten)
{
    ULARGE_INTEGER lcb, pcbr, pcbw;
    HRESULT hr;
    
    out("IStream %p::CopyTo(%p, %lu, %p, %p)", _pstm, pstm->GetI(), cb,
	pcbRead, pcbWritten);
    ULISet32(lcb, cb);
    hr = Result(_pstm->CopyTo(pstm->GetI(), lcb, &pcbr, &pcbw));
    if (pcbRead)
        *pcbRead = ULIGetLow(pcbr);
    if (pcbWritten)
        *pcbWritten = ULIGetLow(pcbw);
    return hr;
}

HRESULT WStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    out("IStream %p::Stat(%p, %lu)", _pstm, pstatstg, grfStatFlag);
    return Result(_pstm->Stat(pstatstg, grfStatFlag));
}

HRESULT WStream::Clone(WStream * *ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStream %p::Clone(%p)", _pstm, ppstm);
    hr = Result(_pstm->Clone(&pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

//+--------------------------------------------------------------
//
//  IEnumSTATSTG wrappers
//
//---------------------------------------------------------------

WEnumSTATSTG *WEnumSTATSTG::Wrap(IEnumSTATSTG *pienm)
{
    WEnumSTATSTG *wenm;

    wenm = new WEnumSTATSTG(pienm);
    if (wenm == NULL)
	error(EXIT_OOM, "Unable to wrap IEnumSTATSTG\n");
    return wenm;
}

WEnumSTATSTG::WEnumSTATSTG(IEnumSTATSTG *penm)
{
    // Note:  takes ownership of penm
    _penm = penm;
}

WEnumSTATSTG::~WEnumSTATSTG(void)
{
    if (_penm)
	Release();
}

void WEnumSTATSTG::Unwrap(void)
{
    delete this;
}

HRESULT WEnumSTATSTG::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IEnumSTATSTG %p::QueryInterface(riid, %p)", _penm, ppvObj);
    return Result(_penm->QueryInterface(riid, ppvObj));
}

ULONG WEnumSTATSTG::AddRef(void)
{
    ULONG ul;

    ul = _penm->AddRef();
    out("IEnumSTATSTG %p::AddRef() - %lu\n", _penm, ul);
    return ul;
}

ULONG WEnumSTATSTG::Release(void)
{
    ULONG ul;

    ul = _penm->Release();
    out("IEnumSTATSTG %p::Release() - %lu\n", _penm, ul);
    if (ul == 0)
	_penm = NULL;
    return ul;
}

HRESULT WEnumSTATSTG::Next(ULONG celt, STATSTG rgelt[], ULONG *pceltFetched)
{
    out("IEnumSTATSTG %p::Next(%lu, rgelt, %p)", _penm, celt, pceltFetched);
    return Result(_penm->Next(celt, rgelt, pceltFetched));
}

HRESULT WEnumSTATSTG::Skip(ULONG celt)
{
    out("IEnumSTATSTG %p::Skip(%lu)", _penm, celt);
    return Result(_penm->Skip(celt));
}

HRESULT WEnumSTATSTG::Reset(void)
{
    out("IEnumSTATSTG %p::Reset()", _penm);
    return Result(_penm->Reset());
}

HRESULT WEnumSTATSTG::Clone(WEnumSTATSTG **ppenm)
{
    HRESULT hr;
    IEnumSTATSTG *pienm;

    out("IEnumSTATSTG %p::Clone(%p)", _penm, ppenm);
    hr = Result(_penm->Clone(&pienm));
    *ppenm = WEnumSTATSTG::Wrap(pienm);
    return hr;
}

//+--------------------------------------------------------------
//
//  Root level wrappers
//
//---------------------------------------------------------------

HRESULT WStgCreateDocfile(const OLECHAR * pwcsName,
			const DWORD grfMode,
			DWORD reserved,
			WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

#define LARGE_SECTORS
#ifndef LARGE_SECTORS
    if (pwcsName)
     {
	 out("StgCreateDocfile(%s, 0x%lX, %lu, %p)", 
	     OlecsOut(pwcsName), grfMode, reserved, ppstgOpen);
     }
    hr = Result(StgCreateDocfile(pwcsName, grfMode,
                                 reserved, &pistg));
#else
    out("StgCreateStorageEx(%s, 0x%lX, %lu, %p)", OlecsOut(pwcsName), grfMode,
	reserved, ppstgOpen);

    STGOPTIONS stgoptions;
    stgoptions.usVersion = STGOPTIONS_VERSION;
    stgoptions.reserved = 0;
    stgoptions.ulSectorSize = 4096;
    stgoptions.pwcsTemplateFile = NULL;

    hr = Result(StgCreateStorageEx ( pwcsName, grfMode,
                   STGFMT_DOCFILE,
                   0, &stgoptions,
                   0, IID_IStorage, (void **) &pistg));
#endif

    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgCreateDocfileOnILockBytes(ILockBytes *plkbyt,
				    const DWORD grfMode,
				    DWORD reserved,
				    WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgCreateDocfileOnILockBytes(%p, 0x%lX, %lu, %p)",
	plkbyt, grfMode, reserved, ppstgOpen);
    hr = Result(StgCreateDocfileOnILockBytes(plkbyt, grfMode,
                                             reserved, &pistg));
    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgOpenStorage(const OLECHAR * pwcsName,
		      WStorage *pstgPriority,
		      const DWORD grfMode,
		      SNB snbExclude,
		      DWORD reserved,
		      WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgOpenStorage(%s, %p, 0x%lX, %p, %lu, %p)", OlecsOut(pwcsName),
	SAFEI(pstgPriority), grfMode, snbExclude, reserved, ppstgOpen);
    hr = Result(StgOpenStorage(pwcsName, (IStorage*)SAFEI(pstgPriority), grfMode,
			      snbExclude,
                               reserved, &pistg));

    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgOpenStorageOnILockBytes(ILockBytes *plkbyt,
				  WStorage *pstgPriority,
				  const DWORD grfMode,
				  SNB snbExclude,
				  DWORD reserved,
				  WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgOpenStorageOnILockBytes(%p, %p, 0x%lX, %p, %lu, %p)",
	plkbyt, SAFEI(pstgPriority), grfMode, snbExclude, reserved,
	ppstgOpen);
    hr = Result(StgOpenStorageOnILockBytes(plkbyt, (IStorage*)SAFEI(pstgPriority),
					  grfMode, snbExclude, reserved,
					  &pistg));
    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgIsStorageFile(const OLECHAR * pwcsName)
{
    out("StgIsStorageFile(%s)", OlecsOut(pwcsName));
    return Result(StgIsStorageFile(pwcsName));
}

HRESULT WStgIsStorageILockBytes(ILockBytes * plkbyt)
{
    out("StgIsStorageILockBytes(%p)", plkbyt);
    return Result(StgIsStorageILockBytes(plkbyt));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\ref\test\stgdrt\wchar.c ===
/*
*
*       Copyright (c) 1985-1996, Microsoft Corporation. All Rights Reserved.
*
*       Character functions (to and from wide characters)
i*
******************************************************************************
*/

#include "h/wchar.h"
#include <errno.h>

/*
** Converts a single byte i.e. ascii string to the wide char format 
**
** NOTE: This function does NOT handle multibyte characters!
**       It should be used only when wchar_t is not 2 bytes and
**       we cannot use the standard functions
**
*/

#ifndef _MSC_VER
size_t sbstowcs(WCHAR *pwcs, const char *s, size_t n )
{
	size_t count=0;

	/* if destintation string exists, fill it in */
	if (pwcs)
	{
		while (count < n)
		{
			*pwcs = (WCHAR) ( (unsigned char)s[count]);
			if (!s[count])
				return count;
			count++;
			pwcs++;
		}
		return count;
	}
	else { /* pwcs == NULL, get size only, s must be NUL-terminated */
		return strlen(s);
	}
}
#endif

/***
*size_t wcstrsbs() - Convert wide char string to single byte char string.
*
*Purpose:
*       Convert a wide char string into the equivalent multibyte char string 
*       [ANSI].
*
*Entry:
*       char *s            = pointer to destination char string
*       const WCHAR *pwc = pointer to source wide character string
*       size_t           n = maximum number of bytes to store in s
*
*Exit:
*       If s != NULL, returns    (size_t)-1 (if a wchar cannot be converted)
*       Otherwise:       Number of bytes modified (<=n), not including
*                    the terminating NUL, if any.
* 
*Exceptions
*       Returns (size_t)-1 if s is NULL or invalid mb character encountered.
*
*******************************************************************************/

size_t __cdecl wcstosbs( char * s, const WCHAR * pwcs, size_t n)
{
	size_t count=0;
        /* if destination string exists, fill it in */
 	if (s)
	{
		while(count < n)
		{
		    if (*pwcs > 255)  /* validate high byte */
		    {
			errno = EILSEQ;
			return (size_t)-1;  /* error */
		    }
		    s[count] = (char) *pwcs;

 		    if (!(*pwcs++))
			return count;
    		    count++;
	        }
		return count;
											} else { /* s == NULL, get size only, pwcs must be NUL-terminated */
	        const WCHAR *eos = pwcs;
		while (*eos++);
		return ( (size_t) (eos - pwcs -1));
	}
}


/******
*	WCHAR *wcscat(dst, src) - concatenate (append) one wide character string
*       to another
*
*Purpose:
*       Concatenates src onto the end of dest.  Assumes enough
*       space in dest.
*
*Entry:
*       WCHAR *dst - wide character string to which "src" is to be appended
*       const WCHAR *src - wide character string to append to end of "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

WCHAR * __cdecl wcscat(WCHAR * dst, const WCHAR * src)
{
    WCHAR * cp = dst;

    while( *cp )
            ++cp;       /* Find end of dst */

    wcscpy(cp,src);     /* Copy src to end of dst */

    return dst;         /* return dst */

}


/***
*WCHAR *wcscpy(dst, src) - copy one wide character string over another
*
*Purpose:
*       Copies the wide character string src into the spot specified by
*       dest; assumes enough room.
*
*Entry:
*       WCHAR * dst - wide character string over which "src" is to be copied
*       const WCHAR * src - string to be copied over "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*******************************************************************************/

WCHAR * __cdecl wcscpy(WCHAR * dst, const WCHAR * src)
{
    WCHAR * cp = dst;

    while( *cp++ = *src++ )
            ;               /* Copy src over dst */

    return dst;
}


/***
*wcslen - return the length of a null-terminated string
*
*Purpose:
*       Finds the number of wide characters in the given wide character
*       string, not including the final null character.
*
*Entry:
*       const wchat_t * str - string whose length is to be computed
*
*Exit:
*       length of the string "str", exclusive of the final null wide character
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcslen(const WCHAR * str)
{
    WCHAR *string = (WCHAR *) str;

    while( *string )
            string++;

    return string - str;
}

/****************************************************************************
*wcsnicmp.c - compare first n characters of two wide character strings with
*             case insensitivity
*
*       Copyright (c) 1985-1996, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines wcsnicmp() - compare first n characters of two wide character
*       strings for lexical order with case insensitivity.
*
*****************************************************************************/

/***
*WCHAR wcUp(wc) - upper case wide character
****/

static WCHAR wcUp(WCHAR wc)
{
    if ('a' <= wc && wc <= 'z')
        wc += (WCHAR)('A' - 'a');

    return(wc);
}

/***
*int wcsnicmp(first, last, count) - compare first count wide characters of wide
*       character strings with case insensitivity.
*
*Purpose:
*       Compares two wide character strings for lexical order.  The comparison
*       stops after: (1) a difference between the strings is found, (2) the end
*       of the strings is reached, or (3) count characters have been
*       compared.
*
*Entry:
*       char *first, *last - wide character strings to compare
*       unsigned count - maximum number of wide characters to compare
*
*Exit:
*       returns <0 if first < last
*       returns  0 if first == last
*       returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcsnicmp(const WCHAR * first, const WCHAR * last, size_t count)
{
      if (!count)
              return 0;

      while (--count && *first && wcUp(*first) == wcUp(*last))
              {
              first++;
              last++;
              }

      return wcUp(*first) - wcUp(*last);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\simp\simphead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:   simphead.cxx
//
//  Contents:   Precompiled headers
//
//  History:    04-Aug-94       PhilipLa        Created.
//
//--------------------------------------------------------------------------

#include <memory.h>

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
}
#include <ole2.h>

#if defined(_CHICAGO_)
#include <widewrap.h>
#endif

#include <msf.hxx>
#include <header.hxx>
#include <fat.hxx>
#include <dir.hxx>
#include <dirfunc.hxx>
#include <psetstg.hxx>
#include <simpdf.hxx>
#include <simpstm.hxx>
#include <dfnlist.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\simp\simpdf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	simpdf.cxx
//
//  Contents:	StdDocfile implementation
//
//  Classes:	
//
//  Functions:	
//
//  History:	04-Aug-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "simphead.cxx"
#pragma hdrstop


#if DBG == 1
DECLARE_INFOLEVEL(simp)
#endif

//+---------------------------------------------------------------------------
//
//  Function:	DfCreateSimpDocfile, private
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	04-Aug-94	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE DfCreateSimpDocfile(WCHAR const *pwcsName,
                          DWORD grfMode,
                          DWORD reserved,
                          IStorage **ppstgOpen)
{
    SCODE sc;
    CSimpStorage *pstg;

    if (ppstgOpen == NULL)
        return STG_E_INVALIDPARAMETER;

    if (grfMode !=
        (STGM_SIMPLE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE))
        return STG_E_INVALIDFLAG;

    
    pstg = new CSimpStorage;
    if (pstg == NULL)
    {
        return STG_E_INSUFFICIENTMEMORY;
    }
    
    sc = pstg->Init(pwcsName, NULL);
    
    if (FAILED(sc))
    {
        pstg->Release();
        pstg = NULL;
    }

    *ppstgOpen = pstg;
    return sc;
}

#if WIN32 != 200
//+---------------------------------------------------------------------------
//
//  Function:   DfOpenSimpDocfile, private
//
//  Synopsis:   opens an existing docfile for reading
//
//  Arguments:  [pwcsName] name of docfile
//              [grfMode]  permission bits
//              [reserved] must be zero
//              [pstgOpen] opened storage pointer
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-96   HenryLee    Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE DfOpenSimpDocfile(WCHAR const *pwcsName,
                          DWORD grfMode,
                          DWORD reserved,
                          IStorage **ppstgOpen)

{
    SCODE sc = S_OK;
    CSimpStorageOpen *pstg;

    if (ppstgOpen == NULL)
        return STG_E_INVALIDPARAMETER;
    else
        *ppstgOpen = NULL;

    if (grfMode != (STGM_SIMPLE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE) &&
        grfMode != (STGM_SIMPLE | STGM_READ      | STGM_SHARE_EXCLUSIVE))
        return STG_E_INVALIDFLAG;

    if ((pstg = new CSimpStorageOpen) == NULL)
    {
        return STG_E_INSUFFICIENTMEMORY;
    }

    if (FAILED(sc = pstg->Init(pwcsName, grfMode, NULL)))
    {
        pstg->Release();
        pstg = NULL;
    }

    *ppstgOpen = pstg;
    return sc;
}
#endif // WIN32 != 200
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\simp\simpstg2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       simpstg2.cxx
//
//  Contents:   SimpStorageOpen class implementation
//
//  Classes:    CSimpStorageOpen, CSafeBYTEArray 
//
//  Functions:  
//
//  Notes:      No error labels, tried to use destructors for cleanup
//
//  History:    04-May-96       HenryLee       Created
//
//----------------------------------------------------------------------------

#include "simphead.cxx"
#pragma hdrstop

#include <expparam.hxx>

//+---------------------------------------------------------------------------
//
//  Class:      CSafeBYTEArray
//
//  Purpose:    automatically allocate & destroy an array of BYTEs
//
//  Interface:
//
//  History:    04-Jun-96   HenryLee    Created
//
//  Notes:      destructor automatically cleans up
//
//----------------------------------------------------------------------------

class CSafeBYTEArray
{
public:
    inline CSafeBYTEArray (ULONG cBYTE) {_p = new BYTE[cBYTE]; };
    inline ~CSafeBYTEArray () { if (_p) delete [] _p; };
    inline operator BYTE* ()  { return _p; };
private:
    BYTE *_p;   // allowed to be NULL
};

//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::Init, public
//
//  Synopsis:   Init function
//
//  Arguments:  [psdh] -- Pointer to hints structure
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//              14-Oct-97       HenryLee       recoginize CNSS file format
//
//----------------------------------------------------------------------------

SCODE CSimpStorageOpen::Init(WCHAR const * pwcsName, DWORD grfMode,
                             SSimpDocfileHints *psdh)
{
    SCODE sc = S_OK;
    simpDebugOut((DEB_ITRACE,
                 "In  CSimpStorageOpen::Init:%p(%ws)\n", this, pwcsName));

#ifdef UNICODE
    TCHAR const *atcPath = pwcsName;
#else
    TCHAR atcPath[_MAX_PATH+1];

    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;

    if (!WideCharToMultiByte( uCodePage, 0, pwcsName, -1,
            atcPath, _MAX_PATH + 1, NULL, NULL))
    {
        return STG_E_INVALIDNAME;
    }
#endif

    DWORD dwMode;
    switch (grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE)) 
    {
        case STGM_READWRITE : dwMode = GENERIC_READ | GENERIC_WRITE; break;
        case STGM_READ : dwMode = GENERIC_READ;  break;
        case STGM_WRITE : dwMode = GENERIC_WRITE; break;
        default: Win4Assert (!"Invalid mode"); return STG_E_INVALIDPARAMETER;
    }

    _hFile = CreateFileT(atcPath, dwMode, 0,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (_hFile == INVALID_HANDLE_VALUE)
    {
        return Win32ErrorToScode(GetLastError());
    }

    _grfMode = grfMode;
    _sectMax = 0;
    _fDirty = FALSE;
    _clsid = IID_NULL;
    _grfStateBits = 0;

    simpAssert  (pwcsName != NULL); // CreateFileT would fail above if it was NULL
    sc = StringCbCopy(_awcsName, sizeof(_awcsName), pwcsName);
    if (FAILED(sc))
        return sc;

    ULONG cbRead;
    BOOL f= ReadFile(_hFile, _hdr.GetData(), HEADERSIZE, &cbRead, NULL);
    if (!f)
    {
        return Win32ErrorToScode(GetLastError());
    }

    if (cbRead != HEADERSIZE)
    {
        return STG_E_READFAULT;
    }

    if (!SUCCEEDED(sc = ValidateHeader(_hdr)))
    {
        return sc;
    }

    ULONG ulEndOfFile = GetFileSize(_hFile, NULL);
    if (ulEndOfFile == 0xFFFFFFFF && GetLastError() != NO_ERROR)
        return Win32ErrorToScode(GetLastError());

    const ULONG ulFatStart=_hdr.GetFatStart()*SECTORSIZE + HEADERSIZE;
    const ULONG ulDifStart=_hdr.GetDifStart()*SECTORSIZE + HEADERSIZE;
    const ULONG ulFatLength = _hdr.GetFatLength()*SECTORSIZE;
    const ULONG ulDifLength = _hdr.GetDifLength()*SECTORSIZE;
    const ULONG ulDirLength = ulEndOfFile - ulFatStart - ulFatLength;
    const ULONG cBytes = ulDirLength + ulFatLength + ulDifLength;

    if (ulFatLength == 0 || ulDirLength == 0)
        return STG_E_DOCFILECORRUPT;

    DWORD dwErr;
    CSafeBYTEArray pByte (cBytes);
    
    if (pByte == NULL)
        return STG_E_INSUFFICIENTMEMORY;

    if ((dwErr = SetFilePointer (_hFile, 
                 (ulDifLength == 0 ?  ulFatStart : ulDifStart),
                 NULL, FILE_BEGIN)) == 0xFFFFFFFF)
    {
        return Win32ErrorToScode(GetLastError());
    }

    // Read the FAT, DIFAT, and Directory into one big buffer
    //
    if (!(f=ReadFile(_hFile, pByte, cBytes, &cbRead, NULL)))
    {
        return Win32ErrorToScode(GetLastError());
    }
    if (cbRead != cBytes)
    {
        return STG_E_READFAULT;
    }

    if (!SUCCEEDED(sc = ValidateDirectory(
        pByte+ulDifLength+ulFatLength, ulDirLength)))
    {
        return sc;
    }

    if (!SUCCEEDED(sc = ValidateFat ((SECT*) (pByte+ulDifLength),
        ulFatLength)))
    {
        return sc;
    }

    if (ulDifLength != 0 && !SUCCEEDED(sc = ValidateDIFat ((SECT *) (pByte+0),
        ulDifLength, _hdr.GetFatSect(CSECTFAT-1))))
    {
        return sc;
    }

    simpDebugOut((DEB_ITRACE, "Out CSimpStorage::Init\n"));
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::ValidateHeader, public
//
//  Synopsis:   verifies header is in simple mode format
//
//  Arguments:  [hdr] -- reference to a docfile header
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//              14-Oct-97       HenryLee       recoginize CNSS file format
//
//----------------------------------------------------------------------------

SCODE CSimpStorageOpen::ValidateHeader (CMSFHeader &hdr)
{
    SCODE sc = S_OK;

    if (!SUCCEEDED(sc = hdr.Validate()))
    {
        return sc;
    }

    const SECT sectDifStart = hdr.GetDifStart();
    const SECT sectFatStart = hdr.GetFatStart();
    const SECT sectDirStart = hdr.GetDirStart();

    // in simple mode, DifStart < FatStart < DirStart
    //
    if(hdr.GetMiniFatStart() != ENDOFCHAIN || hdr.GetMiniFatLength() != 0 ||
       (sectDifStart != ENDOFCHAIN && sectDifStart >= sectFatStart))
    {
        return STG_E_OLDFORMAT;
    }

    // in simple mode, DifStart+DifLength = FatStart
    //                 FatStart+FatLength = DirStart
    //
    //
    if (sectDifStart != ENDOFCHAIN &&
        (sectDifStart + hdr.GetDifLength() != sectFatStart))
    {
        return STG_E_OLDFORMAT;
    }

    if (sectDirStart != 0 &&
        (sectFatStart + hdr.GetFatLength() != sectDirStart))
    {
            return STG_E_OLDFORMAT;
    }

    // make sure the FAT is contiguous within the header
    //
    for (INT i=1; i < CSECTFAT; i++)
    {
        if (hdr.GetFatSect(i) == FREESECT)
            break;

        if (hdr.GetFatSect(i-1)+1 != hdr.GetFatSect(i))
            return STG_E_OLDFORMAT;
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::ValidateDirectory, public
//
//  Synopsis:   verifies stream entries are correct
//
//  Arguments:  
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//              14-Oct-97       HenryLee       recoginize CNSS file format
//
//----------------------------------------------------------------------------

SCODE CSimpStorageOpen::ValidateDirectory (BYTE *pByte, ULONG ulDirLength)
{
    SCODE sc = S_OK;
    CDfNameList *pdflRoot = _pdfl;
    SECT sectStartLowest = ENDOFCHAIN;
    ULONG ulSize = 0;
    ULONG cbStorages = 0;
    CDirEntry *pde = (CDirEntry *) pByte;

    // Read the directory entries until the end of buffer
    CDfNameList *pdflPrev = NULL;
    for (ULONG i=0; i < ulDirLength/sizeof(CDirEntry); i++)
    {
         if (!pde[i].IsFree())
         {
              if (pde[i].GetFlags() != STGTY_ROOT &&
                  pde[i].GetFlags() != STGTY_STREAM &&
                  pde[i].GetFlags() != STGTY_STORAGE)
                  return STG_E_OLDFORMAT;

              if (STORAGELIKE(pde[i].GetFlags()))
              {
                  cbStorages++;       // first entry must be a storage
                  if (pdflPrev != NULL || cbStorages > 1) 
                      return STG_E_OLDFORMAT;
              }

              if (pde[i].GetRightSib() == (SID) i ||
                  pde[i].GetLeftSib()  == (SID) i)
                return STG_E_DOCFILECORRUPT;

              CDfNameList *pdfl = new CDfNameList;
              if (pdfl != NULL)
              {  
                  pdfl->SetDfName(pde[i].GetName());
                  pdfl->SetStart(pde[i].GetStart());

                  if (sectStartLowest > pdfl->GetStart())
                      sectStartLowest = pdfl->GetStart();

#ifdef LARGE_STREAMS
                  pdfl->SetSize((ULONG)pde[i].GetSize(FALSE));
#else
                  pdfl->SetSize((ULONG)pde[i].GetSize());
#endif
                  pdfl->Insert (&_pdfl, pdflPrev, NULL);  //insert at end
                  pdflPrev = pdfl;
              }
              else return STG_E_INSUFFICIENTMEMORY;
         }
    }

    pdflRoot = _pdfl;
    if (pdflRoot == 0 || pdflRoot->GetStart() != ENDOFCHAIN ||
                         pdflRoot->GetSize() != 0)
    {
        return STG_E_OLDFORMAT;
    }
    else pdflRoot = pdflRoot->GetNext();

    // make sure streams are one after another
    //
    for (CDfNameList *pdfl = pdflRoot; pdfl != NULL; pdfl = pdfl->GetNext())
    {
        // start should be after another stream's end
        // In the CNSS case, the pdflRoot points to 1st stream in file
        // In the docfile case, entry with 0 start sector is 1st stream in file
        if (pdfl->GetStart() != sectStartLowest) // skip 1st stream
        {
            CDfNameList *pdfl2 = NULL;
            for (pdfl2 = pdflRoot; pdfl2 != NULL; pdfl2=pdfl2->GetNext())
            {
                if (pdfl->GetStart() == (pdfl2->GetStart() + (
                    pdfl2->GetSize()+SECTORSIZE-1)/SECTORSIZE))
                    break;
            }
            if (pdfl2 == NULL)            // did not find a match
                return STG_E_OLDFORMAT;
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::ValidateFat, public
//
//  Synopsis:   verifies that stream sectors are contiguous
//
//  Arguments:  [pSect] array of Fat sectors
//              [ulFatLength] length of the Fat
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//----------------------------------------------------------------------------

SCODE CSimpStorageOpen::ValidateFat (SECT *pSect, ULONG ulFatLength)
{
    SCODE sc = S_OK;

    simpAssert  (_pdfl != NULL && pSect != NULL);

    for (CDfNameList *pdfl = _pdfl->GetNext(); pdfl; pdfl = pdfl->GetNext())
    {
        SECT sectStart = pdfl->GetStart();
        ULONG ulSize = pdfl->GetSize();

        SECT *psect = &pSect[sectStart];
        SECT sectCount = sectStart+1;

        for (ULONG i = sectStart; 
                   i < sectStart + (ulSize+SECTORSIZE-1)/SECTORSIZE; i++)
        {
            if (*psect != sectCount && *psect != ENDOFCHAIN)
                return STG_E_OLDFORMAT;
            psect++;         // check for sector numbers
            sectCount++;     // increasing in order by 1
        }

        if ((ULONG)(psect - pSect) > ulFatLength / sizeof(SECT))
        {
            return STG_E_OLDFORMAT;
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::ValidateDIFat, public
//
//  Synopsis:   verifies that FAT sectors are contiguous
//
//  Arguments:  [pSect] array of DIFat sectors
//              [ulDIFatLength] length of the DIFat
//              [sectStart] last Fat sector in header
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//----------------------------------------------------------------------------

SCODE CSimpStorageOpen::ValidateDIFat (SECT *pSect, ULONG ulDIFatLength,
                                       SECT sectStart)
{
    SCODE sc = S_OK;
    simpAssert (pSect != NULL);
    simpAssert (sectStart != ENDOFCHAIN);

    SECT *psect = pSect;
    SECT sectCount = sectStart + 1;
    SECT iLastSect = SECTORSIZE / sizeof(SECT);

    for (ULONG i = 0; i < ulDIFatLength/sizeof(SECT); i++)
    {
        // skip last sector entry
        if (*psect != FREESECT && ((i+1) % iLastSect) != 0)
        { 
            if (*psect != sectCount)
                return STG_E_OLDFORMAT;

            sectCount++;     // check for sector numbers increasing by 1
        }
        psect++; 
    }

    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::Release, public
//
//  Synopsis:   Releases resources for a CSimpStorageOpen
//              override CSimpStorage::Release because of delete this
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpStorageOpen::Release(void)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStorageOpen::Release()\n"));
    simpAssert(_cReferences > 0);

    LONG lRet = AtomicDec(&_cReferences);
    if (lRet == 0)
    {
        if (_fDirty)
            Commit(STGC_DEFAULT);
        CloseHandle(_hFile);         // streams are not reverted
        delete this;
    }

    simpDebugOut((DEB_TRACE, "Out CSimpStorageOpen::Release()\n"));
    return (ULONG) lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorageOpen::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc = S_OK;

    simpDebugOut((DEB_TRACE, "In  CSimpStorageOpen::Stat(%p)\n", pstatstg));

    SIMP_VALIDATE(Stat(pstatstg, grfStatFlag));
    
    if (GetFileTime(_hFile, &pstatstg->ctime, &pstatstg->atime,
                            &pstatstg->mtime) == FALSE)
    {
        return Win32ErrorToScode(GetLastError());
    }

    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        DWORD cbName;
        cbName = (lstrlenW(_awcsName)+1)*sizeof(WCHAR);
        if ((pstatstg->pwcsName = (WCHAR*) CoTaskMemAlloc(
            cbName)) == 0)
        {
            return STG_E_INSUFFICIENTMEMORY;
        }
        StringCbCopy(pstatstg->pwcsName, cbName, _awcsName);
    }

    pstatstg->grfMode = _grfMode;
    pstatstg->clsid = _clsid;
    pstatstg->grfStateBits = _grfStateBits;

    pstatstg->type = STGTY_STORAGE;
    ULISet32(pstatstg->cbSize, 0);
    pstatstg->grfLocksSupported = 0;
    pstatstg->STATSTG_dwStgFmt = 0;

    simpDebugOut((DEB_TRACE, "Out CSimpStorageOpen::Stat\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::OpenStream, public
//
//  Synopsis:   Opens an existing stream
//
//  Arguments:  [pwcsName] - Name
//              [reserved1]
//              [grfMode] - Permissions
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorageOpen::OpenStream(WCHAR const *pwcsName,
                                          void *reserved1,
                                          DWORD grfMode,
                                          DWORD reserved2,
                                          IStream **ppstm)
{
    SCODE sc = S_OK;
    simpAssert  (_pdfl != NULL);
    CDfNameList *pdflLoop = _pdfl->GetNext();
    CDfName dfn;

    simpDebugOut((DEB_TRACE, "In  CSimpStorageOpen:OpenStream("
                "%ws, %p, %lX, %lu, %p)\n", pwcsName, reserved1,
                grfMode, reserved2, ppstm));

    SIMP_VALIDATE(OpenStream(pwcsName,
                             reserved1,
                             grfMode,
                             reserved2,
                             ppstm));
    
    if (_pdflCurrent != NULL)
        return STG_E_INVALIDFUNCTION;

    if (grfMode != (STGM_READWRITE | STGM_SHARE_EXCLUSIVE) &&
        grfMode != (STGM_READ      | STGM_SHARE_EXCLUSIVE))
        return STG_E_INVALIDFLAG;

    if (_grfMode == (STGM_READ      | STGM_SHARE_EXCLUSIVE)  &&
         grfMode == (STGM_READWRITE | STGM_SHARE_EXCLUSIVE))
        return STG_E_ACCESSDENIED;

    dfn.Set(pwcsName);
    while (pdflLoop != NULL)
    {
        INT iCmp = CDirectory::NameCompare(&dfn, pdflLoop->GetName());
        if (iCmp == 0)
        {
            //Found a stream with this name
            CSimpStreamOpen *pstm = new CSimpStreamOpen ();
            if (pstm != NULL)
            {
                _pdflCurrent = pdflLoop;
                if (!SUCCEEDED(sc = pstm->Init (this, _hFile, 
                              (_pdflCurrent->GetStart()+1)*SECTORSIZE,
                               grfMode, _pdflCurrent)))
                {
                    delete pstm;
                    pstm = NULL;
                    _pdflCurrent = NULL;
                }
                *ppstm = pstm;
                break;
            }
            else return STG_E_INSUFFICIENTMEMORY;
        }
        pdflLoop = pdflLoop->GetNext();
    }

    if (pdflLoop == NULL)
    {
        sc = STG_E_FILENOTFOUND;
    }

    simpDebugOut((DEB_TRACE, "Out CSimpStorageOpen::OpenStream => %p\n",
                *ppstm));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::CreateStream, public
//
//  Synopsis:   stub
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorageOpen::CreateStream(WCHAR const *pwcsName,
                            DWORD grfMode,
                            DWORD reserved1,
                            DWORD reserved2,
                            IStream **ppstm)
{
    simpDebugOut((DEB_TRACE, "Stb CSimpStorageOpen::CreateStream\n"));
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::EnumElements, public
//
//  Synopsis:   Starts an iterator
//
//  Arguments:  [reserved1]
//              [reserved2]
//              [reserved3]
//              [ppenm] - Enumerator return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppenm]
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorageOpen::EnumElements(DWORD reserved1,
                                           void *reserved2,
                                           DWORD reserved3,
                                           IEnumSTATSTG **ppenm)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStorageOpen::EnumElements\n"));
    SCODE sc = S_OK;

    SIMP_VALIDATE(EnumElements(reserved1,
                               reserved2,
                               reserved3,
                               ppenm));
    
    if ((*ppenm = new CSimpEnumSTATSTG (_pdfl, _pdfl)) == NULL)
        sc = STG_E_INSUFFICIENTMEMORY;

    simpDebugOut((DEB_TRACE, "Out CSimpStorageOpen::EnumElements => %x\n", sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::SetClass, public
//
//  Synopsis:   Sets storage class
//
//  Arguments:  [clsid] - class id
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorageOpen::SetClass(REFCLSID rclsid)
{
    simpDebugOut((DEB_TRACE, "Stb CSimpStorageOpen::SetClass\n"));
    return STG_E_INVALIDFUNCTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\simp\simpstg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       simpstg.cxx
//
//  Contents:   SimpStorage class implementation
//
//  Classes:
//
//  Functions:
//
//  History:    04-Aug-94   PhilipLa    Created
//              26-Feb-97   Danl        QI support for IID_IPropertySetStorage
//
//----------------------------------------------------------------------------

#include "simphead.cxx"
#pragma hdrstop

#include <ole.hxx>
#include <logfile.hxx>
#include <expparam.hxx>


#ifdef SECURE_BUFFER
BYTE s_bufSecure[MINISTREAMSIZE];
#endif


ULONG ConvertSect(SECT sect)
{
    return (ULONG)(sect << SECTORSHIFT512) + SECTORSIZE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorage::Init, public
//
//  Synopsis:   Init function
//
//  Arguments:  [psdh] -- Pointer to hints structure
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

SCODE CSimpStorage::Init(WCHAR const * pwcsName, SSimpDocfileHints *psdh)
{
    simpDebugOut((DEB_ITRACE,
                 "In  CSimpStorage::Init:%p(%ws)\n", this, pwcsName));

#ifdef UNICODE
    TCHAR const *atcPath = pwcsName;
#else
    TCHAR atcPath[_MAX_PATH+1];

    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;

    if (!WideCharToMultiByte(
            uCodePage,
            0,
            pwcsName,
            -1,
            atcPath,
            _MAX_PATH + 1,
            NULL,
            NULL))
    {
        return STG_E_INVALIDNAME;
    }
#endif

    _hFile = CreateFileT(atcPath,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (_hFile == INVALID_HANDLE_VALUE)
    {
        return STG_SCODE(GetLastError());
    }

    if (FALSE == SetEndOfFile (_hFile))
    {
        return STG_SCODE(GetLastError());
    }

    _sectMax = 0;
    //From this point on, we need to try to produce a docfile.
    _fDirty = TRUE;
    _clsid = IID_NULL;

#ifdef SECURE_SIMPLE_MODE
    memset(s_bufSecure, SECURECHAR, MINISTREAMSIZE);
#endif

    simpDebugOut((DEB_ITRACE, "Out CSimpStorage::Init\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::Release, public
//
//  Synopsis:   Releases resources for a CSimpStorage
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpStorage::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CSimpStorage::Release()\n", this));
    simpDebugOut((DEB_TRACE, "In  CSimpStorage::Release()\n"));

    simpAssert(_cReferences > 0);
    lRet = AtomicDec(&_cReferences);
    if (lRet == 0)
    {
        //Clean up
        if (_hFile != INVALID_HANDLE_VALUE)
        {
            if (_fDirty)
                Commit(STGC_DEFAULT);
            CloseHandle(_hFile);
        }
        delete this;
    }

    simpDebugOut((DEB_TRACE, "Out CSimpStorage::Release()\n"));
    olLog(("%p::Out CSimpStorage::Release().  ret == %lu\n", this, lRet));
    FreeLogFile();
    return (ULONG)lRet;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::CreateStream, public
//
//  Synopsis:   Creates a stream
//
//  Arguments:  [pwcsName] - Name
//              [grfMode] - Permissions
//              [reserved1]
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::CreateStream(WCHAR const *pwcsName,
                                            DWORD grfMode,
                                            DWORD reserved1,
                                            DWORD reserved2,
                                            IStream **ppstm)
{
    SCODE sc;
    CSimpStream *pstm;
    CDfNameList *pdfl, *pdflPrev = NULL;
    CDfNameList *pdflLoop = _pdfl;
    int iCmp;

    olLog(("%p::In  CSimpStorage::CreateStream(%ws, %lX, %lu, %lu, %p)\n",
           this, pwcsName, grfMode, reserved1, reserved2, ppstm));

    SIMP_VALIDATE(CreateStream(pwcsName,
                               grfMode,
                               reserved1,
                               reserved2,
                               ppstm));

    if (grfMode != (STGM_READWRITE | STGM_SHARE_EXCLUSIVE))
        return STG_E_INVALIDFLAG;

    if (_pdflCurrent != NULL)
    {
        return STG_E_INVALIDFUNCTION;
    }

    //Check the name.  If it isn't already in the list, create a new
    //  CDfNameList object (in pdfl), and create a new stream object for it.

    pdfl = new CDfNameList;
    if (pdfl == NULL)
    {
        return STG_E_INSUFFICIENTMEMORY;
    }

    pstm = new CSimpStream;
    if (pstm == NULL)
    {
        delete pdfl;
        return STG_E_INSUFFICIENTMEMORY;
    }

    pdfl->SetName(pwcsName);
    pdfl->SetStart(_sectMax);
    pdfl->SetSize(0);

    while (pdflLoop != NULL)
    {
        iCmp = CDirectory::NameCompare(pdfl->GetName(), pdflLoop->GetName());
        if (iCmp == 0)
        {
            //Already have a stream of this name.
            delete pdfl;
            delete pstm;
            return STG_E_FILEALREADYEXISTS;
        }

        if (iCmp < 0)
        {
            //We found the right spot.
            break;
        }

        pdflPrev = pdflLoop;
        pdflLoop = pdflLoop->GetNext();
    }

    if (FAILED(sc = pstm->Init(this, _hFile, ConvertSect(_sectMax))))
    {
        delete pdfl;
        delete pstm;
        return sc;
    }

    //Insert pdfl into list.
    pdfl->Insert(&_pdfl, pdflPrev, pdflLoop);

    _pdflCurrent = pdfl;
    _fDirty = TRUE;
    _cStreams++;
    *ppstm = pstm;

    olLog(("%p::Out CSimpStorage::CreateStream().  "
           "*ppstm == %p, ret == %lx\n", this, *ppstm, S_OK));

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorage::ReleaseCurrentStream, public
//
//  Synopsis:   Signal release of the current open stream
//
//  Arguments:  None.
//
//  Returns:    void.
//
//  History:    05-Aug-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

#ifdef SECURE_SIMPLE_MODE
void CSimpStorage::ReleaseCurrentStream(ULONG ulHighWater)
#else
void CSimpStorage::ReleaseCurrentStream(void)
#endif
{
    simpDebugOut((DEB_ITRACE,
                 "In  CSimpStorage::ReleaseCurrentStream:%p()\n", this));

    ULONG cbSize;
    ULONG ulEndOfFile;

    ulEndOfFile = GetFileSize(_hFile, NULL);

    cbSize = ulEndOfFile - ConvertSect(_sectMax);
    cbSize = max(cbSize, MINISTREAMSIZE);

    _pdflCurrent->SetSize(cbSize);

    ULONG sectUsed;
    sectUsed = (cbSize + SECTORSIZE - 1) / SECTORSIZE;

#ifdef SECURE_SIMPLE_MODE
    ULONG cbBytesToWrite = ConvertSect(sectUsed + _sectMax) - ulHighWater;
    simpAssert(ConvertSect(sectUsed + _sectMax) >= ulHighWater);

    ULONG cbWritten;

    if ((cbBytesToWrite > 0) &&
        (SetFilePointer(_hFile, ulHighWater, NULL, FILE_BEGIN) != INVALID_SET_FILE_POINTER))
    {
        while (cbBytesToWrite > 0)
        {
            if (!WriteFile(_hFile,
                           s_bufSecure,
                           min(MINISTREAMSIZE, cbBytesToWrite),
                           &cbWritten,
                           NULL))
            {
                break;
            }
            cbBytesToWrite -= cbWritten;
        }
    }
#endif
    _sectMax += sectUsed;
    _pdflCurrent = NULL;

    simpDebugOut((DEB_ITRACE, "Out CSimpStorage::ReleaseCurrentStream\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::OpenStream, public
//
//  Synopsis:   Opens an existing stream
//
//  Arguments:  [pwcsName] - Name
//              [reserved1]
//              [grfMode] - Permissions
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::OpenStream(WCHAR const *pwcsName,
                                          void *reserved1,
                                          DWORD grfMode,
                                          DWORD reserved2,
                                          IStream **ppstm)
{
    return STG_E_INVALIDFUNCTION;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::CreateStorage, public
//
//  Synopsis:   Creates an embedded DocFile
//
//  Arguments:  [pwcsName] - Name
//              [grfMode] - Permissions
//              [reserved1]
//              [reserved2]
//              [ppstg] - New DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstg]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::CreateStorage(WCHAR const *pwcsName,
                                             DWORD grfMode,
                                             DWORD reserved1,
                                             LPSTGSECURITY reserved2,
                                             IStorage **ppstg)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::OpenStorage, public
//
//  Synopsis:   Gets an existing embedded DocFile
//
//  Arguments:  [pwcsName] - Name
//              [pstgPriority] - Priority reopens
//              [grfMode] - Permissions
//              [snbExclude] - Priority reopens
//              [reserved]
//              [ppstg] - DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstg]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::OpenStorage(WCHAR const *pwcsName,
                                           IStorage *pstgPriority,
                                           DWORD grfMode,
                                           SNBW snbExclude,
                                           DWORD reserved,
                                           IStorage **ppstg)
{
    return STG_E_INVALIDFUNCTION;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::CopyTo, public
//
//  Synopsis:   Makes a copy of a DocFile
//
//  Arguments:  [ciidExclude] - Length of rgiid array
//              [rgiidExclude] - Array of IIDs to exclude
//              [snbExclude] - Names to exclude
//              [pstgDest] - Parent of copy
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::CopyTo(DWORD ciidExclude,
                                      IID const *rgiidExclude,
                                      SNBW snbExclude,
                                      IStorage *pstgDest)
{
    return STG_E_INVALIDFUNCTION;
}



//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorage::BuildTree, private
//
//  Synopsis:   Construct the btree given the sorted array of entries.
//
//  Arguments:  [ade] -- Array of CDirEntry to operate on.  These are
//                      already sorted.
//              [sidStart] -- SID of first entry on this segment
//              [cStreams] -- Length of segment to process
//
//  Returns:    SID of root of tree
//
//  History:    09-Aug-94       PhilipLa        Created
//
//  Notes:      This is a recursive function.  Yes, I know...
//
//----------------------------------------------------------------------------

SID CSimpStorage::BuildTree(CDirEntry *ade, SID sidStart, ULONG cStreams)
{
    simpDebugOut((DEB_ITRACE, "In  CSimpStorage::BuildTree:%p()\n", this));

    if (cStreams > 3)
    {
        SID sidSplit;

        sidSplit = sidStart + (cStreams / 2);

        simpAssert(cStreams == 1 + (sidSplit - sidStart) +
                   (cStreams + sidStart - 1) - sidSplit);

        ade[sidSplit].SetLeftSib(BuildTree(ade,
                                           sidStart,
                                           sidSplit - sidStart));
        ade[sidSplit].SetRightSib(BuildTree(ade,
                                            sidSplit + 1,
                                            (cStreams + sidStart - 1) -
                                            sidSplit));

        return sidSplit;
    }
    //Base cases:
    //  cStreams == 1 -- return sidStart
    //  cStreams == 2 -- Left child of sidStart + 1 == sidStart, return
    //                  sidStart + 1
    //  cStreams == 3 -- Root is sidStart + 1, with children sidStart and
    //                    sidStart + 2

    if (cStreams == 1)
    {
        return sidStart;
    }

    if (cStreams == 3)
        ade[sidStart + 1].SetRightSib(sidStart + 2);

    ade[sidStart + 1].SetLeftSib(sidStart);
    return sidStart + 1;

    simpDebugOut((DEB_ITRACE, "Out CSimpStorage::BuildTree\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::Commit, public
//
//  Synopsis:   Commits transacted changes
//
//  Arguments:  [dwFlags] - DFC_*
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::Commit(DWORD dwFlags)
{
    CDfName const dfnRoot(L"Root Entry");
    SCODE sc;
    
    olLog(("%p::In  CSimpStorage::Commit(%lX)\n",this, dwFlags));

    SIMP_VALIDATE(Commit(dwFlags));
    
    // Simple mode commit does not allow open stream elements
    // While we could possibly revert the stream instead of returning an error,
    // it would not have the same semantics as normal mode transactions
    if (_pdflCurrent != NULL)
        return STG_E_INVALIDFUNCTION;

    if (!_fDirty)
        return S_OK;

    //Allocate a buffer big enough for all the control structures.
    const USHORT cdePerSect = SECTORSIZE / sizeof(CDirEntry);
    const USHORT cSectPerFat = SECTORSIZE / sizeof(SECT);

    ULONG cDifSect = 0;
    ULONG cFatSect = 0;
    ULONG cFatSectOld = (ULONG)-1;
    ULONG cDifSectOld = (ULONG)-1;
    ULONG cDirSect;
    ULONG cSect;
    ULONG cbSize;

    cDirSect = (_cStreams + 1 + cdePerSect - 1) / cdePerSect;
    cSect = _sectMax + cDirSect;

    //At this point, csect is the number of sectors needed to hold
    //  everything but the fat itself (and the DIFat, if necessary).


    while ((cFatSect != cFatSectOld) || (cDifSect != cDifSectOld))
    {
        //Now, compute the number of fat sectors needed to hold everything.

        cFatSectOld = cFatSect;
        cFatSect = (cSect + cFatSect + cDifSect + cSectPerFat - 1) /
            cSectPerFat;

        cDifSectOld = cDifSect;
        if (cFatSect >= CSECTFAT)
        {
            cDifSect = (cFatSect - CSECTFAT + cSectPerFat - 2)
                        / (cSectPerFat - 1);
        }
    }

    //At this point, we know how big the buffer needs to be.  Allocate
    // it.

    _pbBuf = new BYTE[(cFatSect + cDirSect + cDifSect) * SECTORSIZE];

    if (_pbBuf == NULL)
    {
        return STG_E_INSUFFICIENTMEMORY;
    }

    //The fat is placed in the buffer first, followed by the directory.
    SECT sect;
    SECT *asectFat;
    SECT *asectDif;
    CDirEntry *adeDir;

    SECT sectDifStart = _sectMax;
    SECT sectFatStart = _sectMax + cDifSect;
    SECT sectDirStart = _sectMax + cDifSect + cFatSect;

    asectDif = (SECT *)_pbBuf;
    asectFat = (SECT *)(_pbBuf + (cDifSect * SECTORSIZE));
    adeDir = (CDirEntry *)(_pbBuf + ((cFatSect + cDifSect) * SECTORSIZE));
    //asectFat and adeDir can be used as arrays.

    //Need to get the buffer to a correct 'empty' state.
    //  1)  Initialize fat and difat to all 0xff.
    memset(asectDif, 0xff, cDifSect * SECTORSIZE);
    memset(asectFat, 0xff, cFatSect * SECTORSIZE);

    //  2)  Initialize dir to all empty state
    for (USHORT i = 0; i < cDirSect * cdePerSect; i++)
    {
        adeDir[i].Init(STGTY_INVALID);
        simpAssert((BYTE *)&adeDir[i] <
                   _pbBuf + ((cFatSect + cDifSect + cDirSect) * SECTORSIZE));
    }


    if (cDifSect > 0)
    {
        //Put dif into fat.
        for (sect = sectDifStart; sect < sectFatStart; sect++)
        {
            asectFat[sect] = DIFSECT;
            simpAssert((BYTE *)&asectFat[sect] < (BYTE *)adeDir);

            ULONG ulOffset = sect - sectDifStart;

            asectDif[ulOffset * cSectPerFat + (cSectPerFat - 1)] = sect + 1;
        }
        asectDif[((cDifSect - 1) * cSectPerFat) + (cSectPerFat - 1)] =
            ENDOFCHAIN;
        _hdr.SetDifStart(sectDifStart);
        _hdr.SetDifLength(cDifSect);
    }

    for (sect = sectFatStart;
         sect < sectDirStart;
         sect++)
    {
        asectFat[sect] = FATSECT;
        simpAssert((BYTE *)&asectFat[sect] < (BYTE *)adeDir);

        ULONG ulOffset = sect - sectFatStart;

        if (ulOffset < CSECTFAT)
        {
            _hdr.SetFatSect(ulOffset, sect);
        }
        else
        {
            ulOffset -= CSECTFAT;
            asectDif[(ulOffset / (cSectPerFat - 1)) * cSectPerFat +
                     (ulOffset % (cSectPerFat - 1))] = sect;
        }
    }

    for (sect = sectDirStart;
         sect < sectDirStart + cDirSect;
         sect++)
    {
        asectFat[sect] = sect + 1;
        simpAssert((BYTE *)&asectFat[sect] < (BYTE *)adeDir);
    }
    asectFat[sectDirStart + cDirSect - 1] = ENDOFCHAIN;
    simpAssert((BYTE *)&asectFat[sectDirStart + cDirSect - 1] <
               (BYTE *)adeDir);

    _hdr.SetDirStart(sectDirStart);
    _hdr.SetFatLength(cFatSect);

    //Fat, directory, and header are set up.  Woowoo.

    //Walk name list and construct directory and fat structures for
    //    user streams.
    //Write them out, then write out header.

    CDfNameList *pdfl;
    SID sid;
    pdfl = _pdfl;
    sid = 1;

    while (pdfl != NULL)
    {
        //Set up fat chain.
        SECT sectStart = pdfl->GetStart();
        cSect = (pdfl->GetSize() + SECTORSIZE - 1) / SECTORSIZE;

        for (sect = sectStart; sect < sectStart + cSect; sect++)
        {
            asectFat[sect] = sect + 1;
            simpAssert((BYTE *)&asectFat[sect] < (BYTE *)adeDir);
        }
        asectFat[sectStart + cSect - 1] = ENDOFCHAIN;
        simpAssert((BYTE *)&asectFat[sectStart + cSect - 1] < (BYTE *)adeDir);

        adeDir[sid].SetFlags(STGTY_STREAM);
        adeDir[sid].SetName(pdfl->GetName());
        adeDir[sid].SetStart(pdfl->GetStart());
        adeDir[sid].SetSize(pdfl->GetSize());
        adeDir[sid].SetColor(DE_BLACK);
        simpAssert((BYTE *)&adeDir[sid] <
                   _pbBuf + ((cFatSect + cDifSect + cDirSect) * SECTORSIZE));
        pdfl = pdfl->GetNext();
        sid++;
    }

    //Set up root entry.
    adeDir[0].Init(STGTY_ROOT);
    adeDir[0].SetName(&dfnRoot);
    adeDir[0].SetClassId(_clsid);
    adeDir[0].SetColor(DE_BLACK);

    //This recursively builds the btree and sets the root in the child
    //    of the root entry.
    adeDir[0].SetChild(BuildTree(adeDir, 1, _cStreams));


    //Write out buffer
    ULONG cbWritten;
    DWORD dwErr;

    dwErr = SetFilePointer(_hFile, ConvertSect(_sectMax), NULL, FILE_BEGIN);
    if (dwErr == INVALID_SET_FILE_POINTER)
    {
        sc = STG_SCODE(GetLastError());
        delete _pbBuf;
        _pbBuf = NULL;
        return sc;
    }
    BOOL f= WriteFile(_hFile,
                      _pbBuf,
                      (cFatSect + cDifSect + cDirSect) * SECTORSIZE,
                      &cbWritten,
                      NULL);
    if (!f)
    {
        sc = STG_SCODE(GetLastError());
        delete _pbBuf;
        _pbBuf = NULL;
        return sc;
    }

    //Write out header
    dwErr= SetFilePointer(_hFile, 0, NULL, FILE_BEGIN);
    if (dwErr == INVALID_SET_FILE_POINTER)
    {
        sc = STG_SCODE(GetLastError());
        delete _pbBuf;
        _pbBuf = NULL;
        return sc;
    }

    f= WriteFile(_hFile,
                 _hdr.GetData(),
                 sizeof(CMSFHeaderData),
                 &cbWritten,
                 NULL);
    if (!f)
    {
        sc = STG_SCODE(GetLastError());
        delete _pbBuf;
        _pbBuf = NULL;
        return sc;
    }

    if (!(dwFlags & STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE))
    {
        f = FlushFileBuffers(_hFile);
        if (!f)
        {
            sc = STG_SCODE(GetLastError());
            delete _pbBuf;
            _pbBuf = NULL;
            return sc;
        }
    }

    delete _pbBuf;
    _pbBuf = NULL;

    _fDirty = FALSE;

    olLog(("%p::Out CSimpStorage::Commit().  ret == %lx\n",this, S_OK));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::Revert, public
//
//  Synopsis:   Reverts transacted changes
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::Revert(void)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::EnumElements, public
//
//  Synopsis:   Starts an iterator
//
//  Arguments:  [reserved1]
//              [reserved2]
//              [reserved3]
//              [ppenm] - Enumerator return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppenm]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::EnumElements(DWORD reserved1,
                                           void *reserved2,
                                           DWORD reserved3,
                                           IEnumSTATSTG **ppenm)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::DestroyElement, public
//
//  Synopsis:   Permanently deletes an element of a DocFile
//
//  Arguments:  [pwcsName] - Name of element
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::DestroyElement(WCHAR const *pwcsName)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::MoveElementTo, public
//
//  Synopsis:   Move an element of a DocFile to an IStorage
//
//  Arguments:  [pwcsName] - Current name
//              [ptcsNewName] - New name
//
//  Returns:    Appropriate status code
//
//  Algorithm:  Open source as storage or stream (whatever works)
//              Create appropriate destination
//              Copy source to destination
//              Set create time of destination equal to create time of source
//              If appropriate, delete source
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::MoveElementTo(WCHAR const *pwcsName,
                                             IStorage *pstgParent,
                                             OLECHAR const *ptcsNewName,
                                             DWORD grfFlags)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::RenameElement, public
//
//  Synopsis:   Renames an element of a DocFile
//
//  Arguments:  [pwcsName] - Current name
//              [pwcsNewName] - New name
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::RenameElement(WCHAR const *pwcsName,
                                             WCHAR const *pwcsNewName)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::SetElementTimes, public
//
//  Synopsis:   Sets element time stamps
//
//  Arguments:  [pwcsName] - Name
//              [pctime] - create time
//              [patime] - access time
//              [pmtime] - modify time
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::SetElementTimes(WCHAR const *pwcsName,
                                               FILETIME const *pctime,
                                               FILETIME const *patime,
                                               FILETIME const *pmtime)
{
    SCODE sc;
    
    olLog(("%p::In  CSimpStorage::SetElementTimes(%ws, %p, %p, %p)\n",
           this, pwcsName, pctime, patime, pmtime));

    SIMP_VALIDATE(SetElementTimes(pwcsName,
                                  pctime,
                                  patime,
                                  pmtime));
    
    if (pwcsName != NULL)
        return STG_E_INVALIDFUNCTION;

    if (!SetFileTime(_hFile,
                     pctime,
                     patime,
                     pmtime))
    {
        return STG_SCODE(GetLastError());
    }
    olLog(("%p::Out CSimpStorage::SetElementTimes().  ret == %lx\n",
           this, S_OK));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::SetClass, public
//
//  Synopsis:   Sets storage class
//
//  Arguments:  [clsid] - class id
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::SetClass(REFCLSID rclsid)
{
    olLog(("%p::In  CSimpStorage::SetClass(?)\n", this));
    SCODE sc;
    
    SIMP_VALIDATE(SetClass(rclsid));
    
    _clsid = rclsid;
    _fDirty = TRUE;
    olLog(("%p::Out CSimpStorage::SetClass().  ret == %lx\n",
           this, S_OK));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::SetStateBits, public
//
//  Synopsis:   Sets state bits
//
//  Arguments:  [grfStateBits] - state bits
//              [grfMask] - state bits mask
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpStorage::AddRef(void)
{
    ULONG ulRet;

    olLog(("%p::In  CSimpStorage::AddRef()\n", this));
    simpDebugOut((DEB_TRACE, "In  CSimpStorage::AddRef()\n"));

    AtomicInc(&_cReferences);
    ulRet = _cReferences;

    simpDebugOut((DEB_TRACE, "Out CSimpStorage::AddRef\n"));
    olLog(("%p::Out CSimpStorage::AddRef().  ret == %lu\n", this, ulRet));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    olLog(("%p::In  CSimpStorage::QueryInterface(?, %p)\n",
           this, ppvObj));
    simpDebugOut((DEB_TRACE, "In  CSimpStorage::QueryInterface(?, %p)\n",
                ppvObj));

    SIMP_VALIDATE(QueryInterface(iid, ppvObj));

    sc = S_OK;
    if (IsEqualIID(iid, IID_IStorage) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IStorage *)this;
        CSimpStorage::AddRef();
    }
    else if (IsEqualIID(iid, IID_IMarshal))
    {
        *ppvObj = (IMarshal *)this;
        CSimpStorage::AddRef();
    }
    else if (IsEqualIID(iid, IID_IPropertySetStorage))
    {
        *ppvObj = (IPropertySetStorage *)this;
        CSimpStorage::AddRef();
    }
    else
        sc = E_NOINTERFACE;

    olLog(("%p::Out CSimpStorage::QueryInterface().  "
           "*ppvObj == %p  ret == %lx\n", this, *ppvObj, sc));
    simpDebugOut((DEB_TRACE, "Out CSimpStorage::QueryInterface => %p\n",
                ppvObj));
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::GetUnmarshalClass, public
//
//  Synopsis:   Returns the class ID
//
//  Arguments:  [riid] - IID of object
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcid] - CLSID return
//
//  Returns:    Invalid function.
//
//  Modifies:   [pcid]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::GetUnmarshalClass(REFIID riid,
                                                void *pv,
                                                DWORD dwDestContext,
                                                LPVOID pvDestContext,
                                                DWORD mshlflags,
                                                LPCLSID pcid)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::GetMarshalSizeMax, public
//
//  Synopsis:   Returns the size needed for the marshal buffer
//
//  Arguments:  [riid] - IID of object being marshaled
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::GetMarshalSizeMax(REFIID riid,
                                                void *pv,
                                                DWORD dwDestContext,
                                                LPVOID pvDestContext,
                                                DWORD mshlflags,
                                                LPDWORD pcbSize)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::MarshalInterface, public
//
//  Synopsis:   Marshals a given object
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [riid] - Interface to marshal
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::MarshalInterface(IStream *pstStm,
                                               REFIID riid,
                                               void *pv,
                                               DWORD dwDestContext,
                                               LPVOID pvDestContext,
                                               DWORD mshlflags)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::UnmarshalInterface, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//              [riid] -
//              [ppvObj] -
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::UnmarshalInterface(IStream *pstStm,
                                                 REFIID riid,
                                                 void **ppvObj)
{
    return STG_E_INVALIDFUNCTION;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::ReleaseMarshalData, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::ReleaseMarshalData(IStream *pstStm)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::DisconnectObject, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [dwRevserved] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::DisconnectObject(DWORD dwReserved)
{
    return STG_E_INVALIDFUNCTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\simp\simpstm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	simpstm.cxx
//
//  Contents:	CStdStream implementation
//
//  Classes:	
//
//  Functions:	
//
//  History:	04-Aug-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "simphead.cxx"
#pragma hdrstop

#include <ole.hxx>
#include <logfile.hxx>
#include <expparam.hxx>


#if DBG == 1 && defined(SECURE_SIMPLE_MODE)
void CSimpStream::CheckSeekPointer(void)
{
    LONG lHighChk;
    ULONG ulLowChk;
    lHighChk = 0;
    ulLowChk = SetFilePointer(_hFile, 0, &lHighChk, FILE_CURRENT);
    if (ulLowChk == 0xFFFFFFFF)
    {
        //An error occurred while checking.
        simpDebugOut((DEB_ERROR, "SetFilePointer call failed with %lu\n",
                      GetLastError()));
    }
    else if ((ulLowChk != _ulSeekPos) || (lHighChk != 0))
    {
        simpDebugOut((DEB_ERROR, "Seek pointer mismatch."
                      "  Cached = %lu, Real = %lu, High = %lu\n",
                      _ulSeekPos, ulLowChk, lHighChk));
        simpAssert((ulLowChk == _ulSeekPos) && (lHighChk == 0));
    }
}
#define CheckSeek() CheckSeekPointer()
#else
#define CheckSeek()
#endif // DBG == 1 && defined(SECURE_SIMPLE_MODE)

//+---------------------------------------------------------------------------
//
//  Member:	CSimpStream::Init, public
//
//  Synopsis:	Initialize stream object
//
//  Arguments:	[pstgParent] -- Pointer to parent
//              [hFile] -- File handle for writes
//              [ulSeekStart] -- Beginning seek pointer
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	04-Aug-94	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CSimpStream::Init(
    CSimpStorage *pstgParent,
    HANDLE hFile,
    ULONG ulSeekStart)
{
    simpDebugOut((DEB_ITRACE, "In  CSimpStream::Init:%p()\n", this));
    _ulSeekStart = ulSeekStart;
    _hFile = hFile;
    _pstgParent = pstgParent;
    _cReferences = 1;

#ifdef SECURE_SIMPLE_MODE    
    _ulHighWater = ulSeekStart;
#endif    
    _ulSeekPos = ulSeekStart;
    
    if (SetFilePointer(_hFile, ulSeekStart, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return STG_SCODE(GetLastError());
    }

    CheckSeek();
    
    if (!SetEndOfFile(_hFile))
    {
        return STG_SCODE(GetLastError());
    }
    
    simpDebugOut((DEB_ITRACE, "Out CSimpStream::Init\n"));
    return S_OK;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Read, public
//
//  Synopsis:   Read from a stream
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return number of bytes read
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Read(VOID HUGEP *pb, ULONG cb, ULONG *pcbRead)
{
    ULONG cbRead;
    ULONG *pcb;
    SCODE sc;

    olLog(("%p::In  CSimpStream::Read(%p, %lu, %p)\n",
           this, pb, cb, pcbRead));

    SIMP_VALIDATE(Read(pb, cb, pcbRead));
    
    pcb = (pcbRead != NULL) ? pcbRead : &cbRead;

#ifdef SECURE_SIMPLE_MODE
    if (_ulSeekPos + cb > _ulHighWater)
    {
        ULONG cbTotalSize;
        cbTotalSize = GetFileSize(_hFile, NULL);

        if (_ulSeekPos + cb > cbTotalSize)
        {
            //Truncate.
            cb = (_ulSeekPos > cbTotalSize) ? 0 : cbTotalSize - _ulSeekPos;
        }
        
        //Part of this read would come from uninitialized space, so
        //  we need to return zeroes instead.
        if (_ulSeekPos > _ulHighWater)
        {
            if (SetFilePointer(_hFile,
                               _ulSeekPos + cb,
                               NULL,
                               FILE_BEGIN) == 0xFFFFFFFF)
            {
                //We can't get the seek pointer where it will need to
                //  end up, so return zero bytes and be done with it.
                *pcb = 0;
                return S_OK;
            }
            
            //Actually, the whole thing is coming from uninitialized
            //  space.  Why someone would do this is a mystery, but
            //  let's return zeroes anyway.
            memset(pb, SECURECHAR, cb);
            *pcb = cb;
            
            _ulSeekPos += cb;
        }
        else
        {
            ULONG cbBytesToRead = _ulHighWater - _ulSeekPos;
            
            if (FAILED(sc = Read(pb, cbBytesToRead, pcb)))
            {
                CheckSeek();
                return sc;
            }

            cb -= *pcb;
            
            if ((*pcb != cbBytesToRead) ||
                (SetFilePointer(_hFile,
                                _ulSeekPos + cb,
                                NULL,
                                FILE_BEGIN) == 0xFFFFFFFF))
            {
                //Either the Read call returned a weird number of bytes,
                //                     Or
                //We can't actually get the seek pointer where we need
                //  it, so return fewer bytes than we normally would,
                //  with a success code.
                CheckSeek();
                return S_OK;
            }
            
            //Zero the rest of the buffer.
            memset((BYTE *)pb + *pcb, SECURECHAR, cb);
            *pcb += cb;
            _ulSeekPos += cb;
        }
        CheckSeek();
        return S_OK;
    }
#endif
        
    //Maps directly to ReadFile call
    BOOL f = ReadFile(_hFile,
                      pb,
                      cb,
                      pcb,
                      NULL);

    _ulSeekPos += *pcb;
    
    CheckSeek();

    if (!f)
        return STG_SCODE(GetLastError());

    olLog(("%p::Out CSimpStream::Read().  *pcbRead == %lu, ret = %lx\n",
           this, *pcb, S_OK));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Write, public
//
//  Synopsis:   Write to a stream
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to write
//              [pcbWritten] - Return of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbWritten]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Write(
    VOID const HUGEP *pb,
    ULONG cb,
    ULONG *pcbWritten)
{
    ULONG cbWritten;
    ULONG *pcb;
    BOOL f = TRUE;
    SCODE sc = S_OK;
    
    olLog(("%p::In  CSimpStream::Write(%p, %lu, %p)\n",
           this, pb, cb, pcbWritten));

    SIMP_VALIDATE(Write(pb, cb, pcbWritten));
    
    pcb = (pcbWritten != NULL) ? pcbWritten : &cbWritten;

    if (_ulSeekPos + cb >= OLOCKREGIONBEGIN)
        return STG_E_DOCFILETOOLARGE;

#ifdef SECURE_SIMPLE_MODE
    if (_ulSeekPos > _ulHighWater)
    {
        //We're leaving a gap in the file, so we need to fill in that
        //   gap.  Sad but true.
        ULONG cbBytesToWrite = _ulSeekPos - _ulHighWater;

        ULONG cbWrittenSecure;
    
        if (SetFilePointer(_hFile,
                           _ulHighWater,
                           NULL,
                           FILE_BEGIN) != 0xFFFFFFFF)
        {
            while (cbBytesToWrite > 0)
            {
                if (!(f = WriteFile(_hFile,
                                    s_bufSecure,
                                    min(MINISTREAMSIZE, cbBytesToWrite),
                                    &cbWrittenSecure,
                                    NULL)))
                {
                    break;
                }
                cbBytesToWrite -= cbWrittenSecure;
            }
            if ((!f) && (SetFilePointer(_hFile,
                               _ulSeekPos,
                               NULL,
                               FILE_BEGIN) == 0xFFFFFFFF))
            {
                return STG_SCODE(GetLastError());
            }
        }
        CheckSeek();
    }
#endif    
    //Maps directly to WriteFile call
    f = WriteFile(_hFile,
                       pb,
                       cb,
                       pcb,
                       NULL);

    _ulSeekPos += *pcb;
#ifdef SECURE_SIMPLE_MODE
    if (_ulSeekPos > _ulHighWater)
        _ulHighWater = _ulSeekPos;
#endif

    if (!f)
    {
        sc = STG_SCODE(GetLastError());
    }

    CheckSeek();
    olLog(("%p::Out CSimpStream::Write().  "
           "*pcbWritten == %lu, ret = %lx\n",
           this, *pcb, sc));

    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Seek, public
//
//  Synopsis:   Seek to a point in a stream
//
//  Arguments:  [dlibMove] - Offset to move by
//              [dwOrigin] - SEEK_SET, SEEK_CUR, SEEK_END
//              [plibNewPosition] - Return of new offset
//
//  Returns:    Appropriate status code
//
//  Modifies:   [plibNewPosition]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Seek(LARGE_INTEGER dlibMove,
                               DWORD dwOrigin,
                               ULARGE_INTEGER *plibNewPosition)
{
    SCODE sc = S_OK;
    LONG lMove;
    ULONG ulPos = 0;

    simpAssert((dwOrigin == STREAM_SEEK_SET) || (dwOrigin == STREAM_SEEK_CUR) ||
               (dwOrigin == STREAM_SEEK_END));

    olLog(("%p::In  CSimpStream::Seek(%ld, %lu, %p)\n",
           this, LIGetLow(dlibMove), dwOrigin, plibNewPosition));

    SIMP_VALIDATE(Seek(dlibMove, dwOrigin, plibNewPosition));
    
    // Truncate dlibMove to 32 bits
    if (dwOrigin == STREAM_SEEK_SET)
    {
        // Make sure we don't seek too far
        if (LIGetHigh(dlibMove) != 0)
            LISet32(dlibMove, 0xffffffff);
    }
    else
    {
        // High dword must be zero for positive values or -1 for
        // negative values
        // Additionally, for negative values, the low dword can't
        // exceed -0x80000000 because the 32nd bit is the sign
        // bit
        if (LIGetHigh(dlibMove) > 0 ||
            (LIGetHigh(dlibMove) == 0 &&
             LIGetLow(dlibMove) >= 0x80000000))
            LISet32(dlibMove, 0x7fffffff);
        else if (LIGetHigh(dlibMove) < -1 ||
                 (LIGetHigh(dlibMove) == -1 &&
                  LIGetLow(dlibMove) <= 0x7fffffff))
            LISet32(dlibMove, 0x80000000);
    }

    lMove = (LONG)LIGetLow(dlibMove);
    
    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:
        ulPos = _ulSeekStart + lMove;
        break;
        
    case STREAM_SEEK_END:
        ULONG cbSize;
        cbSize = GetFileSize(_hFile, NULL);
        
        if (lMove < 0)
        {
            if ((ULONG)(-lMove) > (cbSize - _ulSeekStart))
                return STG_E_INVALIDFUNCTION;
        }
        ulPos = cbSize+lMove;
        break;
        
    case STREAM_SEEK_CUR:
        ulPos = SetFilePointer(_hFile, 0, NULL, FILE_CURRENT);
        
        if (lMove < 0)
        {
            if ((ULONG)(-lMove) > (ulPos - _ulSeekStart))
                return STG_E_INVALIDFUNCTION;
        }
        ulPos += lMove;
        break;
    }

    ulPos = SetFilePointer(_hFile,
                           ulPos,
                           NULL,
                           FILE_BEGIN);

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, ulPos - _ulSeekStart);
    }

    _ulSeekPos = ulPos;

    CheckSeek();

    olLog(("%p::Out CSimpStream::Seek().  ulPos == %lu,  ret == %lx\n",
           this, ulPos, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::SetSize, public
//
//  Synopsis:   Sets the size of a stream
//
//  Arguments:  [ulNewSize] - New size
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::SetSize(ULARGE_INTEGER ulNewSize)
{
    ULONG ulCurrentPos;
    SCODE sc;
    
    olLog(("%p::In  CSimpStream::SetSize(%lu)\n",
           this, ULIGetLow(ulNewSize)));

    SIMP_VALIDATE(SetSize(ulNewSize));
    
    ulCurrentPos = SetFilePointer(_hFile, 0, NULL, FILE_CURRENT);

    if (ulCurrentPos == 0xFFFFFFFF)
    {
        return STG_SCODE(GetLastError());
    }
    
    if (ULIGetHigh(ulNewSize) != 0 ||
        ulCurrentPos + ULIGetLow(ulNewSize) >= OLOCKREGIONBEGIN)
        return STG_E_DOCFILETOOLARGE;

    if (SetFilePointer(_hFile,
                       ULIGetLow(ulNewSize) + _ulSeekStart,
                       NULL,
                       FILE_BEGIN) == 0xFFFFFFFF)
    {
        CheckSeek();
        return STG_SCODE(GetLastError());
    }
    
    if (!SetEndOfFile(_hFile))
    {
        SetFilePointer(_hFile, ulCurrentPos, NULL, FILE_BEGIN);

        CheckSeek();
        return STG_SCODE(GetLastError());
    }

#ifdef SECURE_SIMPLE_MODE
    // if we are shrinking the stream below the highwater mark, reset it
    if (ULIGetLow(ulNewSize) + _ulSeekStart < _ulHighWater)
    {
        _ulHighWater = ULIGetLow(ulNewSize) + _ulSeekStart;
    }
#endif    
        
    if (SetFilePointer(_hFile, ulCurrentPos, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        _ulSeekPos = ULIGetLow(ulNewSize) + _ulSeekStart;
        CheckSeek();
        return STG_SCODE(GetLastError());
    }
    
    CheckSeek();
    olLog(("%p::Out CSimpStream::SetSize().  ret == %lx\n", this, S_OK));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::CopyTo, public
//
//  Synopsis:   Copies information from one stream to another
//
//  Arguments:  [pstm] - Destination
//              [cb] - Number of bytes to copy
//              [pcbRead] - Return number of bytes read
//              [pcbWritten] - Return number of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//              [pcbWritten]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::CopyTo(IStream *pstm,
                                 ULARGE_INTEGER cb,
                                 ULARGE_INTEGER *pcbRead,
                                 ULARGE_INTEGER *pcbWritten)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream::CopyTo("
                  "%p, %lu, %p, %p)\n", pstm, ULIGetLow(cb),
                  pcbRead, pcbWritten));
    simpDebugOut((DEB_TRACE, "Out CSimpStream::CopyTo\n"));
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Release, public
//
//  Synopsis:   Releases a stream
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpStream::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CSimpStream::Release()\n", this));
    simpDebugOut((DEB_TRACE, "In  CSimpStream::Release()\n"));

    simpAssert(_cReferences > 0);
    lRet = AtomicDec(&_cReferences);
    if (lRet == 0)
    {
#ifdef SECURE_SIMPLE_MODE
        _pstgParent->ReleaseCurrentStream(_ulHighWater);
#else        
        _pstgParent->ReleaseCurrentStream();
#endif        
        
        delete this;
    }
    else if (lRet < 0)
        lRet = 0;

    simpDebugOut((DEB_TRACE, "Out CSimpStream::Release\n"));
    olLog(("%p::Out CSimpStream::Release().  ret == %lu\n", this, lRet));
    FreeLogFile();
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc = S_OK;

    simpDebugOut((DEB_TRACE, "In  CSimpStream::Stat(%p, %lu)\n",
                  pstatstg, grfStatFlag));

    SIMP_VALIDATE(Stat(pstatstg, grfStatFlag));
    
    memset (pstatstg, 0, sizeof(STATSTG));

    if (!(grfStatFlag & STATFLAG_NONAME))
    {
        return STG_E_INVALIDFLAG;
    }

    pstatstg->cbSize.LowPart = _ulSeekPos - _ulSeekStart;
    pstatstg->cbSize.HighPart = 0;
    pstatstg->type = STGTY_STREAM;
    pstatstg->grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE;

    simpDebugOut((DEB_TRACE, "Out CSimpStream::Stat\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Clone, public
//
//  Synopsis:   Clones a stream
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Clone(IStream **ppstm)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream::Clone(%p)\n",
                  ppstm));
    simpDebugOut((DEB_TRACE, "Out CSimpStream::Clone\n"));
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpStream::AddRef(void)
{
    ULONG ulRet;

    olLog(("%p::In  CSimpStream::AddRef()\n", this));
    simpDebugOut((DEB_TRACE, "In  CSimpStream::AddRef()\n"));

    AtomicInc(&_cReferences);
    ulRet = _cReferences;

    simpDebugOut((DEB_TRACE, "Out CSimpStream::AddRef\n"));
    olLog(("%p::Out CSimpStream::AddRef().  ret == %lu\n", this, ulRet));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::LockRegion, public
//
//  Synopsis:   Nonfunctional
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::LockRegion(ULARGE_INTEGER libOffset,
                                     ULARGE_INTEGER cb,
                                     DWORD dwLockType)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream::LockRegion("
                  "%lu, %lu\n", ULIGetLow(cb), dwLockType));
    simpDebugOut((DEB_TRACE, "Out CSimpStream::LockRegion\n"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::UnlockRegion, public
//
//  Synopsis:   Nonfunctional
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::UnlockRegion(ULARGE_INTEGER libOffset,
                                       ULARGE_INTEGER cb,
                                       DWORD dwLockType)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream::UnlockRegion(%lu, %lu)\n",
                  ULIGetLow(cb), dwLockType));
    simpDebugOut((DEB_TRACE, "Out CSimpStream::UnlockRegion\n"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Commit, public
//
//  Synopsis:   No-op in current implementation
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Commit(DWORD grfCommitFlags)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream::Commit(%lu)\n",
                  grfCommitFlags));
    simpDebugOut((DEB_TRACE, "Out CSimpStream::Commit\n"));
    return STG_E_UNIMPLEMENTEDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Revert, public
//
//  Synopsis:   No-op in current implementation
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Revert(void)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream::Revert()\n"));
    simpDebugOut((DEB_TRACE, "Out CSimpStream::Revert\n"));
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    olLog(("%p::In  CSimpStream::QueryInterface(?, %p)\n",
           this, ppvObj));
    simpDebugOut((DEB_TRACE, "In  CSimpStream::QueryInterface(?, %p)\n",
                  ppvObj));

    SIMP_VALIDATE(QueryInterface(iid, ppvObj));
    
    sc = S_OK;
    if (IsEqualIID(iid, IID_IStream) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IStream *)this;
        CSimpStream::AddRef();
    }
    else if (IsEqualIID(iid, IID_IMarshal))
    {
        *ppvObj = (IMarshal *)this;
        CSimpStream::AddRef();
    }
    else
        sc = E_NOINTERFACE;

    simpDebugOut((DEB_TRACE, "Out CSimpStream::QueryInterface => %p\n",
                  ppvObj));
    olLog(("%p::Out CSimpStream::QueryInterface().  "
           "*ppvObj == %p, ret == %lx\n", this, *ppvObj, sc));
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStream::GetUnmarshalClass, public
//
//  Synopsis:   Returns the class ID
//
//  Arguments:  [riid] - IID of object
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcid] - CLSID return
//
//  Returns:    Invalid function.
//
//  Modifies:   [pcid]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::GetUnmarshalClass(REFIID riid,
                                            void *pv,
                                            DWORD dwDestContext,
                                            LPVOID pvDestContext,
                                            DWORD mshlflags,
                                            LPCLSID pcid)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::GetMarshalSizeMax, public
//
//  Synopsis:   Returns the size needed for the marshal buffer
//
//  Arguments:  [riid] - IID of object being marshaled
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::GetMarshalSizeMax(REFIID riid,
                                            void *pv,
                                            DWORD dwDestContext,
                                            LPVOID pvDestContext,
                                            DWORD mshlflags,
                                            LPDWORD pcbSize)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::MarshalInterface, public
//
//  Synopsis:   Marshals a given object
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [riid] - Interface to marshal
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::MarshalInterface(IStream *pstStm,
                                           REFIID riid,
                                           void *pv,
                                           DWORD dwDestContext,
                                           LPVOID pvDestContext,
                                           DWORD mshlflags)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::UnmarshalInterface, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//              [riid] -
//              [ppvObj] -
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::UnmarshalInterface(IStream *pstStm,
                                             REFIID riid,
                                             void **ppvObj)
{
    return STG_E_INVALIDFUNCTION;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStream::ReleaseMarshalData, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::ReleaseMarshalData(IStream *pstStm)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::DisconnectObject, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [dwRevserved] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::DisconnectObject(DWORD dwReserved)
{
    return STG_E_INVALIDFUNCTION;
}

//+---------------------------------------------------------------------------
//
//  Member: CSimpStreamOpen::Init, public
//
//  Synopsis:   Initialize stream object for simple mode read
//
//  Arguments:  [pstgParent] -- Pointer to parent
//              [hFile] -- File handle for writes
//              [ulSeekStart] -- Beginning seek pointer
//              [grfMode] -- open mode of the stream
//              [pdfl] -- CDfNameList entry for this stream
//
//  Returns:    Appropriate status code
//
//  History:    04-Jun-96   HenryLee    Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE CSimpStreamOpen::Init(CSimpStorageOpen *pstgParent, HANDLE hFile,
                         ULONG ulSeekStart, DWORD grfMode, CDfNameList *pdfl)
{
    simpDebugOut((DEB_ITRACE, "In  CSimpStreamOpen::Init:%p()\n", this));
    simpAssert (pdfl != NULL);

    _ulSeekStart = ulSeekStart;
    _pdfl = pdfl;
    _hFile = hFile;
    _pstgParent = pstgParent;
    _cReferences = 1;
    _grfMode = grfMode;

    if (SetFilePointer(_hFile, ulSeekStart, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

#ifdef SECURE_SIMPLE_MODE
    _ulHighWater = ulSeekStart + pdfl->GetSize();
#endif
    _ulSeekPos = ulSeekStart;

    simpDebugOut((DEB_ITRACE, "Out CSimpStreamOpen::Init\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStreamOpen::Read, public
//
//  Synopsis:   Read from a stream for simple mode open
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//  History:    04-Aug-96   HenryLee    Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStreamOpen::Read ( VOID *pb, ULONG cb, ULONG *pcbRead)
{
    SCODE sc = S_OK;
    simpAssert (_pdfl != NULL);

    // cannot read past end of stream
    if (_ulSeekPos + cb > _ulSeekStart + _pdfl->GetSize())
        cb = _ulSeekStart + _pdfl->GetSize() - _ulSeekPos;

    sc = CSimpStream::Read (pb, cb, pcbRead);

    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStreamOpen::Write, public
//
//  Synopsis:   Write to a stream for simple mode open
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to write
//              [pcbWritten] - Return of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbWritten]
//
//  History:    04-Jun-96   HenryLee    Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStreamOpen::Write(VOID const *pb, ULONG cb, ULONG *pcbWritten)
{
    SCODE sc = S_OK;
    simpAssert (_pdfl != NULL);

    if ((_grfMode & (STGM_READ|STGM_WRITE|STGM_READWRITE)) == STGM_READ)
        return STG_E_ACCESSDENIED;

    // cannot write past end of stream
    if (_ulSeekPos + cb > _ulSeekStart + _pdfl->GetSize()) 
        return STG_E_WRITEFAULT;

    sc = CSimpStream::Write (pb, cb, pcbWritten);

    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStreamOpen::SetSize, public
//
//  Synopsis:   Sets the size of a stream for simple mode read
//
//  Arguments:  [ulNewSize] - New size
//
//  Returns:    Appropriate status code
//
//  History:    04-Jun-96   HenryLee    Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStreamOpen::SetSize(ULARGE_INTEGER ulNewSize)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream2::SetSize()\n"));

    simpAssert (_pdfl != NULL);

    return STG_E_INVALIDFUNCTION;

    simpDebugOut((DEB_TRACE, "Out CSimpStreamOpen::SetSize\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStreamOpen::Release, public
//
//  Synopsis:   Releases a stream
//
//  Returns:    Appropriate status code
//
//  History:    04-Jun-96   HenryLee    Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpStreamOpen::Release()
{
    simpDebugOut((DEB_TRACE, "In  CSimpStreamOpen::Release()\n"));

    simpAssert(_cReferences > 0);
    LONG lRet = AtomicDec(&_cReferences);
    if (lRet == 0)
    {
        ((CSimpStorageOpen *)_pstgParent)->ReleaseCurrentStream();
        delete this;
    }
    else if (lRet < 0)
        lRet = 0;

    simpDebugOut((DEB_TRACE, "Out CSimpStreamOpen::Release\n"));
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStreamOpen::Seek, public
//
//  Synopsis:   Seek to a point in a stream
//
//  Arguments:  [dlibMove] - Offset to move by
//              [dwOrigin] - SEEK_SET, SEEK_CUR, SEEK_END
//              [plibNewPosition] - Return of new offset
//
//  Returns:    Appropriate status code
//
//  Modifies:   [plibNewPosition]
//
//  History:    04-Sep-96      HenryLee   Created
//
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStreamOpen::Seek(LARGE_INTEGER dlibMove,
                                   DWORD dwOrigin,
                                   ULARGE_INTEGER *plibNewPosition)
{
    SCODE sc = S_OK;
    LONG lMove;
    ULONG ulPos = 0;

    simpDebugOut((DEB_TRACE, "%p::In  CSimpStreamOpen::Seek(%ld, %lu, %p)\n",
           this, LIGetLow(dlibMove), dwOrigin, plibNewPosition));

    SIMP_VALIDATE(Seek(dlibMove, dwOrigin, plibNewPosition));
    
    // Truncate dlibMove to 32 bits
    if (dwOrigin == STREAM_SEEK_SET)
    {
        if (LIGetHigh(dlibMove) != 0)   // Make sure we don't seek too far
            LISet32(dlibMove, 0xffffffff);
    }
    else
    {
        // High dword must be zero for positive values or -1 for
        // negative values
        // Additionally, for negative values, the low dword can't
        // exceed -0x80000000 because the 32nd bit is the sign
        // bit
        if (LIGetHigh(dlibMove) > 0 ||
           (LIGetHigh(dlibMove) == 0 && LIGetLow(dlibMove) >= 0x80000000))
            LISet32(dlibMove, 0x7fffffff);
        else if (LIGetHigh(dlibMove) < -1 ||
                (LIGetHigh(dlibMove) == -1 && LIGetLow(dlibMove) <= 0x7fffffff))
            LISet32(dlibMove, 0x80000000);
    }

    lMove = (LONG)LIGetLow(dlibMove);

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:
        if (lMove < 0 || (ULONG) lMove > _pdfl->GetSize())
            return STG_E_INVALIDFUNCTION;

        ulPos = _ulSeekStart + lMove;
        break;

    case STREAM_SEEK_END:
        if (lMove > 0 || (lMove < 0 && (ULONG)(-lMove) > _pdfl->GetSize())) 
            return STG_E_INVALIDFUNCTION;

        ulPos = _ulSeekStart + _pdfl->GetSize() + lMove;
        break;

    case STREAM_SEEK_CUR:
        ulPos = SetFilePointer(_hFile, 0, NULL, FILE_CURRENT);

        if ((ULONG) (ulPos + lMove) > _ulSeekStart + _pdfl->GetSize() ||
            (LONG) (ulPos + lMove) < _ulSeekStart)
            return STG_E_INVALIDFUNCTION;

        ulPos += lMove;
        break;
    }

    ulPos = SetFilePointer(_hFile,
                           ulPos,
                           NULL,
                           FILE_BEGIN);

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, ulPos - _ulSeekStart);
    }

    _ulSeekPos = ulPos;

    simpDebugOut((DEB_TRACE, "%p::Out CSimpStreamOpen::Seek(). ulPos==%lu,"
           " ret==%lx\n", this, ulPos, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStreamOpen::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStreamOpen::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc = S_OK;
    simpDebugOut((DEB_TRACE, "In  CSimpStreamOpen::Stat(%p, %lu)\n",
                  pstatstg, grfStatFlag));

    SIMP_VALIDATE(Stat(pstatstg, grfStatFlag));
    
    simpAssert (_pdfl != NULL);

    memset (pstatstg, 0, sizeof(STATSTG));

    if (!(grfStatFlag & STATFLAG_NONAME))
    {
        pstatstg->pwcsName = (WCHAR *) CoTaskMemAlloc (
                _pdfl->GetName()->GetLength()+sizeof(WCHAR));

        if (pstatstg->pwcsName)
        {
           memcpy (pstatstg->pwcsName, _pdfl->GetName()->GetBuffer(),
                _pdfl->GetName()->GetLength());
           pstatstg->pwcsName[_pdfl->GetName()->GetLength()/sizeof(WCHAR)] =
                L'\0';
        }
        else sc = STG_E_INSUFFICIENTMEMORY;
    }

    pstatstg->cbSize.LowPart = _pdfl->GetSize();
    pstatstg->cbSize.HighPart = 0;
    pstatstg->type = STGTY_STREAM;
    pstatstg->grfMode = _grfMode;

    simpDebugOut((DEB_TRACE, "Out CSimpStreamOpen::Stat\n"));
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\utils\df2t\df2t.cxx ===
//+----------------------------------------------------------------------------// File:    DF2T.CXX
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1991 - 1992.
//
// Contents:  utility program for converting a Docfile to a directory tree.
//  	      Given a Docfile,it is walked with an enumerator and each
//			  embedded IStorage creates a directory in the specified
//	      destination tree while each IStream creates a file within
//	      the appropriate directory.  Finally, a tree compare is
//	      performed on the source and destination trees.
//
// Classes:   IStorage    - Container class
//            IStream     - Contained stream class
//            IEnumSTATSTG - Enumerator class for IStorages
//
// Command line:  df2c -f/-b -(n)ameofDocfile -(s)rcTree -(d)estTree -T -W
//		    -f forward conversion (docfile --> tree)
//		    -b backward conversion (tree --> docfile)
//          -n name for root docfile
//          -s name of the source directory tree
//		    -d name of the destination directory tree
//          -t specifies STGM_TRANSACTED mode
//          -w specifies STGM_SHARE_DENY_WRITE mode for root docfile
//
//		  -f and -b cannot be both specified in one command.
//
//		  The default conversion is from Docfile to tree.
//		  Therefore, -n and -d(est) must be specified when forward
//		  conversion -f is used.  Otherwise, -b should be accompanied
//		  by -s(rc) and -n(doc).
//
//                This utility defaults to running in DIRECT mode so that all
//                operations at all levels are performed immediately on the
//                base copy of the root docfile.
//
//                With the -T switch, this runs in STGM_TRANSACTED mode for
//                all IStorage creation and instantiation so that scratch
//		  streams are created and committed, but only made permanent
//		  in the persistent version by Commit of the root docfile.
//
//                With the -W switch, this runs in STGM_TRANSACTED mode
//                with STGM_SHARE_DENY_WRITE for root docfile creation and
//                instantiation so that operations are performed on the base
//                copy of the docfile.
//
// Requires:  Windows 3.x.  MSF.DLL and DOCFILE.DLL should be in same dir
//            as executable or in \windows\system
//
// Returns:   0 if successful, exits with error code otherwise
//
// Notes:     uses whcar and 'mbtowcs' conversions for wide char support
//	      returns STG_E_NOTCURRENT if docfile-to-be-created
//	      already exists.
//
// Created: RichE, January 13, 1992  Original program
// Revised: t-chrisy, June 25, 1992  convert the test program to a utility
// 					dftc.cxx --> df2t.cxx
//-----------------------------------------------------------------------------


#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include <direct.h>

#include "w4ctsupp.hxx"

#define WILD_CARD "\\*.*"
#define BACK_SLASH "\\"
#define NS_INCL (STGTY_STORAGE | STGTY_STREAM)
#define FIND_ATTRS _A_SUBDIR | _A_NORMAL | _A_RDONLY | _A_HIDDEN
#define FILE_BUF_SIZE 32768 // msf is optimized for file size of 4K or 512bytes
#define DOCTOTREE 0
#define TREETODOC 1

//function prototypes
void CopyTreeToDocfile(IStorage *pstgParent);
void CopyDocfileToTree(IStorage *pstgParent, TCHAR *ptcsDFName);
void CopyFileToStream(IStorage *pstgParent, char *FileName);
void CopyStreamToFile(IStorage *pstgParent, TCHAR *ptcsStreamName);
int GetOptions(int argc, char *argv[]);
void Usage(char *pszProgName);

//buffers for file/dir path calls and docfile name (default assignments)
char szDestDocfile[_MAX_PATH + 1] = "";
char szSrcPath[_MAX_PATH + 1] = "";
char szDestPath[_MAX_PATH + 1] = "";
int  iSrcPathEnd = sizeof(_MAX_PATH);   //length minus terminating '\0'
int  iDestPathEnd = sizeof(_MAX_PATH);

//buffers for converting to/from wide characters
TCHAR wcsWideName[_MAX_PATH + 1];
char  szName[_MAX_PATH + 1];

//modifiers to flags for root and child docfiles (GetOptions may modify)
DWORD dwRootFlags = STGM_READWRITE | STGM_SHARE_DENY_WRITE;
DWORD dwChildFlags = STGM_READWRITE | STGM_SHARE_EXCLUSIVE;

void utMemFree(void *pv)
{
    IMalloc FAR* pMalloc;
    if (SUCCEEDED(GetScode(CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        pMalloc->Free(pv);
        pMalloc->Release();
    }
}

//+----------------------------------------------------------------------------
// Function: main, public
//
// Synopsis: main body of program, controls overall flow
//
// Effects:  initialize.  Depending on the direction of converionsn,
//			  call functions to create a tree, given a DocFile;
//			  call functions to create a DocFile, given a tree.
//
// Created: RichE January 13, 1992  original program
// Revised: t-chrisy June 25, 1992  modified to convert docfile to tree;
//					and vice versa.
//
//-----------------------------------------------------------------------------

void main(int argc, char *argv[])
{
    IStorage *pstgDest = NULL;
    SCODE    scRc;
    short ret;

#if WIN32 == 300
    if (FAILED(scRc = GetScode(CoInitializeEx(NULL, COINIT_MULTITHREADED))))
#else
    if (FAILED(scRc = GetScode(CoInitialize(NULL))))
#endif
    {
        fprintf(stderr, "CoInitialize failed with sc = %lx\n", scRc);
        exit(1);
    }

    ret=GetOptions(argc, argv);
    if (ret==DOCTOTREE)
    {
        tprintf(bDestOut, "Converting Docfile to tree....\n");
        if ((!strcmp(szDestDocfile,"\0"))||(!strcmp(szDestPath,"\0")))
        {
            tprintf(bDestOut, "Invalid switches used.\n");
            tprintf(bDestOut,
                    "If -f is indicated, -n and -d must also be specified.\n");
            exit(1);
        }	
    }	
    else
    {
        tprintf(bDestOut, "Converting a directory tree to Docfile....\n");
        if ((!strcmp(szDestDocfile,"\0")||(!strcmp(szSrcPath,"\0"))))
        {
            tprintf(bDestOut, "Invalid switches used.\n");
            tprintf(bDestOut,
                    "If -b is chosen, -s and -n must also be specified.\n");
            exit(1);
        }
    }

    if (dwRootFlags & STGM_TRANSACTED)
    {
        tprintf(bDestOut, "STGM_TRANSACTED mode ");
        if ((dwRootFlags & 0x70) == STGM_SHARE_EXCLUSIVE)
        {
            tprintf(bDestOut, "with STGM_SHARE_EXCLUSIVE");
        }
        else
        {
            tprintf(bDestOut, "without STGM_SHARE_EXCLUSIVE");
        }
    }
    else
    {
        tprintf(bDestOut, "STGM_DIRECT mode (with STGM_SHARE_EXCLUSIVE)");
    }
    tprintf(bDestOut, " operation\n");

    MakeWide(wcsWideName, szDestDocfile);

    if (ret==DOCTOTREE) // Docfile to tree...
    {
        MakePath(szDestPath);
        CopyDocfileToTree((IStorage *) NULL, wcsWideName);
    }
    else
    {	
	// Create root docfile with specified mode, nuke if already exists
        tprintf(bDestOut, "Create root docfile %s\n", szDestDocfile);
        scRc = GetScode(StgCreateDocfile(wcsWideName,
                                         dwRootFlags | STGM_CREATE, 0,
                                         &pstgDest));
        tprintf(bDestOut, "Returned %lu\n", scRc);
        tprintf(bDestOut, "Root docfile %s %s, pointer %p\n", szDestDocfile,
                pstgDest == NULL ? "FALSE" : "TRUE", pstgDest);
        if (pstgDest == NULL || FAILED(scRc))
        {
            ErrExit(DEST_LOG, scRc, "Error creating root docfile %s\n",
                    szDestDocfile);
        }
        CopyTreeToDocfile(pstgDest);
    }
}

//+----------------------------------------------------------------------------
// Function: CopyTreeToDocfile, private
//
// Synopsis: traverses and reads source tree and creates docfile image
//
// Effects: for each directory in source tree, an IStorage is created, for each
//          file, a contained stream is created.  this function is recursive.
//
// Arguments: [pstgParent] - current parent IStorage for new containees
//
// Created: RichE, January 13, 1992
// Revised: RichE March 5, 1992     Df APIs to method calls
// Revised: RichE March 6, 1992     TRANSACTED mode operation
// Revised: RichE March 17, 1992    convert to OLE interfaces
//-----------------------------------------------------------------------------

void CopyTreeToDocfile(IStorage *pstgParent)
{
    struct find_t FileInfo;
    SCODE         scRc;
    USHORT        usEndOfBasePath;
    IStorage      *pstgChild;

    // Save pointer to base of pure path at this level
    usEndOfBasePath = strlen(szSrcPath) + 1;

    scRc = _dos_findfirst(strcat(szSrcPath, WILD_CARD), FIND_ATTRS, &FileInfo);
	
    while (scRc==0)
    {
	// If not '.' or '..' directories
	if (FileInfo.name[0] != '.')
	{
            // Restore pure path and add current file/dir name to it
            szSrcPath[usEndOfBasePath] = NIL;
            strcat(szSrcPath, FileInfo.name);
            if (FileInfo.attrib == _A_SUBDIR)
            {
                MakeWide(wcsWideName, FileInfo.name);
                // Create new IStorage inside current one,
                // use dir name for name
                tprintf(bDestOut,
                        "Create embedded DF %s inside pstgParent %p\n",
                        szSrcPath, pstgParent);
                scRc = GetScode(pstgParent->CreateStorage(wcsWideName,
                                                          dwChildFlags |
                                                          STGM_FAILIFTHERE,
                                                          0, 0,
                                                          &pstgChild));
                tprintf(bDestOut, "Returned: %lu, pointer = %p\n",
                        scRc, pstgChild);

                if (pstgChild == NULL || FAILED(scRc))
                {
                    ErrExit(DEST_LOG, scRc,
                            "Error creating child IStorage %s\n",
                            FileInfo.name);
                }
                CopyTreeToDocfile(pstgChild);
            }
            else
            {
                CopyFileToStream(pstgParent, FileInfo.name);
            }
        }
        scRc = _dos_findnext(&FileInfo);
    }
    if (dwRootFlags & STGM_TRANSACTED)
    {
        tprintf(bDestOut, "Committing pstgParent %p\n", pstgParent);
        if (scRc = GetScode(pstgParent->Commit(STGC_ONLYIFCURRENT)))
        {
            ErrExit(DEST_LOG, scRc, "Error committing IStorage %p\n",
                    pstgParent);
        }
    }
    tprintf(bDestOut, "Releasing pstgParent %p\n", pstgParent);
    pstgParent->Release();
}

//+----------------------------------------------------------------------------
// Function: CopyFileToStream, private
//
// Synopsis: copies supplied file to stream inside of parent IStorage
//
// Arguments: [pstgParent] - parent IStorage for stream created
//            [FileName] - name of source file to copy to stream
//
// Created: RichE, January 13, 1992
// Revised: RichE March 5, 1992     Df APIs to method calls
// Revised: RichE March 6, 1992     TRANSACTED mode operation
// Revised: RichE March 15, 1992    streams no longer TRANSACTED
// Revised: RichE March 17, 1992    convert to OLE interfaces
//-----------------------------------------------------------------------------

void CopyFileToStream(IStorage *pstgParent, char *FileName)
{
    IStream *pstmStream = NULL;
    FILE    *FileToCopy;
    SCODE   scRc;
    ULONG   cNumRead;
    ULONG   cNumWritten;
    BYTE    *FileBuf;

    tprintf(bDestOut, "  File %s\n", szSrcPath);
    FileToCopy = fopen(szSrcPath, "rb");
    if (FileToCopy == NULL)
    {
        ErrExit(DEST_LOG, ERR, "Cannot open file %s\n", szSrcPath);
    }

    MakeWide(wcsWideName, FileName);

    // Create a stream inside parent IStorage
    tprintf(bDestOut,
            "Create embedded stream inside parent pstgParent = %p\n",
            pstgParent);
    scRc = GetScode(pstgParent->CreateStream(wcsWideName, STGM_STREAM |
                                             STGM_FAILIFTHERE, 0, 0,
                                             &pstmStream));
    tprintf(bDestOut, "Returned: %lu, pointer = %p\n", scRc, pstmStream);
    if (pstmStream == NULL || FAILED(scRc))
    {
        ErrExit(DEST_LOG, scRc, "Error creating stream %s\n", szSrcPath);
    }

    FileBuf = (BYTE * ) Allocate(FILE_BUF_SIZE * sizeof(BYTE));

    //while still reading from source file, write what was just read to Stream
    while (cNumRead = fread(FileBuf, 1, FILE_BUF_SIZE, FileToCopy))
    {
        if (ferror(FileToCopy))
        {
            ErrExit(DEST_LOG, ERR, "Error during stream read of %s\n",
                    szSrcPath);
        }

        tprintf(bDestOut, "Try Stream write of %lu bytes on stream %p\n",
                cNumRead, pstmStream);
        scRc = GetScode(pstmStream->Write(FileBuf, cNumRead, &cNumWritten));
        tprintf(bDestOut, "Returned: %lu, bytes written %lu\n",
                scRc, cNumWritten);
        if (cNumWritten != cNumRead)
        {
            tprintf(bDestOut, "Write:  scRc = %lu, cNumWritten = %lu, ",
                    scRc, cNumWritten);
            tprintf(bDestOut, "cNumRead = %lu\n", cNumRead);
        }

        if (FAILED(scRc))
        {
            ErrExit(DEST_LOG, ERR, "Error writing stream %p\n", pstmStream);
        }
    }

    tprintf(bDestOut, "Releasing stream %p\n", pstmStream);
    pstmStream->Release();

    fclose(FileToCopy);
    free(FileBuf);
}

//+----------------------------------------------------------------------------// Function: CopyDocfileToTree, private
//
// Synopsis: enumerates and reads docfile and creates directory tree
//
// Effects: for each child IStorage in the root docfile, a subdir is created,
//          for each child stream, a file is created.  this function is
//          recursive.
//
// Arguments: [pstgParent] - current parent IStorage for reading containees
//            [ptcsDFName] - name of IStorage to instantiate
//
// Created: RichE, January 13, 1992
// Revised: RichE March 5, 1992     Df APIs to method calls
// Revised: RichE March 6, 1992     TRANSACTED mode operation
// Revised: RichE March 17, 1992    convert to OLE interfaces
// Revised: t-chrisy June 30, 1992  removed the section on unlinking docfile
//-----------------------------------------------------------------------------

void CopyDocfileToTree(IStorage *pstgParent, TCHAR *ptcsDFName)
{
    IStorage    *pstgSrc = NULL;
    IEnumSTATSTG *penmWalk;
    USHORT      usEndOfBasePath;
    SCODE       scRc;
    STATSTG     sstg;
    int         iRc;

    // Add back slash & save pointer to base of pure path at this level
    strcat(szDestPath, BACK_SLASH);
    usEndOfBasePath = strlen(szDestPath);

    MakeSingle(szName, ptcsDFName);

    // If not first call (parent != NULL) then instantiate child IStorage with
    // method call, else instantiate root docfile via Df API call
    if (pstgParent != NULL)
    {
        tprintf(bDestOut, "Get embedded IStorage %s in parent %p\n",
                szName, pstgParent);
        scRc = GetScode(pstgParent->OpenStorage(ptcsDFName, NULL, dwChildFlags,
                                                NULL, 0, &pstgSrc));
    }
    else
    {
        tprintf(bDestOut, "Instantiate root docfile %s\n", szName);
	dwRootFlags |= STGM_READ;
        scRc = GetScode(StgOpenStorage(ptcsDFName, NULL, dwRootFlags, NULL,
                                       0, &pstgSrc));
    }

    tprintf(bDestOut, "Return code: %lu, IStorage pointer %p\n",
            scRc, pstgSrc);
    if (pstgSrc == NULL || FAILED(scRc))
    {
        ErrExit(DEST_LOG, scRc, "Error instantiating IStorage %s\n", szName);
    }

    // Get an enumerator on the IStorage we just instantiated
    scRc = GetScode(pstgSrc->EnumElements(0, NULL, 0, &penmWalk));
    tprintf(bDestOut, "Got enumerator %p on IStorage %p, returned %lu\n",
            penmWalk, pstgSrc, scRc);
    if (penmWalk == NULL || FAILED(scRc))
    {
        ErrExit(DEST_LOG, scRc,
                "Error obtaining enumerator for IStorage %p\n", pstgSrc);
    }

    // Loop until GetNext returns other than S_OK, then break out of loop
    while (TRUE)
    {
        if (GetScode(penmWalk->Next(1, &sstg, NULL)) != S_OK)
        {
            tprintf(bDestOut, "No more to enumerate with enumerator %p\n",
                    penmWalk);
            break;
        }
        else
        {
            MakeSingle(szName, sstg.pwcsName);
            tprintf(bDestOut, "Got item type %lu, Name %s, w/enumerator %p\n",
                    sstg.type, szName, penmWalk);

            // Restore to path + BACK_SLASH and add file/dir name to DestPath
            szDestPath[usEndOfBasePath] = NIL;
            strcat(szDestPath, szName);
            tprintf(bDestOut, "Path Name: %s is ", szDestPath);
            if (sstg.type == STGTY_STORAGE)
            {
                tprintf(bDestOut, "STGTY_STORAGE\n");
                iRc = _mkdir(szDestPath);
                tprintf(bDestOut,
                        "Trying to make directory %s, returned %d\n",
                        szDestPath, iRc);
                CopyDocfileToTree(pstgSrc, sstg.pwcsName);
            }
            else
            {
                tprintf(bDestOut, "STGTY_STREAM\n");
                CopyStreamToFile(pstgSrc, sstg.pwcsName);
            }
        }

        utMemFree(sstg.pwcsName);
    }

    tprintf(bDestOut, "Releasing enumerator %p\n", penmWalk);
    penmWalk->Release();
}


//+----------------------------------------------------------------------------
// Function: CopyStreamToFile, private
//
// Synopsis: copies supplied embedded stream to file in current dubdir
//
// Arguments: [pstgParent] - parent IStorage for stream to copy
//            [ptcsStreamName] - name of stream to copy to file
//
// Created: RichE, January 13, 1992
// Revised: RichE March 5, 1992     Df APIs to method calls
// Revised: RichE March 6, 1992     TRANSACTED mode operation
// Revised: RichE March 15, 1992    streams no longer TRANSACTED
// Revised: RichE March 17, 1992    convert to OLE interfaces
//-----------------------------------------------------------------------------

void CopyStreamToFile(IStorage *pstgParent, TCHAR *ptcsStreamName)
{
    IStream *pstmStream = NULL;
    FILE    *FileToWrite;
    ULONG   cNumRead = 1;
    ULONG   cNumWritten;
    BYTE    *FileBuf;
    SCODE   scRc;

    tprintf(bDestOut, "Copying embedded stream to file %s\n", szDestPath);

    // Instantiate named stream within parent IStorage
    tprintf(bDestOut, "Get stream in parent %p\n", pstgParent);
    scRc = GetScode(pstgParent->OpenStream(ptcsStreamName, NULL, STGM_STREAM,
                                           0, &pstmStream));
    tprintf(bDestOut, "Returned: %lu, stream pointer %p\n", scRc, pstmStream);
    if (pstmStream == NULL || FAILED(scRc))
    {
        ErrExit(DEST_LOG, scRc, "Error opening stream %s\n", szDestPath);
    }

    FileToWrite = fopen(szDestPath, "wb");
    if (FileToWrite == NULL)
    {
        ErrExit(DEST_LOG, ERR, "Cannot open file %s\n", szDestPath);
    }

    FileBuf = (BYTE * ) Allocate(FILE_BUF_SIZE * sizeof(BYTE));

    // While still reading Stream, write what was just read to file.
    tprintf(bDestOut, "Starting to read stream %p\n", pstmStream);
    while (cNumRead > 0)
    {
        scRc = GetScode(pstmStream->Read(FileBuf, FILE_BUF_SIZE, &cNumRead));
        tprintf(bDestOut, "Read %lu bytes from stream %p, returned %lu\n",
                cNumRead, pstmStream, scRc);
        if (FAILED(scRc))
        {
            ErrExit(DEST_LOG, scRc, "Error reading stream %p\n", pstmStream);
        }
        cNumWritten = (ULONG)fwrite(FileBuf, 1, (size_t)cNumRead, FileToWrite);
        if (ferror(FileToWrite))
        {
            ErrExit(DEST_LOG, ERR, "Error writing to file %s\n", szDestPath);
        }

        if (cNumWritten != cNumRead)
        {
            tprintf(bDestOut, "Fwrite: cNumRead = %lu, cNumWritten = %lu\n",
                    cNumRead, cNumWritten);
        }
    }

    tprintf(bDestOut, "Attempting to release stream %p in IStorage %p\n",
            pstmStream, pstgParent);
    pstmStream->Release();

    fclose(FileToWrite);
    free(FileBuf);
}


//+----------------------------------------------------------------------------
// Function: GetOptions, private
// Returns: DOCTOTREE or TREETODOC to indicate the direction of conversion.
//
// Synopsis: parses command line and sets global program options/variables
//
// Arguments: [argc] and [**argv] passed from main() function
//
// Modifies: [szSrcPath, szDestPath, szDestDocfile]
//
// Created: RichE, January 13, 1992
// Revised: RichE, March 15, 1992    added -T and -W switches
// Revised: RichE, March 19, 1992    fixed bug displaying error usage
// Revised: t-chrisy, June 25, 1992  added -f and -b switches
//-----------------------------------------------------------------------------

int GetOptions(int argc, char *argv[])
{
    char *pszArg;
    char *pszProgName;
    BOOL ArgsOK = TRUE;
    short ret=DOCTOTREE;

    // Bump past command name (argv[0])
    pszProgName = *argv++;

    // For each command line arg, if it begins with a '-' or '/' check the
    // next letter for a valid argument.  return error for invalid args

    while ((pszArg = *argv++) != NULL)
    {
        if (*pszArg == '-' || *pszArg == '/')
        {
            switch (tolower(*(++pszArg)))
            {
            case 'w':
                dwRootFlags |= STGM_TRANSACTED;
                dwChildFlags |= STGM_TRANSACTED;
                break;
            case 't':
                dwRootFlags |= STGM_TRANSACTED;
                dwChildFlags |= STGM_TRANSACTED;
                break;

            case 's':
                strcpy(szSrcPath, ++pszArg);
                iSrcPathEnd = strlen(pszArg);
                break;

            case 'd':
                strcpy(szDestPath, ++pszArg);
                iDestPathEnd = strlen(pszArg);
                break;

            case 'z':
                 LogFile(++pszArg,LOG_INIT);
                 break;

            case 'y':
                SetDebugMode(tolower(*(++pszArg)));
                break;

            case 'n':
                if (strlen(++pszArg) <= _MAX_PATH)
                {
                    strcpy(szDestDocfile, pszArg);
                }
                else
                {
                    tprintf(DEST_LOG, "Dest DocFile Name too long: %s\n",
                            pszArg);
                    tprintf(DEST_LOG, "Max len = %d\n", _MAX_PATH);
                    tprintf(DEST_LOG, "Specified len = %d\n", strlen(pszArg));
                    ArgsOK = FALSE;
                }
                break;
	
            case 'f':
                // Docfile to tree
                dwRootFlags &= ~0x03;		// clear access bits
                dwRootFlags |= STGM_READ;
                ret=DOCTOTREE;
                break;

            case 'b':
                // Tree to docfile
                dwRootFlags &= ~0x70;
                dwRootFlags |= STGM_SHARE_EXCLUSIVE;
                ret=TREETODOC;	
                break;

            default:
                ArgsOK = FALSE;
                break;
            }
        }
        else
            ArgsOK = FALSE;
	
        if (ArgsOK == FALSE)
        {
            tprintf(DEST_LOG,
                    "Invalid command line argument: %s\n", --pszArg);
            Usage(pszProgName);
        }
    }
    return ret;
}


//+----------------------------------------------------------------------------
// Function: Usage, private
//
// Synopsis: displays program syntax and example and exits with error
//
// Arguments: [pszProgramName] - name of this executable file for error usage
//
// Created: RichE, January 15, 1992
// Revised: t-chrisy, June 30, 1992  Added -f and -b options.
//+----------------------------------------------------------------------------

void Usage(char *pszProgName)
{
	
    tprintf(DEST_ERR, "Usage: %s\n", pszProgName);
    tprintf(DEST_ERR, "       [-f]		- forward conversion"
            "(docfile-->tree)  DEFAULT\n");
    tprintf(DEST_ERR, "       		-n and -d must be specified.");
    tprintf(DEST_ERR, "       [-b]		- backward conversion"
            "(tree-->docfile)\n");
    tprintf(DEST_ERR, "       		-s and -n must be specified.");
    tprintf(DEST_ERR, "       [-sSRCDIR]	 \n");
    tprintf(DEST_ERR, "       [-nDOCFILENAME]    \n");
    tprintf(DEST_ERR, "       [-dDESTDIR]        \n");
    tprintf(DEST_ERR, "       [-t]               - for transacted mode\n");
    tprintf(DEST_ERR, "       [-w]               - for deny write mode\n");
    ErrExit(DEST_ERR, ERR, "   ex:  %df2t -b -sc:\\dos -nd:\\docfile.dfl\n",
            pszProgName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\utils\chkdsk\chkdsk.cxx ===
//-----------------------------------------------------------------------
//
// File:	chkdsk.cxx
//
// Contents: 	Sanity checking and recovery mechanism for multistream files
//
// Argument: 
//
// History:	9-July-92	t-chrisy	Created.
//------------------------------------------------------------------------

#include "chkdsk.hxx"

// Global variables, declared as so for convenience.
CMSFHeader *pheader;
CFat *pFat;
CFat *pMiniFat;
CDirectory *pDir;
CDIFat *pDIFat;
BOOL fixdf;
CFatVector *pfvFat, *pfvMiniFat;
wchar_t pwcsDocfile[_MAX_PATH];
DFLAGS	df = DF_READWRITE | DF_DENYWRITE;

extern SCODE DllMultiStreamFromCorruptedStream(CMStream MSTREAM_NEAR **ppms,
			       ILockBytes **pplstStream,
			       DWORD dwFlags);

// Function Prototypes
void BuildFatTables();
void MarkFatTables();
void TreeWalk(CDirEntry *pde, SID sid);
BOOL GetOption(int argc, char *argv[]);
void Usage(char *pszProgName);
void DIFTable();

void main(int argc, char *argv[])
{
	CFileStream *pfilestr;
	CMStream MSTREAM_NEAR *pms;
	SCODE scRc;
	ILockBytes *pilb;

	// if fixdf returns yes, open docfile without a copy;
	// otherwise, open docfile with a copy and operate on the copy.
	fixdf = GetOption(argc,argv);
	pfilestr = new CFileStream;
	
	// creating ILockBytes implementation for the given file 
	// Note:  When a docfile is corrupted, the chkdsk utility
	//      calls the original CFileStream::Init.  If any objects
	//		fail to instantiate, the approach is to call an
	// 		alternative Init routine, which can force the instantiation
	// 		of Directory and MiniFat objects.

	if (fixdf==TRUE)		// -f specified, write allowed.
	{
		df &= ~0x03;
		df |= DF_WRITE;
		printf("Trying to open file...\n");
		scRc = pfilestr->Init(pwcsDocfile,RSF_OPEN,df);
		if (FAILED(scRc)) 
		{
			printf("Error creating ILockBytes.\n");
			exit(FAIL_CREATE_ILB);
		}
	}
	else					// open a read-only copy of filestream
	{
		df &= ~0x300;		// clear access bits
		df |= DF_DENYWRITE;
		printf("Trying to open file...\n");
		scRc = pfilestr->Init(pwcsDocfile,RSF_OPEN,df);
		if (FAILED(scRc)) 
		{
			printf("Error creating ILockBytes.\n");
			exit(FAIL_CREATE_ILB);
		}
		else printf("Successfully created ILockBytes.\n");
	}

  	scRc = pfilestr->Validate();
	if (scRc == STG_E_INVALIDHANDLE)
	{
		printf("Filestream signature is not valid.\n");
		exit(INVALID_DOCFILE);
	}

	// CFileStream is essentially equivalent to ILockBytes.
	pilb = (ILockBytes *) pfilestr;
	scRc = DllMultiStreamFromStream(&pms,&pilb,0);

	if (FAILED(scRc)) 
		if (FAILED(scRc = DllMultiStreamFromCorruptedStream
					(&pms,&pilb,0)))
		{
			exit(FAIL_CREATE_MULTISTREAM);
			printf("Error creating a multistream.\n");
		}

	
	// When an multi-stream is instantiated, the following control structures
	// are automatically instantiated.
	pheader = pms->GetHeader();
	pDir = pms->GetDir();
	pFat = pms->GetFat();
	pMiniFat = pms->GetMiniFat();
	pDIFat = pms->GetDIFat();

		printf("\tBuilding fat tables...\n");
	BuildFatTables();
		printf("\tExamining the DIFat...\n");
	DIFTable();
		printf("\tExamining Fat and MiniFat chains...\n");
	MarkFatTables();
		printf("\tChecking completed.\n");
	delete(pfvFat);
	delete(pfvMiniFat);
	pfilestr->Release();
		printf("Memory blocks freed.\n");
}

void BuildFatTables()
{
	// Build two tables: one for Fat sectors, the other for Minifat sectors.

	FSINDEX FatLen,MiniFatLen;
	FatLen = pheader->GetFatLength();
	MiniFatLen = pheader->GetMiniFatLength();
	pfvFat = new CFatVector(TABLE_SIZE);
	pfvFat->Init(FatLen);
	if (MiniFatLen == 0) 
		printf("No MiniFat to be checked.\n");
	else 
	{	
		pfvMiniFat = new CFatVector(TABLE_SIZE);
		pfvMiniFat->Init(MiniFatLen);
	}
}

void MarkFatTables()
{
	CDirEntry *pde;

	// Walk through all the fat chains and mark the new table with the
	// first SID number encountered.

	pDir->SidToEntry(SIDROOT,&pde);
	TreeWalk(pde,SIDROOT);			// pde points to the root entry now
}

void TreeWalk(CDirEntry *pde, SID sid)
{
	CDirEntry *pchild, *pnext;
	SID childsid, nextsid;
	SCODE scRc,scRcM;
	FSINDEX fitable,fioffset;
	SECT sectentry, sect;
	CFatSect *pfsec;
	CFatVector *pfv;
	CFat *pf;
	ULONG uldesize;
	
	pDir->GetStart(sid,&sect);
	uldesize = pde->GetSize();

	if (uldesize >= MINISTREAMSIZE)		// storage is in FAT
	{
		pfv = pfvFat;
		pf = pFat;
	}
	else
	{
		pfv = pfvMiniFat;
		pf = pMiniFat;
	}
	
	// Check if LUID exceeds MaxLUID.  If so, report the error.
	if (pde->GetLuid() > pheader->GetLuid())
		printf("LUID for dir entry #%lu exceeds MAXLuid.\n",sid);
	
	while (sect < MAXREGSECT)
	{
		if (sid == SIDROOT)
			break;		// nothing should be in root stream
		// Use fitable and fioffset to index into the fat (or minifat)
		// table and mark the field with visited.
		// at the same time, check for loops or crosslinks.

		//Note:  3 cases
		fitable = sect / (TABLE_SIZE);
		fioffset = sect % (TABLE_SIZE);
		pfv->GetTable(fitable,&pfsec);      // pfsec = ptr to CFatSect 
		sectentry = pfsec->GetSect(fioffset);		

//		printf("\tsect = %lu \t \t sectentry = %lu \t stream_size = %lu\n",
//				sect,sectentry, uldesize);
		// Mark the FatTables as well as fixing the multistream.
		// Right now, the routine only marks the FatTables.
		//Note:  3 cases...but the last two cases may not
		// be handled the same.
		if (sectentry > MAXREGSECT)
			pfsec->SetSect(fioffset,sid);
		else if (sectentry == sid)
		{
			// discontinue the current stream chain by marking
			// current SECT as ENDOFCHAIN.
			pf->SetNext(sect,ENDOFCHAIN);
			pfsec->SetSect(fioffset,ENDOFCHAIN);
			printf("Loop detected at fat SECT %ul\n",sectentry);
		}
		else 
		{
			pf->SetNext(sect,ENDOFCHAIN);
			pfsec->SetSect(fioffset,ENDOFCHAIN);
			printf("Crosslink detected at Fat SECT %lu with stream #%lu\n",
				sect,sid);
		}
		// get the next sector to be examined
		// !!!!! Need to use the Fat object to track down next sector
		pf->GetNext(sect,&sect);
	}
		
	// Recursively go down the tree
	// pchild and pnext must point to the original tree for
	// efficiency purposes.
	
	childsid = pde->GetChild();
	if (childsid != NOSTREAM) 
	{
		pDir->SidToEntry(childsid,&pchild);
		TreeWalk(pchild,childsid);
	}
	nextsid = pde->GetNext();
	if (nextsid != NOSTREAM)
	{
		pDir->SidToEntry(nextsid,&pnext);
		TreeWalk(pnext,nextsid);
	}

	if (fixdf==TRUE) 
	{
		scRc = pFat->Flush();
		scRcM = pMiniFat->Flush();
		if (FAILED(scRc) || FAILED(scRcM))
			printf("Failed to write all modified FatSects out to stream.\n");
	}
}
	
BOOL GetOption(int argc, char *argv[]) 
{
	char *pszArg, *pszProgName;
	BOOL ArgsOK = FALSE, Fix = FALSE;
	pszProgName = *argv++;

	while ((pszArg = *argv++) != NULL)
	{
		if (*pszArg == '-' || *pszArg == '/')
		{
			switch (tolower(*(++pszArg)))
			{
			case 'f':		// fix the errors.
				Fix = TRUE;   // open file with read-only without a copy.
				break;
			case 'n':		// name of the docfile to be opened.
							// path of the filename.
				mbstowcs(pwcsDocfile,++pszArg,_MAX_PATH);
				Fix = FALSE;
				ArgsOK = TRUE;
				break;
			default:
				break;
			}
		}
		else ArgsOK = FALSE;
	}
	if (ArgsOK == FALSE) 
	{
		printf("0 argument or invalid command line argument.\n");
		Usage(pszProgName);
		exit(INVALID_ARG);
	}
	return Fix;
}

void Usage(char *pszProgName)
{
	printf("Usage:  %s\n", pszProgName);
	printf("		-f	fix requested by user.\n");
	printf("		-n  <name of docfile>\n");
	printf("The -n option must be specified.\n");
}
	
	
void DIFTable()				// August 11, 1992
{
	// Walk through each DIF sector array to detect loops and 
	// crosslinks.  
	SCODE scRc;
	BOOL FatOK = TRUE;
	SECT sect, sectentry; 
	FSINDEX diflen, fatlen, fitable, fioffset, index, minifatlen,uldif,ulr;
	CFatSect *pfsec;

	diflen = pheader->GetDifLength();
	fatlen = pheader->GetFatLength();
	minifatlen = pheader->GetMiniFatLength();
	
	// testing the validity of pheader->GetDifLength
	if (fatlen > CSECTFAT)		// diflen > 0
	{
		ulr = ( ((fatlen - CSECTFAT)%TABLE_SIZE) > 0 )? 1: 0;
		uldif = CSECTFAT + (fatlen-CSECTFAT)/TABLE_SIZE + ulr;
	}
	else uldif = 0;
	if (diflen!=uldif) 
		printf("DIFLEN in header is inconsistent with FatLEN.\n");

	for (index=0; index<fatlen; index++)
	{
		pDIFat->GetFatSect(index,&sect);
		if (sect < MAXREGSECT)
		{
			fitable =  sect / TABLE_SIZE;
			fioffset = sect % TABLE_SIZE;
			pfvFat->GetTable(fitable,&pfsec);	 // pfsec = ptr to CFatSect 
			sectentry = pfsec->GetSect(fioffset);			
		
			if (sectentry > MAXREGSECT)
				pfsec->SetSect(fioffset,SIDFAT);
			else 
			{
				printf("Crosslink! DIF index #%u points\n",index);
				printf(" to the same location %u.\n", sect);
				FatOK = FALSE;
			}
		}
		pDIFat->GetFatSect(index+1,&sect);
	}

	if (FatOK == TRUE)
		printf("No errors found in DIFat.\n");

	// Walk through the terminating cells in each sector array to check
	// the correctness of chaining.
	printf("\tWalking through DIFTable chain.\n");
	for (index = 0; index<diflen; index++)
	{
		pDIFat->GetSect(index,&sect);
		fitable =  sect/TABLE_SIZE;
		fioffset = sect%TABLE_SIZE;
		pfvFat->GetTable(fitable,&pfsec); // pfsec = ptr to CFatSect 
		sectentry = pfsec->GetSect(fioffset);			
		if ((sectentry!=ENDOFCHAIN) && (index == diflen-1))
			printf("ERROR!  ENDOFCHAIN expected at the end of DIFat.\n.");
		pDIFat->SetFatSect(fioffset,SIDDIF);
		pfsec->SetSect(fioffset,SIDDIF);
	}
	if (fixdf==TRUE) 
	{
		scRc = pDIFat->FlushAll();
		if (FAILED(scRc)) 
			printf("Failed to write all modified FatSects out to stream.\n");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\utils\df2t\w4ctsupp.cxx ===
//############################################################################
//#
//#   Microsoft Windows
//#   Copyright (C) Microsoft Corporation, 1992 - 1992.
//#   All rights reserved.
//#
//############################################################################
//
//+----------------------------------------------------------------------------
// File: W4CTSUPP.CXX
//
// Contents: Contains support functions for docfile testing
//
// Command line: N/A
//
// Requires: must be linked with program containing function main()
//
// Notes: Compiled to create W4CTSUPP.LIB
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <direct.h>
#include <ctype.h>
#include <time.h>

#define __CRC32__
#include "w4ctsupp.hxx"

#include <dfdeb.hxx>

//char for separating FAT file name from extension
#define FILE_NAME_SEPARATOR '.'

//global array of interesting file sizes for IStream read/writes
USHORT ausSIZE_ARRAY[] = {0,1,2,255,256,257,511,512,513,2047,2048,2049,4095,4096,4097};

//test logging file pointer
static FILE *fileLogFile = NULL;

//should log be closed after every log write, modified by SetDebugMode()
static BOOL fCloseLogAfterWrite = FALSE;

//test name string for ErrExit and application use
char szTestName[MAX_TEST_NAME_LEN + 1] = "No Test Name Specified";

//random number seed used by test apps
USHORT usRandomSeed = 0;

//routing variable for standard out in tprintf and ErrExit calls
//can be changed from default of DEST_OUT
BYTE bDestOut = DEST_OUT;

//+----------------------------------------------------------------------------
// Function: Allocate, public
//
// Synopsis: allocate memory, exit with error if malloc failes
//
// Arguments: [cbBytesToAllocate] - size of memory block to allocate
//
// Returns: void pointer to block of memory allocated
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void *Allocate(size_t cbBytesToAllocate)
{
    void *pvMemPtr;

    pvMemPtr = (void *) malloc(cbBytesToAllocate);
    if(pvMemPtr == NULL)
    {
        ErrExit(DEST_ERR, ERR, "Unable to allocate %u bytes of memory\n",
                cbBytesToAllocate);
    }

    return pvMemPtr;
}

//+----------------------------------------------------------------------------
// Function: MakePath, public
//
// Synopsis: makes a sub-directory at end of specified path
//
// Effects: For each char in pszDirToMake, if it's a '\', make the destination
//          directory at the level accumulated in pszPathBuf, else append
//          the next letter of the dest path to pszPathBuf.  After the loop,
//          attempt to _mkdir a final time (since the path probably won't
//          end with a '\').
//
// Arguments: [pszDirToMake] - full directory path name to make
//
// Returns: TRUE if all directories in path were made OK, otherwise FALSE
//
// Created: RichE January 1992
//-----------------------------------------------------------------------------

BOOL MakePath(char *pszDirToMake)
{
#ifdef DBCS
	char *pszDirToMakeSav = pszDirToMake;
#endif
    char *pcDestPathSoFar;
    char *pszPathBuf;
    int  iRc;

    pszPathBuf = (char *) Allocate(_MAX_PATH + 1);
    pcDestPathSoFar = pszPathBuf;

    //
    //while not at end of path string, if this char is a back slash, make
    //the directory up to the slash.  in either case, copy the next char
    //into the accumulated path buffer.
    //

    while (*pszDirToMake)
    {
        if (*pszDirToMake == '\\')
        {
            *pcDestPathSoFar = NIL;
            iRc = _mkdir(pszPathBuf);
            tprintf(bDestOut, "Trying to make directory %s, returned %d\n",
                    pszPathBuf, iRc);
        }
#ifdef DBCS
 #ifdef _MAC
		if (iskanji (*pszDirToMake)) // iskanji is in dbcsutil.cpp
 #else
		if (IsDBCSLeadbyte (*pszDirToMake))
 #endif
        	*pcDestPathSoFar++ = *pszDirToMake++;
#endif
        *pcDestPathSoFar++ = *pszDirToMake++;
    }

    //
    //if the last char wasn't a back slash, the last part of the path hasn't
    //been made so make it.
    //
#ifdef DBCS
 #ifdef _MAC
	DecLpch (pszDirToMakeSav, pszDirToMake);
 #else
	pszDirToMake = AnsiPrev (pszDirToMakeSav, pszDirToMake);
 #endif // MAC
	if (*pszDirToMake != '\\')
#else
    if (*(--pszDirToMake) != '\\')
#endif
    {
        *pcDestPathSoFar = NIL;
        iRc = _mkdir(pszPathBuf);
        tprintf(bDestOut, "Trying to make directory %s, returned %d\n",
                pszPathBuf, iRc);
    }

    free(pszPathBuf);

    return (iRc == 0) ? TRUE : FALSE;
}



//+----------------------------------------------------------------------------
// Function: SetDebugMode, public
//
// Synopsis: sets debugging mode and program exit control and tprintf routing
//
// Effects: Sets exit control to 'no exit when complete.'  depending upon
//          the char passed, in calls debug macro to set appropriate
//          debug mode.  If no debug is specified, sets program exit
//          control to 'exit when complete' and sets flag to close log
//          file after every log write.  If a debug mode other than
//          none is specified, redirects default output destination to
//          DEST_LOG instead of DEST_OUT.  Also sets capture buffer to
//          unlimited size
//
// Arguments: [DebugMode] - single character representing desired mode
//
// Modifiles: [fCloseLogAfterWrite] - if running in non-debug mode, close
//                                    log file after every write
//
// Created: RichE April 1992
//-----------------------------------------------------------------------------

void SetDebugMode(char DebugMode)
{
    SET_DISPLAY_BUF_SIZE;

    NO_EXIT_WHEN_DONE;

    switch(DebugMode)
    {
    case 'a':
        DEBUG_ALL;
        bDestOut = DEST_LOG;
        break;

    case 'n':
        DEBUG_NONE;
        EXIT_WHEN_DONE;
        //fCloseLogAfterWrite = TRUE;
        break;

    case 'd':
        DEBUG_DOCFILE;
        bDestOut = DEST_LOG;
        break;

    case 'm':
        DEBUG_MSF;
        bDestOut = DEST_LOG;
        break;

    case 'i':
    default:
        DEBUG_INTERNAL_ERRORS;
        bDestOut = DEST_LOG;
        break;

    }
}



//+----------------------------------------------------------------------------
// Function: ErrExit, public
//
// Synopsis: allows error output to any combo of stdout, stderr, and logfile
//
// Effects: depending upon flags passed in, will display (via vfprintf)
//          error output to any combination of stdout, stderr, and a user-
//          supplied log file.  if output destination is a log file,
//          will open the log file if not already open and set
//          all output to the error output destination as well.
//          prints docfile error message based on error code, or
//          generic error message is error is undefined.  prints error
//          return code, prints FAIL message using extern global [szTestName]
//          (defined in calling test) and exits with error code.
//
// Arguments: [bOutputDest] - bit flags specifying where output goes
//                            valid flags defined in W4CTSUPP.HXX
//            [ErrCode] - error code to use in exit() function
//            [fmt] - vfprintf formatting string
//            [...] - parameters to vfprintf function
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void ErrExit(BYTE bOutputDest, SCODE ErrCode, char *fmt, ...)
{
    USHORT iErrIndex = 0;

    struct
    {
        SCODE scErrCode;
        char *pszErrMessage;
    } aszErrMessages[] = {S_FALSE,                     "S_FALSE",
                          STG_E_INVALIDFUNCTION,       "STG_E_INVALIDFUNCTION",
                          STG_E_FILENOTFOUND,          "STG_E_FILENOTFOUND",
                          STG_E_TOOMANYOPENFILES,      "STG_E_TOOMANYOPENFILES",
                          STG_E_ACCESSDENIED,          "STG_E_ACCESSDENIED",
                          STG_E_INVALIDHANDLE,         "STG_E_INVALIDHANDLE",
                          STG_E_INSUFFICIENTMEMORY,    "STG_E_INSUFFICIENTMEMORY",
                          STG_E_INVALIDPOINTER,        "STG_E_INVALIDPOINTER",
                          STG_E_NOMOREFILES,           "STG_E_NOMOREFILES",
                          STG_E_WRITEFAULT,            "STG_E_WRITEFAULT",
                          STG_E_READFAULT,             "STG_E_READFAULT",
                          STG_E_LOCKVIOLATION,         "STG_E_LOCKVIOLATION",
                          STG_E_FILEALREADYEXISTS,     "STG_E_FILEALREADYEXISTS",
                          STG_E_INVALIDPARAMETER,      "STG_E_INVALIDPARAMETER",
                          STG_E_MEDIUMFULL,             "STG_E_MEDIUMFULL",
                          STG_E_ABNORMALAPIEXIT,       "STG_E_ABNORMALAPIEXIT",
                          STG_E_INVALIDHEADER,         "STG_E_INVALIDHEADER",
                          STG_E_INVALIDNAME,           "STG_E_INVALIDNAME",
                          STG_E_UNKNOWN,               "STG_E_UNKNOWN",
                          STG_E_UNIMPLEMENTEDFUNCTION, "STG_E_UNIMPLEMENTEDFUNCTION",
                          STG_E_INVALIDFLAG,           "STG_E_INVALIDFLAG",
                          STG_E_INUSE,                 "STG_E_INUSE",
                          STG_E_NOTCURRENT,            "STG_E_NOTCURRENT",
                          STG_E_REVERTED,              "STG_E_REVERTED",
                          STG_S_CONVERTED,             "STG_S_CONVERTED",
                          ERR,                         "GENERIC_ERROR"
                         };

    va_list args;

    va_start(args, fmt);

    //if dest is log file, open log file if not already open
    //and set all output to DEST_ERR as well.
    if (bOutputDest & DEST_LOG)
    {
        bOutputDest |= DEST_ERR;

        if (fileLogFile == NULL)
        {
            LogFile(NULL, LOG_OPEN);
        }

        vfprintf(fileLogFile, fmt, args);

        if (fCloseLogAfterWrite == TRUE)
        {
            LogFile(NULL, LOG_CLOSE);
        }
    }

    if (bOutputDest & DEST_OUT)
    {
        vfprintf(stdout, fmt, args);
    }

    if (bOutputDest & DEST_ERR)
    {
        vfprintf(stderr, fmt, args);
    }

    va_end(args);

    tprintf(bOutputDest, "Return code %lu (0x%08lX), ", ErrCode, ErrCode);

    //lookup error in struct table and print error message
    while (aszErrMessages[iErrIndex].scErrCode != ErrCode)
    {
        if (aszErrMessages[iErrIndex].scErrCode == ERR)
        {
            break;
        }
        else
        {
            iErrIndex++;
        }
    }

    tprintf(bOutputDest, "%s\n", aszErrMessages[iErrIndex].pszErrMessage);

    tprintf(bOutputDest, "FAIL: %s\n", szTestName);

    exit((int) ErrCode);
}



//+----------------------------------------------------------------------------
// Function: tprintf, public
//
// Synopsis: allows output to any combo of stdout, stderr, and logfile
//
// Effects: depending upon flags passed in, will display (via vfprintf)
//          output to any combination of stdout, stderr, and a user-
//          supplied log file.  if output destination is a log file,
//          will open the log file if not already open and set
//          all output to the error output destination as well.
//
// Arguments: [bOutputDest] - bit flags specifying where output goes
//                            valid flags defined in W4CTSUPP.HXX
//            [fmt] - vfprintf formatting string
//            [...] - parameters to vfprintf function
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void tprintf(BYTE bOutputDest, char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);

    //if dest is log file, open log file if not already open
    //and set all output to DEST_ERR as well.
    if (bOutputDest & DEST_LOG)
    {
        bOutputDest |= DEST_ERR;

        if (fileLogFile == NULL)
        {
            LogFile(NULL, LOG_OPEN);
        }

        vfprintf(fileLogFile, fmt, args);

        if (fCloseLogAfterWrite == TRUE)
        {
            LogFile(NULL, LOG_CLOSE);
        }
    }

    if (bOutputDest & DEST_OUT)
    {
        vfprintf(stdout, fmt, args);
    }

    if (bOutputDest & DEST_ERR)
    {
        vfprintf(stderr, fmt, args);
    }

    va_end(args);
}



//+----------------------------------------------------------------------------
// Function: LogFile, public
//
// Synopsis: opens or closed specified file for logging via tprintf and errexit
//
// Effects: the specfied file is opened via fopen for logging purposes when
//          [bLogFileAction] = LOG_OPEN and closed for LOG_CLOSE.  The
//          calling application should open the LogFile via a LOG_INIT
//          call which will define the routine to call to ensure that the
//          log file is closed upon completion and set the log file name.
//
// Modifies: [fileLogFile] - the global variable defined at top of this file
//           will contain a pointer to the log file stream on exit.
//
// Arguments: [pszLogFileName] - pathname of file for logging purposes
//            [bLogFileAction] - whether to open or close the log file
//
// Notes: [pszLogReOpenName] is the filename to use for opening the log
//        file.  In non-debug runs, the log file is closed after every
//        log write and re-opened before the next write.
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void LogFile(char *pszLogFileName, BYTE bLogFileAction)
{
    static char  *pszLogReOpenName = NULL;
    static BOOL  fFirstInitCall = FALSE;
    char         *pszTestDataDir;

    switch (bLogFileAction)
    {
    case LOG_INIT:
        if (pszLogFileName == NULL)
        {
            ErrExit(DEST_ERR, ERR, "No filename specified for LOG_INIT\n");
        }

        if (fileLogFile != NULL)
        {
            fclose(fileLogFile);
            free(pszLogReOpenName);
        }

        pszLogReOpenName = (char *) Allocate(strlen(pszLogFileName)+1);
        strcpy(pszLogReOpenName, pszLogFileName);

        if (fFirstInitCall == FALSE)
        {
            //register function to call on program exit
            //

            atexit(MakeSureThatLogIsClosed);
            fFirstInitCall = TRUE;

            //
            //change to dir specified by DFDATA env variable, if it's set
            //

            if (pszTestDataDir = getenv("DFDATA"))
            {
                _chdir(pszTestDataDir);
            }
        }

        break;

    case LOG_OPEN:
        if (fileLogFile != NULL)
        {
            ErrExit(DEST_ERR,ERR,"Can't open log file %s, log is already open!",
                    pszLogReOpenName);
        }

        if (pszLogReOpenName == NULL)
        {
            pszLogReOpenName = (char *) Allocate(strlen(LOG_DEFAULT_NAME)+1);
            strcpy(pszLogReOpenName, LOG_DEFAULT_NAME);
        }

        if ((fileLogFile = fopen(pszLogReOpenName, "w")) == NULL)
        {
            ErrExit(DEST_ERR, ERR, "Error opening log file %s\n",
                    pszLogReOpenName);
        }

        break;

    case LOG_CLOSE:
        if (fileLogFile != NULL)
        {
            fflush(fileLogFile);
            fclose(fileLogFile);
        }
        else
        {
            tprintf(DEST_ERR,"Warning: can't close log file %s, log isn't open!",
                   pszLogReOpenName);
        }

        break;

    default:
        ErrExit(DEST_ERR,ERR,"Invalid parameter to LogFile() function!");
    }
}



//+----------------------------------------------------------------------------
// Function: MakeSureThatLogFileIsClosed
//
// Synopsis: closes log file on exit
//
// Effects: immediately flushes all file buffers, and then calls Logfile to
// close the test log file.  upon abnormal exit (GP fault), this saves most
// of the log information.
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void MakeSureThatLogIsClosed(void)
{
    //fflush(fileLogFile);
    LogFile(NULL, LOG_CLOSE);

}

//+----------------------------------------------------------------------------
// Function: MakeSingle, public
//
// Synopsis: converts TCHAR string to single character string
//
// Arguments: [pszSingleName] - pointer to TCHAR string
//            [ptcsWideName] - buffer to hold returned single-wide string
//
// Modifies: [pszSingleName] - on exit holds single-wide character string
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void MakeSingle(char *pszSingleName, TCHAR *ptcsWideName)
{
#ifdef UNICODE
    USHORT cusBufLen = (tcslen(ptcsWideName)+1) * sizeof(TCHAR);

    if (_fwcstombs(pszSingleName, ptcsWideName, cusBufLen) == -1)
    {
        ErrExit(DEST_LOG, ERR, "Error converting TCHAR string to single wide\n");
    }
#else
    strcpy(pszSingleName, ptcsWideName);
#endif
}



//+----------------------------------------------------------------------------
// Function: MakeWide, public
//
// Synopsis: converts single character string to multi-byte (TCHAR) string
//
// Arguments: [ptcsWideName] - buffer to hold returned TCHAR string
//            [pszSingleName] - pointer to single wide string
//
// Modifies: [ptcsWideName] - on exit holds wide character string
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void MakeWide(TCHAR *ptcsWideName, char *pszSingleName)
{
#ifdef UNICODE
    USHORT cusBufLen = (strlen(pszSingleName)+1) * sizeof(TCHAR);

    if (_fmbstowcs(ptcsWideName, pszSingleName, cusBufLen) == -1)
    {
        ErrExit(DEST_LOG, ERR, "Error converting name %s to TCHAR string\n", pszSingleName);
    }
#else
    strcpy(ptcsWideName, pszSingleName);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\utils\fail\fail.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       Fail.CXX
//
//  Contents:   Docfile Failure Test
//
//  History:    21-Jan-93 AlexT     Created
//
//  Notes:      This test cycles through all failure points for each call,
//              verifying that we clean up correctly.
//
//--------------------------------------------------------------------------

#include <headers.cxx>

#pragma hdrstop

#include <sift.hxx>

#if DBG != 1
#error FAIL.EXE requires DBG == 1
#endif

// #define BREADTHTEST  //  Comment out for depth testing (just most recent tests)

//+-------------------------------------------------------------------------
//
//  Function:   VerifyDisk
//
//  Synopsis:   verify that disk file does or does not exist
//
//  Arguments:  [fExist]    -- TRUE if file should exist, else FALSE
//              [iteration] -- iteration number
//
//  History:    22-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

void VerifyDisk(BOOL fExist, LONG iteration)
{
    if (_access("c:\\testfail.dfl", 0) == 0)
    {
        if (!fExist)
        {
            printf("..Iteration %ld, file still exists\n", iteration);
        }
    }
    else
    {
        if (fExist)
        {
            printf("..Iteration %ld, file doesn't exist\n", iteration);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   VerifyMemory
//
//  Arguments:  [iteration] -- iteration number
//
//  Requires:   Caller should expect 0 memory to be allocated
//
//  History:    22-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

void VerifyMemory(LONG iteration)
{
    if (DfGetMemAlloced() > 0L)
    {
        printf("..Iteration %ld - memory allocated\n", iteration);
        DfPrintAllocs();
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   VerifyClean
//
//  Synopsis:   checks disk, memory
//
//  Arguments:  [sc]        -- status code
//              [dwMode]    -- Docfile mode
//              [iteration] -- iteration
//
//  History:    22-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

void VerifyClean(SCODE sc, DWORD dwMode, LONG iteration)
{
    VerifyDisk(SUCCEEDED(sc) &&
               !(dwMode & STGM_DELETEONRELEASE), iteration);
    VerifyMemory(iteration);
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateWorkingDocfile
//
//  Synopsis:   create and verify the test Docfile
//
//  Arguments:  [dwMode]    -- Docfile creation mode
//              [ppstg]     -- placeholder for IStorage
//              [iteration] -- iteration number
//
//  Returns:    SCODE
//
//  Modifies:   ppstg
//
//  History:    22-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

SCODE CreateWorkingDocfile(DWORD dwMode, IStorage **ppstg, LONG iteration)
{
    SCODE sc;

    //  Make sample call
    remove("c:\\testfail.dfl");
    sc = DfGetScode(StgCreateDocfile(
            "c:\\testfail.dfl",
            dwMode,
            0,
            ppstg));

    if (FAILED(sc))
    {
        if (iteration == 0)
        {
            //  This was a prep call.  Prep calls aren't supposed to fail
            if (sc == STG_E_INVALIDFLAG)
            {
                //  Probably a bad combination of mode flags
                printf("..Iteration %ld, sc = STG_E_INVALIDFLAG (OK)\n",
                       iteration);
            }
            else if (FAILED(sc))
            {
                //  Something unexpected
                printf("..Iteration %ld failed - sc = 0x%lX\n",
                       iteration, sc);
            }
        }
        else    //  iteration != 0
        {
            if (sc == STG_E_INSUFFICIENTMEMORY || sc == STG_E_MEDIUMFULL)
            {
                //  we expected these failures;  do nothing
                ;
            }
            else
            {
                printf("..Iteration %ld failed - sc = 0x%lX (??)\n",
                       iteration, sc);
            }
        }
    }

    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestStgCreate
//
//  Purpose:    Test StgCreateDocfile
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestStgCreate : public CTestCase
{
private:
    SCODE _sc;
    CModeDf _mdf;
    IStorage *_pstg;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestStgCreate::Init(void)
{
    printf("SIFT StgCreateDocfile\n");
    _mdf.Init();
    return(TRUE);
}

SCODE CTestStgCreate::Prep(LONG iteration)
{
    //  inherit this?
    return(NOERROR);
}

SCODE CTestStgCreate::Call(LONG iteration)
{
    if (iteration == 0)
        printf("Docfile Mode 0x%lX\n", _mdf.GetMode());

    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, iteration);

    return(_sc);
}

void CTestStgCreate::EndCall(LONG iteration)
{
    _pstg->Release();
}

void CTestStgCreate::CallVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

void CTestStgCreate::EndPrep(LONG iteration)
{
    //  inherit this?
}

void CTestStgCreate::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestStgCreate::Next(void)
{
    if (!_mdf.Next())
        return FALSE;

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestCreateStorage
//
//  Purpose:    Test IStorage::CreateStorage
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestCreateStorage : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStg _mstg;
    IStorage *_pstgChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCreateStorage::Init(void)
{
    printf("SIFT IStorage::CreateStorage\n");
    _mdf.Init();
    _mstg.Init();
    return(TRUE);
}

SCODE CTestCreateStorage::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    return(_sc);
}

SCODE CTestCreateStorage::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Child Storage Mode 0x%lX\n",
               _mdf.GetMode(), _mstg.GetMode());

    sc = DfGetScode(_pstg->CreateStorage(
            "TestFail Storage",
            _mstg.GetMode(),
            0,
            0,
            &_pstgChild));

    return(sc);
}

void CTestCreateStorage::EndCall(LONG iteration)
{
    _pstgChild->Release();
}

void CTestCreateStorage::CallVerify(LONG iteration)
{
}

void CTestCreateStorage::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestCreateStorage::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestCreateStorage::Next(void)
{
    if (!_mstg.Next())
    {
        _mstg.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestCreateStream
//
//  Purpose:    Test IStorage::CreateStream
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestCreateStream : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCreateStream::Init(void)
{
    printf("SIFT IStorage::CreateStream\n");
    _mdf.Init();
    _mstm.Init();
    return(TRUE);
}

SCODE CTestCreateStream::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    return(_sc);
}

SCODE CTestCreateStream::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Child Stream Mode 0x%lX\n",
               _mdf.GetMode(), _mstm.GetMode());

    sc = DfGetScode(_pstg->CreateStream(
        "TestFail Stream",
        _mstm.GetMode(),
        0,
        0,
        &_pstmChild));

    return(sc);
}

void CTestCreateStream::EndCall(LONG iteration)
{
    _pstmChild->Release();
}

void CTestCreateStream::CallVerify(LONG iteration)
{
}

void CTestCreateStream::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestCreateStream::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestCreateStream::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestWrite
//
//  Purpose:    Test IStream::Write
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestWrite : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestWrite::Init(void)
{
    printf("SIFT IStream::Write\n");
    _mdf.Init();
    _mstm.Init();
    return(TRUE);
}

SCODE CTestWrite::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                _mstm.GetMode(),
                0,
                0,
                &_pstmChild));

        if (FAILED(_sc))
            _pstg->Release();
    }
    return(_sc);
}

SCODE CTestWrite::Call(LONG iteration)
{
    SCODE sc;
    ULONG cb = 1;
    char c = 'X';
    ULONG cbWritten;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Stream Mode 0x%lX, Write %ld bytes\n",
               _mdf.GetMode(), _mstm.GetMode(), cb);

    sc = DfGetScode(_pstmChild->Write(&c, cb, &cbWritten));

    if (FAILED(sc))
    {
        if (sc != STG_E_MEDIUMFULL)
            printf("..Iteration %ld - failed - sc = 0x%lX\n",
                   iteration, sc);
    }
    return(sc);
}

void CTestWrite::EndCall(LONG iteration)
{
}

void CTestWrite::CallVerify(LONG iteration)
{
}

void CTestWrite::EndPrep(LONG iteration)
{
    _pstmChild->Release();
    _pstg->Release();
}

void CTestWrite::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestWrite::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestOpenStream
//
//  Purpose:    Test IStorage::OpenStream
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestOpenStream : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstm;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestOpenStream::Init(void)
{
    printf("SIFT IStorage::OpenStream\n");
    _mdf.Init();
    _mstm.Init();
    return(TRUE);
}

SCODE CTestOpenStream::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                _mstm.GetMode(),
                0,
                0,
                &_pstm));

        if (FAILED(_sc))
            _pstg->Release();
        else
            _pstm->Release();
    }
    return(_sc);
}

SCODE CTestOpenStream::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Stream Mode 0x%lX\n",
               _mdf.GetMode(), _mstm.GetMode());

    sc = DfGetScode(_pstg->OpenStream(
            "TestFail Stream",
            0,
            _mstm.GetMode(),
            0,
            &_pstm));

    return(sc);
}

void CTestOpenStream::EndCall(LONG iteration)
{
    _pstm->Release();
}

void CTestOpenStream::CallVerify(LONG iteration)
{
}

void CTestOpenStream::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestOpenStream::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestOpenStream::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestOpenStorage
//
//  Purpose:    Test IStorage::OpenStorage
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestOpenStorage : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStg _mstg;
    IStorage *_pstgChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestOpenStorage::Init(void)
{
    printf("SIFT IStorage::OpenStorage\n");
    _mdf.Init();
    _mstg.Init();
    return(TRUE);
}

SCODE CTestOpenStorage::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStorage(
                "TestFail Storage",
                _mstg.GetMode(),
                0,
                0,
                &_pstgChild));

        if (FAILED(_sc))
            _pstg->Release();
        else
            _pstgChild->Release();
    }
    return(_sc);
}

SCODE CTestOpenStorage::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Storage Mode 0x%lX\n",
               _mdf.GetMode(), _mstg.GetMode());

    sc = DfGetScode(_pstg->OpenStorage("TestFail Storage", 0,
            _mstg.GetMode(), 0, 0, &_pstgChild));

    return(sc);
}

void CTestOpenStorage::EndCall(LONG iteration)
{
    _pstgChild->Release();
}

void CTestOpenStorage::CallVerify(LONG iteration)
{
}

void CTestOpenStorage::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestOpenStorage::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestOpenStorage::Next(void)
{
    if (!_mstg.Next())
    {
        _mstg.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestCommit
//
//  Purpose:    Test IStream::Write
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestCommit : public CTestCase
{
private:
    CModeDf _mdf;
    IStorage *_pstg;

    CModeStg _mstg;
    IStorage *_pstgChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCommit::Init(void)
{
    printf("SIFT IStorage::Commit\n");
    _mdf.Init();
    _mstg.Init();
    return(TRUE);
}

SCODE CTestCommit::Prep(LONG iteration)
{
    SCODE sc;

    sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(sc))
    {
        sc = DfGetScode(_pstg->CreateStorage(
                "TestFail Storage",
                _mstg.GetMode(),
                0,
                0,
                &_pstgChild));

        if (FAILED(sc))
            _pstg->Release();
    }
    return(sc);
}

SCODE CTestCommit::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Storage Mode 0x%lX\n",
               _mdf.GetMode(), _mstg.GetMode());

    sc = DfGetScode(_pstgChild->Commit(0));

    if (FAILED(sc))
    {
        if (sc != STG_E_MEDIUMFULL)
            printf("..Iteration %ld - STG_E_MEDIUMFULL\n", iteration);
        else
            printf("..Iteration %ld - failed - sc = 0x%lX\n",
                   iteration, sc);
    }
    return(sc);
}

void CTestCommit::EndCall(LONG iteration)
{
}

void CTestCommit::CallVerify(LONG iteration)
{
}

void CTestCommit::EndPrep(LONG iteration)
{
    _pstgChild->Release();
    _pstg->Release();
}

void CTestCommit::EndVerify(LONG iteration)
{
    VerifyClean(S_OK, _mdf.GetMode(), iteration);
}

BOOL CTestCommit::Next(void)
{
    if (!_mstg.Next())
    {
        _mstg.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestCommit2
//
//  Purpose:    Test IStorage::Commit
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestCommit2 : public CTestCase
{
private:
    CModeDf _mdf;
    IStorage *_pstg;

    CModeStg _mstg;
    IStorage *_pstgChild;

    IStream *_pstmChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCommit2::Init(void)
{
    printf("SIFT IStorage::Commit\n");
    _mdf.Init();
    _mstg.Init();
    return(TRUE);
}

SCODE CTestCommit2::Prep(LONG iteration)
{
    SCODE sc;
    ULONG cb = 1;
    char c = 'X';
    ULONG cbWritten;

    sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(sc))
    {
        sc = DfGetScode(_pstg->CreateStorage(
                "TestFail Storage",
                _mstg.GetMode(),
                0,
                0,
                &_pstgChild));

        if (FAILED(sc))
            _pstg->Release();
        else
        {
            sc = DfGetScode(_pstgChild->CreateStream(
                    "TestFail Stream",
                    STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                    0,
                    0,
                    &_pstmChild));

            if (FAILED(sc))
            {
                _pstgChild->Release();
                _pstg->Release();
            }
            else
            {
                sc = DfGetScode(_pstmChild->Write(&c, cb, &cbWritten));
                if (FAILED(sc))
                {
                    _pstmChild->Release();
                    _pstgChild->Release();
                    _pstg->Release();
                }
            }
        }
    }
    return(sc);
}

SCODE CTestCommit2::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Storage Mode 0x%lX\n",
               _mdf.GetMode(), _mstg.GetMode());

    sc = DfGetScode(_pstgChild->Commit(0));

    if (FAILED(sc))
    {
        if (sc == STG_E_MEDIUMFULL)
            printf("..Iteration %ld - STG_E_MEDIUMFULL\n", iteration);
        else
            printf("..Iteration %ld - failed - sc = 0x%lX\n",
                   iteration, sc);
    }
    return(sc);
}

void CTestCommit2::EndCall(LONG iteration)
{
}

void CTestCommit2::CallVerify(LONG iteration)
{
}

void CTestCommit2::EndPrep(LONG iteration)
{
    _pstmChild->Release();
    _pstgChild->Release();
    _pstg->Release();
}

void CTestCommit2::EndVerify(LONG iteration)
{
    VerifyClean(S_OK, _mdf.GetMode(), iteration);
}

BOOL CTestCommit2::Next(void)
{
    if (!_mstg.Next())
    {
        _mstg.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestCommit3
//
//  Purpose:    Test IStorage::Commit
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestCommit3 : public CTestCase
{
private:
    CModeDf _mdf;
    IStorage *_pstg;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCommit3::Init(void)
{
    printf("SIFT IStorage::Commit\n");
    _mdf.Init();
    return(TRUE);
}

SCODE CTestCommit3::Prep(LONG iteration)
{
    SCODE sc;
    ULONG cb = 1;
    char c = 'X';

    sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);

    if (FAILED(sc))
        return(sc);

    IStream *pstm;
    sc = DfGetScode(_pstg->CreateStream(
                "PP40",
                STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                0,
                0,
                &pstm));
    pstm->Release();

    IStorage *pstgChild;
    sc = DfGetScode(_pstg->CreateStorage(
                "TestFail Storage",
                STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                0,
                0,
                &pstgChild));

    sc = DfGetScode(pstgChild->CreateStream(
                "One",
                STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                0,
                0,
                &pstm));
    pstm->Release();
    sc = DfGetScode(pstgChild->CreateStream(
                "Two",
                STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                0,
                0,
                &pstm));
    pstm->Release();
    sc = DfGetScode(pstgChild->CreateStream(
                "Three",
                STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                0,
                0,
                &pstm));
    pstm->Release();

    sc = DfGetScode(pstgChild->Commit(0));
    pstgChild->Release();

    return(sc);
}

SCODE CTestCommit3::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX\n",
               _mdf.GetMode());

    sc = DfGetScode(_pstg->Commit(0));

    if (FAILED(sc))
    {
        if (sc == STG_E_MEDIUMFULL)
            printf("..Iteration %ld - STG_E_MEDIUMFULL\n", iteration);
        else
            printf("..Iteration %ld - failed - sc = 0x%lX\n",
                   iteration, sc);
    }
    return(sc);
}

void CTestCommit3::EndCall(LONG iteration)
{
}

void CTestCommit3::CallVerify(LONG iteration)
{
}

void CTestCommit3::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestCommit3::EndVerify(LONG iteration)
{
    VerifyClean(S_OK, _mdf.GetMode(), iteration);
}

BOOL CTestCommit3::Next(void)
{
    if (!_mdf.Next())
        return(FALSE);

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestCommit4
//
//  Purpose:    Test IStorage::Commit with resized streams
//
//  Interface:  CTestCase
//
//  History:    08-Sep-93 DrewB     Created
//
//--------------------------------------------------------------------------

class CTestCommit4 : public CTestCase
{
private:
    CModeDf _mdf;
    IStorage *_pstg;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCommit4::Init(void)
{
    printf("SIFT IStorage::Commit\n");
    _mdf.Init();
    return(TRUE);
}

#define LARGE_SIZE 4097
#define SMALL_SIZE 4095

SCODE CTestCommit4::Prep(LONG iteration)
{
    SCODE sc;
    IStream *pstm;
    ULARGE_INTEGER uli;

    sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (FAILED(sc))
        goto EH_Err;
    sc = DfGetScode(_pstg->CreateStream("Test",
                                        STGM_DIRECT | STGM_SHARE_EXCLUSIVE |
                                        STGM_READWRITE, 0, 0, &pstm));
    if (FAILED(sc))
        goto EH_pstg;
    uli.HighPart = 0;
    uli.LowPart = LARGE_SIZE;
    sc = DfGetScode(pstm->SetSize(uli));
    if (FAILED(sc))
        goto EH_pstm;
    sc = DfGetScode(_pstg->Commit(0));
    if (FAILED(sc))
        goto EH_pstm;
    uli.LowPart = SMALL_SIZE;
    sc = DfGetScode(pstm->SetSize(uli));
    if (FAILED(sc))
        goto EH_pstm;
    pstm->Release();
    return sc;

 EH_pstm:
    pstm->Release();
 EH_pstg:
    _pstg->Release();
 EH_Err:
    return sc;
}

SCODE CTestCommit4::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX\n",
               _mdf.GetMode());

    sc = DfGetScode(_pstg->Commit(0));

    if (FAILED(sc))
    {
        if (sc == STG_E_MEDIUMFULL)
            printf("..Iteration %ld - STG_E_MEDIUMFULL\n", iteration);
        else
            printf("..Iteration %ld - failed - sc = 0x%lX\n",
                   iteration, sc);
    }
    return(sc);
}

void CTestCommit4::EndCall(LONG iteration)
{
}

void CTestCommit4::CallVerify(LONG iteration)
{
    IStream *pstm;
    SCODE sc;
    STATSTG stat;

    sc = DfGetScode(_pstg->OpenStream("Test", NULL, STGM_DIRECT |
                                      STGM_SHARE_EXCLUSIVE, 0, &pstm));
    if (FAILED(sc))
    {
        printf("Can't open stream - %lX\n", sc);
        return;
    }
    sc = DfGetScode(pstm->Stat(&stat, STATFLAG_NONAME));
    pstm->Release();
    if (FAILED(sc))
    {
        printf("Can't stat stream - %lX\n", sc);
        return;
    }
    if (stat.cbSize.LowPart != SMALL_SIZE)
    {
        printf("Stream length is %lu rather than %d\n",
               stat.cbSize.LowPart, SMALL_SIZE);
        return;
    }
}

void CTestCommit4::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestCommit4::EndVerify(LONG iteration)
{
    VerifyClean(S_OK, _mdf.GetMode(), iteration);
}

BOOL CTestCommit4::Next(void)
{
    if (!_mdf.Next())
        return(FALSE);

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestStgOpen
//
//  Purpose:    Test StgOpenStorage
//
//  Interface:  CTestCase
//
//  History:    28-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestStgOpen : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestStgOpen::Init(void)
{
    printf("SIFT StgOpenStorage\n");
    _mdf.Init();
    return(TRUE);
}

SCODE CTestStgOpen::Prep(LONG iteration)
{
    SCODE sc;
    DWORD dwMode = STGM_DIRECT          |
                   STGM_READWRITE       |
                   STGM_SHARE_EXCLUSIVE |
                   STGM_FAILIFTHERE;
    IStorage *pstg, *pstgChild;
    IStream *pstmChild;

    sc = CreateWorkingDocfile(dwMode, &pstg, 0);
    if (SUCCEEDED(sc))
    {
        sc = DfGetScode(pstg->CreateStorage(
                "TestFail Storage",
                dwMode,
                0,
                0,
                &pstgChild));

        if (SUCCEEDED(sc))
        {
            sc = DfGetScode(pstgChild->CreateStream(
                    "TestFail Stream",
                    dwMode,
                    0,
                    0,
                    &pstmChild));

            if (SUCCEEDED(sc))
                pstmChild->Release();

            pstgChild->Release();
        }

        pstg->Release();
    }
    return(sc);
}

SCODE CTestStgOpen::Call(LONG iteration)
{
    if (iteration == 0)
        printf("Docfile Mode 0x%lX\n", _mdf.GetMode());

    _sc = DfGetScode(StgOpenStorage("c:\\testfail.dfl",
             NULL,
             _mdf.GetMode(),
             NULL,
             0,
            &_pstg));

    if (FAILED(_sc))
    {
        if (iteration == 0 && _sc == STG_E_INVALIDFLAG)
        {
            printf("..STG_E_INVALIDFLAG\n");
            //  Must have been a bad combination of flags - we
            //  ignore these for now.
        }
        else if (iteration > 0 && _sc == STG_E_INSUFFICIENTMEMORY)
        {
            //  Do nothing (expected failure)
        }
        else if (iteration > 0 && _sc == STG_E_MEDIUMFULL)
        {
            //  Do nothing (expected failure)
        }
        else
            printf("..Iteration %ld, call failed - sc = 0x%lX\n",
                   iteration, _sc);
    }
    return(_sc);
}

void CTestStgOpen::EndCall(LONG iteration)
{
    _pstg->Release();
}

void CTestStgOpen::CallVerify(LONG iteration)
{
}

void CTestStgOpen::EndPrep(LONG iteration)
{
}

void CTestStgOpen::EndVerify(LONG iteration)
{
    //  If the call failed, the file should still exist.
    //  If the call succeeded
    //    If mode was delete on release,
    //       file should not exist
    //    else file should exist

    VerifyDisk((SUCCEEDED(_sc) && (!(_mdf.GetMode() & STGM_DELETEONRELEASE))) ||
               FAILED(_sc), iteration);
    VerifyMemory(iteration);
}

BOOL CTestStgOpen::Next(void)
{
    if (!_mdf.Next())
         return(FALSE);

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Class:      CTestWrite2
//
//  Purpose:    Test IStream::Write for largish writes
//
//  Interface:  CTestCase
//
//  History:    16-Feb-93       PhilipLa        Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestWrite2 : public CTestCase
{
private:
    SCODE _sc;

    BYTE *_pb;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

    ULONG _cb;
    ULONG _cBlock;

    ULONG _cbSize;
public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestWrite2::Init(void)
{
    printf("SIFT IStream::Write2 - large writes without Setsize\n");
    _mdf.Init();
    _mstm.Init();

    _cb = 8192;
    _cBlock = 8;

    _pb = NULL;
    return(TRUE);
}

SCODE CTestWrite2::Prep(LONG iteration)
{

    _pb = new BYTE[8192];
    memset(_pb, 'X', 8192);

    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                _mstm.GetMode(),
                0,
                0,
                &_pstmChild));

        _cbSize = 0;
        if (FAILED(_sc))
            _pstg->Release();

    }
    return(_sc);
}

SCODE CTestWrite2::Call(LONG iteration)
{
    SCODE sc;
    ULONG cbWritten;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Stream Mode 0x%lX, Write %ld bytes\n",
               _mdf.GetMode(), _mstm.GetMode(), _cb * _cBlock);

    for (ULONG i = 0; i < _cBlock; i++)
    {
        sc = DfGetScode(_pstmChild->Write(_pb, _cb, &cbWritten));
        _cbSize += cbWritten;

        if (FAILED(sc))
        {
            if (sc != STG_E_MEDIUMFULL)
                printf("..Iteration %ld, block %lu - failed - sc = 0x%lX\n",
                       iteration, i + 1, sc);
            break;
        }
    }
    return(sc);
}

void CTestWrite2::EndCall(LONG iteration)
{
    STATSTG stat;

    _pstmChild->Stat(&stat, STATFLAG_NONAME);

    if (ULIGetLow(stat.cbSize) != _cbSize)
    {
        printf("..Iteration %lu - Size of stream is %lu.  Expected %lu\n",
               iteration, ULIGetLow(stat.cbSize), _cbSize);
    }
}

void CTestWrite2::CallVerify(LONG iteration)
{
    STATSTG stat;

    _pstmChild->Stat(&stat, STATFLAG_NONAME);

    if (ULIGetLow(stat.cbSize) != _cbSize)
    {
        printf("..Iteration %lu - Size of stream is %lu.  Expected %lu\n",
               iteration, ULIGetLow(stat.cbSize), _cbSize);
    }

}

void CTestWrite2::EndPrep(LONG iteration)
{
    delete _pb;
    _pb = NULL;

    _pstmChild->Release();
    _pstg->Release();
}

void CTestWrite2::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestWrite2::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Class:      CTestWrite3
//
//  Purpose:    Test IStream::Write for largish writes
//
//  Interface:  CTestCase
//
//  History:    16-Feb-93       PhilipLa        Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestWrite3 : public CTestCase
{
private:
    SCODE _sc;

    BYTE *_pb;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

    ULONG _cb;
    ULONG _cBlock;
public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestWrite3::Init(void)
{
    printf("SIFT IStream::Write3 - large writes with prior Setsize\n");
    _mdf.Init();
    _mstm.Init();

    _cb = 8192;
    _cBlock = 8;

    _pb = NULL;
    return(TRUE);
}

SCODE CTestWrite3::Prep(LONG iteration)
{

    _pb = new BYTE[8192];
    memset(_pb, 'X', 8192);

    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                _mstm.GetMode(),
                0,
                0,
                &_pstmChild));

        if (FAILED(_sc))
            _pstg->Release();
        else
        {
            ULARGE_INTEGER cbSize;

            ULISet32(cbSize, _cb * _cBlock);

            _sc = DfGetScode(_pstmChild->SetSize(cbSize));

            if (FAILED(_sc))
            {
                _pstmChild->Release();
                _pstg->Release();
            }
        }
    }
    return(_sc);
}

SCODE CTestWrite3::Call(LONG iteration)
{
    SCODE sc;
    ULONG cbWritten;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Stream Mode 0x%lX, Write %ld bytes\n",
               _mdf.GetMode(), _mstm.GetMode(), _cb * _cBlock);
    else
        printf("ERROR - shouldn't hit iteration %lu\n", iteration);

    for (ULONG i = 0; i < _cBlock; i++)
    {
        sc = DfGetScode(_pstmChild->Write(_pb, _cb, &cbWritten));
        if (FAILED(sc))
        {
            if (sc != STG_E_MEDIUMFULL)
                printf("..Iteration %ld, block %lu - failed - sc = 0x%lX\n",
                       iteration, i + 1, sc);
            break;
        }
    }
    return(sc);
}

void CTestWrite3::EndCall(LONG iteration)
{
}

void CTestWrite3::CallVerify(LONG iteration)
{
}

void CTestWrite3::EndPrep(LONG iteration)
{
    delete _pb;
    _pb = NULL;

    _pstmChild->Release();
    _pstg->Release();
}

void CTestWrite3::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestWrite3::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Class:      CTestSetsize
//
//  Purpose:    Test IStream::Write for largish writes
//
//  Interface:  CTestCase
//
//  History:    16-Feb-93       PhilipLa        Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestSetsize : public CTestCase
{
private:
    SCODE _sc;

    BYTE *_pb;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

    ULONG _cb;
    ULONG _cBlock;
public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestSetsize::Init(void)
{
    printf("SIFT IStream::Setsize\n");
    _mdf.Init();
    _mstm.Init();

    _cb = 8192;
    _cBlock = 9;

    _pb = NULL;
    return(TRUE);
}

SCODE CTestSetsize::Prep(LONG iteration)
{

    _pb = new BYTE[8192];
    memset(_pb, 'X', 8192);

    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                _mstm.GetMode(),
                0,
                0,
                &_pstmChild));

        if (FAILED(_sc))
            _pstg->Release();
    }
    return(_sc);
}

SCODE CTestSetsize::Call(LONG iteration)
{
    SCODE sc;
    ULONG cbWritten;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Stream Mode 0x%lX, Write %ld bytes\n",
               _mdf.GetMode(), _mstm.GetMode(), _cb * _cBlock);

    ULARGE_INTEGER cbSize;

    ULISet32(cbSize, _cb * _cBlock);

    sc = DfGetScode(_pstmChild->SetSize(cbSize));


    if (FAILED(sc))
    {
        if (sc != STG_E_MEDIUMFULL)
            printf("..Iteration %ld - failed - sc = 0x%lX\n", iteration, sc);
    }
    else
    {
        for (ULONG i = 0; i < _cBlock; i++)
        {
            sc = DfGetScode(_pstmChild->Write(_pb, _cb, &cbWritten));
            if (FAILED(sc))
            {
                printf("..Iteration %ld, Write %lu failed - sc == 0x%lX\n",
                       iteration, i + 1, sc);
                break;
            }
        }
    }
    return(sc);
}

void CTestSetsize::EndCall(LONG iteration)
{
    STATSTG stat;

    _pstmChild->Stat(&stat, STATFLAG_NONAME);

    if (ULIGetLow(stat.cbSize) != _cb * _cBlock)
    {
        printf("..Iteration %lu - Size of stream is %lu, expected %lu\n",
               iteration, ULIGetLow(stat.cbSize), _cb * _cBlock);
    }

}

void CTestSetsize::CallVerify(LONG iteration)
{
    STATSTG stat;

    _pstmChild->Stat(&stat, STATFLAG_NONAME);

    if (ULIGetLow(stat.cbSize) != 0)
    {
        printf("..Iteration %lu - Size of stream is %lu, expected 0\n",
               iteration, ULIGetLow(stat.cbSize));
    }
}

void CTestSetsize::EndPrep(LONG iteration)
{
    delete _pb;
    _pb = NULL;

    _pstmChild->Release();
    _pstg->Release();
}

void CTestSetsize::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestSetsize::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Class:      CTestCreateStream2
//
//  Purpose:    Test IStorage::CreateStream2
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestCreateStream2 : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCreateStream2::Init(void)
{
    printf("SIFT IStorage::CreateStream2\n");
    _mdf.Init();
    _mstm.Init();
    return(TRUE);
}

SCODE CTestCreateStream2::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    return(_sc);
}

SCODE CTestCreateStream2::Call(LONG iteration)
{
    SCODE sc;
    ULONG cStream = 8;

    char * pszName = "XTestFail Stream";
    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Child Stream Mode 0x%lX\n",
               _mdf.GetMode(), _mstm.GetMode());

    for (ULONG i = 0; i < cStream; i++)
    {
        pszName[0] = ((char)i) + '0';

        sc = DfGetScode(_pstg->CreateStream(
                pszName,
                _mstm.GetMode(),
                0,
                0,
                &_pstmChild));

        if (FAILED(sc))
        {
            if ((sc == STG_E_MEDIUMFULL) || (sc == STG_E_INSUFFICIENTMEMORY))
            {
                //Do nothing. We expected these.
            }
            else printf("..Iteration %ld, stream %lu - failed - sc = 0x%lX\n",
                    iteration, i + 1, sc);
            break;
        }
        _pstmChild->Release();
    }

    return(sc);
}

void CTestCreateStream2::EndCall(LONG iteration)
{
}

void CTestCreateStream2::CallVerify(LONG iteration)
{
}

void CTestCreateStream2::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestCreateStream2::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestCreateStream2::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestDestroyElement
//
//  Purpose:    Test IStorage::DestroyElement
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestDestroyElement : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStg _mstg;
    IStorage *_pstgChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestDestroyElement::Init(void)
{
    printf("SIFT IStorage::DestroyElement\n");
    _mdf.Init();
    _mstg.Init();
    return(TRUE);
}

SCODE CTestDestroyElement::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStorage(
                "TestFail Storage",
                _mstg.GetMode(),
                0,
                0,
                &_pstgChild));

        _pstgChild->Release();
    }


    return(_sc);
}

SCODE CTestDestroyElement::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Child Storage Mode 0x%lX\n",
               _mdf.GetMode(), _mstg.GetMode());

    sc = DfGetScode(_pstg->DestroyElement("TestFail Storage"));

    if (FAILED(sc))
    {
        if ((sc == STG_E_MEDIUMFULL) || (sc == STG_E_INSUFFICIENTMEMORY))
        {
            //We expected these - do nothing.
        }
        else
            printf("..Iteration %ld - failed - sc = 0x%lX\n",
                   iteration, sc);
    }

    return(sc);
}

void CTestDestroyElement::EndCall(LONG iteration)
{
    SCODE sc;

    sc = DfGetScode(_pstg->OpenStorage(
            "TestFail Storage",
            0,
            _mstg.GetMode(),
            0,
            0,
            &_pstgChild));

    if (sc != STG_E_FILENOTFOUND)
    {
        printf("..Iteration %ld - open failed with 0x%lX, expected STG_E_FILENOTFOUND\n",
               iteration,
               sc);
    }

    if (SUCCEEDED(sc))
    {
        _pstgChild->Release();
    }
}

void CTestDestroyElement::CallVerify(LONG iteration)
{
    SCODE sc;

    sc = DfGetScode(_pstg->OpenStorage(
            "TestFail Storage",
            0,
            _mstg.GetMode(),
            0,
            0,
            &_pstgChild));

    if (FAILED(sc))
    {
        printf("..Iteration %ld - open failed with 0x%lX, expected success.\n",
               iteration,
               sc);
    }
    else
    {
        _pstgChild->Release();
    }

}

void CTestDestroyElement::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestDestroyElement::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestDestroyElement::Next(void)
{
    if (!_mstg.Next())
    {
        _mstg.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Class:      CTestSetsize2
//
//  Purpose:    Test IStream::Write for largish writes
//
//  Interface:  CTestCase
//
//  History:    16-Feb-93       PhilipLa        Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestSetsize2 : public CTestCase
{
private:
    SCODE _sc;

    BYTE *_pb;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

    ULONG _cb;
    ULONG _cBlock;
public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestSetsize2::Init(void)
{
    printf("SIFT IStream::Setsize2\n");
    _mdf.Init();
    _mstm.Init();

    _cb = 8192;
    _cBlock = 9;

    _pb = NULL;
    return(TRUE);
}

SCODE CTestSetsize2::Prep(LONG iteration)
{

    _pb = new BYTE[8192];
    memset(_pb, 'X', 8192);

    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                _mstm.GetMode(),
                0,
                0,
                &_pstmChild));

        if (FAILED(_sc))
            _pstg->Release();
        else
        {
            ULARGE_INTEGER ulSize;
            ULISet32(ulSize, _cb * _cBlock);

            _sc = DfGetScode(_pstmChild->SetSize(ulSize));
            if (FAILED(_sc))
                printf("Setsize failed in Prep()\n");
            else
            {
                for (ULONG i = 0; i < _cBlock; i++)
                {
                    ULONG cbWritten;

                    _sc = DfGetScode(_pstmChild->Write(_pb, _cb, &cbWritten));
                    if (FAILED(_sc))
                        break;
                }
            }
        }
    }
    return(_sc);
}

SCODE CTestSetsize2::Call(LONG iteration)
{
    SCODE sc;

    ULARGE_INTEGER ulSize;
    ULISet32(ulSize, 2048L);

    sc = DfGetScode(_pstmChild->SetSize(ulSize));

    return(sc);
}

void CTestSetsize2::EndCall(LONG iteration)
{

    STATSTG stat;

    _pstmChild->Stat(&stat, STATFLAG_NONAME);

    if (ULIGetLow(stat.cbSize) != 2048L)
    {
        printf("..Iteration %lu - Size of stream is %lu, expected %lu\n",
               iteration, ULIGetLow(stat.cbSize), 2048L);
    }

    LARGE_INTEGER newPos;
    ULISet32(newPos, 0);
    ULARGE_INTEGER dummy;

    _pstmChild->Seek(newPos, STREAM_SEEK_SET, &dummy);
    ULONG cbRead;

    _pstmChild->Read(_pb, 2048, &cbRead);
    if (cbRead != 2048)
    {
        printf("Unknown error - read %lu bytes, expected 2048\n");
    }
    else
    {
        for (ULONG i = 0; i < 2048; i ++)
        {
            if (_pb[i] != 'X')
            {
                printf("Error in buffer data.\n");
                break;
            }
        }
    }

}


void CTestSetsize2::CallVerify(LONG iteration)
{

    STATSTG stat;

    _pstmChild->Stat(&stat, STATFLAG_NONAME);

    if (ULIGetLow(stat.cbSize) != _cb * _cBlock)
    {
        printf("..Iteration %lu - Size of stream is %lu, expected %lu\n",
               iteration, ULIGetLow(stat.cbSize), _cb * _cBlock);
    }
    else
    {
        LARGE_INTEGER newPos;
        ULISet32(newPos, 0);
        ULARGE_INTEGER dummy;

        _pstmChild->Seek(newPos, STREAM_SEEK_SET, &dummy);

        for (ULONG i = 0; i < _cBlock; i++)
        {
            ULONG cbRead;

            _sc = DfGetScode(_pstmChild->Read(_pb, _cb, &cbRead));
            if (FAILED(_sc))
            {
                printf("Read failed with %lX\n", _sc);
                break;
            }
            if (cbRead != _cb)
            {
                printf("Read %lu bytes, expected %lu\n",cbRead,_cb);
                break;
            }
            for (ULONG j = 0; j < _cb; j++)
            {
                if (_pb[j] != 'X')
                {
                    printf("Data mismatch at byte %lu, block %lu\n",j,i);
                    break;
                }
            }
        }
    }
}

void CTestSetsize2::EndPrep(LONG iteration)
{
    delete _pb;
    _pb = NULL;

    _pstmChild->Release();
    _pstg->Release();
}

void CTestSetsize2::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestSetsize2::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Class:      CTestSwitchToFile
//
//  Purpose:    Test SwitchToFile
//
//  Interface:  CTestCase
//
//  History:    18-Jun-93       PhilipLa        Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestSwitchToFile : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestSwitchToFile::Init(void)
{
    printf("SIFT IStream::SwitchToFile\n");
    _mdf.Init();
    return(TRUE);
}

SCODE CTestSwitchToFile::Prep(LONG iteration)
{
    IStream *pstm;
    _unlink("c:\\tmp\\stf.dfl");

    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                STGM_DIRECT|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pstm));

        if (FAILED(_sc))
            _pstg->Release();
        else
        {
            ULARGE_INTEGER ul;

            ULISet32(ul, 80000);

            _sc = DfGetScode(pstm->SetSize(ul));
            pstm->Release();

            if (FAILED(_sc))
            {
                _pstg->Release();
            }
        }
    }
    return(_sc);
}

SCODE CTestSwitchToFile::Call(LONG iteration)
{
    SCODE sc;
    IRootStorage *pstgRoot;

    sc = DfGetScode(_pstg->QueryInterface(
            IID_IRootStorage,
            (void **)&pstgRoot));

    if (FAILED(sc))
        return sc;

    sc = DfGetScode(pstgRoot->SwitchToFile("c:\\tmp\\stf.dfl"));

    pstgRoot->Release();

    if (FAILED(sc))
        return sc;


    sc = DfGetScode(_pstg->Commit(STGC_OVERWRITE));

    if (FAILED(sc))
    {
        printf("... Commit with overwrite failed.\n");
    }
    else
    {
        printf("... Commit succeeded.\n");
    }

    return(sc);
}

void CTestSwitchToFile::EndCall(LONG iteration)
{
}


void CTestSwitchToFile::CallVerify(LONG iteration)
{
}

void CTestSwitchToFile::EndPrep(LONG iteration)
{
    _pstg->Release();
    _unlink("c:\\tmp\\stf.dfl");
}

void CTestSwitchToFile::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestSwitchToFile::Next(void)
{
    do
    {
        if (!_mdf.Next())
            return FALSE;
    }
    while (((_mdf.GetMode() & 0x70) == STGM_SHARE_DENY_READ) ||
           (_mdf.GetMode() & 0x70) == STGM_SHARE_DENY_NONE);

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Function:   TestCount, TestItem
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Returns:
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CTestStgCreate      tstStgCreate;
CTestCreateStorage  tstCreateStorage;
CTestCreateStream   tstCreateStream;
CTestWrite          tstWrite;
CTestOpenStorage    tstOpenStorage;
CTestOpenStream     tstOpenStream;
CTestCommit         tstCommit;
CTestCommit2        tstCommit2;
CTestStgOpen        tstStgOpen;
CTestWrite2         tstWrite2;
CTestWrite3         tstWrite3;
CTestSetsize        tstSetsize;
CTestSetsize2       tstSetsize2;
CTestCreateStream2  tstCreateStream2;
CTestDestroyElement tstDestroyElement;
CTestSwitchToFile   tstSwitchToFile;
CTestCommit3        tstCommit3;
CTestCommit4        tstCommit4;

CTestCase *atst[] =
{
#if defined(BREADTHTEST)
    &tstStgCreate,
    &tstStgOpen,
    &tstCreateStorage,
    &tstCreateStream,
    &tstWrite,
    &tstCommit,
    &tstCommit2,
    &tstOpenStream,
    &tstOpenStorage,
    &tstWrite2,
    &tstWrite3,
    &tstSetsize,
    &tstCreateStream2,
    &tstDestroyElement,
    &tstSetsize2,
    &tstSwitchToFile,
    &tstCommit3,
#endif
    &tstCommit4
};

int TestCount(void)
{
    return(sizeof(atst)/sizeof(CTestCase *));
}

CTestCase *TestItem(int iTest)
{
    return(atst[iTest]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\utils\fail\headers.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       headers.cxx
//
//  Contents:   Precompiled headers
//
//  History:    21-Jan-93 AlexT    Created
//
//--------------------------------------------------------------------------

#if DBG != 1
#error FAIL.EXE requires DBG == 1
#endif

#include <io.h>
#include <stdio.h>
#include <stdlib.h>

#include <windows.h>
#include <memory.h>
#include <storage.h>

#include <debnot.h>
#include <dfdeb.hxx>
#include <dfmsp.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\utils\fail\supp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       Supp.cxx
//
//  Contents:   Supplementary classes
//
//  Classes:    CModeDf - Docfile creation modes
//
//  History:    25-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>

#pragma hdrstop

#include <sift.hxx>

#if DBG != 1
#error FAIL.EXE requires DBG == 1
#endif

// #define DEPTHTEST    //  Uncomment out for depth testing (long time)

//+-------------------------------------------------------------------------
//
//  Notes:  Mode combinations for StgCreateDocfile
//
//--------------------------------------------------------------------------

DWORD adwTransactionModes[] = {
    STGM_DIRECT,
    STGM_TRANSACTED
};

#define TMODES (sizeof(adwTransactionModes) / sizeof(DWORD))

DWORD adwAccessModes[] = {
    STGM_READWRITE,
    STGM_WRITE,
    STGM_READ
};

#if defined(DEPTHTEST)
# define AMODES (sizeof(adwAccessModes) / sizeof(DWORD))
#else
# define AMODES 1
#endif

DWORD adwShareModes[] = {
    STGM_SHARE_DENY_NONE,
    STGM_SHARE_EXCLUSIVE,
    STGM_SHARE_DENY_READ,
    STGM_SHARE_DENY_WRITE
};

#if defined(DEPTHTEST)
# define SMODES (sizeof(adwShareModes) / sizeof(DWORD))
#else
# define SMODES 2
#endif

DWORD adwDeleteModes[] = {
    0,
    STGM_DELETEONRELEASE
};

#if defined(DEPTHTEST)
# define DMODES (sizeof(adwDeleteModes) / sizeof(DWORD))
#else
# define DMODES 1
#endif

DWORD adwCreateModes[] = {
    STGM_FAILIFTHERE,
    STGM_CREATE,
    STGM_CONVERT
};

#if defined(DEPTHTEST)
# define CMODES (sizeof(adwCreateModes) / sizeof(DWORD))
#else
# define CMODES 1
#endif

void CModeDf::Init(void)
{
    _it = _ia = _is = _id = _ic = 0;
    CalcMode();
}

void CModeDf::CalcMode(void)
{
    _dwMode = adwTransactionModes[_it] |
              adwAccessModes[_ia]      |
              adwShareModes[_is]       |
              adwDeleteModes[_id]      |
              adwCreateModes[_ic];
}

BOOL CModeDf::Next(void)
{
    BOOL f = TRUE;

    if (++_ic >= CMODES)
    {
        _ic = 0;
        if (++_id >= DMODES)
        {
            _id = 0;
            if (++_is >= SMODES)
            {
                _is = 0;
                if (++_ia >= AMODES)
                {
                    _ia = 0;
                    if (++_it >= TMODES)
                    {
                        f = FALSE;
                    }
                }
            }
        }
    }

    if (f)
        CalcMode();

    return(f);
}

void CModeStg::Init(void)
{
    _it = _ia = 0;
    CalcMode();
}

void CModeStg::CalcMode(void)
{
    _dwMode = adwTransactionModes[_it] |
              adwAccessModes[_ia]      |
              STGM_SHARE_EXCLUSIVE;
}

BOOL CModeStg::Next(void)
{
    BOOL f = TRUE;

    if (++_ia >= AMODES)
    {
        _ia = 0;
        if (++_it >= TMODES)
        {
            f = FALSE;
        }
    }

    if (f)
        CalcMode();

    return(f);
}

void CModeStm::Init(void)
{
    _ia = 0;
    CalcMode();
}

void CModeStm::CalcMode(void)
{
    _dwMode = STGM_DIRECT         |
              adwAccessModes[_ia] |
              STGM_SHARE_EXCLUSIVE;
}

BOOL CModeStm::Next(void)
{
    BOOL f = TRUE;

    if (++_ia >= AMODES)
    {
        f = FALSE;
    }

    if (f)
        CalcMode();

    return(f);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\chicago.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=200           \
              -D_CHICAGO_=200       \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
              -DCAIROLE_DOWNLEVEL   \
              -DMULTI_THREADING     \
              -D_WIN32_DCOM         \
              $(TRACELOG)

# For the Chicago project, we do not want to use CRTDLL.DLL, so leave this
# line commented out.
#
#

USE_LIBCMT=   1

CHICAGO_PRODUCT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\daytona.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=100           \
              -D_NT1X_=100          \
              -DUNICODE             \
              -D_UNICODE            \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
	      -DCAIROLE_DOWNLEVEL   \
	      -DMULTI_THREADING     \
              $(TRACELOG)

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1

USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\utils\fail\sift.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       SIFT.cxx
//
//  Contents:   Simulated Iterated Failure Testing Harness
//
//  Functions:  Sift
//
//  History:    25-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>

#pragma hdrstop

#if DBG != 1
#error FAIL.EXE requires DBG == 1
#endif

#include <sift.hxx>

#define SET_DISPLAY_BUF_SIZE _wsetscreenbuf(_fileno(stdout), _WINBUFINF)

void main (int argc, char *argv[])
{
    int i;
    int cTests = TestCount();

    SiftInit();

    SET_DISPLAY_BUF_SIZE;   //set QuickWin buffer size to infinite

    printf("SIFT %d tests.\n", cTests);

    for (i = 0; i < cTests; i++)
    {
        SiftDriver(TestItem(i));
    }

    //  Be a good citizen and leave the Docfile clean
    SetFailLimit(0L);

    CoUninitialize();

    printf("SIFT complete.\n");
}

//+-------------------------------------------------------------------------
//
//  Function:   Initialize
//
//  Synopsis:   Standard initialization
//
//  History:    21-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

void SiftInit(void)
{
    SCODE sc;

#if WIN32 == 300
    if (FAILED(sc = DfGetScode(CoInitializeEx(NULL, COINIT_MULTITHREADED))))
#else
    if (FAILED(sc = DfGetScode(CoInitialize(NULL))))
#endif
        printf("SIFT: Unable to CoInitialize, sc = 0x%lX\n", sc);

    DfDebug(0x00100101, 0x101);
}

void SiftDriver(CTestCase *ptc)
{
    SCODE sc;

    if (!ptc->Init())
    {
        //  Test's obligation to display failure message
        return;
    }

    do
    {
        LONG iteration, lcf = 0;
        for (iteration = 0; iteration <= lcf; iteration++)
        {
            SetFailLimit(0L);

            sc = ptc->Prep(iteration);
            if (FAILED(sc))
                continue;

            SetFailLimit(iteration);
            sc = ptc->Call(iteration);

            if (SUCCEEDED(sc))
            {
                if (iteration == 0)
                {
                    lcf = DfGetResLimit(DBR_FAILCOUNT);
                    printf("%ld failure points\n", lcf);
                }
                else
                {
                    //  Shouldn't have succeeded
                    printf("..Iteration %ld succeeded!\n", iteration);
                }
                SetFailLimit(0L);
                ptc->EndCall(iteration);
            }
            else
            {
                SetFailLimit(0L);
                ptc->CallVerify(iteration);
            }

            ptc->EndPrep(iteration);
            ptc->EndVerify(iteration);
        }
    } while (ptc->Next());
}

//+-------------------------------------------------------------------------
//
//  Function:   SetFailLimit
//
//  Synopsis:   clear count, set limit
//
//  Arguments:  [limit] -- failure limit
//
//  History:    22-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

void SetFailLimit(LONG limit)
{
    DfSetResLimit(DBR_FAILCOUNT, 0);
    DfSetResLimit(DBR_FAILLIMIT, limit);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\utils\stgview\stgview.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:	stgview.cxx
//
//  Contents:	Storage viewer utility
//
//  History:	10-Dec-91	DrewB	Created
//
//---------------------------------------------------------------

#include <memory.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <ctype.h>

#include <windows.h>
#if WIN32 != 300
#include <storage.h>
#endif
#include <wchar.h>
#include <dfmsp.hxx>

#define FLG_RECURSIVE   0x00000001
#define FLG_STREAMS     0x00000002
#define FLG_VERBOSE     0x00000004

#define DFTOUCH

#ifdef DFTOUCH
#define CB_BUFFER   1024
#else
#define CB_BUFFER   16
#endif
BYTE    abBuffer[CB_BUFFER];

char *szTypes[] =
{
    "", "IStorage", "IStream", "ILockBytes"
};

void utMemFree(void *pv)
{
    IMalloc FAR* pMalloc;
    if (SUCCEEDED(GetScode(CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        pMalloc->Free(pv);
        pMalloc->Release();
    }
}

void LevSpace(int iLevel)
{
    int i;

    for (i = 0; i<iLevel; i++)
	printf("  ");
}

void PrintStat(STATSTG *psstg, ULONG flOptions, int iLevel)
{
    LevSpace(iLevel);
    if (flOptions & FLG_VERBOSE)
    {
#ifdef UNICODE
	wprintf(L"%s:%hs =>\n", psstg->pwcsName, szTypes[psstg->type]);
#else
	printf("%s:%s =>\n", psstg->pwcsName, szTypes[psstg->type]);
#endif

#ifdef FLAT
        SYSTEMTIME systime;
        struct tm stime;

	LevSpace(iLevel+1);
        if (((psstg->ctime.dwHighDateTime != 0) ||
             (psstg->ctime.dwLowDateTime != 0 )) &&
            FileTimeToSystemTime(&psstg->ctime, &systime))
        {
            stime.tm_sec   = systime.wSecond;
            stime.tm_min   = systime.wMinute;
            stime.tm_hour  = systime.wHour;
            stime.tm_mday  = systime.wDay;
            stime.tm_mon   = systime.wMonth - 1;
            stime.tm_year  = systime.wYear - 1900;
            stime.tm_wday  = systime.wDayOfWeek;
            stime.tm_yday  = 0;
            stime.tm_isdst = 0;

	    printf("Created : %s", asctime(&stime));
        }
        else
	   printf("Created : %lx %lx (conversion unavailable)\n",
		  psstg->ctime.dwHighDateTime, psstg->ctime.dwLowDateTime);

	LevSpace(iLevel+1);
        if (((psstg->mtime.dwHighDateTime != 0) ||
             (psstg->mtime.dwLowDateTime != 0 )) &&
            FileTimeToSystemTime(&psstg->mtime, &systime))
        {
            stime.tm_sec   = systime.wSecond;
            stime.tm_min   = systime.wMinute;
            stime.tm_hour  = systime.wHour;
            stime.tm_mday  = systime.wDay;
            stime.tm_mon   = systime.wMonth - 1;
            stime.tm_year  = systime.wYear - 1900;
            stime.tm_wday  = systime.wDayOfWeek;
            stime.tm_yday  = 0;
            stime.tm_isdst = 0;

	    printf("Modified : %s", asctime(&stime));
        }
        else
	    printf("Modified : %lx %lx (conversion unavailable)\n",
	           psstg->ctime.dwHighDateTime, psstg->ctime.dwLowDateTime);

	LevSpace(iLevel+1);
        if (((psstg->atime.dwHighDateTime != 0) ||
             (psstg->atime.dwLowDateTime != 0 )) &&
            FileTimeToSystemTime(&psstg->mtime, &systime))
        {
            stime.tm_sec   = systime.wSecond;
            stime.tm_min   = systime.wMinute;
            stime.tm_hour  = systime.wHour;
            stime.tm_mday  = systime.wDay;
            stime.tm_mon   = systime.wMonth - 1;
            stime.tm_year  = systime.wYear - 1900;
            stime.tm_wday  = systime.wDayOfWeek;
            stime.tm_yday  = 0;
            stime.tm_isdst = 0;

	    printf("Accessed : %s", asctime(&stime));
        }
        else
	    printf("Accessed : %lx %lx (conversion unavailable)\n",
	           psstg->ctime.dwHighDateTime, psstg->ctime.dwLowDateTime);
#else
	LevSpace(iLevel+1);
	printf("Created : %lx %lx (conversion unavailable)\n",
	       psstg->ctime.dwHighDateTime, psstg->ctime.dwLowDateTime);
	LevSpace(iLevel+1);
	printf("Modified : %lx %lx (conversion unavailable)\n",
	       psstg->mtime.dwHighDateTime, psstg->mtime.dwLowDateTime);
	LevSpace(iLevel+1);
	printf("Accessed : %lx %lx (conversion unavailable)\n",
	       psstg->atime.dwHighDateTime, psstg->atime.dwLowDateTime);
#endif

	if (psstg->type == STGTY_STREAM || psstg->type == STGTY_LOCKBYTES)
	{
	    LevSpace(iLevel+1);
	    printf("Size: %lu:%lu\n", ULIGetHigh(psstg->cbSize),
		   ULIGetLow(psstg->cbSize));
	}
    }
    else
#ifdef UNICODE
	wprintf(L"%s\n", psstg->pwcsName);
#else
	printf("%s\n", psstg->pwcsName);
#endif
}

// ctype doesn't work properly
#define dfisprint(c) ((c) >= ' ' && (c) < 127)

void Stream(IStream *pstm, ULONG flOptions, int iLevel)
{
    ULONG   cbRead;
#ifdef DFTOUCH
    ULONG   cbTotal = 0;
#endif
    SCODE   sc;

    sc = GetScode(pstm->Read(abBuffer, CB_BUFFER, &cbRead));
    while (SUCCEEDED(sc) && (cbRead > 0))
    {
        LevSpace(iLevel);
#ifdef DFTOUCH
	cbTotal += cbRead;
	printf("Read %lu bytes\n", cbTotal);
#else
        for (ULONG ib = 0; ib < cbRead; ib++)
        {
            printf("%.2X", (int)abBuffer[ib]);
        }
        for (ib = ib; ib < CB_BUFFER + 1; ib++)
        {
            printf("  ");
        }

        for (ib = 0; ib < cbRead; ib++)
        {
            printf("%c", dfisprint(abBuffer[ib]) ? abBuffer[ib] : '.');
        }
        printf("\n");
#endif

        sc = GetScode(pstm->Read(abBuffer, CB_BUFFER, &cbRead));
    }
    if (FAILED(sc))
	printf("Read failed with 0x%lX\n", sc);
}

void Contents(IStorage *pdf, ULONG flOptions, int iLevel)
{
    IEnumSTATSTG *pdfi;
    SCODE sc;
    IStorage *pdfChild;
    IStream  *pstmChild;
    STATSTG sstg;

    if (FAILED(pdf->EnumElements(0, NULL, 0, &pdfi)))
    {
	fprintf(stderr, "Unable to create iterator\n");
	return;
    }
    for (;;)
    {
	sc = GetScode(pdfi->Next(1, &sstg, NULL));
	if (sc != S_OK)
	    break;
	PrintStat(&sstg, flOptions, iLevel);
	if ((sstg.type == STGTY_STORAGE) && (flOptions & FLG_RECURSIVE))
	{
	    if (SUCCEEDED(pdf->OpenStorage(sstg.pwcsName, NULL,
					   STGM_READ | STGM_SHARE_EXCLUSIVE,
					   NULL, 0, &pdfChild)))
	    {
		Contents(pdfChild, flOptions, iLevel+1);
		pdfChild->Release();
	    }
	    else
		fprintf(stderr, "%s: Unable to recurse\n", sstg.pwcsName);
	}
        else
        if ((sstg.type == STGTY_STREAM) && (flOptions & FLG_STREAMS))
        {
            if (SUCCEEDED(pdf->OpenStream(sstg.pwcsName, NULL,
                                          STGM_READ | STGM_SHARE_EXCLUSIVE,
                                          0, &pstmChild)))
            {
                Stream(pstmChild, flOptions, iLevel+1);
                pstmChild->Release();
            }
            else
                fprintf(stderr, "%s: Unable to open\n", sstg.pwcsName);
        }
	utMemFree(sstg.pwcsName);
    }
    pdfi->Release();
    if (FAILED(sc))
	printf("Enumeration failed with 0x%lX\n", sc);
}

void Descend(IStorage *pdf, char *pszPath, IStorage **ppdf)
{
    IStorage   *pdfNext;
    char       *pszNext = pszPath;
    char       *pszEnd  = strchr(pszNext, '\\');
    TCHAR atcName[CWCSTORAGENAME];

    while (pszNext != NULL)
    {
        if (pszEnd != NULL)
        {
            *pszEnd = '\0';
        }

#ifdef UNICODE
        if (mbstowcs(atcName, pszNext, CWCSTORAGENAME) == (size_t)-1)
        {
            pdf = NULL;

            fprintf(stderr, "Unable to convert '%s' to Unicode\n", pszNext);
            break;
        }
#else
        strcpy(atcName, pszNext);
#endif
        if (SUCCEEDED(pdf->OpenStorage(atcName, NULL,
                                       STGM_READ | STGM_SHARE_EXCLUSIVE,
                                       NULL, 0, &pdfNext)))
        {
            pdf = pdfNext;

            if (pszEnd != NULL)
            {
                *pszEnd = '\\';

                pszNext = pszEnd + 1;
                pszEnd  = strchr(pszNext, '\\');
            }
            else
            {
                pszNext = NULL;
            }
        }
        else
        {
            pdf = NULL;

            fprintf(stderr, "Unable to open '%s' in docfile\n", pszPath);
            break;
        }
    }

    *ppdf = pdf;
}

void __cdecl main(int argc, char **argv)
{
    ULONG flOptions = 0;
    IStorage *pdf;
    IStorage *pdfRoot;
    STATSTG sstg;

    argc--;
    argv++;
    while ((argc > 0) && ((*argv)[0] == '-'))
    {
        for (int ich = 1; (*argv)[ich] != '\0'; ich++)
        {
            switch((*argv)[ich])
            {
            case 's':
                flOptions |= FLG_STREAMS;
                break;
            case 'v':
                flOptions |= FLG_VERBOSE;
                break;
            case 'r':
                flOptions |= FLG_RECURSIVE;
                break;
            default:
                fprintf(stderr, "Unknown switch '%c'\n", (*argv)[ich]);
                break;
            }
        }

        argc--;
        argv++;
    }

    if ((argc != 1) && (argc != 2))
    {
	printf("Usage: stgview [-v] [-s] [-r] docfile [path]\n");
	exit(1);
    }

    SCODE sc;

#if WIN32 == 300
    if (FAILED(sc = GetScode(CoInitializeEx(NULL, COINIT_MULTITHREADED))))
#else
    if (FAILED(sc = GetScode(CoInitialize(NULL))))
#endif
    {
        fprintf(stderr, "CoInitialize failed with sc = %lx\n", sc);
        exit(1);
    }

    TCHAR atcName[_MAX_PATH];
#ifdef UNICODE
    if (mbstowcs(atcName, *argv, _MAX_PATH) == (size_t)-1)
    {
        fprintf(stderr, "Unable to convert '%s' to Unicode\n", *argv);
        exit(1);
    }
#else
    strcpy(atcName, *argv);
#endif
    if (FAILED(StgOpenStorage(atcName, NULL, STGM_READ | STGM_SHARE_DENY_WRITE,
			      NULL, 0, &pdf)))
    {
	fprintf(stderr, "Unable to open '%s'\n", *argv);
	exit(1);
    }
    else
    {
        if (argc == 2)
        {
            Descend(pdf, *(argv + 1), &pdfRoot);
        }
        else
        {
            pdf->AddRef();
            pdfRoot = pdf;
        }

        if (pdfRoot != NULL)
        {
            if (FAILED(pdfRoot->Stat(&sstg, 0)))
                fprintf(stderr, "Unable to stat root\n");
            else
            {
                PrintStat(&sstg, flOptions, 0);
                utMemFree(sstg.pwcsName);
            }
            Contents(pdfRoot, flOptions, 1);
            pdfRoot->Release();
        }
	pdf->Release();
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cairo.inc ===
# This is the global include file for the cairo version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=300           \
              -D_CAIRO_=300         \
              -DUNICODE             \
              -D_UNICODE            \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
	      -DCAIROLE_DISTRIBUTED \
	      -DMULTI_THREADING     \
              $(TRACELOG)

# For the Cairo build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1

USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\accctrl\client\chicago\makefile.inc ===
DEST_TREE=chicago

!include ..\makeidl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\accctrl\client\oactestc.cxx ===
/****************************************************************************

  File: actestc.cxx
  Description: Client side of the DCOM IAccessControl test program.

****************************************************************************/


#include <windows.h>
#include <ole2.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <accctrl.h>
#include "oactest.h"
#include <oleext.h>
#include <rpcdce.h>

/* Internal program parameters */
#define BIG_BUFFER       2048
#define LINE_BUFF_SIZE 200
#define MAX_TOKENS_NUM 20
#define STR_LEN 100


// Define some bogus access masks so that we can verify the
// the validation mechanism of DCOM IAccessControl

#define BOGUS_ACCESS_RIGHT1 (COM_RIGHTS_EXECUTE*2)
#define BOGUS_ACCESS_RIGHT2 (COM_RIGHTS_EXECUTE*4)
#define BOGUS_ACCESS_RIGHT3 (COM_RIGHTS_EXECUTE*8)
#define BOGUS_ACCESS_RIGHT4 (COM_RIGHTS_EXECUTE*16)


// The following structure encapsulates all kinds of information that
// can be associated with a trustee.
typedef struct tagTRUSTEE_RECORD
{
  DWORD                         grfAccessPermissions;
  ACCESS_MODE                   grfAccessMode;
  DWORD                         grfInheritance;
  PTRUSTEE_W                    pMultipleTrustee;
  MULTIPLE_TRUSTEE_OPERATION    MultipleTrusteeOperation;
  TRUSTEE_FORM                  TrusteeForm;
  TRUSTEE_TYPE                  TrusteeType;
  LPWSTR                        pwszTrusteeName;
  PISID                         pSID;
} TRUSTEE_RECORD;


/* Global variables */
char pszUserName[STR_LEN];            // User Name
char pszBasePath[STR_LEN];
char pszResource[STR_LEN];            // Resource location
EXPLICIT_ACCESS_W   g_pLocalExplicitAccessList[100];
ULONG               g_ulNumOfLocalExplicitAccesses = 0;
ACCESS_REQUEST_W    g_pLocalAccessRequestList[100];
ULONG               g_ulNumOfLocalAccessRequests = 0;
PEXPLICIT_ACCESS_W  g_pReturnedExplicitAccessList = NULL;
ULONG               g_ulNumOfExplicitAccessesReturned = 0;
TRUSTEE_W           g_pLocalTrusteeList[100];
ULONG               g_ulNumOfLocalTrustees = 0;
TRUSTEE_RECORD      g_LocalTrusteeRecord;
IAccessControlTest  *g_pIAccessControlTest;
IUnknown            *g_pIUnknown;

const CLSID CLSID_COAccessControlTest
    = {0x20692b00,0xe710,0x11cf,{0xaf,0x0b,0x00,0xaa,0x00,0x44,0xfb,0x89}};

/* Internal function prototyoes */
void Tokenize(char *, char *[], short *);
void stringtolower(char *);
PISID GetSIDForTrustee(LPWSTR);
void AddTrusteeToExplicitAccessList(TRUSTEE_RECORD *, PEXPLICIT_ACCESS_W, ULONG *);
void DeleteTrusteeFromExplicitAccessList(ULONG, PEXPLICIT_ACCESS_W, ULONG *);
void AddTrusteeToAccessRequestList(TRUSTEE_RECORD *, PACCESS_REQUEST_W, ULONG *);
void DeleteTrusteeFromAccessRequestList(ULONG, PACCESS_REQUEST_W, ULONG *);
void MapTrusteeRecordToTrustee(TRUSTEE_RECORD *, TRUSTEE_W *);
void AddTrusteeToTrusteeList(TRUSTEE_RECORD *, TRUSTEE_W *, ULONG *);
void DeleteTrusteeFromTrusteeList(ULONG, TRUSTEE_W *, ULONG *);
void DestroyAccessRequestList(PACCESS_REQUEST_W, ULONG *);
void DestroyTrusteeList(TRUSTEE_W *, ULONG *);
void DestroyExplicitAccessList(PEXPLICIT_ACCESS_W, ULONG *);
void PrintEnvironment(void);
void DumpTrusteeRecord(TRUSTEE_RECORD *);
void DumpAccessRequestList(ULONG, ACCESS_REQUEST_W []);
void DumpExplicitAccessList(ULONG, EXPLICIT_ACCESS_W []);
void DumpAccessPermissions(DWORD);
DWORD StringToAccessPermission(CHAR *);
void DumpAccessMode(ACCESS_MODE);
void DumpTrusteeList(ULONG, TRUSTEE_W []);
void DumpTrustee(TRUSTEE_W *);
void DumpMultipleTrusteeOperation(MULTIPLE_TRUSTEE_OPERATION);
MULTIPLE_TRUSTEE_OPERATION StringToMultipleTrusteeOperation(CHAR *);
void DumpTrusteeType(TRUSTEE_TYPE);
TRUSTEE_TYPE StringToTrusteeType(CHAR *);
void DumpTrusteeForm(TRUSTEE_FORM);
TRUSTEE_FORM StringToTrusteeForm(CHAR *);
void DumpSID(PISID);
ACCESS_MODE StringToAccessMode(CHAR *);
void DumpInheritance(DWORD);
DWORD StringToInheritance(CHAR *);
void ReleaseExplicitAccessList(ULONG, PEXPLICIT_ACCESS_W);
void CopyExplicitAccessList(PEXPLICIT_ACCESS_W, PEXPLICIT_ACCESS_W, ULONG *, ULONG);
void ExecTestServer(CHAR *);
void ExecRevertAccessRights(void);
void ExecCommitAccessRights(void);
void ExecGetClassID(void);
void ExecInitNewACL(void);
void ExecLoadACL(CHAR *);
void ExecSaveACL(CHAR *);
void ExecGetSizeMax(void);
void ExecIsDirty(void);
void ExecGrantAccessRights(void);
void ExecSetAccessRights(void);
void ExecDenyAccessRights(void);
void ExecReplaceAllAccessRights(void);
void ExecRevokeExplicitAccessRights(void);
void ExecIsAccessPermitted(void);
void ExecGetEffectiveAccessRights(void);
void ExecGetExplicitAccessRights(void);
void ExecCleanupProc();


void Usage(char * pszProgramName)
{
    printf("Usage:  %s\n", pszProgramName);
    printf(" -m remote_server_name\n");
    exit(1);
}


void stringtolower
(
char *pszString
)
{
    char c;

    while(c = *pszString)
    {
        if(c <= 'Z' && c >= 'A')
        {
            *pszString = c - 'A' + 'a';
        }
        pszString++;
    }
} // stringtolower


void __cdecl main(int argc, char **argv)
{
    RPC_STATUS status;
    unsigned long ulCode;
    WCHAR                      DummyChar;
    int                       i;
    char                      aLineBuff[LINE_BUFF_SIZE];
    char                      *aTokens[MAX_TOKENS_NUM];
    short                     iNumOfTokens;
    SEC_WINNT_AUTH_IDENTITY_A auth_id;
    UCHAR                     uname[STR_LEN];
    UCHAR                     domain[STR_LEN];
    UCHAR                     password[STR_LEN];
    TRUSTEE_W                 DummyMultipleTrustee;
    ULONG                     ulStrLen;
    DWORD                     dwAccessPermission;
    BOOL                      biBatchMode = FALSE;
    HRESULT                   hr;
    OLECHAR                   pwszRemoteServer[1024];
    DWORD                     dwStrLen;

    /* allow the user to override settings with command line switches */
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'm':  // remote server name
                dwStrLen = MultiByteToWideChar( CP_ACP
                                              , NULL
                                              , argv[++i]
                                              , -1
                                              , pwszRemoteServer
                                              , 1024);
                break;
            case 'b':
                biBatchMode = TRUE;
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }

    // Initialize the testing environment

    aTokens[0] = aLineBuff;

    g_LocalTrusteeRecord.grfAccessPermissions = 0;
    g_LocalTrusteeRecord.grfAccessMode = GRANT_ACCESS;
    g_LocalTrusteeRecord.grfInheritance = NO_INHERITANCE;
    g_LocalTrusteeRecord.pMultipleTrustee = NULL;
    g_LocalTrusteeRecord.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    g_LocalTrusteeRecord.TrusteeForm = TRUSTEE_IS_NAME;
    g_LocalTrusteeRecord.TrusteeType = TRUSTEE_IS_USER;
    g_LocalTrusteeRecord.pwszTrusteeName = NULL;
    g_LocalTrusteeRecord.pSID = NULL;




    auth_id.User = uname;
    auth_id.Domain = domain;
    auth_id.Password = password;
    auth_id.Flags = 0x01; // ANSI

    // Call CoInitialize to initialize the com library
    hr = CoInitialize(NULL);

    if(FAILED(hr))
    {
        printf("Failed to initialize the COM library.");
        exit(hr);
    } // if

    // Call CoInitializeSecurity
    hr = CoInitializeSecurity( NULL
                             , -1
                             , NULL
                             , NULL
                             , RPC_C_AUTHN_LEVEL_CONNECT
                             , RPC_C_IMP_LEVEL_IMPERSONATE
                             , NULL
                             , EOAC_NONE
                             , NULL );


    if(FAILED(hr))
    {
        printf("Failed to initialize the COM call security layer.\n");
        exit(hr);
    }

    MULTI_QI MultiQI;

    MultiQI.pIID = &IID_IUnknown;
    MultiQI.pItf = NULL;

    COSERVERINFO ServerInfo;
    ServerInfo.pwszName = pwszRemoteServer;
    ServerInfo.pAuthInfo = NULL;
    ServerInfo.dwReserved1 = 0;
    ServerInfo.dwReserved2 = 0;
    // Call CoCreateInstance to create an access control test
    // object
    hr = CoCreateInstanceEx( CLSID_COAccessControlTest
                           , NULL
                           , CLSCTX_REMOTE_SERVER
                           , &ServerInfo
                           , 1
                           , &MultiQI);

    if(FAILED(hr))
    {
        printf("CoCreateInstance failed with exit code %x.\n", hr);
        exit(hr);
    }
    hr = MultiQI.hr;
    g_pIUnknown = (IUnknown *)MultiQI.pItf;

    if(FAILED(hr))
    {
        printf("Failed to create an instance of the access control test object.\n");
        exit(hr);
    }

    hr = g_pIUnknown->QueryInterface(IID_IAccessControlTest, (void **)&g_pIAccessControlTest);

    if(FAILED(hr))
    {
        printf("Failed to query for the IAccessControlTest interface.\n");
        exit(hr);
    }
    printf("\n");
    PrintEnvironment();


    printf("\n");


    /* Entering the interactive command loop */


    for(;;)
    {

        // Print out prompt
        if (!biBatchMode)
        {
            printf("Command>");
        }

        memset(aLineBuff, 0, LINE_BUFF_SIZE);

        // Read input form user
        gets(aLineBuff);

        if (biBatchMode)
        {
            printf("%s\n",aLineBuff);
        }

        Tokenize(aLineBuff,aTokens,&iNumOfTokens);

        // Process the tokens
        stringtolower(aTokens[0]);

        // Decode and execute command
        // Ignore comments
          if (iNumOfTokens == 0)
          {
            continue;
          }
          if (*aTokens[0] == '#')
          {
            continue;
          }
          printf("\n");
          if (strcmp(aTokens[0],"quit") == 0)
          {
            printf("Exit.\n");
            ExecCleanupProc();
            break;
          }
          else if (strcmp(aTokens[0],"exit") == 0)
          {
            printf("Exit.\n");
            ExecCleanupProc();
            break;
          }
          else if (strcmp(aTokens[0],"sleep") == 0)
          {
            printf("Sleep for %s milliseconds", aTokens[1]);
            Sleep(atoi(aTokens[1]));
          }
          else if (strcmp(aTokens[0], "testserver") == 0)
          {
            g_pIAccessControlTest->TestServer(aTokens[1]);
            printf("Done.\n");
          }
          else if (strcmp(aTokens[0],"switchclientctx") == 0)
          {

            printf("User:");
            gets((CHAR *)uname);
            printf("Domain:");
            gets((CHAR *)domain);
            printf("Password:");
            gets((CHAR *)password);

            auth_id.UserLength = strlen((CHAR *)uname);
            auth_id.DomainLength = strlen((CHAR *)domain);
            auth_id.PasswordLength = strlen((CHAR *)password);
            auth_id.Flags = 0x1;

            /* Set authentication info so that the server is triggered */
            /* to cache group info for the client from the domain server */
            hr = CoSetProxyBlanket( g_pIAccessControlTest
                                  , RPC_C_AUTHN_WINNT
                                  , RPC_C_AUTHZ_NONE
                                  , NULL
                                  , RPC_C_AUTHN_LEVEL_CONNECT
                                  , RPC_C_IMP_LEVEL_IMPERSONATE
                                  , &auth_id
                                  , EOAC_NONE );

            printf("CoSetProxyBlanket returned %x\n", hr);
            if (FAILED(hr))
            {
              exit(hr);
            }
          }
          else if (strcmp(aTokens[0],"toggleaccessperm") == 0)
          {
            stringtolower(aTokens[1]);
            dwAccessPermission = StringToAccessPermission(aTokens[1]);
            if (g_LocalTrusteeRecord.grfAccessPermissions & dwAccessPermission)
            {
              g_LocalTrusteeRecord.grfAccessPermissions &= ~dwAccessPermission;
            }
            else
            {
              g_LocalTrusteeRecord.grfAccessPermissions |= dwAccessPermission;
            }
            printf("Done.\n");
          }
          else if (strcmp(aTokens[0],"set") == 0)
          {
            stringtolower(aTokens[1]);

            if (strcmp(aTokens[1],"trusteename") == 0)
            {

                // The old SID in the global trustee record will no longer valid so we
                // may as well release it to avoid confusion
                if (g_LocalTrusteeRecord.pSID != NULL)
                {
                    midl_user_free(g_LocalTrusteeRecord.pSID);
                    g_LocalTrusteeRecord.pSID = NULL;
                }

                if (g_LocalTrusteeRecord.pwszTrusteeName != NULL)
                {
                    midl_user_free(g_LocalTrusteeRecord.pwszTrusteeName);
                }
                ulStrLen = MultiByteToWideChar( CP_ACP
                                              , 0
                                              , aTokens[2]
                                              , -1
                                              , &DummyChar
                                              , 0 );
                g_LocalTrusteeRecord.pwszTrusteeName = (LPWSTR)midl_user_allocate(sizeof(WCHAR) * (ulStrLen+1));

                MultiByteToWideChar( CP_ACP
                                   , 0
                                   , aTokens[2]
                                   , ulStrLen + 1
                                   , g_LocalTrusteeRecord.pwszTrusteeName
                                   , ulStrLen + 1);

                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "accessmode") == 0)
            {
                stringtolower(aTokens[2]);
                g_LocalTrusteeRecord.grfAccessMode = StringToAccessMode(aTokens[2]);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "inheritance") == 0)
            {
                stringtolower(aTokens[2]);
                g_LocalTrusteeRecord.grfInheritance = StringToInheritance(aTokens[2]);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "multipletrustee") == 0)
            {
                stringtolower(aTokens[2]);
                if (strcmp(aTokens[2], "null") == 0)
                {
                    g_LocalTrusteeRecord.pMultipleTrustee = NULL;
                }
                else
                {
                    g_LocalTrusteeRecord.pMultipleTrustee = &DummyMultipleTrustee;
                }
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "multipletrusteeoperation") == 0)
            {
                stringtolower(aTokens[2]);
                g_LocalTrusteeRecord.MultipleTrusteeOperation = StringToMultipleTrusteeOperation(aTokens[2]);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "trusteeform") == 0)
            {
                stringtolower(aTokens[2]);
                g_LocalTrusteeRecord.TrusteeForm = StringToTrusteeForm(aTokens[2]);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "trusteetype") == 0)
            {
                stringtolower(aTokens[2]);
                g_LocalTrusteeRecord.TrusteeType = StringToTrusteeType(aTokens[2]);
                printf("Done.\n");
            }
            else
            {
              printf("Invalid environment variable.\n");
            } // if
          }
          else if (strcmp(aTokens[0], "getsidforcurrenttrustee") == 0)
          {
            g_LocalTrusteeRecord.pSID = GetSIDForTrustee(g_LocalTrusteeRecord.pwszTrusteeName);
            printf("Done.\n");
          }
          else if (strcmp(aTokens[0], "addtrustee") == 0)
          {
            stringtolower(aTokens[1]);
            if (strcmp(aTokens[1], "explicitaccesslist") == 0)
            {
                AddTrusteeToExplicitAccessList(&g_LocalTrusteeRecord, g_pLocalExplicitAccessList, &g_ulNumOfLocalExplicitAccesses);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "accessrequestlist") == 0)
            {
                AddTrusteeToAccessRequestList(&g_LocalTrusteeRecord, g_pLocalAccessRequestList, &g_ulNumOfLocalAccessRequests);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "trusteelist") == 0)
            {
                AddTrusteeToTrusteeList(&g_LocalTrusteeRecord, g_pLocalTrusteeList, &g_ulNumOfLocalTrustees);
                printf("Done.\n");
            }
            else
            {
                printf("Unknown list type.\n");
            }
          }
          else if (strcmp(aTokens[0], "deletetrustee") == 0)
          {
            stringtolower(aTokens[2]);
            if (strcmp(aTokens[2], "localexplicitaccesslist") == 0)
            {
                DeleteTrusteeFromExplicitAccessList(atoi(aTokens[1]), g_pLocalExplicitAccessList, &g_ulNumOfLocalExplicitAccesses);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[2], "accessrequestlist") == 0)
            {
                DeleteTrusteeFromAccessRequestList(atoi(aTokens[1]), g_pLocalAccessRequestList, &g_ulNumOfLocalAccessRequests);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[2], "trusteelist") == 0)
            {
                DeleteTrusteeFromTrusteeList(atoi(aTokens[1]), g_pLocalTrusteeList, &g_ulNumOfLocalTrustees);
                printf("Done.\n");
            }
            else
            {
                printf("Unknown list type.\n");
            }
          }
          else if (strcmp(aTokens[0], "destroy") == 0)
          {
            stringtolower(aTokens[1]);
            if (strcmp(aTokens[1], "localexplicitaccesslist") == 0)
            {
                DestroyExplicitAccessList(g_pLocalExplicitAccessList, &g_ulNumOfLocalExplicitAccesses);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "returnedexplicitaccessslist") == 0)
            {
                DestroyExplicitAccessList(g_pReturnedExplicitAccessList, &g_ulNumOfExplicitAccessesReturned);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "accessrequestlist") == 0)
            {
                DestroyAccessRequestList(g_pLocalAccessRequestList, &g_ulNumOfLocalAccessRequests);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "trusteelist") == 0)
            {
                DestroyTrusteeList(g_pLocalTrusteeList, &g_ulNumOfLocalTrustees);
            }
            else
            {
                printf("Unknown list type.");
            }
          }
          else if (strcmp(aTokens[0], "view") == 0)
          {
            stringtolower(aTokens[1]);
            if (strcmp(aTokens[1], "localexplicitaccesslist") == 0)
            {
                DumpExplicitAccessList(g_ulNumOfLocalExplicitAccesses, g_pLocalExplicitAccessList);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "returnedexplicitaccessslist") == 0)
            {
                DumpExplicitAccessList(g_ulNumOfExplicitAccessesReturned, g_pReturnedExplicitAccessList);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "accessrequestlist") == 0)
            {
                DumpAccessRequestList(g_ulNumOfLocalAccessRequests, g_pLocalAccessRequestList);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "trusteelist") == 0)
            {
                DumpTrusteeList(g_ulNumOfLocalTrustees, g_pLocalTrusteeList);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "trusteerecord") == 0)
            {
                DumpTrusteeRecord(&g_LocalTrusteeRecord);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "localenvironment") == 0)
            {
                PrintEnvironment();
            }
                else
            {
                printf("Invalid argument.");
            }

          }
          else if (strcmp(aTokens[0], "copyreturnedlist") == 0)
          {
            // release the old local explicit access list
            ReleaseExplicitAccessList(g_ulNumOfLocalExplicitAccesses, g_pLocalExplicitAccessList);

            // replace the local explicit acccess list with the explicit access list returned
            // from the last call to GetExplicitAccess
            CopyExplicitAccessList(g_pLocalExplicitAccessList, g_pReturnedExplicitAccessList, &g_ulNumOfLocalExplicitAccesses, g_ulNumOfExplicitAccessesReturned);
            printf("Done.\n");
          }
          else if (strcmp(aTokens[0], "exec") == 0)
          {
            stringtolower(aTokens[1]);
            if (strcmp(aTokens[1], "testserver") == 0)
            {
                ExecTestServer(aTokens[2]);
            }
            else if (strcmp(aTokens[1], "revertaccessrights") == 0)
            {
                ExecRevertAccessRights();
            }
            else if (strcmp(aTokens[1], "commitaccessrights") == 0)
            {
                ExecCommitAccessRights();
            }
            else if (strcmp(aTokens[1], "getclassid") == 0)
            {
                ExecGetClassID();
            }
            else if (strcmp(aTokens[1], "initnewacl") == 0)
            {
                ExecInitNewACL();
            }
            else if (strcmp(aTokens[1], "loadacl") == 0)
            {
                ExecLoadACL(aTokens[2]);
            }
            else if (strcmp(aTokens[1], "saveacl") == 0)
            {
                ExecSaveACL(aTokens[2]);
            }
            else if (strcmp(aTokens[1], "isdirty") == 0)
            {
                ExecIsDirty();
            }
            else if (strcmp(aTokens[1], "getsizemax") == 0)
            {
                ExecGetSizeMax();
            }
            else if (strcmp(aTokens[1], "grantaccessrights") == 0)
            {
                ExecGrantAccessRights();
            }
            else if (strcmp(aTokens[1], "setaccessrights") == 0)
            {
                ExecSetAccessRights();
            }
            else if (strcmp(aTokens[1], "denyaccessrights") == 0)
            {
                ExecDenyAccessRights();
            }
            else if (strcmp(aTokens[1], "replaceallaccessrights") == 0)
            {
                ExecReplaceAllAccessRights();
            }
            else if (strcmp(aTokens[1], "revokeexplicitaccessrights") == 0)
            {
                ExecRevokeExplicitAccessRights();
            }
            else if (strcmp(aTokens[1], "isaccesspermitted") == 0)
            {
                ExecIsAccessPermitted();
            }
            else if (strcmp(aTokens[1], "geteffectiveaccessrights") == 0)
            {
                ExecGetEffectiveAccessRights();
            }
            else if (strcmp(aTokens[1], "getexplicitaccessrights") == 0)
            {
                ExecGetExplicitAccessRights();
            }
            else
            {
                printf("Unknown command.\n");
            }
          }

          else
          {
            printf("Unrecognized command.\n");
          } // if

          printf("\n");


        } // for

    exit(0);

}  // end main()


PISID GetSIDForTrustee
(
LPWSTR pwszTrusteeName
)
{
    PISID            pSID;
    DWORD           dwSize = 0;
    WCHAR           pwszDomain[100];
    DWORD           dwDomainSize = 100;
    SID_NAME_USE    SIDUse;


    LookupAccountNameW( NULL
                      , pwszTrusteeName
                      , pSID
                      , &dwSize
                      , pwszDomain
                      , &dwDomainSize
                      , &SIDUse );

    pSID = (PISID)midl_user_allocate(dwSize);

    LookupAccountNameW( NULL
                      , pwszTrusteeName
                      , pSID
                      , &dwSize
                      , pwszDomain
                      , &dwDomainSize
                      , &SIDUse );

    return pSID;
}

void AddTrusteeToExplicitAccessList
(
TRUSTEE_RECORD     *pTrusteeRecord,
PEXPLICIT_ACCESS_W pExplicitAccessList,
ULONG              *pulNumOfExplicitAccesses
)
{
    PEXPLICIT_ACCESS_W pInsertionPoint;

    pInsertionPoint = pExplicitAccessList + *pulNumOfExplicitAccesses;
    pInsertionPoint->grfAccessPermissions = pTrusteeRecord->grfAccessPermissions;
    pInsertionPoint->grfAccessMode = pTrusteeRecord->grfAccessMode;
    pInsertionPoint->grfInheritance = pTrusteeRecord->grfInheritance;
    MapTrusteeRecordToTrustee(pTrusteeRecord, &(pInsertionPoint->Trustee));
    (*pulNumOfExplicitAccesses)++;


}

void DeleteTrusteeFromExplicitAccessList
(
ULONG               ulIndex,
PEXPLICIT_ACCESS_W  pExplicitAccessList,
ULONG               *pulNumOfExplicitAccesses
)
{
    PEXPLICIT_ACCESS_W pDeletionPoint;

    if(ulIndex >= *pulNumOfExplicitAccesses)
    {
        return;
    }
    pDeletionPoint = pExplicitAccessList + ulIndex;

    midl_user_free(pDeletionPoint->Trustee.ptstrName);

    (*pulNumOfExplicitAccesses)--;
    memmove(pDeletionPoint, pDeletionPoint + 1, sizeof(EXPLICIT_ACCESS_W) * (*pulNumOfExplicitAccesses - ulIndex));
}

void AddTrusteeToAccessRequestList
(
TRUSTEE_RECORD    *pTrusteeRecord,
PACCESS_REQUEST_W pAccessRequestList,
ULONG             *pulNumOfAccessRequests
)
{
    PACCESS_REQUEST_W pInsertionPoint;

    pInsertionPoint = pAccessRequestList + *pulNumOfAccessRequests;

    pInsertionPoint->grfAccessPermissions = pTrusteeRecord->grfAccessPermissions;
    MapTrusteeRecordToTrustee(pTrusteeRecord, &(pInsertionPoint->Trustee));
    (*pulNumOfAccessRequests)++;

}

void DeleteTrusteeFromAccessRequestList
(
ULONG             ulIndex,
PACCESS_REQUEST_W pAccessRequestList,
ULONG             *pulNumOfAccessRequests
)
{
    PACCESS_REQUEST_W pDeletionPoint;
    pDeletionPoint = pAccessRequestList + ulIndex;

    if (ulIndex >= *pulNumOfAccessRequests)
    {
        return;
    }

    midl_user_free(pDeletionPoint->Trustee.ptstrName);
    (*pulNumOfAccessRequests)--;

    memmove(pDeletionPoint, pDeletionPoint + 1, sizeof(ACCESS_REQUEST_W) * (*pulNumOfAccessRequests - ulIndex));
}

void MapTrusteeRecordToTrustee
(
TRUSTEE_RECORD *pTrusteeRecord,
TRUSTEE_W      *pTrustee
)
{
    ULONG ulTrusteeNameLength;
    pTrustee->pMultipleTrustee = pTrusteeRecord->pMultipleTrustee;
    pTrustee->MultipleTrusteeOperation = pTrusteeRecord->MultipleTrusteeOperation;
    pTrustee->TrusteeForm = pTrusteeRecord->TrusteeForm;
    pTrustee->TrusteeType = pTrusteeRecord->TrusteeType;
    switch(pTrusteeRecord->TrusteeForm)
    {
        case TRUSTEE_IS_SID:
            if(pTrusteeRecord->pSID== NULL)
            {
                pTrustee->ptstrName = NULL;
            }
            else
            {
                ulTrusteeNameLength = GetSidLengthRequired(pTrusteeRecord->pSID->SubAuthorityCount);
                pTrustee->ptstrName = (LPWSTR)midl_user_allocate(ulTrusteeNameLength);
                CopySid(ulTrusteeNameLength, (PSID)(pTrustee->ptstrName), pTrusteeRecord->pSID);
            }
            break;
        case TRUSTEE_IS_NAME:
            if (pTrusteeRecord->pwszTrusteeName == NULL)
            {
                pTrustee->ptstrName = NULL;
            }
            else
            {
                ulTrusteeNameLength = lstrlenW(pTrusteeRecord->pwszTrusteeName);
                pTrustee->ptstrName = (LPWSTR)midl_user_allocate((ulTrusteeNameLength + 1) * sizeof(WCHAR));
                lstrcpyW(pTrustee->ptstrName, pTrusteeRecord->pwszTrusteeName);
            }
            break;
    }
}

void AddTrusteeToTrusteeList
(
TRUSTEE_RECORD *pTrusteeRecord,
TRUSTEE_W      *pTrusteeList,
ULONG          *pulNumOfTrustees
)
{
    TRUSTEE_W *pInsertionPoint;

    pInsertionPoint = pTrusteeList + *pulNumOfTrustees;

    MapTrusteeRecordToTrustee(pTrusteeRecord, pInsertionPoint);
    (*pulNumOfTrustees)++;

}

void DeleteTrusteeFromTrusteeList
(
ULONG            ulIndex,
TRUSTEE_W        *pTrusteeList,
ULONG            *pulNumOfTrustees
)
{
    TRUSTEE_W *pDeletionPoint;
    pDeletionPoint = pTrusteeList + ulIndex;

    if (ulIndex >= *pulNumOfTrustees)
    {
        return;
    }

    midl_user_free(pDeletionPoint->ptstrName);
    (*pulNumOfTrustees)--;

    memmove(pDeletionPoint, pDeletionPoint + 1, sizeof(TRUSTEE_W) * (*pulNumOfTrustees - ulIndex));
}

void DestroyAccessRequestList
(
PACCESS_REQUEST_W pAccessRequestList,
ULONG             *pulNumOfAccessRequests
)
{
    ULONG i;
    PACCESS_REQUEST_W pAccessRequestListPtr;

    for ( i = 0, pAccessRequestListPtr = pAccessRequestList
        ; i < *pulNumOfAccessRequests
        ; i++, pAccessRequestListPtr++)
    {
        midl_user_free(pAccessRequestListPtr->Trustee.ptstrName);
    }
    *pulNumOfAccessRequests = 0;

}

void DestroyTrusteeList
(
TRUSTEE_W *pTrusteeList,
ULONG     *pulNumOfTrustees
)
{
    ULONG i;
    TRUSTEE_W *pTrusteeListPtr;

    for ( i = 0, pTrusteeListPtr = pTrusteeList
        ; i < *pulNumOfTrustees
        ; i++, pTrusteeListPtr++)
    {
        midl_user_free(pTrusteeListPtr->ptstrName);
    }
    *pulNumOfTrustees = 0;
}

void DestroyExplicitAccessList
(
PEXPLICIT_ACCESS_W pExplicitAccessList,
ULONG              *pulNumOfExplicitAccesses
)
{
    ReleaseExplicitAccessList(*pulNumOfExplicitAccesses, pExplicitAccessList);
    *pulNumOfExplicitAccesses = 0;
}


/*

Function: PrintEnvironment

Parameter: none

Return: void

Purpose: This function prints out the current setting of the
         client side global varibles.

*/

void PrintEnvironment
(
void
)
{
    printf("Local access request list:\n");
    DumpAccessRequestList(g_ulNumOfLocalAccessRequests, g_pLocalAccessRequestList);
    printf("Local explicit access list:\n");
    DumpExplicitAccessList(g_ulNumOfLocalExplicitAccesses, g_pLocalExplicitAccessList);
    printf("Local trustee list:\n");
    DumpTrusteeList(g_ulNumOfLocalTrustees, g_pLocalTrusteeList);
    printf("The explicit access list returned form the last call to GetExplicitAccessRights:\n");
    DumpExplicitAccessList(g_ulNumOfExplicitAccessesReturned, g_pReturnedExplicitAccessList);
    printf("Current trustee record:\n");
    DumpTrusteeRecord(&g_LocalTrusteeRecord);

} // PrintEnvironment

void DumpTrusteeRecord
(
TRUSTEE_RECORD *pTrusteeRecord
)
{
    CHAR  pszTrusteeName[200];
    ULONG ulStrLen;

    printf("Access permissions:\n");
    DumpAccessPermissions(pTrusteeRecord->grfAccessPermissions);
    printf("Access mode: ");
    DumpAccessMode(pTrusteeRecord->grfAccessMode);
    printf("Inheritance: ");
    DumpInheritance(pTrusteeRecord->grfInheritance);
    printf("pMultipleTrustree is ");
    if(pTrusteeRecord->pMultipleTrustee == NULL)
    {
        printf("NULL.\n");
    }
    else
    {
        printf("non-NULL.\n");
    }
    printf("MultipleTrusteeOperation: ");
    DumpMultipleTrusteeOperation(pTrusteeRecord->MultipleTrusteeOperation);
    printf("TrusteeForm: ");
    DumpTrusteeForm(pTrusteeRecord->TrusteeForm);
    printf("TrusteeType: ");
    DumpTrusteeType(pTrusteeRecord->TrusteeType);

    if (pTrusteeRecord->pwszTrusteeName == NULL)
    {
        strcpy(pszTrusteeName, "<NULL>");

    }
    else
    {
        ulStrLen = WideCharToMultiByte( CP_ACP
                                      , 0
                                      , pTrusteeRecord->pwszTrusteeName
                                      , -1
                                      , pszTrusteeName
                                      , 200
                                      , NULL
                                      , NULL );
    }
    printf("Trustee's name: %s\n", pszTrusteeName);


    printf("Trustee's SID: \n");
    DumpSID(pTrusteeRecord->pSID);
    printf("\n");
}


void DumpAccessRequestList
(
ULONG            ulNumOfEntries,
ACCESS_REQUEST_W pAccessRequestList[]
)
{
    ULONG i;
    PACCESS_REQUEST_W pLocalAccessRequestListPtr;

    for (i = 0, pLocalAccessRequestListPtr = pAccessRequestList; i < ulNumOfEntries; i++, pLocalAccessRequestListPtr++)
    {
        printf("Access request #%d:\n\n", i);
        printf("Access permissions: ");
        DumpAccessPermissions(pLocalAccessRequestListPtr->grfAccessPermissions);
        printf("Trustee: \n");
        DumpTrustee(&(pLocalAccessRequestListPtr->Trustee));
        printf("\n");
    }
}



/*

Function: DumpLocalExplicitAccessList

Parameters: ULONG              ulNumOfEntries - Number of EXPLICIT_ACCESS structures in the array
            EXPLICIT_ACCESS_W  pExplicitAccessList - Pointer to an array of EXPLICIT_ACCESS structures to be printed
                                                     to be printed to the console.
Purpose: This function prints an array of explicit access structures to the console

*/
void DumpExplicitAccessList
(
ULONG              ulNumOfEntries,
EXPLICIT_ACCESS_W  pExplicitAccessList[]
)
{
    ULONG i;                                       // Loop counter
    EXPLICIT_ACCESS_W *pLocalExplicitAccessListPtr; // Local pointer for stepping through the explicit access list

    for (pLocalExplicitAccessListPtr = pExplicitAccessList, i = 0; i < ulNumOfEntries; i++, pLocalExplicitAccessListPtr++)
    {
       printf("Entry #%d.\n\n", i);
       printf("Access permissions:\n");
       DumpAccessPermissions(pLocalExplicitAccessListPtr->grfAccessPermissions);
       printf("Access mode: ");
       DumpAccessMode(pLocalExplicitAccessListPtr->grfAccessMode);
       printf("Inheritance: ");
       DumpInheritance(pLocalExplicitAccessListPtr->grfInheritance);
       printf("Trustee:\n");
       DumpTrustee(&(pLocalExplicitAccessListPtr->Trustee));
       printf("End Of entry #%d.\n\n", i);
    } // for
} // DumpLocalExplicitAccessList

void DumpAccessPermissions
(
DWORD grfAccessPermissions
)
{
    if(grfAccessPermissions & COM_RIGHTS_EXECUTE)
    {
        printf("COM_RIGHTS_EXECUTE\n");
    }
    if(grfAccessPermissions & BOGUS_ACCESS_RIGHT1)
    {
        printf("BOGUS_ACCESS_RIGHT1\n");
    }
    if(grfAccessPermissions & BOGUS_ACCESS_RIGHT2)
    {
        printf("BOGUS_ACCESS_RIGHT2\n");
    }
    if(grfAccessPermissions & BOGUS_ACCESS_RIGHT3)
    {
        printf("BOGUS_ACCESS_RIGHT3\n");
    }
    if(grfAccessPermissions & BOGUS_ACCESS_RIGHT4)
    {
        printf("BOGUS_ACCESS_RIGHT4\n");
    }
}

DWORD StringToAccessPermission
(
CHAR *pszString
)
{
    if (strcmp(pszString, "com_rights_execute") == 0)
    {
        return COM_RIGHTS_EXECUTE;
    }
    if (strcmp(pszString, "bogus_access_right1") == 0)
    {
        return BOGUS_ACCESS_RIGHT1;
    }
    if (strcmp(pszString, "bogus_access_right2") == 0)
    {
        return BOGUS_ACCESS_RIGHT2;
    }
    if (strcmp(pszString, "bogus_access_right3") == 0)
    {
        return BOGUS_ACCESS_RIGHT3;
    }
    if (strcmp(pszString, "bogus_access_right4") == 0)
    {
        return BOGUS_ACCESS_RIGHT4;
    }
    return 0;
}

void DumpAccessMode
(
ACCESS_MODE grfAccessMode
)
{
    switch(grfAccessMode)
    {
        case NOT_USED_ACCESS:
            printf("NOT_USED_ACCESS\n");
            break;
        case GRANT_ACCESS:
            printf("GRANT_ACCESS\n");
            break;
        case DENY_ACCESS:
            printf("DENY_ACCESS\n");
            break;
        case SET_ACCESS:
            printf("SET_ACCESS\n");
            break;
        case REVOKE_ACCESS:
            printf("REVOKE_ACCESS\n");
            break;
        case SET_AUDIT_SUCCESS:
            printf("SET_AUDIT_SUCCESS\n");
            break;
        case SET_AUDIT_FAILURE:
            printf("SET_AUDIT_FAILURE\n");
            break;
    } // switch
} // DumpAccessMode

void DumpTrusteeList
(
ULONG ulNumOfTrustees,
TRUSTEE_W pTrusteeList[]
)
{
    ULONG       i;
    PTRUSTEE_W  pTrusteeListPtr;

    for( i = 0, pTrusteeListPtr = pTrusteeList
       ; i < ulNumOfTrustees
       ; i++, pTrusteeListPtr++)
    {
        printf("Trustee #%d:\n", i);
        DumpTrustee(pTrusteeListPtr);
        printf("\n");
    }
}

void DumpTrustee
(
TRUSTEE_W *pTrustee
)
{
    char  pszTrusteeName[256];
    ULONG ulStrLen;

    printf("pMultipleTrustee is ");
    if(pTrustee->pMultipleTrustee == NULL)
    {
        printf("NULL.\n");
    }
    else
    {
        printf("non-NULL.\n");
    }
    printf("MultipleTrusteeOperation: ");
    DumpMultipleTrusteeOperation(pTrustee->MultipleTrusteeOperation);
    printf("TrusteeForm: ");
    DumpTrusteeForm(pTrustee->TrusteeForm);
    printf("TrusteeType: ");
    DumpTrusteeType(pTrustee->TrusteeType);

    switch(pTrustee->TrusteeForm)
    {
        case TRUSTEE_IS_NAME:
            if (pTrustee->ptstrName == NULL)
            {
                strcpy(pszTrusteeName, "<NULL>");
            }
            else
            {
                ulStrLen = WideCharToMultiByte( CP_ACP
                                              , 0
                                              , pTrustee->ptstrName
                                              , -1
                                              , pszTrusteeName
                                              , 256
                                              , NULL
                                              , NULL );

                pszTrusteeName[ulStrLen] = '\0';
            }
            printf("Trustee's name is: %s\n", pszTrusteeName);
            break;
        case TRUSTEE_IS_SID:
            printf("Trustee's SID is:\n");
            DumpSID((PISID)(pTrustee->ptstrName));
            break;
    } // switch
}

void DumpMultipleTrusteeOperation
(
MULTIPLE_TRUSTEE_OPERATION MultipleTrusteeOperation
)
{
    switch(MultipleTrusteeOperation)
    {
        case NO_MULTIPLE_TRUSTEE:
            printf("NO_MULTIPLE_TRUSTEE\n");
            break;
        case TRUSTEE_IS_IMPERSONATE:
            printf("TRUSTEE_IS_IMPERSONATE\n");
            break;
    }
}

MULTIPLE_TRUSTEE_OPERATION StringToMultipleTrusteeOperation
(
CHAR *pszString
)
{
    if(strcmp(pszString, "no_multiple_trustee") == 0)
    {
        return NO_MULTIPLE_TRUSTEE;
    }
    if(strcmp(pszString, "trustee_is_impersonate") == 0)
    {
        return TRUSTEE_IS_IMPERSONATE;
    }
    return NO_MULTIPLE_TRUSTEE;

}

void DumpTrusteeType
(
TRUSTEE_TYPE TrusteeType
)
{
    switch (TrusteeType)
    {
        case TRUSTEE_IS_UNKNOWN:
            printf("TRUSTEE_IS_UNKNOWN\n");
            break;
        case TRUSTEE_IS_USER:
            printf("TRUSTEE_IS_USER\n");
            break;
        case TRUSTEE_IS_GROUP:
            printf("TRSUTEE_IS_GROUP\n");
            break;

    }
}

TRUSTEE_TYPE StringToTrusteeType
(
CHAR *pszString
)
{
    if(strcmp(pszString, "trustee_is_unknown") == 0)
    {
        return TRUSTEE_IS_UNKNOWN;
    }
    if(strcmp(pszString, "trustee_is_user") == 0)
    {
        return TRUSTEE_IS_USER;
    }
    if(strcmp(pszString, "trustee_is_group") == 0)
    {
        return TRUSTEE_IS_GROUP;
    }
    return TRUSTEE_IS_UNKNOWN;
}

void DumpTrusteeForm
(
TRUSTEE_FORM TrusteeForm
)
{
    switch (TrusteeForm)
    {
        case TRUSTEE_IS_NAME:
            printf("TRUSTEE_IS_NAME\n");
            break;
        case TRUSTEE_IS_SID:
            printf("TRUSTEE_IS_SID\n");
            break;
    }
}

TRUSTEE_FORM StringToTrusteeForm
(
CHAR *pszString
)
{
    if (strcmp(pszString, "trustee_is_name") == 0)
    {
        return TRUSTEE_IS_NAME;
    }
    if (strcmp(pszString, "trustee_is_sid") == 0)
    {
        return TRUSTEE_IS_SID;
    }
    return TRUSTEE_IS_NAME;
}



void DumpSID
(
PISID pSID
)
{
    ULONG i;
    if( pSID == NULL)
    {
        printf("<NULL>\n");
    }
    else
    {

        printf("Revision: %d\n", pSID->Revision);
        printf("SubAuthorityCount: %d\n", pSID->SubAuthorityCount);
        printf("IdentifierAuthority: {%d,%d,%d,%d,%d,%d}\n", (pSID->IdentifierAuthority.Value)[0]
                                                           , (pSID->IdentifierAuthority.Value)[1]
                                                           , (pSID->IdentifierAuthority.Value)[2]
                                                           , (pSID->IdentifierAuthority.Value)[3]
                                                           , (pSID->IdentifierAuthority.Value)[4]
                                                           , (pSID->IdentifierAuthority.Value)[5] );
        printf("SubAuthorities:\n");
        for (i = 0; i < pSID->SubAuthorityCount; i++)
        {
            printf("%d\n", pSID->SubAuthority[i]);
        }
    }

}

ACCESS_MODE StringToAccessMode
(
CHAR *pszString
)
{
    if(strcmp(pszString, "not_use_access") == 0)
    {
        return NOT_USED_ACCESS;
    }
    if(strcmp(pszString, "grant_access") == 0)
    {
        return GRANT_ACCESS;
    }
    if(strcmp(pszString, "set_access") == 0)
    {
        return SET_ACCESS;
    }
    if(strcmp(pszString, "deny_access") == 0)
    {
        return DENY_ACCESS;
    }
    if(strcmp(pszString, "revoke_access") == 0)
    {
        return REVOKE_ACCESS;
    }
    if(strcmp(pszString, "set_audit_success") == 0)
    {
        return SET_AUDIT_SUCCESS;
    }
    if(strcmp(pszString, "set_audit_failure") == 0)
    {
        return SET_AUDIT_FAILURE;
    }
    return NOT_USED_ACCESS;

}

void DumpInheritance
(
DWORD grfInheritance
)
{
    switch(grfInheritance)
    {
        case NO_INHERITANCE:
            printf("NO_INHERITANCE\n");
            break;
        case SUB_CONTAINERS_ONLY_INHERIT:
            printf("SUB_CONTAINERS_ONLY_INHERIT\n");
            break;
        case SUB_OBJECTS_ONLY_INHERIT:
            printf("SUB_OBJECTS_ONLY_INHERIT\n");
            break;
        case SUB_CONTAINERS_AND_OBJECTS_INHERIT:
            printf("SUB_CONTAINERS_AND_OBJECTS_INHERIT\n");
            break;
    }
}

DWORD StringToInheritance
(
CHAR *pszString
)
{
    if (strcmp(pszString, "no_inheritance") == 0)
    {
        return NO_INHERITANCE;
    }
    if (strcmp(pszString, "sub_containers_only_inherit") == 0)
    {
        return SUB_CONTAINERS_ONLY_INHERIT;
    }
    if (strcmp(pszString, "sub_objects_only_inherit") == 0)
    {
        return SUB_OBJECTS_ONLY_INHERIT;
    }
    if (strcmp(pszString, "sub_containers_and_objects_inherit") == 0)
    {
        return SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    }
    return 0;
}

void ReleaseExplicitAccessList
(
ULONG              cCount,
PEXPLICIT_ACCESS_W pExplicitAccessList
)
{
    ULONG i;

    for (i = 0; i < cCount; i++)
    {
        midl_user_free(pExplicitAccessList[i].Trustee.ptstrName);
    }
    if(pExplicitAccessList != g_pLocalExplicitAccessList)
    {
        midl_user_free(pExplicitAccessList);
    }

}


void CopyExplicitAccessList
(
PEXPLICIT_ACCESS_W pTarget,
PEXPLICIT_ACCESS_W pSource,
ULONG              *pcCount,
ULONG              cCount
)
{
    ULONG i;
    PEXPLICIT_ACCESS_W pTargetPtr;
    PEXPLICIT_ACCESS_W pSourcePtr;
    ULONG ulTrusteeNameSize;


    for ( i = 0, pTargetPtr = pTarget, pSourcePtr = pSource
        ; i < cCount
        ; i++, pTargetPtr++, pSourcePtr++)
    {
        memcpy(pTargetPtr, pSourcePtr, sizeof(EXPLICIT_ACCESS));
        switch(pTargetPtr->Trustee.TrusteeForm)
        {
            case TRUSTEE_IS_SID:
                ulTrusteeNameSize = GetSidLengthRequired(((PISID)(pTargetPtr->Trustee.ptstrName))->SubAuthorityCount);
                pTargetPtr->Trustee.ptstrName = (LPWSTR)midl_user_allocate(ulTrusteeNameSize);
                CopySid(ulTrusteeNameSize, (PISID)(pTargetPtr->Trustee.ptstrName), (PISID)(pSourcePtr->Trustee.ptstrName));
                break;
            case TRUSTEE_IS_NAME:
                ulTrusteeNameSize = lstrlenW(pSourcePtr->Trustee.ptstrName);
                pTargetPtr->Trustee.ptstrName = (LPWSTR)midl_user_allocate((ulTrusteeNameSize + 1) * sizeof(WCHAR));
                lstrcpyW(pTargetPtr->Trustee.ptstrName, pSourcePtr->Trustee.ptstrName);
                break;
        }
    }
    *pcCount = cCount;

}

void ExecTestServer
(
CHAR *pszTestString
)
{
    ULONG ulCode;
    HRESULT hr;


    printf("Calling TestServer.\n");
    g_pIAccessControlTest->TestServer(pszTestString);


} // ExecTestServer

void ExecRevertAccessRights
(
void
)
{
    ULONG ulCode;
    HRESULT hr;

    printf("Calling RevertAccessRights.\n");
    hr = g_pIAccessControlTest->RevertAccessRights();

    if(hr == E_NOTIMPL)
    {
        printf("hr is E_NOTIMPL.\n");
    }
} // ExecRevertAccessRights

void ExecCommitAccessRights
(
void
)
{
    ULONG ulCode;
    HRESULT hr;

    printf("Calling CommitAccessRights.\n");
    hr = g_pIAccessControlTest->CommitAccessRights(0);

    if(hr == E_NOTIMPL)
    {
        printf("hr is E_NOTIMPL.\n");
    }
} // ExecCommitAccessRights

void ExecGetClassID
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    CLSID    clsid;
    HRESULT  hr;


    printf("Calling GetClassID.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->GetClassID(&clsid, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
        printf("The clsid returned is {%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}.\n"
                , clsid.Data1, clsid.Data2, clsid.Data3
                , clsid.Data4[0], clsid.Data4[1], clsid.Data4[2]
                , clsid.Data4[3], clsid.Data4[4], clsid.Data4[5]
                , clsid.Data4[6], clsid.Data4[7]);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if


    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecGetSizeMax

void ExecInitNewACL
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;


    printf("Calling InitNewACL.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->InitNewACL(&dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecInitNewACL

void ExecLoadACL
(
CHAR *pszFilename
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling LoadACL.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->LoadACL(pszFilename, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecLoadACL

void ExecSaveACL
(
CHAR *pszFilename
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    ULONG    ulNumOfBytesWritten;
    HRESULT  hr;


    printf("Calling SaveACL.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->SaveACL(pszFilename, TRUE, &ulNumOfBytesWritten, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The number of bytes written to the file was %d\n", ulNumOfBytesWritten);
    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecSaveACL

void ExecGetSizeMax
(
void
)
{
    ULONG    ulCode;
    DWORD    dwTotalTickCount;
    DOUBLE   dMillisec;
    ULONG    ulNumOfBytesRequired;
    HRESULT  hr;

    printf("Calling GetSizeMax.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->GetSizeMax(&ulNumOfBytesRequired, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The number of bytes required to save the ACL was %d\n", ulNumOfBytesRequired);
    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecGetSizeMax

void ExecIsDirty
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling IsDirty.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->IsDirty(&dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
        if(hr == S_OK)
        {
            printf("The access control object was dirty.\n");
        }
        else
        {
            printf("The access control object was clean.\n");
        }
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecIsDirty

void ExecGrantAccessRights
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling GrantAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->GrantAccessRights(g_ulNumOfLocalAccessRequests, (PE_ACCESS_REQUEST)(g_pLocalAccessRequestList), &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecGrantAccessRights

void ExecSetAccessRights
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling SetAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->SetAccessRights(g_ulNumOfLocalAccessRequests, (PE_ACCESS_REQUEST)g_pLocalAccessRequestList, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecSetAccessRights

void ExecDenyAccessRights
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling DenyAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->DenyAccessRights(g_ulNumOfLocalAccessRequests, (PE_ACCESS_REQUEST)g_pLocalAccessRequestList, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecDenyAccessRights

void ExecReplaceAllAccessRights
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling ReplaceAllAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->ReplaceAllAccessRights(g_ulNumOfLocalExplicitAccesses, (PE_EXPLICIT_ACCESS)g_pLocalExplicitAccessList, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecReplaceAllAccessRights

void ExecRevokeExplicitAccessRights
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling RevokeExplicitAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->RevokeExplicitAccessRights(g_ulNumOfLocalTrustees, (PE_TRUSTEE)g_pLocalTrusteeList, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecRevokeExplicitAccessRights

void ExecIsAccessPermitted
(
void
)
{
    ULONG     ulCode;
    DOUBLE   dMillisec;
    DWORD     dwTotalTickCount;
    HRESULT   hr;
    TRUSTEE_W Trustee;

    MapTrusteeRecordToTrustee(&g_LocalTrusteeRecord, &Trustee);

    printf("Calling IsAccessPermitted.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->IsAccessPermitted((PE_TRUSTEE)&Trustee, g_LocalTrusteeRecord.grfAccessPermissions, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if (hr == S_OK)
    {
        printf("The current trustee is granted the current set of access rights.\n");
    }
    else if (hr == E_ACCESSDENIED)
    {
        printf("The current trustee is denied the current set of access rights.\n");
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecIsAccessPermitted

void ExecGetEffectiveAccessRights
(
void
)
{
    ULONG     ulCode;
    DOUBLE   dMillisec;
    DWORD     dwTotalTickCount;
    HRESULT   hr;
    TRUSTEE_W Trustee;
    DWORD     dwRights;

    MapTrusteeRecordToTrustee(&g_LocalTrusteeRecord, &Trustee);

    printf("Calling GetEffectiveAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->GetEffectiveAccessRights((PE_TRUSTEE)&Trustee, &dwRights, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
        printf("The set of effective access rights available to the current trustee includes:\n");
        DumpAccessPermissions(dwRights);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecGetEffectiveAccessRights

void ExecGetExplicitAccessRights
(
void
)
{
    ULONG     ulCode;
    DOUBLE   dMillisec;
    DWORD     dwTotalTickCount;
    HRESULT   hr;

    // If the global retruned explicit access list pointer is not NULL,
    // release the old returned explicit access list
    if (g_pReturnedExplicitAccessList != NULL)
    {
        ReleaseExplicitAccessList(g_ulNumOfExplicitAccessesReturned, g_pReturnedExplicitAccessList);

    } // if
    g_pReturnedExplicitAccessList = NULL;

    printf("Calling GetExplicitAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->GetExplicitAccessRights(&g_ulNumOfExplicitAccessesReturned, (PE_EXPLICIT_ACCESS *)&g_pReturnedExplicitAccessList, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
        printf("The number of explicit access structures returned is %d.\n", g_ulNumOfExplicitAccessesReturned);
        printf("The returned explicit access list is as follows:\n");
        DumpExplicitAccessList(g_ulNumOfExplicitAccessesReturned, g_pReturnedExplicitAccessList);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecGetExplicitAccessRights

void ExecCleanupProc
(
void
)
{
    ULONG ulCode;

    // Release the IAccessControlTest pointer
    g_pIAccessControlTest->Release();
    g_pIUnknown->Release();

    // Cleanup all the memory allocated for the Local list
    DestroyAccessRequestList(g_pLocalAccessRequestList, &g_ulNumOfLocalAccessRequests);
    DestroyTrusteeList(g_pLocalTrusteeList, &g_ulNumOfLocalTrustees);
    DestroyExplicitAccessList(g_pLocalExplicitAccessList, &g_ulNumOfLocalExplicitAccesses);
    DestroyExplicitAccessList(g_pReturnedExplicitAccessList, &g_ulNumOfExplicitAccessesReturned);

} // ExecCleanupProc

/*

Function: Tokenize
Parameters: [in]  char      *pLineBuffer
            [out] char      *pTokens[]
            [out] short     *piNumOfTokens

Return:  void

Purpose: This function partition a string of space delimited tokens
         to null delimited tokens and return pointers to each individual
         token in pTokens and the number of tokens ion the string in
         piNumOfTokens.

Comment: Memory for the array of char * Tokens should be allocated by
         the caller.

         This function is implemented as a simple finite state machine.
         State 0 - Outside a token
         State 1 - Inside a token

*/

void Tokenize
(
char * pLineBuffer,
char * pTokens[],
short * piNumOfTokens
)
{
  short iTokens = 0;        // Token index
  char  *pLBuffPtr = pLineBuffer; // Pointer in the line buffer
  char  c; // current character
  short state = 0; // State of the tokenizing machine

  for(;;)
  {
    c = *pLBuffPtr;

    switch(state)
    {
    case 0:
      switch(c)
      {
        case '\t': // Ignore blanks
        case ' ':
        case '\n':
          break;
        case '\0':
          goto end;
        default:
          state=1;
          pTokens[iTokens]=pLBuffPtr;
          break;
      } // switch
      break;
    case 1:
      switch(c)
      {
        case '\t':
        case ' ':
        case '\n':
          *pLBuffPtr='\0';
          iTokens++;
          state=0;
          break;
        case '\0':
          *pLBuffPtr='\0';
          iTokens++;
          pTokens[iTokens]=pLBuffPtr;
          goto end;
        default:
          break;
      }
      break;
    }
    pLBuffPtr++;
  }// switch
  end:
  *piNumOfTokens = iTokens;
  return;
} // Tokenize

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void  __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(CoTaskMemAlloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    CoTaskMemFree(ptr);
}

/* end file actestc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\accctrl\idl\makefile.inc ===
!ifndef MIDL
MIDL = midl.exe
!endif


MIDL_FLAGS= \
        -Zp8 \
        -Oicf \
        -char unsigned \
        -error allocation \
        -error bounds_check \
        -error stub_data \
!ifdef TARGET_CPP        
        -cpp_cmd $(TARGET_CPP) \
!endif
        -DMIDL_PASS

..\h\actest.h ..\client\actest_c.c ..\server\actest_s.c: actest.idl actest.acf
        $(MIDL) $(MIDL_FLAGS) -sstub ..\server\actest_s.c  -header ..\h\actest.h -cstub ..\client\actest_c.c actest.idl

oactest_i.c oactest_p.c dlldata.c: oactest.idl
        $(MIDL) $(MIDL_FLAGS) oactest.idl
        mv oactest.h ..\h
allps: ..\h\actest.h  ..\client\actest_c.c ..\server\actest_s.c oactest_p.c oactest_i.c dlldata.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\accctrl\server\daytona\makefile.inc ===
DEST_TREE=chicago

!include ..\makeidl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\accctrl\server\oactestp.cxx ===
/****************************************************************************

    FILE:       actestp.c

    PURPOSE:    
                
    FUNCTIONS:  
    COMMENTS:

****************************************************************************/

#include <windows.h>
#include <ole2.h>
#include <oleext.h> // IAccessControl interface definition
#include <wchar.h>
#include <tchar.h>

#include <stdlib.h>
#include <stdio.h>
#include "oactest.h"    // header file generated by MIDL compiler

void DecrementLockCount();
void IncrementLockCount();
void ObjectCreated();
void ObjectDestroyed();

const CLSID CLSID_COAccessControl_DCOM
    = {0x52c0e9e1,0xc0c0,0x11cf,{0xae,0xec,0x00,0xaa,0x00,0x44,0xfb,0x89}};

extern "C" const CLSID CLSID_COAccessControlTest;
extern ULONG g_ulFrequency;
DWORD g_dwRegister;
long  g_fClassRegistered = FALSE;

// IAccessControlTest implementation class
class CAccessControlTest : public IAccessControlTest
{
private:
    IUnknown         *m_pIUnknown;
    IPersistStream   *m_pIPersistStream;
    IAccessControl   *m_pIAccessControl;
    ULONG            m_cRef;
    BOOL             m_bInitialized;

    // destructor
    ~CAccessControlTest()
    {
        DecrementLockCount();
        ObjectDestroyed();
    }


public:
    
    // contructor
    CAccessControlTest()
    {
        m_cRef = 0;
        m_bInitialized = FALSE;
        ObjectCreated();
        IncrementLockCount();
    }


    STDMETHODIMP_(HRESULT) QueryInterface
    (
    REFIID iid,
    void **ppv
    );

    STDMETHODIMP_(ULONG) AddRef();

    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP_(HRESULT) TestServer
    (
    LPSTR pszTestString
    );

    STDMETHODIMP_(HRESULT) GetClassID
    (
    CLSID   *pClassID,
    DOUBLE  *pdMillisec
    );

    STDMETHODIMP_(HRESULT) InitNewACL
    (
    DOUBLE*pdMillisec
    );

    STDMETHODIMP_(HRESULT) LoadACL
    (
    LPCSTR  pszFilename,
    DOUBLE  *pdMillisec
    );

    STDMETHODIMP_(HRESULT) SaveACL
    (
    LPCSTR  pszFilename,
    BOOL    fClearDirty,
    ULONG   *pulBytesWritten,
    DOUBLE  *pdMillisec
    );

    STDMETHODIMP_(HRESULT) GetSizeMax
    (
    ULONG           *pcdSize,
    DOUBLE          *pdMillisec
    );

    STDMETHODIMP_(HRESULT) IsDirty
    (
    DOUBLE  *pdMillisec
    );

    STDMETHODIMP_(HRESULT) GrantAccessRights
    (
    ULONG            cCount,
    E_ACCESS_REQUEST *pAccessRequestList,
    DOUBLE           *pdMillisec
    );

    STDMETHODIMP_(HRESULT) DenyAccessRights
    (
    ULONG            cCount,
    E_ACCESS_REQUEST pAccessRequestList[],
    DOUBLE           *pdMillisec
    );

    STDMETHODIMP_(HRESULT) SetAccessRights
    (
    ULONG            cCount,
    E_ACCESS_REQUEST pAccessRequestList[],
    DOUBLE           *pdMillisec
    );

    STDMETHODIMP_(HRESULT) ReplaceAllAccessRights
    (
    ULONG             cCount,
    E_EXPLICIT_ACCESS pExplicitAccessList[],
    DOUBLE            *pdMillisec
    );

    STDMETHODIMP_(HRESULT) RevokeExplicitAccessRights
    (
    ULONG      cCount,
    E_TRUSTEE  pTrustee[],
    DOUBLE     *pdMillisec
    );

    STDMETHODIMP_(HRESULT) IsAccessPermitted
    (
    E_TRUSTEE   *pTrustee,
    DWORD       grfAccessPermissions,
    DOUBLE      *pdMillisec 
    );

    STDMETHODIMP_(HRESULT) GetEffectiveAccessRights
    (
    E_TRUSTEE   *pTrustee,  
    DWORD       *pdwRights,
    DOUBLE      *pdMillisec
    );

    STDMETHODIMP_(HRESULT) GetExplicitAccessRights
    (
    ULONG               *pcCount,
    PE_EXPLICIT_ACCESS  *ppExplicitAccessList,
    DOUBLE              *pdMillisec
    );

    STDMETHODIMP_(HRESULT) RevertAccessRights
    (
    );

    STDMETHODIMP_(HRESULT) CommitAccessRights
    (
    DWORD   grfCommitFlags
    );

}; // CAccessControlTest

//+-------------------------------------------------------------------------
//
//  Method:     CAccessControlTest::AddRef, public
//
//  Synopsis:   Increment reference count
//
//  See Also:   IUnknown::AddRef
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) 
CAccessControlTest::AddRef()
{
    InterlockedIncrement((long *) &m_cRef);
    return m_cRef;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAccessControlTest::Release, public
//
//  Synopsis:   Decrement DLL reference count
//
//  Notes:      After the m_cRef is decremented, the object may be 
//              deleted by another thread.  In order to make this code safe
//              for multiple threads, we have to access the object state 
//              before decrementing m_cRef.
//
//  See Also:   IUnknown::Release.
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAccessControlTest::Release()
{
    unsigned long count;
    
    count = m_cRef - 1;

    if(InterlockedDecrement((long *) &m_cRef) == 0)
    {
        count = 0;
        if(m_bInitialized)
        {
            m_pIUnknown->Release();
            m_pIPersistStream->Release();
            m_pIAccessControl->Release();
        }
        delete this;
    }

    return count;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAccessControlTest::QueryInterface, public
//
//  Synopsis:   Query for an interface on the class factory.
//
//  See Also:   IUnknown:QueryInterface
//
//--------------------------------------------------------------------------
STDMETHODIMP_(HRESULT)
CAccessControlTest::QueryInterface
(
REFIID iid,
void **ppv
)
{
    HRESULT hr;

    if (!m_bInitialized)
    {
        hr = CoCreateInstance( CLSID_COAccessControl_DCOM
                             , NULL
                             , CLSCTX_INPROC_SERVER
                             , IID_IUnknown
                             , (void **)&m_pIUnknown);
        if(FAILED(hr))      
        {
            printf("Failed to create an instance of COAccessControl\n.");
            return hr;
        }

        hr = m_pIUnknown->QueryInterface(IID_IPersistStream, (void **)&m_pIPersistStream);

        if(FAILED(hr))      
        {
            printf("Failed to query for the IPersistStream Interface.\n");
            return hr;
        }
        hr = m_pIUnknown->QueryInterface(IID_IAccessControl, (void **)&m_pIAccessControl);

        if(FAILED(hr))
        {
            printf("Failed to query for the IAccessControl interface.\n");
            return hr;
        }
        m_bInitialized = TRUE;
    }


    if ( IsEqualGUID( iid, IID_IUnknown ) )
    {
        *ppv = (IUnknown *) this;
        ((IUnknown *)(*ppv))->AddRef();
	    hr = S_OK;
    }
    else if (IsEqualGUID( iid, IID_IAccessControlTest))
    {
        *ppv = (IUnknown *)(IAccessControlTest *)this;
        ((IAccessControlTest *)(*ppv))->AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::TestServer
(
LPSTR pszTestString
)
{
    printf("The test string is: %s\n", pszTestString);

    return S_OK;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::GetClassID
(
CLSID   *pClassID,
DOUBLE  *pdMillisec
)
{
    HRESULT    localhr;
    CLSID      clsid;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIPersistStream->GetClassID(&clsid);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pClassID = clsid;
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::InitNewACL
(
DOUBLE  *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIPersistStream->Load(NULL);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;

}

STDMETHODIMP_(HRESULT) CAccessControlTest::LoadACL
(
LPCSTR  pszFilename,
DOUBLE  *pdMillisec
)
{
    HRESULT    localhr;
    IStream    *pIStream = NULL;
    HANDLE     FileHandle;
    DWORD      dwFileSize;
    void       *pvBuffer;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    // Open the file specified by the client
    FileHandle = CreateFileA( pszFilename
                            , GENERIC_READ
                            , FILE_SHARE_READ | FILE_SHARE_WRITE
                            , NULL
                            , OPEN_EXISTING
                            , FILE_ATTRIBUTE_NORMAL
                            , NULL );

    if( FileHandle == INVALID_HANDLE_VALUE )
    {   
        printf("Cannot open file %s.\n", pszFilename);
        *pdMillisec = 0;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Get the size of the file
    dwFileSize = GetFileSize(FileHandle, NULL);

    // Create a buffer to hold the data in the file
    pvBuffer = CoTaskMemAlloc(dwFileSize);


    DWORD dwBytesRead;
    // Read the data of the opened file into a buffer
    if(!ReadFile( FileHandle
                , pvBuffer
                , dwFileSize
                , &dwBytesRead
                , NULL ))
    {
    
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Once we have read the file data into a buffer, we can
    // close the file handle
    CloseHandle( FileHandle);

    // Create a stream on the the buffer 
    localhr = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);

    if (FAILED(localhr))
    {
        printf("Cannot create stream object.\n");
        CoTaskMemFree(pvBuffer);
        *pdMillisec = 0;
        return localhr;
    }

    // Load the data in the buffer into the IStream object
    localhr = pIStream->Write(pvBuffer, dwFileSize, NULL);

    // Release the local buffer
    CoTaskMemFree(pvBuffer);


    if (FAILED(localhr))
    {
        printf("Failed to load data into stream object.\n");
        *pdMillisec = 0;
        return localhr;
    }

    // Rewind the stream pointer the starting position
    LARGE_INTEGER li;
    li.LowPart = 0;
    li.HighPart = 0;
    localhr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

    if (FAILED(localhr))
    {
        printf("Failed to set the stream pointer to the starting position.\n");
        *pdMillisec = 0;
        return localhr;
    }

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIPersistStream->Load(pIStream);
    QueryPerformanceCounter(&liCount2);
    

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;

    // Release the local stream pointer
    pIStream->Release();

    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::SaveACL
(
LPCSTR  pszFilename,
BOOL    fClearDirty,
ULONG   *pulNumOfBytesWritten,
DOUBLE  *pdMillisec
)
{
    HRESULT    localhr;
    IStream    *pIStream = NULL;
    HANDLE     FileHandle;
    DWORD      dwFileSize;
    void       *pvBuffer;
    STATSTG    StreamInfo;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    // Create a stream on the the buffer 
    localhr = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);

    if (FAILED(localhr))
    {
        printf("Cannot create stream object.\n");
        *pdMillisec = 0;
        return localhr;
    }

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIPersistStream->Save(pIStream, fClearDirty);
    QueryPerformanceCounter(&liCount2);

    if(FAILED(localhr))
    {
        *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
        return localhr;
    }

    // Get the number of bytes written to the stream
    localhr = pIStream->Stat(&StreamInfo, STATFLAG_NONAME);
    if (FAILED(localhr))
    {
        printf("Unable to get information about the local stream.\n");
        *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
        return localhr;
    }

    dwFileSize = StreamInfo.cbSize.LowPart;

    LARGE_INTEGER liOffset;

    liOffset.QuadPart = Int32x32To64(dwFileSize, -1);
    pIStream->Seek(liOffset,STREAM_SEEK_CUR, NULL);

    // Allocate a buffer to store the data in the stream
    pvBuffer = CoTaskMemAlloc(dwFileSize);

    // Write the stream
    localhr = pIStream->Read(pvBuffer, dwFileSize, NULL);

    if(FAILED(localhr))
    {
        printf("Unable to write data from stream to buffer.\n");
        CoTaskMemFree(pvBuffer);
        *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
        return localhr;
    }    

    // Open the file specified by the client
    FileHandle = CreateFileA( pszFilename
                            , GENERIC_WRITE | GENERIC_READ
                            , FILE_SHARE_READ | FILE_SHARE_WRITE
                            , NULL
                            , CREATE_ALWAYS
                            , FILE_ATTRIBUTE_NORMAL
                            , NULL );

    if( FileHandle == INVALID_HANDLE_VALUE )
    {   
        printf("Cannot open file %s.\n", pszFilename);
        CoTaskMemFree(pvBuffer);
        *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Read the data of the opened file into a buffer
    if(!WriteFile( FileHandle
                 , pvBuffer
                 , dwFileSize
                 , pulNumOfBytesWritten
                 , NULL ))
    {
        DWORD dwLastError;
        dwLastError = GetLastError();
        printf("Write failed with error code %x.", dwLastError);
    }

    // Flush the file buffers
    FlushFileBuffers(FileHandle);

    // Close the file handle
    CloseHandle(FileHandle);

    CoTaskMemFree(pvBuffer);


    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    *pulNumOfBytesWritten = dwFileSize;


    // Release the local stream pointer
    pIStream->Release();

    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::GetSizeMax
(
ULONG   *pcdSize,
DOUBLE  *pdMillisec
)
{
    ULARGE_INTEGER  uliSize;
    HRESULT         localhr;    
    
    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;


    QueryPerformanceCounter(&liCount1);
    localhr = m_pIPersistStream->GetSizeMax(&uliSize);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pcdSize = uliSize.LowPart;
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::IsDirty
(
DOUBLE  *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    
    QueryPerformanceCounter(&liCount1);
    localhr = m_pIPersistStream->IsDirty();
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;

    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::GrantAccessRights
(
ULONG            cCount,
E_ACCESS_REQUEST pAccessRequestList[],
DOUBLE           *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    
    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->GrantAccessRights(cCount, (ACCESS_REQUEST_W *)pAccessRequestList);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::SetAccessRights
(
ULONG            cCount,
E_ACCESS_REQUEST pAccessRequestList[],
DOUBLE           *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->SetAccessRights(cCount, (ACCESS_REQUEST_W *)pAccessRequestList);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::DenyAccessRights
(
ULONG            cCount,
E_ACCESS_REQUEST pAccessRequestList[],
DOUBLE           *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    
    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->DenyAccessRights(cCount, (ACCESS_REQUEST_W *)pAccessRequestList);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::ReplaceAllAccessRights
(
ULONG             cCount,
E_EXPLICIT_ACCESS pExplicitAccessList[],
DOUBLE            *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    
    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->ReplaceAllAccessRights(cCount, (EXPLICIT_ACCESS_W *)pExplicitAccessList);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::RevokeExplicitAccessRights
(
ULONG             cCount,
E_TRUSTEE         pTrustee[],
DOUBLE            *pdMillisec
)
{
    char       *pszClientName;
    RPC_STATUS status;
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->RevokeExplicitAccessRights(cCount, (TRUSTEE_W *)pTrustee);
    QueryPerformanceCounter(&liCount2);


    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::IsAccessPermitted
(
E_TRUSTEE         *pTrustee,
DWORD             grfAccessPermissions,
DOUBLE            *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->IsAccessPermitted((TRUSTEE_W *)pTrustee, grfAccessPermissions);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::GetEffectiveAccessRights
(
E_TRUSTEE         *pTrustee,
DWORD             *pdwRights,
DOUBLE            *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->GetEffectiveAccessRights((TRUSTEE_W *)pTrustee, pdwRights);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::GetExplicitAccessRights
(
ULONG              *pcCount,
PE_EXPLICIT_ACCESS *ppExplicitAccessList,
DOUBLE             *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->GetExplicitAccessRights(pcCount, (PEXPLICIT_ACCESS_W *)ppExplicitAccessList);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::RevertAccessRights
(
)
{
    return m_pIAccessControl->RevertAccessRights();

}


STDMETHODIMP_(HRESULT) CAccessControlTest::CommitAccessRights
(
DWORD   grfCommitFlags
)
{
    return m_pIAccessControl->CommitAccessRights(grfCommitFlags);
}

class CACTestClassFactory : public IClassFactory
{
private:
    unsigned long    m_cRef;

    //destructor
    ~CACTestClassFactory()
    {
        ObjectDestroyed();
    }

public:
    //constructor
    CACTestClassFactory()
    {
        m_cRef = 0;
        ObjectCreated();
    }

	HRESULT STDMETHODCALLTYPE QueryInterface(
		REFIID iid,
	    void **ppv);
	
	ULONG STDMETHODCALLTYPE AddRef();
	
	ULONG STDMETHODCALLTYPE Release();
	
	HRESULT STDMETHODCALLTYPE CreateInstance(
	    IUnknown *punkOuter,
	    REFIID riid,
	    void **ppv);

   HRESULT STDMETHODCALLTYPE LockServer(
        BOOL fLock );

};

//+-------------------------------------------------------------------------
//
//  Method:     CACTestClassFactory::AddRef, public
//
//  Synopsis:   Increment DLL reference counts
//
//  See Also:   IUnknown::AddRef
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE 
CACTestClassFactory::AddRef()
{
    InterlockedIncrement((long *) &m_cRef);
    return m_cRef;
}

//+-------------------------------------------------------------------------
//
//  Method:     CACTestClassFactory::CreateInstance, public
//
//  Synopsis:   Create an instance of CAccessControlTest.
//
//  See Also:   IClassFactory::CreateInstance
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CACTestClassFactory::CreateInstance
(
    IUnknown *punkOuter,
    REFIID riid,
    void **ppv
)
{
    HRESULT hr;
    CAccessControlTest *pACTest;

    if(punkOuter != 0)
    {
        //The CAccessControlTest class doesn't support aggregation.
        return CLASS_E_NOAGGREGATION;
    }

    pACTest = new CAccessControlTest();
    if(pACTest != 0)
    {
        hr = pACTest->QueryInterface(riid, ppv);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppv = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CACTestClassFactory::LockServer, public
//
//  Synopsis:   Lock the server in memory (by adding an extra reference)
//
//  Notes:      The class factory will be revoked when the lock count
//              is decremented to zero.  LockServer(TRUE) will increment the
//              lock count and ensure that the class factory will
//              not be revoked.
//
//  See Also:   IClassFactory::LockServer
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CACTestClassFactory::LockServer(
    BOOL fLock )
{
    if (fLock == TRUE)
        IncrementLockCount();
    else
        DecrementLockCount();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CACTestClassFactory::QueryInterface, public
//
//  Synopsis:   Query for an interface on the class factory.
//
//  See Also:   IUnknown::QueryInterface
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CACTestClassFactory::QueryInterface (
    REFIID iid,
    void **ppv )
{
    HRESULT hr;

    if ( IsEqualGUID( iid, IID_IUnknown) ||
         IsEqualGUID( iid, IID_IClassFactory ) )
    {
        *ppv = this;
        ((IUnknown *)(*ppv))->AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}
//+-------------------------------------------------------------------------
//
//  Method:     CACTestClassFactory::Release, public
//
//  Synopsis:   Decrement DLL reference count
//
//  See Also:   IUnknown::Release
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CACTestClassFactory::Release()
{
    unsigned long count;
    
    count = m_cRef - 1;

    if(InterlockedDecrement((long *) &m_cRef) == 0)
    {
        count = 0;
        delete this;
    }
    return count;
}

//+-------------------------------------------------------------------------
//
//  Function:   RegisterClassFactory.
//
//  Synopsis:   Register the class factory if it is not currently registered.
//
//--------------------------------------------------------------------------
HRESULT RegisterClassFactory()
{
    HRESULT hr;
    CACTestClassFactory *pClassFactory;

    if(InterlockedExchange(&g_fClassRegistered, TRUE) == FALSE)
    {
        pClassFactory = new CACTestClassFactory;
        
        if(pClassFactory != 0)
        {
            hr = CoRegisterClassObject(CLSID_COAccessControlTest,
	   	        		               (IUnknown *) pClassFactory,
	    	        	               CLSCTX_LOCAL_SERVER,
		    	                       REGCLS_MULTIPLEUSE,
			                           &g_dwRegister);
        }
        else
        {
           hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_OK;
    }
    return hr;  
}

//+-------------------------------------------------------------------------
//
//  Function:   RevokeClassFactory.
//
//  Synopsis:   Revoke the registered class factories if they have not
//              already been revoked.
//
//--------------------------------------------------------------------------
HRESULT RevokeClassFactory()
{
    HRESULT hr;

    if(InterlockedExchange(&g_fClassRegistered, FALSE) == TRUE)
    {
        hr = CoRevokeClassObject(g_dwRegister);
    }
    else
    {
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\acttest.h ===
/*
 *  acttest.h
 */

#ifndef _CLSID_
#define _CLSID_

#ifdef __cplusplus
extern "C"{
#endif

//
// Uncomment this define to make client and server free threaded.
//
#define FREETHREADED 

//
// Uncomment this define to enable the tests to run on the private
// rpcperf domain.
//
// #define USERPCPERFDOMAIN    

extern CLSID CLSID_ActLocal;
extern CLSID CLSID_ActRemote;
extern CLSID CLSID_ActAtStorage;
extern CLSID CLSID_ActInproc;
extern CLSID CLSID_ActPreConfig;
extern CLSID CLSID_ActRunAsLoggedOn;
extern CLSID CLSID_ActService;
extern CLSID CLSID_ActServerOnly;

extern TCHAR * ClsidGoober32String;
extern TCHAR * ClsidActLocalString;
extern TCHAR * ClsidActRemoteString;
extern TCHAR * ClsidActAtStorageString;
extern TCHAR * ClsidActInprocString;
extern TCHAR * ClsidActPreConfigString;
extern TCHAR * ClsidActRunAsLoggedOnString;
extern TCHAR * ClsidActServiceString;
extern TCHAR * ClsidActServerOnlyString;

void DeleteClsidKey( TCHAR * pwszClsid );

long SetAppIDSecurity( TCHAR * pszAppID );


int AddBatchPrivilege(const TCHAR *szUser);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\accctrl\server\chicago\makefile.inc ===
DEST_TREE=chicago

!include ..\makeidl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\client\pswrd.cxx ===
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}
#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>
#include <stdio.h>

BOOL SetPassword(TCHAR * szCID, TCHAR * pszPw)
{
#ifndef CHICO
    WCHAR * szPw = pszPw;
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    LSA_HANDLE hPolicy;
    LSA_UNICODE_STRING sKey;
    LSA_UNICODE_STRING sPassword;
    WCHAR szKey[256];
    swprintf(szKey, L"SCM:%s", szCID);
    sKey.Length = (wcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.MaximumLength = (wcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.Buffer = szKey;
    sPassword.Length = (wcslen(szPw) + 1) * sizeof(WCHAR);
    sPassword.MaximumLength = 80 * sizeof(WCHAR);
    sPassword.Buffer = szPw;

    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);

    // open the local security policy
    if (!NT_SUCCESS(
            LsaOpenPolicy(
                NULL,
                &sObjAttributes,
                POLICY_CREATE_SECRET,
                &hPolicy)))
    {
        printf("LsaOpenPolicy failed with %d\n",GetLastError());
        return(FALSE);
    }

    // store private data
    if (!NT_SUCCESS(
            LsaStorePrivateData(hPolicy, &sKey, &sPassword)))
    {
        printf("LsaStorePrivateData failed with %d\n",GetLastError());
        return(FALSE);
    }

    LsaClose(hPolicy);
#endif
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\accctrl\server\oactests.cxx ===
/****************************************************************************

    FILE:       oactests.cxx


****************************************************************************/

#include <windows.h>
#include <oleext.h>
#include <stdio.h>
#include "oactest.h"    // header file generated by MIDL compiler


HRESULT RegisterClassFactory();
HRESULT RevokeClassFactory();

//Prototypes for local functions
HRESULT RegisterLocalServer(REFCLSID rclsid);
HRESULT RegisterProxyDll(const char *pszProxyDll);
HRESULT UnregisterLocalServer(REFCLSID rclsid);
HRESULT UnregisterProxyDll(const char *pszProxyDll);

extern "C" const CLSID CLSID_COAccessControlTest
    = {0x20692b00,0xe710,0x11cf,{0xaf,0x0b,0x00,0xaa,0x00,0x44,0xfb,0x89}};

extern  ULONG g_ulFrequency;
long    g_LockCount   = 0;
long    g_ObjectCount = 0;
DWORD   g_dwThreadID;
ULONG   g_ulFrequency;
//+---------------------------------------------------------------------------
//
//  Function:   DecrementLockCount
//
//  Synopsis:   Decrements the lock count.  The lock count controls the 
//              registration of the class factory in the class table.
//              DecrementLockCount revokes the class factory when the 
//              lock count is zero.
//
//  Called By:  ~CAccessControlTest, IClassFactory::LockServer(FALSE).
//
//  See Also:   ObjectCreated, ObjectDestroyed, IncrementLockCount.
//
//----------------------------------------------------------------------------
void DecrementLockCount()
{
    //Decrement the lock count.
    if(InterlockedDecrement(&g_LockCount) == 0)
    {
        //When the lock count is decremented to zero,
        //revoke the class factory.
        RevokeClassFactory();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IncrementLockCount
//
//  Synopsis:   Increments the lock count.  The lock count controls the 
//              registration of the class factory in the class table.
//              If necessary, IncrementLockCount will reregister the class
//              factory in the class table.
//
//  Called By:  CAccessControlTest, IClassFactory::LockServer(TRUE).
//
//  See Also:   DecrementLockCount, ObjectCreated, ObjectDestroyed.
//
//----------------------------------------------------------------------------
void IncrementLockCount()
{
    if(g_LockCount == 0)
    {
        //Increment the lock count.
        InterlockedIncrement(&g_LockCount);

        //Reregister the class factory if necessary.
        RegisterClassFactory();
    }
    else
    {
        //Increment the lock count.
        InterlockedIncrement(&g_LockCount);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Main entry point for the server application.  This function 
//              initializes the server and processes the message loop.
//
//----------------------------------------------------------------------------
int _cdecl main(int argc, char *argv[])
{
    HRESULT hr = S_OK;
    int i;
    BOOL fRegisterServer = FALSE;
    BOOL fUnregisterServer = FALSE;
    BOOL fEmbedding = FALSE;
    BOOL fHelp = FALSE;
    MSG msg;

    // Parse each item, skip the command name
    for (i = 1; i < argc; i++)
    {
        if (lstrcmpiA( argv[i], "-Embedding" ) == 0)
        {
            //This server has been activated by OLE.
            fEmbedding = TRUE;
        }
        else if (lstrcmpiA( argv[i], "/REGSERVER" ) == 0)
        {
            fRegisterServer = TRUE;
        }
        else if (lstrcmpiA( argv[i], "/UNREGSERVER" ) == 0)
        {
            fUnregisterServer = TRUE;
        }
        else
        {
            fHelp = TRUE;
        }
    }

    if(fHelp == TRUE)
        {
        printf("USAGE: server /REGSERVER   - Installs server in the registry.\n");
        printf("       server /UNREGSERVER - Removes server from the registry.\n");
        printf("       server -Embedding   - Server was auto-started by OLE.\n");
        return 0;
    }
    else if(fUnregisterServer == TRUE)
    {
        hr = UnregisterLocalServer(CLSID_COAccessControlTest);
        if(FAILED(hr))
        {
            printf("Failed to remove local server from the registry.\n");
        }

        hr = UnregisterProxyDll("oactest.dll");
        if(FAILED(hr))
        {
            printf("Failed to remove proxy DLL from the registry.\n");
        }
        return 0;
    }
    

    //Install the local server in the registry.
    hr = RegisterLocalServer(CLSID_COAccessControlTest);
    if(FAILED(hr))
    {
        printf("Failed to install local server in the registry.\n");
    }

    //Install the proxy DLL in the registry.
    hr = RegisterProxyDll("oactest.dll");
    if(FAILED(hr))
    {
        printf("Failed to install proxy DLL in the registry.\n");
    }

    if(fRegisterServer == TRUE)
        return 0;

  
    //
    // Initialize OLE before calling any other OLE functions.
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if(SUCCEEDED(hr))
    {   
        hr = RegisterClassFactory();

        if(SUCCEEDED(hr))
        {

            LARGE_INTEGER liFreq;

            QueryPerformanceFrequency(&liFreq);

            g_ulFrequency = liFreq.LowPart;

            printf("Waiting for client to connect...\n");
            g_dwThreadID = GetCurrentThreadId();
            // Main message loop.  We will remain in the message loop
            // until we get a WM_QUIT message.
    	    while (GetMessage(&msg, NULL, 0, 0))
    	    {
        	    TranslateMessage(&msg);
        	    DispatchMessage(&msg);
        	}

            //If the class factory is still registered in the 
            //class table, revoke it before we shut down.
            RevokeClassFactory();
	    }
        else
        {
            printf("Failed to register class factory.\n");
        }

        CoUninitialize();
    }
    else
    {
        printf("CoInitialize failed.\n");
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   ObjectCreated
//
//  Synopsis:   Increments the object count controlling the main message loop
//              of the server process.  
//
//  Called By:  CAccessControlTest, CAccessControlTestFactory.
//
//  See Also:   DecrementLockCount, IncrementLockCount, ObjectDestroyed.
//
//----------------------------------------------------------------------------
void ObjectCreated()
{
    InterlockedIncrement(&g_ObjectCount);
}


//+---------------------------------------------------------------------------
//
//  Function:   ObjectDestroyed
//
//  Synopsis:   Decrements the object count controlling the main message loop 
//              of the server process.  When the object count is decremented 
//              to zero, we post a WM_QUIT message.  The main message loop will
//              exit and terminate the server process.
//
//  Called By:  ~CAccessControlTest, ~CAccessControlTestFactory.
//
//  See Also:   DecrementLockCount, IncrementLockCount, ObjectCreated.
//
//----------------------------------------------------------------------------
void ObjectDestroyed()
{
    if(InterlockedDecrement(&g_ObjectCount) == 0)
    {
        //When the last object is released, post a quit message.
        PostThreadMessage(g_dwThreadID, WM_QUIT, NULL, NULL);
    }
}

  
//+---------------------------------------------------------------------------
//
//  Function:   RegisterLocalServer
//
//  Synopsis:   Creates a registry key for a local server.
//
//  Parameters: rclsid - Supplies the class ID of the local server.
//
//----------------------------------------------------------------------------
HRESULT RegisterLocalServer(REFCLSID rclsid)
{
    HRESULT hr;
    LONG error;
    HKEY hKeyCLSID;         // key for ...\Classes\CLSID
    HKEY hKeyClassID;
    HKEY hKey;              // current key
    DWORD dwDisposition;
    char szServer[MAX_PATH];
    char szClassID[39];
    unsigned long length;

    length = GetModuleFileNameA(0, szServer, sizeof(szServer));

    if(length == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    //create the CLSID key
    error = RegCreateKeyExA(
            HKEY_CLASSES_ROOT, 
            "CLSID",
            0, 
            "REG_SZ", 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            0,
            &hKeyCLSID,
            &dwDisposition);

    if(!error)
    {
        //convert the class ID to a registry key name.
        sprintf(szClassID, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                rclsid.Data1, rclsid.Data2, rclsid.Data3,
                rclsid.Data4[0], rclsid.Data4[1],
                rclsid.Data4[2], rclsid.Data4[3],
                rclsid.Data4[4], rclsid.Data4[5],
                rclsid.Data4[6], rclsid.Data4[7]);
  
        //create key for the server class
        error = RegCreateKeyExA(hKeyCLSID, 
                                szClassID,
                                0, 
                                "REG_SZ", 
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                0,
                                &hKeyClassID,
                                &dwDisposition);

        if(!error)
        {
            //create LocalServer32 key.
            error = RegCreateKeyExA(hKeyClassID,           
                                    "LocalServer32",
                                    0, 
                                    "REG_SZ", 
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    0,            
                                    &hKey,
                                    &dwDisposition);

            if(!error)
            {
                //Set the server name.
                error = RegSetValueExA(hKey, 
                                       "", 
                                       0, 
                                       REG_SZ, 
                                       (const unsigned char *)szServer,
                                       lstrlenA(szServer) + 1);

                // Specifies in the registry that this
                // server supports both threading models
                error = RegSetValueExA( hKey
                                      , "ThreadingModel"
                                      , 0
                                      , REG_SZ
                                      , (const unsigned char *)"Both"
                                      , lstrlenA("Both") + 1);

                RegFlushKey(hKey);
                RegCloseKey(hKey);
            }
            RegCloseKey(hKeyClassID);
        }
        RegCloseKey(hKeyCLSID);
    }

    if(!error)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(error);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegisterProxyDll
//
//  Synopsis:   Creates registry entries for the interfaces contained in a 
//              proxy DLL.  
//
//  Parameters: pszProxyDll - Supplies the filename of the proxy DLL.
//
//  Notes:      RegisterProxyDll calls the DllRegisterServer function 
//              exported from the proxy DLL.
//
//----------------------------------------------------------------------------
HRESULT RegisterProxyDll(const char *pszProxyDll)
{
    HRESULT hr;
    HINSTANCE hProxyDll;
    HRESULT (STDAPICALLTYPE *pfnDllRegisterServer)();
 
    hProxyDll = LoadLibraryA(pszProxyDll);
    
    if(hProxyDll != 0)
    {
        pfnDllRegisterServer = (HRESULT (STDAPICALLTYPE *)())
            GetProcAddress(hProxyDll, "DllRegisterServer");
        
        if(pfnDllRegisterServer != 0)
            hr = (*pfnDllRegisterServer)();
        else
            hr = HRESULT_FROM_WIN32(GetLastError());

        FreeLibrary(hProxyDll);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   UnregisterLocalServer
//
//  Synopsis:   Removes the registry key for a local server.
//
//  Parameters: rclsid - Supplies the class ID of the local server.
//
//----------------------------------------------------------------------------
HRESULT UnregisterLocalServer(REFCLSID rclsid)
{
    HRESULT hr;
    HKEY hKeyCLSID;
    HKEY hKeyClassID;
    long error;
    char szClassID[39];

    //open the CLSID key
    error = RegOpenKeyExA(
        HKEY_CLASSES_ROOT, 
        "CLSID",
        0, 
        KEY_ALL_ACCESS,
        &hKeyCLSID);

    if(!error)
    { 
    //convert the class ID to a registry key name.
    sprintf(szClassID, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            rclsid.Data1, rclsid.Data2, rclsid.Data3,
            rclsid.Data4[0], rclsid.Data4[1],
            rclsid.Data4[2], rclsid.Data4[3],
            rclsid.Data4[4], rclsid.Data4[5],
            rclsid.Data4[6], rclsid.Data4[7]);

        //open registry key for class ID string
        error = RegOpenKeyExA(
            hKeyCLSID, 
            szClassID,
            0, 
            KEY_ALL_ACCESS,
            &hKeyClassID);

        if(!error)
        {
            //delete LocalServer32 key. 
            error = RegDeleteKeyA(hKeyClassID, "LocalServer32");
            RegCloseKey(hKeyClassID);          
        }

        error = RegDeleteKeyA(hKeyCLSID, szClassID);
        RegCloseKey(hKeyCLSID);
    }

    if(!error)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(error);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   UnregisterProxyDll
//
//  Synopsis:   Removes registry entries for the interfaces contained in a 
//              proxy DLL.  
//
//  Parameters: pszProxyDll - Supplies the filename of the proxy DLL.
//
//  Notes:      UnregisterProxyDll calls the DllUnregisterServer function 
//              exported from the proxy DLL.
//
//----------------------------------------------------------------------------
HRESULT UnregisterProxyDll(const char *pszProxyDll)
{
    HRESULT hr;
    HINSTANCE hProxyDll;
    HRESULT (STDAPICALLTYPE *pfnDllUnregisterServer)();
    
    hProxyDll = LoadLibraryA(pszProxyDll);
    
    if(hProxyDll != 0)
    {
        pfnDllUnregisterServer = (HRESULT (STDAPICALLTYPE *)())
            GetProcAddress(hProxyDll, "DllUnregisterServer");
        
        if(pfnDllUnregisterServer != 0)
            hr = (*pfnDllUnregisterServer)();
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    
        FreeLibrary(hProxyDll);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


/* end file actestss.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\client\client.cxx ===
/*
 * client.cxx
 */

#include "client.hxx"

#define MIN_TEST_NUMBER         1
#define MAX_TEST_NUMBER         27

BOOL UnimplementedTest();
BOOL UnsupportedTest();
BOOL GenericCITest(REFCLSID clsid, REFIID iid, WCHAR * wszServerName, int n, DWORD ctxt);

BOOL CGCOLocalEXE();
BOOL CGCOExplicitActivator();
BOOL CILocalDLL();
BOOL CILocalEXE();
BOOL CIExplicitActivator();
BOOL CI3LocalEXE();
BOOL CI3ExplicitActivator();
BOOL CGIFFLocalEXE();
BOOL CGIFFExplicitActivator();
BOOL CGIFFRegistryActivator();
BOOL CGIFFAtStorageActivator();
BOOL IMBLocalEXE();
BOOL IMBLocalService();
BOOL IMBAtStorageActivator();
BOOL IMBAtStorageService();
BOOL IMBAtStoragePreCon();
BOOL IMBAtStorageUser();
BOOL CIFromStgLocalEXE();
BOOL CIFromStgActivator();
BOOL CICustomLocalDLL();
BOOL CICustomLocalEXE();
BOOL CILocalPreCon();
BOOL CIExplicitPreCon();
BOOL CILocalUser();
BOOL CIExplicitUser();
BOOL CILocalPreConACL();
BOOL CIExplicitPreConACL();
BOOL CILocalService();
BOOL CIExplicitService();

#ifdef NO_DCOM
LPTESTFUNC rgTest[] =
    {
        NULL,
        CGCOLocalEXE,
        UnsupportedTest,
        CILocalDLL,
        CILocalEXE,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest
/* New tests
        UnsupportedTest,
        UnsupportedTest,
end new tests */
        CI3LocalEXE,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        IMBLocalEXE,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        NULL
    };
#else
#ifdef CHICO
LPTESTFUNC rgTest[] =
    {
        NULL,
        CGCOLocalEXE,
        CGCOExplicitActivator,
        CILocalDLL,
        CILocalEXE,
        CIExplicitActivator,
        CILocalPreCon,
        CIExplicitPreCon,
        CILocalUser,
        CIExplicitUser,
        UnsupportedTest,
        CIExplicitService,
/* new tests
        CILocalPreConACL,
        CIExplicitPreConACL,
end new tests */
        CI3LocalEXE,
        CI3ExplicitActivator,
        CICustomLocalDLL,
        CICustomLocalEXE,
        CGIFFLocalEXE,
        CGIFFExplicitActivator,
        CGIFFRegistryActivator,
        CGIFFAtStorageActivator,
        IMBLocalEXE,
        UnsupportedTest,
        IMBAtStorageActivator,
        IMBAtStorageService,
        IMBAtStoragePreCon,
        IMBAtStorageUser,
        CIFromStgLocalEXE,
        CIFromStgActivator,
        NULL
    };
#else
LPTESTFUNC rgTest[] =
    {
        NULL,
        CGCOLocalEXE,
        CGCOExplicitActivator,
        CILocalDLL,
        CILocalEXE,
        CIExplicitActivator,
        CILocalPreCon,
        CIExplicitPreCon,
        CILocalUser,
        CIExplicitUser,
        CILocalService,
        CIExplicitService,
/* new tests
        CILocalPreConACL,
        CIExplicitPreConACL,
end new tests */
        CI3LocalEXE,
        CI3ExplicitActivator,
        CICustomLocalDLL,
        CICustomLocalEXE,
        CGIFFLocalEXE,
        CGIFFExplicitActivator,
        CGIFFRegistryActivator,
        CGIFFAtStorageActivator,
        IMBLocalEXE,
        IMBLocalService,
        IMBAtStorageActivator,
        IMBAtStorageService,
        IMBAtStoragePreCon,
        IMBAtStorageUser,
        CIFromStgLocalEXE,
        CIFromStgActivator,
        NULL
    };
#endif // CHICO
#endif // NO_DCOM

char *  TestName[] =
        {
            NULL,
           "CoGetClassObject                    local       EXE",
           "CoGetClassObject                    explicit    activator",
           "CoCreateInstance                    local       DLL",
           "CoCreateInstance                    local       EXE",
           "CoCreateInstance                    explicit    activator",
           "CoCreateInstance                    local       pre-configured",
           "CoCreateInstance                    explicit    pre-configured",
           "CoCreateInstance                    local       user",
           "CoCreateInstance                    explicit    user",
           "CoCreateInstance                    local       service",
           "CoCreateInstance                    explicit    service",
/* new tests
           "CoCreateInstance                    local       pre-configured ACL",
           "CoCreateInstance                    explicit    pre-configured ACL",
end new tests */
           "CoCreateInstance (3 IIDs)           local       EXE",
           "CoCreateInstance (3 IIDs)           explicit    activator",
           "CoCreateInstance from custom itf.   local       DLL",
           "CoCreateInstance from custom itf.   local       EXE",
           "CoGetInstanceFromFile               local       EXE",
           "CoGetInstanceFromFile               explicit    activator",
           "CoGetInstanceFromFile               registry    activator",
           "CoGetInstanceFromFile               AtStorage   activator",
           "IMoniker::BindToObject              local       EXE",
           "IMoniker::BindToObject              local       service",
           "IMoniker::BindToObject              AtStorage   activator",
           "IMoniker::BindToObject              AtStorage   service",
           "IMoniker::BindToObject              AtStorage   pre-configured",
           "IMoniker::BindToObject              AtStorage   user",
           "CoGetInstanceFromIStorage           local       EXE",
           "CoGetInstanceFromIStorage           explicit    activator",
            NULL
        };

char    RunTest[] =
        {
            -1,
            // CoGetClassObject
            YES,
            YES,
            // CoCreateInstance
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
/* new tests
            YES,
            YES,
end new tests */
            // CoCreateInstance (3 IIDs)
            YES,
            YES,
            // CoGetInstanceFromFile
            YES,
            YES,
            YES,
            YES,
            // IMoniker:Bind
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            -1
         };

char    RunLocalTest[] =
        {
            -1,
            // CoGetClassObject
            YES,
            NO,
            // CreateInstance
            YES,
            YES,
            NO,
            YES,
            NO,
            YES,
            NO,
            YES,
            NO,
/* new tests
            YES,
            NO,
end new tests */
            // CreateInstance (3 IIDs)
            YES,
            NO,
            // CreateInstance from custom Itf.
            YES,
            YES,
            // CoGetInstanceFromFile
            YES,
            NO,
            NO,
            NO,
            // IMoniker:Bind
            YES,
            YES,
            NO,
            NO,
            NO,
            NO,
            // CoGetInstanceFromIStorage
            YES,
            NO,
            -1
         };

#define ACT_SERVERNAME_LENGTH 31
#define ACT_FILENAME_LENGTH 255

TCHAR ServerName[ACT_SERVERNAME_LENGTH+1];
TCHAR RemoteFileName[ACT_FILENAME_LENGTH+1];
TCHAR * LocalFileName = TEXT("c:\\acttest.dat");
TCHAR * StorageName = TEXT("c:\\acttest.stg");
TCHAR ShareName[ACT_SERVERNAME_LENGTH+1] = TEXT("C$");
#ifndef UNICODE
WCHAR wszServerName[ACT_SERVERNAME_LENGTH+1];
WCHAR wszRemoteFileName[ACT_FILENAME_LENGTH+1];
WCHAR * wszLocalFileName = L"c:\\acttest.dat";
WCHAR * wszStorageName = L"c:\\acttest.stg";
#else
WCHAR *wszServerName = ServerName;
WCHAR *wszRemoteFileName = RemoteFileName;
WCHAR * wszLocalFileName = LocalFileName;
WCHAR * wszStorageName = StorageName;
#endif

LARGE_INTEGER liPerfFreq;
LARGE_INTEGER liStart;
LARGE_INTEGER liStop;
LARGE_INTEGER liElapsedTime;

#define RESET_CLOCK liElapsedTime.LowPart = liElapsedTime.HighPart = 0
#define START_CLOCK QueryPerformanceCounter(&liStart)
#define STOP_CLOCK      QueryPerformanceCounter(&liStop); \
                        liElapsedTime.QuadPart += liStop.QuadPart - liStart.QuadPart
#define DUMP_CLOCK DisplayElapsedTime()
#define START_LOOP for (unsigned sl_n = uIterations+1; sl_n--;){
#define STOP_LOOP if (uIterations == sl_n ) RESET_CLOCK;}
#define SLEEP_IF_LOOPING if (sl_n && !gfHoldServer) Sleep(1000)

unsigned uIterations = 0;

BOOL    gfRegister = TRUE;
BOOL    gfHoldServer = FALSE;
BOOL    gfLocal = FALSE;
BOOL    gfNolocal = FALSE;
BOOL    gfSpecificTest = FALSE;

void DisplayElapsedTime(void)
{
    LONGLONG    MicroPerIter;

    liElapsedTime.QuadPart /= uIterations;

    MicroPerIter = liElapsedTime.QuadPart * 1000000;
    MicroPerIter /= liPerfFreq.QuadPart;

    printf( "Time: %d microseconds per iteration", (DWORD) MicroPerIter );
}

BOOL AllLocal()
{
    for (int x = MIN_TEST_NUMBER; x<= MAX_TEST_NUMBER; x++)
    {
        if (RunTest[x]  &&  !RunLocalTest[x])
            return(FALSE);
    }
    return(TRUE);
}

void _cdecl main( int argc, char ** argv )
{
    HRESULT         HResult;
    HANDLE          hFile;
    int             n;

#ifndef NO_DCOM
    if ( argc == 1 )
        PrintUsageAndExit( FALSE );
#endif // NO_DCOM

    if ( argc > 1 && strcmp(argv[1],"-?") == 0 )
        PrintUsageAndExit( TRUE );

    n = 1;

    while ( (n < argc) && (*argv[n] == '-') )
    {
        if ( (n < argc) && strcmp(argv[n],"-local") == 0 )
        {
            if (gfLocal | gfNolocal)
            {
                PrintUsageAndExit( FALSE );
            }
            gfLocal = TRUE;
            memcpy(RunTest, RunLocalTest, MAX_TEST_NUMBER + MIN_TEST_NUMBER);
            n++;
        }

        if ( (n < argc) && strcmp(argv[n],"-nolocal") == 0 )
        {
            if (gfLocal | gfNolocal)
            {
                PrintUsageAndExit( FALSE );
            }
            gfNolocal = TRUE;
            for (int x = MIN_TEST_NUMBER; x<= MAX_TEST_NUMBER; x++)
            {
                RunTest[x] = !RunLocalTest[x];
            }
            n++;
        }

        if ( (n < argc) && strcmp(argv[n],"-noreg") == 0 )
        {
            gfRegister = FALSE;
            n++;
            continue;
        }

        if ( (n < argc) && strcmp(argv[n],"-hold") == 0 )
        {
            gfHoldServer = TRUE;
            n++;
            continue;
        }

        if ( (n < argc) && strcmp(argv[n],"-n") == 0 )
        {
            if ( ++n >= argc )
                PrintUsageAndExit(FALSE);

            uIterations = atoi(argv[n++]);
        }

        if ( (n < argc) && strcmp(argv[n],"-t") == 0 )
        {
            long    TestNum1, TestNum2;

            if ( ++n >= argc )
                PrintUsageAndExit(FALSE);

            TestNum1 = atoi(argv[n++]);

            if ( (n < argc) && ((TestNum2 = atoi(argv[n])) != 0) )
                n++;
            else
                TestNum2 = TestNum1;

            if ( (TestNum1 < MIN_TEST_NUMBER) || (TestNum2 > MAX_TEST_NUMBER) )
            {
                printf( "Test number(s) must be between %d and %d.\n",
                        MIN_TEST_NUMBER,
                        MAX_TEST_NUMBER );
                return;
            }

            if ( TestNum1 > TestNum2 )
            {
                printf( "Second test number must be greater than the first.\n" );
                return;
            }

            if (!gfSpecificTest)
            {
                gfSpecificTest = TRUE;
                // only do this the first time -t is found on the command line
                memset(RunTest,NO,sizeof(RunTest));
            }
            memset(&RunTest[TestNum1],YES,sizeof(char)*(TestNum2-TestNum1+1));
        }
    }

#ifndef NO_DCOM
    if ( n != argc - 1  && n != argc -2 && !AllLocal())
    {
        printf("ERROR - Selected tests require a server name.\n");
        ExitThread(0);
    }

    if ( n < argc )
    {
#ifndef UNICODE
        strcpy(ServerName, argv[n]);
#endif
        MultiByteToWideChar( CP_ACP,
                             0,
                             argv[n],
                             -1,
                             wszServerName,
                             ACT_SERVERNAME_LENGTH );
        if ( ++n < argc)
        {
#ifndef UNICODE
        strcpy(ShareName, argv[n]);
#else
        MultiByteToWideChar( CP_ACP,
                             0,
                             argv[n],
                             -1,
                             ShareName,
                             ACT_SERVERNAME_LENGTH );
#endif
        }
        else
        {
#ifdef CHICO
           printf("ERROR - On Win95 Selected tests require a share name.\n");
           ExitThread(0);
#endif
        }
    }
    else
    {
#ifndef UNICODE
        ServerName[0] = 0;
#endif
        wszServerName[0] = 0;
        ShareName[0] = 0;
    }
#endif // NO_DCOM

    hFile = CreateFile(
                LocalFileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                0,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                0 );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        printf("CreateFile failed while creating local file: %d\n", GetLastError());
        return;
    }

    CloseHandle( hFile );

#ifndef NO_DCOM
    if ( ServerName[0] != 0 )
    {
        RemoteFileName[0] = 0;

        if ( ServerName[0] != TEXT('\\') )
            lstrcat( RemoteFileName, TEXT("\\\\") );

        lstrcat( RemoteFileName, ServerName );
        lstrcat( RemoteFileName, TEXT("\\") );
        lstrcat( RemoteFileName, ShareName );
        lstrcat( RemoteFileName, TEXT("\\acttest.dat") );

#ifndef UNICODE
        MultiByteToWideChar( CP_ACP,
                             0,
                             RemoteFileName,
                             -1,
                             wszRemoteFileName,
                             ACT_FILENAME_LENGTH);
#endif

        hFile = CreateFile(
                    RemoteFileName,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    0,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    0 );

        if ( hFile == INVALID_HANDLE_VALUE )
        {
            printf("CreateFile failed while creating remote file: %d\n", GetLastError());
            return;
        }

        CloseHandle( hFile );
    }
#endif // NO_DCOM

#ifdef FREETHREADED
    HResult = CoInitializeEx(NULL,COINIT_MULTITHREADED );
#else
    HResult = CoInitialize(NULL);
#endif

    if( FAILED(HResult) )
    {
        printf( "Client CoInitialize failed Ox%x!\n", HResult );
        return;
    }

    if ((!QueryPerformanceFrequency(&liPerfFreq)) && uIterations > 0)
    {
        printf("No high performance counter.\nTests cannot be timed.\nAborting.\n");
    }
    else
    {
        if ( ! Tests() )
            printf("\nTests FAILED\n");
        else
            printf("\nTests SUCCEEDED\n");
    }

    CoUninitialize();
    DeleteFile( LocalFileName );
#ifndef NO_DCOM
    DeleteFile( RemoteFileName );
#endif // NO_DCOM
}

BOOL Tests()
{
    HRESULT         HResult;
    long            RegStatus;

    if (gfRegister)
    {
        DeleteClsidKey( ClsidGoober32String );
        DeleteClsidKey( ClsidActLocalString );
        DeleteClsidKey( ClsidActRemoteString );
        DeleteClsidKey( ClsidActAtStorageString );
        DeleteClsidKey( ClsidActInprocString );
        DeleteClsidKey( ClsidActPreConfigString );
        DeleteClsidKey( ClsidActRunAsLoggedOnString );
        DeleteClsidKey( ClsidActServiceString );
        DeleteClsidKey( ClsidActServerOnlyString );

        if ( (RegStatus = InitializeRegistryForInproc()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForInproc failed %d.\n", RegStatus);
            return FALSE;
        }

        if ( (RegStatus = InitializeRegistryForLocal()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForLocal failed %d.\n", RegStatus);
            return FALSE;
        }

        if ( (RegStatus = InitializeRegistryForCustom()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForCustom failed %d.\n", RegStatus);
            return FALSE;
        }
    #ifndef NO_DCOM
        if ( (RegStatus = InitializeRegistryForRemote()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForRemote failed %d.\n", RegStatus);
            return FALSE;
        }

        if ( (RegStatus = InitializeRegistryForService()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForService failed %d.\n", RegStatus);
            return FALSE;
        }
    #endif // NO_DCOM
    }
    BOOL fAllTests = TRUE;

    for (int x = MIN_TEST_NUMBER; x <= MAX_TEST_NUMBER; x++)
    {
        if (RunTest[x])
        {
            printf("\nTest %2d: %s\n",x, TestName[x]);
            // prime the system once to ensure the test is fully cached
            if (rgTest[x]())
            {
                printf("PASSED");
                if (uIterations)
                {
                    printf(" - ");
                    DUMP_CLOCK;
                }
                printf("\n");
            }
            else
            {
                printf("FAILED\n");
                fAllTests = FALSE;
            }

        }
    }

    return(fAllTests);
}

void PrintUsageAndExit( BOOL bListTests )
{
#ifdef NO_DCOM
    printf("Usage : %s [-hold] [-noreg] [-n #] [-t # [#]]\n", "actclt");
    printf("\t-n #     : Run specific number of timed iterations (default is 0).\n");
    printf("\t-noreg   : Don't update registry\n");
    printf("\t-t #     : Run specific test number or a range of tests.\n");
    printf("\t-?       : Print usage plus test descriptions.\n");
#else
    printf("Usage : %s [-hold] [-noreg] [[-local] | [-nolocal]] [-n #] [-t # [#]] [server_name [share_name]] \n", "actclt");
    printf("\t-hold    : Hold the server up during all iterations.\n");
    printf("\t-local   : Run only local activation tests.\n");
    printf("\t-n #     : Run specific number of timed iterations (default is 0).\n");
    printf("\t-nolocal : Run only remote activation tests.\n");
    printf("\t-noreg   : Don't update registry\n");
    printf("\t-t #     : Run specific test number or a range of tests.\n");
    printf("\t-?       : Print usage plus test descriptions.\n");
#endif // NO_DCOM

    if ( bListTests )
    {
        long    n;

        printf("\nTests :\n");
        printf("\t # Method                              Location    Security\n");
        printf("\t-- ----------------------------------- ----------- --------------\n");

        for ( n = MIN_TEST_NUMBER; n <= MAX_TEST_NUMBER; n++ )
        {
            printf("\t%2d %s\n", n, TestName[n]);
        }
    }

    ExitThread(0);
}

void * __RPC_API
MIDL_user_allocate(size_t len)
{
    return malloc(len);
}

void __RPC_API
MIDL_user_free(void * vp)
{
    free(vp);
}

BOOL StampFileWithCLSID(WCHAR * szFilename, CLSID & clsid)
{
    HRESULT hr;
    IStorage * pStg;

    hr = StgCreateDocfile(
                szFilename,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                &pStg);

    if (FAILED (hr))
    {
        printf("StgCreateDocfile returned 0x%x\n", hr);
        return(FALSE);
    }

    hr = WriteClassStg(pStg, clsid);

    pStg->Release();

    if (FAILED (hr))
    {
        printf("WriteClassStg returned 0x%x\n", hr);
        return(FALSE);
    }

    return(TRUE);
}

//
// Test Procedures:
//

BOOL UnimplementedTest()
{
    printf("Not implemented at this time.\n");
    return(TRUE);
}

BOOL UnsupportedTest()
{
    printf("Not supported by this version.\n");
    return(TRUE);
}

BOOL GenericCITest(REFCLSID clsid, REFIID iid, WCHAR * wszServerName, int n, DWORD ctxt)
{
    COSERVERINFO   ServerInfo;
    COSERVERINFO   *pServerInfo;
    IUnknown * punkHeld = NULL;

    if (wszServerName)
    {
        memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
        ServerInfo.pwszName = wszServerName;
        pServerInfo = &ServerInfo;
    }
    else
    {
        pServerInfo = NULL;
    }

    MULTI_QI QIStruct[10];
    int x;
    HRESULT hr;
    BOOL fReturn = TRUE;

    STAR