 16: // (signed) short

		ps = (short *) (m_StrmConvHdr.pbDst);
		cbSize = m_StrmConvHdr.cbDstLengthUsed;

		sMax = sMin = 0;

		for (cbSize >>= 1; cbSize; cbSize--, ps++)
		{
			if (*ps > sMax) sMax = *ps;
			if (*ps < sMin) sMin = *ps;
		}
	
		dwMaxStrength = (DWORD) (sMax - sMin); // drop sign bit
		break;

	}
	return dwMaxStrength;
}


STDMETHODIMP
RecvDSAudioStream::SetProperty(
	DWORD prop,
	PVOID pBuf,
	UINT cbBuf
    )
{
	DWORD dw;
	HRESULT hr = S_OK;
	
	if (cbBuf < sizeof (DWORD))
		return DPR_INVALID_PARAMETER;

	switch (prop)
    {
	//case PROP_VOLUME:
		

	case PROP_DUPLEX_TYPE:
		ASSERT(0);  // dead code for this case type;
		break;
		
	case DP_PROP_DUPLEX_TYPE:
		// internal version, called by DataPump::SetDuplexMode() after ensuring streams are stopped
		dw = *(DWORD *)pBuf;
		if (dw & DP_FLAG_HALF_DUPLEX)
			m_DPFlags |= DP_FLAG_HALF_DUPLEX;
		else
			m_DPFlags &= ~DP_FLAG_HALF_DUPLEX;
		break;
		

	case PROP_PLAY_ON:
	{

		if (*(DWORD *)pBuf)   // unmute
		{
			m_ThreadFlags &= ~DPTFLAG_PAUSE_RECV;
		}
		else  // mute
		{
			m_ThreadFlags |= DPTFLAG_PAUSE_RECV;
		}
	
//		DWORD flag =  DPFLAG_ENABLE_RECV;
//		if (*(DWORD *)pBuf) {
//			m_DPFlags |= flag; // set the flag
//			hr = Start();
//		}
//		else
//		{
//			m_DPFlags &= ~flag; // clear the flag
//			hr = Stop();
//		}

		RETAILMSG(("NAC: RecvAudioStream: %s", *(DWORD*)pBuf ? "Enabling":"Disabling"));
		break;
	}	
	case PROP_PLAYBACK_DEVICE:
		m_RenderingDevice = *(DWORD*)pBuf;
		RETAILMSG(("NAC: Setting default playback device to %d", m_RenderingDevice));
		if (m_RenderingDevice != WAVE_MAPPER)
			hr = DirectSoundMgr::MapWaveIdToGuid(m_RenderingDevice,&m_DSguid);
		break;

    case PROP_VIDEO_AUDIO_SYNC:
		if (*(DWORD *)pBuf)
    		m_DPFlags |= DPFLAG_AV_SYNC;
		else
			m_DPFlags &= ~DPFLAG_AV_SYNC;
    	break;

	default:
		return DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}

HRESULT
RecvDSAudioStream::GetCurrentPlayNTPTime(NTP_TS *pNtpTime)
{
	DWORD rtpTime;
#ifdef OLDSTUFF
	if ((m_DPFlags & DPFLAG_STARTED_RECV) && m_fReceiving) {
		if (m_Net->RTPtoNTP(m_PlaybackTimestamp,pNtpTime))
			return S_OK;
	}
#endif
	return 0xff;	// return proper error
		
}

BOOL RecvDSAudioStream::IsEmpty() {
	// check if anything in DSBuffer or in decode buffer
	return (m_fEmpty && !(m_StrmConvHdr.dwDstUser & BUFFER_RECEIVED));
}

/*
	Called by the recv thread to setup the stream for receiving.
	Post the initial recv buffer(s). Subsequently, the buffers are posted
	in the RTPRecvCallback()
*/
HRESULT
RecvDSAudioStream::StartRecv(HWND hWnd)
{
	HRESULT hr = S_OK;
	DWORD dwPropVal = 0;
	FX_ENTRY ("RecvDSAudioStream::StartRecv");
	
	if ((!(m_ThreadFlags & DPTFLAG_STOP_RECV) ) && (m_DPFlags  & DPFLAG_CONFIGURED_RECV)){
		if (!(m_DPFlags & DP_FLAG_HALF_DUPLEX) && !m_pDSBuf) {
		// Create the DS object only if its full-duplex
		// In the half-duplex case the DSbuffer is created
		// when the first packet is received
		// only  reason its here is so that SetDuplexMode can take effect right away
		// BUGBUG: opening waveIn before DS causes death of the waveOut on Memphis!!
			hr = CreateDSBuffer();
			
			if (hr  != S_OK) {
				DEBUGMSG (ZONE_DP, ("%s: CreateSoundBuffer create failed, hr=0x%lX\r\n", _fx_, hr));
				return hr;
			}
		}
		if (m_pDSBuf)
			hr = m_pDSBuf->Play(0,0,DSBPLAY_LOOPING);

//		m_RecvFilter->GetProp (FM_PROP_SRC_SIZE, &dwPropVal);
		//hr = m_Net->SetRecvNotification(&RTPRecvDSCallback, (DWORD)this, 2, dwPropVal, hWnd);	// for WS1 only
		hr =m_pIRTPRecv->SetRecvNotification(&RTPRecvCallback,(DWORD_PTR)this, 2);
			
		
	}
	return hr;
}

/*
	Called by the recv thread to suspend receiving  on this RTP session
	If there are outstanding receive buffers they have to be recovered
*/

HRESULT
RecvDSAudioStream::StopRecv()
{
	// dont recv on this stream
	m_pIRTPRecv->CancelRecvNotification();

	// cancel any pending timeout. (its okay if it wasnt scheduled )
	m_pDP->m_RecvTimer.CancelTimeout(&m_TimeoutObj);

	// Release DirectSound object
	ReleaseDSBuffer();

	return S_OK;		
}

/*
	Create a DirectSound object and a DirectSound secondary buffer.
	This routine is called after the stream is configured, so the wave format has been set
	and the DSBUFFERDESC struct has been initialized.
*/
HRESULT
RecvDSAudioStream::CreateDSBuffer()
{
	HRESULT hr;
	HWAVEOUT hwo=NULL;
	DSCAPS dscaps;
	FX_ENTRY ("RecvDSAudioStream::CreateDSBuffer");

	ASSERT(!m_pDSBuf);
	if (m_DPFlags & DP_FLAG_HALF_DUPLEX) {
		DWORD dwStatus;
		// Got to take the half duplex event
		// BUGBUG: this method wont cut it if there is more than one send and one recv stream
		dwStatus = WaitForSingleObject(g_hEventHalfDuplex, 0);
		if (dwStatus != WAIT_OBJECT_0)
			return DPR_CANT_OPEN_DEV;
	}
	//	Stop any high level ("PlaySound()") usage of wave device.
	
	// Create the direct sound object (if necessary)
	hr = DirectSoundMgr::Instance(m_RenderingDevice==WAVE_MAPPER ? NULL: &m_DSguid, &m_pDS, m_pDP->m_hAppWnd, &m_fDevRecv);

	if (hr == S_OK)
	{
		hr = m_pDS->CreateSoundBuffer(&m_DSBufDesc,&m_pDSBuf,NULL);
		if (hr == DSERR_INVALIDPARAM)
		{
			// if global focus (DX3) is not supported, try sticky focus
			m_DSBufDesc.dwFlags ^= (DSBCAPS_GLOBALFOCUS|DSBCAPS_STICKYFOCUS);
			hr = m_pDS->CreateSoundBuffer(&m_DSBufDesc,&m_pDSBuf,NULL);
		}
		m_PlayPosT = 0;		// DS play position is initially at the start of the buffer

		if (hr != S_OK)
		{
			DEBUGMSG (ZONE_DP, ("%s: CreateSoundBuffer create failed, hr=0x%lX\r\n", _fx_, hr));

			m_nFailCount++;
			if (m_nFailCount == MAX_FAILCOUNT)
			{
				m_pDP->StreamEvent(MCF_RECV, MCF_AUDIO, STREAM_EVENT_DEVICE_FAILURE, 0);
				m_bJammed = TRUE;
				m_bCanSignalOpen = TRUE;
			}
		}

		dscaps.dwSize = sizeof(dscaps);
		dscaps.dwFlags = 0;
		m_pDS->GetCaps(&dscaps);	// get DirectSound object attributes
		m_DSFlags = dscaps.dwFlags;

		if (m_DSFlags & DSCAPS_EMULDRIVER)
		{
			// use g_MinDSEmulAudioDelay since this is the emulated driver
			m_MinDelayT = (m_fDevRecv.nSamplesPerSec * g_MinDSEmulAudioDelayMs) / 1000;
			m_DelayT = m_MinDelayT;
		};
	}

	else
	{
		DEBUGMSG (ZONE_DP, ("%s: DirectSound create failed, hr=0x%lX\r\n", _fx_, hr));

		m_nFailCount++;
		if (m_nFailCount == MAX_FAILCOUNT)
		{
			m_pDP->StreamEvent(MCF_RECV, MCF_AUDIO, STREAM_EVENT_DEVICE_FAILURE, 0);
			m_bJammed = TRUE;
			m_bCanSignalOpen = TRUE;
		}
	}


	if (hr == S_OK)
	{
		if (m_DPFlags & DPFLAG_STARTED_RECV)
		{
			m_pDSBuf->Play(0,0,DSBPLAY_LOOPING);
		}

		if (m_bCanSignalOpen)
		{
			m_pDP->StreamEvent(MCF_RECV, MCF_AUDIO, STREAM_EVENT_DEVICE_OPEN, 0);
			m_bCanSignalOpen = FALSE; // don't signal open condition anymore
		}

		m_bJammed = FALSE;
		m_nFailCount = 0;
	}
	else
	{
		ReleaseDSBuffer();
	}
	return hr;
}

HRESULT
RecvDSAudioStream::ReleaseDSBuffer()
{
	m_fEmpty = TRUE;
	if (m_pDSBuf) {
		ULONG uref;
		uref = m_pDSBuf->Release();
		m_pDSBuf = NULL;
		//DEBUGMSG(ZONE_DP,("Releasing DirectSound buffer (%d)\n", uref));
	}
	if (m_pDS) {
		DirectSoundMgr::ReleaseInstance(m_pDS);
		m_pDS = NULL;
		if (m_DPFlags & DP_FLAG_HALF_DUPLEX)
			SetEvent(g_hEventHalfDuplex);
	}
	return S_OK;
		
}

HRESULT
RecvDSAudioStream::Decode(UCHAR *pData, UINT cbData)
{
	MMRESULT mmr;
	HRESULT hr=S_OK;
	FX_ENTRY ("RecvDSAudioStream::Decode");
	UINT uDstLength;


	if (m_dwSrcSize < cbData)
	{
		DEBUGMSG (ZONE_DP, ("%s: RecvDSAudioStream::Decode failed - buffer larger than expected\r\n", _fx_));
		return DPR_CONVERSION_FAILED;
	}

	CopyMemory(m_StrmConvHdr.pbSrc, pData, cbData);
	m_StrmConvHdr.cbSrcLength = cbData;
	mmr = m_pAudioFilter->Convert(&m_StrmConvHdr);

	if (mmr != MMSYSERR_NOERROR)
	{
		DEBUGMSG (ZONE_DP, ("%s: acmStreamConvert failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
		hr = DPR_CONVERSION_FAILED;
	}
	else
	{
		m_StrmConvHdr.dwDstUser = BUFFER_RECEIVED;	// buffer is ready to play
		// if receive side silence detection is turned on,
		// check decoded buffer signal level
		if (m_DPFlags & DP_FLAG_AUTO_SILENCE_DETECT)
		{
			if (m_AudioMonitor.SilenceDetect((WORD) GetSignalStrength()))
			{
				m_StrmConvHdr.dwDstUser = BUFFER_SILENT;
			}
		}
	}

	return hr;
	// end
}

// insert the decoded buf at the appropriate location in the DirectSound buffer
HRESULT
RecvDSAudioStream::PlayBuf(DWORD timestamp, UINT seq, BOOL fMark)
{
	UINT lenT = BYTESTOSAMPLES(m_StrmConvHdr.cbDstLengthUsed);
	DWORD curPlayPosT, curWritePosT, curWriteLagT;
	LPVOID p1, p2;
	DWORD cb1, cb2;
	HRESULT hr;
	DWORD dwDSStatus = 0;

	/*
	All of the following are expressed in samples:
	m_NextTimeT is timestamp of next expected packet. Usually timestamp equals m_NextT
	m_BufSizeT is the total buffer size in samples.
	m_NextPosT is the write position corresponding to m_NextT.
	m_PlayPosT is the current play position
	m_DelayT is the ideal playback delay
	*/

	LOG((LOGMSG_DSTIME, GetTickCount()));
	LOG((LOGMSG_DSENTRY, timestamp, seq, fMark));

	m_pDSBuf->GetCurrentPosition(&curPlayPosT,&curWritePosT);
	curPlayPosT = BYTESTOSAMPLES(curPlayPosT);	
	curWritePosT = BYTESTOSAMPLES(curWritePosT);
	m_pDSBuf->GetStatus(&dwDSStatus);

	if (!m_fEmpty)
	{
		// wasn't empty last time we checked but is it empty now?
		if (QMOD(curPlayPosT-m_PlayPosT, m_BufSizeT) > QMOD(m_NextPosT-m_PlayPosT, m_BufSizeT))
		{
			// play cursor has advanced beyond the last written byte
			m_fEmpty = TRUE;
			LOG((LOGMSG_DSEMPTY, curPlayPosT, m_PlayPosT, m_NextPosT));
		}
		// write silence into the part of the buffer that just played
		hr = m_pDSBuf->Lock(SAMPLESTOBYTES(m_PlayPosT),SAMPLESTOBYTES(QMOD(curPlayPosT-m_PlayPosT, m_BufSizeT)), &p1, &cb1, &p2, &cb2, 0);
		if (hr == S_OK)
		{
			ZeroMemory(p1,cb1);
			if (cb2)
				ZeroMemory(p2,cb2);
			m_pDSBuf->Unlock(p1,cb1,p2,cb2);
		}
	}
	hr = S_OK;	
	
	// calculate minimum write-behind margin.
	// This is low for native sound drivers and high for emulated drivers, so , assuming it's accurate
	// there's no need to distinguish between emulated and native drivers.
	curWriteLagT = QMOD(curWritePosT-curPlayPosT, m_BufSizeT);


	if (m_fEmpty)
	{
		// the DS buffer only has silence in it. In this state, m_NextPosT and m_NextTimeT are irrelevant.
		// We get to put the new buffer wherever we choose, so we put it m_DelayT after the current write position.
		curWritePosT = QMOD(curWritePosT+m_DelayT, m_BufSizeT);
		
	}
	else
	{
	
		if (TS_EARLIER(timestamp, m_NextTimeT))
			hr = DPR_OUT_OF_SEQUENCE;	// act dumb and discard misordered packets
		else
		{
			UINT curDelayT = QMOD(m_NextPosT - curPlayPosT, m_BufSizeT);
			if (fMark)
			{
				// we have some leeway in choosing the insertion point, because this is the start of a talkspurt
				if (curDelayT > m_DelayT + curWriteLagT)
				{
					// put it right after the last sample
					curWritePosT = m_NextPosT;
				}
				else
				{
					// put it m_DelayT after the current write position
					curWritePosT = QMOD(curWritePosT+m_DelayT, m_BufSizeT);
				}
			}
			else
			{
				// bytes in
				if ((timestamp-m_NextTimeT + curDelayT) < m_BufSizeT)
				{
					curWritePosT = QMOD(m_NextPosT +timestamp-m_NextTimeT, m_BufSizeT);
				}
				else
				{
					// overflow!! Could either dump whats in buffer or dump the packet
					// dumping the packet is easier for now
					hr = DPR_OUT_OF_SEQUENCE;
				}
			}
		}
	}
	if ((dwDSStatus & DSBSTATUS_PLAYING) && (seq != INVALID_RTP_SEQ_NUMBER))
		UpdateVariableDelay(timestamp,curPlayPosT );
	// When receive silence detection is enabled:
    // dont play the packet if we have received at least a quarter second of silent packets.
    // This will enable switch to talk (in half-duplex mode).
	if (m_StrmConvHdr.dwDstUser == BUFFER_SILENT)
		m_SilenceDurationT += lenT;
	else
		m_SilenceDurationT = 0;	
		
	if (hr == S_OK && m_SilenceDurationT < m_fDevRecv.nSamplesPerSec/4)
	{
		LOG((LOGMSG_DSPLAY,curPlayPosT, curWritePosT, lenT));
		// check if we have space for the whole packet
		if (QMOD(curWritePosT-curPlayPosT, m_BufSizeT) > m_BufSizeT - lenT)
		{
			// no
			curPlayPosT = QMOD(curWritePosT + lenT + 1000, m_BufSizeT);
			hr = m_pDSBuf->SetCurrentPosition(SAMPLESTOBYTES(curPlayPosT));
			LOG((LOGMSG_DSMOVPOS,curPlayPosT, hr));
		}
		
		hr = m_pDSBuf->Lock(SAMPLESTOBYTES(curWritePosT),m_StrmConvHdr.cbDstLengthUsed, &p1, &cb1, &p2, &cb2, 0);
		if (hr == S_OK)
		{
			CopyMemory(p1, m_StrmConvHdr.pbDst, cb1);
			if (cb2)
				CopyMemory(p2, m_StrmConvHdr.pbDst+cb1, cb2);
			m_pDSBuf->Unlock(p1,cb1,p2,cb2);

			m_fEmpty = FALSE;
		}
		else
		{
			DEBUGMSG(ZONE_DP,("DirectSoundBuffer->Lock failed with %x\n",hr));
		}
		m_StrmConvHdr.dwDstUser = 0;	// to indicate that the decode buffer is empty again
		m_NextTimeT = timestamp + lenT;
		m_NextPosT = QMOD(curWritePosT+lenT, m_BufSizeT);
		// now calculate total queued length
		lenT = QMOD(m_NextPosT- curPlayPosT, m_BufSizeT);
		// Reset the timer to trigger shortly after  the last valid sample has played
		// The timer serves two purposes:
		// - ensure that the DS buffer is silenced before it wraps around
		// - allow the DS object to be released in the half-duplex case, once the remote stops sending
		// convert to millisecs
		// Need to make sure the timeout happens before the DS buffer wrapsaround.

		if (lenT > m_BufSizeT/2)
			lenT = m_BufSizeT/2;
		lenT = lenT * 1000/ m_fDevRecv.nSamplesPerSec;
		m_pDP->m_RecvTimer.CancelTimeout(&m_TimeoutObj);
		m_TimeoutObj.SetDueTime(GetTickCount()+lenT+100);
		m_pDP->m_RecvTimer.SetTimeout(&m_TimeoutObj);
	}
	m_PlayPosT = curPlayPosT;
	return hr;
		
}
// This routine is called on every packet to perform the adaptive delay calculation
// Remote time is measured by the RTP timestamp and local time is measured by the DirectSound
// play pointer.
// The general idea is to average how much a packet is later than its 'expected' arrival time,
// assuming the packet with the shortest trip delay is dead on time.
//
void
RecvDSAudioStream::UpdateVariableDelay(DWORD sendT, DWORD curPlayPosT)
{
#define PLAYOUT_DELAY_FACTOR	2
	LONG deltaA, deltaS;
	DWORD delay;
	// update arrival time based on how much the DS play pointer has advanced
	// since the last packet
	m_ArrT += QMOD(curPlayPosT-m_PlayPosT, m_BufSizeT);
	// m_ArrivalT0 and m_SendT0 are the arrival and send timestamps of the packet
	// with the shortest trip delay. We could have just stored (m_ArrivalT0 - m_SendT0)
	// but since the local and remote clocks are completely unsynchronized, there would
	// be signed/unsigned complications.
	deltaS = sendT - m_SendT0;
	deltaA = m_ArrT - m_ArrivalT0;
	if (deltaA < deltaS 		// this packet took less time
		|| deltaA > (int)m_fDevRecv.nSamplesPerSec*8	// reset every 8 secs
		|| deltaS < -(int)m_fDevRecv.nSamplesPerSec	// or after big timestamp jumps
		)	
	{
		delay = 0;
		// delay = deltaS - deltaA
		// replace shortest trip delay times
		m_SendT0 = sendT;
		m_ArrivalT0 = m_ArrT;
	} else {
		// variable delay is how much longer this packet took
		delay = deltaA - deltaS;
	}
	// now update average variable delay according to
	// m_AvgVarDelay = m_AvgVarDelay + (delay - m_AvgVarDelay)*1/16;
	// however we are storing the scaled average, with a scaling
	// factor of 16. So the calculation becomes
	m_ScaledAvgVarDelay = m_ScaledAvgVarDelay + (delay - m_ScaledAvgVarDelay/16);
	// now calculate actual buffering delay we will use
	//  MinDelay adds some slack (may be necessary for some drivers)
	m_DelayT = m_MinDelayT + PLAYOUT_DELAY_FACTOR * m_ScaledAvgVarDelay/16;
	if (m_DelayT > m_MaxDelayT) m_DelayT = m_MaxDelayT;

	LOG((LOGMSG_JITTER,delay, m_ScaledAvgVarDelay/16, m_DelayT));


	UPDATE_COUNTER(g_pctrAudioJBDelay, (m_DelayT * 1000)/m_fDevRecv.nSamplesPerSec);

}

void
RecvDSAudioStream::RecvTimeout()
{
	DWORD curPlayPosT, curWritePosT;
	LPVOID p1, p2;
	DWORD cb1, cb2;
	UINT lenT;
	HRESULT hr;

	if (m_pDSBuf == NULL)
	{
		WARNING_OUT(("RecvDSAudioStream::RecvTimeout - DirectSoundBuffer is not valid\r\n"));
		return;
	}


	m_pDSBuf->GetCurrentPosition(&curPlayPosT,&curWritePosT);
	curPlayPosT = BYTESTOSAMPLES(curPlayPosT);
	curWritePosT = BYTESTOSAMPLES(curWritePosT);

	// this part is cut and pasted from PlayBuf
	if (!m_fEmpty) {
		// wasn't empty last time we checked but is it empty now?
		if (QMOD(curPlayPosT-m_PlayPosT, m_BufSizeT) > QMOD(m_NextPosT-m_PlayPosT, m_BufSizeT)) {
			// play cursor has advanced beyond the last written byte
			m_fEmpty = TRUE;
		}
		// write silence into the part of the buffer that just played
		hr = m_pDSBuf->Lock(SAMPLESTOBYTES(m_PlayPosT),SAMPLESTOBYTES(QMOD(curPlayPosT-m_PlayPosT, m_BufSizeT)), &p1, &cb1, &p2, &cb2, 0);
		if (hr == S_OK) {
			ZeroMemory(p1,cb1);
			if (cb2)
				ZeroMemory(p2,cb2);
			m_pDSBuf->Unlock(p1,cb1,p2,cb2);
		}
	}
	LOG((LOGMSG_DSTIMEOUT, curPlayPosT, m_NextPosT, GetTickCount()));
	
	m_PlayPosT = curPlayPosT;
	if (!m_fEmpty) {
		// The buffer isnt quite empty yet!
		// Reschedule??
		DEBUGMSG(ZONE_DP,("DSBuffer not empty after timeout\n"));
		lenT = QMOD(m_NextPosT- curPlayPosT, m_BufSizeT);
		// Reset the timer to trigger shortly after  the last valid sample has played
		// Need to make sure the timeout happens before the DS buffer wrapsaround.
		if (lenT > m_BufSizeT/2)
			lenT = m_BufSizeT/2;
		// convert to millisecs
		lenT = lenT * 1000/ m_fDevRecv.nSamplesPerSec;
		m_TimeoutObj.SetDueTime(GetTickCount()+lenT+100);
		m_pDP->m_RecvTimer.SetTimeout(&m_TimeoutObj);
	}
	else if (m_DPFlags & DP_FLAG_HALF_DUPLEX)
	{
		// need to release the DSBuffer and DSObject
		ReleaseDSBuffer();
	}
}

HRESULT RecvDSAudioStream::RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark)
{
	HRESULT hr;

    if (m_ThreadFlags & DPTFLAG_PAUSE_RECV)
	{
		return E_FAIL;
    }

	// update number of bits received
	UPDATE_COUNTER(g_pctrAudioReceiveBytes,(pWsaBuf->len + IP_HEADER_SIZE + UDP_HEADER_SIZE)*8);

	hr = Decode((BYTE *)pWsaBuf->buf + sizeof(RTP_HDR), pWsaBuf->len - sizeof(RTP_HDR));
	if (hr == S_OK )
	{
		// Have we initialized DirectSound?
		// Yes, unless its half-duplex
		if (!m_pDSBuf)
		{
			hr = CreateDSBuffer();
		}
		if (hr == S_OK)
		{
			PlayBuf(timestamp, seq, fMark);
		}
	}
	m_pIRTPRecv->FreePacket(pWsaBuf);
	return S_OK;
}

// this method called from the UI thread only
HRESULT RecvDSAudioStream::DTMFBeep()
{
	if ( (!(m_DPFlags & DPFLAG_STARTED_RECV)) ||
		 (m_ThreadFlags & DPTFLAG_PAUSE_RECV) )
	{
		return E_FAIL;
	}

	m_pDP->RecvThreadMessage(MSG_PLAY_SOUND, this);

	return S_OK;
}


HRESULT RecvDSAudioStream::OnDTMFBeep()
{
	int nBeeps;
	DWORD dwBufSize = m_StrmConvHdr.cbDstLength;
	HRESULT hr=S_OK;
	int nIndex;

	if ( (!(m_DPFlags & DPFLAG_STARTED_RECV)) ||
		 (m_ThreadFlags & DPTFLAG_PAUSE_RECV) )
	{
		return E_FAIL;
	}

	if (dwBufSize == 0)
	{
		return E_FAIL;
	}


	nBeeps = DTMF_FEEDBACK_BEEP_MS / ((dwBufSize * 1000) / m_fDevRecv.nAvgBytesPerSec);

	if (nBeeps == 0)
	{
		nBeeps = 1;
	}

	MakeDTMFBeep(&m_fDevRecv, m_StrmConvHdr.pbDst , m_StrmConvHdr.cbDstLength);

	if (!m_pDSBuf)
	{
		hr = CreateDSBuffer();
		if (FAILED(hr))
		{
			return hr;
		}
	}


	m_StrmConvHdr.dwDstUser = BUFFER_RECEIVED;
	PlayBuf(m_NextTimeT , INVALID_RTP_SEQ_NUMBER, true);
	nBeeps--;

	for (nIndex = 0; nIndex < nBeeps; nIndex++)
	{
		m_StrmConvHdr.dwDstUser = BUFFER_RECEIVED;
		PlayBuf(m_NextTimeT, INVALID_RTP_SEQ_NUMBER, false);
	}
	
	return S_OK;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\dtmf.cpp ===
#include "precomp.h"
#include "dtmf.h"
#include <math.h>


// has to be #defines, not const int's because our build environment
// doesn't like the embedded structure stuff.
#define DTMF_ROW1_FREQ 697
#define DTMF_ROW2_FREQ 770
#define DTMF_ROW3_FREQ 852
#define DTMF_ROW4_FREQ 941

#define DTMF_COL1_FREQ 1209
#define DTMF_COL2_FREQ 1336
#define DTMF_COL3_FREQ 1477
#define DTMF_COL4_FREQ 1633
// For "A", "B", "C", "D"


// the length of all the tones are the same except for "zero"
// Zero needs longer because it just barely survives G.723 compression

const int DTMF_TONE_RAMP_MS = 60;  // ramp up/down time
const int DTMF_TONE_LENGTH_MS = 240; // includes ramp time!
const int DTMF_SILENCE_LENGTH_MS = 240; // silence gap between tones

const double DTMF_AMP_FREQ1 = 17000;
const double DTMF_AMP_FREQ2 = 14000;

struct DTMF_TONE
{
	int freq1;
	int freq2;
	int nLengthMS; // length in milliseconds
};


const int DTMF_NUM_TONES = 16;
const int DTMF_SILENCE	= -1;

DTMF_TONE DTMF_TONE_DEF_LIST[] =
{
	{DTMF_ROW4_FREQ, DTMF_COL2_FREQ, DTMF_TONE_LENGTH_MS}, //0

	{DTMF_ROW1_FREQ, DTMF_COL1_FREQ, DTMF_TONE_LENGTH_MS}, //1
	{DTMF_ROW1_FREQ, DTMF_COL2_FREQ, DTMF_TONE_LENGTH_MS}, //2
	{DTMF_ROW1_FREQ, DTMF_COL3_FREQ, DTMF_TONE_LENGTH_MS}, //3

	{DTMF_ROW2_FREQ, DTMF_COL1_FREQ, DTMF_TONE_LENGTH_MS}, //4
	{DTMF_ROW2_FREQ, DTMF_COL2_FREQ, DTMF_TONE_LENGTH_MS}, //5
	{DTMF_ROW2_FREQ, DTMF_COL3_FREQ, DTMF_TONE_LENGTH_MS}, //6

	{DTMF_ROW3_FREQ, DTMF_COL1_FREQ, DTMF_TONE_LENGTH_MS}, //7
	{DTMF_ROW3_FREQ, DTMF_COL2_FREQ, DTMF_TONE_LENGTH_MS}, //8
	{DTMF_ROW3_FREQ, DTMF_COL3_FREQ, DTMF_TONE_LENGTH_MS}, //9

	{DTMF_ROW4_FREQ, DTMF_COL1_FREQ, DTMF_TONE_LENGTH_MS}, //STAR
	{DTMF_ROW4_FREQ, DTMF_COL3_FREQ, DTMF_TONE_LENGTH_MS}, //POUND

	{DTMF_ROW1_FREQ, DTMF_COL4_FREQ, DTMF_TONE_LENGTH_MS}, //A
	{DTMF_ROW2_FREQ, DTMF_COL4_FREQ, DTMF_TONE_LENGTH_MS}, //B
	{DTMF_ROW3_FREQ, DTMF_COL4_FREQ, DTMF_TONE_LENGTH_MS}, //C
	{DTMF_ROW4_FREQ, DTMF_COL4_FREQ, DTMF_TONE_LENGTH_MS}, //D
};





DTMFQueue::DTMFQueue() : 
m_aTones(NULL),
m_bInitialized(false),
m_nQueueHead(0),
m_nQueueLength(0),
m_hEvent(NULL)
{
	InitializeCriticalSection(&m_cs);
	m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
}

DTMFQueue::~DTMFQueue()
{
	DeleteCriticalSection(&m_cs);
	ReleaseToneBank();
	CloseHandle(m_hEvent);
}


HRESULT DTMFQueue::Initialize(WAVEFORMATEX *pWaveFormat)
{
	if (m_bInitialized)
	{
		ReleaseToneBank();
	}
	m_nQueueLength = 0;
	m_nQueueHead = 0;

	return GenerateTones(pWaveFormat);
};


HRESULT DTMFQueue::GenerateTones(WAVEFORMATEX *pWaveFormat)
{
	int nIndex;
	int nToneLength;  // tone length in bytes
	int nToneLengthMS; // tone length in millisecs

	ReleaseToneBank();

	m_WaveFormat = *pWaveFormat;

    DBG_SAVE_FILE_LINE
	m_aTones = new PBYTE[DTMF_NUM_TONES];  // array of 16 tones

	if (m_aTones == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// allocate memory for each tone
	for (nIndex = 0; nIndex < DTMF_NUM_TONES; nIndex++)
	{
		nToneLengthMS = DTMF_TONE_DEF_LIST[nIndex].nLengthMS;

		nToneLength = (pWaveFormat->nSamplesPerSec) * (pWaveFormat->wBitsPerSample) / 8;
		nToneLength = (nToneLength * nToneLengthMS) / 1000;

        DBG_SAVE_FILE_LINE
		m_aTones[nIndex] = new BYTE[nToneLength];

		if (m_aTones[nIndex] == NULL)
		{
			return E_OUTOFMEMORY;
		}

		CreateDTMFTone(m_aTones[nIndex], nToneLength, nIndex);
	}

	m_bInitialized = true;
	return S_OK;
}



void DTMFQueue::CreateDTMFTone(BYTE *pTone, int nToneLength, int toneID)
{
	ZeroMemory(pTone, nToneLength);

	AddSignal(pTone, DTMF_TONE_DEF_LIST[toneID].freq1, DTMF_AMP_FREQ1, nToneLength);
	AddSignal(pTone, DTMF_TONE_DEF_LIST[toneID].freq2, DTMF_AMP_FREQ2, nToneLength);
}


void DTMFQueue::AddSignal(BYTE *pTone, int nFrequency, double dAmp, int nLength)
{
	double d;
	int nIndex;
	SHORT *aSamples = (SHORT*)pTone;
	SHORT shSample;
	BYTE nSample8;
	double dRampAmpInc, dRampAmp;
	int nRampSamples;
	const double PI = 3.1415926535897932384626433832795;


	nRampSamples = (m_WaveFormat.nSamplesPerSec * DTMF_TONE_RAMP_MS) / 1000;
	dRampAmpInc = 1.0 / nRampSamples;
	dRampAmp = 0.0;


	if (m_WaveFormat.wBitsPerSample == 16)
	{
		nLength = nLength / 2;
		for (nIndex = 0; nIndex < nLength; nIndex++)
		{
			// y = sin((x * 2 * PI * f)/SRATE)

			// d is a value between -1 and +1;
			d = sin((PI * (2.0 * (nIndex * nFrequency))) / m_WaveFormat.nSamplesPerSec);

			if (nIndex < nRampSamples)
			{
				dRampAmp = dRampAmpInc * nIndex;
			}
			else if ((nIndex+nRampSamples) >= nLength)
			{
				dRampAmp = dRampAmpInc * (nLength - nIndex - 1);
			}
			else
			{
				dRampAmp = 1.0;
			}

			shSample =  (SHORT)(dAmp * d * dRampAmp);

			aSamples[nIndex] += shSample;
		}

		return;
	}

	// 8-bit samples have a center point of 128
	// must invert high order bit to compensate
	for (nIndex = 0; nIndex < nLength; nIndex++)
	{
		d = sin((PI * (2.0 * (nIndex * nFrequency))) / m_WaveFormat.nSamplesPerSec);

		if (nIndex < nRampSamples)
		{
			dRampAmp = dRampAmpInc * nIndex;
		}
		else if ((nIndex+nRampSamples) >= nLength)
		{
			dRampAmp = dRampAmpInc * (nLength - nIndex - 1);
		}
		else
		{
			dRampAmp = 1.0;
		}


		shSample =  (SHORT)(dAmp * d * dRampAmp);
		shSample = (shSample >> 8) & 0x00ff;
		nSample8 = (BYTE)shSample;
		nSample8 = nSample8 ^ 0x80;
		pTone[nIndex] = nSample8;
	}
	return;
};




void DTMFQueue::ReleaseToneBank()
{
	int nIndex;
	if (m_aTones)
	{
		for (nIndex = 0; nIndex < DTMF_NUM_TONES; nIndex++)
		{
			delete [] m_aTones[nIndex];
		}
		delete [] m_aTones;
		m_aTones = NULL;
	}
	
	m_bInitialized = false;
}


HRESULT DTMFQueue::AddDigitToQueue(int nDigit)
{
	int nQueueIndex;
	int nToneLength, nToneLengthMS;
	int nSilenceLength;

	if (m_bInitialized == false)
		return E_FAIL;

	if ((nDigit < 0) || (nDigit >= DTMF_NUM_TONES))
	{
		return E_FAIL;
	}

	EnterCriticalSection(&m_cs);
	
	if (m_nQueueLength >= (DTMF_QUEUE_SIZE-1))
	{
		LeaveCriticalSection(&m_cs);
		return E_FAIL;
	}

	nToneLengthMS = DTMF_TONE_DEF_LIST[nDigit].nLengthMS;
	nToneLength = (m_WaveFormat.nSamplesPerSec) * (m_WaveFormat.wBitsPerSample) / 8;

	nSilenceLength = (nToneLength * DTMF_SILENCE_LENGTH_MS) / 1000;
	nToneLength = (nToneLength * nToneLengthMS) / 1000;


	// add silence to pad between tones.  Also helps to "reset" the codec
	// to a good state
	nQueueIndex = (m_nQueueHead + m_nQueueLength) % DTMF_QUEUE_SIZE;
	m_aTxQueue[nQueueIndex].nBytesToCopy = nSilenceLength;
	m_aTxQueue[nQueueIndex].nToneID = DTMF_SILENCE;
	m_aTxQueue[nQueueIndex].nOffsetStart = 0;
	m_nQueueLength++;

	// add the tone to the read queue
	nQueueIndex = (m_nQueueHead + m_nQueueLength) % DTMF_QUEUE_SIZE;
	m_aTxQueue[nQueueIndex].nBytesToCopy = nToneLength;
	m_aTxQueue[nQueueIndex].nToneID = nDigit;
	m_aTxQueue[nQueueIndex].nOffsetStart = 0;
	m_nQueueLength++;


	LeaveCriticalSection(&m_cs);
	return S_OK;
	
}


HRESULT DTMFQueue::ReadFromQueue(BYTE *pBuffer, UINT uSize)
{
	DTMF_TX_ELEMENT *pQueueElement;
	int nSilenceOffset;
	BYTE fillByte;

	if (m_bInitialized == false)
		return E_FAIL;

	if (m_WaveFormat.wBitsPerSample == 8)
	{
		fillByte = 0x80;
	}
	else
	{
		ASSERT((uSize % 2) == 0); // uSize must be even for 16-bit fills
		fillByte = 0;
	}

	EnterCriticalSection(&m_cs);

	if (m_nQueueLength <= 0)
	{
		LeaveCriticalSection(&m_cs);
		return E_FAIL;
	}

	pQueueElement = &m_aTxQueue[m_nQueueHead];

	if (pQueueElement->nBytesToCopy <= (int)uSize)
	{
		if (pQueueElement->nToneID == DTMF_SILENCE)
		{
			FillMemory(pBuffer, uSize, fillByte);
		}
		else
		{
			CopyMemory(pBuffer, pQueueElement->nOffsetStart + m_aTones[pQueueElement->nToneID], pQueueElement->nBytesToCopy);
			FillMemory(pBuffer+(pQueueElement->nBytesToCopy), uSize-(pQueueElement->nBytesToCopy), fillByte);
		}
		m_nQueueHead = (m_nQueueHead + 1) % DTMF_QUEUE_SIZE;
		m_nQueueLength--;
	}


	else
	{
		if (pQueueElement->nToneID == DTMF_SILENCE)
		{
			FillMemory(pBuffer, uSize, fillByte);
		}
		else
		{
			CopyMemory(pBuffer, pQueueElement->nOffsetStart + m_aTones[pQueueElement->nToneID], uSize);
		}
		pQueueElement->nBytesToCopy -= uSize;
		pQueueElement->nOffsetStart += uSize;
	}

	LeaveCriticalSection(&m_cs);

	return S_OK;
}

HRESULT DTMFQueue::ClearQueue()
{
	if (m_bInitialized == false)
		return E_FAIL;


	EnterCriticalSection(&m_cs);
	m_nQueueHead = 0;
	m_nQueueLength = 0;
	LeaveCriticalSection(&m_cs);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\intif.h ===
/*
 *  	File: intif.h
 *
 *      
 *
 *		Revision History:
 *
 *		05/06/96	mikev	created
 */
 

#ifndef _INTIF_H
#define _INTIF_H

//
//	Internal interface classes
//
class IConfAdvise;
class IControlChannel;
class IH323PubCap;

typedef IControlChannel *LPIControlChannel;
typedef IConfAdvise* LPIConfAdvise;
typedef IH323PubCap *LPIH323PubCap;

#endif //_INTIF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\h323caps.cpp ===
/*
 *    File: h323caps.cpp
 *
 *    H.323/H.245 specific implementation of Microsoft A/V capability
 *       interface methods.  (Contained in CMsiaCapability class)
 *
 *    Revision History:
 *
 *    09/10/96 mikev created
 * 	  10/08/96 mikeg - created h323vidc.cpp
 *    11/04/96 mikev - cleanup and merge audio and video capability classes (remove
 * 				common inheritance of IH323PubCap, both audio and video implementation
 *				classes inherit from IH323MediaCap. )
 */


#include "precomp.h"

#define SAMPLE_BASED_SAMPLES_PER_FRAME 8
#define MAX_FRAME_LEN   480      //bytes  -  where did this value come from?
#define MAX_FRAME_LEN_RECV	1440  // 180 ms at 8000hz G.711

//	some utility functions for calculating frame sizes and frames per packet

HRESULT WINAPI CreateMediaCapability(REFGUID mediaId, LPIH323MediaCap * ppMediaCapability)
{
	HRESULT hrLast = E_OUTOFMEMORY;
	
	if (!ppMediaCapability)
		return E_POINTER;
	if (mediaId == MEDIA_TYPE_H323AUDIO)
	{
   		CMsiaCapability * pAudObj = NULL;
   		UINT uAud;

        DBG_SAVE_FILE_LINE
   		pAudObj = new CMsiaCapability;

   		if(pAudObj)
   		{

			hrLast = pAudObj->QueryInterface(IID_IH323MediaCap, (void **)ppMediaCapability);
			pAudObj->Release(); // this balances the refcount of "new CMsiaCapability"
			pAudObj = NULL;
		}


    }
	else if (mediaId == MEDIA_TYPE_H323VIDEO)
	{
		CMsivCapability * pVidObj = NULL;

        DBG_SAVE_FILE_LINE
		pVidObj = new CMsivCapability;
	   	if(pVidObj)
		{
		
			hrLast = pVidObj->QueryInterface(IID_IH323MediaCap, (void **)ppMediaCapability);
			pVidObj->Release(); // this balances the refcount of "new CMsivCapability"
			pVidObj = NULL;
		}
		
	}
	else
		hrLast = E_NOINTERFACE;
	if(HR_SUCCEEDED(hrLast))
	{
		if (!(*ppMediaCapability)->Init())
		{
			(*ppMediaCapability)->Release();
			hrLast = E_FAIL;
			*ppMediaCapability = NULL;
		}
	}
	return hrLast;	
}

//
//	CMsiaCapability
//
UINT CMsiaCapability::GetLocalSendParamSize(MEDIA_FORMAT_ID dwID)
{
	return (sizeof(AUDIO_CHANNEL_PARAMETERS));
}
UINT CMsiaCapability::GetLocalRecvParamSize(PCC_TERMCAP pCapability)
{
	return (sizeof(AUDIO_CHANNEL_PARAMETERS));
}


HRESULT CMsiaCapability::CreateCapList(LPVOID *ppCapBuf)
{
	UINT u;
	AUDCAP_DETAILS *pDecodeDetails = pLocalFormats;
	PCC_TERMCAPLIST   pTermCapList = NULL;
	PPCC_TERMCAP  ppCCThisTermCap = NULL;
		
	PCC_TERMCAP  pCCThisCap = NULL;
	PNSC_AUDIO_CAPABILITY pNSCapNext = NULL;
	LPWAVEFORMATEX lpwfx;
	HRESULT hr = hrSuccess;
	FX_ENTRY ("CreateCapList");
	// validate input
	if(!ppCapBuf)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto ERROR_OUT;
	}
	*ppCapBuf = NULL;
	if(!uNumLocalFormats || !pDecodeDetails)
	{
		hr = CAPS_E_NOCAPS;
		goto ERROR_OUT;
	}

	pTermCapList = (PCC_TERMCAPLIST)MemAlloc(sizeof(CC_TERMCAPLIST));
	if(!pTermCapList)
	{
		hr = CAPS_E_NOMEM;
		goto ERROR_OUT;		
	}
	ppCCThisTermCap = (PPCC_TERMCAP)MemAlloc(uNumLocalFormats * sizeof(PCC_TERMCAP));
	if(!ppCCThisTermCap)
	{
		hr = CAPS_E_NOMEM;
		goto ERROR_OUT;		
	}
	pTermCapList->wLength = 0;
	// point the CC_TERMCAPLIST pTermCapArray at the array of PCC_TERMCAP
	pTermCapList->pTermCapArray = ppCCThisTermCap;
	/*
					CC_TERMCAPLIST       PCC_TERMCAP        CC_TERMCAP

  pTermCapList->    {
						wLength
						pTermCapArray--->pTermCap----------->{single capability.....}
					}
										pTermCap----------->{single capability.}
			
										pTermCap----------->{single capability...}

    */

	for(u=0; u <uNumLocalFormats; u++)
	{
		// check if enabled for receive, skip if false
		// also skip if public version of capabilities is to be advertised via a
		// separate local capability entry
		if((!pDecodeDetails->bRecvEnabled ) || (pDecodeDetails->dwPublicRefIndex))
		{
			pDecodeDetails++;
			continue;
		}

		if(pDecodeDetails->H245TermCap.ClientType ==0
				|| pDecodeDetails->H245TermCap.ClientType ==H245_CLIENT_AUD_NONSTD)
		{

			lpwfx = (LPWAVEFORMATEX)pDecodeDetails->lpLocalFormatDetails;
			if(!lpwfx)
			{
				pDecodeDetails++;
				continue;
			}
			// allocate for this one capability
			pCCThisCap = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP));		
			pNSCapNext = (PNSC_AUDIO_CAPABILITY)MemAlloc(sizeof(NSC_AUDIO_CAPABILITY)
				+ lpwfx->cbSize);
				
			if((!pCCThisCap)|| (!pNSCapNext))
			{
				hr = CAPS_E_NOMEM;
				goto ERROR_OUT;		
			}
			// set type of nonstandard capability
			pNSCapNext->cap_type = NSC_ACM_WAVEFORMATEX;
			// stuff both chunks of nonstandard capability info into buffer
			// first stuff the "channel parameters" (the format independent communication options)
			memcpy(&pNSCapNext->cap_params, &pDecodeDetails->nonstd_params, sizeof(NSC_CHANNEL_PARAMETERS));
			
			// then the ACM stuff
			memcpy(&pNSCapNext->cap_data.wfx, lpwfx, sizeof(WAVEFORMATEX) + lpwfx->cbSize);

			pCCThisCap->ClientType = H245_CLIENT_AUD_NONSTD;
			pCCThisCap->DataType = H245_DATA_AUDIO;
			// is this a "receive only" cap or a send&receive cap
			pCCThisCap->Dir = (pDecodeDetails->bSendEnabled && bPublicizeTXCaps)
				? H245_CAPDIR_LCLRXTX :H245_CAPDIR_LCLRX;

			// convert index of the cap entry to the ID
			pCCThisCap->CapId = (USHORT)IndexToId(u);

			// all nonstandard identifier fields are unsigned short
			// two possibilities for choice are "h221NonStandard_chosen" and "object_chosen"
			pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice = h221NonStandard_chosen;
			// NOTE: there is some question about the correct byte order
			// of the codes in the h221NonStandard structure
			pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode = USA_H221_COUNTRY_CODE;
			pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension = USA_H221_COUNTRY_EXTENSION;
			pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = MICROSOFT_H_221_MFG_CODE;

			// set size of buffer
			pCCThisCap->Cap.H245Aud_NONSTD.data.length = sizeof(NSC_AUDIO_CAPABILITY) + lpwfx->cbSize;
			pCCThisCap->Cap.H245Aud_NONSTD.data.value = (BYTE *)pNSCapNext;   // point to nonstandard stuff

			// pNSCapNext is now referenced by the pTermCapList and will
			// be cleaned up via DeleteCapList(). Null the ptr so that error cleanup
			// won't try redundant cleanup.
			pNSCapNext = NULL;
		}
		else
		{
			// allocate for this one capability
			pCCThisCap = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP));		
			if(!pCCThisCap)
			{
				hr = CAPS_E_NOMEM;
				goto ERROR_OUT;		
			}
			
			pCCThisCap->ClientType = (H245_CLIENT_T)pDecodeDetails->H245TermCap.ClientType;
			pCCThisCap->DataType = H245_DATA_AUDIO;
			// is this a "receive only" cap or a send&receive cap
			pCCThisCap->Dir = (pDecodeDetails->bSendEnabled && bPublicizeTXCaps)
				? H245_CAPDIR_LCLRXTX :H245_CAPDIR_LCLRX;
			
			// convert the index of the cap entry to the ID
			pCCThisCap->CapId = (USHORT)IndexToId(u);//

			// Fixup capability parameters based on local details
			// use parameters that should have been set when codecs were enumerated
			// Special note for sample based codecs: H.225.0 Section 6.2.1 states
			// "Sample based codecs, such as G.711 and G.722 shall be considered to be
			// frame oriented, with a frame size of eight samples."
			switch  (pCCThisCap->ClientType )
			{

				case H245_CLIENT_AUD_G711_ALAW64:
					pCCThisCap->Cap.H245Aud_G711_ALAW64 =
						pDecodeDetails->nonstd_params.wFramesPerPktMax
						/ SAMPLE_BASED_SAMPLES_PER_FRAME;
				break;
				case H245_CLIENT_AUD_G711_ULAW64:
					pCCThisCap->Cap.H245Aud_G711_ULAW64 =
						pDecodeDetails->nonstd_params.wFramesPerPktMax
						/SAMPLE_BASED_SAMPLES_PER_FRAME ;
				break;

				case H245_CLIENT_AUD_G723:
					
					pCCThisCap->Cap.H245Aud_G723.maxAl_sduAudioFrames =   //4
						pDecodeDetails->nonstd_params.wFramesPerPktMax;
					// we know that the G.723 codec can decode SID in any mode, so
					//could we always advertise the *capability* to do silence suppression ????
				
					pCCThisCap->Cap.H245Aud_G723.silenceSuppression = 0;
						// = (pDecodeDetails->nonstd_params.UseSilenceDet)?1:0;
				break;
				default:
				break;
			}
		}
		pDecodeDetails++;
		*ppCCThisTermCap++ = pCCThisCap;// add ptr to this capability to the array
		pTermCapList->wLength++;      	// count this entry
		// pCCThisCap is now referenced by the pTermCapList and will
		// be cleaned up via DeleteCapList(). Null the ptr so that error cleanup
		// won't try redundant cleanup.
		pCCThisCap = NULL;
	}
	*ppCapBuf = pTermCapList;
	return hr;

ERROR_OUT:
	if(pTermCapList)
	{
		DeleteCapList(pTermCapList);
	}
	if(pCCThisCap)
		MemFree(pCCThisCap);
	if(pNSCapNext)
		MemFree(pNSCapNext);
	return hr;


}

HRESULT CMsiaCapability::DeleteCapList(LPVOID pCapBuf)
{
	UINT u;
	PCC_TERMCAPLIST pTermCapList = (PCC_TERMCAPLIST)pCapBuf;
	PCC_TERMCAP  pCCThisCap;
	PNSC_AUDIO_CAPABILITY pNSCap;
	
	if(!pTermCapList)
	{
		return CAPS_E_INVALID_PARAM;
	}

	if(pTermCapList->pTermCapArray)						
	{
		while(pTermCapList->wLength--)
		{
			pCCThisCap = *(pTermCapList->pTermCapArray + pTermCapList->wLength);
			if(pCCThisCap)
			{
				if(pCCThisCap->ClientType == H245_CLIENT_AUD_NONSTD)
				{
					if(pCCThisCap->Cap.H245Aud_NONSTD.data.value)
					{
						MemFree(pCCThisCap->Cap.H245Aud_NONSTD.data.value);
					}
				}
				MemFree(pCCThisCap);
			}
		}
		MemFree(pTermCapList->pTermCapArray);
	}
	MemFree(pTermCapList);
	return hrSuccess;
}


// copies relevant fields from a real H245 TERMCAP struct
// to a local H245TermCap struct
void CopyTermCapInfo(PCC_TERMCAP pSrc, H245_TERMCAP *pDest)
{
	ZeroMemory(pDest, sizeof(*pDest));

	pDest->Dir        = pSrc->Dir;
	pDest->DataType   = pSrc->DataType;
	pDest->ClientType = pSrc->ClientType;
	pDest->CapId      = pSrc->CapId;

	pDest->H245_NonStd    = pSrc->Cap.H245_NonStd;
	pDest->H245Aud_NONSTD = pSrc->Cap.H245Aud_NONSTD;

	pDest->H245Aud_G711_ALAW64 = pSrc->Cap.H245Aud_G711_ALAW64;
	pDest->H245Aud_G711_ULAW64 = pSrc->Cap.H245Aud_G711_ULAW64;
	pDest->H245Aud_G723        = pSrc->Cap.H245Aud_G723;

	return;
}


void CopyLocalTermCapInfo(H245_TERMCAP *pSrc, PCC_TERMCAP pDest)
{
	ZeroMemory(pDest, sizeof(*pDest));

	pDest->Dir        = pSrc->Dir;
	pDest->DataType   = pSrc->DataType;
	pDest->ClientType = pSrc->ClientType;
	pDest->CapId      = pSrc->CapId;

	pDest->Cap.H245_NonStd    = pSrc->H245_NonStd;
	pDest->Cap.H245Aud_NONSTD = pSrc->H245Aud_NONSTD;

	pDest->Cap.H245Aud_G711_ALAW64 = pSrc->H245Aud_G711_ALAW64;
	pDest->Cap.H245Aud_G711_ULAW64 = pSrc->H245Aud_G711_ULAW64;
	pDest->Cap.H245Aud_G723        = pSrc->H245Aud_G723;

	return;
}




// the intent is to keep a copy of the channel parameters used to open a send channel
// that the remote end can decode.

AUDIO_FORMAT_ID CMsiaCapability::AddRemoteDecodeFormat(PCC_TERMCAP pCCThisCap)
{
	FX_ENTRY ("CMsiaCapability::AddRemoteDecodeFormat");

	AUDCAP_DETAILS audcapdetails =
		{WAVE_FORMAT_UNKNOWN, NONSTD_TERMCAP,  STD_CHAN_PARAMS,
		{RTP_DYNAMIC_MIN, 8000, 4},
		0, TRUE, TRUE, 320, 32000,32000,50,0,0,0,NULL,0, NULL,""};

	LPVOID lpData = NULL;
	UINT uSize = 0;
	AUDCAP_DETAILS *pTemp;
	if(!pCCThisCap)
	{
		return INVALID_AUDIO_FORMAT;
	}
	
	// check room
	if(uRemoteDecodeFormatCapacity <= uNumRemoteDecodeFormats)
	{
		// get more mem, realloc memory by CAP_CHUNK_SIZE for pRemoteDecodeFormats
		pTemp = (AUDCAP_DETAILS *)MemAlloc((uNumRemoteDecodeFormats + CAP_CHUNK_SIZE)*sizeof(AUDCAP_DETAILS));
		if(!pTemp)
			goto ERROR_EXIT;
		// remember how much capacity we now have
		uRemoteDecodeFormatCapacity = uNumRemoteDecodeFormats + CAP_CHUNK_SIZE;
		#ifdef DEBUG
		if((uNumRemoteDecodeFormats && !pRemoteDecodeFormats) || (!uNumRemoteDecodeFormats && pRemoteDecodeFormats))
		{
			ERRORMESSAGE(("%s:leak! uNumRemoteDecodeFormats:0x%08lX, pRemoteDecodeFormats:0x%08lX\r\n",
				_fx_, uNumRemoteDecodeFormats,pRemoteDecodeFormats));
		}
		#endif
		// copy old stuff, discard old mem
		if(uNumRemoteDecodeFormats && pRemoteDecodeFormats)
		{
			memcpy(pTemp, pRemoteDecodeFormats, uNumRemoteDecodeFormats*sizeof(AUDCAP_DETAILS));
			MemFree(pRemoteDecodeFormats);
		}
		pRemoteDecodeFormats = pTemp;
	}
	// pTemp is where the stuff is cached
	pTemp = pRemoteDecodeFormats+uNumRemoteDecodeFormats;

	// fixup the capability structure being added.  First thing: initialize defaults
	memcpy(pTemp, &audcapdetails, sizeof(AUDCAP_DETAILS));
	// next, the H245 parameters

//	memcpy(&pTemp->H245Cap, pCCThisCap, sizeof(pTemp->H245Cap));
	CopyTermCapInfo(pCCThisCap, &pTemp->H245TermCap);
	
	// Note: if nonstandard data exists, the nonstd pointers need to be fixed up
	if(pCCThisCap->ClientType == H245_CLIENT_AUD_NONSTD)
	{
		// do we recognize this?
		if(pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			if((pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode == USA_H221_COUNTRY_CODE)
			&& (pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension == USA_H221_COUNTRY_EXTENSION)
			&& (pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode == MICROSOFT_H_221_MFG_CODE))
			{
				// ok, this is ours so far. Now what data type is contained therein?
				// welllll, lets keep a copy of this regardless ????.  If we can't understand
				// future versions of ourselves, then what???
				uSize = pCCThisCap->Cap.H245Aud_NONSTD.data.length;
				lpData = pCCThisCap->Cap.H245Aud_NONSTD.data.value;
			}
		}
	} else {
		// set up the NSC_CHANNEL_PARAMETERS struct based on the remote H245 parameters
		
		switch(pCCThisCap->ClientType )  {
			case H245_CLIENT_AUD_G711_ALAW64:
				pTemp->nonstd_params.wFramesPerPktMax = pCCThisCap->Cap.H245Aud_G711_ALAW64
							* SAMPLE_BASED_SAMPLES_PER_FRAME;
			break;
			case H245_CLIENT_AUD_G711_ULAW64:
				pTemp->nonstd_params.wFramesPerPktMax = pCCThisCap->Cap.H245Aud_G711_ULAW64
							* SAMPLE_BASED_SAMPLES_PER_FRAME;
			break;

			case H245_CLIENT_AUD_G723:
				
				pTemp->nonstd_params.wFramesPerPktMax =pCCThisCap->Cap.H245Aud_G723.maxAl_sduAudioFrames;
				// do we care about silence suppression?
				pTemp->nonstd_params.UseSilenceDet = pCCThisCap->Cap.H245Aud_G723.silenceSuppression;
			break;
			default:
			break;
		}
	}
			
	pTemp->uLocalDetailsSize = 0; // we're not keeping another copy of local encode details
	pTemp->lpLocalFormatDetails =0; // we're not keeping another copy of local encode details
	
	pTemp->uRemoteDetailsSize = 0;   // clear this now
	if(uSize && lpData)
	{
		pTemp->H245TermCap.H245Aud_NONSTD.data.length = uSize;
		pTemp->H245TermCap.H245Aud_NONSTD.data.value = (unsigned char *)lpData;
		
		pTemp->lpRemoteFormatDetails = MemAlloc(uSize);
		if(pTemp->lpRemoteFormatDetails)
		{
			memcpy(pTemp->lpRemoteFormatDetails, lpData, uSize);
			pTemp->uRemoteDetailsSize = uSize;
				
		}
		#ifdef DEBUG
			else
			{
				ERRORMESSAGE(("%s:allocation failed!\r\n",_fx_));
			}
		#endif
	}
	else
	{
		pTemp->lpRemoteFormatDetails = NULL;
		pTemp->uRemoteDetailsSize =0;
	}
	uNumRemoteDecodeFormats++;
	// use the index as the ID
	return (uNumRemoteDecodeFormats-1);

	ERROR_EXIT:
	return INVALID_AUDIO_FORMAT;
			
}

BOOL CMsiaCapability::IsCapabilityRecognized(PCC_TERMCAP pCCThisCap)
{
	FX_ENTRY ("CMsiaCapability::IsCapabilityRecognized");
	if(pCCThisCap->DataType != H245_DATA_AUDIO)
		return FALSE;
		
	if(pCCThisCap->ClientType == H245_CLIENT_AUD_NONSTD)
	{
		// do we recognize this?
		if(pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			if((pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode == USA_H221_COUNTRY_CODE)
			&& (pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension == USA_H221_COUNTRY_EXTENSION)
			&& (pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode == MICROSOFT_H_221_MFG_CODE))

			{
				// ok, this is ours so far. Now what data type is contained therein?
				// welllll, lets keep a copy of this regardless ????.  If we can't understand
				// future versions of ourselves, then what???
				return TRUE;
			}
			else
			{
				// unrecognized nonstandard capability
				ERRORMESSAGE(("%s:unrecognized nonstd capability\r\n",_fx_));
#ifdef DEBUG
				VOID DumpNonstdParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2);
				DumpNonstdParameters(NULL, pCCThisCap);
#endif
				return FALSE;
			}
		}
	}
	return TRUE;
}
HRESULT CMsiaCapability::AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList)
{
	FX_ENTRY ("CMsiaCapability::AddRemoteDecodeCaps");
	HRESULT hr = hrSuccess;
	PPCC_TERMCAP ppCCThisCap;
	PCC_TERMCAP pCCThisCap;

	WORD wNumCaps;

		//ERRORMESSAGE(("%s,\r\n", _fx_));
	if(!pTermCapList)    // additional capability descriptors may be added
	{                                // at any time
		return CAPS_E_INVALID_PARAM;
	}

	// cleanup old term caps if term caps are being added and old caps exist
	FlushRemoteCaps();
	
	wNumCaps = pTermCapList->wLength;
	ppCCThisCap = pTermCapList->pTermCapArray;
	
/*
					CC_TERMCAPLIST       TERMCAPINFO       CC_TERMCAP

	pTermCapList-> {
						wLength
						pTermCapInfo--->pTermCap----------->{single capability.....}
					}
										pTermCap----------->{single capability.}

										pTermCap----------->{single capability...}

*/
	while(wNumCaps--)
	{
		if(!(pCCThisCap = *ppCCThisCap++))
		{
			ERRORMESSAGE(("%s:null pTermCap, 0x%04x of 0x%04x\r\n",
				_fx_, pTermCapList->wLength - wNumCaps, pTermCapList->wLength));
			continue;
		}
		if(!IsCapabilityRecognized(pCCThisCap))
		{
			continue;
		}
		AddRemoteDecodeFormat(pCCThisCap);
	}
	return hr;
}



// Given the ID of a local format, gets the channel parameters that are sent to the
// remote end as part of the capability exchange.  This function is not used by the
// capability exchange code (because it sends more than just these parameters).
// However, this is useful information by itself - it can be used for validating the
// parameters of channel open requests against the expected parameters

HRESULT CMsiaCapability::GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, AUDIO_FORMAT_ID id)
{
	UINT uIndex = IDToIndex(id);
	//    validate input
	if(!pBufOut|| (uIndex >= (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(uBufSize < sizeof(CC_TERMCAP))
	{
		return CAPS_E_BUFFER_TOO_SMALL;
	}
//	memcpy(pBufOut, &((pLocalFormats + uIndex)->H245Cap), sizeof(CC_TERMCAP));
	CopyLocalTermCapInfo(&((pLocalFormats + uIndex)->H245TermCap), (PCC_TERMCAP)pBufOut);

	return hrSuccess;
}

HRESULT CMsiaCapability::SetAudioPacketDuration(UINT uPacketDuration)
{
	m_uPacketDuration = uPacketDuration;
	return S_OK;
}

// Given the IDs of  "matching" local and remote formats, gets the preferred channel parameters
// that will be used in requests to open a channel for sending to the remote.

HRESULT CMsiaCapability::GetEncodeParams(LPVOID pBufOut, UINT uBufSize,LPVOID pLocalParams, UINT uSizeLocal,
	AUDIO_FORMAT_ID idRemote, AUDIO_FORMAT_ID idLocal)
{
	UINT uLocalIndex = IDToIndex(idLocal);
	AUDCAP_DETAILS *pLocalDetails  = pLocalFormats + uLocalIndex;
	AUDCAP_DETAILS *pFmtTheirs;
	AUDIO_CHANNEL_PARAMETERS local_params;
	PNSC_CHANNEL_PARAMETERS  pNSRemoteParams;
	LPWAVEFORMATEX lpwfx;

	UINT u;
	PCC_TERMCAP pTermCap = (PCC_TERMCAP)pBufOut;
	//    validate input
	if(!pBufOut)
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(uBufSize < sizeof(CC_TERMCAP))
	{
		return CAPS_E_BUFFER_TOO_SMALL;
	}
	if(!pLocalParams|| uSizeLocal < sizeof(AUDIO_CHANNEL_PARAMETERS)
		||(uLocalIndex >= (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}

	pFmtTheirs = pRemoteDecodeFormats;     // start at the beginning of the remote formats
	for(u=0; u<uNumRemoteDecodeFormats; u++)
	{
		if(pFmtTheirs->H245TermCap.CapId == idRemote)
		{
			// copy CC_TERMCAP struct. Any data referenced by CC_TERMCAP now has
			// two references to it.  i.e. pTermCap->extrablah is the same
			// location as pFmtTheirs->extrablah
//			memcpy(pBufOut, &(pFmtTheirs->H245Cap), sizeof(CC_TERMCAP));
			CopyLocalTermCapInfo(&(pFmtTheirs->H245TermCap), (PCC_TERMCAP)pBufOut);

			break;
		}
		pFmtTheirs++;  // next entry in receiver's caps
	}

	// check for an unfound format
	if(u >= uNumRemoteDecodeFormats)
		goto ERROR_EXIT;
		
	// select channel parameters if appropriate.   The audio formats that have variable parameters
	// are :
	
	// H245_CAP_G723_T               H245Aud_G723;
	// H245_CAP_AIS11172_T           H245Aud_IS11172;
	// H245_CAP_IS13818_T            H245Aud_IS13818;
	// and of course all nonstandard formats

	// Select parameters based on local capability info
	
	// initialize local_params with  default settings
	memcpy(&local_params.ns_params,&pLocalDetails->nonstd_params,sizeof(local_params.ns_params));

	// recalculate frames per packet
	lpwfx = (LPWAVEFORMATEX)pLocalDetails->lpLocalFormatDetails;
	local_params.ns_params.wFramesPerPktMax = LOWORD(MaxFramesPerPacket(lpwfx));
	local_params.ns_params.wFramesPerPkt =  LOWORD(MinFramesPerPacket(lpwfx));
	if(local_params.ns_params.wFramesPerPktMin > local_params.ns_params.wFramesPerPkt)
	{
		local_params.ns_params.wFramesPerPktMin = local_params.ns_params.wFramesPerPkt;
	}


	
	if(pTermCap->ClientType == H245_CLIENT_AUD_G723)
	{
		// select frames per packet based on minimum latency value that is acceptable
		pTermCap->Cap.H245Aud_G723.maxAl_sduAudioFrames =  //4
		  min(local_params.ns_params.wFramesPerPkt, pTermCap->Cap.H245Aud_G723.maxAl_sduAudioFrames);
		// pLocalDetails->nonstd_params.wFramesPerPktMax;
		// never request silence suppression
		pTermCap->Cap.H245Aud_G723.silenceSuppression = 0;
			// (pLocalDetails->nonstd_params.UseSilenceDet)?1:0;

		// keep a copy of the selected parameters for use on the local side
		local_params.ns_params.wFramesPerPkt = 	local_params.ns_params.wFramesPerPktMin =
			local_params.ns_params.wFramesPerPktMax = pTermCap->Cap.H245Aud_G723.maxAl_sduAudioFrames;
		local_params.ns_params.UseSilenceDet = pTermCap->Cap.H245Aud_G723.silenceSuppression;
		local_params.RTP_Payload = pLocalDetails->audio_params.RTPPayload;
	}
	else if(pTermCap->ClientType == H245_CLIENT_AUD_G711_ALAW64)
	{
		// select frames per packet based on minimum latency value that is acceptable
		pTermCap->Cap.H245Aud_G711_ALAW64 =
		  min(local_params.ns_params.wFramesPerPkt/SAMPLE_BASED_SAMPLES_PER_FRAME, pTermCap->Cap.H245Aud_G711_ALAW64);
		// keep a copy of the selected parameters for use on the local side
		local_params.ns_params.wFramesPerPkt = 	local_params.ns_params.wFramesPerPktMin =
			local_params.ns_params.wFramesPerPktMax = pTermCap->Cap.H245Aud_G711_ALAW64*SAMPLE_BASED_SAMPLES_PER_FRAME;
		local_params.ns_params.UseSilenceDet = FALSE;
		// note that local_params.RTP_Payload is fixed below
	}
	else if(pTermCap->ClientType == H245_CLIENT_AUD_G711_ULAW64)
	{
		// select frames per packet based on minimum latency value that is acceptable
		pTermCap->Cap.H245Aud_G711_ULAW64 =
		  min(local_params.ns_params.wFramesPerPkt/SAMPLE_BASED_SAMPLES_PER_FRAME, pTermCap->Cap.H245Aud_G711_ULAW64);
		// keep a copy of the selected parameters for use on the local side
		local_params.ns_params.wFramesPerPkt = 	local_params.ns_params.wFramesPerPktMin =
			local_params.ns_params.wFramesPerPktMax = pTermCap->Cap.H245Aud_G711_ULAW64*SAMPLE_BASED_SAMPLES_PER_FRAME;
		local_params.ns_params.UseSilenceDet = FALSE;
		// note that local_params.RTP_Payload is fixed below
	}
	else if (pTermCap->ClientType == H245_CLIENT_AUD_NONSTD)
	{
		
	// note:  "H245_CLIENT_AUD_NONSTD H245Aud_NONSTD;" also has variable parameters in the
	// form of a pointer to a chunk of nonstandard data.  This pointer and the nonstandard
	// data it points to was set when remote caps were received (see AddRemoteDecodeCaps ()).
	// So as of this point, we just copied that nonstandard data back out into the channel
	// parameters.  We will use these parameters to request an open channel.

	// once we fix up a few important parameters. set channel params based on local params
		
		
		pNSRemoteParams = &((PNSC_AUDIO_CAPABILITY)(pTermCap->Cap.H245Aud_NONSTD.data.value))->cap_params;

		// LOOKLOOK ---- which parameters do we really need to select ???
		// For example, if wFrameSizeMin != wFrameSizeMax, do we pick something in the range?
		// or own favorite value?  what else?

		if(pNSRemoteParams->wFrameSizeMax < pNSRemoteParams->wFrameSize) // fixup bogus parameters
		    pNSRemoteParams->wFrameSizeMax = pNSRemoteParams->wFrameSize;
		
		// note that this writes on the memory that is caching remote capabilities
		// set frame size to our preferred size unless remote can't take it that big
		pNSRemoteParams->wFrameSize =
				min(local_params.ns_params.wFrameSize, pNSRemoteParams->wFrameSizeMax);
		pNSRemoteParams->wFramesPerPkt = min( local_params.ns_params.wFramesPerPkt,
				pNSRemoteParams->wFramesPerPktMax);

		// use optional stuff only of both sides have it
		pNSRemoteParams->UseSilenceDet = pNSRemoteParams->UseSilenceDet && local_params.ns_params.UseSilenceDet;
		pNSRemoteParams->UsePostFilter = pNSRemoteParams->UsePostFilter && local_params.ns_params.UsePostFilter;
		
		// keep a copy of the selected parameters for use on the local side
		memcpy(&local_params.ns_params, pNSRemoteParams, sizeof(NSC_CHANNEL_PARAMETERS));
	}

	// fix payload type
	local_params.RTP_Payload = pLocalDetails->audio_params.RTPPayload;
	memcpy(pLocalParams, &local_params, sizeof(AUDIO_CHANNEL_PARAMETERS));
	
	return hrSuccess;

	ERROR_EXIT:
	return CAPS_E_INVALID_PARAM;
}


// Given the ID of the local format, gets the local parameters that are used to configure
// the RECEIVE side of the channel
HRESULT CMsiaCapability::GetLocalDecodeParams(LPVOID lpvBuf,  UINT uBufSize, AUDIO_FORMAT_ID id)
{
	//    validate input
	if(!lpvBuf|| uBufSize < sizeof(NSC_CHANNEL_PARAMETERS) ||(id > (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}
	memcpy(lpvBuf, &((pLocalFormats + id)->nonstd_params), sizeof(NSC_CHANNEL_PARAMETERS));
	return hrSuccess;
}

BOOL NonstandardCapsCompareA(AUDCAP_DETAILS *pFmtMine, PNSC_AUDIO_CAPABILITY pCap2,
	UINT uSize2)
{
	LPWAVEFORMATEX lpwfx;
	if(!pFmtMine || !pCap2)
		return FALSE;

	if(!(lpwfx = (LPWAVEFORMATEX)pFmtMine->lpLocalFormatDetails))
		return FALSE;

		
	if(pCap2->cap_type == NSC_ACM_WAVEFORMATEX)
	{
		// check sizes first
		if(lpwfx->cbSize != pCap2->cap_data.wfx.cbSize)
		{
			return FALSE;
		}
		// compare structures, including extra bytes
		if(memcmp(lpwfx, &pCap2->cap_data.wfx,
			sizeof(WAVEFORMATEX) + lpwfx->cbSize )==0)
		{
			return TRUE;
		}
	}
	else if(pCap2->cap_type == NSC_ACMABBREV)
	{
		if((LOWORD(pCap2->cap_data.acm_brief.dwFormatTag) == lpwfx->wFormatTag)
		 && (pCap2->cap_data.acm_brief.dwSamplesPerSec ==  lpwfx->nSamplesPerSec)
		 && (LOWORD(pCap2->cap_data.acm_brief.dwBitsPerSample) ==  lpwfx->wBitsPerSample))
		{
			return TRUE;
		}
	}
	return FALSE;
}


HRESULT CMsiaCapability::ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote)
{
	AUDCAP_DETAILS *pFmtLocal;
	AUDCAP_DETAILS *pFmtRemote;
	UINT uIndex = IDToIndex(FormatIDLocal);
	UINT i;

	if(!pFormatIDRemote || (FormatIDLocal == INVALID_MEDIA_FORMAT)
		|| (uIndex >= (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}
	pFmtLocal = pLocalFormats + uIndex;
	
	pFmtRemote = pRemoteDecodeFormats;     // start at the beginning of the remote formats
	for(i=0; i<uNumRemoteDecodeFormats; i++)
	{
		if(!pFmtLocal->bSendEnabled)
			continue;
			
		// compare capabilities - start by comparing the format tag. a.k.a. "ClientType" in H.245 land
		if(pFmtLocal->H245TermCap.ClientType ==  pFmtRemote->H245TermCap.ClientType)
		{
			// if this is a nonstandard cap, compare nonstandard parameters
			if(pFmtLocal->H245TermCap.ClientType == H245_CLIENT_AUD_NONSTD)
			{
				if(NonstandardCapsCompareA(pFmtLocal,
					(PNSC_AUDIO_CAPABILITY)pFmtRemote->H245TermCap.H245Aud_NONSTD.data.value,
					pFmtRemote->H245TermCap.H245Aud_NONSTD.data.length))
				{
					goto RESOLVED_EXIT;
				}
			}
			else  // compare standard parameters, if any
			{
				// well, so far, there aren't any parameters that are significant enough
				// to affect the match/no match decision
				goto RESOLVED_EXIT;
			}
		}
		pFmtRemote++;  // next entry in receiver's caps
	}

	return CAPS_E_NOMATCH;
	
RESOLVED_EXIT:
	// Match! return ID of remote decoding (receive fmt) caps that match our
	// send caps
	*pFormatIDRemote = pFmtRemote->H245TermCap.CapId;
	return hrSuccess;
}

// resolve using currently cached local and remote formats

HRESULT CMsiaCapability::ResolveEncodeFormat(
	AUDIO_FORMAT_ID *pIDEncodeOut,
	AUDIO_FORMAT_ID *pIDRemoteDecode)
{
	UINT i,j=0;
	AUDCAP_DETAILS *pFmtMine = pLocalFormats;
	AUDCAP_DETAILS *pFmtTheirs;
	// LP_CUSTOM_CAPS lpCustomRemoteCaps = (LP_CUSTOM_CAPS)lpvRemoteCustomFormats;
	// LP_MSIAVC_CUSTOM_CAP_ENTRY lpCustomCaps;
	// LPWAVEFORMATEX lpWFX;
	
	if(!pIDEncodeOut || !pIDRemoteDecode)
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pLocalFormats)
	{
		*pIDEncodeOut = *pIDRemoteDecode = INVALID_AUDIO_FORMAT;
		return CAPS_E_NOCAPS;
	}
	if(!pRemoteDecodeFormats || !uNumRemoteDecodeFormats)
	{
		*pIDEncodeOut = *pIDRemoteDecode = INVALID_AUDIO_FORMAT;
		return CAPS_E_NOMATCH;
	}

	// decide how to encode.  my caps are ordered by my preference according to
	// the contents of IDsByRank[]

	//If given a salt, find the position and add it
	if (*pIDEncodeOut != INVALID_MEDIA_FORMAT)
	{
	 	UINT uIndex = IDToIndex(*pIDEncodeOut);
		if (uIndex > uNumLocalFormats)
		{
			return CAPS_W_NO_MORE_FORMATS;
		}
		for(i=0; i<uNumLocalFormats; i++)
		{
			if (pLocalFormats[IDsByRank[i]].H245TermCap.CapId == *pIDEncodeOut)
			{
	 			j=i+1;
				break;
			}
		}	
	}

	for(i=j; i<uNumLocalFormats; i++)
	{
		pFmtMine = pLocalFormats + IDsByRank[i];
		// check to see if this format is enabled for encoding
		if(!pFmtMine->bSendEnabled)
			continue;

		pFmtTheirs = pRemoteDecodeFormats;     // start at the beginning of the remote formats
		for(j=0; j<uNumRemoteDecodeFormats; j++)
		{
			// compare capabilities - start by comparing the format tag. a.k.a. "ClientType" in H.245 land
			if(pFmtMine->H245TermCap.ClientType ==  pFmtTheirs->H245TermCap.ClientType)
			{
				// if this is a nonstandard cap, compare nonstandard parameters
				if(pFmtMine->H245TermCap.ClientType == H245_CLIENT_AUD_NONSTD)
				{

					if(NonstandardCapsCompareA(pFmtMine,
					// (PNSC_AUDIO_CAPABILITY)pFmtMine->H245Cap.Cap.H245Aud_NONSTD.data.value,
						(PNSC_AUDIO_CAPABILITY)pFmtTheirs->H245TermCap.H245Aud_NONSTD.data.value,
						//pFmtMine->H245Cap.Cap.H245Aud_NONSTD.data.length,
						pFmtTheirs->H245TermCap.H245Aud_NONSTD.data.length))
					{
						goto RESOLVED_EXIT;
					}
				

				}
				else  // compare standard parameters, if any
				{
					// well, so far, there aren't any parameters that are significant enough
					// to affect the match/no match decision
					goto RESOLVED_EXIT;
				}
			}
			pFmtTheirs++;  // next entry in receiver's caps
		}
		
	}
	return CAPS_E_NOMATCH;
	
RESOLVED_EXIT:
	// Match!
    DEBUGMSG (ZONE_CONN,("Audio resolved (SEND) to Format Tag: %d\r\n",pFmtMine->wFormatTag));
	// return ID of our encoding (sending fmt) caps that match
	*pIDEncodeOut = pFmtMine->H245TermCap.CapId;
	// return ID of remote decoding (receive fmt) caps that match our
	// send caps
	*pIDRemoteDecode = pFmtTheirs->H245TermCap.CapId;
	return hrSuccess;

	
}

HRESULT CMsiaCapability::GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,
		AUDIO_FORMAT_ID * pFormatID, LPVOID lpvBuf, UINT uBufSize)
{
	UINT i,j=0;
	PCC_TERMCAP pCapability;
	AUDCAP_DETAILS *pFmtMine = pLocalFormats;
	PAUDIO_CHANNEL_PARAMETERS pAudioParams = (PAUDIO_CHANNEL_PARAMETERS) lpvBuf;

	if(!pChannelParams || !(pCapability = pChannelParams->pChannelCapability) || !pFormatID || !lpvBuf
		|| (uBufSize < sizeof(AUDIO_CHANNEL_PARAMETERS)))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pLocalFormats)
	{
		return CAPS_E_NOCAPS;
	}

	for(i=0; i<uNumLocalFormats; i++)
	{
		WORD wFramesPerPkt;
		pFmtMine = pLocalFormats + IDsByRank[i];
	
		// compare capabilities - start by comparing the format tag. a.k.a. "ClientType" in H.245 land
		if(pFmtMine->H245TermCap.ClientType ==  pCapability->ClientType)
		{
			// if this is a nonstandard cap, compare nonstandard parameters
			if(pFmtMine->H245TermCap.ClientType == H245_CLIENT_AUD_NONSTD)
			{
				if(NonstandardCapsCompareA(pFmtMine,
					(PNSC_AUDIO_CAPABILITY)pCapability->Cap.H245Aud_NONSTD.data.value,
					pCapability->Cap.H245Aud_NONSTD.data.length))
				{
					PNSC_AUDIO_CAPABILITY pNSCapRemote;
					pNSCapRemote = (PNSC_AUDIO_CAPABILITY)pCapability->Cap.H245Aud_NONSTD.data.value;
					if (pNSCapRemote->cap_params.wFramesPerPkt <= pFmtMine->nonstd_params.wFramesPerPktMax)
					{
						pAudioParams->ns_params = pNSCapRemote->cap_params;
						goto RESOLVED_EXIT;
					}
				}
			}
			else  // compare standard parameters, if any
			{

				if(pFmtMine->H245TermCap.ClientType == H245_CLIENT_AUD_G723)
				{
					// NEED TO FIND THE G.723 format that results in the largest buffer
					// size calculations so that the larger bitrate format can be used.
					// The buffer size calculations in the datapump are based on the
					// WAVEFORMATEX structure
					// search the remainder of the prioritized list, keep the best
					
					LPWAVEFORMATEX lpwf1, lpwf2;
					AUDCAP_DETAILS *pFmtTry;
					lpwf1 =(LPWAVEFORMATEX)pFmtMine->lpLocalFormatDetails;
					
					for(j = i+1;  j<uNumLocalFormats; j++)
					{
						pFmtTry = pLocalFormats + IDsByRank[j];
						if(pFmtTry->H245TermCap.ClientType != H245_CLIENT_AUD_G723)
							continue;

						lpwf2 =(LPWAVEFORMATEX)pFmtTry->lpLocalFormatDetails;
						if(lpwf2->nAvgBytesPerSec > lpwf1->nAvgBytesPerSec)
						{
							//pFmtMine = pFmtTry;
							lpwf1 = lpwf2;
							// Return value is based on index i.  This one is the
							// one we want so far
							i = j;
						}
						
					}
					
					// We know that the G.723 codec can decode SID in any mode,
					//
					//if(pFmtMine->H245Cap.Cap.H245Aud_G723.silenceSuppression ==
					//  pCapability->Cap.H245Aud_G723.silenceSuppression)
					//{
					//}
				}
				pAudioParams->ns_params = pFmtMine->nonstd_params;
				// update wFramesPerPkt with the actual recv channel parameter
				switch (pCapability->ClientType)
				{
					default:
					case H245_CLIENT_AUD_G711_ALAW64:
						wFramesPerPkt = pCapability->Cap.H245Aud_G711_ALAW64 * SAMPLE_BASED_SAMPLES_PER_FRAME;
						break;
					case H245_CLIENT_AUD_G711_ULAW64:
						wFramesPerPkt = pCapability->Cap.H245Aud_G711_ULAW64 * SAMPLE_BASED_SAMPLES_PER_FRAME;
						break;
					// these have no parameters
					//case H245_CLIENT_AUD_G711_ULAW56:
					//case H245_CLIENT_AUD_G711_ALAW56:
					break;

					case H245_CLIENT_AUD_G723:
						wFramesPerPkt = pCapability->Cap.H245Aud_G723.maxAl_sduAudioFrames;
					break;
				}
				if (wFramesPerPkt <= pFmtMine->nonstd_params.wFramesPerPktMax)
				{
					pAudioParams->ns_params.wFramesPerPkt = wFramesPerPkt;
					goto RESOLVED_EXIT;
				}
				else
				{
	    		DEBUGMSG (ZONE_CONN,("Recv channel wFramesPerPkt mismatch! ours=%d, theirs=%d\r\n",pFmtMine->nonstd_params.wFramesPerPktMax,wFramesPerPkt));
	    		}
			
			}
		}
	}
	return CAPS_E_NOMATCH;

RESOLVED_EXIT:
	// Match!
	// return ID of the decoding caps that match
	*pFormatID = IndexToId(IDsByRank[i]);
	
	pAudioParams->RTP_Payload  = pChannelParams->bRTPPayloadType;
	pAudioParams->ns_params.UseSilenceDet = (BYTE)pChannelParams->bSilenceSuppression;

    DEBUGMSG (ZONE_CONN,("Audio resolved (RECEIVE) to Format Tag: %d\r\n",pFmtMine->wFormatTag));

	return hrSuccess;

}

DWORD CMsiaCapability::MinFramesPerPacket(WAVEFORMATEX *pwf)
{
	UINT sblk, uSize;
	uSize = MinSampleSize(pwf);   // this calculates the minimum # of samples
								// that will still fit in an 80 mS frame
	
	// calculate samples per block ( aka frame)
	sblk = pwf->nBlockAlign* pwf->nSamplesPerSec/ pwf->nAvgBytesPerSec;
	if(!sblk)
		return 0;   // should never happen unless ACM is corrupted,
	// min samples per frame/samples per block = min frames/block.
	return uSize/sblk;
}


//
// determine a reasonable maximum number of frames per packet.
// 4x the Minimum is reasonable, so long as it doesn't make
// the packet too big
DWORD CMsiaCapability::MaxFramesPerPacket(WAVEFORMATEX *pwf)
{
	DWORD dwMin, dwMax;

	dwMin = MinFramesPerPacket(pwf); // minimum number of frames

	dwMax = MAX_FRAME_LEN_RECV / (dwMin * pwf->nBlockAlign);

	dwMax = min((4*dwMin), dwMax*dwMin);

	if (dwMax < dwMin)
	{
		WARNING_OUT(("CMsiaCapability::MaxFramesPerPacket - Max value computed as less than min.  Return Min for Max\r\n"));
		dwMax = dwMin;
	}

	return dwMax;

}

//
//   MinSampleSize() taken from datapump.cpp ChoosePacketSize()
//


// what else depends on it?
UINT CMsiaCapability::MinSampleSize(WAVEFORMATEX *pwf)
{
	// calculate default samples per pkt
	UINT spp, sblk;
	spp = m_uPacketDuration * pwf->nSamplesPerSec / 1000;
	// calculate samples per block ( aka frame)
	sblk = pwf->nBlockAlign* pwf->nSamplesPerSec/ pwf->nAvgBytesPerSec;
	if (sblk <= spp) {
		spp = (spp/sblk)*sblk;
		if ( spp*pwf->nAvgBytesPerSec/pwf->nSamplesPerSec > MAX_FRAME_LEN) {
			// packet too big
			spp = (MAX_FRAME_LEN/pwf->nBlockAlign)*sblk;
		}
	} else
		spp = sblk;
	return spp;
}

HRESULT CMsiaCapability::IsFormatEnabled (MEDIA_FORMAT_ID FormatID, PBOOL bRecv, PBOOL bSend)
{
   UINT uIndex = IDToIndex(FormatID);
   // 	validate input
   if(uIndex >= (UINT)uNumLocalFormats)
   {
	   return CAPS_E_INVALID_PARAM;
   }

   *bSend=((pLocalFormats + uIndex)->bSendEnabled);
   *bRecv=((pLocalFormats + uIndex)->bRecvEnabled);

   return hrSuccess;

}

BOOL CMsiaCapability::IsFormatPublic (MEDIA_FORMAT_ID FormatID)
{
	UINT uIndex = IDToIndex(FormatID);
	// 	validate input
	if(uIndex >= (UINT)uNumLocalFormats)
		return FALSE;
		
	// test if this is format is a duplicate of a public format
	if((pLocalFormats + uIndex)->dwPublicRefIndex)
		return FALSE;	// then we keep this format to ourselves
	else
		return TRUE;
}
MEDIA_FORMAT_ID CMsiaCapability::GetPublicID(MEDIA_FORMAT_ID FormatID)
{
	UINT uIndex = IDToIndex(FormatID);
	// 	validate input
	if(uIndex >= (UINT)uNumLocalFormats)
		return INVALID_MEDIA_FORMAT;
		
	if((pLocalFormats + uIndex)->dwPublicRefIndex)
	{
		return (pLocalFormats + ((pLocalFormats + uIndex)->dwPublicRefIndex))->H245TermCap.CapId;
	}
	else
	{
		return FormatID;
	}
}

#ifdef DEBUG
VOID DumpWFX(LPWAVEFORMATEX lpwfxLocal, LPWAVEFORMATEX lpwfxRemote)
{
	FX_ENTRY("DumpWFX");
	ERRORMESSAGE((" -------- %s Begin --------\r\n",_fx_));
	if(lpwfxLocal)
	{
		ERRORMESSAGE((" -------- Local --------\r\n"));
		ERRORMESSAGE(("wFormatTag:\t0x%04X, nChannels:\t0x%04X\r\n",
			lpwfxLocal->wFormatTag, lpwfxLocal->nChannels));
		ERRORMESSAGE(("nSamplesPerSec:\t0x%08lX, nAvgBytesPerSec:\t0x%08lX\r\n",
			lpwfxLocal->nSamplesPerSec, lpwfxLocal->nAvgBytesPerSec));
		ERRORMESSAGE(("nBlockAlign:\t0x%04X, wBitsPerSample:\t0x%04X, cbSize:\t0x%04X\r\n",
			lpwfxLocal->nBlockAlign, lpwfxLocal->wBitsPerSample, lpwfxLocal->cbSize));
	}
	if(lpwfxRemote)
	{
			ERRORMESSAGE((" -------- Remote --------\r\n"));
		ERRORMESSAGE(("wFormatTag:\t0x%04X, nChannels:\t0x%04X\r\n",
			lpwfxRemote->wFormatTag, lpwfxRemote->nChannels));
		ERRORMESSAGE(("nSamplesPerSec:\t0x%08lX, nAvgBytesPerSec:\t0x%08lX\r\n",
			lpwfxRemote->nSamplesPerSec, lpwfxRemote->nAvgBytesPerSec));
		ERRORMESSAGE(("nBlockAlign:\t0x%04X, wBitsPerSample:\t0x%04X, cbSize:\t0x%04X\r\n",
			lpwfxRemote->nBlockAlign, lpwfxRemote->wBitsPerSample, lpwfxRemote->cbSize));
	}
	ERRORMESSAGE((" -------- %s End --------\r\n",_fx_));
}
VOID DumpChannelParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2)
{
	FX_ENTRY("DumpChannelParameters");
	ERRORMESSAGE((" -------- %s Begin --------\r\n",_fx_));
	if(pChanCap1)
	{
		ERRORMESSAGE((" -------- Local Cap --------\r\n"));
		ERRORMESSAGE(("DataType:%d(d), ClientType:%d(d)\r\n",pChanCap1->DataType,pChanCap1->ClientType));
		ERRORMESSAGE(("Direction:%d(d), CapId:%d(d)\r\n",pChanCap1->Dir,pChanCap1->CapId));
	}
	if(pChanCap2)
	{
		ERRORMESSAGE((" -------- Remote Cap --------\r\n"));
		ERRORMESSAGE(("DataType:%d(d), ClientType:%d(d)\r\n",pChanCap2->DataType,pChanCap2->ClientType));
		ERRORMESSAGE(("Direction:%d(d), CapId:%d(d)\r\n",pChanCap2->Dir,pChanCap2->CapId));
	}
	ERRORMESSAGE((" -------- %s End --------\r\n",_fx_));
}
VOID DumpNonstdParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2)
{
	FX_ENTRY("DumpNonstdParameters");
	
	ERRORMESSAGE((" -------- %s Begin --------\r\n",_fx_));
	DumpChannelParameters(pChanCap1, pChanCap2);
	
	if(pChanCap1)
	{
		ERRORMESSAGE((" -------- Local Cap --------\r\n"));
		if(pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			ERRORMESSAGE(("t35CountryCode:%d(d), t35Extension:%d(d)\r\n",
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode,
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension));
			ERRORMESSAGE(("MfrCode:%d(d), data length:%d(d)\r\n",
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode,
				pChanCap1->Cap.H245Aud_NONSTD.data.length));
		}
		else
		{
			ERRORMESSAGE(("unrecognized nonStandardIdentifier.choice: %d(d)\r\n",
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice));
		}
	}
	if(pChanCap2)
	{
		ERRORMESSAGE((" -------- Remote Cap --------\r\n"));
		if(pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			ERRORMESSAGE(("t35CountryCode:%d(d), t35Extension:%d(d)\r\n",
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode,
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension));
			ERRORMESSAGE(("MfrCode:%d(d), data length:%d(d)\r\n",
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode,
				pChanCap2->Cap.H245Aud_NONSTD.data.length));
		}
		else
		{
			ERRORMESSAGE(("nonStandardIdentifier.choice: %d(d)\r\n",
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice));
		}
	}
	ERRORMESSAGE((" -------- %s End --------\r\n",_fx_));
}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\imp.h ===
#define APP_PORT H323_PORT

#ifdef __cplusplus
	LPIControlChannel CreateControlChannel(GUID PIDofProtocolType);
#endif	// __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\inscodec.h ===
/*
 -  INSCODEC.H
 -
 *	Microsoft NetMeeting
 *	Network Audio Controller (NAC) DLL
 *	Internal header file for installable codecs
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		1.29.97		Yoram Yaacovi		Created
 *
 */

#include <pshpack8.h> /* Assume 8 byte packing throughout */

/*
 *	Macros
 */
#define COMPARE_GUIDS(a,b)	RtlEqualMemory((a), (b), sizeof(GUID))
#define ACQMUTEX(hMutex)											\
	while (WaitForSingleObject(hMutex, 10000) == WAIT_TIMEOUT)		\
	{																\
		ERRORMSG(("Thread 0x%x waits on mutex\n", GetCurrentThreadId()));	\
	}																\
		
#define RELMUTEX(hMutex)	ReleaseMutex(hMutex)

#define IMPL(class, member, pointer) \
	(&((class *)0)->member == pointer, ((class *) (((LONG_PTR) pointer) - offsetof (class, member))))

/*
 *	Data Structures
 */

/****************************************************************************
 *  @doc  INTERNAL DATASTRUC AUDIO
 *
 *	@class CInstallAudioCodecs | Installable Audio codecs
 *
 *	@base public | IInstallAudioCodecs
 *
 ***************************************************************************/
class CInstallAudioCodecs : public IInstallAudioCodecs
{
	public:
	//	IUnknown methods
		STDMETHODIMP QueryInterface (REFIID riid, void **ppv);
		STDMETHODIMP_(ULONG) AddRef (void);
		STDMETHODIMP_(ULONG) Release (void);

	//	IInstallAudioCodecs methods
		STDMETHODIMP AddACMFormat (LPWAVEFORMATEX lpwfx, PBASIC_AUDCAP_INFO pAudCapInfo);
		STDMETHODIMP RemoveACMFormat (LPWAVEFORMATEX lpwfx);
		STDMETHODIMP ReorderFormats (PAUDCAP_INFO_LIST pAudCapInfoList);
		STDMETHODIMP EnumFormats(PAUDCAP_INFO_LIST *ppAudCapInfoList);
		STDMETHODIMP FreeBuffer(LPVOID lpBuffer);

	private:
	// Private functions

	// Debug display functions

	// Variables
};

/****************************************************************************
 *  @doc  INTERNAL DATASTRUC VIDEO
 *
 *	@class CInstallVideoCodecs | Installable Video codecs
 *
 *	@base public | IInstallVideoCodecs
 *
 ***************************************************************************/
class CInstallVideoCodecs : public IInstallVideoCodecs
{
	public:
	//	IUnknown methods
		STDMETHODIMP QueryInterface (REFIID riid, void **ppv);
		STDMETHODIMP_(ULONG) AddRef (void);
		STDMETHODIMP_(ULONG) Release (void);

	//	IInstallVideoCodecs methods
		STDMETHODIMP AddVCMFormat (PVIDCAP_INFO pVidCapInfo);
		STDMETHODIMP RemoveVCMFormat (PVIDCAP_INFO pVidCapInfo);
		STDMETHODIMP ReorderFormats (PVIDCAP_INFO_LIST pVidCapInfoList);
		STDMETHODIMP EnumFormats(PVIDCAP_INFO_LIST *ppVidCapInfoList);
		STDMETHODIMP FreeBuffer(LPVOID lpBuffer);

	private:
	// Private functions
		STDMETHODIMP AddRemoveVCMFormat(PVIDCAP_INFO pVidCapInfo,
										BOOL bAdd);

	// Debug display functions

	// Variables
};

/****************************************************************************
 *  @doc  INTERNAL DATASTRUC
 *
 *	@class CInstallCodecs | Installable codecs
 *
 *	@base public | IUnknown
 *
 ***************************************************************************/
class CInstallCodecs : public IInstallCodecs
{
	friend class CInstallAudioCodecs;
	friend class CInstallVideoCodecs;

	public:
	//	IUnknown methods
		STDMETHODIMP QueryInterface (REFIID riid, void **ppv);
		STDMETHODIMP_(ULONG) AddRef (void);
		STDMETHODIMP_(ULONG) Release (void);

		CInstallCodecs (void);
		~CInstallCodecs (void);
		HRESULT Initialize(REFIID riid);

	private:
	// Functions
		STDMETHODIMP FreeBuffer(LPVOID lpBuffer);
		STDMETHODIMP TranslateHr(HRESULT hr);

	// Audio and video interfaces
		CInstallAudioCodecs ifAudio;
		CInstallVideoCodecs ifVideo;

	// Variables
		// @cmember Reference Count
		int m_cRef;
		// Two public members to allow access from the nested classes
		// @cmember Pointer to an audio capability interface
		LPAPPCAPPIF m_pAudAppCaps;
		// @cmember Pointer to an video capability interface
		LPAPPVIDCAPPIF m_pVidAppCaps;

};

/*
 *	Globals
 */
EXTERN_C HANDLE g_hMutex;
EXTERN_C class CInstallCodecs *g_pIC;

/*
 *	Function prototypes
 */

#include <poppack.h> /* End byte packing */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\inscodec.cpp ===
/*
 -  INSCODEC.CPP
 -
 *	Microsoft NetMeeting
 *	Network Access Controller (NAC) DLL
 *	Installable codecs interfaces
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		01.29.96	Yoram Yaacovi		Created
 *
 *	Functions:
 *		CInstallCodecs
 *			QueryInterface
 *			AddRef
 *			Release
 *			Initialize
 *			TranslateHr
 *		CInstallAudioCodecs
 *			QueryInterface
 *			AddRef
 *			Release
 *			AddACMFormat
 *			RemoveACMFormat
 *			ReorderFormats
 *			EnumFormats
 *			FreeBuffer
 *		CInstallVideoCodecs
 *			QueryInterface
 *			AddRef
 *			Release
 *			AddVCMFormat
 *			RemoveVCMFormat
 *			ReorderFormats
 *			EnumFormats
 *			FreeBuffer
 *		Public:
 *		Private:
 *			FreeBuffer
 *		External:
 *			CreateInstallCodecs
 *
 *
 *  @doc  EXTERNAL
 *
 *	Notes:
 *	@topic Implementation Notes | Below are some implementation notes.
 *
 *	@devnote To add an audio or video format for use with NetMeeting, first obtain the
 *	appropriate interface by calling the COM CoCreateInstance, providing the desired
 *	interface (IInstallAudioCodecs or IInstallVideoCodecs). Then call the Add>CMFormat
 *	method on this interface to add a format, or Remove?CMFormat to remove one. Use
 *	the EnumFormats method to enumerate the list of formats known to NetMeeting, or
 *	ReorderFormats to make NetMeeting use these formats in a different priority order
 *	(see comment in the ReorderFormats description).
 *
 *	@devnote When a vendor uses our API to add a codec format for use with NetMeeting,
 *	the information about this format is stored in the registry. Whenever we do
 *	an upgrade install of NetMeeting, we blow away these registry entry,
 *	together with all the standard registry entries. This is required to avoid
 *	incompatibility problems. This means that if a user installed a 3rd party codec,
 *	and then upgraded NetMeeting, he will have to re-add the custom codec.
 *
 */

#include <precomp.h>
#include <confreg.h>	// for setting NetMeeting to manual codec selection
#include <regentry.h>	// for setting NetMeeting to manual codec selection

EXTERN_C int g_cICObjects=0;
EXTERN_C HANDLE g_hMutex=NULL;
class CInstallCodecs *g_pIC;

/***************************************************************************

	CInstallCodecs

***************************************************************************/
/***************************************************************************

    IUnknown Methods

***************************************************************************/
HRESULT CInstallCodecs::QueryInterface (REFIID riid, LPVOID *lppNewObj)
{
    HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::QueryInterface\n"));

#ifdef DEBUG
	// parameter validation
    if (IsBadReadPtr(&riid, (UINT) sizeof(IID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadWritePtr(lppNewObj, sizeof(LPVOID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }
#endif	// DEBUG
	
	*lppNewObj = 0;

	if (riid == IID_IUnknown || riid == IID_IInstallCodecs)
		*lppNewObj = (IInstallCodecs *) this;
	else if (riid == IID_IInstallAudioCodecs)
		*lppNewObj = (IInstallAudioCodecs *) &ifAudio;
	else if (riid == IID_IInstallVideoCodecs)
		*lppNewObj = (IInstallVideoCodecs *) &ifVideo;
	else
	{
		hr = E_NOINTERFACE;
		goto out;
	}	
	
	((IUnknown *)*lppNewObj)->AddRef ();

out:
	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::QueryInterface - leave, hr=0x%x\n", hr));
	return hr;
}

ULONG CInstallCodecs::AddRef (void)
{
	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::AddRef\n"));

	InterlockedIncrement((long *) &m_cRef);

	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::AddRef - leave, m_cRef=%d\n", m_cRef));

	return m_cRef;
}

ULONG CInstallCodecs::Release (void)
{
	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::Release\n"));

	// if the cRef is already 0 (shouldn't happen), assert, but let it through
	ASSERT(m_cRef);

	if (InterlockedDecrement((long *) &m_cRef) == 0)
	{
		delete this;
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::Release - leave, m_cRef=%d\n", m_cRef));
	
	return m_cRef;
}

/***************************************************************************

	CInstallAudioCodecs

***************************************************************************/
/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC AUDIO
 *
 *	@interface IInstallAudioCodecs | This interface provides methods for
 *		adding audio codec formats for use with NetMeeting, as well as
 *		removing these formats, enumerating them, and change their use order.
 *
 ***************************************************************************/
/***************************************************************************

    IUnknown Methods

	Calling the containing object respective methods

***************************************************************************/
/****************************************************************************
 *
 *  @method HRESULT | IInstallAudioCodecs | QueryInterface | QueryInterface
 *
 ***************************************************************************/
HRESULT CInstallAudioCodecs::QueryInterface (REFIID riid, LPVOID *lppNewObj)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::QueryInterface\n"));

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::QueryInterface - leave\n"));
	return (This->QueryInterface(riid, lppNewObj));

}

/****************************************************************************
 *
 *  @method ULONG | IInstallAudioCodecs | AddRef | AddRef
 *
 ***************************************************************************/
ULONG CInstallAudioCodecs::AddRef (void)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::AddRef\n"));

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::AddRef - leave\n"));
	return (This->AddRef());
}

/****************************************************************************
 *
 *  @method ULONG | IInstallAudioCodecs | Release | Release
 *
 ***************************************************************************/
ULONG CInstallAudioCodecs::Release (void)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::Release\n"));

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::Release - leave\n"));
	return (This->Release());
}

/****************************************************************************
 *
 *	AddACMFormat
 *
 *  @method HRESULT | IInstallAudioCodecs | AddACMFormat | Adds an ACM encoding
 *		format for use with NetMeeting
 *
 *  @parm LPWAVEFORMATEX | lpwfx | Pointer to the WAVEFORMATEX structure of the
 *		format to add
 *
 *  @parm PAUDCAP_INFO | pAudCapInfo | Additional format info that is not in the
 *		WAVEFORMATEX structure
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_NO_SUCH_FORMAT | The specified WAVEFORMATEX was not found with ACM.
 *			The format must be installed with ACM before it can be added for use
 *			with NetMeeting.
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *      reported a system error
 *
 ***************************************************************************/
HRESULT CInstallAudioCodecs::AddACMFormat(LPWAVEFORMATEX lpwfx, PAUDCAP_INFO pAudCapInfo)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::AddACMFormat\n"));

	/*
	 *	Parameter validation
	 */

	// parameters
	if (!lpwfx || !pAudCapInfo ||
		IsBadReadPtr(lpwfx, (UINT) sizeof(WAVEFORMATEX)) ||
		IsBadReadPtr(pAudCapInfo, (UINT) sizeof(AUDCAP_INFO)))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// NAC doesn't like a nBlockAlign of 0
	if (lpwfx->nBlockAlign == 0)
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// the format tags in the WAVEFORMAT and the AUDCAP_INFO should match
	if (lpwfx->wFormatTag != pAudCapInfo->wFormatTag)
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// only supporting formats with one audio channel
	if (lpwfx->nChannels != 1)
	{
		hr = E_INVALIDARG;
		goto out;
	}
		
	/*
	 *	Add the format
	 */

	// add
	hr = This->m_pAudAppCaps->AddACMFormat(lpwfx, pAudCapInfo);

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallAudioCodecs::AddACMFormat failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::AddACMFormat - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	RemoveACMFormat
 *
 *  @method HRESULT | IInstallAudioCodecs | RemoveACMFormat | Removes an ACM
 *		format from the list of formats used by NetMeeting
 *
 *  @parm LPWAVEFORMATEX | lpwfx | Pointer to the WAVEFORMATEX structure for the
 *		format to remove
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (0x7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_NO_SUCH_FORMAT | The specified format was not found.
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *			reported a system error
 *
 ***************************************************************************/
HRESULT CInstallAudioCodecs::RemoveACMFormat(LPWAVEFORMATEX lpwfx)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::RemoveACMFormat\n"));

	/*
	 *	Parameter validation
	 */

	if (!lpwfx ||
		IsBadReadPtr(lpwfx, (UINT) sizeof(WAVEFORMATEX)))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// NAC doesn't like a nBlockAlign of 0
	if (lpwfx->nBlockAlign == 0)
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// only supporting formats with one audio channel
	if (lpwfx->nChannels != 1)
	{
		hr = E_INVALIDARG;
		goto out;
	}
		
	hr = This->m_pAudAppCaps->RemoveACMFormat(lpwfx);

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallAudioCodecs::RemoveACMFormat failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::RemoveACMFormat - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	ReorderFormats
 *
 *  @method HRESULT | IInstallAudioCodecs | ReorderFormats | Reorders the audio
 *		formats for use with Netmeeting
 *
 *  @parm PAUDCAP_INFO_LIST | pAudCapInfoList | Pointer to a structure with a count
 *		and a pointer to a list of the formats to reorder. The list is of the
 *		format AUDCAP_INFO_LIST.
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *      reported a system error
 *
 *	@comm Since ReorderFormats can only reorder formats that are known to NetMeeting,
 *		it is recommended that the caller will first call EnumFormats, to get the
 *		of all formats known to NetMeeting, assign new sort indices (wSortIndex),
 *		and then call ReorderFormats with the modified list.
 *
 *	@comm Arranging the formats in a specific order, by using ReorderFormats, does
 *		not guarantee that the top ranked formats will be used before lower ranked
 *		formats are used. For example, if the sending system is not capable of
 *		encoding a top ranked format, this format will not be used. The same
 *		will happen if the receiving system cannot decode this format.
 *
 ***************************************************************************/
HRESULT CInstallAudioCodecs::ReorderFormats(PAUDCAP_INFO_LIST pAudCapInfoList)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object
	RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::ReorderFormats\n"));

	/*
	 *	Parameter validation
	 */

	if (!pAudCapInfoList ||
		IsBadReadPtr(pAudCapInfoList, sizeof(DWORD)) ||
		IsBadReadPtr(pAudCapInfoList,
				sizeof(AUDCAP_INFO_LIST) + ((pAudCapInfoList->cFormats-1) * sizeof(AUDCAP_INFO))))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// fill in the format buffer here

	hr = This->m_pAudAppCaps->ApplyAppFormatPrefs(pAudCapInfoList->aFormats,
												pAudCapInfoList->cFormats);

	if (FAILED(hr))
		goto out;

	/*
	 *	switch NetMeeting to manual mode
	 */

	// set the registry. failing here won't fail ReorderFormats
	re.SetValue(REGVAL_CODECCHOICE, CODECCHOICE_MANUAL);

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallAudioCodecs::ReorderFormats failed, hr=0x%x\n", hr));
	}
	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::ReorderFormats - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	EnumFormats
 *
 *  @method HRESULT | IInstallAudioCodecs | EnumFormats | Enumerates the audio
 *		codec formats known to NetMeeting
 *
 *  @parm PAUDCAP_INFO_LIST * | ppAudCapInfoList | Address where this method
 *		will put a pointer to a AUDCAP_INFO_LIST list, where enumerated formats
 *		are listed.
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *		@flag E_OUTOFMEMORY | Not enough memory for allocating the enumeration buffer
 *		@flag IC_E_NO_FORMATS | No formats were available to enumerate
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *      reported a system error
 *
 *	@comm The caller is expected to free the returned list, by calling FreeBuffer
 *		on the same interface.
 *
 ***************************************************************************/
HRESULT CInstallAudioCodecs::EnumFormats(PAUDCAP_INFO_LIST *ppAudCapInfoList)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object
	ULONG cFormats = 0;
	UINT uBufSize = 0;
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::EnumFormats\n"));

	/*
	 *	Parameter validation
	 */

	if (!ppAudCapInfoList ||
		IsBadWritePtr(ppAudCapInfoList, sizeof(PAUDCAP_INFO_LIST)))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// nothing yet....
	*ppAudCapInfoList = NULL;

	// are there any formats ?
	if (HR_FAILED(This->m_pAudAppCaps->GetNumFormats((UINT *) &cFormats))	||
		(cFormats == 0))
	{
		hr = IC_E_NO_FORMATS;
		goto out;
	}

	// allocate a buffer for the call. the caller is expected to call
	// FreeBuffer to free
	// AUDCAP_INFO_LIST already includes one AUDCAP_INFO
	uBufSize = sizeof(AUDCAP_INFO_LIST) + (cFormats-1) * sizeof(AUDCAP_INFO);
	*ppAudCapInfoList = (PAUDCAP_INFO_LIST) MEMALLOC (uBufSize);
	if (!(*ppAudCapInfoList))
	{
		hr = E_OUTOFMEMORY;
		goto out;
	}
		
	hr = This->m_pAudAppCaps->EnumFormats((*ppAudCapInfoList)->aFormats, uBufSize,
											(UINT *) &((*ppAudCapInfoList)->cFormats));

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallAudioCodecs::EnumFormats failed, hr=0x%x\n", hr));
	}
	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::EnumFormats - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	FreeBuffer
 *
 *  @method HRESULT | IInstallAudioCodecs | FreeBuffer | Free a buffer that was
 *		returned by the IInstallAudioCodec interface
 *
 *  @parm LPVOID | lpBuffer | Address of the buffer to free. This buffer must have
 *		been allocated by one of the IInstallAudioCodecs methods
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		None
 *
 ***************************************************************************/
HRESULT CInstallAudioCodecs::FreeBuffer(LPVOID lpBuffer)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object
	HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::FreeBuffer\n"));

	hr = This->FreeBuffer(lpBuffer);

	if (FAILED(hr))
	{
		ERRORMSG(("CInstallAudioCodecs::FreeBuffer failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::FreeBuffer - leave, hr=0x%x\n", hr));
	return This->TranslateHr(hr);
}

/***************************************************************************

	CInstallVideoCodecs

***************************************************************************/
/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC VIDEO
 ***************************************************************************/
/***************************************************************************

    IUnknown Methods

	Calling the containing object respective methods

***************************************************************************/
/****************************************************************************
 *
 *  @method HRESULT | IInstallVideoCodecs | QueryInterface | QueryInterface
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::QueryInterface (REFIID riid, LPVOID *lppNewObj)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::QueryInterface\n"));

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::QueryInterface - leave\n"));
	return (This->QueryInterface(riid, lppNewObj));

}

/****************************************************************************
 *
 *  @method ULONG | IInstallVideoCodecs | AddRef | AddRef
 *
 ***************************************************************************/
ULONG CInstallVideoCodecs::AddRef (void)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::AddRef\n"));

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::AddRef - leave\n"));
	return (This->AddRef());
}

/****************************************************************************
 *
 *  @method ULONG | IInstallVideoCodecs | Release | Release
 *
 ***************************************************************************/
ULONG CInstallVideoCodecs::Release (void)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::Release\n"));

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::Release - leave\n"));
	return (This->Release());
}

/****************************************************************************
 *
 *	AddVCMFormat
 *
 *  @method HRESULT | IInstallVideoCodecs | AddVCMFormat | Adds an video encoding
 *		format for use with	NetMeeting
 *
 *  @parm PAUDCAP_INFO | pVidCapInfo | Information on the format to add
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_NO_SUCH_FORMAT | The specified format was not found. The format
 *			must be installed with Video For Windows before it can be added for use
 *			with NetMeeting.
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *			reported a system error
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::AddVCMFormat(PVIDCAP_INFO pVidCapInfo)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::AddVCMFormat\n"));

	/*
	 *	Add the format
	 */

	hr = AddRemoveVCMFormat(pVidCapInfo, TRUE);

	if (FAILED(hr))
	{
		ERRORMSG(("CInstallVideoCodecs::AddVCMFormat failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::AddVCMFormat - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	RemoveVCMFormat
 *
 *  @method HRESULT | IInstallVideoCodecs | RemoveVCMFormat | Removes an video
 *		format from the list of formats used by NetMeeting
 *
 *  @parm PVIDCAP_INFO | pVidCapInfo | Pointer to the PVIDCAP_INFO structure
 *		describing the format to remove
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (0x7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_NO_SUCH_FORMAT | The specified format was not found.
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *			reported a system error
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::RemoveVCMFormat(PVIDCAP_INFO pVidCapInfo)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::RemoveVCMFormat\n"));

	/*
	 *	Remove the format
	 */

	hr = AddRemoveVCMFormat(pVidCapInfo, FALSE);

	if (FAILED(hr))
	{
		ERRORMSG(("CInstallVideoCodecs::RemoveVCMFormat failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::RemoveVCMFormat - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	ReorderFormats
 *
 *  @method HRESULT | IInstallVideoCodecs | ReorderFormats | Reorders the video
 *		formats for use with Netmeeting
 *
 *  @parm PVIDCAP_INFO_LIST | pVidCapInfoList | Pointer to a structure with a count
 *		and a pointer to a list of the formats to reorder. The list is of the
 *		format VIDCAP_INFO_LIST.
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *      reported a system error
 *
 *	@comm Since ReorderFormats can only reorder formats that are known to NetMeeting,
 *		it is recommended that the caller will first call EnumFormats, to get the
 *		of all formats known to NetMeeting, assign new sort indices (wSortIndex),
 *		and then call ReorderFormats with the modified list.
 *
 *	@comm Arranging the formats in a specific order, by using ReorderFormats, does
 *		not guarantee that the top ranked formats will be used before lower ranked
 *		formats are used. For example, if the sending system is not capable of
 *		encoding a top ranked format, this format will not be used. The same
 *		will happen if the receiving system cannot decode this format.
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::ReorderFormats(PVIDCAP_INFO_LIST pVidCapInfoList)
{
 	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::ReorderFormats\n"));

	/*
	 *	Parameter validation
	 */

	if (!pVidCapInfoList ||
		IsBadReadPtr(pVidCapInfoList, sizeof(DWORD)) ||
		IsBadReadPtr(pVidCapInfoList,
				sizeof(VIDCAP_INFO_LIST) + ((pVidCapInfoList->cFormats-1) * sizeof(VIDCAP_INFO))))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	hr = This->m_pVidAppCaps->ApplyAppFormatPrefs(pVidCapInfoList->aFormats,
													pVidCapInfoList->cFormats);

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallVideoCodecs::ReorderFormats failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::ReorderFormats - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	EnumFormats
 *
 *  @method HRESULT | IInstallVideoCodecs | EnumFormats | Enumerates the video
 *		codec formats known to NetMeeting
 *
 *  @parm PVIDCAP_INFO_LIST * | ppVidCapInfoList | Address where this method
 *		will put a pointer to a VIDCAP_INFO_LIST list, where enumerated formats
 *		are listed.
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *		@flag E_OUTOFMEMORY | Not enough memory for allocating the enumeration buffer
 *		@flag IC_E_NO_FORMATS | No formats were available to enumerate
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *      reported a system error
 *
 *	@comm The caller is expected to free the returned list, by calling FreeBuffer
 *		on the same interface.
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::EnumFormats(PVIDCAP_INFO_LIST *ppVidCapInfoList)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object
	ULONG cFormats = 0;
	UINT uBufSize = 0;
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::EnumFormats\n"));

	/*
	 *	Parameter validation
	 */

	if (!ppVidCapInfoList ||
		IsBadWritePtr(ppVidCapInfoList, sizeof(PVIDCAP_INFO_LIST)))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// nothing yet....
	*ppVidCapInfoList = NULL;

	// are there any formats ?
	if (HR_FAILED(This->m_pVidAppCaps->GetNumFormats((UINT *) &cFormats))	||
		(cFormats == 0))
	{
		hr = IC_E_NO_FORMATS;
		goto out;
	}

	// allocate a buffer for the call. the caller is expected to call
	// FreeBuffer to free
	// VIDCAP_INFO_LIST already includes one VIDCAP_INFO
	uBufSize = sizeof(VIDCAP_INFO_LIST) + (cFormats-1) * sizeof(VIDCAP_INFO);
	*ppVidCapInfoList = (PVIDCAP_INFO_LIST) MEMALLOC (uBufSize);
	if (!(*ppVidCapInfoList))
	{
		hr = E_OUTOFMEMORY;
		goto out;
	}
		
	hr = This->m_pVidAppCaps->EnumFormats((*ppVidCapInfoList)->aFormats, uBufSize,
											(UINT *) &((*ppVidCapInfoList)->cFormats));

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallVideoCodecs::EnumFormats failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::EnumFormats - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	FreeBuffer
 *
 *  @method HRESULT | IInstallVideoCodecs | FreeBuffer | Free a buffer that was
 *		returned by the IInstallVideoCodec interface
 *
 *  @parm LPVOID | lpBuffer | Address of the buffer to free. This buffer must have
 *		been allocated by one of the IInstallVideoCodecs methods
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		None
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::FreeBuffer(LPVOID lpBuffer)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object
	HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::FreeBuffer\n"));

	hr = This->FreeBuffer(lpBuffer);

	if (FAILED(hr))
	{
		ERRORMSG(("CInstallVideoCodecs::FreeBuffer failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::FreeBuffer - leave, hr=0x%x\n", hr));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *  @doc  INTERNAL COMPFUNC
 ***************************************************************************/
/****************************************************************************
 *
 *	AddRemoveVCMFormat
 *
 *  @method HRESULT | IInstallVideoCodecs | AddRemoveVCMFormat | Adds or
 *		removes a VCM format for use with NetMeeting
 *
 *  @parm PAUDCAP_INFO | pVidCapInfo | Information on the format to add/remove
 *
 *	@parm BOOL | bAdd | TRUE = Add the format, FALSE = Remove the format
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_NO_SUCH_FORMAT | The specified format was not found. The format
 *			must be installed with Video For Windows before it can be added for use
 *			with NetMeeting.
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *			reported a system error
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::AddRemoveVCMFormat(PVIDCAP_INFO pVidCapInfo,
												BOOL bAdd)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object
	VIDEOFORMATEX vfx;
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::AddVCMFormat\n"));

	/*
	 *	Parameter validation
	 */

	if (!pVidCapInfo ||
		IsBadReadPtr(pVidCapInfo, (UINT) sizeof(VIDCAP_INFO)))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// some fields should not be zero
	if ((pVidCapInfo->uFrameRate == 0)	||
		(pVidCapInfo->uAvgBitrate == 0)	||
		((pVidCapInfo->dwBitsPerSample == 0) &&
		 (pVidCapInfo->bih.biBitCount == 0)))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// make sure dwBitsPerSample and biBitCount match
	if (pVidCapInfo->dwBitsPerSample == 0)
		pVidCapInfo->dwBitsPerSample = pVidCapInfo->bih.biBitCount;
	if (pVidCapInfo->bih.biBitCount == 0)
		pVidCapInfo->bih.biBitCount = LOWORD(pVidCapInfo->dwBitsPerSample);
			
	if (LOWORD(pVidCapInfo->dwBitsPerSample) != pVidCapInfo->bih.biBitCount)
	{
		hr = E_INVALIDARG;
		goto out;
	}

	/*
	 *	Make a VIDEOFORMATEX structure
	 */

	RtlZeroMemory((PVOID) &vfx, sizeof(VIDEOFORMATEX));


	// Make sure it's Upper Case
	if (pVidCapInfo->dwFormatTag > 256)
		CharUpperBuff((LPTSTR)&pVidCapInfo->dwFormatTag, sizeof(DWORD));

	vfx.dwFormatTag = pVidCapInfo->dwFormatTag;

	vfx.nSamplesPerSec = pVidCapInfo->uFrameRate;
	vfx.wBitsPerSample = pVidCapInfo->dwBitsPerSample;	// wBitPerSample is a DWORD
	vfx.nAvgBytesPerSec = pVidCapInfo->uAvgBitrate;
	RtlCopyMemory(&vfx.bih,	&pVidCapInfo->bih, sizeof(BITMAPINFOHEADER));

	/*
	 *	Add or remove the format
	 */

	if (bAdd)
		hr = This->m_pVidAppCaps->AddVCMFormat(&vfx, pVidCapInfo);
	else
		hr = This->m_pVidAppCaps->RemoveVCMFormat(&vfx);

out:
	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::AddRemoveVCMFormat - leave\n"));
	return This->TranslateHr(hr);
}


/***************************************************************************

    Name      : CInstallCodecs::CInstallCodecs

    Purpose   : The CInstallCodecs object constructor

    Parameters: none

    Returns   : None

    Comment   :

***************************************************************************/
inline CInstallCodecs::CInstallCodecs (void)
{
	m_cRef = 0;	// will be bumped to 1 by the explicit QI in the create function
	m_pAudAppCaps = NULL;
	m_pVidAppCaps = NULL;

	// can't use ++ because RISC processors may translate to several instructions
	InterlockedIncrement((long *) &g_cICObjects);
}

/***************************************************************************

    Name      : CInstallCodecs::~CInstallCodecs

    Purpose   : The CInstallCodecs object destructor

    Parameters: none

    Returns   : None

    Comment   :

***************************************************************************/
inline CInstallCodecs::~CInstallCodecs (void)
{
	// let the caps interfaces and objects go
	if (m_pAudAppCaps)
		m_pAudAppCaps->Release();
	if (m_pVidAppCaps)
		m_pVidAppCaps->Release();

	// can't use ++ because RISC processors may translate to several instructions
	if (!InterlockedDecrement((long *) &g_cICObjects))
	{
		if (g_hMutex)
			CloseHandle(g_hMutex);
		g_hMutex = NULL;
	}

	g_pIC = (CInstallCodecs *)NULL;

}

/***************************************************************************

    Name      : CInstallCodecs::FreeBuffer

    Purpose   : Frees a buffer allocated by the the installable codecs interfaces.

    Parameters: lpBuffer - a pointer to the buffer to free. This buffer must
					have been allocated by installable codecs interfaces

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CInstallCodecs::FreeBuffer(LPVOID lpBuffer)
{
	HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::FreeBuffer\n"));

	if (lpBuffer)
		MEMFREE(lpBuffer);

	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::FreeBuffer - leave, hr=0x%x\n", hr));
	return TranslateHr(hr);
}

/***************************************************************************

    Name      : CInstallCodecs::TranslateHr

    Purpose   : Translates an HRESULT to an external installable codecs value

    Parameters: hr - [in] the HRESULT value to translate

    Returns   : HRESULT - the translated value

    Comment   :

***************************************************************************/
HRESULT CInstallCodecs::TranslateHr(HRESULT hr)
{
	switch (hr)
	{
	
	case CAPS_E_NOMATCH:
		hr = IC_E_NO_SUCH_FORMAT;
		break;

	case CAPS_E_INVALID_PARAM:
		hr = E_INVALIDARG;
		break;

	case CAPS_E_SYSTEM_ERROR:
		hr = IC_E_INTERNAL_ERROR;
		break;
	
	default:
		break;
	}

	return hr;
}

/****************************************************************************
 *
 *	Initialize
 *
 *  @func HRESULT | Initialize | Initializes the CinstallCodecs object
 *
 *  @parm REFIID | riid | Reference to the identifier of the interface
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *		@flag E_OUTOFMEMORY | Not enough memory for creating the object
 *      @flag IC_E_CAPS_INSTANTIATION_FAILURE | Could not instantiate a capability object
 *      @flag IC_E_CAPS_INITIALIZATION_FAILURE | Could not initialize a capability object
 *
 ***************************************************************************/
HRESULT CInstallCodecs::Initialize(REFIID riid)
{
	HRESULT hr=NOERROR;
	CMsiaCapability *pAudCapObj = NULL;
	CMsivCapability *pVidCapObj = NULL;

	/*
	 *	Instantiate
	 */

	ACQMUTEX(g_hMutex);

	/*
	 *	Audio
	 */

	if ((riid == IID_IInstallAudioCodecs)	&&
		!m_pAudAppCaps)
	{
		// instantiate the audio capability object
        DBG_SAVE_FILE_LINE
		pAudCapObj = new CMsiaCapability;

		if (!pAudCapObj)
		{
			hr = IC_E_CAPS_INSTANTIATION_FAILURE;
   			goto out;
		}

		// get an appcap interface on the capability objects
		// this interface will be used for most calls
		hr = pAudCapObj->QueryInterface(IID_IAppAudioCap, (void **)&m_pAudAppCaps);
		if(!HR_SUCCEEDED(hr))
		{
			hr = IC_E_CAPS_INSTANTIATION_FAILURE;
			goto out;
		}
		pAudCapObj->Release(); // this balances the refcount of "new CMsiaCapability"

		// initialize the capability objects
		if (!(pAudCapObj->Init()))
		{
			hr = IC_E_CAPS_INITIALIZATION_FAILURE;
   			goto out;
		}
	}

	/*
	 *	Video
	 */

	if ((riid == IID_IInstallVideoCodecs)	&&
		!m_pVidAppCaps)
	{
		// instantiate the video capability object
        DBG_SAVE_FILE_LINE
		pVidCapObj = new CMsivCapability;

		if (!pVidCapObj)
		{
			hr = IC_E_CAPS_INSTANTIATION_FAILURE;
   			goto out;
		}
		// get an appcap interface on the capability objects
		// this interface will be used for most calls
		hr = pVidCapObj->QueryInterface(IID_IAppVidCap, (void **)&m_pVidAppCaps);
		if(!HR_SUCCEEDED(hr))
		{
			hr = IC_E_CAPS_INSTANTIATION_FAILURE;
			goto out;
		}
		pVidCapObj->Release(); // this balances the refcount of "new CMsivCapability"

		if (!(pVidCapObj->Init()))
		{
			hr = IC_E_CAPS_INITIALIZATION_FAILURE;
   			goto out;
		}
	}

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallCodecs::Initialize failed, hr=0x%x\n", hr));
	}

	RELMUTEX(g_hMutex);
	return TranslateHr(hr);
}


/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC
 ***************************************************************************/
/****************************************************************************
 *
 *	CreateInstallCodecs
 *
 *  @func HRESULT | CreateInstallCodecs | Creates an instance of the CInstallCodecs
 *		object, and returns	the requested interface. This function should only be
 *		called indirectly through CoCreateInstance.
 *  @parm LPUNKNOWN | punkOuter | Pointer to whether object is or isnt part
 *		of an aggregate
 *
 *  @parm REFIID | riid | Reference to the identifier of the interface
 *
 *  @parm LPVOID * | ppv | Indirect pointer to requested interface
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *		@flag E_OUTOFMEMORY | Not enough memory for creating the object
 *      @flag CLASS_E_NOAGGREGATION | Aggregation is not supported for this object
 *      @flag IC_E_CAPS_INSTANTIATION_FAILURE | Could not instantiate a capability object
 *      @flag IC_E_CAPS_INITIALIZATION_FAILURE | Could not initialize a capability object
 *
 *	@comm CreateInstallCodecs should not be called directly. Clients of installable
 *		codecs should use the COM CoCreateInstance to instantiate the object, expecting
 *		the same return values.
 *
 ***************************************************************************/
extern "C" HRESULT WINAPI CreateInstallCodecs (	IUnknown *pUnkOuter,
												REFIID riid,
												void **ppv)
{
	CInstallCodecs *pIC;
	HRESULT hr = NOERROR;

	*ppv = 0;
	if (pUnkOuter)
	{
		hr = CLASS_E_NOAGGREGATION;
		goto out;
	}

	/*
	 *	instantiate the object
	 */

	// create a mutex to control access to QoS object data
	//
	// NOTE: I'm taking some chance here: the code that creates the mutex must be
	// executed by one thread at a time, so it should really be in the PROCESS_ATTACH
	// for NAC.DLL. However, since this code is expected to be called rarely, and in
	// order not to add code to the NAC load time, I put it here.
	if (!g_hMutex)
	{
		g_hMutex = CreateMutex(NULL, FALSE, NULL);
		ASSERT(g_hMutex);
		if (!g_hMutex)
		{
			ERRORMSG(("CreateInstallCodecs: CreateMutex failed, 0x%x\n", GetLastError()));
			hr = E_FAIL;
			goto out;
		}
	}

	ACQMUTEX(g_hMutex);


	// only instantiate a new object if it doesn't already exist
	if (!g_pIC)
	{
        DBG_SAVE_FILE_LINE
		if (!(pIC = new CInstallCodecs))
		{
			hr = E_OUTOFMEMORY;
			RELMUTEX(g_hMutex);
			goto out;
		}

		// Save pointer
		g_pIC = pIC;
	}
	else
	{
		// this is the case when the object was already instantiaed in this
		// process, so we only want to return the object pointer.
		pIC = g_pIC;
	}

	// always initialize the object. Initialize will only initialize what
	// is not yet initialized
	hr = pIC->Initialize(riid);

	RELMUTEX(g_hMutex);

	// get the requested interface for the caller
	if (pIC)
	{
		// QueryInterface will get us the interface pointer and will AddRef
		// the object
		hr = pIC->QueryInterface (riid, ppv);
	}
	else
		hr = E_FAIL;

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CreateInstallCodecs failed, hr=0x%x\n", hr));
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\ivcapapi.cpp ===
/*
 *  	File: connobj.cpp
 *
 *		implementation of Internet Video capability API interface.
 *
 *		
 *
 *		Revision History:
 *
 *		06/18/96	mikev	created
 *		07/28/96	philf	added support for video
 */

#include "precomp.h"
	
ULONG CImpAppVidCap ::AddRef()
{
	 return (m_pCapObject->AddRef());
}
ULONG CImpAppVidCap ::Release()
{
	 return (m_pCapObject->Release());
}
HRESULT CImpAppVidCap::GetNumFormats(UINT *puNumFmtOut)
{
	return (m_pCapObject->GetNumFormats(puNumFmtOut));
}
HRESULT CImpAppVidCap ::GetBasicVidcapInfo (VIDEO_FORMAT_ID Id,
		PBASIC_VIDCAP_INFO pFormatPrefsBuf)
{
 	return (m_pCapObject->GetBasicVidcapInfo (Id, pFormatPrefsBuf));
}		
HRESULT CImpAppVidCap ::EnumFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut)
{
	 return (m_pCapObject->EnumFormats(pFmtBuf, uBufsize, uNumFmtOut));
}

HRESULT CImpAppVidCap ::EnumCommonFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut, BOOL bTXCaps)
{
	 return (m_pCapObject->EnumCommonFormats(pFmtBuf, uBufsize, uNumFmtOut, bTXCaps));
}

HRESULT CImpAppVidCap ::ApplyAppFormatPrefs (PBASIC_VIDCAP_INFO pFormatPrefsBuf,
	UINT uNumFormatPrefs)
{
	 return (m_pCapObject->ApplyAppFormatPrefs (pFormatPrefsBuf, uNumFormatPrefs));
}

HRESULT CImpAppVidCap ::AddVCMFormat (PVIDEOFORMATEX pvfx, PVIDCAP_INFO pVidCapInfo)
{
	 return (m_pCapObject->AddVCMFormat(pvfx, pVidCapInfo));
}
HRESULT CImpAppVidCap ::RemoveVCMFormat (PVIDEOFORMATEX pvfx)
{
	 return (m_pCapObject->RemoveVCMFormat(pvfx));
}
PVIDEOFORMATEX CImpAppVidCap::GetVidcapDetails (VIDEO_FORMAT_ID Id)
{
	UINT uSize;
	VIDEOFORMATEX *pFormat;
	m_pCapObject->GetEncodeFormatDetails(Id, (VOID**)&pFormat, &uSize);
	return pFormat;
}
HRESULT CImpAppVidCap::GetPreferredFormatId (VIDEO_FORMAT_ID *pId)
{
	return (pId ? m_pCapObject->GetPreferredFormatId (pId) : (HRESULT)S_FALSE);
}
HRESULT CImpAppVidCap::SetDeviceID(DWORD dwDeviceID)
{
	 return (m_pCapObject->SetDeviceID(dwDeviceID));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\iacapapi.cpp ===
/*
 *  	File: connobj.cpp
 *
 *		implementation of Internet Audio capability API interface.
 *
 *		
 *
 *		Revision History:
 *
 *		06/18/96	mikev	created
 */

#include "precomp.h"
	
ULONG CImpAppAudioCap ::AddRef()
{
	 return (m_pCapObject->AddRef());
}
ULONG CImpAppAudioCap ::Release()
{
	 return (m_pCapObject->Release());
}
HRESULT CImpAppAudioCap::GetNumFormats(UINT *puNumFmtOut)
{
	return (m_pCapObject->GetNumFormats(puNumFmtOut));
}
HRESULT CImpAppAudioCap ::GetBasicAudcapInfo (AUDIO_FORMAT_ID Id,
		PBASIC_AUDCAP_INFO pFormatPrefsBuf)
{
 	return (m_pCapObject->GetBasicAudcapInfo (Id, pFormatPrefsBuf));
}		
HRESULT CImpAppAudioCap ::EnumFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut)
{
	 return (m_pCapObject->EnumFormats(pFmtBuf, uBufsize, uNumFmtOut));
}

HRESULT CImpAppAudioCap ::EnumCommonFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut, BOOL bTXCaps)
{
	 return (m_pCapObject->EnumCommonFormats(pFmtBuf, uBufsize, uNumFmtOut, bTXCaps));
}

HRESULT CImpAppAudioCap ::ApplyAppFormatPrefs (PBASIC_AUDCAP_INFO pFormatPrefsBuf,
	UINT uNumFormatPrefs)
{
	 return (m_pCapObject->ApplyAppFormatPrefs (pFormatPrefsBuf, uNumFormatPrefs));
}

HRESULT CImpAppAudioCap ::AddACMFormat (LPWAVEFORMATEX lpwfx, PAUDCAP_INFO pAudCapInfo)
{
	 return (m_pCapObject->AddACMFormat(lpwfx, pAudCapInfo));
}
HRESULT CImpAppAudioCap ::RemoveACMFormat (LPWAVEFORMATEX lpwfx)
{
	 return (m_pCapObject->RemoveACMFormat(lpwfx));
}

LPVOID CImpAppAudioCap::GetFormatDetails (AUDIO_FORMAT_ID Id)
{
	VOID *pFormat;
	UINT uSize;

	m_pCapObject->GetEncodeFormatDetails(Id, &pFormat, &uSize);
	return pFormat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\log.cpp ===
// LOG.C
// low overhead logging routines
// can be used in time-critical situations
// LogInit should be called once to create the memory mapped file
// use LOGVIEW.EXE to view the log.

#include "precomp.h"

#ifdef LOGGING
// storage in log.c
// Strings corresponding to LOGMSG_XXX
// Note: cant use %s in format string
char LogStringTable [][MAX_STRING_SIZE] = {
// dont exceed the size of the string below!
//	"123456789012345678901234567890123456789012345678901234567890123"
	"Sent at %d\n",
	"NetRecv ts = %d, seq = %d at %d\n",
	"AP::Send   (%d), %d bytes, ts =%d\n",
	"AP::Silent (%d) %d\n",
	"AP::Record (%d)\n",
	"AP::Recv   (%d) seq = %d len=%d\n",
	"Rx::Reset1 MaxT=%d PlayT=%d PlayPos=%d\n",
	"Rx::Reset2 MaxT=%d PlayT=%d PlayPos=%d\n",
	"AP::Encoded(%d)\n",
	"AP::Decoded(%d)\n",
	"AP::Playing(%d) at %d\n",
	"AP::PlaySil(%d)\n",
	"RcrdTh:: try to open audio dev\n",
	"PlayTh: too many missings and Yield\n",
	"RcrdTh:: too many silence and Yield\n",
	"AP::Recycle(%d)\n",
	"AutoSilence: strength=%d,threshold=%d,avgSilence=%d\n",
	"Tx -Presend(%d)\n",
	"Rx-Skipping(%d)\n",
	"Tx::Reset FreePos=%d SendPos=%d\n",
	"Rx::VarDelay=%d samples, avgVarDelay=%d, delayPos=%d\n",
	"AP::PlayInterpolated(%d)\n",
	"AP::Interpolated (%d) %d\n",
	"VP::Send   (%d), %d bytes, ts =%d\n",
	"VP::Recv   (%d) seq = %d len=%d\n",
	"VP::Recycle(%d)\n",
	"VP::Record (%d)\n",
	"VP::Playing(%d) at %d\n",
	"VP::PlaySil(%d)\n",
	"VP::PlayInterpolated(%d)\n",
	"VP::Interpolated (%d) %d\n",
	"VP::Encoded(%d)\n",
	"VP::Decoded(%d)\n",
	"Vid::Trying to open Capture\n",
	"Vid:GetSendFrame    (%d)\n",
	"Vid:GetRecvFrame    (%d)\n",
	"Vid:ReleaseSendFrame(%d)\n",
	"Vid:ReleaseRecvFrame(%d)\n",
	"Vid:Playing back TS %d aud sync %d\n",
	"DGSOCK:->OnRead (%d)\n",
	"DGSOCK:<-OnRead (%d)\n",
	"DGSOCK:->OnReadDone (%d)\n",
	"DGSOCK:<-OnReadDone (%d)\n",
	"DGSOCK:->RecvFrom (%d)\n",
	"DGSOCK:<-RecvFrom (%d)\n",
	"DGSOCK:ReadWouldBlock (%d)\n",
	"VidSend: VP::Queue %d bytes, ts =%d at %d\n",
	"VidSend: AP::Queue %d bytes, ts =%d at %d\n",
	"VidSend: VP::Send %d bytes, ts =%d at %d\n",
	"VidSend: AP::Send %d bytes, ts =%d at %d\n",
	"VidSend: VP::!Send %d bytes, ts =%d\n",
	"VidSend: AP::!Send %d bytes, ts =%d\n",
	"VidSend: IO Pending\n",
	"VidSend: Audio queue is empty\n",
	"VidSend: Video queue is empty\n",
	"AudSend: VP::Queue %d bytes, ts =%d\n",
	"AudSend: AP::Queue %d bytes, ts =%d at %d\n",
	"AudSend: VP::Send %d bytes, ts =%d\n",
	"AudSend: AP::Send %d bytes, ts =%d at %d\n",
	"AudSend: VP::!Send %d bytes, ts =%d\n",
	"AudSend: AP::!Send %d bytes, ts =%d\n",
	"AudSend: IO Pending\n",
	"AudSend: Audio queue is empty\n",
	"AudSend: Video queue is empty\n",
	"Send blocked for %d ms\n",

	"DS PlayBuf: Play=%d, Write=%d, len=%d\n",
	"DS Empty  : Play=%d, lastPlay=%d, nextWrite=%d\n",
	"DS Timeout: Play=%d, nextWrite=%d at %d\n",
	"DS PlayBuf Overflow! SetPlayPosition to %d (hr=%d)\n",
	"DS Create: (hr = %d)\n",
	"DS Release: (uref = %d)\n",
	"DS PlayBuf: Dropped out of sequence packet\n",
	"DS PlayBuf: timestamp=%d, seq=%d, fMark=%d\n",
	"DS PlayBuf: GetTickCount=%d\n",
	"DS PlayBuf: PlayPos=%d, WritePos=%d\n",
	"DS PlayBuf: Dropping packet due to overflow\n",
	"m_Next=%d, curDelay=%d, bufSize=%d\n",

	"Send Audio Config   took %ld ms\r\n",
	"Send Audio UnConfig took %ld ms\r\n",
	"Send Video Config   took %ld ms\r\n",
	"Send Video UnConfig took %ld ms\r\n",
	"Recv Audio Config   took %ld ms\r\n",
	"Recv Audio UnConfig took %ld ms\r\n",
	"Recv Video Config   took %ld ms\r\n",
	"Recv Video UnConfig took %ld ms\r\n",


	"DSC Timestamp: %d\r\n",
	"DSC GetCurrentPos: capPos=%d  ReadPos=%d\r\n",
	"DSC Timeout: A timeout has occured\r\n",
	"DSC Lagging condition: Lag=%d  NextExpect=%d\r\n",
	"DSC Sending: Num=%d, dwFirstPos=%d, dwLastPos=%d\r\n",
	"DSC Stats: BufferSize=%d, FrameSize=%d\r\n",
	"DSC Early condition detected\r\n"
};

#define MAX_LOG_ENTRIES		2048

// IMPORTANT: should be identical to definition in viewer app.
typedef struct {
	int locked;		// set to TRUE while viewer is accessing log
	int cdwEntrySize;
	int cMaxEntries;
	int cbOffsetBase;	// from start of this struct
	int cbOffsetStringTable;	// from start of this struct
	int cStrings;		// number of strings
	int cCurrent;		// index of current log position
} LOG_HEADER;

struct LogEntry {
	DWORD dw[4];
} *pLogBase;

#define MAX_LOG_SIZE (sizeof(LOG_HEADER)+sizeof(struct LogEntry)*MAX_LOG_ENTRIES + sizeof(LogStringTable))

HANDLE hMapFile = NULL;
char szLogViewMap[] = "LogViewMap";
LOG_HEADER *pLog=NULL;
CRITICAL_SECTION logCritSect;	// not used


void Log (UINT n, UINT arg1, UINT arg2, UINT arg3)
{
	struct LogEntry *pCurEntry;
	if (pLog == NULL || pLog->locked)
		return;


	//EnterCriticalSection(&logCritSect);
	// sideeffect of multiple access are not serious so
	// dont bother with synchronization.
	pLog->cCurrent++;
	if (pLog->cCurrent >= pLog->cMaxEntries) {
		pLog->cCurrent = 0;		//wraparound
	}
	pCurEntry = pLogBase + pLog->cCurrent;
	pCurEntry->dw[0] = n;
	pCurEntry->dw[1] = arg1;
	pCurEntry->dw[2] = arg2;
	pCurEntry->dw[3] = arg3;
	//LeaveCriticalSection(&logCritSect);
}

int LogInit()
{
	int fSuccess;
	hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE,
		NULL,
		PAGE_READWRITE,
		0,
		MAX_LOG_SIZE,
		szLogViewMap);
	if (hMapFile == NULL) {
		//printf("Couldnt open Map: %s\n",szLogViewMap);
		fSuccess = FALSE;
		goto Exit;
	}
	pLog = (LOG_HEADER *)MapViewOfFile(hMapFile,
		FILE_MAP_ALL_ACCESS,
		0,
		0,
		0);	// entire file starting from offset 0
	if (pLog == NULL) {
		//printf("Couldnt map view %s\n",szLogViewMap);
		fSuccess = FALSE;
		goto Exit;
	}
	InitializeCriticalSection(&logCritSect);
	// initialize log
	pLog->locked = 0;
	pLog->cdwEntrySize = sizeof(struct LogEntry)/sizeof(DWORD);	// size in dwords
	pLog->cMaxEntries = MAX_LOG_ENTRIES;
	pLog->cbOffsetBase = sizeof(LOG_HEADER)+sizeof(LogStringTable);
	pLog->cbOffsetStringTable = sizeof(LOG_HEADER);
	pLog->cStrings = sizeof(LogStringTable)/MAX_STRING_SIZE;
	pLog->cCurrent = 0;	// current position

	pLogBase = (struct LogEntry *)((PBYTE)pLog + pLog->cbOffsetBase);

	memcpy((PBYTE)pLog + pLog->cbOffsetStringTable, LogStringTable, sizeof(LogStringTable));
	memset((PBYTE)pLogBase,0,MAX_LOG_ENTRIES*pLog->cdwEntrySize*4);
	fSuccess  = TRUE;
Exit:
	return fSuccess;
}

LogClose()
{
	if (pLog)
	{
		DeleteCriticalSection(&logCritSect);
		UnmapViewOfFile(pLog);
		pLog = NULL;
		CloseHandle(hMapFile);
		hMapFile = NULL;
	}
	return TRUE;
}
#endif // LOGGING enabled

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\mediapkt.cpp ===
#include "precomp.h"


#define ZONE_AP			1



#define _GetPlatform()	(m_dwState & DP_MASK_PLATFORM)
#define _SetPlatform(s)	(m_dwState = (m_dwState & ~DP_MASK_PLATFORM) | (s & DP_MASK_PLATFORM))

///////////////////////////////////////////////////////
//
//  Public methods
//


MediaPacket::MediaPacket ( void )
{
	_Construct ();
}


MediaPacket::~MediaPacket ( void )
{
	_Destruct ();
}


HRESULT MediaPacket::Initialize ( MEDIAPACKETINIT * p )
{
	HRESULT hr = DPR_SUCCESS;

	FX_ENTRY ("AdPckt::Init")

	if (p == NULL)
	{
		DEBUGMSG (ZONE_AP, ("%s: invalid parameter (null ptr)\r\n", _fx_));
		return DPR_INVALID_PARAMETER;
	}

	_Construct ();

	// we need to analyze flags to
	// warn conflicting or insufficient flags
	m_dwState |= p->dwFlags;

	// get handle of stream conversion
	m_hStrmConv = p->hStrmConv;

	// get handle of wave device
	// m_hDev = p->hDevAudio;
	m_hDev = NULL;

	// flags about prepared
	m_fDevPrepared = FALSE;
	m_fStrmPrepared = FALSE;

	// set up wave formats
	m_pStrmConvSrcFmt = p->pStrmConvSrcFmt;
	m_pStrmConvDstFmt = p->pStrmConvDstFmt;
	m_pDevFmt = p->pDevFmt;
	m_payload = p->payload;

	// net buffer
	if (p->cbSizeNetData)
	{ 	// send or recv
		m_pNetData = (NETBUF *) LocalAlloc (LMEM_FIXED, p->cbSizeNetData + p->cbOffsetNetData + p->cbPayloadHeaderSize + sizeof (NETBUF));
		if (m_pNetData == NULL)
		{
			DEBUGMSG (ZONE_AP, ("%s: MemAlloc1 (%ld) failed\r\n",
			_fx_, (ULONG) (p->cbSizeNetData + p->cbOffsetNetData)));
			hr = DPR_OUT_OF_MEMORY;
			goto MyExit;
		}
		m_pNetData->data = (PBYTE) m_pNetData + p->cbOffsetNetData + p->cbPayloadHeaderSize + sizeof (NETBUF);
		m_pNetData->length = p->cbSizeNetData;
		m_cbMaxNetData = p->cbSizeNetData;
		m_pNetData->pool = NULL;
	}
	else
	{
#ifdef PREP_HDR_PER_CONV
		// recv
		m_pNetData = NULL;
#else
		hr = DPR_INVALID_PARAMETER;
		goto MyExit;
#endif
	}

	m_index = p->index;

	// if m_pStrmConvDstFmt == m_pStrmConvSrcFmt,
	// then m_pRawData <-- m_pNetData
	// else allocate it
	if (IsSameMediaFormat (m_pStrmConvSrcFmt, m_pStrmConvDstFmt))
	{
		m_pRawData = m_pNetData;
	}
	else if (p->fDontAllocRawBufs)
	{
		m_pRawData = NULL;
	}
	else
	{
		m_pRawData = (NETBUF *) LocalAlloc (LMEM_FIXED, p->cbSizeRawData + p->cbOffsetRawData + sizeof(NETBUF));
		if (m_pRawData == NULL)
		{
			DEBUGMSG (ZONE_AP, ("%s: MemAlloc2 (%ld) failed\r\n",
			_fx_, (ULONG) (p->cbSizeRawData + p->cbOffsetRawData)));
			hr = DPR_OUT_OF_MEMORY;
			goto MyExit;
		}
		m_pRawData->data = (PBYTE) m_pRawData + sizeof(NETBUF) + p->cbOffsetRawData;
		m_pRawData->length = p->cbSizeRawData;
		m_pRawData->pool = NULL;
	}

	// if m_pDevFmt == m_pStrmConvSrcFmt (when SEND)
	// then m_pDevData <-- m_pRawData
	// else allocate it
	if (((m_dwState & DP_FLAG_SEND) &&
				IsSameMediaFormat (m_pStrmConvSrcFmt, m_pDevFmt)) ||
		((m_dwState & DP_FLAG_RECV) &&
				IsSameMediaFormat (m_pStrmConvDstFmt, m_pDevFmt)))
	{
		// typical case - codec raw format matches that of i/o device
		m_pDevData = m_pRawData;
	}
	else
	{
		// codec raw format doesnt match that of device
		// BUGBUG: we dont really handle this case yet
		m_pDevData = (NETBUF *) LocalAlloc (LMEM_FIXED, p->cbSizeDevData + p->cbOffsetDevData + sizeof(NETBUF));
		if (m_pDevData == NULL)
		{
			DEBUGMSG (ZONE_AP, ("%s: MemAlloc3 (%ld) failed\r\n",
			_fx_, (ULONG) (p->cbSizeDevData + p->cbOffsetDevData)));
			hr = DPR_OUT_OF_MEMORY;
			goto MyExit;
		}
		m_pDevData->data = (PBYTE) m_pDevData + sizeof(NETBUF) + p->cbOffsetDevData;
		m_pDevData->length = p->cbSizeDevData;
		m_pDevData->pool = NULL;
	}

	MakeSilence ();

MyExit:

	if (hr == DPR_SUCCESS)
	{
		m_fInitialized = TRUE;
		SetState (MP_STATE_RESET);
	}

	return hr;
}


HRESULT MediaPacket::Receive ( NETBUF *pNetBuf, DWORD timestamp, UINT seq, UINT fMark )
{
	m_seq = seq;
	m_timestamp = timestamp;
	m_fMark = fMark;

#ifdef PREP_HDR_PER_CONV
	m_pNetData = pNetBuf;
#else
	if (pNetBuf)  // pNetBuf may be NULL for video
	{
		if (pNetBuf->length > m_cbMaxNetData)
			return DPR_INVALID_PARAMETER;
		if (m_pNetData && pNetBuf)
		{
			CopyMemory (m_pNetData->data, pNetBuf->data,
							(m_pNetData->length = pNetBuf->length));

		}
	}
#endif

	LOG(((m_dwState & DP_FLAG_VIDEO)? LOGMSG_VID_RECV: LOGMSG_AUD_RECV,m_index,seq,m_pNetData->length));
	SetState (MP_STATE_NET_IN_STREAM);
	return DPR_SUCCESS;
}


HRESULT MediaPacket::Recycle ( void )
{
	HRESULT hr = DPR_SUCCESS;

	FX_ENTRY ("MdPckt::Recycle")

	LOG(((m_dwState & DP_FLAG_VIDEO)? LOGMSG_VID_RECYCLE: LOGMSG_AUD_RECYCLE, m_index));
	if (m_dwState & DP_FLAG_RECV)
	{
		if (m_pRawData && m_pRawData->pool) {
			m_pRawData->pool->ReturnBuffer((PVOID) m_pRawData);
			if (m_pDevData == m_pRawData)
				m_pDevData = NULL;
			m_pRawData = NULL;
		}
#ifdef PREP_HDR_PER_CONV
		// free net data buffer
		if (m_pNetData && m_pNetData->pool) m_pNetData->pool->ReturnBuffer ((PVOID) m_pNetData);
		if (m_pNetData == m_pRawData) m_pRawData = NULL;
		m_pNetData = NULL;
#endif
	}

	SetState (MP_STATE_RESET);

	return hr;
}


HRESULT MediaPacket::GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	FX_ENTRY ("AdPckt::GetProp")

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
		case MP_PROP_STATE:
			*pdwPropVal = GetState ();
			break;

		case MP_PROP_PLATFORM:
			*pdwPropVal = _GetPlatform ();
			break;

		case MP_PROP_DEV_MEDIA_FORMAT:
			*pdwPropVal = (DWORD_PTR) m_pDevFmt;
			break;

		case MP_PROP_DEV_DATA:
			*pdwPropVal = (DWORD_PTR) m_pDevData;
			break;

		case MP_PROP_DEV_HANDLE:
			*pdwPropVal = (DWORD_PTR) m_hDev;
			break;

		case MP_PROP_DEV_MEDIA_HDR:
			*pdwPropVal = (DWORD_PTR) m_pDevHdr;
			break;

		case MP_PROP_IN_STREAM_FORMAT:
			*pdwPropVal = (DWORD_PTR) m_pStrmConvSrcFmt;
			break;

		case MP_PROP_OUT_STREAM_FORMAT:
			*pdwPropVal = (DWORD_PTR) m_pStrmConvDstFmt;
			break;

		case MP_PROP_TIMESTAMP:
			*pdwPropVal = (DWORD) m_timestamp;
			break;
	
		case MP_PROP_INDEX:
			*pdwPropVal = (DWORD) m_index;
			break;

		case MP_PROP_PREAMBLE:
			*pdwPropVal = (DWORD) m_fMark;
			break;

		case MP_PROP_FILTER_HEADER:
			*pdwPropVal = (DWORD_PTR) m_pStrmConvHdr;
			break;

		case MP_PROP_MAX_NET_LENGTH:
			*pdwPropVal = m_cbMaxNetData;
			break;


		default:
			hr = DPR_INVALID_PROP_ID;
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}


HRESULT MediaPacket::SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	FX_ENTRY ("AdPckt::SetProp")

	switch (dwPropId)
	{
	case MP_PROP_STATE:
		SetState ((DWORD)dwPropVal);
		break;

	case MP_PROP_PLATFORM:
		_SetPlatform ((DWORD)dwPropVal);
		break;

	case MP_PROP_DEV_MEDIA_FORMAT:
	case MP_PROP_IN_STREAM_FORMAT:
	case MP_PROP_OUT_STREAM_FORMAT:
		hr = DPR_IMPOSSIBLE_SET_PROP;
		break;

	case MP_PROP_TIMESTAMP:
		m_timestamp = (DWORD)dwPropVal;
		break;

	case MP_PROP_PREAMBLE:
		m_fMark = dwPropVal ? 1 : 0;
		break;

	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}


HRESULT MediaPacket::Release ( void )
{
	_Destruct ();
	return DPR_SUCCESS;
}

BOOL MediaPacket::SetDecodeBuffer(NETBUF *pBuf)
{
	ASSERT(!m_pRawData);
	m_pRawData = pBuf;
	if (!m_pDevData) m_pDevData = pBuf;
	return TRUE;
}

///////////////////////////////////////////////////////
//
//  Private methods
//


void MediaPacket::_Construct ( void )
{
	m_hStrmConv = NULL;
	m_pStrmConvHdr = NULL;
	m_pStrmConvSrcFmt = NULL;
	m_pStrmConvDstFmt = NULL;

	m_hDev = NULL;
	m_pDevHdr = NULL;
	m_pDevFmt = NULL;

	m_pDevData = NULL;
	m_pRawData = NULL;
	m_pNetData = NULL;

	m_dwState = 0;
	m_fBusy = FALSE;
	m_timestamp = 0;
	m_seq = 0;
	m_index = 0;
	m_fMark = 0;

	m_cbValidRawData = 0;

	m_fRendering = FALSE;

	m_fInitialized = FALSE;

}


void MediaPacket::_Destruct ( void )
{
	if (m_fInitialized)
	{
		if (m_pDevHdr) MemFree (m_pDevHdr);
		m_pDevHdr = NULL;

		if (m_pStrmConvHdr) MemFree (m_pStrmConvHdr);
		m_pStrmConvHdr = NULL;

		if (m_pDevData == m_pRawData) m_pDevData = NULL;
		if (m_pRawData == m_pNetData) m_pRawData = NULL;

		if (m_pDevData) {
			if (m_pDevData->pool)
				m_pDevData->pool->ReturnBuffer((PVOID) m_pDevData);
			else
				LocalFree (m_pDevData);
			m_pDevData = NULL;
		}

		if (m_pRawData) {
			if (m_pRawData->pool)
				m_pRawData->pool->ReturnBuffer((PVOID) m_pRawData);
			else
				LocalFree (m_pRawData);
			m_pRawData = NULL;
		}

		if (m_pNetData && m_pNetData->pool)
			m_pNetData->pool->ReturnBuffer ((PVOID) m_pNetData);
		else if (m_pNetData)
			LocalFree (m_pNetData);
		m_pNetData = NULL;

		SetState (MP_STATE_RESET);

		m_fInitialized = FALSE;
	}
}

HRESULT MediaPacket::GetDevData(PVOID *ppData, PUINT pcbData)
{
	if (!ppData || !pcbData)
		return DPR_INVALID_PARAMETER;

	if (m_pDevData) {
		*ppData = m_pDevData->data;
		*pcbData = m_pDevData->length;
	} else {
		*ppData = NULL;
		*pcbData = 0;
	}

	return DPR_SUCCESS;
}

HRESULT MediaPacket::GetNetData(PVOID *ppData, PUINT pcbData)
{

	if (!ppData || !pcbData)
		return DPR_INVALID_PARAMETER;

	if (m_pNetData) {
		*ppData = m_pNetData->data;
		*pcbData = m_pNetData->length;
	} else {
		*ppData = NULL;
		*pcbData = 0;
	}

	return DPR_SUCCESS;

}


HRESULT MediaPacket::SetNetLength(UINT uLength)
{
	if ((m_pNetData) && (m_pNetData->data))
	{
		m_pNetData->length = uLength;
	}
	else
	{
		return E_FAIL;
	}
	return S_OK;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\medictrl.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    medictrl.h

Abstract:
	Defines the MediaControl class which encapsulates the multimedia devices, in particular
	WaveIn and WaveOut.

--*/

#ifndef _MEDICTRL_H_
#define _MEDICTRL_H_


#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define MC_USING_DEFAULT			((UINT) -1)

// #define MC_DEF_SILENCE_LEVEL		110	// about 10%
// #define MC_DEF_SILENCE_LEVEL		20	// about 2%
#define MC_DEF_SILENCE_LEVEL		60	// about 6%
#define MC_DEF_SILENCE_DURATION		600	// 600ms
#define MC_DEF_DURATION				40	// 40ms
#define MC_DEF_VOLUME				50	// 50%

#define MC_DEF_RECORD_TIMEOUT		2000 // 1000ms
#define MC_DEF_PLAY_TIMEOUT			2000 // 1000ms

#define MC_DEF_RECORD_BUFS			4
#define MC_DEF_PLAY_BUFS			4


typedef struct tagMediaCtrlInitStruct
{
	DWORD		dwFlags;
	HWND		hAppWnd;		// handle to window that owns the NAVC
	HINSTANCE	hAppInst;		// handle to instance of app
}
	MEDIACTRLINIT;

typedef struct tagMediaCtrlConfigStruct
{
	ULONG		cbSamplesPerPkt;	// samples per buffer (only needed if duration is not specified)
	DPHANDLE	hStrm;		// Rx/Tx audio stream
	UINT		uDevId;
	PVOID		pDevFmt;
	UINT		uDuration;		// buffer duration in units of ms, usually 20ms or 30ms

}MEDIACTRLCONFIG;


class MediaControl
{
protected:

	// flags
	DWORD		m_dwFlags;			// compatible to that of class AudioPacket

	// ptr to stream object
	DPHANDLE	m_hStrm;		// Rx/Tx  queue

	// device id
	UINT		m_uDevId;

	// device of mm io
	DPHANDLE	m_hDev;
	PVOID		m_pDevFmt;
	ULONG		m_cbSizeDevData;	// ATT: the sender must agree on this size
									// this should be done in format negotiation
									// need to talk to MikeV about this!!!
	// properties
	UINT		m_uState;			// state: idle, start, pause, stop
	UINT		m_uDuration;		// duration per frame, in units of 10ms
	BOOL volatile m_fJammed;		// is the device allocated elsewhere

	// notification event
	HANDLE		m_hEvent;

	// references to audio packets
	MediaPacket	**m_ppMediaPkt;
	ULONG		m_cMediaPkt;

protected:

	void _Construct ( void );
	void _Destruct ( void );

public:

	MediaControl ( void );
	~MediaControl ( void );

	virtual HRESULT Initialize ( MEDIACTRLINIT * p );
	virtual HRESULT Configure ( MEDIACTRLCONFIG * p ) = 0;
	virtual HRESULT FillMediaPacketInit ( MEDIAPACKETINIT * p );
	virtual HRESULT SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal );
	virtual HRESULT GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal );
	virtual HRESULT Open ( void ) = 0;
	virtual HRESULT Start ( void ) = 0;
	virtual HRESULT Stop ( void ) = 0;
	virtual HRESULT Reset ( void ) = 0;
	virtual HRESULT Close ( void ) = 0;
	virtual HRESULT RegisterData ( PVOID pDataPtrArray, ULONG cElements );
	virtual HRESULT PrepareHeaders ( void );
	virtual HRESULT UnprepareHeaders ( void );
	virtual HRESULT Release ( void );
};

class WaveInControl : public MediaControl {
private:
	UINT		m_uTimeout;			// timeout in notification wait
	UINT		m_uPrefeed;			// num of buffers prefed to device
	UINT		m_uSilenceDuration;	// continuous silence before cutoff

public:	
	WaveInControl ( void );
	~WaveInControl ( void );

	HRESULT Initialize ( MEDIACTRLINIT * p );
	HRESULT Configure ( MEDIACTRLCONFIG * p );
	HRESULT SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal );
	HRESULT GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal );
	HRESULT Open ( void );
	HRESULT Start ( void );
	HRESULT Stop ( void );
	HRESULT Reset ( void );
	HRESULT Close ( void );
	
};

class WaveOutControl : public MediaControl {
private:
	UINT		m_uVolume;			// volume of the sound
	UINT		m_uTimeout;			// timeout in notification wait
	UINT		m_uPrefeed;			// num of buffers prefed to device
	UINT		m_uPosition;		// position of the playback stream
public:	
	WaveOutControl ( void );
	~WaveOutControl ( void );
	HRESULT Initialize ( MEDIACTRLINIT * p );
	HRESULT Configure ( MEDIACTRLCONFIG * p );
	HRESULT SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal );
	HRESULT GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal );
	HRESULT Open ( void );
	HRESULT Start ( void );
	HRESULT Stop ( void );
	HRESULT Reset ( void );
	HRESULT Close ( void );
};

enum
{
	MC_PROP_MEDIA_STREAM,
	MC_PROP_MEDIA_DEV_HANDLE,
	MC_PROP_MEDIA_FORMAT,
	MC_PROP_SIZE,
	MC_PROP_PLATFORM,
	MC_PROP_VOLUME,
	MC_PROP_SILENCE_LEVEL,
	MC_PROP_SILENCE_DURATION,
	MC_PROP_TIMEOUT,
	MC_PROP_PREFEED,
	MC_PROP_DURATION,
	MC_PROP_DUPLEX_TYPE,
	MC_PROP_EVENT_HANDLE,
	MC_PROP_SPP,
	MC_PROP_SPS,
	MC_PROP_STATE,
	MC_PROP_VOICE_SWITCH,
	MC_PROP_AUDIO_STRENGTH,
	MC_PROP_MEDIA_DEV_ID,
	MC_PROP_AUDIO_JAMMED,
	MC_PROP_NumOfProps
};


enum
{
	MC_TYPE_AUDIO,
	MC_TYPE_NumOfTypes
};


enum
{
	MC_STATE_IDLE,
	MC_STATE_START,
	MC_STATE_PAUSE,
	MC_STATE_STOP,
	MC_STATE_NumOfStates
};


#include <poppack.h> /* End byte packing */

#endif // _MEDICTRL_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\mediapkt.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    audpackt.h

Abstract:

    Contains  prototypes for the AudioPacket class, which encapsulates a sound buffer in
    its various states: recorded/encoded/network/decoded/playing etc.

--*/
#ifndef _MEDIAPKT_H_
#define _MEDIAPKT_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */



class MediaControl;
class FilterManager;
class DataPump;

typedef struct tagNetBuf
{
	// first part looks like a Winsock WSABUF struct
	ULONG		length;
	UCHAR		*data;
	class BufferPool	*pool;
	struct tagNetBuf *next;
}
	NETBUF;


typedef struct tagMediaPacketInit
{
	// flags
	DWORD		dwFlags;
	// if set then MediaPacket doesnt allocate NETBUFs for RawData
	BOOL		fDontAllocRawBufs;
	
	// stream of conversion
	DPHANDLE	hStrmConv;
	PVOID		pStrmConvSrcFmt;
	PVOID		pStrmConvDstFmt;

	// device of mm io
	// DPHANDLE	hDevAudio;
	PVOID		pDevFmt;

	// dev buffer
	// PVOID	pDevData;
	ULONG		cbSizeDevData;
	ULONG		cbOffsetDevData;

	// wave buffer
	// PVOID	pWaveData;
	ULONG		cbSizeRawData;
	ULONG		cbOffsetRawData;

	// net buffer
	ULONG		cbSizeNetData;
	ULONG		cbOffsetNetData;
	ULONG		cbPayloadHeaderSize;
	int			index;
	BYTE		payload;

}
	MEDIAPACKETINIT;


/////////////////////////////////////////////
//
// AudioPacket
//
#define DP_MASK_STATE		  0x000000FFUL

class MediaPacket
{

protected:

	// stream of conversion
	DPHANDLE	m_hStrmConv;
	PVOID		m_pStrmConvHdr;
	PVOID		m_pStrmConvSrcFmt;
	PVOID		m_pStrmConvDstFmt;

	// device of mm io
	DPHANDLE	m_hDev;
	PVOID		m_pDevHdr;
	PVOID		m_pDevFmt;

	// dev related buffer and info
	NETBUF		*m_pDevData;

	// wave related buffer and info
	NETBUF		*m_pRawData;
	UINT        m_cbValidRawData;  // audio only - size of decode results

	// network related buffer and info
	NETBUF		*m_pNetData;
	UINT		m_cbMaxNetData;		// size of allocated net buffer

	// public properties accessible
	DWORD		m_dwState;
	BOOL		m_fBusy;	// set if not owned by rx/txstream
	UINT		m_seq;		// RTP seq num
	UINT		m_index;	// position in queue

	
	// internal properties
	BOOL		m_fInitialized;
	BOOL		m_fDevPrepared;
	BOOL		m_fStrmPrepared;


private:

	void _Construct ( void );
	void _Destruct ( void );

public:
 	BOOL m_fRendering;

	UINT		m_fMark;	// RTP mark bit
	DWORD		m_timestamp;// RTP timestamp
	BYTE		m_payload;	// RTP payload

	MediaPacket ( void );
	~MediaPacket ( void );

	virtual HRESULT Initialize ( MEDIAPACKETINIT * p );
	virtual HRESULT Receive (NETBUF *pNetBuf, DWORD timestamp, UINT seq, UINT fMark);
	virtual HRESULT Play ( MMIODEST *pmmioDest, UINT uDataType )  = 0;
	virtual HRESULT Record ( void ) = 0;
	virtual HRESULT GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal );
	virtual HRESULT SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal );
	virtual HRESULT Interpolate ( MediaPacket * pPrev, MediaPacket * pNext) = 0;
	virtual HRESULT Release ( void );
	virtual HRESULT Recycle ( void );
	virtual HRESULT Open ( UINT uType, DPHANDLE hdl ) = 0;	// called by RxStream or TxStream
	virtual HRESULT Close ( UINT uType ) = 0;				// called by RxStream or TxStream
	virtual BOOL IsBufferDone ( void ) = 0;
	virtual BOOL IsSameMediaFormat(PVOID fmt1,PVOID fmt2) = 0;
	virtual void WriteToFile (MMIODEST *pmmioDest) = 0;
	virtual void ReadFromFile (MMIOSRC *pmmioSrc ) = 0;
	virtual HRESULT GetSignalStrength (  PDWORD pdwMaxStrength ) = 0;
	virtual HRESULT MakeSilence ( void ) = 0;
	BOOL SetDecodeBuffer(NETBUF *pNetBuf);
	BOOL Busy(void) { return m_fBusy;}
	void Busy(BOOL fBusy) { m_fBusy = fBusy;}
	UINT GetSeqNum(void) { return m_seq;}
	DWORD GetTimestamp(void) { return m_timestamp;}
	BYTE GetPayload(void) { return m_payload;}
	VOID SetPayload(BYTE bPayload) { m_payload = bPayload;}
	UINT GetIndex(void) {return m_index;}
	UINT GetState(void) { return (m_dwState & DP_MASK_STATE); }
	void SetState(DWORD s) { m_dwState = (m_dwState & ~DP_MASK_STATE) | (s & DP_MASK_STATE); }
	void* GetConversionHeader() {return m_pStrmConvHdr;}

	HRESULT GetDevData(PVOID *ppData, PUINT pcbData) ;
	HRESULT GetNetData(PVOID *ppData, PUINT pcbData);
	HRESULT SetNetLength(UINT uLength);
	virtual DWORD GetDevDataSamples() = 0;
	inline DWORD GetFrameSize() {return ((DWORD)m_pNetData->length);}
	inline void SetRawActual(UINT uRawValid) {m_cbValidRawData = uRawValid;}
};


enum
{
	MP_STATE_RESET,

	MP_STATE_RECORDING,
	MP_STATE_RECORDED,
	MP_STATE_ENCODED,
	MP_STATE_NET_OUT_STREAM,

	MP_STATE_NET_IN_STREAM,
	MP_STATE_DECODED,
	MP_STATE_PLAYING_BACK,
	MP_STATE_PLAYING_SILENCE,
	MP_STATE_PLAYED_BACK,

	MP_STATE_RECYCLED,

	MP_STATE_NumOfStates
};



enum
{
	MP_DATATYPE_FROMWIRE,
	MP_DATATYPE_SILENCE,
	MP_DATATYPE_INTERPOLATED,
	MP_DATATYPE_NumOfDataTypes
};

// types for Open()/Close()
enum
{
	MP_TYPE_RECVSTRMCONV,
	MP_TYPE_STREAMCONV,
	MP_TYPE_DEV,
	MP_TYPE_NumOfTypes
};



enum
{
	MP_PROP_STATE,
	MP_PROP_PLATFORM,
	MP_PROP_DEV_MEDIA_FORMAT,
	MP_PROP_DEV_DATA,
	MP_PROP_DEV_HANDLE,
	MP_PROP_DEV_MEDIA_HDR,
	MP_PROP_IN_STREAM_FORMAT,
	MP_PROP_OUT_STREAM_FORMAT,
	MP_PROP_TIMESTAMP,
	MP_PROP_INDEX,
	MP_PROP_PREAMBLE,
	MP_PROP_SEQNUM,
	MP_PROP_FILTER_HEADER,
	MP_PROP_MAX_NET_LENGTH,
	MP_PROP_NumOfProps
};

#include <poppack.h> /* End byte packing */

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\medictrl.cpp ===
#include "precomp.h"

extern HANDLE g_hEventHalfDuplex;


///////////////////////////////////////////////////////
//
//  Public methods
//


MediaControl::MediaControl ( void )
{
	_Construct ();
}


MediaControl::~MediaControl ( void )
{
	_Destruct ();
}

HRESULT MediaControl::Initialize ( MEDIACTRLINIT * p )
{
	HRESULT hr = DPR_SUCCESS;
	DEBUGMSG (ZONE_VERBOSE, ("MediaControl::Initialize: enter.\r\n"));

	m_dwFlags = p->dwFlags;
	m_hEvent = NULL;

	m_uDuration = MC_DEF_DURATION;
	
	DEBUGMSG (ZONE_VERBOSE, ("MediaControl::Initialize: exit, hr=0x%lX\r\n",  hr));

	m_hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
	if (m_hEvent == NULL)
	{
		hr = DPR_CANT_CREATE_EVENT;
	}

	return hr;
}

HRESULT MediaControl::RegisterData ( PVOID pDataPtrArray, ULONG cElements )
{
	HRESULT hr;

	if (pDataPtrArray == NULL) return DPR_INVALID_PARAMETER;

	m_ppMediaPkt = (MediaPacket **) pDataPtrArray;
	m_cMediaPkt = cElements;
	hr = DPR_SUCCESS;

	return hr;
}


HRESULT MediaControl::FillMediaPacketInit ( MEDIAPACKETINIT * p )
{
	if (p == NULL) return DPR_INVALID_PARAMETER;

	p->pDevFmt = m_pDevFmt;

	p->cbSizeDevData = m_cbSizeDevData;
	p->cbOffsetDevData = 0;

	return DPR_SUCCESS;
}


HRESULT MediaControl::SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal )
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	switch (dwPropId)
	{
	case MC_PROP_MEDIA_STREAM:
		m_hStrm = (DPHANDLE) dwPropVal;
		break;

	case MC_PROP_MEDIA_DEV_HANDLE:
		m_hDev = (DPHANDLE) dwPropVal;
		break;

	case MC_PROP_MEDIA_DEV_ID:
		m_uDevId = (UINT) dwPropVal;
		break;

	case MC_PROP_MEDIA_FORMAT:
		m_pDevFmt = (PVOID) dwPropVal;
		break;

	case MC_PROP_SIZE:
		m_cbSizeDevData = (DWORD)dwPropVal;
		break;

	case MC_PROP_PLATFORM:
		m_dwFlags = (DWORD)((m_dwFlags & ~DP_MASK_PLATFORM) | (dwPropVal & DP_MASK_PLATFORM));
		break;

	case MC_PROP_DURATION:
		m_uDuration = (DWORD)dwPropVal;
		break;

	case MC_PROP_DUPLEX_TYPE:
		m_dwFlags = (DWORD)((m_dwFlags & ~DP_MASK_DUPLEX) | (dwPropVal & DP_MASK_DUPLEX));
		break;

	case MC_PROP_STATE:
		hr = DPR_IMPOSSIBLE_SET_PROP;
		break;

	case MC_PROP_AUDIO_JAMMED:
		m_fJammed = (DWORD)dwPropVal;
		break;

	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}


HRESULT MediaControl::GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
		case MC_PROP_MEDIA_STREAM:
			*pdwPropVal = (DWORD_PTR) m_hStrm;
			break;

		case MC_PROP_MEDIA_DEV_HANDLE:
			*pdwPropVal = (DWORD_PTR) m_hDev;
			break;

		case MC_PROP_MEDIA_DEV_ID:
			*pdwPropVal = (DWORD) m_uDevId;
			break;

		case MC_PROP_MEDIA_FORMAT:
			*pdwPropVal = (DWORD_PTR) m_pDevFmt;
			break;

		case MC_PROP_SIZE:
			*pdwPropVal = (DWORD) m_cbSizeDevData;
			break;

		case MC_PROP_PLATFORM:
			*pdwPropVal = m_dwFlags & DP_MASK_PLATFORM;
			break;

		case MC_PROP_STATE:
			*pdwPropVal = m_uState;
			break;

		case MC_PROP_DURATION:
			*pdwPropVal = m_uDuration;
			break;

		case MC_PROP_DUPLEX_TYPE:
			*pdwPropVal = m_dwFlags & DP_MASK_DUPLEX;
			break;
			
		case MC_PROP_EVENT_HANDLE:
			*pdwPropVal = (DWORD_PTR) m_hEvent;
			break;

		case MC_PROP_AUDIO_JAMMED:
			*pdwPropVal = (DWORD)(m_fJammed ? TRUE : FALSE);
			break;

		default:
			hr = DPR_INVALID_PROP_ID;
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}



HRESULT MediaControl::PrepareHeaders ( void )
{
	HRESULT hr = DPR_SUCCESS;
	MediaPacket **pp;
	ULONG uc;

	if (m_hDev)
	{
		if (m_ppMediaPkt == NULL)
		{
			hr = DPR_INVALID_PARAMETER;
			goto MyExit;
		}

		for (uc = m_cMediaPkt, pp = m_ppMediaPkt; uc--; pp++)
		{
			if (*pp)
			{
				hr = (*pp)->Open (MP_TYPE_DEV, m_hDev);
				if (hr != DPR_SUCCESS)
				{
					goto MyExit;
				}
			}
		}
	}

MyExit:

	return hr;
}


HRESULT MediaControl::UnprepareHeaders ( void )
{
	HRESULT hr = DPR_SUCCESS;
	MediaPacket **pp;
	ULONG uc;

	if (m_hDev)
	{
		if (m_ppMediaPkt == NULL)
		{
			hr = DPR_INVALID_PARAMETER;
			goto MyExit;
		}

		for (uc = m_cMediaPkt, pp = m_ppMediaPkt; uc--; pp++)
		{
			if (*pp)
			{
				hr = (*pp)->Close (MP_TYPE_DEV);
				if (hr != DPR_SUCCESS)
				{
					goto MyExit;
				}
			}
		}

                //
                // LAURABU 11/24/99
                // Messes up pausing/unpausing audio
                // Had added this to fix faults pausing/unpausing video
                //
                // m_cMediaPkt = 0;
                // m_ppMediaPkt = NULL;
                //
	}

MyExit:

	return hr;
}


HRESULT MediaControl::Release ( void )
{
	_Destruct ();
	return DPR_SUCCESS;
}


///////////////////////////////////////////////////////
//
//  Private methods
//


void MediaControl::_Construct ( void )
{
	m_dwFlags = 0;

	m_hStrm = NULL;

	m_uDevId = 0;

	m_hDev = NULL;
	m_pDevFmt = NULL;
	m_uDuration = 0;
	m_cbSizeDevData = 0;

	m_uState = 0;

	m_hEvent = NULL;

	m_ppMediaPkt = NULL;
	m_cMediaPkt = 0;

	m_fJammed = FALSE;
}


void MediaControl::_Destruct ( void )
{
	if (m_hDev) {
	// waveInOut/UnprepareHeaders() and waveIn/OutClose() can fail if the
	// device is still playing.  Need to Reset() first!
		Reset();
		UnprepareHeaders ();
		Close ();
	}

	if (m_hEvent)
	{
		CloseHandle (m_hEvent);
		m_hEvent = NULL;
	}
}

WaveInControl::WaveInControl()
{
}

WaveInControl::~WaveInControl()
{
}

WaveOutControl::WaveOutControl()
{
	m_uPosition = 0;
	m_uVolume = 0;
}

WaveOutControl::~WaveOutControl()
{
}

HRESULT WaveInControl::Initialize ( MEDIACTRLINIT * p )
{
	HRESULT hr = DPR_SUCCESS;
	DEBUGMSG (ZONE_VERBOSE, ("WaveInControl::Initialize: enter.\r\n"));

	if ((hr =MediaControl::Initialize( p)) != DPR_SUCCESS)
		return hr;
	
	m_uTimeout = MC_DEF_RECORD_TIMEOUT;
	
	m_uPrefeed = MC_DEF_RECORD_BUFS;
	
	m_uSilenceDuration = MC_DEF_SILENCE_DURATION;

	DEBUGMSG (ZONE_VERBOSE, ("WaveInControl::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}



HRESULT WaveOutControl::Initialize ( MEDIACTRLINIT * p )
{
	HRESULT hr = DPR_SUCCESS;
	DEBUGMSG (ZONE_VERBOSE, ("WaveOutControl::Initialize: enter.\r\n"));

	if ((hr =MediaControl::Initialize( p)) != DPR_SUCCESS)
		return hr;
		
	m_uTimeout = MC_DEF_PLAY_TIMEOUT;
	
	m_uPrefeed = MC_DEF_PLAY_BUFS;
	
	m_uVolume = MC_DEF_VOLUME;

	DEBUGMSG (ZONE_VERBOSE, ("WaveOutControl::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


HRESULT WaveInControl::Configure ( MEDIACTRLCONFIG * p )
{
	HRESULT hr = DPR_SUCCESS;
	UINT uBlockAlign;

	DEBUGMSG (ZONE_VERBOSE, ("WaveInControl::Configure: enter.\r\n"));


	m_hStrm = p->hStrm;
	m_uDevId = p->uDevId;
	m_pDevFmt = p->pDevFmt;

	if (m_pDevFmt == NULL) return DPR_INVALID_PARAMETER;


	if ((m_uDuration = p->uDuration) == MC_USING_DEFAULT)
	{
		m_cbSizeDevData = ((WAVEFORMAT *) m_pDevFmt)->nAvgBytesPerSec * p->cbSamplesPerPkt
			/((WAVEFORMAT *) m_pDevFmt)->nSamplesPerSec;
		m_uDuration = p->cbSamplesPerPkt*1000 /((WAVEFORMAT *) m_pDevFmt)->nSamplesPerSec;
	} else {
	// roughly calculate the buffer size based on 20ms
	m_cbSizeDevData = ((WAVEFORMAT *) m_pDevFmt)->nAvgBytesPerSec
									* m_uDuration / 1000;

	// need to be on the block alignment boundary
	uBlockAlign = ((WAVEFORMAT *) m_pDevFmt)->nBlockAlign;
	m_cbSizeDevData = ((m_cbSizeDevData + uBlockAlign - 1) / uBlockAlign)
									* uBlockAlign;
	}


	DEBUGMSG (ZONE_VERBOSE, ("WaveInControl::Configure: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


HRESULT WaveOutControl::Configure ( MEDIACTRLCONFIG * p )
{
	HRESULT hr = DPR_SUCCESS;
	UINT uBlockAlign;

	DEBUGMSG (ZONE_VERBOSE, ("WaveOutControl::Configure: enter.\r\n"));


	m_hStrm = p->hStrm;
	m_uDevId = p->uDevId;
	m_pDevFmt = p->pDevFmt;
	
	if (m_pDevFmt == NULL) return DPR_INVALID_PARAMETER;


	if ((m_uDuration = p->uDuration) == MC_USING_DEFAULT)
	{
		m_cbSizeDevData = ((WAVEFORMAT *) m_pDevFmt)->nAvgBytesPerSec * p->cbSamplesPerPkt
			/((WAVEFORMAT *) m_pDevFmt)->nSamplesPerSec;
		m_uDuration = p->cbSamplesPerPkt*1000 /((WAVEFORMAT *) m_pDevFmt)->nSamplesPerSec;
	} else {
	// roughly calculate the buffer size based on 20ms
	m_cbSizeDevData = ((WAVEFORMAT *) m_pDevFmt)->nAvgBytesPerSec
									* m_uDuration / 1000;

	// need to be on the block alignment boundary
	uBlockAlign = ((WAVEFORMAT *) m_pDevFmt)->nBlockAlign;
	m_cbSizeDevData = ((m_cbSizeDevData + uBlockAlign - 1) / uBlockAlign)
									* uBlockAlign;
	}

	DEBUGMSG (ZONE_VERBOSE, ("MediaControl::Configure: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


HRESULT WaveInControl::Open ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;
	MMRESULT mmr;
	DWORD dwfOpen;
	UINT uDevId;

	m_hDev = NULL;

	dwfOpen = CALLBACK_EVENT;
	uDevId = (m_uDevId == (UINT) -1) ? WAVE_MAPPER : m_uDevId;
	mmr = waveInOpen ((HWAVEIN *) &m_hDev, uDevId,
					  (WAVEFORMATEX *) m_pDevFmt,
					  (DWORD_PTR) m_hEvent, 0, dwfOpen);
	// begin hack
	if (mmr == WAVERR_BADFORMAT && uDevId != WAVE_MAPPER) {
		// the sound card probably doesnt support our sample size or sample rate
		// (16 bit, 8Khz)
		// Try using the WAVE_MAPPER. The WAVE_MAPPER may end up using
		// a different device than the one we wanted !!
		DEBUGMSG (1, ("MediaControl::Open: bad format, trying WAVE_MAPPER\r\n" ));
		mmr = waveInOpen ((HWAVEIN *) &m_hDev, WAVE_MAPPER,
					  (WAVEFORMATEX *) m_pDevFmt,
					  (DWORD_PTR) m_hEvent, 0, dwfOpen);
		if (mmr == MMSYSERR_NOERROR)
			m_uDevId = (UINT) -1;	// use WAVE_MAPPER next time
	}
	
	// end hack
	if (mmr != MMSYSERR_NOERROR)
	{
		DEBUGMSG (1, ("MediaControl::Open: waveInOpen failed, mmr=%ld\r\n", (ULONG) mmr));
		hr = DPR_CANT_OPEN_WAVE_DEV;
		goto MyExit;
	}
	else
	{
		hr = DPR_SUCCESS;
	}

MyExit:

	return hr;
}



HRESULT WaveOutControl::Open ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;
	MMRESULT mmr;
	DWORD dwfOpen;
	UINT uDevId;

	m_hDev = NULL;

	dwfOpen = CALLBACK_EVENT;
	uDevId = (m_uDevId == (UINT) -1) ? WAVE_MAPPER : m_uDevId;
	mmr = waveOutOpen ((HWAVEOUT *) &m_hDev, uDevId,
					   (WAVEFORMATEX *) m_pDevFmt,
					   (DWORD_PTR) m_hEvent, 0, dwfOpen);
	// begin hack
	if (mmr == WAVERR_BADFORMAT && uDevId != WAVE_MAPPER) {
		// the sound card probably doesnt support our sample size or sample rate
		// (16 bit, 8Khz)
		// Try using the WAVE_MAPPER. The WAVE_MAPPER may end up using
		// a different device than the one we wanted !!
		DEBUGMSG (1, ("MediaControl::Open: bad format, trying WAVE_MAPPER\r\n" ));
		mmr = waveOutOpen((HWAVEOUT *) &m_hDev, WAVE_MAPPER,
				   (WAVEFORMATEX *) m_pDevFmt,
				   (DWORD_PTR) m_hEvent, 0, dwfOpen);
		if (mmr == MMSYSERR_NOERROR)
			m_uDevId = (UINT) -1;	// use WAVE_MAPPER next time
	}
	// end hack
	if (mmr != MMSYSERR_NOERROR)
	{
		DEBUGMSG (1, ("MediaControl::Open: waveOutOpen failed, mmr=%ld\r\n", (ULONG) mmr));
		hr = DPR_CANT_OPEN_WAVE_DEV;
		goto MyExit;
	}
	else
	{
		hr = DPR_SUCCESS;
	}
		
MyExit:

	return hr;
}



HRESULT WaveInControl::Close ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;
	MMRESULT mmr;

	if (m_hDev)
	{
		mmr = waveInClose ((HWAVEIN) m_hDev);
		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (1, ("MediaControl::CloseAudioDev: waveInClose failed, mmr=%ld\r\n", (ULONG) mmr));
			hr = DPR_CANT_CLOSE_WAVE_DEV;
		}
		else
		{
			hr = DPR_SUCCESS;
		}
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}

	m_hDev = NULL;

	return hr;
}


HRESULT WaveOutControl::Close ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;
	MMRESULT mmr;

	if (m_hDev)
	{
		mmr = waveOutClose ((HWAVEOUT) m_hDev);
		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (1, ("MediaControl::CloseAudioDev: waveOutClose failed, mmr=%ld\r\n", (ULONG) mmr));
			hr = DPR_CANT_CLOSE_WAVE_DEV;
		}
		else
		{
			hr = DPR_SUCCESS;
		}
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}

	m_hDev = NULL;

	return hr;
}



HRESULT WaveInControl::Start ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;
	MMRESULT mmr;

	if (m_hDev)
	{
		mmr = waveInStart ((HWAVEIN) m_hDev);
		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (1, ("MediaControl::StartAudioDev: waveInStart failed, mmr=%ld\r\n", (ULONG) mmr));
			hr = DPR_CANT_START_WAVE_DEV;
		}
		else
		{
			hr = DPR_SUCCESS;
		}
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}
	
	return hr;
}

HRESULT WaveOutControl::Start ( void )
{
	return DPR_SUCCESS;
}

HRESULT WaveOutControl::Stop( void )
{
	return DPR_INVALID_PARAMETER;
}

HRESULT WaveInControl::Stop ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;
	MMRESULT mmr;

	if (m_hDev)
	{
		mmr = waveInStop ((HWAVEIN) m_hDev);
		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (1, ("MediaControl::StopAudioDev: waveInStop failed, mmr=%ld\r\n", (ULONG) mmr));
			hr = DPR_CANT_STOP_WAVE_DEV;
		}
		else
		{
			hr = DPR_SUCCESS;
		}
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}

	return hr;
}



HRESULT WaveInControl::Reset ( void )
{
	HRESULT hr;
	MMRESULT mmr;

	if (m_hDev)
	{
		mmr = waveInReset ((HWAVEIN) m_hDev);
		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (1, ("MediaControl::ResetAudioDev: waveInReset failed, mmr=%ld\r\n", (ULONG) mmr));
			hr = DPR_CANT_RESET_WAVE_DEV;
		}
		else
		{
			hr = DPR_SUCCESS;
		}
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}

	return hr;
}



HRESULT WaveOutControl::Reset ( void )
{
	HRESULT hr;
	MMRESULT mmr;

	if (m_hDev)
	{
			
		mmr = waveOutReset ((HWAVEOUT) m_hDev);
		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (1, ("MediaControl::ResetAudioDev: waveOutReset failed, mmr=%ld\r\n", (ULONG) mmr));
			hr = DPR_CANT_RESET_WAVE_DEV;
		}
		else
		{
			hr = DPR_SUCCESS;
		}
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}

	return hr;
}


HRESULT WaveInControl::SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal )
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	switch (dwPropId)
	{

	case MC_PROP_VOICE_SWITCH:
		m_dwFlags = (DWORD)((m_dwFlags & ~DP_MASK_VOICESWITCH) | (dwPropVal & DP_MASK_VOICESWITCH));
		break;
		

	case MC_PROP_SILENCE_DURATION:
		if (dwPropVal == MC_USING_DEFAULT)
			m_uSilenceDuration = MC_DEF_SILENCE_DURATION;
		else
			m_uSilenceDuration = (DWORD)dwPropVal;		//ms
		break;

	case MC_PROP_TIMEOUT:
		m_uTimeout = (DWORD)dwPropVal;
		break;

	case MC_PROP_PREFEED:
		m_uPrefeed = (DWORD)dwPropVal;
		break;

	default:
		hr = MediaControl::SetProp(dwPropId, dwPropVal );
		break;
	}

	return hr;
}



HRESULT WaveOutControl::SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal )
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	switch (dwPropId)
	{

	case MC_PROP_VOICE_SWITCH:
		m_dwFlags = (DWORD)((m_dwFlags & ~DP_MASK_VOICESWITCH) | (dwPropVal & DP_MASK_VOICESWITCH));
		break;
		
	case MC_PROP_VOLUME:
		if (m_dwFlags & DP_FLAG_SEND)
		{
			hr = DPR_INVALID_PARAMETER;
			goto MyExit;
		}
		if (dwPropVal == MC_USING_DEFAULT)	// dont change the volume
			break;
		// this is in units of % of maximum.  Scale it to mmsystem.
		dwPropVal = min(dwPropVal, 100);
		dwPropVal *= 655;
		dwPropVal |= (dwPropVal << 16);
		mmr = waveOutSetVolume ((HWAVEOUT) m_hDev, (DWORD)dwPropVal);
		if (mmr != MMSYSERR_NOERROR)
		{
			hr = DPR_CANT_SET_VOLUME;
			goto MyExit;
		}

		m_uVolume = (DWORD)dwPropVal;
		break;

	case MC_PROP_TIMEOUT:
		m_uTimeout = (DWORD)dwPropVal;
		break;

	case MC_PROP_PREFEED:
		m_uPrefeed = (DWORD)dwPropVal;
		break;

	default:
		hr = MediaControl::SetProp(dwPropId, dwPropVal );
		break;
	}

MyExit:

	return hr;
}


char LogScale[] = {0, 3, 6, 9, 11, 13, 15,
 17, 19, 21, 23, 24, 26, 27, 28, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
 42, 43, 43, 44, 45, 46, 46, 47, 48, 48, 49, 50, 50, 51, 51, 52, 52, 53, 54, 54,
 55, 55, 56, 56, 57, 57, 58, 58, 59, 59, 59, 60, 60, 61, 61, 62, 62, 62, 63, 63,
 64, 64, 64, 65, 65, 65, 66, 66, 66, 67, 67, 67, 68, 68, 68, 69, 69, 69, 70, 70,
 70, 71, 71, 71, 71, 72, 72, 72, 73, 73, 73, 73, 74, 74, 74, 74, 75, 75, 75, 75,
 76, 76, 76, 76, 77, 77, 77, 77, 78, 78, 78, 78, 79, 79, 79, 79, 79, 80, 80, 80,
 80, 81, 81, 81, 81, 81, 82, 82, 82, 82, 82, 83, 83, 83, 83, 83, 84, 84, 84, 84,
 84, 84, 85, 85, 85, 85, 85, 86, 86, 86, 86, 86, 86, 87, 87, 87, 87, 87, 87, 88,
 88, 88, 88, 88, 88, 89, 89, 89, 89, 89, 89, 89, 90, 90, 90, 90, 90, 90, 91, 91,
 91, 91, 91, 91, 91, 92, 92, 92, 92, 92, 92, 92, 93, 93, 93, 93, 93, 93, 93, 93,
 94, 94, 94, 94, 94, 94, 94, 95, 95, 95, 95, 95, 95, 95, 95, 96, 96, 96, 96, 96,
 96, 96, 96, 97, 97, 97, 97, 97, 97, 97, 97, 97, 98, 98, 98, 98, 98, 98, 98, 98,
 99, 99, 99, 99, 99, 99, 99, 99, 100};


HRESULT WaveInControl::GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
		case MC_PROP_SILENCE_DURATION:
			*pdwPropVal = m_uSilenceDuration;
			break;
		
		case MC_PROP_TIMEOUT:
			*pdwPropVal = m_uTimeout;
			break;

		case MC_PROP_PREFEED:
			*pdwPropVal = m_uPrefeed;
			break;

		case MC_PROP_VOICE_SWITCH:
			*pdwPropVal = m_dwFlags & DP_MASK_VOICESWITCH;
			break;
		
		case MC_PROP_SPP:
//			*pdwPropVal = (DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nSamplesPerSec
//								* m_uDuration / 100UL;
			*pdwPropVal = m_cbSizeDevData * (DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nSamplesPerSec
						/(DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nAvgBytesPerSec;
			break;

		case MC_PROP_SPS:
			*pdwPropVal = (DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nSamplesPerSec;

			break;

		default:
			hr = MediaControl::GetProp( dwPropId, pdwPropVal );
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}

HRESULT WaveOutControl::GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
		case MC_PROP_VOLUME:
			*pdwPropVal = m_uVolume;
			break;

		case MC_PROP_TIMEOUT:
			*pdwPropVal = m_uTimeout;
			break;

		case MC_PROP_PREFEED:
			*pdwPropVal = m_uPrefeed;
			break;

		case MC_PROP_VOICE_SWITCH:
			*pdwPropVal = m_dwFlags & DP_MASK_VOICESWITCH;
			break;
		
		case MC_PROP_SPP:
//			*pdwPropVal = (DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nSamplesPerSec
//								* m_uDuration / 100UL;
			*pdwPropVal = m_cbSizeDevData * (DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nSamplesPerSec
						/(DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nAvgBytesPerSec;
			break;

		case MC_PROP_SPS:
			*pdwPropVal = (DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nSamplesPerSec;

			break;
		
		default:
			hr = MediaControl::GetProp( dwPropId, pdwPropVal );
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\medvctrl.cpp ===
#include "precomp.h"

extern HANDLE g_hVidEventHalfDuplex;


///////////////////////////////////////////////////////
//
//  Public methods
//


VideoInControl::VideoInControl ( void )
{
}


VideoInControl::~VideoInControl ( void )
{
}


VideoOutControl::VideoOutControl ( void )
{
}


VideoOutControl::~VideoOutControl ( void )
{
}


HRESULT VideoInControl::Initialize ( MEDIACTRLINIT * p )
{
	HRESULT hr = DPR_SUCCESS;
	DEBUGMSG (ZONE_VERBOSE, ("VideoInControl::Initialize: enter.\r\n"));

	m_dwFlags = p->dwFlags;
	m_hEvent = NULL;
	m_uDuration = MC_DEF_DURATION;
	m_uTimeout = MC_DEF_RECORD_TIMEOUT;	
	m_uPrefeed = MC_DEF_RECORD_BUFS;
	//Request the max, and let QOS throttle us back
    m_FPSRequested = m_FPSMax = 2997;
	
	DEBUGMSG (ZONE_VERBOSE, ("VideoInControl::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


HRESULT VideoOutControl::Initialize ( MEDIACTRLINIT * p )
{
	HRESULT hr = DPR_SUCCESS;
	DEBUGMSG (ZONE_VERBOSE, ("VideoOutControl::Initialize: enter.\r\n"));

	if ((hr =MediaControl::Initialize( p)) != DPR_SUCCESS)
		return hr;

	m_uTimeout = MC_DEF_PLAY_TIMEOUT;
	
	m_uPrefeed = MC_DEF_PLAY_BUFS;
	
	DEBUGMSG (ZONE_VERBOSE, ("VideoOutControl::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


HRESULT VideoInControl::Configure ( MEDIACTRLCONFIG * p )
{
	UINT uBlockAlign;

	DEBUGMSG (ZONE_VERBOSE, ("VideoInControl::Configure: enter.\r\n"));


	m_hStrm = p->hStrm;
	m_uDevId = p->uDevId;
	m_pDevFmt = p->pDevFmt;
	
	if (m_pDevFmt == NULL) return DPR_INVALID_PARAMETER;


	if ((m_uDuration = p->uDuration) == MC_USING_DEFAULT)
	{
		m_cbSizeDevData = ((VIDEOFORMATEX *) m_pDevFmt)->nAvgBytesPerSec * p->cbSamplesPerPkt
			/((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec;
		m_uDuration = p->cbSamplesPerPkt*1000 /((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec;
	} else {
	// roughly calculate the buffer size based on 20ms
	m_cbSizeDevData = ((VIDEOFORMATEX *) m_pDevFmt)->nAvgBytesPerSec
									* m_uDuration / 1000;

	// need to be on the block alignment boundary
	uBlockAlign = ((VIDEOFORMATEX *) m_pDevFmt)->nBlockAlign;
	m_cbSizeDevData = ((m_cbSizeDevData + uBlockAlign - 1) / uBlockAlign)
									* uBlockAlign;
	}
	// at configuration we set the max. frame rate
    if (m_uDuration)
    	m_FPSMax = 100000 / m_uDuration;  // convert msec/frame to fps
	m_FPSRequested = ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec * 100;

	DEBUGMSG (ZONE_VERBOSE, ("VideoInControl::Configure: exit\r\n"));
	return DPR_SUCCESS;
}


HRESULT VideoOutControl::Configure ( MEDIACTRLCONFIG * p )
{
	UINT uBlockAlign;
	
	DEBUGMSG (ZONE_VERBOSE, ("VideoOutControl::Configure: enter.\r\n"));

	m_hStrm = p->hStrm;
	m_uDevId = p->uDevId;
	m_pDevFmt = p->pDevFmt;
	
	if (m_pDevFmt == NULL) return DPR_INVALID_PARAMETER;


	if ((m_uDuration = p->uDuration) == MC_USING_DEFAULT)
	{
		m_cbSizeDevData = ((VIDEOFORMATEX *) m_pDevFmt)->nAvgBytesPerSec * p->cbSamplesPerPkt
			/((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec;
		m_uDuration = p->cbSamplesPerPkt*1000 /((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec;
	} else {
	// roughly calculate the buffer size based on 20ms
	m_cbSizeDevData = ((VIDEOFORMATEX *) m_pDevFmt)->nAvgBytesPerSec
									* m_uDuration / 1000;

	// need to be on the block alignment boundary
	uBlockAlign = ((VIDEOFORMATEX *) m_pDevFmt)->nBlockAlign;
	m_cbSizeDevData = ((m_cbSizeDevData + uBlockAlign - 1) / uBlockAlign)
									* uBlockAlign;
	}

	DEBUGMSG (ZONE_VERBOSE, ("VideoOutControl::Configure: exit\r\n"));
	return DPR_SUCCESS;
}


HRESULT VideoInControl::Open ( void )
{
	HRESULT hr;
    FINDCAPTUREDEVICE fcd;
    HFRAMEBUF hbuf;
    DWORD dwSize, i;
    LPBITMAPINFOHEADER lpbi;
	int iWidth, iHeight;
	char szName[MAX_PATH];

    fcd.dwSize = sizeof (FINDCAPTUREDEVICE);
    if (m_uDevId == -1)
   	    FindFirstCaptureDevice(&fcd, NULL);
	else
	{
        if (!FindFirstCaptureDeviceByIndex(&fcd, m_uDevId))
		{
			// Update m_uDevId with new device index
   	        if (FindFirstCaptureDevice(&fcd, NULL))
				m_uDevId = fcd.nDeviceIndex;
		}
    }

#ifndef NO_QCCOLOR_HACK
    if (fcd.szDeviceName[0] && lstrcmpi(fcd.szDeviceName, "qccolor.drv") == 0) {
        // this hack clears out the [conf] section of qccolor.ini to prevent problems in
        // setformat when the driver initializes to an unknown format that is recorded in
        // the ini file.
        dwSize = GetModuleFileName(NULL, szName, sizeof(szName));
        for (i = dwSize-1; i; i--)
            if (szName[i] == '\\' || szName[i] == ':')
                break;
        i++;
        MoveMemory (szName, &szName[i], dwSize-i+1);
        dwSize -= i;
        for (i = dwSize-1; i; i--)
            if (szName[i] == '.') {
                szName[i] = 0;
                break;
            }

        dwSize = 0;
        WritePrivateProfileSection(szName, (LPCTSTR)&dwSize, "QCCOLOR.INI");
    }
#endif

   	if (!(m_hDev = (DPHANDLE)OpenCaptureDevice(fcd.nDeviceIndex)) && m_uDevId != -1) {
		DEBUGMSG (1, ("MediaVidCtrl::Open: OpenCaptureDevice failed, trying VIDEO_MAPPER\r\n" ));
   	    FindFirstCaptureDevice(&fcd, NULL);
	   	if (m_hDev = (DPHANDLE)OpenCaptureDevice(fcd.nDeviceIndex))
			m_uDevId = (UINT) -1;	// use VIDEO_MAPPER next time
	}
   	
	if (m_hDev) {
		hr = DPR_SUCCESS;
    } else {
		DEBUGMSG (1, ("MediaVidCtrl::Open: OpenCaptureDevice failed\r\n" ));
		hr = DPR_CANT_OPEN_DEV;
    }

	return hr;
}


HRESULT VideoOutControl::Open ( void )
{
	return DPR_SUCCESS;
}


HRESULT VideoInControl::Close ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;

	if (m_hDev)
	{
	    CloseCaptureDevice((HCAPDEV)m_hDev);
		hr = DPR_SUCCESS;
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}

	m_hDev = NULL;

	return hr;
}


HRESULT VideoOutControl::Close ( void )
{
	return DPR_SUCCESS;
}


HRESULT VideoInControl::Start ( void )
{
	return DPR_SUCCESS;
}


HRESULT VideoOutControl::Start ( void )
{
	return DPR_SUCCESS;
}


HRESULT VideoInControl::Stop ( void )
{
	return DPR_SUCCESS;
}


HRESULT VideoOutControl::Stop ( void )
{
	return DPR_INVALID_PARAMETER;
}


HRESULT VideoInControl::Reset ( void )
{
	return VideoInControl::Stop();
}


HRESULT VideoOutControl::Reset ( void )
{
	return DPR_SUCCESS;
}


HRESULT VideoInControl::DisplayDriverDialog (HWND hwnd, DWORD dwDlgId)
{
	HRESULT hr = DPR_SUCCESS;
	DWORD dwRes;
	PDWORD pdwMask;

   	if (m_hDev) {
        if (dwDlgId & CAPTURE_DIALOG_SOURCE)
            dwDlgId = CAPDEV_DIALOG_SOURCE;
        else
            dwDlgId = CAPDEV_DIALOG_IMAGE;

#if 1
        if (!CaptureDeviceDialog(m_hDev, hwnd, dwDlgId, NULL)) {
#else
        if (!CaptureDeviceDialog(m_hDev, hwnd, dwDlgId, &((VIDEOFORMATEX *)m_pDevFmt)->bih)) {
#endif
            dwRes = GetLastError();
            if (dwRes == ERROR_DCAP_DIALOG_FORMAT || dwRes == ERROR_DCAP_DIALOG_STREAM) {
                DEBUGMSG (1, ("MediaVidCtrl::Open: CaptureDeviceDialog failed\r\n" ));
                hr = DPR_CONVERSION_FAILED; // user did something in the dialog that caused a problem
            }
            else
                hr = DPR_INVALID_PARAMETER;
        }
    }
    else
        hr = DPR_INVALID_HANDLE;

    return hr;
}

HRESULT VideoInControl::SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal )
{
	HRESULT hr = DPR_SUCCESS;
	UINT ms;

	switch (dwPropId)
	{
		
	case MC_PROP_TIMEOUT:
		m_uTimeout = (DWORD)dwPropVal;
		break;

	case MC_PROP_PREFEED:
		m_uPrefeed = (DWORD)dwPropVal;
		break;

	case MC_PROP_VIDEO_FRAME_RATE:
	case MC_PROP_MAX_VIDEO_FRAME_RATE:
		break;

	default:
		hr = MediaControl::SetProp(dwPropId, dwPropVal );
		break;
	}

	return hr;
}


HRESULT VideoOutControl::SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	switch (dwPropId)
	{
	case MC_PROP_TIMEOUT:
		m_uTimeout = (DWORD)dwPropVal;
		break;

	case MC_PROP_PREFEED:
		m_uPrefeed = (DWORD)dwPropVal;
		break;

	default:
		hr = MediaControl::SetProp(dwPropId, dwPropVal );
		break;
	}

	return hr;
}


HRESULT VideoInControl::GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal )
{
	HRESULT hr = DPR_SUCCESS;
	DWORD dwMask;

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
		case MC_PROP_TIMEOUT:
			*pdwPropVal = m_uTimeout;
			break;

		case MC_PROP_PREFEED:
			*pdwPropVal = m_uPrefeed;
			break;

		case MC_PROP_SPP:
//			*pdwPropVal = (DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec
//								* m_uDuration / 100UL;
			*pdwPropVal = m_cbSizeDevData * (DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec
						/(DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nAvgBytesPerSec;
			break;

		case MC_PROP_SPS:
			*pdwPropVal = (DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec;

			break;
			
		case MC_PROP_VIDEO_FRAME_RATE:
		case MC_PROP_MAX_VIDEO_FRAME_RATE:
			break;
			
        case MC_PROP_VFW_DIALOGS:
			*pdwPropVal = 0;
			if (vcmGetDevCapsDialogs(m_uDevId, &dwMask) == (MMRESULT)MMSYSERR_NOERROR) {
				if (dwMask & SOURCE_DLG_ON)
					*pdwPropVal = CAPTURE_DIALOG_SOURCE;
				if (dwMask & FORMAT_DLG_ON)
					*pdwPropVal |= CAPTURE_DIALOG_FORMAT;
			}
            break;

		default:
			hr = MediaControl::GetProp( dwPropId, pdwPropVal );
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}


HRESULT VideoOutControl::GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
		case MC_PROP_TIMEOUT:
			*pdwPropVal = m_uTimeout;
			break;

		case MC_PROP_PREFEED:
			*pdwPropVal = m_uPrefeed;
			break;

		case MC_PROP_SPP:
//			*pdwPropVal = (DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec
//								* m_uDuration / 100UL;
			*pdwPropVal = m_cbSizeDevData * (DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec
						/(DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nAvgBytesPerSec;
			break;

		case MC_PROP_SPS:
			*pdwPropVal = (DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec;
			
		default:
			hr = MediaControl::GetProp( dwPropId, pdwPropVal );
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\medistrm.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    medistrm.h

Abstract:
	Contains constants and class declarations for the abstract MediaStream object. A MediaStream
	represents a single unidirectional stream, such as a received Video channel.
	
--*/
#ifndef _MEDISTRM_H_
#define _MEDISTRM_H_

#include "dtmf.h"

#include <pshpack8.h> /* Assume 8 byte packing throughout */


class DataPump;
class TxStream;
class RxStream;
class AcmFilter;
class VcmFilter;
class MediaControl;
class BufferPool;
class AudioPacket;
class VideoPacket;

class SendMediaStream : public IMediaChannel {
	friend class SendAudioStream;
protected:
	DataPump *m_pDP;
	TxStream *m_SendStream;
	MediaControl *m_InMedia;
	UINT m_CaptureDevice;		// device id used for recording
	UINT m_PreviousCaptureDevice;		// device id used for recording
	IRTPSession *m_Net;
	IRTPSend *m_pRTPSend;
	BYTE m_RTPPayload;			// payload type
	//BufferPool *m_NetBufferPool;
	DWORD m_SendTimestamp;
	DWORD m_SavedTickCount;
	DWORD m_ThreadFlags;
	DWORD m_DPFlags;
	BOOL m_fSending;
	MEDIA_FORMAT_ID m_PrevFormatId;
	DWORD m_dwDstSize;


	FLOWSPEC m_flowspec;
	HRESULT SetFlowSpec();


	HANDLE m_hCapturingThread;
	DWORD m_CaptureThId;

	CRITICAL_SECTION m_crsQos;

	// IQOS interface pointer and two resources requests: one for BW and one for CPU
	struct {
		int cResourceRequests;
		RESOURCEREQUEST aResourceRequest[2];
	} m_aRRq;

	// Performance statistics
	struct {
		DWORD dwMsCap;					// Capture CPU usage (ms)
		DWORD dwMsComp;					// Compression CPU usage (ms)
        DWORD dwBits;				    // Compressed audio or video frame size (bits)
		DWORD dwCount;					// Number of video frames captured or audio packets recorded
		DWORD dwOldestTs;				// Oldest QoS callback timestamp
		DWORD dwNewestTs;				// Most recent QoS callback timestamp
		HKEY hPerfKey;					// Handle to CPU perf data collection reg key on Win95/98
		DWORD dwSmoothedCPUUsage;		// Previous CPU usage value - used to compute slow-varying average in CPU usage
		BOOL fWinNT;					// Are we running on WinNT or Win95/98?
		struct {						// Structure used to extract CPU usage performance on NT
			DWORD		cbPerfData;
			PBYTE		pbyPerfData;
			HANDLE		hPerfData;
			LONGLONG	llPerfTime100nSec;
			PLONGLONG	pllCounterValue;
			DWORD		dwProcessorIndex;
			DWORD		dwPercentProcessorIndex;
			DWORD		dwNumProcessors;
		} NtCPUUsage;
	} m_Stats;

	RTP_STATS m_RTPStats;			// network stats
public:
	SendMediaStream()
	{
		InitializeCriticalSection(&m_crsQos);
	};
	virtual ~SendMediaStream()
	{
		DeleteCriticalSection(&m_crsQos);
	}

	// Implementation of IMediaChannel::GetState
	STDMETHODIMP_(DWORD) GetState()
	{
		if (m_DPFlags & DPFLAG_STARTED_SEND) return MSSTATE_STARTED;
		else if (m_DPFlags & DPFLAG_CONFIGURED_SEND) return MSSTATE_CONFIGURED;
		else return MSSTATE_UNCONFIGURED;
	}

	virtual HRESULT Initialize(DataPump *) = 0;
	virtual DWORD Send() = 0;
	virtual void EndSend() = 0;

	virtual HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown);


	} ;

class RecvMediaStream : public IMediaChannel
{
	friend class DataPump;
	friend BOOL RTPRecvCallback(DWORD_PTR,WSABUF *);
protected:
	DataPump *m_pDP;
	RxStream *m_RecvStream;
	MediaControl *m_OutMedia;
	UINT m_RenderingDevice;		// device id used for playback

	IRTPSession *m_Net;
	IRTPRecv *m_pIRTPRecv;

	//BufferPool *m_NetBufferPool;
	DWORD m_ThreadFlags;
	DWORD m_DPFlags;
	BOOL m_fReceiving;
	DWORD m_PlaybackTimestamp;	// last played sample
	
	HANDLE m_hRecvThreadStopEvent;
	HANDLE m_hRenderingThread;
	DWORD m_RenderingThId;
	UINT m_nRecvBuffersPending;

	DWORD m_dwSrcSize;

	FLOWSPEC m_flowspec;
	HRESULT SetFlowSpec();



public:
	RecvMediaStream(){};
	virtual HRESULT Initialize(DataPump *) = 0;
	virtual BOOL IsEmpty() = 0;

	// Implementation of IMediaChannel::GetState
	STDMETHODIMP_(DWORD) GetState()
	{
		if (m_DPFlags & DPFLAG_STARTED_RECV) return MSSTATE_STARTED;
		else if (m_DPFlags & DPFLAG_CONFIGURED_RECV) return MSSTATE_CONFIGURED;
		else return MSSTATE_UNCONFIGURED;
	}

	virtual HRESULT RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark)=0;
	
    virtual HRESULT GetCurrentPlayNTPTime(NTP_TS *)=0;
    virtual HRESULT StartRecv(HWND)=0;
    virtual HRESULT StopRecv()=0;

	virtual HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown);


	virtual HRESULT DTMFBeep() {return S_OK;}
	virtual HRESULT OnDTMFBeep() {return S_OK;}

};


class SendVideoStream : public SendMediaStream, public IVideoRender,
                        public IVideoChannel
{
	friend class DataPump;
protected:
    CCaptureChain* m_pCaptureChain;
	VIDEOFORMATEX  m_fDevSend;
	VIDEOFORMATEX  m_fCodecOutput;
	RECT m_cliprect;
	DWORD m_maxfps;
	DWORD m_frametime;

	int *m_pTSTable; // NULL if table isn't used
	DWORD m_dwCurrentTSSetting;

	VcmFilter *m_pVideoFilter;
	IUnknown *m_pIUnknown;					// Pointer to IUnkown from which we'll query the Stream Signal interface

    class MediaPacket *m_pNextPacketToRender;	// current recv video frame
	UINT m_cRendering;		// count of packets given out by GetFrame()
	HANDLE m_hRenderEvent;	// IVideoRender event for recv notification
	LPFNFRAMEREADY m_pfFrameReadyCallback;	// callback function
	CRITICAL_SECTION m_crs;

	CRITICAL_SECTION m_crsVidQoS; // Allows QoS thread to read the video statistics while capture and compression are running

	// the capture thread (and it's launch function)
	static DWORD CALLBACK StartCaptureThread(LPVOID pVoid);
	DWORD CapturingThread();


	HRESULT SendPacket(VideoPacket *pVP, UINT *puBytesSent);
	STDMETHODIMP_(void) UnConfigure(void);

	LONG m_lRefCount;

public:	
	SendVideoStream(): SendMediaStream(){m_Net=NULL; m_lRefCount=0; };
	virtual ~SendVideoStream();
	
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef(void);
	virtual ULONG STDMETHODCALLTYPE Release(void);

	
	// IMediaChannel APIs
	// new version of Configure()
	HRESULT STDMETHODCALLTYPE Configure(
		BYTE *pFormat,
		UINT cbFormat,
		BYTE *pChannelParams,
		UINT cbParams,
		IUnknown *pUnknown);

	STDMETHODIMP Start(void);
	STDMETHODIMP Stop(void);

	HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown)
	{
		return SendMediaStream::SetNetworkInterface(pUnknown);
	}

	STDMETHODIMP_(DWORD) GetState()
	{
		return SendMediaStream::GetState();
	}

	HRESULT STDMETHODCALLTYPE SetMaxBitrate(UINT uMaxBitrate);


	// IVideoChannel
	virtual HRESULT __stdcall SetTemporalSpatialTradeOff(DWORD dwVal);
	virtual HRESULT __stdcall GetTemporalSpatialTradeOff(DWORD *pdwVal);
	virtual HRESULT __stdcall SendKeyFrame(void);
	virtual HRESULT __stdcall ShowDeviceDialog(DWORD dwFlags);
	virtual HRESULT __stdcall GetDeviceDialog(DWORD *pdwFlags);

    // IProperty methods
	STDMETHODIMP GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf);
	STDMETHODIMP SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf);

	// IVideoRender methods
	STDMETHODIMP Init( DWORD_PTR dwUser, LPFNFRAMEREADY pfCallback);
	STDMETHODIMP Done(void);
	STDMETHODIMP GetFrame(FRAMECONTEXT* pfc);
	STDMETHODIMP ReleaseFrame(FRAMECONTEXT *pfc);

	// Other virtual methods
	virtual HRESULT Initialize(DataPump *);

	// Non virtual methods
	static HRESULT CALLBACK QosNotifyVideoCB(LPRESOURCEREQUESTLIST lpResourceRequestList, DWORD_PTR dwThis);
	void UnConfigureSendVideo(BOOL fNewDeviceSettings, BOOL fNewDevice);
	void StartCPUUsageCollection(void);
	BOOL GetCPUUsage(PDWORD pdwOverallCPUUsage);
	void StopCPUUsageCollection(void);
	BOOL SetTargetRates(DWORD dwTargetFrameRate, DWORD dwTargetBitrate);
	DWORD Send();
	void EndSend();


};

class RecvVideoStream : public RecvMediaStream, public IVideoRender {
	friend class DataPump;
protected:
	VIDEOFORMATEX  m_fDevRecv;
	RECT m_cliprect;
	class MediaPacket *m_pNextPacketToRender;	// current recv video frame
	UINT m_cRendering;		// count of packets given out by GetFrame()
	HANDLE m_hRenderEvent;	// IVideoRender event for recv notification
	LPFNFRAMEREADY m_pfFrameReadyCallback;	// callback function
	CRITICAL_SECTION m_crs;
	VcmFilter *m_pVideoFilter;
	IUnknown *m_pIUnknown;					// Pointer to IUnkown from which we'll query the Stream Signal interface
	IStreamSignal *m_pIStreamSignal;		// Pointer to I-Frame request interface
	CRITICAL_SECTION m_crsIStreamSignal;	// Used to serialize access to the interface between Stop() and the RTP callback
	UINT m_ulLastSeq;						// Last received RTP sequence number
	DWORD m_dwLastIFrameRequest;			// When was the last I-frame request sent? Used to make sure we don't send requests too often
	BOOL m_fDiscontinuity;					// Signals that a discontinuity (RTP packet lost or receive frame buffer overflow) was detected

	CRITICAL_SECTION m_crsVidQoS; // Allows QoS thread to read the video statistics while capture and compression are running

	static DWORD CALLBACK StartRenderingThread(PVOID pVoid);
	DWORD RenderingThread();

	STDMETHODIMP_(void) UnConfigure(void);

	LONG m_lRefCount;

public:	
	RecvVideoStream() : RecvMediaStream(){m_Net=NULL; m_lRefCount=0; };
	virtual ~RecvVideoStream();
	
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef(void);
	virtual ULONG STDMETHODCALLTYPE Release(void);

	// IMediaChannel APIs
	HRESULT STDMETHODCALLTYPE Configure(
		BYTE *pFormat,
		UINT cbFormat,
		BYTE *pChannelParams,
		UINT cbParams,
		IUnknown *pUnknown);


	STDMETHODIMP Start(void);
	STDMETHODIMP Stop(void);

	HRESULT STDMETHODCALLTYPE SetMaxBitrate(UINT uMaxBitrate)
	{
		return E_NOTIMPL;
	}

    // IProperty methods
	STDMETHODIMP GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf);
	STDMETHODIMP SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf);

	// IVideoRender methods
	STDMETHODIMP Init( DWORD_PTR dwUser, LPFNFRAMEREADY pfCallback);
	STDMETHODIMP Done(void);
	STDMETHODIMP GetFrame(FRAMECONTEXT* pfc);
	STDMETHODIMP ReleaseFrame(FRAMECONTEXT *pfc);

	// Other virtual methods
	virtual HRESULT Initialize(DataPump *);
	virtual BOOL IsEmpty();
	HRESULT GetCurrentPlayNTPTime(NTP_TS *);
    virtual HRESULT StartRecv(HWND);
    virtual HRESULT StopRecv();

	virtual HRESULT RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark);


	// Non virtual methods

};

extern char LogScale[];

class AudioSilenceDetector {
private:
	UINT		m_uManualSilenceLevel;	// silence level in unit of 1/1000
	DWORD 		m_dwMaxStrength;	// signal strength in units of 1/1000
	INT 		m_iSilenceLevel;	// adaptive silence threshold
	INT 		m_iSilenceAvg;		// scale factor 256
	INT 		m_iTalkAvg;			// average strength of non-silent signal

public:
	AudioSilenceDetector();
	void SetSilenceLevel(UINT level) {m_uManualSilenceLevel = level;}
	UINT GetSilenceLevel(void)  {return m_uManualSilenceLevel;}
	UINT GetSignalStrength(void) {return LogScale[m_dwMaxStrength >> 8];}
	BOOL SilenceDetect(WORD strength);
};

class SendAudioStream : public SendMediaStream, public IAudioChannel, public IDTMFSend
{
	friend class DataPump;
private:
	WAVEFORMATEX m_fDevSend;
	WAVEFORMATEX m_wfCompressed;
	AcmFilter *m_pAudioFilter;  // this will replace m_fSendFilter
	MMIOSRC		m_mmioSrc;
	AudioSilenceDetector m_AudioMonitor;
	BOOL	m_bAutoMix;

	static DWORD CALLBACK StartRecordingThread (LPVOID pVoid);
	DWORD RecordingThread();

	HRESULT SendPacket(AudioPacket *pAP, UINT *puBytesSent);
	STDMETHODIMP_(void) UnConfigure(void);

	LONG m_lRefCount;

	DTMFQueue *m_pDTMF;
	HRESULT __stdcall SendDTMF();

public:
	SendAudioStream() : SendMediaStream(){m_Net=NULL;m_lRefCount=0;};
	virtual ~SendAudioStream();


	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef(void);
	virtual ULONG STDMETHODCALLTYPE Release(void);

	// IMediaChannel APIs
	// new version of Configure()
	HRESULT STDMETHODCALLTYPE Configure(
		BYTE *pFormat,
		UINT cbFormat,
		BYTE *pChannelParams,
		UINT cbParams,
		IUnknown *pUnknown);

	STDMETHODIMP Start(void);
	STDMETHODIMP Stop(void);

	HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown)
	{
		return SendMediaStream::SetNetworkInterface(pUnknown);
	}

	STDMETHODIMP_(DWORD) GetState()
	{
		return SendMediaStream::GetState();
	}

	HRESULT STDMETHODCALLTYPE SetMaxBitrate(UINT uMaxBitrate);

	// IAudioChannel
	STDMETHODIMP GetSignalLevel(UINT *pSignalStrength);

	
	// IDTMFSend
	virtual HRESULT __stdcall AddDigit(int nDigit);
	virtual HRESULT __stdcall ResetDTMF();


    // IProperty methods
	STDMETHODIMP GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf);
	STDMETHODIMP SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf);

	// Other virtual methods
	virtual HRESULT Initialize(DataPump *pdp);

	// Non virtual methods
	static HRESULT CALLBACK QosNotifyAudioCB(LPRESOURCEREQUESTLIST lpResourceRequestList, DWORD_PTR dwThis);

	HRESULT OpenSrcFile (void);
	HRESULT CloseSrcFile (void);
	DWORD Send();
	void EndSend();

};

class RecvAudioStream : public RecvMediaStream, public IAudioChannel
{
	friend class DataPump;
private:
	WAVEFORMATEX m_fDevRecv;
	IAppAudioCap* m_pAudioCaps;	// pointer to the audio capabilities object
	// mmio file operations
	MMIODEST	m_mmioDest;

	AcmFilter *m_pAudioFilter;  // this will replace m_fSendFilter

	AudioSilenceDetector m_AudioMonitor;
	
	CRITICAL_SECTION m_crsAudQoS; // Allows QoS thread to read the audio statistics while recording and compression are running

	static DWORD CALLBACK StartPlaybackThread(LPVOID pVoid);
	DWORD PlaybackThread();

	STDMETHODIMP_(void) UnConfigure(void);

	LONG m_lRefCount;

	virtual HRESULT DTMFBeep();


public:	
	RecvAudioStream() :RecvMediaStream(){m_Net=NULL;m_lRefCount=0;};
	virtual ~RecvAudioStream();


	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef(void);
	virtual ULONG STDMETHODCALLTYPE Release(void);


	// IMediaChannel APIs
	HRESULT STDMETHODCALLTYPE Configure(
		BYTE *pFormat,
		UINT cbFormat,
		BYTE *pChannelParams,
		UINT cbParams,
		IUnknown *pUnknown);


	STDMETHODIMP Start(void);
	STDMETHODIMP Stop(void);

	HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown)
	{
		return RecvMediaStream::SetNetworkInterface(pUnknown);
	}

	STDMETHODIMP_(DWORD) GetState()
	{
		return RecvMediaStream::GetState();
	}

	HRESULT STDMETHODCALLTYPE SetMaxBitrate(UINT uMaxBitrate)
	{
		return E_NOTIMPL;
	}

	// IAudioChannel
	STDMETHODIMP GetSignalLevel(UINT *pSignalStrength);


    // IProperty methods
	STDMETHODIMP GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf);
	STDMETHODIMP SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf);

	// Other virtual inherited methods
	virtual HRESULT Initialize(DataPump *);
	virtual BOOL IsEmpty();
	HRESULT GetCurrentPlayNTPTime(NTP_TS *);
    virtual HRESULT StartRecv(HWND);
    virtual HRESULT StopRecv();

	virtual HRESULT RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark);



};

#include <poppack.h> /* End byte packing */


#endif // _MEDISTRM_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\medvctrl.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    medvctrl.h

Abstract:
	Defines the MediaControl class which encapsulates the multimedia devices, in particular
	videoIn and videoOut.

--*/

#ifndef _MEDVCTRL_H_
#define _MEDVCTRL_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

class VideoInControl : public MediaControl {
private:
	UINT		m_uTimeout;			// timeout in notification wait
	UINT		m_uPrefeed;			// num of buffers prefed to device
	UINT 		m_FPSRequested;     // requested frame rate
	UINT		m_FPSMax;           // max frame rate
public:	
	VideoInControl ( void );
	~VideoInControl ( void );

	HRESULT Initialize ( MEDIACTRLINIT * p );
	HRESULT Configure ( MEDIACTRLCONFIG * p );
	HRESULT SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal );
	HRESULT GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal );
	HRESULT Open ( void );
	HRESULT Start ( void );
	HRESULT Stop ( void );
	HRESULT Reset ( void );
	HRESULT Close ( void );
	HRESULT DisplayDriverDialog (HWND hwnd, DWORD dwDlgId);
};

class VideoOutControl : public MediaControl {
private:
	UINT		m_uTimeout;			// timeout in notification wait
	UINT		m_uPrefeed;			// num of buffers prefed to device
	UINT		m_uPosition;		// position of the playback stream
public:	
	VideoOutControl ( void );
	~VideoOutControl ( void );

	HRESULT Initialize ( MEDIACTRLINIT * p );
	HRESULT Configure ( MEDIACTRLCONFIG * p );
	HRESULT SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal );
	HRESULT GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal );
	HRESULT Open ( void );
	HRESULT Start ( void );
	HRESULT Stop ( void );
	HRESULT Reset ( void );
	HRESULT Close ( void );
};

enum {
	MC_PROP_VIDEO_FRAME_RATE = MC_PROP_NumOfProps,
	MC_PROP_MAX_VIDEO_FRAME_RATE,
	MC_PROP_VFW_DIALOGS
	};

#include <poppack.h> /* End byte packing */

#endif // _MEDVCTRL_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\medistrm.cpp ===
#include <precomp.h>


// IID_IProperty
IID IID_IProperty = 
	{ /* 4e94d3e0-793e-11d0-8ef0-00a0c90541f4 */
    0x4e94d3e0,
    0x793e,
    0x11d0,
    {0x8e, 0xf0, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0xf4}
  };
 


// default implementations for SetNetworkInterface

HRESULT STDMETHODCALLTYPE SendMediaStream::SetNetworkInterface(IUnknown *pUnknown)
{
	HRESULT hr=S_OK;
	IRTPSend *pRTPSend=NULL;

	if (m_DPFlags & DPFLAG_STARTED_SEND)
	{
		return DPR_IO_PENDING; // anything better to return ?
	}

	if (pUnknown != NULL)
	{
		hr = pUnknown->QueryInterface(IID_IRTPSend, (void**)&pRTPSend);
	}

	if (SUCCEEDED(hr))
	{
		if (m_pRTPSend)
		{
			m_pRTPSend->Release();
		}
		m_pRTPSend = pRTPSend;
		ZeroMemory(&m_RTPStats,sizeof(m_RTPStats));	// reset network stats
	}

	return hr;

}


HRESULT SendMediaStream::SetFlowSpec()
{
	HRESULT hr = DPR_NOT_CONFIGURED;
	IRTPSession *pRtpSession;

	if (m_pDP->m_bDisableRSVP)
		return S_OK;

	if ((m_DPFlags & DPFLAG_CONFIGURED_SEND) && (m_pRTPSend))
	{
		m_pRTPSend->QueryInterface(IID_IRTPSession, (void**)&pRtpSession);

		pRtpSession->SetSendFlowspec(&m_flowspec);
		pRtpSession->Release();
		hr = DPR_SUCCESS;
	}

	return hr;
}


HRESULT RecvMediaStream::SetFlowSpec()
{
	HRESULT hr = DPR_NOT_CONFIGURED;
	IRTPSession *pSession=NULL;

	if (m_pDP->m_bDisableRSVP)
		return S_OK;
	
	if ((m_DPFlags & DPFLAG_CONFIGURED_RECV) && (m_pIRTPRecv))
	{
		// the following is bogus for two reasons
		// 1. when we go multipoint, we really need to set
		//    set the WinsockQos based on the total number
		//    of incoming sessions.
		// 2. The RTP interfaces will eventually be made
		//    so that RTP Session and RTPRecv objects are
		//    distinct.  So QI will fail.
		hr = m_pIRTPRecv->QueryInterface(IID_IRTPSession, (void**)&pSession);
		if (SUCCEEDED(hr))
		{
			pSession->SetRecvFlowspec(&m_flowspec);
			pSession->Release();
			hr = DPR_SUCCESS;
		}
	}

	return hr;
}


HRESULT STDMETHODCALLTYPE RecvMediaStream::SetNetworkInterface(IUnknown *pUnknown)
{
	HRESULT hr=S_OK;
	IRTPRecv *pRTPRecv=NULL;

	// don't try to do change the RTP interface while in mid-stream
	if (m_DPFlags & DPFLAG_STARTED_RECV)
	{
		return DPR_IO_PENDING; // anything better to return ?
	}

	if (pUnknown)
	{
		hr = pUnknown->QueryInterface(IID_IRTPRecv, (void**)&pRTPRecv);
	}
	if (SUCCEEDED(hr))
	{
		if (m_pIRTPRecv)
		{
			m_pIRTPRecv->Release();
		}
		m_pIRTPRecv = pRTPRecv;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\mixer.cpp ===
#include "precomp.h"
#include <mixer.h>

//
// private APIs
//


#define MAX_MICROPHONE_DEVS 10

static MMRESULT mixerGetControlValue ( HMIXER, DWORD *, DWORD, UINT );
static MMRESULT mixerSetControlValue ( HMIXER, DWORD *, DWORD, UINT );
static MMRESULT mixerGetControlId ( HMIXER, DWORD *, DWORD, DWORD );
static MMRESULT mixerGetControlByType ( HMIXER, DWORD, DWORD, MIXERCONTROL *pMixerControl);


struct AGCDetails
{
	WORD wMID; // manufacturer ID
	WORD wPID; // product ID
	DWORD dwAGCID; // AGC ID
};


static const AGCDetails AGCList[] =
{
//  MID    PID   AGCID
    {1,     323,   27},  // Creative Labs (NT)
    {1,     104,   21},  // Creative Labs (NT 5)
    {2,     409,   27},  // Creative Labs
    {21,     42,   13},  // Turtle Beach Tropez
    {132,     3, 2072},  // Crystal MMX
    {384,     7,   28},  // Xitel Storm 3d PCI
    {385,    32,   35}   // Aztech PCI-331
};


static BOOL GetAGCID(WORD wMID, WORD wPID, DWORD *pdwAGCID)
{
	int nIndex;
	int nAGCEntries = sizeof(AGCList) / sizeof(AGCDetails);

	for (nIndex = 0; nIndex < nAGCEntries; nIndex++)
	{
		if ( (AGCList[nIndex].wMID == wMID) &&
		     (AGCList[nIndex].wPID == wPID))
		{
			*pdwAGCID = AGCList[nIndex].dwAGCID;
			return TRUE;
		}
	}
	return FALSE;
}



//
//	Init
//
//	Enumerate all existing mixers in the system. For each mixer,
//	we enumerate all lines with destination Speaker and WaveIn.
//	For each such line, we cache the control id and control value
//	of volume control. An invalid flag will be tagged to any control
//  not supported by this mixer.
//	When an application is finished with all mixers operations,
//	it must call ReleaseAllMixers to free all memory resources and
//	mixers.
//
//	THIS MUST BE THE FIRST API TO CALL TO START MIXER OPERATIONS.
//
//	Input: The handle of the window which will handle all callback
//	messages MM_MIXM_CONTROL_CHANGE and MM_MIXM_LINE_CHANGE.
//
//	Output: TRUE if success; otherwise, FALSE.
//
BOOL CMixerDevice::Init( HWND hWnd, UINT_PTR uWaveDevId, DWORD dwFlags)
{
	UINT uDstIdx, uSrcIdx, uMixerIdCheck, uMixerIdx;
	MMRESULT mmr = MMSYSERR_NOERROR;
	MIXERLINE mlDst, mlSrc;
	UINT_PTR nMixers, nWaveInDevs,  uIndex;

	//get the mixer device corresponding to the wave device
	mmr = mixerGetID((HMIXEROBJ)uWaveDevId, &uMixerIdx, dwFlags);
	if ((mmr != MMSYSERR_NOERROR) && (mmr != MMSYSERR_NODRIVER)) {
		return FALSE;
	}

	// a simple fix for cheesy sound cards that don't make a
	// direct mapping between waveDevice and mixer device
	// e.g. MWAVE cards and newer SB NT 4 drivers
	// If there is only ONE mixer device  and if no other waveIn device
	// uses it, then it is probably valid.

	if ((mmr == MMSYSERR_NODRIVER) && (dwFlags == MIXER_OBJECTF_WAVEIN))
	{
		nMixers = mixerGetNumDevs();
		nWaveInDevs = waveInGetNumDevs();
		if (nMixers == 1)
		{
			uMixerIdx = 0;
			for (uIndex = 0; uIndex < nWaveInDevs; uIndex++)
			{
				mmr = mixerGetID((HMIXEROBJ)uIndex, &uMixerIdCheck, dwFlags);
				if ((mmr == MMSYSERR_NOERROR) && (uMixerIdCheck == uMixerIdx))
				{
					return FALSE;  // the mixer belongs to another waveIn Device
				}
			}
		}
		else
		{
			return FALSE;
		}
	}


	// open the mixer such that we can get notification messages
	mmr = mixerOpen (
			&m_hMixer,
			uMixerIdx,
			(DWORD_PTR) hWnd,
			0,
			(hWnd ? CALLBACK_WINDOW : 0) | MIXER_OBJECTF_MIXER);
	if (mmr != MMSYSERR_NOERROR) {
		return FALSE;
	}

	// get mixer caps
	mmr = mixerGetDevCaps (uMixerIdx, &(m_mixerCaps), sizeof (MIXERCAPS));
	if ((mmr != MMSYSERR_NOERROR) || (0 == m_mixerCaps.cDestinations)) {
		mixerClose(m_hMixer);
		return FALSE;
	}

	for (uDstIdx = 0; uDstIdx < m_mixerCaps.cDestinations; uDstIdx++)
	{
		ZeroMemory (&mlDst, sizeof (mlDst));
		mlDst.cbStruct = sizeof (mlDst);
		mlDst.dwDestination = uDstIdx;

		// get the mixer line for this destination
		mmr = mixerGetLineInfo ((HMIXEROBJ)m_hMixer, &mlDst,
					MIXER_GETLINEINFOF_DESTINATION | MIXER_OBJECTF_HMIXER);
		if (mmr != MMSYSERR_NOERROR) continue;

		// examine the type of this destination line
		if (((MIXER_OBJECTF_WAVEOUT == dwFlags) &&
			 (MIXERLINE_COMPONENTTYPE_DST_SPEAKERS == mlDst.dwComponentType)) ||
			((MIXER_OBJECTF_WAVEIN == dwFlags) &&
			 (MIXERLINE_COMPONENTTYPE_DST_WAVEIN == mlDst.dwComponentType)))
		{
			 // fill in more info about DstLine
			m_DstLine.ucChannels = mlDst.cChannels;
			if (!(mlDst.fdwLine & MIXERLINE_LINEF_DISCONNECTED))
			{
				// get id and value of volume control
				mmr = mixerGetControlId (
						m_hMixer,
						&m_DstLine.dwControlId,
						mlDst.dwLineID,
						MIXERCONTROL_CONTROLTYPE_VOLUME);
				m_DstLine.fIdValid = (mmr == MMSYSERR_NOERROR);

				m_DstLine.dwLineId = mlDst.dwLineID;
				m_DstLine.dwCompType = mlDst.dwComponentType;
				m_DstLine.dwConnections = mlDst.cConnections;

				// -----------------------------------------------------
				// enumerate all sources for this destination
				for (uSrcIdx = 0; uSrcIdx < mlDst.cConnections; uSrcIdx++)
				{
					// get the info of the line with specific src and dst...
					ZeroMemory (&mlSrc, sizeof (mlSrc));
					mlSrc.cbStruct = sizeof (mlSrc);
					mlSrc.dwDestination = uDstIdx;
					mlSrc.dwSource = uSrcIdx;

					mmr = mixerGetLineInfo (
							(HMIXEROBJ)m_hMixer,
							&mlSrc,
							MIXER_GETLINEINFOF_SOURCE | MIXER_OBJECTF_HMIXER);
					if (mmr == MMSYSERR_NOERROR)
					{
						if (((MIXERLINE_COMPONENTTYPE_DST_SPEAKERS == mlDst.dwComponentType) &&
							 (MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT == mlSrc.dwComponentType)) ||
							((MIXERLINE_COMPONENTTYPE_DST_WAVEIN == mlDst.dwComponentType) &&
							 (MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE == mlSrc.dwComponentType)))
						{
							// fill in more info about this source
							m_SrcLine.ucChannels = mlSrc.cChannels;

							// get id and value of volume control
							mmr = mixerGetControlId (
									m_hMixer,
									&m_SrcLine.dwControlId,
									mlSrc.dwLineID,
									MIXERCONTROL_CONTROLTYPE_VOLUME);
							m_SrcLine.fIdValid = (mmr == MMSYSERR_NOERROR);

							m_SrcLine.dwLineId = mlSrc.dwLineID;
							m_SrcLine.dwCompType = mlSrc.dwComponentType;
							m_SrcLine.dwConnections = mlSrc.cConnections;

							break;
						}
					}
				}
			}
			break;
		}
	}
		
    return TRUE;
}

CMixerDevice* CMixerDevice::GetMixerForWaveDevice( HWND hWnd, UINT uWaveDevId, DWORD dwFlags)
{
    DBG_SAVE_FILE_LINE
	CMixerDevice* pMixerDev = new CMixerDevice;
	if (NULL != pMixerDev)
	{
		if (!pMixerDev->Init(hWnd, uWaveDevId, dwFlags))
		{
			delete pMixerDev;
			pMixerDev = NULL;
		}
	}
	return pMixerDev;
}

BOOL CMixerDevice::SetMainVolume(DWORD dwVolume)
{
	MMRESULT mmr = MMSYSERR_ERROR;
	DWORD adwVolume[2];

	adwVolume[0] = adwVolume[1] = (DWORD) LOWORD (dwVolume);

	if (m_DstLine.fIdValid) {
		mmr = mixerSetControlValue (
				m_hMixer,
				adwVolume,
				m_DstLine.dwControlId,
				2);
	}
	return (mmr == MMSYSERR_NOERROR);
}

BOOL CMixerDevice::SetSubVolume(DWORD dwVolume)
{
	MMRESULT mmr = MMSYSERR_ERROR;
	DWORD adwVolume[2];

	adwVolume[0] = adwVolume[1] = (DWORD) LOWORD (dwVolume);

	if (m_SrcLine.fIdValid)
	{
		mmr = mixerSetControlValue (
			m_hMixer,
			adwVolume,
			m_SrcLine.dwControlId,
			m_SrcLine.ucChannels);
	}
	return (mmr == MMSYSERR_NOERROR);
}

//
// Gets the volume (0 - 65535) of the master volume
// returns TRUE if succesful,
// returns FALSE if it fails or if this control is not available
//

BOOL CMixerDevice::GetMainVolume(LPDWORD pdwVolume)
{
	BOOL fRet = FALSE;

	if (m_DstLine.fIdValid)
	{
		DWORD adwVolume[2];
		MMRESULT mmr = ::mixerGetControlValue(
									m_hMixer,
									adwVolume,
									m_DstLine.dwControlId,
									2);
		fRet = (mmr == MMSYSERR_NOERROR);
		if (fRet)
		{
			// BUGBUG: is this the left channel only?
			*pdwVolume = LOWORD(adwVolume[0]);
		}
	}

	return fRet;
}

//
// Gets the volume (0 - 65535) of the sub volume
// returns TRUE if succesful,
// returns FALSE if it fails or if this control is not available
//

BOOL CMixerDevice::GetSubVolume(LPDWORD pdwVolume)
{
	BOOL fRet = FALSE;

	if (m_SrcLine.fIdValid)
	{
		DWORD adwVolume[2];
		MMRESULT mmr = ::mixerGetControlValue(
									m_hMixer,
									adwVolume,
									m_SrcLine.dwControlId,
									m_SrcLine.ucChannels);
		fRet = (mmr == MMSYSERR_NOERROR);
		if (fRet)
		{
			// BUGBUG: is this the left channel only?
			*pdwVolume = LOWORD(adwVolume[0]);
		}
	}

	return fRet;
}


// Return the value of the Auto Gain Control on SB16/AWE32 cards
// Returns FALSE if the control is not supported.
// pfOn is OUTPUT, OPTIONAL - value of AGC
BOOL CMixerDevice::GetAGC(BOOL *pfOn)
{
	MMRESULT mmr;
	DWORD dwAGCId;
	DWORD dwValue;

	if (FALSE == GetAGCID(m_mixerCaps.wMid, m_mixerCaps.wPid, &dwAGCId))
		return FALSE;

	mmr = mixerGetControlValue(m_hMixer, &dwValue, dwAGCId, 1);
	if (mmr != MMSYSERR_NOERROR)
		return FALSE;

	if (pfOn)
		*pfOn = dwValue;
	
	return TRUE;
}

/*
	Hack API to turn MIC Auto Gain Control on or off.
	Its a hack because it only works on SB16/AWE32 cards.
*/
BOOL CMixerDevice::SetAGC(BOOL fOn)
{
	DWORD dwAGCId;
	DWORD dwValue;
	MMRESULT mmr;

	if (FALSE == GetAGCID(m_mixerCaps.wMid, m_mixerCaps.wPid, &dwAGCId))
		return FALSE;

	mmr = mixerGetControlValue(m_hMixer, &dwValue, dwAGCId, 1);
	if (mmr != MMSYSERR_NOERROR)
		return FALSE;
	if (dwValue == (DWORD)fOn)
		return TRUE;
	dwValue = fOn;
	mmr = mixerSetControlValue(m_hMixer, &dwValue, dwAGCId, 1);
	return (mmr == MMSYSERR_NOERROR);
}

BOOL CMixerDevice::EnableMicrophone()
{
	MIXERLINE mixerLine;
	MIXERCONTROL mixerControl;
	MIXERCONTROLDETAILS mixerControlDetails, mixerControlDetailsOrig;
	UINT uIndex, numItems, numMics, numMicsSet, fMicFound;
	UINT uMicIndex = 0;
	UINT aMicIndices[MAX_MICROPHONE_DEVS];
	MIXERCONTROLDETAILS_LISTTEXT *aListText = NULL;
	MIXERCONTROLDETAILS_BOOLEAN *aEnableList = NULL;
	MMRESULT mmr;

	// check to see if component type is valid (which means the line exists!)
	// even if the volume control doesn't exist or isn't slidable,
	// there may still be a select switch
	if ((m_SrcLine.dwCompType != MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE) ||
	    (m_DstLine.dwCompType != MIXERLINE_COMPONENTTYPE_DST_WAVEIN))
	{
		return FALSE;
	}

	// try to find the mixer list
	if (    (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CT_CLASS_LIST, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MIXER, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MUX, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_SINGLESELECT, &mixerControl))
	   )
	{
		TRACE_OUT(("CMixerDevice::EnableMicrophone-Unable to find mixer list!"));
		return FALSE;
	}

	ZeroMemory(&mixerControlDetails, sizeof(MIXERCONTROLDETAILS));

	mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
	mixerControlDetails.dwControlID = mixerControl.dwControlID;
	if (MIXERCONTROL_CONTROLF_UNIFORM & mixerControl.fdwControl)
		mixerControlDetails.cChannels = 1;
	else
		mixerControlDetails.cChannels = m_DstLine.ucChannels;

	if (MIXERCONTROL_CONTROLF_MULTIPLE & mixerControl.fdwControl)
		mixerControlDetails.cMultipleItems = (UINT)mixerControl.cMultipleItems;
	else
		mixerControlDetails.cMultipleItems = 1;

	// weirdness - you have to set cbDetails to the size of a single LISTTEXT item
	// setting it to anything larger will make the call fail
	mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_LISTTEXT);


	numItems = mixerControlDetails.cMultipleItems;
	if (m_DstLine.dwConnections > numItems)
		numItems = m_DstLine.dwConnections;

    DBG_SAVE_FILE_LINE
	aListText = new MIXERCONTROLDETAILS_LISTTEXT[numItems];

    DBG_SAVE_FILE_LINE
	aEnableList = new MIXERCONTROLDETAILS_BOOLEAN[numItems];
	if ((aListText == NULL) || (aEnableList == NULL))
	{
		WARNING_OUT(("CMixerDevice::EnableMicrophone-Out of memory"));
		return FALSE;
	}

	ZeroMemory(aListText, sizeof(MIXERCONTROLDETAILS_LISTTEXT)*numItems);
	ZeroMemory(aEnableList, sizeof(MIXERCONTROLDETAILS_BOOLEAN)*numItems);

	mixerControlDetails.paDetails = aListText;

	// preserve the settings, some values will change after this call
	mixerControlDetailsOrig = mixerControlDetails;

	// query for the text of the list
	mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
	                             MIXER_GETCONTROLDETAILSF_LISTTEXT
	                             |MIXER_OBJECTF_HMIXER);

	// some sound cards don't specify CONTROLF_MULTIPLE
	// try doing what sndvol32 does for MUX controls
	if (mmr != MMSYSERR_NOERROR)
	{
		mixerControlDetails = mixerControlDetailsOrig;
		mixerControlDetails.cChannels = 1;
		mixerControlDetails.cMultipleItems = m_DstLine.dwConnections;
		mixerControlDetailsOrig = mixerControlDetails;
		mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
		                             MIXER_GETCONTROLDETAILSF_LISTTEXT
		                             |MIXER_OBJECTF_HMIXER);
	}

	if (mmr != MMSYSERR_NOERROR)
	{
		delete [] aListText;
		delete [] aEnableList;
		return FALSE;
	}

	// enumerate for the microphone
	numMics = 0;
	fMicFound = FALSE;
	for (uIndex = 0; uIndex < mixerControlDetails.cMultipleItems; uIndex++)
	{
		// dwParam1 of the listText structure is the LineID of the source
		// dwParam2 should be the component type, but unfoturnately not
		// all sound cards obey this rule.
		ZeroMemory (&mixerLine, sizeof(MIXERLINE));
		mixerLine.cbStruct = sizeof(MIXERLINE);
		mixerLine.dwLineID = aListText[uIndex].dwParam1;

		mmr = mixerGetLineInfo ((HMIXEROBJ)m_hMixer, &mixerLine,
					MIXER_GETLINEINFOF_LINEID | MIXER_OBJECTF_HMIXER);

		if ((mmr == MMSYSERR_NOERROR) &&
		    (mixerLine.dwComponentType == m_SrcLine.dwCompType) &&
			 (numMics < MAX_MICROPHONE_DEVS))
		{
			aMicIndices[numMics] = uIndex;
			numMics++;
		}

		if (aListText[uIndex].dwParam1 == m_SrcLine.dwLineId)
		{
			uMicIndex = uIndex;
			fMicFound = TRUE;  // can't rely on uIndex or uNumMics not zero
		}
	}

	if (fMicFound == FALSE)
	{
		delete [] aListText;
		delete [] aEnableList;
		return FALSE;
	}

	// now we know which position in the array to set, let's do it.

	mixerControlDetails = mixerControlDetailsOrig;
	mixerControlDetails.paDetails = aEnableList;
	mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

	// find out what's already marked as set.
	mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
	        MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);

	if ((mmr == MMSYSERR_NOERROR) && (aEnableList[uMicIndex].fValue != 1))
	{
		// how many microphone's are already enabled ?
		// if another microphone is already enabled and if the device is MUX type
		// we won't attempt to turn one on.
		numMicsSet = 0;
		for (uIndex = 0; uIndex < numMics; uIndex++)
		{
			if ((aEnableList[aMicIndices[uIndex]].fValue == 1) &&
			    (uIndex != uMicIndex))
			{
				numMicsSet++;
			}
		}


		if ( (mixerControl.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX)
		   ||(mixerControl.dwControlType == MIXERCONTROL_CONTROLTYPE_SINGLESELECT))
		{
			ZeroMemory(aEnableList, sizeof(aEnableList)*numItems);
			aEnableList[uMicIndex].fValue = 1;
			if (numMicsSet == 0)
			{
				mmr = mixerSetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
			                             MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
			}
			else
			{
				mmr = MMSYSERR_ERROR;  // a mike has already been enabled
			}
		}
		else
		{
			mixerControlDetails = mixerControlDetailsOrig;
			mixerControlDetails.paDetails = aEnableList;
			mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
			aEnableList[uMicIndex].fValue = 1;
			mmr = mixerSetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
		                             MIXER_GETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
		}
	}

	delete []aEnableList;
	delete []aListText;

	return (mmr == MMSYSERR_NOERROR);

}


BOOL CMixerDevice::UnMuteVolume()
{
	MIXERCONTROL mixerControl;
	MIXERCONTROLDETAILS mixerControlDetails;
	MIXERCONTROLDETAILS_BOOLEAN mcdb;
	MMRESULT mmrMaster, mmrSub;

	// try to unmute the master volume
	// this could be used on both the recording and playback mixers

	mmrMaster = mixerGetControlByType(m_hMixer,
	            m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MUTE,
	              &mixerControl);

	if (mmrMaster == MMSYSERR_NOERROR)
	{
		ZeroMemory(&mixerControlDetails, sizeof(MIXERCONTROLDETAILS));
		mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
		mixerControlDetails.dwControlID = mixerControl.dwControlID;

		mixerControlDetails.cChannels = 1;
		mixerControlDetails.cMultipleItems = 0;

		mcdb.fValue = 0;
		mixerControlDetails.paDetails = &mcdb;
		mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

		mmrMaster = mixerSetControlDetails((HMIXEROBJ)m_hMixer,
		            &mixerControlDetails,
		            MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
		
	}


	// only try to unmute waveOut
    if ( (m_DstLine.dwCompType != MIXERLINE_COMPONENTTYPE_DST_SPEAKERS)
	   || (m_SrcLine.dwCompType == 0))
	{
		return (mmrMaster == MMSYSERR_NOERROR);
	}

	
	mmrSub = mixerGetControlByType(m_hMixer,
	         m_SrcLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MUTE,
	         &mixerControl);

	if (mmrSub == MMSYSERR_NOERROR)
	{
		ZeroMemory(&mixerControlDetails, sizeof(MIXERCONTROLDETAILS));
		mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
		mixerControlDetails.dwControlID = mixerControl.dwControlID;

		mixerControlDetails.cChannels = 1;
		mixerControlDetails.cMultipleItems = 0;

		mcdb.fValue = 0;
		mixerControlDetails.paDetails = &mcdb;
		mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

		mmrSub =  mixerSetControlDetails((HMIXEROBJ)m_hMixer,
		          &mixerControlDetails,
		          MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
	}


	return ((mmrSub == MMSYSERR_NOERROR) || (mmrMaster == MMSYSERR_NOERROR));

}



//////////////////////////////////////////////////
//
// The following are private APIs
//

static MMRESULT mixerGetControlValue ( HMIXER hMixer, DWORD *pdwValue,
								DWORD dwControlId, UINT ucChannels )
{
	MIXERCONTROLDETAILS mxcd;
	MMRESULT mmr;

	ZeroMemory (&mxcd, sizeof (mxcd));
	mxcd.cbStruct = sizeof (mxcd);
	mxcd.dwControlID = dwControlId;
	mxcd.cChannels = ucChannels;
	mxcd.cbDetails = sizeof (DWORD);
	mxcd.paDetails = (PVOID) pdwValue;
	mmr = mixerGetControlDetails ((HMIXEROBJ) hMixer, &mxcd,
			MIXER_GETCONTROLDETAILSF_VALUE | MIXER_OBJECTF_HMIXER);
	return mmr;
}


static MMRESULT mixerSetControlValue ( HMIXER hMixer, DWORD *pdwValue,
								DWORD dwControlId, UINT ucChannels )
{
	MIXERCONTROLDETAILS mxcd;
	MMRESULT mmr;

	ZeroMemory (&mxcd, sizeof (mxcd));
	mxcd.cbStruct = sizeof (mxcd);
	mxcd.dwControlID = dwControlId;
	mxcd.cChannels = ucChannels;
	mxcd.cbDetails = sizeof (DWORD);
	mxcd.paDetails = (PVOID) pdwValue;
	mmr = mixerSetControlDetails ((HMIXEROBJ) hMixer, &mxcd,
			MIXER_SETCONTROLDETAILSF_VALUE | MIXER_OBJECTF_HMIXER);
	return mmr;
}


static MMRESULT mixerGetControlId ( HMIXER hMixer, DWORD *pdwControlId,
							 DWORD dwLineId, DWORD dwControlType )
{
	MIXERLINECONTROLS mxlc;
	MIXERCONTROL mxc;
	MMRESULT mmr;

	ZeroMemory (&mxlc, sizeof (mxlc));
	ZeroMemory (&mxc, sizeof (mxc));
	mxlc.cbStruct = sizeof (mxlc);
	mxlc.dwLineID = dwLineId;
	mxlc.dwControlType = dwControlType;
	mxlc.cControls = 1;
	mxlc.cbmxctrl = sizeof (mxc);
	mxlc.pamxctrl = &mxc;
	mmr = mixerGetLineControls ((HMIXEROBJ) hMixer, &mxlc,
				MIXER_GETLINECONTROLSF_ONEBYTYPE | MIXER_OBJECTF_HMIXER);
	*pdwControlId = mxc.dwControlID;
	return mmr;
}


// similar to above, except returns the whole control
static MMRESULT mixerGetControlByType ( HMIXER hMixer, DWORD dwLineId, DWORD dwControlType, MIXERCONTROL *pMixerControl)
{
	MIXERLINECONTROLS mxlc;
	MMRESULT mmr;

	ZeroMemory (&mxlc, sizeof (mxlc));
	ZeroMemory (pMixerControl, sizeof (MIXERCONTROL));
	mxlc.cbStruct = sizeof (mxlc);
	mxlc.dwLineID = dwLineId;
	mxlc.dwControlType = dwControlType;
	mxlc.cControls = 1;
	mxlc.cbmxctrl = sizeof (MIXERCONTROL);
	mxlc.pamxctrl = pMixerControl;
	mmr = mixerGetLineControls ((HMIXEROBJ) hMixer, &mxlc,
				MIXER_GETLINECONTROLSF_ONEBYTYPE | MIXER_OBJECTF_HMIXER);
	
	return mmr;
}

// IUnknown stuff
ULONG __stdcall CMixerDevice::AddRef()
{
	InterlockedIncrement(&m_lRefCount);
	return m_lRefCount;
}

ULONG __stdcall CMixerDevice::Release()
{
	if (0 == InterlockedDecrement(&m_lRefCount))
	{
		delete this;
		return 0;
	}
	return m_lRefCount;
}

HRESULT __stdcall CMixerDevice::QueryInterface(const IID& iid, void **ppVoid)
{

	if ((iid == IID_IUnknown) || (iid == IID_IMixer))
	{
		*ppVoid = this;
	}
	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
	
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\mixer.h ===
// File: mixer.h

#ifndef _MIXER_H_
#define _MIXER_H_

typedef struct tagMixLine
{
	UINT	ucChannels;
	BOOL	fIdValid;
	DWORD	dwControlId;

	DWORD dwLineId;   // line ID of destination
	DWORD dwCompType; // Component type
	DWORD dwConnections; // number of sources associated with this line
} MIXLINE;

class CMixerDevice : public IMixer
{
private:
	HMIXER	 	m_hMixer;
	MIXERCAPS	m_mixerCaps;
	MIXLINE		m_DstLine;
	MIXLINE		m_SrcLine;

	BOOL		Init( HWND hWnd, UINT_PTR uWaveDevId, DWORD dwFlags);

	LONG m_lRefCount;

protected:
	CMixerDevice() : m_lRefCount(0)
	{
		m_hMixer = NULL;
		ZeroMemory (&m_DstLine, sizeof(m_DstLine));
		ZeroMemory (&m_SrcLine, sizeof(m_SrcLine));
	}

public:
	~CMixerDevice()
	{
		if (NULL != m_hMixer)
		{
			mixerClose(m_hMixer);
		}
	}

	BOOL __stdcall SetVolume (DWORD dwVolume)
	{
		BOOL fSetMain = SetMainVolume(dwVolume);
		BOOL fSetSub = SetSubVolume(dwVolume);
		return fSetMain || fSetSub;
	}
	BOOL __stdcall CanSetVolume () { return m_DstLine.fIdValid || m_SrcLine.fIdValid; }
	BOOL __stdcall SetMainVolume(DWORD dwVolume);
	BOOL __stdcall SetSubVolume(DWORD dwVolume);
	BOOL __stdcall SetAGC(BOOL fOn);
	BOOL __stdcall GetMainVolume(LPDWORD pdwVolume);
	BOOL __stdcall GetSubVolume(LPDWORD pdwVolume);
	BOOL __stdcall GetAGC(BOOL *pfOn);
	BOOL __stdcall EnableMicrophone();
	BOOL __stdcall UnMuteVolume();
	static CMixerDevice* GetMixerForWaveDevice( HWND hWnd, UINT uWaveDevId, DWORD dwFlags);

	// IUnknown
	HRESULT __stdcall QueryInterface(const IID&, void**);
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\msh26x.h ===
typedef enum tagFrameSize
{
	FORBIDDEN=0,
	SQCIF=1,
	QCIF=2,
	CIF=3,
	fCIF=4,
	ssCIF=5

}FrameSize;

// MSH26X Configuration Information
typedef struct tagMSH26XCONF{
	BOOL	bInitialized;               // Whether custom msgs can be rcv'd.
	BOOL	bCompressBegin;				// Whether the CompressBegin msg was rcv'd.
	BOOL	bRTPHeader;                 // Whether to generate RTP header info
	/* used if bRTPHeader */
	UINT	unPacketSize;               // Maximum packet size
	BOOL	bEncoderResiliency;         // Whether to use resiliency restrictions
	/* used if bEncoderResiliency */
	UINT	unPacketLoss;
	BOOL	bBitRateState;
	/* used if bBitRateState */
	UINT	unBytesPerSecond;
	/* The following information is determined from the packet loss value.   */
	/*  These values are calculated each time we receive a resiliency msg or */
	/*  the value is changed through the dialog box.  They are not stored in */
	/*  the registry.  Only the above elements are stored in the registry.   */
	BOOL	bDisallowPosVerMVs;   		// if true, disallow positive vertical MVs
	BOOL	bDisallowAllVerMVs;   		// if true, disallow all vertical MVs
	UINT	unPercentForcedUpdate;      // Percent Forced Update per Frame
	UINT	unDefaultIntraQuant;        // Default Intra Quant
	UINT	unDefaultInterQuant;        // Default Inter Quant
} MSH26XCONF;

// MSH26X Compressor Instance information
typedef struct tagMSH26XCOMPINSTINFO{
	BOOL		Initialized;
	WORD		xres, yres;
	FrameSize	FrameSz;		// Which of the supported frame sizes.
	float		FrameRate;
	DWORD		DataRate;		// Data rate in bytes per second.
	HGLOBAL		hEncoderInst;   // Instance data private to encoder.
	LPVOID		EncoderInst;
	WORD		CompressedSize;
	BOOL		Is160x120;
	BOOL		Is240x180;
	BOOL		Is320x240;
	MSH26XCONF	Configuration;
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
	UINT		InputCompression;
	UINT		InputBitWidth;
#endif
} MSH26XCOMPINSTINFO, *PMSH26XCOMPINSTINFO;

// MSH26X BitStream Info Trailer structure
typedef struct tagH26X_RTP_BSINFO_TRAILER {
	DWORD dwVersion;
	DWORD dwFlags;
	DWORD dwUniqueCode;
	DWORD dwCompressedSize;
	DWORD dwNumOfPackets;
	BYTE  bySrc;
	BYTE  byTR;
	BYTE  byTRB;
	BYTE  byDBQ;
} H26X_RTP_BSINFO_TRAILER, *PH26X_RTP_BSINFO_TRAILER;

// MSH263 BitStream Info structure
typedef struct tagRTP_H263_BSINFO {
	DWORD dwFlags;
	DWORD dwBitOffset;
	BYTE  byMode;
	BYTE  byMBA;
	BYTE  byQuant;
	BYTE  byGOBN;
	char  cHMV1;
	char  cVMV1;
	char  cHMV2;
	char  cVMV2;
} RTP_H263_BSINFO, *PRTP_H263_BSINFO;

// MSH261 BitStream Info structure
typedef struct tagRTP_H261_BSINFO {
	DWORD dwFlags;
	DWORD dwBitOffset;
	BYTE  byMBA;
	BYTE  byQuant;
	BYTE  byGOBN;
	char  cHMV;
	char  cVMV;
	BYTE  byPadding0;
	WORD  wPadding1;
} RTP_H261_BSINFO, *PRTP_H261_BSINFO;

// Constants
#define H263_RTP_BS_START_CODE		MakeFOURCC('H','2','6','3')
#define H261_RTP_BS_START_CODE		MakeFOURCC('H','2','6','1')
#define RTP_H26X_INTRA_CODED		0x00000001
#define RTP_H263_PB					0x00000002
#define RTP_H263_AP					0x00000004
#define RTP_H263_SAC				0x00000008
#define RTP_H263_MODE_A				0x00
#define RTP_H263_MODE_B				0x01
#define RTP_H263_MODE_C				0x02
#define H26X_RTP_PAYLOAD_VERSION    0x00000000
#define RTP_H26X_PACKET_LOST		0x00000001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\msiacaps.cpp ===
/*
 *  	File: msiacaps.cpp
 *
 *		ACM implementation of Microsoft Network Audio capability object.
 *
 *		Revision History:
 *
 *		06/06/96	mikev	created
 */


#include "precomp.h"

//Prototypes....
ULONG ReadRegistryFormats (LPCSTR lpszKeyName,CHAR ***pppName,BYTE ***pppData,PUINT pnFormats,DWORD dwDebugSize);
void FreeRegistryFormats (PRRF_INFO pRegFmts);

static BOOL bUseDefault;


#define szRegMSIPAndH323Encodings	TEXT("ACMH323Encodings")


AUDCAP_DETAILS default_id_table[] =
{


{WAVE_FORMAT_ADPCM, NONSTD_TERMCAP, STD_CHAN_PARAMS, {RTP_DYNAMIC_MIN, 0, 8000, 4},
	0, TRUE, TRUE, 500, 32000,32000,50,0,PREF_ORDER_UNASSIGNED,0,NULL,0, NULL,
	"Microsoft ADPCM"},


	{WAVE_FORMAT_LH_CELP, NONSTD_TERMCAP, STD_CHAN_PARAMS,{RTP_DYNAMIC_MIN,  0, 8000, 16},
		0, TRUE, TRUE, 640, 5600,5600,LNH_48_CPU,0,3,0,NULL,0,NULL,
		"Lernout & Hauspie CELP 4.8kbit/s"},
	{WAVE_FORMAT_LH_SB8,  NONSTD_TERMCAP, STD_CHAN_PARAMS,{RTP_DYNAMIC_MIN,  0, 8000, 16},
		0, TRUE, TRUE, 640, 8000,8000,LNH_8_CPU,0,0,0,NULL,0,NULL,
		"Lernout & Hauspie SBC 8kbit/s"},
	{WAVE_FORMAT_LH_SB12, NONSTD_TERMCAP, STD_CHAN_PARAMS, {RTP_DYNAMIC_MIN,  0, 8000, 16},
		0, TRUE, TRUE, 640, 12000,12000,LNH_12_CPU,0,1,0,NULL,0,NULL,
		"Lernout & Hauspie SBC 12kbit/s"},
	{WAVE_FORMAT_LH_SB16, NONSTD_TERMCAP, STD_CHAN_PARAMS,{RTP_DYNAMIC_MIN,  0, 8000, 16},
		0, TRUE, TRUE, 640, 16000,16000,LNH_16_CPU,0,2,0,NULL,0,NULL,
		"Lernout & Hauspie SBC 16kbit/s"},
	{WAVE_FORMAT_MSRT24, NONSTD_TERMCAP, STD_CHAN_PARAMS,{RTP_DYNAMIC_MIN,  0, 8000, 16},
		0, TRUE, TRUE, 720, 2400,2400,MSRT24_CPU,0,4,0,NULL,0,NULL,
		"Voxware RT 2.4kbit/s"},
	{WAVE_FORMAT_MSG723,  STD_TERMCAP(H245_CLIENT_AUD_G723), 	// client type H245_CLIENT_AUD_G723,
		STD_CHAN_PARAMS, {RTP_PAYLOAD_G723,  0, 8000, 0},
		0, TRUE, TRUE, 960, 5600,5600,MS_G723_CPU,0,
		0,	// priority
		0,NULL,0,NULL, "Microsoft G.723.1"},
	{WAVE_FORMAT_ALAW,	STD_TERMCAP( H245_CLIENT_AUD_G711_ALAW64),
		STD_CHAN_PARAMS, {RTP_PAYLOAD_G711_ALAW,  0, 8000, 8},
		0, TRUE, TRUE, 500, 64000,64000,CCITT_A_CPU,0,0,
		0, NULL, 0, NULL, "CCITT A-Law"},
	{WAVE_FORMAT_MULAW,	STD_TERMCAP( H245_CLIENT_AUD_G711_ULAW64),
		STD_CHAN_PARAMS, {RTP_PAYLOAD_G711_MULAW,  0, 8000, 8},
		0, TRUE, TRUE, 500, 64000,64000,CCITT_U_CPU,0,0,
		0, NULL, 0, NULL, "CCITT u-Law"},
		
#if(0)
// do not use this version of the G.723 codec
	{WAVE_FORMAT_INTELG723,  STD_TERMCAP(H245_CLIENT_AUD_G723), 	// client type H245_CLIENT_AUD_G723,
		STD_CHAN_PARAMS, {RTP_DYNAMIC_MIN,  0, 8000, 0},
		0, TRUE, TRUE, 960, 16000,16000,99,0,
		0,	// priority
		0,NULL,0,NULL, "G.723"},
		
	{WAVE_FORMAT_DSPGROUP_TRUESPEECH, {
		NONSTD_TERMCAP, {RTP_DYNAMIC_MIN,  0, 5510, 4},
		0, TRUE, TRUE, 500, 5510,5510,50,0,0,0,NULL},
		"DSP Group TrueSpeech(TM)"},
    {WAVE_FORMAT_PCM, {{RTP_DYNAMIC_MIN,  0, 8000, 8}, TRUE, TRUE, 160, 64000,64000,50,0,0,0,NULL,0,NULL}, "MS-ADPCM"},
	{WAVE_FORMAT_PCM, {{RTP_DYNAMIC_MIN,  0, 5510, 8}, TRUE, TRUE, 160, 44080,44080,50,0,0,0,NULL,0,NULL}, "MS-ADPCM"},
	{WAVE_FORMAT_PCM, {{RTP_DYNAMIC_MIN,  0, 11025, 8}, TRUE, TRUE, 160, 88200,88200,50,0,0,0,NULL,0,NULL},"MS-ADPCM"},
	{WAVE_FORMAT_PCM, {{RTP_DYNAMIC_MIN,  0, 8000, 16}, TRUE, TRUE, 160, 128000,128000,50,0,0,0,NULL,0,NULL},"MS-ADPCM"},
	{WAVE_FORMAT_ADPCM, {{RTP_DYNAMIC_MIN,  0, 8000, 4}, TRUE, TRUE, 500, 16000,16000,50,0,,0,0,NULL,0,NULL}, "MS-ADPCM"},
	{WAVE_FORMAT_GSM610, 	 STD_CHAN_PARAMS,{RTP_DYNAMIC_MIN,  0, 8000, 0},
		0, TRUE, TRUE, 320, 8000,8000,96,0,PREF_ORDER_UNASSIGNED,0,NULL,0,NULL,
		//"Microsoft GSM 6.10"
		"GSM 6.10"},
#endif	// DEF_USE_ALLPCM	


};


UINT uDefTableEntries = sizeof(default_id_table) /sizeof(AUDCAP_DETAILS);
static BOOL bCreateDefTable = FALSE;


//
//	static members of CMsiaCapability
//

MEDIA_FORMAT_ID CMsiaCapability::IDsByRank[MAX_CAPS_PRESORT];
UINT CMsiaCapability::uNumLocalFormats = 0;			// # of active entries in pLocalFormats
UINT CMsiaCapability::uStaticRef = 0;					// global ref count
UINT CMsiaCapability::uCapIDBase = 0;					// rebase capability ID to index into IDsByRank
UINT CMsiaCapability::uLocalFormatCapacity = 0;		// size of pLocalFormats (in multiples of AUDCAP_DETAILS)
AUDCAP_DETAILS * CMsiaCapability::pLocalFormats = NULL;	

CMsiaCapability::CMsiaCapability()
:uRef(1),
wMaxCPU(95),
m_uPacketDuration(90),
uNumRemoteDecodeFormats(0),
uRemoteDecodeFormatCapacity(0),
pRemoteDecodeFormats(NULL),
bPublicizeTXCaps(FALSE),
bPublicizeTSTradeoff(FALSE),
pRegFmts(NULL)

{
	m_IAppCap.Init(this);
}

CMsiaCapability::~CMsiaCapability()
{
	CloseACMDriver();
	UINT u;
	AUDCAP_DETAILS *pDetails;
	// release global static memory (the local capabilities) if this is the last delete
	if(uStaticRef <= 1)
	{
		if (pLocalFormats)
		{	
			pDetails = pLocalFormats;
			for(u=0; u <uNumLocalFormats; u++)
			{
				if(pDetails->lpLocalFormatDetails)
				{
					MEMFREE(pDetails->lpLocalFormatDetails);
				}
				// there really should never be remote details associated with the local
				// formats........
				if(pDetails->lpRemoteFormatDetails)
				{
					MEMFREE(pDetails->lpRemoteFormatDetails);
				}
				
				pDetails++;
			}
			MEMFREE(pLocalFormats);
			pLocalFormats=NULL;
			uLocalFormatCapacity = 0;
		}
		uStaticRef--;

        //Clean up the format cache. - This was the audio format information that
        //Was in the registry. A list of names, ptrs to AUDCAP_DETAILS blocks
        //and a count of formats. Memory is allocated in ReadRegistryFormats,
        //called from ReInit()

	}
	else
	{
		uStaticRef--;
	}
	
	if (pRemoteDecodeFormats)
	{	
		pDetails = pRemoteDecodeFormats;
		for(u=0; u <uNumRemoteDecodeFormats; u++)
		{
			if(pDetails->lpLocalFormatDetails)
			{
				MEMFREE(pDetails->lpLocalFormatDetails);
			}
			// there really should never be remote details associated with the local
			// formats........
			if(pDetails->lpRemoteFormatDetails)
			{
				MEMFREE(pDetails->lpRemoteFormatDetails);
			}
			
			pDetails++;
		}
		MEMFREE(pRemoteDecodeFormats);
		pRemoteDecodeFormats=NULL;
		uRemoteDecodeFormatCapacity  = 0;
	}

	FreeRegistryFormats(pRegFmts);
}

BOOL CMsiaCapability::Init()
{
	BOOL bRet;
	if(uStaticRef == 0)
	{
		if(bRet = ReInit())
		{
			uStaticRef++;
		}
	}
	else
	{
		uStaticRef++;
		bRet = TRUE;
	}
	return bRet;
}


BOOL CMsiaCapability::ReInit()
{
	SYSTEM_INFO si;
	DWORD dwDisposition;
	BOOL bRet = TRUE;
	ACM_APP_PARAM sAppParam={this, NULL, ACMAPP_FORMATENUMHANDLER_ENUM, NULL, NULL, 0, NULL};
	ACMFORMATTAGDETAILS aftd;
	AUDCAP_DETAILS audcapDetails;
	UINT i;

	ZeroMemory(&IDsByRank, sizeof(IDsByRank));

	// LOOKLOOK - this supports a hack to disable CPU intensive codecs if not running on a pentium
	GetSystemInfo(&si);
#ifdef _M_IX86
	wMaxCPU = (si.dwProcessorType == PROCESSOR_INTEL_PENTIUM )? 100 : 50;
#endif
#ifdef _ALPHA_
	wMaxCPU = 100;
#endif
	if (pLocalFormats)
	{	
		UINT u;
		AUDCAP_DETAILS *pDetails = pLocalFormats;
		for(u=0; u <uNumLocalFormats; u++)
		{
			if(pDetails->lpLocalFormatDetails)
			{
				MEMFREE(pDetails->lpLocalFormatDetails);
			}
			// there really should never be remote details associated with the local
			// formats........
			if(pDetails->lpRemoteFormatDetails)
			{
				MEMFREE(pDetails->lpRemoteFormatDetails);
			}
			
			pDetails++;
		}
		MEMFREE(pLocalFormats);
		pLocalFormats = NULL;
		uLocalFormatCapacity = 0;
	}

	uNumLocalFormats = 0;
	uCapIDBase=0;				

    /*
	 *	Format cache
	 */


    if (!pRegFmts) {	
        if (!(pRegFmts=(PRRF_INFO)MemAlloc (sizeof (RRF_INFO)))) {
            bRet = FALSE;
            goto RELEASE_AND_EXIT;
        }

   		bUseDefault=FALSE;

        if (ReadRegistryFormats (szRegInternetPhone TEXT("\\") szRegMSIPAndH323Encodings,
				&pRegFmts->pNames,(BYTE ***)&pRegFmts->pData,&pRegFmts->nFormats,sizeof (AUDCAP_DETAILS)) != ERROR_SUCCESS) {
    		bUseDefault=TRUE;
    		MemFree ((void *) pRegFmts);
    		pRegFmts=NULL;
        }
    }

	// pass the registry formats through ACM to the handler
    sAppParam.pRegCache=pRegFmts;

	if(!DriverEnum((DWORD_PTR) &sAppParam))
	{
		bRet = FALSE;
		goto RELEASE_AND_EXIT;
	}
				
 	SortEncodeCaps(SortByAppPref);
RELEASE_AND_EXIT:
	return bRet;
}


STDMETHODIMP CMsiaCapability::QueryInterface( REFIID iid,	void ** ppvObject)
{
	// this breaks the rules for the official COM QueryInterface because
	// the interfaces that are queried for are not necessarily real COM
	// interfaces.  The reflexive property of QueryInterface would be broken in
	// that case.

	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if(iid == IID_IAppAudioCap )
	{
		*ppvObject = (LPAPPCAPPIF)&m_IAppCap;
		AddRef();
		hr = hrSuccess;
	}
	else if(iid == IID_IH323MediaCap)
	{
		*ppvObject = (IH323MediaCap *)this;
		AddRef();
		hr = hrSuccess;
	}
	else if (iid == IID_IUnknown)
	{
		*ppvObject = this;
		AddRef();
		hr = hrSuccess;
	}
	
	return hr;
}


ULONG CMsiaCapability::AddRef()
{
	uRef++;
	return uRef;
}

ULONG CMsiaCapability::Release()
{
	uRef--;
	if(uRef == 0)
	{
		delete this;
		return 0;
	}
	return uRef;
}
VOID CMsiaCapability::FreeRegistryKeyName(LPTSTR lpszKeyName)
{
	if (lpszKeyName)
    {
		LocalFree(lpszKeyName);
    }
}

LPTSTR CMsiaCapability::AllocRegistryKeyName(LPTSTR lpDriverName,
		UINT uSampleRate, UINT uBitsPerSample, UINT uBytesPerSec)
{
	FX_ENTRY(("MsiaCapability::AllocRegistryKeyName"));
	BOOL bRet = FALSE;
	LPTSTR lpszKeyName = NULL;

	if(!lpDriverName)
	{
		return NULL;
	}	
	// build a subkey name (drivername_samplerate_bitspersample)
	// allow room for THREE underscore chars + 2x17 bytes of string returned
	// from _itoa

	// NOTE: use wsprintf instead of itoa - because of dependency on runtime lib
	lpszKeyName = (LPTSTR)LocalAlloc (LPTR, lstrlen(lpDriverName) * sizeof(*lpDriverName)+3*20);
	if (!lpszKeyName)
	{
		ERRORMESSAGE(("%s: LocalAlloc failed\r\n",_fx_));
        return(NULL);
    }
    // build a subkey name ("drivername_samplerate_bitspersample")
	wsprintf(lpszKeyName,
				"%s_%u_%u_%u",
				lpDriverName,
				uSampleRate,
				uBitsPerSample,
				uBytesPerSec);

	return (lpszKeyName);
}


VOID CMsiaCapability::SortEncodeCaps(SortMode sortmode)
{
	UINT iSorted=0;
	UINT iInsert = 0;
	UINT iCache=0;
	UINT iTemp =0;
	BOOL bInsert;	
	AUDCAP_DETAILS *pDetails1, *pDetails2;
	
	if(!uNumLocalFormats)
		return;
	if(uNumLocalFormats ==1)
	{
		IDsByRank[0]=0;
		return;
	}
	
	// look at every cached format, build index array
	for(iCache=0;iCache<uNumLocalFormats;iCache++)
	{
		pDetails1 = pLocalFormats+iCache;
		for(iInsert=0;iInsert < iSorted; iInsert++)
		{
			pDetails2 = pLocalFormats+IDsByRank[iInsert];
			// if existing stuff is less than new stuff....
			
			bInsert = FALSE;
			switch(sortmode)
			{
				case SortByAppPref:
					if(pDetails2->wApplicationPrefOrder > pDetails1->wApplicationPrefOrder)
						bInsert = TRUE;
				break;
				default:
				break;
			}
			
			if(bInsert)
			{
				if(iSorted < MAX_CAPS_PRESORT)
				{
					iSorted++;
				}
				// make room, if there is something in the last element,
				// it gets overwritten
				for(iTemp = iSorted-1; iTemp > iInsert; iTemp--)
				{
					IDsByRank[iTemp] = IDsByRank[iTemp-1];
				}
				// insert at iInsert
				IDsByRank[iInsert] = iCache;
				break;
			}
		}
		// check end boundary
		if((iInsert == iSorted) && (iInsert < MAX_CAPS_PRESORT))
		{
			IDsByRank[iInsert] = iCache;
			iSorted++;
		}
	}
}



STDMETHODIMP CMsiaCapability::GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize)
{
	// validate input
	UINT uIndex = 	IDToIndex(FormatID);
	if(uIndex >= (UINT)uNumLocalFormats)
	{
		*puSize = 0;
		*ppFormat = NULL;
		return E_INVALIDARG;
	}

	*ppFormat = (pLocalFormats + uIndex)->lpLocalFormatDetails;
	*puSize = SIZEOF_WAVEFORMATEX((WAVEFORMATEX*)(*ppFormat));
	return S_OK;

}

STDMETHODIMP CMsiaCapability::GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize)
{
	// same as GetDecodeFormatDetails
	return GetDecodeFormatDetails(FormatID, ppFormat, puSize);
}

VOID CMsiaCapability::CalculateFormatProperties(AUDCAP_DETAILS *pFmtBuf,LPWAVEFORMATEX lpwfx)
{
	WORD wFrames;
	if(!pFmtBuf)
	{
		return;
	}
	
	// use actual bits per sample unless the bps field is zero, in which case
	// assume 16 bits (worst case).  This is a typical GSM scenario
	UINT uBitrateIn = (pFmtBuf->audio_params.uSamplesPerSec) *
		((pFmtBuf->audio_params.uBitsPerSample)
		? pFmtBuf->audio_params.uBitsPerSample
		:16);

	// set the maximum bitrate (uMaxBitrate). we're not setting the average bitrate (uAvgBitrate),
	// since the nAvgBytesPerSec reported by ACM is really worst case. uAvgBitrate will be set
	// from the hardcoded numbers for our known codecs and from the provided AUDCAP_INFO for
	// installable codecs
	pFmtBuf->uMaxBitrate = (lpwfx->nAvgBytesPerSec)? lpwfx->nAvgBytesPerSec*8:uBitrateIn;

	pFmtBuf->dwDefaultSamples = MinSampleSize(lpwfx);
	
	// nonstandard channel parameters.  This
	// might be a good point to calculate values that don't have valid defaults set.
	wFrames = pFmtBuf->nonstd_params.wFramesPerPktMax;
	if(!pFmtBuf->nonstd_params.wFramesPerPktMax)	
	{
		pFmtBuf->nonstd_params.wFramesPerPktMax=
			wFrames = LOWORD(MaxFramesPerPacket(lpwfx));
	}
	// if the preferred frames/packet is 0 or greater than the max, set it to min
	if((pFmtBuf->nonstd_params.wFramesPerPkt ==0) ||
		(pFmtBuf->nonstd_params.wFramesPerPkt > wFrames))
	{
		pFmtBuf->nonstd_params.wFramesPerPkt =
			LOWORD(MinFramesPerPacket(lpwfx));
	}
	// if the min is more than preferred, fix it
	if(pFmtBuf->nonstd_params.wFramesPerPktMin > pFmtBuf->nonstd_params.wFramesPerPkt)
	{
		pFmtBuf->nonstd_params.wFramesPerPktMin =
			LOWORD(MinFramesPerPacket(lpwfx));
	}

	pFmtBuf->nonstd_params.wDataRate =0;  // default
	pFmtBuf->nonstd_params.wFrameSize = (pFmtBuf->nonstd_params.wFramesPerPkt)
			? LOWORD(pFmtBuf->dwDefaultSamples / pFmtBuf->nonstd_params.wFramesPerPkt): 0;
	pFmtBuf->nonstd_params.UsePostFilter = 0;
	pFmtBuf->nonstd_params.UseSilenceDet = 0;

}


AUDIO_FORMAT_ID CMsiaCapability::AddFormat(AUDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize)
{
	FX_ENTRY(("CMsiaCapability::AddFormat"));
	AUDCAP_DETAILS *pTemp;
	WORD wFrames;
	UINT uSamples;
	if(!pFmtBuf || !lpvMappingData || !uSize)
	{
		return INVALID_AUDIO_FORMAT;
	}
	// check room
	if(uLocalFormatCapacity <= uNumLocalFormats)
	{
		// get more mem, realloc memory by CAP_CHUNK_SIZE for pLocalFormats
		pTemp = (AUDCAP_DETAILS *)MEMALLOC((uNumLocalFormats + CAP_CHUNK_SIZE)*sizeof(AUDCAP_DETAILS));
		if(!pTemp)
			goto ERROR_EXIT;
		// remember how much capacity we now have
		uLocalFormatCapacity = uNumLocalFormats + CAP_CHUNK_SIZE;
		#ifdef DEBUG
		if((uNumLocalFormats && !pLocalFormats) || (!uNumLocalFormats && pLocalFormats))
		{
			ERRORMESSAGE(("%s:leak! uNumLocalFormats:0x%08lX, pLocalFormats:0x%08lX\r\n",
				_fx_, uNumLocalFormats,pLocalFormats));
		}
		#endif
		// copy old stuff, discard old mem
		if(uNumLocalFormats && pLocalFormats)
		{
			memcpy(pTemp, pLocalFormats, uNumLocalFormats*sizeof(AUDCAP_DETAILS));
			MEMFREE(pLocalFormats);
		}
		pLocalFormats = pTemp;
	}
	// pTemp is where the stuff is cached
	pTemp = pLocalFormats+uNumLocalFormats;
	memcpy(pTemp, pFmtBuf, sizeof(AUDCAP_DETAILS));	
	
	pTemp->uLocalDetailsSize = 0;	// clear this now
	//if(uSize && lpvMappingData)
	//{
		pTemp->lpLocalFormatDetails = MEMALLOC(uSize);
		if(pTemp->lpLocalFormatDetails)
		{
			memcpy(pTemp->lpLocalFormatDetails, lpvMappingData, uSize);
			pTemp->uLocalDetailsSize = uSize;
		}
		#ifdef DEBUG
			else
			{
				ERRORMESSAGE(("%s:allocation failed!\r\n",_fx_));
			}
		#endif
	//}
	//else
	//{
	//}

	// in all cases, fixup channel parameters.

	pTemp->dwDefaultSamples = uSamples =pTemp->dwDefaultSamples;
	
	wFrames = pTemp->nonstd_params.wFramesPerPktMax;
	if(!pTemp->nonstd_params.wFramesPerPktMax)	
	{
		pTemp->nonstd_params.wFramesPerPktMax=
			wFrames = LOWORD(MaxFramesPerPacket((LPWAVEFORMATEX)lpvMappingData));
	}
	// if the preferred frames/packet is 0 or greater than the max, set it to min
	if((pTemp->nonstd_params.wFramesPerPkt ==0) ||
		(pTemp->nonstd_params.wFramesPerPkt > wFrames))
	{
		pTemp->nonstd_params.wFramesPerPkt =
			LOWORD(MinFramesPerPacket((LPWAVEFORMATEX)lpvMappingData));
	}
	// if the min is more than preferred, fix it
	if(pTemp->nonstd_params.wFramesPerPktMin > pTemp->nonstd_params.wFramesPerPkt)
	{
		pTemp->nonstd_params.wFramesPerPktMin =
			LOWORD(MinFramesPerPacket((LPWAVEFORMATEX)lpvMappingData));
	}
	pTemp->nonstd_params.wDataRate =0;  // default
	pTemp->nonstd_params.wFrameSize = (pTemp->nonstd_params.wFramesPerPkt)
			?uSamples / pTemp->nonstd_params.wFramesPerPkt: 0;
    if(pTemp->nonstd_params.wFrameSizeMax < pTemp->nonstd_params.wFrameSize)
        pTemp->nonstd_params.wFrameSizeMax = pTemp->nonstd_params.wFrameSize;

	pTemp->nonstd_params.UsePostFilter = 0;
	pTemp->nonstd_params.UseSilenceDet = 0;


	// fixup the H245 parameters.  Use the REBASED index of the cap entry as the cap ID
	pTemp->H245TermCap.CapId = (USHORT)IndexToId(uNumLocalFormats);

	if(pTemp->H245TermCap.ClientType ==0
				|| pTemp->H245TermCap.ClientType ==H245_CLIENT_AUD_NONSTD)
	{
		LPWAVEFORMATEX lpwfx;
		lpwfx = (LPWAVEFORMATEX)pTemp->lpLocalFormatDetails;
		if(lpwfx)
		{	
			pTemp->H245TermCap.ClientType = H245_CLIENT_AUD_NONSTD;

			// all nonstandard identifier fields are unsigned short
			// two possibilities for choice are "h221NonStandard_chosen" and "object_chosen"
			pTemp->H245TermCap.H245Aud_NONSTD.nonStandardIdentifier.choice = h221NonStandard_chosen;
		
			pTemp->H245TermCap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode = USA_H221_COUNTRY_CODE;
			pTemp->H245TermCap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension = USA_H221_COUNTRY_EXTENSION;
			pTemp->H245TermCap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = MICROSOFT_H_221_MFG_CODE;

			// Set the nonstandard data fields to null for now. The nonstandard cap data will be
			// created when capabilities are serialized.
			// set size of buffer
			pTemp->H245TermCap.H245Aud_NONSTD.data.length = 0;
			pTemp->H245TermCap.H245Aud_NONSTD.data.value = NULL;
		}
	}
	else
	{
		// the following should already have been set in *pFmtBuf by the calling function
		// and it should have already been copied to *pTemp
		
		//pTemp->ClientType = (H245_CLIENT_T)pDecodeDetails->H245Cap.ClientType;
		//pTemp->DataType = H245_DATA_AUDIO;
		//pTemp->Dir = H245_CAPDIR_LCLTX;  // should this be H245_CAPDIR_LCLRX for receive caps?
		
		// issue:special case G723 params ???
		if(pTemp->H245TermCap.ClientType == H245_CLIENT_AUD_G723) 	
		{
			pTemp->H245TermCap.H245Aud_G723.maxAl_sduAudioFrames = 4;
// mikev 9/10/96 - we may NOT want to advertise silence suppression capability of
// the codec because our silence detection scheme works out-of-band for any codec
// 9/29/96 - this gets overwritten in SerializeH323DecodeFormats() anyway
			pTemp->H245TermCap.H245Aud_G723.silenceSuppression = 0;
		}
		
		// check for pre-existing capability with the same standard ID.
		pTemp->dwPublicRefIndex = 0;	// forget old association, assume that there
										// is no pre-existing capability with the same
										//standard ID.
		UINT i;
		AUDCAP_DETAILS *pFmtExisting = pLocalFormats;
		BOOL bRefFound = FALSE; // this var needed only to support backward
								// compatibility with Netmeeting 2.0 Beta 1
		if(uNumLocalFormats && pLocalFormats)
		{
			for(i=0; i<uNumLocalFormats; i++)
			{
				pFmtExisting = pLocalFormats + i;
				// see if it is the same defined codepoint
				if(pFmtExisting->H245TermCap.ClientType == pTemp->H245TermCap.ClientType)
				{
					// mark this capability entry as being publically advertised
					// by the existing entry.  If the existing entry also refs
					// another, follow the reference
					pTemp->dwPublicRefIndex = (pFmtExisting->dwPublicRefIndex)?
						pFmtExisting->dwPublicRefIndex : i;
					bRefFound = TRUE;
					break;
				}
			}
		}

	}		

	uNumLocalFormats++;
	
	// return the capability ID.
	//return (uNumLocalFormats-1);
	return pTemp->H245TermCap.CapId;
	
	ERROR_EXIT:
	return INVALID_AUDIO_FORMAT;
			
}

UINT CMsiaCapability::GetNumCaps(BOOL bRXCaps)
{
	UINT u, uOut=0;
	
	AUDCAP_DETAILS *pDecodeDetails = pLocalFormats;
	if(bRXCaps)
	{
		for(u=0; u <uNumLocalFormats; u++)
		{
			if(pDecodeDetails->bRecvEnabled)
				uOut++;
			
			pDecodeDetails++;
		}
		return uOut;
	}
	else
		return uNumLocalFormats;
}

VOID CMsiaCapability::FlushRemoteCaps()
{
	if(pRemoteDecodeFormats)
	{
		MEMFREE(pRemoteDecodeFormats);
		pRemoteDecodeFormats = NULL;
		uNumRemoteDecodeFormats = 0;
		uRemoteDecodeFormatCapacity = 0;
	}
}
HRESULT CMsiaCapability::GetNumFormats(UINT *puNumFmtOut)
{
	*puNumFmtOut = uNumLocalFormats;
	return hrSuccess;
}


/***************************************************************************

    Name      : CMsiaCapability::FormatEnumHandler

    Purpose   : Enumerate ACM formats coming from ACM, and see if they
					are ones that we use.

    Parameters:	Standard ACM EnumFormatCallback parameters

    Returns   : BOOL

    Comment   :

***************************************************************************/
BOOL CMsiaCapability::FormatEnumHandler(HACMDRIVERID hadid,
    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport)
{
	PACM_APP_PARAM pAppParam = (PACM_APP_PARAM) dwInstance;
	LPACMFORMATTAGDETAILS paftd = pAppParam->paftd;
	AUDCAP_DETAILS audcap_entry;

	// look at the passed in dwInstance. this will tell us which format handler
	// to call
	if ((pAppParam->dwFlags && ACMAPP_FORMATENUMHANDLER_MASK) == ACMAPP_FORMATENUMHANDLER_ADD)
	{
		// this one was called for add format purposes
		return AddFormatEnumHandler(hadid, pafd, dwInstance, fdwSupport);
	}

	// evaluate the details
	if(pafd->pwfx->nChannels ==1)
	{
		if(IsFormatSpecified(pafd->pwfx, pafd, paftd, &audcap_entry))
		{
			DEBUGMSG(ZONE_ACM,("FormatEnumHandler: tag 0x%04X, nChannels %d\r\n",
				pafd->pwfx->wFormatTag, pafd->pwfx->nChannels));
			DEBUGMSG(ZONE_ACM,("FormatEnumHandler: nSamplesPerSec 0x%08lX, nAvgBytesPerSec 0x%08lX,\r\n",
				pafd->pwfx->nSamplesPerSec, pafd->pwfx->nAvgBytesPerSec));
			DEBUGMSG(ZONE_ACM,("FormatEnumHandler: nBlockAlign 0x%04X, wBitsPerSample 0x%04X, cbSize 0x%04X\r\n",
				pafd->pwfx->nBlockAlign, pafd->pwfx->wBitsPerSample, pafd->pwfx->cbSize));
			DEBUGMSG(ZONE_ACM,("FormatEnumHandler: szFormat %s,\r\n",
				 pafd->szFormat));

		//	done inside IsFormatSpecified and/or whatever it calls
		//  CalculateFormatProperties(&audcap_details, pafd->pwfx);
			AddFormat(&audcap_entry, (LPVOID)pafd->pwfx,
				(pafd->pwfx) ? (sizeof(WAVEFORMATEX)+pafd->pwfx->cbSize):0);	
				
		}
		//#define BUILD_TEST_ENTRIES
#ifdef BUILD_TEST_ENTRIES
		else
		{
			AUDCAP_INFO sAudCapInfo;

			if(paftd)
			{		
				if((lstrcmp(paftd->szFormatTag, "G.723" ) ==0)
				/*	||  (lstrcmp(paftd->szFormatTag, "MSN Audio" ) ==0) */
					||  (lstrcmp(paftd->szFormatTag, "GSM 6.10" ) ==0))
				{
					lstrcpyn(audcap_entry.szFormat, paftd->szFormatTag,
						sizeof(audcap_entry.szFormat));
					int iLen = lstrlen(audcap_entry.szFormat);
					if(iLen < (sizeof(audcap_entry.szFormat) + 8*sizeof(TCHAR)))
					{
						// ok to concatenate
						lstrcat(audcap_entry.szFormat,", ");
						// must check for truncation. so do the final concatenation via lstrcpyn
						// lstrcat(audcap_entry.szFormat, pafd->szFormat);
						iLen = lstrlen(audcap_entry.szFormat);
						lstrcpyn(&audcap_entry.szFormat[iLen], pafd->szFormat,
							sizeof(audcap_entry.szFormat) - iLen - sizeof(TCHAR));
					}
					lstrcpyn(sAudCapInfo.szFormat, audcap_entry.szFormat,
								sizeof(sAudCapInfo.szFormat); 		
					AddACMFormat (pafd->pwfx, &sAudCapInfo);						
				}
			}
		}
#endif	// BUILD_TEST_ENTRIES
	}

	return TRUE;

}


/***************************************************************************

    Name      : CMsiaCapability::BuildFormatName

    Purpose   : Builds a format name for a format, from the format name and
				the tag name

    Parameters:	pAudcapDetails [out] - pointer to an AUDCAP_DETAILS structure, where the
					created value name will be stored
				pszFormatTagName [in] - pointer to the name of the format tag
				pszFormatName [in] - pointer to the name of the format

    Returns   : BOOL

    Comment   :

***************************************************************************/
BOOL CMsiaCapability::BuildFormatName(	AUDCAP_DETAILS *pAudcapDetails,
													char *pszFormatTagName,
													char *pszFormatName)
{
	BOOL bRet = TRUE;
	int iLen=0;

	if (!pAudcapDetails ||
		!pszFormatTagName	||
		!pszFormatName)
	{
		bRet = FALSE;
		goto out;
	}

	// concatenate ACM strings to form the first part of the registry key - the
	// format is szFormatTag (actually pAudcapDetails->szFormat)
	// (the string  which describes the format tag followed by szFormatDetails
	// (the string which describes parameters, e.g. sample rate)

	lstrcpyn(pAudcapDetails->szFormat, pszFormatTagName, sizeof(pAudcapDetails->szFormat));
	iLen = lstrlen(pAudcapDetails->szFormat);
	// if the format tag description string takes up all the space, don't
	// bother with the format details (need space for ", " also).
	// we're going to say that if we don't have room for 4 characters
	// of the format details string + " ,", then it's not worth it if the
	// point is generating a unique string -if it is not unique by now, it
	// will be because some ACM driver writer was  misinformed
	if(iLen < (sizeof(pAudcapDetails->szFormat) + 8*sizeof(TCHAR)))
	{
		// ok to concatenate
		lstrcat(pAudcapDetails->szFormat,", ");
		// must check for truncation. so do the final concatenation via lstrcpyn
		// lstrcat(pFormatPrefsBuf->szFormat, pafd->szFormat);
		iLen = lstrlen(pAudcapDetails->szFormat);
		lstrcpyn(pAudcapDetails->szFormat+iLen, pszFormatName,
					sizeof(pAudcapDetails->szFormat) - iLen - sizeof(TCHAR));
	}		

out:
	return bRet;
}

// Free a a structure of registry formats info (PRRF_INFO), including memory pointed
// from this structure
void FreeRegistryFormats (PRRF_INFO pRegFmts)
{
	UINT u;

    if (pRegFmts) {
        for (u=0;u<pRegFmts->nFormats;u++) {
            MemFree ((void *) pRegFmts->pNames[u]);
            MemFree ((void *) pRegFmts->pData[u]);
        }
        MemFree ((void *) pRegFmts->pNames);
        MemFree ((void *) pRegFmts->pData);
        MemFree ((void *) pRegFmts);

    }
}

ULONG ReadRegistryFormats (LPCSTR lpszKeyName,CHAR ***pppName,BYTE ***pppData,PUINT pnFormats,DWORD dwDebugSize)
{

    HKEY hKeyParent;
    DWORD nSubKey,nMaxSubLen,nValues=0,nValNamelen,nValDatalen,nValTemp,nDataTemp,i;
    ULONG hRes;

    //Not neccessary but makes life easier
    CHAR **pNames=NULL;
    BYTE **pData=NULL;

    *pnFormats=0;


    //Get the top level node.
    hRes=RegOpenKeyEx (HKEY_LOCAL_MACHINE,lpszKeyName,0,KEY_READ,&hKeyParent);

    if (hRes != ERROR_SUCCESS)
    {
        return hRes;
    }

    //Get some info about this key
    hRes=RegQueryInfoKey (hKeyParent,NULL,NULL,NULL,&nSubKey,&nMaxSubLen,NULL,&nValues,&nValNamelen,&nValDatalen,NULL,NULL);

    if (hRes != ERROR_SUCCESS)
    {
        goto Error_Out;
    }


    if (nValDatalen != dwDebugSize) {
        DEBUGMSG (ZONE_ACM,("Largest Data Value not expected size!\r\n"));
        hRes=ERROR_INVALID_DATA;
        goto Error_Out;
    }

    //Allocate some memory for the various pointers.
    if (!(pNames=(char **) MemAlloc (sizeof(char *)*nValues))) {
        hRes=ERROR_OUTOFMEMORY;
        goto Error_Out;
    }
    ZeroMemory (pNames,sizeof (char *)*nValues);

    if (!(pData = (BYTE **) MemAlloc (sizeof(BYTE *)*nValues))) {
        hRes=ERROR_OUTOFMEMORY;
        goto Error_Out;
    }
    ZeroMemory (pData,sizeof (BYTE *)*nValues);


    //Walk the value list.
    for (i=0;i<nValues;i++)
    {
        //Yes, we're wasting memory here, oh well it's not a lot.
        //probably 40 bytes. We free it later
        if (!(pNames[i] = (char *)MemAlloc (nValNamelen))) {
            hRes=ERROR_OUTOFMEMORY;
            goto Error_Out;
        }

        if (!(pData[i] = (BYTE *)MemAlloc (nValDatalen))) {
            hRes=ERROR_OUTOFMEMORY;
            goto Error_Out;
        }

        //This needs to be able to be smashed, but is an in/out param.
        nValTemp=nValNamelen;
        nDataTemp=nValDatalen;

        hRes=RegEnumValue (hKeyParent,i,(pNames[i]),&nValTemp,NULL,NULL,(pData[i]),&nDataTemp);

#ifdef DEBUG
        if (nDataTemp != dwDebugSize) {
            DEBUGMSG (ZONE_ACM, ("ReadRegistryFormats: Data block not expected size!\r\n"));
            //Return?
        }
#endif

    }

    //Fill in the output.
    *pnFormats=nValues;
    *pppName=pNames;
    *pppData=pData;

    RegCloseKey (hKeyParent);

    return (ERROR_SUCCESS);

Error_Out:
        RegCloseKey (hKeyParent);
        //Free any allocations
        if(pNames)
        {
        	for (i=0;i<nValues;i++)
        	{
            	if (pNames[i])
            	{
                	MemFree (pNames[i]);
            	}
        	}
            MemFree (pNames);
        }

        if (pData)
        {
           	for (i=0;i<nValues;i++)
           	{
           		if (pData[i])
           		{
                	MemFree (pData[i]);
                }
           	}
        	
            MemFree (pData);
        }
        return hRes;
}


BOOL CMsiaCapability::IsFormatSpecified(LPWAVEFORMATEX lpwfx,  LPACMFORMATDETAILS pafd,
	LPACMFORMATTAGDETAILS paftd, AUDCAP_DETAILS *pAudcapDetails)
{
	AUDCAP_DETAILS cap_entry;
	BOOL bRet = FALSE;
	LPTSTR lpszValueName = NULL;
	DWORD dwRes;
	UINT i;


	if(!lpwfx || !pAudcapDetails)
	{
		return FALSE;
	}


    if (!bUseDefault) {
        for (i=0;i<pRegFmts->nFormats;i++) {
            // do a quick sanity check on the contents
            if ( (lpwfx->wFormatTag == ((AUDCAP_DETAILS *)pRegFmts->pData[i])->wFormatTag) &&
                 (lpwfx->nSamplesPerSec == ((DWORD)((AUDCAP_DETAILS *)pRegFmts->pData[i])->audio_params.uSamplesPerSec)) &&
                 ((lpwfx->nAvgBytesPerSec * 8) == (((AUDCAP_DETAILS *)pRegFmts->pData[i])->uMaxBitrate))) {
                break;
            }
        }

        if (i == pRegFmts->nFormats) {
            //Check the case that some (but not all) of the default formats are missing.
            for (i=0;i<uDefTableEntries;i++) {
                if ((paftd->dwFormatTag == default_id_table[i].wFormatTag)
                    && (lpwfx->nSamplesPerSec == (DWORD)default_id_table[i].audio_params.uSamplesPerSec)
                    && (lpwfx->wBitsPerSample == LOWORD(default_id_table[i].audio_params.uBitsPerSample))) {

                    //Arrgh!! Jump down, and rebuild this format
                    goto RebuildFormat;
                }
            }
            if (i==uDefTableEntries) {
                //We don't care about this format, it's not in the cache, or default list
                return FALSE;
            }

        }

        memcpy(pAudcapDetails, pRegFmts->pData[i], sizeof(AUDCAP_DETAILS));
        bRet=TRUE;
    } else {

RebuildFormat:
    	RtlZeroMemory((PVOID) pAudcapDetails, sizeof(AUDCAP_DETAILS));

    	// fixup the bits per sample and sample rate fields of audio_params so that the key name can be built
    	pAudcapDetails->audio_params.uSamplesPerSec = lpwfx->nSamplesPerSec;
    	pAudcapDetails->audio_params.uBitsPerSample = MAKELONG(lpwfx->wBitsPerSample,0);
    	pAudcapDetails->uMaxBitrate = lpwfx->nAvgBytesPerSec * 8;	

    	if (!paftd	||
    		(!BuildFormatName(	pAudcapDetails,
    							paftd->szFormatTag,
    							pafd->szFormat)))
    	{
    		ERRORMESSAGE(("IsFormatSpecified: Couldn't build format name\r\n"));
    		return(FALSE);
    	}

        for(i=0;i< uDefTableEntries; i++)
        {
            if((lpwfx->wFormatTag == default_id_table[i].wFormatTag)
                && (lpwfx->nSamplesPerSec == (DWORD)default_id_table[i].audio_params.uSamplesPerSec)
                && (lpwfx->wBitsPerSample == LOWORD(default_id_table[i].audio_params.uBitsPerSample)))
                //&& strnicmp(lpwfx->szFormat, default_id_table[i].szFormat)
            {
                // found matching default entry - copy stuff from table
                // (but don't overwrite the string)
                memcpy(pAudcapDetails, &default_id_table[i],
                    sizeof(AUDCAP_DETAILS) - sizeof(pAudcapDetails->szFormat));

                // LOOKLOOK - test against CPU limitations.
                // this supports a hack to disable CPU intensive codecs if not running
                //on a pentium

                if(default_id_table[i].wCPUUtilizationEncode > wMaxCPU)
                {					
                    pAudcapDetails->bSendEnabled = FALSE;
                }			
                if(default_id_table[i].wCPUUtilizationDecode > wMaxCPU)
                {					
                    pAudcapDetails->bRecvEnabled = FALSE;		
                }			

                // add this to the registry
                CalculateFormatProperties(pAudcapDetails, lpwfx);
                bRet = UpdateFormatInRegistry(pAudcapDetails);
                break;
            }
        }

    }



    return bRet;
}


/***************************************************************************

    Name      : CMsiaCapability::CopyAudcapInfo

    Purpose   : Copies basic audio info from an AUDCAP_INFO structure to an
				AUDCAP_DETAILS structure, or vice versa. AUDCAP_INFO is external
				representation. AUDCAP_DETAILS is internal one.

    Parameters:	pDetails - pointer to an AUDCAP_DETAILS structure
				pInfo - pointer to an AUDCAP_INFO structure
				bDirection - 0 = ->, 1 = <-

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsiaCapability::CopyAudcapInfo (PAUDCAP_DETAILS pDetails,
	PAUDCAP_INFO pInfo, BOOL bDirection)
{
	WORD wSortIndex;
	UINT uIndex;
	AUDIO_FORMAT_ID Id;
	HRESULT hr=NOERROR;
	
	if(!pInfo || !pDetails)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}

	if (bDirection)
	{
		// AUDCAP_INFO -> AUDCAP_DETAILS
		// the caller cannot modify szFormat, Id, wSortIndex and uMaxBitrate, all calculated fields

		pDetails->wFormatTag = pInfo->wFormatTag;	
		pDetails->uAvgBitrate = pInfo->uAvgBitrate;
		pDetails->wCPUUtilizationEncode	= pInfo->wCPUUtilizationEncode;
		pDetails->wCPUUtilizationDecode	= pInfo->wCPUUtilizationDecode;
		pDetails->bSendEnabled =  pInfo->bSendEnabled;
		pDetails->bRecvEnabled = pInfo->bRecvEnabled;
	}
	else
	{		
		// find the sort index.
		uIndex = (UINT)(pDetails - pLocalFormats);
		Id = IndexToId(uIndex);
		for(wSortIndex=0; wSortIndex<uNumLocalFormats && wSortIndex < MAX_CAPS_PRESORT; wSortIndex++)
		{
			if (uIndex == IDsByRank[wSortIndex])
				break; // found it
		}
		// note:  recall that only  MAX_CAPS_PRESORT are sorted and the rest are in random order.
		// the rest all have a value of MAX_CAPS_PRESORT for the sort index

		memcpy(pInfo->szFormat, pDetails->szFormat, sizeof(pInfo->szFormat));

		// AUDCAP_DETAILS -> AUDCAP_INFO	
		pInfo->wFormatTag = pDetails->wFormatTag;	
		pInfo->Id = Id;
		pInfo->uMaxBitrate = pDetails->uMaxBitrate;
		pInfo->uAvgBitrate = pDetails->uAvgBitrate;
		pInfo->wCPUUtilizationEncode	= pDetails->wCPUUtilizationEncode;
		pInfo->wCPUUtilizationDecode	= pDetails->wCPUUtilizationDecode;
		pInfo->bSendEnabled =  pDetails->bSendEnabled;
		pInfo->bRecvEnabled = pDetails->bRecvEnabled;
		pInfo->wSortIndex = wSortIndex;
	}

out:
	return hr;
}


HRESULT CMsiaCapability::EnumCommonFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut, BOOL bTXCaps)
{
	UINT u, uNumOut =0;
	HRESULT hr = hrSuccess;
	MEDIA_FORMAT_ID FormatIDRemote;
	HRESULT hrIsCommon;	
	
	AUDCAP_DETAILS *pDetails = pLocalFormats;
	// validate input
	if(!pFmtBuf || !uNumFmtOut || (uBufsize < (sizeof(BASIC_AUDCAP_INFO)*uNumLocalFormats)))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pDetails)
	{
		return CAPS_E_NOCAPS;
	}
	// temporary - enumerating requestable receive formats is not yet supported
	if(!bTXCaps)
		return CAPS_E_NOT_SUPPORTED;
		
	for(u=0; (u <uNumLocalFormats) && (u <MAX_CAPS_PRESORT); u++)
	{
		pDetails = pLocalFormats + IDsByRank[u];	
		// if there is a session, then return formats that are common to local and remote.
		if(uNumRemoteDecodeFormats)
		{
			hrIsCommon = ResolveToLocalFormat(IndexToId(IDsByRank[u]), &FormatIDRemote);
			if(HR_SUCCEEDED(hrIsCommon))	
			{
				hr = CopyAudcapInfo (pDetails, pFmtBuf, 0);	
				if(!HR_SUCCEEDED(hr))	
					goto EXIT;
				uNumOut++;
				pFmtBuf++;
			}
		}
		else	// no remote capabilities exist because there is no current session
		{
			hr = CAPS_E_NOCAPS;
		}
	}

	*uNumFmtOut = uNumOut;
EXIT:
	return hr;
}

HRESULT CMsiaCapability::EnumFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut)
{
	UINT u;
	HRESULT hr = hrSuccess;
	AUDCAP_DETAILS *pDetails = pLocalFormats;
	// validate input
	if(!pFmtBuf || !uNumFmtOut || (uBufsize < (sizeof(BASIC_AUDCAP_INFO)*uNumLocalFormats)))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pDetails)
	{
		return CAPS_E_NOCAPS;
	}

	for(u=0; (u <uNumLocalFormats) && (u <MAX_CAPS_PRESORT); u++)
	{
		pDetails = pLocalFormats + IDsByRank[u];	
		hr = CopyAudcapInfo (pDetails, pFmtBuf, 0);	
		if(!HR_SUCCEEDED(hr))	
			goto EXIT;
		pFmtBuf++;
	}

	*uNumFmtOut = min(uNumLocalFormats, MAX_CAPS_PRESORT);
EXIT:
	return hr;
}

HRESULT CMsiaCapability::GetBasicAudcapInfo (AUDIO_FORMAT_ID Id, PBASIC_AUDCAP_INFO pFormatPrefsBuf)
{
	AUDCAP_DETAILS *pFmt;
	UINT uIndex = IDToIndex(Id);
	if(!pFormatPrefsBuf || (uNumLocalFormats <= uIndex))
	{
		return CAPS_E_INVALID_PARAM;
	}
	pFmt = pLocalFormats + uIndex;

	return (CopyAudcapInfo(pFmt,pFormatPrefsBuf, 0));
}

HRESULT CMsiaCapability::ApplyAppFormatPrefs (PBASIC_AUDCAP_INFO pFormatPrefsBuf,
	UINT uNumFormatPrefs)
{
	FX_ENTRY ("CMsiaCapability::ApplyAppFormatPrefs");
	UINT u, v;
	PBASIC_AUDCAP_INFO pTemp;
	AUDCAP_DETAILS *pFmt;

	if(!pFormatPrefsBuf || (uNumLocalFormats != uNumFormatPrefs))
	{
		ERRORMESSAGE(("%s invalid param: pFbuf:0x%08lx, uNumIN:%d, uNum:%d\r\n",
			_fx_, pFormatPrefsBuf, uNumFormatPrefs, uNumLocalFormats));
		return CAPS_E_INVALID_PARAM;
	}
	
	// validate
	for(u=0; u <uNumLocalFormats; u++)
	{
		pTemp =  pFormatPrefsBuf+u;
		// make sure that the format ID is real
		if(IDToIndex(pTemp->Id) >= uNumLocalFormats)
		{
			return CAPS_E_INVALID_PARAM;
		}
		// look for bad sort indices, duplicate sort indices and duplicate format IDs
		if(pTemp->wSortIndex >= uNumLocalFormats)
			return CAPS_E_INVALID_PARAM;
			
		for(v=u+1; v <uNumLocalFormats; v++)
		{
			if((pTemp->wSortIndex == pFormatPrefsBuf[v].wSortIndex)
				|| (pTemp->Id == pFormatPrefsBuf[v].Id))
			{
			ERRORMESSAGE(("%s invalid param: wSI1:0x%04x, wSI2:0x%04x, ID1:%d, ID2:%d\r\n",
			_fx_, pTemp->wSortIndex, pFormatPrefsBuf[v].wSortIndex, pTemp->Id,
			pFormatPrefsBuf[v].Id));
				return CAPS_E_INVALID_PARAM;
			}
		}
	}
	// all seems well
	for(u=0; u <uNumLocalFormats; u++)
	{
		pTemp =  pFormatPrefsBuf+u;			// next entry of the input
		pFmt = pLocalFormats + IDToIndex(pTemp->Id);	// identifies this local format

		// apply the new sort order
		pFmt->wApplicationPrefOrder = pTemp->wSortIndex;
		// update the updatable parameters (CPU utilization, bitrate)
		pFmt->bSendEnabled = pTemp->bSendEnabled;
		pFmt->bRecvEnabled	= pTemp->bRecvEnabled;
		
// only the tuning wizard or other profiling app can write these (via other apis only)
		pFmt->wCPUUtilizationEncode	= pTemp->wCPUUtilizationEncode;
		pFmt->wCPUUtilizationDecode	= pTemp->wCPUUtilizationDecode;
//		pFmt->wApplicationPrefOrder	= pTemp->wApplicationPrefOrder;
//		pFmt->uAvgBitrate	= pTemp->
//		pFmt->wCompressionRatio	= pTemp->
		
		// update the registry
		UpdateFormatInRegistry(pFmt);
		
		// now update the sort order contained in IDsByRank
		// note:  recall that only  MAX_CAPS_PRESORT are sorted and the rest are in random order.
		// LOOKLOOK - maybe need a separate sort order array? - the order in IDsByRank
		// is being overriden here
		// the array holds the sorted indices into the array of formats in pLocalFormats
		if(pTemp->wSortIndex < MAX_CAPS_PRESORT)
		{
			// insert the format at the position indicated by the input
			IDsByRank[pTemp->wSortIndex] = (MEDIA_FORMAT_ID)(pFmt - pLocalFormats);
		}
		
	}

#ifdef DEBUG
	for(u=0; u <uNumLocalFormats; u++) {
		pTemp =  pFormatPrefsBuf+u;			// next entry of the input
		pFmt = pLocalFormats + IDToIndex(pTemp->Id);	// identifies this local format
	    DEBUGMSG (ZONE_ACM,("Format %s: Sort Index: %d\r\n",pTemp->szFormat,pTemp->wSortIndex));
    }
#endif

	return hrSuccess;
}

		// update the registry
BOOL CMsiaCapability::UpdateFormatInRegistry(AUDCAP_DETAILS *pAudcapDetails)
{

	FX_ENTRY(("CMsiaCapability::UpdateFormatInRegistry"));
	LPTSTR lpszKeyName = NULL;
	BOOL bRet;
	UINT i;
	if(!pAudcapDetails)
	{
		return FALSE;
	}	

    //Update the CACHE info!!!
    if (pRegFmts) {
        for (i=0;i<pRegFmts->nFormats;i++) {
            if (!lstrcmp (((AUDCAP_DETAILS *)pRegFmts->pData[i])->szFormat,pAudcapDetails->szFormat) &&
				pAudcapDetails->audio_params.uSamplesPerSec == ((AUDCAP_DETAILS *)pRegFmts->pData[i])->audio_params.uSamplesPerSec &&
				pAudcapDetails->audio_params.uBitsPerSample == ((AUDCAP_DETAILS *)pRegFmts->pData[i])->audio_params.uBitsPerSample &&
				pAudcapDetails->uMaxBitrate == ((AUDCAP_DETAILS *)pRegFmts->pData[i])->uMaxBitrate) {

                memcpy (pRegFmts->pData[i],pAudcapDetails,sizeof (AUDCAP_DETAILS));
                break;
            }
        }
    }


	lpszKeyName = AllocRegistryKeyName(	pAudcapDetails->szFormat,
										pAudcapDetails->audio_params.uSamplesPerSec,
										pAudcapDetails->audio_params.uBitsPerSample,
										pAudcapDetails->uMaxBitrate);
	if (!lpszKeyName)
	{
		ERRORMESSAGE(("%s:Alloc failed\r\n",_fx_));
        return(FALSE);
    }

	DEBUGMSG(ZONE_ACM,("%s:updating %s, wPref:0x%04x, bS:%d, bR:%d\r\n",
			_fx_, lpszKeyName, pAudcapDetails->wApplicationPrefOrder,
			pAudcapDetails->bSendEnabled, pAudcapDetails->bRecvEnabled));
	// add this to the registry
	RegEntry reAudCaps(szRegInternetPhone TEXT("\\") szRegMSIPAndH323Encodings,
						HKEY_LOCAL_MACHINE);

	bRet = (ERROR_SUCCESS == reAudCaps.SetValue(lpszKeyName,
												pAudcapDetails,
												sizeof(AUDCAP_DETAILS)));

	FreeRegistryKeyName(lpszKeyName);
    return(bRet);				
}

/***************************************************************************

    Name      : CMsiaCapability::AddFormatEnumHandler

    Purpose   : Enumerates the ACM formats for the case in which we want
				to see all formats, and find the one we need. Used for installable
				codecs when we want to find more info on the format being added

    Parameters:	Standard ACM EnumFormatCallback parameters

    Returns   : BOOL (somewhat upside down logic)
				TRUE - not out format. keep calling.
				FALSE - found our format. don't call anymore

    Comment   :

***************************************************************************/
BOOL CMsiaCapability::AddFormatEnumHandler(HACMDRIVERID hadid,
    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport)
{
	PACM_APP_PARAM pAppParam = (PACM_APP_PARAM) dwInstance;
	LPWAVEFORMATEX lpwfx = pAppParam->lpwfx;
	LPACMFORMATTAGDETAILS paftd = pAppParam->paftd;
	AUDCAP_DETAILS *pAudcapDetails = pAppParam->pAudcapDetails;
	BOOL bRet = TRUE;

	if (pAppParam->hr == NOERROR)
	{
		// already got what we wanted
		bRet = FALSE;
		goto out;
	}
	
	// check to see if this is the format we're looking for
	if ((lpwfx->cbSize != pafd->pwfx->cbSize) ||
		!RtlEqualMemory(lpwfx, pafd->pwfx, sizeof(WAVEFORMATEX)+lpwfx->cbSize))
	{
		// not the one. out of here asap, but tell ACM to keep calling us
		bRet = TRUE;
		goto out;
	}

	// this is the format tag we're looking for
	if (BuildFormatName(pAudcapDetails,
						paftd->szFormatTag,
						pafd->szFormat))
	{
		pAppParam->hr = NOERROR;
	}
	
	// either an error or we found what we want. tell ACM not to call us anymore
	bRet = FALSE;	

out:
	return bRet;
}

/***************************************************************************

    Name      : NormalizeCPUUtilization

    Purpose   : Normalize CPU utilization numbers for an audio format

    Parameters:	pAudcapDetails [in/out] pointer to an AUDCAP_DETAILS structure
					with the wCPUUtilizationEncode and wCPUUtilizationDecode
					correctly initialized. These fields will be scaled in place
					per the machine CPU.

    Returns   : FALSE for error

***************************************************************************/
BOOL NormalizeCPUUtilization (PAUDCAP_DETAILS pAudcapDetails)
{
#define wCPUEncode pAudcapDetails->wCPUUtilizationEncode
#define wCPUDecode pAudcapDetails->wCPUUtilizationDecode
#define BASE_PENTIUM 90
	int nNormalizedSpeed, iFamily=0;

	if (!pAudcapDetails)
	{
		ASSERT(pAudcapDetails);
		return FALSE;
	}

#ifdef	_M_IX86
	GetNormalizedCPUSpeed (&nNormalizedSpeed,&iFamily);
#else
	// profile the CPU on, say, an Alpha
	// see ui\conf\audiocpl.cpp
	iFamily=5;
	nNormalizedSpeed=300;
#endif

	// base is Pentium 90Mhz.
	if (iFamily < 5)
	{	// 486 or below, inlcuding Cyrix parts
		if (nNormalizedSpeed > 50)
		{	// Cyrix or friends. 1.5 the utilization of a P5-90. Make it so.
			wCPUEncode += max(1, wCPUEncode / 2);
			wCPUDecode += max(1, wCPUDecode / 2);
		}
		else
		{	// 486 is half a P5-90. This is not accurate, but good enough
			wCPUEncode = max(1, wCPUEncode * 2);
			wCPUDecode = max(1, wCPUDecode * 2);
		}
	}
	else
	{	// it's a Pentium or TNGs
		// nNormalizedSpeed ALREADY accounts for P-Pro and later families
		wCPUEncode=max(1,((wCPUEncode*BASE_PENTIUM)/nNormalizedSpeed));
		wCPUDecode=max(1,((wCPUDecode*BASE_PENTIUM)/nNormalizedSpeed));
	}

	// disable this format if encode utilization is too high
	// we compare to 80%, since there's no QoS CPU utilization number at
	// this point, and if there was, it would usually select 81%
	if (wCPUEncode > 80)
		pAudcapDetails->bSendEnabled = FALSE;

	return TRUE;
}

/***************************************************************************

    Name      : CMsiaCapability::AddACMFormat

    Purpose   : Adds an ACM format to the list of formats we support

    Parameters:	lpwfx - pointer to the waveformat structure for the added codec
				pAudCapInfo - additional format info that is not in the waveformat
					structure

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsiaCapability::AddACMFormat (LPWAVEFORMATEX lpwfx, PBASIC_AUDCAP_INFO pAudcapInfo)
{
	HRESULT hr = hrSuccess;
	// initialize cap entry with default values
	AUDCAP_DETAILS cap_entry =
		{WAVE_FORMAT_UNKNOWN,  NONSTD_TERMCAP, STD_CHAN_PARAMS,
		{RTP_DYNAMIC_MIN,  0, 8000, 16},
		0, TRUE, TRUE,
		960, 				// default number of samples per packet
		16000,				// default to 16kbs bitrate
		0, 					// unknown average bitrate
		90, 90,	// default CPU utilization
		PREF_ORDER_UNASSIGNED,	// unassigned sort order
		0,NULL,0,NULL,
		""};
	ACM_APP_PARAM sAppParam = {	this, &cap_entry, ACMAPP_FORMATENUMHANDLER_ADD,
								lpwfx, NULL, CAPS_E_SYSTEM_ERROR, NULL};
		
	/*
	 *	Parameter validation
	 */

	if (!lpwfx || !pAudcapInfo)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}
		
	// nBlockAlign of 0 is illegal and will crash NAC
	if (lpwfx->nBlockAlign == 0)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}
		
	// only supporting formats with one audio channel
	if (lpwfx->nChannels != 1)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}
		
	/*
	 *	Build the AUDCAP_DETALS structure for this format
	 */

	// WAVEFORMAT info first
	// fixup the bits per sample and sample rate fields of audio_params so that
	// the key name can be built
	cap_entry.audio_params.uSamplesPerSec = lpwfx->nSamplesPerSec;
	cap_entry.audio_params.uBitsPerSample = MAKELONG(lpwfx->wBitsPerSample,0);

	// fill in info given in lpwfx, calculate whatever parameters can be calculated
	// use actual bits per sample unless the bps field is zero, in which case
	// assume 16 bits (worst case).
	cap_entry.wFormatTag = lpwfx->wFormatTag;

	// now add in the caller AUDCAP_INFO information
	CopyAudcapInfo(&cap_entry, pAudcapInfo, 1);

	// normalize the encode and decode CPU utilization numbers
	NormalizeCPUUtilization(&cap_entry);

	// get the values we need to get from the WAVEFORMATEX structure
	CalculateFormatProperties(&cap_entry, lpwfx);

	// set the RTP payload number. We are using a random number from the dynamic range
	// for the installable codecs
	cap_entry.audio_params.RTPPayload = RTP_DYNAMIC_MIN;

	// get ACM to enumerate all formats, and see if we can find this one
	// this call will make ACM call into AddFormatEnumHandler, which will try to
	// match formats returned by ACM with the added format, and if successful,
	// will create a format name for it into cap_entry.szFormat;
	if(!DriverEnum((DWORD_PTR) &sAppParam))
	{
		hr = CAPS_E_NOMATCH;
		goto out;
	}
				
	if (HR_FAILED(sAppParam.hr))
	{
		ERRORMESSAGE(("CMsiaCapability::AddACMFormat: format enum problem\r\n"));
		hr = CAPS_E_NOMATCH;
		goto out;
	}

	// add this to the registry
	if(!UpdateFormatInRegistry(&cap_entry))
	{
		ERRORMESSAGE(("CMsiaCapability::AddACMFormat: can't update registry\r\n"));
		hr = CAPS_E_SYSTEM_ERROR;
		goto out;
	}
	// free the old format cache...
    FreeRegistryFormats(pRegFmts);
	pRegFmts=NULL;

	// reinit to update the list of local formats
    if (!ReInit())
	{
		ERRORMESSAGE(("CMsiaCapability::AddACMFormat: Reinit failed\r\n"));
		hr = CAPS_E_SYSTEM_ERROR;
   		goto out;
	}

out:
	return hr;
}

/***************************************************************************

    Name      : CMsiaCapability::RemoveACMFormat

    Purpose   : Removes an ACM format from the list of formats we support

    Parameters:	lpwfx - pointer to the waveformat structure for the added codec

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsiaCapability::RemoveACMFormat (LPWAVEFORMATEX lpwfx)
{
	HRESULT hr = hrSuccess;
    HKEY hKey = NULL;
	LPTSTR lpszValueName = NULL;
    DWORD dwErr;
	AUDCAP_DETAILS cap_entry;
	ACM_APP_PARAM sAppParam = {	this, &cap_entry, ACMAPP_FORMATENUMHANDLER_ADD,
								lpwfx, NULL, CAPS_E_SYSTEM_ERROR, NULL};
	
	/*
	 *	Parameter validation
	 */

	if(!lpwfx)
	{
		ERRORMESSAGE(("CMsiaCapability::RemoveACMFormat: NULL WAVEFORMAT pointer\r\n"));
		return CAPS_E_INVALID_PARAM;
	}	

	// nBlockAlign of 0 is illegal and will crash NAC
	if (lpwfx->nBlockAlign == 0)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}
		
	// only supporting formats with one audio channel
	if (lpwfx->nChannels != 1)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}
		
	/*
	 *	Enumerate ACM formats
	 */

	if(!DriverEnum((DWORD_PTR) &sAppParam))
	{
		ERRORMESSAGE(("CMsiaCapability::RemoveACMFormat: Couldn't find format\r\n"));
		hr = CAPS_E_NOMATCH;
		goto out;
	}
				
	if (HR_FAILED(sAppParam.hr))
	{
		ERRORMESSAGE(("CMsiaCapability::RemoveACMFormat: format enum problem\r\n"));
		hr = CAPS_E_SYSTEM_ERROR;
		goto out;
	}

	lpszValueName = AllocRegistryKeyName(cap_entry.szFormat,
										lpwfx->nSamplesPerSec,
										MAKELONG(lpwfx->wBitsPerSample,0),
										lpwfx->nAvgBytesPerSec * 8);
	if (!lpszValueName)
	{
		ERRORMESSAGE(("CMsiaCapability::RemoveACMFormat: Alloc failed\r\n"));
	    hr = CAPS_E_SYSTEM_ERROR;
	    goto out;
    }

	// Get the key handle
    if (dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					szRegInternetPhone TEXT("\\") szRegMSIPAndH323Encodings, 0,
					KEY_ALL_ACCESS, &hKey))
	{
		ERRORMESSAGE(("CMsiaCapability::RemoveACMFormat: can't open key to delete\r\n"));
	    hr = CAPS_E_SYSTEM_ERROR;
	    goto out;
    }

	dwErr = RegDeleteValue(hKey, lpszValueName );	
	if(dwErr != ERROR_SUCCESS)
	{
		hr = CAPS_E_SYSTEM_ERROR;
		goto out;
	}

	// free the old format cache...
    FreeRegistryFormats(pRegFmts);
    pRegFmts=NULL;

	// reinit to update the list of local formats
    if (!ReInit())
	{
		hr = CAPS_E_SYSTEM_ERROR;
   		goto out;
	}

out:
    if (hKey)
        RegCloseKey(hKey);
	if(lpszValueName)
		MEMFREE(lpszValueName);		
	return hr;
}

HRESULT CMsiaCapability::SetCapIDBase (UINT uNewBase)
{
	uCapIDBase = uNewBase;	
	UINT u;
	for (u=0;u<uNumLocalFormats;u++)
	{
    	pLocalFormats[u].H245TermCap.CapId = u + uCapIDBase;
	}
   	return hrSuccess;
}

BOOL CMsiaCapability::IsHostForCapID(MEDIA_FORMAT_ID CapID)
{
	if((CapID >= uCapIDBase) && ((CapID - uCapIDBase) < uNumLocalFormats))
		return TRUE;
	else
		return FALSE;
	
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\nac.h ===
/*
 *  	File: nac.h
 *
 *      Microsoft Network Audio Controller (NAC) header file
 *
 *		Revision History:
 *
 *		11/28/95	mikev	created
 */


#ifndef _NAC_H
#define _NAC_H
#define _NAVC_

#ifdef __cplusplus
class CConnection;
class DataPump;
class CNac;
typedef class CConnection CIPPhoneConnection;


//
//	temporary defs
//
typedef CNac **LPLPNAC;
HRESULT WINAPI CreateNac(LPLPNAC lplpNac);

#endif	// __cplusplus

// windows messages
#define WNAC_START		WM_USER+0x100
#define	WNAC_CONNECTREQ WNAC_START+0x0000
#define WCON_STATUS 	WNAC_START+0x0001

//
//	end of temporary defs
//

//
//  utility functions
//
VOID FreeTranslatedAliasList(PCC_ALIASNAMES pDoomed);
HRESULT AllocTranslatedAliasList(PCC_ALIASNAMES *ppDest, P_H323ALIASLIST pSource);

#define DEF_AP_BWMAX	14400


/*
 *	Class definitions
 */

#ifdef __cplusplus

class CNac : public INac
{
	
protected:
    PCC_ALIASNAMES m_pLocalAliases;
    
	LPWSTR	m_pUserName;
	UINT	uRef;
	HRESULT hrLast;
	UINT m_uMaximumBandwidth;
	// application data
	CNOTIFYPROC pProcNotifyConnect;	// connection notification callback
	HWND hWndNotifyConnect;	// connection notification hwnd
	HWND hAppWnd;			// hwnd of the process that owns the NAC
	HINSTANCE hAppInstance;	// instance of the process that owns the NAC

	// subcomponent object references
	LPIH323PubCap m_pCapabilityResolver;
	CConnection *m_pListenLine;	// connection object listening for incoming
	CConnection *m_pCurrentLine;	// active connection object(talking), if there is one
	CConnection *m_pLineList;	
	int m_numlines;	// # of objects in m_pLineList

	ImpICommChan 	*m_pSendAudioChannel;	
	ImpICommChan	*m_pSendVideoChannel;	
	
//  Internal interfaces	
	BOOL Init();	// internal initialization

	OBJ_CPT;		// profiling timer
	
public:
	CConnection *m_pNextToAccept;
	HWND GetAppWnd(){return hAppWnd;};
	HINSTANCE GetAppInstance() {return hAppInstance;};
	LPWSTR GetUserDisplayName() {return m_pUserName;};
    PCC_ALIASNAMES GetUserAliases() {return m_pLocalAliases;};
    PCC_ALIASITEM GetUserDisplayAlias();
	CNac();
	~CNac();
	HRESULT CreateConnection(CConnection **lplpConnection, GUID PIDofProtocolType);
	HRESULT RemoveConnection(CConnection *lpConnection);
	HRESULT LastHR() {return hrLast;};
	VOID SetLastHR(HRESULT hr) {hrLast = hr;};
	HRESULT GetConnobjArray(CConnection **lplpArray, UINT uSize);
	ICtrlCommChan *QueryPreviewChannel(LPGUID lpMID);

	STDMETHOD_( CREQ_RESPONSETYPE, ConnectionRequest(CConnection *pConnection));
	STDMETHOD_( CREQ_RESPONSETYPE, FilterConnectionRequest(CConnection *pConnection,
	    P_APP_CALL_SETUP_DATA pAppData));

// INacInterface stuff
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHOD_(ULONG, AddRef());
	STDMETHOD_(ULONG, Release());
	STDMETHOD( Initialize(HWND hWnd, HINSTANCE hInst, PORT *lpPort));
	STDMETHOD( SetMaxPPBandwidth(UINT Bandwidth));
	STDMETHOD( RegisterConnectionNotify(HWND hWnd, CNOTIFYPROC pConnectRequestHandler));
	STDMETHOD( DeregisterConnectionNotify(HWND hWnd, CNOTIFYPROC pConnectRequestHandler));
	STDMETHOD( GetNumConnections(ULONG *lp));
	STDMETHOD( GetConnectionArray(LPCONNECTIONIF *lplpArray, UINT uSize));
	STDMETHOD( CreateConnection(LPCONNECTIONIF *lplpLine, GUID PIDofProtocolType));
	STDMETHOD( DeleteConnection(LPCONNECTIONIF lpLine));
	STDMETHOD( SetUserDisplayName(LPWSTR lpwName));
	STDMETHODIMP CreateLocalCommChannel(ICommChannel** ppCommChan, LPGUID lpMID,
		IMediaChannel* pMediaStream);
	STDMETHODIMP SetUserAliasNames(P_H323ALIASLIST pAliases);
	STDMETHODIMP EnableGatekeeper(BOOL bEnable, PSOCKADDR_IN pGKAddr);
};

#else	// not __cplusplus


#endif	//  __cplusplus


#endif	//#ifndef _NAC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\msivcaps.cpp ===
/*
 *  	File: msivcaps.cpp
 *
 *		VCM implementation of Microsoft Network Video capability object.
 *
 *		Revision History:
 *
 *		06/06/96	mikev	created msiacaps.cpp
 *		07/28/96	philf	created (added support for video)
 */


#define _MSIAV_ TRUE
#include "precomp.h"


BOOL GetFormatBuffer();
extern PVCMFORMATDETAILS pvfd_g;

#define PREF_ORDER_UNASSIGNED 0xffff

//External function (in msiacaps.cpp) to read reg info in one shot
#ifdef DEBUG
extern ULONG ReadRegistryFormats (LPCSTR lpszKeyName,CHAR ***pppName,BYTE ***pppData,PUINT pnFormats,DWORD dwDebugSize);
#else
extern ULONG ReadRegistryFormats (LPCSTR lpszKeyName,CHAR ***pppName,BYTE ***pppData,PUINT pnFormats);
#endif



//This can be used as an export, so give it a unique name!
#ifndef _ALPHA_
VIDCAP_DETAILS default_vid_table[] =
{
#ifdef USE_BILINEAR_MSH26X
	{VIDEO_FORMAT_MSH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Small, 128, 96},0,TRUE,TRUE,1,245760*8,245760*8,10,10,5,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M263, 24bit, 30fps, 128x096"},
	{VIDEO_FORMAT_MSH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Medium, 176, 144},0,TRUE,TRUE,1,245760*8,245760*8,10,10,4,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M263, 24bit, 30fps, 176x144"},
	{VIDEO_FORMAT_MSH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Large, 352, 288},0,TRUE,TRUE,1,245760*8*4,245760*8*4,10,10,6,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M263, 24bit, 30fps, 352x288"},
	{VIDEO_FORMAT_MSH261,STD_VID_TERMCAP(H245_CLIENT_VID_H261),STD_VID_PARAMS,{RTP_PAYLOAD_H261,0,30, 24, Medium, 176, 144},0,TRUE,TRUE,1,245760*8,245760*8,10,10,7,0,NULL,0,NULL,"Microsoft H.261 Video Codec, vidc.M261, 24bit, 30fps, 176x144"},
	{VIDEO_FORMAT_MSH261,STD_VID_TERMCAP(H245_CLIENT_VID_H261),STD_VID_PARAMS,{RTP_PAYLOAD_H261,0,30, 24, Large, 352, 288},0,TRUE,TRUE,1,245760*8*4,245760*8*4,10,10,8,0,NULL,0,NULL,"Microsoft H.261 Video Codec, vidc.M261, 24bit, 30fps, 352x288"},
	{VIDEO_FORMAT_MSH26X,NONSTD_VID_TERMCAP,STD_VID_PARAMS,{RTP_DYNAMIC_MIN+1,0,24, Small, 80, 64},0,TRUE,TRUE,1,245760*8,245760*8,10,10,2,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M26X, 24bit, 30fps, 080x064"},
	{VIDEO_FORMAT_MSH26X,NONSTD_VID_TERMCAP,STD_VID_PARAMS,{RTP_DYNAMIC_MIN+1,0,30, 24, Medium, 128, 96},0,TRUE,TRUE,1,245760*8,245760*8,10,10,1,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M26X, 24bit, 30fps, 128x096"},
	{VIDEO_FORMAT_MSH26X,NONSTD_VID_TERMCAP,STD_VID_PARAMS,{RTP_DYNAMIC_MIN+1,0,24, Large, 176, 144},0,TRUE,TRUE,1,245760*8,245760*8,10,10,3,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M26X, 24bit, 30fps, 176x144"}
#else
	{VIDEO_FORMAT_MSH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Small, 128, 96},0,TRUE,TRUE,1,245760*8,245760*8,10,10,5,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M263, 24bit, 30fps, 128x096"},
	{VIDEO_FORMAT_MSH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Medium, 176, 144},0,TRUE,TRUE,1,245760*8,245760*8,10,10,2,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M263, 24bit, 30fps, 176x144"},
	{VIDEO_FORMAT_MSH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Large, 352, 288},0,TRUE,TRUE,1,245760*8*4,245760*8*4,10,10,14,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M263, 24bit, 30fps, 352x288"},
	{VIDEO_FORMAT_MSH261,STD_VID_TERMCAP(H245_CLIENT_VID_H261),STD_VID_PARAMS,{RTP_PAYLOAD_H261,0,30, 24, Medium, 176, 144},0,TRUE,TRUE,1,245760*8,245760*8,10,10,9,0,NULL,0,NULL,"Microsoft H.261 Video Codec, vidc.M261, 24bit, 30fps, 176x144"},
	{VIDEO_FORMAT_MSH261,STD_VID_TERMCAP(H245_CLIENT_VID_H261),STD_VID_PARAMS,{RTP_PAYLOAD_H261,0,30, 24, Large, 352, 288},0,TRUE,TRUE,1,245760*8*4,245760*8*4,10,10,20,0,NULL,0,NULL,"Microsoft H.261 Video Codec, vidc.M261, 24bit, 30fps, 352x288"},
#endif
};
#else
VIDCAP_DETAILS default_vid_table[] =
{
	{VIDEO_FORMAT_DECH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Small,128, 96},0,TRUE,TRUE,1,53760,53760,10,10,10,0,0,5,0,NULL,0,NULL,  "Digital H263 Video CODEC, vidc.D263, 24bit, 30fps, 128x096"},
	{VIDEO_FORMAT_DECH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Medium,176, 144},0,TRUE,TRUE,1,53760,53760,10,10,10,0,0,2,0,NULL,0,NULL,"Digital H263 Video Codec, vidc.D263, 24bit, 30fps, 176x144"},
	{VIDEO_FORMAT_DECH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Large,352, 288},0,TRUE,TRUE,1,53760,53760,10,10,10,0,0,14,0,NULL,0,NULL,"Digital H263 Video Codec, vidc.D263, 24bit, 30fps, 352x288"},
	{VIDEO_FORMAT_DECH261,STD_VID_TERMCAP(H245_CLIENT_VID_H261),STD_VID_PARAMS,{RTP_PAYLOAD_H261,0,30, 24, Medium,176, 144},0,TRUE,TRUE,1,53760,53760,10,10,10,0,0,9,0,NULL,0,NULL,"Digital H261 Video Codec, vidc.D261, 24bit, 30fps, 176x144"},
	{VIDEO_FORMAT_DECH261,STD_VID_TERMCAP(H245_CLIENT_VID_H261),STD_VID_PARAMS,{RTP_PAYLOAD_H261,0,30, 24, Large,352, 288},0,TRUE,TRUE,1,53760,53760,10,10,10,0,0,20,0,NULL,0,NULL,"Digital H261 Video Codec, vidc.D261, 24bit, 30fps, 352x288"},
};
#endif
static UINT uDefVidTableEntries = sizeof(default_vid_table) /sizeof(VIDCAP_DETAILS);
static BOOL bCreateDefTable = FALSE;

//
//	static members of CMsivCapability
//

MEDIA_FORMAT_ID CMsivCapability::IDsByRank[MAX_CAPS_PRESORT];
UINT CMsivCapability::uNumLocalFormats = 0;			// # of active entries in pLocalFormats
UINT CMsivCapability::uStaticRef = 0;					// global ref count
UINT CMsivCapability::uCapIDBase = 0;					// rebase capability ID to index into IDsByRank
UINT CMsivCapability::uLocalFormatCapacity = 0;		// size of pLocalFormats (in multiples of AUDCAP_DETAILS)
VIDCAP_DETAILS * CMsivCapability::pLocalFormats = NULL;	



CMsivCapability::CMsivCapability()
:uRef(1),
wMaxCPU(95),
uNumRemoteDecodeFormats(0),
uRemoteDecodeFormatCapacity(0),
pRemoteDecodeFormats(NULL),
bPublicizeTXCaps(FALSE),
bPublicizeTSTradeoff(TRUE)
{
	m_IAppVidCap.Init(this);
}


CMsivCapability::~CMsivCapability()
{
	UINT u;
	VIDCAP_DETAILS *pDetails;
	// release global static memory (the local capabilities) if this is the last delete
	if(uStaticRef <= 1)
	{
		if (pLocalFormats)
		{	
			pDetails = pLocalFormats;
			for(u=0; u <uNumLocalFormats; u++)
			{
				if(pDetails->lpLocalFormatDetails)
				{
					MEMFREE(pDetails->lpLocalFormatDetails);
				}
				// there really should never be remote details associated with the local
				// formats........
				if(pDetails->lpRemoteFormatDetails)
				{
					MEMFREE(pDetails->lpRemoteFormatDetails);
				}
				
				pDetails++;
			}
			MEMFREE(pLocalFormats);
			pLocalFormats=NULL;
			uLocalFormatCapacity = 0;
		}
		uStaticRef--;
	}
	else
	{
		uStaticRef--;
	}
	
	if (pRemoteDecodeFormats)
	{	
		pDetails = pRemoteDecodeFormats;
		for(u=0; u <uNumRemoteDecodeFormats; u++)
		{
			if(pDetails->lpLocalFormatDetails)
			{
				MEMFREE(pDetails->lpLocalFormatDetails);
			}
			// there really should never be remote details associated with the local
			// formats........
			if(pDetails->lpRemoteFormatDetails)
			{
				MEMFREE(pDetails->lpRemoteFormatDetails);
			}
			
			pDetails++;
		}
		MEMFREE(pRemoteDecodeFormats);
		pRemoteDecodeFormats=NULL;
		uRemoteDecodeFormatCapacity  = 0;
	}
	
}
UINT CMsivCapability::GetNumCaps(BOOL bRXCaps)
{
	UINT u, uOut=0;
	
	VIDCAP_DETAILS *pDecodeDetails = pLocalFormats;
	if(bRXCaps)
	{
		for(u=0; u <uNumLocalFormats; u++)
		{
			if(pDecodeDetails->bRecvEnabled)
				uOut++;
			
			pDecodeDetails++;
		}
		return uOut;
	}
	else
	{
		for(u=0; u <uNumLocalFormats; u++)
		{
			if(pDecodeDetails->bSendEnabled)
				uOut++;
			
			pDecodeDetails++;
		}
		return uOut;
	}
}



STDMETHODIMP CMsivCapability::QueryInterface( REFIID iid,	void ** ppvObject)
{
	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if(iid == IID_IAppVidCap )
	{
		*ppvObject = (LPAPPVIDCAPPIF)&m_IAppVidCap;
		AddRef();			
		hr = hrSuccess;
	}
	else if(iid == IID_IH323MediaCap)
	{
		*ppvObject = (IH323MediaCap *)this;
		AddRef();
		hr = hrSuccess;
	}
	else if (iid == IID_IUnknown)
	{
		*ppvObject = this;
		AddRef();
		hr = hrSuccess;
	}
	return hr;
}
ULONG CMsivCapability::AddRef()
{
	uRef++;
	return uRef;
}


ULONG CMsivCapability::Release()
{
	uRef--;
	if(uRef == 0)
	{
		delete this;
		return 0;
	}
	return uRef;
}
HRESULT CMsivCapability::GetNumFormats(UINT *puNumFmtOut)
{
	*puNumFmtOut = uNumLocalFormats;
	return hrSuccess;
}
VOID CMsivCapability::FreeRegistryKeyName(LPTSTR lpszKeyName)
{
	if (lpszKeyName)
    {
		LocalFree(lpszKeyName);
    }
}

LPTSTR CMsivCapability::AllocRegistryKeyName(LPTSTR lpDriverName,
		UINT uSampleRate, UINT uBitsPerSample, UINT uBitsPerSec,UINT uWidth,UINT uHeight)
{
	FX_ENTRY(("AllocRegistryKeyName"));
	BOOL bRet = FALSE;
	LPTSTR lpszKeyName = NULL;

	if(!lpDriverName)
	{
		return NULL;
	}	
	// build a subkey name (drivername_samplerate_bitspersample)
	// allow room for THREE underscore chars + 2x17 bytes of string returned
	// from _itoa

	// NOTE: use wsprintf instead of itoa - because of dependency on runtime lib
	//Added 2 UINTs for video...
	lpszKeyName = (LPTSTR)LocalAlloc (LPTR, lstrlen(lpDriverName) * sizeof(*lpDriverName) +5*20);
	if (!lpszKeyName)
	{
		ERRORMESSAGE(("%s: LocalAlloc failed\r\n",_fx_));
        return(NULL);
    }
    // build a subkey name ("drivername_samplerate_bitspersample")
	wsprintf(lpszKeyName,
				"%s_%u_%u_%u_%u_%u",
				lpDriverName,
				uSampleRate,
				uBitsPerSample,
				uBitsPerSec,
				uWidth,
				uHeight);

	return (lpszKeyName);
}

VOID CMsivCapability::SortEncodeCaps(SortMode sortmode)
{
	UINT iSorted=0;
	UINT iInsert = 0;
	UINT iCache=0;
	UINT iTemp =0;
	BOOL bInsert;	
	VIDCAP_DETAILS *pDetails1, *pDetails2;
	
	if(!uNumLocalFormats)
		return;
	if(uNumLocalFormats ==1)
	{
		IDsByRank[0]=0;
		return;
	}
	
	// look at every cached format, build index array
	for(iCache=0;iCache<uNumLocalFormats;iCache++)
	{
		pDetails1 = pLocalFormats+iCache;
		for(iInsert=0;iInsert < iSorted; iInsert++)
		{
			pDetails2 = pLocalFormats+IDsByRank[iInsert];
			// if existing stuff is less than new stuff....
			
			bInsert = FALSE;
			switch(sortmode)
			{
				case SortByAppPref:
					if(pDetails2->wApplicationPrefOrder > pDetails1->wApplicationPrefOrder)
						bInsert = TRUE;
				break;
				default:
				break;
			}
			
			if(bInsert)
			{
				if(iSorted < MAX_CAPS_PRESORT)
				{
					iSorted++;
				}
				// make room, if there is something in the last element,
				// it gets overwritten
				for(iTemp = iSorted-1; iTemp > iInsert; iTemp--)
				{
					IDsByRank[iTemp] = IDsByRank[iTemp-1];
				}
				// insert at iInsert
				IDsByRank[iInsert] = iCache;
				break;
			}
		}
		// check end boundary
		if((iInsert == iSorted) && (iInsert < MAX_CAPS_PRESORT))
		{
			IDsByRank[iInsert] = iCache;
			iSorted++;
		}
	}
}

BOOL CMsivCapability::Init()
{
	BOOL bRet;
	if(uStaticRef == 0)
	{
		if(bRet = ReInit())
		{
			uStaticRef++;
		}
	}
	else
	{
		uStaticRef++;
		bRet = TRUE;
	}
	return bRet;
}

BOOL CMsivCapability::ReInit()
{
	DWORD dwDisposition;
	BOOL bRet = TRUE;
	//CVcmCapability::ReInit();	// base class ReInit MUST ALWAYS BE CALLED
	SYSTEM_INFO si;
	ZeroMemory(&IDsByRank, sizeof(IDsByRank));
	
	// LOOKLOOK - this supports a hack to disable CPU intensive codecs if not running on a pentium
	GetSystemInfo(&si);
	wMaxCPU = (si.dwProcessorType == PROCESSOR_INTEL_PENTIUM )? 100 : 95;
	


	UINT uNumRemoteDecodeFormats;	// # of entries for remote decode capabilities
	UINT uRemoteDecodeFormatCapacity;	// size of pRemoteDecodeFormats (in multiples of VIDCAP_DETAILS)

	if (pLocalFormats)
	{	
		UINT u;
		VIDCAP_DETAILS *pDetails = pLocalFormats;
		for(u=0; u <uNumLocalFormats; u++)
		{
			if(pDetails->lpLocalFormatDetails)
			{
				MEMFREE(pDetails->lpLocalFormatDetails);
			}
			// there really should never be remote details associated with the local
			// formats........
			if(pDetails->lpRemoteFormatDetails)
			{
				MEMFREE(pDetails->lpRemoteFormatDetails);
			}
			
			pDetails++;
		}
		MEMFREE(pLocalFormats);
		pLocalFormats = NULL;
		uLocalFormatCapacity = 0;
	}

	uNumLocalFormats = 0;
	uCapIDBase = 0;					
	uLocalFormatCapacity =0;	

	// m_pAppParam should be non-NULL only if we want to add a VCM format
	// and not for standard enumeration
	m_pAppParam = NULL;

	if(!FormatEnum(this, VCM_FORMATENUMF_APP))
	{
		bRet = FALSE;
		goto RELEASE_AND_EXIT;
	}
 	SortEncodeCaps(SortByAppPref);
RELEASE_AND_EXIT:
	return bRet;
}


STDMETHODIMP CMsivCapability::GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize)
{
	// validate input
	UINT uIndex = 	IDToIndex(FormatID);
	if(uIndex >= (UINT)uNumLocalFormats)
	{
		*puSize = 0;
		*ppFormat = NULL;
		return E_INVALIDARG;
	}

	*ppFormat = (pLocalFormats + uIndex)->lpLocalFormatDetails;
	*puSize = sizeof(VIDEOFORMATEX);
	return S_OK;

}

STDMETHODIMP CMsivCapability::GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize)
{
	// same as GetDecodeFormatDetails
	return GetDecodeFormatDetails(FormatID, ppFormat, puSize);
}

VOID CMsivCapability::CalculateFormatProperties(VIDCAP_DETAILS *pFmtBuf, PVIDEOFORMATEX lpvfx)
{
	if(!pFmtBuf)
	{
		return;
	}
	
	// Estimate input bit rate
	UINT uBitrateIn = lpvfx->nSamplesPerSec * WIDTHBYTES(lpvfx->bih.biWidth * lpvfx->bih.biBitCount) * lpvfx->bih.biHeight * 8;
		
	// set the maximum bitrate (uMaxBitrate). we're not setting the average bitrate (uAvgBitrate),
	// since the nAvgBytesPerSec reported by VCM is really worst case. uAvgBitrate will be set
	// from the hardcoded numbers for our known codecs and from the provided VIDCAP_INFO for
	// installable codecs
	pFmtBuf->uMaxBitrate = (lpvfx->nAvgBytesPerSec)? lpvfx->nAvgBytesPerSec*8:uBitrateIn;
	
}

VIDEO_FORMAT_ID CMsivCapability::AddFormat(VIDCAP_DETAILS *pFmtBuf,
	LPVOID lpvMappingData, UINT uSize)
{
	VIDCAP_DETAILS *pTemp;
	VIDEO_PARAMS *pVidCapInfo;
	UINT	 format;

	if(!pFmtBuf)
	{
		return INVALID_VIDEO_FORMAT;
	}
	// check room
	if(uLocalFormatCapacity <= uNumLocalFormats)
	{
		// get more mem, realloc memory by CAP_CHUNK_SIZE for pLocalFormats
		pTemp = (VIDCAP_DETAILS *)MEMALLOC((uNumLocalFormats + CAP_CHUNK_SIZE)*sizeof(VIDCAP_DETAILS));
		if(!pTemp)
			goto ERROR_EXIT;
		// remember how much capacity we now have
		uLocalFormatCapacity = uNumLocalFormats + CAP_CHUNK_SIZE;
		#ifdef DEBUG
		if((uNumLocalFormats && !pLocalFormats) || (!uNumLocalFormats && pLocalFormats))
		{
			ERRORMESSAGE(("AddFormat:leak! uNumLocalFormats:0x%08lX, pLocalFormats:0x%08lX\r\n", uNumLocalFormats,pLocalFormats));
		}
		#endif
		// copy old stuff, discard old mem
		if(uNumLocalFormats && pLocalFormats)
		{
			memcpy(pTemp, pLocalFormats, uNumLocalFormats*sizeof(VIDCAP_DETAILS));
			MEMFREE(pLocalFormats);
		}
		pLocalFormats = pTemp;
	}
	// pTemp is where the stuff is cached
	pTemp = pLocalFormats+uNumLocalFormats;
	memcpy(pTemp, pFmtBuf, sizeof(VIDCAP_DETAILS));	
	
	pTemp->uLocalDetailsSize = 0;	// clear this now
	if(uSize && lpvMappingData)
	{
		pTemp->lpLocalFormatDetails = MEMALLOC(uSize);
		if(pTemp->lpLocalFormatDetails)
		{
			memcpy(pTemp->lpLocalFormatDetails, lpvMappingData, uSize);
			pTemp->uLocalDetailsSize = uSize;
		}
		#ifdef DEBUG
			else
			{
				ERRORMESSAGE(("AddFormat:allocation failed!\r\n"));
			}
		#endif
	}
	else
	{

	}


	// LOOKLOOK NEED TO FIXUP channel parameters

	// pTemp->dwDefaultSamples
	// pTemp->nonstd_params.wFramesPerPkt
	// pTemp->nonstd_params.wFramesPerPktMax
	// pTemp->nonstd_params.wFramesPerPktMin
	// pTemp->nonstd_params.wDataRate
	// pTemp->nonstd_params.wFrameSize
	
	
	// fixup the H245 parameters.  Use the index of the cap entry as the cap ID
	pTemp->H245Cap.CapId = (USHORT)IndexToId(uNumLocalFormats);

	if(pTemp->H245Cap.ClientType ==0
				|| pTemp->H245Cap.ClientType ==H245_CLIENT_VID_NONSTD)
	{

			pTemp->H245Cap.Cap.H245Vid_NONSTD.nonStandardIdentifier.choice = h221NonStandard_chosen;
			// NOTE: there is some question about the correct byte order
			// of the codes in the h221NonStandard structure
			pTemp->H245Cap.Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode = USA_H221_COUNTRY_CODE;
			pTemp->H245Cap.Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension = USA_H221_COUNTRY_EXTENSION;
			pTemp->H245Cap.Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = MICROSOFT_H_221_MFG_CODE;
			// Set the nonstandard data fields to null for now. The nonstandard cap data will be
			// created when capabilities are serialized.
			
			pTemp->H245Cap.Cap.H245Vid_NONSTD.data.length = 0;
			pTemp->H245Cap.Cap.H245Vid_NONSTD.data.value = NULL;
	}
	else
	{
		switch  (pTemp->H245Cap.ClientType )
		{
			case H245_CLIENT_VID_H263: {

			   pVidCapInfo=&pTemp->video_params;

			   format=get_format (pVidCapInfo->biWidth,pVidCapInfo->biHeight);
			   switch (format) {	
				case SQCIF: {
				     pTemp->H245Cap.Cap.H245Vid_H263.bit_mask =H263VideoCapability_sqcifMPI_present;
				     //MPI minimum interval in units of 1/29.97sec so 30/ (frames/sec) is reasonable
				     pTemp->H245Cap.Cap.H245Vid_H263.sqcifMPI = 30/pVidCapInfo->uSamplesPerSec;
				     pTemp->H245Cap.Cap.H245Vid_H263.H263VdCpblty_qcifMPI =0;
				     pTemp->H245Cap.Cap.H245Vid_H263.H263VdCpblty_cifMPI =0;
				     break;
		

				}
				case QCIF: {
				     pTemp->H245Cap.Cap.H245Vid_H263.bit_mask =H263VideoCapability_qcifMPI_present;

				     pTemp->H245Cap.Cap.H245Vid_H263.sqcifMPI = 0;
				     pTemp->H245Cap.Cap.H245Vid_H263.H263VdCpblty_qcifMPI =30/pVidCapInfo->uSamplesPerSec;
				     pTemp->H245Cap.Cap.H245Vid_H263.H263VdCpblty_cifMPI =0;
				     break;

				}
				case CIF: {
				     pTemp->H245Cap.Cap.H245Vid_H263.bit_mask =H263VideoCapability_cifMPI_present;
				
				     pTemp->H245Cap.Cap.H245Vid_H263.sqcifMPI = 0;
				     pTemp->H245Cap.Cap.H245Vid_H263.H263VdCpblty_qcifMPI =0;
				     pTemp->H245Cap.Cap.H245Vid_H263.H263VdCpblty_cifMPI =30/pVidCapInfo->uSamplesPerSec;
				     break;
	
				}

				  default:
					 break;
			   }
				

			   pTemp->H245Cap.Cap.H245Vid_H263.cif4MPI	=0;
			   pTemp->H245Cap.Cap.H245Vid_H263.cif16MPI	=0;
			   pTemp->H245Cap.Cap.H245Vid_H263.maxBitRate	= pFmtBuf->uMaxBitrate / 100;	// in units of 100 bits/s
					
			   pTemp->H245Cap.Cap.H245Vid_H263.unrestrictedVector = FALSE;
			   pTemp->H245Cap.Cap.H245Vid_H263.arithmeticCoding 	= FALSE;
			   pTemp->H245Cap.Cap.H245Vid_H263.advancedPrediction	= FALSE;
			   pTemp->H245Cap.Cap.H245Vid_H263.pbFrames			= FALSE;
			   pTemp->H245Cap.Cap.H245Vid_H263.tmprlSptlTrdOffCpblty = FALSE;
			   pTemp->H245Cap.Cap.H245Vid_H263.hrd_B				= 0;
			   pTemp->H245Cap.Cap.H245Vid_H263.bppMaxKb			= 0;
/* Optional, and not supported		pTemp->H245Cap.Cap.H245Vid_H263.slowQcifMPI	=0;
			   pTemp->H245Cap.Cap.H245Vid_H263.slowSqcifMPI	=0;
			   pTemp->H245Cap.Cap.H245Vid_H263.slowCifMPI		=0;
			   pTemp->H245Cap.Cap.H245Vid_H263.slowCif4MPI	=0;
			   pTemp->H245Cap.Cap.H245Vid_H263.slowCif16MPI	=0;
*/
			   pTemp->H245Cap.Cap.H245Vid_H263.H263VCy_errrCmpnstn = TRUE;
		     break;
		    }
			case H245_CLIENT_VID_H261:
			   pVidCapInfo=&pTemp->video_params;

			   format=get_format (pVidCapInfo->biWidth,pVidCapInfo->biHeight);
			   switch (format) {	
				case QCIF: {
				     pTemp->H245Cap.Cap.H245Vid_H261.bit_mask =H261VdCpblty_qcifMPI_present;
				     pTemp->H245Cap.Cap.H245Vid_H261.H261VdCpblty_qcifMPI =max (1,min (4,30/pVidCapInfo->uSamplesPerSec));
				     pTemp->H245Cap.Cap.H245Vid_H261.H261VdCpblty_cifMPI =0;
				     break;
				}
				case CIF: {
				     pTemp->H245Cap.Cap.H245Vid_H261.bit_mask =H261VdCpblty_cifMPI_present;
				     pTemp->H245Cap.Cap.H245Vid_H261.H261VdCpblty_qcifMPI =0;
				     pTemp->H245Cap.Cap.H245Vid_H261.H261VdCpblty_cifMPI =max (1,min(4,30/pVidCapInfo->uSamplesPerSec));
				     break;
				}
				  default:
					 break;
			   }
				
			   pTemp->H245Cap.Cap.H245Vid_H261.maxBitRate	= pFmtBuf->uMaxBitrate / 100;	// in units of 100 bits/s
			   pTemp->H245Cap.Cap.H245Vid_H261.tmprlSptlTrdOffCpblty = FALSE;
			   pTemp->H245Cap.Cap.H245Vid_H261.stillImageTransmission = FALSE;
			break;

		}
	}		
	
	uNumLocalFormats++;
	return pTemp->H245Cap.CapId;

	ERROR_EXIT:
	return INVALID_VIDEO_FORMAT;
			
}
		
/***************************************************************************

    Name      : CMsivCapability::BuildFormatName

    Purpose   : Builds a format name for a format, from the format name and
				the tag name

    Parameters:	pVidcapDetails [out] - pointer to an VIDCAP_DETAILS structure, where the
					created value name will be stored
				pszDriverName [in] - pointer to the name of the driver
				pszFormatName [in] - pointer to name of the format

    Returns   : BOOL

    Comment   :

***************************************************************************/
BOOL CMsivCapability::BuildFormatName(	PVIDCAP_DETAILS pVidcapDetails,
										WCHAR *pszDriverName,
										WCHAR *pszFormatName)
{
	int iLen, iLen2;
	BOOL bRet=TRUE;
	char szTemp[260];

	if (!pVidcapDetails ||
		!pszDriverName	||
		!pszFormatName)
	{
		bRet = FALSE;
		goto out;
	}

	// concatenate VCM strings to form the first part of the registry key - the
	// format is szFormatTag (actually pVidcapDetails->szFormat)
	// (the string  which describes the format tag followed by szFormatDetails
	// (the string which describes parameters, e.g. sample rate)
	iLen2 = WideCharToMultiByte(GetACP(), 0, pszDriverName, -1, NULL, 0, NULL, NULL);
	WideCharToMultiByte(GetACP(), 0, pszDriverName, iLen2, szTemp, iLen2, NULL, NULL);
	lstrcpyn(pVidcapDetails->szFormat, szTemp, sizeof(pVidcapDetails->szFormat));
	iLen = lstrlen(pVidcapDetails->szFormat);

	// if the format tag description string takes up all the space, don't
	// bother with the format details (need space for ", " also).
	// we're going to say that if we don't have room for 4 characters
	// of the format details string + " ,", then it's not worth it if the
	// point is generating a unique string -if it is not unique by now, it
	// will be because some VCM driver writer was  misinformed
	if(iLen < (sizeof(pVidcapDetails->szFormat) + 8*sizeof(TCHAR)))
	{
		// ok to concatenate
		lstrcat(pVidcapDetails->szFormat,", ");
		// must check for truncation. so do the final concatenation via lstrcpyn
		// lstrcat(pFormatPrefsBuf->szFormat, pvfd->szFormat);
		iLen2 = WideCharToMultiByte(GetACP(), 0, pszFormatName, -1, NULL, 0, NULL, NULL);
		WideCharToMultiByte(GetACP(), 0, pszFormatName, iLen2, szTemp, iLen2, NULL, NULL);
		iLen = lstrlen(pVidcapDetails->szFormat);
		lstrcpyn(pVidcapDetails->szFormat+iLen, szTemp,
			sizeof(pVidcapDetails->szFormat) - iLen - sizeof(TCHAR));
	}		

out:
	return bRet;
}

/***************************************************************************

    Name      : CMsivCapability::GetFormatName

    Purpose   : Gets a driver and format info from VCM and builds a format name

    Parameters:	pVidcapDetails [out] - pointer to an VIDCAP_DETAILS structure, where the
					created value name will be stored
				pvfx [in] - pointer to the VIDEOFORMATEX structure for which we
					need the driver name and the format name

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsivCapability::GetFormatName(	PVIDCAP_DETAILS pVidcapDetails,
										PVIDEOFORMATEX pvfx)
{
	VCMDRIVERDETAILS vdd;
	VCMFORMATDETAILS vfd;
	HRESULT hr=NOERROR;

	// get the driver details info in order to build correct format name
	vdd.fccHandler = pvfx->dwFormatTag;
	if (vcmDriverDetails(&vdd) != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE(("CMsivCapability::GetFormatName: can't get the driver details\r\n"));
		hr = CAPS_E_NOMATCH;
		goto out;
	}

	// have the driver details. get the format details
	vfd.pvfx = pvfx;
	if (vcmFormatDetails(&vfd) != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE(("CMsivCapability::GetFormatName: can't get the format details\r\n"));
		hr = CAPS_E_NOMATCH;
		goto out;
	}

	// have the format details too. build the name to store in the registry
	if (!BuildFormatName(pVidcapDetails, vdd.szDescription, vfd.szFormat))
	{
		ERRORMESSAGE(("CMsivCapability::GetFormatName: can't build format name\r\n"));
		hr = CAPS_E_SYSTEM_ERROR;
		goto out;
	}

out:
	return hr;
}

BOOL CMsivCapability::FormatEnumHandler(HVCMDRIVERID hvdid,
    PVCMFORMATDETAILS pvfd, VCMDRIVERDETAILS *pvdd, DWORD_PTR dwInstance)
{
	CMsivCapability *pCapObject = (CMsivCapability *)dwInstance;
	VIDCAP_DETAILS vidcap_entry;
	UINT i;

	// evaluate the details
	if(IsFormatSpecified(pvfd->pvfx, pvfd, pvdd, &vidcap_entry))
	{
		DEBUGMSG(ZONE_VCM,("FormatEnumHandler: tag 0x%08X\r\n",
			pvfd->pvfx->dwFormatTag));
		DEBUGMSG(ZONE_VCM,("FormatEnumHandler: nSamplesPerSec 0x%08lX, nAvgBytesPerSec 0x%08lX,\r\n",
			pvfd->pvfx->nSamplesPerSec, pvfd->pvfx->nAvgBytesPerSec));
		DEBUGMSG(ZONE_VCM,("FormatEnumHandler: nBlockAlign 0x%08X, wBitsPerSample 0x%04X\r\n",
			pvfd->pvfx->nBlockAlign, pvfd->pvfx->wBitsPerSample));
		DEBUGMSG(ZONE_VCM,("FormatEnumHandler: szFormat %s,\r\n",
			 pvfd->szFormat));

	//	done inside IsFormatSpecified and/or whatever it calls
	//  CalculateFormatProperties(&audcap_details, pvfd->pvfx);
		i=AddFormat(&vidcap_entry, (LPVOID)pvfd->pvfx,
			(pvfd->pvfx) ? sizeof(VIDEOFORMATEX):0);	

		if (i != INVALID_VIDEO_FORMAT) {
		   //Set the Send/Recv Flags...
		   //This now needs to set bSendEnabled, and bRecvEnabled, according to pvfd->dwFlags
		   //So, we need to find the format, and update the flags accordingly.

		   //OUTPUT IS RECV!!!!
		   if (pvfd->dwFlags == VCM_FORMATENUMF_BOTH) {
		      pLocalFormats[i].bSendEnabled=TRUE;
		      pLocalFormats[i].bRecvEnabled=TRUE;
		   }else {
		      if(pvfd->dwFlags == VCM_FORMATENUMF_OUTPUT) {
			 pLocalFormats[i].bSendEnabled=FALSE;
			 pLocalFormats[i].bRecvEnabled=TRUE;
		      } else {
			 pLocalFormats[i].bSendEnabled=TRUE;
			 pLocalFormats[i].bRecvEnabled=FALSE;
		      }
		   }
		}
	}
	
	return TRUE;
}


BOOL CMsivCapability::IsFormatSpecified(PVIDEOFORMATEX lpFormat,  PVCMFORMATDETAILS pvfd,
	VCMDRIVERDETAILS *pvdd,	VIDCAP_DETAILS *pVidcapDetails)
{
	VIDCAP_DETAILS *pcap_entry;
	BOOL bRet = FALSE;
	LPTSTR lpszKeyName = NULL;
	DWORD dwRes;
	UINT i;
	
	if(!lpFormat || !pVidcapDetails)
	{
		return FALSE;
	}
		
	RtlZeroMemory((PVOID) pVidcapDetails, sizeof(VIDCAP_DETAILS));
	
	// fixup the VIDEOFORMAT fields of video_params so that the key name can be built
	pVidcapDetails->video_params.uSamplesPerSec = lpFormat->nSamplesPerSec;
	pVidcapDetails->video_params.uBitsPerSample = MAKELONG(lpFormat->bih.biBitCount,0);
	pVidcapDetails->video_params.biWidth=lpFormat->bih.biWidth;
	pVidcapDetails->video_params.biHeight=lpFormat->bih.biHeight;
	pVidcapDetails->uMaxBitrate=lpFormat->nAvgBytesPerSec * 8;
	
	// build the name of the format out of the driver and the VCM format name
	if ((!pvdd)	||
		!BuildFormatName(pVidcapDetails, pvdd->szDescription, pvfd->szFormat))
	{
		ERRORMESSAGE(("IsFormatSpecified: Coludn't build format name\r\n"));
		return(FALSE);
	}

	lpszKeyName = AllocRegistryKeyName(	pVidcapDetails->szFormat,
										pVidcapDetails->video_params.uSamplesPerSec,
										pVidcapDetails->video_params.uBitsPerSample,
										pVidcapDetails->uMaxBitrate,
										pVidcapDetails->video_params.biWidth,
										pVidcapDetails->video_params.biHeight);
	if (!lpszKeyName)
	{
		ERRORMESSAGE(("IsFormatSpecified: Alloc failed\r\n"));
	    return(FALSE);
    }

	RegEntry reVidCaps(szRegInternetPhone TEXT("\\") szRegInternetPhoneVCMEncodings,
						HKEY_LOCAL_MACHINE,
						FALSE,
						KEY_READ);

	dwRes = reVidCaps.GetBinary(lpszKeyName, (PVOID *) &pcap_entry);

	// use current registry setting if it exists
	if(dwRes && (dwRes == sizeof(VIDCAP_DETAILS)))
	{
		// do a quick sanity check on the contents
		if((lpFormat->dwFormatTag == pcap_entry->dwFormatTag)
			&& (lpFormat->nSamplesPerSec == (DWORD)pcap_entry->video_params.uSamplesPerSec)
			&& (lpFormat->wBitsPerSample == LOWORD(pcap_entry->video_params.uBitsPerSample))
			&& (lpFormat->bih.biWidth == (LONG) pcap_entry->video_params.biWidth)
			&& (lpFormat->bih.biHeight == (LONG) pcap_entry->video_params.biHeight))
		{
			CopyMemory(pVidcapDetails, pcap_entry, sizeof(VIDCAP_DETAILS));
			bRet = TRUE;
		}
	}
	else	// check the static default table, and recreate the default entries
	{
		for(i=0;i< uDefVidTableEntries; i++)
		{
		   if((lpFormat->dwFormatTag == default_vid_table[i].dwFormatTag)
			  && (lpFormat->nSamplesPerSec == (DWORD)default_vid_table[i].video_params.uSamplesPerSec)
			  && (lpFormat->wBitsPerSample == LOWORD(default_vid_table[i].video_params.uBitsPerSample))
			  && (lpFormat->bih.biWidth == (LONG) default_vid_table[i].video_params.biWidth)
			  && (lpFormat->bih.biHeight == (LONG) default_vid_table[i].video_params.biHeight))
			  {
				// found matching default entry - copy stuff from table
				// (but don't overwrite the string)
				memcpy(pVidcapDetails, &default_vid_table[i],
					sizeof(VIDCAP_DETAILS) - sizeof(pVidcapDetails->szFormat));

				// LOOKLOOK - test against CPU limitations.
				// this supports a hack to disable CPU intensive codecs if not running
				//on a pentium
				if(default_vid_table[i].wCPUUtilizationEncode > wMaxCPU)
				{					
					pVidcapDetails->bSendEnabled = FALSE;
					pVidcapDetails->bRecvEnabled = FALSE;		
				}			
				
				// add this to the registry
				CalculateFormatProperties(pVidcapDetails, lpFormat);
				bRet = UpdateFormatInRegistry(pVidcapDetails);
				break;
			}
		}
	}

	if (lpszKeyName)
    {
		FreeRegistryKeyName(lpszKeyName);
    }
    return(bRet);
}


/***************************************************************************

    Name      : CMsivCapability::CopyVidcapInfo

    Purpose   : Copies basic video info from an VIDCAP_INFO structure to an
				VIDCAP_DETAILS structure, or vice versa. VIDCAP_INFO is external
				representation. VIDCAP_DETAILS is internal one.

    Parameters:	pDetails - pointer to an VIDCAP_DETAILS structure
				pInfo - pointer to an VIDCAP_INFO structure
				bDirection - 0 = ->, 1 = <-

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsivCapability::CopyVidcapInfo(PVIDCAP_DETAILS pDetails,
										PVIDCAP_INFO pInfo,
										BOOL bDirection)
{
	WORD wSortIndex;
	VIDEO_FORMAT_ID Id;
	UINT uIndex;	
	HRESULT hr=NOERROR;

	if(!pInfo || !pDetails)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}

	if (bDirection)
	{
		// VIDCAP_INFO -> VIDCAP_DETAILS

		// the caller cannot modify szFormat, Id, wSortIndex and uMaxBitrate, all calculated fields
		// nAvgBitrate can be provided, but will be overriden if the codec provided a non-zero
		// value in the VIDEOFORMATEX structure

		pDetails->dwFormatTag = pInfo->dwFormatTag;
		pDetails->uAvgBitrate = pInfo->uAvgBitrate;
		pDetails->wCPUUtilizationEncode	= pInfo->wCPUUtilizationEncode;
		pDetails->wCPUUtilizationDecode	= pInfo->wCPUUtilizationDecode;
		pDetails->bSendEnabled =  pInfo->bSendEnabled;
		pDetails->bRecvEnabled = pInfo->bRecvEnabled;
		pDetails->video_params.enumVideoSize = pInfo->enumVideoSize;
		pDetails->video_params.biHeight = pInfo->bih.biHeight;
		pDetails->video_params.biWidth  = pInfo->bih.biWidth;
		// lpLocalFormatDetails is updated in AddFormat
// DO NOT overwrite any of the fields used to construct the regkey name		
//		pDetails->video_params.uSamplesPerSec = pInfo->uFrameRate;
		pDetails->video_params.uBitsPerSample = pInfo->dwBitsPerSample;

		//Re-adjust to frame rate. MPI is Interval in units of 1/29.97 seconds
		//No div by zero error
		pInfo->uFrameRate= max(1,pInfo->uFrameRate);
		pDetails->nonstd_params.MPI = 30/pInfo->uFrameRate;
	}
	else
	{
		// VIDCAP_DETAILS -> VIDCAP_INFO	
		PVIDEOFORMATEX pvfx = (PVIDEOFORMATEX) pDetails->lpLocalFormatDetails;

		// find the sort index.
		uIndex = (UINT)(pDetails - pLocalFormats);
		Id = IndexToId(uIndex);
		for(wSortIndex=0; wSortIndex<uNumLocalFormats && wSortIndex < MAX_CAPS_PRESORT; wSortIndex++)
		{
			if (uIndex == IDsByRank[wSortIndex])
				break; // found it
		}
		// note:  recall that only  MAX_CAPS_PRESORT are sorted and the rest are in random order.
		// the rest all have a value of MAX_CAPS_PRESORT for the sort index
			
		pInfo->dwFormatTag = pDetails->dwFormatTag;	
		pInfo->Id = Id;
		memcpy(pInfo->szFormat, pDetails->szFormat, sizeof(pInfo->szFormat));
		pInfo->wCPUUtilizationEncode = pDetails->wCPUUtilizationEncode;
		pInfo->wCPUUtilizationDecode = pDetails->wCPUUtilizationDecode;
		pInfo->bSendEnabled =  pDetails->bSendEnabled;
		pInfo->bRecvEnabled = pDetails->bRecvEnabled;
		pInfo->wSortIndex = wSortIndex;
		pInfo->enumVideoSize = pDetails->video_params.enumVideoSize;
		if (pvfx)
			RtlCopyMemory(&pInfo->bih, &pvfx->bih, sizeof(BITMAPINFOHEADER));
		//The h.323 nonstd params for bitrate is in units of 100 bits/sec
		pInfo->dwBitsPerSample = pDetails->video_params.uBitsPerSample;
		pInfo->uAvgBitrate = pDetails->uAvgBitrate;
		pInfo->uMaxBitrate = pDetails->nonstd_params.maxBitRate*100;

		//Re-adjust to frame rate. MPI is Interval in units of 1/29.97 seconds
		//No div by zero error
		pDetails->nonstd_params.MPI= max(1,pDetails->nonstd_params.MPI);
		pInfo->uFrameRate =  min(30,30/pDetails->nonstd_params.MPI);
	}

out:
	return hr;
}



HRESULT CMsivCapability::EnumCommonFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut, BOOL bTXCaps)
{
	UINT u, uNumOut = 0;;
	HRESULT hr = hrSuccess;
	VIDCAP_DETAILS *pDetails = pLocalFormats;
	MEDIA_FORMAT_ID FormatIDRemote;
	HRESULT hrIsCommon;
	
	// validate input
	if(!pFmtBuf || !uNumFmtOut || (uBufsize < (sizeof(BASIC_VIDCAP_INFO)*uNumLocalFormats)))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pDetails)
	{
		return CAPS_E_NOCAPS;
	}

	// temporary - enumerating requestable receive formats is not yet supported
	if(!bTXCaps)
		return CAPS_E_NOT_SUPPORTED;
		
	for(u=0; (u <uNumLocalFormats) && (u <MAX_CAPS_PRESORT); u++)
	{
		pDetails = pLocalFormats + IDsByRank[u];	
		// if there is a session, then return formats that are common to local and remote.
		if(uNumRemoteDecodeFormats)
		{
			hrIsCommon = ResolveToLocalFormat(IndexToId(IDsByRank[u]), &FormatIDRemote);
			if(HR_SUCCEEDED(hrIsCommon))	
			{
				hr = CopyVidcapInfo (pDetails, pFmtBuf, 0);	
				if(!HR_SUCCEEDED(hr))	
					goto EXIT;
				uNumOut++;
				pFmtBuf++;
			}
		}
		else	// no remote capabilities exist because there is no current session
		{
			hr = CAPS_E_NOCAPS;
		}
	}

	*uNumFmtOut = uNumOut;
EXIT:
	return hr;
}

HRESULT CMsivCapability::EnumFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut)
{
	UINT u;
	HRESULT hr = hrSuccess;
	VIDCAP_DETAILS *pDetails = pLocalFormats;
	
	// validate input
	if(!pFmtBuf || !uNumFmtOut || (uBufsize < (sizeof(BASIC_VIDCAP_INFO)*uNumLocalFormats)))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pDetails)
	{
		return CAPS_E_NOCAPS;
	}

	for(u=0; (u <uNumLocalFormats) && (u <MAX_CAPS_PRESORT); u++)
	{
		pDetails = pLocalFormats + IDsByRank[u];	
		hr = CopyVidcapInfo (pDetails, pFmtBuf, 0);	
		if(!HR_SUCCEEDED(hr))	
			goto EXIT;
		pFmtBuf++;
	}

	*uNumFmtOut = min(uNumLocalFormats, MAX_CAPS_PRESORT);
EXIT:
	return hr;
}

HRESULT CMsivCapability::GetBasicVidcapInfo (VIDEO_FORMAT_ID Id, PBASIC_VIDCAP_INFO pFormatPrefsBuf)
{
	VIDCAP_DETAILS *pFmt;
	UINT uIndex = IDToIndex(Id);
	if(!pFormatPrefsBuf || (uNumLocalFormats <= uIndex))
	{
		return CAPS_E_INVALID_PARAM;
	}
	pFmt = pLocalFormats + uIndex;

	return (CopyVidcapInfo(pFmt,pFormatPrefsBuf,0));
}

HRESULT CMsivCapability::ApplyAppFormatPrefs (PBASIC_VIDCAP_INFO pFormatPrefsBuf,
	UINT uNumFormatPrefs)
{
	FX_ENTRY ("CMsivCapability::ApplyAppFormatPrefs");
	UINT u, v;
	PBASIC_VIDCAP_INFO pTemp;
	VIDCAP_DETAILS *pFmt;

	if(!pFormatPrefsBuf || (uNumLocalFormats != uNumFormatPrefs))
	{
		ERRORMESSAGE(("%s invalid param: pFbuf:0x%08lx, uNumIN:%d, uNum:%d\r\n",
			_fx_, pFormatPrefsBuf, uNumFormatPrefs, uNumLocalFormats));
		return CAPS_E_INVALID_PARAM;
	}
	
	// validate
	for(u=0; u <uNumLocalFormats; u++)
	{
		pTemp =  pFormatPrefsBuf+u;
		// make sure that the format ID is real
		if(IDToIndex(pTemp->Id) >= uNumLocalFormats)
		{
			return CAPS_E_INVALID_PARAM;
		}
		// look for bad sort indices, duplicate sort indices and duplicate format IDs
		if(pTemp->wSortIndex >= uNumLocalFormats)
			return CAPS_E_INVALID_PARAM;
			
		for(v=u+1; v <uNumLocalFormats; v++)
		{
			if((pTemp->wSortIndex == pFormatPrefsBuf[v].wSortIndex)
				|| (pTemp->Id == pFormatPrefsBuf[v].Id))
			{
			ERRORMESSAGE(("%s invalid param: wSI1:0x%04x, wSI2:0x%04x, ID1:%d, ID2:%d\r\n",
			_fx_, pTemp->wSortIndex, pFormatPrefsBuf[v].wSortIndex, pTemp->Id,
			pFormatPrefsBuf[v].Id));
				return CAPS_E_INVALID_PARAM;
			}
		}
	}
	// all seems well
	for(u=0; u <uNumLocalFormats; u++)
	{
		pTemp =  pFormatPrefsBuf+u;			// next entry of the input
		pFmt = pLocalFormats + IDToIndex(pTemp->Id);	// identifies this local format

		// apply the new sort order
		pFmt->wApplicationPrefOrder = pTemp->wSortIndex;
		// update the updatable parameters (CPU utilization, bitrate)
		pFmt->bSendEnabled = pTemp->bSendEnabled;
		pFmt->bRecvEnabled	= pTemp->bRecvEnabled;
// DO NOT overwrite any of the fields used to construct the regkey name		
//		pFmt->video_params.uSamplesPerSec = pTemp->uFrameRate;
		//Units of 100 bits/sec
		pFmt->nonstd_params.maxBitRate= (pTemp->uMaxBitrate/100);
//		pFmt->nonstd_params.maxBPP= 0;

		pFmt->nonstd_params.MPI= 30/max(pTemp->uFrameRate, 1);
		
		// only the tuning wizard or other profiling app can write wCPUUtilizationEncode,
		// wCPUUtilizationDecode, uAvgBitrate
		
		// update the registry
		UpdateFormatInRegistry(pFmt);
		
		// now update the sort order contained in VIDsByRank
		// note:  recall that only  MAX_CAPS_PRESORT are sorted and the rest are in random order.
		// LOOKLOOK - maybe need a separate sort order array? - the order in VIDsByRank
		// is being overriden here
		// the array holds the sorted indices into the array of formats in pLocalFormats
		if(pTemp->wSortIndex < MAX_CAPS_PRESORT)
		{
			// insert the format at the position indicated by the input
			IDsByRank[pTemp->wSortIndex] = (MEDIA_FORMAT_ID)(pFmt - pLocalFormats);
		}
		
	}



	return hrSuccess;
}

		// update the registry
BOOL CMsivCapability::UpdateFormatInRegistry(VIDCAP_DETAILS *pVidcapDetails)
{

	FX_ENTRY(("CMsivCapability::UpdateFormatInRegistry"));
	LPTSTR lpszKeyName = NULL;
	BOOL bRet;
	if(!pVidcapDetails)
	{
		return FALSE;
	}	

	lpszKeyName = AllocRegistryKeyName(	pVidcapDetails->szFormat,
										pVidcapDetails->video_params.uSamplesPerSec,
										pVidcapDetails->video_params.uBitsPerSample,
										pVidcapDetails->uMaxBitrate,
										pVidcapDetails->video_params.biWidth,
										pVidcapDetails->video_params.biHeight);
	if (!lpszKeyName)
	{
		ERRORMESSAGE(("%s:Alloc failed\r\n",_fx_));
        return(FALSE);
    }

	DEBUGMSG(ZONE_VCM,("%s:updating %s, wPref:0x%04x, bS:%d, bR:%d\r\n",
			_fx_, lpszKeyName, pVidcapDetails->wApplicationPrefOrder,
			pVidcapDetails->bSendEnabled, pVidcapDetails->bRecvEnabled));
	// add this to the registry
	RegEntry reVidCaps(szRegInternetPhone TEXT("\\") szRegInternetPhoneVCMEncodings,
						HKEY_LOCAL_MACHINE);

	bRet = (ERROR_SUCCESS == reVidCaps.SetValue(lpszKeyName,
												pVidcapDetails,
												sizeof(VIDCAP_DETAILS)));
							
	FreeRegistryKeyName(lpszKeyName);
    return(bRet);				
}


/***************************************************************************

    Name      : CMsivCapability::AddVCMFormat

    Purpose   : Adds an VCM format to the list of formats we support

    Parameters:	pvfx - pointer to the videoformat structure for the added codec
				pVidcapInfo - additional format info that is not in the videoformat
					structure

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsivCapability::AddVCMFormat (PVIDEOFORMATEX pvfx, PVIDCAP_INFO pVidcapInfo)
{
	HRESULT hr = hrSuccess;
	// initialize cap entry with default values
	VIDCAP_DETAILS cap_entry =
		{VIDEO_FORMAT_UNKNOWN, NONSTD_VID_TERMCAP,STD_VID_PARAMS,
		{RTP_DYNAMIC_MIN+1,  0, 30, 7680, Small, 0, 0},0,
		TRUE, TRUE,
		1, 				// default number of samples per packet
		245760*8,	// default to 16kbs bitrate
		245760*8, 					// unknown average bitrate
		10, 10,	// default CPU utilization
		PREF_ORDER_UNASSIGNED,	// unassigned sort order
		0,NULL,0,NULL,
		""};
		
	if(!pvfx || !pVidcapInfo)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}	

	/*
	 *	Build the VIDCAP_DETAILS structure for this format
	 */

	// now add VIDCAP_INFO information
	CopyVidcapInfo(&cap_entry, pVidcapInfo, 1);

	// calculate whatever parameters can be calculated
	// use actual bits per sample unless the bps field is zero, in which case
	// assume 16 bits (worst case).
	CalculateFormatProperties(&cap_entry, pvfx);

	// Make sure it's an upper case FourCC
	if (cap_entry.dwFormatTag > 256)
		CharUpperBuff((LPTSTR)&cap_entry.dwFormatTag, sizeof(DWORD));

	// set the RTP payload number. We are using a random number from the dynamic range
	// for the installable codecs
	cap_entry.video_params.RTPPayload = RTP_DYNAMIC_MIN+1;

	// get the format name and driver name for this format from VCM and
	// build a format name to add to the registry
	hr = GetFormatName(&cap_entry, pvfx);
	if (FAILED(hr))
		goto out;

	// add this to the registry
	if(!UpdateFormatInRegistry(&cap_entry))
	{
		ERRORMESSAGE(("CMsivCapability::AddVCMFormat: can't update registry\r\n"));
		hr = CAPS_E_SYSTEM_ERROR;
		goto out;
	}

	// reinit to update the list of local formats
    if (!ReInit())
	{
		hr = CAPS_E_SYSTEM_ERROR;
   		goto out;
	}

out:
	return hr;
}

/***************************************************************************

    Name      : CMsivCapability::RemoveVCMFormat

    Purpose   : Removes an VCM format to the list of formats we support

    Parameters:	pvfx - pointer to the videoformat structure for the added codec

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsivCapability::RemoveVCMFormat (PVIDEOFORMATEX pvfx)
{
	HRESULT hr = hrSuccess;
    HKEY hKey = NULL;
	LPTSTR lpszValueName = NULL;
    DWORD dwErr;
	VIDCAP_DETAILS cap_entry;
	
	if(!pvfx)
	{
		return CAPS_E_INVALID_PARAM;
	}	

	// get the format name and driver name for this format from VCM and
	// build a format name to add to the registry
	hr = GetFormatName(&cap_entry, pvfx);
	if (FAILED(hr))
		goto out;

	lpszValueName = AllocRegistryKeyName(cap_entry.szFormat,
										pvfx->nSamplesPerSec,
										MAKELONG(pvfx->wBitsPerSample,0),
										pvfx->nAvgBytesPerSec*8,
										pvfx->bih.biWidth,
										pvfx->bih.biHeight);
	if (!lpszValueName)
	{
		ERRORMESSAGE(("CMsivCapability::RemoveVCMFormat: Alloc failed\r\n"));
	    hr = CAPS_E_SYSTEM_ERROR;
	    goto out;
    }

	// Get the key handle
    if (dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					szRegInternetPhone TEXT("\\") szRegInternetPhoneVCMEncodings,
					0, KEY_ALL_ACCESS, &hKey))
	{
		ERRORMESSAGE(("CMsivCapability::RemoveVCMFormat: can't open key to delete\r\n"));
	    hr = CAPS_E_SYSTEM_ERROR;
	    goto out;
    }

	dwErr = RegDeleteValue(hKey, lpszValueName );	
	if(dwErr != ERROR_SUCCESS)
	{
		hr = CAPS_E_SYSTEM_ERROR;
		goto out;
	}

	// reinit to update the list of local formats
    if (!ReInit())
	{
		hr = CAPS_E_SYSTEM_ERROR;
   		goto out;
	}

out:
    if (hKey)
        RegCloseKey(hKey);
	if(lpszValueName)
		MEMFREE(lpszValueName);		
	return hr;
}
UINT CMsivCapability::GetLocalSendParamSize(MEDIA_FORMAT_ID dwID)
{
	return (sizeof(VIDEO_CHANNEL_PARAMETERS));
}
UINT CMsivCapability::GetLocalRecvParamSize(PCC_TERMCAP pCapability)
{
	return (sizeof(VIDEO_CHANNEL_PARAMETERS));
}

HRESULT CMsivCapability::CreateCapList(LPVOID *ppCapBuf)
{
	HRESULT hr = hrSuccess;
	UINT u;
	VIDCAP_DETAILS *pDecodeDetails = pLocalFormats;
	PCC_TERMCAPLIST   pTermCapList = NULL;
	PPCC_TERMCAP  ppCCThisTermCap = NULL;
	PCC_TERMCAP  pCCThisCap = NULL;
	PNSC_VIDEO_CAPABILITY pNSCapNext = NULL;
	PVIDEOFORMATEX lpvcd;
	VIDEO_PARAMS  	*pVidCapInfo;
	UINT format;
	FX_ENTRY ("CreateCapList");
	// validate input
	if(!ppCapBuf)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto ERROR_OUT;
	}
	*ppCapBuf = NULL;
	if(!uNumLocalFormats || !pDecodeDetails)
	{
		hr = CAPS_E_NOCAPS;
		goto ERROR_OUT;
	}

	pTermCapList = (PCC_TERMCAPLIST)MemAlloc(sizeof(CC_TERMCAPLIST));
	if(!pTermCapList)
	{
		hr = CAPS_E_NOMEM;
		goto ERROR_OUT;		
	}
	ppCCThisTermCap = (PPCC_TERMCAP)MemAlloc(uNumLocalFormats * sizeof(PCC_TERMCAP));
	if(!ppCCThisTermCap)
	{
		hr = CAPS_E_NOMEM;
		goto ERROR_OUT;		
	}
	pTermCapList->wLength = 0;
	// point the CC_TERMCAPLIST pTermCapArray at the array of PCC_TERMCAP
	pTermCapList->pTermCapArray = ppCCThisTermCap;
	/*
					CC_TERMCAPLIST       PCC_TERMCAP        CC_TERMCAP

  pTermCapList->    {
						wLength
						pTermCapArray--->pTermCap----------->{single capability.....}
					}
										pTermCap----------->{single capability.}
			
										pTermCap----------->{single capability...}

    */

	for(u=0; u <uNumLocalFormats; u++)
	{
		// check if enabled for receive, skip if false
		// also skip if public version of capabilities is to be advertised via a
		// separate local capability entry
		if((!pDecodeDetails->bRecvEnabled ) || (pDecodeDetails->dwPublicRefIndex))
		{
			pDecodeDetails++;
			continue;
		}

		if(pDecodeDetails->H245Cap.ClientType ==0
				|| pDecodeDetails->H245Cap.ClientType ==H245_CLIENT_VID_NONSTD)
		{

			lpvcd = (PVIDEOFORMATEX)pDecodeDetails->lpLocalFormatDetails;
			if(!lpvcd)
			{	
				pDecodeDetails++;
				continue;
			}
			// allocate for this one capability
			pCCThisCap = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP));		
			pNSCapNext = (PNSC_VIDEO_CAPABILITY)MemAlloc(sizeof(NSC_VIDEO_CAPABILITY));
				
			if((!pCCThisCap)|| (!pNSCapNext))
			{
				hr = CAPS_E_NOMEM;
				goto ERROR_OUT;		
			}
			// set type of nonstandard capability
			pNSCapNext->cvp_type = NSC_VCM_VIDEOFORMATEX;
			// stuff both chunks of nonstandard capability info into buffer
			// first stuff the "channel parameters" (the format independent communication options)
			memcpy(&pNSCapNext->cvp_params, &pDecodeDetails->nonstd_params, sizeof(NSC_CHANNEL_VIDEO_PARAMETERS));
			
			// then the VCM stuff
			memcpy(&pNSCapNext->cvp_data.vfx, lpvcd, sizeof(VIDEOFORMATEX));

			pCCThisCap->ClientType = H245_CLIENT_VID_NONSTD;
			pCCThisCap->DataType = H245_DATA_VIDEO;
			pCCThisCap->Dir = (pDecodeDetails->bSendEnabled && bPublicizeTXCaps)
				? H245_CAPDIR_LCLRXTX :H245_CAPDIR_LCLRX;

			// LOOKLOOK use the index of the cap entry as the ID
			// The ID is already preset in local formats by AddCapabilityBase()
			// pCCThisCap->CapId = (USHORT)IndexToId(u);
			pCCThisCap->CapId = pDecodeDetails->H245Cap.CapId;

			// all nonstandard identifier fields are unsigned short
			// two possibilities for choice are "h221NonStandard_chosen" and "object_chosen"
			pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.choice = h221NonStandard_chosen;
			// NOTE: there is some question about the correct byte order
			// of the codes in the h221NonStandard structure
			pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode = USA_H221_COUNTRY_CODE;
			pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension = USA_H221_COUNTRY_EXTENSION;
			pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = MICROSOFT_H_221_MFG_CODE;


			// set size of buffer
			pCCThisCap->Cap.H245Vid_NONSTD.data.length = sizeof(NSC_VIDEO_CAPABILITY) - BMIH_SLOP_BYTES;
			pCCThisCap->Cap.H245Vid_NONSTD.data.value = (BYTE *)pNSCapNext;	// point to nonstandard stuff

			// pNSCapNext is now referenced by the pTermCapList and will
			// be cleaned up via DeleteCapList(). Null the ptr so that error cleanup
			// won't try redundant cleanup.
			pNSCapNext = NULL;
		}
		else
		{
			// allocate for this one capability
			pCCThisCap = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP));		
			if(!pCCThisCap)
			{
				hr = CAPS_E_NOMEM;
				goto ERROR_OUT;		
			}
			
			pCCThisCap->ClientType = (H245_CLIENT_T)pDecodeDetails->H245Cap.ClientType;
			pCCThisCap->DataType = H245_DATA_VIDEO;
			pCCThisCap->Dir = H245_CAPDIR_LCLRX;  // should this be H245_CAPDIR_LCLRX for receive caps?
			pCCThisCap->CapId = pDecodeDetails->H245Cap.CapId;
			pVidCapInfo=&pDecodeDetails->video_params;
			switch  (pCCThisCap->ClientType )
			{
  				case H245_CLIENT_VID_H263:

  				#pragma message ("Collapse H.263 formats")
				// refer to the hack that sets H245Vid_H263 parameters
				// when formats are enumerated.  if that was always done right, then
				// all that needs to happen here is collapsing
  			
  				// This is where the formats need to collapse. H.263 probably
  				// should not be collapsed into 1 format.  Given M specific local
  				// formats, collapse into N.

			       format=get_format (pVidCapInfo->biWidth,pVidCapInfo->biHeight);
			       switch (format) {	
				     case SQCIF: {
					   pCCThisCap->Cap.H245Vid_H263.bit_mask =H263VideoCapability_sqcifMPI_present;
					   //MPI minimum interval in units of 1/29.97sec so 30/ (frames/sec) is reasonable
					   pCCThisCap->Cap.H245Vid_H263.sqcifMPI = max (1,pDecodeDetails->nonstd_params.MPI); //30/pVidCapInfo->uSamplesPerSec;
					   pCCThisCap->Cap.H245Vid_H263.H263VdCpblty_qcifMPI =0;
					   pCCThisCap->Cap.H245Vid_H263.H263VdCpblty_cifMPI =0;
					   break;
		

				     }
				     case QCIF: {
					   pCCThisCap->Cap.H245Vid_H263.bit_mask =H263VideoCapability_qcifMPI_present;

					   pCCThisCap->Cap.H245Vid_H263.sqcifMPI = 0;
					   pCCThisCap->Cap.H245Vid_H263.H263VdCpblty_qcifMPI =max (1,pDecodeDetails->nonstd_params.MPI);//30/pVidCapInfo->uSamplesPerSec; ;;
					   pCCThisCap->Cap.H245Vid_H263.H263VdCpblty_cifMPI =0;
					   break;

				     }
				     case CIF: {
					   pCCThisCap->Cap.H245Vid_H263.bit_mask =H263VideoCapability_cifMPI_present;
				
					   pCCThisCap->Cap.H245Vid_H263.sqcifMPI = 0;
					   pCCThisCap->Cap.H245Vid_H263.H263VdCpblty_qcifMPI =0;
					   pCCThisCap->Cap.H245Vid_H263.H263VdCpblty_cifMPI = max (1,pDecodeDetails->nonstd_params.MPI);//30/pVidCapInfo->uSamplesPerSec;
					   break;
	
				     }
					  default:
						 break;


			       }
				

			       pCCThisCap->Cap.H245Vid_H263.cif4MPI	=0;
			       pCCThisCap->Cap.H245Vid_H263.cif16MPI	=0;
			       pCCThisCap->Cap.H245Vid_H263.maxBitRate	=
			                       pDecodeDetails->nonstd_params.maxBitRate;
					
			       pCCThisCap->Cap.H245Vid_H263.unrestrictedVector = FALSE;
			       pCCThisCap->Cap.H245Vid_H263.arithmeticCoding 	= FALSE;
			       pCCThisCap->Cap.H245Vid_H263.advancedPrediction	= FALSE;
			       pCCThisCap->Cap.H245Vid_H263.pbFrames			= FALSE;
			       pCCThisCap->Cap.H245Vid_H263.tmprlSptlTrdOffCpblty = (ASN1bool_t)bPublicizeTSTradeoff;
			       pCCThisCap->Cap.H245Vid_H263.hrd_B				= 0;
			       pCCThisCap->Cap.H245Vid_H263.bppMaxKb	=
				    pDecodeDetails->nonstd_params.maxBPP;

/* Optional, and not supported		pCCThisCap->Cap.H245Vid_H263.slowQcifMPI	=0;
			       pCCThisCap->Cap.H245Vid_H263.slowSqcifMPI	=0;
			       pCCThisCap->Cap.H245Vid_H263.slowCifMPI		=0;
			       pCCThisCap->Cap.H245Vid_H263.slowCif4MPI	=0;
			       pCCThisCap->Cap.H245Vid_H263.slowCif16MPI	=0;
*/
			       pCCThisCap->Cap.H245Vid_H263.H263VCy_errrCmpnstn = TRUE;
			       break;
				
				case H245_CLIENT_VID_H261:

  				#pragma message ("Collapse H.261 formats")
				// refer to the hack that sets H245Vid_H261 parameters
				// when formats are enumerated.  if that was always done right, then
				// all that needs to happen here is collapsing
  			
  				// This is where the formats need to collapse. H.261 probably
  				// should not be collapsed into 1 format.  Given M specific local
  				// formats, collapse into N.

			       format=get_format (pVidCapInfo->biWidth,pVidCapInfo->biHeight);
			       switch (format) {	
				     case QCIF: {
					   pCCThisCap->Cap.H245Vid_H261.bit_mask =H261VdCpblty_qcifMPI_present;
					   pCCThisCap->Cap.H245Vid_H261.H261VdCpblty_qcifMPI =max (1,min(4,pDecodeDetails->nonstd_params.MPI));//30/pVidCapInfo->uSamplesPerSec; ;;
					   pCCThisCap->Cap.H245Vid_H261.H261VdCpblty_cifMPI =0;
					   break;
				     }
				     case CIF: {
					   pCCThisCap->Cap.H245Vid_H261.bit_mask =H261VdCpblty_cifMPI_present;
					   pCCThisCap->Cap.H245Vid_H261.H261VdCpblty_qcifMPI =0;
					   pCCThisCap->Cap.H245Vid_H261.H261VdCpblty_cifMPI =max  (1,min(4,pDecodeDetails->nonstd_params.MPI));//30/pVidCapInfo->uSamplesPerSec;
					   break;
				     }
					  default:
						 break;
			       }
			       pCCThisCap->Cap.H245Vid_H261.maxBitRate = (ASN1uint16_t)pDecodeDetails->nonstd_params.maxBitRate;
			       pCCThisCap->Cap.H245Vid_H261.tmprlSptlTrdOffCpblty = (ASN1bool_t)bPublicizeTSTradeoff;
			       pCCThisCap->Cap.H245Vid_H261.stillImageTransmission = FALSE;
  				break;

				default:
				case H245_CLIENT_VID_NONSTD:
				break;

			}
		}
		pDecodeDetails++;
		*ppCCThisTermCap++ = pCCThisCap;// add ptr to this capability to the array
		pTermCapList->wLength++;      	// count this entry
		// pCCThisCap is now referenced by the pTermCapList and will
		// be cleaned up via DeleteCapList(). Null the ptr so that error cleanup
		// won't try redundant cleanup.
		pCCThisCap = NULL;
	}
	*ppCapBuf = pTermCapList;
	return hr;

ERROR_OUT:
	if(pTermCapList)
	{
		DeleteCapList(pTermCapList);
	}
	if(pCCThisCap)
		MemFree(pCCThisCap);
	if(pNSCapNext)
		MemFree(pNSCapNext);
	return hr;


}

HRESULT CMsivCapability::DeleteCapList(LPVOID pCapBuf)
{
	UINT u;
	PCC_TERMCAPLIST pTermCapList = (PCC_TERMCAPLIST)pCapBuf;
	PCC_TERMCAP  pCCThisCap;
	PNSC_VIDEO_CAPABILITY pNSCap;
	
	if(!pTermCapList)
	{
		return CAPS_E_INVALID_PARAM;
	}

	if(pTermCapList->pTermCapArray)						
	{
		while(pTermCapList->wLength--)
		{
			pCCThisCap = *(pTermCapList->pTermCapArray + pTermCapList->wLength);
			if(pCCThisCap)
			{
				if(pCCThisCap->ClientType == H245_CLIENT_VID_NONSTD)
				{
					if(pCCThisCap->Cap.H245Vid_NONSTD.data.value)
					{
						MemFree(pCCThisCap->Cap.H245Vid_NONSTD.data.value);
					}
				}
				MemFree(pCCThisCap);
			}
		}
		MemFree(pTermCapList->pTermCapArray);
	}
	MemFree(pTermCapList);
	return hrSuccess;
}

BOOL CMsivCapability::IsCapabilityRecognized(PCC_TERMCAP pCCThisCap)
{
	FX_ENTRY ("CMsivCapability::IsCapabilityRecognized");
	if(pCCThisCap->DataType != H245_DATA_VIDEO)
		return FALSE;
	
	if(pCCThisCap->ClientType == H245_CLIENT_VID_NONSTD)
	{
		// do we recognize this?
		if(pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			if((pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode == USA_H221_COUNTRY_CODE)
			&& (pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension == USA_H221_COUNTRY_EXTENSION)
			&& (pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode == MICROSOFT_H_221_MFG_CODE))

			{
				// ok, this is ours so far. Now what data type is contained therein?
				// welllll, lets keep a copy of this regardless ????.  If we can't understand
				// future versions of ourselves, then what???
				return TRUE;
			}
			else
			{
				// unrecognized nonstandard capability
				ERRORMESSAGE(("%s:unrecognized nonstd capability\r\n",_fx_));
#ifdef DEBUG
				VOID DumpNonstdParameters(PCC_TERMCAP , PCC_TERMCAP );
				DumpNonstdParameters(NULL, pCCThisCap);
#endif
				return FALSE;
			}
		}
	}
	return TRUE;
}

// the intent is to keep a copy of the channel parameters used to open a send channel
// that the remote end can decode.


VIDEO_FORMAT_ID CMsivCapability::AddRemoteDecodeFormat(PCC_TERMCAP pCCThisCap)
{
	FX_ENTRY ("CMsivCapability::AddRemoteDecodeFormat");

	VIDCAP_DETAILS vidcapdetails =
		{VIDEO_FORMAT_UNKNOWN,NONSTD_VID_TERMCAP, STD_VID_PARAMS,
		{RTP_DYNAMIC_MIN+1, 0, 30, 7680, Small, 0, 0},0,
		TRUE, TRUE, 1, 245760*8,245760*8,10,10,0,0,NULL,0,NULL,""};
	
	VIDCAP_DETAILS *pTemp;
	LPVOID lpData = NULL;
	UINT uSize = 0;
	if(!pCCThisCap)
	{
		return INVALID_VIDEO_FORMAT;
	}	
   // check room
	if(uRemoteDecodeFormatCapacity <= uNumRemoteDecodeFormats)
	{
		// get more mem, realloc memory by CAP_CHUNK_SIZE for pRemoteDecodeFormats
		pTemp = (VIDCAP_DETAILS *)MEMALLOC((uNumRemoteDecodeFormats + CAP_CHUNK_SIZE)*sizeof(VIDCAP_DETAILS));
		if(!pTemp)
			goto ERROR_EXIT;
		// remember how much capacity we now have
		uRemoteDecodeFormatCapacity = uNumRemoteDecodeFormats + CAP_CHUNK_SIZE;
		#ifdef DEBUG
		if((uNumRemoteDecodeFormats && !pRemoteDecodeFormats) || (!uNumRemoteDecodeFormats && pRemoteDecodeFormats))
		{
			ERRORMESSAGE(("%s:leak! uNumRemoteDecodeFormats:0x%08lX, pRemoteDecodeFormats:0x%08lX\r\n",
				_fx_, uNumRemoteDecodeFormats,pRemoteDecodeFormats));
		}
		#endif
		// copy old stuff, discard old mem
		if(uNumRemoteDecodeFormats && pRemoteDecodeFormats)
		{
			memcpy(pTemp, pRemoteDecodeFormats, uNumRemoteDecodeFormats*sizeof(AUDCAP_DETAILS));
			MEMFREE(pRemoteDecodeFormats);
		}
		pRemoteDecodeFormats = pTemp;
	}
	// pTemp is where the stuff is cached
	pTemp = pRemoteDecodeFormats+uNumRemoteDecodeFormats;

	// fixup the capability structure being added.  First thing: initialize defaults
	memcpy(pTemp, &vidcapdetails, sizeof(VIDCAP_DETAILS));
	// next, the H245 parameters
	memcpy(&pTemp->H245Cap, pCCThisCap, sizeof(pTemp->H245Cap));
	
	// Note: if nonstandard data exists, the nonstd pointers need to be fixed up
	if(pCCThisCap->ClientType == H245_CLIENT_VID_NONSTD)
	{
		// do we recognize this?
		if(pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			if((pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode == USA_H221_COUNTRY_CODE)
			&& (pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension == USA_H221_COUNTRY_EXTENSION)
			&& (pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode == MICROSOFT_H_221_MFG_CODE))
			{
				// ok, this is ours so far. Now what data type is contained therein?
				// welllll, lets keep a copy of this regardless ????.  If we can't understand
				// future versions of ourselves, then what???
				uSize = pCCThisCap->Cap.H245Vid_NONSTD.data.length;
				lpData = pCCThisCap->Cap.H245Vid_NONSTD.data.value;
			}
		}
	}
	// this is not really necessary to set RTP payload type of what is received - it should
	// be obvious.
	else if (pCCThisCap->ClientType == H245_CLIENT_VID_H263 )
	{
		pTemp->video_params.RTPPayload = RTP_PAYLOAD_H263;
	}
	else if(pCCThisCap->ClientType == H245_CLIENT_VID_H261)
	{
		pTemp->video_params.RTPPayload = RTP_PAYLOAD_H261;
	}

	
	pTemp->uLocalDetailsSize = 0;	// we're not keeping another copy of local encode details
	pTemp->lpLocalFormatDetails =0; // we're not keeping another copy of local encode details
	
	pTemp->uRemoteDetailsSize = 0;	// clear this now
	if(uSize && lpData)
	{
		pTemp->H245Cap.Cap.H245Vid_NONSTD.data.length = uSize;
		pTemp->H245Cap.Cap.H245Vid_NONSTD.data.value = (unsigned char *)lpData;
		
		pTemp->lpRemoteFormatDetails = MEMALLOC(uSize);
		if(pTemp->lpRemoteFormatDetails)
		{
			memcpy(pTemp->lpRemoteFormatDetails, lpData, uSize);
			pTemp->uRemoteDetailsSize = uSize;
				
		}
		#ifdef DEBUG
			else
			{
				ERRORMESSAGE(("%s:allocation failed!\r\n",_fx_));
			}
		#endif
	}
	else
	{
		pTemp->lpRemoteFormatDetails = NULL;
		pTemp->uRemoteDetailsSize =0;
	}
	uNumRemoteDecodeFormats++;
	// use the index as the ID
	return (uNumRemoteDecodeFormats-1);

	ERROR_EXIT:
	return INVALID_VIDEO_FORMAT;
			
}
		
VOID CMsivCapability::FlushRemoteCaps()
{
	if(pRemoteDecodeFormats)
	{
		MEMFREE(pRemoteDecodeFormats);
		pRemoteDecodeFormats = NULL;
		uNumRemoteDecodeFormats = 0;
		uRemoteDecodeFormatCapacity = 0;
	}
}

HRESULT CMsivCapability::AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList)
{
	FX_ENTRY ("CMsivCapability::AddRemoteDecodeCaps");
	HRESULT hr = hrSuccess;
	PPCC_TERMCAP ppCCThisCap;
	PCC_TERMCAP pCCThisCap;
	WORD wNumCaps;

	   //ERRORMESSAGE(("%s,\r\n", _fx_));
	if(!pTermCapList) 			// additional capability descriptors may be added
	{							// at any time
		return CAPS_E_INVALID_PARAM;
	}

	// cleanup old term caps if term caps are being addded and old caps exist
	FlushRemoteCaps();
				
	wNumCaps = pTermCapList->wLength;			
	ppCCThisCap = pTermCapList->pTermCapArray;
	
/*
					CC_TERMCAPLIST			TERMCAPINFO			CC_TERMCAP

	pTermCapList->	{
						wLength
						pTermCapInfo--->pTermCap----------->{single capability.....}
					}					
										pTermCap----------->{single capability.}

										pTermCap----------->{single capability...}

*/
	while(wNumCaps--)
	{
		if(!(pCCThisCap = *ppCCThisCap++))		
		{
			ERRORMESSAGE(("%s:null pTermCap, 0x%04x of 0x%04x\r\n",
				_fx_, pTermCapList->wLength - wNumCaps, pTermCapList->wLength));
			continue;
		}	
		if(!IsCapabilityRecognized(pCCThisCap))
		{
			continue;
		}
		AddRemoteDecodeFormat(pCCThisCap);
	}
	return hr;
}




// Given the ID of a local format, gets the channel parameters that are sent to the
// remote end as part of the capability exchange.  This function is not used by the
// capability exchange code (because it sends more than just these parameters).
// However, this is useful information by itself - it can be used for validating the
// parameters of channel open requests against the expected parameters

HRESULT CMsivCapability::GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, VIDEO_FORMAT_ID id)
{
	UINT uIndex = IDToIndex(id);
	// 	validate input
	if(!pBufOut|| (uIndex >= (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(uBufSize < sizeof(CC_TERMCAP))
	{
		return CAPS_E_BUFFER_TOO_SMALL;
	}
	memcpy(pBufOut, &((pLocalFormats + uIndex)->H245Cap), sizeof(CC_TERMCAP));

	return hrSuccess;
}

HRESULT CMsivCapability::SetAudioPacketDuration(UINT uPacketDuration)
{
	return CAPS_E_INVALID_PARAM;
}
	
// Given the IDs of  "matching" local and remote formats, gets the preferred channel parameters
// that will be used in requests to open a channel for sending to the remote.

HRESULT CMsivCapability::GetEncodeParams(LPVOID pBufOut, UINT uBufSize,LPVOID pLocalParams, UINT uSizeLocal,
	VIDEO_FORMAT_ID idRemote, VIDEO_FORMAT_ID idLocal)
{
	UINT uLocalIndex = IDToIndex(idLocal);
   	VIDCAP_DETAILS *pLocalDetails  = pLocalFormats + uLocalIndex;
	VIDCAP_DETAILS *pFmtTheirs;
	VIDEO_CHANNEL_PARAMETERS local_params;
	UINT u;
	PCC_TERMCAP pTermCap = (PCC_TERMCAP)pBufOut;
	
	// 	validate input
	// AddCapabilityBase adds to the ID below. Make sure we're checking Video Formats
	if(!pBufOut)
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(uBufSize < sizeof(CC_TERMCAP))
	{
		return CAPS_E_BUFFER_TOO_SMALL;
	}
	if(!pLocalParams|| uSizeLocal < sizeof(VIDEO_CHANNEL_PARAMETERS)
		||(uLocalIndex >= (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}

	pFmtTheirs = pRemoteDecodeFormats; 		// start at the beginning of the remote formats
	for(u=0; u<uNumRemoteDecodeFormats; u++)
	{
		if(pFmtTheirs->H245Cap.CapId == idRemote)
		{
			// copy CC_TERMCAP struct. Any data referenced by CC_TERMCAP now has
			// two references to it.  i.e. pTermCap->extrablah is the same
			// location as pFmtTheirs->extrablah
			memcpy(pBufOut, &(pFmtTheirs->H245Cap), sizeof(CC_TERMCAP));
			break;
		}
		pFmtTheirs++;	// next entry in receiver's caps
	}

	// check for an unfound format
	if(u >= uNumRemoteDecodeFormats)
		goto ERROR_EXIT;
		
	// select channel parameters if appropriate.   The audio formats that have variable parameters
	// are :

#pragma message ("Are H.26? variable parameter formats?")
	// H245_CAP_H261               H245Vid_H261;
	// H245_CAP_H263               H245Vid_H263;
	// and of course all nonstandard formats

	// Select parameters based on local capability info
	
	if(pTermCap->ClientType == H245_CLIENT_VID_H263)	
	{
		unsigned short bit_mask;	
		// select frames per packet based on minimum latency value that is acceptable
#define H263_QCIF	0x4000
#define H263_MAXBP	0x0200
//H263_QCIF | H263_MAXBP;

	
	   pTermCap->Cap.H245Vid_H263.bit_mask= H263_MAXBP | pLocalDetails->H245Cap.Cap.H245Vid_H263.bit_mask;


	   local_params.ns_params.maxBitRate = pTermCap->Cap.H245Vid_H263.maxBitRate
	   	= min (pLocalDetails->nonstd_params.maxBitRate , pFmtTheirs->H245Cap.Cap.H245Vid_H263.maxBitRate);
	   local_params.ns_params.maxBPP = pTermCap->Cap.H245Vid_H263.bppMaxKb
	   	= min (pLocalDetails->nonstd_params.maxBPP, pFmtTheirs->H245Cap.Cap.H245Vid_H263.bppMaxKb);


		// we (the local end) need to know that actual MPI is going to be used!
		// like everywhere else in this module, the assumption is that local H.263 capabilities are
		// fanned out with one local cap entry per frame size.
		// MPI minimum interval in units of 1/29.97sec so take the longest interval
		// there is no pretty way to do this	
		bit_mask = pLocalDetails->H245Cap.Cap.H245Vid_H263.bit_mask;
		if(bit_mask & H263VideoCapability_sqcifMPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H263.sqcifMPI =
				max(pLocalDetails->nonstd_params.MPI,
					pTermCap->Cap.H245Vid_H263.sqcifMPI);
		}
		else if (bit_mask &  H263VideoCapability_qcifMPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H263.H263VdCpblty_qcifMPI =
				max(pLocalDetails->nonstd_params.MPI,
					pTermCap->Cap.H245Vid_H263.H263VdCpblty_qcifMPI);
		}
		else if (bit_mask &  H263VideoCapability_cifMPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H263.H263VdCpblty_cifMPI =
				max(pLocalDetails->nonstd_params.MPI,
					pTermCap->Cap.H245Vid_H263.H263VdCpblty_cifMPI);
		}
		else if (bit_mask &  H263VideoCapability_cif4MPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H263.cif4MPI =
				max(pLocalDetails->H245Cap.Cap.H245Vid_H263.cif4MPI,
					pTermCap->Cap.H245Vid_H263.cif4MPI);
		}
		else if (bit_mask &  H263VideoCapability_cif16MPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H263.cif16MPI =
				max(pLocalDetails->nonstd_params.MPI,
					pTermCap->Cap.H245Vid_H263.cif16MPI);
		}
		// else	// impossible.  Doom, as MikeG and JonT would say

	}
	else if(pTermCap->ClientType == H245_CLIENT_VID_H261)	
	{
		unsigned short bit_mask;	
		// select frames per packet based on minimum latency value that is acceptable
	
	   pTermCap->Cap.H245Vid_H261.bit_mask= pLocalDetails->H245Cap.Cap.H245Vid_H261.bit_mask;


	   local_params.ns_params.maxBitRate = pTermCap->Cap.H245Vid_H261.maxBitRate
	   	= min (pLocalDetails->nonstd_params.maxBitRate , pFmtTheirs->H245Cap.Cap.H245Vid_H261.maxBitRate);
	
		// we (the local end) need to know that actual MPI is going to be used!
		// like everywhere else in this module, the assumption is that local H.261 capabilities are
		// fanned out with one local cap entry per frame size.
		// MPI minimum interval in units of 1/29.97sec so take the longest interval
		// there is no pretty way to do this	
		bit_mask = pLocalDetails->H245Cap.Cap.H245Vid_H261.bit_mask;
		if (bit_mask &  H261VdCpblty_qcifMPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H261.H261VdCpblty_qcifMPI =
				max(pLocalDetails->nonstd_params.MPI,
					pTermCap->Cap.H245Vid_H261.H261VdCpblty_qcifMPI);
		}
		else if (bit_mask &  H261VdCpblty_cifMPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H261.H261VdCpblty_cifMPI =
				max(pLocalDetails->nonstd_params.MPI,
					pTermCap->Cap.H245Vid_H261.H261VdCpblty_cifMPI);
		}
		// else	// impossible.  Doom, as MikeG and JonT would say

	}
	else if (pTermCap->ClientType == H245_CLIENT_VID_NONSTD)
	{
		// NOT YET IMPLEMENTED!!!!.  even the nonstandard parameters need to be fixed
		// up here based on mutual maxes and mins
		memcpy(&local_params.ns_params, &pLocalDetails->nonstd_params,
			sizeof(NSC_CHANNEL_VIDEO_PARAMETERS));
	}
	local_params.RTP_Payload = pLocalDetails->video_params.RTPPayload;
	//Fixup local
	memcpy(pLocalParams, &local_params, sizeof(VIDEO_CHANNEL_PARAMETERS));

	
	return hrSuccess;

	ERROR_EXIT:
	return CAPS_E_INVALID_PARAM;
}	



BOOL NonStandardCapsCompareV(VIDCAP_DETAILS *pFmtMine, PNSC_VIDEO_CAPABILITY pCap2,
	UINT uSize2)
{
	PVIDEOFORMATEX lpvcd;
	if(!pFmtMine || !pCap2)
		return FALSE;

	if(!(lpvcd = (PVIDEOFORMATEX)pFmtMine->lpLocalFormatDetails))
		return FALSE;

		
	if(pCap2->cvp_type == NSC_VCM_VIDEOFORMATEX)
	{
		// check sizes first
		if(lpvcd->bih.biSize != pCap2->cvp_data.vfx.bih.biSize)
		{
			return FALSE;
		}
		// compare structures, including extra bytes
		if(memcmp(lpvcd, &pCap2->cvp_data.vfx,
			sizeof(VIDEOFORMATEX) - BMIH_SLOP_BYTES)==0)
		{
			return TRUE;										
		}
	}
	else if(pCap2->cvp_type == NSC_VCMABBREV)
	{
	        if((LOWORD(pCap2->cvp_data.vcm_brief.dwFormatTag) == lpvcd->dwFormatTag)
		 && (pCap2->cvp_data.vcm_brief.dwSamplesPerSec ==  lpvcd->nSamplesPerSec)
		 && (LOWORD(pCap2->cvp_data.vcm_brief.dwBitsPerSample) ==  lpvcd->wBitsPerSample))
 		{
			return TRUE;
 		}
	}
	return FALSE;
}


BOOL HasNonStandardCapsTS(VIDCAP_DETAILS *pFmtMine, PNSC_VIDEO_CAPABILITY pCap2)
{
	PVIDEOFORMATEX lpvcd;

	if(!pFmtMine || !pCap2)
		return FALSE;

	if(!(lpvcd = (PVIDEOFORMATEX)pFmtMine->lpLocalFormatDetails))
		return FALSE;
		
	if(pCap2->cvp_type == NSC_VCM_VIDEOFORMATEX)
		if(lpvcd->dwSupportTSTradeOff && pCap2->cvp_data.vfx.dwSupportTSTradeOff)
			return TRUE;

	return FALSE;
}



HRESULT CMsivCapability::ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote)
{
	VIDCAP_DETAILS *pFmtLocal;
	VIDCAP_DETAILS *pFmtRemote;
	UINT format_mask;
	UINT uIndex = IDToIndex(FormatIDLocal);
	UINT i;

	if(!pFormatIDRemote || (FormatIDLocal == INVALID_MEDIA_FORMAT)
		|| (uIndex >= (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}
	pFmtLocal = pLocalFormats + uIndex;
	
	pFmtRemote = pRemoteDecodeFormats;     // start at the beginning of the remote formats
	for(i=0; i<uNumRemoteDecodeFormats; i++)
	{
		if(!pFmtLocal->bSendEnabled)
			continue;
			
		// compare capabilities - start by comparing the format tag. a.k.a. "ClientType" in H.245 land
		if(pFmtLocal->H245Cap.ClientType ==  pFmtRemote->H245Cap.ClientType)
		{
			// if this is a nonstandard cap, compare nonstandard parameters
			if(pFmtLocal->H245Cap.ClientType == H245_CLIENT_VID_NONSTD)
			{
				if(NonStandardCapsCompareV(pFmtLocal,
					(PNSC_VIDEO_CAPABILITY)pFmtRemote->H245Cap.Cap.H245Vid_NONSTD.data.value,
					pFmtRemote->H245Cap.Cap.H245Vid_NONSTD.data.length))
				{
					goto RESOLVED_EXIT;
				}
			}
			else	// compare standard parameters, if any
			{
				// well, so far, there aren't any parameters that are significant enough
				// to affect the match/no match decision
				if (pFmtLocal->H245Cap.ClientType == H245_CLIENT_VID_H263)
				{
				       format_mask=  H263VideoCapability_sqcifMPI_present
				       	| H263VideoCapability_qcifMPI_present | H263VideoCapability_cifMPI_present	
				       	| H263VideoCapability_cif4MPI_present | H263VideoCapability_cif16MPI_present;
				       if ((pFmtRemote->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask) & (pFmtLocal->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask))
				       {
				       		// compatible basic format
						  	goto RESOLVED_EXIT;
				       }
				}
				else if (pFmtLocal->H245Cap.ClientType == H245_CLIENT_VID_H261)
				{
				       format_mask=  H261VdCpblty_qcifMPI_present | H261VdCpblty_cifMPI_present;
				       if ((pFmtRemote->H245Cap.Cap.H245Vid_H261.bit_mask & format_mask) & (pFmtLocal->H245Cap.Cap.H245Vid_H261.bit_mask & format_mask))
				       {
				       		// compatible basic format
						  	goto RESOLVED_EXIT;
				       }
				}
				else
				{
				   //Some other standard format
				   goto RESOLVED_EXIT;
				}
			}
		}		
		pFmtRemote++;	// next entry in remote caps
	}
	return CAPS_E_NOMATCH;
	
RESOLVED_EXIT:
// Match!
	// return ID of remote decoding (receive fmt) caps that match our
	// send caps
	*pFormatIDRemote = pFmtRemote->H245Cap.CapId;
	return hrSuccess;
}

// resolve using currently cached local and remote formats

HRESULT CMsivCapability::ResolveEncodeFormat(
 	VIDEO_FORMAT_ID *pIDEncodeOut,
	VIDEO_FORMAT_ID *pIDRemoteDecode)
{
	UINT i,j=0,format_mask;
	VIDCAP_DETAILS *pFmtMine = pLocalFormats;
	VIDCAP_DETAILS *pFmtTheirs;
	
	if(!pIDEncodeOut || !pIDRemoteDecode)
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pLocalFormats)
	{
		*pIDEncodeOut = *pIDRemoteDecode = INVALID_VIDEO_FORMAT;
		return CAPS_E_NOCAPS;
	}
	if(!pRemoteDecodeFormats || !uNumRemoteDecodeFormats)
	{
		*pIDEncodeOut = *pIDRemoteDecode = INVALID_VIDEO_FORMAT;
		return CAPS_E_NOMATCH;
	}

	// decide how to encode.  my caps are ordered by my preference according to
	// the contents of IDsByRank[]
	//If given a salt, find the position and add it
	if (*pIDEncodeOut != INVALID_MEDIA_FORMAT)
	{
		UINT uIndex = IDToIndex(*pIDEncodeOut);
		if (uIndex > uNumLocalFormats)
		{
			return CAPS_W_NO_MORE_FORMATS;
		}
		for(i=0; i<uNumLocalFormats; i++)
		{
			if (pLocalFormats[IDsByRank[i]].H245Cap.CapId == *pIDEncodeOut)
			{
	 			j=i+1;
				break;
			}
		}	
	}

	// start at index j
	for(i=j; i<uNumLocalFormats; i++)
	{
		pFmtMine = pLocalFormats + IDsByRank[i];	
		// check to see if this format is enabled for encoding
		if(!pFmtMine->bSendEnabled)
			continue;

		pFmtTheirs = pRemoteDecodeFormats; 		// start at the beginning of the remote formats
		for(j=0; j<uNumRemoteDecodeFormats; j++)
		{
			// compare capabilities - start by comparing the format tag. a.k.a. "ClientType" in H.245 land
			if(pFmtMine->H245Cap.ClientType ==  pFmtTheirs->H245Cap.ClientType)
			{
				// if this is a nonstandard cap, compare nonstandard parameters
				if(pFmtMine->H245Cap.ClientType == H245_CLIENT_VID_NONSTD)
				{

					if(NonStandardCapsCompareV(pFmtMine,
						(PNSC_VIDEO_CAPABILITY)pFmtTheirs->H245Cap.Cap.H245Vid_NONSTD.data.value,
						pFmtTheirs->H245Cap.Cap.H245Vid_NONSTD.data.length))
					{
						goto RESOLVED_EXIT;
					}
				

				}
				else	// compare standard parameters, if any
				{
					// well, so far, there aren't any parameters that are significant enough
					// to affect the match/no match decision
					if (pFmtMine->H245Cap.ClientType == H245_CLIENT_VID_H263)
					{
					       format_mask=  H263VideoCapability_sqcifMPI_present| H263VideoCapability_qcifMPI_present
					       	|H263VdCpblty_cifMPI_present	
					       	|H263VideoCapability_cif4MPI_present
					       	|H263VideoCapability_cif16MPI_present;
					       if ((pFmtTheirs->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask) & (pFmtMine->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask))
					       {
					       		// compatible basic format
							  	goto RESOLVED_EXIT;
					       }
					}
					else if (pFmtMine->H245Cap.ClientType == H245_CLIENT_VID_H261)
					{
					       format_mask=  H261VdCpblty_qcifMPI_present | H261VdCpblty_cifMPI_present;
					       if ((pFmtTheirs->H245Cap.Cap.H245Vid_H261.bit_mask & format_mask) & (pFmtMine->H245Cap.Cap.H245Vid_H261.bit_mask & format_mask))
					       {
					       		// compatible basic format
							  	goto RESOLVED_EXIT;
					       }
					} else {
					   //Some other standard format
					   goto RESOLVED_EXIT;

					}

				}
			}		
			pFmtTheirs++;	// next entry in receiver's caps
		}
		
	}
	return CAPS_E_NOMATCH;
	
RESOLVED_EXIT:
// Match!
// return ID of our encoding (sending fmt) caps that match
	
	*pIDEncodeOut = pFmtMine->H245Cap.CapId;
	// return ID of remote decoding (receive fmt) caps that match our
	// send caps
	*pIDRemoteDecode = pFmtTheirs->H245Cap.CapId;
	return hrSuccess;

	
}

HRESULT CMsivCapability::GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,
		VIDEO_FORMAT_ID * pFormatID, LPVOID lpvBuf, UINT uBufSize)
{
	UINT i,j=0;
	VIDCAP_DETAILS *pFmtMine = pLocalFormats;
	VIDCAP_DETAILS *pFmtTheirs = pRemoteDecodeFormats; 	

	VIDEO_CHANNEL_PARAMETERS local_params;
	PNSC_CHANNEL_VIDEO_PARAMETERS pNSCap = &local_params.ns_params;
	PCC_TERMCAP pCapability;
	
	if(!pChannelParams || !(pCapability = pChannelParams->pChannelCapability) || !pFormatID || !lpvBuf ||
		(uBufSize < sizeof(VIDEO_CHANNEL_PARAMETERS)))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pLocalFormats)
	{
		return CAPS_E_NOCAPS;
	}
	
	local_params.TS_Tradeoff = FALSE;		// initialize TS tradeoff
	for(i=0; i<uNumLocalFormats; i++)
	{
		pFmtMine = pLocalFormats + IDsByRank[i];	
	
		// compare capabilities - start by comparing the format tag. a.k.a. "ClientType" in H.245 land
		if(pFmtMine->H245Cap.ClientType ==  pCapability->ClientType)
		{
		   // if this is a nonstandard cap, compare nonstandard parameters
		   if(pFmtMine->H245Cap.ClientType == H245_CLIENT_VID_NONSTD)
		   {
				if(NonStandardCapsCompareV(pFmtMine, (PNSC_VIDEO_CAPABILITY)pCapability->Cap.H245Vid_NONSTD.data.value,
					pCapability->Cap.H245Vid_NONSTD.data.length))
				{
					#pragma message ("someday may need need fixup of nonstd params")
					// for now, the remote & local nonstandard params are what we want
					// and the remote's version of NSC_CHANNEL_VIDEO_PARAMETERS will
					// be copied out
					pNSCap = (PNSC_CHANNEL_VIDEO_PARAMETERS)
						&((PNSC_VIDEO_CAPABILITY)pCapability->Cap.H245Vid_NONSTD.data.value)->cvp_params;

					// Does this format support temporal/spatial tradeoff
					if(HasNonStandardCapsTS(pFmtMine, (PNSC_VIDEO_CAPABILITY)pCapability->Cap.H245Vid_NONSTD.data.value))
						local_params.TS_Tradeoff = TRUE;	
					else
						local_params.TS_Tradeoff = FALSE;

					goto RESOLVED_EXIT;
				}
			}
			else	// compare standard parameters, if any
			{
				switch (pFmtMine->H245Cap.ClientType)
				{
					unsigned short bit_mask, format_mask, usMyMPI, usTheirMPI;

					case H245_CLIENT_VID_H263:
					// like everywhere else in this module, the assumption is that
					// local H.263 capabilities are fanned out with one local cap entry
					// per frame size.
						
						format_mask=  H263VideoCapability_sqcifMPI_present
							| H263VideoCapability_qcifMPI_present
							| H263VideoCapability_cifMPI_present	
							| H263VideoCapability_cif4MPI_present
							| H263VideoCapability_cif16MPI_present;
						// bail out if no match or nonexistent frame size
						if (!((pCapability->Cap.H245Vid_H263.bit_mask & format_mask) & (pFmtMine->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask)))
							continue;
								
						//  get the maximum bitrate
						local_params.ns_params.maxBitRate = min(pFmtMine->H245Cap.Cap.H245Vid_H263.maxBitRate,
						 	pCapability->Cap.H245Vid_H263.maxBitRate);
						local_params.ns_params.maxBPP = min (pFmtMine->H245Cap.Cap.H245Vid_H263.bppMaxKb ,
							pCapability->Cap.H245Vid_H263.bppMaxKb);
	
						// FIND THE MAXIMUM MPI!!!!. (minimum frame rate)
						// there is no pretty way to do this	
						bit_mask = pFmtMine->H245Cap.Cap.H245Vid_H263.bit_mask;
						if(bit_mask & H263VideoCapability_sqcifMPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H263.sqcifMPI,
									pCapability->Cap.H245Vid_H263.sqcifMPI);
						}
						else if (bit_mask &  H263VideoCapability_qcifMPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H263.H263VdCpblty_qcifMPI,
									pCapability->Cap.H245Vid_H263.H263VdCpblty_qcifMPI);
						}
						else if (bit_mask &  H263VideoCapability_cifMPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H263.H263VdCpblty_cifMPI,
									pCapability->Cap.H245Vid_H263.H263VdCpblty_cifMPI);
						}
						else if (bit_mask &  H263VideoCapability_cif4MPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H263.cif4MPI,
									pCapability->Cap.H245Vid_H263.cif4MPI);
						}
						else if (bit_mask &  H263VideoCapability_cif16MPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H263.cif16MPI,
									pCapability->Cap.H245Vid_H263.cif16MPI);

						}
						else	// impossible.  Doom, as MikeG and JonT would say
							continue;

						// Fallout (And the format is found!)
						
						// And one more special thing: find out if the other end
						// advertised Temporal/Spatial tradeoff in it's send capabilities.
						// First try the obvious.  Technically, it only makes sense for
						// transmit capabilities, but if the channel params have it, then
						// the other end must have the capability
						if(pCapability->Cap.H245Vid_H263.tmprlSptlTrdOffCpblty)
						{
							local_params.TS_Tradeoff = TRUE;	
						}
						else
						{
							// Search for a H.263 SEND capability that has the T/S tradoff set
							for(j=0; j<uNumRemoteDecodeFormats; j++)
							{
								if((pFmtTheirs->H245Cap.ClientType == H245_CLIENT_VID_H263)
								// exclude RX capabilities
									&&  (pFmtTheirs->H245Cap.Dir != H245_CAPDIR_LCLRX)
									&&  (pFmtTheirs->H245Cap.Dir != H245_CAPDIR_RMTRX))
								{
									if ((pFmtTheirs->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask) & (pFmtMine->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask))
									{
										local_params.TS_Tradeoff = TRUE;
										break;
									}
								}		
								pFmtTheirs++;	// next entry in receiver's caps
							}

						}
						goto RESOLVED_EXIT;
						
					break;
		
					case H245_CLIENT_VID_H261:
					// like everywhere else in this module, the assumption is that
					// local H.261 capabilities are fanned out with one local cap entry
					// per frame size.
						
						format_mask=  H261VdCpblty_qcifMPI_present |H261VdCpblty_cifMPI_present;
						// bail out if no match or nonexistent frame size
						if (!((pCapability->Cap.H245Vid_H261.bit_mask & format_mask) & (pFmtMine->H245Cap.Cap.H245Vid_H261.bit_mask & format_mask)))
							continue;
								
						//  get the maximum bitrate
						local_params.ns_params.maxBitRate = min(pFmtMine->H245Cap.Cap.H245Vid_H261.maxBitRate,
						 	pCapability->Cap.H245Vid_H261.maxBitRate);
	
						// FIND THE MAXIMUM MPI!!!!. (minimum frame rate)
						// there is no pretty way to do this	
						bit_mask = pFmtMine->H245Cap.Cap.H245Vid_H261.bit_mask;
						if (bit_mask &  H261VdCpblty_qcifMPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H261.H261VdCpblty_qcifMPI,
									pCapability->Cap.H245Vid_H261.H261VdCpblty_qcifMPI);
						}
						else if (bit_mask &  H261VdCpblty_cifMPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H261.H261VdCpblty_cifMPI,
									pCapability->Cap.H245Vid_H261.H261VdCpblty_cifMPI);
						}
						else	// impossible.  Doom, as MikeG and JonT would say
							continue;

						// Fallout (And the format is found!)
						
						// And one more special thing: find out if the other end
						// advertised Temporal/Spatial tradeoff in it's send capabilities.
						// First try the obvious.  Technically, it only makes sense for
						// transmit capabilities, but if the channel params have it, then
						// the other end must have the capability
						if(pCapability->Cap.H245Vid_H261.tmprlSptlTrdOffCpblty)
						{
							local_params.TS_Tradeoff = TRUE;	
						}
						else
						{
							// Search for a H.261 SEND capability that has the T/S tradoff set
							for(j=0; j<uNumRemoteDecodeFormats; j++)
							{
								if((pFmtTheirs->H245Cap.ClientType == H245_CLIENT_VID_H261)
								// exclude RX capabilities
									&&  (pFmtTheirs->H245Cap.Dir != H245_CAPDIR_LCLRX)
									&&  (pFmtTheirs->H245Cap.Dir != H245_CAPDIR_RMTRX))
								{
									if ((pFmtTheirs->H245Cap.Cap.H245Vid_H261.bit_mask
										& format_mask)
										& (pFmtMine->H245Cap.Cap.H245Vid_H261.bit_mask
										& format_mask))
									{
										local_params.TS_Tradeoff = TRUE;
										break;
									}
								}		
								pFmtTheirs++;	// next entry in receiver's caps
							}

						}
						goto RESOLVED_EXIT;
					break;

					default:
						goto RESOLVED_EXIT;
					break;
			
					
				}
			}// end else compare standard parameters, if any	
		}// end if(pFmtMine->H245Cap.ClientType ==  pCapability->ClientType)
	}
	return CAPS_E_NOMATCH;

RESOLVED_EXIT:
	// Match!
	// return ID of the decoding caps that match
	*pFormatID = pFmtMine->H245Cap.CapId;
	local_params.RTP_Payload = pChannelParams->bRTPPayloadType;;
	memcpy(lpvBuf, &local_params, sizeof(VIDEO_CHANNEL_PARAMETERS));
	return hrSuccess;
}



HRESULT CMsivCapability::SetCapIDBase (UINT uNewBase)
{
	uCapIDBase = uNewBase;	
	UINT u;
	for (u=0;u<uNumLocalFormats;u++)
	{
    	pLocalFormats[u].H245Cap.CapId = u + uCapIDBase;
	}
   	return hrSuccess;
}

BOOL CMsivCapability::IsHostForCapID(MEDIA_FORMAT_ID CapID)
{
	if((CapID >= uCapIDBase) && ((CapID - uCapIDBase) < uNumLocalFormats))
		return TRUE;
	else
		return FALSE;
	
}



HRESULT CMsivCapability::IsFormatEnabled (MEDIA_FORMAT_ID FormatID, PBOOL bRecv, PBOOL bSend)
{
   UINT uIndex = IDToIndex(FormatID);
   // 	validate input
   if(uIndex >= (UINT)uNumLocalFormats)
   {
	   return CAPS_E_INVALID_PARAM;
   }
   *bSend=((pLocalFormats + uIndex)->bSendEnabled);
   *bRecv=((pLocalFormats + uIndex)->bRecvEnabled);

   return hrSuccess;

}

BOOL CMsivCapability::IsFormatPublic (MEDIA_FORMAT_ID FormatID)
{
	UINT uIndex = IDToIndex(FormatID);
	// 	validate input
	if(uIndex >= (UINT)uNumLocalFormats)
		return FALSE;
		
	// test if this is format is a duplicate of a public format
	if((pLocalFormats + uIndex)->dwPublicRefIndex)
		return FALSE;	// then we keep this format to ourselves
	else
		return TRUE;
}
MEDIA_FORMAT_ID CMsivCapability::GetPublicID(MEDIA_FORMAT_ID FormatID)
{
	UINT uIndex = IDToIndex(FormatID);
	// 	validate input
	if(uIndex >= (UINT)uNumLocalFormats)
		return INVALID_MEDIA_FORMAT;
		
	if((pLocalFormats + uIndex)->dwPublicRefIndex)
	{
		return (pLocalFormats + ((pLocalFormats + uIndex)->dwPublicRefIndex))->H245Cap.CapId;
	}
	else
	{
		return FormatID;
	}
}

// Returns the Id of the format with the smallest wSortIndex - preferred format.
HRESULT CMsivCapability::GetPreferredFormatId (VIDEO_FORMAT_ID *pId)
{
	HRESULT			hr = hrSuccess;
	VIDCAP_DETAILS	*pDetails = pLocalFormats;
	UINT			u, uIndex;	
	WORD			wSortIndex, wMinSortIndex = SHRT_MAX;

	// Validate input param
	if (!pId)
		return((HRESULT)CAPS_E_INVALID_PARAM);

	// Validate state
	if(!uNumLocalFormats || !pDetails)
		return((HRESULT)CAPS_E_NOCAPS);

	// Look for the format with the smallest wSortIndex
	for (u = 0; (u < uNumLocalFormats) && (u < MAX_CAPS_PRESORT); u++)
	{
		pDetails = pLocalFormats + IDsByRank[u];	
		// Find the sort index.
		uIndex = (UINT)(pDetails - pLocalFormats);
		for (wSortIndex = 0; (wSortIndex < uNumLocalFormats) && (wSortIndex < MAX_CAPS_PRESORT); wSortIndex++)
		{
			if (uIndex == IDsByRank[wSortIndex])
				break; // Found it
		}
		if (wSortIndex <= wMinSortIndex)
		{
			*pId = IndexToId(uIndex);
			wMinSortIndex = wSortIndex;
		}
	}

	return(hr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\nacguids.c ===
#define  INITGUIDS
#include <objbase.h>
#include <initguid.h>
#include <mmsystem.h>
#include "ibitmap.h"
#include "effect.h"

// the following is yanked from "VidPool.h" {36447655-7089-11d0-BC25-00AA00A13C86}
DEFINE_GUID(BFID_PRIVATEDIB, 0x36447655, 0x7089, 0x11d0, 0xbc, 0x25, 0x0, 0xaa, 0x0, 0xa1, 0x3c, 0x86); 

#include "common.h"
#include "nacguids.h"
#include "qos.h"
#include "codecs.h"
#include <irtp_i.c>

// {D2E97231-0C18-11d0-AD53-00AA004A80A3}
//static const GUID OID_CAP_ACM_TO_MSIA = 
//{ 0xd2e97231, 0xc18, 0x11d0, { 0xad, 0x53, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 } 
//};

// {D2E97230-0C18-11d0-AD53-00AA004A80A3}
//static const GUID OID_CAP_ACM_TO_H323 = 
//{ 0xd2e97230, 0xc18, 0x11d0, { 0xad, 0x53, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 } 
//};

// {A4209190-14B4-11d0-AD55-00AA004A80A3}
//static const GUID PID_H323 = 
//{ 0xa4209190, 0x14b4, 0x11d0, { 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 
//} };

// {A4209191-14B4-11d0-AD55-00AA004A80A3}
//static const GUID PID_MSICCP = 
//{ 0xa4209191, 0x14b4, 0x11d0, { 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 
//} };

// {A4209192-14B4-11d0-AD55-00AA004A80A3}
//static const GUID PID_MNM10_DUAL = 
//{ 0xa4209192, 0x14b4, 0x11d0, { 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 
//} };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\plog.cpp ===
#include "precomp.h"

#ifdef PLS_DEBUG
#include "plog.h"



CCallLog::CCallLog(int size)
{
	m_bValid = false;

    DBG_SAVE_FILE_LINE
	m_pLogEntry = new CPacketLogEntry[size];
	if (m_pLogEntry == NULL)
	{
		WARNING_OUT(("CCallLog:Out of memory"));
		return;
	}

	m_currentIndex = 0;
	m_size = size;
	m_bValid = true;
}

CCallLog::~CCallLog()
{
	if (m_bValid)
	{
		delete [] m_pLogEntry;
	}
}



bool CCallLog::AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark)
{
	CPacketLogEntry Entry;

	if (m_bValid == false) return false;

	Entry.dwTimeStamp = dwTimeStamp;
	Entry.dwSequenceNumber = dwSeqNum;
	Entry.LL_ArrivalTime = LL_ArrivalTime;
	Entry.dwSize = dwSize;
	Entry.dwLosses = 0;
	Entry.bLate = false;
	Entry.bMark = fMark;

	if (SizeCheck() == false)
		return false;

	m_pLogEntry[m_currentIndex++] = Entry;
	return true;

}

bool CCallLog::SizeCheck()
{
	if (m_bValid == false)
		return false;

	if (m_currentIndex < m_size)
		return true;
	return false;
}


bool CCallLog::Flush(HANDLE hFile)
{
	int index;
	CPacketLogEntry *pEntry;
	char szOutputLine[80];
	DWORD dwNumWritten;
   __int64 ArrivalTime64;
	__int64 PerfFreq64;
	LARGE_INTEGER LL_PerfFreq;
	
	if (m_bValid == false)
		return false;

	if (hFile == INVALID_HANDLE_VALUE)
		return false;

	PerformStats();

	// what's the performance frequency of this machine
	QueryPerformanceFrequency(&LL_PerfFreq);
	PerfFreq64 = LL_PerfFreq.QuadPart;

	for (index = 0; index < m_currentIndex; index++)
	{
		pEntry = &m_pLogEntry[index];

		ArrivalTime64 = pEntry->LL_ArrivalTime.QuadPart * 1000;
		ArrivalTime64 = ArrivalTime64 / PerfFreq64;

		sprintf(szOutputLine, "%d\t%d\t%d\t%d\t%d",
		        pEntry->dwTimeStamp,
		        pEntry->dwSequenceNumber,
		        (int)ArrivalTime64,
		        pEntry->dwSize,
		        pEntry->dwLosses);
		
		if (pEntry->bMark)
			strcat(szOutputLine, "\tMARK");
		else strcat(szOutputLine, "\t");

		if (pEntry->bLate)
			strcat(szOutputLine, "\tLATE");
		
		strcat(szOutputLine, "\n");

		WriteFile(hFile, szOutputLine, strlen(szOutputLine), &dwNumWritten, NULL);

	}
	return true;
}


CCallLog& CCallLog::operator=(const CCallLog& log)
{
	WARNING_OUT(("CCallLog:Assignment not supported"));
	return *this;
}

CCallLog::CCallLog(const CCallLog& log)
{
	WARNING_OUT(("CCallLog:Copy constructor not supported"));
	return;
}

bool CCallLog::PerformStats()
{
	int index, probeIndex;
	DWORD nextExpected;
	bool bFound;

	if (m_bValid == false)
		return false;

	if (m_currentIndex == 0)
		return false;

	// Set the current "loss" value for each entry to 0
	for (index = 0; index < m_currentIndex; index++)
	{
		m_pLogEntry[index].dwLosses = 0;
		m_pLogEntry[index].bLate = false;
	}

	// the first packet will always be a match with nextExpected
	nextExpected = m_pLogEntry[0].dwSequenceNumber;

	for (index = 0; index < m_currentIndex; index++)
	{
		if (nextExpected > 65535)
			nextExpected = 0;
		// if the packet has the next expected seq num, then everything is ok
		if (m_pLogEntry[index].dwSequenceNumber == nextExpected)
		{
			nextExpected++;
			continue;
		}

		// we've detected a missing packet... time to go hunting
		else if (m_pLogEntry[index].dwSequenceNumber > nextExpected)
		{
			bFound = false;
			probeIndex = index+1;
			while ((probeIndex < m_currentIndex) &&
			       (probeIndex < (index+PLOG_MAX_NOT_LATE)) )
			{
				if (m_pLogEntry[index].dwSequenceNumber == nextExpected)
					bFound = true;
				probeIndex++;
			}

			// the packet was merely out of sequence
			if (bFound == true)
			{
				nextExpected++;
				continue;
			}

			// the packet is probably lost
			// notice that we are simply incrementing dwLoss measure,
			// rolling the index back one
			m_pLogEntry[index].dwLosses++;
			nextExpected++;
			index--; // this is so we can continue to count additional
			         // loss packets for the same index
			continue; // back to the top of the for-loop
		}

		// a packet that was either previously thought of as lost or late
		else
		{
			m_pLogEntry[index].bLate = true;	
		}


	}


	return true;
}


// --------------------------------------------------------------

CPacketLog::CPacketLog(LPTSTR szDiskFile):
	m_hFile(INVALID_HANDLE_VALUE),
	m_nExtension(0)
{
	m_pCallLog = NULL;
	strcpy(m_szDiskFile, szDiskFile);
}


// initializes an output file.  Closes the current file if still open
bool CPacketLog::InitFile()
{
	char szFileName[120];

	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

	sprintf(szFileName, "%s%d%s", m_szDiskFile, m_nExtension, PLOG_FILE_EXT);
	m_hFile = CreateFile(szFileName, 
									GENERIC_READ|GENERIC_WRITE, 
									0, NULL, OPEN_EXISTING,
									FILE_ATTRIBUTE_NORMAL, NULL);

	while ((m_hFile != INVALID_HANDLE_VALUE) && (m_nExtension < 100))
	{
		CloseHandle(m_hFile);
		sprintf(szFileName, "%s%d%s", m_szDiskFile, m_nExtension, PLOG_FILE_EXT);
		m_hFile = CreateFile(szFileName, 
									GENERIC_READ|GENERIC_WRITE, 
									0, NULL, OPEN_EXISTING,
									FILE_ATTRIBUTE_NORMAL, NULL);
		m_nExtension++;
	}
			

	m_hFile = CreateFile(szFileName,
	                     GENERIC_READ|GENERIC_WRITE, 
	                     FILE_SHARE_READ,
	                     NULL,
	                     CREATE_ALWAYS,
	                     FILE_ATTRIBUTE_NORMAL,
	                     NULL);
	                     
	                     
	if (m_hFile == INVALID_HANDLE_VALUE)
	{
		WARNING_OUT(("CPacketLog:Unable to initialize output file"));
		return false;
	}

	return true;

}


CPacketLog::CPacketLog(const CPacketLog& packet_log)
{
	// it wouldn't be an error if duphandle was used correctly
	ERROR_OUT(("CPacketLog:Invalid to create a new packetLog via a copy constructor"));
	return;
}



CPacketLog& CPacketLog::operator=(const CPacketLog& packet_log)
{
	// it wouldn't be an error if duphandle was used correctly
	ERROR_OUT(("CPacketLog:Invalid to create a new packetLog via the assignment operator"));
	return *this;	
}


CPacketLog::~CPacketLog()
{
	if (m_pCallLog != NULL)
	{
		Flush();
		delete (m_pCallLog);
	}

	if (m_hFile != INVALID_HANDLE_VALUE)
		CloseHandle(m_hFile);

}


bool CPacketLog::Flush()
{
	char *szCallHeader = "CALLSTART\n";
	DWORD dwNumWritten;

	if (m_pCallLog == NULL)
		return false;

	WriteFile(m_hFile, szCallHeader, strlen(szCallHeader), &dwNumWritten, NULL);
	m_pCallLog->Flush(m_hFile);		

	return true;
}



bool CPacketLog::MarkCallStart()
{
	// write the previous call to file
	if (m_pCallLog != NULL)
	{
		Flush();
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
		delete m_pCallLog;
	}

	if (false == InitFile())
	{
		return false;
	}

    DBG_SAVE_FILE_LINE
	m_pCallLog = new CCallLog(PLOG_MAX_PACKETS_CALL);
	if (m_pCallLog == NULL)
		return false;

	return true;
}


bool CPacketLog::AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark)
{
	if (m_pCallLog == NULL)
	{
		if (false == MarkCallStart())
			return false;
	}

	return (m_pCallLog->AddEntry(dwTimeStamp, dwSeqNum, LL_ArrivalTime, dwSize, fMark));

}


// if-def pls_debug
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\plog.h ===
#ifndef PLOG_H
#define PLOG_H

#define PLOG_MAX_CALLS	20
#define PLOG_MAX_PACKETS_CALL 20000
#define PLOG_FILE_AUDIO "C:\\AuPacketLog"
#define PLOG_FILE_VIDEO "C:\\VidPacketLog"
#define PLOG_FILE_EXT    ".txt"

// number of packets until the missing packet
// is declared "lost" instead of late
#define PLOG_MAX_NOT_LATE	20

struct CPacketLogEntry
{
	DWORD dwSequenceNumber;
	DWORD dwTimeStamp;
	LARGE_INTEGER LL_ArrivalTime;
	DWORD dwSize;
	DWORD dwLosses;
	bool bLate;  // is the packet late ?
	bool bMark;  // is the M bit set in the RTP packet
};


class CCallLog
{
private:
	CPacketLogEntry *m_pLogEntry;
	int m_size;  // max num of entries this list can hold
	int m_currentIndex;
	bool m_bValid;
public:
	CCallLog(int size=PLOG_MAX_PACKETS_CALL);
	~CCallLog();
	bool AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark); 
	bool Flush(HANDLE hFile);
	bool SizeCheck();

	CCallLog& operator=(const CCallLog&);
	CCallLog(const CCallLog&);

	bool PerformStats();
};



// PacketLog maintains a list of CPacketLogEntry's
class CPacketLog
{
private:
	HANDLE m_hFile;         // handle to disk file where logs are kept
	CCallLog *m_pCallLog;   // pointer to CCallLog instance
	char m_szDiskFile[80];  // base name of the disk file
	int m_nExtension;	// current file extension index number

	bool InitFile();

public :
	CPacketLog(LPTSTR szDiskFile);
	CPacketLog(const CPacketLog&);

	CPacketLog& operator=(const CPacketLog&);

	~CPacketLog();
	bool Flush();

	bool MarkCallStart();
	bool AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark); 

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\naclist.cpp ===
#include "precomp.h"
#include "NacList.h"


template <class T>
NacList<T>::NacList(int nInitialSize, int nGrowthRate) : 
m_nSize(0), m_nHeadIndex(0), m_nTotalSize(nInitialSize), m_nGrowthRate(nGrowthRate)
{

	ASSERT(nInitialSize > 0);
	ASSERT(nGrowthRate > 0);

    DBG_SAVE_FILE_LINE
	m_aElements = new T[nInitialSize];
	if (m_aElements == NULL)
	{
		ERROR_OUT(("NacList::NacList - Out of memory"));
	}
}

template <class T>
NacList<T>::~NacList()
{
	Flush();
	delete [] m_aElements;
}

template <class T>
void NacList<T>::Flush()
{
	m_nHeadIndex = 0;
	m_nSize = 0;
}

template <class T>
bool NacList<T>::PeekFront(T *pT)
{
	if (m_nSize <= 0)
	{
		return false;
	}

	*pT = m_aElements[m_nHeadIndex];
	return true;
}

template <class T>
bool NacList<T>::PeekRear(T *pT)
{
	int nRearIndex;

	if (m_nSize <= 0)
	{
		return false;
	}

	nRearIndex = (m_nHeadIndex + m_nSize - 1) % m_nTotalSize;

	*pT = m_aElements[nRearIndex];
	return true;
}

template <class T>
bool NacList<T>::PushFront(const T &t)
{
	int nInsertIndex;

	// do we need to grow
	if (m_nSize >= m_nTotalSize)
	{
		Grow();
	}

	if (m_nHeadIndex == 0)
	{
		m_nHeadIndex = m_nTotalSize - 1;
	}
	else
	{
		--m_nHeadIndex;
	}

	m_aElements[m_nHeadIndex] = t;
	m_nSize++;

	return true;
}

template <class T>
bool NacList<T>::PushRear(const T &t)
{
	int nInsertIndex;

	// do we need to grow
	if (m_nSize >= m_nTotalSize)
	{
		Grow();
	}

	nInsertIndex = (m_nHeadIndex + m_nSize) % m_nTotalSize;
	m_aElements[nInsertIndex] = t;

	m_nSize++;

	return true;
}


template <class T>
bool NacList<T>::PopFront(T *pT)
{
	ASSERT(m_nSize >= 0);

	if (m_nSize <= 0)
	{
		return false;
	}

	*pT = m_aElements[m_nHeadIndex];


	m_nHeadIndex = (m_nHeadIndex + 1) % m_nTotalSize;
	m_nSize--;

	return true;
}


template <class T>
bool NacList<T>::PopRear(T *pT)
{
	int nRearIndex;

	ASSERT(m_nSize >= 0);

	if (m_nSize <= 0)
	{
		return false;
	}

	nRearIndex = (m_nHeadIndex + m_nSize - 1) % m_nTotalSize;

	*pT = m_aElements[nRearIndex];
	m_nSize--;
	return true;
}



template <class T>
int NacList<T>::Grow()
{
	T *aNew;
	int nTotalSize;
	int nIndex, nCopyIndex;

	nTotalSize = m_nTotalSize + m_nGrowthRate;

    DBG_SAVE_FILE_LINE
	aNew = new T[nTotalSize];
	if (aNew == NULL)
	{
		ERROR_OUT(("Out of Memory"));
		return 0;
	}

	for (nIndex = 0; nIndex < m_nSize; nIndex++)
	{
		nCopyIndex = (nIndex + m_nHeadIndex) % m_nTotalSize;
		aNew[nIndex] = m_aElements[nCopyIndex];
	}

	delete [] m_aElements;
	m_aElements = aNew;

	m_nTotalSize = nTotalSize;
	m_nHeadIndex = 0;

	return (nTotalSize);
}



// Thread Safe List


template <class T>
ThreadSafeList<T>::ThreadSafeList(int nInitialSize, int nGrowthRate) : 
NacList<T>(nInitialSize, nGrowthRate)
{
	InitializeCriticalSection(&m_cs);
}

template <class T>
ThreadSafeList<T>::~ThreadSafeList()
{
	DeleteCriticalSection(&m_cs);
}

template <class T>
void ThreadSafeList<T>::Flush()
{
	EnterCriticalSection(&m_cs);
	NacList<T>::Flush();
	LeaveCriticalSection(&m_cs);
}

template <class T>
bool ThreadSafeList<T>::PeekFront(T *pT)
{
	bool bRet;
	EnterCriticalSection(&m_cs);
	bRet = NacList<T>::PeekFront(pT);
	LeaveCriticalSection(&m_cs);
	return bRet;
}

template <class T>
bool ThreadSafeList<T>::PeekRear(T *pT)
{
	bool bRet;
	EnterCriticalSection(&m_cs);
	bRet = NacList<T>::PeekRear(pT);
	LeaveCriticalSection(&m_cs);
	return bRet;
}

template <class T>
bool ThreadSafeList<T>::PushFront(const T &t)
{
	bool bRet;
	EnterCriticalSection(&m_cs);
	bRet = NacList<T>::PushFront(t);
	LeaveCriticalSection(&m_cs);
	return bRet;
}

template <class T>
bool ThreadSafeList<T>::PushRear(const T &t)
{
	bool bRet;
	EnterCriticalSection(&m_cs);
	bRet = NacList<T>::PushRear(t);
	LeaveCriticalSection(&m_cs);
	return bRet;
}


template <class T>
bool ThreadSafeList<T>::PopFront(T *pT)
{
	bool bRet;
	EnterCriticalSection(&m_cs);
	bRet = NacList<T>::PopFront(pT);
	LeaveCriticalSection(&m_cs);
	return bRet;
}


template <class T>
bool ThreadSafeList<T>::PopRear(T *pT)
{
	bool bRet;
	EnterCriticalSection(&m_cs);
	bRet = NacList<T>::PopRear(pT);
	LeaveCriticalSection(&m_cs);
	return bRet;
}

template <class T>
int ThreadSafeList<T>::Size()
{
	int nRet;
	EnterCriticalSection(&m_cs);
	nRet = NacList<T>::Size();
	LeaveCriticalSection(&m_cs);
	return nRet;
}



// each instance type of the template needs to be declared here
// For example:
//   template class NacList<int>;  // list of integers
//   template class NacList<int*>; // list of pointers to integers


// you have to disable warnings for the following error, else
// the compiler thinks that a second instantiation is occuring
// when it's really only a second declaration
// This generates a warning which becomes an error
#pragma warning(disable:4660)

#include "PacketSender.h"
template class ThreadSafeList<PS_QUEUE_ELEMENT>;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\packetsender.cpp ===
#include "precomp.h"
#include "NacList.h"
#include "PacketSender.h"



PacketSender::PacketSender() : 
m_SendQueue(PS_INITSIZE, PS_GROWRATE) // shouldn't ever get big
{
	InitializeCriticalSection(&m_cs);
}

PacketSender::~PacketSender()
{
	DeleteCriticalSection(&m_cs);
}




// takes the first packets out of the queue and sends it
// returns true if a packet was taken out of the queue and sent
BOOL PacketSender::SendPacket()
{
	BOOL bRet;
	PS_QUEUE_ELEMENT pqe;
	WSABUF wsabuf;
	RTP_HDR *pRtpHdr;
	DWORD dwType=PS_AUDIO;

	EnterCriticalSection(&m_cs);

	bRet = m_SendQueue.PopFront(&pqe);
	if (bRet)
	{
		ASSERT(pqe.data);

		pRtpHdr = (RTP_HDR*)(pqe.data - sizeof(RTP_HDR));
		*(DWORD *)pRtpHdr = 0;
		pRtpHdr->ts = pqe.pMP->GetTimestamp();
		pRtpHdr->m = pqe.fMark;
		pRtpHdr->payload = pqe.pMP->GetPayload();

		if (pqe.pHeaderInfo && pqe.dwHdrSize && (pqe.dwPacketType==PS_VIDEO))
		{
			CopyMemory(pqe.data, pqe.pHeaderInfo, pqe.dwHdrSize);
		}

		wsabuf.buf = (char *)pRtpHdr;
		wsabuf.len = pqe.dwSize + sizeof(RTP_HDR);

		if (FAILED(pqe.pRTPSend->Send(&wsabuf, 1, NULL, NULL)))
		{
			LOG(((pqe.dwPacketType == PS_VIDEO) ? LOGMSG_VIDSEND_AUD_NOT_SEND : LOGMSG_AUDSEND_AUD_NOT_SEND, pqe.dwSize + sizeof (RTP_HDR), pqe.pMP->m_timestamp));
			DEBUGMSG (ZONE_DP, ("Check_Send: pRTPSend->Send failed\r\n" ));
		}
		else
		{
			LOG(((pqe.dwPacketType == PS_VIDEO) ? LOGMSG_VIDSEND_AUD_SEND : LOGMSG_AUDSEND_AUD_SEND, pqe.dwSize + sizeof (RTP_HDR), pqe.pMP->m_timestamp, GetTickCount()));
		}

    	if (pqe.pHeaderInfo)
		{
    	    MemFree ((BYTE *)(pqe.pHeaderInfo));
        }

	}

	LeaveCriticalSection(&m_cs);

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\naclist.h ===
#ifndef NAC_LIST_H
#define NAC_LIST_H


#include <wtypes.h>

// generic List template to be used as
// a Queue or Stack



template <class T> class NacList
{
private:
	typedef T *PTR_T;
	typedef T **PTR_PTR_T;

	T *m_aElements;  // array of pointers

	int m_nSize;  // number of Appended elements
	int m_nHeadIndex;
	int m_nTotalSize;  // total size of queue (used+unsed slots)
	int m_nGrowthRate;

	int Grow();

public:
	NacList(int nInitialSize, int nGrowthRate);
	~NacList();

	bool PeekFront(T *ptr);   // returns list's front (doesn't remove)
	bool PeekRear(T *ptr);    // returns list's rear (doesn't remove)

	bool PushFront(const T &t);      // adds to the front of the list
	bool PushRear(const T &t);       // adds to the rear of the list

	bool PopFront(T *ptr);    // returns and removes list's front
	bool PopRear(T *ptr);     // returns and removes list's rear

	void Flush();            // marks as list empty
	inline int Size() {return m_nSize;}
};


// Thread safe version of above
template <class T> class ThreadSafeList : public NacList<T>
{
private:
	CRITICAL_SECTION m_cs;

public:
	ThreadSafeList(int nInitialSize, int nGrowthRate);
	~ThreadSafeList();

	bool PeekFront(T *ptr);   // returns list's front (doesn't remove)
	bool PeekRear(T *ptr);    // returns list's rear (doesn't remove)

	bool PushFront(const T &t);      // adds to the front of the list
	bool PushRear(const T &t);       // adds to the rear of the list

	bool PopFront(T *ptr);    // returns and removes list's front
	bool PopRear(T *ptr);     // returns and removes list's rear

	void Flush();
	int Size();

	// note: we don't inherit "Grow" because it will only get
	// called while we are in the Critical SEction
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\rtp.h ===
/*
  RTP.H

  RTP structures and prototypes
*/

#ifndef _RTP_H_
#define _RTP_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define RTP_VERSION		2

/* Defined in rrcm_dll.h
typedef enum {
  RTCP_SDES_END	=  0,
  RTCP_SDES_CNAME  =  1,
  RTCP_SDES_NAME   =  2,
  RTCP_SDES_EMAIL  =  3,
  RTCP_SDES_PHONE  =  4,
  RTCP_SDES_LOC	=  5,
  RTCP_SDES_TOOL   =  6,
  RTCP_SDES_NOTE   =  7,
  RTCP_SDES_PRIV   =  8, 
  RTCP_SDES_IMG	=  9,
  RTCP_SDES_DOOR   = 10,
  RTCP_SDES_SOURCE = 11
} SDES_TYPE;
*/

typedef enum {
  RTCP_TYPE_SR   = 200,		// sender report
  RTCP_TYPE_RR   = 201,		// receiver report
  RTCP_TYPE_SDES = 202,		// source description
  RTCP_TYPE_BYE  = 203,		// end of session
  RTCP_TYPE_APP  = 204		// app. specific
} RTCP_TYPE;

typedef unsigned __int64 NTP_TS;

typedef struct {
	// !!! WARNING !!!
	// The following word doesn't need to be swapped for NtoH()
	unsigned short cc:4;	   /* CSRC count */
	unsigned short x:1;		/* header extension flag */
	unsigned short p:1;		/* padding flag */
	unsigned short version:2;  /* protocol version */
  	unsigned short payload:7;	   /* payload type */
	unsigned short m:1;		/* marker bit */

  	WORD seq;			 /* sequence number */
  	DWORD ts;			  /* timestamp */
  	DWORD ssrc;			/* synchronization source */
  //DWORD csrc[1];		 /* optional CSRC list */
} RTP_HDR;

// common part of RTCP header
typedef struct {
  	unsigned short version:2;  /* protocol version */
  	unsigned short p:1;		/* padding flag */
  	unsigned short count:5;	/* varies by payload type */
	unsigned short rtcpType:8;	   	/* payload type */
  	WORD length;		  /* packet length in dwords, without this hdr */
} RTCP_HDR;

/* reception report */
typedef struct {
  DWORD ssrc;			/* data source being reported */
  BYTE fracLost; /* fraction lost since last SR/RR */
  BYTE lostHi;			 /* cumulative number of packets lost (signed!) */
  WORD lostLo;
  DWORD lastSeq;		/* extended last sequence number received */
  DWORD jitter;		  /* interarrival jitter */
  DWORD lastSR;			 /* last SR packet from this source */
  DWORD delayLastSR;			/* delay since last SR packet */
} RTCP_RR;

/* sender report (SR) */
typedef struct {
  DWORD ssrc;		/* source this RTCP packet refers to */
  DWORD ntpHi;	/* NTP timestamp - seconds */
  DWORD ntpLo;	  /* mantissa */
  DWORD timestamp;	  /* RTP timestamp */
  DWORD packetsSent;	   /* packets sent */
  DWORD bytesSent;	   /* octets sent */ 
  /* variable-length list */
  //RTCP_RR rr[1];
} RTCP_SR;

/* BYE */
typedef struct {
  DWORD src[1];	  /* list of sources */
  /* can't express trailing text */
} RTCP_BYE;

typedef struct {
  BYTE type;			 /* type of SDES item (rtcp_sdes_type_t) */
  BYTE length;		   /* length of SDES item (in octets) */
  char data[1];			/* text, not zero-terminated */
} RTCP_SDES_ITEM;

/* source description (SDES) */
typedef struct  {
  DWORD src;			  /* first SSRC/CSRC */
  RTCP_SDES_ITEM item[1]; /* list of SDES items */
} RTCP_SDES;



#define INVALID_RTP_SEQ_NUMBER	0xffffffff

#include <poppack.h> /* End byte packing */

#endif // _RTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\packetsender.h ===
#ifndef _NAC_PACKET_SENDER_H_
#define _NAC_PACKET_SENDER_H_


#define PS_INITSIZE 32
#define PS_GROWRATE	10

#define PS_AUDIO	1
#define PS_VIDEO	2

#include "NacList.h"

class MediaPacket;
class TxStream;

typedef struct _psqelement
{
	MediaPacket *pMP;
	DWORD dwPacketType;
	IRTPSend *pRTPSend;
	BYTE    *data;
	DWORD   dwSize;
	UINT    fMark;
	BYTE    *pHeaderInfo;
	DWORD   dwHdrSize;
} PS_QUEUE_ELEMENT;



class PacketSender
{
private:

	// adding to the queue is done via the interface exposed by
	// m_SendQueue.  It's thread safe, but we don't want both
	// threads trying to send from this queue at the same time,
	// we may accidentally send packets our of order

	CRITICAL_SECTION m_cs;
public:

	// audio thread will "PushFront" elements containing packets
	// to this queue.  VideoThread will PushRear packets.
	ThreadSafeList<PS_QUEUE_ELEMENT> m_SendQueue;
	BOOL SendPacket();  // sends one packet in a thread safe manner

	PacketSender();
	~PacketSender();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\rvstream.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    rvstream.h

Abstract:
	The RVStream class maintains a circular list of MediaPackets. RTP packets received
	from the network are put into the ring (PutNextNetIn), then decoded and removed from the
	ring when the time comes to play them (GetNextPlay). After playback, the packets are
	returned to the ring (Release).
	The ring is implemented as an array and under normal operation the index of the next 
	MediaPacket to play (m_PlayPos) advances by one when GetNextPlay is called.
	RVstream is intended for video packets. Each entry in the ring corresponds to a
	RTP packet as opposed to a time slot.
--*/
#ifndef _RVSTREAM_H_
#define _RVSTREAM_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */
void FreeNetBufList(NETBUF *pNB);
void AppendNetBufList(NETBUF *pFirstNB, NETBUF *pNB);


class RVStream : public RxStream {
public:
	RVStream(UINT size): RxStream(size){ m_NetBufList = NULL; m_LastGoodSeq=0xFFFF; m_pVideoFilter=NULL; m_NetBufPool.Initialize(40, sizeof(NETBUF)+sizeof(WSABUF **)); };
	virtual MediaPacket *GetNextPlay();
	virtual HRESULT PutNextNetIn(WSABUF *pNetBuf, DWORD timestamp, UINT seq, UINT fMark, BOOL *pfSkippedData, BOOL *pfSyncPoint);
	virtual BOOL ReleaseNetBuffers() ;
	virtual HRESULT FastForward( BOOL fSilenceOnly);
	HRESULT Reset(UINT seq,DWORD timestamp);
	virtual HRESULT SetLastGoodSeq(UINT seq);
	virtual Destroy();
	virtual Initialize(UINT flags, UINT size, IRTPRecv *, MEDIAPACKETINIT *papi, ULONG ulSamplesPerPacket, ULONG ulSamplesPerSec, VcmFilter *pVideoFilter);
	HRESULT RestorePacket(NETBUF *pNetBuf, MediaPacket *pVP, DWORD timestamp, UINT seq, UINT fMark, BOOL *pfReceivedKeyframe);

private:
	HRESULT ReassembleFrame(NETBUF *pNetBuf, UINT seq, UINT fMark);
	BufferPool m_NetBufPool;
	NETBUF *m_NetBufList;
	WORD m_LastGoodSeq;

	VcmFilter *m_pVideoFilter;

	virtual void StartDecode();
};


#include <poppack.h> /* End byte packing */



#endif // _RVSTREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\recvaudio.cpp ===
#include "precomp.h"

#ifdef PLS_DEBUG
#include "plog.h"
extern CPacketLog *g_pPacketLog;
#endif

// #define LOGSTATISTICS_ON 1

UINT g_MinWaveAudioDelayMs=240;	// minimum millisecs of introduced playback delay (Wave)
UINT g_MaxAudioDelayMs=750;	// maximum milliesecs of introduced playback delay
UINT g_MinDSEmulAudioDelayMs=240; // minimum delay (DirectSound on emulated driver)

HRESULT STDMETHODCALLTYPE RecvAudioStream::QueryInterface(REFIID iid, void **ppVoid)
{
	// resolve duplicate inheritance to the RecvMediaStream;

	extern IID IID_IProperty;

	if (iid == IID_IUnknown)
	{
		*ppVoid = (IUnknown*)((RecvMediaStream*)this);
	}
	else if (iid == IID_IMediaChannel)
	{
		*ppVoid = (IMediaChannel*)((RecvMediaStream *)this);
	}
	else if (iid == IID_IAudioChannel)
	{
		*ppVoid = (IAudioChannel*)this;
	}
	else if (iid == IID_IProperty)
	{
		*ppVoid = NULL;
		ERROR_OUT(("Don't QueryInterface for IID_IProperty, use IMediaChannel"));
		return E_NOINTERFACE;
	}
	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}
	AddRef();

	return S_OK;

}

ULONG STDMETHODCALLTYPE RecvAudioStream::AddRef(void)
{
	return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE RecvAudioStream::Release(void)
{
	LONG lRet;
	lRet = InterlockedDecrement(&m_lRefCount);
	if (lRet == 0)
	{
		delete this;
		return 0;
	}
	else
		return lRet;
}


HRESULT
RecvAudioStream::Initialize( DataPump *pDP)
{
	HRESULT hr = DPR_OUT_OF_MEMORY;
	DWORD dwFlags =  DP_FLAG_FULL_DUPLEX | DP_FLAG_AUTO_SWITCH ;
	MEDIACTRLINIT mcInit;
	FX_ENTRY ("RecvAudioStream::Initialize")

	InitializeCriticalSection(&m_crsAudQoS);
	dwFlags |= DP_FLAG_ACM | DP_FLAG_MMSYSTEM | DP_FLAG_AUTO_SILENCE_DETECT;

	// store the platform flags
	// enable Send and Recv by default
	m_DPFlags = (dwFlags & DP_MASK_PLATFORM) | DPFLAG_ENABLE_SEND | DPFLAG_ENABLE_RECV;
	// store a back pointer to the datapump container
	m_pDP = pDP;
	m_pIRTPRecv = NULL;
	m_Net = NULL;  // this object (m_Net) no longer used (at least for now)
	m_dwSrcSize = 0;
	

	// Initialize data (should be in constructor)
	m_RenderingDevice = (UINT) -1;	// use VIDEO_MAPPER



	// Create Receive and Transmit audio streams
    DBG_SAVE_FILE_LINE
	m_RecvStream = new RxStream(MAX_RXRING_SIZE);
		
	if (!m_RecvStream )
	{
		DEBUGMSG (ZONE_DP, ("%s: RxStream or TxStream new failed\r\n", _fx_));
 		goto StreamAllocError;
	}


	// Create Input and Output audio filters
    DBG_SAVE_FILE_LINE
	m_pAudioFilter = new AcmFilter();
	if (!m_pAudioFilter)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmManager new failed\r\n", _fx_));
		goto FilterAllocError;
	}
	
	//Create MultiMedia device control objects
    DBG_SAVE_FILE_LINE
	m_OutMedia = new WaveOutControl();
	if ( !m_OutMedia)
	{
		DEBUGMSG (ZONE_DP, ("%s: MediaControl new failed\r\n", _fx_));
		goto MediaAllocError;
	}

	// Initialize the recv-stream media control object
	mcInit.dwFlags = dwFlags | DP_FLAG_RECV;
	hr = m_OutMedia->Initialize(&mcInit);
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: OMedia->Init failed, hr=0x%lX\r\n", _fx_, hr));
		goto MediaAllocError;
	}

	// determine if the wave devices are available
	if (waveOutGetNumDevs()) m_DPFlags |= DP_FLAG_PLAY_CAP;
	
	// set media to half duplex mode by default
	m_OutMedia->SetProp(MC_PROP_DUPLEX_TYPE, DP_FLAG_HALF_DUPLEX);

	m_DPFlags |= DPFLAG_INITIALIZED;

	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 0, REP_SYS_AUDIO_DSOUND);
	RETAILMSG(("NAC: Audio Subsystem: WAVE"));

	return DPR_SUCCESS;


MediaAllocError:
	if (m_OutMedia) delete m_OutMedia;
FilterAllocError:
	if (m_pAudioFilter) delete m_pAudioFilter;
StreamAllocError:
	if (m_RecvStream) delete m_RecvStream;

	ERRORMESSAGE( ("%s: exit, hr=0x%lX\r\n", _fx_, hr));

	return hr;
}

RecvAudioStream::~RecvAudioStream()
{

	if (m_DPFlags & DPFLAG_INITIALIZED) {
		m_DPFlags &= ~DPFLAG_INITIALIZED;
	
		if (m_DPFlags & DPFLAG_CONFIGURED_RECV)
			UnConfigure();

		if (m_pIRTPRecv)
		{
			m_pIRTPRecv->Release();
			m_pIRTPRecv = NULL;
		}

		// Close the receive and transmit streams
		if (m_RecvStream) delete m_RecvStream;

		// Close the wave devices
		if (m_OutMedia) { delete m_OutMedia;}

		// close the filter
		if (m_pAudioFilter)
			delete m_pAudioFilter;

		m_pDP->RemoveMediaChannel(MCF_RECV|MCF_AUDIO, (IMediaChannel*)(RecvMediaStream*)this);
	}
	DeleteCriticalSection(&m_crsAudQoS);
}



HRESULT STDMETHODCALLTYPE RecvAudioStream::Configure(
	BYTE *pFormat,
	UINT cbFormat,
	BYTE *pChannelParams,
	UINT cbParams,
	IUnknown *pUnknown)
{
	HRESULT hr;
	BOOL fRet;
	MEDIAPACKETINIT apInit;
	MEDIACTRLCONFIG mcConfig;
	MediaPacket **ppAudPckt;
	ULONG cAudPckt;
	DWORD_PTR dwPropVal;
	DWORD dwFlags;
	AUDIO_CHANNEL_PARAMETERS audChannelParams;
	UINT uAudioCodec;
	UINT ringSize = MAX_RXRING_SIZE;
	WAVEFORMATEX *pwfRecv;
	UINT maxRingSamples;
	MMRESULT mmr;

	
	FX_ENTRY ("RecvAudioStream::Configure")


	if (m_DPFlags & DPFLAG_STARTED_RECV)
	{
		return DPR_IO_PENDING; // anything better to return
	}

	if (m_DPFlags & DPFLAG_CONFIGURED_RECV)
	{
		DEBUGMSG(ZONE_DP, ("Stream Re-Configuration - calling UnConfigure"));
		UnConfigure();
	}

	// get format details
	if ((NULL == pFormat) || (NULL == pChannelParams) ||
	    (cbFormat < sizeof(WAVEFORMATEX)) )

	{
		return DPR_INVALID_PARAMETER;
	}


	audChannelParams = *(AUDIO_CHANNEL_PARAMETERS *)pChannelParams;
	pwfRecv = (WAVEFORMATEX *)pFormat;

	if (! (m_DPFlags & DPFLAG_INITIALIZED))
		return DPR_OUT_OF_MEMORY;		//BUGBUG: return proper error;
		
	// full or half duplex ? get flags from media control - use the record side
	hr = m_OutMedia->GetProp(MC_PROP_DUPLEX_TYPE, &dwPropVal);
    dwFlags = (DWORD)dwPropVal;

	if(!HR_SUCCEEDED(hr))
	{
		dwFlags = DP_FLAG_HALF_DUPLEX | DP_FLAG_AUTO_SWITCH;
	}
//	if (m_Net)
//	{
//		hr = m_Net->QueryInterface(IID_IRTPRecv, (void **)&m_pIRTPRecv);
//		if (!SUCCEEDED(hr))
//			return hr;
//	}
	
	
	mcConfig.uDuration = MC_USING_DEFAULT;	// set duration by samples per pkt
	

	mmr = AcmFilter::SuggestDecodeFormat(pwfRecv, &m_fDevRecv);

	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfRecv->wFormatTag, REP_RECV_AUDIO_FORMAT);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfRecv->nSamplesPerSec, REP_RECV_AUDIO_SAMPLING);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfRecv->nAvgBytesPerSec*8, REP_RECV_AUDIO_BITRATE);
	RETAILMSG(("NAC: Audio Recv Format: %s", (pwfRecv->wFormatTag == 66) ? "G723.1" : (pwfRecv->wFormatTag == 112) ? "LHCELP" : (pwfRecv->wFormatTag == 113) ? "LHSB08" : (pwfRecv->wFormatTag == 114) ? "LHSB12" : (pwfRecv->wFormatTag == 115) ? "LHSB16" : (pwfRecv->wFormatTag == 6) ? "MSALAW" : (pwfRecv->wFormatTag == 7) ? "MSULAW" : (pwfRecv->wFormatTag == 130) ? "MSRT24" : "??????"));
	RETAILMSG(("NAC: Audio Recv Sampling Rate (Hz): %ld", pwfRecv->nSamplesPerSec));
	RETAILMSG(("NAC: Audio Recv Bitrate (w/o network overhead - bps): %ld", pwfRecv->nAvgBytesPerSec*8));

	// Initialize the recv-stream media control object
	mcConfig.pDevFmt = &m_fDevRecv;
	mcConfig.hStrm = (DPHANDLE) m_RecvStream;
	mcConfig.uDevId = m_RenderingDevice;
	mcConfig.cbSamplesPerPkt = audChannelParams.ns_params.wFrameSize
									*audChannelParams.ns_params.wFramesPerPkt;

	UPDATE_REPORT_ENTRY(g_prptCallParameters, mcConfig.cbSamplesPerPkt, REP_RECV_AUDIO_PACKET);
	RETAILMSG(("NAC: Audio Recv Packetization (ms/packet): %ld", pwfRecv->nSamplesPerSec ? mcConfig.cbSamplesPerPkt * 1000UL / pwfRecv->nSamplesPerSec : 0));
	INIT_COUNTER_MAX(g_pctrAudioReceiveBytes, (pwfRecv->nAvgBytesPerSec + pwfRecv->nSamplesPerSec * (sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE) / mcConfig.cbSamplesPerPkt) << 3);

	hr = m_OutMedia->Configure(&mcConfig);
	// Check if we can open the wave device. This is just to give advance notice of
	// sound card being busy.
	//	Stop any high level ("PlaySound()") usage of wave device.
	//
	PlaySound(NULL,NULL, 0);
//	if (hr == DPR_SUCCESS && !(dwFlags & DP_FLAG_HALF_DUPLEX)) {
//		hr = m_OutMedia->Open ();
//	}
	
//	if (hr != DPR_SUCCESS)
//	{
//		DEBUGMSG (ZONE_DP, ("%s: OMedia->Config failed, hr=0x%lX\r\n", _fx_, hr));
//		goto OMediaInitError;
//	}
	
	mmr = m_pAudioFilter->Open(pwfRecv, &m_fDevRecv);
	if (mmr != 0)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmFilter->Open failed, mmr=%d\r\n", _fx_, mmr));
		hr = DPR_CANT_OPEN_CODEC;
		goto RecvFilterInitError;
	}


	// Initialize the recv stream
	ZeroMemory (&apInit, sizeof (apInit));

	apInit.dwFlags = DP_FLAG_RECV | DP_FLAG_ACM | DP_FLAG_MMSYSTEM;
	apInit.pStrmConvSrcFmt = pwfRecv;
	apInit.pStrmConvDstFmt = &m_fDevRecv;


	m_OutMedia->FillMediaPacketInit (&apInit);

	apInit.cbSizeRawData = apInit.cbSizeDevData;

	m_pAudioFilter->SuggestSrcSize(apInit.cbSizeDevData, &m_dwSrcSize);


	apInit.cbSizeNetData = m_dwSrcSize;
	apInit.cbOffsetNetData = sizeof (RTP_HDR);

	m_OutMedia->GetProp (MC_PROP_SPP, &dwPropVal);
	// set our total receive buffering capacity to somewhere between
	// 2 and 4 seconds.
	// Also make sure that the buffering capacity is at least one
	// second more than maxAudioDelay
	maxRingSamples = pwfRecv->nSamplesPerSec + pwfRecv->nSamplesPerSec*g_MaxAudioDelayMs/1000;

	if (maxRingSamples < 4*pwfRecv->nSamplesPerSec)
		maxRingSamples = 4*pwfRecv->nSamplesPerSec;
	while (ringSize* dwPropVal > maxRingSamples && ringSize > 8)
		ringSize = ringSize/2;
	dwFlags = DP_FLAG_MMSYSTEM;
	// if sender is not doing silence detection, we do it
	// on the receive side
	if (!audChannelParams.ns_params.UseSilenceDet)
		dwFlags |= DP_FLAG_AUTO_SILENCE_DETECT;
	fRet = m_RecvStream->Initialize (dwFlags, ringSize, NULL, &apInit, (DWORD)dwPropVal, pwfRecv->nSamplesPerSec, m_pAudioFilter);
	if (! fRet)
	{
		DEBUGMSG (ZONE_DP, ("%s: RxStream->Init failed, fRet=0%u\r\n", _fx_, fRet));
		hr = DPR_CANT_INIT_RX_STREAM;
		goto RxStreamInitError;
	}

	// WS2Qos will be called in Start to communicate stream reservations to the
	// remote endpoint using a RESV message
	//
	// We use a peak-rate allocation approach based on our target bitrates
	// Note that for the token bucket size and the maximum SDU size, we now
	// account for IP header overhead, and use the max frame fragment size
	// instead of the maximum compressed image size returned by the codec
	//
	// Some of the parameters are left unspecified because they are set
	// in the sender Tspec.

	InitAudioFlowspec(&m_flowspec, pwfRecv, m_dwSrcSize);


	// prepare headers for RxStream
	m_RecvStream->GetRing (&ppAudPckt, &cAudPckt);
	m_OutMedia->RegisterData (ppAudPckt, cAudPckt);
//	m_OutMedia->PrepareHeaders ();

	m_pAudioFilter->PrepareAudioPackets((AudioPacket**)ppAudPckt, cAudPckt, AP_DECODE);

	// Open the record to wav file
	AudioFile::OpenDestFile(&m_mmioDest, &m_fDevRecv);

	m_DPFlags |= DPFLAG_CONFIGURED_RECV;

#ifdef TEST
	LOG((LOGMSG_TIME_RECV_AUDIO_CONFIGURE,GetTickCount() - dwTicks));
#endif

	return DPR_SUCCESS;

RxStreamInitError:
RecvFilterInitError:
	m_pAudioFilter->Close();
	m_OutMedia->Close();
//OMediaInitError:
	if (m_pIRTPRecv)
	{
		m_pIRTPRecv->Release();
		m_pIRTPRecv = NULL;
	}
	ERRORMESSAGE(("%s:  failed, hr=0%u\r\n", _fx_, hr));
	return hr;
}


void RecvAudioStream::UnConfigure()
{

	AudioPacket **ppAudPckt=NULL;
	ULONG uPackets;

#ifdef TEST
	DWORD dwTicks;

	dwTicks = GetTickCount();
#endif

	if ((m_DPFlags & DPFLAG_CONFIGURED_RECV)) {


		Stop();


		// Close the RTP state if its open
		//m_Net->Close(); We should be able to do this in Disconnect()
	
		m_Net = NULL;

		m_OutMedia->Reset();
		m_OutMedia->UnprepareHeaders();
		m_OutMedia->Close();
		// Close the record to wav file
		AudioFile::CloseDestFile(&m_mmioDest);

		// Close the filters
		m_RecvStream->GetRing ((MediaPacket***)&ppAudPckt, &uPackets);
		m_pAudioFilter->UnPrepareAudioPackets(ppAudPckt, uPackets, AP_DECODE);

		m_pAudioFilter->Close();


		// Close the receive streams
		m_RecvStream->Destroy();

        m_DPFlags &= ~(DPFLAG_CONFIGURED_RECV);

	}
#ifdef TEST
	LOG((LOGMSG_TIME_RECV_AUDIO_UNCONFIGURE,GetTickCount() - dwTicks));
#endif

}

DWORD CALLBACK RecvAudioStream::StartPlaybackThread(LPVOID pVoid)
{
	RecvAudioStream *pThisStream = (RecvAudioStream *)pVoid;
	return pThisStream->PlaybackThread();
}



HRESULT
RecvAudioStream::Start()
{
	FX_ENTRY ("RecvAudioStream::Start");
	
	if (m_DPFlags & DPFLAG_STARTED_RECV)
		return DPR_SUCCESS;
	// TODO: remove this check once audio UI calls the IComChan PAUSE_RECV prop
	if (!(m_DPFlags & DPFLAG_ENABLE_RECV))
		return DPR_SUCCESS;
	if ((!(m_DPFlags & DPFLAG_CONFIGURED_RECV)) || (NULL==m_pIRTPRecv))
		return DPR_NOT_CONFIGURED;
	ASSERT(!m_hRenderingThread );
	m_ThreadFlags &= ~(DPTFLAG_STOP_PLAY|DPTFLAG_STOP_RECV);

	SetFlowSpec();

	// Start playback thread
	if (!(m_ThreadFlags & DPTFLAG_STOP_PLAY))
		m_hRenderingThread = CreateThread(NULL,0,RecvAudioStream::StartPlaybackThread,this,0,&m_RenderingThId);
	// Start receive thread
    m_pDP->StartReceiving(this);
    m_DPFlags |= DPFLAG_STARTED_RECV;
	DEBUGMSG (ZONE_DP, ("%s: Play ThId=%x\r\n",_fx_, m_RenderingThId));
	return DPR_SUCCESS;
}

// LOOK: Identical to RecvVideoStream version.
HRESULT
RecvAudioStream::Stop()
{
	DWORD dwWait;
	
	FX_ENTRY ("RecvAudioStream::Stop");

	if(!(m_DPFlags &  DPFLAG_STARTED_RECV))
	{
		return DPR_SUCCESS;
	}

	m_ThreadFlags = m_ThreadFlags  |
		DPTFLAG_STOP_RECV |  DPTFLAG_STOP_PLAY ;

	m_pDP->StopReceiving(this);
	
DEBUGMSG (ZONE_VERBOSE, ("%s: hRenderingThread=%x\r\n",_fx_, m_hRenderingThread));

	/*
	 *	we want to wait for all the threads to exit, but we need to handle windows
	 *	messages (mostly from winsock) while waiting.
	 */

	if(m_hRenderingThread)
	{
		dwWait = WaitForSingleObject(m_hRenderingThread, INFINITE);

		DEBUGMSG (ZONE_VERBOSE, ("%s: dwWait =%d\r\n", _fx_,  dwWait));
		ASSERT(dwWait != WAIT_FAILED);

		CloseHandle(m_hRenderingThread);
		m_hRenderingThread = NULL;
	}

    //This is per channel, but the variable is "DPFlags"
 	m_DPFlags &= ~DPFLAG_STARTED_RECV;

	
	return DPR_SUCCESS;
}


// low order word is the signal strength
// high order work contains bits to indicate status
// (0x01 - receiving (actually playing))
// (0x02 - audio device is jammed)
STDMETHODIMP RecvAudioStream::GetSignalLevel(UINT *pSignalStrength)
{
	DWORD dwLevel;
	DWORD dwJammed;
    DWORD_PTR dwPropVal;

	if ( (!(m_DPFlags & DPFLAG_STARTED_RECV)) ||
		 (m_ThreadFlags & DPTFLAG_PAUSE_RECV))
	{
		dwLevel = 0;
	}
	else
	{
		m_RecvStream->GetSignalStrength(&dwLevel);
		dwLevel = (dwLevel >> 8) & 0x00ff;
		dwLevel = LogScale[dwLevel];

		m_OutMedia->GetProp(MC_PROP_AUDIO_JAMMED, &dwPropVal);
        dwJammed = (DWORD)dwPropVal;

		if (dwJammed)
		{
			dwLevel = (2 << 16);
		}
		else if (m_fReceiving)
		{
			dwLevel |= (1 << 16);
		}
	}
	*pSignalStrength = dwLevel;
	return S_OK;
};




//  IProperty::GetProperty / SetProperty
//  (DataPump::MediaChannel::GetProperty)
//      Properties of the MediaChannel. Supports properties for both audio
//      and video channels.

STDMETHODIMP
RecvAudioStream::GetProperty(
	DWORD prop,
	PVOID pBuf,
	LPUINT pcbBuf
    )
{
	HRESULT hr = DPR_SUCCESS;
	RTP_STATS RTPStats;
	DWORD_PTR dwPropVal;
	UINT len = sizeof(DWORD);	// most props are DWORDs

	if (!pBuf || *pcbBuf < len)
    {
		*pcbBuf = len;
		return DPR_INVALID_PARAMETER;
	}

	switch (prop)
    {
	case PROP_RECV_AUDIO_STRENGTH:
		return GetSignalLevel((UINT *)pBuf);
		

	case PROP_AUDIO_JAMMED:
		hr = m_OutMedia->GetProp(MC_PROP_AUDIO_JAMMED, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

#ifdef OLDSTUFF
	case PROP_NET_RECV_STATS:
		if (m_Net && *pcbBuf >= sizeof(RTP_STATS))
        {
			m_Net->GetRecvStats((RTP_STATS *)pBuf);
			*pcbBuf = sizeof(RTP_STATS);
		} else
			hr = DPR_INVALID_PROP_VAL;
			
		break;
#endif

	case PROP_DURATION:
		hr = m_OutMedia->GetProp(MC_PROP_DURATION, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_VOLUME:
		hr = m_OutMedia->GetProp(MC_PROP_VOLUME, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_DUPLEX_TYPE:
		hr = m_OutMedia->GetProp(MC_PROP_DUPLEX_TYPE, &dwPropVal);
		if(HR_SUCCEEDED(hr))
		{
			if(dwPropVal & DP_FLAG_FULL_DUPLEX)
				*(DWORD *)pBuf = DUPLEX_TYPE_FULL;
			else
				*(DWORD *)pBuf = DUPLEX_TYPE_HALF;
		}
		break;

	case PROP_AUDIO_SPP:
		hr = m_OutMedia->GetProp(MC_PROP_SPP, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_AUDIO_SPS:
		hr = m_OutMedia->GetProp(MC_PROP_SPS, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_WAVE_DEVICE_TYPE:
		*(DWORD *)pBuf = m_DPFlags & DP_MASK_WAVE_DEVICE;
		break;

	case PROP_PLAY_ON:
		*(DWORD *)pBuf = (m_ThreadFlags & DPFLAG_ENABLE_RECV)!=0;
		break;

	case PROP_PLAYBACK_DEVICE:
		*(DWORD *)pBuf = m_RenderingDevice;
		break;

	case PROP_VIDEO_AUDIO_SYNC:
		*(DWORD *)pBuf = ((m_DPFlags & DPFLAG_AV_SYNC) != 0);
		break;
	
	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}


STDMETHODIMP
RecvAudioStream::SetProperty(
	DWORD prop,
	PVOID pBuf,
	UINT cbBuf
    )
{
	DWORD_PTR dwPropVal;
	HRESULT hr = S_OK;
	
	if (cbBuf < sizeof (DWORD))
		return DPR_INVALID_PARAMETER;

	switch (prop)
    {
    case PROP_VOLUME:
        dwPropVal = *(DWORD *)pBuf;
		hr = m_OutMedia->SetProp(MC_PROP_VOLUME, dwPropVal);
		break;

	case PROP_DUPLEX_TYPE:
		ASSERT(0);
		break;
		
	case DP_PROP_DUPLEX_TYPE:
		// internal version, called by DataPump::SetDuplexMode() after ensuring streams are stopped
		dwPropVal = *(DWORD *)pBuf;
		if (dwPropVal)
		{
			dwPropVal = DP_FLAG_FULL_DUPLEX;
		}
		else
		{
			dwPropVal = DP_FLAG_HALF_DUPLEX;
		}
		m_OutMedia->SetProp(MC_PROP_DUPLEX_TYPE, dwPropVal);
		break;

	case PROP_PLAY_ON:
	{
		if (*(DWORD *)pBuf)   // unmute
		{
			m_ThreadFlags &= ~DPTFLAG_PAUSE_RECV;
		}
		else  // mute
		{
			m_ThreadFlags |= DPTFLAG_PAUSE_RECV;
		}

//		DWORD flag =  DPFLAG_ENABLE_RECV;
//		if (*(DWORD *)pBuf) {
//			m_DPFlags |= flag; // set the flag
//			hr = Start();
//		}
//		else
//		{
//			m_DPFlags &= ~flag; // clear the flag
//			hr = Stop();
//		}

		RETAILMSG(("NAC: %s", *(DWORD *)pBuf ? "Enabling":"Disabling"));
		break;
	}	
	case PROP_PLAYBACK_DEVICE:
		m_RenderingDevice = *(DWORD *)pBuf;
		RETAILMSG(("NAC: Setting default playback device to %d", m_RenderingDevice));
		break;
	
    case PROP_VIDEO_AUDIO_SYNC:
		if (*(DWORD *)pBuf)
    		m_DPFlags |= DPFLAG_AV_SYNC;
		else
			m_DPFlags &= ~DPFLAG_AV_SYNC;
    	break;

	default:
		return DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}

HRESULT
RecvAudioStream::GetCurrentPlayNTPTime(NTP_TS *pNtpTime)
{
	DWORD rtpTime;
#ifdef OLDSTUFF
	if ((m_DPFlags & DPFLAG_STARTED_RECV) && m_fReceiving) {
		if (m_Net->RTPtoNTP(m_PlaybackTimestamp,pNtpTime))
			return S_OK;
	}
#endif
	return 0xff;	// return proper error
		
}

BOOL RecvAudioStream::IsEmpty() {
	return m_RecvStream->IsEmpty();
}

/*
	Called by the recv thread to setup the stream for receiving.
	Post the initial recv buffer(s). Subsequently, the buffers are posted
	in the RTPRecvCallback()
*/
HRESULT
RecvAudioStream::StartRecv(HWND hWnd)
{
	HRESULT hr = S_OK;
	DWORD dwPropVal = 0;
	if ((!(m_ThreadFlags & DPTFLAG_STOP_RECV) ) && (m_DPFlags  & DPFLAG_CONFIGURED_RECV)){
//		m_RecvFilter->GetProp (FM_PROP_SRC_SIZE, &dwPropVal);
		hr =m_pIRTPRecv->SetRecvNotification(&RTPRecvCallback, (DWORD_PTR)this, 2);
		
	}

	return hr;
}

/*
	Called by the recv thread to suspend receiving  on this RTP session
	If there are outstanding receive buffers they have to be recovered
*/

HRESULT
RecvAudioStream::StopRecv()
{
	// dont recv on this stream

	m_pIRTPRecv->CancelRecvNotification();

	return S_OK;		
}

HRESULT RecvAudioStream::RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark)
{
	HRESULT hr;
	DWORD_PTR dwPropVal;

	// if we are paused, reject the packet
	if (m_ThreadFlags & DPTFLAG_PAUSE_RECV)
	{
		return E_FAIL;
	}

	// The last two parameters are only used by the recv video stream
	hr = m_RecvStream->PutNextNetIn(pWsaBuf, timestamp, seq, fMark, NULL, NULL);

	m_pIRTPRecv->FreePacket(pWsaBuf);

	if (SUCCEEDED(hr))
	{
		m_OutMedia->GetProp (MC_PROP_EVENT_HANDLE, &dwPropVal);
		if (dwPropVal)
		{
			SetEvent( (HANDLE) dwPropVal);
		}
		else
		{
			DEBUGMSG(ZONE_DP,("PutNextNetIn (ts=%d,seq=%d,fMark=%d) failed with 0x%lX\r\n",timestamp,seq,fMark,hr));
		}
	}

	return S_OK;

}


// global RTP callback function for all receive streams
BOOL
RTPRecvCallback(
	DWORD_PTR dwCallback,
	WSABUF *pNetRecvBuf
	)
{
	HRESULT hr;
	DWORD timestamp;
	UINT seq;
	BOOL fMark;
	RecvMediaStream *pRecvMC = (RecvMediaStream *)dwCallback;
	
	RTP_HDR *pRTPHdr;
	pRTPHdr = (RTP_HDR *)pNetRecvBuf->buf;
	
	timestamp = pRTPHdr->ts;
	seq = pRTPHdr->seq;
	fMark = pRTPHdr->m;
		
		// packet looks okay
	LOG((LOGMSG_NET_RECVD,timestamp,seq,GetTickCount()));

	hr = pRecvMC->RTPCallback(pNetRecvBuf,timestamp,seq,fMark);
	if (SUCCEEDED(hr))
	{
		return TRUE;
	}
	return FALSE;
}

#define MAX_SILENCE_LEVEL 75*256
#define MIN_SILENCE_LEVEL 10*256


AudioSilenceDetector::AudioSilenceDetector()
{
 	// initialize silence detector stats
	// start with a high value because the estimator falls fast but rises slowly
	m_iSilenceAvg = MAX_SILENCE_LEVEL - MIN_SILENCE_LEVEL;
	m_iTalkAvg = 0;
	m_iSilenceLevel = MAX_SILENCE_LEVEL;

	m_uManualSilenceLevel = 1000;	// use auto mode.
}

// update adaptive silence threshold variables in SendAudioStats
// using m_dwMaxStrength (the max. peak to peak value in a buffer)
// return TRUE if below threshold
BOOL AudioSilenceDetector::SilenceDetect(WORD wStrength)
{
	int fSilence;
	INT strength;

	m_dwMaxStrength = wStrength;
	strength = LogScale[m_dwMaxStrength >> 8] << 8;

	// UI sets the silence threshold high ( == 1000/1000) to indicate
	// automatic silence detection
	if (m_uManualSilenceLevel >= 1000) {
		LOG((LOGMSG_AUTO_SILENCE,strength >> 8,m_iSilenceLevel >> 8,m_iSilenceAvg>>8));
		if (strength > m_iSilenceLevel) {
			// talking
			// increase threshold slowly
			// BUGBUG: should depend on time interval
			m_iSilenceLevel += 50;	//increased from 25- GJ
			m_iTalkAvg += (strength -m_iTalkAvg)/16;
			fSilence = FALSE;
		} else {
			// silence
			// update the average silence level
			m_iSilenceAvg += (strength - m_iSilenceAvg)/16;
			// set the threshold to the avg silence + a constant
			m_iSilenceLevel = m_iSilenceAvg + MIN_SILENCE_LEVEL;
			fSilence = TRUE;
		}
		if (m_iSilenceLevel > MAX_SILENCE_LEVEL)
			m_iSilenceLevel = MAX_SILENCE_LEVEL;
	} else {
		// use the user-specified silence threshold
		// oddly, the manual silence level is in a different range [0,1000]
		DWORD dwSilenceLevel = m_uManualSilenceLevel * 65536/1000;
		fSilence = (m_dwMaxStrength < dwSilenceLevel);
		LOG((LOGMSG_AUTO_SILENCE,m_dwMaxStrength, dwSilenceLevel ,0));
	}
	return fSilence;
}


// this method called from the UI thread only
HRESULT RecvAudioStream::DTMFBeep()
{
	int nBeeps;
	MediaPacket **ppAudPckt=NULL, *pPacket=NULL;
	void *pBuffer;
	ULONG uCount;
	UINT uBufferSize=0;

	if ( (!(m_DPFlags & DPFLAG_STARTED_RECV)) ||
		 (m_ThreadFlags & DPTFLAG_PAUSE_RECV) )
	{
		return E_FAIL;
	}

	// how many packets do we inject into the stream ?
	m_RecvStream->GetRing(&ppAudPckt, &uCount);
	pPacket = ppAudPckt[0];
	pPacket->GetDevData(&pBuffer, &uBufferSize);

	if (uBufferSize == 0)
	{
		return E_FAIL;
	}

	nBeeps = DTMF_FEEDBACK_BEEP_MS / ((uBufferSize * 1000) / m_fDevRecv.nAvgBytesPerSec);

	if (nBeeps == 0)
	{
		nBeeps = 1;
	}

	m_RecvStream->InjectBeeps(nBeeps);

	return S_OK;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\rvstream.cpp ===
/*
	RVSTREAM.C
*/

#include "precomp.h"

#define PLAYOUT_DELAY_FACTOR	2
#ifndef MAX_MISORDER
#define MAX_MISORDER 30
#endif

void FreeNetBufList(NETBUF *pNB, IRTPRecv *pRTP)
{
	NETBUF *pNBTemp;
	while (pNB) {
		pNBTemp = pNB;
		pNB = pNB->next;
		if (pRTP) pRTP->FreePacket(*(WSABUF **)(pNBTemp + 1));
		pNBTemp->pool->ReturnBuffer(pNBTemp);
	}	
}

void AppendNetBufList(NETBUF *pFirstNB, NETBUF *pNB)
{
	NETBUF *pNB1 = pFirstNB;
	while (pNB1->next) {
		ASSERT(pNB != pNB1);
		pNB1 = pNB1->next;
	}
	ASSERT(pNB != pNB1);
	pNB1->next = pNB;
}



int RVStream::Initialize(UINT flags, UINT size, IRTPRecv *pRTP, MEDIAPACKETINIT *papi, ULONG ulSamplesPerPacket, ULONG ulSamplesPerSec, VcmFilter *pVideoFilter)
{
	m_pVideoFilter = pVideoFilter;
	return ((RxStream*)this)->Initialize(flags, size, pRTP, papi, ulSamplesPerPacket, ulSamplesPerSec);
}




/*
	Queues a received RTP packet.
	The packet is described by pNetBuf.
	This routine will take care of freeing pNetBuf (even in error cases)
*/
HRESULT
RVStream::PutNextNetIn(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark, BOOL *pfSkippedData, BOOL *pfSyncPoint)
{
	FX_ENTRY("RVStream::PutNextNetIn");

	UINT pos;
	MediaPacket *pAP;
	NETBUF *pNB_Packet;
	HRESULT hr;
	NETBUF *pNetBuf = (NETBUF *)m_NetBufPool.GetBuffer();
	ASSERT(pNetBuf);

	EnterCriticalSection(&m_CritSect);

	*pfSkippedData = FALSE;
	*pfSyncPoint = FALSE;

	if (pNetBuf == NULL)
	{
		hr = E_OUTOFMEMORY;
		WARNING_OUT(("RVStream::PutNextNetIn - Out of memory in buffer pool"));
		m_pRTP->FreePacket(pWsaBuf);
		goto ErrorExit;
	}

	*(WSABUF **)(pNetBuf+1) = pWsaBuf;	// cache the WSABUF pointer so it can be returned later
	pNetBuf->data = (PBYTE) pWsaBuf->buf + sizeof(RTP_HDR);
	pNetBuf->length = pWsaBuf->len - sizeof(RTP_HDR);
	pNetBuf->next = NULL;
	pNetBuf->pool = &m_NetBufPool;

	hr = ReassembleFrame(pNetBuf, seq, fMark);

	if (hr != DPR_SUCCESS)
	{
		// free pNetBuf since its not yet on m_NetBufList.
		// m_NetBufList will be freed at ErrorExit
		::FreeNetBufList(pNetBuf,m_pRTP);
		goto ErrorExit;
	}

	// not the end of the frame
	if (!fMark)
	{
		LeaveCriticalSection(&m_CritSect);
		return S_FALSE;  // success, but not a new frame yet
	}

	// If we get here we think we have a complete encoded video frame (fMark was
	// set on the last packet)
	
	// if the ring is full or the timestamp is earlier, dump everything.This may be too drastic
	// and the reset action could be refined to dump only the older
	// packets. However, need to make sure the ring doesnt get "stuck"
	pos = ModRing(m_MaxPos+1);
	if (pos == m_FreePos || TS_EARLIER(timestamp, m_MaxT)) {
		Reset(seq,timestamp);
		*pfSkippedData = TRUE;
		pos = ModRing(m_MaxPos + 1); // check again
		if (pos == m_FreePos) {
			hr = DPR_OUT_OF_MEMORY;
			m_LastGoodSeq -= MAX_MISORDER; //make sure we dont accidentally synchronize
			goto ErrorExit;
		}
	}

	// insert frame into ring

	pAP = m_Ring[pos];
	if (pAP->Busy() || pAP->GetState() != MP_STATE_RESET) {
		hr = DPR_DUPLICATE_PACKET;
		goto ErrorExit;
	}

	// new stuff
	hr = RestorePacket(m_NetBufList, pAP, timestamp, seq, fMark, pfSyncPoint);
	if (FAILED(hr))
	{
		goto ErrorExit;
	}

	if (*pfSyncPoint)
	{
		DEBUGMSG (ZONE_IFRAME, ("%s: Received a keyframe\r\n", _fx_));
	}

	::FreeNetBufList(m_NetBufList,m_pRTP);
	m_NetBufList = NULL;
#ifdef DEBUG
	if (!TS_LATER(timestamp, m_MaxT))
	{
			DEBUGMSG (ZONE_DP, ("PutNextNetIn(): Reconstructed frame's timestamp <= to previous frame's!\r\n"));
	}
#endif
	m_MaxT = timestamp;
	m_MaxPos = pos;		// advance m_MaxPos
// end new stuff

		
	LeaveCriticalSection(&m_CritSect);
	StartDecode();
	return hr;
ErrorExit:
	// if we're in the middle of assembling a frame, free buffers
	if (m_NetBufList){
		::FreeNetBufList(m_NetBufList,m_pRTP);
		m_NetBufList = NULL;
	}
	LeaveCriticalSection(&m_CritSect);
	return hr;

}

// Called to force the release of any accumulated NETBUFs back to the owner (RTP).
// This can be called at shutdown or to escape from a out-of-buffer situation
BOOL RVStream::ReleaseNetBuffers()
{
	::FreeNetBufList(m_NetBufList, m_pRTP);
	m_NetBufList = NULL;
	return TRUE;
}

// Take a packet and reassemble it into a frame.
// Doesnt currently process out-of-order packets (ie) the entire frame is
// discarded
// The NETBUF is held onto, unless an error is returned
HRESULT
RVStream::ReassembleFrame(NETBUF *pNetBuf, UINT seq, UINT fMark)
{

	++m_LastGoodSeq;
	if (seq != m_LastGoodSeq) {
		// dont handle out of sequence packets
		if (fMark)
			m_LastGoodSeq = (WORD)seq;
		else
			--m_LastGoodSeq;	// LastGoodSeq left unchanged

		return DPR_OUT_OF_SEQUENCE;
	}

	
	if (m_NetBufList ) {
		// append to list of fragments
		::AppendNetBufList(m_NetBufList,pNetBuf);
	} else {
		// start of frame
		m_NetBufList = pNetBuf;
	}

	return DPR_SUCCESS;	
}

HRESULT
RVStream::SetLastGoodSeq(UINT seq)
{
	m_LastGoodSeq = seq ? (WORD)(seq-1) : (WORD)0xFFFF;
	return DPR_SUCCESS;
}

// called when restarting after a pause (fSilenceOnly == FALSE) or
// to catch up when latency is getting too much (fSilenceOnly == TRUE)
// determine new play position by skipping any
// stale packets

HRESULT RVStream::FastForward( BOOL fSilenceOnly)
{
	UINT pos;
	DWORD timestamp = 0;
	// restart the receive stream
	EnterCriticalSection(&m_CritSect);
	if (!TS_EARLIER(m_MaxT , m_PlayT)) {
		// there are buffers waiting to be played
		// dump them!
		if (ModRing(m_MaxPos - m_PlayPos) <= m_DelayPos)
			goto Exit;	// not too many stale packets;

		for (pos=m_PlayPos;pos != ModRing(m_MaxPos -m_DelayPos);pos = ModRing(pos+1),m_PlaySeq++) {
			if (m_Ring[pos]->Busy()
				|| (m_Ring[pos]->GetState() != MP_STATE_RESET
					&& (fSilenceOnly ||ModRing(m_MaxPos-pos) <= m_MaxDelayPos)))
			{	// non-empty packet
				if (m_Ring[pos]->Busy())	// uncommon case
					goto Exit;	// bailing out
				timestamp = m_Ring[pos]->GetTimestamp();
				break;
			}
			m_Ring[pos]->Recycle();	// free NETBUF and Reset state
			LOG((LOGMSG_RX_SKIP,pos));
		}
		if (timestamp)	{// starting from non-empty packet
			m_PlayT = timestamp;
			//m_Ring[pos]->GetProp(MP_PROP_SEQNUM, &m_PlaySeq);
		} else {		// starting from (possibly) empty packet
			m_PlayT++;
		}

		// probably also need to update FreePos
		if (m_FreePos == ModRing(m_PlayPos-1))
			m_FreePos = ModRing(pos-1);
		m_PlayPos = pos;
		/*
		if (pos == ModRing(m_MaxPos+1)) {
			DEBUGMSG(1,("Reset:: m_MaxT inconsisten!\n"));
		}
		*/
		LOG((LOGMSG_RX_RESET2,m_MaxT,m_PlayT,m_PlayPos));
	}
Exit:
	LeaveCriticalSection(&m_CritSect);
	return DPR_SUCCESS;
}


HRESULT
RVStream::Reset(UINT seq,DWORD timestamp)
{
	UINT pos;
	HRESULT hr;
	// restart the receive stream
	EnterCriticalSection(&m_CritSect);
	LOG((LOGMSG_RX_RESET,m_MaxPos,m_PlayT,m_PlayPos));
	/*if (!TS_EARLIER(m_MaxT , m_PlayT)) */
	{
		// there are buffers waiting to be played
		// dump them!
		// Empty the RVStream and set PlayT appropriately
		for (pos = m_PlayPos;
			pos != m_FreePos;
			pos = ModRing(pos+1))
		{
			if (m_Ring[pos]->Busy ())
			{
				DEBUGMSG (1, ("RVStream::Reset: packet is busy, pos=%d\r\n", pos));
				ASSERT(1);
				hr = DPR_INVALID_PARAMETER;
				goto Failed;
			}
			m_Ring[pos]->Recycle();	// free NETBUF and Reset state
		}
	}
	m_MaxPos = ModRing(m_PlayPos-1);
	m_PlayT = timestamp;
	m_MaxT = m_PlayT -1;	// m_MaxT must be less than m_PlayT
	m_PlaySeq = seq;
	
	LOG((LOGMSG_RX_RESET2,m_MaxPos,m_PlayT,m_PlayPos));
	hr = DPR_SUCCESS;
Failed:
	LeaveCriticalSection(&m_CritSect);
	return hr;		
}

MediaPacket *RVStream::GetNextPlay(void)
{
	MediaPacket *pAP = NULL;
	UINT pos,seq;
	DWORD timestamp = 0, dwVal;
	EnterCriticalSection(&m_CritSect);


	pAP = m_Ring[m_PlayPos];
	if (pAP->Busy() ||
	(pAP->GetState() != MP_STATE_RESET && pAP->GetState() != MP_STATE_DECODED)
	 || ModRing(m_PlayPos+1) == m_FreePos) {
		LeaveCriticalSection(&m_CritSect);
		return NULL;
	} else {
	// If there are empty buffer(s) at the head of the q followed
	// by  a talkspurt (non-empty buffers) and if the talkspurt is excessively
	// delayed then squeeze out the silence.
	//
		if (pAP->GetState() == MP_STATE_RESET)
			FastForward(TRUE);	// skip silence packets if necessary
		pAP = m_Ring[m_PlayPos];	// in case the play position changed
		if (pAP->GetState() == MP_STATE_DECODED) {
			timestamp = pAP->GetTimestamp();
			seq = pAP->GetSeqNum();
		}
			
	}

	pAP->Busy(TRUE);
	m_PlayPos = ModRing(m_PlayPos+1);
	if (timestamp) {
		m_PlayT = timestamp+1;
		m_PlaySeq = seq+1;
	} else {
		m_PlaySeq++;
		// we dont really know the timestamp of the next frame to play
		// without looking at it, and it may not have arrived
		// so m_PlayT is just a lower bound
		m_PlayT++;	
	}
	LeaveCriticalSection(&m_CritSect);
	return pAP;
}

RVStream::Destroy()
{
	ASSERT (!m_NetBufList);
	//::FreeNetBufList(m_NetBufList,m_pRTP);
	m_NetBufList = NULL;
	RxStream::Destroy();
	return DPR_SUCCESS;
}


void RVStream::StartDecode()
{
	MediaPacket *pVP;
	MMRESULT mmr;

	// if we have a separate decode thread this will signal it.
	// for now we insert the decode loop here
	while (pVP = GetNextDecode())
	{
		mmr = m_pVideoFilter->Convert((VideoPacket*)pVP, VP_DECODE);
		if (mmr != MMSYSERR_NOERROR)
			pVP->Recycle();
		else
			pVP->SetState(MP_STATE_DECODED);

		Release(pVP);
	}
}


HRESULT RVStream::RestorePacket(NETBUF *pNetBuf, MediaPacket *pVP, DWORD timestamp, UINT seq, UINT fMark, BOOL *pfReceivedKeyframe)
{
	VOID *pNet;
	UINT uSizeNet;
	WSABUF bufDesc[MAX_VIDEO_FRAGMENTS];		// limit to at most 32 fragments
	UINT i;
	DWORD dwReceivedBytes=0;
	NETBUF *pnb;
	DWORD dwLength;
    DWORD_PTR dwPropVal;
	MMRESULT mmr;

	i = 0;
	pnb = pNetBuf;
	while (pnb && i < MAX_VIDEO_FRAGMENTS) {
		bufDesc[i].buf = (char *)pnb->data;
		bufDesc[i].len = pnb->length;
		dwReceivedBytes += pnb->length + sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE;
		pnb = pnb->next;
		i++;
	}
	ASSERT(!pnb); // fail if we get a frame with more than MAX_VIDEO_FRAGMENTS

    // Write the bits per second counter
    UPDATE_COUNTER(g_pctrVideoReceiveBytes, dwReceivedBytes * 8);


	pVP->GetNetData(&pNet, &uSizeNet);

	// Initialize length to maximum reconstructed frame size
	pVP->GetProp(MP_PROP_MAX_NET_LENGTH, &dwPropVal);
    dwLength = (DWORD)dwPropVal;

	if (pnb==NULL)
	{
		mmr = m_pVideoFilter->RestorePayload(bufDesc, i, (BYTE*)pNet, &dwLength, pfReceivedKeyframe);
		if (mmr == MMSYSERR_NOERROR)
		{
			pVP->SetNetLength(dwLength);
			pVP->Receive(NULL, timestamp, seq, fMark);
			return S_OK;
		}
	}

	return E_FAIL;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\precomp.h ===
/* precomp.h for NAC.DLL */

// typedefs are useful for dynamic linking to Winsock APIs
#define INCL_WINSOCK_API_TYPEDEFS 1

#include <windows.h>
#include <windowsx.h>
#include <winsock2.h>
#include <winperf.h>

// NetMeeting standard includes
#include <oprahcom.h>
#include <confdbg.h>
#include <avutil.h>
#include <oblist.h>
#include <regentry.h>

#include <limits.h>
#include <mmreg.h>
#include <mmsystem.h>
#include <msacm.h>
#include <vfw.h>


#ifndef _WINSOCK2API_ // { _WINSOCK2API_

typedef struct _OVERLAPPED *    LPWSAOVERLAPPED;

typedef struct _WSABUF {
    u_long      len;     /* the length of the buffer */
    char FAR *  buf;     /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;

typedef
void
(CALLBACK * LPWSAOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwError,
    DWORD cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwFlags
    );

#define WSA_IO_PENDING          (ERROR_IO_PENDING)

#endif // } _WINSOCK2API_
#include "com.h"
#include "nacguids.h"
#include "Dcap.h"
#include "capture.h"
#include "vidinout.h"
#include "vcmStrm.h"
#include "msh26x.h"
#ifdef USE_MPEG4_SCRUNCH
#include "mpeg4.h"
#endif
#include "mperror.h"
#include "common.h"
#include "irtp.h"
#include "iacapapi.h"
#include "ih323cc.h"
#include "icomchan.h"	// only for IVideoDevice
#include "incommon.h"
#include "callcont.h"
#include "h245api.h"	// for some h245 constants
#include "intif.h"
#include "rtp.h"
#include "imstream.h"
#include "codecs.h"
#include "mediacap.h"
#include "acmcaps.h"
#include "vcmcaps.h"
#include "nmqos.h"
#include "iprop.h"
#include "ividrdr.h"
#include "datapump.h"
#include "medistrm.h"
#include "dsound.h"
#include "dsstream.h"
#include "auformats.h"
#include "imp.h"
#include "utils.h"
#include "bufpool.h"
#include "mediapkt.h"
#include "audpackt.h"
#include "vidpackt.h"
#include "rxstream.h"
#include "rvstream.h"
#include "txstream.h"
#include "medictrl.h"
#include "medvctrl.h"
#include "AcmFilter.h"
#include "VcmFilter.h"
#include "devaudq.h"
#include "vidutils.h"
#include "counters.h"
#include "inscodec.h"
#include "avcommon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\rxstream.cpp ===
/*
	RXSTREAM.C
*/

#include "precomp.h"
extern UINT g_MinWaveAudioDelayMs;	// minimum millisecs of introduced playback delay
extern UINT g_MaxAudioDelayMs;	// maximum milliesecs of introduced playback delay


RxStream::RxStream(UINT size)
{
	UINT i;
	for (i =0; i < size; i++) {
		m_Ring[i] = NULL;
	}
	// initialize object critical section
	InitializeCriticalSection(&m_CritSect);
}

RxStream::~RxStream()
{
	DeleteCriticalSection(&m_CritSect);
}

RxStream::Initialize(
	UINT flags,
	UINT size,		// MB power of 2
	IRTPRecv *pRTP,
	MEDIAPACKETINIT *papi,
	ULONG ulSamplesPerPacket,
	ULONG ulSamplesPerSec,
	AcmFilter *pAcmFilter)  // this param may be NULL for video
{
	UINT i;
	MediaPacket *pAP;

	m_fPreamblePacket = TRUE;
	m_pDecodeBufferPool = NULL;

	m_RingSize = size;
	m_dwFlags = flags;
	if (flags & DP_FLAG_MMSYSTEM)
	{
		if (m_RingSize > MAX_RXRING_SIZE)
			return FALSE;
	}
	else if (flags & DP_FLAG_VIDEO)
	{
		if (m_RingSize > MAX_RXVRING_SIZE)
			return FALSE;
		if (!IsSameFormat (papi->pStrmConvSrcFmt, papi->pStrmConvDstFmt)) {
			// the video decode bufs are not allocated per MediaPacket object.
			// instead we use a BufferPool with a few buffers.
			papi->fDontAllocRawBufs = TRUE;

            DBG_SAVE_FILE_LINE
			m_pDecodeBufferPool = new BufferPool;
			// Three seems to be the minimum number of frame bufs 
			// One is being rendered and at least two are needed
			// so the rendering can catch up with the received frames
			// (another alternative is to dump frames to catch up)
			if (m_pDecodeBufferPool->Initialize(3,
				sizeof(NETBUF)+papi->cbSizeRawData + papi->cbOffsetRawData) != S_OK)
			{
				DEBUGMSG(ZONE_DP,("Couldnt initialize decode bufpool!\n"));
				delete m_pDecodeBufferPool;
				m_pDecodeBufferPool = NULL;
				return FALSE;
			}
		}
	}

	m_pRTP = pRTP;

	for (i=0; i < m_RingSize; i++)
	{
		if (flags & DP_FLAG_MMSYSTEM)
        {
            DBG_SAVE_FILE_LINE
			pAP = new AudioPacket;
        }
		else if (flags & DP_FLAG_VIDEO)
        {
            DBG_SAVE_FILE_LINE
			pAP = new VideoPacket;
        }
		m_Ring[i] = pAP;
		papi->index = i;
		if (!pAP || pAP->Initialize(papi) != DPR_SUCCESS)
			break;
	}
	if (i < m_RingSize)
	{
		for (UINT j=0; j<=i; j++)
		{
			if (m_Ring[j]) {
				m_Ring[j]->Release();
				delete m_Ring[j];
			}
		}
		return FALSE;
	}


	m_SamplesPerPkt = ulSamplesPerPacket;
	m_SamplesPerSec  = ulSamplesPerSec;
	// initialize pointers
	m_PlaySeq = 0;
	m_PlayT = 0;
	m_MaxT = m_PlayT - 1; // m_MaxT < m_PlayT indicates queue is empty
	m_MaxPos = 0;
	m_PlayPos = 0;
	m_FreePos = m_RingSize - 1;
	m_MinDelayPos = m_SamplesPerSec*g_MinWaveAudioDelayMs/1000/m_SamplesPerPkt;	//  fixed 250 ms delay
	if (m_MinDelayPos < 3) m_MinDelayPos = 3;
	
	m_MaxDelayPos = m_SamplesPerSec*g_MaxAudioDelayMs/1000/m_SamplesPerPkt;	//fixed 750 ms delay
	m_DelayPos = m_MinDelayPos;
	m_ScaledAvgVarDelay = 0;
	m_SilenceDurationT = 0;
	//m_DeltaT = MAX_TIMESTAMP;

	m_pAudioFilter = pAcmFilter;

	// go ahead and cache the WAVEFORMATEX structures
	// it's handy to have around
	if (m_dwFlags & DP_FLAG_AUDIO)
	{
		m_wfxSrc = *(WAVEFORMATEX*)(papi->pStrmConvSrcFmt);
		m_wfxDst = *(WAVEFORMATEX*)(papi->pStrmConvDstFmt);
	}
	m_nBeeps = 0;

	return TRUE;
}

#define PLAYOUT_DELAY_FACTOR	2
void RxStream::UpdateVariableDelay(DWORD sendT, DWORD arrT)
{
	LONG deltaA, deltaS;
	DWORD delay,delayPos;
// m_ArrivalT0 and m_SendT0 are the arrival and send timestamps of the packet
// with the shortest trip delay. We could have just stored (m_ArrivalT0 - m_SendT0)
// but since the local and remote clocks are completely unsynchronized, there would
// be signed/unsigned complications.
	deltaS = sendT - m_SendT0;
	deltaA = arrT - m_ArrivalT0;
	
	if (deltaA < deltaS)	{
		// this packet took less time
		delay = deltaS - deltaA;
		// replace shortest trip delay times
		m_SendT0 = sendT;
		m_ArrivalT0 = arrT;
	} else {
		// variable delay is how much longer this packet took
		delay = deltaA - deltaS;
	}
	// update average variable delay according to
	// m_AvgVarDelay = m_AvgVarDelay + (delay - m_AvgVarDelay)*1/16;
	// however we are storing the scaled average, with a scaling
	// factor of 16. So the calculation becomes
	m_ScaledAvgVarDelay = m_ScaledAvgVarDelay + (delay - m_ScaledAvgVarDelay/16);
	// now calculate delayPos
	delayPos = m_MinDelayPos + PLAYOUT_DELAY_FACTOR * m_ScaledAvgVarDelay/16/m_SamplesPerPkt;
	if (delayPos >= m_MaxDelayPos) delayPos = m_MaxDelayPos;

	LOG((LOGMSG_JITTER,delay, m_ScaledAvgVarDelay/16, delayPos));
	if (m_DelayPos != delayPos) {
		DEBUGMSG(ZONE_VERBOSE,("Changing m_DelayPos from %d to %d\n",m_DelayPos, delayPos));
		m_DelayPos = delayPos;
	}

	UPDATE_COUNTER(g_pctrAudioJBDelay, m_DelayPos*(m_SamplesPerPkt*1000)/m_SamplesPerSec);
}

// This function is only used for audio packets
HRESULT
RxStream::PutNextNetIn(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark, BOOL *pfSkippedData, BOOL *pfSyncPoint)
{
	DWORD deltaTicks;
	MediaPacket *pAP;
	HRESULT hr;
	UINT samples;
	NETBUF netbuf;
	
	netbuf.data = (PBYTE) pWsaBuf->buf + sizeof(RTP_HDR);
	netbuf.length = pWsaBuf->len - sizeof(RTP_HDR);
	
	EnterCriticalSection(&m_CritSect);

	deltaTicks = (timestamp - m_PlayT)/m_SamplesPerPkt;
	
	if (deltaTicks > ModRing(m_FreePos - m_PlayPos)) {
	// the packet is too late or packet overrun
	// if the timestamp is earlier than the max. received so far
	// then reject it if there are packets queued up
		if (TS_EARLIER(timestamp, m_MaxT) && !IsEmpty()) {
			hr = DPR_LATE_PACKET;				// deltaTicks is -ve
			goto ErrorExit;
		}
		// restart the receive stream with this packet
		Reset(timestamp);
		m_SendT0 = timestamp;
		m_ArrivalT0 = MsToTimestamp(timeGetTime());
		deltaTicks = (timestamp - m_PlayT)/m_SamplesPerPkt;

	}

	// insert into ring
	pAP = m_Ring[ModRing(m_PlayPos+deltaTicks)];
	if (pAP->Busy() || pAP->GetState() != MP_STATE_RESET) {
		hr = DPR_DUPLICATE_PACKET;
		goto ErrorExit;
	}
	
	// update number of bits received
	UPDATE_COUNTER(g_pctrAudioReceiveBytes,(netbuf.length + sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE)*8);

	hr = pAP->Receive(&netbuf, timestamp, seq, fMark);
	if (hr != DPR_SUCCESS)
		goto ErrorExit;
		
//	m_pRTP->FreePacket(pWsaBuf);	// return the buffer to RTP
	
	if (TS_LATER(timestamp, m_MaxT)) { // timestamp > m_MaxT
		if (timestamp - m_MaxT > m_SamplesPerPkt * 4) {
			// probably beginning of talkspurt - reset minimum delay timestamps
			// Note: we should use the Mark flag in RTP header to detect this
			m_SendT0 = timestamp;
			m_ArrivalT0 = MsToTimestamp(timeGetTime());
		}
		m_MaxT = timestamp;
		m_MaxPos = ModRing(m_PlayPos + deltaTicks);
	}
	// Calculate variable delay (sort of jitter)
	UpdateVariableDelay(timestamp, MsToTimestamp(timeGetTime()));

	LeaveCriticalSection(&m_CritSect);
	StartDecode();

	// Some implementations packetize audio in smaller chunks than they negotiated 
	// We deal with this by checking the length of the decoded packet and change
	// the constant m_SamplesPerPkt. Hopefully this will only happen once per session
	// (and never for NM-to-NM calls). Randomly varying packet sizes are still going
	// to sound lousy, because the recv queue management has the implicit assumption
	// that all packets (at least those in the queue) have the same length
	if (pAP->GetState() == MP_STATE_DECODED && (samples = pAP->GetDevDataSamples())) {
		if (samples != m_SamplesPerPkt) {
			// we're getting different sized (typically smaller) packets than we expected
			DEBUGMSG(ZONE_DP,("Changing SamplesPerPkt from %d to %d\n",m_SamplesPerPkt, samples));
			m_SamplesPerPkt = samples;
			m_MinDelayPos = m_SamplesPerSec*g_MinWaveAudioDelayMs/1000/m_SamplesPerPkt;	//  fixed 250 ms delay
			if (m_MinDelayPos < 2) m_MinDelayPos = 2;
			
			m_MaxDelayPos = m_SamplesPerSec*g_MaxAudioDelayMs/1000/m_SamplesPerPkt;	//fixed 750 ms delay
		}
	}
	return DPR_SUCCESS;
ErrorExit:
//	m_pRTP->FreePacket(pWsaBuf);
	LeaveCriticalSection(&m_CritSect);
	return hr;

}

// called when restarting after a pause (fSilenceOnly == FALSE) or
// to catch up when latency is getting too much (fSilenceOnly == TRUE)
// determine new play position by skipping any
// stale packets
HRESULT RxStream::FastForward( BOOL fSilenceOnly)
{
	UINT pos;
	DWORD timestamp = 0;
	// restart the receive stream
	EnterCriticalSection(&m_CritSect);
	if (!TS_EARLIER(m_MaxT ,m_PlayT)) {
		// there are buffers waiting to be played
		// dump them!
		if (ModRing(m_MaxPos - m_PlayPos) <= m_DelayPos)
			goto Exit;	// not too many stale packets
		for (pos=m_PlayPos;pos != ModRing(m_MaxPos -m_DelayPos);pos = ModRing(pos+1)) {
			if (m_Ring[pos]->Busy()
				|| (m_Ring[pos]->GetState() != MP_STATE_RESET
					&& (fSilenceOnly ||ModRing(m_MaxPos-pos) <= m_MaxDelayPos)))
			{	// non-empty packet
				if (m_Ring[pos]->Busy())	// uncommon case
					goto Exit;	// bailing out
				timestamp =m_Ring[pos]->GetTimestamp();
				break;
			}
			m_Ring[pos]->Recycle();	// free NETBUF and Reset state
			LOG((LOGMSG_RX_SKIP,pos));
		}
		if (timestamp)	// starting from non-empty packet
			m_PlayT = timestamp;
		else			// starting from (possibly) empty packet
			m_PlayT = m_MaxT - m_DelayPos*m_SamplesPerPkt;

		// probably also need to update FreePos
		if (m_FreePos == ModRing(m_PlayPos-1))
			m_FreePos = ModRing(pos-1);
		m_PlayPos = pos;
		/*
		if (pos == ModRing(m_MaxPos+1)) {
			DEBUGMSG(1,("Reset:: m_MaxT inconsisten!\n"));
		}
		*/

		LOG((LOGMSG_RX_RESET2,m_MaxT,m_PlayT,m_PlayPos));
	}
Exit:
	LeaveCriticalSection(&m_CritSect);
	return DPR_SUCCESS;
}


HRESULT
RxStream::Reset(DWORD timestamp)
{
	UINT pos;
	DWORD T;
	// restart the receive stream
	EnterCriticalSection(&m_CritSect);
	LOG((LOGMSG_RX_RESET,m_MaxT,m_PlayT,m_PlayPos));
	if (!TS_EARLIER(m_MaxT, m_PlayT)) {
		// there are buffers waiting to be played
		// dump them!
		// Empty the RxStream and set PlayT appropriately
		for (pos = m_PlayPos;
			pos != ModRing(m_PlayPos-1);
			pos = ModRing(pos+1))
			{
			if (m_Ring[pos]->Busy ())
			{
				ERRORMESSAGE(("RxStream::Reset: packet is busy, pos=%d\r\n", pos));
				ASSERT(1);
			}
			T = m_Ring[pos]->GetTimestamp();
			m_Ring[pos]->Recycle();	// free NETBUF and Reset state
			if (T == m_MaxT)
				break;
		}
	}
	if (timestamp !=0)
		m_PlayT = timestamp - m_DelayPos*m_SamplesPerPkt;
	m_MaxT = m_PlayT - 1;	// max must be less than play

	LOG((LOGMSG_RX_RESET2,m_MaxT,m_PlayT,m_PlayPos));
	LeaveCriticalSection(&m_CritSect);
	return DPR_SUCCESS;		
}

BOOL RxStream::IsEmpty()
{
	BOOL fEmpty;

	EnterCriticalSection(&m_CritSect);
	if (TS_EARLIER(m_MaxT, m_PlayT) || m_RingSize == 0) 
		fEmpty = TRUE;
	else if (m_dwFlags & DP_FLAG_AUTO_SILENCE_DETECT)
	{
		UINT pos;
		// we could have received packets that
		// are deemed silent. Walk the packets between
		// PlayPos and MaxPos and check if they're all empty
		pos = m_PlayPos;
		fEmpty = TRUE;
		do {
			if (m_Ring[pos]->Busy() || (m_Ring[pos]->GetState() != MP_STATE_RESET ))
			{
				fEmpty = FALSE; // no point scanning further
				break;
			}
			pos = ModRing(pos+1);
		} while (pos != ModRing(m_MaxPos+1));
		
	}
	else 
	{
	// not doing receive silence detection
	// every received packet counts
		fEmpty = FALSE;
	}
	LeaveCriticalSection(&m_CritSect);
	return fEmpty;
}

void RxStream::StartDecode()
{
	MediaPacket *pAP;
	MMRESULT mmr;

	// if we have a separate decode thread this will signal it.
	// for now we insert the decode loop here
	while (pAP = GetNextDecode())
	{
//		if (pAP->Decode() != DPR_SUCCESS)
//		{
//			pAP->Recycle();
//		}

		mmr = m_pAudioFilter->Convert((AudioPacket *)pAP, AP_DECODE);
		if (mmr != MMSYSERR_NOERROR)
		{
			pAP->Recycle();
		}


		else
		{
			pAP->SetState(MP_STATE_DECODED);

			if (m_dwFlags & DP_FLAG_AUTO_SILENCE_DETECT) {
	    // dont play the packet if we have received at least a quarter second of silent packets.
	    // This will enable switch to talk (in half-duplex mode).
				DWORD dw;
				pAP->GetSignalStrength(&dw);
				if (m_AudioMonitor.SilenceDetect((WORD)dw)) {
					m_SilenceDurationT += m_SamplesPerPkt;
					if (m_SilenceDurationT > m_SamplesPerSec/4)
						pAP->Recycle();
				} else {
					m_SilenceDurationT = 0;
				}
			}
		}
		Release(pAP);
	}
}

MediaPacket *RxStream::GetNextDecode(void)
{
	MediaPacket *pAP = NULL;
	UINT pos;
	NETBUF *pBuf;
	EnterCriticalSection(&m_CritSect);
	// do we have any packets in the queue
	if (! TS_EARLIER(m_MaxT , m_PlayT)) {
		pos = m_PlayPos;
		do {
			if (!m_Ring[pos]->Busy() && m_Ring[pos]->GetState() == MP_STATE_NET_IN_STREAM ) {
				if (m_pDecodeBufferPool) {
					// MediaPacket needs to be given a decode buffer
					if ( pBuf = (NETBUF *)m_pDecodeBufferPool->GetBuffer()) {
						// init the buffer
						pBuf->pool = m_pDecodeBufferPool;
						pBuf->length = m_pDecodeBufferPool->GetMaxBufferSize()-sizeof(NETBUF);
						pBuf->data = (PBYTE)(pBuf + 1);
						m_Ring[pos]->SetDecodeBuffer(pBuf);
					} else {
						break;	// no buffers available
					}
				}
				pAP = m_Ring[pos];
				pAP->Busy(TRUE);
				break;
			}
			pos = ModRing(pos+1);
		} while (pos != ModRing(m_MaxPos+1));
	}
	
	LeaveCriticalSection(&m_CritSect);
	return pAP;
}

MediaPacket *RxStream::GetNextPlay(void)
{
	MediaPacket *pAP = NULL;
	UINT pos;
	EnterCriticalSection(&m_CritSect);


	pAP = m_Ring[m_PlayPos];
	if (pAP->Busy() || (pAP->GetState() != MP_STATE_RESET && pAP->GetState() != MP_STATE_DECODED)) {
		// bad - the next packet is not decoded yet
		pos = ModRing(m_FreePos-1);
		if (pos != m_PlayPos && !m_Ring[m_FreePos]->Busy()
			&& m_Ring[m_FreePos]->GetState() == MP_STATE_RESET) {
			// give an empty buffer from the end
			pAP = m_Ring[m_FreePos];
			m_FreePos = pos;
		} else {
			// worse - no free packets
			// this can only happen if packets are not released
			// or we-re backed up all the way with new packets
			// Reset?
			LeaveCriticalSection(&m_CritSect);
			return NULL;
		}
	} else {
	// If there are empty buffer(s) at the head of the q followed
	// by  a talkspurt (non-empty buffers) and if the talkspurt is excessively
	// delayed then squeeze out the silence.
	//
		if (pAP->GetState() == MP_STATE_RESET)
			FastForward(TRUE);	// skip silence packets if necessary
		pAP = m_Ring[m_PlayPos];	// in case the play position changed
	}

	if (pAP->GetState() == MP_STATE_RESET) {
		// give missing packets a timestamp
		pAP->SetProp(MP_PROP_TIMESTAMP,m_PlayT);
	}
	pAP->Busy(TRUE);
	m_PlayPos = ModRing(m_PlayPos+1);
	m_PlayT += m_SamplesPerPkt;


	// the worst hack in all of NAC.DLL - the injection of the 
	// DTMF "feedback tone".  Clearly, this waveout stream stuff needs
	// to be rewritten!
	if (m_nBeeps > 0)
	{
		PVOID pBuffer=NULL;
		UINT uSize=0;
		WAVEFORMATEX wfx;

		if ((pAP) && (m_dwFlags & DP_FLAG_AUDIO))
		{
			pAP->GetDevData(&pBuffer, &uSize);
			if (pBuffer)
			{
				MakeDTMFBeep(&m_wfxDst, (PBYTE)pBuffer, uSize);
				pAP->SetState(MP_STATE_DECODED);
				pAP->SetRawActual(uSize);
			}
		}

		m_nBeeps--;
	}


	LeaveCriticalSection(&m_CritSect);
	return pAP;
}



void RxStream::InjectBeeps(int nBeeps)
{
	EnterCriticalSection(&m_CritSect);

	m_nBeeps = nBeeps;

	LeaveCriticalSection(&m_CritSect);

}

/*************************************************************************

	Function:	PeekPrevPlay(void)

	Purpose :	Get previous audio packet played back.

	Returns :	Pointer to that packet.

	Params  :	None.

	Comments:

	History :	Date		Reason

				06/02/96	Created - PhilF

*************************************************************************/
MediaPacket *RxStream::PeekPrevPlay(void)
{
	MediaPacket *pAP = NULL;
	EnterCriticalSection(&m_CritSect);

	// Get packet previously scheduled for playback from the ring
	pAP = m_Ring[ModRing(m_PlayPos+m_RingSize-2)];

	LeaveCriticalSection(&m_CritSect);
	return pAP;
}

/*************************************************************************

	Function:	PeekNextPlay(void)

	Purpose :	Get next next audio packet to be played.

	Returns :	Pointer to that packet.

	Params  :	None.

	Comments:

	History :	Date		Reason

				06/02/96	Created - PhilF

*************************************************************************/
MediaPacket *RxStream::PeekNextPlay(void)
{
	MediaPacket *pAP = NULL;
	EnterCriticalSection(&m_CritSect);

	// Get packet next scheduled for playback from the ring
	pAP = m_Ring[ModRing(m_PlayPos)];

	LeaveCriticalSection(&m_CritSect);
	return pAP;
}

HRESULT RxStream::GetSignalStrength(PDWORD pdw)
{
	MediaPacket *pAP;
	EnterCriticalSection(&m_CritSect);
	pAP = m_Ring[m_PlayPos];
	if (!pAP || pAP->Busy() || pAP->GetState() != MP_STATE_DECODED)
		*pdw = 0;
	else {
		pAP->GetSignalStrength(pdw);
	}
	LeaveCriticalSection(&m_CritSect);
	return DPR_SUCCESS;
}

// Scan thru the ring, looking for the next
// decoded packet and report its RTP timestamp
BOOL RxStream::NextPlayablePacketTime(DWORD *pTS)	
{
	UINT pos;
	if (IsEmpty())
		return FALSE;
	pos = m_PlayPos;
	do {
		if (m_Ring[pos]->Busy())
			return FALSE; // no point scanning further
		if (m_Ring[pos]->GetState() == MP_STATE_DECODED ) {
			*pTS = m_Ring[pos]->GetTimestamp();
			return TRUE;
		}
		pos = ModRing(pos+1);
	} while (pos != ModRing(m_MaxPos+1));
	// no decoded packets
	return FALSE;
}

void RxStream::Release(MediaPacket *pAP)
{
	UINT pos;
	DWORD thisPos;

	DWORD T;
	EnterCriticalSection(&m_CritSect);
	if (pAP->GetState() == MP_STATE_DECODED) {
		// if its playout time has pAPt reset it
		T = pAP->GetTimestamp();
		if (TS_EARLIER(T ,m_PlayT)) {
			pAP->MakeSilence();
		}
	}
	pAP->Busy(FALSE);
	// Advance the free position if we are freeing the next one
	pos = ModRing(m_FreePos+1);
	thisPos = pAP->GetIndex();
	if (pos == thisPos) {
		// Releasing one packet may advance FreePos several
		while (pos != m_PlayPos && !m_Ring[pos]->Busy()) {
			m_FreePos = pos;
			pos = ModRing(pos+1);
		}
	}
	
	LeaveCriticalSection(&m_CritSect);
}

HRESULT
RxStream::SetLastGoodSeq(UINT seq)
{
	return DPR_SUCCESS;
}


RxStream::Destroy(void)
{
	UINT i;
	EnterCriticalSection(&m_CritSect);
	for (i=0; i < m_RingSize; i++) {
		if (m_Ring[i]) {
			m_Ring[i]->Release();
			delete m_Ring[i];
			m_Ring[i] = NULL;
		}
	}
	m_RingSize = 0;

	if (m_pDecodeBufferPool) {
		delete m_pDecodeBufferPool;
		m_pDecodeBufferPool = NULL;
	}
	LeaveCriticalSection(&m_CritSect);
	return DPR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\rxstream.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    rxstream.h

Abstract:
	The RxStream class maintains a circular list of MediaPackets. RTP packets received
	from the network are put into the ring (PutNextNetIn), then decoded and removed from the
	ring when the time comes to play them (GetNextPlay). After playback, the packets are
	returned to the ring (Release).
	The ring is implemented as an array and under normal operation the index of the next 
	MediaPacket to play (m_PlayPos) advances by one when GetNextPlay is called.
--*/
#ifndef _RXSTREAM_H_
#define _RXSTREAM_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define MAX_RXRING_SIZE 64
#define MAX_RXVRING_SIZE 64

// these macros are for comparing timestamps that
// are within 2^31 of each other.
#define TS_EARLIER(A,B) ((signed) ((A)-(B)) < 0)
#define TS_LATER(A,B) ((signed) ((A)-(B)) > 0)


class RxStream {
public:
	RxStream(UINT size);
	virtual ~RxStream();
	virtual Initialize(UINT flags, UINT size, IRTPRecv *, MEDIAPACKETINIT *papi, ULONG ulSamplesPerPacket, ULONG ulSamplesPerSec, AcmFilter *pAcmFilter = NULL);
	virtual MediaPacket *GetNextPlay();
	MediaPacket *PeekPrevPlay();
	MediaPacket *PeekNextPlay();
	virtual void Release(MediaPacket *);
	virtual HRESULT PutNextNetIn(WSABUF *pNetBuf, DWORD timestamp, UINT seq, UINT fMark, BOOL *pfSkippedData, BOOL *pfSyncPoint);
	virtual BOOL ReleaseNetBuffers() {return FALSE;}
	HRESULT Reset(DWORD);
	virtual HRESULT SetLastGoodSeq(UINT seq);
	virtual HRESULT FastForward( BOOL fSilenceOnly);
	void SetRTP(IRTPRecv *pRTPRecv) {m_pRTP = pRTPRecv;}
	int IsEmpty() ;
	BOOL NextPlayablePacketTime(DWORD *pTS);
	UINT BufferDelay(void) { return m_MinDelayPos;}
	HRESULT GetSignalStrength(PDWORD pdw);
	void GetRing ( MediaPacket ***pppAudPckt, ULONG *puSize ) { *pppAudPckt = &m_Ring[0]; *puSize = (ULONG) m_RingSize; }
	virtual Destroy();

	void InjectBeeps(int nBeeps);

protected:
	DWORD m_dwFlags;
	IRTPRecv *m_pRTP;
	MediaPacket *m_Ring[MAX_RXRING_SIZE];
	BufferPool *m_pDecodeBufferPool;	// pool of free bufs
	UINT m_RingSize;            // Size of ring of MediaPackets. Initialized at 32.
	UINT m_PlayPos;             // Ring position of the packet to be played. Initialized to 0.
	DWORD m_PlayT;              // Timestamp of the packet to be played. Initialized to 0.
	UINT m_PlaySeq;             // Unused!!!
	UINT m_MaxPos;              // Maximum position in the ring of all the packets received so far. Initialized to 0. Equal to the position of the last packet received, unless this last packet is late.
	DWORD m_MaxT;               // Maximum timestamp of all the packets received so far. Initialized to 0. Equal to the timestamp of the last packet received, unless this last packet is late.
	UINT m_DelayPos;            // Current delay position with the maximum position in the ring of all the packets received so far. m_MinDelayPos <= m_DelayPos <= m_MaxDelayPos.
	UINT m_MinDelayPos;         // Minimum offset in position in the ring (delay) with the packet to be played. m_MinDelayPos <= m_DelayPos <= m_MaxDelayPos. Minimum value is 2. Initial value is m_SamplesPerSec/4/m_SamplesPerPkt == 250ms.
	UINT m_MaxDelayPos;         // Maximum offset in position in the ring (delay) with the packet to be played. m_MinDelayPos <= m_DelayPos <= m_MaxDelayPos. Minimum value is ???. Initial value is m_SamplesPerSec*3/4/m_SamplesPerPkt == 750ms.
	UINT m_FreePos;             // Maximum ring position of a free buffer. Initialized to m_RingSize - 1. Usually, m_FreePos == m_PlayPos - 1 or smaller if the buffer before m_PlayPos are still busy.
	DWORD m_SendT0;             // m_SendT0 is the send timestamp of the packet with the shortest trip delay. We could have just stored (m_ArrivalT0 - m_SendT0) but since the local and remote clocks are completely unsynchronized, there would be signed/unsigned complications.
	DWORD m_ArrivalT0;          // m_ArrivalT0 is the arrival timestamp of the packet with the shortest trip delay. We could have just stored (m_ArrivalT0 - m_SendT0) but since the local and remote clocks are completely unsynchronized, there would be signed/unsigned complications.
	LONG m_ScaledAvgVarDelay;   // Average Variable Delay according to m_ScaledAvgVarDelay = m_ScaledAvgVarDelay + (delay - m_ScaledAvgVarDelay/16). This is the m_DelayPos jitter.
	UINT m_SamplesPerPkt;       // Number of samples per audio packet. We're talking PCM samples here, even for compressed data. Initialized to 640. Usually worth several compressed audio frames.
	UINT m_SamplesPerSec;       // Sample rate, in samples per second (hertz), that each channel should be played or recorded. m_SamplesPerSec's initialization value is 8.0 kHz.
	CRITICAL_SECTION m_CritSect;
	UINT ModRing(UINT i) {return (i & (m_RingSize-1));}
	virtual void StartDecode(void);     // overrided in RVStream
	MediaPacket *GetNextDecode();
	void UpdateVariableDelay(DWORD sendT, DWORD arrT);
	DWORD MsToTimestamp(DWORD ms) {return ms*m_SamplesPerSec/1000;}	//BUGBUG: Chance of overflow?
	BOOL m_fPreamblePacket;
	AudioSilenceDetector m_AudioMonitor;
	UINT m_SilenceDurationT;

	AcmFilter *m_pAudioFilter;
	WAVEFORMATEX m_wfxSrc;
	WAVEFORMATEX m_wfxDst;

	int m_nBeeps;
};

#include <poppack.h> /* End byte packing */



#endif // _RXSTREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\threadevent.h ===
#ifndef _NAC_TEP_H_
#define _NAC_TEP_H_

#include "imstream.h"

extern const int WM_TEP_MESSAGE;

#include <pshpack8.h> /* Assume 8 byte packing throughout */


class ThreadEventProxy
{
public:

	ThreadEventProxy(IStreamEventNotify *pNotify, HINSTANCE hInstance);
	~ThreadEventProxy();

	BOOL ThreadEvent(UINT uDirection, UINT uMediaType,
	            UINT uEventCode, UINT uSubCode);

private:
	HWND m_hwnd;  // hidden Window
	IStreamEventNotify *m_pNotify;


	static LPARAM __stdcall WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	static BOOL s_bWndClassRegistered;
	static const LPTSTR s_szWndClassName;
};

#include <poppack.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\sendaudio.cpp ===
#include "precomp.h"
#include "dtmf.h"


HRESULT
SendAudioStream::Initialize( DataPump *pDP)
{
	HRESULT hr = DPR_OUT_OF_MEMORY;
	DWORD dwFlags =  DP_FLAG_FULL_DUPLEX | DP_FLAG_AUTO_SWITCH ;
	MEDIACTRLINIT mcInit;
	FX_ENTRY ("SendAudioStream::Initialize")

	dwFlags |= DP_FLAG_ACM | DP_FLAG_MMSYSTEM | DP_FLAG_AUTO_SILENCE_DETECT;

	// store the platform flags
	// enable Send and Recv by default
	m_DPFlags = (dwFlags & DP_MASK_PLATFORM) | DPFLAG_ENABLE_SEND;
	// store a back pointer to the datapump container
	m_pDP = pDP;

	m_Net = NULL; // this object (RTPSession) no longer used;
	m_pRTPSend = NULL;  // replaced with this object (RTPSend)

	// Initialize data (should be in constructor)
	m_CaptureDevice = (UINT) -1;	// use VIDEO_MAPPER



	// Create and Transmit audio streams
	
    DBG_SAVE_FILE_LINE
	m_SendStream = new TxStream();
	if ( !m_SendStream)
	{
		DEBUGMSG (ZONE_DP, ("%s: TxStream new failed\r\n", _fx_));
 		goto StreamAllocError;
	}


	// Create Input and Output audio filters
    DBG_SAVE_FILE_LINE
	m_pAudioFilter = new AcmFilter();  // audio filter will replace m_SendFilter
	if (!m_pAudioFilter)
	{
		DEBUGMSG (ZONE_DP, ("%s: FilterManager new failed\r\n", _fx_));
		goto FilterAllocError;
	}
	
	//Create MultiMedia device control objects
    DBG_SAVE_FILE_LINE
	m_InMedia = new WaveInControl();
	if (!m_InMedia )
	{
		DEBUGMSG (ZONE_DP, ("%s: MediaControl new failed\r\n", _fx_));
		goto MediaAllocError;
	}

	// Initialize the send-stream media control object
	mcInit.dwFlags = dwFlags | DP_FLAG_SEND;
	hr = m_InMedia->Initialize(&mcInit);
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: IMedia->Init failed, hr=0x%lX\r\n", _fx_, hr));
		goto MediaAllocError;
	}

    DBG_SAVE_FILE_LINE
	m_pDTMF = new DTMFQueue;
	if (!m_pDTMF)
	{
		return DPR_OUT_OF_MEMORY;
	}



	// determine if the wave devices are available
	if (waveInGetNumDevs()) m_DPFlags |= DP_FLAG_RECORD_CAP;
	
	// set media to half duplex mode by default
	m_InMedia->SetProp(MC_PROP_DUPLEX_TYPE, DP_FLAG_HALF_DUPLEX);

	m_SavedTickCount = timeGetTime();	//so we start with low timestamps
	m_DPFlags |= DPFLAG_INITIALIZED;

	m_bAutoMix = FALSE; // where else do you initialize this ?

	return DPR_SUCCESS;


MediaAllocError:
	if (m_InMedia) delete m_InMedia;
FilterAllocError:
	if (m_pAudioFilter) delete m_pAudioFilter;
StreamAllocError:
	if (m_SendStream) delete m_SendStream;

	ERRORMESSAGE( ("%s: exit, hr=0x%lX\r\n", _fx_, hr));

	return hr;
}


SendAudioStream::~SendAudioStream()
{

	if (m_DPFlags & DPFLAG_INITIALIZED) {
		m_DPFlags &= ~DPFLAG_INITIALIZED;
	
		if (m_DPFlags & DPFLAG_CONFIGURED_SEND )
			UnConfigure();

		if (m_pRTPSend)
		{
			m_pRTPSend->Release();
			m_pRTPSend = NULL;
		}

		if (m_pDTMF)
		{
			delete m_pDTMF;
			m_pDTMF = NULL;
		}

		// Close the receive and transmit streams
		if (m_SendStream) delete m_SendStream;

		// Close the wave devices
		if (m_InMedia) { delete m_InMedia;}


		if (m_pAudioFilter)
			delete m_pAudioFilter;

		m_pDP->RemoveMediaChannel(MCF_SEND|MCF_AUDIO, (IMediaChannel*)(SendMediaStream*)this);
	}
}


HRESULT STDMETHODCALLTYPE SendAudioStream::QueryInterface(REFIID iid, void **ppVoid)
{
	// resolve duplicate inheritance to the SendMediaStream;

	extern IID IID_IProperty;

	if (iid == IID_IUnknown)
	{
		*ppVoid = (IUnknown*)((SendMediaStream*)this);
	}
	else if (iid == IID_IMediaChannel)
	{
		*ppVoid = (IMediaChannel*)((SendMediaStream *)this);
	}
	else if (iid == IID_IAudioChannel)
	{
		*ppVoid = (IAudioChannel*)this;
	}
	else if (iid == IID_IDTMFSend)
	{
		*ppVoid = (IDTMFSend*)this;
	}
	else if (iid == IID_IProperty)
	{
		*ppVoid = NULL;
		ERROR_OUT(("Don't QueryInterface for IID_IProperty, use IMediaChannel"));
		return E_NOINTERFACE;
	}
	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}
	AddRef();

	return S_OK;

}

ULONG STDMETHODCALLTYPE SendAudioStream::AddRef(void)
{
	return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE SendAudioStream::Release(void)
{
	LONG lRet;

	lRet = InterlockedDecrement(&m_lRefCount);

	if (lRet == 0)
	{
		delete this;
		return 0;
	}

	else
		return lRet;

}



	
HRESULT STDMETHODCALLTYPE SendAudioStream::Configure(
	BYTE *pFormat,
	UINT cbFormat,
	BYTE *pChannelParams,
	UINT cbParams,
	IUnknown *pUnknown)
{
	HRESULT hr;
	BOOL fRet;
	MEDIAPACKETINIT apInit;
	MEDIACTRLCONFIG mcConfig;
	MediaPacket **ppAudPckt;
	ULONG cAudPckt;
	DWORD_PTR dwPropVal;
    DWORD dwSourceSize, dwDestSize;
	UINT ringSize = MAX_RXRING_SIZE;
	WAVEFORMATEX *pwfSend;
	DWORD dwPacketDuration, dwPacketSize;
	AUDIO_CHANNEL_PARAMETERS audChannelParams;
	audChannelParams.RTP_Payload = 0;
	MMRESULT mmr;
	int nIndex;
	
	FX_ENTRY ("SendAudioStream::Configure")

	// basic parameter checking
	if (! (m_DPFlags & DPFLAG_INITIALIZED))
		return DPR_OUT_OF_MEMORY;		//BUGBUG: return proper error;

	// Not a good idea to change anything while in mid-stream
	if (m_DPFlags & DPFLAG_STARTED_SEND)
	{
		return DPR_IO_PENDING; // anything better to return
	}

	if (m_DPFlags & DPFLAG_CONFIGURED_SEND)
	{
		DEBUGMSG(ZONE_DP, ("Stream Re-Configuration - calling UnConfigure"));
		UnConfigure();
	}


	if ((NULL == pFormat) || (NULL == pChannelParams) ||
		(cbParams < sizeof(AUDIO_CHANNEL_PARAMETERS)) ||
		(cbFormat < sizeof(WAVEFORMATEX)))
	{
		return DPR_INVALID_PARAMETER;
	}

	audChannelParams = *(AUDIO_CHANNEL_PARAMETERS *)pChannelParams;
	pwfSend = (WAVEFORMATEX *)pFormat;
	m_wfCompressed = *pwfSend;
	m_wfCompressed.cbSize = 0;

	mmr = AcmFilter::SuggestDecodeFormat(pwfSend, &m_fDevSend);

	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfSend->wFormatTag, REP_SEND_AUDIO_FORMAT);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfSend->nSamplesPerSec, REP_SEND_AUDIO_SAMPLING);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfSend->nAvgBytesPerSec * 8, REP_SEND_AUDIO_BITRATE);
	RETAILMSG(("NAC: Audio Send Format: %s", (pwfSend->wFormatTag == 66) ? "G723.1" : (pwfSend->wFormatTag == 112) ? "LHCELP" : (pwfSend->wFormatTag == 113) ? "LHSB08" : (pwfSend->wFormatTag == 114) ? "LHSB12" : (pwfSend->wFormatTag == 115) ? "LHSB16" : (pwfSend->wFormatTag == 6) ? "MSALAW" : (pwfSend->wFormatTag == 7) ? "MSULAW" : (pwfSend->wFormatTag == 130) ? "MSRT24" : "??????"));
	RETAILMSG(("NAC: Audio Send Sampling Rate (Hz): %ld", pwfSend->nSamplesPerSec));
	RETAILMSG(("NAC: Audio Send Bitrate (w/o network overhead - bps): %ld", pwfSend->nAvgBytesPerSec*8));

// Initialize the send-stream media control object
	mcConfig.uDuration = MC_USING_DEFAULT;	// set duration by samples per pkt
	mcConfig.pDevFmt = &m_fDevSend;
	mcConfig.hStrm = (DPHANDLE) m_SendStream;
	mcConfig.uDevId = m_CaptureDevice;
	mcConfig.cbSamplesPerPkt = audChannelParams.ns_params.wFrameSize
		*audChannelParams.ns_params.wFramesPerPkt;

	UPDATE_REPORT_ENTRY(g_prptCallParameters, mcConfig.cbSamplesPerPkt, REP_SEND_AUDIO_PACKET);
	RETAILMSG(("NAC: Audio Send Packetization (ms/packet): %ld", pwfSend->nSamplesPerSec ? mcConfig.cbSamplesPerPkt * 1000UL / pwfSend->nSamplesPerSec : 0));
	INIT_COUNTER_MAX(g_pctrAudioSendBytes, (pwfSend->nAvgBytesPerSec + pwfSend->nSamplesPerSec * (sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE) / mcConfig.cbSamplesPerPkt) << 3);

	hr = m_InMedia->Configure(&mcConfig);
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: IMedia->Config failed, hr=0x%lX\r\n", _fx_, hr));
		goto IMediaInitError;
	}

	
	// initialize the ACM filter
	mmr = m_pAudioFilter->Open(&m_fDevSend, pwfSend);
	if (mmr != 0)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmFilter->Open failed, mmr=%d\r\n", _fx_, mmr));
		hr = DPR_CANT_OPEN_CODEC;
		goto SendFilterInitError;
	}


	// Initialize the send stream and the packets
	ZeroMemory (&apInit, sizeof (apInit));

	apInit.dwFlags = DP_FLAG_SEND | DP_FLAG_ACM | DP_FLAG_MMSYSTEM;
	m_InMedia->FillMediaPacketInit (&apInit);

	m_InMedia->GetProp (MC_PROP_SIZE, &dwPropVal);
    dwSourceSize = (DWORD)dwPropVal;

	m_pAudioFilter->SuggestDstSize(dwSourceSize, &dwDestSize);

	apInit.cbSizeRawData = dwSourceSize;
	apInit.cbOffsetRawData = 0;
	apInit.cbSizeNetData = dwDestSize;
	dwPacketSize = dwDestSize;

	apInit.pStrmConvSrcFmt = &m_fDevSend;
	apInit.pStrmConvDstFmt = &m_wfCompressed;


	m_InMedia->GetProp (MC_PROP_DURATION, &dwPropVal);
    dwPacketDuration = (DWORD)dwPropVal;

	apInit.cbOffsetNetData = sizeof (RTP_HDR);
	apInit.payload = audChannelParams.RTP_Payload;
	fRet = m_SendStream->Initialize (DP_FLAG_MMSYSTEM, MAX_TXRING_SIZE, m_pDP, &apInit);
	if (! fRet)
	{
		DEBUGMSG (ZONE_DP, ("%s: TxStream->Init failed, fRet=0%u\r\n", _fx_, fRet));
		hr = DPR_CANT_INIT_TX_STREAM;
		goto TxStreamInitError;
	}

	// prepare headers for TxStream
	m_SendStream->GetRing (&ppAudPckt, &cAudPckt);
	m_InMedia->RegisterData (ppAudPckt, cAudPckt);
	m_InMedia->PrepareHeaders ();

	m_pAudioFilter->PrepareAudioPackets((AudioPacket**)ppAudPckt, cAudPckt, AP_ENCODE);

	// Open the play from wav file
	OpenSrcFile();


	// Initialize DTMF support
	m_pDTMF->Initialize(&m_fDevSend);
	m_pDTMF->ClearQueue();


	// WS2Qos will be called in Start to communicate stream reservations to the
	// remote endpoint using a RESV message
	//
	// We use a peak-rate allocation approach based on our target bitrates
	// Note that for the token bucket size and the maximum SDU size, we now
	// account for IP header overhead, and use the max frame fragment size
	// instead of the maximum compressed image size returned by the codec
	//
	// Some of the parameters are left unspecified because they are set
	// in the sender Tspec.


	InitAudioFlowspec(&m_flowspec, pwfSend, dwPacketSize);

	if (m_pDP->m_pIQoS)
	{
		// Initialize our requests. One for CPU usage, one for bandwidth usage.
		m_aRRq.cResourceRequests = 2;
		m_aRRq.aResourceRequest[0].resourceID = RESOURCE_OUTGOING_BANDWIDTH;
		if (dwPacketDuration)
			m_aRRq.aResourceRequest[0].nUnitsMin = (DWORD)(dwPacketSize + sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE) * 8000 / dwPacketDuration;
		else
			m_aRRq.aResourceRequest[0].nUnitsMin = 0;
		m_aRRq.aResourceRequest[1].resourceID = RESOURCE_CPU_CYCLES;
		m_aRRq.aResourceRequest[1].nUnitsMin = 800;

/*
        BUGBUG. This is, in theory the correct calculation, but until we do more investigation, go with a known value

		m_aRRq.aResourceRequest[1].nUnitsMin = (audDetails.wCPUUtilizationEncode+audDetails.wCPUUtilizationDecode)*10;

*/
		// Initialize QoS structure
		ZeroMemory(&m_Stats, sizeof(m_Stats));

		// Initialize oldest QoS callback timestamp
		// Register with the QoS module. Even if this call fails, that's Ok, we'll do without the QoS support
		m_pDP->m_pIQoS->RequestResources((GUID *)&MEDIA_TYPE_H323AUDIO, (LPRESOURCEREQUESTLIST)&m_aRRq, QosNotifyAudioCB, (DWORD_PTR)this);
	}

	m_DPFlags |= DPFLAG_CONFIGURED_SEND;


	return DPR_SUCCESS;

TxStreamInitError:
SendFilterInitError:
	m_InMedia->Close();
	m_pAudioFilter->Close();
IMediaInitError:
	ERRORMESSAGE(("%s:  failed, hr=0%u\r\n", _fx_, hr));
	return hr;
}




void SendAudioStream::UnConfigure()
{
	AudioPacket **ppAudPckt;
	ULONG uPackets;


	if ((m_DPFlags & DPFLAG_CONFIGURED_SEND)) {
	
		if (m_hCapturingThread) {
			Stop();
		}
		
		// Close the wave devices
		m_InMedia->Reset();
		m_InMedia->UnprepareHeaders();
		m_InMedia->Close();
		// Close the play from wav file
		CloseSrcFile();

		// Close the filters
		m_SendStream->GetRing ((MediaPacket***)&ppAudPckt, &uPackets);
		m_pAudioFilter->UnPrepareAudioPackets(ppAudPckt, uPackets, AP_ENCODE);
		m_pAudioFilter->Close();

		// Close the transmit streams
		m_SendStream->Destroy();
		m_DPFlags &= ~DPFLAG_CONFIGURED_SEND;
		m_ThreadFlags = 0;  // invalidate previous call to SetMaxBitrate


		// Release the QoS Resources
		// If the associated RequestResources had failed, the ReleaseResources can be
		// still called... it will just come back without having freed anything.
		if (m_pDP->m_pIQoS)
		{
			m_pDP->m_pIQoS->ReleaseResources((GUID *)&MEDIA_TYPE_H323AUDIO, (LPRESOURCEREQUESTLIST)&m_aRRq);
		}
	}
}


DWORD CALLBACK SendAudioStream::StartRecordingThread (LPVOID pVoid)
{
	SendAudioStream *pThisStream = (SendAudioStream*)pVoid;
	return pThisStream->RecordingThread();
}




// LOOK: identical to SendVideoStream version.
HRESULT
SendAudioStream::Start()
{
	FX_ENTRY ("SendAudioStream::Start")
	if (m_DPFlags & DPFLAG_STARTED_SEND)
		return DPR_SUCCESS;
	// TODO: remove this check once audio UI calls the IComChan PAUSE_ prop
	if (!(m_DPFlags & DPFLAG_ENABLE_SEND))
		return DPR_SUCCESS;
	if ((!(m_DPFlags & DPFLAG_CONFIGURED_SEND)) || (m_pRTPSend==NULL))
		return DPR_NOT_CONFIGURED;
	ASSERT(!m_hCapturingThread);
	m_ThreadFlags &= ~(DPTFLAG_STOP_RECORD|DPTFLAG_STOP_SEND);

	SetFlowSpec();

	// Start recording thread
	if (!(m_ThreadFlags & DPTFLAG_STOP_RECORD))
		m_hCapturingThread = CreateThread(NULL,0, SendAudioStream::StartRecordingThread,(LPVOID)this,0,&m_CaptureThId);

	m_DPFlags |= DPFLAG_STARTED_SEND;

	DEBUGMSG (ZONE_DP, ("%s: Record threadid=%x,\r\n", _fx_, m_CaptureThId));
	return DPR_SUCCESS;
}

// LOOK: identical to SendVideoStream version.
HRESULT
SendAudioStream::Stop()
{											
	DWORD dwWait;

	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		return DPR_SUCCESS;
	}
	
	m_ThreadFlags = m_ThreadFlags  |
		DPTFLAG_STOP_SEND |  DPTFLAG_STOP_RECORD ;

	if(m_SendStream)
		m_SendStream->Stop();
	
DEBUGMSG (ZONE_VERBOSE, ("STOP1: Waiting for record thread to exit\r\n"));

	/*
	 *	we want to wait for all the threads to exit, but we need to handle windows
	 *	messages (mostly from winsock) while waiting.
	 */

	if(m_hCapturingThread)
	{
		dwWait = WaitForSingleObject (m_hCapturingThread, INFINITE);

		DEBUGMSG (ZONE_VERBOSE, ("STOP2: Recording thread exited\r\n"));
		ASSERT(dwWait != WAIT_FAILED);
	
		CloseHandle(m_hCapturingThread);
		m_hCapturingThread = NULL;
	}
	m_DPFlags &= ~DPFLAG_STARTED_SEND;
	
	return DPR_SUCCESS;
}



// low order word is the signal strength
// high order work contains bits to indicate status
// (0x01 - transmitting)
// (0x02 - audio device is jammed)
STDMETHODIMP SendAudioStream::GetSignalLevel(UINT *pSignalStrength)
{
	UINT uLevel;
	DWORD dwJammed;
    DWORD_PTR dwPropVal;

	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		uLevel = 0;
	}
	else
	{
		uLevel = m_AudioMonitor.GetSignalStrength();

		m_InMedia->GetProp(MC_PROP_AUDIO_JAMMED, &dwPropVal);
        dwJammed = (DWORD)dwPropVal;

		if (dwJammed)
		{
			uLevel = (2 << 16);  // 0x0200
		}
		else if (m_fSending)
		{
			uLevel |= (1 << 16); // 0x0100 + uLevel
		}
	}

	*pSignalStrength = uLevel;
	return S_OK;
};



// this interface method is primarily for H.245 flow control messages
// it will pause the stream if uMaxBitrate is less than the codec
// output bitrate.  Only valid on a Configure'd stream.
HRESULT STDMETHODCALLTYPE SendAudioStream::SetMaxBitrate(UINT uMaxBitrate)
{
	UINT uMinBitrate;
	
	if (!(m_DPFlags & DPFLAG_CONFIGURED_SEND))
	{
		return DPR_NOT_CONFIGURED;
	}

	uMinBitrate = 8 * m_wfCompressed.nAvgBytesPerSec;

	if (uMaxBitrate < uMinBitrate)
	{
		DEBUGMSG(1, ("SendAudioStream::SetMaxBitrate - PAUSING"));
		m_ThreadFlags |= DPTFLAG_PAUSE_SEND;
	}
	else
	{
		DEBUGMSG(1, ("SendAudioStream::SetMaxBitrate - UnPausing"));
		m_ThreadFlags = m_ThreadFlags & ~(DPTFLAG_PAUSE_SEND);
	}

	return S_OK;
}

//  IProperty::GetProperty / SetProperty
//  (DataPump::MediaChannel::GetProperty)
//      Properties of the MediaChannel. Supports properties for both audio
//      and video channels.

STDMETHODIMP
SendAudioStream::GetProperty(
	DWORD prop,
	PVOID pBuf,
	LPUINT pcbBuf
    )
{
	HRESULT hr = DPR_SUCCESS;
	RTP_STATS RTPStats;
	DWORD_PTR dwPropVal;
	UINT len = sizeof(DWORD);	// most props are DWORDs

	if (!pBuf || *pcbBuf < len)
    {
		*pcbBuf = len;
		return DPR_INVALID_PARAMETER;
	}

	switch (prop)
    {
	case PROP_AUDIO_STRENGTH:
		return GetSignalLevel((UINT *)pBuf);

	case PROP_AUDIO_JAMMED:
		hr = m_InMedia->GetProp(MC_PROP_AUDIO_JAMMED, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

#ifdef OLDSTUFF
	case PROP_NET_SEND_STATS:
		if (m_Net && *pcbBuf >= sizeof(RTP_STATS))
        {
			m_Net->GetSendStats((RTP_STATS *)pBuf);
			*pcbBuf = sizeof(RTP_STATS);
		} else
			hr = DPR_INVALID_PROP_VAL;
			
		break;
#endif

	case PROP_DURATION:
		hr = m_InMedia->GetProp(MC_PROP_DURATION, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_SILENCE_LEVEL:
		*(DWORD *)pBuf = m_AudioMonitor.GetSilenceLevel();
		break;

	case PROP_SILENCE_DURATION:
		hr = m_InMedia->GetProp(MC_PROP_SILENCE_DURATION, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_DUPLEX_TYPE:
		hr = m_InMedia->GetProp(MC_PROP_DUPLEX_TYPE, &dwPropVal);
		if(HR_SUCCEEDED(hr))
		{
			if(dwPropVal & DP_FLAG_FULL_DUPLEX)
				*(DWORD *)pBuf = DUPLEX_TYPE_FULL;
			else
				*(DWORD *)pBuf = DUPLEX_TYPE_HALF;
		}
		break;

	case PROP_AUDIO_SPP:
		hr = m_InMedia->GetProp(MC_PROP_SPP, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_AUDIO_SPS:
		hr = m_InMedia->GetProp(MC_PROP_SPS, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_WAVE_DEVICE_TYPE:
		*(DWORD *)pBuf = m_DPFlags & DP_MASK_WAVE_DEVICE;
		break;

	case PROP_RECORD_ON:
		*(DWORD *)pBuf = (m_DPFlags & DPFLAG_ENABLE_SEND) !=0;
		break;

	case PROP_AUDIO_AUTOMIX:
		*(DWORD *)pBuf = m_bAutoMix;
		break;

	case PROP_RECORD_DEVICE:
		*(DWORD *)pBuf = m_CaptureDevice;
		break;

	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}


STDMETHODIMP
SendAudioStream::SetProperty(
	DWORD prop,
	PVOID pBuf,
	UINT cbBuf
    )
{
	DWORD dw;
	HRESULT hr = S_OK;
	
	if (cbBuf < sizeof (DWORD))
		return DPR_INVALID_PARAMETER;

	switch (prop)
    {
	case PROP_SILENCE_LEVEL:
		m_AudioMonitor.SetSilenceLevel(*(DWORD *)pBuf);
		RETAILMSG(("NAC: Silence Level set to %d / 1000",*(DWORD*)pBuf));
		break;

	case PROP_DUPLEX_TYPE:
		ASSERT(0);
		break;


	case DP_PROP_DUPLEX_TYPE:
		dw = *(DWORD*)pBuf;
		if (dw)
		{
			dw = DP_FLAG_FULL_DUPLEX;
		}
		else
		{
			dw = DP_FLAG_HALF_DUPLEX;
		}

		m_InMedia->SetProp(MC_PROP_DUPLEX_TYPE, dw);
		break;

	case PROP_VOICE_SWITCH:
		// set duplex type of both input and output
		dw = *(DWORD*)pBuf;
		switch(dw)
		{
			case VOICE_SWITCH_MIC_ON:
				dw = DP_FLAG_MIC_ON;
			break;
			case VOICE_SWITCH_MIC_OFF:
				dw = DP_FLAG_MIC_OFF;
			break;
			default:
			case VOICE_SWITCH_AUTO:
				dw = DP_FLAG_AUTO_SWITCH;
			break;
		}
	
		hr = m_InMedia->SetProp(MC_PROP_VOICE_SWITCH, dw);
		RETAILMSG(("NAC: Setting voice switch to %s", (DP_FLAG_AUTO_SWITCH & dw) ? "Auto" : ((DP_FLAG_MIC_ON & dw)? "MicOn":"MicOff")));
		break;

	case PROP_SILENCE_DURATION:
		hr = m_InMedia->SetProp(MC_PROP_SILENCE_DURATION, *(DWORD*)pBuf);
		RETAILMSG(("NAC: setting silence duration to %d ms",*(DWORD*)pBuf));
		break;
// TODO: remove this property once UI calls IComChan version
	case PROP_RECORD_ON:
	{
		DWORD flag =  DPFLAG_ENABLE_SEND ;
		if (*(DWORD *)pBuf) {
			m_DPFlags |= flag; // set the flag
			Start();
		}
		else
		{
			m_DPFlags &= ~flag; // clear the flag
			Stop();
		}
		RETAILMSG(("NAC: %s", *(DWORD*)pBuf ? "Enabling":"Disabling"));
		break;
	}	

	case PROP_AUDIO_AUTOMIX:
		m_bAutoMix = *(DWORD*)pBuf;
		break;


	case PROP_RECORD_DEVICE:
		m_CaptureDevice = *(DWORD*)pBuf;
		RETAILMSG(("NAC: Setting default record device to %d", m_CaptureDevice));
		break;

	default:
		return DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}

void SendAudioStream::EndSend()
{
}








/*************************************************************************

  Function: SendAudioStream::OpenSrcFile(void)

  Purpose : Opens wav file to read audio data from.

  Returns : HRESULT.

  Params  : None

  Comments: * Registry keys:
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\fPlayFromFile
              If set to zero, data will not be read from wav file.
              If set to a non null value <= INT_MAX, data will be read from wav file.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\szInputFileName
              Name of the wav file to read audio data from.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\fLoop
              If set to zero, the file will only be read once.
              If set to a non null value <= INT_MAX, the file will be read circularly.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\cchIOBuffer
              If set to zero, size of the MM IO buffer is set to its default value (8Kbytes).
              If set to one, size of the MM IO buffer is set to match maximum size of the wav file.
              If set a non null value between 2 and INT_MAX, size of the MM IO buffer is set to cchIOBuffer bytes.

  History : Date      Reason
            06/02/96  Created - PhilF

*************************************************************************/
HRESULT SendAudioStream::OpenSrcFile (void)
{
	return AudioFile::OpenSourceFile(&m_mmioSrc, &m_fDevSend);
}


/*************************************************************************

  Function: DataPump::CloseSrcFile(void)

  Purpose : Close wav file used to read audio data from.

  Returns : HRESULT.

  Params  : None

  Comments:

  History : Date      Reason
            06/02/96  Created - PhilF

*************************************************************************/
HRESULT SendAudioStream::CloseSrcFile (void)
{
	return AudioFile::CloseSourceFile(&m_mmioSrc);
}


HRESULT CALLBACK SendAudioStream::QosNotifyAudioCB(LPRESOURCEREQUESTLIST lpResourceRequestList, DWORD_PTR dwThis)
{
	HRESULT hr=NOERROR;
	LPRESOURCEREQUESTLIST prrl=lpResourceRequestList;
	int i;
#ifdef LOGSTATISTICS_ON
	int iMaxBWUsage, iMaxCPUUsage;
	char szDebug[256];
#endif
	DWORD dwCPUUsage, dwBWUsage;
	int iCPUUsageId, iBWUsageId;
	UINT dwSize = sizeof(int);
	SendMediaStream *pThis = (SendMediaStream *)dwThis;

	// Enter critical section to allow QoS thread to read the statistics while recording
	EnterCriticalSection(&(pThis->m_crsQos));

	// Record the time of this callback call
	pThis->m_Stats.dwNewestTs = timeGetTime();

	// Only do anything if we have at least captured a frame in the previous epoch
	if ((pThis->m_Stats.dwCount) && (pThis->m_Stats.dwNewestTs > pThis->m_Stats.dwOldestTs))
	{
#ifdef LOGSTATISTICS_ON
		wsprintf(szDebug, "    Epoch = %ld\r\n", pThis->m_Stats.dwNewestTs - pThis->m_Stats.dwOldestTs);
		OutputDebugString(szDebug);
#endif
		// Read the stats
		dwCPUUsage = pThis->m_Stats.dwMsComp * 1000UL / (pThis->m_Stats.dwNewestTs - pThis->m_Stats.dwOldestTs);
		dwBWUsage = pThis->m_Stats.dwBits * 1000UL / (pThis->m_Stats.dwNewestTs - pThis->m_Stats.dwOldestTs);

		// Initialize QoS structure. Only the four first fields should be zeroed.
		ZeroMemory(&(pThis->m_Stats), 4UL * sizeof(DWORD));

		// Record the time of this call for the next callback call
		pThis->m_Stats.dwOldestTs = pThis->m_Stats.dwNewestTs;
	}
	else
		dwBWUsage = dwCPUUsage = 0UL;

	// Get the latest RTCP stats and update the counters.
	// we do this here because it is called periodically.
	if (pThis->m_pRTPSend)
	{
		UINT lastPacketsLost = pThis->m_RTPStats.packetsLost;
		if (g_pctrAudioSendLost &&  SUCCEEDED(pThis->m_pRTPSend->GetSendStats(&pThis->m_RTPStats)))
			UPDATE_COUNTER(g_pctrAudioSendLost, pThis->m_RTPStats.packetsLost-lastPacketsLost);
	}
		
	// Leave critical section
	LeaveCriticalSection(&(pThis->m_crsQos));


	// Get the max for the resources.
#ifdef LOGSTATISTICS_ON
	iMaxCPUUsage = -1L; iMaxBWUsage = -1L;
#endif
	for (i=0, iCPUUsageId = -1L, iBWUsageId = -1L; i<(int)lpResourceRequestList->cRequests; i++)
		if (lpResourceRequestList->aRequests[i].resourceID == RESOURCE_OUTGOING_BANDWIDTH)
			iBWUsageId = i;
		else if (lpResourceRequestList->aRequests[i].resourceID == RESOURCE_CPU_CYCLES)
			iCPUUsageId = i;

#ifdef LOGSTATISTICS_ON
	if (iBWUsageId != -1L)
		iMaxBWUsage = lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin;
	if (iCPUUsageId != -1L)
		iMaxCPUUsage = lpResourceRequestList->aRequests[iCPUUsageId].nUnitsMin;
#endif

	// Update the QoS resources (only if you need less than what's available)
	if (iCPUUsageId != -1L)
	{
		if ((int)dwCPUUsage < lpResourceRequestList->aRequests[iCPUUsageId].nUnitsMin)
			lpResourceRequestList->aRequests[iCPUUsageId].nUnitsMin = dwCPUUsage;
	}
	
	if (iBWUsageId != -1L)
	{
		if ((int)dwBWUsage < lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin)
			lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin = dwBWUsage;
	}

#ifdef LOGSTATISTICS_ON
	// How are we doing?
	if (iCPUUsageId != -1L)
	{
		wsprintf(szDebug, " A: Max CPU Usage: %ld, Current CPU Usage: %ld\r\n", iMaxCPUUsage, dwCPUUsage);
		OutputDebugString(szDebug);
	}
	if (iBWUsageId != -1L)
	{
		wsprintf(szDebug, " A: Max BW Usage: %ld, Current BW Usage: %ld\r\n", iMaxBWUsage, dwBWUsage);
		OutputDebugString(szDebug);
	}
#endif

	return hr;
}



HRESULT __stdcall SendAudioStream::AddDigit(int nDigit)
{
	IMediaChannel *pIMC = NULL;
	RecvMediaStream *pRecv = NULL;
	BOOL bIsStarted;

	if ((!(m_DPFlags & DPFLAG_CONFIGURED_SEND)) || (m_pRTPSend==NULL))
	{
		return DPR_NOT_CONFIGURED;
	}

	bIsStarted = (m_DPFlags & DPFLAG_STARTED_SEND);

	if (bIsStarted)
	{
		Stop();
	}

	m_pDTMF->AddDigitToQueue(nDigit);
	SendDTMF();



	m_pDP->GetMediaChannelInterface(MCF_RECV | MCF_AUDIO, &pIMC);
	if (pIMC)
	{
		pRecv = static_cast<RecvMediaStream *> (pIMC);
		pRecv->DTMFBeep();
		pIMC->Release();
	}

	if (bIsStarted)
	{
		Start();
	}

	return S_OK;
}


HRESULT __stdcall SendAudioStream::SendDTMF()
{
	HRESULT hr;
	MediaPacket **ppAudPckt, *pPacket;
	ULONG uCount;
	UINT uBufferSize, uBytesSent;
	void *pBuffer;
	bool bMark = true;
	DWORD dwSamplesPerPkt;
	MMRESULT mmr;
	DWORD dwSamplesPerSec;
	DWORD dwPacketTimeMS;
    DWORD_PTR dwPropVal;
	UINT uTimerID;
	HANDLE hEvent = m_pDTMF->GetEvent();
	
	
	m_InMedia->GetProp (MC_PROP_SPP, &dwPropVal);
    dwSamplesPerPkt = (DWORD)dwPropVal;

	m_InMedia->GetProp (MC_PROP_SPS, &dwPropVal);
    dwSamplesPerSec = (DWORD)dwPropVal;

	dwPacketTimeMS = (dwSamplesPerPkt * 1000) / dwSamplesPerSec;

	timeBeginPeriod(5);
	ResetEvent(hEvent);
	uTimerID = timeSetEvent(dwPacketTimeMS-1, 5, (LPTIMECALLBACK)hEvent, 0, TIME_CALLBACK_EVENT_SET|TIME_PERIODIC);

	// since the stream is stopped, just grab any packet
	// from the TxStream

	m_SendStream->GetRing(&ppAudPckt, &uCount);
	pPacket = ppAudPckt[0];
	pPacket->GetDevData(&pBuffer, &uBufferSize);

	hr = m_pDTMF->ReadFromQueue((BYTE*)pBuffer, uBufferSize);

	while (SUCCEEDED(hr))
	{

		// there should be only 1 tone in the queue (it can handle more)
		// so assume we only need to set the mark bit on the first packet


		pPacket->m_fMark = bMark;
		bMark = false;

		pPacket->SetProp(MP_PROP_TIMESTAMP, m_SendTimestamp);
		m_SendTimestamp += dwSamplesPerPkt;

		pPacket->SetState (MP_STATE_RECORDED);

		// compress
		mmr = m_pAudioFilter->Convert((AudioPacket*)pPacket, AP_ENCODE);
		if (mmr == MMSYSERR_NOERROR)
		{
			pPacket->SetState(MP_STATE_ENCODED);
			SendPacket((AudioPacket*)pPacket, &uBytesSent);
			pPacket->m_fMark=false;
			pPacket->SetState(MP_STATE_RESET);
		}

		hr = m_pDTMF->ReadFromQueue((BYTE*)pBuffer, uBufferSize);

		// so that we don't overload the receive jitter buffer on the remote
		// side, sleep a few milliseconds between sending packets
		if (SUCCEEDED(hr))
		{
			WaitForSingleObject(hEvent, dwPacketTimeMS);
			ResetEvent(hEvent);
		}
	}

	timeKillEvent(uTimerID);
	timeEndPeriod(5);
	return S_OK;
}


HRESULT __stdcall SendAudioStream::ResetDTMF()
{
	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		return S_OK;
	}

	return m_pDTMF->ClearQueue();
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\threads.cpp ===
#include "precomp.h"
#include "mixer.h"
#include "agc.h"

// #define LOGSTATISTICS_ON 1

DWORD SendAudioStream::RecordingThread ()
{
	HRESULT hr = DPR_SUCCESS;
	MediaPacket *pPacket;
	DWORD dwWait;
	HANDLE hEvent;
	DWORD dwDuplexType;
	DWORD dwVoiceSwitch;
	DWORD_PTR dwPropVal;
	DWORD dwSamplesPerPkt;
	DWORD dwSamplesPerSec;
	DWORD dwSilenceLimit, dwMaxStrength, dwLengthMS;
	WORD wPeakStrength;
	UINT u, uBufferSize;
	UINT uSilenceCount = 0;
	UINT uPrefeed = 0;
	UINT uTimeout = 0;
	DevMediaQueue dq;
	BOOL  fSilent;
	AGC agc(NULL);  // audio gain control object
	CMixerDevice *pMixer = NULL;
	int nFailCount = 0;
	bool bCanSignalOpen=true;  // should we signal that the device is open

	// note: pMC is an artifact of when this thread was in the Datapump
	// namespace.  We can probably start phasing this variable out.
	// in the mean time:  "pMC = this" will suffice

	// SendAudioStream *pMC = (SendAudioStream *)(m_pDP->m_Audio.pSendStream);
	SendAudioStream *pMC = this;

	ASSERT(pMC && (pMC->m_DPFlags  & DPFLAG_INITIALIZED));
	
	TxStream		*pStream = pMC->m_SendStream;
	AcmFilter	*pAudioFilter = pMC->m_pAudioFilter;
	// warning: typecasting a base class ptr to a derived class ptr.
	WaveInControl	*pMediaCtrl = (WaveInControl *)pMC->m_InMedia;

	FX_ENTRY ("DP::RcrdTh:")

	// get thread context
	if (pStream == NULL || pAudioFilter == NULL || pMediaCtrl == NULL)
	{
		return DPR_INVALID_PARAMETER;
	}

	// Enter critical section: QoS thread also reads the statistics
	EnterCriticalSection(&pMC->m_crsQos);

	// Initialize QoS structure
	ZeroMemory(&pMC->m_Stats, 4UL * sizeof(DWORD));

	// Initialize oldest QoS callback timestamp
	pMC->m_Stats.dwNewestTs = pMC->m_Stats.dwOldestTs = timeGetTime();

	// Leave critical section
	LeaveCriticalSection(&pMC->m_crsQos);

	pMediaCtrl->GetProp(MC_PROP_MEDIA_DEV_ID, &dwPropVal);
	if (dwPropVal != (DWORD)WAVE_MAPPER)
	{
		pMixer = CMixerDevice::GetMixerForWaveDevice(NULL, (DWORD)dwPropVal, MIXER_OBJECTF_WAVEIN);
	}

	// even if pMixer is null, this is fine, AGC will catch subsequent errors
	agc.SetMixer(pMixer);

	// get thresholds
	pMediaCtrl->GetProp (MC_PROP_TIMEOUT, &dwPropVal);
	uTimeout = (DWORD)dwPropVal;
	pMediaCtrl->GetProp (MC_PROP_PREFEED, &dwPropVal);
	uPrefeed = (DWORD)dwPropVal;

	// get duplex type
	pMediaCtrl->GetProp (MC_PROP_DUPLEX_TYPE, &dwPropVal);
    dwDuplexType = (DWORD)dwPropVal;

	// get Samples/Pkt and Samples/Sec
	pMediaCtrl->GetProp (MC_PROP_SPP, &dwPropVal);
    dwSamplesPerPkt = (DWORD)dwPropVal;

	pMediaCtrl->GetProp (MC_PROP_SPS, &dwPropVal);
    dwSamplesPerSec = (DWORD)dwPropVal;

	pMediaCtrl->GetProp (MC_PROP_SILENCE_DURATION, &dwPropVal);
    dwSilenceLimit = (DWORD)dwPropVal;

	// calculate silence limit in units of packets
	// silence_time_in_ms/packet_duration_in_ms
	dwSilenceLimit = dwSilenceLimit*dwSamplesPerSec/(dwSamplesPerPkt*1000);

	// length of a packet in millisecs
	dwLengthMS = (dwSamplesPerPkt * 1000) / dwSamplesPerSec;


	dq.SetSize (MAX_TXRING_SIZE);

WaitForSignal:

	// DEBUGMSG (1, ("%s: WaitForSignal\r\n", _fx_));


	{
		pMediaCtrl->GetProp (MC_PROP_MEDIA_DEV_HANDLE, &dwPropVal);
		if (dwPropVal)
		{
			DEBUGMSG (ZONE_DP, ("%s: already open\r\n", _fx_));
			goto SendLoop; // sound device already open
		}

		// in the full-duplex case, open and prepare the device  and charge ahead.
		// in the half duplex case wait for playback's signal before opening the device
		while (TRUE)
		{
			// should I stop now???
			if (pMC->m_ThreadFlags & DPTFLAG_STOP_RECORD)
			{
				DEBUGMSG (ZONE_DP, ("%s: STOP_1\r\n", _fx_));
				goto MyEndThread;
			}
			dwWait = (dwDuplexType & DP_FLAG_HALF_DUPLEX) ? WaitForSingleObject (g_hEventHalfDuplex, uTimeout)
				: WAIT_OBJECT_0;

			// now, let's check why I don't need to wait
			if (dwWait == WAIT_OBJECT_0)
			{
				//DEBUGMSG (ZONE_DP, ("%s: try to open audio dev\r\n", _fx_));
				LOG((LOGMSG_OPEN_AUDIO));
				hr = pMediaCtrl->Open ();
				if (hr != DPR_SUCCESS)
				{
					DEBUGMSG (ZONE_DP, ("%s: MediaCtrl::Open failed, hr=0x%lX\r\n", _fx_, hr));
					
					pMediaCtrl->SetProp(MC_PROP_AUDIO_JAMMED, TRUE);

					SetEvent(g_hEventHalfDuplex);

					nFailCount++;

					if (nFailCount == MAX_FAILCOUNT)
					{
						// three attempts to open the device have failed
						// signal to the UI that something is wrong
						m_pDP->StreamEvent(MCF_SEND, MCF_AUDIO, STREAM_EVENT_DEVICE_FAILURE, 0);
						bCanSignalOpen = true;
					}

					Sleep(2000);	// Sleep for two seconds

					continue;
				}
				// Notification is not used. if needed do it thru Channel
				//pMC->m_Connection->DoNotification(CONNECTION_OPEN_MIC);
				pMediaCtrl->PrepareHeaders ();
				goto SendLoop;
			}

		} // while
	}	


SendLoop:
	nFailCount = 0;

	pMediaCtrl->SetProp(MC_PROP_AUDIO_JAMMED, FALSE);
	if (bCanSignalOpen)
	{
		m_pDP->StreamEvent(MCF_SEND, MCF_AUDIO, STREAM_EVENT_DEVICE_OPEN, 0);
		bCanSignalOpen = false; // don't signal more than once per session
	}

	// DEBUGMSG (1, ("%s: SendLoop\r\n", _fx_));
	// get event handle
	pMediaCtrl->GetProp (MC_PROP_EVENT_HANDLE, &dwPropVal);
	hEvent = (HANDLE) dwPropVal;
	if (hEvent == NULL)
	{
		DEBUGMSG (ZONE_DP, ("%s: invalid event\r\n", _fx_));
		return DPR_CANT_CREATE_EVENT;
	}


	// hey, in the very beginning, let's 'Start' it
	hr = pMediaCtrl->Start ();
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: MediaControl::Start failed, hr=0x%lX\r\n", _fx_, hr));
		goto MyEndThread;
	}

	// update timestamp to account for the 'sleep' period
	pMC->m_SendTimestamp += (GetTickCount() - pMC->m_SavedTickCount)*dwSamplesPerSec/1000;

	// let's feed four buffers first
	for (u = 0; u < uPrefeed; u++)
	{
		if ((pPacket = pStream->GetFree ()) != NULL)
		{
			if ((hr = pPacket->Record ()) != DPR_SUCCESS)
			{
				DEBUGMSG (ZONE_DP, ("%s: Record failed, hr=0x%lX\r\n", _fx_, hr));
			}
			dq.Put (pPacket);
		}
	}

	// let's get into the loop, mm system notification loop
	pMC->m_fSending= FALSE;
	while (TRUE)
	{
		dwWait = WaitForSingleObject (hEvent, uTimeout);

		// should I stop now???
		if (pMC->m_ThreadFlags & DPTFLAG_STOP_RECORD)
		{
			DEBUGMSG (ZONE_DP, ("%s: STOP_3\r\n", _fx_));
			goto HalfDuplexYield;
		}
		
		// get current voice switching mode
		pMediaCtrl->GetProp (MC_PROP_VOICE_SWITCH, &dwPropVal);
        dwVoiceSwitch = (DWORD)dwPropVal;

		// see why I don't need to wait
		if (dwWait != WAIT_TIMEOUT)
		{
			while (TRUE)
			{
				if ((pPacket = dq.Peek ()) != NULL)
				{
					if (! pPacket->IsBufferDone ())
					{
						break;
					}
					else
					{
						if (pMC->m_mmioSrc.fPlayFromFile && pMC->m_mmioSrc.hmmioSrc)
							pPacket->ReadFromFile (&pMC->m_mmioSrc);
						u--;	// one less buffer with the wave device
					}
				}
				else
				{
					DEBUGMSG (ZONE_VERBOSE, ("%s: Peek is NULL\r\n", _fx_));
					break;
				}

				pPacket = dq.Get ();


				((AudioPacket*)pPacket)->ComputePower (&dwMaxStrength, &wPeakStrength);

				// is this packet silent?

				fSilent = pMC->m_AudioMonitor.SilenceDetect((WORD)dwMaxStrength);
	
				if((dwVoiceSwitch == DP_FLAG_AUTO_SWITCH)
				&& fSilent)
				{
					// pPacket->SetState (MP_STATE_RESET); // note: done in Recycle
					if (++uSilenceCount >= dwSilenceLimit)
					{
						pMC->m_fSending = FALSE;	// stop sending packets
						// if half duplex mode and playback thread may be waiting
						if (dwDuplexType & DP_FLAG_HALF_DUPLEX)
						{
							IMediaChannel *pIMC = NULL;
							RecvMediaStream *pRecv;
							m_pDP->GetMediaChannelInterface(MCF_RECV | MCF_AUDIO, &pIMC);
							if (pIMC)
							{
								pRecv = static_cast<RecvMediaStream *> (pIMC);
								if (pRecv->IsEmpty()==FALSE)
								{
							//DEBUGMSG (ZONE_DP, ("%s: too many silence and Yield\r\n", _fx_));

									LOG((LOGMSG_REC_YIELD));
									pPacket->Recycle ();
									pStream->PutNextRecorded (pPacket);
									uSilenceCount = 0;
									pIMC->Release();
									goto HalfDuplexYield;
								}
								pIMC->Release();
							}
						}
					}
				}
				else
				{
					switch(dwVoiceSwitch)
					{	
						// either there was NO silence, or manual switching is in effect
						default:
						case DP_FLAG_AUTO_SWITCH:	// this proves no silence (in this path because of non-silence)
						case DP_FLAG_MIC_ON:
							pMC->m_fSending = TRUE;
							uSilenceCount = 0;
						break;
						case DP_FLAG_MIC_OFF:
							pMC->m_fSending = FALSE;
						break;
					}

				}
				if (pMC->m_fSending)
				{
					pPacket->SetState (MP_STATE_RECORDED);

					// do AUTOMIX, but ignore DTMF tones
					if (pMC->m_bAutoMix)
					{
						agc.Update(wPeakStrength, dwLengthMS);
					}
				}
				else
				{
					pPacket->Recycle();

					// Enter critical section: QoS thread also reads the statistics
					EnterCriticalSection(&pMC->m_crsQos);

					// Update total number of packets recorded
					pMC->m_Stats.dwCount++;

					// Leave critical section
					LeaveCriticalSection(&pMC->m_crsQos);
				}

				pPacket->SetProp(MP_PROP_TIMESTAMP,pMC->m_SendTimestamp);
				// pPacket->SetProp(MP_PROP_TIMESTAMP,GetTickCount());
				pMC->m_SendTimestamp += dwSamplesPerPkt;
				
				pStream->PutNextRecorded (pPacket);

			} // while
		}
		else
		{
			if (dwDuplexType & DP_FLAG_HALF_DUPLEX)
			{
				DEBUGMSG (ZONE_DP, ("%s: Timeout and Yield\r\n", _fx_));
				goto HalfDuplexYield;
			}
		} // if
		pMC->Send();

		// Make sure the recorder has an adequate number of buffers
		while ((pPacket = pStream->GetFree()) != NULL)
		{
			if ((hr = pPacket->Record ()) == DPR_SUCCESS)
			{
				dq.Put (pPacket);
			}
			else
			{
				dq.Put (pPacket);
				DEBUGMSG (ZONE_DP, ("%s: Record FAILED, hr=0x%lX\r\n", _fx_, hr));
				break;
			}
			u++;
		}
		if (u < uPrefeed)
		{
			DEBUGMSG (ZONE_DP, ("%s: NO FREE BUFFERS\r\n", _fx_));
		}
	} // while TRUE

	goto MyEndThread;


HalfDuplexYield:

	// stop and reset audio device
	pMediaCtrl->Reset ();

	// flush dq
	while ((pPacket = dq.Get ()) != NULL)
	{
		pStream->PutNextRecorded (pPacket);
		pPacket->Recycle ();
	}

	// save real time so we can update the timestamp when we restart
	pMC->m_SavedTickCount = GetTickCount();

	// reset the event
	ResetEvent (hEvent);

	// close audio device
	pMediaCtrl->UnprepareHeaders ();
	pMediaCtrl->Close ();

	// signal playback thread to start
	SetEvent (g_hEventHalfDuplex);

	if (!(pMC->m_ThreadFlags & DPTFLAG_STOP_RECORD)) {

		// yield
		// playback has to claim the device within 100ms or we take it back.
		Sleep (100);

		// wait for playback's signal
		goto WaitForSignal;
	}


MyEndThread:

	if (pMixer)
		delete pMixer;

	pMediaCtrl->SetProp(MC_PROP_AUDIO_JAMMED, FALSE);

	pMC->m_fSending = FALSE;
	DEBUGMSG (ZONE_DP, ("%s: Exiting.\r\n", _fx_));
	return hr;
}


DWORD RecvAudioStream::PlaybackThread ( void)
{
	HRESULT hr = DPR_SUCCESS;
	MediaPacket * pPacket;
	MediaPacket * pPrevPacket;
	MediaPacket * pNextPacket;
	DWORD dwWait;
	HANDLE hEvent;
	DWORD dwDuplexType;
	DWORD_PTR dwPropVal;
	UINT u;
	UINT uMissingCount = 0;
	UINT uPrefeed = 0;
	UINT uTimeout = 0;
	UINT uSamplesPerPkt=0;
	DevMediaQueue dq;
	UINT uGoodPacketsQueued = 0;
	int nFailCount = 0;
	bool bCanSignalOpen=true;
	//warning: casting from base to dervied class


	// note: pMC is an artifact of when this thread was in the Datapump
	// namespace.  We can probably start phasing this variable out.
	// in the mean time:  "pMC = this" will suffice
	// RecvAudioStream *pMC = (RecvAudioStream *)(m_pDP->m_Audio.pRecvStream);

	RecvAudioStream *pMC = this;
	
	RxStream		*pStream = pMC->m_RecvStream;
	MediaControl	*pMediaCtrl = pMC->m_OutMedia;

#if 0
	NETBUF * pStaticNetBuf;
#endif

	FX_ENTRY ("DP::PlayTh")

	if (pStream == NULL ||	m_pAudioFilter == NULL || pMediaCtrl == NULL)
	{
		return DPR_INVALID_PARAMETER;
	}

	// get event handle
	pMediaCtrl->GetProp (MC_PROP_EVENT_HANDLE, &dwPropVal);
	hEvent = (HANDLE) dwPropVal;
	if (hEvent == NULL)
	{
		DEBUGMSG (ZONE_DP, ("%s: invalid event\r\n", _fx_));
		return DPR_CANT_CREATE_EVENT;
	}


	// get thresholds
	pMediaCtrl->GetProp (MC_PROP_TIMEOUT, &dwPropVal);
	uTimeout = (DWORD)dwPropVal;

	uPrefeed = pStream->BufferDelay();

	// get samples per pkt
	pMediaCtrl->GetProp(MC_PROP_SPP, &dwPropVal);
	uSamplesPerPkt = (DWORD)dwPropVal;
	
	// get duplex type
	pMediaCtrl->GetProp (MC_PROP_DUPLEX_TYPE, &dwPropVal);
    dwDuplexType = (DWORD)dwPropVal;

	// set dq size
	dq.SetSize (uPrefeed);

WaitForSignal:

	// DEBUGMSG (1, ("%s: WaitForSignal\r\n", _fx_));

		pMediaCtrl->GetProp (MC_PROP_MEDIA_DEV_HANDLE, &dwPropVal);
		if (dwPropVal)
		{
			DEBUGMSG (ZONE_DP, ("%s: already open\r\n", _fx_));
			goto RecvLoop; // already open
		}

		// in the full-duplex case, open and prepare the device  and charge ahead.
		// in the half duplex case wait for playback's signal before opening the device
		while (TRUE)
		{
			// should I stop now???
			if (pMC->m_ThreadFlags & DPTFLAG_STOP_PLAY)
			{
				DEBUGMSG (ZONE_VERBOSE, ("%s: STOP_1\r\n", _fx_));
				goto MyEndThread;
			}
			dwWait = (dwDuplexType & DP_FLAG_HALF_DUPLEX) ? WaitForSingleObject (g_hEventHalfDuplex, uTimeout)
				: WAIT_OBJECT_0;


			// to see why I don't need to wait
			if (dwWait == WAIT_OBJECT_0)
			{
				// DEBUGMSG (1, ("%s: try to open audio dev\r\n", _fx_));
				pStream->FastForward(FALSE);	// GJ - flush receive queue
				hr = pMediaCtrl->Open ();
				if (hr != DPR_SUCCESS)
				{
					// somebody may have commandeered the wave out device
					// this could be a temporary problem so lets give it some time
					DEBUGMSG (ZONE_DP, ("%s: MediaControl::Open failed, hr=0x%lX\r\n", _fx_, hr));
					pMediaCtrl->SetProp(MC_PROP_AUDIO_JAMMED, TRUE);

					SetEvent(g_hEventHalfDuplex);

					nFailCount++;

					if (nFailCount == MAX_FAILCOUNT)
					{
						// three attempts to open the device have failed
						// signal to the UI that something is wrong
						m_pDP->StreamEvent(MCF_RECV, MCF_AUDIO, STREAM_EVENT_DEVICE_FAILURE, 0);
						bCanSignalOpen = true;
					}

					Sleep(2000);	// sleep for two seconds
					continue;
				}
				// Notification is not used. if needed do it thru Channel
				//pMC->m_Connection->DoNotification(CONNECTION_OPEN_SPK);
				pMediaCtrl->PrepareHeaders ();

				goto RecvLoop;
			}
		} // while

RecvLoop:
	nFailCount = 0;
	pMediaCtrl->SetProp(MC_PROP_AUDIO_JAMMED, FALSE);
	if (bCanSignalOpen)
	{
		m_pDP->StreamEvent(MCF_RECV, MCF_AUDIO, STREAM_EVENT_DEVICE_OPEN, 0);
		bCanSignalOpen = false;  // don't signal open more than once per session
	}


	// Set my thread priority high
	// This thread doesnt do any compute intensive work (except maybe
	// interpolate?).
	// Its sole purpose is to stream ready buffers to the sound device
	SetThreadPriority(pMC->m_hRenderingThread, THREAD_PRIORITY_HIGHEST);
	
	// DEBUGMSG (1, ("%s: SendLoop\r\n", _fx_));


	// let's feed four buffers first
	// But make sure the receive stream has enough buffering delay
	// so we dont read past the last packet.
	//if (uPrefeed > pStream->BufferDelay())
	uGoodPacketsQueued = 0;
	for (u = 0; u < uPrefeed; u++)
	{
		if ((pPacket = pStream->GetNextPlay ()) != NULL)
		{
			if (pPacket->GetState () == MP_STATE_RESET)
			{
				// hr = pPacket->Play (pStaticNetBuf);
				hr = pPacket->Play (&pMC->m_mmioDest, MP_DATATYPE_SILENCE);
			}
			else
			{
				// hr = pPacket->Play ();
				hr = pPacket->Play (&pMC->m_mmioDest, MP_DATATYPE_FROMWIRE);
				uGoodPacketsQueued++;
			}

			if (hr != DPR_SUCCESS)
			{
				DEBUGMSG (ZONE_DP, ("%s: Play failed, hr=0x%lX\r\n", _fx_, hr));
				SetEvent(hEvent);
			}

			dq.Put (pPacket);
		}
	}

	pMC->m_fReceiving = TRUE;
	// let's get into the loop
	uMissingCount = 0;
	while (TRUE)
	{
		
		dwWait = WaitForSingleObject (hEvent, uTimeout);

		// should I stop now???
		if (pMC->m_ThreadFlags & DPTFLAG_STOP_PLAY)
		{
			DEBUGMSG (ZONE_VERBOSE, ("%s: STOP_3\r\n", _fx_));
			goto HalfDuplexYield;
		}

		// see why I don't need to wait
		if (dwWait != WAIT_TIMEOUT)
		{
			while (TRUE)
			{
				if ((pPacket = dq.Peek ()) != NULL)
				{
					if (! pPacket->IsBufferDone ())
					{
						break;
					}
				}
				else
				{
					DEBUGMSG (ZONE_VERBOSE, ("%s: Peek is NULL\r\n", _fx_));
					break;
				}

				pPacket = dq.Get ();
				if (pPacket->GetState() != MP_STATE_PLAYING_SILENCE)
					uGoodPacketsQueued--;	// a non-empty buffer just got done
				pMC->m_PlaybackTimestamp = pPacket->GetTimestamp() + uSamplesPerPkt;
				pPacket->Recycle ();
				pStream->Release (pPacket);

				if ((pPacket = pStream->GetNextPlay ()) != NULL)
				{
					// check if we are in half-duplex mode and also if
					// the recording thread is around.
					if (dwDuplexType & DP_FLAG_HALF_DUPLEX)
					{
						IMediaChannel *pIMC = NULL;
						BOOL fSending = FALSE;
						m_pDP->GetMediaChannelInterface(MCF_SEND | MCF_AUDIO, &pIMC);
						if (pIMC)
						{
							fSending = (pIMC->GetState() == MSSTATE_STARTED);
							pIMC->Release();
						}
						if (fSending) {
							if (pPacket->GetState () == MP_STATE_RESET)
							{
								// Decide if its time to yield
								// Dont want to yield until we've finished playing all data packets
								//
								if (!uGoodPacketsQueued &&
									(pStream->IsEmpty() || ++uMissingCount >= DEF_MISSING_LIMIT))
								{
									//DEBUGMSG (ZONE_DP, ("%s: too many missings and Yield\r\n", _fx_));
									LOG( (LOGMSG_PLAY_YIELD));
									pPacket->Recycle ();
									pStream->Release (pPacket);
									goto HalfDuplexYield;
								}
							}
							else
							{
								uMissingCount = 0;
							}
						}
					}

					if (pPacket->GetState () == MP_STATE_RESET)
					{
						pPrevPacket = pStream->PeekPrevPlay ();
						pNextPacket = pStream->PeekNextPlay ();
						hr = pPacket->Interpolate(pPrevPacket, pNextPacket);
						if (hr != DPR_SUCCESS)
						{
							//DEBUGMSG (ZONE_DP, ("%s: Interpolate failed, hr=0x%lX\r\n", _fx_, hr));
							hr = pPacket->Play (&pMC->m_mmioDest, MP_DATATYPE_SILENCE);
						}
						else
							hr = pPacket->Play (&pMC->m_mmioDest, MP_DATATYPE_INTERPOLATED);
					}
					else
					{
						// hr = pPacket->Play ();
						hr = pPacket->Play (&pMC->m_mmioDest, MP_DATATYPE_FROMWIRE);
						uGoodPacketsQueued++;
					}

					if (hr != DPR_SUCCESS)
					{
						DEBUGMSG (ZONE_DP, ("%s: Play failed, hr=0x%lX\r\n", _fx_, hr));
						SetEvent(hEvent);
					}

					dq.Put (pPacket);
				} else {
					DEBUGMSG( ZONE_DP, ("%s: NO PLAY BUFFERS!",_fx_));
				}
			} // while
		}
		else
		{
			if (dwDuplexType & DP_FLAG_HALF_DUPLEX)
			{
				DEBUGMSG (ZONE_DP, ("%s: Timeout and Yield!\r\n", _fx_));
				goto HalfDuplexYield;
			}
		}
	} // while TRUE

	goto MyEndThread;


HalfDuplexYield:

	pMC->m_fReceiving = FALSE;
	// stop and reset audio device
	pMediaCtrl->Reset ();

	// flush dq
	while ((pPacket = dq.Get ()) != NULL)
	{
		pPacket->Recycle ();
		pStream->Release (pPacket);
	}

	// reset the event
	ResetEvent (hEvent);

	// close audio device
	pMediaCtrl->UnprepareHeaders ();
	pMediaCtrl->Close ();

	// signal recording thread to start
	SetEvent (g_hEventHalfDuplex);

	if (!(pMC->m_ThreadFlags & DPTFLAG_STOP_PLAY)) {
		// yield
		Sleep (0);

		// wait for recording's signal
		// restore thread priority
		SetThreadPriority(pMC->m_hRenderingThread,THREAD_PRIORITY_NORMAL);
		goto WaitForSignal;
	}

MyEndThread:

	pMediaCtrl->SetProp(MC_PROP_AUDIO_JAMMED, FALSE);


	DEBUGMSG(ZONE_DP, ("%s: Exiting.\n", _fx_));
	return hr;
}

DWORD SendAudioStream::Send()

{
	MMRESULT mmr;
 	MediaPacket *pAP;
	void *pBuffer;
	DWORD dwBeforeEncode;
	DWORD dwAfterEncode;
	DWORD dwPacketSize;
	UINT uBytesSent;
#ifdef LOGSTATISTICS_ON
	char szDebug[256];
	DWORD dwDebugSaveBits;
#endif

 	while ( pAP = m_SendStream->GetNext()) {
 		if (!(m_ThreadFlags & DPTFLAG_PAUSE_SEND)) {

			dwBeforeEncode = timeGetTime();
			mmr = m_pAudioFilter->Convert((AudioPacket*)pAP, AP_ENCODE);
			if (mmr == MMSYSERR_NOERROR)
			{
				pAP->SetState(MP_STATE_ENCODED);
			}

			// Time the encoding operation
			dwAfterEncode = timeGetTime() - dwBeforeEncode;

			if (mmr == MMSYSERR_NOERROR)
			{
				SendPacket((AudioPacket*)pAP, &uBytesSent);
			}
			else
			{
				uBytesSent = 0;
			}


		   	UPDATE_COUNTER(g_pctrAudioSendBytes, uBytesSent*8);

			// Enter critical section: QoS thread also reads the statistics
			EnterCriticalSection(&m_crsQos);

			// Update total number of packets recorded
			m_Stats.dwCount++;

			// Save the perfs in our stats structure for QoS
#ifdef LOGSTATISTICS_ON
			dwDebugSaveBits = m_Stats.dwBits;
#endif
			// Add this new frame size to the cumulated size
			m_Stats.dwBits += (uBytesSent * 8);

			// Add this compression time to total compression time
			m_Stats.dwMsComp += dwAfterEncode;

#ifdef LOGSTATISTICS_ON
			wsprintf(szDebug, " A: (Voiced) dwBits = %ld up from %ld (file: %s line: %ld)\r\n", m_Stats.dwBits, dwDebugSaveBits, __FILE__, __LINE__);
			OutputDebugString(szDebug);
#endif
			// Leave critical section
			LeaveCriticalSection(&m_crsQos);
 		}

		// whether or not we sent the packet, we need to return
		// it to the free queue
		pAP->m_fMark=0;
		pAP->SetState(MP_STATE_RESET);
		m_SendStream->Release(pAP);
	}
 	return DPR_SUCCESS;
}



// queues and sends the packet
// if the packet failed the encode process, it doesn't get sent

HRESULT SendAudioStream::SendPacket(AudioPacket *pAP, UINT *puBytesSent)
{
	PS_QUEUE_ELEMENT psq;
	UINT uLength;
	int nPacketsSent=0;


	if (pAP->GetState() != MP_STATE_ENCODED)
	{
		DEBUGMSG (ZONE_ACM, ("SendAudioStream::SendPacket: Packet not compressed\r\n"));
		*puBytesSent = 0;
		return E_FAIL;
	}

	ASSERT(m_pRTPSend);

	psq.pMP = pAP;
	psq.dwPacketType = PS_AUDIO;
	psq.pRTPSend = m_pRTPSend;
	pAP->GetNetData((void**)(&(psq.data)), &uLength);
	ASSERT(psq.data);
	psq.dwSize = uLength;
	psq.fMark = pAP->m_fMark;
	psq.pHeaderInfo = NULL;
	psq.dwHdrSize = 0;

	*puBytesSent = uLength + sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE;

	// add audio packets to the front of the queue
	m_pDP->m_PacketSender.m_SendQueue.PushFront(psq);

	while (m_pDP->m_PacketSender.SendPacket())
	{
		;
	}

	return S_OK;

};


#ifdef OLDSTUFF
/*
// Winsock 1 receive thread
// Creates a hidden window and a message loop to process WINSOCK window
// messages. Also processes private messages from the datapump to start/stop
// receiving on a particular media stream
 */
DWORD
DataPump::CommonRecvThread (void )
{

	HRESULT hr;
	HWND hWnd = (HWND)NULL;
	RecvMediaStream *pRecvMC;
	BOOL fChange = FALSE;
	MSG msg;
	DWORD curTime, nextUpdateTime = 0, t;
	UINT timerId = 0;
	
	FX_ENTRY ("DP::RecvTh")


	// Create hidden window
	hWnd =
	CreateWindowEx(
		WS_EX_NOPARENTNOTIFY,
        "SockMgrWClass", 	/* See RegisterClass() call.          */
        NULL,
        WS_CHILD ,    		/* Window style.                      */
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        m_hAppWnd,			/* the application window is the parent. */
        (HMENU)this,      	/* hardcoded ID         */
        m_hAppInst,   		/* the application owns this window.    */
        NULL				/* Pointer not needed.                */
    );

	if(!hWnd)
	{	
		hr = GetLastError();
		DEBUGMSG(ZONE_DP,("CreateWindow returned %d\n",hr));
		goto CLEANUPEXIT;
	}
	SetThreadPriority(m_hRecvThread, THREAD_PRIORITY_ABOVE_NORMAL);

    // This function is guaranteed to create a queue on this thread
    PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

	// notify thread creator that we're ready to recv messages
	SetEvent(m_hRecvThreadAckEvent);


	// Wait for control messages from Start()/Stop() or Winsock messages directed to
	// our hidden window
	while (GetMessage(&msg, NULL, 0, 0)) {
		switch(msg.message) {
		case MSG_START_RECV:
			// Start receiving on the specified media stream
			DEBUGMSG(ZONE_VERBOSE,("%s: MSG_START_RECV\n",_fx_));
			pRecvMC = (RecvMediaStream *)msg.lParam;
			// call the stream to post recv buffers and
			// tell Winsock to start sending socket msgs to our window
			pRecvMC->StartRecv(hWnd);
			fChange = TRUE;
			break;
			
		case MSG_STOP_RECV:
			// Stop receiving on the specified media stream
			DEBUGMSG(ZONE_VERBOSE,("%s: MSG_STOP_RECV\n",_fx_));
			pRecvMC = (RecvMediaStream *)msg.lParam;
			// call the stream to cancel outstanding recvs etc.
			// currently we assume this can be done synchronously
			pRecvMC->StopRecv();
			fChange = TRUE;
			break;
		case MSG_EXIT_RECV:
			// Exit the recv thread.
			// Assume that we are not currently receving on any stream.
			DEBUGMSG(ZONE_VERBOSE,("%s: MSG_EXIT_RECV\n",_fx_));
			fChange = TRUE;
			if (DestroyWindow(hWnd)) {
				break;
			}
			DEBUGMSG(ZONE_DP,("DestroyWindow returned %d\n",GetLastError()));
			// fall thru to PostQuitMessage()
			
		case WM_DESTROY:
			PostQuitMessage(0);
			break;
		case WM_TIMER:
			if (msg.hwnd == NULL) {
				// this timer is for the benefit of ThreadTimer::UpdateTime()
				// however, we are calling UpdateTime after every message (see below)
				// so we dont do anything special here.
				break;
			}
		default:
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        if (fChange) {
			// the thread MSGs need to be acked
			SetEvent(m_hRecvThreadAckEvent);
			fChange = FALSE;
		}
		
		t = m_RecvTimer.UpdateTime(curTime=GetTickCount());
		if (t != nextUpdateTime)  {
			// Thread timer wants to change its update time
			nextUpdateTime = t;
			if (timerId) {
				KillTimer(NULL,timerId);
				timerId = 0;
			}
			// if nextTime is zero, there are no scheduled timeouts so we dont need to call UpdateTime
			if (nextUpdateTime)
				timerId = SetTimer(NULL, 0, nextUpdateTime - curTime + 50, NULL);
		}
		

    }


	CLEANUPEXIT:
	DEBUGMSG(ZONE_DP,("%s terminating.\n", _fx_));

	return hr;

}

#endif
/*
	Winsock 2 receive thread. Main differnce here is that it has a WaitEx loop
	where we wait for Start/Stop commands from the datapump while allowing
	WS2 APCs to be handled.
	Note: Only way to use the same thread routine for WS1 and WS2 is with
	MsgWaitForMultipleObjectsEx, which unfortunately is not implemented in Win95
*/
DWORD
DataPump::CommonWS2RecvThread (void )
{

	HRESULT hr;
	RecvMediaStream *pRecvMC;
	BOOL fChange = FALSE, fExit = FALSE;
	DWORD dwWaitStatus;
	DWORD curTime,  t;
	
	FX_ENTRY ("DP::WS2RecvTh")


	SetThreadPriority(m_hRecvThread, THREAD_PRIORITY_ABOVE_NORMAL);


	// notify thread creator that we're ready to recv messages
	SetEvent(m_hRecvThreadAckEvent);


	while (!fExit) {
		// Wait for control messages from Start()/Stop() or Winsock async
		// thread callbacks

		// dispatch expired timeouts and check how long we need to wait
		t = m_RecvTimer.UpdateTime(curTime=GetTickCount());
		t = (t ? t-curTime+50 : INFINITE);
			
		dwWaitStatus = WaitForSingleObjectEx(m_hRecvThreadSignalEvent,t,TRUE);
		if (dwWaitStatus == WAIT_OBJECT_0) {
			switch(m_CurRecvMsg) {
			case MSG_START_RECV:
				// Start receiving on the specified media stream
				DEBUGMSG(ZONE_VERBOSE,("%s: MSG_START_RECV\n",_fx_));
				pRecvMC = m_pCurRecvStream;
				// call the stream to post recv buffers and
				// tell Winsock to start sending socket msgs to our window
				pRecvMC->StartRecv(NULL);
				fChange = TRUE;
				break;
				
			case MSG_STOP_RECV:
				// Stop receiving on the specified media stream
				DEBUGMSG(ZONE_VERBOSE,("%s: MSG_STOP_RECV\n",_fx_));
				pRecvMC = m_pCurRecvStream;
				// call the stream to cancel outstanding recvs etc.
				//  currently we assume this can be done synchronously
				pRecvMC->StopRecv();
				fChange = TRUE;
				break;
			case MSG_EXIT_RECV:
				// Exit the recv thread.
				// Assume that we are not currently receving on any stream.
				DEBUGMSG(ZONE_VERBOSE,("%s: MSG_EXIT_RECV\n",_fx_));
				fChange = TRUE;
				fExit = TRUE;
				break;

			case MSG_PLAY_SOUND:
				fChange = TRUE;
				pRecvMC->OnDTMFBeep();
				break;
				
			default:
				// shouldnt be anything else
				ASSERT(0);
	        }

	        if (fChange) {
				// the thread MSGs need to be acked
				SetEvent(m_hRecvThreadAckEvent);
				fChange = FALSE;
			}

	    } else if (dwWaitStatus == WAIT_IO_COMPLETION) {
	    	// nothing to do here
	    } else if (dwWaitStatus != WAIT_TIMEOUT) {
	    	DEBUGMSG(ZONE_DP,("%s: Wait failed with %d",_fx_,GetLastError()));
	    	fExit=TRUE;
	    }
	}

	DEBUGMSG(ZONE_DP,("%s terminating.\n", _fx_));

	return 0;

}


void ThreadTimer::SetTimeout(TTimeout *pTObj)
{
	DWORD time = pTObj->GetDueTime();
	// insert in increasing order of timeout
	for (TTimeout *pT = m_TimeoutList.pNext; pT != &m_TimeoutList; pT = pT->pNext) {
		if ((int)(pT->m_DueTime- m_CurTime) > (int) (time - m_CurTime))
			break;
	}
	pTObj->InsertAfter(pT->pPrev);
	
}

void ThreadTimer::CancelTimeout(TTimeout *pTObj)
{
	pTObj->Remove();	// remove from list
}

// Called by thread with the current time as input (usually obtained from GetTickCount())
// Returns the time by which UpdateTime() should be called again or currentTime+0xFFFFFFFF if there
// are no scheduled timeouts
DWORD ThreadTimer::UpdateTime(DWORD curTime)
{
	TTimeout *pT;
	m_CurTime = curTime;
	// figure out which timeouts have elapsed and do the callbacks
	while (!IsEmpty()) {
		pT = m_TimeoutList.pNext;
		if ((int)(pT->m_DueTime-m_CurTime) <= 0) {
			pT->Remove();
			pT->TimeoutIndication();
		} else
			break;
	}
	return (IsEmpty() ? m_CurTime+INFINITE : m_TimeoutList.pNext->m_DueTime);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\threadevent.cpp ===
#include "precomp.h"
#include "ThreadEvent.h"

const int WM_TEP_MESSAGE = WM_USER+101;

// static members
BOOL ThreadEventProxy::s_bWndClassRegistered = FALSE;
const LPTSTR ThreadEventProxy::s_szWndClassName = "NAC_TEP_HIDDENWINDOW";

ThreadEventProxy::ThreadEventProxy(IStreamEventNotify *pNotify, HINSTANCE hInst)
{
	WNDCLASSEX wndClass;


	if (s_bWndClassRegistered == FALSE)
	{
		ZeroMemory(&wndClass, sizeof(wndClass));
		wndClass.cbSize = sizeof(wndClass);
		wndClass.style = CS_HREDRAW | CS_VREDRAW;
		wndClass.lpfnWndProc = WndProc;
		wndClass.hInstance = hInst;
		wndClass.lpszClassName = s_szWndClassName;
		RegisterClassEx(&wndClass);
		s_bWndClassRegistered = TRUE;
	}

	m_hwnd = CreateWindow(s_szWndClassName, "Hidden Window",
                          WS_OVERLAPPEDWINDOW, 0, 0, 0, 0,
						  NULL,
						  NULL,
						  hInst,
						  NULL);

	if (m_hwnd)
		SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LPARAM)this);

	m_pNotify = pNotify;

	return;
}

ThreadEventProxy::~ThreadEventProxy()
{
	MSG msg;

	// just in case there is an outstanding message posted in the
	// queue for this window, clear the 
	if (m_hwnd)
	{
		SetWindowLongPtr(m_hwnd, GWLP_USERDATA, 0);
	}

	while (PeekMessage(&msg, m_hwnd, 0, 0, PM_REMOVE))
	{
		;
	}

	DestroyWindow(m_hwnd);
	m_hwnd = NULL;

}




// static
LPARAM ThreadEventProxy::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	ThreadEventProxy *pTEP;

	pTEP = (ThreadEventProxy*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	if (pTEP != NULL)
	{
		switch (uMsg)
		{

			case WM_TEP_MESSAGE:
			{
				// the message codes for the stream notifcation are
				// contained
				if (pTEP->m_pNotify)
					pTEP->m_pNotify->EventNotification(HIWORD(wParam), LOWORD(wParam), HIWORD(lParam), LOWORD(lParam));
				return 0;
			}
		}
	}

	return DefWindowProc(hwnd, uMsg, wParam, lParam);

}


BOOL ThreadEventProxy::ThreadEvent(UINT uDirection, UINT uMediaType,
                                   UINT uEventCode, UINT uSubCode)
{
	WPARAM wParam;
	LPARAM lParam;

	wParam = MAKELONG(uMediaType, uDirection);
	lParam = MAKELONG(uSubCode, uEventCode);

	if (m_hwnd)
	{
		PostMessage(m_hwnd, WM_TEP_MESSAGE, wParam, lParam);
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\txstream.cpp ===
/*
	TxStream.cpp
  */

#include "precomp.h"

TxStream::Initialize ( UINT flags, UINT numBufs, DataPump *pdp, MEDIAPACKETINIT *papi )
{
	UINT i;
	MediaPacket *pAP;


	m_RingSize = numBufs;
	if (flags & DP_FLAG_MMSYSTEM)
	{
		if (m_RingSize > MAX_TXRING_SIZE)
			return FALSE;
	}
	else if (flags & DP_FLAG_VIDEO)
	{
		if (m_RingSize > MAX_TXVRING_SIZE)
			return FALSE;
	}

	m_pDataPump = pdp;
	for (i=0; i < m_RingSize; i++)
	{
		if (flags & DP_FLAG_MMSYSTEM)
        {
            DBG_SAVE_FILE_LINE
			pAP = new AudioPacket;
        }
		else if (flags & DP_FLAG_VIDEO)
        {
            DBG_SAVE_FILE_LINE
			pAP = new VideoPacket;
        }
		else
			break;
		m_Ring[i] = pAP;
		papi->index = i;
		if (!pAP || pAP->Initialize(papi) != DPR_SUCCESS)
			break;
	}
	if (i < m_RingSize)
	{
		for (UINT j=0; j<=i; j++)
		{
			m_Ring[j]->Release();
			delete m_Ring[j];
		}
		return FALSE;
	}

	// queue is empty
	m_SendPos = m_FreePos = 0;
	m_PreSendCount = 1;	// cached silent buffers

	m_TxFlags = 0;

	// initialize object critical section
	InitializeCriticalSection(&m_CritSect);

	return TRUE;
}

TxStream::PutNextRecorded(MediaPacket *pAP)
{
	// insert into queue
	UINT thispos,pos;
	UINT unsent,cb;
	DWORD timestamp,ts;
	UINT spp;
	PVOID pUnused;
	BOOL fMarked;

	EnterCriticalSection(&m_CritSect);
	if (pAP->GetState() == MP_STATE_RECORDED) {
		if ( m_fTalkspurt == FALSE) {
			// beginning of a talkspurt
			thispos = pAP->GetIndex();
			timestamp = pAP->GetTimestamp();
			// figure out the samples per pkt
			//
			spp = 0;	// in case the below call fails
			if (pAP->GetDevData(&pUnused,&cb) == DPR_SUCCESS) {
				spp = cb/2;	// convert bytes to samples assuming 16 bit samples
			}

			// find the number of packets in send queue
			unsent = ModRing(thispos - m_SendPos);
			if (unsent > m_PreSendCount)
				unsent = m_PreSendCount;
			pos = ModRing(thispos - unsent);
			timestamp = timestamp - unsent*spp;
			// if there are (upto PreSendCount) unsent packets before this one, then
			// relabel 'silent' ones as 'recorded'.
			fMarked = FALSE;
			while (pos != thispos) {
				if (m_Ring[pos]->GetState() != MP_STATE_RECORDED) {
					// make sure the buffer is chronologically adjacent
					ts =m_Ring[pos]->GetTimestamp();
					if (ts == timestamp) {
						m_Ring[pos]->SetState(MP_STATE_RECORDED);
						if (!fMarked) {
							fMarked = TRUE;
							m_Ring[pos]->SetProp(MP_PROP_PREAMBLE, 1); // set the RTP Mark bit
						}
						LOG((LOGMSG_PRESEND,pos));
					}
				}
				timestamp += spp;
				pos = ModRing(pos+1);
			}
			m_fTalkspurt = TRUE;
		}
	} else {
		m_fTalkspurt = FALSE;
	}
	pAP->Busy(FALSE);
	LeaveCriticalSection(&m_CritSect);
	return TRUE;
}

// blocking call
// Get Audio packet from head of Transmit queue
// Called by the send thread
#if 0
MediaPacket *TxStream::GetNext()
{
	DWORD waitResult;
	MediaPacket *pAP = NULL;
	UINT pos;

	while (1) {
		// Recorded Packets are queued between SendPos and FreePos
		// Packets owned by the Play device are marked busy 
		EnterCriticalSection(&m_CritSect);
		while (m_SendPos != m_FreePos && !m_Ring[m_SendPos]->Busy()) {
			pos = m_SendPos;
			m_SendPos = ModRing(m_SendPos+1);
			// skip non-data (silence) packets
			if (m_Ring[pos]->GetState() == MP_STATE_RECORDED)  {
				// found a packet
				pAP = m_Ring[pos];
				pAP->Busy(TRUE);
				LeaveCriticalSection(&m_CritSect);
				if (m_fPreamblePacket)
				{
					pAP->SetProp (MP_PROP_PREAMBLE, TRUE);
					m_fPreamblePacket = FALSE;
				}
				return (pAP);
			}
						
		}

		LeaveCriticalSection(&m_CritSect);
		// nothing in the queue
		if (m_TxFlags & DPTFLAG_STOP_SEND)
			break;	// return NULL;
		waitResult = WaitForSingleObject(m_hQEvent, INFINITE);
	}
	return (NULL);
}
#endif
MediaPacket *TxStream::GetNext()
{
	DWORD waitResult;
	MediaPacket *pAP = NULL;
	UINT pos,recpos;

	{
		EnterCriticalSection(&m_CritSect);
		// Recorded Packets are queued between SendPos and FreePos
		// Packets owned by the Play device are marked busy 
		pos = m_SendPos;
		while (pos != m_FreePos && !m_Ring[pos]->Busy()) {
			pos = ModRing(pos+1);
		}
		recpos = pos;	// end marker
		if (recpos != m_SendPos) {

			// skip all but  'm_PreSendCount' silent packets.
			// (later we may decide some of these are not silent after all)
			while (ModRing(recpos-m_SendPos) > m_PreSendCount && m_Ring[m_SendPos]->GetState() != MP_STATE_RECORDED) {
				m_SendPos = ModRing(m_SendPos+1);
			}
			if (m_Ring[m_SendPos]->GetState() == MP_STATE_RECORDED) {
				// found a packet
				pAP = m_Ring[m_SendPos];
				pAP->Busy(TRUE);
				m_SendPos = ModRing(m_SendPos+1);
			}
		} // else recpos == m_SendPos 
		LeaveCriticalSection(&m_CritSect);
	}

	return pAP;

}
MediaPacket *TxStream::GetFree()
{
	UINT pos;
	MediaPacket *pAP;

	EnterCriticalSection(&m_CritSect);
	pos = ModRing(m_FreePos+1);

	if (pos == m_SendPos || m_Ring[pos]->Busy()) {
		LeaveCriticalSection(&m_CritSect);
		return NULL;

	}
	// ASSERT(m_Ring[pos]->GetState() == MP_STATE_RESET);
	// ASSERT(m_Ring[m_FreePos]->GetState() == MP_STATE_RESET);
	// 
	pAP = m_Ring[m_FreePos];
	pAP->Busy(TRUE);
	m_FreePos = pos;
	LeaveCriticalSection(&m_CritSect);
	return pAP;
}

// called by the send thread to free an MediaPacket
void TxStream::Release(MediaPacket *pAP)
{
	pAP->Busy(FALSE);
}

// Try to empty the queue by dumping unsent packets.
// However, we cant do anything about busy packets
UINT TxStream::Reset(void)
{
	UINT pos;
	BOOL success;
	EnterCriticalSection(&m_CritSect);
	pos = m_FreePos;
	// allow send thread to block on new packets
	m_TxFlags &= ~DPTFLAG_STOP_SEND;
	while (pos != m_SendPos && !m_Ring[pos]->Busy()) {
		pos = ModRing(pos+1);
	}
	if (pos == m_SendPos) {
		// good - no buffers with send thread
		while ( pos != m_FreePos && !m_Ring[pos]->Busy()) {
			m_Ring[pos]->MakeSilence();
			pos = ModRing(pos+1);
		}
		m_SendPos = pos;
		success = TRUE;
	} else {
		// bad - buffers have not been released by send thread
		// could sleep
		success = FALSE;
	}
	LOG((LOGMSG_TX_RESET, m_FreePos, m_SendPos));
	LeaveCriticalSection(&m_CritSect);
	return success;
}

void TxStream::Stop(void)
{
	EnterCriticalSection(&m_CritSect);
	m_TxFlags |= DPTFLAG_STOP_SEND;
	LeaveCriticalSection(&m_CritSect);
	
	return;

}

TxStream::Destroy(void)
{
	UINT i;
	for (i=0; i < m_RingSize; i++) {
		if (m_Ring[i]) {
			m_Ring[i]->Release();
			delete m_Ring[i];
		}
	}

	DeleteCriticalSection(&m_CritSect);
	return DPR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\threadsv.cpp ===
#include "precomp.h"

// #define LOGSTATISTICS_ON 1

#define RTPTIMEPERMS	90	// RTP timestamps use a 90Khz clock
DWORD g_iPost = 0UL;

// Constants
#define POLL_PERIOD 30


void
CALLBACK
TimeCallback(
    UINT uID,	
    UINT uMsg,	
    HANDLE hEvent,	
    DWORD dw1,	
    DWORD dw2	
    )
{
    SetEvent (hEvent);    // signal to initiate frame grab
}


DWORD SendVideoStream::CapturingThread (void )
{
    DWORD lasttime;
    IBitmapSurface* pBS;
	VideoPacket *pPacket;
	DWORD dwWait;
	HANDLE hEvent;
	HCAPDEV hCapDev;
	DWORD_PTR dwPropVal;
	DWORD dwBeforeCapture;
	DWORD dwFrames = 0;
	DWORD dwOver = 0;
	DWORD dwStart;
	UINT u;
	UINT uPreambleCount = 2;
	UINT uTimeout = 0;
	DevMediaQueue dq;
    SendVideoStream     *pMC = this;
	TxStream			*pStream = pMC->m_SendStream;
	MediaControl		*pMediaCtrl = pMC->m_InMedia;
    UINT    timerID;
    LPBITMAPINFOHEADER pbmih;
	HRESULT hr = DPR_SUCCESS;

#ifdef LOGSTATISTICS_ON
	char szDebug[256];
	HANDLE hDebugFile;
	DWORD d;
	DWORD dwDebugPrevious = 0UL;
#endif
	DWORD dwDelta;

	FX_ENTRY ("DP::CaptTh:")

	// get thread context
	if (pStream == NULL || m_pVideoFilter == NULL || pMediaCtrl == NULL)
	{
		return DPR_INVALID_PARAMETER;
	}

	// get thresholds
	pMediaCtrl->GetProp (MC_PROP_TIMEOUT, &dwPropVal);
	uTimeout = (DWORD)dwPropVal;

	// set dq size
	dq.SetSize (MAX_TXVRING_SIZE);

	pMediaCtrl->GetProp (MC_PROP_MEDIA_DEV_HANDLE, &dwPropVal);
	if (!dwPropVal)
	{
		DEBUGMSG (ZONE_DP, ("%s: capture device not open (0x%lX)\r\n", _fx_));
    	goto MyEndThread;
	}
    hCapDev = (HCAPDEV)dwPropVal;

#if 0
	// hey, in the very beginning, let's 'Start' it
	hr = pMediaCtrl->Start ();
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: MedVidCtrl::Start failed, hr=0x%lX\r\n", _fx_, hr));
		goto MyEndThread;
	}
#endif

	// update timestamp to account for the 'sleep' period
	dwPropVal = timeGetTime();
	pMC->m_SendTimestamp += ((DWORD)dwPropVal - pMC->m_SavedTickCount)*RTPTIMEPERMS;
	pMC->m_SavedTickCount = (DWORD)dwPropVal;

	// Enter critical section: QoS thread also reads the statistics
	EnterCriticalSection(&pMC->m_crsVidQoS);

	// Initialize QoS structure
	ZeroMemory(&pMC->m_Stats, 4UL * sizeof(DWORD));

	// Initialize oldest QoS callback timestamp
	pMC->m_Stats.dwNewestTs = pMC->m_Stats.dwOldestTs = (DWORD)dwPropVal;

	// Leave critical section
	LeaveCriticalSection(&pMC->m_crsVidQoS);

	// let's get into the loop
	pMC->m_fSending= TRUE;

    // get event handle
    if (!(hEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
        DEBUGMSG (ZONE_DP, ("%s: invalid event\r\n", _fx_));
        hr = DPR_CANT_CREATE_EVENT;
        goto MyEndThread;
    }

    if (!(timerID = timeSetEvent(POLL_PERIOD, 1, (LPTIMECALLBACK)&TimeCallback, (DWORD_PTR)hEvent, TIME_PERIODIC))) {
        DEBUGMSG (ZONE_DP, ("%s: failed to init MM timer\r\n", _fx_));
        CloseHandle (hEvent);
        hr = DPR_CANT_CREATE_EVENT;
        goto MyEndThread;
    }

	// force I-Frames to be sent for the first few frames
	// to make sure that the receiver gets one
	pMC->m_ThreadFlags |= DPTFLAG_SEND_PREAMBLE;

    pPacket = NULL;
    lasttime = timeGetTime();
    dwStart = lasttime;
	while (!(pMC->m_ThreadFlags & DPTFLAG_STOP_RECORD))
    {
		dwWait = WaitForSingleObject (hEvent, uTimeout);

		// see why I don't need to wait
		if ((dwWait != WAIT_TIMEOUT) && !(pMC->m_ThreadFlags & DPTFLAG_PAUSE_CAPTURE)) {
            if (!pPacket) {
	            if (pPacket = (VideoPacket *)pStream->GetFree()) {
                    if ((hr = pPacket->Record()) != DPR_SUCCESS) {
			    	    DEBUGMSG (ZONE_DP, ("%s: Capture FAILED, hr=0x%lX\r\n", _fx_, hr));
				        break;
    				}
	    		}
		    }

            dwBeforeCapture = timeGetTime();

	    	if (pPacket && pMC->m_pCaptureChain && dwBeforeCapture - lasttime >= pMC->m_frametime) {
                // If there's no frame ready, bail out of the loop and wait
                // until we get signaled.

#ifdef LOGSTATISTICS_ON
				hDebugFile = CreateFile("C:\\Timings.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
				SetFilePointer(hDebugFile, 0, NULL, FILE_END);
				wsprintf(szDebug, "Delta: %ld\r\n", dwBeforeCapture - dwDebugPrevious);
				WriteFile(hDebugFile, szDebug, strlen(szDebug), &d, NULL);
				CloseHandle(hDebugFile);
				dwDebugPrevious = dwBeforeCapture;
#endif

				dwDelta = dwBeforeCapture - lasttime - pMC->m_frametime;

#if 0
                if ((ci_state & CAPSTATE_INDLG) && lpbmih) {
                    lpbmih->biSize = GetCaptureDeviceFormatHeaderSize(g_hcapdev);
                    if (!GetCaptureDeviceFormat(g_hcapdev, lpbmih) ||
                        g_lpbmi->biSize != lpbmih->biSize ||
                        g_lpbmi->biSizeImage != lpbmih->biSizeImage)
                        continue;   // skip capture
                }
#endif

                pMC->m_pCaptureChain->GrabFrame(&pBS);

                if (pBS) {
                    // deal with captured frame

            	    if (!(pMC->m_DPFlags & DPFLAG_REAL_THING)) {
            	        dwWait = timeGetTime();
            	        dwOver += (dwWait - dwBeforeCapture);
                        if (++dwFrames == 20) {
                            dwWait -= dwStart;
                            dwOver = (dwOver * 13) / 10;    // 130%
                            pMC->m_frametime = (pMC->m_frametime * dwOver) / dwWait;
                            pMC->m_frametime = (pMC->m_frametime * 13) / 10;    // 130%
                            if (pMC->m_frametime < 50)
                                pMC->m_frametime = 50;
                            else if (pMC->m_frametime > 1000)
                                pMC->m_frametime = 1000;
                    	    dwOver = dwFrames = 0;   // restart tracking
                    	    dwStart = timeGetTime();
                        }
                    }

				    if (pMC->m_fSending) {
	    			    dwPropVal = timeGetTime();	// returns time in millisec

						// Enter critical section: QoS thread also reads the statistics
						EnterCriticalSection(&pMC->m_crsVidQoS);
						
						// If this is the first frame captured with a new frame rate value,
						// the delta isn't valid anymore -> reset it
						if (pMC->m_Stats.dwCount == 0)
							dwDelta = 0;

						// Update total number of frames captured
						pMC->m_Stats.dwCount++;

						// Add this capture time to total capture time
						// If we can access the CPU perf counters Ok, we won't use this value
						pMC->m_Stats.dwMsCap += (DWORD)dwPropVal - dwBeforeCapture;

						// Leave critical section
						LeaveCriticalSection(&pMC->m_crsVidQoS);
						
	    			    // convert to RTP time units (1/90Khz for video)
    				    pMC->m_SendTimestamp += ((DWORD)dwPropVal- pMC->m_SavedTickCount) * RTPTIMEPERMS;
						pMC->m_SavedTickCount = (DWORD)dwPropVal;

    				    pPacket->SetProp(MP_PROP_TIMESTAMP,pMC->m_SendTimestamp);
                    	pPacket->SetSurface(pBS);
					    pPacket->SetState(MP_STATE_RECORDED);
	    			    pStream->PutNextRecorded (pPacket);
		    		    pMC->Send();
				    	if (uPreambleCount) {
				    		if (!--uPreambleCount) {
				    			// return to default I-frame spacing
				    			pMC->m_ThreadFlags &= ~DPTFLAG_SEND_PREAMBLE;
				    		}
				    	}
				    	pPacket = NULL;

                        // Indicate that another frame was sent
                        UPDATE_COUNTER(g_pctrVideoSend, 1);
                    }

                    // release captured frame
                    pBS->Release();
                    lasttime = dwBeforeCapture - dwDelta;
            	}
#ifdef LOGSTATISTICS_ON
				else
				{
					hDebugFile = CreateFile("C:\\Timings.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
					SetFilePointer(hDebugFile, 0, NULL, FILE_END);
					WriteFile(hDebugFile, "No Frame grabbed\r\n", 16, &d, NULL);
					CloseHandle(hDebugFile);
				}
#endif
	        }
#ifdef LOGSTATISTICS_ON
			else
			{
				hDebugFile = CreateFile("C:\\Timings.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
				SetFilePointer(hDebugFile, 0, NULL, FILE_END);
				if (!pPacket)
					WriteFile(hDebugFile, "No Frame Ready (pPacket is NULL)\r\n", 35, &d, NULL);
				else
				{
					if (!pMC->m_pCaptureChain)
						WriteFile(hDebugFile, "No Frame Ready (CapChain is NULL)\r\n", 33, &d, NULL);
					else
						WriteFile(hDebugFile, "No Frame Ready (Timings are bad)\r\n", 32, &d, NULL);
				}
				CloseHandle(hDebugFile);
			}
#endif
		}
    }

	// Enter critical section: QoS thread also reads the statistics
	EnterCriticalSection(&pMC->m_crsVidQoS);

	// Reset number of captured frames
	pMC->m_Stats.dwCount = 0;

	// Leave critical section
	LeaveCriticalSection(&pMC->m_crsVidQoS);

    if (pPacket) {
    	pPacket->Recycle();
		pStream->Release(pPacket);
    	pPacket = NULL;
    }

    timeKillEvent(timerID);

    CloseHandle (hEvent);

	// Ensure no outstanding preview frames
	pMC->EndSend();

	// stop and reset capture device
	pMediaCtrl->Reset ();

	// save real time so we can update the timestamp when we restart
	pMC->m_SavedTickCount = timeGetTime();

MyEndThread:

	pMC->m_fSending = FALSE;
	DEBUGMSG (ZONE_DP, ("%s: Exiting.\r\n", _fx_));
	return hr;
}


DWORD RecvVideoStream::RenderingThread ( void)
{
	HRESULT hr = DPR_SUCCESS;
	MediaPacket * pPacket;
	DWORD dwWait;
	DWORD rtpTs, rtpSyncTs;
	HANDLE hEvent;
	DWORD_PTR dwPropVal;
	UINT uTimeout = 0;
	UINT uGoodPacketsQueued = 0;
	RecvVideoStream *pMC = this;
	RxStream			*pStream = pMC->m_RecvStream;
	MediaControl		*pMediaCtrl = pMC->m_OutMedia;

	FX_ENTRY ("DP::RenderingTh")

	if (pStream == NULL || pMediaCtrl == NULL)
	{
		return DPR_INVALID_PARAMETER;
	}

	// get event handle
	pMediaCtrl->GetProp (MC_PROP_EVENT_HANDLE, &dwPropVal);
	hEvent = (HANDLE) dwPropVal;
	if (hEvent == NULL)
	{
		DEBUGMSG (ZONE_DP, ("%s: invalid event\r\n", _fx_));
		return DPR_CANT_CREATE_EVENT;
	}


	// get thresholds
	pMediaCtrl->GetProp (MC_PROP_TIMEOUT, &dwPropVal);
	uTimeout = (DWORD)dwPropVal;

	pMC->m_RecvStream->FastForward(FALSE);	// flush receive queue

	// Notification is not used. if needed do it thru Channel
	//if (pMC->m_Connection)
	//	pMC->m_Connection->DoNotification(CONNECTION_OPEN_REND);

	pMC->m_fReceiving = TRUE;

	// Since we dont have reliable sender RTP timestamps yet,
	// follow the simplistic approach of playing
	// back frames as soon as they are available
	// with no attempt at reconstructing the timing

	// The RecvVidThread will signal an event when
	// it has received and decoded a frame. We wake up on
	// that event and call GetNextPlay().
	// This will keep the Recv queue moving with the
	// latest decoded packet ready to be given to the
	// app for rendering.
	
	while (!(pMC->m_ThreadFlags & DPTFLAG_STOP_PLAY))
    {
		dwWait = WaitForSingleObject (hEvent, uTimeout);
		ASSERT(dwWait != WAIT_FAILED);
		// see why I don't need to wait
		if (dwWait != WAIT_TIMEOUT) {
			if (pMC->m_DPFlags & DPFLAG_AV_SYNC) {
				// find out the timestamp of the frame to be played
				//
				NTP_TS ntpTs;
				rtpSyncTs = 0;
#ifdef OLDSTUFF
				if (m_Audio.pRecvStream && m_Audio.pRecvStream->GetCurrentPlayNTPTime(&ntpTs) == DPR_SUCCESS)
					pMC->m_Net->NTPtoRTP(ntpTs,&rtpSyncTs);
#endif
			}
			while (pStream->NextPlayablePacketTime(&rtpTs)) {
				// there is a playable packet in the queue
				if ((pMC->m_DPFlags & DPFLAG_AV_SYNC) && rtpSyncTs != 0) {
					LOG((LOGMSG_TESTSYNC,rtpTs, rtpSyncTs));
					if (TS_LATER(rtpTs,rtpSyncTs))
						break; // its time has not come
				}
				// get the packet.
				pPacket = pStream->GetNextPlay ();	
				if (pPacket  != NULL)
				{
					if (pPacket->GetState () != MP_STATE_DECODED) {
						pPacket->Recycle();
						pStream->Release(pPacket);
					} else
					{
						LOG((LOGMSG_VID_PLAY,pPacket->GetIndex(), GetTickCount()));
						EnterCriticalSection(&pMC->m_crs);
						pPacket->SetState(MP_STATE_PLAYING_BACK);
						pMC->m_PlaybackTimestamp = pPacket->GetTimestamp();
						if (pMC->m_pNextPacketToRender) {
							if (!pMC->m_pNextPacketToRender->m_fRendering) {
								// the app is not referencing the frame.
								pMC->m_pNextPacketToRender->Recycle();
								pStream->Release(pMC->m_pNextPacketToRender);
							} else {
								// it will get Recycled and Released later when the app
								// calls ReleaseFrame()
							}
							uGoodPacketsQueued--;
						}
						pMC->m_pNextPacketToRender = pPacket;
						LeaveCriticalSection(&pMC->m_crs);
						if(pMC->m_pfFrameReadyCallback)
						{
							(pMC->m_pfFrameReadyCallback)((DWORD_PTR)pMC->m_hRenderEvent);
						}
						else if (pMC->m_hRenderEvent)
							SetEvent(pMC->m_hRenderEvent);
						
						uGoodPacketsQueued++;

                        // Indicate that another frame was sent
                        UPDATE_COUNTER(g_pctrVideoReceive, 1);
					}
				}	// if (pPacket != NULL)
			}	// while
		}
	}



	pMC->m_fReceiving = FALSE;

	// Notification is not used. if needed do it thru Channel
	//if (pMC->m_Connection)
	//	pMC->m_Connection->DoNotification(CONNECTION_CLOSE_REND);

	// wait till all frames being rendered are returned
	// typically wont be more than one
	while (pMC->m_cRendering || pMC->m_pNextPacketToRender) {
		EnterCriticalSection(&pMC->m_crs);
		if (pMC->m_pNextPacketToRender && !pMC->m_pNextPacketToRender->m_fRendering) {
			// the app is not referencing the current frame.
			pMC->m_pNextPacketToRender->Recycle();
			pStream->Release(pMC->m_pNextPacketToRender);
			// no more frames till the thread is restarted
			pMC->m_pNextPacketToRender = NULL;
			LeaveCriticalSection(&pMC->m_crs);
		} else {
			// wait till the app  Releases it
			//
			LeaveCriticalSection(&pMC->m_crs);
			Sleep(100);
			DEBUGMSG(ZONE_DP, ("%s: Waiting for final ReleaseFrame()\n",_fx_));
		}
	}
	// reset the event we're waiting on.
	ResetEvent (hEvent);


	DEBUGMSG(ZONE_DP, ("%s: Exiting.\n", _fx_));
	return hr;
}

DWORD SendVideoStream::Send(void)
{
	BOOL fNewPreviewFrame = FALSE, bRet;
	MediaPacket *pVP;
	DWORD dwBeforeEncode;
	DWORD dwAfterEncode;
	UINT uBytesSent;
	MMRESULT mmr;
	DWORD dwEncodeFlags;
#ifdef LOGSTATISTICS_ON
	char szDebug[256];
	DWORD dwDebugSaveBits;
#endif

	while (pVP = m_SendStream->GetNext()) {
		EnterCriticalSection(&m_crs);
		if (m_pNextPacketToRender) {
			// free the last preview packet if its not being referenced
			// thru the IVideoRender API.
			// if it is being referenced ( fRendering is set), then it
			// will be freed in IVideoRender->ReleaseFrame()
			if (!m_pNextPacketToRender->m_fRendering) {
				m_pNextPacketToRender->Recycle();
				m_SendStream->Release(m_pNextPacketToRender);
			}
		}
		m_pNextPacketToRender = pVP;
		fNewPreviewFrame = TRUE;
		LeaveCriticalSection(&m_crs);
		
		if (!(m_ThreadFlags & DPTFLAG_PAUSE_SEND)) {
			dwBeforeEncode = timeGetTime();


			if (m_ThreadFlags & DPTFLAG_SEND_PREAMBLE)
				dwEncodeFlags = VCM_STREAMCONVERTF_FORCE_KEYFRAME;
			else
				dwEncodeFlags = 0;

			mmr = m_pVideoFilter->Convert((VideoPacket*)pVP, VP_ENCODE, dwEncodeFlags);
			if (mmr == MMSYSERR_NOERROR)
			{
				pVP->SetState(MP_STATE_ENCODED);
			}

			// Save the perfs in our stats structure for QoS
			dwAfterEncode = timeGetTime() - dwBeforeEncode;

			//HACKHACK bugbug, until we support fragmentation, set the marker bit always.
			pVP->SetProp (MP_PROP_PREAMBLE,TRUE);

			if (mmr == MMSYSERR_NOERROR)
			{
				SendPacket((VideoPacket*)pVP, &uBytesSent);
			}
			else
			{
				uBytesSent = 0;
			}

			// reset the packet and return it to the free queue
			pVP->m_fMark=0;
			pVP->SetState(MP_STATE_RESET);
			m_SendStream->Release(pVP);

			UPDATE_COUNTER(g_pctrVideoSendBytes, uBytesSent * 8);

			// Enter critical section: QoS thread also reads the statistics
			EnterCriticalSection(&m_crsVidQoS);

			// Add this compression time to total compression time
			// If we can access the CPU perf counters Ok, we won't use this value
			m_Stats.dwMsComp += dwAfterEncode;

#ifdef LOGSTATISTICS_ON
			dwDebugSaveBits = m_Stats.dwBits;
#endif
			// Add this new frame size to the cumulated size
			m_Stats.dwBits += uBytesSent * 8;

#ifdef LOGSTATISTICS_ON
			wsprintf(szDebug, " V: dwBits = %ld up from %ld (file: %s line: %ld)\r\n", m_Stats.dwBits, dwDebugSaveBits, __FILE__, __LINE__);
			OutputDebugString(szDebug);
#endif
			// Leave critical section
			LeaveCriticalSection(&m_crsVidQoS);

			//LOG((LOGMSG_SENT,GetTickCount()));
		}
		//m_SendStream->Release(pVP);
	}
	// Signal the IVideoRender event if we have a new frame.
	
	if (fNewPreviewFrame)
	{
		if(m_pfFrameReadyCallback)
		{
			(m_pfFrameReadyCallback)((DWORD_PTR)m_hRenderEvent);
		}
		else if(m_hRenderEvent)
			SetEvent(m_hRenderEvent);
	}	
	return DPR_SUCCESS;
}


/* Wait till all preview packets are released by the UI.
	Typically there wont be more than one
*/
void SendVideoStream::EndSend()
{
	while (m_cRendering || m_pNextPacketToRender) {
		EnterCriticalSection(&m_crs);
	
		// free the last preview packet if its not being referenced
		// thru the IVideoRender API.
		if (m_pNextPacketToRender && !m_pNextPacketToRender->m_fRendering) {
			m_pNextPacketToRender->Recycle();
			m_SendStream->Release(m_pNextPacketToRender);
			m_pNextPacketToRender = NULL;
			LeaveCriticalSection(&m_crs);
		} else {
			LeaveCriticalSection(&m_crs);
			Sleep(100);
			DEBUGMSG(ZONE_DP,("DP::EndSendVideo: Waiting for final Release Frame\n"));
		}
	}
}


HRESULT SendVideoStream::SendPacket(VideoPacket *pVP, UINT *puBytesSent)
{
	PS_QUEUE_ELEMENT psq;
	UINT uLength;
	DWORD dwPacketSize = 0;
	DWORD dwHdrSize = 0;
	DWORD dwHdrSizeAlloc = 0;
	DWORD dwPacketCount = 0;
	int nPacketsSent=0;
	UINT uPacketIndex, fMark=0;
	MMRESULT mmr;
	PBYTE pHdrInfo, netData, netDataPacket;

	*puBytesSent = 0;

	if (pVP->GetState() != MP_STATE_ENCODED)
	{
		DEBUGMSG (ZONE_VCM, ("SendVideoStream::SendPacket: Packet not compressed\r\n"));
		return E_FAIL;
	}


//	m_Net->QueryInterface(IID_IRTPSend, (void**)&pIRTPSend);
	ASSERT(m_pRTPSend);


	// these stay the same for video
	psq.pMP = pVP;
	psq.dwPacketType = PS_VIDEO;
//	psq.pRTPSend = pIRTPSend;
	psq.pRTPSend = m_pRTPSend;

	pVP->GetNetData((void**)(&netData), &uLength);
	ASSERT(netData);

	m_pVideoFilter->GetPayloadHeaderSize(&dwHdrSizeAlloc);

	do
	{

		if (dwHdrSizeAlloc)
		{
			pHdrInfo = (BYTE*)MemAlloc(dwHdrSizeAlloc);
		}
		if(pHdrInfo == NULL)
		{
			return E_FAIL;
		}

		mmr = m_pVideoFilter->FormatPayload(netData,
		                                    uLength,
		                                    &netDataPacket,
		                                    &dwPacketSize,
		                                    &dwPacketCount,
		                                    &fMark,
		                                    &pHdrInfo,
		                                    &dwHdrSize);

		if (mmr == MMSYSERR_NOERROR)
		{
			psq.data = netDataPacket;
			psq.dwSize = dwPacketSize;
			psq.fMark = fMark;
			psq.pHeaderInfo = pHdrInfo;
			psq.dwHdrSize = dwHdrSize;
			m_pDP->m_PacketSender.m_SendQueue.PushRear(psq);
			*puBytesSent = *puBytesSent + dwPacketSize + sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE;
		}
		else
		{
			MemFree((BYTE *)pHdrInfo);
		}

	} while (mmr == MMSYSERR_NOERROR);


	while (m_pDP->m_PacketSender.SendPacket())
	{
		;
	}



//	pIRTPSend->Release();

	return S_OK;

};



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\txstream.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    txstream.h

Abstract:
	The TxStream class maintains a queue of MediaPackets. The record thread gets a free buffer
	(GetFree), records into the buffer and puts it in the queue (PutNextWaveIn) from where it is
	removed (GetNext),	decoded and sent on the network.
	The queue is implemented as a circular array with m_SendPos marking the index
	of the next recorded buffer.

--*/
#ifndef _TXSTREAM_H_
#define _TXSTREAM_H_


#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define MAX_TXRING_SIZE 8
#define MAX_TXVRING_SIZE 4

class TxStream {
public:
	BOOL Initialize(UINT flags, UINT size, DataPump *pdp, MEDIAPACKETINIT *papi);
	BOOL PutNextRecorded(MediaPacket *);
	MediaPacket *GetFree();
	MediaPacket *GetNext();
	void Release(MediaPacket *);
	void Stop();
	UINT Reset();
	void GetRing ( MediaPacket ***pppAudPckt, ULONG *puSize ) { *pppAudPckt = &m_Ring[0]; *puSize = (ULONG) m_RingSize; }
	BOOL Destroy();
private:
	MediaPacket *m_Ring[MAX_TXRING_SIZE];
	UINT m_RingSize;
	UINT m_FreePos;
	UINT m_SendPos;
	UINT m_PreSendCount;
	HANDLE m_hQEvent;
	UINT m_TxFlags;
	CRITICAL_SECTION m_CritSect;
	DataPump *m_pDataPump;
	UINT ModRing(UINT i) {return (i & (m_RingSize-1));}
	BOOL m_fPreamblePacket;
	BOOL m_fTalkspurt;
};

#include <poppack.h> /* End byte packing */

#endif // _TXSTREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\utils.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    utils.h

Abstract:
	Assorted support and debugging routines used by the Network Audio Controller.

--*/
#ifndef _UTILS_H_
#define _UTILS_H_


#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


typedef struct tagDefWaveFormat
{
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
    WORD    wBitsPerSample;    /* Number of bits per sample of mono data */
    WORD    cbSize;            /* The count in bytes of the size of extra information (after cbSize) */
    WORD    awExtra[32];       /* room for ADPCM coeff...*/
}
    DEFWAVEFORMAT;


enum
{
    //  NAME_SamplesPerSec_BitsPerSample
	DWF_VOX_8K_16,
    DWF_PCM_8K_8,
    DWF_PCM_5510_8,
    DWF_ADPCM_8K_4,
    DWF_ADPCM_5510_4,
    DWF_GSM610_8K,
    DWF_ALAW_8K_8,
    DWF_PCM_11025_8,
    DWF_PCM_8K_16,
    DWF_NumOfWaveFormats
};

extern DEFWAVEFORMAT g_wfDefList[];




WAVEFORMATEX * GetDefWaveFormat ( int idx );
ULONG GetWaveFormatSize ( PVOID pwf );
BOOL IsSameWaveFormat ( PVOID pwf1, PVOID pwf2 );
void FillSilenceBuf ( WAVEFORMATEX *pwf, PBYTE pb, ULONG cb );
void MakeDTMFBeep(WAVEFORMATEX *pwf, PBYTE pb, ULONG cb);

char CompareMemory1 ( char * p1, char * p2, UINT u );
short CompareMemory2 ( short * p1, short * p2, UINT u );
long CompareMemory4 ( long * p1, long * p2, UINT u );


#ifndef SIZEOF_WAVEFORMATEX
#define SIZEOF_WAVEFORMATEX(pwfx)   ((WAVE_FORMAT_PCM==(pwfx)->wFormatTag)?sizeof(PCMWAVEFORMAT):(sizeof(WAVEFORMATEX)+(pwfx)->cbSize))
#endif



#ifdef _DEBUG
#	ifndef DEBUG
#		define DEBUG
#	endif // !DEBUG
#endif // _DEBUG


#ifdef DEBUG // { DEBUG

int WINAPI NacDbgPrintf ( LPTSTR lpszFormat, ... );
extern HDBGZONE  ghDbgZoneNac;

#define ZONE_INIT (GETMASK(ghDbgZoneNac) & 0x0001)
#define ZONE_CONN (GETMASK(ghDbgZoneNac) & 0x0002)
#define ZONE_COMMCHAN (GETMASK(ghDbgZoneNac) & 0x0004)
#define ZONE_CAPS (GETMASK(ghDbgZoneNac) & 0x0008)
#define ZONE_DP   (GETMASK(ghDbgZoneNac) & 0x0010)
#define ZONE_ACM  (GETMASK(ghDbgZoneNac) & 0x0020)
#define ZONE_VCM  (GETMASK(ghDbgZoneNac) & 0x0040)
#define ZONE_VERBOSE (GETMASK(ghDbgZoneNac) & 0x0080)
#define ZONE_INSTCODEC (GETMASK(ghDbgZoneNac) & 0x0100)
#define ZONE_PROFILE (GETMASK(ghDbgZoneNac) & 0x0200)
#define ZONE_QOS (GETMASK(ghDbgZoneNac) & 0x0400)
#define ZONE_IFRAME (GETMASK(ghDbgZoneNac) & 0x0800)

extern HDBGZONE  ghDbgZoneNMCap;
#define ZONE_NMCAP_CDTOR (GETMASK(ghDbgZoneNMCap) & 0x0001)
#define ZONE_NMCAP_REFCOUNT (GETMASK(ghDbgZoneNMCap) & 0x0002)
#define ZONE_NMCAP_STREAMING (GETMASK(ghDbgZoneNMCap) & 0x0004)

#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)	( (z) ? (NacDbgPrintf s ) : 0)
#endif // } DEBUGMSG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	static TCHAR _this_fx_ [] = (s);
#define _fx_		((LPTSTR) _this_fx_)
#endif // } FX_ENTRY
#define ERRORMESSAGE(m) (NacDbgPrintf m)
#else // }{ DEBUG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	
#endif // } FX_ENTRY
#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)
#define ERRORMESSAGE(m)
#endif  // } DEBUGMSG
#define _fx_		
#define ERRORMESSAGE(m)
#endif // } DEBUG

// Message ids.
// Ensure ids correspond to  message strings in LogStringTable[]

enum LogMsgs {
	LOGMSG_SENT		=	1,
	LOGMSG_NET_RECVD,
	LOGMSG_AUD_SEND,
	LOGMSG_SILENT,
	LOGMSG_RECORD,
	LOGMSG_AUD_RECV,
	LOGMSG_RX_RESET,
	LOGMSG_RX_RESET2,
	LOGMSG_ENCODED,
	LOGMSG_DECODED,
	LOGMSG_PLAY,
	LOGMSG_PLAY_SILENT,
	LOGMSG_OPEN_AUDIO,
	LOGMSG_PLAY_YIELD,
	LOGMSG_REC_YIELD,
	LOGMSG_AUD_RECYCLE,
	LOGMSG_AUTO_SILENCE,
	LOGMSG_PRESEND,
	LOGMSG_RX_SKIP,
	LOGMSG_TX_RESET,
	LOGMSG_JITTER,
	LOGMSG_PLAY_INTERPOLATED,
	LOGMSG_INTERPOLATED,
	LOGMSG_VID_SEND,
	LOGMSG_VID_RECV,
	LOGMSG_VID_RECYCLE,
	LOGMSG_VID_RECORD,
	LOGMSG_VID_PLAY,
	LOGMSG_VID_PLAY_SILENT,
	LOGMSG_VID_PLAY_INTERPOLATED,
	LOGMSG_VID_INTERPOLATED,
	LOGMSG_VID_ENCODED,
	LOGMSG_VID_DECODED,
	LOGMSG_OPEN_VIDEO,
	LOGMSG_GET_SEND_FRAME,
	LOGMSG_GET_RECV_FRAME,
	LOGMSG_RELEASE_SEND_FRAME,
	LOGMSG_RELEASE_RECV_FRAME,
	LOGMSG_TESTSYNC,
	LOGMSG_ONREAD1,
	LOGMSG_ONREAD2,
	LOGMSG_ONREADDONE1,
	LOGMSG_ONREADDONE2,
	LOGMSG_RECVFROM1,
	LOGMSG_RECVFROM2,
	LOGMSG_READWOULDBLOCK,
	LOGMSG_VIDSEND_VID_QUEUING,
	LOGMSG_VIDSEND_AUD_QUEUING,
	LOGMSG_VIDSEND_VID_SEND,
	LOGMSG_VIDSEND_AUD_SEND,
	LOGMSG_VIDSEND_VID_NOT_SEND,
	LOGMSG_VIDSEND_AUD_NOT_SEND,
	LOGMSG_VIDSEND_IO_PENDING,
	LOGMSG_VIDSEND_AUDIO_QUEUE_EMPTY,
	LOGMSG_VIDSEND_VIDEO_QUEUE_EMPTY,
	LOGMSG_AUDSEND_VID_QUEUING,
	LOGMSG_AUDSEND_AUD_QUEUING,
	LOGMSG_AUDSEND_VID_SEND,
	LOGMSG_AUDSEND_AUD_SEND,
	LOGMSG_AUDSEND_VID_NOT_SEND,
	LOGMSG_AUDSEND_AUD_NOT_SEND,
	LOGMSG_AUDSEND_IO_PENDING,
	LOGMSG_AUDSEND_AUDIO_QUEUE_EMPTY,
	LOGMSG_AUDSEND_VIDEO_QUEUE_EMPTY,
	LOGMSG_SEND_BLOCKED,

	LOGMSG_DSPLAY,
	LOGMSG_DSEMPTY,
	LOGMSG_DSTIMEOUT,
	LOGMSG_DSMOVPOS,
	LOGMSG_DSCREATE,
	LOGMSG_DSRELEASE,
	LOGMSG_DSDROPOOS, // out of sequence
	LOGMSG_DSENTRY,
	LOGMSG_DSTIME,
	LOGMSG_DSSTATUS,
	LOGMSG_DSDROPOVERFLOW, // overflow
	LOGMSG_DSOFCONDITION,

	LOGMSG_TIME_SEND_AUDIO_CONFIGURE,
	LOGMSG_TIME_SEND_AUDIO_UNCONFIGURE,
	LOGMSG_TIME_SEND_VIDEO_CONFIGURE,
	LOGMSG_TIME_SEND_VIDEO_UNCONFIGURE,
	LOGMSG_TIME_RECV_AUDIO_CONFIGURE,
	LOGMSG_TIME_RECV_AUDIO_UNCONFIGURE,
	LOGMSG_TIME_RECV_VIDEO_CONFIGURE,
	LOGMSG_TIME_RECV_VIDEO_UNCONFIGURE,

	LOGMSG_DSC_TIMESTAMP,
	LOGMSG_DSC_GETCURRENTPOS,
	LOGMSG_DSC_LOG_TIMEOUT,
	LOGMSG_DSC_LAGGING,
	LOGMSG_DSC_SENDING,
	LOGMSG_DSC_STATS,
	LOGMSG_DSC_EARLY
};

#ifdef DEBUG
#define LOGGING	1
#else
#ifdef TEST
#define LOGGING 1
#endif
#endif

#ifdef LOGGING
#define MAX_STRING_SIZE		64

void Log (UINT n, UINT arg1=0, UINT arg2=0, UINT arg3=0);
LogInit();
LogClose();
#define LOG(x) Log x

#else

#define LOG(x)
#define LogInit()
#define LogClose()
#endif	// LOGGING


HRESULT InitAudioFlowspec(FLOWSPEC *pFlowSpec, WAVEFORMATEX *pwf, DWORD dwPacketSize);
HRESULT InitVideoFlowspec(FLOWSPEC *pFlowspec, DWORD dwMaxBitrate, DWORD dwMaxFrag, DWORD dwAvgPacketSize);


#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#include <poppack.h> /* End byte packing */

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\utils.cpp ===
#include "precomp.h"


// SHORT g_BeepSamples[] = {195,-4352,-14484,-8778,397,-1801,2376,12278,6830,-2053};
SHORT g_BeepSamples[] = {195,-4352,-12484,-8778,397,-1801,2376,10278,6830,-2053};


#define BL  1024


#if 0
DEFWAVEFORMAT g_wfDefList[] =
{
    {WAVE_FORMAT_PCM,   1, 22050, 22050, 1, 8, 0},
    {WAVE_FORMAT_PCM,   1, 11025, 11025, 1, 8, 0},
    {WAVE_FORMAT_PCM,   1, 8000,  8000,  1, 8, 0},
    {WAVE_FORMAT_PCM,   1, 5510,  5510,  1, 8, 0},
    {WAVE_FORMAT_ADPCM, 1, 11025, 11025/2, BL, 4, 32, (BL-7)*2+2, 7, 0x0100,0x0000,0x0200,0xFF00,0x0000,0x0000,0x00C0,0x0040,0x00F0,0x0000,0x01CC,0xFF30,0x0188,0xFF18},
    {WAVE_FORMAT_ADPCM, 1, 8000,  8000/2,  BL, 4, 32, (BL-7)*2+2, 7, 0x0100,0x0000,0x0200,0xFF00,0x0000,0x0000,0x00C0,0x0040,0x00F0,0x0000,0x01CC,0xFF30,0x0188,0xFF18},
    {WAVE_FORMAT_ADPCM, 1, 5510,  5510/2,  BL, 4, 32, (BL-7)*2+2, 7, 0x0100,0x0000,0x0200,0xFF00,0x0000,0x0000,0x00C0,0x0040,0x00F0,0x0000,0x01CC,0xFF30,0x0188,0xFF18},
    {WAVE_FORMAT_PCM,   1, 11025, 11025, 1, 8, 0},
};
#endif


DEFWAVEFORMAT g_wfDefList[] =
{
	{WAVE_FORMAT_VOXWARE,1,8000, 16000,  2,   16, 0},
    {WAVE_FORMAT_PCM,   1, 8000,  8000,  1,   8,  0},
    {WAVE_FORMAT_PCM,   1, 5510,  5510,  1,   8,  0},
    {WAVE_FORMAT_ADPCM, 1, 8000,  4096,  256, 4,  32, 500, 7, 0x0100,0x0000,0x0200,0xFF00,0x0000,0x0000,0x00C0,0x0040,0x00F0,0x0000,0x01CC,0xFF30,0x0188,0xFF18},
    {WAVE_FORMAT_ADPCM, 1, 5510,  2755,  256, 4,  32, 500, 7, 0x0100,0x0000,0x0200,0xFF00,0x0000,0x0000,0x00C0,0x0040,0x00F0,0x0000,0x01CC,0xFF30,0x0188,0xFF18},
    {WAVE_FORMAT_GSM610,1, 8000,  1625,  65,  0,  2, 320, 240, 0},
    {WAVE_FORMAT_ALAW,  1, 8000,  8000,  1,   8,  0},
    {WAVE_FORMAT_PCM,   1, 11025, 11025, 1,   8,  0},
    {WAVE_FORMAT_PCM,   1, 8000,  16000, 2,   16, 0},
};


WAVEFORMATEX * GetDefWaveFormat ( int idx )
{
    return ((idx < DWF_NumOfWaveFormats) ?
            (WAVEFORMATEX *) &g_wfDefList[idx] :
            (WAVEFORMATEX *) NULL);
}


ULONG GetWaveFormatSize ( PVOID pwf )
{
    return (((WAVEFORMAT *) pwf)->wFormatTag == WAVE_FORMAT_PCM  
        ? sizeof (PCMWAVEFORMAT)
        : sizeof (PCMWAVEFORMAT) + sizeof (WORD) + ((WAVEFORMATEX *) pwf)->cbSize);
}


BOOL IsSameWaveFormat ( PVOID pwf1, PVOID pwf2 )
{
    UINT u1 = GetWaveFormatSize (pwf1);
    UINT u2 = GetWaveFormatSize (pwf2);
    BOOL fSame = FALSE;

    if (u1 == u2)
    {
        fSame = ! CompareMemory1 ((char *)pwf1, (char *)pwf2, u1);
    }

    return fSame;
}


void FillSilenceBuf ( WAVEFORMATEX *pwf, PBYTE pb, ULONG cb )
{
	if (pwf && pb)
	{
		if ((pwf->wFormatTag == WAVE_FORMAT_PCM) && (pwf->wBitsPerSample == 8))
		{
			FillMemory (pb, cb, (BYTE) 0x80);
		}
		else
		{
			ZeroMemory (pb, cb);
		}
	}
}


void MakeDTMFBeep(WAVEFORMATEX *pwf, PBYTE pb, ULONG cb)
{
	SHORT *pShort = (SHORT*)pb;
	int nBeepMod = sizeof (g_BeepSamples) / sizeof(g_BeepSamples[0]);
	int nIndex, nLoops = 0;
	BYTE bSample;

	if (pwf->wBitsPerSample == 16)
	{
		nLoops = cb / 2;
		for (nIndex=0; nIndex < nLoops; nIndex++)
		{
			pShort[nIndex] = g_BeepSamples[(nIndex % nBeepMod)];
		}
	}
	else
	{
		nLoops = cb;
		for (nIndex=0; nIndex < nLoops; nIndex++)
		{
			bSample = (g_BeepSamples[(nIndex % nBeepMod)] >> 8) & 0x00ff;
			bSample = bSample ^ 0x80;
			pb[nIndex] = bSample;
		}
	}
}



char CompareMemory1 ( char * p1, char * p2, UINT u )
{
    char i;

    while (u--)
    {
        i = *p1++ - *p2++;
        if (i) return i;
    }

    return 0;
}


short CompareMemory2 ( short * p1, short * p2, UINT u )
{
    short i;

    while (u--)
    {
        i = *p1++ - *p2++;
        if (i) return i;
    }

    return 0;
}


long CompareMemory4 ( long * p1, long * p2, UINT u )
{
    long i;

    while (u--)
    {
        i = *p1++ - *p2++;
        if (i) return i;
    }

    return 0;
}


const DWORD WIN98GOLDBUILD = 1998;
const DWORD WIN98GOLDMAJOR = 4;
const DWORD WIN98GOLDMINOR = 10;


inline bool ISWIN98GOLD()
{
	OSVERSIONINFO osVersion;
	BOOL bRet;

	osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	bRet = GetVersionEx(&osVersion);


	if ( bRet && 
	        ( (osVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
	          (osVersion.dwMajorVersion == WIN98GOLDMAJOR) &&
	          (osVersion.dwMinorVersion == WIN98GOLDMINOR) // && 
//	          (osVersion.dwBuildNumber == WIN98GOLDBUILD)
            )
		)
	{
		return true;
	}

	return false;

}

// dwPacketSize is the size of the audio payload (excludes RTP header)
// pwf represents the compressed audio format
HRESULT InitAudioFlowspec(FLOWSPEC *pFlowspec, WAVEFORMATEX *pwf, DWORD dwPacketSize)
{

	DWORD dwPacketOverhead = 0;
	OSVERSIONINFO osVersion;
	DWORD dwTotalSize;
	BOOL bRet;


	// on Windows 2000 and Win98 OSR, the FLOWSPEC needs to be set without regard
	// to the UDP/IP headers.

	// On Win98 Gold, FLOWSPEC needs to account for IP/UDP headers

	// no way to detect this without explicitly checking the version number

	if (ISWIN98GOLD())
	{
		dwPacketOverhead = IP_HEADER_SIZE + UDP_HEADER_SIZE;
	}

	dwTotalSize = dwPacketOverhead + dwPacketSize + sizeof(RTP_HDR);

	// rather than specify the exact minimum bandwidth we need for audio,
	// make it slightly larger (10%) to account for bursts and beginning
	// of talk spurts

	// peakbandwidth is set another increment above TR, and bucket size
	// is adjusted high as well


	pFlowspec->TokenRate = (dwTotalSize * pwf->nAvgBytesPerSec) / dwPacketSize;
	pFlowspec->TokenRate = (11 * pFlowspec->TokenRate) / 10;

	// peak bandwidth is an ADDITIONAL 10% greater than TokenRate, so it's
	// really a 21% increase over the theoretical minimum
	pFlowspec->PeakBandwidth = (11 * pFlowspec->TokenRate) / 10;
	pFlowspec->TokenBucketSize = dwTotalSize * 4;
	pFlowspec->MinimumPolicedSize = dwTotalSize;
	pFlowspec->MaxSduSize = pFlowspec->MinimumPolicedSize;
	pFlowspec->Latency = QOS_NOT_SPECIFIED;
	pFlowspec->DelayVariation = QOS_NOT_SPECIFIED;
	pFlowspec->ServiceType = SERVICETYPE_GUARANTEED;

	return S_OK;

}



HRESULT InitVideoFlowspec(FLOWSPEC *pFlowspec, DWORD dwMaxBitRate, DWORD dwMaxFrag, DWORD dwAvgPacketSize)
{
	DWORD dwPacketOverhead = 0;


	// I-Frames will be fragmented into 3 or 4 packets
	// and will be about 1000 bytes each

	// P-Frames average about 250 - 500 bytes each

	// we'll assume the reservation is a NetMeeting to NetMeeting call
	// so there will be few I-Frames sent



	if (ISWIN98GOLD())
	{
		dwPacketOverhead = IP_HEADER_SIZE + UDP_HEADER_SIZE;
	}

	// for 28.8 modems, 11kbits/sec have already been allocated for audio
	// so only allocate 17kbits/sec for video.  This means that some packets
	// will be "non-conforming" and may receive less than a best-effort services.
	// but this is believed to be better than having no RSVP/QOS at all

	// if this becomes an issue, then it may be better to have no RSVP/QOS at all

	// maxBitRate will be equal to 14400 (14.4 modem), 28000 (28.8 modem), 85000 (ISDN/DSL), or 621700 (LAN)
	// (* .70, so really it can be: 10080, 20160, 59500, 435190)


	if (dwMaxBitRate <= BW_144KBS_BITS)
	{
		dwMaxBitRate = 4000;  // is it worth it to attempt QOS at 14.4 ?
	}
	else if (dwMaxBitRate <= BW_288KBS_BITS)
	{
		dwMaxBitRate = 17000;
	}



	pFlowspec->TokenRate = dwMaxBitRate / 8;
	pFlowspec->MaxSduSize = dwMaxFrag + dwPacketOverhead + sizeof(RTP_HDR);
	pFlowspec->MinimumPolicedSize = dwAvgPacketSize + dwPacketOverhead;
	pFlowspec->PeakBandwidth = (DWORD)(pFlowspec->TokenRate * 1.2);
	pFlowspec->TokenBucketSize = dwMaxFrag * 3;

	pFlowspec->Latency = QOS_NOT_SPECIFIED;
	pFlowspec->DelayVariation = QOS_NOT_SPECIFIED;
	pFlowspec->ServiceType = SERVICETYPE_CONTROLLEDLOAD;

	return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\vcmcaps.cpp ===
/*
 *  	File: vcmcaps.cpp
 *
 *		Base VCM implementation of Microsoft Network Audio capability object.
 *
 *		Revision History:
 *
 *		12/20/95	mikev	created
 *		06/11/96	mikev	separated protocol implementation specifics into
 *							msiacaps.cpp (the original proprietary version) and
 *							vcmh323.cpp (H.323/H.245 implementation)
 *		07/28/96	philf	added support for video
 */


#include "precomp.h"


//UINT uVidNumLocalFormats =0;		// # of active entries in pLocalFormats
//UINT uVidLocalFormatCapacity=0;	// size of pLocalFormats (in multiples of VIDCAP_DETAILS)
//UINT uVidStaticRef = 0;			// global ref count
//UINT uVidNumCustomDecodeFormats=0;	// # of custom entries for decode

//VIDEO_FORMAT_ID VIDsByRank[MAX_CAPS_PRESORT];		// the best 16 ranked formats, sorted (descending, best first)
//AUDIO_FORMAT_ID IDsByBandwidth[MAX_CAPS_PRESORT];	// ascending, least BW reqirement first
//AUDIO_FORMAT_ID IDsByLossTolerance[MAX_CAPS_PRESORT];	// descending, most tolerant first
//AUDIO_FORMAT_ID IDsByCPULoad[MAX_CAPS_PRESORT];		// ascending, lightest load first

//#pragma data_seg()


PVCMFORMATDETAILS pvfd_g;
static UINT uMaxFormatSize =0;
	
PVIDEOFORMATEX lpScratchFormat = NULL;

BOOL __stdcall VCMFormatEnumCallback(HVCMDRIVERID hvdid, PVCMDRIVERDETAILS pvdd, PVCMFORMATDETAILS pvfd, DWORD_PTR dwInstance);


CVcmCapability::CVcmCapability()
:m_dwDeviceID(VIDEO_MAPPER)
{
}

CVcmCapability::~CVcmCapability()
{
}

//	FormatEnum() is the root level enumeration of VCM formats. Each permutation of
//  format tag, bits per sample, and sample rate is considered a unique format
//  and will have a unique registry entry if it is "enabled" for internet video
//	vcmFormatEnum() calls VCMFormatEnumCallback().
BOOL CVcmCapability::FormatEnum(CVcmCapability *pCapObject, DWORD dwFlags)
{
	MMRESULT mResult;
	VCMDRIVERDETAILS vdd;
	VCMFORMATDETAILS vfd;

	if(!GetVideoFormatBuffer())
		return FALSE;
	
	vdd.dwSize = sizeof(VCMDRIVERDETAILS);
	vfd.cbStruct = sizeof(VCMFORMATDETAILS);
	vfd.pvfx = lpScratchFormat;
	vfd.cbvfx = uMaxFormatSize;
	vfd.szFormat[0]=(WCHAR)0;

	mResult = vcmFormatEnum(m_dwDeviceID, VCMFormatEnumCallback, &vdd, &vfd, (DWORD_PTR)pCapObject,
							dwFlags | VCM_FORMATENUMF_BOTH);

	if(lpScratchFormat) {
	   MemFree(lpScratchFormat);
	   lpScratchFormat=NULL;
	}

	if(mResult != MMSYSERR_NOERROR)
   	{
		return FALSE;
   	}
	return TRUE;
}

// default implementation of FormatEnumHandler does nothing
BOOL  CVcmCapability::FormatEnumHandler(HVCMDRIVERID hvdid,
	    PVCMFORMATDETAILS pvfd, VCMDRIVERDETAILS *pvdd, DWORD_PTR dwInstance)
{
	return FALSE;
}

BOOL __stdcall VCMFormatEnumCallback(HVCMDRIVERID hvdid,
    PVCMDRIVERDETAILS pvdd, PVCMFORMATDETAILS pvfd, DWORD_PTR dwInstance)
{
	CVcmCapability *pCapability = (CVcmCapability *)dwInstance;

	return pCapability->FormatEnumHandler(hvdid, pvfd, pvdd, dwInstance);
}


BOOL GetVideoFormatBuffer()
{
	// Get size of largest VIDEOFORMATEX structure in the system
	MMRESULT mResult;

	if((mResult = vcmMetrics(NULL, VCM_METRIC_MAX_SIZE_FORMAT, (LPVOID) &uMaxFormatSize)) != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE(("GetFormatBuffer: vcmMetrics failed:0x%08lX\r\n",mResult));
		return FALSE;
	}


	if(!(lpScratchFormat = (PVIDEOFORMATEX) MemAlloc(uMaxFormatSize)))
	{
		ERRORMESSAGE(("GetFormatBuffer: allocation failed\r\n"));
		return FALSE;
	}

	ZeroMemory(lpScratchFormat, uMaxFormatSize);

	return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\vcmcaps.h ===
/*
 *  	File: vcmcaps.h
 *
 *
 *		VCM implementation of Microsoft Network Video capability object.
 *
 *		Additional methods supported by this implementation:
 *	
 *		VIDEO_FORMAT_ID AddEncodeFormat(VIDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize);
 *		VIDEO_FORMAT_ID AddDecodeFormat(VIDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize);
 *
 *		Revision History:
 *
 *		12/27/95	mikev	created
 *		07/28/96	philf	added support for video
 */


#ifndef _VCMCAPS_H
#define _VCMCAPS_H
#include <pshpack8.h>

// VCM enumeration support functions
BOOL GetVideoFormatBuffer(VOID);
BOOL __stdcall FormatTagEnumCallback(HVCMDRIVERID hadid, PVCMFORMATTAGDETAILS paftd,
    DWORD dwInstance,  DWORD fdwSupport);
BOOL __stdcall FormatEnumCallback(HVCMDRIVERID hadid,
    PVCMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport);
BOOL __stdcall DriverEnumCallback(HVCMDRIVERID hadid,
    DWORD_PTR dwInstance, DWORD fdwSupport);

#ifdef __cplusplus

class CVcmCapability
{
protected:
	HACMDRIVER hAcmDriver;	
	DWORD m_dwDeviceID;
public:
	CVcmCapability();
	~CVcmCapability();
	BOOL FormatEnum(CVcmCapability *pCapObject, DWORD dwFlags);
	BOOL DriverEnum(CVcmCapability *pCapObject);
	HACMDRIVER GetDriverHandle() {return hAcmDriver;};
	virtual BOOL FormatEnumHandler(HVCMDRIVERID hadid,
	    PVCMFORMATDETAILS pafd, VCMDRIVERDETAILS *padd, DWORD_PTR dwInstance);
};

#define SQCIF 	0x1
#define QCIF 	0x2
#define CIF 	0x4
#define UNKNOWN 0x8
#define get_format(w,h) ((w == 128 && h == 96 ) ? SQCIF : ((w == 176 && h == 144 )? QCIF: ((w == 352 && h == 288 ) ? CIF :UNKNOWN)))



#define NONSTD_VID_TERMCAP {H245_CAPDIR_LCLRX, H245_DATA_VIDEO,H245_CLIENT_VID_NONSTD, 0, {0}}
#define STD_VID_TERMCAP(tc) {H245_CAPDIR_LCLRX, H245_DATA_VIDEO,(tc), 0, {0}}

//Advertise the maximum possible rate, and assume we can do below this.
//H.261 defines a max MPI of 4!

#define STD_VID_PARAMS {0,0,1}

typedef struct VideoParameters
{
	BYTE	RTPPayload;		// RTP payload type
	DWORD	dwFormatDescriptor;	// the unique ID of this format
	UINT	uSamplesPerSec;	// the number of frames per second
	UINT	uBitsPerSample;	// the number of bits per pixel
	VIDEO_SIZES enumVideoSize;	// enum. Use Small, Medium, Large
	UINT	biWidth;		// the frame width in pixels
	UINT	biHeight;		// the frame height in pixels
}VIDEO_PARAMS;


typedef struct VidCapDetails
{
	DWORD	dwFormatTag;
	CC_TERMCAP H245Cap;
	NSC_CHANNEL_VIDEO_PARAMETERS nonstd_params;
	VIDEO_PARAMS video_params;	// this has a dependency on protocol.h
	DWORD dwPublicRefIndex;	// index of the local capability entry that will be
							// advertized.  Zero if this entry is the one to advertize
	
	BOOL bSendEnabled;
	BOOL bRecvEnabled;	
	DWORD dwDefaultSamples;		// default number of samples per packet
	UINT uMaxBitrate;			// max bandwidth used by this format (calculated: bits per sample * sample rate)
	UINT uAvgBitrate;			// average bandwidth used by this format (we get this from the codec)
	WORD wCPUUtilizationEncode;
	WORD wCPUUtilizationDecode;	
	WORD wApplicationPrefOrder;	// overriding preference - lower number means more preferred
	UINT uLocalDetailsSize;		// size in bytes of what lpLocalFormatDetails points to
	LPVOID lpLocalFormatDetails;
	UINT uRemoteDetailsSize;	// size in bytes of what lpRemoteFormatDetails points to
	LPVOID lpRemoteFormatDetails;
	char szFormat[VCMFORMATDETAILS_FORMAT_CHARS];
} VIDCAP_DETAILS, *PVIDCAP_DETAILS;

/*
 *	VCM interface
 *	Definitions for interfacing with VCM
 */

typedef struct
{
	PVIDCAP_DETAILS pVidcapDetails;	// a pointer to an VIDCAP_DETAILS structure
	DWORD dwFlags;					// misc flags...
	PVIDEOFORMATEX pvfx;			// pointer to video format structure. used when adding formats
	HRESULT hr;
} VCM_APP_PARAM, *PVCM_APP_PARAM;


//
//  implementation class of the Video Interface
//

class CImpAppVidCap : public IAppVidCap
{
	public:
	STDMETHOD_(ULONG,  AddRef());
	STDMETHOD_(ULONG, Release());
	
	STDMETHOD(GetNumFormats(UINT *puNumFmtOut));
    STDMETHOD(ApplyAppFormatPrefs(PBASIC_VIDCAP_INFO pFormatPrefsBuf,
		UINT uNumFormatPrefs));
    STDMETHOD(EnumFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut));
	STDMETHOD(EnumCommonFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut, BOOL bTXCaps));
	STDMETHOD( GetBasicVidcapInfo (VIDEO_FORMAT_ID Id,
		PBASIC_VIDCAP_INFO pFormatPrefsBuf));
	STDMETHOD( AddVCMFormat (PVIDEOFORMATEX lpvfx, PVIDCAP_INFO pVidCapInfo));
	STDMETHOD( RemoveVCMFormat (PVIDEOFORMATEX lpvfx));
	STDMETHOD_ (PVIDEOFORMATEX, GetVidcapDetails(THIS_ VIDEO_FORMAT_ID Id));
	STDMETHOD( GetPreferredFormatId (VIDEO_FORMAT_ID *pId));
	STDMETHOD (SetDeviceID(DWORD dwDeviceID));

 	void Init(class CMsivCapability * pCapObject) {m_pCapObject = pCapObject;};

protected:
	class CMsivCapability * m_pCapObject;
};


class CMsivCapability : public IH323MediaCap, public CVcmCapability
{

protected:
	UINT uRef;
	BOOL bPublicizeTXCaps;
	BOOL bPublicizeTSTradeoff;
	//LOOKLOOK this supports a hack to disable CPU intensive codecs if not running on a pentium
	WORD wMaxCPU;	
	static MEDIA_FORMAT_ID IDsByRank[MAX_CAPS_PRESORT];
	
	static UINT uNumLocalFormats;			// # of active entries in pLocalFormats
	static UINT uStaticRef;					// global ref count
	static UINT uCapIDBase;					// rebase capability ID to index into IDsByRank
	static VIDCAP_DETAILS *pLocalFormats;	// cached list of formats that we can receive
	static UINT uLocalFormatCapacity;		// size of pLocalFormats (in multiples of VIDCAP_DETAILS)

	PVIDCAP_DETAILS pRemoteDecodeFormats;	// cached list of formats that the
											// other end can receive/decode
	UINT uNumRemoteDecodeFormats;	// # of entries for remote decode capabilities
	UINT uRemoteDecodeFormatCapacity;		// size of pRemoteDecodeFormats (in multiples of VIDCAP_DETAILS)

	PVCM_APP_PARAM	m_pAppParam;			// a pointer to a PVCM_APP_PARAM structure. Used to carry
											// a information through the enumeration process
											// but can be used for other purposes		
//
// embedded interface classes
//
	CImpAppVidCap m_IAppVidCap;
protected:

// Internal functions
	UINT IDToIndex(MEDIA_FORMAT_ID id) {return id - uCapIDBase;};
	MEDIA_FORMAT_ID IndexToId(UINT uIndex){return uIndex + uCapIDBase;};

	LPTSTR AllocRegistryKeyName(LPTSTR lpDriverName,
		UINT uSampleRate, UINT uBitsPerSample, UINT uBytesPerSec,UINT uWidth,UINT uHeight);
	VOID FreeRegistryKeyName(LPTSTR lpszKeyName);
	

	VOID CalculateFormatProperties(VIDCAP_DETAILS *pFmtBuf, PVIDEOFORMATEX lpvfx);
	BOOL IsFormatSpecified(PVIDEOFORMATEX lpFormat, PVCMFORMATDETAILS pvfd,
		VCMDRIVERDETAILS *pvdd, VIDCAP_DETAILS *pVidcapDetails);
	virtual VOID SortEncodeCaps(SortMode sortmode);
	virtual VIDEO_FORMAT_ID AddFormat(VIDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize);
	BOOL UpdateFormatInRegistry(VIDCAP_DETAILS *pFmt);
	BOOL BuildFormatName(	PVIDCAP_DETAILS pVidcapDetails,
							WCHAR *pszDriverName,
							WCHAR *pszFormatName);
	HRESULT GetFormatName(PVIDCAP_DETAILS pVidcapDetails, PVIDEOFORMATEX pvfx);

public:
	STDMETHOD_(BOOL, Init());
	STDMETHOD_(BOOL, ReInit());
	CMsivCapability();
	~CMsivCapability();
	
// handler for codec enumeration callback	
	virtual BOOL FormatEnumHandler(HVCMDRIVERID hvdid,
	        PVCMFORMATDETAILS pvfd, VCMDRIVERDETAILS *pvdd, DWORD_PTR dwInstance);

//
// Common interface methods
//
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHOD_(ULONG,  AddRef());
	STDMETHOD_(ULONG, Release());

//		
// IVCapApi methods		
//
	STDMETHOD(GetNumFormats(UINT *puNumFmtOut));
	STDMETHOD(ApplyAppFormatPrefs(PBASIC_VIDCAP_INFO pFormatPrefsBuf,
		UINT uNumFormatPrefs));
    STDMETHOD(EnumFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut));
	STDMETHOD(EnumCommonFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut, BOOL bTXCaps));		
	STDMETHOD( GetBasicVidcapInfo (VIDEO_FORMAT_ID Id,
		PBASIC_VIDCAP_INFO pFormatPrefsBuf));
	STDMETHOD( AddVCMFormat (PVIDEOFORMATEX lpvfx, PVIDCAP_INFO pVidCapInfo));
	STDMETHOD( RemoveVCMFormat (PVIDEOFORMATEX lpvfx));
	STDMETHOD( GetPreferredFormatId (VIDEO_FORMAT_ID *pId));
	STDMETHOD (SetDeviceID(DWORD dwDeviceID)) {m_dwDeviceID = dwDeviceID; return hrSuccess;};			

// support of IVCapApi methods	
	virtual HRESULT CopyVidcapInfo (PVIDCAP_DETAILS pDetails, PVIDCAP_INFO pInfo,
									BOOL bDirection);
//
//	IH323MediaCap methods
//
	STDMETHOD_(VOID, FlushRemoteCaps());
	STDMETHOD( AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList));
	STDMETHOD_(VIDEO_FORMAT_ID, AddRemoteDecodeFormat(PCC_TERMCAP pCCThisCap));

	// Get local and remote channel parameters for a specific encode capability
	STDMETHOD( GetEncodeParams(LPVOID pBufOut, UINT uBufSize, LPVOID pLocalParams,
			UINT uLocalSize,MEDIA_FORMAT_ID idRemote,MEDIA_FORMAT_ID idLocal));
	STDMETHOD( GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, VIDEO_FORMAT_ID id));
   	STDMETHOD( GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,
		VIDEO_FORMAT_ID * pFormatID, LPVOID lpvBuf, UINT uBufSize));
		
	STDMETHOD_(UINT, GetNumCaps()){return uNumLocalFormats;};
	STDMETHOD_(UINT, GetNumCaps(BOOL bRXCaps));
	STDMETHOD_(BOOL, IsHostForCapID(MEDIA_FORMAT_ID CapID));
	STDMETHOD_(BOOL, IsCapabilityRecognized(PCC_TERMCAP pCCThisCap));
	STDMETHOD(SetCapIDBase(UINT uNewBase));
	STDMETHOD_(UINT, GetCapIDBase()) {return uCapIDBase;};
	STDMETHOD (IsFormatEnabled (MEDIA_FORMAT_ID FormatID, PBOOL bRecv, PBOOL bSend));
	STDMETHOD_(BOOL, IsFormatPublic(MEDIA_FORMAT_ID FormatID));
	STDMETHOD_(MEDIA_FORMAT_ID, GetPublicID(MEDIA_FORMAT_ID FormatID));

	STDMETHOD_ (VOID, EnableTXCaps(BOOL bSetting)) {bPublicizeTXCaps = bSetting;};
	STDMETHOD_ (VOID, EnableRemoteTSTradeoff(BOOL bSetting)) {bPublicizeTSTradeoff= bSetting;};
	STDMETHOD (SetAudioPacketDuration( UINT durationInMs));
	STDMETHOD (ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote));
	STDMETHOD_(UINT, GetLocalSendParamSize(MEDIA_FORMAT_ID dwID));
	STDMETHOD_(UINT, GetLocalRecvParamSize(PCC_TERMCAP pCapability));
	STDMETHOD( CreateCapList(LPVOID *ppCapBuf));
	STDMETHOD( DeleteCapList(LPVOID pCapBuf));
	STDMETHOD( ResolveEncodeFormat(VIDEO_FORMAT_ID *pIDVidEncodeOut,VIDEO_FORMAT_ID * pIDVidRemoteDecode));

// methods provided to the Data pump, common to H.323 and MSICCP
	STDMETHOD(GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize));
	STDMETHOD(GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize));
};

#endif	// __cplusplus
#include <poppack.h>

#endif	//#ifndef _VCMCAPS_H




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\vcmfilter.cpp ===
#include "precomp.h"
#include "VcmFilter.h"





VcmFilter::VcmFilter() :
m_hStream(NULL),
m_dwBrightness(VCM_RESET_BRIGHTNESS),
m_dwContrast(VCM_RESET_CONTRAST),
m_dwImageQuality(VCM_RESET_IMAGE_QUALITY),
m_dwSaturation(VCM_RESET_SATURATION),
m_bOpen(FALSE),
m_bSending(FALSE)
{;}


VcmFilter::~VcmFilter()
{
	Close();
}



// we should figure out based on the Src and Dst parameters
// whether or not this is a send or receive filter
MMRESULT VcmFilter::Open(VIDEOFORMATEX *pVfSrc, VIDEOFORMATEX *pVfDst, DWORD dwMaxFragSize)
{
	MMRESULT mmr;

	// just in case, we are open in some other context:
	Close();


	// are we sending (compressing) or are we receiving (uncompressing)
	ASSERT((pVfSrc->bih.biCompression) || (pVfDst->bih.biCompression));
	m_bSending = ((pVfSrc->bih.biCompression == BI_RGB) ||
	              (pVfDst->bih.biCompression != BI_RGB));

	if (m_bSending == FALSE)
	{
		m_dwBrightness = VCM_DEFAULT_BRIGHTNESS;
		m_dwContrast = VCM_DEFAULT_CONTRAST;
		m_dwSaturation = VCM_DEFAULT_SATURATION;
	}
	else
	{
		m_dwImageQuality = VCM_DEFAULT_IMAGE_QUALITY;
	}

	
	mmr = vcmStreamOpen ((PHVCMSTREAM) &m_hStream, NULL,
								 pVfSrc,
								 pVfDst,
								 m_dwImageQuality, dwMaxFragSize, 0, 0, 0);
	if (mmr != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE( ("VcmFilter::Open - failed, mmr=%ld\r\n", (ULONG) mmr));
		m_bOpen = FALSE;
	}
	else
	{
		m_vfSrc = *pVfSrc;
		m_vfDst = *pVfDst;
		m_bOpen = TRUE;
	}
	return mmr;

}


MMRESULT VcmFilter::Close()
{
	MMRESULT mmr=MMSYSERR_NOERROR;

	if (m_bOpen)
	{
		mmr = vcmStreamClose(m_hStream);
	}

	m_hStream = NULL;
	m_bOpen = FALSE;
	return mmr;
}



MMRESULT VcmFilter::PrepareHeader(PVCMSTREAMHEADER pVcmHdr)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	mmr = vcmStreamPrepareHeader(m_hStream, pVcmHdr, 0);
	return mmr;
}


MMRESULT VcmFilter::UnprepareHeader(PVCMSTREAMHEADER pVcmHdr)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	mmr = vcmStreamUnprepareHeader(m_hStream, pVcmHdr, 0);
	return mmr;
}



MMRESULT VcmFilter::SuggestSrcSize(DWORD dwDstSize, DWORD *p_dwSuggestedSrcSize)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = vcmStreamSize ( m_hStream, dwDstSize,
	                      p_dwSuggestedSrcSize, VCM_STREAMSIZEF_DESTINATION);

	if (mmr == VCMERR_NOTPOSSIBLE)
	{
		*p_dwSuggestedSrcSize = min (dwDstSize, 256);
		ERROR_OUT(("VcmFilter::SuggestSrcSize() failed (VCMERR_NOTPOSSIBLE) - defaulting to %d as source size\r\n", *p_dwSuggestedSrcSize));
		mmr = MMSYSERR_NOERROR;
	}

	else if (mmr != MMSYSERR_NOERROR)
	{
		*p_dwSuggestedSrcSize = 0;
		DEBUGMSG(ZONE_VCM, ("VcmFilter::SuggestSrcSize() failed (%d)\r\n", mmr));
	}

	return mmr;

}


MMRESULT VcmFilter::SuggestDstSize(DWORD dwSrcSize, DWORD *p_dwSuggestedDecodeSize)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = vcmStreamSize ( m_hStream, dwSrcSize,
	                      p_dwSuggestedDecodeSize, VCM_STREAMSIZEF_SOURCE);

	if (mmr == VCMERR_NOTPOSSIBLE)
	{
		*p_dwSuggestedDecodeSize = min (dwSrcSize, 256);
		ERROR_OUT(("VcmFilter::SuggestDstSize() failed (VCMERR_NOTPOSSIBLE) - defaulting to %d as source size\r\n", *p_dwSuggestedDecodeSize));
		mmr = MMSYSERR_NOERROR;
	}

	else if (mmr != MMSYSERR_NOERROR)
	{
		*p_dwSuggestedDecodeSize = 0;
		DEBUGMSG(ZONE_VCM, ("VcmFilter::SuggestDstSize() failed (%d)\r\n", mmr));
	}

	return mmr;
}


MMRESULT VcmFilter::Convert(PVCMSTREAMHEADER pVcmHdr, DWORD dwEncodeFlags, BOOL bPrepareHeader)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	if (bPrepareHeader)
	{
		mmr = PrepareHeader(pVcmHdr);
		if (mmr != MMSYSERR_NOERROR)
			return mmr;
	}


	// encoding...
	// The codec has its own agenda to generate I frames. But we lose the first
	// frames sent. So we need to send more I frames at the beginning. We force this
	// by setting the VCM_STREAMCONVERTF_FORCE_KEYFRAME flag.
	dwEncodeFlags |= VCM_STREAMCONVERTF_START | VCM_STREAMCONVERTF_END;

	mmr = vcmStreamConvert (m_hStream, pVcmHdr, dwEncodeFlags);

	if (mmr != MMSYSERR_NOERROR)
	{
		DEBUGMSG(ZONE_VCM, ("VcmFilter::Convert() failed (%d)\r\n", mmr));
	}

	if (bPrepareHeader)
	{
		UnprepareHeader(pVcmHdr);
	}

	return mmr;
}


MMRESULT VcmFilter::Convert(BYTE *pSrcBuffer, DWORD dwSrcSize,
	                 BYTE *pDstBuffer, DWORD dwDstSize,
	                 DWORD dwEncodeFlags)
{
	VCMSTREAMHEADER vcmHdr;
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;


	ZeroMemory(&vcmHdr, sizeof(vcmHdr));

	vcmHdr.cbStruct = sizeof(vcmHdr);
	vcmHdr.pbSrc = pSrcBuffer;
	vcmHdr.cbSrcLength = dwSrcSize;
	vcmHdr.pbDst = pDstBuffer;
	vcmHdr.cbDstLength = dwDstSize;

	mmr = Convert(&vcmHdr, dwEncodeFlags, TRUE);

	return mmr;

}

MMRESULT VcmFilter::Convert(VideoPacket *pVP, UINT uDirection, DWORD dwEncodeFlags)
{
	VCMSTREAMHEADER *pVcmHdr;
	DWORD_PTR dwPropVal;
	BYTE *pRaw, *pNet;
	UINT uSizeRaw, uSizeNet;
	MMRESULT mmr = MMSYSERR_INVALHANDLE;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;


	pVP->GetDevData((PVOID*)&pRaw, &uSizeRaw);
	pVP->GetNetData((PVOID*)&pNet, &uSizeNet);
	pVP->GetProp(MP_PROP_FILTER_HEADER, &dwPropVal);
	pVcmHdr = (VCMSTREAMHEADER*)dwPropVal;


	ASSERT(pRaw);
	ASSERT(pNet);

	ZeroMemory(pVcmHdr, sizeof(VCMSTREAMHEADER));
	pVcmHdr->cbStruct = sizeof(VCMSTREAMHEADER);


	if (uDirection == VP_DECODE)
	{
		pVcmHdr->pbSrc = pNet;
		pVcmHdr->cbSrcLength = uSizeNet;
		pVcmHdr->pbDst = pRaw;
		pVcmHdr->cbDstLength = uSizeRaw;

		mmr = Convert(pVcmHdr, dwEncodeFlags, TRUE);

	}
	else if (uDirection == VP_ENCODE)
	{
		pVcmHdr->pbSrc = pRaw;
		pVcmHdr->cbSrcLength = uSizeRaw;
		pVcmHdr->pbDst = pNet;
		pVcmHdr->cbDstLength = uSizeNet;

		mmr = Convert(pVcmHdr, dwEncodeFlags, TRUE);
		if (mmr == MMSYSERR_NOERROR)
		{
			pVP->SetNetLength(pVcmHdr->cbDstLengthUsed);
		}
	}

	return mmr;

}


// this method is static
MMRESULT VcmFilter::SuggestDecodeFormat(VIDEOFORMATEX *pVfSrc, VIDEOFORMATEX *pVfDst)
{
	MMRESULT mmr;


	pVfDst->nSamplesPerSec = pVfSrc->nSamplesPerSec;
	pVfDst->dwFormatTag = VIDEO_FORMAT_BI_RGB;

	mmr = vcmFormatSuggest(VIDEO_MAPPER, NULL, pVfSrc, (VIDEOFORMATEX *)pVfDst, sizeof(VIDEOFORMATEX),
			VCM_FORMATSUGGESTF_DST_NSAMPLESPERSEC | VCM_FORMATSUGGESTF_DST_WFORMATTAG);

	if (mmr != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE( ("VcmFilter::SuggestDecodeFormat failed, mmr=%ld\r\n", (ULONG) mmr));
	}
	return mmr;
}


// this method is static
MMRESULT VcmFilter::SuggestEncodeFormat(UINT uDevice, VIDEOFORMATEX *pfEnc, VIDEOFORMATEX *pfDec)
{
	MMRESULT mmr;
	DWORD dwFormatTag;

	pfEnc->nSamplesPerSec = pfDec->nSamplesPerSec;

	// Get the preferred format of the capture device
	if ((mmr = vcmGetDevCapsPreferredFormatTag(uDevice, &dwFormatTag)) != MMSYSERR_NOERROR)
		return mmr;

	pfEnc->dwFormatTag = dwFormatTag;

	mmr = vcmFormatSuggest(uDevice, NULL, pfEnc, (VIDEOFORMATEX *)pfDec, sizeof(VIDEOFORMATEX),
			VCM_FORMATSUGGESTF_SRC_NSAMPLESPERSEC | VCM_FORMATSUGGESTF_SRC_WFORMATTAG);

	if (mmr != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE( ("VcmFilter::SuggestEncodeFormat failed, mmr=%ld\r\n", (ULONG) mmr));
	}

	return mmr;

}


HRESULT VcmFilter::SetProperty(DWORD dwPropId, DWORD dwPropVal)
{
	HRESULT hr = DPR_SUCCESS;

	switch (dwPropId)
	{
		case FM_PROP_VIDEO_BRIGHTNESS:
			m_dwBrightness = dwPropVal;
			vcmStreamSetBrightness (m_hStream, m_dwBrightness);
			break;

		case FM_PROP_VIDEO_CONTRAST:
			m_dwContrast = dwPropVal;
			vcmStreamSetContrast (m_hStream, m_dwContrast);
			break;

		case FM_PROP_VIDEO_SATURATION:
			m_dwSaturation = dwPropVal;
			vcmStreamSetSaturation (m_hStream, m_dwSaturation);
			break;

		case FM_PROP_VIDEO_IMAGE_QUALITY:
			m_dwImageQuality = dwPropVal;
			vcmStreamSetImageQuality (m_hStream, m_dwImageQuality);
			break;
		
		case FM_PROP_VIDEO_RESET_BRIGHTNESS:
			m_dwBrightness = VCM_DEFAULT_BRIGHTNESS;
			vcmStreamSetBrightness (m_hStream, VCM_RESET_BRIGHTNESS);
			break;

		case FM_PROP_VIDEO_RESET_CONTRAST:
			m_dwContrast = VCM_DEFAULT_CONTRAST;
			vcmStreamSetContrast (m_hStream, VCM_RESET_CONTRAST);
			break;

		case FM_PROP_VIDEO_RESET_SATURATION:
			m_dwSaturation = VCM_DEFAULT_SATURATION;
			vcmStreamSetSaturation (m_hStream, VCM_RESET_SATURATION);
			break;

		case FM_PROP_VIDEO_RESET_IMAGE_QUALITY:
			m_dwImageQuality = VCM_DEFAULT_IMAGE_QUALITY;
			vcmStreamSetImageQuality (m_hStream, VCM_RESET_IMAGE_QUALITY);
			break;

		case FM_PROP_VIDEO_MAX_PACKET_SIZE:
			vcmStreamSetMaxPacketSize (m_hStream, dwPropVal);
			break;

		case FM_PROP_PERIODIC_IFRAMES:
			vcmStreamPeriodicIFrames (m_hStream, (BOOL)dwPropVal);
			break;


	default:
		ASSERT(0);
		hr = DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}

HRESULT VcmFilter::GetProperty(DWORD dwPropId, PDWORD pdwPropVal)
{
	HRESULT hr = DPR_SUCCESS;

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
			case FM_PROP_POSTPROCESSING_SUPPORTED:
				*pdwPropVal = vcmStreamIsPostProcessingSupported(m_hStream);
				break;

			case FM_PROP_VIDEO_BRIGHTNESS:
				*pdwPropVal = m_dwBrightness;
				break;

			case FM_PROP_VIDEO_CONTRAST:
				*pdwPropVal = m_dwContrast;
				break;

			case FM_PROP_VIDEO_SATURATION:
				*pdwPropVal = m_dwSaturation;
				break;

			case FM_PROP_VIDEO_IMAGE_QUALITY:
				*pdwPropVal = m_dwImageQuality;
				break;

			case FM_PROP_PAYLOAD_HEADER_SIZE:
				vcmStreamGetPayloadHeaderSize (m_hStream, pdwPropVal);
				break;

		default:
			ASSERT(0);
			hr = DPR_INVALID_PROP_ID;
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}


MMRESULT VcmFilter::RestorePayload(WSABUF *ppDataPkt, DWORD dwPktCount, PBYTE pbyFrame, PDWORD pdwFrameSize, BOOL *pfReceivedKeyframe)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = vcmStreamRestorePayload(m_hStream, ppDataPkt, dwPktCount, pbyFrame, pdwFrameSize, pfReceivedKeyframe);
	return mmr;
}


MMRESULT VcmFilter::FormatPayload(PBYTE pDataSrc, DWORD dwDataSize, PBYTE *ppDataPkt,
	                       PDWORD pdwPktSize, PDWORD pdwPktCount, UINT *pfMark,
						   PBYTE *pHdrInfo,	PDWORD pdwHdrSize)
{
	MMRESULT mmr;
	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = vcmStreamFormatPayload(m_hStream, pDataSrc, dwDataSize, ppDataPkt,
	                             pdwPktSize, pdwPktCount, pfMark,
	                             pHdrInfo, pdwHdrSize);
	return mmr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\vcmfilter.h ===
#ifndef VCM_FILTER_H
#define VCM_FILTER_H


#define VP_ENCODE	1
#define VP_DECODE	2







enum
{
	FM_PROP_POSTPROCESSING_SUPPORTED,
	FM_PROP_VIDEO_BRIGHTNESS,
	FM_PROP_VIDEO_CONTRAST,
	FM_PROP_VIDEO_SATURATION,
	FM_PROP_VIDEO_IMAGE_QUALITY,
	FM_PROP_VIDEO_RESET_BRIGHTNESS,
	FM_PROP_VIDEO_RESET_CONTRAST,
	FM_PROP_VIDEO_RESET_SATURATION,
	FM_PROP_VIDEO_RESET_IMAGE_QUALITY,
	FM_PROP_PAYLOAD_HEADER_SIZE,
	FM_PROP_VIDEO_MAX_PACKET_SIZE,
	FM_PROP_PERIODIC_IFRAMES,
	FM_PROP_NumOfProps
};







class VcmFilter
{

private:
	VIDEOFORMATEX m_vfSrc;  // source format
	VIDEOFORMATEX m_vfDst;  // destination format

	HVCMSTREAM m_hStream;   // handle to vcm stream

	DWORD m_dwBrightness;
	DWORD m_dwContrast;
	DWORD m_dwImageQuality;
	DWORD m_dwSaturation;

	BOOL m_bOpen;
	BOOL m_bSending;  // TRUE if compressing for send
	                 // FALSE if decompressing for receive 
	              
public:
	VcmFilter();
	~VcmFilter();

	MMRESULT Open(VIDEOFORMATEX *pVfSrc, VIDEOFORMATEX *pVfDst, DWORD dwMaxFragSize);
	MMRESULT PrepareHeader(PVCMSTREAMHEADER pVcmHdr);
	MMRESULT UnprepareHeader(PVCMSTREAMHEADER pVcmHdr);
	MMRESULT Close();

	MMRESULT Convert(PVCMSTREAMHEADER pVcmHdr, DWORD dwEncodeFlags=0, BOOL bPrepareHeader=FALSE);
	MMRESULT Convert(BYTE *pSrcBuffer, DWORD dwSrcSize,
	                 BYTE *pDstBuffer, DWORD dwDstSize,
	                 DWORD dwEncodeFlags=0);

	MMRESULT Convert(VideoPacket *pVP, UINT uDirection, DWORD dwEncodeFlags=0);



	HRESULT GetProperty(DWORD dwPropId, PDWORD pdwPropVal);
	HRESULT SetProperty(DWORD dwPropID, DWORD dwPropVal);

	MMRESULT SuggestSrcSize(DWORD dwDestSize, DWORD *p_dwSuggestedSourceSize);
	MMRESULT SuggestDstSize(DWORD dwSourceSize, DWORD *p_dwSuggestedDstSize);

	MMRESULT RestorePayload(WSABUF *ppDataPkt, DWORD dwPktCount, PBYTE pbyFrame, PDWORD pdwFrameSize, BOOL *pfReceivedKeyframe);
	MMRESULT FormatPayload(PBYTE pDataSrc, DWORD dwDataSize, PBYTE *ppDataPkt,
	                       PDWORD pdwPktSize, PDWORD pdwPktCount, UINT *pfMark,
						   PBYTE *pHdrInfo,	PDWORD pdwHdrSize);

	// inline wrappers to vcm functions
	MMRESULT GetPayloadHeaderSize(DWORD *pdwSize) {return vcmStreamGetPayloadHeaderSize(m_hStream, pdwSize);}
	MMRESULT RequestIFrame() {return vcmStreamRequestIFrame(m_hStream);}
	MMRESULT SetTargetRates(DWORD dwTargetFrameRate, DWORD dwTargetByteRate)
	{return vcmStreamSetTargetRates(m_hStream, dwTargetFrameRate, dwTargetByteRate);}


	static MMRESULT SuggestDecodeFormat(VIDEOFORMATEX *pVfSrc, VIDEOFORMATEX *pVfDst);
	static MMRESULT SuggestEncodeFormat(UINT uDevice, VIDEOFORMATEX *pfEnc, VIDEOFORMATEX *pfDec);


};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\vcmstrm.cpp ===
#include "precomp.h"

// #define LOG_COMPRESSION_PARAMS 1
// #define LOGPAYLOAD_ON 1

#ifdef LOGPAYLOAD_ON
HANDLE			g_DebugFile = (HANDLE)NULL;
HANDLE			g_TDebugFile = (HANDLE)NULL;
#endif

// #define VALIDATE_SBIT_EBIT 1

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
DWORD g_dwPreviousEBIT = 0;
#endif // } VALIDATE_SBIT_EBIT

#define BUFFER_SIZE 50
#define NUM_FPS_ENTRIES 1
#define NUM_BITDEPTH_ENTRIES 9
#define NUM_RGB_BITDEPTH_ENTRIES 4
#define VIDEO_FORMAT_NUM_RESOLUTIONS 6
#define MAX_NUM_REGISTERED_SIZES 3
#define MAX_VERSION 80 // Needs to be in sync with the MAX_VERSION in dcap\inc\idcap.h
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

// String resources
#define IDS_FORMAT_1	TEXT("%4.4hs.%4.4hs, %02dbit, %02dfps, %03dx%03d")
#define IDS_FORMAT_2	TEXT("%4.4hs.%04d, %02dbit, %02dfps, %03dx%03d")

#define szRegDeviceKey			TEXT("SOFTWARE\\Microsoft\\Conferencing\\CaptureDevices")
#define szRegCaptureDefaultKey	TEXT("SOFTWARE\\Microsoft\\Conferencing\\CaptureDefaultFormats")
#define szRegConferencingKey	TEXT("SOFTWARE\\Microsoft\\Conferencing")
#define szTotalRegDeviceKey		TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Conferencing\\CaptureDevices")
#define szRegCaptureKey			TEXT("CaptureDevices")
#define szRegdwImageSizeKey		TEXT("dwImageSize")
#define szRegImageSizesKey		TEXT("aImageSizes")
#define szRegNumImageSizesKey	TEXT("nNumSizes")
#define szRegdwNumColorsKey		TEXT("dwNumColors")
#define szRegdwStreamingModeKey	TEXT("dwStreamingMode")
#define szRegdwDialogsKey		TEXT("dwDialogs")
#define szRegbmi4bitColorsKey	TEXT("bmi4bitColors")
#define szRegbmi8bitColorsKey	TEXT("bmi8bitColors")
#define szRegDefaultFormatKey	TEXT("DefaultFormat")

EXTERN_C HINSTANCE	g_hInst; // Our module handle. defined in nac.cpp

//External function (in msiacaps.cpp) to read reg info in one shot
extern ULONG ReadRegistryFormats (LPCSTR lpszKeyName,CHAR ***pppName,BYTE ***pppData,PUINT pnFormats,DWORD dwDebugSize);

PVCM_APP_ICINFO g_aVCMAppInfo;

int             g_nNumVCMAppInfoEntries;
int             g_nNumFrameSizesEntries;
BOOL            g_fNewCodecsInstalled;

#ifdef LOGFILE_ON


DWORD			g_CompressTime;
DWORD			g_DecompressTime;
HANDLE			g_CompressLogFile;
HANDLE			g_DecompressLogFile;
DWORD			g_dwCompressBytesWritten;
DWORD			g_dwDecompressBytesWritten;
char			g_szCompressBuffer[256];
char			g_szDecompressBuffer[256];
DWORD			g_OrigCompressTime;
DWORD			g_OrigDecompressTime;
DWORD			g_AvgCompressTime;
DWORD			g_AvgDecompressTime;
DWORD			g_aCompressTime[4096];
DWORD			g_aDecompressTime[4096];
SYSTEMTIME		g_SystemTime;
#endif

typedef struct tagDejaVu
{
	VIDEOFORMATEX	vfx;
	DWORD			dwFlags;
} DEJAVU, *PDEJAVU;

#if 1
// Array of known ITU sizes
MYFRAMESIZE g_ITUSizes[8] =
		{
		{    0,   0 },
		{  128,  96 },
		{  176, 144 },
		{  352, 288 },
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
		{   80,  64 },
#else
		{  704, 576 },
#endif
		{ 1408,1152 },
		{    0,   0 },
		{    0,   0 }
		};

// For now, the size of the VIDEOFORMATEX being 1118 even if
// there is no palette, do not enumerate all of the possible
// formats. As soon as you have replaced the BITMAPINFOHEADER
// + Palette by pointers to such structure, enable all the
// sizes.
NCAP_APP_INFO g_awResolutions[VIDEO_FORMAT_NUM_RESOLUTIONS] =
		{
//		VIDEO_FORMAT_IMAGE_SIZE_40_30,
//		VIDEO_FORMAT_IMAGE_SIZE_64_48,
//		VIDEO_FORMAT_IMAGE_SIZE_80_60,
//		VIDEO_FORMAT_IMAGE_SIZE_96_64,
//		VIDEO_FORMAT_IMAGE_SIZE_112_80,
//		VIDEO_FORMAT_IMAGE_SIZE_120_90,
		{ VIDEO_FORMAT_IMAGE_SIZE_128_96, 128, 96 },
//		VIDEO_FORMAT_IMAGE_SIZE_144_112,
		{ VIDEO_FORMAT_IMAGE_SIZE_160_120, 160, 120 },
//		VIDEO_FORMAT_IMAGE_SIZE_160_128,
		{ VIDEO_FORMAT_IMAGE_SIZE_176_144, 176, 144 },
//		VIDEO_FORMAT_IMAGE_SIZE_192_160,
//		VIDEO_FORMAT_IMAGE_SIZE_200_150,
//		VIDEO_FORMAT_IMAGE_SIZE_208_176,
//		VIDEO_FORMAT_IMAGE_SIZE_224_192,
		{ VIDEO_FORMAT_IMAGE_SIZE_240_180, 240, 180 },
//		VIDEO_FORMAT_IMAGE_SIZE_240_208,
//		VIDEO_FORMAT_IMAGE_SIZE_256_224,
//		VIDEO_FORMAT_IMAGE_SIZE_272_240,
//		VIDEO_FORMAT_IMAGE_SIZE_280_210,
//		VIDEO_FORMAT_IMAGE_SIZE_288_256,
//		VIDEO_FORMAT_IMAGE_SIZE_304_272,
		{ VIDEO_FORMAT_IMAGE_SIZE_320_240, 320, 240 },
//		VIDEO_FORMAT_IMAGE_SIZE_320_288,
//		VIDEO_FORMAT_IMAGE_SIZE_336_288,
		{ VIDEO_FORMAT_IMAGE_SIZE_352_288, 352, 288 },
//		VIDEO_FORMAT_IMAGE_SIZE_640_480,
		};

#else

// For now, the size of the VIDEOFORMATEX being 1118 even if
// there is no palette, do not enumerate all of the possible
// formats. As soon as you have replaced the BITMAPINFOHEADER
// + Palette by pointers to such structure, enable all the
// sizes.
DWORD g_awResolutions[VIDEO_FORMAT_NUM_RESOLUTIONS] =
		{
//		VIDEO_FORMAT_IMAGE_SIZE_40_30,
//		VIDEO_FORMAT_IMAGE_SIZE_64_48,
//		VIDEO_FORMAT_IMAGE_SIZE_80_60,
//		VIDEO_FORMAT_IMAGE_SIZE_96_64,
//		VIDEO_FORMAT_IMAGE_SIZE_112_80,
//		VIDEO_FORMAT_IMAGE_SIZE_120_90,
		VIDEO_FORMAT_IMAGE_SIZE_160_120,
//		VIDEO_FORMAT_IMAGE_SIZE_144_112,
		VIDEO_FORMAT_IMAGE_SIZE_128_96,
//		VIDEO_FORMAT_IMAGE_SIZE_160_128,
		VIDEO_FORMAT_IMAGE_SIZE_240_180,
//		VIDEO_FORMAT_IMAGE_SIZE_192_160,
//		VIDEO_FORMAT_IMAGE_SIZE_200_150,
//		VIDEO_FORMAT_IMAGE_SIZE_208_176,
//		VIDEO_FORMAT_IMAGE_SIZE_224_192,
		VIDEO_FORMAT_IMAGE_SIZE_176_144,
//		VIDEO_FORMAT_IMAGE_SIZE_240_208,
//		VIDEO_FORMAT_IMAGE_SIZE_256_224,
//		VIDEO_FORMAT_IMAGE_SIZE_272_240,
//		VIDEO_FORMAT_IMAGE_SIZE_280_210,
//		VIDEO_FORMAT_IMAGE_SIZE_288_256,
//		VIDEO_FORMAT_IMAGE_SIZE_304_272,
		VIDEO_FORMAT_IMAGE_SIZE_320_240,
//		VIDEO_FORMAT_IMAGE_SIZE_320_288,
//		VIDEO_FORMAT_IMAGE_SIZE_336_288,
		VIDEO_FORMAT_IMAGE_SIZE_352_288,
//		VIDEO_FORMAT_IMAGE_SIZE_640_480,
		};
#endif

//int	g_aiFps[NUM_FPS_ENTRIES] = {3, 7, 15};
int	g_aiFps[NUM_FPS_ENTRIES] = {30};
// The order of the bit depths matches what I think is the
// preferred format if more than one is supported.
// For color, 16bit is almost as good as 24 but uses less memory
// and is faster for color QuickCam.
// For greyscale, 16 greyscale levels is Ok, not as good as 64,
// but Greyscale QuickCam is too slow at 64 levels.
int g_aiBitDepth[NUM_BITDEPTH_ENTRIES] = {9, 12, 12, 16, 16, 16, 24, 4, 8};
int g_aiNumColors[NUM_BITDEPTH_ENTRIES] = {VIDEO_FORMAT_NUM_COLORS_YVU9, VIDEO_FORMAT_NUM_COLORS_I420, VIDEO_FORMAT_NUM_COLORS_IYUV, VIDEO_FORMAT_NUM_COLORS_YUY2, VIDEO_FORMAT_NUM_COLORS_UYVY, VIDEO_FORMAT_NUM_COLORS_65536, VIDEO_FORMAT_NUM_COLORS_16777216, VIDEO_FORMAT_NUM_COLORS_16, VIDEO_FORMAT_NUM_COLORS_256};
int g_aiFourCCCode[NUM_BITDEPTH_ENTRIES] = {VIDEO_FORMAT_YVU9, VIDEO_FORMAT_I420, VIDEO_FORMAT_IYUV, VIDEO_FORMAT_YUY2, VIDEO_FORMAT_UYVY, VIDEO_FORMAT_BI_RGB, VIDEO_FORMAT_BI_RGB, VIDEO_FORMAT_BI_RGB, VIDEO_FORMAT_BI_RGB};
int	g_aiClrUsed[NUM_BITDEPTH_ENTRIES] = {0, 0, 0, 0, 0, 0, 0, 16, 256};

PVCMSTREAMHEADER DeQueVCMHeader(PVCMSTREAM pvs);
MMRESULT VCMAPI vcmDefaultFormatWriteToReg(LPSTR szDeviceName, LPSTR szDeviceVersion, LPBITMAPINFOHEADER lpbmih);

#define IsVCMHeaderPrepared(pvh)    ((pvh)->fdwStatus &  VCMSTREAMHEADER_STATUSF_PREPARED)
#define MarkVCMHeaderPrepared(pvh)     ((pvh)->fdwStatus |= VCMSTREAMHEADER_STATUSF_PREPARED)
#define MarkVCMHeaderUnprepared(pvh)   ((pvh)->fdwStatus &=~VCMSTREAMHEADER_STATUSF_PREPARED)
#define IsVCMHeaderInQueue(pvh)        ((pvh)->fdwStatus &  VCMSTREAMHEADER_STATUSF_INQUEUE)
#define MarkVCMHeaderInQueue(pvh)      ((pvh)->fdwStatus |= VCMSTREAMHEADER_STATUSF_INQUEUE)
#define MarkVCMHeaderUnQueued(pvh)     ((pvh)->fdwStatus &=~VCMSTREAMHEADER_STATUSF_INQUEUE)
#define IsVCMHeaderDone(pvh)        ((pvh)->fdwStatus &  VCMSTREAMHEADER_STATUSF_DONE)
#define MarkVCMHeaderDone(pvh)         ((pvh)->fdwStatus |= VCMSTREAMHEADER_STATUSF_DONE)
#define MarkVCMHeaderNotDone(pvh)      ((pvh)->fdwStatus &=~VCMSTREAMHEADER_STATUSF_DONE)


/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmMetrics | This function returns various metrics for the Video
 *      Compression Manager (VCM) or related VCM objects.
 *
 *  @parm HVCMOBJ | hvo | Specifies the VCM object to query for the metric
 *      specified in <p uMetric>. This argument may be NULL for some
 *      queries.
 *
 *  @parm UINT | uMetric | Specifies the metric index to be returned in
 *      <p pMetric>.
 *
 *      @flag VCM_METRIC_COUNT_COMPRESSORS | Specifies that the returned value is
 *      the number of global VCM compressors in
 *      the system. The <p hvo> argument must be NULL for this metric index.
 *      The <p pMetric> argument must point to a buffer of a size equal to a
 *      DWORD.
 *
 *      @flag VCM_METRIC_COUNT_DECOMPRESSORS | Specifies that the returned value is
 *      the number of global VCM decompressors in
 *      the system. The <p hvo> argument must be NULL for this metric index.
 *      The <p pMetric> argument must point to a buffer of a size equal to a
 *      DWORD.
 *
 *      @flag VCM_METRIC_MAX_SIZE_FORMAT | Specifies that the returned value
 *      is the size of the largest <t VIDEOFORMATEX> structure. If <p hvo>
 *      is NULL, then the return value is the largest <t VIDEOFORMATEX>
 *      structure in the system. If <p hvo> identifies an open instance
 *      of an VCM driver (<t HVCMDRIVER>) or a VCM driver identifier
 *      (<t HVCMDRIVERID>), then the largest <t VIDEOFORMATEX>
 *      structure for that driver is returned. The <p pMetric> argument must
 *      point to a buffer of a size equal to a DWORD. This metric is not allowed
 *      for a VCM stream handle (<t HVCMSTREAM>).
 *
 *  @parm LPVOID | pMetric | Specifies a pointer to the buffer that will
 *      receive the metric details. The exact definition depends on the
 *      <p uMetric> index.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *      @flag MMSYSERR_INVALPARAM | The <p pMetric> parameter is invalid.
 *      @flag MMSYSERR_NOTSUPPORTED | The <p uMetric> index is not supported.
 *      @flag VCMERR_NOTPOSSIBLE | The <p uMetric> index cannot be returned
 *      for the specified <p hvo>.
 *
 ***************************************************************************/
MMRESULT VCMAPI vcmMetrics(HVCMOBJ hao, UINT uMetric, LPVOID pMetric)
{
	MMRESULT	mmr;
	ICINFO		ICinfo;

	if (!pMetric)
	{
		ERRORMESSAGE(("vcmMetrics: Specified pointer is invalid, pMetric=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	 switch (uMetric)
	 {
		case VCM_METRIC_MAX_SIZE_FORMAT:
			// For now, assume all VIDEOFORMATEX structures have identical sizes
			*(LPDWORD)pMetric = (DWORD)sizeof(VIDEOFORMATEX);
			mmr = (MMRESULT)MMSYSERR_NOERROR;
			break;
		case VCM_METRIC_MAX_SIZE_BITMAPINFOHEADER:
			// For now, assume all BITMAPINFOHEADER structures have identical sizes
			*(LPDWORD)pMetric = (DWORD)sizeof(BITMAPINFOHEADER);
			mmr = (MMRESULT)MMSYSERR_NOERROR;
			break;
		case VCM_METRIC_COUNT_DRIVERS:
		case VCM_METRIC_COUNT_COMPRESSORS:
			for (*(LPDWORD)pMetric = 0; ICInfo(ICTYPE_VIDEO, *(LPDWORD)pMetric, &ICinfo); (*(LPDWORD)pMetric)++)
				;
			mmr = (MMRESULT)MMSYSERR_NOERROR;
			break;
		default:
			ERRORMESSAGE(("vcmMetrics: Specified index is invalid, uMetric=%ld\r\n", uMetric));
			mmr = (MMRESULT)MMSYSERR_NOTSUPPORTED;
			break;
	}

	return (mmr);
}

/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmDriverDetails | This function queries a specified
 *      Video Compression Manager (VCM) driver to determine its driver details.
 *
 *  @parm PVCMDRIVERDETAILS | pvdd | Pointer to a <t VCMDRIVERDETAILS>
 *      structure that will receive the driver details. The
 *      <e VCMDRIVERDETAILS.cbStruct> member must be initialized to the
 *      size, in bytes, of the structure. The <e VCMDRIVERDETAILS.fccType> member
 *      must be initialized to the four-character code indicating the type of
 *      stream being compressed or decompressed. Specify VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC
 *      for video streams. The <e VCMDRIVERDETAILS.fccHandler> member must be initialized
 *      to the four-character code identifying the compressor.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *      @flag MMSYSERR_NODRIVER | No matching codec is present.
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed is invalid.
 *
 *  @xref <f vcmDriverEnum>
 ***************************************************************************/
MMRESULT VCMAPI vcmDriverDetails(PVCMDRIVERDETAILS pvdd)
{
	DWORD	fccHandler;
	ICINFO	ICinfo;
	HIC		hIC;

	// Check input params
	if (!pvdd)
	{
		ERRORMESSAGE(("vcmDriverDetails: Specified pointer is invalid, pvdd=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Make fccHandler uppercase and back it up
	fccHandler = pvdd->fccHandler;
	if (fccHandler > 256)
		CharUpperBuff((LPTSTR)&fccHandler, sizeof(DWORD));

	// Try to open the codec
	if (hIC = ICOpen(ICTYPE_VIDEO, fccHandler, ICMODE_QUERY))
	{
		// Get the details
		ICGetInfo(hIC, &ICinfo, sizeof(ICINFO));

		// Restore fccHandler
		ICinfo.fccHandler = fccHandler;

		// VCMDRIVERDETAILS and ICINFO are identical structures
		CopyMemory(pvdd, &ICinfo, sizeof(VCMDRIVERDETAILS));

		// Close the codec
		ICClose(hIC);
	}
	else
		return ((MMRESULT)MMSYSERR_NODRIVER);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmFormatDetails | This function queries the Video Compression
 *      Manager (VCM) for details on format for a specific video format.
 *
 *  @parm PVCMFORMATDETAILS | pvfd | Specifies a pointer to the
 *      <t VCMFORMATDETAILS> structure that is to receive the format
 *      details for the given embedded pointer to a <t VIDEOFORMATEX> structure.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *      @flag MMSYSERR_NODRIVER | No matching codec is present.
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed is invalid.
 *
 *  @xref <f vcmDriverDetails>
 ***************************************************************************/
MMRESULT VCMAPI vcmFormatDetails(PVCMFORMATDETAILS pvfd)
{
	MMRESULT	mmr = (MMRESULT)MMSYSERR_NOERROR;
	DWORD		fccHandler;
	DWORD		fccType;
	HIC			hIC;
	char		szBuffer[BUFFER_SIZE]; // Could be smaller.
	int			iLen;

	// Check input params
	if (!pvfd)
	{
		ERRORMESSAGE(("vcmDriverDetails: Specified pointer is invalid, pvdd=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvfd->pvfx)
	{
		ERRORMESSAGE(("vcmDriverDetails: Specified pointer is invalid, pvdd->pvfx=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Make fccHandler uppercase and back it up
	fccHandler = pvfd->pvfx->dwFormatTag;
	fccType = ICTYPE_VIDEO;
	if (fccHandler > 256)
		CharUpperBuff((LPTSTR)&fccHandler, sizeof(DWORD));

	// Try to open the codec
	if (hIC = ICOpen(fccType, pvfd->pvfx->dwFormatTag, ICMODE_QUERY))
	{
		// Check if the codec supports the format
		if (ICDecompressQuery(hIC, &pvfd->pvfx->bih, (LPBITMAPINFOHEADER)NULL) == ICERR_OK)
		{
#if 0
			if (ICCompressQuery(hIC, (LPBITMAPINFOHEADER)NULL, &pvfd->pvfx->bih) == ICERR_OK)
			{
#endif
				// Now complete the format details info, overwrite some of the fields of
				// the VIDEOFORMATEX structure too, just in case we were passed bogus values...
				pvfd->pvfx->nSamplesPerSec = g_aiFps[0];

				if (pvfd->pvfx->dwFormatTag > 256)
					wsprintf(szBuffer, IDS_FORMAT_1, (LPSTR)&fccType, (LPSTR)&fccHandler,
							pvfd->pvfx->bih.biBitCount, pvfd->pvfx->nSamplesPerSec,
							pvfd->pvfx->bih.biWidth, pvfd->pvfx->bih.biHeight);
				else
					wsprintf(szBuffer, IDS_FORMAT_2, (LPSTR)&fccType, fccHandler,
							pvfd->pvfx->bih.biBitCount, pvfd->pvfx->nSamplesPerSec,
							pvfd->pvfx->bih.biWidth, pvfd->pvfx->bih.biHeight);
				iLen = MultiByteToWideChar(GetACP(), 0, szBuffer, -1, pvfd->szFormat, 0);
				MultiByteToWideChar(GetACP(), 0, szBuffer, -1, pvfd->szFormat, iLen);
#if 0
			}
			else
				mmr = (MMRESULT)MMSYSERR_NODRIVER;
#endif
		}
		else
			mmr = (MMRESULT)MMSYSERR_NODRIVER;

		// Close the codec
		ICClose(hIC);
	}
	else
		mmr = (MMRESULT)MMSYSERR_NODRIVER;

	return (mmr);
}


/*****************************************************************************
 * @doc EXTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmGetDevCaps | This function queries a specified
 *   video capture input device to determine its capabilities.
 *
 * @parm UINT | uDevice | Specifies the video capture input device ID.
 *
 * @parm PVIDEOINCAPS | pvc | Specifies a pointer to a <t VIDEOINCAPS>
 *   structure. This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | cbvc | Specifies the size of the <t VIDEOINCAPS> structure.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_BADDEVICEID | Specified device device ID is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified pointer to structure is invalid.
 *   @flag MMSYSERR_NODRIVER | No capture device driver or device is present.
 *   @flag VCMERR_NONSPECIFIC | The capture driver failed to provide description information.
 *
 * @comm Only <p cbwc> bytes (or less) of information is copied to the location
 *   pointed to by <p pvc>. If <p cbwc> is zero, nothing is copied, and
 *   the function returns zero.
 *
 *   If the ID of the capture device passed is VIDEO_MAPPER, the first device in the list
 *   of installed capture devices is considered.
 *
 * @devnote You never return MMSYSERR_NODRIVER. Is there a way to make a difference
 *   between a call failing because there is no device, or because of a device failure?
 *
 * @xref <f videoDevCapsProfile> <f videoDevCapsReadFromReg> <f videoDevCapsWriteToReg>
 ****************************************************************************/
MMRESULT VCMAPI vcmGetDevCaps(UINT uDevice, PVIDEOINCAPS pvc, UINT cbvc)
{
	MMRESULT	mmr;
	FINDCAPTUREDEVICE fcd;

	// Check input params
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmGetDevCaps: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}
	if (!pvc)
	{
		ERRORMESSAGE(("vcmGetDevCaps: Specified pointer is invalid, pvc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!cbvc)
	{
		ERRORMESSAGE(("vcmGetDevCaps: Specified structure size is invalid, cbvc=%ld\r\n", cbvc));
		return ((MMRESULT)MMSYSERR_NOERROR);
	}

	// Get the driver name and version number
    fcd.dwSize = sizeof (FINDCAPTUREDEVICE);
	if (uDevice == VIDEO_MAPPER)
	{
		if (!FindFirstCaptureDevice(&fcd, NULL))
		{
			ERRORMESSAGE(("vcmGetDevCaps: FindFirstCaptureDevice() failed\r\n"));
			return ((MMRESULT)VCMERR_NONSPECIFIC);
		}
	}
	else
	{
		if (!FindFirstCaptureDeviceByIndex(&fcd, uDevice))
		{
			ERRORMESSAGE(("vcmGetDevCaps: FindFirstCaptureDevice() failed\r\n"));
			return ((MMRESULT)VCMERR_NONSPECIFIC);
		}
	}

	// Set default values
	pvc->dwImageSize = pvc->dwNumColors = (DWORD)NULL;
	pvc->dwStreamingMode = STREAMING_PREFER_FRAME_GRAB;
	pvc->dwDialogs = FORMAT_DLG_OFF | SOURCE_DLG_ON;

    //Look for a specific version of the driver first....
    lstrcpy(pvc->szDeviceName, fcd.szDeviceDescription);
    lstrcpy(pvc->szDeviceVersion, fcd.szDeviceVersion);

	// Based on the name and version number of the driver, set capabilities.
	// We first try to look them up from the registry. If this is a very popular
	// board/camera, chances are that we have set the key at install time already.
	// If we can't find the key, we profile the hardware and save the results
	// to the registry.
	if (vcmDevCapsReadFromReg(pvc->szDeviceName, pvc->szDeviceVersion,pvc, cbvc) != MMSYSERR_NOERROR)
	{

        //Didn't find the specific version, try it again, with NULL version info
        pvc->szDeviceVersion[0]= (char) NULL;
        if (vcmDevCapsReadFromReg(pvc->szDeviceName, NULL,pvc, cbvc) != MMSYSERR_NOERROR)
        {
    		DEBUGMSG (ZONE_VCM, ("vcmGetDevCaps: Unknown capture hardware found. Profiling...\r\n"));
            lstrcpy(pvc->szDeviceVersion, fcd.szDeviceVersion);

    		if ((mmr = vcmDevCapsProfile(uDevice, pvc, cbvc)) == MMSYSERR_NOERROR)
            {
                // record this default in the registry
                if (pvc->szDeviceName[0] != '\0')
                {
                    vcmDevCapsWriteToReg(pvc->szDeviceName, pvc->szDeviceVersion, pvc, cbvc);
                }
                else
                {
                    //fcd.szDeviceName is the Driver Name
                    vcmDevCapsWriteToReg(fcd.szDeviceName, pvc->szDeviceVersion, pvc, cbvc);
                }

            }
    		else
    		{
    			ERRORMESSAGE(("vcmGetDevCaps: vcmDevCapsProfile() failed\r\n"));
    			return (mmr);
    		}
        }
	}

	return ((MMRESULT)MMSYSERR_NOERROR);
}

/****************************************************************************
 *  @doc  INTERNAL COMPFUNC
 *
 *  @func MMRESULT | AppICInfo | The <f AppICInfo> function
 *      will either call the standard ICInfo function
 *      function continues enumerating until there are no more suitable
 *      formats for the format tag or the callback function returns FALSE.
 *
 ***************************************************************************/

/*
 *	NOTE:
 *
 *	ICInfo returns TRUE on success and FALSE on failure. The documentation suggests
 *	otherwise and is wrong. AppICInfo returns the same.
 */

BOOL VFWAPI AppICInfo(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo, DWORD fdwEnum)
{
	if ((fdwEnum & VCM_FORMATENUMF_ALLMASK) == VCM_FORMATENUMF_ALL)
	{
		// enumerating all formats, just do the standard ICInfo
		return ICInfo(fccType, fccHandler, lpicinfo);
	}
	else
	{
		// only enumerating specific formats

		// are we done ?
		if (fccHandler >= (DWORD)g_nNumVCMAppInfoEntries)
		{
			// we're done enumerating app-specific formats
			return FALSE;
		}

		lpicinfo->fccType = g_aVCMAppInfo[fccHandler].fccType;
		lpicinfo->fccHandler = g_aVCMAppInfo[fccHandler].fccHandler;
		return TRUE;
	}
}

BOOL vcmBuildDefaultEntries (void)
{

    //Yikes! Reg. problem (or first boot) instantiate only the minimum...
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
    g_nNumVCMAppInfoEntries=3;
#else
    g_nNumVCMAppInfoEntries=2;
#endif
    g_nNumFrameSizesEntries=MAX_NUM_REGISTERED_SIZES;
    g_fNewCodecsInstalled=FALSE;

    //Allocate space for the VCM_APP_ICINFO structure (zero init'd)
    if (!(g_aVCMAppInfo = (VCM_APP_ICINFO *)MemAlloc (g_nNumVCMAppInfoEntries*sizeof (VCM_APP_ICINFO)))) {
        //Aiiie!
        ERRORMESSAGE (("vcmBDE: Memory Allocation Failed!\r\n"));
        return FALSE;
    }

    //H.263
    g_aVCMAppInfo[0].fccType=ICTYPE_VIDEO;
#ifndef _ALPHA_
    g_aVCMAppInfo[0].fccHandler=VIDEO_FORMAT_MSH263;
#else
    g_aVCMAppInfo[0].fccHandler=VIDEO_FORMAT_DECH263;
#endif
    g_aVCMAppInfo[0].framesize[0].biWidth=128;
    g_aVCMAppInfo[0].framesize[0].biHeight=96;
    g_aVCMAppInfo[0].framesize[1].biWidth=176;
    g_aVCMAppInfo[0].framesize[1].biHeight=144;
    g_aVCMAppInfo[0].framesize[2].biWidth=352;
    g_aVCMAppInfo[0].framesize[2].biHeight=288;


    //H.261
    g_aVCMAppInfo[1].fccType=ICTYPE_VIDEO;
#ifndef _ALPHA_
    g_aVCMAppInfo[1].fccHandler=VIDEO_FORMAT_MSH261;
#else
    g_aVCMAppInfo[1].fccHandler=VIDEO_FORMAT_DECH261;
#endif
    g_aVCMAppInfo[1].framesize[0].biWidth=0;
    g_aVCMAppInfo[1].framesize[0].biHeight=0;
    g_aVCMAppInfo[1].framesize[1].biWidth=176;
    g_aVCMAppInfo[1].framesize[1].biHeight=144;
    g_aVCMAppInfo[1].framesize[2].biWidth=352;
    g_aVCMAppInfo[1].framesize[2].biHeight=288;

#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
    //H.26X
    g_aVCMAppInfo[2].fccType=ICTYPE_VIDEO;
    g_aVCMAppInfo[2].fccHandler=VIDEO_FORMAT_MSH26X;
    g_aVCMAppInfo[2].framesize[0].biWidth=80;
    g_aVCMAppInfo[2].framesize[0].biHeight=64;
    g_aVCMAppInfo[2].framesize[1].biWidth=128;
    g_aVCMAppInfo[2].framesize[1].biHeight=96;
    g_aVCMAppInfo[2].framesize[2].biWidth=176;
    g_aVCMAppInfo[2].framesize[2].biHeight=144;
#endif

    return TRUE;
}


BOOL vcmFillGlobalsFromRegistry (void)
{

    int i,j,k,iFormats,iOffset;
    DWORD *pTmp;
    BOOL bKnown;
    MYFRAMESIZE *pTmpFrame;
	char            **pVCMNames;
    VIDCAP_DETAILS  **pVCMData;
    UINT            nFormats;


    //Read the registry for all the keys that we care about
    //We're loading the values of HKLM\Software\Microsoft\Internet Audio\VCMEncodings

    if (ReadRegistryFormats(szRegInternetPhone TEXT("\\") szRegInternetPhoneVCMEncodings,
			&pVCMNames,(BYTE ***)&pVCMData,&nFormats,sizeof (VIDCAP_DETAILS)) != ERROR_SUCCESS) {
        ERRORMESSAGE (("vcmFillGlobalsFromRegistry, couldn't build formats from registry\r\n"));
        return (vcmBuildDefaultEntries());
    }

    //Minimum number of frame and format sizes;
    g_nNumFrameSizesEntries=MAX_NUM_REGISTERED_SIZES;
    g_nNumVCMAppInfoEntries=0;
    g_fNewCodecsInstalled=FALSE;


    //Allocate a temp buffer of size of nFormats, use this to track various things
    if (!(pTmp = (DWORD *)MemAlloc (nFormats * sizeof (DWORD)))) {

        ERRORMESSAGE (("vcmFillGlobalsFromRegistry: Memory Allocation Failed!\r\n"));
        return FALSE;
    }


    //Find the number of formats,
    for (i=0;i< (int )nFormats;i++) {
        bKnown=FALSE;
        for (j=0;j<g_nNumVCMAppInfoEntries;j++) {
            if (pVCMData[i]->dwFormatTag == pTmp[j]) {
                bKnown=TRUE;
                break;
            }
        }
        if (!bKnown) {
            //something new
            pTmp[g_nNumVCMAppInfoEntries++]=pVCMData[i]->dwFormatTag;
            g_fNewCodecsInstalled=TRUE;
        }
    }

    //Allocate space for the VCM_APP_ICINFO structure (zero init'd)

	if (g_aVCMAppInfo != NULL)
	{
		MemFree(g_aVCMAppInfo);
	}

    if (!(g_aVCMAppInfo = (VCM_APP_ICINFO *)MemAlloc (g_nNumVCMAppInfoEntries*sizeof (VCM_APP_ICINFO))))
	{
        //Aiiie!
        MemFree (pTmp);
        ERRORMESSAGE (("vcmFillGlobalsFromRegistry: Memory Allocation Failed!\r\n"));
        return FALSE;
    }

    //Fill out the basic information.
    //All elements have a certain commonality
    for (j=0;j<g_nNumVCMAppInfoEntries;j++) {

        g_aVCMAppInfo[j].fccType=ICTYPE_VIDEO;
        g_aVCMAppInfo[j].fccHandler=pTmp[j];

        //Known local formats
        iFormats=0;

        for (i=0;i<(int )nFormats;i++) {
            if (pTmp[j] == pVCMData[i]->dwFormatTag) {
                //Ok, add the registry size, if we don't have it listed
                bKnown=FALSE;
                for (k=0;k<iFormats;k++) {
                    if (g_aVCMAppInfo[j].framesize[k].biWidth == pVCMData[i]->video_params.biWidth &&
                        g_aVCMAppInfo[j].framesize[k].biHeight == pVCMData[i]->video_params.biHeight ) {

                        bKnown=TRUE;
                        break;
                    }
                }
                if (!bKnown) {
                    iOffset=pVCMData[i]->video_params.enumVideoSize;
                    g_aVCMAppInfo[j].framesize[iOffset].biWidth = (WORD)pVCMData[i]->video_params.biWidth;
                    g_aVCMAppInfo[j].framesize[iOffset].biHeight = (WORD)pVCMData[i]->video_params.biHeight;
                    iFormats++;
                }
            }
        }

    }

    //Now, build the DCAP_APP_INFO ptr

    //Max * is #entries * MAX_NUM_REGISTERED_SIZES
    if (!(pTmpFrame = (MYFRAMESIZE *)MemAlloc ((g_nNumVCMAppInfoEntries*MAX_NUM_REGISTERED_SIZES)*sizeof (DWORD)))) {
        //Aiiie!
        MemFree (pTmp);
        ERRORMESSAGE (("vcmFillGlobalsFromRegistry: Memory Allocation Failed!\r\n"));
        return FALSE;
    }

    iFormats=0;

    for (j=0;j<g_nNumVCMAppInfoEntries;j++) {

        //Magic # of frame sizes per format
        for (k=0;k < MAX_NUM_REGISTERED_SIZES;k++) {
            bKnown=FALSE;
            for (i=0;i<iFormats;i++) {
                if ( (g_aVCMAppInfo[j].framesize[k].biWidth == pTmpFrame[i].biWidth &&
                    g_aVCMAppInfo[j].framesize[k].biHeight == pTmpFrame[i].biHeight)
					|| (!g_aVCMAppInfo[j].framesize[k].biWidth && !g_aVCMAppInfo[j].framesize[k].biHeight) ){
                    bKnown=TRUE;
                    break;
                }
            }
            if (!bKnown) {
                    pTmpFrame[iFormats].biWidth  = g_aVCMAppInfo[j].framesize[k].biWidth;
                    pTmpFrame[iFormats++].biHeight = g_aVCMAppInfo[j].framesize[k].biHeight;
            }
        }
    }

    g_nNumFrameSizesEntries=iFormats;

    //Free up the ReadRegistryEntries memory...
    for (i=0;i<(int) nFormats; i++) {
        MemFree (pVCMNames[i]);
        MemFree (pVCMData[i]);
    }

    MemFree (pVCMNames);
    MemFree (pVCMData);

    MemFree (pTmp);
    MemFree (pTmpFrame);

    return TRUE;
}


/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmFormatEnum | The <f vcmFormatEnum> function
 *      enumerates video formats available. The <f vcmFormatEnum>
 *      function continues enumerating until there are no more suitable
 *      formats for the format tag or the callback function returns FALSE.
 *
 *  @parm UINT | uDevice | Specifies the capture device ID.
 *
 *  @parm VCMFORMATENUMCB | fnCallback | Specifies the procedure-instance
 *      address of the application-defined callback function.
 *
 *  @parm PVCMDRIVERDETAILS | pvdd | Specifies a pointer to the
 *      <t VCMDRIVERDETAILS> structure that is to receive the driver details
 *      passed to the <p fnCallback> function.
 *
 *  @parm PVCMFORMATDETAILS | pvfd | Specifies a pointer to the
 *      <t VCMFORMATDETAILS> structure that is to receive the format details
 *      passed to the <p fnCallback> function. This structure must have the
 *      <e VCMFORMATDETAILS.cbStruct>, <e VCMFORMATDETAILS.pvfx>, and
 *      <e VCMFORMATDETAILS.cbvfx> members of the <t VCMFORMATDETAILS>
 *      structure initialized. The <e VCMFORMATDETAILS.dwFormatTag> member
 *      must also be initialized to either VIDEO_FORMAT_UNKNOWN or a
 *      valid format tag.
 *
 *  @parm DWORD | dwInstance | Specifies a 32-bit, application-defined value
 *      that is passed to the callback function along with VCM format details.
 *
 *  @parm DWORD | fdwEnum | Specifies flags for enumerating formats that can be
 *      generated, or formats that can be decompressed.
 *
 *      @flag VCM_FORMATENUMF_INPUT | Specifies that the format enumeration should only
 *      return the video formats that can be transmitted.
 *
 *      @flag VCM_FORMATENUMF_OUTPUT | Specifies that the format enumeration should only
 *      return the video formats that can be received.
 *
 *      @flag VCM_FORMATENUMF_BOTH | Specifies that the format enumeration should
 *      return the video formats that can be received and transmitted.
 *
 *      @flag VCM_FORMATENUMF_APP | Specifies that the format enumeration should
 *      enumerate only video formats known to the application
 *
 *      @flag VCM_FORMATENUMF_ALL | Specifies that the format enumeration should
 *      enumerate all video formats known to VCM
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *      @flag MMSYSERR_NOMEM | A memory allocation failed.
 *      @flag MMSYSERR_BADDEVICEID | Specified device device ID is invalid.
 *      @flag VCMERR_NOTPOSSIBLE | The details for the format cannot be
 *      returned.
 *
 *  @comm The <f vcmFormatEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no suitable VCM drivers are installed. Moreover, the
 *      callback function will not be called.
 *
 *  @xref <f vcmFormatEnumCallback>
 ***************************************************************************/
MMRESULT VCMAPI vcmFormatEnum(	UINT uDevice, VCMFORMATENUMCB fnCallback, PVCMDRIVERDETAILS pvdd,
								PVCMFORMATDETAILS pvfd, DWORD_PTR dwInstance, DWORD fdwEnum)
{
	int				i, j, k, l, m;
	HIC				hIC;
	ICINFO			ICinfo;
	BITMAPINFO		bmi;
	DWORD			dw;
	char			szBuffer[BUFFER_SIZE]; // Could be smaller.
	int				iLen;
	VIDEOINCAPS		vic;
	PDEJAVU			pdvDejaVuCurr, pdvDejaVu;
	BOOL			bDejaVu, fUnsupportedInputSize, fUnsupportedBitDepth;
	DWORD			fccHandler;
	int				iNumCaps = 0; // Num of valid caps into the advDejaVu matrix


	// Check input params
	if (!pvdd)
	{
		ERRORMESSAGE(("vcmFormatEnum: Specified pointer is invalid, pvdd=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvfd)
	{
		ERRORMESSAGE(("vcmFormatEnum: Specified pointer is invalid, pvfd=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!(VCM_FORMATENUMF_TYPEMASK & fdwEnum))
	{
		ERRORMESSAGE(("vcmFormatEnum: Specified mask is invalid, fdwEnum=0x%lX\r\n", fdwEnum));
		return ((MMRESULT)MMSYSERR_INVALFLAG);
	}
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmFormatEnum: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}

    //Build the system VCM globals
    if (!vcmFillGlobalsFromRegistry ())
	{
        ERRORMESSAGE (("vcmFormatEnum, couldn't build formats from registry\r\n"));
        return (VCMERR_NOTPOSSIBLE);
    }

	// We need to remember what we have already enumerated
	// The formats already enumerated are stored in the following matrix
	if (!(pdvDejaVu = (PDEJAVU)MemAlloc(g_nNumFrameSizesEntries *
	                                        NUM_BITDEPTH_ENTRIES *
	                                        NUM_FPS_ENTRIES * sizeof(DEJAVU))))
	{
		ERRORMESSAGE(("vcmFormatEnum: A memory allocation failed\r\n"));
		return ((MMRESULT)MMSYSERR_NOMEM);
	}

	// If we enumerate formats we can generate, they need to be in sync with what
	// the capture hardware can actually produce, that is RGB4, RGB8, RGB16, RGB24, YUY2, UYVY, YVU9, I420 or IYUV.
	if ((fdwEnum & VCM_FORMATENUMF_INPUT) || (fdwEnum & VCM_FORMATENUMF_BOTH))
	{
		if (vcmGetDevCaps(uDevice, &vic, sizeof(VIDEOINCAPS)) != MMSYSERR_NOERROR)
		{
			if (fdwEnum & VCM_FORMATENUMF_INPUT)
				return ((MMRESULT)MMSYSERR_NOERROR);
			else
				fdwEnum = VCM_FORMATENUMF_OUTPUT;
		}
	}

	// We're asked to enumerate all the formats that this machine can render or transmit.
	// We can send or render all the RGB formats, in which case they will not be
	// compressed/decompressed, but directly transmitted/rendered by the UI. But still, someone needs
	// to enumerate these. This is done here.
	// We, of course, also enumerate the formats that we can decompress and the ones we can generate.
	bmi.bmiHeader.biSize			= sizeof(BITMAPINFOHEADER);
	bmi.bmiHeader.biPlanes			= 1;
	bmi.bmiHeader.biCompression		= BI_RGB;
	bmi.bmiHeader.biXPelsPerMeter	= 0;
	bmi.bmiHeader.biYPelsPerMeter	= 0;
	bmi.bmiHeader.biClrUsed			= 0;
	bmi.bmiHeader.biClrImportant	= 0;


	// Now enumerate real compressors
	// for (i=0; ICInfo(ICTYPE_VIDEO, i, &ICinfo); i++) == NO GOOD:
	// We need to enumerate everything and then filter on
	// the value of fccHandler, because some codecs will fail to
	// enum entirely if the fccType parameter to ICInfo is non null.
	// SOMEONE should be shot...
	for (i=0; AppICInfo(0, i, &ICinfo, fdwEnum); i++, iNumCaps = 0)
	{
		// Get the details of the ICINFO structure
		if ((ICinfo.fccType == ICTYPE_VIDEO)  && (ICInfo(ICinfo.fccType, ICinfo.fccHandler, &ICinfo)))
		{
			// Make fccHandler uppercase and back it up
			if (ICinfo.fccHandler > 256)
				CharUpperBuff((LPTSTR)&ICinfo.fccHandler, sizeof(DWORD));
			fccHandler = ICinfo.fccHandler;

			// If the client returns FALSE we need to terminate the enumeration process
			if (hIC = ICOpen(ICinfo.fccType, ICinfo.fccHandler, ICMODE_QUERY))
			{
				// Enable H.26x codecs
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
				if ((ICinfo.fccHandler == VIDEO_FORMAT_MSH263) || (ICinfo.fccHandler == VIDEO_FORMAT_MSH261) || (ICinfo.fccHandler == VIDEO_FORMAT_MSH26X))
#else
				if ((ICinfo.fccHandler == VIDEO_FORMAT_MSH263) || (ICinfo.fccHandler == VIDEO_FORMAT_MSH261))
#endif
#else
				if ((ICinfo.fccHandler == VIDEO_FORMAT_DECH263) || (ICinfo.fccHandler == VIDEO_FORMAT_DECH261))
#endif
					ICSendMessage(hIC, CUSTOM_ENABLE_CODEC, G723MAGICWORD1, G723MAGICWORD2);

				ICGetInfo(hIC, &ICinfo, sizeof(ICINFO));
				// The VDEC codec sets the fccType to the same
				// value than the fccHandler! Correct that hereticism:
				if ((ICinfo.fccType == VIDEO_FORMAT_VDEC) && (ICinfo.fccHandler == VIDEO_FORMAT_VDEC))
					ICinfo.fccType = ICTYPE_VIDEO;

				// Restore fccHandler
				ICinfo.fccHandler = fccHandler;

				// VCMDRIVERDETAILS and ICINFO are identical structures
				CopyMemory(pvdd, &ICinfo, sizeof(VCMDRIVERDETAILS));

				// For all the built-in sizes we support
				for (l=0; l<MAX_NUM_REGISTERED_SIZES; l++)
				{
					if ((g_aVCMAppInfo[i].framesize[l].biWidth != 0) && (g_aVCMAppInfo[i].framesize[l].biHeight != 0))
					{
						fUnsupportedInputSize = FALSE;

#ifndef NO_LARGE_SIZE_EXCLUSION_HACK
// HACK for version 2
// Since we didn't get general scaling code into version 2, we want to disable the largest size
// if the capture device doesn't support it.  Otherwise we'll put a smaller size into the middle
// of a large black field which looks ugly.  For version 3, we should be able to add the general
// scaling code and remove this hack.

                        if (l == MAX_NUM_REGISTERED_SIZES-1) {
                            // find largest size supported by capture device
                            // NOTE: we assume that the bit definitions for sizes are sorted
                            for (k = VIDEO_FORMAT_NUM_RESOLUTIONS-1; k >= 0 && !(g_awResolutions[k].dwRes & vic.dwImageSize); k--)
                            {}

                            // if we don't find a size, or the size is not greater than half the current size
                            // then mark the size as not supported
                            if ((k < 0) ||
                                (g_awResolutions[k].framesize.biWidth <= (LONG)g_aVCMAppInfo[i].framesize[l].biWidth/2) ||
                                (g_awResolutions[k].framesize.biHeight <= (LONG)g_aVCMAppInfo[i].framesize[l].biHeight/2)) {
                                // capture doesn't support this size
                                if (fdwEnum & VCM_FORMATENUMF_INPUT)
                        			continue;   // we're done
                                else if (fdwEnum & VCM_FORMATENUMF_BOTH)
                        			fUnsupportedInputSize = TRUE;
                        	}
                        }
#endif

						// The new capture stuff can generate data at any size
						bmi.bmiHeader.biWidth  = (LONG)g_aVCMAppInfo[i].framesize[l].biWidth;
						bmi.bmiHeader.biHeight = (LONG)g_aVCMAppInfo[i].framesize[l].biHeight;

						// For all the bit depths we support
						for (k=0; k<NUM_BITDEPTH_ENTRIES; k++)
						{
							// Try the non-RGB formats only if no RGB format
							fUnsupportedBitDepth = FALSE;

							if (((fdwEnum & VCM_FORMATENUMF_INPUT)  || (fdwEnum & VCM_FORMATENUMF_BOTH)) && !((g_aiNumColors[k] & vic.dwNumColors)))
								fUnsupportedBitDepth = TRUE;

							if ((fdwEnum & VCM_FORMATENUMF_INPUT) && fUnsupportedBitDepth)
								goto NextCompressedBitDepth;

							// Set the direction flag appropriately
							if (fdwEnum & VCM_FORMATENUMF_OUTPUT)
								pvfd->dwFlags = VCM_FORMATENUMF_OUTPUT;
							else if (fdwEnum & VCM_FORMATENUMF_INPUT)
								pvfd->dwFlags = VCM_FORMATENUMF_INPUT;
							else if (fdwEnum & VCM_FORMATENUMF_BOTH)
							{
								if (fUnsupportedInputSize || fUnsupportedBitDepth)
									pvfd->dwFlags = VCM_FORMATENUMF_OUTPUT;
								else
									pvfd->dwFlags = VCM_FORMATENUMF_BOTH;
							}

							bmi.bmiHeader.biBitCount      = (WORD)g_aiBitDepth[k];
							bmi.bmiHeader.biCompression   = g_aiFourCCCode[k];
							bmi.bmiHeader.biSizeImage     = (DWORD)WIDTHBYTES(bmi.bmiHeader.biWidth * bmi.bmiHeader.biBitCount) * bmi.bmiHeader.biHeight;

							// Check if the compressor supports the format
							if (ICCompressQuery(hIC, &bmi, (LPBITMAPINFOHEADER)NULL) == ICERR_OK)
							{
								// Now get the size required to hold the format
								dw = ICCompressGetFormatSize(hIC, &bmi);
								// PHILF's BUGBUG: pvfd->cbvfx is the size of the whole structure, not the bitmap info header
								if ((dw >= sizeof(BITMAPINFOHEADER)) && (dw <= pvfd->cbvfx))
								{
									if (ICCompressGetFormat(hIC, &bmi, &pvfd->pvfx->bih) == ICERR_OK)
									{
										// Check if it has alreay been enumerated
										for (m=0, bDejaVu=FALSE, pdvDejaVuCurr = pdvDejaVu; m<iNumCaps; m++, pdvDejaVuCurr++)
										{
											bDejaVu = (!((pdvDejaVuCurr->vfx.bih.biWidth != pvfd->pvfx->bih.biWidth)
											|| (pdvDejaVuCurr->vfx.bih.biHeight != pvfd->pvfx->bih.biHeight)
											|| (pdvDejaVuCurr->vfx.bih.biBitCount != pvfd->pvfx->bih.biBitCount)
											|| (pdvDejaVuCurr->vfx.bih.biCompression != pvfd->pvfx->bih.biCompression)));

											if (bDejaVu)
											{
												// Only remember the maximum compressed size
												if (pdvDejaVuCurr->vfx.bih.biSizeImage < pvfd->pvfx->bih.biSizeImage)
													pdvDejaVuCurr->vfx.bih.biSizeImage = pvfd->pvfx->bih.biSizeImage;
												break;
											}
										}
										if (!bDejaVu)
										{
											// Add new format to the list of DejaVus
											CopyMemory(&(pdvDejaVu + iNumCaps)->vfx, pvfd->pvfx, sizeof(VIDEOFORMATEX));
											(pdvDejaVu + iNumCaps)->dwFlags = pvfd->dwFlags;

											// Update count of caps
											iNumCaps++;

										}
										else
											if ((pvfd->dwFlags == VCM_FORMATENUMF_BOTH) && ((pdvDejaVu + m)->dwFlags != VCM_FORMATENUMF_BOTH))
												(pdvDejaVu + m)->dwFlags = VCM_FORMATENUMF_BOTH;
									}
								}
							}
	NextCompressedBitDepth:;
						}
					}
				}
				ICClose(hIC);

				// For all the caps we have found
				for (m=0; m<iNumCaps; m++)
				{
					// For all the frame rates we support
					for (j=0; j<NUM_FPS_ENTRIES; j++)
					{
						// Copy the cap and flags
						CopyMemory(pvfd->pvfx, &(pdvDejaVu + m)->vfx, sizeof(VIDEOFORMATEX));
						pvfd->dwFlags = (pdvDejaVu + m)->dwFlags;
						// Update rest of the fields
						pvfd->pvfx->nSamplesPerSec = g_aiFps[j];
						pvfd->pvfx->wBitsPerSample = pvfd->pvfx->bih.biBitCount;
#if 0
						if (pvfd->pvfx->bih.biCompression > 256)
						{
							CharUpperBuff((LPTSTR)&pvfd->pvfx->bih.biCompression, sizeof(DWORD));
							pvdd->fccHandler = pvfd->dwFormatTag = pvfd->pvfx->dwFormatTag = pvfd->pvfx->bih.biCompression;
						}
						else
#endif
							pvfd->pvfx->dwFormatTag = pvfd->dwFormatTag = pvdd->fccHandler;
						pvfd->pvfx->nAvgBytesPerSec = pvfd->pvfx->nMinBytesPerSec = pvfd->pvfx->nMaxBytesPerSec = pvfd->pvfx->nSamplesPerSec * pvfd->pvfx->bih.biSizeImage;
						pvfd->pvfx->nBlockAlign = pvfd->pvfx->bih.biSizeImage;
						// The following fields should probably not be modified...
						pvfd->pvfx->dwRequestMicroSecPerFrame = 1000000L / g_aiFps[j];
						pvfd->pvfx->dwPercentDropForError = 10UL;
						// pvfd->pvfx->dwNumVideoRequested = 2UL;
						pvfd->pvfx->dwNumVideoRequested = g_aiFps[j];
						pvfd->pvfx->dwSupportTSTradeOff = 1UL;
						pvfd->pvfx->bLive = TRUE;
						pvfd->pvfx->dwFormatSize = sizeof(VIDEOFORMATEX);

						// Copy the palette if there is one
						if (pvfd->pvfx->wBitsPerSample == 4)
						{	
                            pvfd->pvfx->bih.biClrUsed = 0;
                            if (vic.dwFlags & VICF_4BIT_TABLE) {
    							// Copy the 16 color palette
	    						CopyMemory(&pvfd->pvfx->bihSLOP[0], &vic.bmi4bitColors[0], NUM_4BIT_ENTRIES * sizeof(RGBQUAD));
	    						pvfd->pvfx->bih.biClrUsed = 16;
	    				    }
						}
						else if (pvfd->pvfx->wBitsPerSample == 8)
						{
                            pvfd->pvfx->bih.biClrUsed = 0;
                            if (vic.dwFlags & VICF_8BIT_TABLE) {
    							// Copy the 256 color palette
	    						CopyMemory(&pvfd->pvfx->bihSLOP[0], &vic.bmi8bitColors[0], NUM_8BIT_ENTRIES * sizeof(RGBQUAD));
	    						pvfd->pvfx->bih.biClrUsed = 256;
	    				    }
						}

						if (pvdd->fccHandler > 256)
							wsprintf(szBuffer, IDS_FORMAT_1, (LPSTR)&pvdd->fccType, (LPSTR)&pvdd->fccHandler,
									pvfd->pvfx->bih.biBitCount, pvfd->pvfx->nSamplesPerSec,
									pvfd->pvfx->bih.biWidth, pvfd->pvfx->bih.biHeight);
						else
							wsprintf(szBuffer, IDS_FORMAT_2, (LPSTR)&pvdd->fccType, pvdd->fccHandler,
									pvfd->pvfx->bih.biBitCount, pvfd->pvfx->nSamplesPerSec,
									pvfd->pvfx->bih.biWidth, pvfd->pvfx->bih.biHeight);
						iLen = MultiByteToWideChar(GetACP(), 0, szBuffer, -1, pvfd->szFormat, 0);
						MultiByteToWideChar(GetACP(), 0, szBuffer, -1, pvfd->szFormat, iLen);
						if (!((* fnCallback)((HVCMDRIVERID)hIC, pvdd, pvfd, dwInstance)))
							break;
					}
				}
			}
		}
	}

	// Free table of capabilities
	if (pdvDejaVu)
  	    MemFree((HANDLE)pdvDejaVu);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmFormatSuggest | This function asks the Video Compression Manager
 *      (VCM) or a specified VCM driver to suggest a destination format for
 *      the supplied source format, or the recommended source format for a supplied destination
 *      format. For example, an application can use this function to determine one or more
 *      valid RGB formats to which a compressed format can be decompressed.
 *
 *  @parm UINT | uDevice | Identifies the capture device ID.
 *
 *  @parm HVCMDRIVER | hvd | Identifies an optional open instance of a
 *      driver to query for a suggested destination format. If this
 *      argument is NULL, the VCM attempts to find the best driver to suggest
 *      a destination format or a source format.
 *
 *  @parm PVIDEOFORMATEX | pvfxSrc | Specifies a pointer to a <t VIDEOFORMATEX>
 *      structure that identifies the source format to suggest a destination
 *      format to be used for a conversion, or that will receive the suggested
 *      source format for the <p pvfxDst> format. Note
 *      that based on the <p fdwSuggest> argument, some members of the structure
 *      pointed to by <p pvfxSrc> may require initialization.
 *
 *  @parm PVIDEOFORMATEX | pvfxDst | Specifies a pointer to a <t VIDEOFORMATEX>
 *      data structure that will receive the suggested destination format
 *      for the <p pvfxSrc> format, or that identifies the destination format to
 *      suggest a recommended source format to be used for a conversion. Note
 *      that based on the <p fdwSuggest> argument, some members of the structure
 *      pointed to by <p pvfxDst> may require initialization.
 *
 *  @parm DWORD | cbvfxDst | Specifies the size in bytes available for
 *      the destination, or the source format. The <f vcmMetrics>
 *      functions can be used to determine the maximum size required for any
 *      format available for the specified driver (or for all installed VCM
 *      drivers).
 *
 *  @parm DWORD | fdwSuggest | Specifies flags for matching the desired
 *      destination format, or source format.
 *
 *      @flag VCM_FORMATSUGGESTF_DST_WFORMATTAG | Specifies that the
 *      <e VIDEOFORMATEX.dwFormatTag> member of the <p pvfxDst> structure is
 *      valid. The VCM will query acceptable installed drivers that can
 *      use the <p pvfxSrc> structure as their source format and output a
 *      destination format matching the <e VIDEOFORMATEX.dwFormatTag>
 *      member, or fail. The <p pvfxDst> structure is updated with the complete
 *      destination format.
 *
 *      @flag VCM_FORMATSUGGESTF_DST_NSAMPLESPERSEC | Specifies that the
 *      <e VIDEOFORMATEX.nSamplesPerSec> member of the <p pvfxDst> structure
 *      is valid. The VCM will query acceptable installed drivers that can
 *      use the <p pvfxSrc> structure as their source format and output a
 *      destination format matching the <e VIDEOFORMATEX.nSamplesPerSec>
 *      member, or fail. The <p pvfxDst> structure is updated with the complete
 *      destination format.
 *
 *      @flag VCM_FORMATSUGGESTF_DST_WBITSPERSAMPLE | Specifies that the
 *      <e VIDEOFORMATEX.wBitsPerSample> member of the <p pvfxDst> structure
 *      is valid. The VCM will query acceptable installed drivers that can
 *      use the <p pvfxSrc> structure as their source format and output a
 *      destination format matching the <e VIDEOFORMATEX.wBitsPerSample>
 *      member, or fail. The <p pvfxDst> structure is updated with the complete
 *      destination format.
 *
 *      @flag VCM_FORMATSUGGESTF_SRC_WFORMATTAG | Specifies that the
 *      <e VIDEOFORMATEX.dwFormatTag> member of the <p pvfxSrc> structure is
 *      valid. The VCM will query acceptable installed drivers that can
 *      use the <p pvfxDst> structure as their destination format and accept a
 *      source format matching the <e VIDEOFORMATEX.dwFormatTag>
 *      member, or fail. The <p pvfxSrc> structure is updated with the complete
 *      source format.
 *
 *      @flag VCM_FORMATSUGGESTF_SRC_NSAMPLESPERSEC | Specifies that the
 *      <e VIDEOFORMATEX.nSamplesPerSec> member of the <p pvfxSrc> structure
 *      is valid. The VCM will query acceptable installed drivers that can
 *      use the <p pvfxDst> structure as their destination format and accept a
 *      source format matching the <e VIDEOFORMATEX.nSamplesPerSec>
 *      member or fail. The <p pvfxSrc> structure is updated with the complete
 *      source format.
 *
 *      @flag VCM_FORMATSUGGESTF_SRC_WBITSPERSAMPLE | Specifies that the
 *      <e VIDEOFORMATEX.wBitsPerSample> member of the <p pvfxSrc> structure
 *      is valid. The VCM will query acceptable installed drivers that can
 *      use the <p pvfxDst> structure as their destination format and accept a
 *      source format matching the <e VIDEOFORMATEX.wBitsPerSample>
 *      member, or fail. The <p pvfxSrc> structure is updated with the complete
 *      source format.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_NOTSUPPORTED | One or more of the restriction bits is not supported.
 *
 *      @flag MMSYSERR_NODRIVER | No capture device driver or device is present.
 *
 *  @devnote PhilF: For now, only the VCM_FORMATSUGGESTF_DST_WFORMATTAG and VCM_FORMATSUGGESTF_SRC_WFORMATTAG
 *      are supported. The other flags are just ignored. Add real support for other flags
 *      if  they would really make a difference. But for the two current Data Pump calls,
 *      they don't influence the outcome of the call.
 *
 *      The cbvfxDst is never used. Should we still pass it? How can I make a good use of it?
 *
 *      Should there also be cbvfxSrc parameter?
 *
 *      This function is used to determine what should the (source) capture format of the capture
 *      device be in order to generate a specific compressed destination format.
 *      Now, there are two possibilities. Either we can directly capture at a frame size
 *      identical to the one in the <p pvfxDst> structure, or we can't, but still, once compressed
 *      the output frame has the same size than the one in the <p pvfxDst> structure.
 *      Typical example: Greyscale QuickCam. If the output format were set to 128x96 (SQCIF)
 *      and we were to try capturing directly at this size, this would fail, since 128x96
 *      is not supported by the hardware. On the other hand, if we capture at 160x120,
 *      the codec will truncate to 128x96. Now, how can we figure this out programmatically?
 *      For now, the next largest size is ASSUMED to be truncatable by the codec to the right size.
 *      This needs to be actually run through the codec for validation. Fix that.
 *
 *      If the capture driver capture with a format that is not RGB, this call will fail to suggest
 *      a valid source format and will return MMSYSERR_NODRIVER. Fix that.
 *
 *  @xref <f vcmMetrics> <f vcmFormatEnum>
 ***************************************************************************/
MMRESULT VCMAPI vcmFormatSuggest(UINT uDevice, HVCMDRIVER hvd, PVIDEOFORMATEX pvfxSrc, PVIDEOFORMATEX pvfxDst, DWORD cbvfxDst, DWORD fdwSuggest)
{
	DWORD		dwSize;
	MMRESULT	mmr;
	WORD		wFlags;
	HIC			hIC;
	DWORD		fdwSuggestL;
	DWORD		dwFormatTag;
	VIDEOINCAPS	vic;
	int			i, delta, best, tmp;

#define VCM_FORMAT_SUGGEST_SUPPORT VCM_FORMATSUGGESTF_TYPEMASK

	// Check input params
	if (!pvfxSrc)
	{
		ERRORMESSAGE(("vcmFormatSuggest: Specified pointer is invalid, pvfxSrc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvfxDst)
	{
		ERRORMESSAGE(("vcmFormatSuggest: Specified pointer is invalid, pvfxSrc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmFormatSuggest: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}

	// Grab the suggestion restriction bits and verify that we support
	// the ones that are specified
	fdwSuggestL = (VCM_FORMATSUGGESTF_TYPEMASK & fdwSuggest);

	if (~VCM_FORMAT_SUGGEST_SUPPORT & fdwSuggestL)
	{
		ERRORMESSAGE(("vcmFormatSuggest: Specified mask is invalid, fdwSuggest=0x%lX\r\n", fdwSuggest));
		return ((MMRESULT)MMSYSERR_NOTSUPPORTED);
	}

	// Get the size of the largest bitmap info header
	if (((mmr = vcmMetrics((HVCMOBJ)NULL, VCM_METRIC_MAX_SIZE_BITMAPINFOHEADER, &dwSize)) == MMSYSERR_NOERROR) && (dwSize >= sizeof(BITMAPINFOHEADER)))
	{
		if (fdwSuggest & VCM_FORMATSUGGESTF_DST_WFORMATTAG)
		{
			if (pvfxSrc->bih.biCompression == BI_RGB)
			{
				if (pvfxDst->bih.biCompression == BI_RGB)
				{
					// Input and output format are uncompressed
					CopyMemory(pvfxDst, pvfxSrc, pvfxSrc->dwFormatSize);
					return ((MMRESULT)MMSYSERR_NOERROR);
				}
				else
				{
					wFlags = ICMODE_COMPRESS;
					dwFormatTag = pvfxDst->dwFormatTag;
				}
			}
			else
			{
				wFlags = ICMODE_DECOMPRESS;
				dwFormatTag = pvfxSrc->dwFormatTag;
			}

#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
			if ((dwFormatTag == VIDEO_FORMAT_MSH263) || (dwFormatTag == VIDEO_FORMAT_MSH261) || (dwFormatTag == VIDEO_FORMAT_MSH26X))
#else
			if ((dwFormatTag == VIDEO_FORMAT_MSH263) || (dwFormatTag == VIDEO_FORMAT_MSH261))
#endif
#else
			if ((dwFormatTag == VIDEO_FORMAT_DECH263) || (dwFormatTag == VIDEO_FORMAT_DECH261))
#endif
			{
				hIC = ICOpen(VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC, dwFormatTag, wFlags);

				if (hIC && (wFlags == ICMODE_COMPRESS))
					ICSendMessage(hIC, CUSTOM_ENABLE_CODEC, G723MAGICWORD1, G723MAGICWORD2);
			}
			else
				hIC = ICLocate(VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC, dwFormatTag, (LPBITMAPINFOHEADER)&pvfxSrc->bih, (LPBITMAPINFOHEADER)NULL, wFlags);

			if (hIC)
			{
				if (wFlags == ICMODE_COMPRESS)
				{
					// Now get the size required to hold the format
					dwSize = ICCompressGetFormatSize(hIC, &pvfxSrc->bih);
					if ((dwSize >= sizeof(BITMAPINFOHEADER)) && (dwSize <= cbvfxDst))
					{
						if (ICCompressGetFormat(hIC, &pvfxSrc->bih, &pvfxDst->bih) == ICERR_OK)
						{
							pvfxDst->nSamplesPerSec = pvfxSrc->nSamplesPerSec;
							pvfxDst->wBitsPerSample = pvfxDst->bih.biBitCount;
							pvfxDst->dwFormatTag = pvfxDst->bih.biCompression;
							pvfxDst->nAvgBytesPerSec = pvfxDst->nMinBytesPerSec = pvfxDst->nMaxBytesPerSec = pvfxDst->nSamplesPerSec * pvfxDst->bih.biSizeImage;
							pvfxDst->nBlockAlign = pvfxDst->bih.biSizeImage;
							// The following fields should probably not be modified...
							pvfxDst->dwRequestMicroSecPerFrame = pvfxSrc->dwRequestMicroSecPerFrame;
							pvfxDst->dwPercentDropForError = pvfxSrc->dwPercentDropForError;
							pvfxDst->dwNumVideoRequested = pvfxSrc->dwNumVideoRequested;
							pvfxDst->dwSupportTSTradeOff = pvfxSrc->dwSupportTSTradeOff;
							pvfxDst->bLive = pvfxSrc->bLive;
							pvfxDst->dwFormatSize = sizeof(VIDEOFORMATEX);
						}
					}
				}
				else
				{
					// Now get the size required to hold the format
					dwSize = ICDecompressGetFormatSize(hIC, &pvfxSrc->bih);
					if ((dwSize >= sizeof(BITMAPINFOHEADER)) && (dwSize <= cbvfxDst))
					{
						if (ICDecompressGetFormat(hIC, &pvfxSrc->bih, &pvfxDst->bih) == ICERR_OK)
						{
							pvfxDst->nSamplesPerSec = pvfxSrc->nSamplesPerSec;
							pvfxDst->wBitsPerSample = pvfxDst->bih.biBitCount;
							pvfxDst->dwFormatTag = pvfxDst->bih.biCompression;
							pvfxDst->nAvgBytesPerSec = pvfxDst->nMinBytesPerSec = pvfxDst->nMaxBytesPerSec = pvfxDst->nSamplesPerSec * pvfxDst->bih.biSizeImage;
							pvfxDst->nBlockAlign = pvfxDst->bih.biSizeImage;
							pvfxDst->dwRequestMicroSecPerFrame = pvfxSrc->dwRequestMicroSecPerFrame;
							// The following fields should probably not be modified...
							pvfxDst->dwRequestMicroSecPerFrame = pvfxSrc->dwRequestMicroSecPerFrame;
							pvfxDst->dwPercentDropForError = pvfxSrc->dwPercentDropForError;
							pvfxDst->dwNumVideoRequested = pvfxSrc->dwNumVideoRequested;
							pvfxDst->dwSupportTSTradeOff = pvfxSrc->dwSupportTSTradeOff;
							pvfxDst->bLive = pvfxSrc->bLive;
							pvfxDst->dwFormatSize = sizeof(VIDEOFORMATEX);
						}
					}
				}
				ICClose(hIC);
			}
		}
		else if (fdwSuggest & VCM_FORMATSUGGESTF_SRC_WFORMATTAG)
		{

			// In case only the format tag was initialized, copy it to the biCompression field
			pvfxSrc->bih.biCompression = pvfxSrc->dwFormatTag;

			if (pvfxSrc->bih.biCompression == BI_RGB)
			{
				if (pvfxDst->bih.biCompression == BI_RGB)
				{
					// Input and output format are uncompressed
					CopyMemory(pvfxSrc, pvfxDst, pvfxDst->dwFormatSize);
					return ((MMRESULT)MMSYSERR_NOERROR);
				}
				else
				{
					wFlags = ICMODE_COMPRESS;
					dwFormatTag = pvfxDst->dwFormatTag;
				}
			}
			else
			{
				if (pvfxDst->bih.biCompression == BI_RGB)
				{
					wFlags = ICMODE_DECOMPRESS;
					dwFormatTag = pvfxSrc->dwFormatTag;
				}
				else
				{
					wFlags = ICMODE_COMPRESS;
					dwFormatTag = pvfxDst->dwFormatTag;
				}
			}

			if (wFlags == ICMODE_COMPRESS)
			{
				// Now, there are two possibilities. Either we can directly capture at a frame size
				// identical to the one in the pvfxDst structure, or we can't, but once compressed
				// the output frame has the same size than the one in the pvfxDst structure.
				// Typical example, Greyscale QuickCam. If the output format were set to 128x96 (SQCIF)
				// and we were to try capturing directly at this size, this would fail, since 128x96
				// is not supported by the hardware. On the other hand, if we capture at 160x120,
				// the codec will truncate to 128x96. Now, how can we figure this out programmatically?

				// The color and greyscale capability field will let us know what bit depth to use.
				// We should probably have a field that also says which bit depth is preferred in the
				// case more than one are supported. For now, assume the priority order is: 16, 24, 4, 8
				if ((mmr = vcmGetDevCaps(uDevice, &vic, sizeof(VIDEOINCAPS))) != MMSYSERR_NOERROR)
					return (mmr);

                if (vic.dwImageSize & VIDEO_FORMAT_IMAGE_SIZE_USE_DEFAULT) {
               		ERRORMESSAGE(("vcmFormatSuggest: suggest using default\r\n"));
               		return ((MMRESULT)MMSYSERR_NOTSUPPORTED);
                }

				CopyMemory(&pvfxSrc->bih, &pvfxDst->bih, sizeof(BITMAPINFOHEADER));

				// Assume the next resolution will be correctly truncated to the output size
				best = -1;
				delta = 999999;
				for (i=0; i<VIDEO_FORMAT_NUM_RESOLUTIONS; i++) {
					if (g_awResolutions[i].dwRes & vic.dwImageSize) {
						tmp = g_awResolutions[i].framesize.biWidth - pvfxDst->bih.biWidth;
						if (tmp < 0) tmp = -tmp;
						if (tmp < delta) {
							delta = tmp;
							best = i;
						}
						tmp = g_awResolutions[i].framesize.biHeight - pvfxDst->bih.biHeight;
						if (tmp < 0) tmp = -tmp;
						if (tmp < delta) {
							delta = tmp;
							best = i;
						}
					}
				}
        		if (best < 0) {
                    ERRORMESSAGE(("vcmFormatSuggest: no available formats\r\n"));
                    return ((MMRESULT)MMSYSERR_NOTSUPPORTED);
        		}
				// Actually, you don't have to assume it will work. You can directly ask the codec
				// is this would work...
				pvfxSrc->bih.biWidth = g_awResolutions[best].framesize.biWidth;
				pvfxSrc->bih.biHeight = g_awResolutions[best].framesize.biHeight;

				// Now, we assume that the captured format is an RGB format. Once in place, you should
				// verify this from the capability set of the capture device.
				if (pvfxSrc->bih.biSize != sizeof(BITMAPINFOHEADER))
					pvfxSrc->bih.biSize = sizeof(BITMAPINFOHEADER);

				// If the capture hardware does not support RGB, we need to use its compressed format
				for (i=0; i<NUM_BITDEPTH_ENTRIES; i++)
				{
					if (vic.dwNumColors & g_aiNumColors[i])
					{
						pvfxSrc->bih.biBitCount = (WORD)g_aiBitDepth[i];
						pvfxSrc->bih.biCompression = g_aiFourCCCode[i];
						break;
					}
				}
				
				// Copy the palette if there is one
				if (pvfxSrc->bih.biBitCount == 4)
				{	
        			pvfxSrc->bih.biClrUsed = 0;
                    if (vic.dwFlags & VICF_4BIT_TABLE) {
						// Copy the 16 color palette
						CopyMemory(&pvfxSrc->bihSLOP[0], &vic.bmi4bitColors[0], NUM_4BIT_ENTRIES * sizeof(RGBQUAD));
   						pvfxSrc->bih.biClrUsed = 16;
				    }
				}
				else if (pvfxSrc->bih.biBitCount == 8)
				{
        			pvfxSrc->bih.biClrUsed = 0;
                    if (vic.dwFlags & VICF_8BIT_TABLE) {
						// Copy the 256 color palette
						CopyMemory(&pvfxSrc->bihSLOP[0], &vic.bmi8bitColors[0], NUM_8BIT_ENTRIES * sizeof(RGBQUAD));
   						pvfxSrc->bih.biClrUsed = 256;
				    }
				}

				pvfxSrc->bih.biSizeImage = WIDTHBYTES(pvfxSrc->bih.biWidth * pvfxSrc->bih.biBitCount) * pvfxSrc->bih.biHeight;
			}
			else
			{
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
				if ((dwFormatTag == VIDEO_FORMAT_MSH263) || (dwFormatTag == VIDEO_FORMAT_MSH261) || (dwFormatTag == VIDEO_FORMAT_MSH26X))
#else
				if ((dwFormatTag == VIDEO_FORMAT_MSH263) || (dwFormatTag == VIDEO_FORMAT_MSH261))
#endif
#else
				if ((dwFormatTag == VIDEO_FORMAT_DECH263) || (dwFormatTag == VIDEO_FORMAT_DECH261))
#endif
					hIC = ICOpen(VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC, dwFormatTag, wFlags);
				else
					hIC = ICLocate(VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC, dwFormatTag, (LPBITMAPINFOHEADER)&pvfxSrc->bih, (LPBITMAPINFOHEADER)NULL, wFlags);

				if (hIC)
				{
					// Now get the size required to hold the format
					dwSize = ICDecompressGetFormatSize(hIC, &pvfxSrc->bih);
					if ((dwSize >= sizeof(BITMAPINFOHEADER)) && (dwSize <= cbvfxDst))
					{
						if (ICDecompressGetFormat(hIC, &pvfxSrc->bih, &pvfxDst->bih) == ICERR_OK)
						{
							pvfxSrc->nSamplesPerSec = pvfxSrc->nSamplesPerSec;
							pvfxSrc->wBitsPerSample = pvfxDst->bih.biBitCount;
							pvfxSrc->dwFormatTag = pvfxDst->bih.biCompression;
							pvfxDst->nAvgBytesPerSec = pvfxDst->nMinBytesPerSec = pvfxDst->nMaxBytesPerSec = pvfxDst->nSamplesPerSec * pvfxDst->bih.biSizeImage;
							pvfxDst->nBlockAlign = pvfxDst->bih.biSizeImage;
							pvfxDst->dwRequestMicroSecPerFrame = pvfxSrc->dwRequestMicroSecPerFrame;
							// The following fields should probably not be modified...
							pvfxDst->dwRequestMicroSecPerFrame = pvfxSrc->dwRequestMicroSecPerFrame;
							pvfxDst->dwPercentDropForError = pvfxSrc->dwPercentDropForError;
							pvfxDst->dwNumVideoRequested = pvfxSrc->dwNumVideoRequested;
							pvfxDst->dwSupportTSTradeOff = pvfxSrc->dwSupportTSTradeOff;
							pvfxDst->bLive = pvfxSrc->bLive;
							pvfxDst->dwFormatSize = sizeof(VIDEOFORMATEX);
						}
					}
    				ICClose(hIC);
				}
			}
		}
	}

	return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamOpen | The vcmStreamOpen function opens a Video Compression
 *      Manager (VCM) conversion stream. Conversion streams are used to convert data from
 *      one specified video format to another.
 *
 *  @parm PHVCMSTREAM | phvs | Specifies a pointer to a <t HVCMSTREAM>
 *      handle that will receive the new stream handle that can be used to
 *      perform conversions. Use this handle to identify the stream
 *      when calling other VCM stream conversion functions. This parameter
 *      should be NULL if the VCM_STREAMOPENF_QUERY flag is specified.
 *
 *  @parm HVCMDRIVER | hvd | Specifies an optional handle to a VCM driver.
 *      If specified, this handle identifies a specific driver to be used
 *      for a conversion stream. If this argument is NULL, then all suitable
 *      installed VCM drivers are queried until a match is found.
 *
 *  @parm PVIDEOFORMATEX | pvfxSrc | Specifies a pointer to a <t VIDEOFORMATEX>
 *      structure that identifies the desired source format for the
 *      conversion.
 *
 *  @parm PVIDEOFORMATEX | pvfxDst | Specifies a pointer to a <t VIDEOFORMATEX>
 *      structure that identifies the desired destination format for the
 *      conversion.
 *
 * @parm DWORD | dwImageQuality | Specifies an image quality value (between 0
 *      and 31. The lower number indicates a high spatial quality at a low frame
 *      rate, the larger number indiocates a low spatial quality at a high frame
 *      rate.
 *
 *  @parm DWORD | dwCallback | Specifies the address of a callback function
 *      or a handle to a window called after each buffer is converted. A
 *      callback will only be called if the conversion stream is opened with
 *      the VCM_STREAMOPENF_ASYNC flag. If the conversion stream is opened
 *     without the CCM_STREAMOPENF_ASYNC flag, then this parameter should
 *     be set to zero.
 *
 *  @parm DWORD | dwInstance | Specifies user-instance data passed on to the
 *      callback specified by <p dwCallback>. This argument is not used with
 *      window callbacks. If the conversion stream is opened without the
 *     VCM_STREAMOPENF_ASYNC flag, then this parameter should be set to zero.
 *
 *  @parm DWORD | fdwOpen | Specifies flags for opening the conversion stream.
 *
 *      @flag VCM_STREAMOPENF_QUERY | Specifies that the VCM will be queried
 *      to determine whether it supports the given conversion. A conversion
 *      stream will not be opened and no <t HVCMSTREAM> handle will be
 *      returned.
 *
 *      @flag VCM_STREAMOPENF_NONREALTIME | Specifies that the VCM will not
 *      consider time constraints when converting the data. By default, the
 *      driver will attempt to convert the data in real time. Note that for
 *      some formats, specifying this flag might improve the video quality
 *      or other characteristics.
 *
 *      @flag VCM_STREAMOPENF_ASYNC | Specifies that conversion of the stream should
 *      be performed asynchronously. If this flag is specified, the application
 *      can use a callback to be notified on open and close of the conversion
 *      stream, and after each buffer is converted. In addition to using a
 *      callback, an application can examine the <e VCMSTREAMHEADER.fdwStatus>
 *      of the <t VCMSTREAMHEADER> structure for the VCMSTREAMHEADER_STATUSF_DONE
 *      flag.
 *
 *      @flag CALLBACK_WINDOW | Specifies that <p dwCallback> is assumed to
 *      be a window handle.
 *
 *      @flag CALLBACK_FUNCTION | Specifies that <p dwCallback> is assumed to
 *      be a callback procedure address. The function prototype must conform
 *      to the <f vcmStreamConvertCallback> convention.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_NOMEM | Unable to allocate resources.
 *
 *      @flag VCMERR_NOTPOSSIBLE | The requested operation cannot be performed.
 *
 *  @comm Note that if a VCM driver cannot perform real-time conversions,
 *      and the VCM_STREAMOPENF_NONREALTIME flag is not specified for
 *      the <p fdwOpen> argument, the open will fail returning an
 *      VCMERR_NOTPOSSIBLE error code. An application can use the
 *      VCM_STREAMOPENF_QUERY flag to determine if real-time conversions
 *      are supported for the input arguments.
 *
 *    If a window is chosen to receive callback information, the
 *      following messages are sent to the window procedure function to
 *      indicate the progress of the conversion stream: <m MM_VCM_OPEN>,
 *      <m MM_VCM_CLOSE>, and <m MM_VCM_DONE>. The <p wParam>  parameter identifies
 *      the <t HVCMSTREAM> handle. The <p lParam>  parameter identifies the
 *      <t VCMSTREAMHEADER> structure for <m MM_VCM_DONE>, but is not used
 *      for <m MM_VCM_OPEN> and <m MM_VCM_CLOSE>.
 *
 *      If a function is chosen to receive callback information, the
 *      following messages are sent to the function to indicate the progress
 *      of output: <m MM_VCM_OPEN>, <m MM_VCM_CLOSE>, and
 *      <m MM_VCM_DONE>. The callback function must reside in a DLL. You do
 *      not need to use <f MakeProcInstance> to get a procedure-instance
 *      address for the callback function.
 *
 *  @xref <f vcmStreamClose> <f vcmStreamConvert>
 *      <f vcmFormatSuggest> <f vcmStreamConvertCallback>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamOpen(PHVCMSTREAM phvs, HVCMDRIVER hvd, PVIDEOFORMATEX pvfxSrc, PVIDEOFORMATEX pvfxDst, DWORD dwImageQuality, DWORD dwPacketSize, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
{
	MMRESULT			mmr;
	DWORD				dwFlags;
	DWORD				fccHandler;
	HIC					hIC;
	VIDEOFORMATEX		*pvfxS;
	VIDEOFORMATEX		*pvfxD;
	BITMAPINFOHEADER	*pbmiPrev;		// Pointer to reconstructed frame bitmap info header (for now assume it is the same than the input format...)
	ICINFO				icInfo;
	PVOID				pvState;		// Pointer to codec configuration information
	DWORD				dw;				// Size of codec configuration information or destination BITAMPINFO
	ICCOMPRESSFRAMES	iccf = {0};			// Structure used to set compression parameters
	PMSH26XCOMPINSTINFO	pciMSH26XInfo;	// Pointer to MS H26X configuration information
#ifdef USE_MPEG4_SCRUNCH
	PMPEG4COMPINSTINFO	pciMPEG4Info;	// Pointer to MPEG4 Scrunch configuration information
#endif

	// Check input params
	if (!pvfxSrc)
	{
		ERRORMESSAGE(("vcmStreamOpen: Specified pointer is invalid, pvfxSrc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvfxDst)
	{
		ERRORMESSAGE(("vcmStreamOpen: Specified pointer is invalid, pvfxSrc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvfxSrc->dwFormatSize)
	{
		ERRORMESSAGE(("vcmStreamOpen: Specified format size is invalid, pvfxSrc->dwFormatSize=%ld\r\n", pvfxSrc->dwFormatSize));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvfxDst->dwFormatSize)
	{
		ERRORMESSAGE(("vcmStreamOpen: Specified format size is invalid, pvfxDst->dwFormatSize=%ld\r\n", pvfxDst->dwFormatSize));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if ((dwImageQuality < VCM_MIN_IMAGE_QUALITY) || (dwImageQuality > VCM_MAX_IMAGE_QUALITY))
		dwImageQuality = VCM_DEFAULT_IMAGE_QUALITY;

	// Set default values
	*phvs = (HVCMSTREAM)NULL;

	// Are we compressing of decompressing?
	if (pvfxSrc->bih.biCompression == BI_RGB)
	{
		dwFlags = ICMODE_COMPRESS;
		fccHandler = (DWORD)pvfxDst->bih.biCompression;
	}
	else
	{
		if (pvfxDst->bih.biCompression == BI_RGB)
		{
			dwFlags = ICMODE_DECOMPRESS;
			fccHandler = (DWORD)pvfxSrc->bih.biCompression;
		}
		else
		{
			dwFlags = ICMODE_COMPRESS;
			fccHandler = (DWORD)pvfxDst->bih.biCompression;
		}
	}

	// Get a handle to the compressor/decompressor
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
	if ((fccHandler == VIDEO_FORMAT_MSH263) || (fccHandler == VIDEO_FORMAT_MSH261) || (fccHandler == VIDEO_FORMAT_MSH26X))
#else
	if ((fccHandler == VIDEO_FORMAT_MSH263) || (fccHandler == VIDEO_FORMAT_MSH261))
#endif
#else
	if ((fccHandler == VIDEO_FORMAT_DECH263) || (fccHandler == VIDEO_FORMAT_DECH261))
#endif
	{
		hIC = ICOpen(VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC, fccHandler, (WORD)dwFlags);
		if (hIC && (dwFlags == ICMODE_COMPRESS))
			ICSendMessage(hIC, CUSTOM_ENABLE_CODEC, G723MAGICWORD1, G723MAGICWORD2);
	}
	else
		hIC = ICLocate(VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC, fccHandler, (LPBITMAPINFOHEADER)&pvfxSrc->bih, (LPBITMAPINFOHEADER)&pvfxDst->bih, (WORD)dwFlags);

	if (hIC)
	{
		// Get info about this compressor
		ICGetInfo(hIC, &icInfo, sizeof(ICINFO));

		// Allocate VCM stream structure
		if (!(*phvs = (HVCMSTREAM)MemAlloc(sizeof(VCMSTREAM))))
		{
			ERRORMESSAGE(("vcmStreamOpen: Memory allocation of a VCM stream structure failed\r\n"));
			mmr = (MMRESULT)MMSYSERR_NOMEM;
			goto MyExit0;
		}
		else
		{
			((PVCMSTREAM)(*phvs))->hIC = (HVCMDRIVER)hIC;
			((PVCMSTREAM)(*phvs))->dwICInfoFlags = icInfo.dwFlags;
			((PVCMSTREAM)(*phvs))->dwQuality = dwImageQuality;
			((PVCMSTREAM)(*phvs))->dwMaxPacketSize = dwPacketSize;
			((PVCMSTREAM)(*phvs))->dwFrame = 0L;
			// For now, issue a key frame every 15 seconds
			((PVCMSTREAM)(*phvs))->dwLastIFrameTime = GetTickCount();
			((PVCMSTREAM)(*phvs))->fPeriodicIFrames = TRUE;
			((PVCMSTREAM)(*phvs))->dwCallback = dwCallback;
			((PVCMSTREAM)(*phvs))->dwCallbackInstance = dwInstance;
			((PVCMSTREAM)(*phvs))->fdwOpen = fdwOpen;
			((PVCMSTREAM)(*phvs))->fdwStream = dwFlags;
			((PVCMSTREAM)(*phvs))->dwLastTimestamp = ULONG_MAX;


			// We need the following crs to make sure we don't miss any of the I-Frame requests
			// emittted by the UI. Problematic scenario: pvs->dwFrame is at 123 for instance.
			// The UI thread requests an I-Frame by setting pvs->dwFrame. If the capture/compression
			// thread was in ICCompress() (which is very probable since it takes quite some time
			// to compress a frame), pvs->dwFrame will be incremented by one when ICCompress()
			// returns. We failed to handle the I-Frame request correctly, since the next time
			// ICCompress() gets called pvs->dwFrame will be equal to 1, for which we do not
			// generate an I-Frame.
			if ((dwFlags == ICMODE_COMPRESS) || (dwFlags == ICMODE_FASTCOMPRESS))	// Hmmm... where could you have set the second mode?
				InitializeCriticalSection(&(((PVCMSTREAM)(*phvs))->crsFrameNumber));

			// Allocate the video formats
			if (!(pvfxS = (VIDEOFORMATEX *)MemAlloc(pvfxSrc->dwFormatSize)))
			{
				ERRORMESSAGE(("vcmStreamOpen: Memory allocation of source video format failed\r\n"));
				mmr = (MMRESULT)MMSYSERR_NOMEM;
				goto MyExit1;
			}
			else
			{
				if (!(pvfxD = (VIDEOFORMATEX *)MemAlloc(pvfxDst->dwFormatSize)))
				{
					ERRORMESSAGE(("vcmStreamOpen: Memory allocation of destination video format failed\r\n"));
					mmr = (MMRESULT)MMSYSERR_NOMEM;
					goto MyExit2;
				}
				else
				{	// This is naive. You need to query the codec for its decompressed format size and data
					if (!(pbmiPrev = (BITMAPINFOHEADER *)MemAlloc(sizeof(BITMAPINFOHEADER))))
					{
						ERRORMESSAGE(("vcmStreamOpen: Memory allocation of previous video frame failed\r\n"));
						mmr = (MMRESULT)MMSYSERR_NOMEM;
						goto MyExit3;
					}
					else
					{
						CopyMemory(((PVCMSTREAM)(*phvs))->pvfxSrc = pvfxS, pvfxSrc, pvfxSrc->dwFormatSize);
						CopyMemory(((PVCMSTREAM)(*phvs))->pvfxDst = pvfxD, pvfxDst, pvfxDst->dwFormatSize);
						CopyMemory(((PVCMSTREAM)(*phvs))->pbmiPrev = pbmiPrev, &pvfxSrc->bih, sizeof(BITMAPINFOHEADER));
					}
				}
			}

			if ((dwFlags == ICMODE_COMPRESS) || (dwFlags == ICMODE_FASTCOMPRESS))	// Hmmm... where could you have set the second mode?
			{
				// Get the state of the compressor
				if (dw = ICGetStateSize(hIC))
				{
					if (!(pvState = (PVOID)MemAlloc(dw)))
					{
						ERRORMESSAGE(("vcmStreamOpen: Memory allocation of codec configuration information structure failed\r\n"));
						mmr = (MMRESULT)MMSYSERR_NOMEM;
						goto MyExit4;
					}
					if (((DWORD) ICGetState(hIC, pvState, dw)) != dw)
					{
						ERRORMESSAGE(("vcmStreamOpen: ICGetState() failed\r\n"));
						mmr = (MMRESULT)VCMERR_FAILED;
						goto MyExit5;
					}
				}

				// Do any of the stuff that is MS H.263 or MS H.261 specific right here
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
				if ((pvfxDst->bih.biCompression == VIDEO_FORMAT_MSH263) || (pvfxDst->bih.biCompression == VIDEO_FORMAT_MSH261) || (pvfxDst->bih.biCompression == VIDEO_FORMAT_MSH26X))
#else
				if ((pvfxDst->bih.biCompression == VIDEO_FORMAT_MSH263) || (pvfxDst->bih.biCompression == VIDEO_FORMAT_MSH261))
#endif
#else
				if ((pvfxDst->bih.biCompression == VIDEO_FORMAT_DECH263) || (pvfxDst->bih.biCompression == VIDEO_FORMAT_DECH261))
#endif
				{
					pciMSH26XInfo = (PMSH26XCOMPINSTINFO)pvState;

					// Really configure the codec for compression
					pciMSH26XInfo->Configuration.bRTPHeader = TRUE;
					pciMSH26XInfo->Configuration.unPacketSize = ((PVCMSTREAM)(*phvs))->dwMaxPacketSize;
					pciMSH26XInfo->Configuration.bEncoderResiliency = FALSE;
					pciMSH26XInfo->Configuration.unPacketLoss = 0;
					// PhilF-: Make this work on the alpha
#ifndef _ALPHA_
					pciMSH26XInfo->Configuration.bBitRateState = TRUE;
#else
					pciMSH26XInfo->Configuration.bBitRateState = FALSE;
#endif
					pciMSH26XInfo->Configuration.unBytesPerSecond = 1664;
					if (((DWORD) ICSetState(hIC, (PVOID)pciMSH26XInfo, dw)) != dw)
					{
						ERRORMESSAGE(("vcmStreamOpen: ICSetState() failed\r\n"));
						mmr = (MMRESULT)VCMERR_FAILED;
						goto MyExit5;
					}

					// Get rid of the state structure
					MemFree((HANDLE)pvState);
				}
#ifdef USE_MPEG4_SCRUNCH
				else if ((pvfxDst->bih.biCompression == VIDEO_FORMAT_MPEG4_SCRUNCH))
				{
					pciMPEG4Info = (PMPEG4COMPINSTINFO)pvState;

					// Configure the codec for compression
					pciMPEG4Info->lMagic = MPG4_STATE_MAGIC;
					pciMPEG4Info->dDataRate = 20;
					pciMPEG4Info->lCrisp = CRISP_DEF;
					pciMPEG4Info->lKeydist = 30;
					pciMPEG4Info->lPScale = MPG4_PSEUDO_SCALE;
					pciMPEG4Info->lTotalWindowMs = MPG4_TOTAL_WINDOW_DEFAULT;
					pciMPEG4Info->lVideoWindowMs = MPG4_VIDEO_WINDOW_DEFAULT;
					pciMPEG4Info->lFramesInfoValid = FALSE;
					pciMPEG4Info->lBFrameOn = MPG4_B_FRAME_ON;
					pciMPEG4Info->lLiveEncode = MPG4_LIVE_ENCODE;
					if (((DWORD) ICSetState(hIC, (PVOID)pciMPEG4Info, dw)) != dw)
					{
						ERRORMESSAGE(("vcmStreamOpen: ICSetState() failed\r\n"));
						mmr = (MMRESULT)VCMERR_FAILED;
						goto MyExit5;
					}

					// Get rid of the state structure
					MemFree((HANDLE)pvState);
				}
#endif

				// Initialize ICCOMPRESSFRAMES structure
				iccf.dwFlags = icInfo.dwFlags;
				((PVCMSTREAM)(*phvs))->dwQuality = dwImageQuality;
				iccf.lQuality = 10000UL - (dwImageQuality * 322UL);
				iccf.lDataRate = 1664;			// Look into this...
				iccf.lKeyRate = LONG_MAX;
				iccf.dwRate = 1000UL;
#ifdef USE_MPEG4_SCRUNCH
				iccf.dwScale = 142857;
#else
				iccf.dwScale = pvfxDst->dwRequestMicroSecPerFrame / 1000UL;
#endif
				((PVCMSTREAM)(*phvs))->dwTargetFrameRate = iccf.dwScale;
				((PVCMSTREAM)(*phvs))->dwTargetByterate = iccf.lDataRate;

				// Send this guy to the compressor
				if ((mmr = ICSendMessage(hIC, ICM_COMPRESS_FRAMES_INFO, (DWORD_PTR)&iccf, sizeof(iccf)) != ICERR_OK))
				{
					ERRORMESSAGE(("vcmStreamOpen: Codec failed to handle ICM_COMPRESS_FRAMES_INFO message correctly\r\n"));
					mmr = (MMRESULT)VCMERR_FAILED;
					goto MyExit4;
				}

				// Start the compressor/decompressor with the right format
				if ((dw = ICCompressGetFormatSize(hIC, &pvfxSrc->bih) < sizeof(BITMAPINFOHEADER)))
				{
					ERRORMESSAGE(("vcmStreamOpen: Codec failed to answer request for compressed format size\r\n"));
					mmr = (MMRESULT)VCMERR_FAILED;
					goto MyExit4;
				}

				// BUG_BUG: Where has pvfxDst been re-allocated ???
				if ((dw = (DWORD)ICCompressGetFormat(hIC, &pvfxSrc->bih, &pvfxD->bih)) != ICERR_OK)
				{
					ERRORMESSAGE(("vcmStreamOpen: Codec failed to answer request for compressed format\r\n"));
					mmr = (MMRESULT)VCMERR_FAILED;
					goto MyExit4;
				}

				if ((mmr = (MMRESULT)ICCompressBegin(hIC, &pvfxSrc->bih, &pvfxD->bih)) != MMSYSERR_NOERROR)
				{
					ERRORMESSAGE(("vcmStreamOpen: Codec failed to start\r\n"));
					mmr = (MMRESULT)VCMERR_FAILED;
					goto MyExit4;
				}

				DEBUGMSG (1, ("vcmStreamOpen: Opening %.4s compression stream\r\n", (LPSTR)&pvfxDst->bih.biCompression));

				// Update the passed destination video format. The caller really needs to use
				// that information to allocate the buffer sizes appropriately.
				CopyMemory(pvfxDst, pvfxD, sizeof(VIDEOFORMATEX));

				// Here, you can probably get the size of the compressed frames and update the destination format
				// with the real size of the compressed video buffer so that the DP can allocate the right set
				// of video buffers.

			}
			else if ((dwFlags == ICMODE_DECOMPRESS) || (dwFlags == ICMODE_FASTDECOMPRESS))
			{
				if (mmr = ICDecompressBegin(hIC, &pvfxSrc->bih, &pvfxDst->bih) != MMSYSERR_NOERROR)
				{
					ERRORMESSAGE(("vcmStreamOpen: Codec failed to start\r\n"));
					mmr = (MMRESULT)VCMERR_FAILED;
					goto MyExit4;
				}

				DEBUGMSG (1, ("vcmStreamOpen: Opening %.4s decompression stream\r\n", (LPSTR)&pvfxSrc->bih.biCompression));

#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
				if ((pvfxSrc->bih.biCompression == VIDEO_FORMAT_MSH263) || (pvfxSrc->bih.biCompression == VIDEO_FORMAT_MSH261) || (pvfxSrc->bih.biCompression == VIDEO_FORMAT_MSH26X))
#else
				if ((pvfxSrc->bih.biCompression == VIDEO_FORMAT_MSH263) || (pvfxSrc->bih.biCompression == VIDEO_FORMAT_MSH261))
#endif
#else
				if ((pvfxSrc->bih.biCompression == VIDEO_FORMAT_DECH263) || (pvfxSrc->bih.biCompression == VIDEO_FORMAT_DECH261))
#endif
					vcmStreamMessage(*phvs, CUSTOM_ENABLE_CODEC, G723MAGICWORD1, G723MAGICWORD2);
			}

		}

#ifdef LOGFILE_ON
		if ((dwFlags == ICMODE_COMPRESS) || (dwFlags == ICMODE_FASTCOMPRESS))
		{
			if ((g_CompressLogFile = CreateFile("C:\\VCMCLog.txt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
			{
    			GetLocalTime(&g_SystemTime);
				wsprintf(g_szCompressBuffer, "Date %hu/%hu/%hu, Time %hu:%hu\r\n", g_SystemTime.wMonth, g_SystemTime.wDay, g_SystemTime.wYear, g_SystemTime.wHour, g_SystemTime.wMinute);
				WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
				wsprintf(g_szCompressBuffer, "Frame#\t\tSize\t\tArrival Time\t\tCompression Time\r\n");
				WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
				CloseHandle(g_CompressLogFile);
			}
		}
		else if ((dwFlags == ICMODE_DECOMPRESS) || (dwFlags == ICMODE_FASTDECOMPRESS))
		{
			if ((g_DecompressLogFile = CreateFile("C:\\VCMDLog.txt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
			{
    			GetLocalTime(&g_SystemTime);
				wsprintf(g_szDecompressBuffer, "Date %hu/%hu/%hu, Time %hu:%hu\r\n", g_SystemTime.wMonth, g_SystemTime.wDay, g_SystemTime.wYear, g_SystemTime.wHour, g_SystemTime.wMinute);
				WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
				wsprintf(g_szDecompressBuffer, "Frame#\t\tSize\t\tArrival Time\t\tDecompression Time\r\n");
				WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
				CloseHandle(g_DecompressLogFile);
			}
		}
#endif

		return ((MMRESULT)MMSYSERR_NOERROR);

	}
	else
		return ((MMRESULT)VCMERR_NOTPOSSIBLE);

MyExit5:
	if (pvState)
		MemFree(pvState);
MyExit4:
	if (pbmiPrev)
		MemFree(pbmiPrev);
MyExit3:
	if (pvfxD)
		MemFree(pvfxD);
MyExit2:
	if (pvfxS)
		MemFree(pvfxS);
MyExit1:
	if ((dwFlags == ICMODE_COMPRESS) || (dwFlags == ICMODE_FASTCOMPRESS))	// Hmmm... where could you have set the second mode?
		DeleteCriticalSection(&(((PVCMSTREAM)(*phvs))->crsFrameNumber));
	if (*phvs)
		MemFree(*phvs);
	*phvs = (HVCMSTREAM)(PVCMSTREAM)NULL;
MyExit0:
	return (mmr);

}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamClose | The vcmStreamClose function closes a previously
 *      opened Video Compression Manager (VCM) conversion stream. If the function is
 *      successful, the handle is invalidated.
 *
 *  @parm HVCMSTREAM | hvs | Identifies the open conversion stream to be closed.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag VCMERR_BUSY | The conversion stream cannot be closed because
 *      an asynchronous conversion is still in progress.
 *
 *  @xref <f vcmStreamOpen> <f vcmStreamReset>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamClose(HVCMSTREAM hvs)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;
#ifdef LOGFILE_ON
	DWORD		i;
#endif

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamClose: Specified HVCMSTREAM handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	// Stop the compressor/decompressor
	if ((pvs->fdwStream == ICMODE_COMPRESS) || (pvs->fdwStream == ICMODE_FASTCOMPRESS))
	{
#ifdef LOGFILE_ON
		g_OrigCompressTime = GetTickCount() - g_OrigCompressTime;
		if (pvs->dwFrame)
		{
			for (i=0, g_AvgCompressTime=0; i<pvs->dwFrame && i<4096; i++)
				g_AvgCompressTime += g_aCompressTime[i];
			g_AvgCompressTime /= i;
		}
		if ((g_CompressLogFile = CreateFile("C:\\VCMCLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
		{
			SetFilePointer(g_CompressLogFile, 0, NULL, FILE_END);
			if (pvs->dwFrame)
			{
				wsprintf(g_szCompressBuffer, "Frames/s\tAvg. Comp. Time\r\n");
				WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
				wsprintf(g_szCompressBuffer, "%04d\t\t%03d\r\n", pvs->dwFrame * 1000 / g_OrigCompressTime, g_AvgCompressTime);
				WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
			}
			else
			{
				wsprintf(g_szCompressBuffer, "No frames were compressed!");
				WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
			}
			CloseHandle(g_CompressLogFile);
		}
#endif
		if (ICCompressEnd((HIC)pvs->hIC) != MMSYSERR_NOERROR)
		{
			ERRORMESSAGE(("vcmStreamClose: Codec failed to stop\r\n"));
			return ((MMRESULT)VCMERR_FAILED);
		}
	}
	else if ((pvs->fdwStream == ICMODE_DECOMPRESS) || (pvs->fdwStream == ICMODE_FASTDECOMPRESS))
	{
#ifdef LOGFILE_ON
		g_OrigDecompressTime = GetTickCount() - g_OrigDecompressTime;
		if (pvs->dwFrame)
		{
			for (i=0, g_AvgDecompressTime=0; i<pvs->dwFrame && i<4096; i++)
				g_AvgDecompressTime += g_aDecompressTime[i];
			g_AvgDecompressTime /= i;
		}
		if ((g_DecompressLogFile = CreateFile("C:\\VCMDLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
		{
			SetFilePointer(g_DecompressLogFile, 0, NULL, FILE_END);
			if (pvs->dwFrame)
			{
				wsprintf(g_szDecompressBuffer, "Frames/s\tAvg. Decomp. Time\r\n");
				WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
				wsprintf(g_szDecompressBuffer, "%04d\t\t%03d\r\n", pvs->dwFrame * 1000 / g_OrigDecompressTime, g_AvgDecompressTime);
				WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
			}
			else
			{
				wsprintf(g_szDecompressBuffer, "No frames were decompressed!");
				WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
			}
			CloseHandle(g_DecompressLogFile);
		}
#endif
		if (ICDecompressEnd((HIC)pvs->hIC) != MMSYSERR_NOERROR)
		{
			ERRORMESSAGE(("vcmStreamClose: Codec failed to stop\r\n"));
			return ((MMRESULT)VCMERR_FAILED);
		}
	}

	// Close compressor/decompressor
	if (pvs->hIC)
		ICClose((HIC)pvs->hIC);

	// Nuke critical section
	if ((pvs->fdwStream == ICMODE_COMPRESS) || (pvs->fdwStream == ICMODE_FASTCOMPRESS))
		DeleteCriticalSection(&pvs->crsFrameNumber);

	// Free video format buffers
	if (pvs->pvfxSrc)
		MemFree(pvs->pvfxSrc);
	if (pvs->pvfxDst)
		MemFree(pvs->pvfxDst);
	if (pvs->pbmiPrev)
		MemFree(pvs->pbmiPrev);

	// Free main VCM structure
	MemFree(pvs);
	
	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamSize | The vcmStreamSize function returns a recommended size for a
 *      source or destination buffer on an Video Compression Manager (VCM)
 *      stream.
 *
 *  @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 *  @parm DWORD | cbInput | Specifies the size in bytes of either the source
 *      or destination buffer. The <p fdwSize> flags specify what the
 *      input argument defines. This argument must be non-zero.
 *
 *  @parm LPDWORD | pdwOutputBytes | Specifies a pointer to a <t DWORD>
 *      that contains the size in bytes of the source or destination buffer.
 *      The <p fdwSize> flags specify what the output argument defines.
 *      If the <f vcmStreamSize> function succeeds, this location will
 *      always be filled with a non-zero value.
 *
 *  @parm DWORD | fdwSize | Specifies flags for the stream-size query.
 *
 *      @flag VCM_STREAMSIZEF_SOURCE | Indicates that <p cbInput> contains
 *      the size of the source buffer. The <p pdwOutputBytes> argument will
 *      receive the recommended destination buffer size in bytes.
 *
 *      @flag VCM_STREAMSIZEF_DESTINATION | Indicates that <p cbInput>
 *      contains the size of the destination buffer. The <p pdwOutputBytes>
 *      argument will receive the recommended source buffer size in bytes.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *      @flag VCMERR_NOTPOSSIBLE | The requested operation cannot be performed.
 *
 *  @comm An application can use the <f vcmStreamSize> function to determine
 *      suggested buffer sizes for either source or destination buffers.
 *      The buffer sizes returned might be only an estimation of the
 *      actual sizes required for conversion. Because actual conversion
 *      sizes cannot always be determined without performing the conversion,
 *      the sizes returned will usually be overestimated.
 *
 *      In the event of an error, the location pointed to by
 *      <p pdwOutputBytes> will receive zero. This assumes that the pointer
 *      specified by <p pdwOutputBytes> is valid.
 *
 *  @xref <f vcmStreamPrepareHeader> <f vcmStreamConvert>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSize(HVCMSTREAM hvs, DWORD cbInput, PDWORD pdwOutputBytes, DWORD fdwSize)
{
	PVCMSTREAM  pvs = (PVCMSTREAM)hvs;
	DWORD    dwNumFrames;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamSize: Specified HVCMSTREAM handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	// Do the math
	switch (VCM_STREAMSIZEF_QUERYMASK & fdwSize)
	{
		case VCM_STREAMSIZEF_SOURCE:
			if (pvs->pvfxSrc->dwFormatTag != VIDEO_FORMAT_BI_RGB)
			{
				// How many destination RGB bytes are needed to hold the decoded source
				// buffer of cbInput compressed bytes
				if (!(dwNumFrames = cbInput / pvs->pvfxSrc->nBlockAlign))
				{
					ERRORMESSAGE(("vcmStreamSize: The requested operation cannot be performed\r\n"));
					return ((MMRESULT)VCMERR_NOTPOSSIBLE);
				}
				else
					*pdwOutputBytes = dwNumFrames * pvs->pvfxDst->nBlockAlign;
			}
			else
			{
				// How many destination compressed bytes are needed to hold the encoded	source
				// buffer of cbInput RGB bytes
				if (!(dwNumFrames = cbInput / pvs->pvfxSrc->nBlockAlign))
				{
					ERRORMESSAGE(("vcmStreamSize: The requested operation cannot be performed\r\n"));
					return ((MMRESULT)VCMERR_NOTPOSSIBLE);
				}
				else
				{
					if (cbInput % pvs->pvfxSrc->nBlockAlign)
						dwNumFrames++;
					*pdwOutputBytes = dwNumFrames * pvs->pvfxDst->nBlockAlign;
				}
			}
			return ((MMRESULT)MMSYSERR_NOERROR);

		case VCM_STREAMSIZEF_DESTINATION:
			if (pvs->pvfxDst->dwFormatTag != VIDEO_FORMAT_BI_RGB)
			{
				// How many source RGB bytes can be encoded into a destination buffer
				// of cbInput bytes
				if (!(dwNumFrames = cbInput / pvs->pvfxDst->nBlockAlign))
				{
					ERRORMESSAGE(("vcmStreamSize: The requested operation cannot be performed\r\n"));
					return ((MMRESULT)VCMERR_NOTPOSSIBLE);
				}
				else
					*pdwOutputBytes = dwNumFrames * pvs->pvfxSrc->nBlockAlign;
			}
			else
			{
				// How many source encoded bytes can be decoded into a destination buffer
				// of cbInput RGB bytes
				if (!(dwNumFrames = cbInput / pvs->pvfxDst->nBlockAlign))
				{
					ERRORMESSAGE(("vcmStreamSize: The requested operation cannot be performed\r\n"));
					return ((MMRESULT)VCMERR_NOTPOSSIBLE);
				}
				else
					*pdwOutputBytes = dwNumFrames * pvs->pvfxSrc->nBlockAlign;
			}
			return ((MMRESULT)MMSYSERR_NOERROR);

		default:
					ERRORMESSAGE(("vcmStreamSize: One or more flags are invalid\r\n"));
			return ((MMRESULT)MMSYSERR_NOTSUPPORTED);
	}

}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamReset | The vcmStreamReset function stops conversions
 *      for a given Video Compression Manager (VCM) stream. All pending
 *      buffers are marked as done and returned to the application.
 *
 *  @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *  @comm Resetting a VCM conversion stream is only necessary to reset
 *      asynchronous conversion streams. However, resetting a synchronous
 *      conversion stream will succeed, but no action will be taken.
 *
 *  @xref <f vcmStreamConvert> <f vcmStreamClose>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamReset(HVCMSTREAM hvs)
{
	PVCMSTREAM        pvs = (PVCMSTREAM)hvs;
	PVCMSTREAMHEADER  pvsh;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmSreamReset: Specified HVCMSTREAM handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	while (pvsh = DeQueVCMHeader(pvs))
	{
		MarkVCMHeaderDone(pvsh);
		// Look into how this would be best handled
		// What if the capture driver sends us those exact same
		// messages for its own buffers?

		// Test for the validity of the callback before doing this...
		switch (pvs->fdwOpen)
		{
			case CALLBACK_FUNCTION:
				(*(VCMSTREAMPROC)pvs->dwCallback)(hvs, VCM_DONE, pvs->dwCallbackInstance, (DWORD_PTR)pvsh, 0);
				break;

			case CALLBACK_EVENT:
				SetEvent((HANDLE)pvs->dwCallback);
				break;

			case CALLBACK_WINDOW:
				PostMessage((HWND)pvs->dwCallback, MM_VCM_DONE, (WPARAM)hvs, (LPARAM)pvsh);
				break;

			case CALLBACK_THREAD:
				PostThreadMessage((DWORD)pvs->dwCallback, MM_VCM_DONE, (WPARAM)hvs, (LPARAM)pvsh);
				break;

			case CALLBACK_NULL:
				break;

			default:
				break;
		}
	}

	pvs->pvhFirst = NULL;
	pvs->pvhLast = NULL;

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamMessage | This function sends a user-defined
 *      message to a given Video Compression Manager (VCM) stream instance.
 *
 *  @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 *  @parm UINT | uMsg | Specifies the message that the VCM stream must
 *      process. This message must be in the <m VCMDM_USER> message range
 *      (above or equal to <m VCMDM_USER> and less than
 *      <m VCMDM_RESERVED_LOW>). The exception to this restriction is
 *      the <m VCMDM_STREAM_UPDATE> message.
 *
 *  @parm LPARAM | lParam1 | Specifies the first message parameter.
 *
 *  @parm LPARAM | lParam2 | Specifies the second message parameter.
 *
 *  @rdesc The return value is specific to the user-defined VCM driver
 *      message <p uMsg> sent. However, the following return values are
 *      possible:
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *      @flag MMSYSERR_INVALPARAM | <p uMsg> is not in the VCMDM_USER range.
 *      @flag MMSYSERR_NOTSUPPORTED | The VCM driver did not process the message.
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamMessage(HVCMSTREAM hvs, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamMessage: Specified HVCMSTREAM handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	// Check input params
	if ((uMsg > VCMDM_RESERVED_HIGH) || (uMsg < VCMDM_RESERVED_LOW))
	{
		ERRORMESSAGE(("vcmStreamMessage: Specified message is out of range, uMsg=0x%lX (expected value is between 0x%lX and 0x%lX)\r\n", uMsg, VCMDM_RESERVED_LOW, VCMDM_RESERVED_HIGH));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Send the message to the codec.
	if (pvs->hIC)
		if (ICSendMessage((HIC)(HVCMDRIVERID)pvs->hIC, uMsg, lParam1, lParam2) != ICERR_OK)
		{
			ERRORMESSAGE(("vcmStreamMessage: Codec failed to handle user-defined message correctly\r\n"));
			return ((MMRESULT)MMSYSERR_NOTSUPPORTED);
		}

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamConvert | The vcmStreamConvert function requests the Video
 *      Compression Manager (VCM) to perform a conversion on the specified conversion stream. A
 *      conversion may be synchronous or asynchronous depending on how the
 *      stream was opened.
 *
 *  @parm HVCMSTREAM | has | Identifies the open conversion stream.
 *
 *  @parm PVCMSTREAMHEADER | pash | Specifies a pointer to a stream header
 *      that describes source and destination buffers for a conversion. This
 *      header must have been prepared previously using the
 *      <f vcmStreamPrepareHeader> function.
 *
 *  @parm  DWORD | fdwConvert | Specifies flags for doing the conversion.
 *
 *      @flag VCM_STREAMCONVERTF_BLOCKALIGN | Specifies that only integral
 *      numbers of blocks will be converted. Converted data will end on
 *      block aligned boundaries. An application should use this flag for
 *      all conversions on a stream until there is not enough source data
 *      to convert to a block-aligned destination. In this case, the last
 *      conversion should be specified without this flag.
 *
 *      @flag VCM_STREAMCONVERTF_START | Specifies that the VCM conversion
 *      stream should reinitialize its instance data. For example, if a
 *      conversion stream holds instance data, such as delta or predictor
 *      information, this flag will restore the stream to starting defaults.
 *      Note that this flag can be specified with the VCM_STREAMCONVERTF_END
 *      flag.
 *
 *      @flag VCM_STREAMCONVERTF_END | Specifies that the VCM conversion
 *      stream should begin returning pending instance data. For example, if
 *      a conversion stream holds instance data, such as the tail end of an
 *      echo filter operation, this flag will cause the stream to start
 *      returning this remaining data with optional source data. Note that
 *      this flag can be specified with the VCM_STREAMCONVERTF_START flag.
 *
 *      @flag VCM_STREAMCONVERTF_FORCE_KEYFRAME | Specifies that the VCM conversion
 *      stream should compress the current frame as a key frame.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag VCMERR_BUSY | The stream header <p pash> is currently in use
 *      and cannot be reused.
 *
 *      @flag VCMERR_UNPREPARED | The stream header <p pash> is currently
 *      not prepared by the <f vcmStreamPrepareHeader> function.
 *
 *  @comm The source and destination data buffers must be prepared with
 *      <f vcmStreamPrepareHeader> before they are passed to <f vcmStreamConvert>.
 *
 *      If an asynchronous conversion request is successfully queued by
 *      the VCM or driver, and later the conversion is determined to
 *      be impossible, then the <t VCMSTREAMHEADER> will be posted back to
 *      the application's callback with the <e VCMSTREAMHEADER.cbDstLengthUsed>
 *      member set to zero.
 *
 *  @xref <f vcmStreamOpen> <f vcmStreamReset> <f vcmStreamPrepareHeader>
 *      <f vcmStreamUnprepareHeader>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamConvert(HVCMSTREAM hvs, PVCMSTREAMHEADER pvsh, DWORD fdwConvert)
{
	MMRESULT	mmr;
	PVCMSTREAM  pvs = (PVCMSTREAM)hvs;
	BOOL		fKeyFrame;
	BOOL		fTemporalCompress;
	BOOL		fFastTemporal;
    DWORD		dwMaxSizeThisFrame = 0xffffff;
	DWORD		ckid = 0UL;
	DWORD		dwFlags;
	DWORD		dwTimestamp;

#ifdef LOGFILE_ON
	if ((pvs->fdwStream == ICMODE_COMPRESS) || (pvs->fdwStream == ICMODE_FASTCOMPRESS))
		g_CompressTime = GetTickCount();
	else if ((pvs->fdwStream == ICMODE_DECOMPRESS) || (pvs->fdwStream == ICMODE_FASTDECOMPRESS))
		g_DecompressTime = GetTickCount();
#endif

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamConvert: Specified HVCMSTREAM handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (!pvsh)
	{
		ERRORMESSAGE(("vcmStreamConvert: Specified PVCMSTREAMHEADER pointer is invalid, pvsh=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (pvsh->cbStruct < sizeof(VCMSTREAMHEADER))
	{
		ERRORMESSAGE(("vcmStreamConvert: The size of the VCM stream header is invalid, pvsh->cbStruct=%ld (expected value is %ld)\r\n", pvsh->cbStruct, sizeof(VCMSTREAMHEADER)));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	// Return if buffer is already being converted
	if (IsVCMHeaderInQueue(pvsh))
	{
		ERRORMESSAGE(("vcmStreamConvert: Buffer is already being converted\r\n"));
		return ((MMRESULT)VCMERR_BUSY);
	}

	// Return if buffer has not been prepared
	if (!IsVCMHeaderPrepared(pvsh))
	{
		ERRORMESSAGE(("vcmStreamConvert: Buffer has not been prepared\r\n"));
		return ((MMRESULT)VCMERR_UNPREPARED);
	}

	// Set flags
	MarkVCMHeaderNotDone(pvsh);
	pvsh->cbSrcLengthUsed = pvsh->cbSrcLength;
	pvsh->cbDstLengthUsed = pvsh->cbDstLength;
	pvsh->cbPrevLengthUsed = pvsh->cbPrevLength;
	MarkVCMHeaderInQueue(pvsh);

	// Queue buffer
	pvsh->pNext = NULL;
	if (pvs->pvhLast)
		pvs->pvhLast->pNext = pvsh;
	else
		pvs->pvhFirst = pvsh;
	pvs->pvhLast = pvsh;

	if ((pvs->fdwStream == ICMODE_COMPRESS) || (pvs->fdwStream == ICMODE_FASTCOMPRESS))
	{
		// Save the current time
		dwTimestamp = GetTickCount();

		// We need the following crs to make sure we don't miss any of the I-Frame requests
		// emittted by the UI. Problematic scenario: pvs->dwFrame is at 123 for instance.
		// The UI thread requests an I-Frame by setting pvs->dwFrame to 0. If the capture/compression
		// thread was in ICCompress() (which is very probable since it takes quite some time
		// to compress a frame), pvs->dwFrame will be incremented by one when ICCompress()
		// returns. We failed to handle the I-Frame request correctly, since the next time
		// ICCompress() gets called pvs->dwFrame will be equal to 1, for which we do not
		// generate an I-Frame.
		EnterCriticalSection(&pvs->crsFrameNumber);

		// Compress
		fTemporalCompress = pvs->dwICInfoFlags & VIDCF_TEMPORAL;
		fFastTemporal = pvs->dwICInfoFlags & VIDCF_FASTTEMPORALC;
		fKeyFrame = !fTemporalCompress || (fTemporalCompress && !fFastTemporal && ((pvsh->pbPrev == (PBYTE)NULL) || (pvsh->cbPrevLength == (DWORD)NULL))) ||
				(pvs->fPeriodicIFrames && (((dwTimestamp > pvs->dwLastIFrameTime) && ((dwTimestamp - pvs->dwLastIFrameTime) > MIN_IFRAME_REQUEST_INTERVAL)))) || (pvs->dwFrame == 0) || (fdwConvert & VCM_STREAMCONVERTF_FORCE_KEYFRAME);
		dwFlags = fKeyFrame ? AVIIF_KEYFRAME : 0;
#if 0
		dwMaxSizeThisFrame = fKeyFrame ? 0xffffff : pvs->dwTargetFrameRate ? pvs->dwTargetByterate * pvs->dwTargetFrameRate / 1000UL : 0;
#else
		dwMaxSizeThisFrame = pvs->dwTargetFrameRate ? pvs->dwTargetByterate * 100UL / pvs->dwTargetFrameRate : 0;
#endif

		// We need to modify the frame number so that the codec can generate
		// a valid TR. TRs use MPIs as their units. So we need to generate a
		// frame number assuming a 29.97Hz capture rate, even though we will be
		// capturing at some other rate.
		if (pvs->dwLastTimestamp == ULONG_MAX)
		{
			// This is the first frame
			pvs->dwFrame = 0UL;

			// Save the current time
			pvs->dwLastTimestamp = dwTimestamp;

			// DEBUGMSG (ZONE_VCM, ("vcmStreamConvert: Last Timestamp = ULONG_MAX => Frame # = 0\r\n"));
		}
		else
		{
			// Compare the current timestamp to the last one we saved. The difference
			// will let us normalize the frame count to 29.97Hz.
			if (fKeyFrame)
			{
				pvs->dwFrame = 0UL;
				pvs->dwLastTimestamp = dwTimestamp;
			}
			else
				pvs->dwFrame = (dwTimestamp - pvs->dwLastTimestamp) * 2997 / 100000UL;

			// DEBUGMSG (ZONE_VCM, ("vcmStreamConvert: Last Timestamp = %ld => Frame # = %ld\r\n", pvs->dwLastTimestamp, pvs->dwFrame));
		}

		if (fKeyFrame)
		{
			pvs->dwLastIFrameTime = dwTimestamp;
			DEBUGMSG (ZONE_VCM, ("vcmStreamConvert: Generating an I-Frame...\r\n"));
		}

		mmr = ICCompress((HIC)pvs->hIC, fKeyFrame ? ICCOMPRESS_KEYFRAME : 0, (LPBITMAPINFOHEADER)&pvs->pvfxDst->bih, pvsh->pbDst, (LPBITMAPINFOHEADER)&pvs->pvfxSrc->bih, pvsh->pbSrc, &ckid, &dwFlags,
					pvs->dwFrame++, dwMaxSizeThisFrame, 10000UL - (pvs->dwQuality * 322UL), fKeyFrame | fFastTemporal ? NULL : (LPBITMAPINFOHEADER)&pvs->pbmiPrev, fKeyFrame | fFastTemporal ? NULL : pvsh->pbPrev);

		// Allow the UI to modify the frame number on its own thread
		LeaveCriticalSection(&pvs->crsFrameNumber);

		if (mmr != MMSYSERR_NOERROR)
		{
#ifdef LOGFILE_ON
			if (pvs->dwFrame < 4096)
			{
				if (pvs->dwFrame ==1)
					g_OrigCompressTime = g_CompressTime;
				g_aCompressTime[pvs->dwFrame-1] = g_CompressTime = GetTickCount() - g_CompressTime;
				if ((g_CompressLogFile = CreateFile("C:\\VCMCLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
				{
					SetFilePointer(g_CompressLogFile, 0, NULL, FILE_END);
					wsprintf(g_szCompressBuffer, "%04d\t\t%08d\t\t.o0Failed!0o.\r\n", pvs->dwFrame-1, g_OrigCompressTime);
					WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
					CloseHandle(g_CompressLogFile);
				}
			}
#endif
			ERRORMESSAGE(("vcmStreamConvert: ICCompress() failed, mmr=%ld\r\n", mmr));
			// Get the handle to the video device associated to the capture window
			pvsh = DeQueVCMHeader(pvs);
			MarkVCMHeaderDone(pvsh);

			return ((MMRESULT)VCMERR_FAILED);
		}

		pvsh->cbDstLengthUsed = pvs->pvfxDst->bih.biSizeImage;

		if ((fTemporalCompress) && (!fFastTemporal))
		{
			if (!pvsh->pbPrev)
				pvsh->pbPrev = (PBYTE)MemAlloc(pvs->pvfxSrc->bih.biSizeImage);

			if (pvsh->pbPrev)
			{
				// What about fast temporal?
				if (mmr = ICDecompress((HIC)pvs->hIC, 0, (LPBITMAPINFOHEADER)&pvs->pvfxDst->bih, pvsh->pbDst, (LPBITMAPINFOHEADER)&pvs->pvfxSrc->bih, pvsh->pbPrev) != MMSYSERR_NOERROR)
				{
					ERRORMESSAGE(("vcmStreamConvert: ICCompress() failed, mmr=%ld\r\n", mmr));
					// Get the handle to the video device associated to the capture window
	                pvsh = DeQueVCMHeader(pvs);
	                MarkVCMHeaderDone(pvsh);
					return ((MMRESULT)VCMERR_FAILED); // Do we really want to quit?
				}
			}
		}
	}
	else if ((pvs->fdwStream == ICMODE_DECOMPRESS) || (pvs->fdwStream == ICMODE_FASTDECOMPRESS))
	{
		// Decompress
		pvs->dwFrame++;

		pvs->pvfxSrc->bih.biSizeImage = pvsh->cbSrcLength;

		if (mmr = ICDecompress((HIC)pvs->hIC, 0, (LPBITMAPINFOHEADER)&pvs->pvfxSrc->bih, pvsh->pbSrc, (LPBITMAPINFOHEADER)&pvs->pvfxDst->bih, pvsh->pbDst) != MMSYSERR_NOERROR)
		{
#ifdef LOGFILE_ON
			if (pvs->dwFrame < 4096)
			{
				if (pvs->dwFrame ==1)
					g_OrigDecompressTime = g_DecompressTime;
				g_aDecompressTime[pvs->dwFrame-1] = g_DecompressTime = GetTickCount() - g_DecompressTime;
				if ((g_DecompressLogFile = CreateFile("C:\\VCMDLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
				{
					SetFilePointer(g_DecompressLogFile, 0, NULL, FILE_END);
					wsprintf(g_szDecompressBuffer, "%04d\t\t%08d\t\t.o0Failed!0o.\r\n", pvs->dwFrame-1, g_OrigDecompressTime);
					WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
					CloseHandle(g_DecompressLogFile);
				}
			}
#endif
			ERRORMESSAGE(("vcmStreamConvert: ICDecompress() failed, mmr=%ld\r\n", mmr));
			// Get the handle to the video device associated to the capture window
			pvsh = DeQueVCMHeader(pvs);
			MarkVCMHeaderDone(pvsh);
			return ((MMRESULT)VCMERR_FAILED);
		}

	}

#ifdef LOGFILE_ON
	if (pvs->dwFrame < 4096)
	{
		if ((pvs->fdwStream == ICMODE_COMPRESS) || (pvs->fdwStream == ICMODE_FASTCOMPRESS))
		{
			if (pvs->dwFrame == 1)
				g_OrigCompressTime = g_CompressTime;
			g_aCompressTime[pvs->dwFrame-1] = g_CompressTime = GetTickCount() - g_CompressTime;
			if ((g_CompressLogFile = CreateFile("C:\\VCMCLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
			{
				SetFilePointer(g_CompressLogFile, 0, NULL, FILE_END);
				wsprintf(g_szCompressBuffer, "%04d\t\t%08d\t\t%05d\t\t%03d\r\n", pvs->dwFrame-1, g_OrigCompressTime, pvs->pvfxDst->bih.biSizeImage, g_CompressTime);
				WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
				CloseHandle(g_CompressLogFile);
			}
		}
		else if ((pvs->fdwStream == ICMODE_DECOMPRESS) || (pvs->fdwStream == ICMODE_FASTDECOMPRESS))
		{
			if (pvs->dwFrame == 1)
				g_OrigDecompressTime = g_DecompressTime;
			g_aDecompressTime[pvs->dwFrame-1] = g_DecompressTime = GetTickCount() - g_DecompressTime;
			if ((g_DecompressLogFile = CreateFile("C:\\VCMDLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
			{
				SetFilePointer(g_DecompressLogFile, 0, NULL, FILE_END);
				wsprintf(g_szDecompressBuffer, "%04d\t\t%08d\t\t%05d\t\t%03d\r\n", pvs->dwFrame-1, g_OrigDecompressTime, pvs->pvfxDst->bih.biSizeImage, g_DecompressTime);
				WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
				CloseHandle(g_DecompressLogFile);
			}
		}
	}
#endif

	// Get the handle to the video device associated to the capture window
	pvsh = DeQueVCMHeader(pvs);
	MarkVCMHeaderDone(pvsh);

	// Test for the validity of the callback before doing this...
	switch (pvs->fdwOpen)
	{
		case CALLBACK_FUNCTION:
			(*(VCMSTREAMPROC)pvs->dwCallback)(hvs, VCM_DONE, pvs->dwCallbackInstance, (DWORD_PTR)pvsh, 0);
			break;

		case CALLBACK_EVENT:
			SetEvent((HANDLE)pvs->dwCallback);
			break;

		case CALLBACK_WINDOW:
			PostMessage((HWND)pvs->dwCallback, MM_VCM_DONE, (WPARAM)hvs, (LPARAM)pvsh);
			break;

		case CALLBACK_THREAD:
			PostThreadMessage((DWORD)pvs->dwCallback, MM_VCM_DONE, (WPARAM)hvs, (LPARAM)pvsh);
			break;

		case CALLBACK_NULL:
		default:
			break;
	}

	return ((MMRESULT)MMSYSERR_NOERROR);

}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamPrepareHeader | The vcmStreamPrepareHeader
 * function prepares an <t VCMSTREAMHEADER> for an Video Compression
 * Manager (VCM) stream conversion. This function must be called for
 * every stream header before it can be used in a conversion stream. An
 * application only needs to prepare a stream header once for the life of
 * a given stream; the stream header can be reused as long as the same
 * source and destiniation buffers are used, and the size of the source
 * and destination buffers do not exceed the sizes used when the stream
 * header was originally prepared.
 *
 *  @parm HVCMSTREAM | has | Specifies a handle to the conversion steam.
 *
 *  @parm PVCMSTREAMHEADER | pash | Specifies a pointer to an <t VCMSTREAMHEADER>
 *      structure that identifies the source and destination data buffers to
 *      be prepared.
 *
 *  @parm DWORD | fdwPrepare | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_NOMEM | Unable to allocate resources.
 *
 *  @comm Preparing a stream header that has already been prepared has no
 *      effect, and the function returns zero. However, an application should
 *      take care to structure code so multiple prepares do not occur.
 *
 *  @xref <f vcmStreamUnprepareHeader> <f vcmStreamOpen>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamPrepareHeader(HVCMSTREAM hvs, PVCMSTREAMHEADER pvsh, DWORD fdwPrepare)
{
	MMRESULT mmr = (MMRESULT)MMSYSERR_NOERROR;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamPrepareHeader: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (!pvsh)
	{
		ERRORMESSAGE(("vcmStreamPrepareHeader: Specified pointer is invalid, pvsh=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	// Return if buffer has already been prepared
	if (IsVCMHeaderPrepared(pvsh))
	{
		ERRORMESSAGE(("vcmStreamPrepareHeader: Buffer has already been prepared\r\n"));
		return (mmr);
	}

#ifdef REALLY_LOCK
	// Lock the buffers
	if (!VirtualLock(pvsh, (DWORD)sizeof(VCMSTREAMHEADER)))
	{
		ERRORMESSAGE(("vcmStreamPrepareHeader: VirtualLock() failed\r\n"));
		mmr = (MMRESULT)MMSYSERR_NOMEM;
	}
	else
	{
		if (!VirtualLock(pvsh->pbSrc, pvsh->cbSrcLength))
		{
			ERRORMESSAGE(("vcmStreamPrepareHeader: VirtualLock() failed\r\n"));
			VirtualUnlock(pvsh, (DWORD)sizeof(VCMSTREAMHEADER));
			mmr = (MMRESULT)MMSYSERR_NOMEM;
		}
		else
		{
			if (!VirtualLock(pvsh->pbDst, pvsh->cbDstLength))
			{
				ERRORMESSAGE(("vcmStreamPrepareHeader: VirtualLock() failed\r\n"));
				VirtualUnlock(pvsh->pbSrc, pvsh->cbSrcLength);
				VirtualUnlock(pvsh, (DWORD)sizeof(VCMSTREAMHEADER));
				mmr = (MMRESULT)MMSYSERR_NOMEM;
			}
		}
	}
#endif

	// Update flag
	if (mmr == MMSYSERR_NOERROR)
		MarkVCMHeaderPrepared(pvsh);

	return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamUnprepareHeader | The vcmStreamUnprepareHeader function
 *      cleans up the preparation performed by the <f vcmStreamPrepareHeader>
 *      function for an Video Compression Manager (VCM) stream. This function must
 *      be called after the VCM is finished with the given buffers. An
 *      application must call this function before freeing the source and
 *      destination buffers.
 *
 *  @parm HVCMSTREAM | has | Specifies a handle to the conversion steam.
 *
 *  @parm PVCMSTREAMHEADER | pash | Specifies a pointer to an <t VCMSTREAMHEADER>
 *      structure that identifies the source and destination data buffers to
 *      be unprepared.
 *
 *  @parm DWORD | fdwUnprepare | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *      @flag VCMERR_BUSY | The stream header <p pash> is currently in use
 *      and cannot be unprepared.
 *      @flag VCMERR_UNPREPARED | The stream header <p pash> was
 *      not prepared by the <f vcmStreamPrepareHeader> function.
 *
 *  @comm Unpreparing a stream header that has already been unprepared is
 *      an error. An application must specify the source and destination
 *      buffer lengths (<e VCMSTREAMHEADER.cbSrcLength> and
 *      <e VCMSTREAMHEADER.cbDstLength> respectively) that were used
 *      during the corresponding <f vcmStreamPrepareHeader> call. Failing
 *      to reset these member values will cause <f vcmStreamUnprepareHeader>
 *      to fail with MMSYSERR_INVALPARAM.
 *
 *      Note that there are some errors that the VCM can recover from. The
 *      VCM will return a non-zero error, yet the stream header will be
 *      properly unprepared. To determine whether the stream header was
 *      actually unprepared an application can examine the
 *      VCMSTREAMHEADER_STATUSF_PREPARED flag. The header will always be
 *      unprepared if <f vcmStreamUnprepareHeader> returns success.
 *
 *  @xref <f vcmStreamPrepareHeader> <f vcmStreamClose>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamUnprepareHeader(HVCMSTREAM hvs, PVCMSTREAMHEADER pvsh, DWORD fdwUnprepare)
{
	MMRESULT mmr = (MMRESULT)MMSYSERR_NOERROR;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamUnprepareHeader: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (!pvsh)
	{
		ERRORMESSAGE(("vcmStreamUnprepareHeader: Specified pointer is invalid, pvsh=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Return if buffer is currently in use
	if (IsVCMHeaderInQueue(pvsh))
	{
		ERRORMESSAGE(("vcmStreamUnprepareHeader: Buffer is currently in use\r\n"));
		return ((MMRESULT)VCMERR_BUSY);
	}

	// Return if buffer has not been prepared
	if (!IsVCMHeaderPrepared(pvsh))
	{
		ERRORMESSAGE(("vcmStreamUnprepareHeader: Buffer has not been prepared\r\n"));
		return ((MMRESULT)VCMERR_UNPREPARED);
	}

#ifdef REALLY_LOCK
	// Unlock the buffers
	VirtualUnlock(pvsh->pbSrc, pvsh->cbSrcLength);
	VirtualUnlock(pvsh->pbDst, pvsh->cbDstLength);
	VirtualUnlock(pvsh, (DWORD)sizeof(VCMSTREAMHEADER));
#endif

	// Update flag
	MarkVCMHeaderUnprepared(pvsh);

	return ((MMRESULT)MMSYSERR_NOERROR);
}

PVCMSTREAMHEADER DeQueVCMHeader(PVCMSTREAM pvs)
{
	PVCMSTREAMHEADER pvsh;

	if (pvsh = pvs->pvhFirst)
	{
		MarkVCMHeaderUnQueued(pvsh);
		pvs->pvhFirst = pvsh->pNext;
		if (pvs->pvhFirst == NULL)
			pvs->pvhLast = NULL;
	}

	return (pvsh);
}

/*****************************************************************************
 * @doc INTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmDevCapsReadFromReg | This function looks up the
 *   capabilities of a specified video capture input device from the registry.
 *
 * @parm UINT | szDeviceName | Specifies the video capture input device driver name.
 *
 * @parm UINT | szDeviceVersion | Specifies the video capture input device driver version.
 *   May be NULL.
 *
 * @parm PVIDEOINCAPS | pvc | Specifies a pointer to a <t VIDEOINCAPS>
 *   structure. This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | cbvc | Specifies the size of the <t VIDEOINCAPS> structure.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALPARAM | Specified pointer is invalid, or its content is invalid.
 *   @flag VCMERR_NOREGENTRY | No registry entry for specified capture device driver was found.
 *
 * @comm Only <p cbwc> bytes (or less) of information is copied to the location
 *   pointed to by <p pvc>. If <p cbwc> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref <f vcmGetDevCaps> <f vcmDevCapsProfile> <f vcmDevCapsWriteToReg>
 ****************************************************************************/
MMRESULT VCMAPI vcmDevCapsReadFromReg(LPSTR szDeviceName, LPSTR szDeviceVersion,PVIDEOINCAPS pvc, UINT cbvc)
{
	MMRESULT	mmr = (MMRESULT)MMSYSERR_NOERROR;
	HKEY		hDeviceKey, hKey;
	DWORD		dwSize, dwType;
	char		szKey[MAX_PATH + MAX_VERSION + 2];
	LONG lRet;

	// Check input params
	if (!szDeviceName)
	{
		ERRORMESSAGE(("vcmDevCapsReadFromReg: Specified pointer is invalid, szDeviceName=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (szDeviceName[0] == '\0')
	{
		ERRORMESSAGE(("vcmDevCapsReadFromReg: Video capture input device driver name is empty\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvc)
	{
		ERRORMESSAGE(("vcmDevCapsReadFromReg: Specified pointer is invalid, pvc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!cbvc)
	{
		ERRORMESSAGE(("vcmDevCapsReadFromReg: Specified structure size is invalid, cbvc=0\r\n"));
		return ((MMRESULT)MMSYSERR_NOERROR);
	}

	// Check if the main capture devices key is there
	if (RegOpenKey(HKEY_LOCAL_MACHINE, szRegDeviceKey, &hDeviceKey) != ERROR_SUCCESS)
		return ((MMRESULT)VCMERR_NOREGENTRY);


    //If we have version info use that to build the key name
    if (szDeviceVersion) {
        wsprintf(szKey, "%s, %s", szDeviceName, szDeviceVersion);
    } else {
        lstrcpyn(szKey, szDeviceName, ARRAYSIZE(szKey));
    }

    // Check if there already is a key for the current device
	if (RegOpenKey(hDeviceKey, szKey, &hKey) != ERROR_SUCCESS)
	{
		mmr = (MMRESULT)VCMERR_NOREGENTRY;
		goto MyExit0;
	}

	// Get the values stored in the key
	dwSize = sizeof(DWORD);
	RegQueryValueEx(hKey, (LPTSTR)szRegdwImageSizeKey, NULL, &dwType, (LPBYTE)&pvc->dwImageSize, &dwSize);
	dwSize = sizeof(DWORD);
	RegQueryValueEx(hKey, (LPTSTR)szRegdwNumColorsKey, NULL, &dwType, (LPBYTE)&pvc->dwNumColors, &dwSize);
	dwSize = sizeof(DWORD);
	pvc->dwStreamingMode = STREAMING_PREFER_FRAME_GRAB;
	RegQueryValueEx(hKey, (LPTSTR)szRegdwStreamingModeKey, NULL, &dwType, (LPBYTE)&pvc->dwStreamingMode, &dwSize);
	dwSize = sizeof(DWORD);
	pvc->dwDialogs = FORMAT_DLG_OFF | SOURCE_DLG_ON;
	RegQueryValueEx(hKey, (LPTSTR)szRegdwDialogsKey, NULL, &dwType, (LPBYTE)&pvc->dwDialogs, &dwSize);



	// Check dwNumColors to figure out if we need to read the palettes too
	if (pvc->dwNumColors & VIDEO_FORMAT_NUM_COLORS_16)
	{
		dwSize = NUM_4BIT_ENTRIES * sizeof(RGBQUAD);
		if (RegQueryValueEx(hKey, (LPTSTR)szRegbmi4bitColorsKey, NULL, &dwType,
                    		(LPBYTE)&pvc->bmi4bitColors[0], &dwSize) == ERROR_SUCCESS) {
            pvc->dwFlags |= VICF_4BIT_TABLE;
        }
        else
            FillMemory ((LPBYTE)&pvc->bmi4bitColors[0], NUM_4BIT_ENTRIES * sizeof(RGBQUAD), 0);
	}
	if (pvc->dwNumColors & VIDEO_FORMAT_NUM_COLORS_256)
	{
		dwSize = NUM_8BIT_ENTRIES * sizeof(RGBQUAD);
		if (RegQueryValueEx(hKey, (LPTSTR)szRegbmi8bitColorsKey, NULL, &dwType,
		                    (LPBYTE)&pvc->bmi8bitColors[0], &dwSize) == ERROR_SUCCESS) {
            pvc->dwFlags |= VICF_8BIT_TABLE;
        }
        else
            FillMemory ((LPBYTE)&pvc->bmi8bitColors[0], NUM_8BIT_ENTRIES * sizeof(RGBQUAD), 0);
	}

	// Close the registry keys
	RegCloseKey(hKey);
MyExit0:
	RegCloseKey(hDeviceKey);

	return (mmr);

}


/*****************************************************************************
 * @doc INTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmDevCapsProfile | This function profiles the video capture
 *   input device to figure out its capabilities.
 *
 * @parm PVIDEOINCAPS | pvc | Specifies a pointer to a <t VIDEOINCAPS>
 *   structure. This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | cbvc | Specifies the size of the <t VIDEOINCAPS> structure.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALPARAM | Specified pointer is invalid, or its content is invalid.
 *   @flag MMSYSERR_NOMEM | A memory allocation failed.
 *   @flag MMSYSERR_NODRIVER | No capture device driver or device is present.
 *   @flag VCMERR_NONSPECIFIC | The capture driver failed to provide description information.
 *
 * @comm Only <p cbwc> bytes (or less) of information is copied to the location
 *   pointed to by <p pvc>. If <p cbwc> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref <f vcmGetDevCaps> <f videoDevCapsReadFromReg> <f videoDevCapsWriteToReg>
 ****************************************************************************/
MMRESULT VCMAPI vcmDevCapsProfile(UINT uDevice, PVIDEOINCAPS pvc, UINT cbvc)
{
	MMRESULT			mmr = (MMRESULT)MMSYSERR_NOERROR;
	FINDCAPTUREDEVICE	fcd;
	LPBITMAPINFO		lpbmi;
	HCAPDEV				hCapDev = (HCAPDEV)NULL;
	int					k,l;
	BOOL				b4bitPalInitialized = FALSE;
	BOOL				b8bitPalInitialized = FALSE;
	BOOL				bRet;

	// Check input params
	if (!pvc)
	{
		ERRORMESSAGE(("vcmDevCapsProfile: Specified pointer is invalid, pvc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!cbvc)
	{
		ERRORMESSAGE(("vcmDevCapsProfile: Specified structure size is invalid, cbvc=0\r\n"));
		return ((MMRESULT)MMSYSERR_NOERROR);
	}

	// Check input params
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmGetDevCaps: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}

	// Allocate space for BMIH and palette
	if ((lpbmi = (LPBITMAPINFO)MemAlloc(sizeof(BITMAPINFOHEADER) + NUM_8BIT_ENTRIES * sizeof(RGBQUAD))) == NULL)
	{
		ERRORMESSAGE(("vcmDevCapsProfile: BMIH and palette allocation failed\r\n"));
		return ((MMRESULT)MMSYSERR_NOMEM);
	}

	// For now, always set the preferred streaming mode to STREAMING_PREFER_FRAME_GRAB
	// But in the future, do some real profiling...
	pvc->dwStreamingMode = STREAMING_PREFER_FRAME_GRAB;
	pvc->dwDialogs = FORMAT_DLG_OFF | SOURCE_DLG_OFF;

	lpbmi->bmiHeader.biPlanes = 1;

	// if VIDEO_MAPPER: use first capture device
	fcd.dwSize = sizeof (FINDCAPTUREDEVICE);

	if (uDevice == VIDEO_MAPPER)
	{
		bRet = FindFirstCaptureDevice(&fcd, NULL);
	}

	else
		bRet = FindFirstCaptureDeviceByIndex(&fcd, uDevice);

	if (bRet)
		hCapDev = OpenCaptureDevice(fcd.nDeviceIndex);
	

	if (hCapDev != NULL)
	{
		// If the driver exposes a source dialog, there is no need to go further:
		// we advertise this dialog and that's it. On the other hand, if there isn't
		// a source dialog per se, it may be hidden in the format dialog, in which case
		// we advertise the format dialog.
		if (CaptureDeviceDialog(hCapDev, (HWND)NULL, CAPDEV_DIALOG_SOURCE | CAPDEV_DIALOG_QUERY, NULL))
			pvc->dwDialogs |= SOURCE_DLG_ON;
		else
			if (CaptureDeviceDialog(hCapDev, (HWND)NULL, CAPDEV_DIALOG_IMAGE | CAPDEV_DIALOG_QUERY, NULL))
				pvc->dwDialogs |= FORMAT_DLG_ON;

        // since we don't know anything about this adapter, we just use its default format
        // and report that we can get any size, which we will do through conversion
        // we will report the correct color depth only if the default size matches one of
        // our sizes, we'll always report 24bit color

        pvc->dwImageSize |= VIDEO_FORMAT_IMAGE_SIZE_USE_DEFAULT;

        // get the device's default format
        lpbmi->bmiHeader.biSize = GetCaptureDeviceFormatHeaderSize(hCapDev);
        GetCaptureDeviceFormat(hCapDev, (LPBITMAPINFOHEADER)lpbmi);

        // record this default in the registry
        if (pvc->szDeviceName[0] != '\0') {
            vcmDefaultFormatWriteToReg(pvc->szDeviceName, pvc->szDeviceVersion, (LPBITMAPINFOHEADER)lpbmi);
        } else {
            //Fall back and use driver name as the key
            vcmDefaultFormatWriteToReg(fcd.szDeviceName, pvc->szDeviceVersion, (LPBITMAPINFOHEADER)lpbmi);
        }

        if ((lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_BI_RGB) ||
            (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_YVU9) ||
            (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_YUY2) ||
            (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_UYVY) ||
            (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_I420) ||
            (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_IYUV)) {
            if (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_YVU9)
                k = VIDEO_FORMAT_NUM_COLORS_YVU9;
            else if (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_YUY2)
                k = VIDEO_FORMAT_NUM_COLORS_YUY2;
            else if (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_UYVY)
                k = VIDEO_FORMAT_NUM_COLORS_UYVY;
            else if (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_I420)
                k = VIDEO_FORMAT_NUM_COLORS_I420;
            else if (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_IYUV)
                k = VIDEO_FORMAT_NUM_COLORS_IYUV;
            else {
                for (k = 0; k < NUM_BITDEPTH_ENTRIES; k++) {
        			if (lpbmi->bmiHeader.biBitCount == g_aiBitDepth[k])
        			    break;
    	        }
    	        if (k < NUM_BITDEPTH_ENTRIES)
    	            k = g_aiNumColors[k];
    	        else
    	            k = 0;
    	    }
        }

        // converted sizes will probably get to RGB24, so always say that we support it
        pvc->dwNumColors |= VIDEO_FORMAT_NUM_COLORS_16777216;

        // always say that we support these 2 standard formats
        pvc->dwImageSize |= VIDEO_FORMAT_IMAGE_SIZE_176_144 | VIDEO_FORMAT_IMAGE_SIZE_128_96;
   		for (l=0; l<VIDEO_FORMAT_NUM_RESOLUTIONS; l++) {
            if ((lpbmi->bmiHeader.biWidth == (LONG)g_awResolutions[l].framesize.biWidth) &&
                 (lpbmi->bmiHeader.biHeight == (LONG)g_awResolutions[l].framesize.biHeight)) {
   		        pvc->dwImageSize |= g_awResolutions[l].dwRes;
    			pvc->dwNumColors |= k;
   		        break;
   		    }
	    }
	}
	else
		mmr = (MMRESULT)MMSYSERR_NODRIVER;

	// Close capture device
	if (hCapDev)
		CloseCaptureDevice(hCapDev);

	// Free BMIH + palette space
	if (lpbmi)
		MemFree(lpbmi);

	return (mmr);

}


/*****************************************************************************
 * @doc EXTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmDevCapsWriteToReg | This function writes the
 *   capabilities of a specified video capture input device into the registry.
 *
 * @parm UINT | szDeviceName | Specifies the video capture input device driver name.
 *
 * @parm UINT | szDeviceVersion | Specifies the video capture input device driver version.
 *   May be NULL.
 *
 * @parm PVIDEOINCAPS | pvc | Specifies a pointer to a <t VIDEOINCAPS>
 *   structure. This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | cbvc | Specifies the size of the <t VIDEOINCAPS> structure.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALPARAM | Specified pointer is invalid, or its content is invalid.
 *   @flag VCMERR_NOREGENTRY | No registry entry could be created for the specified capture device driver.
 *
 * @comm Only <p cbwc> bytes (or less) of information is copied to the location
 *   pointed to by <p pvc>. If <p cbwc> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref <f vcmGetDevCaps> <f videoDevCapsProfile> <f videoDevCapsWriteToReg>
 ****************************************************************************/
MMRESULT VCMAPI vcmDevCapsWriteToReg(LPSTR szDeviceName, LPSTR szDeviceVersion, PVIDEOINCAPS pvc, UINT cbvc)
{
	HKEY	hDeviceKey;
	HKEY	hKey;
	DWORD	dwDisposition;
	DWORD	dwSize;
	char	szKey[MAX_PATH + MAX_VERSION + 2];

	// Check input params
	if (!szDeviceName)
	{
		ERRORMESSAGE(("vcmDevCapsWriteToReg: Specified pointer is invalid, szDeviceName=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (szDeviceName[0] == '\0')
	{
		ERRORMESSAGE(("vcmDevCapsWriteToReg: Video capture input device driver name is empty\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvc)
	{
		ERRORMESSAGE(("vcmDevCapsWriteToReg: Specified pointer is invalid, pvc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!cbvc)
	{
		ERRORMESSAGE(("vcmDevCapsWriteToReg: Specified structure size is invalid, cbvc=0\r\n"));
		return ((MMRESULT)MMSYSERR_NOERROR);
	}

	// Open the main capture devices key, or create it if it doesn't exist
	if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegDeviceKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hDeviceKey, &dwDisposition) != ERROR_SUCCESS)
		return ((MMRESULT)VCMERR_NOREGENTRY);

    //If we have version info use that to build the key name
    if (szDeviceVersion && szDeviceVersion[0] != '\0') {
        wsprintf(szKey, "%s, %s", szDeviceName, szDeviceVersion);
    } else {
        lstrcpyn(szKey, szDeviceName, ARRAYSIZE(szKey));
    }


	// Check if there already is a key for the current device
	// Open the key for the current device, or create the key if it doesn't exist
	if (RegCreateKeyEx(hDeviceKey, szKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS)
		return ((MMRESULT)VCMERR_NOREGENTRY);

	// Set the values in the key
	dwSize = sizeof(DWORD);
	RegSetValueEx(hKey, (LPTSTR)szRegdwImageSizeKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&pvc->dwImageSize, dwSize);
	dwSize = sizeof(DWORD);
	RegSetValueEx(hKey, (LPTSTR)szRegdwNumColorsKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&pvc->dwNumColors, dwSize);
	dwSize = sizeof(DWORD);
	RegSetValueEx(hKey, (LPTSTR)szRegdwStreamingModeKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&pvc->dwStreamingMode, dwSize);
	dwSize = sizeof(DWORD);
	RegSetValueEx(hKey, (LPTSTR)szRegdwDialogsKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&pvc->dwDialogs, dwSize);

	// Check dwNumColors to figure out if we need to set the palettes too
	if (pvc->dwNumColors & VIDEO_FORMAT_NUM_COLORS_16)
	{
		dwSize = NUM_4BIT_ENTRIES * sizeof(RGBQUAD);
		RegSetValueEx(hKey, (LPTSTR)szRegbmi4bitColorsKey, (DWORD)NULL, REG_BINARY, (LPBYTE)&pvc->bmi4bitColors[0], dwSize);
	}
	if (pvc->dwNumColors & VIDEO_FORMAT_NUM_COLORS_256)
	{
		dwSize = NUM_8BIT_ENTRIES * sizeof(RGBQUAD);
		RegSetValueEx(hKey, (LPTSTR)szRegbmi8bitColorsKey, (DWORD)NULL, REG_BINARY, (LPBYTE)&pvc->bmi8bitColors[0], dwSize);
	}

	// Close the keys
	RegCloseKey(hKey);
	RegCloseKey(hDeviceKey);

	return ((MMRESULT)MMSYSERR_NOERROR);

}


MMRESULT VCMAPI vcmDefaultFormatWriteToReg(LPSTR szDeviceName, LPSTR szDeviceVersion, LPBITMAPINFOHEADER lpbmih)
{
	HKEY	hDeviceKey;
	HKEY	hKey;
	DWORD	dwDisposition;
	DWORD	dwSize;
	char	szKey[MAX_PATH + MAX_VERSION + 2];
	char    szFOURCC[5];

	// Check input params
	if (!szDeviceName)
	{
		ERRORMESSAGE(("vcmDefaultFormatWriteToReg: Specified pointer is invalid, szDeviceName=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (szDeviceName[0] == '\0')
	{
		ERRORMESSAGE(("vcmDefaultFormatWriteToReg: Video capture input device driver name is empty\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!lpbmih)
	{
		ERRORMESSAGE(("vcmDefaultFormatWriteToReg: Specified pointer is invalid, lpbmih=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Open the main capture devices key, or create it if it doesn't exist
	if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegCaptureDefaultKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hDeviceKey, &dwDisposition) != ERROR_SUCCESS)
		return ((MMRESULT)VCMERR_NOREGENTRY);

    //If we have version info use that to build the key name
    if (szDeviceVersion && szDeviceVersion[0] != '\0') {
        wsprintf(szKey, "%s, %s", szDeviceName, szDeviceVersion);
    } else {
        lstrcpyn(szKey, szDeviceName, ARRAYSIZE(szKey));
    }

	// Check if there already is a key for the current device
	// Open the key for the current device, or create the key if it doesn't exist
	if (RegCreateKeyEx(hDeviceKey, szKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS)
		return ((MMRESULT)VCMERR_NOREGENTRY);

    if (lpbmih->biCompression == BI_RGB)
        wsprintf(szFOURCC, "RGB");
    else {
        *((DWORD*)szFOURCC) = lpbmih->biCompression;
        szFOURCC[4] = '\0';
    }

	dwSize = wsprintf(szKey, "%s, %dx%dx%d", szFOURCC, lpbmih->biWidth, lpbmih->biHeight, lpbmih->biBitCount);
	RegSetValueEx(hKey, (LPTSTR)szRegDefaultFormatKey, (DWORD)NULL, REG_SZ, (CONST BYTE *)szKey, dwSize+1);

	// Close the keys
	RegCloseKey(hKey);
	RegCloseKey(hDeviceKey);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/*****************************************************************************
 * @doc EXTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmGetDevCapsPreferredFormatTag | This function queries a specified
 *   video capture input device to determine the format tag it will be effectively
 *   capturing at.
 *
 * @parm UINT | uDevice | Specifies the video capture input device ID.
 *
 * @parm PINT | pbiWidth | Specifies a pointer to the actual width
 *   the capture will be performed at.
 *
 * @parm PINT | pbiHeight | Specifies a pointer to the actual height
 *   the capture will be performed at.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALPARAM | Specified pointer to structure is invalid.
 *   @flag MMSYSERR_BADDEVICEID | Specified device device ID is invalid.
 *   @flag VCMERR_NONSPECIFIC | The capture driver failed to provide valid information.
 *
 * @xref <f vcmGetDevCaps>
 ****************************************************************************/
MMRESULT VCMAPI vcmGetDevCapsPreferredFormatTag(UINT uDevice, PDWORD pdwFormatTag)
{
	MMRESULT	mmr = (MMRESULT)MMSYSERR_NOERROR;
	VIDEOINCAPS vic;
	int			i;

	// Check input params
	if (!pdwFormatTag)
	{
		ERRORMESSAGE(("vcmGetDevCapsPreferredFormatTag: Specified pointer is invalid, pdwFormatTag=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmGetDevCapsPreferredFormatTag: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}

	// Get the capabilities of the capture hardware
	if ((mmr = vcmGetDevCaps(uDevice, &vic, sizeof(VIDEOINCAPS))) != MMSYSERR_NOERROR)
		return (mmr);

	// WE prefer to use I420 or IYUV, YVU9, YUY2, UYVY, RGB16, RGB24, RGB4, RGB8 in that order.
	for (i=0; i<NUM_BITDEPTH_ENTRIES; i++)
		if (g_aiNumColors[i] & vic.dwNumColors)
			break;
	
	if (i == NUM_BITDEPTH_ENTRIES)
		return ((MMRESULT)VCMERR_NONSPECIFIC);
	else
		*pdwFormatTag = g_aiFourCCCode[i];

	return ((MMRESULT)MMSYSERR_NOERROR);

}


/*****************************************************************************
 * @doc EXTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmGetDevCapsStreamingMode | This function queries a specified
 *   video capture input device to determine its preferred streaming mode.
 *
 * @parm UINT | uDevice | Specifies the video capture input device ID.
 *
 * @parm PDWORD | pdwStreamingMode | Specifies a pointer to the preferred streaming mode.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALPARAM | Specified pointer to structure is invalid.
 *   @flag MMSYSERR_BADDEVICEID | Specified device device ID is invalid.
 *   @flag VCMERR_NONSPECIFIC | The capture driver failed to provide valid information.
 *
 * @xref <f vcmGetDevCaps>
 ****************************************************************************/
MMRESULT VCMAPI vcmGetDevCapsStreamingMode(UINT uDevice, PDWORD pdwStreamingMode)
{
	MMRESULT	mmr = (MMRESULT)MMSYSERR_NOERROR;
	VIDEOINCAPS vic;

	// Check input params
	if (!pdwStreamingMode)
	{
		ERRORMESSAGE(("vcmGetDevCapsStreamingMode: Specified pointer is invalid, pdwStreamingMode=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmGetDevCapsStreamingMode: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}

	// Get the capabilities of the capture hardware
	if ((mmr = vcmGetDevCaps(uDevice, &vic, sizeof(VIDEOINCAPS))) != MMSYSERR_NOERROR)
		return (mmr);

	// Get the streaming mode.
	*pdwStreamingMode = vic.dwStreamingMode;

	return ((MMRESULT)MMSYSERR_NOERROR);

}




/*****************************************************************************
 * @doc EXTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmGetDevCapsDialogs | This function queries a specified
 *   video capture input device to determine if its dialog and source format
 *   its should be exposed.
 *
 * @parm UINT | uDevice | Specifies the video capture input device ID.
 *
 * @parm PDWORD | pdwDialogs | Specifies a pointer to the dialogs to be exposed.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALPARAM | Specified pointer to structure is invalid.
 *   @flag MMSYSERR_BADDEVICEID | Specified device device ID is invalid.
 *   @flag VCMERR_NONSPECIFIC | The capture driver failed to provide valid information.
 *
 * @xref <f vcmGetDevCaps>
 ****************************************************************************/
MMRESULT VCMAPI vcmGetDevCapsDialogs(UINT uDevice, PDWORD pdwDialogs)
{
	MMRESULT	mmr = (MMRESULT)MMSYSERR_NOERROR;
	VIDEOINCAPS vic;

	// Check input params
	if (!pdwDialogs)
	{
		ERRORMESSAGE(("vcmGetDevCapsDialogs: Specified pointer is invalid, pdwDialogs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmGetDevCapsDialogs: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}

	// Get the capabilities of the capture hardware
	if ((mmr = vcmGetDevCaps(uDevice, &vic, sizeof(VIDEOINCAPS))) != MMSYSERR_NOERROR)
		return (mmr);

	// Get the streaming mode.
	*pdwDialogs = vic.dwDialogs;

	return ((MMRESULT)MMSYSERR_NOERROR);

}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamSetBrightness | This function sends a user-defined
 *   message to a given Video Compression Manager (VCM) stream instance to set
 *   the brightness of the decompressed images. The brightness is a value defined
 *   between 0 and 255. The brightness can also be reset by passing a value equal
 *   to VCM_RESET_BRIGHTNESS.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm DWORD | dwBrightness | Specifies the value of the brightness requested.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified brightness value is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | The VCM driver cannot set the brightness.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSetBrightness(HVCMSTREAM hvs, DWORD dwBrightness)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamSetBrightness: Specified HVCMSTREAM handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if ((dwBrightness != VCM_RESET_BRIGHTNESS) && ((dwBrightness > VCM_MAX_BRIGHTNESS) || (dwBrightness < VCM_MIN_BRIGHTNESS)))
	{
		ERRORMESSAGE(("vcmStreamSetBrightness: Specified brightness value is invalid, dwBrightness=%ld (expected value is between %ld and %ld)\r\n", dwBrightness, VCM_MIN_BRIGHTNESS, VCM_MAX_BRIGHTNESS));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Only our (intel h.263) codec supports this. If the codec used is different,
	// that's Ok: no need to return an error.
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
	if (pvs->pvfxSrc && ((pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH26X)))
#else
	if (pvs->pvfxSrc && (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263))
#endif
		vcmStreamMessage(hvs, PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS, (dwBrightness != VCM_RESET_BRIGHTNESS) ? (LPARAM)dwBrightness : (LPARAM)VCM_DEFAULT_BRIGHTNESS, (LPARAM)0);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamSetContrast | This function sends a user-defined
 *   message to a given Video Compression Manager (VCM) stream instance to set
 *   the contrast of the decompressed images. The contrast is a value defined
 *   between 0 and 255. The contrast can also be reset by passing a value equal
 *   to VCM_RESET_CONTRAST.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm DWORD | dwContrast | Specifies the value of the contrast requested.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified contrast value is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | The VCM driver cannot set the contrast.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSetContrast(HVCMSTREAM hvs, DWORD dwContrast)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamSetContrast: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if ((dwContrast != VCM_RESET_CONTRAST) && ((dwContrast > VCM_MAX_CONTRAST) || (dwContrast < VCM_MIN_CONTRAST)))
	{
		ERRORMESSAGE(("vcmStreamSetContrast: Specified contrast value is invalid, dwContrast=%ld (expected value is between %ld and %ld)\r\n", dwContrast, VCM_MIN_CONTRAST, VCM_MAX_CONTRAST));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Only our (intel ) codec supports this. If the codec used is different,
	// that's Ok: no need to return an error.
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
	if (pvs->pvfxSrc && ((pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH26X)))
#else
	if (pvs->pvfxSrc && (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263))
#endif
		vcmStreamMessage(hvs, PLAYBACK_CUSTOM_CHANGE_CONTRAST, (dwContrast != VCM_RESET_CONTRAST) ? (LPARAM)dwContrast : (LPARAM)VCM_DEFAULT_CONTRAST, (LPARAM)0);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamSetSaturation | This function sends a user-defined
 *   message to a given Video Compression Manager (VCM) stream instance to set
 *   the saturation of the decompressed images. The saturation is a value defined
 *   between 0 and 255. The saturation can also be reset by passing a value equal
 *   to VCM_RESET_SATURATION.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm DWORD | dwSaturation | Specifies the value of the saturation requested.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified saturation value is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | The VCM driver cannot set the saturation.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSetSaturation(HVCMSTREAM hvs, DWORD dwSaturation)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamSetSaturation: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if ((dwSaturation != VCM_RESET_SATURATION) && ((dwSaturation > VCM_MAX_SATURATION) || (dwSaturation < VCM_MIN_SATURATION)))
	{
		ERRORMESSAGE(("vcmStreamSetSaturation: Specified saturation value is invalid, dwSaturation=%ld (expected value is between %ld and %ld)\r\n", dwSaturation, VCM_MIN_SATURATION, VCM_MAX_SATURATION));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Only our (H.263 intel)  codec supports this. If the codec used is different,
	// that's Ok: no need to return an error.
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
	if (pvs->pvfxSrc && ((pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH26X)))
#else
	if (pvs->pvfxSrc && (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263))
#endif
		vcmStreamMessage(hvs, PLAYBACK_CUSTOM_CHANGE_SATURATION, (dwSaturation != VCM_RESET_SATURATION) ? (LPARAM)dwSaturation : (LPARAM)VCM_DEFAULT_SATURATION, (LPARAM)0);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamIsPostProcessingSupported | This function is used to find
 *   out if the decompressor can post-process the decompressed image to, for
 *   instance, modify its brightness, contrast or saturation.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @rdesc The return value is TRUE if the decompressor supports post-processing. Otherwise, it returns FALSE.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
BOOL VCMAPI vcmStreamIsPostProcessingSupported(HVCMSTREAM hvs)
{
	// Check input params
	if (!hvs)
		return (FALSE);

	// Put the code that checks this property right here!!!

	return (FALSE);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamSetImageQuality | This function sends the image
 *   quality compression parameter.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm DWORD | dwImageQuality | Specifies an image quality value (between 0
 *   and 31. The lower number indicates a high spatial quality at a low frame
 *   rate, the larger number indiocates a low spatial quality at a high frame
 *   rate.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified image quality value is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | The VCM driver cannot set the compression ratio.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSetImageQuality(HVCMSTREAM hvs, DWORD dwImageQuality)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;
#ifdef USE_MPEG4_SCRUNCH
	PVOID				pvState;
	DWORD				dw;
	PMPEG4COMPINSTINFO	pciMPEG4Info;
#endif
#ifdef LOG_COMPRESSION_PARAMS
	char szDebug[100];
#endif

	// Check input param
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamSetImageQuality: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	// Set to default value if out or range
	if ((dwImageQuality > VCM_MIN_IMAGE_QUALITY))
	{
		pvs->dwQuality = VCM_DEFAULT_IMAGE_QUALITY;
		ERRORMESSAGE(("vcmStreamSetImageQuality: Specified image quality value is invalid, dwImageQuality=%ld (expected value is between %ld and %ld)\r\n", dwImageQuality, VCM_MAX_IMAGE_QUALITY, VCM_MIN_IMAGE_QUALITY));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Put the code that sets this property right here!!!
	pvs->dwQuality = dwImageQuality;

#ifdef USE_MPEG4_SCRUNCH
	// Get the state of the compressor
	if (dw = ICGetStateSize((HIC)pvs->hIC))
	{
		if (pvState = (PVOID)MemAlloc(dw))
		{
			if (((DWORD) ICGetState((HIC)pvs->hIC, pvState, dw)) == dw)
			{
				pciMPEG4Info = (PMPEG4COMPINSTINFO)pvState;

				// Configure the codec for compression
				pciMPEG4Info->lMagic = MPG4_STATE_MAGIC;
				pciMPEG4Info->dDataRate = 20;
				pciMPEG4Info->lCrisp = dwImageQuality * 3;
				pciMPEG4Info->lKeydist = 30;
				pciMPEG4Info->lPScale = MPG4_PSEUDO_SCALE;
				pciMPEG4Info->lTotalWindowMs = MPG4_TOTAL_WINDOW_DEFAULT;
				pciMPEG4Info->lVideoWindowMs = MPG4_VIDEO_WINDOW_DEFAULT;
				pciMPEG4Info->lFramesInfoValid = FALSE;
				pciMPEG4Info->lBFrameOn = MPG4_B_FRAME_ON;
				pciMPEG4Info->lLiveEncode = MPG4_LIVE_ENCODE;

				ICSetState((HIC)pvs->hIC, (PVOID)pciMPEG4Info, dw);

				// Get rid of the state structure
				MemFree((HANDLE)pvState);
			}
		}
	}
#endif

#ifdef LOG_COMPRESSION_PARAMS
	wsprintf(szDebug, "New image quality: %ld\r\n", dwImageQuality);
	OutputDebugString(szDebug);
#endif

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamSetMaxPacketSize | This function sets the maximum
 *   video packet size.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm DWORD | dwMaxPacketSize | Specifies the maximum packet size.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified image quality value is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | The VCM driver cannot set the size.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSetMaxPacketSize(HVCMSTREAM hvs, DWORD dwMaxPacketSize)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamSetMaxPacketSize: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if ((dwMaxPacketSize != VCM_RESET_PACKET_SIZE) && ((dwMaxPacketSize > VCM_MAX_PACKET_SIZE) || (dwMaxPacketSize < VCM_MIN_PACKET_SIZE)))
	{
		ERRORMESSAGE(("vcmStreamSetMaxPacketSize: Specified max packet size value is invalid, dwMaxPacketSize=%ld (expected value is between %ld and %ld)\r\n", dwMaxPacketSize, VCM_MIN_PACKET_SIZE, VCM_MAX_PACKET_SIZE));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Only our (H.26x intel) codecs supports this. If the codec used is different,
	// just return an 'unsupported' error.
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
	if (pvs->pvfxDst && ((pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH261) || (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH26X)))
#else
	if (pvs->pvfxDst && ((pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH261)))
#endif
	{
		if (dwMaxPacketSize != VCM_RESET_PACKET_SIZE)
			pvs->dwMaxPacketSize = dwMaxPacketSize;
		else
			pvs->dwMaxPacketSize = VCM_DEFAULT_PACKET_SIZE;
		vcmStreamMessage(hvs, CODEC_CUSTOM_ENCODER_CONTROL, MAKELONG(EC_PACKET_SIZE,EC_SET_CURRENT), (LPARAM)pvs->dwMaxPacketSize);
	}
	else
		return ((MMRESULT)MMSYSERR_NOTSUPPORTED);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamSetTargetRates | This function sets the target
 *   bitrate and frame rate to be used in the estimation of the target frame
 *   size at compression time.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm DWORD | dwTargetFrameRate | Specifies a target frame rate value.
 *
 * @parm DWORD | dwTargetByterate | Specifies a target byterate value.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise,
 *   it returns an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified target frame rate value is
 *   invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | The VCM driver cannot set the compression
 *   ratio.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSetTargetRates(HVCMSTREAM hvs, DWORD dwTargetFrameRate, DWORD dwTargetByterate)
{
	FX_ENTRY("vcmStreamSetTargetRates");

	// IP + UDP + RTP + payload mode C header - worst case
	#define TRANSPORT_HEADER_SIZE (20 + 8 + 12 + 12)

	PVCMSTREAM			pvs = (PVCMSTREAM)hvs;
	ICCOMPRESSFRAMES	iccf = {0};

	ASSERT(hvs && ((dwTargetFrameRate == VCM_RESET_FRAME_RATE) || ((dwTargetFrameRate <= VCM_MAX_FRAME_RATE) && (dwTargetFrameRate >= VCM_MIN_FRAME_RATE))) && ((dwTargetByterate == VCM_RESET_BYTE_RATE) || ((dwTargetByterate <= VCM_MAX_BYTE_RATE) && (dwTargetByterate >= VCM_MIN_BYTE_RATE))));

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("%s: Specified handle is invalid, hvs=NULL\r\n", _fx_));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if ((dwTargetFrameRate != VCM_RESET_FRAME_RATE) && (dwTargetFrameRate > VCM_MAX_FRAME_RATE) && (dwTargetFrameRate < VCM_MIN_FRAME_RATE))
	{
		ERRORMESSAGE(("%s: Specified target frame rate value is invalid, dwTargetFrameRate=%ld (expected value is between %ld and %ld)\r\n", _fx_, dwTargetFrameRate, VCM_MIN_FRAME_RATE, VCM_MAX_FRAME_RATE));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if ((dwTargetByterate != VCM_RESET_BYTE_RATE) && (dwTargetByterate > VCM_MAX_BYTE_RATE)  && (dwTargetByterate < VCM_MIN_BYTE_RATE))
	{
		ERRORMESSAGE(("%s: Specified target bitrate value is invalid, dwTargetBitrate=%ld bps (expected value is between %ld and %ld bps)\r\n", _fx_, dwTargetByterate << 3, VCM_MIN_BYTE_RATE << 3, VCM_MAX_BYTE_RATE << 3));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Don't change the state of the codec while it's compressing a frame
	EnterCriticalSection(&pvs->crsFrameNumber);

	// Set the new rates on the codec
	iccf.lQuality = 10000UL - (pvs->dwQuality * 322UL);
	if (pvs->dwMaxPacketSize)
		iccf.lDataRate = pvs->dwTargetByterate = dwTargetByterate - (dwTargetByterate / pvs->dwMaxPacketSize + 1) * TRANSPORT_HEADER_SIZE;
	else
		iccf.lDataRate = pvs->dwTargetByterate = dwTargetByterate;
	iccf.lKeyRate = LONG_MAX;
	iccf.dwRate = 1000UL;
	pvs->dwTargetFrameRate = dwTargetFrameRate;
	iccf.dwScale = iccf.dwRate * 100UL / dwTargetFrameRate;
	if (ICSendMessage((HIC)(HVCMDRIVERID)pvs->hIC, ICM_COMPRESS_FRAMES_INFO, (DWORD_PTR)&iccf, sizeof(iccf)) != ICERR_OK)
	{
		LeaveCriticalSection(&pvs->crsFrameNumber);

		ERRORMESSAGE(("%s: Codec failed to handle ICM_COMPRESS_FRAMES_INFO message correctly\r\n", _fx_));

		return ((MMRESULT)VCMERR_FAILED);
	}

	LeaveCriticalSection(&pvs->crsFrameNumber);

	DEBUGMSG(ZONE_VCM, ("%s: New targets:\r\n  Frame rate: %ld.%ld fps\r\n  Bitrate (minus network overhead): %ld bps\r\n  Frame size: %ld bits\r\n", _fx_, pvs->dwTargetFrameRate / 100UL, (DWORD)(pvs->dwTargetFrameRate - (DWORD)(pvs->dwTargetFrameRate / 100UL) * 100UL), pvs->dwTargetByterate << 3, (pvs->dwTargetByterate << 3) * 100UL / pvs->dwTargetFrameRate));

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamRestorePayload | This function takes a list of video
 *   packets and recreates the video payload of a complete frame from these.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm WSABUF* | ppDataPkt | Specifies a pointer to the list of video packets.
 *
 * @parm DWORD | dwPktCount | Specifies the number of packets in the list.
 *
 * @parm PBYTE | pbyFrame | Specifies a pointer to the reconstructed video data.
 *
 * @parm DWORD* | pdwFrameSize | Specifies a pointer to the size of reconstructed video data.
 *
 * @parm BOOL* | pfReceivedKeyframe | Specifies a pointer to receive the type (I or P) of a frame.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified data pointer is invalid.
 *
 * @comm The <p pdwFrameSize> parameter should be initialized to the maximum frame
 *   size, before calling the <f vcmStreamRestorePayload> function.
 *
 * @xref <f vcmStreamFormatPayload>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamRestorePayload(HVCMSTREAM hvs, WSABUF *ppDataPkt, DWORD dwPktCount, PBYTE pbyFrame, PDWORD pdwFrameSize, BOOL *pfReceivedKeyframe)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;
	DWORD		dwHeaderSize = 0UL;
	DWORD		dwPSCBytes = 0UL;
	DWORD		dwMaxFrameSize;
#ifdef DEBUG
	char		szTDebug[256];
#endif
#ifdef LOGPAYLOAD_ON
	PBYTE		p = pbyFrame;
	HANDLE		g_TDebugFile;
	DWORD		d, GOBn;
	long		j = (long)(BYTE)ppDataPkt->buf[3];
#endif

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamRestorePayload: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (!ppDataPkt)
	{
		ERRORMESSAGE(("vcmStreamRestorePayload: Specified pointer is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!dwPktCount)
	{
		ERRORMESSAGE(("vcmStreamRestorePayload: Specified packet count is invalid, dwPktCount=0\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pbyFrame)
	{
		ERRORMESSAGE(("vcmStreamRestorePayload: Specified pointer is invalid, pbyFrame=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pdwFrameSize)
	{
		ERRORMESSAGE(("vcmStreamRestorePayload: Specified pointer is invalid, pdwFrameSize=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Save maximum payload size
	dwMaxFrameSize = *pdwFrameSize;

	// Initialize payload size
	*pdwFrameSize = 0;

	// Initialize default frame type
	*pfReceivedKeyframe = FALSE;

	// What is the type of this payload
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
	if ((pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH26X))
#else
	if (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263)
#endif
#else
	if (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_DECH263)
#endif
	{
		// Strip the header of each packet and copy the payload in the video buffer
		while (dwPktCount--)
		{
			// Look for the first two bits to figure out what's the mode used.
			// This will dictate the size of the header to be removed.
			// Mode A is 4 bytes: first bit is set to 1,
			// Mode B is 8 bytes: first bit is set to 0, second bit is set to 0,
			// Mode C is 12 bytes: first bit is set to 0, second bit is set to 1.
			dwHeaderSize = ((ppDataPkt->buf[0] & 0x80) ? ((ppDataPkt->buf[0] & 0x40) ? 12 : 8) : 4);

			// Look at the payload header to figure out if the frame is a keyframe
			*pfReceivedKeyframe |= (BOOL)(ppDataPkt->buf[2] & 0x80);

#ifdef LOGPAYLOAD_ON
			// Output some debug stuff
			if (dwHeaderSize == 4)
			{
				GOBn = (DWORD)((BYTE)ppDataPkt->buf[4]) << 24 | (DWORD)((BYTE)ppDataPkt->buf[5]) << 16 | (DWORD)((BYTE)ppDataPkt->buf[6]) << 8 | (DWORD)((BYTE)ppDataPkt->buf[7]);
				GOBn >>= (DWORD)(10 - (DWORD)((ppDataPkt->buf[0] & 0x38) >> 3));
				GOBn &= 0x0000001F;
				wsprintf(szTDebug, "Header content: Frame %3ld, GOB %0ld\r\n", (DWORD)(ppDataPkt->buf[3]), GOBn);
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[0] & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[0] & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  SBIT:    %01ld\r\n", (DWORD)((ppDataPkt->buf[0] & 0x38) >> 3));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  EBIT:    %01ld\r\n", (DWORD)(ppDataPkt->buf[0] & 0x07));
				OutputDebugString(szTDebug);
				switch ((DWORD)(ppDataPkt->buf[1] >> 5))
				{
					case 0:
						wsprintf(szTDebug, "   SRC: '000' => Source format forbidden!\r\n");
						break;
					case 1:
						wsprintf(szTDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
						break;
					case 2:
						wsprintf(szTDebug, "   SRC: '010' => Source format QCIF\r\n");
						break;
					case 3:
						wsprintf(szTDebug, "   SRC: '011' => Source format CIF\r\n");
						break;
					case 4:
						wsprintf(szTDebug, "   SRC: '100' => Source format 4CIF\r\n");
						break;
					case 5:
						wsprintf(szTDebug, "   SRC: '101' => Source format 16CIF\r\n");
						break;
					case 6:
						wsprintf(szTDebug, "   SRC: '110' => Source format reserved\r\n");
						break;
					case 7:
						wsprintf(szTDebug, "   SRC: '111' => Source format reserved\r\n");
						break;
					default:
						wsprintf(szTDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(ppDataPkt->buf[1] >> 5));
						break;
				}
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)((ppDataPkt->buf[1] & 0x1F) >> 5));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[2] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[2] & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[2] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "   DBQ:    %01ld  => Should be 0\r\n", (DWORD)((ppDataPkt->buf[2] & 0x18) >> 3));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "   TRB:    %01ld  => Should be 0\r\n", (DWORD)(ppDataPkt->buf[2] & 0x07));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "    TR:  %03ld\r\n", (DWORD)(ppDataPkt->buf[3]));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "Header: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[0], (BYTE)ppDataPkt->buf[1], (BYTE)ppDataPkt->buf[2], (BYTE)ppDataPkt->buf[3]);
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "dword1: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[4], (BYTE)ppDataPkt->buf[5], (BYTE)ppDataPkt->buf[6], (BYTE)ppDataPkt->buf[7]);
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "dword2: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[8], (BYTE)ppDataPkt->buf[9], (BYTE)ppDataPkt->buf[10], (BYTE)ppDataPkt->buf[11]);
				OutputDebugString(szTDebug);
			}
			else if (dwHeaderSize == 8)
			{
				wsprintf(szTDebug, "Header content:\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[0] & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[0] & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  SBIT:    %01ld\r\n", (DWORD)((ppDataPkt->buf[0] & 0x38) >> 3));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  EBIT:    %01ld\r\n", (DWORD)(ppDataPkt->buf[0] & 0x07));
				OutputDebugString(szTDebug);
				switch ((DWORD)(ppDataPkt->buf[1] >> 5))
				{
					case 0:
						wsprintf(szTDebug, "   SRC: '000' => Source format forbidden!\r\n");
						break;
					case 1:
						wsprintf(szTDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
						break;
					case 2:
						wsprintf(szTDebug, "   SRC: '010' => Source format QCIF\r\n");
						break;
					case 3:
						wsprintf(szTDebug, "   SRC: '011' => Source format CIF\r\n");
						break;
					case 4:
						wsprintf(szTDebug, "   SRC: '100' => Source format 4CIF\r\n");
						break;
					case 5:
						wsprintf(szTDebug, "   SRC: '101' => Source format 16CIF\r\n");
						break;
					case 6:
						wsprintf(szTDebug, "   SRC: '110' => Source format reserved\r\n");
						break;
					case 7:
						wsprintf(szTDebug, "   SRC: '111' => Source format reserved\r\n");
						break;
					default:
						wsprintf(szTDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(ppDataPkt->buf[1] >> 5));
						break;
				}
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, " QUANT:   %02ld\r\n", (DWORD)((ppDataPkt->buf[1] & 0x1F) >> 5));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[2] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[2] & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[2] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  GOBN:  %03ld\r\n", (DWORD)(ppDataPkt->buf[2] & 0x1F));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "   MBA:  %03ld\r\n", (DWORD)(ppDataPkt->buf[3]));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  HMV1:  %03ld\r\n", (DWORD)(ppDataPkt->buf[7]));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  VMV1:  %03ld\r\n", (DWORD)(ppDataPkt->buf[6]));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  HMV2:  %03ld\r\n", (DWORD)(ppDataPkt->buf[5]));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  VMV2:  %03ld\r\n", (DWORD)(ppDataPkt->buf[4]));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "Header: %02lX %02lX %02lX %02lX %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[0], (BYTE)ppDataPkt->buf[1], (BYTE)ppDataPkt->buf[2], (BYTE)ppDataPkt->buf[3], (BYTE)ppDataPkt->buf[4], (BYTE)ppDataPkt->buf[5], (BYTE)ppDataPkt->buf[6], (BYTE)ppDataPkt->buf[7]);
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "dword1: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[8], (BYTE)ppDataPkt->buf[9], (BYTE)ppDataPkt->buf[10], (BYTE)ppDataPkt->buf[11]);
				OutputDebugString(szTDebug);
			}
#endif

			// The purpose of this code is to look for the presence of the
			// Picture Start Code at the beginning of the frame. If it is
			// not present, we should break in debug mode.

			// Only look for PSC at the beginning of the frame
			if (!*pdwFrameSize)
			{
				// The start of the frame may not be at a byte boundary. The SBIT field
				// of the header ((BYTE)ppDataPkt->buf[0] & 0xE0) will tell us exactly where
				// our frame starts. We then look for the PSC (0000 0000 0000 0000 1000 00 bits)
				*((BYTE *)&dwPSCBytes + 3) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize]);
				*((BYTE *)&dwPSCBytes + 2) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize + 1]);
				*((BYTE *)&dwPSCBytes + 1) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize + 2]);
				*((BYTE *)&dwPSCBytes + 0) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize + 3]);
				dwPSCBytes <<= ((DWORD)((BYTE)ppDataPkt->buf[0] & 0x38) >> 3);
				if ((dwPSCBytes & 0xFFFFFC00) != 0x00008000)
				{
#ifdef DEBUG
					wsprintf(szTDebug, "VCMSTRM: The first packet to reassemble is missing a PSC!\r\n");
					OutputDebugString(szTDebug);
					// DebugBreak();
#endif
					return ((MMRESULT)VCMERR_PSCMISSING);
				}
			}

			// The end of a buffer and the start of the next buffer could belong to the
			// same byte. If this is the case, the first byte of the next buffer was already
			// copied in the video data buffer, with the previous packet. It should not be copied
			// twice. The SBIT field of the payload header allows us to figure out if this is the case.
			if (*pdwFrameSize && (ppDataPkt->buf[0] & 0x38))
				dwHeaderSize++;

#if 0
			//
			// THIS IS FOR EXPERIMENTATION ONLY !!!
			//

			// For I frames, ditch their middle GOB
			if (((dwHeaderSize == 4) || (dwHeaderSize == 5)) && (GOBn == 8) && (ppDataPkt->buf[2] & 0x80))
			{
				wsprintf(szTDebug, "Ditched GOB %2ld of I frame %3ld!\r\n", GOBn, (DWORD)(ppDataPkt->buf[3]));
				OutputDebugString(szTDebug);
				ppDataPkt++;
			}
			else if (((dwHeaderSize == 4) || (dwHeaderSize == 5)) && GOBn && !(ppDataPkt->buf[2] & 0x80))
			{
				wsprintf(szTDebug, "Ditched all GOBs after GOB %2ld of P frame %3ld!\r\n", GOBn, (DWORD)(ppDataPkt->buf[3]));
				OutputDebugString(szTDebug);
				ppDataPkt++;
			}
			else
#endif
			// Verify that the source format has the same video resolution than the conversion stream
			// Test for invalid packets that have a length below the size of the payload header
			if ( (g_ITUSizes[(DWORD)(((BYTE)ppDataPkt->buf[1]) >> 5)].biWidth == pvs->pvfxSrc->bih.biWidth)
				&& (g_ITUSizes[(DWORD)(((BYTE)ppDataPkt->buf[1]) >> 5)].biHeight == pvs->pvfxSrc->bih.biHeight)
				&& (ppDataPkt->len >= dwHeaderSize)
				&& ((*pdwFrameSize + ppDataPkt->len - dwHeaderSize) <= dwMaxFrameSize) )
			{
				// Copy the payload
				CopyMemory(pbyFrame + *pdwFrameSize, ppDataPkt->buf + dwHeaderSize, ppDataPkt->len - dwHeaderSize);

				// Update the payload size and pointer to the input video packets
				*pdwFrameSize += ppDataPkt->len - dwHeaderSize;
			}
			else
			{
				// The total size of the reassembled packet would be larger than the maximum allowed!!!
				// Or the packet has a length less than the payload header size
				// Dump the frame
#ifdef DEBUG
				lstrcpyn(
				    szTDebug, 
				    (ppDataPkt->len >= dwHeaderSize) ? "VCMSTRM: Cumulative size of the reassembled packets is too large: discarding frame!\r\n" : "VCMSTRM: Packet length is smaller than payload header size: discarding frame!\r\n",
				    ARRAYSIZE(szTDebug));
                
				OutputDebugString(szTDebug);
#endif
				return ((MMRESULT)VCMERR_NONSPECIFIC);
			}
			ppDataPkt++;

		}

#ifdef LOGPAYLOAD_ON
		g_TDebugFile = CreateFile("C:\\RecvLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
		SetFilePointer(g_TDebugFile, 0, NULL, FILE_END);
		wsprintf(szTDebug, "Frame #%03ld\r\n", (DWORD)j);
		WriteFile(g_TDebugFile, szTDebug, strlen(szTDebug), &d, NULL);
		for (j=*pdwFrameSize; j>0; j-=4, p+=4)
		{
			wsprintf(szTDebug, "%02lX %02lX %02lX %02lX\r\n", *((BYTE *)p), *((BYTE *)p+1), *((BYTE *)p+2), *((BYTE *)p+3));
			WriteFile(g_TDebugFile, szTDebug, strlen(szTDebug), &d, NULL);
		}
		CloseHandle(g_TDebugFile);
#endif

	}
#ifndef _ALPHA_
	else if (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH261)
#else
	else if (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_DECH261)
#endif
	{
		// Strip the header of each packet and copy the payload in the video buffer
		while (dwPktCount--)
		{

#ifdef LOGPAYLOAD_ON
			// wsprintf(szDebug, "Header: %02lX %02lX %02lX %02lX\r\ndword1: %02lX %02lX %02lX %02lX\r\ndword2: %02lX %02lX %02lX %02lX\r\n", ppDataPkt->buf[0], ppDataPkt->buf[1], ppDataPkt->buf[2], ppDataPkt->buf[3], ppDataPkt->buf[4], ppDataPkt->buf[5], ppDataPkt->buf[6], ppDataPkt->buf[7], ppDataPkt->buf[8], ppDataPkt->buf[9], ppDataPkt->buf[10], ppDataPkt->buf[11]);
			wsprintf(szTDebug, "Header: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[0], (BYTE)ppDataPkt->buf[1], (BYTE)ppDataPkt->buf[2], (BYTE)ppDataPkt->buf[3]);
			OutputDebugString(szTDebug);
			wsprintf(szTDebug, "dword1: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[4], (BYTE)ppDataPkt->buf[5], (BYTE)ppDataPkt->buf[6], (BYTE)ppDataPkt->buf[7]);
			OutputDebugString(szTDebug);
			wsprintf(szTDebug, "dword2: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[8], (BYTE)ppDataPkt->buf[9], (BYTE)ppDataPkt->buf[10], (BYTE)ppDataPkt->buf[11]);
			OutputDebugString(szTDebug);
#endif

			// The H.261 payload header size is always 4 bytes long
			dwHeaderSize = 4;

			// Look at the payload header to figure out if the frame is a keyframe
			*pfReceivedKeyframe |= (BOOL)(ppDataPkt->buf[0] & 0x02);

			// The purpose of this code is to look for the presence of the
			// Picture Start Code at the beginning of the frame. If it is
			// not present, we should break in debug mode.

			// Only look for PSC at the beginning of the frame
			if (!*pdwFrameSize)
			{
				// The start of the frame may not be at a byte boundary. The SBIT field
				// of the header ((BYTE)ppDataPkt->buf[0] & 0xE0) will tell us exactly where
				// our frame starts. We then look for the PSC (0000 0000 0000 0001 0000 bits)
				*((BYTE *)&dwPSCBytes + 3) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize]);
				*((BYTE *)&dwPSCBytes + 2) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize + 1]);
				*((BYTE *)&dwPSCBytes + 1) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize + 2]);
				*((BYTE *)&dwPSCBytes + 0) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize + 3]);
				dwPSCBytes <<= ((DWORD)((BYTE)ppDataPkt->buf[0] & 0xE0) >> 5);
				if ((dwPSCBytes & 0xFFFFF000) != 0x00010000)
				{
#ifdef DEBUG
					wsprintf(szTDebug, "VCMSTRM: The first packet to reassemble is missing a PSC!\r\n");
					OutputDebugString(szTDebug);
					// DebugBreak();
#endif
					return ((MMRESULT)VCMERR_PSCMISSING);
				}
			}

			// The end of a buffer and the start of the next buffer could belong to the
			// same byte. If this is the case, the first byte of the next buffer was already
			// copied in the video data buffer, with the previous packet. It should not be copied
			// twice. The SBIT field of the payload header allows us to figure out if this is the case.
			if (*pdwFrameSize && (ppDataPkt->buf[0] & 0xE0))
				dwHeaderSize++;

			// Copy the payload
			// Test for invalid packets that have a length below the size of the payload header
			if ( (ppDataPkt->len >= dwHeaderSize) && ((*pdwFrameSize + ppDataPkt->len - dwHeaderSize) <= dwMaxFrameSize) )
			{
				// Copy the payload
				CopyMemory(pbyFrame + *pdwFrameSize, ppDataPkt->buf + dwHeaderSize, ppDataPkt->len - dwHeaderSize);

				// Update the payload size and pointer to the input video packets
				*pdwFrameSize += ppDataPkt->len - dwHeaderSize;
				ppDataPkt++;
			}
			else
			{
				// The total size of the reassembled packet would be larger than the maximum allowed!!!
				// Or the packet has a length less than the payload header size
				// Dump the frame
#ifdef DEBUG
				lstrcpyn(
				    szTDebug, 
				    (ppDataPkt->len >= dwHeaderSize) ? "VCMSTRM: Cumulative size of the reassembled packets is too large: discarding frame!\r\n" : "VCMSTRM: Packet length is smaller than payload header size: discarding frame!\r\n",
				    ARRAYSIZE(szTDebug));
                
				OutputDebugString(szTDebug);
				// DebugBreak();
#endif
				return ((MMRESULT)VCMERR_NONSPECIFIC);
			}

		}

#ifdef LOGPAYLOAD_ON
		g_TDebugFile = CreateFile("C:\\RecvLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
		SetFilePointer(g_TDebugFile, 0, NULL, FILE_END);
		wsprintf(szTDebug, "Frame #%03ld\r\n", (DWORD)j);
		WriteFile(g_TDebugFile, szTDebug, strlen(szTDebug), &d, NULL);
		for (j=*pdwFrameSize; j>0; j-=4, p+=4)
		{
			wsprintf(szTDebug, "%02lX %02lX %02lX %02lX\r\n", *((BYTE *)p), *((BYTE *)p+1), *((BYTE *)p+2), *((BYTE *)p+3));
			WriteFile(g_TDebugFile, szTDebug, strlen(szTDebug), &d, NULL);
		}
		CloseHandle(g_TDebugFile);
#endif

	}
	else
	{
		// Strip the header of each packet and copy the payload in the video buffer
		while (dwPktCount--)
		{
			// Copy the payload
			// Test for invalid packets that have a length below the size of the payload header
			if ( (ppDataPkt->len >= dwHeaderSize) && ((*pdwFrameSize + ppDataPkt->len - dwHeaderSize) <= dwMaxFrameSize))
			{
				// Copy the payload
				CopyMemory(pbyFrame + *pdwFrameSize, ppDataPkt->buf + dwHeaderSize, ppDataPkt->len - dwHeaderSize);

				// Update the payload size and pointer to the input video packets
				*pdwFrameSize += ppDataPkt->len - dwHeaderSize;
				ppDataPkt++;
			}
			else
			{
				// The total size of the reassembled packet would be larger than the maximum allowed!!!
				// Or the packet has a length less than the payload header size
				// Dump the frame
#ifdef DEBUG
				lstrcpyn(
				    szTDebug, 
				    (ppDataPkt->len >= dwHeaderSize) ? "VCMSTRM: Cumulative size of the reassembled packets is too large: discarding frame!\r\n" : "VCMSTRM: Packet length is smaller than payload header size: discarding frame!\r\n",
			        ARRAYSIZE(szTDebug));

				OutputDebugString(szTDebug);
				// DebugBreak();
#endif
				return ((MMRESULT)VCMERR_NONSPECIFIC);
			}

		}
	}

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamFormatPayload | This function returns compressed data
 *   spread into data packets with a payload header for the specific format of the
 *   compressed data.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm PBYTE | pDataSrc | Specifies a pointer to the whole compressed data.
 *
 * @parm DWORD | dwDataSize | Specifies the size of the input data in bytes.
 *
 * @parm PBYTE* | ppDataPkt | Specifies a pointer to a pointer to a packet.
 *
 * @parm DWORD* | pdwPktSize | Specifies a pointer to the size of the packet.
 *
 * @parm DWORD | dwPktCount | Specifies what packet to return (0 first packet, 1 second packet, ...)
 *
 * @parm DWORD | dwMaxFragSize | Specifies the maximum packet size
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified data pointer is invalid.
 *   @flag VCMERR_NOMOREPACKETS | There is no more data for the requested packet number, or there isn't any handler for this payload.
 *   @flag VCMERR_NONSPECIFIC | We were asked to put a header we do not know how to generate.
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamFormatPayload(	HVCMSTREAM hvs,
										PBYTE pDataSrc,
										DWORD dwDataSize,
										PBYTE *ppDataPkt,
										PDWORD pdwPktSize,
										PDWORD pdwPktCount,
										UINT *pfMark,
										PBYTE *pHdrInfo,
										PDWORD pdwHdrSize)
{
	PVCMSTREAM					pvs = (PVCMSTREAM)hvs;
	PH26X_RTP_BSINFO_TRAILER	pbsiT;
	PRTP_H263_BSINFO			pbsi263;
	PRTP_H261_BSINFO			pbsi261;
	PBYTE						pb;
	DWORD						dwHeaderHigh = 0UL; // most significant
	DWORD						dwHeaderMiddle = 0UL;
	DWORD						dwHeaderLow = 0UL; // least significant
	BOOL						bOneFrameOnePacket;
#ifdef DEBUG
	char						szDebug[256];
#endif
	long						i;
#ifdef LOGPAYLOAD_ON
	PBYTE						p;
	DWORD						d;
	DWORD						dwLastChunk;
	DWORD						wPrevOffset;
#endif

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamFormatPayload: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (!pDataSrc)
	{
		ERRORMESSAGE(("vcmStreamFormatPayload: Specified pointer is invalid, pDataSrc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Initialize packet pointer
	*ppDataPkt  = pDataSrc;
	*pdwPktSize = dwDataSize;
	*pfMark = 1;
	bOneFrameOnePacket = FALSE;

	// Put the code that builds the packets right here!!!
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
	if ((pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH26X))
#else
	if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH263)
#endif
#else
	if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_DECH263)
#endif
	{
		// Look for the bitstream info trailer
		pbsiT = (PH26X_RTP_BSINFO_TRAILER)(pDataSrc + dwDataSize - sizeof(H26X_RTP_BSINFO_TRAILER));

		// If the whole frame can fit in pvs->dwMaxPacketSize, send it non fragmented
		if ((pbsiT->dwCompressedSize + 4) < pvs->dwMaxPacketSize)
			bOneFrameOnePacket = TRUE;

		// Look for the packet to receive a H.263 payload header
		if ((*pdwPktCount < pbsiT->dwNumOfPackets) && !(bOneFrameOnePacket && *pdwPktCount))
		{

#ifdef _ALPHA_
			// Verify that the content of the bistream info structures is correct
			// If not, do not parse the frame, and fail the call
			// This is to solve problems with the data returned by the DEC codecs
			if (!*pdwPktCount)
			{
				pbsi263 = (PRTP_H263_BSINFO)((PBYTE)pbsiT - pbsiT->dwNumOfPackets * sizeof(RTP_H263_BSINFO));
				for (i=1; i<(long)pbsiT->dwNumOfPackets; i++, pbsi263++)
				{
					if ((pbsi263->dwBitOffset >= (pbsi263+1)->dwBitOffset) || ((pbsiT->dwCompressedSize*8) <= pbsi263->dwBitOffset))
					{
#ifdef DEBUG
						OutputDebugString("VCMSTRM: The content of the extended bitstream info structures is invalid!\r\n");
#endif
						// return ((MMRESULT)VCMERR_NONSPECIFIC);
						bOneFrameOnePacket = TRUE;
					}
				}

				// Test last info strucure
				if ( !bOneFrameOnePacket && ((pbsiT->dwCompressedSize*8) <= pbsi263->dwBitOffset))
				{
#ifdef DEBUG
					OutputDebugString("VCMSTRM: The content of the extended bitstream info structures is invalid!\r\n");
#endif
					// return ((MMRESULT)VCMERR_NONSPECIFIC);
					bOneFrameOnePacket = TRUE;
				}
			}
#endif

#ifdef LOGPAYLOAD_ON
			// Dump the whole frame in the debug window for comparison with receive side
			if (!*pdwPktCount)
			{
				g_DebugFile = CreateFile("C:\\SendLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
				SetFilePointer(g_DebugFile, 0, NULL, FILE_END);
				wsprintf(szDebug, "Frame #%03ld\r\n", (DWORD)pbsiT->byTR);
				WriteFile(g_DebugFile, szDebug, strlen(szDebug), &d, NULL);
				wsprintf(szDebug, "Frame #%03ld has %1ld packets of size ", (DWORD)pbsiT->byTR, (DWORD)pbsiT->dwNumOfPackets);
				OutputDebugString(szDebug);
				pbsi263 = (PRTP_H263_BSINFO)((PBYTE)pbsiT - pbsiT->dwNumOfPackets * sizeof(RTP_H263_BSINFO));
				for (i=1; i<(long)pbsiT->dwNumOfPackets; i++)
				{
					wPrevOffset = pbsi263->dwBitOffset;
					pbsi263++;
					wsprintf(szDebug, "%04ld, ", (DWORD)(pbsi263->dwBitOffset - wPrevOffset) >> 3);
					OutputDebugString(szDebug);
				}
				wsprintf(szDebug, "%04ld\r\n", (DWORD)(pbsiT->dwCompressedSize * 8 - pbsi263->dwBitOffset) >> 3);
				OutputDebugString(szDebug);
				for (i=pbsiT->dwCompressedSize, p=pDataSrc; i>0; i-=4, p+=4)
				{
					wsprintf(szDebug, "%02lX %02lX %02lX %02lX\r\n", *((BYTE *)p), *((BYTE *)p+1), *((BYTE *)p+2), *((BYTE *)p+3));
					WriteFile(g_DebugFile, szDebug, strlen(szDebug), &d, NULL);
				}
				CloseHandle(g_DebugFile);
			}
#endif
			
			// Look for the bitstream info structure
			pbsi263 = (PRTP_H263_BSINFO)((PBYTE)pbsiT - (pbsiT->dwNumOfPackets - *pdwPktCount) * sizeof(RTP_H263_BSINFO));
			
			// Set the marker bit: as long as this is not the last packet of the frame
			// this bit needs to be set to 0
			if (!bOneFrameOnePacket)
			{
				// Count the number of GOBS that could fit in pvs->dwMaxPacketSize
				for (i=1; (i<(long)(pbsiT->dwNumOfPackets - *pdwPktCount)) && (pbsi263->byMode != RTP_H263_MODE_B); i++)
				{
					// Don't try to add a Mode B packet to the end of another Mode A or Mode B packet
					if (((pbsi263+i)->dwBitOffset - pbsi263->dwBitOffset > (pvs->dwMaxPacketSize * 8)) || ((pbsi263+i)->byMode == RTP_H263_MODE_B))
						break;
				}

				if (i < (long)(pbsiT->dwNumOfPackets - *pdwPktCount))
				{
					*pfMark = 0;
					if (i>1)
						i--;
				}
				else
				{
					// Hey! You 're forgetting the last GOB! It could make the total
					// size of the last packet larger than pvs->dwMaxPacketSize... Imbecile!
					if ((pbsiT->dwCompressedSize * 8 - pbsi263->dwBitOffset > (pvs->dwMaxPacketSize * 8)) && (i>1))
					{
						*pfMark = 0;
						i--;
					}
				}

#if 0
				//
				// THIS IS FOR EXPERIMENTATION ONLY !!!
				//

				// Ditch the last GOB
				if ((*pfMark == 1) && (i == 1))
					return ((MMRESULT)VCMERR_NOMOREPACKETS);
#endif
			}

			// Go to the beginning of the data
			pb = pDataSrc + pbsi263->dwBitOffset / 8;

#if 0
			//
			// THIS IS FOR EXPERIMENTATION ONLY !!!
			//

			// Trash the PSC once in a while to see how the other end reacts
			if (!*pdwPktCount && (((*pb == 0) && (*(pb+1) == 0) && ((*(pb+2) & 0xFC) == 0x80))))
			{
				// The previous test guarantees that it is in fact a PSC that we trash...
				if ((DWORD)(RAND_MAX - rand()) < (DWORD)(RAND_MAX / 10))
					*pb = 0xFF;
			}
#endif

#ifdef DEBUG
			if (!*pdwPktCount && (((*pb != 0) || (*(pb+1) != 0) || ((*(pb+2) & 0xFC) != 0x80))))
			{
				wsprintf(szDebug, "VCMSTRM: This compressed frame is missing a PSC!\r\n");
				OutputDebugString(szDebug);
				// DebugBreak();
			}
#endif

			// Look for the kind of header to be built
			if (pbsi263->byMode == RTP_H263_MODE_A)
			{
				// Build a header in mode A

				// 0                   1                   2                   3
				// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				//|F|P|SBIT |EBIT | SRC | R       |I|A|S|DBQ| TRB |    TR         |
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				// But that's the network byte order...

				// F bit already set to 0

				// Set the SRC bits
				dwHeaderHigh |= ((DWORD)(pbsiT->bySrc)) << 21;

				// R bits already set to 0

				// Set the P bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_PB) << 29;

				// Set the I bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H26X_INTRA_CODED) << 15;

				// Set the A bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_AP) << 12;

				// Set the S bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_SAC) << 10;

				// Set the DBQ bits
				dwHeaderHigh |= ((DWORD)(pbsiT->byDBQ)) << 11;

				// Set the TRB bits
				dwHeaderHigh |= ((DWORD)(pbsiT->byTRB)) << 8;

				// Set the TR bits
				dwHeaderHigh |= ((DWORD)(pbsiT->byTR));

				// Special case: 1 frame = 1 packet
				if (bOneFrameOnePacket)
				{
					// SBIT is already set to 0

					// EBIT is already set to 0

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
					ERRORMESSAGE(("vcmFormatPayload: (1F1P) Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld (New frame)\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0x38000000) >> 27, (DWORD)(dwHeaderHigh & 0x07000000) >> 24));
#endif // } VALIDATE_SBIT_EBIT

					// Update the packet size
					*pdwPktSize = pbsiT->dwCompressedSize + 4;

					// Update the packet count
					*pdwPktCount = pbsiT->dwNumOfPackets;

				}
				else
				{
#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
					DWORD dwCurrentSBIT;
#endif // } VALIDATE_SBIT_EBIT

					// Set the SBIT bits
					dwHeaderHigh |= (pbsi263->dwBitOffset % 8) << 27;

					// Set the EBIT bits
					if ((pbsiT->dwNumOfPackets - *pdwPktCount - i) >= 1)
						dwHeaderHigh |= (DWORD)((8UL - ((pbsi263+i)->dwBitOffset % 8)) & 0x00000007) << 24;

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
					// Compare this to the previous EBIT. If the sum of the two
					// is not equal to 8 or 0, something's broken
					if (*pdwPktCount)
						ERRORMESSAGE(("vcmFormatPayload: Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0x38000000) >> 27, (DWORD)(dwHeaderHigh & 0x07000000) >> 24));
					else
						ERRORMESSAGE(("vcmFormatPayload: Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld (New frame)\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0x38000000) >> 27, (DWORD)(dwHeaderHigh & 0x07000000) >> 24));

					// Only test this if this is the first packet
					dwCurrentSBIT = (DWORD)(dwHeaderHigh & 0x38000000) >> 27;
					if ((*pdwPktCount) && (((dwCurrentSBIT + g_dwPreviousEBIT) != 8) && (((dwCurrentSBIT + g_dwPreviousEBIT) != 0))))
						DebugBreak();

					g_dwPreviousEBIT = (dwHeaderHigh & 0x07000000) >> 24;
#endif // } VALIDATE_SBIT_EBIT

					// Update the packet size
					if ((pbsiT->dwNumOfPackets - *pdwPktCount - i) >= 1)
						*pdwPktSize = (((pbsi263+i)->dwBitOffset - 1) / 8) - (pbsi263->dwBitOffset / 8) + 1 + 4;
					else
						*pdwPktSize = pbsiT->dwCompressedSize - pbsi263->dwBitOffset / 8 + 4;

					// Update the packet count
					*pdwPktCount += i;

				}

#if 0
				// Save the header right before the data chunk
				*ppDataPkt = pDataSrc + (pbsi263->dwBitOffset / 8) - 4;

				// Convert to network byte order
				*((BYTE *)*ppDataPkt+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
				*((BYTE *)*ppDataPkt+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
				*((BYTE *)*ppDataPkt+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
				*((BYTE *)*ppDataPkt) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
#else
				// Save the header right before the data chunk
				*ppDataPkt = pDataSrc + (pbsi263->dwBitOffset / 8) - 4;
                *pdwHdrSize=4;

				// Convert to network byte order
				*((BYTE *)*pHdrInfo+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
				*((BYTE *)*pHdrInfo+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
				*((BYTE *)*pHdrInfo+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
				*((BYTE *)*pHdrInfo) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
#endif

#ifdef LOGPAYLOAD_ON
				// Output some debug stuff
				wsprintf(szDebug, "Header content:\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*(BYTE *)*ppDataPkt & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*(BYTE *)*ppDataPkt & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  SBIT:    %01ld\r\n", (DWORD)((*(BYTE *)*ppDataPkt & 0x38) >> 3));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  EBIT:    %01ld\r\n", (DWORD)(*(BYTE *)*ppDataPkt & 0x07));
				OutputDebugString(szDebug);
				switch ((DWORD)(*((BYTE *)*ppDataPkt+1) >> 5))
				{
					case 0:
						wsprintf(szDebug, "   SRC: '000' => Source format forbidden!\r\n");
						break;
					case 1:
						wsprintf(szDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
						break;
					case 2:
						wsprintf(szDebug, "   SRC: '010' => Source format QCIF\r\n");
						break;
					case 3:
						wsprintf(szDebug, "   SRC: '011' => Source format CIF\r\n");
						break;
					case 4:
						wsprintf(szDebug, "   SRC: '100' => Source format 4CIF\r\n");
						break;
					case 5:
						wsprintf(szDebug, "   SRC: '101' => Source format 16CIF\r\n");
						break;
					case 6:
						wsprintf(szDebug, "   SRC: '110' => Source format reserved\r\n");
						break;
					case 7:
						wsprintf(szDebug, "   SRC: '111' => Source format reserved\r\n");
						break;
					default:
						wsprintf(szDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(*((BYTE *)*ppDataPkt+1) >> 5));
						break;
				}
				OutputDebugString(szDebug);
				wsprintf(szDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)((*((BYTE *)*ppDataPkt+1) & 0x1F) >> 5));
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*((BYTE *)*ppDataPkt+2) & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*((BYTE *)*ppDataPkt+2) & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*((BYTE *)*ppDataPkt+2) & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, "   DBQ:    %01ld  => Should be 0\r\n", (DWORD)((*((BYTE *)*ppDataPkt+2) & 0x18) >> 3));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "   TRB:    %01ld  => Should be 0\r\n", (DWORD)(*((BYTE *)*ppDataPkt+2) & 0x07));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "    TR:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+3)));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "Packet: %02lX\r\n Header: %02lX %02lX %02lX %02lX\r\n dword1: %02lX %02lX %02lX %02lX\r\n dword2: %02lX %02lX %02lX %02lX\r\n", *pdwPktCount, *((BYTE *)*ppDataPkt), *((BYTE *)*ppDataPkt+1), *((BYTE *)*ppDataPkt+2), *((BYTE *)*ppDataPkt+3), *((BYTE *)*ppDataPkt+4), *((BYTE *)*ppDataPkt+5), *((BYTE *)*ppDataPkt+6), *((BYTE *)*ppDataPkt+7), *((BYTE *)*ppDataPkt+8), *((BYTE *)*ppDataPkt+9), *((BYTE *)*ppDataPkt+10), *((BYTE *)*ppDataPkt+11));
				OutputDebugString(szDebug);
				if (*pdwPktCount == pbsiT->dwNumOfPackets)
					wsprintf(szDebug, " Tail  : %02lX %02lX XX XX\r\n", *((BYTE *)*ppDataPkt+*pdwPktSize-2), *((BYTE *)*ppDataPkt+*pdwPktSize-1));
				else
					wsprintf(szDebug, " Tail  : %02lX %02lX %02lX %02lX\r\n", *((BYTE *)*ppDataPkt+*pdwPktSize-2), *((BYTE *)*ppDataPkt+*pdwPktSize-1), *((BYTE *)*ppDataPkt+*pdwPktSize), *((BYTE *)*ppDataPkt+*pdwPktSize+1));
				OutputDebugString(szDebug);
				if (*pfMark == 1)
					wsprintf(szDebug, " Marker: ON\r\n");
				else
					wsprintf(szDebug, " Marker: OFF\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, "Frame #%03ld, Packet of size %04ld\r\n", (DWORD)pbsiT->byTR, *pdwPktSize);
				OutputDebugString(szDebug);
#endif
			}
			else if (pbsi263->byMode == RTP_H263_MODE_B)
			{
				// Build a header in mode B

				// 0                   1                   2                   3
				// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				//|F|P|SBIT |EBIT | SRC | QUANT   |I|A|S|  GOBN   |   MBA         |
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				//| HMV1          |  VMV1         |  HMV2         |   VMV2        |
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

				// But that's the network byte order...

				// Set the F bit to 1
				dwHeaderHigh = 0x80000000;

				// Set the SRC bits
				dwHeaderHigh |= ((DWORD)(pbsiT->bySrc)) << 21;

				// Set the QUANT bits
				dwHeaderHigh |= ((DWORD)(pbsi263->byQuant)) << 16;

				// Set the P bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_PB) << 29;

				// Set the I bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H26X_INTRA_CODED) << 15;

				// Set the A bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_AP) << 12;

				// Set the S bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_SAC) << 10;

				// Set the GOBN bits
				dwHeaderHigh |= ((DWORD)(pbsi263->byGOBN)) << 8;

				// Set the TR bits
				dwHeaderHigh |= ((DWORD)(pbsi263->byMBA));

				// Set the HMV1 bits
				dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cHMV1)) << 24;

				// Set the VMV1 bits
				dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cVMV1)) << 16;

				// Set the HMV2 bits
				dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cHMV2)) << 8;

				// Set the VMV2 bits
				dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cVMV2));

				// Special case: 1 frame = 1 packet
				if (bOneFrameOnePacket)
				{
					// SBIT is already set to 0

					// EBIT is already set to 0

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
					ERRORMESSAGE(("vcmFormatPayload: (1F1P) Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld (New frame)\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0x38000000) >> 27, (DWORD)(dwHeaderHigh & 0x07000000) >> 24));
#endif // } VALIDATE_SBIT_EBIT

					// Update the packet size
					*pdwPktSize = pbsiT->dwCompressedSize + 8;

					// Update the packet count
					*pdwPktCount = pbsiT->dwNumOfPackets;

				}
				else
				{

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
					DWORD dwCurrentSBIT;
#endif // } VALIDATE_SBIT_EBIT

					// Set the SBIT bits
					dwHeaderHigh |= (pbsi263->dwBitOffset % 8) << 27;

					// Set the EBIT bits
					if ((pbsiT->dwNumOfPackets - *pdwPktCount - i) >= 1)
						dwHeaderHigh |= (DWORD)((8UL - ((pbsi263+i)->dwBitOffset % 8)) & 0x00000007) << 24;

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
					// Compare this to the previous EBIT. If the sum of the two
					// is not equal to 8 or 0, something's broken
					if (*pdwPktCount)
						ERRORMESSAGE(("vcmFormatPayload: Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0x38000000) >> 27, (DWORD)(dwHeaderHigh & 0x07000000) >> 24));
					else
						ERRORMESSAGE(("vcmFormatPayload: Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld (New frame)\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0x38000000) >> 27, (DWORD)(dwHeaderHigh & 0x07000000) >> 24));

					// Only test this if this is the first packet
					dwCurrentSBIT = (DWORD)(dwHeaderHigh & 0x38000000) >> 27;
					if ((*pdwPktCount) && (((dwCurrentSBIT + g_dwPreviousEBIT) != 8) && (((dwCurrentSBIT + g_dwPreviousEBIT) != 0))))
						DebugBreak();

					g_dwPreviousEBIT = (dwHeaderHigh & 0x07000000) >> 24;
#endif // } VALIDATE_SBIT_EBIT

					// Update the packet size
					if ((pbsiT->dwNumOfPackets - *pdwPktCount - i) >= 1)
						*pdwPktSize = (((pbsi263+i)->dwBitOffset - 1) / 8) - (pbsi263->dwBitOffset / 8) + 1 + 8;
					else
						*pdwPktSize = pbsiT->dwCompressedSize - pbsi263->dwBitOffset / 8 + 8;

					// Update the packet count
					*pdwPktCount += i;

				}

#if 0
				// Save the header right before the data chunk
				*ppDataPkt = pDataSrc + (pbsi263->dwBitOffset / 8) - 8;

				// Convert to network byte order
				*((BYTE *)*ppDataPkt+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
				*((BYTE *)*ppDataPkt+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
				*((BYTE *)*ppDataPkt+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
				*((BYTE *)*ppDataPkt) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
				*((BYTE *)*ppDataPkt+7) = (BYTE)(dwHeaderLow & 0x000000FF);
				*((BYTE *)*ppDataPkt+6) = (BYTE)((dwHeaderLow >> 8) & 0x000000FF);
				*((BYTE *)*ppDataPkt+5) = (BYTE)((dwHeaderLow >> 16) & 0x000000FF);
				*((BYTE *)*ppDataPkt+4) = (BYTE)((dwHeaderLow >> 24) & 0x000000FF);
#else
				// Save the header right before the data chunk
				*ppDataPkt = pDataSrc + (pbsi263->dwBitOffset / 8) - 8;
                *pdwHdrSize=8;

				// Convert to network byte order
				*((BYTE *)*pHdrInfo+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
				*((BYTE *)*pHdrInfo+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
				*((BYTE *)*pHdrInfo+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
				*((BYTE *)*pHdrInfo) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
				*((BYTE *)*pHdrInfo+7) = (BYTE)(dwHeaderLow & 0x000000FF);
				*((BYTE *)*pHdrInfo+6) = (BYTE)((dwHeaderLow >> 8) & 0x000000FF);
				*((BYTE *)*pHdrInfo+5) = (BYTE)((dwHeaderLow >> 16) & 0x000000FF);
				*((BYTE *)*pHdrInfo+4) = (BYTE)((dwHeaderLow >> 24) & 0x000000FF);
#endif

#ifdef LOGPAYLOAD_ON
				// Output some info
				wsprintf(szDebug, "Header content:\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*(BYTE *)*ppDataPkt & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*(BYTE *)*ppDataPkt & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  SBIT:    %01ld\r\n", (DWORD)((*(BYTE *)*ppDataPkt & 0x38) >> 3));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  EBIT:    %01ld\r\n", (DWORD)(*(BYTE *)*ppDataPkt & 0x07));
				OutputDebugString(szDebug);
				switch ((DWORD)(*((BYTE *)*ppDataPkt+1) >> 5))
				{
					case 0:
						wsprintf(szDebug, "   SRC: '000' => Source format forbidden!\r\n");
						break;
					case 1:
						wsprintf(szDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
						break;
					case 2:
						wsprintf(szDebug, "   SRC: '010' => Source format QCIF\r\n");
						break;
					case 3:
						wsprintf(szDebug, "   SRC: '011' => Source format CIF\r\n");
						break;
					case 4:
						wsprintf(szDebug, "   SRC: '100' => Source format 4CIF\r\n");
						break;
					case 5:
						wsprintf(szDebug, "   SRC: '101' => Source format 16CIF\r\n");
						break;
					case 6:
						wsprintf(szDebug, "   SRC: '110' => Source format reserved\r\n");
						break;
					case 7:
						wsprintf(szDebug, "   SRC: '111' => Source format reserved\r\n");
						break;
					default:
						wsprintf(szDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(*((BYTE *)*ppDataPkt+1) >> 5));
						break;
				}
				OutputDebugString(szDebug);
				wsprintf(szDebug, " QUANT:   %02ld\r\n", (DWORD)((*((BYTE *)*ppDataPkt+1) & 0x1F) >> 5));
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*((BYTE *)*ppDataPkt+2) & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*((BYTE *)*ppDataPkt+2) & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*((BYTE *)*ppDataPkt+2) & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  GOBN:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+2) & 0x1F));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "   MBA:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+3)));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  HMV1:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+7)));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  VMV1:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+6)));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  HMV2:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+5)));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  VMV2:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+4)));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "Packet: %02lX\r\n Header: %02lX %02lX %02lX %02lX %02lX %02lX %02lX %02lX\r\n dword1: %02lX %02lX %02lX %02lX\r\n", *pdwPktCount, *((BYTE *)*ppDataPkt), *((BYTE *)*ppDataPkt+1), *((BYTE *)*ppDataPkt+2), *((BYTE *)*ppDataPkt+3), *((BYTE *)*ppDataPkt+4), *((BYTE *)*ppDataPkt+5), *((BYTE *)*ppDataPkt+6), *((BYTE *)*ppDataPkt+7), *((BYTE *)*ppDataPkt+8), *((BYTE *)*ppDataPkt+9), *((BYTE *)*ppDataPkt+10), *((BYTE *)*ppDataPkt+11));
				OutputDebugString(szDebug);
				if (*pdwPktCount == pbsiT->dwNumOfPackets)
					wsprintf(szDebug, " Tail  : %02lX %02lX XX XX\r\n", *((BYTE *)*ppDataPkt+*pdwPktSize-2), *((BYTE *)*ppDataPkt+*pdwPktSize-1));
				else
					wsprintf(szDebug, " Tail  : %02lX %02lX %02lX %02lX\r\n", *((BYTE *)*ppDataPkt+*pdwPktSize-2), *((BYTE *)*ppDataPkt+*pdwPktSize-1), *((BYTE *)*ppDataPkt+*pdwPktSize), *((BYTE *)*ppDataPkt+*pdwPktSize+1));
				OutputDebugString(szDebug);
				if (*pfMark == 1)
					wsprintf(szDebug, " Marker: ON\r\n");
				else
					wsprintf(szDebug, " Marker: OFF\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, "Frame #%03ld, Packet of size %04ld\r\n", (DWORD)pbsiT->byTR, *pdwPktSize);
				OutputDebugString(szDebug);
#endif
			}
			else if (pbsi263->byMode == RTP_H263_MODE_C)
			{
				// Build a header in mode C
#ifdef DEBUG
				wsprintf(szDebug, "VCMSTRM: We were asked to generate a MODE C H.263 payload header!");
				OutputDebugString(szDebug);
				// DebugBreak();
#endif
				return ((MMRESULT)VCMERR_NONSPECIFIC);
			}
		}
		else
			return ((MMRESULT)VCMERR_NOMOREPACKETS);
	}
#ifndef _ALPHA_
	else if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH261)
#else
	else if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_DECH261)
#endif
	{
		// Look for the bitstream info trailer
		pbsiT = (PH26X_RTP_BSINFO_TRAILER)(pDataSrc + dwDataSize - sizeof(H26X_RTP_BSINFO_TRAILER));

		// If the whole frame can fit in dwMaxFragSize, send it non fragmented
		if ((pbsiT->dwCompressedSize + 4) < pvs->dwMaxPacketSize)
			bOneFrameOnePacket = TRUE;

		// Look for the packet to receive a H.261 payload header
		if ((*pdwPktCount < pbsiT->dwNumOfPackets) && !(bOneFrameOnePacket && *pdwPktCount))
		{

#ifdef _ALPHA_
			// Verify that the content of the bistream info structures is correct
			// If not, do not parse the frame, and fail the call
			// This is to solve problems with the data returned by the DEC codecs
			if (!*pdwPktCount)
			{
				pbsi261 = (PRTP_H261_BSINFO)((PBYTE)pbsiT - pbsiT->dwNumOfPackets * sizeof(RTP_H261_BSINFO));
				for (i=1; i<(long)pbsiT->dwNumOfPackets; i++, pbsi261++)
				{
					if ((pbsi261->dwBitOffset >= (pbsi261+1)->dwBitOffset) || ((pbsiT->dwCompressedSize*8) <= pbsi261->dwBitOffset))
					{
#ifdef DEBUG
						OutputDebugString("VCMSTRM: The content of the extended bitstream info structures is invalid!\r\n");
#endif
						// return ((MMRESULT)VCMERR_NONSPECIFIC);
						bOneFrameOnePacket = TRUE;
					}
				}

				// Test last info strucure
				if ( !bOneFrameOnePacket && ((pbsiT->dwCompressedSize*8) <= pbsi261->dwBitOffset))
				{
#ifdef DEBUG
					OutputDebugString("VCMSTRM: The content of the extended bitstream info structures is invalid!\r\n");
#endif
					// return ((MMRESULT)VCMERR_NONSPECIFIC);
					bOneFrameOnePacket = TRUE;
				}
			}
#endif

#ifdef LOGPAYLOAD_ON
			// Dump the whole frame in the debug window for comparison with receive side
			if (!*pdwPktCount)
			{
				g_DebugFile = CreateFile("C:\\SendLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
				SetFilePointer(g_DebugFile, 0, NULL, FILE_END);
				wsprintf(szDebug, "Frame #%03ld\r\n", (DWORD)pbsiT->byTR);
				WriteFile(g_DebugFile, szDebug, strlen(szDebug), &d, NULL);
				wsprintf(szDebug, "Frame #%03ld has %1ld GOBs of size ", (DWORD)pbsiT->byTR, (DWORD)pbsiT->dwNumOfPackets);
				OutputDebugString(szDebug);
				pbsi261 = (PRTP_H261_BSINFO)((PBYTE)pbsiT - pbsiT->dwNumOfPackets * sizeof(RTP_H261_BSINFO));
				for (i=1; i<(long)pbsiT->dwNumOfPackets; i++)
				{
					wPrevOffset = pbsi261->dwBitOffset;
					pbsi261++;
					wsprintf(szDebug, "%04ld, ", (DWORD)(pbsi261->dwBitOffset - wPrevOffset) >> 3);
					OutputDebugString(szDebug);
				}
				wsprintf(szDebug, "%04ld\r\n", (DWORD)(pbsiT->dwCompressedSize * 8 - pbsi261->dwBitOffset) >> 3);
				OutputDebugString(szDebug);
				for (i=pbsiT->dwCompressedSize, p=pDataSrc; i>0; i-=4, p+=4)
				{
					wsprintf(szDebug, "%02lX %02lX %02lX %02lX\r\n", *((BYTE *)p), *((BYTE *)p+1), *((BYTE *)p+2), *((BYTE *)p+3));
					WriteFile(g_DebugFile, szDebug, strlen(szDebug), &d, NULL);
				}
				CloseHandle(g_DebugFile);
			}
#endif
			
			// Look for the bitstream info structure
			pbsi261 = (PRTP_H261_BSINFO)((PBYTE)pbsiT - (pbsiT->dwNumOfPackets - *pdwPktCount) * sizeof(RTP_H261_BSINFO));
			
			// Set the marker bit: as long as this is not the last packet of the frame
			// this bit needs to be set to 0
			if (!bOneFrameOnePacket)
			{
				// Count the number of GOBS that could fit in dwMaxFragSize
				for (i=1; i<(long)(pbsiT->dwNumOfPackets - *pdwPktCount); i++)
				{
					if ((pbsi261+i)->dwBitOffset - pbsi261->dwBitOffset > (pvs->dwMaxPacketSize * 8))
						break;
				}

				if (i < (long)(pbsiT->dwNumOfPackets - *pdwPktCount))
				{
					*pfMark = 0;
					if (i>1)
						i--;
				}
				else
				{
					// Hey! You 're forgetting the last GOB! It could make the total
					// size of the last packet larger than dwMaxFragSize... Imbecile!
					if ((pbsiT->dwCompressedSize * 8 - pbsi261->dwBitOffset > (pvs->dwMaxPacketSize * 8)) && (i>1))
					{
						*pfMark = 0;
						i--;
					}
				}
			}

			// Go to the beginning of the data
			pb = pDataSrc + pbsi261->dwBitOffset / 8;

#ifdef DEBUG
			if (!*pdwPktCount && ((*pb != 0) || (*(pb+1) != 1)))
			{
				wsprintf(szDebug, "VCMSTRM: This GOB is missing a GOB Start!");
				OutputDebugString(szDebug);
				// DebugBreak();
			}
#endif

			// Build a header to this thing!

			// 0                   1                   2                   3
			// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
			//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			//|SBIT |EBIT |I|V| GOBN  |   MBAP  |  QUANT  |  HMVD   |  VMVD   |
			//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			// But that's the network byte order...

			// Set the V bit to 1
			dwHeaderHigh |= 0x01000000;

			// Set the I bit
			dwHeaderHigh |= (pbsiT->dwFlags & RTP_H26X_INTRA_CODED) << 25;

			// Set the GOBn bits
			dwHeaderHigh |= ((DWORD)(pbsi261->byGOBN)) << 20;

			// Set the MBAP bits
			dwHeaderHigh |= ((DWORD)(pbsi261->byMBA)) << 15;

			// Set the QUANT bits
			dwHeaderHigh |= ((DWORD)(pbsi261->byQuant)) << 10;

			// Set the HMVD bits
			dwHeaderHigh |= ((DWORD)(BYTE)(pbsi261->cHMV)) << 5;

			// Set the VMVD bits
			dwHeaderHigh |= ((DWORD)(BYTE)(pbsi261->cVMV));

			// Special case: 1 frame = 1 packet
			if (bOneFrameOnePacket)
			{
				// SBIT is already set to 0

				// EBIT is already set to 0

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
				ERRORMESSAGE(("vcmFormatPayload: (1F1P) Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld (New frame)\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0xE0000000) >> 29, (DWORD)(dwHeaderHigh & 0x1C000000) >> 26));
#endif // } VALIDATE_SBIT_EBIT

				// Update the packet size
				*pdwPktSize = pbsiT->dwCompressedSize + 4;

				// Update the packet count
				*pdwPktCount = pbsiT->dwNumOfPackets;

			}
			else
			{
#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
				DWORD dwCurrentSBIT;
#endif // } VALIDATE_SBIT_EBIT
				// Set the SBIT bits
				dwHeaderHigh |= (pbsi261->dwBitOffset % 8) << 29;

				// Set the EBIT bits
				if ((pbsiT->dwNumOfPackets - *pdwPktCount - i) >= 1)
					dwHeaderHigh |= (DWORD)((8UL - ((pbsi261+i)->dwBitOffset % 8)) & 0x00000007) << 26;

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
				// Compare this to the previous EBIT. If the sum of the two
				// is not equal to 8, something's broken
				if (*pdwPktCount)
					ERRORMESSAGE(("vcmFormatPayload: Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0xE0000000) >> 29, (DWORD)(dwHeaderHigh & 0x1C000000) >> 26));
				else
					ERRORMESSAGE(("vcmFormatPayload: Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld (New frame)\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0xE0000000) >> 29, (DWORD)(dwHeaderHigh & 0x1C000000) >> 26));

				// Only test this if this is the first packet
				dwCurrentSBIT = (DWORD)(dwHeaderHigh & 0xE0000000) >> 29;
				if ((*pdwPktCount) && (((dwCurrentSBIT + g_dwPreviousEBIT) != 8) && (((dwCurrentSBIT + g_dwPreviousEBIT) != 0))))
					DebugBreak();

				g_dwPreviousEBIT = (dwHeaderHigh & 0x1C000000) >> 26;
#endif // } VALIDATE_SBIT_EBIT

				// Update the packet size
				if ((pbsiT->dwNumOfPackets - *pdwPktCount - i) >= 1)
					*pdwPktSize = (((pbsi261+i)->dwBitOffset - 1) / 8) - (pbsi261->dwBitOffset / 8) + 1 + 4;
				else
					*pdwPktSize = pbsiT->dwCompressedSize - pbsi261->dwBitOffset / 8 + 4;

				// Update the packet count
				*pdwPktCount += i;

			}

#if 0
			// Save the header right before the data chunk
			*ppDataPkt = pDataSrc + (pbsi261->dwBitOffset / 8) - 4;

			// Convert to network byte order
			*((BYTE *)*ppDataPkt+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
			*((BYTE *)*ppDataPkt+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
			*((BYTE *)*ppDataPkt+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
			*((BYTE *)*ppDataPkt) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
#else
			// Save the header right before the data chunk
			*ppDataPkt = pDataSrc + (pbsi261->dwBitOffset / 8) - 4;
            *pdwHdrSize=4;

			// Convert to network byte order
			*((BYTE *)*pHdrInfo+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
			*((BYTE *)*pHdrInfo+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
			*((BYTE *)*pHdrInfo+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
			*((BYTE *)*pHdrInfo) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
#endif

#ifdef LOGPAYLOAD_ON
			// Output some debug stuff
			wsprintf(szDebug, "Packet: %02lX\r\n Header: %02lX %02lX %02lX %02lX\r\n dword1: %02lX %02lX %02lX %02lX\r\n dword2: %02lX %02lX %02lX %02lX\r\n", *pdwPktCount, *((BYTE *)*ppDataPkt), *((BYTE *)*ppDataPkt+1), *((BYTE *)*ppDataPkt+2), *((BYTE *)*ppDataPkt+3), *((BYTE *)*ppDataPkt+4), *((BYTE *)*ppDataPkt+5), *((BYTE *)*ppDataPkt+6), *((BYTE *)*ppDataPkt+7), *((BYTE *)*ppDataPkt+8), *((BYTE *)*ppDataPkt+9), *((BYTE *)*ppDataPkt+10), *((BYTE *)*ppDataPkt+11));
			OutputDebugString(szDebug);
			if (*pdwPktCount == pbsiT->dwNumOfPackets)
				wsprintf(szDebug, " Tail  : %02lX %02lX XX XX\r\n", *((BYTE *)*ppDataPkt+*pdwPktSize-2), *((BYTE *)*ppDataPkt+*pdwPktSize-1));
			else
				wsprintf(szDebug, " Tail  : %02lX %02lX %02lX %02lX\r\n", *((BYTE *)*ppDataPkt+*pdwPktSize-2), *((BYTE *)*ppDataPkt+*pdwPktSize-1), *((BYTE *)*ppDataPkt+*pdwPktSize), *((BYTE *)*ppDataPkt+*pdwPktSize+1));
			OutputDebugString(szDebug);
			if (*pfMark == 1)
				wsprintf(szDebug, " Marker: ON\r\n");
			else
				wsprintf(szDebug, " Marker: OFF\r\n");
			OutputDebugString(szDebug);
			wsprintf(szDebug, "Frame #%03ld, Packet of size %04ld\r\n", (DWORD)pbsiT->byTR, *pdwPktSize);
			OutputDebugString(szDebug);
#endif
		}
		else
			return ((MMRESULT)VCMERR_NOMOREPACKETS);
	}
	else
	{
		if (!*pdwPktCount)
		{
			*pdwPktCount = 1;
            *pdwHdrSize  = 0;
		}
		else
			return ((MMRESULT)VCMERR_NOMOREPACKETS);
	}

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamGetPayloadHeaderSize | This function gets the size
 *   of the RTP payload header associated to a video codec.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm PDWORD | pdwPayloadHeaderSize | Specifies a pointer to the payload header size.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified saturation value is invalid.
 *
 * @xref <f vcmStreamFormatPayload>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamGetPayloadHeaderSize(HVCMSTREAM hvs, PDWORD pdwPayloadHeaderSize)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamGetPayloadHeaderSize: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (!pdwPayloadHeaderSize)
	{
		ERRORMESSAGE(("vcmStreamGetPayloadHeaderSize: Specified pointer is invalid, pdwPayloadHeaderSize=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Set default payload header size to 0
	*pdwPayloadHeaderSize = 0;

	// The name of the codec will tell us how to get to the payload header size info
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
	if ((pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH26X))
#else
	if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH263)
#endif
#else
	if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_DECH263)
#endif
	{
		// H.263 has a max payload header size of 12 bytes
		*pdwPayloadHeaderSize = 12;
	}
#ifndef _ALPHA_
	else if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH261)
#else
	else if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_DECH261)
#endif
	{
		// H.261 has a unique payload header size of 4 bytes
		*pdwPayloadHeaderSize = 4;
	}

	return ((MMRESULT)MMSYSERR_NOERROR);
}

/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamRequestIFrame | This function forces the
 *   codec to generate an I-Frame.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamRequestIFrame(HVCMSTREAM hvs)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamRequestIFrame: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	DEBUGMSG (ZONE_VCM, ("vcmStreamRequestIFrame: Requesting an I-Frame...\r\n"));

	// We need the following crs to make sure we don't miss any of the I-Frame requests
	// emitted by the UI. Problematic scenario: pvs->dwFrame is at 123 for instance.
	// The UI thread requests an I-Frame by setting pvs->dwFrame to 0. If the capture/compression
	// thread was in ICCompress() (which is very probable since it takes quite some time
	// to compress a frame), pvs->dwFrame will be incremented by one when ICCompress()
	// returns. We fail to handle the I-Frame request correctly, since the next time
	// ICCompress() gets called pvs->dwFrame will be equal to 1, for which we do not
	// generate an I-Frame.
	EnterCriticalSection(&pvs->crsFrameNumber);

	// Set the frame number to 0. This will force the codec to generate an I-Frame
	pvs->dwFrame = 0;

	// Allow the capture/compression thread to proceed.
	LeaveCriticalSection(&pvs->crsFrameNumber);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamPeriodicIFrames | This function enables or
 *   disables generation of I-Frames periodically.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm BOOL | fPeriodicIFrames | Set to TRUE to generate I-Frames
 *   periodically, FALSE otherwise.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamPeriodicIFrames(HVCMSTREAM hvs, BOOL fPeriodicIFrames)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamDisablePeriodicIFrames: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	DEBUGMSG (ZONE_VCM, ("vcmStreamDisablePeriodicIFrames: Disabling periodic generation of I-Frames...\r\n"));

	// No more periodic I-Frames
	pvs->fPeriodicIFrames = fPeriodicIFrames;

	return ((MMRESULT)MMSYSERR_NOERROR);
}


// frees memory prior to shutdown
MMRESULT VCMAPI vcmReleaseResources()
{
	if (g_aVCMAppInfo)
	{
		MemFree(g_aVCMAppInfo);
		g_aVCMAppInfo = NULL;
	}	

	return MMSYSERR_NOERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\vidpackt.cpp ===
#include "precomp.h"

#define ZONE_AP			ZONE_DP


#define _GetState()		(m_dwState & DP_MASK_STATE)
#define _SetState(s)	(m_dwState = (m_dwState & ~DP_MASK_STATE) | (s & DP_MASK_STATE))

#define _GetPlatform()	(m_dwState & DP_MASK_PLATFORM)
#define _SetPlatform(s)	(m_dwState = (m_dwState & ~DP_MASK_PLATFORM) | (s & DP_MASK_PLATFORM))


int g_videoin_prepare = 0;
int g_videoout_prepare = 0;


///////////////////////////////////////////////////////
//
//  Public methods
//

HRESULT VideoPacket::Initialize ( MEDIAPACKETINIT * p )
{
	HRESULT hr = DPR_SUCCESS;
	ULONG		cbSizeDevData;
	ULONG		cbSizeRawData;

	FX_ENTRY ("VdPckt::Init")

    m_pBS = NULL;

	if (p == NULL)
	{
		DEBUGMSG (ZONE_AP, ("%s: invalid parameter (null ptr)\r\n", _fx_));
		return DPR_INVALID_PARAMETER;
	}

	if (p->dwFlags & DP_FLAG_SEND) {
    	cbSizeDevData = p->cbSizeDevData;
	    cbSizeRawData = p->cbSizeRawData;
    	if (IsSameMediaFormat(p->pStrmConvSrcFmt, p->pDevFmt))
    	    p->cbSizeRawData = 0;
    	p->cbSizeDevData = 0;
	}
	
	hr = MediaPacket::Initialize( p);

// LOOKLOOK RP - if DP_FLAG_SEND, then we've allocated a memory header for the dev buffer,
// but haven't actually allocated memory for the buffer
	if (p->dwFlags & DP_FLAG_SEND) {
		m_pDevData->data = NULL;
   		m_pDevData->length = cbSizeDevData;
	}

	if (hr != DPR_SUCCESS)
		goto MyExit;
		
	// allocate conversion header only if m_pWaveData != m_pNetData
	if (m_pRawData != m_pNetData)
	{
		if (m_dwState & DP_FLAG_VCM)
		{
			m_pStrmConvHdr = MemAlloc (sizeof (VCMSTREAMHEADER));
			if (m_pStrmConvHdr == NULL)
			{
				DEBUGMSG (ZONE_AP, ("%s: MemAlloc4 (%ld) failed\r\n",
				_fx_, (ULONG) sizeof (VCMSTREAMHEADER)));
				hr = DPR_OUT_OF_MEMORY;
				goto MyExit;
			}
		}
		else
		{
			DEBUGMSG (ZONE_AP, ("%s: invalid platform (vcm)\r\n", _fx_));
			hr = DPR_INVALID_PLATFORM;
			goto MyExit;
		}
	}
	else
	{
		m_pStrmConvHdr = NULL;
	}

	MakeSilence ();

MyExit:

	if (hr != DPR_SUCCESS)
	{
		m_fInitialized = FALSE;
		Release();
	}

	return hr;
}


HRESULT VideoPacket::Play ( MMIODEST *pmmioDest, UINT uDataType )
{
	return DPR_INVALID_HANDLE;
}



HRESULT VideoPacket::Record ( void )
{
	FX_ENTRY ("VdPckt::Record")

	LOG((LOGMSG_VID_RECORD,m_index));

	if (_GetState () != MP_STATE_RESET)
	{
		DEBUGMSG (ZONE_AP, ("%s: out of seq, state=0x%lX\r\n", _fx_, m_dwState));
		return DPR_OUT_OF_SEQUENCE;
	}
	
	if (m_pBS && m_pDevData->data) {
	    m_pBS->UnlockBits(NULL, m_pDevData->data);
        m_pBS->Release();
		m_pDevData->data = NULL;
        m_pBS = NULL;
	}
	
	_SetState (MP_STATE_RECORDING);
	return DPR_SUCCESS;
}


HRESULT VideoPacket::SetSurface (IBitmapSurface *pBS)
{
    void* pBits;
    long pitch;

	FX_ENTRY ("VdPckt::SetSurface")
	
    if (pBS) {
        m_pBS = pBS;
        m_pBS->LockBits(NULL, 0, &pBits, &pitch);
        if (!pBits) {
            m_pBS->UnlockBits(NULL, pBits);
            return ERROR_IO_INCOMPLETE;
        }
        m_pBS->AddRef();
        m_pDevData->data = (UCHAR *)pBits;
        return DPR_SUCCESS;
    }
    return E_INVALIDARG;
}


HRESULT VideoPacket::Recycle ( void )
{
	if (m_pBS && m_pDevData->data) {
	    m_pBS->UnlockBits(NULL, m_pDevData->data);
        m_pBS->Release();
		m_pDevData->data = NULL;
        m_pBS = NULL;
	}
    return MediaPacket::Recycle();
}


BOOL VideoPacket::IsBufferDone ( void )
{
	FX_ENTRY ("VdPckt::IsBufferDone")

	if (m_hDev)
	{
		if (m_dwState & DP_FLAG_VIDEO)
		{
//LOOKLOOK RP - what does this need to do?
#if 1
            return TRUE;
#else
~~~			return (((VIDEOINOUTHDR *) m_pDevHdr)->dwFlags & WHDR_DONE);
#endif
		}
	}

	return FALSE;
}


HRESULT VideoPacket::MakeSilence ( void )
{
	// create white noise!!!

	FX_ENTRY ("VdPckt::MakeSilence")

	if (m_pDevFmt)
	{
		if (m_pDevData)
		{
			// Don't need to do anything, what's on screen should do it.
			CopyPreviousBuf ((VIDEOFORMATEX *) m_pDevFmt, (PBYTE) m_pDevData->data,
											(ULONG) m_pDevData->length);
		}
	}

	_SetState(MP_STATE_RESET);
	return DPR_SUCCESS;
}


HRESULT VideoPacket::GetSignalStrength ( PDWORD pdwMaxStrength )
{

	FX_ENTRY ("VdPckt::GetSignalStrength")

	// For now send each and every frame.
	// But you should consider sending only the frames if they
	// are really different of the previously sent one.
	// This will save quite some bandwidth when there is no or
	// very little activity in the video frames.


	return DPR_NOT_YET_IMPLEMENTED;
}


HRESULT VideoPacket::Interpolate ( MediaPacket * pPrev, MediaPacket * pNext)
{
	HRESULT			hr = DPR_SUCCESS;
	DPHANDLE		hPrevDev;
	NETBUF			*pPrevDevData;
	PVOID			pPrevDevHdr;
	VIDEOFORMATEX	*pPrevpfDev;
	VIDEOFORMATEX	*pNextpfDev;
	NETBUF			*pNextDevData;
	PVOID			pNextDevHdr;

	FX_ENTRY ("VdPckt::Interpolate")

	DEBUGMSG (ZONE_AP, ("%s: can't interpolate\r\n", _fx_));
	hr = DPR_INVALID_HANDLE;

	return hr;

}


HRESULT VideoPacket::Open ( UINT uType, DPHANDLE hdl )
// called by RxStream or TxStream
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	FX_ENTRY ("VdPckt::Open")

	switch (uType)
	{
#ifdef PREP_HDR_PER_CONV
	case MP_TYPE_RECVSTRMCONV:
		m_hStrmConv = hdl;
		break;
#endif

	case MP_TYPE_STREAMCONV:
		if ((m_hStrmConv = hdl) != NULL)
		{
			if (m_dwState & DP_FLAG_VCM)
			{
				// initialize the header
				ZeroMemory (m_pStrmConvHdr, sizeof (VCMSTREAMHEADER));
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbStruct = sizeof (VCMSTREAMHEADER);
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->fdwStatus = 0;
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->dwUser = 0;
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->dwSrcUser = 0;
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLengthUsed = 0;
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->dwDstUser = 0;
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLengthUsed = 0;
				
				if (m_pNetData && m_pRawData)
				{
					
					if (m_dwState & DP_FLAG_SEND)
					{
					    if (m_pRawData->data) {
						    ((VCMSTREAMHEADER *) m_pStrmConvHdr)->pbSrc = m_pRawData->data;
						    ((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLength = m_pRawData->length;
						}
						else {
						    // don't have a static raw buffer, so let vcmStreamPrepareHeader
						    // lock the net buffer twice
						    ((VCMSTREAMHEADER *) m_pStrmConvHdr)->pbSrc = m_pNetData->data;
						    ((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLength = m_pNetData->length;
						}
						((VCMSTREAMHEADER *) m_pStrmConvHdr)->pbDst = m_pNetData->data;
						((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLength = m_pNetData->length;
					}
					else
					if (m_dwState & DP_FLAG_RECV)
					{
						((VCMSTREAMHEADER *) m_pStrmConvHdr)->pbSrc = m_pNetData->data;
						((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLength = m_pNetData->length;
						((VCMSTREAMHEADER *) m_pStrmConvHdr)->pbDst = m_pRawData->data;
						((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLength = m_pRawData->length;
					}

					// prepare the header
					mmr = vcmStreamPrepareHeader ((HVCMSTREAM) m_hStrmConv,
												  (VCMSTREAMHEADER *) m_pStrmConvHdr, 0);
					if (mmr != MMSYSERR_NOERROR)
					{
						DEBUGMSG (ZONE_AP, ("%s: vcmStreamPrepareHeader failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
						hr = DPR_CANT_PREPARE_HEADER;
						goto MyExit;
					}

					m_fStrmPrepared = TRUE;
				}
				else
					m_fStrmPrepared = FALSE;
			}
			else
			{
				hr = DPR_INVALID_PLATFORM;
				goto MyExit;
			}
		}
		break;

	case MP_TYPE_DEV:
		if ((m_hDev = hdl) != NULL)
		{
			if (m_dwState & DP_FLAG_VIDEO)
			{
				if (m_dwState & DP_FLAG_SEND)
				{
					g_videoin_prepare++;
				}
				else
				if (m_dwState & DP_FLAG_RECV)
				{
					g_videoout_prepare++;
				}
				else
				{
					hr = DPR_INVALID_PARAMETER;
					goto MyExit;
				}

				m_fDevPrepared = TRUE;
			}
			else
			{
				hr = DPR_INVALID_PLATFORM;
				goto MyExit;
			}
		}
		else
		{
			hr = DPR_INVALID_HANDLE;
			goto MyExit;
		}
		break;

	default:
		hr = DPR_INVALID_PARAMETER;
		goto MyExit;
	}

MyExit:

	return hr;
}


HRESULT VideoPacket::Close ( UINT uType )
// called by RxStream or TxStream
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	FX_ENTRY ("VdPckt::Close")

	switch (uType)
	{
	case MP_TYPE_RECVSTRMCONV:

	case MP_TYPE_STREAMCONV:
		if (m_hStrmConv)
		{
			if (m_dwState & DP_FLAG_VCM)
			{
				if (m_fStrmPrepared)
				{
					// unprepare the header
				    if ((m_dwState & DP_FLAG_SEND) && !m_pRawData->data)
				    {
					    // don't have a static raw buffer, so let vcmStreamUnprepareHeader
					    // unlock the net buffer twice to unwind what Open did
					    ((VCMSTREAMHEADER *) m_pStrmConvHdr)->pbSrc = m_pNetData->data;
					    ((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLength = m_pNetData->length;
					}
					mmr = vcmStreamUnprepareHeader ((HVCMSTREAM) m_hStrmConv,
													(VCMSTREAMHEADER *) m_pStrmConvHdr, 0);

					m_fStrmPrepared = FALSE; // don't care about any error

					if (mmr != MMSYSERR_NOERROR)
					{
						DEBUGMSG (ZONE_AP, ("%s: vcmStreamUnprepareHeader failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
						hr = DPR_CANT_UNPREPARE_HEADER;
						goto MyExit;
					}
				}
			}

			if (uType == MP_TYPE_STREAMCONV) m_hStrmConv = NULL;
		}
		break;

	case MP_TYPE_DEV:
		if (m_hDev)
		{
			if (m_fDevPrepared)
			{
				if (m_dwState & DP_FLAG_SEND)
				{
					g_videoin_prepare--;
				}
				else
				if (m_dwState & DP_FLAG_RECV)
				{
					g_videoout_prepare--;
				}
				else
				{
					hr = DPR_INVALID_PARAMETER;
					goto MyExit;
				}

				m_fDevPrepared = FALSE; // don't care about any error

			}

			m_hDev = NULL;
		}
		else
		{
			hr = DPR_INVALID_HANDLE;
			goto MyExit;
		}
		break;

	default:
		hr = DPR_INVALID_PARAMETER;
		goto MyExit;
	}

MyExit:

	return hr;
}


void VideoPacket::WriteToFile (MMIODEST *pmmioDest)
{
	MMRESULT mmr;
	long dwDataLength;

	FX_ENTRY ("VdPckt::WriteToFile")

#ifdef need_video_file_io
// BUGBUG - this stuff doesn't work
	if (dwDataLength = (DWORD)(pmmioDest->dwDataLength + m_pDevData->length) > pmmioDest->dwMaxDataLength ? (DWORD)(pmmioDest->dwMaxDataLength - pmmioDest->dwDataLength) : m_pDevData->length)
	{
		if (mmioWrite(pmmioDest->hmmioDst, (char *) m_pDevData->data, dwDataLength) != (LONG)m_pDevData->length)
			mmr = MMSYSERR_ERROR;
		else
			pmmioDest->dwDataLength += dwDataLength;
		if ((mmr == MMSYSERR_ERROR) || (pmmioDest->dwDataLength == pmmioDest->dwMaxDataLength))
		{
			mmr = mmioAscend(pmmioDest->hmmioDst, &(pmmioDest->ckDst), 0);
			mmr = mmioAscend(pmmioDest->hmmioDst, &(pmmioDest->ckDstRIFF), 0);
			mmr = mmioClose(pmmioDest->hmmioDst, 0);
			pmmioDest->hmmioDst = NULL;
		}
	}
#endif
}

void VideoPacket::ReadFromFile (MMIOSRC *pmmioSrc)
{
	long lNumBytesRead;

	FX_ENTRY ("VdPckt::ReadFromFile")

#ifdef need_video_file_io
// BUGBUG - this stuff doesn't work

	if (((VIDEOINOUTHDR *) m_pDevHdr)->dwBytesUsed)
	{
MyRead:
		if ((pmmioSrc->dwDataLength + ((VIDEOINOUTHDR *) m_pDevHdr)->dwBytesUsed) <= pmmioSrc->dwMaxDataLength)
		{
			lNumBytesRead = mmioRead(pmmioSrc->hmmioSrc, ((VIDEOINOUTHDR *) m_pDevHdr)->pData, ((VIDEOINOUTHDR *) m_pDevHdr)->dwBytesUsed);
			pmmioSrc->dwDataLength += lNumBytesRead;
		}
		else
		{
			lNumBytesRead = mmioRead(pmmioSrc->hmmioSrc, ((VIDEOINOUTHDR *) m_pDevHdr)->pData, pmmioSrc->dwMaxDataLength - pmmioSrc->dwDataLength);
			pmmioSrc->dwDataLength += lNumBytesRead;
			CopyPreviousBuf ((VIDEOFORMATEX *) m_pDevFmt, (PBYTE) ((VIDEOINOUTHDR *) m_pDevHdr)->pData + lNumBytesRead, ((VIDEOINOUTHDR *) m_pDevHdr)->dwBytesUsed - lNumBytesRead);
			pmmioSrc->dwDataLength = 0;
			lNumBytesRead = 0;
		}
		
		if (!lNumBytesRead)
		{
			if (pmmioSrc->fLoop && !pmmioSrc->fDisconnectAfterPlayback)
			{
				// Reset file pointer to beginning of data
				mmioAscend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrc), 0);
				if (-1L == mmioSeek(pmmioSrc->hmmioSrc, pmmioSrc->ckSrcRIFF.dwDataOffset + sizeof(FOURCC), SEEK_SET))
				{
					DEBUGMSG (1, ("MediaControl::OpenSrcFile: Couldn't seek in file, mmr=%ld\r\n", (ULONG) 0L));
					goto MyMMIOErrorExit2;
				}
				pmmioSrc->ckSrc.ckid = mmioFOURCC('d', 'a', 't', 'a');
				if (mmioDescend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrc), &(pmmioSrc->ckSrcRIFF), MMIO_FINDCHUNK))
				{
					DEBUGMSG (1, ("MediaControl::OpenSrcFile: Couldn't locate 'data' chunk, mmr=%ld\r\n", (ULONG) 0L));
					goto MyMMIOErrorExit2;
				}

				// At this point, the src file is sitting at the very
				// beginning of its data chunks--so we can read from the src file...
				goto MyRead;
MyMMIOErrorExit2:
				mmioAscend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrcRIFF), 0);
				mmioClose(pmmioSrc->hmmioSrc, 0);
				pmmioSrc->hmmioSrc = NULL;
			}
			else
			{
				mmioAscend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrcRIFF), 0);
				mmioClose(pmmioSrc->hmmioSrc, 0);
				pmmioSrc->hmmioSrc = NULL;
				/* Dont want to disconnect the whole connection
				 * TODO: investigate closing the channel
				if (pmmioSrc->fDisconnectAfterPlayback)
					pConnection->SetMode(CMT_Disconnect);
				*/
			}
		}
	}
#endif
}


BOOL VideoPacket::IsSameMediaFormat(PVOID fmt1,PVOID fmt2)
{
	return IsSameFormat(fmt1,fmt2);
}


// returns length of uncompressed video data in buffer
// NOTE: not used yet
DWORD
VideoPacket::GetDevDataSamples()
{
	// samples == frames for video and we only deal with one frame per pkt for now.
	return 1;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nmcap\capture.h ===
#include <windows.h>
#include <ibitmap.h>
#include <frameop.h>
#include <dcap.h>

#ifndef _capture_h
#define _capture_h

class CCaptureChain
{
private:
    CFrameOp*           m_opchain;
    CFilterChain*       m_filterchain;
    DWORD_PTR           m_filtertags;
    CRITICAL_SECTION    m_capcs;

public:
    CCaptureChain();
    ~CCaptureChain();

	STDMETHODIMP InitCaptureChain(HCAPDEV hcapdev, BOOL streaming,
	                               LPBITMAPINFOHEADER lpcap,
                                   LONG desiredwidth, LONG desiredheight,
                                   DWORD desiredformat,
                                   LPBITMAPINFOHEADER *plpdsp);
    STDMETHODIMP GrabFrame(IBitmapSurface** ppBS);
	STDMETHODIMP AddFilter(CLSID* pclsid, LPBITMAPINFOHEADER lpbmhIn,
	                        HANDLE* phNew, HANDLE hAfter);
	STDMETHODIMP RemoveFilter(HANDLE hNew);
	STDMETHODIMP DisplayFilterProperties(HANDLE hFilter, HWND hwndParent);
};

#endif //#ifndef _capture_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\vidutils.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    utils.h

Abstract:
	Assorted support and debugging routines used by the Network Audio Controller.

--*/
#ifndef _VIDUTILS_H_
#define _VIDUTILS_H_


#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

enum
{
    //  NAME_FramesPerSec_BitsPerSample
	DVF_DEFAULT_7FPS_4,
    DVF_NumOfFormats
};

//extern VIDEOFORMATEX g_vfDefList[];

VIDEOFORMATEX * GetDefFormat ( int idx );
ULONG GetFormatSize ( PVOID pwf );
BOOL IsSameFormat ( PVOID pwf1, PVOID pwf2 );
BOOL IsSimilarVidFormat(VIDEOFORMATEX *pFormat1, VIDEOFORMATEX *pFormat2);
void CopyPreviousBuf (VIDEOFORMATEX *pwf, PBYTE pb, ULONG cb);

#define IFRAMES_CAPS_NM3        101
#define IFRAMES_CAPS_NM2        102
#define IFRAMES_CAPS_3RDPARTY   103
#define IFRAMES_CAPS_UNKNOWN    104

int GetIFrameCaps(IStreamSignal *pStreamSignal);


#define SQCIF_WIDTH		128
#define SQCIF_HEIGHT	96

#define QCIF_WIDTH		176
#define QCIF_HEIGHT		144

#define CIF_WIDTH		352
#define CIF_HEIGHT		288


#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#include <poppack.h> /* End byte packing */

#endif // _VIDUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\vidpackt.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    vidpackt.h

Abstract:

    Contains  prototypes for the VideoPacket class, which encapsulates a video buffer in
    its various states: recorded/encoded/network/decoded/playing etc.

--*/
#ifndef _VIDPACKT_H_
#define _VIDPACKT_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define VP_NUM_PREAMBLE_PACKETS		6

#define MAX_CIF_VIDEO_FRAGMENTS		40
#define MAX_QCIF_VIDEO_FRAGMENTS 	20
#define MAX_VIDEO_FRAGMENTS		 	MAX_CIF_VIDEO_FRAGMENTS

class VideoPacket : public MediaPacket
{
 private:
    IBitmapSurface *m_pBS;
 public:
	virtual HRESULT Initialize ( MEDIAPACKETINIT * p );
	virtual HRESULT Play ( MMIODEST *pmmioDest, UINT uDataType );
	virtual HRESULT Record ( void );
	virtual HRESULT Interpolate ( MediaPacket * pPrev, MediaPacket * pNext);
	virtual HRESULT GetSignalStrength ( PDWORD pdwMaxStrength );
	virtual HRESULT MakeSilence ( void );
	virtual HRESULT Recycle ( void );
	virtual HRESULT Open ( UINT uType, DPHANDLE hdl );	// called by RxStream or TxStream
	virtual HRESULT Close ( UINT uType );				// called by RxStream or TxStream
	virtual BOOL IsBufferDone ( void );
	virtual BOOL IsSameMediaFormat(PVOID fmt1,PVOID fmt2);
	virtual DWORD GetDevDataSamples();
	void WriteToFile (MMIODEST *pmmioDest);
	void ReadFromFile (MMIOSRC *pmmioSrc );
	HRESULT SetSurface (IBitmapSurface *pBS);
};


#include <poppack.h> /* End byte packing */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\vidutils.cpp ===
#include "precomp.h"

#define INTEL_PRO 1

#ifdef INTEL_PRO
#define WIDTH 176
#define HEIGHT 144
#define NUMBPP 24
#ifndef _ALPHA_
#define VIDEO_FORMAT VIDEO_FORMAT_MSH263
#else
#define VIDEO_FORMAT VIDEO_FORMAT_DECH263
#endif
#define SIZE_IMAGE 8192
#else
#define WIDTH 160
#define HEIGHT 120
#define NUMBPP 16
#define VIDEO_FORMAT VIDEO_FORMAT_BI_RGB
#define SIZE_IMAGE (WIDTHBYTES(WIDTH * NUMBPP) * HEIGHT)
#endif
#define NUMFPS 7
#define BITRATE (SIZE_IMAGE * NUMFPS)

VIDEOFORMATEX g_vfDefList[DVF_NumOfFormats] =
	{
#if 1
#if 1
        {
		VIDEO_FORMAT,                // dwFormatTag
		NUMFPS,                             // nSamplesPerSec
		BITRATE,                            // nAvgBytesPerSec
		BITRATE,                            // nMinBytesPerSec
		BITRATE,                            // nMaxBytesPerSec
		SIZE_IMAGE,// nBlockAlign
		NUMBPP,                             // wBitsPerSample
		// Temporal fields
		142857UL,                           // dwRequestMicroSecPerFrame
		10UL,                               // dwPersentDropForError
		NUMFPS,                             // dwNumVideoRequested
		1UL,                                // dwSupportTSTradeOff
		TRUE,                               // bLive
		sizeof(VIDEOFORMATEX),              // dwFormatSize
		// Spatial fields (BITMAPINFOHEADER compatible)
			{
			sizeof(BITMAPINFOHEADER),           // bih.biSize
			WIDTH,                              // bih.biWidth
			HEIGHT,                             // bih.biHeight
			1,                                  // bih.biPlanes
			NUMBPP,                             // bih.biBitCount
			VIDEO_FORMAT,                // bih.biCompression
			SIZE_IMAGE,// bih.biSizeImage
			0, 0,                               // bih.bi(X,Y)PelsPerMeter
			0,                                  // bih.biClrUsed
			0                                   // bih.biClrImportant
			}
		}
#else
        {
		VIDEO_FORMAT_BI_RGB,                // dwFormatTag
		NUMFPS,                             // nSamplesPerSec
		BITRATE,                            // nAvgBytesPerSec
		BITRATE,                            // nMinBytesPerSec
		BITRATE,                            // nMaxBytesPerSec
		WIDTHBYTES(WIDTH * NUMBPP) * HEIGHT,// nBlockAlign
		NUMBPP,                             // wBitsPerSample
		// Temporal fields
		142857UL,                           // dwRequestMicroSecPerFrame
		10UL,                               // dwPersentDropForError
		NUMFPS,                             // dwNumVideoRequested
		1UL,                                // dwSupportTSTradeOff
		TRUE,                               // bLive
		sizeof(VIDEOFORMATEX),              // dwFormatSize
		// Spatial fields (BITMAPINFOHEADER compatible)
			{
			sizeof(BITMAPINFOHEADER),           // bih.biSize
			WIDTH,                              // bih.biWidth
			HEIGHT,                             // bih.biHeight
			1,                                  // bih.biPlanes
			NUMBPP,                             // bih.biBitCount
			VIDEO_FORMAT_BI_RGB,                // bih.biCompression
			WIDTHBYTES(WIDTH * NUMBPP) * HEIGHT,// bih.biSizeImage
			0, 0,                               // bih.bi(X,Y)PelsPerMeter
			0,                                  // bih.biClrUsed
			0                                   // bih.biClrImportant
			}
		}
#endif
#else
		{
		// Wave format compatibility fields
		(WORD)0, 7UL, 9600UL, 9600UL, 9600UL, (DWORD)1, (WORD)4,
		// Temporal fields
		142857UL, 10UL, 2UL, 142857UL, TRUE, sizeof(VIDEOFORMATEX),
		// Spatial fields (BITMAPINFOHEADER compatible)
		sizeof(BITMAPINFOHEADER), WIDTH, HEIGHT, 1, 4, BI_RGB, (DWORD)WIDTHBYTES(WIDTH * 4) * HEIGHT, 0, 0, 16, 0
		}
#endif
	};		
#if 0
		// Color information fields (Array of 256 RGBQUAD)
		  0,   0,   0, 0, 255, 255, 255, 0, 238, 238, 238, 0, 221, 221, 221, 0, 204, 204, 204, 0,
		187, 187, 187, 0, 170, 170, 170, 0, 153, 153, 153, 0, 136, 136, 136, 0, 119, 119, 119, 0,
		102, 102, 102, 0,  85,  85,  85, 0,  68,  68,  68, 0,  51,  51,  51, 0,  34,  34,  34, 0,  17,  17,  17, 0
		}
	};
		{  0,   0,   0, 0}, {255, 255, 255, 0}, {238, 238, 238, 0}, {221, 221, 221, 0}, {204, 204, 204, 0},
		{187, 187, 187, 0}, {170, 170, 170, 0}, {153, 153, 153, 0}, {136, 136, 136, 0}, {119, 119, 119, 0},
		{102, 102, 102, 0}, { 85,  85,  85, 0}, { 68,  68,  68, 0}, { 51,  51,  51, 0}, { 34,  34,  34, 0}, { 17,  17,  17, 0}
#endif

VIDEOFORMATEX * GetDefFormat ( int idx )
{
    return ((idx < DVF_NumOfFormats) ?
            (VIDEOFORMATEX *) &g_vfDefList[idx] :
            (VIDEOFORMATEX *) NULL);
}

// Move all this into VideoPacket... same for AudioPacket and utils.c
ULONG GetFormatSize ( PVOID pwf )
{
    return (((VIDEOFORMATEX *) pwf)->dwFormatSize);
}

BOOL IsSameFormat ( PVOID pwf1, PVOID pwf2 )
{
    UINT u1 = GetFormatSize (pwf1);
    UINT u2 = GetFormatSize (pwf2);
    BOOL fSame = FALSE;
	VIDEOFORMATEX *pvfx1 = (VIDEOFORMATEX *)pwf1;
	VIDEOFORMATEX *pvfx2 = (VIDEOFORMATEX *)pwf2;

	// Only compare relevant fields
	if (pvfx1->dwFormatTag != pvfx2->dwFormatTag)
		return FALSE;
	if (pvfx1->nSamplesPerSec != pvfx2->nSamplesPerSec)
		return FALSE;
	if (pvfx1->nAvgBytesPerSec != pvfx2->nAvgBytesPerSec)
		return FALSE;
	if (pvfx1->nMinBytesPerSec != pvfx2->nMinBytesPerSec)
		return FALSE;
	if (pvfx1->nMaxBytesPerSec != pvfx2->nMaxBytesPerSec)
		return FALSE;
	if (pvfx1->nBlockAlign != pvfx2->nBlockAlign)
		return FALSE;
	if (pvfx1->wBitsPerSample != pvfx2->wBitsPerSample)
		return FALSE;
	if (pvfx1->bih.biSize != pvfx2->bih.biSize)
		return FALSE;
	if (pvfx1->bih.biWidth != pvfx2->bih.biWidth)
		return FALSE;
	if (pvfx1->bih.biHeight != pvfx2->bih.biHeight)
		return FALSE;
	if (pvfx1->bih.biPlanes != pvfx2->bih.biPlanes)
		return FALSE;
	if (pvfx1->bih.biBitCount != pvfx2->bih.biBitCount)
		return FALSE;
	if (pvfx1->bih.biCompression != pvfx2->bih.biCompression)
		return FALSE;
	if (pvfx1->bih.biSizeImage != pvfx2->bih.biSizeImage)
		return FALSE;
	if (pvfx1->bih.biClrUsed != pvfx2->bih.biClrUsed)
		return FALSE;

	return TRUE;
}

// Repeat previous frame. This is probably not necessary
// since it is already painted on screen
void CopyPreviousBuf (VIDEOFORMATEX *pwf, PBYTE pb, ULONG cb)
{

	return;

}


// similar to the above "IsSameFormat" call, but similifed to satisfy
// the needs of SendVideoStream::Configure
BOOL IsSimilarVidFormat(VIDEOFORMATEX *pvfx1, VIDEOFORMATEX *pvfx2)
{
	// Only compare relevant fields
	if (pvfx1->bih.biWidth != pvfx2->bih.biWidth)
		return FALSE;
	if (pvfx1->bih.biHeight != pvfx2->bih.biHeight)
		return FALSE;
	if (pvfx1->bih.biCompression != pvfx2->bih.biCompression)
		return FALSE;

	return TRUE;
}


int GetIFrameCaps(IStreamSignal *pStreamSignal)
{
	HRESULT hr;
	PCC_VENDORINFO pLocalVendorInfo, pRemoteVendorInfo;
	int nStringLength20, nStringLength21, nStringLength211, nStringLengthTAPI;
	int nStringLength21sp1;
	bool bIsNetMeeting = false;  // contains NetMeeting in the product string
	char *szProductCompare=NULL;
	char *szVersionCompare=NULL;
	int nLengthProduct, nLengthVersion;
	int nRet = IFRAMES_CAPS_3RDPARTY;

	if (pStreamSignal == NULL)
	{
		return IFRAMES_CAPS_UNKNOWN;
	}

	hr = pStreamSignal->GetVersionInfo(&pLocalVendorInfo, &pRemoteVendorInfo);

	if (FAILED(hr) || (NULL == pRemoteVendorInfo))
	{
		return IFRAMES_CAPS_UNKNOWN;
	}


	// make sure we are dealing with a Microsoft product
	if ((pRemoteVendorInfo->bCountryCode != USA_H221_COUNTRY_CODE) ||
	    (pRemoteVendorInfo->wManufacturerCode != MICROSOFT_H_221_MFG_CODE) ||
	    (pRemoteVendorInfo->pProductNumber == NULL) ||
		(pRemoteVendorInfo->pVersionNumber == NULL)
	   )
	{
		return IFRAMES_CAPS_3RDPARTY;
	}


	// strings aren't guaranteed to be NULL terminated
	// so let's make a quick copy of them that so that we can
	// do easy string comparisons
	nLengthProduct = pRemoteVendorInfo->pProductNumber->wOctetStringLength;
	nLengthVersion = pRemoteVendorInfo->pVersionNumber->wOctetStringLength;

	szProductCompare = new char[nLengthProduct+1];
	szVersionCompare = new char[nLengthVersion+1];

	if ((szProductCompare == NULL) || (szVersionCompare == NULL))
	{
		return IFRAMES_CAPS_3RDPARTY;
	}

	ZeroMemory(szProductCompare, nLengthProduct+1);
	ZeroMemory(szVersionCompare, nLengthVersion+1);
	
	CopyMemory(szProductCompare, pRemoteVendorInfo->pProductNumber->pOctetString, nLengthProduct);
	CopyMemory(szVersionCompare, pRemoteVendorInfo->pVersionNumber->pOctetString, nLengthVersion);

	// a redundant check to make sure that it is indeed a Microsoft product
	if (NULL == _StrStr(szProductCompare, H323_COMPANYNAME_STR))
	{
		return IFRAMES_CAPS_3RDPARTY;
	}


	// quick check to see if this is NetMeeting or something else
	if (NULL != _StrStr(szProductCompare, H323_PRODUCTNAME_SHORT_STR))
	{
		bIsNetMeeting = true;
	}

	// filter out NetMeeting 2.x
	if (bIsNetMeeting)
	{
		if (
		     (0 == lstrcmp(szVersionCompare, H323_20_PRODUCTRELEASE_STR)) ||
		     (0 == lstrcmp(szVersionCompare, H323_21_PRODUCTRELEASE_STR)) ||
		     (0 == lstrcmp(szVersionCompare, H323_211_PRODUCTRELEASE_STR)) ||
		     (0 == lstrcmp(szVersionCompare, H323_21_SP1_PRODUCTRELEASE_STR))
		   )
		{
			delete [] szVersionCompare;
			delete [] szProductCompare;
			return IFRAMES_CAPS_NM2;
		}
	}


	if (bIsNetMeeting == false)
	{
		// filter out TAPI v3.0
		// their version string is "Version 3.0", NetMeeting is "3.0"
		if (0 == lstrcmp(szVersionCompare, H323_TAPI30_PRODUCTRELEASE_STR))
		{
			delete [] szVersionCompare;
			delete [] szProductCompare;
			return IFRAMES_CAPS_3RDPARTY;
		}

		// a Microsoft product that isn't TAPI 3.0 or NetMeeting ?
		// assume compliance with the I-Frames stuff
		DEBUGMSG (ZONE_IFRAME, ("Microsoft H.323 product that isn't NetMeeting !\r\n"));
		DEBUGMSG (ZONE_IFRAME, ("Assuming that that remote knows about I-Frames!\r\n"));
	}

	delete [] szVersionCompare;
	delete [] szProductCompare;

	// must be NetMeeting 3.0, TAPI 3.1, or later
	return IFRAMES_CAPS_NM3;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\vidstrm.cpp ===
#include "precomp.h"

#ifndef SIZEOF_VIDEOFORMATEX
#define SIZEOF_VIDEOFORMATEX(pwfx)   (sizeof(VIDEOFORMATEX))
#endif

// #define LOGSTATISTICS_ON 1

// Used to translate between frame sizes and the FRAME_* bit flags
#define NON_STANDARD    0x80000000
#define SIZE_TO_FLAG(s) (s == Small  ? FRAME_SQCIF : s == Medium ? FRAME_QCIF: s == Large ? FRAME_CIF : NON_STANDARD)


const int VID_AVG_PACKET_SIZE = 450; // avg from NetMon stats


// maps temporal spatial tradeoff to a target frame rate

// assume the MAX frame rate for QCIF and SQCIF is 10 on modem
// let the "best quality" be 2 frames/sec
int g_TSTable_Modem_QCIF[] =
{
	200, 225, 250, 275,  // best quality
	300, 325, 350, 375,
	400, 425, 450, 475,
	500, 525, 550, 575,
	600, 625, 650, 675,
	700, 725, 750, 775,
	800, 825, 850, 875,
	900, 925, 950, 1000   // fast frames
};



// max frame rate for CIF be 2.5 frames/sec on modem
// best quality will be .6 frame/sec
int g_TSTable_Modem_CIF[] =
{
	60,   66,  72,  78,
	84,   90,  96, 102,
	108, 114, 120, 126,
	132, 140, 146, 152,
	158, 164, 170, 174,
	180, 186, 192, 198,
	208, 216, 222, 228,
	232, 238, 244, 250
};




#ifdef USE_NON_LINEAR_FPS_ADJUSTMENT
// this table and related code anc be used for non-linear adjustment of our frame rate based
// on QOS information in QosNotifyVideoCB
int g_QoSMagic[19][19] =
{
	{-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90},
	{-90,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80},
	{-90,-80,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70},
	{-90,-80,-70,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60},
	{-90,-80,-70,-60,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50},
	{-90,-80,-70,-60,-50,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40},
	{-90,-80,-70,-60,-50,-40,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30},
	{-90,-80,-70,-60,-50,-40,-30,-20,-20,-20,-20,-20,-20,-20,-20,-20,-20,-20,-20},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 10, 10, 10, 10, 10, 10, 10, 10},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 20, 20, 20, 20, 20, 20, 20},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 30, 30, 30, 30, 30, 30},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 40, 40, 40, 40, 40, 40},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 40, 50, 50, 50, 50, 50},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 40, 50, 60, 60, 60, 60},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 40, 50, 60, 70, 70, 70},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 40, 50, 60, 70, 80, 80},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 40, 50, 60, 70, 80, 90},
};
#endif

BOOL SortOrder(IAppVidCap *pavc, BASIC_VIDCAP_INFO* pvidcaps, DWORD dwcFormats,
        DWORD dwFlags, WORD wDesiredSortOrder, int nNumFormats);


UINT ChoosePacketSize(VIDEOFORMATEX *pvf)
{
	// set default samples per pkt to 1
	UINT spp, sblk;
	spp = 1;
	// calculate samples per block ( aka frame)
	sblk = pvf->nBlockAlign* pvf->nSamplesPerSec/ pvf->nAvgBytesPerSec;
	if (sblk <= spp) {
		spp = (spp/sblk)*sblk;
	} else
		spp = sblk;
	return spp;
}



HRESULT STDMETHODCALLTYPE SendVideoStream::QueryInterface(REFIID iid, void **ppVoid)
{
	// resolve duplicate inheritance to the SendMediaStream;

	extern IID IID_IProperty;

	if (iid == IID_IUnknown)
	{
		*ppVoid = (IUnknown*)((RecvMediaStream*)this);
	}
	else if (iid == IID_IMediaChannel)
	{
		*ppVoid = (IMediaChannel*)((RecvMediaStream *)this);
	}
	else if (iid == IID_IVideoChannel)
	{
		*ppVoid = (IVideoChannel*)this;
	}
	else if (iid == IID_IProperty)
	{
		*ppVoid = NULL;
		ERROR_OUT(("Don't QueryInterface for IID_IProperty, use IMediaChannel"));
		return E_NOINTERFACE;
	}

	else if (iid == IID_IVideoRender)// satisfy symmetric property of QI
	{
		*ppVoid = (IVideoRender *)this;
	}

	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return S_OK;

}

ULONG STDMETHODCALLTYPE SendVideoStream::AddRef(void)
{
	return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE SendVideoStream::Release(void)
{
	LONG lRet;

	lRet = InterlockedDecrement(&m_lRefCount);

	if (lRet == 0)
	{
		delete this;
		return 0;
	}

	else
		return lRet;

}


DWORD CALLBACK SendVideoStream::StartCaptureThread(LPVOID pVoid)
{
	SendVideoStream *pThisStream = (SendVideoStream*)pVoid;
	return pThisStream->CapturingThread();
}

HRESULT
SendVideoStream::Initialize(DataPump *pDP)
{
	HRESULT hr = DPR_OUT_OF_MEMORY;
	DWORD dwFlags =  DP_FLAG_FULL_DUPLEX | DP_FLAG_AUTO_SWITCH ;
	MEDIACTRLINIT mcInit;
	FX_ENTRY ("DP::InitChannel")
    FINDCAPTUREDEVICE fcd;

	m_pIUnknown = (IUnknown *)NULL;

	InitializeCriticalSection(&m_crsVidQoS);
	InitializeCriticalSection(&m_crs);
	dwFlags |= DP_FLAG_VCM | DP_FLAG_VIDEO ;

    m_maxfps = 2997;            // max of 29.97 fps
    m_frametime = 1000 / 30;     // default of 30 fps  (time in ms) QOS will slow us, if
                                 // need be

	// Modem connections will use a frame rate control table
	// to implement TS-Tradeoff
	m_pTSTable = NULL;
	m_dwCurrentTSSetting = VCM_DEFAULT_IMAGE_QUALITY;

	// store the platform flags
	// enable Send and Recv by default
	m_DPFlags = (dwFlags & DP_MASK_PLATFORM) | DPFLAG_ENABLE_SEND ;
	// store a back pointer to the datapump container
	m_pDP = pDP;
	m_pRTPSend = NULL;
	
//    m_PrevFormatId = INVALID_MEDIA_FORMAT;
	ZeroMemory(&m_fCodecOutput, sizeof(VIDEOFORMATEX));

	// Initialize data (should be in constructor)
	m_CaptureDevice =  (UINT) -1;	// use VIDEO_MAPPER
	m_PreviousCaptureDevice = (UINT) -1;


    DBG_SAVE_FILE_LINE
	m_SendStream = new TxStream();
	if (!m_SendStream)
	{
		DEBUGMSG (ZONE_DP, ("%s:  TxStream new failed\r\n", _fx_));
 		goto StreamAllocError;
	}


	// Create Input and Output video filters
    DBG_SAVE_FILE_LINE
	m_pVideoFilter = new VcmFilter();
	m_dwDstSize = 0;
	if (m_pVideoFilter==NULL)
	{
		DEBUGMSG (ZONE_DP, ("%s: VcmFilter new failed\r\n", _fx_));
		goto FilterAllocError;
	}
	

	//Create Video MultiMedia device control objects
    DBG_SAVE_FILE_LINE
	m_InMedia = new VideoInControl();
	if (!m_InMedia )
	{
		DEBUGMSG (ZONE_DP, ("%s: MediaControl new failed\r\n", _fx_));
		goto MediaAllocError;
	}

	// Initialize the send-stream media control object
	mcInit.dwFlags = dwFlags | DP_FLAG_SEND;
	hr = m_InMedia->Initialize(&mcInit);
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: IMedia->Init failed, hr=0x%lX\r\n", _fx_, hr));
		goto MediaAllocError;
	}


	// determine if the video devices are available
    fcd.dwSize = sizeof (FINDCAPTUREDEVICE);
    if (FindFirstCaptureDevice(&fcd, NULL)) {
		DEBUGMSG (ZONE_DP, ("%s: OMedia->have capture cap\r\n", _fx_));
		m_DPFlags |= DP_FLAG_RECORD_CAP ;
	}
	
	// set media to half duplex mode by default
	m_InMedia->SetProp(MC_PROP_DUPLEX_TYPE, DP_FLAG_HALF_DUPLEX);

	m_SavedTickCount = timeGetTime();	//so we start with low timestamps
	m_DPFlags |= DPFLAG_INITIALIZED;

	return DPR_SUCCESS;


MediaAllocError:
	if (m_InMedia) delete m_InMedia;
FilterAllocError:
	if (m_pVideoFilter) delete m_pVideoFilter;
StreamAllocError:
	if (m_SendStream) delete m_SendStream;

	ERRORMESSAGE( ("SendVideoStream::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}

// LOOK: identical to SendAudioStream version.
SendVideoStream::~SendVideoStream()
{

	if (m_DPFlags & DPFLAG_INITIALIZED) {
		m_DPFlags &= ~DPFLAG_INITIALIZED;

		// TEMP:Make sure preview stops
		m_DPFlags &= ~DPFLAG_ENABLE_PREVIEW;
		
		if (m_DPFlags & DPFLAG_CONFIGURED_SEND )
		{
			UnConfigure();
		}

		if (m_pRTPSend)
		{
			m_pRTPSend->Release();
			m_pRTPSend = NULL;
		}


		// Close the receive and transmit streams
		if (m_SendStream) delete m_SendStream;

		// Close the wave devices
		if (m_InMedia) { delete m_InMedia;}
		// Close the filters
		if (m_pVideoFilter)
		{
			delete m_pVideoFilter;
		}
		m_pDP->RemoveMediaChannel(MCF_SEND| MCF_VIDEO, (IMediaChannel*)(RecvMediaStream *)this);

	}
	DeleteCriticalSection(&m_crs);
	DeleteCriticalSection(&m_crsVidQoS);
}



HRESULT STDMETHODCALLTYPE SendVideoStream::Configure(
	BYTE *pFormat,
	UINT cbFormat,
	BYTE *pChannelParams,
	UINT cbParams,
	IUnknown *pUnknown)
{
	HRESULT hr;
	BOOL fRet;
	MEDIAPACKETINIT pcktInit;
	MEDIACTRLCONFIG mcConfig;
	MediaPacket **ppPckt;
	ULONG cPckt, uIndex;
	DWORD_PTR dwPropVal;
	VIDEOFORMATEX *pfSend = (VIDEOFORMATEX*)pFormat;
	DWORD maxBitRate=0;
	DWORD i, dwSrcSize, dwMaxFragSize=0;
	int iXOffset, iYOffset;
	VIDEO_CHANNEL_PARAMETERS vidChannelParams;
	struct {
		int cResources;
		RESOURCE aResources[1];
	} m_aLocalRs;
	vidChannelParams.RTP_Payload = 0;
	int optval = 0 ;
	CCaptureChain *pChain;
	HCAPDEV hCapDev=NULL;
    LPBITMAPINFOHEADER lpcap, lpsend;
	BOOL fNewDeviceSettings = TRUE;
	BOOL fNewDevice = TRUE;
	BOOL fLive = FALSE, fReconfiguring;
	MMRESULT mmr;
	DWORD dwStreamingMode = STREAMING_PREFER_FRAME_GRAB;


	FX_ENTRY ("SendVideoStream::Configure")

    if (pfSend)
    {
    	// for now, don't allow SendVideoStream to be re-configured
	    // if we are already streaming.
        if (m_DPFlags & DPFLAG_STARTED_SEND)
        {
            return DPR_IO_PENDING;
        }
    }
    else
    {
        ASSERT(!pChannelParams);
    }

	if(NULL != pChannelParams)
	{
		// get channel parameters
		if (cbParams != sizeof(vidChannelParams))
		{
			hr = DPR_INVALID_PARAMETER;
			goto IMediaInitError;
		}

		vidChannelParams = *(VIDEO_CHANNEL_PARAMETERS *)pChannelParams;
		fLive = TRUE;
	}
    else
    {
        //
    	// else this is configuring for preview or is unconfiguring. There are
        // no channel parameters
        //
    }
	
    if (m_DPFlags & DPFLAG_CONFIGURED_SEND)
	{
        if (pfSend)
        {
            if (m_CaptureDevice == m_PreviousCaptureDevice)
    			fNewDevice = FALSE;
	    	if (IsSimilarVidFormat(&m_fCodecOutput, pfSend))
    			fNewDeviceSettings = FALSE;
        }

		// When using a different capture device, we systematically configure everyting
		// although it would probably be possible to optimize the configuration
		// of the filters and transmit stream
        EndSend();
		UnConfigureSendVideo(fNewDeviceSettings, fNewDevice);
    }

    if (!pfSend)
    {
        return DPR_SUCCESS;
    }

	if (fLive)
		m_DPFlags |= DPFLAG_REAL_THING;

//	m_Net = pNet;
	
	if (! (m_DPFlags & DPFLAG_INITIALIZED))
		return DPR_OUT_OF_MEMORY;		//BUGBUG: return proper error;
		
	if (fNewDeviceSettings || fNewDevice)
	{
		m_ThreadFlags |= DPTFLAG_PAUSE_CAPTURE;

		mcConfig.uDuration = MC_USING_DEFAULT;	// set duration by samples per pkt
		// force an unknown device to be profiled by fetching
		// it's streaming capabilites BEFORE opening it
		mmr = vcmGetDevCapsStreamingMode(m_CaptureDevice, &dwStreamingMode);
		if (mmr != MMSYSERR_NOERROR)
		{
			dwStreamingMode = STREAMING_PREFER_FRAME_GRAB;
		}


		m_InMedia->GetProp (MC_PROP_MEDIA_DEV_HANDLE, &dwPropVal);

		if (!dwPropVal) {
			// if capture device isn't already open, then open it
			m_InMedia->SetProp(MC_PROP_MEDIA_DEV_ID, (DWORD)m_CaptureDevice);
			if (fNewDevice)
			{
				hr = m_InMedia->Open();
    			if (hr != DPR_SUCCESS) {
	    			DEBUGMSG (ZONE_DP, ("%s: m_InMedia->Open failed to open capture, hr=0x%lX\r\n", _fx_, hr));
					goto IMediaInitError;
				}
			}
			m_InMedia->GetProp (MC_PROP_MEDIA_DEV_HANDLE, &dwPropVal);
    		if (!dwPropVal) {
	    		DEBUGMSG (ZONE_DP, ("%s: capture device not open (0x%lX)\r\n", _fx_));
				goto IMediaInitError;
			}
		}
		hCapDev = (HCAPDEV)dwPropVal;

		if (m_pCaptureChain) {
			delete m_pCaptureChain;
			m_pCaptureChain = NULL;
		}

		i = 0;  // assume no colortable

		// m_fDevSend is the uncompressed format
		// pfSend is the compressed format
		mmr = VcmFilter::SuggestEncodeFormat(m_CaptureDevice, &m_fDevSend, pfSend);

		if (mmr == MMSYSERR_NOERROR) {
			i = m_fDevSend.bih.biClrUsed;   // non-zero, if vcmstrm gave us a colortable
			SetCaptureDeviceFormat(hCapDev, &m_fDevSend.bih, 0, 0);
		}

		dwPropVal = GetCaptureDeviceFormatHeaderSize(hCapDev);
		while (1) {
			if (lpcap = (LPBITMAPINFOHEADER)MemAlloc((UINT)dwPropVal)) {
				lpcap->biSize = (DWORD)dwPropVal;
				if (!GetCaptureDeviceFormat(hCapDev, lpcap)) {
					MemFree(lpcap);
            		DEBUGMSG (ZONE_DP, ("%s: failed to set/get capture format\r\n", _fx_));
					goto IMediaInitError;
				}
				UPDATE_REPORT_ENTRY(g_prptSystemSettings, (lpcap->biWidth << 22) | (lpcap->biHeight << 12) | ((lpcap->biCompression == VIDEO_FORMAT_UYVY) ? VIDEO_FORMAT_NUM_COLORS_UYVY : (lpcap->biCompression == VIDEO_FORMAT_YUY2) ? VIDEO_FORMAT_NUM_COLORS_YUY2 : (lpcap->biCompression == VIDEO_FORMAT_IYUV) ? VIDEO_FORMAT_NUM_COLORS_IYUV : (lpcap->biCompression == VIDEO_FORMAT_I420) ? VIDEO_FORMAT_NUM_COLORS_I420 : (lpcap->biCompression == VIDEO_FORMAT_YVU9) ? VIDEO_FORMAT_NUM_COLORS_YVU9 : (lpcap->biCompression == 0) ? ((lpcap->biBitCount == 24) ? VIDEO_FORMAT_NUM_COLORS_16777216 : (lpcap->biBitCount == 16) ? VIDEO_FORMAT_NUM_COLORS_65536 : (lpcap->biBitCount == 8) ? VIDEO_FORMAT_NUM_COLORS_256 : (lpcap->biBitCount == 4) ? VIDEO_FORMAT_NUM_COLORS_16 : 0x00000800) : 0x00000800), REP_DEVICE_IMAGE_SIZE);
				if (lpcap->biBitCount > 8)
					break;
				else if (dwPropVal > 256 * sizeof(RGBQUAD)) {
					if (i) {
						// vcmstrm gave us a colortable in m_fDevSend, so use it
						CopyMemory(((BYTE*)lpcap) + lpcap->biSize, (BYTE*)&m_fDevSend.bih + m_fDevSend.bih.biSize,
								   256 * sizeof(RGBQUAD));
					}
					else {
						CAPTUREPALETTE pal;
						LPRGBQUAD lprgb;

						GetCaptureDevicePalette(hCapDev, &pal);
						lprgb = (LPRGBQUAD)(((BYTE*)lpcap) + lpcap->biSize);
						for (i = 0; i < 256; i++) {
               				lprgb->rgbRed = pal.pe[i].peRed;
               				lprgb->rgbGreen = pal.pe[i].peGreen;
                   			lprgb->rgbBlue = pal.pe[i].peBlue;
                   			lprgb++;
						}
					}
					break;
				}

				dwPropVal += 256 * sizeof(RGBQUAD);
				MemFree(lpcap);  // free this lpcap, and alloc a new with room for palette
			}
			else {
       			DEBUGMSG (ZONE_DP, ("%s: failed to set/get capture format\r\n", _fx_));
    			goto IMediaInitError;
			}
		}

        DBG_SAVE_FILE_LINE
		if (pChain = new CCaptureChain) {
    		VIDEOFORMATEX *capfmt;

			// if pfSend is 128x96, but capture is greater, then InitCaptureChain with a larger size so
			// that the codec will just crop to 128x96
			iXOffset = pfSend->bih.biWidth;
			iYOffset = pfSend->bih.biHeight;
			if ((iXOffset == 128) && (iYOffset == 96)) {
				if (lpcap->biWidth == 160) {
					iXOffset = lpcap->biWidth;
					iYOffset = lpcap->biHeight;
				}
				else if (lpcap->biWidth == 320) {
					iXOffset = lpcap->biWidth / 2;
					iYOffset = lpcap->biHeight / 2;
				}
			}
			if ((hr = pChain->InitCaptureChain(hCapDev,
				(dwStreamingMode==STREAMING_PREFER_STREAMING),
								 lpcap, iXOffset, iYOffset, 0, &lpsend)) != NO_ERROR) {
       			DEBUGMSG (ZONE_DP, ("%s: failed to init capture chain\r\n", _fx_));
    			MemFree(lpcap);
       			delete pChain;
    			goto IMediaInitError;
			}
		}
		else {
   			DEBUGMSG (ZONE_DP, ("%s: failed allocate capture chain\r\n", _fx_));
   			MemFree((HANDLE)lpcap);
   			hr = DPR_OUT_OF_MEMORY;
			goto IMediaInitError;
		}
		MemFree((HANDLE)lpcap);

		m_pCaptureChain = pChain;

		// build m_fDevSend format as format that will be input to codec
		CopyMemory(&m_fDevSend, pfSend, sizeof(VIDEOFORMATEX)-sizeof(BITMAPINFOHEADER)-BMIH_SLOP_BYTES);

		// m_fDevSend.bih is the output format of the CaptureChain
		CopyMemory(&m_fDevSend.bih, lpsend, lpsend->biSize);
		//LOOKLOOK RP - need to get colortable too?

		m_fDevSend.dwFormatSize = sizeof(VIDEOFORMATEX);
		m_fDevSend.dwFormatTag = lpsend->biCompression;
		m_fDevSend.nAvgBytesPerSec = m_fDevSend.nMinBytesPerSec =
			m_fDevSend.nMaxBytesPerSec = m_fDevSend.nSamplesPerSec * lpsend->biSizeImage;
		m_fDevSend.nBlockAlign = lpsend->biSizeImage;
		m_fDevSend.wBitsPerSample = lpsend->biBitCount;
		LocalFree((HANDLE)lpsend);

		mcConfig.pDevFmt = &m_fDevSend;
		UPDATE_REPORT_ENTRY(g_prptCallParameters, pfSend->dwFormatTag, REP_SEND_VIDEO_FORMAT);
		RETAILMSG(("NAC: Video Send Format: %.4s", (LPSTR)&pfSend->dwFormatTag));

		// Initialize the send-stream media control object
		mcConfig.hStrm = (DPHANDLE) m_SendStream;
		m_InMedia->GetProp(MC_PROP_MEDIA_DEV_ID, &dwPropVal);
        mcConfig.uDevId = (DWORD)dwPropVal;

		mcConfig.cbSamplesPerPkt = ChoosePacketSize(pfSend);

		hr = m_InMedia->Configure(&mcConfig);
		if (hr != DPR_SUCCESS)
		{
			DEBUGMSG (ZONE_DP, ("%s: IVMedia->Config failed, hr=0x%lX\r\n", _fx_, hr));
			goto IMediaInitError;
		}

		// initialize m_cliprect
		iXOffset = 0; iYOffset = 0;
		if (m_fDevSend.bih.biWidth > pfSend->bih.biWidth)
			iXOffset = (m_fDevSend.bih.biWidth - pfSend->bih.biWidth) >> 1;
		if (m_fDevSend.bih.biHeight > pfSend->bih.biHeight)
			iYOffset = (m_fDevSend.bih.biHeight - pfSend->bih.biHeight) >> 1;
		SetRect(&m_cliprect, iXOffset, iYOffset, pfSend->bih.biWidth + iXOffset, pfSend->bih.biHeight + iYOffset);

		dwMaxFragSize = 512;	// default video packet size
		CopyMemory (&m_fCodecOutput, pfSend, sizeof(VIDEOFORMATEX));
		m_InMedia->GetProp (MC_PROP_SIZE, &dwPropVal);
        dwSrcSize = (DWORD)dwPropVal;

		mmr = m_pVideoFilter->Open(&m_fDevSend, &m_fCodecOutput, dwMaxFragSize);

		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (ZONE_DP, ("%s: VcmFilter->Open failed, mmr=%d\r\n", _fx_, mmr));
			hr = DPR_CANT_OPEN_CODEC;
			goto SendFilterInitError;
		}

		// Initialize the send queue
		ZeroMemory (&pcktInit, sizeof (pcktInit));

		pcktInit.dwFlags = DP_FLAG_SEND | DP_FLAG_VCM | DP_FLAG_VIDEO;
		pcktInit.pStrmConvSrcFmt = &m_fDevSend;
		pcktInit.pStrmConvDstFmt = &m_fCodecOutput;
		pcktInit.cbSizeRawData = dwSrcSize;
		pcktInit.cbOffsetRawData = 0;


		m_InMedia->FillMediaPacketInit (&pcktInit);
		m_InMedia->GetProp (MC_PROP_SIZE, &dwPropVal);


		m_pVideoFilter->SuggestDstSize(dwSrcSize, &m_dwDstSize);
		pcktInit.cbSizeNetData = m_dwDstSize;
			
		m_pVideoFilter->GetProperty(FM_PROP_PAYLOAD_HEADER_SIZE,
                                    &pcktInit.cbPayloadHeaderSize);


		pcktInit.cbOffsetNetData = sizeof (RTP_HDR);
		pcktInit.payload = vidChannelParams.RTP_Payload;



		fRet = m_SendStream->Initialize (DP_FLAG_VIDEO, MAX_TXVRING_SIZE, m_pDP, &pcktInit);
		if (!fRet)
		{
			DEBUGMSG (ZONE_DP, ("%s: TxvStream->Init failed, fRet=0%u\r\n", _fx_, fRet));
			hr = DPR_CANT_INIT_TXV_STREAM;
			goto TxStreamInitError;
		}

		// Prepare headers for TxvStream
		m_SendStream->GetRing (&ppPckt, &cPckt);
		m_InMedia->RegisterData (ppPckt, cPckt);
		m_InMedia->PrepareHeaders ();
	}
	else
	{
		// The following fields may change with the capabilities of the other end point
		dwMaxFragSize = 512;	// default video packet size
		if (pChannelParams)
		{
			m_pVideoFilter->GetProperty(FM_PROP_PAYLOAD_HEADER_SIZE,
                                        &pcktInit.cbPayloadHeaderSize);

			pcktInit.cbOffsetNetData = sizeof (RTP_HDR);
		}
	}
	
	if(pChannelParams)
	{
		// Update the bitrate
		maxBitRate = vidChannelParams.ns_params.maxBitRate*100;
		if (maxBitRate < BW_144KBS_BITS)
			maxBitRate = BW_144KBS_BITS;

		// set the max. fragment size
		DEBUGMSG(ZONE_DP,("%s: Video Send: maxBitRate=%d, maxBPP=%d, MPI=%d\r\n",
			_fx_,maxBitRate,
			vidChannelParams.ns_params.maxBPP*1024,	vidChannelParams.ns_params.MPI*33));

		// Initialize the max frame rate with the negociated max
		if ((vidChannelParams.ns_params.MPI > 0UL) && (vidChannelParams.ns_params.MPI < 33UL))
		{
			dwPropVal = 2997UL / vidChannelParams.ns_params.MPI;
			m_maxfps = (DWORD)dwPropVal;
			INIT_COUNTER_MAX(g_pctrVideoSend, (m_maxfps + 50) / 100);
			UPDATE_REPORT_ENTRY(g_prptCallParameters, (m_maxfps + 50) / 100, REP_SEND_VIDEO_MAXFPS);
			RETAILMSG(("NAC: Video Send Max Frame Rate (negotiated - fps): %ld", (m_maxfps + 50) / 100));
			DEBUGMSG(1,("%s: Video Send: Negociated max fps = %d.%d\r\n", _fx_, m_maxfps/100, m_maxfps - m_maxfps / 100 * 100));
		}

		UPDATE_REPORT_ENTRY(g_prptCallParameters, maxBitRate, REP_SEND_VIDEO_BITRATE);
		RETAILMSG(("NAC: Video Send Max Bitrate (negotiated - bps): %ld", maxBitRate));
		INIT_COUNTER_MAX(g_pctrVideoSendBytes, maxBitRate * 75 / 100);

		// At this point we actually know what is the minimum bitrate chosen
		// by the sender and the receiver. Let's reset the resources reserved
		// by the QoS with those more meaningfull values.
		if (m_pDP->m_pIQoS)
		{
			// Fill in the resource list
			m_aLocalRs.cResources = 1;
			m_aLocalRs.aResources[0].resourceID = RESOURCE_OUTGOING_BANDWIDTH;

			// Do a sanity check on the minimal bit rate
			m_aLocalRs.aResources[0].nUnits = maxBitRate;
			m_aLocalRs.aResources[0].ulResourceFlags = m_aLocalRs.aResources[0].reserved = 0;

			DEBUGMSG(1,("%s: Video Send: Negociated max bps = %d\r\n", _fx_, maxBitRate));

			// Set the resources on the QoS object
			hr = m_pDP->m_pIQoS->SetResources((LPRESOURCELIST)&m_aLocalRs);
		}

		// if we're sending on the LAN, fragment video frames into Ethernet packet sized chunks
		// On slower links use smaller packets for better bandwidth sharing
		// NOTE: codec packetizer can occasionally exceed the fragment size limit
		if (maxBitRate > BW_ISDN_BITS)
			dwMaxFragSize = 1350;

		m_pVideoFilter->SetProperty(FM_PROP_VIDEO_MAX_PACKET_SIZE, dwMaxFragSize);

		// To correctly initialize the flow spec structure we need to get the values that
		// our QoS module will be effectively using. Typically, we only use 70% of the max
		// advertized. On top of that, some system administrator may have significantly
		// reduced the maximum bitrate on this machine.
		if (m_pDP->m_pIQoS)
		{
			LPRESOURCELIST pResourceList = NULL;

			// Get a list of all resources from QoS
			hr = m_pDP->m_pIQoS->GetResources(&pResourceList);
			if (SUCCEEDED(hr) && pResourceList)
			{
				// Find the BW resource
				for (i=0; i < pResourceList->cResources; i++)
				{
					if (pResourceList->aResources[i].resourceID == RESOURCE_OUTGOING_BANDWIDTH)
					{
						maxBitRate = min(maxBitRate, (DWORD)pResourceList->aResources[i].nUnits);
						break;
					}
				}

				// Release memory
				m_pDP->m_pIQoS->FreeBuffer(pResourceList);
			}
		}

		// WS2Qos will be called in Start to communicate stream information to the
		// remote endpoint using a PATH message
		//
		// We use a peak-rate allocation approach based on our target bitrates
		// Note that for the token bucket size and the maximum SDU size, we now
		// account for IP header overhead, and use the max frame fragment size
		// instead of the maximum compressed image size returned by the codec

		ASSERT(maxBitRate > 0);

		InitVideoFlowspec(&m_flowspec, maxBitRate, dwMaxFragSize, VID_AVG_PACKET_SIZE);

		// Update RTCP send address and payload type. It should be known now
		// We have to explicitly set the payload again because the preview
		// channel configuration has already set it to zero.
		m_RTPPayload = vidChannelParams.RTP_Payload;
		m_SendStream->GetRing (&ppPckt, &cPckt);
		for (uIndex = 0; uIndex < cPckt; uIndex++)
		{
			ppPckt[uIndex]->SetPayload(m_RTPPayload);
		}

		// Keep a weak reference to the IUnknown interface
		// We will use it to query a Stream Signal interface pointer in Start()
		m_pIUnknown = pUnknown;
	}

	if (m_DPFlags & DPFLAG_REAL_THING)
	{
		if (m_pDP->m_pIQoS)
		{
			// Initialize our requests. One for CPU usage, one for bandwidth usage.
			m_aRRq.cResourceRequests = 2;
			m_aRRq.aResourceRequest[0].resourceID = RESOURCE_OUTGOING_BANDWIDTH;
			m_aRRq.aResourceRequest[0].nUnitsMin = 0;
			m_aRRq.aResourceRequest[1].resourceID = RESOURCE_CPU_CYCLES;
			m_aRRq.aResourceRequest[1].nUnitsMin = 0;

			// Initialize QoS structure
			ZeroMemory(&m_Stats, sizeof(m_Stats));

			// Start collecting CPU performance data from the registry
			StartCPUUsageCollection();

			// Register with the QoS module. This call should NEVER fail. If it does, we'll do without the QoS
			m_pDP->m_pIQoS->RequestResources((GUID *)&MEDIA_TYPE_H323VIDEO, (LPRESOURCEREQUESTLIST)&m_aRRq, QosNotifyVideoCB, (DWORD_PTR)this);
		}
	}

	// reset the temporal spatial tradeoff to best quality
	// it's expected that the UI will re-specify the TS setting
	// sometime after the stream is started
	m_pVideoFilter->SetProperty(FM_PROP_VIDEO_RESET_IMAGE_QUALITY ,VCM_RESET_IMAGE_QUALITY);
	m_pTSTable = NULL;
	m_dwCurrentTSSetting = VCM_MAX_IMAGE_QUALITY;



    //Before we start, reset the frame frame rate to the channel max.
    //If the previous call had been slower than possible, resume
    //previewing at the desired FPS.
	if (pChannelParams && (m_DPFlags & DPFLAG_REAL_THING))
	{
		int iSlowStartFrameRate;

		// us a frame-rate table for temporal spatial tradeoff settings
		// if the bandwidth is a modem setting
		if (maxBitRate <= BW_288KBS_BITS)
		{
			if (pfSend->bih.biWidth >= CIF_WIDTH)
			{
				m_pTSTable = g_TSTable_Modem_CIF;
			}
			else
			{
				m_pTSTable = g_TSTable_Modem_QCIF;
			}
		}

		// Let's do a slow start and then catch up with the negociated max

		if (m_pTSTable == NULL)
		{
			iSlowStartFrameRate = m_maxfps >> 1;
		}
		else
		{
			iSlowStartFrameRate = m_pTSTable[VCM_MAX_IMAGE_QUALITY];
		}


		SetProperty(PROP_VIDEO_FRAME_RATE, &iSlowStartFrameRate, sizeof(int));

		// Initialize the codec with the new target bitrates and frame rates
		// PhilF-: This assumes that we start with a silent audio channel...
		SetTargetRates(iSlowStartFrameRate, maxBitRate);


	}
	else
	{
		INIT_COUNTER_MAX(g_pctrVideoSend, 30);
		SetProperty(PROP_VIDEO_FRAME_RATE, &m_maxfps, sizeof(int));
	}

    m_ThreadFlags &= ~DPTFLAG_PAUSE_CAPTURE;
	m_DPFlags |= DPFLAG_CONFIGURED_SEND;
	m_PreviousCaptureDevice = m_CaptureDevice;
//	m_PrevFormatId = SendVidFmt;

	return DPR_SUCCESS;


TxStreamInitError:
	m_pVideoFilter->Close();
SendFilterInitError:
IMediaInitError:
    if (m_pCaptureChain) {
        delete m_pCaptureChain;
        m_pCaptureChain = NULL;
    }
	// We need to close the video controller object on failure to open the capture device,
	// otherwise we get a pure virtual function call on NM shutdown!
	if (m_InMedia)
		m_InMedia->Close();
	ERRORMESSAGE(("%s:  failed, hr=0%u\r\n", _fx_, hr));
	return hr;
}


void SendVideoStream::UnConfigure()
{
	// By default, unconfigure all resources
	UnConfigureSendVideo(TRUE, TRUE);
}


void SendVideoStream::UnConfigureSendVideo(BOOL fNewDeviceSettings, BOOL fNewDevice)
{

#ifdef TEST
	DWORD dwTicks;

	dwTicks = GetTickCount();
#endif

	if (m_DPFlags & DPFLAG_CONFIGURED_SEND)
	{
		if (m_hCapturingThread)
			Stop();

		if (fNewDeviceSettings || fNewDevice)
		{
//			m_PrevFormatId = INVALID_MEDIA_FORMAT;
			ZeroMemory(&m_fCodecOutput, sizeof(VIDEOFORMATEX));

			m_Net = NULL;

			if (m_pCaptureChain)
			{
				delete m_pCaptureChain;
				m_pCaptureChain = NULL;
			}

			// Close the devices
			m_InMedia->Reset();
			m_InMedia->UnprepareHeaders();
			if (fNewDevice)
			{
				m_PreviousCaptureDevice = -1L; // VIDEO_MAPPER
				m_InMedia->Close();
			}

			// Close the filters
			m_pVideoFilter->Close();

			// Close the transmit streams
			m_SendStream->Destroy();
		}

		m_DPFlags &= ~DPFLAG_CONFIGURED_SEND;

		// Release the QoS Resources
		// If the associated RequestResources had failed, the ReleaseResources can be
		// still called... it will just come back without having freed anything.
		if (m_pDP->m_pIQoS)
		{
			if (m_DPFlags & DPFLAG_REAL_THING)
			{
				m_pDP->m_pIQoS->ReleaseResources((GUID *)&MEDIA_TYPE_H323VIDEO, (LPRESOURCEREQUESTLIST)&m_aRRq);

				// Terminate CPU usage data collection
				StopCPUUsageCollection();

			}
			m_DPFlags &= ~DPFLAG_REAL_THING;
		}
	}

#ifdef TEST
	LOG((LOGMSG_TIME_SEND_VIDEO_UNCONFIGURE,GetTickCount() - dwTicks));
#endif

}




HRESULT
SendVideoStream::Start()
{
	int nRet= IFRAMES_CAPS_UNKNOWN;

	FX_ENTRY ("SendVideoStream::Start")

	if (m_DPFlags & DPFLAG_STARTED_SEND)
		return DPR_SUCCESS;
	if (!(m_DPFlags & DPFLAG_CONFIGURED_SEND))
		return DPR_NOT_CONFIGURED;

	// to fix:  if we optimize SetNetworkInterface to allow
	// us to transition from preview->sending without having
	// to call stop/start, we need to make sure the flowspec/QOS
	// stuff get's called there.

	SetFlowSpec();
		
	ASSERT(!m_hCapturingThread);
	m_ThreadFlags &= ~(DPTFLAG_STOP_RECORD|DPTFLAG_STOP_SEND);
	// Start recording thread
	if (!(m_ThreadFlags & DPTFLAG_STOP_RECORD))
		m_hCapturingThread = CreateThread(NULL,0, SendVideoStream::StartCaptureThread,this,0,&m_CaptureThId);

// ------------------------------------------------------------------------
	// Decide whether or not we need to send periodic I-Frames during this call

	// Who are we talking to?
	if ((m_pIUnknown) && (m_DPFlags & DPFLAG_REAL_THING))
	{
		HRESULT hr;
		IStreamSignal *pIStreamSignal=NULL;

		hr = m_pIUnknown->QueryInterface(IID_IStreamSignal, (void **)&pIStreamSignal);
		if (HR_SUCCEEDED(hr))
		{
			nRet = GetIFrameCaps(pIStreamSignal);
			pIStreamSignal->Release();
		}
	}

	// only disable sending of I Frames if and only if we know the remote party
	// can handle it.  In this case, NetMeeting 3.0 or TAPI 3.1
	if (nRet == IFRAMES_CAPS_NM3)
	{
		m_pVideoFilter->SetProperty(FM_PROP_PERIODIC_IFRAMES, FALSE);
	}
	else
	{
		m_pVideoFilter->SetProperty(FM_PROP_PERIODIC_IFRAMES, TRUE);
	}
// ------------------------------------------------------------------------


	m_DPFlags |= DPFLAG_STARTED_SEND;

	DEBUGMSG (ZONE_DP, ("%s: Record threadid=%x,\r\n", _fx_, m_CaptureThId));
	return DPR_SUCCESS;
}

// LOOK: identical to SendAudioStream version.
HRESULT
SendVideoStream::Stop()
{
	DWORD dwWait;
	

	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		return DPR_SUCCESS;
	}
	
	m_ThreadFlags = m_ThreadFlags  | DPTFLAG_STOP_SEND |  DPTFLAG_STOP_RECORD;

	if(m_SendStream) {
		m_SendStream->Stop();
		m_SendStream->Reset();
    }
	/*
	 *	we want to wait for all the threads to exit, but we need to handle windows
	 *	messages (mostly from winsock) while waiting.
	 */

 	if(m_hCapturingThread) {
		dwWait = WaitForSingleObject (m_hCapturingThread, INFINITE);

        DEBUGMSG (ZONE_VERBOSE, ("STOP2: dwWait =%d\r\n", dwWait));
    	ASSERT(dwWait != WAIT_FAILED);

		CloseHandle(m_hCapturingThread);
    	m_hCapturingThread = NULL;
    }

	m_DPFlags &= ~DPFLAG_STARTED_SEND;
	
	return DPR_SUCCESS;
}





HRESULT STDMETHODCALLTYPE SendVideoStream::SetMaxBitrate(UINT uMaxBitrate)
{
	DWORD dwFrameRate=0;
	UINT uSize=sizeof(DWORD);
	BOOL bRet;
	HRESULT hr;

	hr = GetProperty(PROP_VIDEO_FRAME_RATE, &dwFrameRate, &uSize);

	if (SUCCEEDED(hr))
	{
		bRet = SetTargetRates(dwFrameRate, (DWORD)uMaxBitrate);
		if (bRet)
			hr = S_OK;
		else
			hr = E_FAIL;
	}

	return hr;
}





//  IProperty::GetProperty / SetProperty
//  (DataPump::MediaChannel::GetProperty)
//      Properties of the MediaStream.

STDMETHODIMP
SendVideoStream::GetProperty(
	DWORD prop,
	PVOID pBuf,
	LPUINT pcbBuf
    )
{
	HRESULT hr = DPR_SUCCESS;
	DWORD dwValue;
    DWORD_PTR dwPropVal;
	UINT len = sizeof(DWORD);	// most props are DWORDs

	if (!pBuf || *pcbBuf < len)
    {
		*pcbBuf = len;
		return DPR_INVALID_PARAMETER;
	}

	switch (prop)
    {
#ifdef OLDSTUFF
	case PROP_NET_SEND_STATS:
		if (m_Net && *pcbBuf >= sizeof(RTP_STATS))
        {
			m_Net->GetSendStats((RTP_STATS *)pBuf);
			*pcbBuf = sizeof(RTP_STATS);
		} else
			hr = DPR_INVALID_PROP_VAL;
			
		break;
#endif
	case PROP_DURATION:
		hr = m_InMedia->GetProp(MC_PROP_DURATION, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;


	case PROP_RECORD_ON:
		*(DWORD *)pBuf = ((m_DPFlags & DPFLAG_ENABLE_SEND) !=0);
		break;
	case PROP_CAPTURE_DEVICE:
		*(UINT *)pBuf = m_CaptureDevice;
		break;

	case PROP_VIDEO_FRAME_RATE:
	    *((DWORD *)pBuf) = 100000 / m_frametime;
		break;

	case PROP_VIDEO_IMAGE_QUALITY:
		hr = GetTemporalSpatialTradeOff((DWORD *)pBuf);
		break;

    case PROP_VIDEO_CAPTURE_AVAILABLE:
        *(DWORD *)pBuf = (m_DPFlags & DP_FLAG_RECORD_CAP) != 0;
        break;

    case PROP_VIDEO_CAPTURE_DIALOGS_AVAILABLE:
		hr = m_InMedia->GetProp(MC_PROP_VFW_DIALOGS, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
        break;

    case PROP_VIDEO_PREVIEW_ON:
		*(DWORD *)pBuf = ((m_DPFlags & DPFLAG_ENABLE_PREVIEW) != 0);
		break;

	case PROP_PAUSE_SEND:
		*(DWORD *)pBuf = ((m_ThreadFlags & DPTFLAG_PAUSE_SEND) != 0);
		break;
	
	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}


STDMETHODIMP
SendVideoStream::SetProperty(
	DWORD prop,
	PVOID pBuf,
	UINT cbBuf
    )
{
	DWORD dw;
	HRESULT hr = S_OK;
	
	if (cbBuf < sizeof (DWORD))
		return DPR_INVALID_PARAMETER;

	switch (prop)
    {
		
	case PROP_CAPTURE_DEVICE:
		if (m_DPFlags & DPFLAG_ENABLE_PREVIEW)
		{
			return DPR_INVALID_PARAMETER;
		}
		else
		{
			m_CaptureDevice = *(UINT*)pBuf;
			m_InMedia->SetProp(MC_PROP_MEDIA_DEV_ID, (DWORD)m_CaptureDevice);
		}

		break;

	case PROP_VIDEO_FRAME_RATE:
		if (*(DWORD*)pBuf <= m_maxfps) {
    		DEBUGMSG(ZONE_VERBOSE, ("DP: setting fps = %d \n", *(DWORD*)pBuf));
			// set frame rate here
            m_frametime = 100000 / *(DWORD*)pBuf;
        }
		break;

	case PROP_VIDEO_IMAGE_QUALITY:
		hr = SetTemporalSpatialTradeOff(*(DWORD*)pBuf);
		break;

	case PROP_VIDEO_RESET_IMAGE_QUALITY:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_IMAGE_QUALITY, VCM_DEFAULT_IMAGE_QUALITY);
		break;

    case PROP_VIDEO_CAPTURE_DIALOG:
        hr = ((VideoInControl *)m_InMedia)->DisplayDriverDialog(GetActiveWindow(), *(DWORD *)pBuf);
        break;

    case PROP_VIDEO_SIZE:
		ASSERT(0);
		break;

    case PROP_VIDEO_PREVIEW_ON:
		ASSERT(0);  	
    	break;
    case PROP_VIDEO_AUDIO_SYNC:
		if (*(DWORD *)pBuf)
    		m_DPFlags |= DPFLAG_AV_SYNC;
		else
			m_DPFlags &= ~DPFLAG_AV_SYNC;
    	break;

	case PROP_PAUSE_SEND:
		if (*(DWORD *)pBuf)
			m_ThreadFlags |= DPTFLAG_PAUSE_SEND;
		else
			m_ThreadFlags &= ~DPTFLAG_PAUSE_SEND;
		break;
	default:
		return DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}



//---------------------------------------------------------------------
//  IVideoRender implementation and support functions



//  IVideoRender::Init
//  (DataPump::Init)

STDMETHODIMP
SendVideoStream::Init(
    DWORD_PTR dwUser,
    LPFNFRAMEREADY pfCallback
    )
{
    // Save the event away. Note that we DO allow both send and receive to
    // share an event
	m_hRenderEvent = (HANDLE) dwUser;
	// if pfCallback is NULL then dwUser is an event handle
	m_pfFrameReadyCallback = pfCallback;
		
	
	return DPR_SUCCESS;
}


//  IVideoRender::Done
//  (DataPump::Done)

STDMETHODIMP
SendVideoStream::Done( )
{
	m_hRenderEvent = NULL;
	m_pfFrameReadyCallback = NULL;
    return DPR_SUCCESS;
}


//  IVideoRender::GetFrame
//  (DataPump::GetFrame)

STDMETHODIMP
SendVideoStream::GetFrame(
    FRAMECONTEXT* pfc
    )
{
	HRESULT hr;
	PVOID pData = NULL;
	UINT cbData = 0;

    // Validate parameters
    if (!pfc )
        return DPR_INVALID_PARAMETER;

    // Don't arbitrarily call out while holding this crs or you may deadlock...
    EnterCriticalSection(&m_crs);

	if ((m_DPFlags & DPFLAG_CONFIGURED_SEND) && m_pNextPacketToRender && !m_pNextPacketToRender->m_fRendering)
    {
		m_pNextPacketToRender->m_fRendering = TRUE;
		m_pNextPacketToRender->GetDevData(&pData,&cbData);
		pfc->lpData = (PUCHAR) pData;
		pfc->dwReserved = (DWORD_PTR) m_pNextPacketToRender;
		// set bmi length?
		pfc->lpbmi = (PBITMAPINFO)&m_fDevSend.bih;
		pfc->lpClipRect = &m_cliprect;
		m_cRendering++;
		hr = S_OK;
		LOG((LOGMSG_GET_SEND_FRAME,m_pNextPacketToRender->GetIndex()));
	} else
		hr = S_FALSE; // nothing ready to render

    LeaveCriticalSection(&m_crs);

	return hr;	
}


//  IVideoRender::ReleaseFrame
//  (DataPump::ReleaseFrame)

STDMETHODIMP
SendVideoStream::ReleaseFrame(
    FRAMECONTEXT* pfc
    )
{
	HRESULT hr;
	MediaPacket *pPacket;

    // Validate parameters
    if (!pfc)
        return DPR_INVALID_PARAMETER;

    // Handle a send frame
    {
        EnterCriticalSection(&m_crs);

        // Don't arbitrarily call out while holding this crs or you may deadlock...

		if ((m_DPFlags & DPFLAG_CONFIGURED_SEND) && (pPacket = (MediaPacket *)pfc->dwReserved) && pPacket->m_fRendering)
        {
			LOG((LOGMSG_RELEASE_SEND_FRAME,pPacket->GetIndex()));
			pPacket->m_fRendering = FALSE;
			pfc->dwReserved = 0;
			// if its not the current frame
			if (m_pNextPacketToRender != pPacket) {
				pPacket->Recycle();
				m_SendStream->Release(pPacket);
			}
			m_cRendering--;
			hr = S_OK;
		}
        else
			hr = DPR_INVALID_PARAMETER;

        LeaveCriticalSection(&m_crs);
	}
		
	return hr;
}

HRESULT __stdcall SendVideoStream::SendKeyFrame(void)
{
	MMRESULT mmr;
	HVCMSTREAM hvs;

	ASSERT(m_pVideoFilter);

	if ((mmr = m_pVideoFilter->RequestIFrame()) != MMSYSERR_NOERROR)
	{
		return S_FALSE;
	}
	return S_OK;

}

// IVideoChannel
HRESULT __stdcall SendVideoStream::SetTemporalSpatialTradeOff(DWORD dwVal)
{
	HRESULT hr=DPR_NOT_CONFIGURED;

	ASSERT(m_pVideoFilter);

	if (m_pVideoFilter)
	{
		if (m_pTSTable == NULL)
		{
			hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_IMAGE_QUALITY, dwVal);
		}
		m_dwCurrentTSSetting = dwVal;
		return S_OK;
	}

	return hr;
}

HRESULT __stdcall SendVideoStream::GetTemporalSpatialTradeOff(DWORD *pdwVal)
{
	HRESULT hr=DPR_NOT_CONFIGURED;

	ASSERT(m_pVideoFilter);

	if (m_pVideoFilter)
	{
		if (m_pTSTable == NULL)
		{
			*pdwVal	= m_dwCurrentTSSetting;	
			hr = S_OK;
		}
		else
		{
			hr = m_pVideoFilter->GetProperty(FM_PROP_VIDEO_IMAGE_QUALITY, pdwVal);
		}
	}
	return hr;
}



HRESULT STDMETHODCALLTYPE RecvVideoStream::QueryInterface(REFIID iid, void **ppVoid)
{
	// resolve duplicate inheritance to the SendMediaStream;

	extern IID IID_IProperty;

	if (iid == IID_IUnknown)
	{
		*ppVoid = (IUnknown*)((RecvMediaStream*)this);
	}
	else if (iid == IID_IMediaChannel)
	{
		*ppVoid = (IMediaChannel*)((RecvMediaStream *)this);
	}
//	else if (iid == IID_IVideoChannel)
//	{
//		*ppVoid = (IVideoChannel*)this;
//	}
	else if (iid == IID_IProperty)
	{
		*ppVoid = NULL;
		ERROR_OUT(("Don't QueryInterface for IID_IProperty, use IMediaChannel"));
		return E_NOINTERFACE;
	}

	else if (iid == IID_IVideoRender)// satisfy symmetric property of QI
	{
		*ppVoid = (IVideoRender *)this;
	}

	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return S_OK;

}

ULONG STDMETHODCALLTYPE RecvVideoStream::AddRef(void)
{
	return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE RecvVideoStream::Release(void)
{
	LONG lRet;

	lRet = InterlockedDecrement(&m_lRefCount);

	if (lRet == 0)
	{
		delete this;
		return 0;
	}

	else
		return lRet;
}

DWORD CALLBACK RecvVideoStream::StartRenderingThread(PVOID pVoid)
{
	RecvVideoStream *pThisStream = (RecvVideoStream*)pVoid;
	return pThisStream->RenderingThread();
}

HRESULT
RecvVideoStream::Initialize(DataPump *pDP)
{
	HRESULT hr = DPR_OUT_OF_MEMORY;
	DWORD dwFlags =  DP_FLAG_FULL_DUPLEX | DP_FLAG_AUTO_SWITCH ;
	MEDIACTRLINIT mcInit;
	FX_ENTRY ("DP::RecvVideoStream")

	m_pIUnknown = (IUnknown *)NULL;

	InitializeCriticalSection(&m_crs);
	InitializeCriticalSection(&m_crsVidQoS);
	InitializeCriticalSection(&m_crsIStreamSignal);

	dwFlags |= DP_FLAG_VCM | DP_FLAG_VIDEO ;

	// store the platform flags
	// enable Send and Recv by default
	m_DPFlags = (dwFlags & DP_MASK_PLATFORM) | DPFLAG_ENABLE_RECV;
	// store a back pointer to the datapump container
	m_pDP = pDP;
	m_Net = NULL;
	m_pIRTPRecv = NULL;
	

	// Initialize data (should be in constructor)
	m_RenderingDevice = (UINT) -1;	// use VIDEO_MAPPER


	// Create Receive and Transmit video streams
    DBG_SAVE_FILE_LINE
	m_RecvStream = new RVStream(MAX_RXVRING_SIZE);
		
	if (!m_RecvStream )
	{
		DEBUGMSG (ZONE_DP, ("%s: RxStream  new failed\r\n", _fx_));
 		goto StreamAllocError;
	}


	// Create Input and Output video filters
    DBG_SAVE_FILE_LINE
	m_pVideoFilter = new VcmFilter();
	m_dwSrcSize = 0;
	if (m_pVideoFilter == NULL)
	{
		DEBUGMSG (ZONE_DP, ("%s: VcmFilter new failed\r\n", _fx_));
		goto FilterAllocError;
	}
	

	//Create Video MultiMedia device control objects
    DBG_SAVE_FILE_LINE
	m_OutMedia = new VideoOutControl();
	if ( !m_OutMedia)
	{
		DEBUGMSG (ZONE_DP, ("%s: MediaControl new failed\r\n", _fx_));
		goto MediaAllocError;
	}


	// Initialize the recv-stream media control object
	mcInit.dwFlags = dwFlags | DP_FLAG_RECV;
	hr = m_OutMedia->Initialize(&mcInit);
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: OMedia->Init failed, hr=0x%lX\r\n", _fx_, hr));
		goto MediaAllocError;
	}


	m_DPFlags |= DP_FLAG_RECORD_CAP ;
	
	// set media to half duplex mode by default
	m_OutMedia->SetProp(MC_PROP_DUPLEX_TYPE, DP_FLAG_HALF_DUPLEX);
	m_DPFlags |= DPFLAG_INITIALIZED;

	return DPR_SUCCESS;


MediaAllocError:
	if (m_OutMedia) delete m_OutMedia;
FilterAllocError:
	if (m_pVideoFilter) delete m_pVideoFilter;
StreamAllocError:
	if (m_RecvStream) delete m_RecvStream;

	ERRORMESSAGE( ("%s: exit, hr=0x%lX\r\n", _fx_,  hr));

	return hr;
}

// LOOK: identical to RecvAudioStream version.
RecvVideoStream::~RecvVideoStream()
{

	if (m_DPFlags & DPFLAG_INITIALIZED) {
		m_DPFlags &= ~DPFLAG_INITIALIZED;
	
		if (m_DPFlags & DPFLAG_CONFIGURED_RECV)
			UnConfigure();

		// Close the receive and transmit streams
		if (m_RecvStream) delete m_RecvStream;

		// Close the wave devices
		if (m_OutMedia) { delete m_OutMedia;}
		// Close the filters
		if (m_pVideoFilter)
			delete m_pVideoFilter;

		m_pDP->RemoveMediaChannel(MCF_RECV| MCF_VIDEO, this);

	}
	DeleteCriticalSection(&m_crs);
	DeleteCriticalSection(&m_crsVidQoS);
	DeleteCriticalSection(&m_crsIStreamSignal);
}


HRESULT
RecvVideoStream::Configure(
	BYTE __RPC_FAR *pFormat,
	UINT cbFormat,
	BYTE __RPC_FAR *pChannelParams,
	UINT cbParams,
	IUnknown *pUnknown)
{
	MMRESULT mmr;
	DWORD dwSrcSize;
	HRESULT hr;
	BOOL fRet;
	MEDIAPACKETINIT pcktInit;
	MEDIACTRLCONFIG mcConfig;
	MediaPacket **ppPckt;
	ULONG cPckt;
	DWORD_PTR dwPropVal;
	UINT ringSize = MAX_RXVRING_SIZE;
	DWORD dwFlags, dwSizeDst, dwMaxFrag, dwMaxBitRate = 0;

	VIDEOFORMATEX *pfRecv = (VIDEOFORMATEX*)pFormat;
	VIDEO_CHANNEL_PARAMETERS vidChannelParams;
	int optval=8192*4; // Use max SQCIF, QCIF I frame size
#ifdef TEST
	DWORD dwTicks;
#endif

	FX_ENTRY ("RecvVideoStream::Configure")

#ifdef TEST
	dwTicks = GetTickCount();
#endif

//	m_Net = pNet;

	// get format details
	if ((NULL == pFormat) || (NULL == pChannelParams)
			|| (cbParams != sizeof(vidChannelParams)))
	{
		return DPR_INVALID_PARAMETER;
	}

	vidChannelParams = *(VIDEO_CHANNEL_PARAMETERS *)pChannelParams;
		
	if (! (m_DPFlags & DPFLAG_INITIALIZED))
		return DPR_OUT_OF_MEMORY;		//BUGBUG: return proper error;
		
//	if (m_Net)
//	{
//		hr = m_Net->QueryInterface(IID_IRTPRecv, (void **)&m_pIRTPRecv);
//		if (!SUCCEEDED(hr))
//			return hr;
//	}
	

	mmr = VcmFilter::SuggestDecodeFormat(pfRecv, &m_fDevRecv);

	// initialize m_cliprect
	SetRect(&m_cliprect, 0, 0, m_fDevRecv.bih.biWidth, m_fDevRecv.bih.biHeight);

	// Initialize the recv-stream media control object
	mcConfig.uDuration = MC_USING_DEFAULT;	// set duration by samples per pkt
	mcConfig.pDevFmt = &m_fDevRecv;
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pfRecv->dwFormatTag, REP_RECV_VIDEO_FORMAT);
	RETAILMSG(("NAC: Video Recv Format: %.4s", (LPSTR)&pfRecv->dwFormatTag));

	mcConfig.hStrm = (DPHANDLE) m_RecvStream;
	mcConfig.uDevId = m_RenderingDevice;
	mcConfig.cbSamplesPerPkt = ChoosePacketSize(pfRecv);
	hr = m_OutMedia->Configure(&mcConfig);
	
	m_OutMedia->GetProp (MC_PROP_SIZE, &dwPropVal);
    dwSizeDst = (DWORD)dwPropVal;

	// BUGBUG - HARDCODED platform flags.  The right way to do this is to
	// have a smart filter object create() that creates a platform-aware
	// instance of the object

	dwFlags = DP_FLAG_RECV | DP_FLAG_VCM | DP_FLAG_VIDEO;

	mmr = m_pVideoFilter->Open(pfRecv, &m_fDevRecv, 0); // maxfragsize == 0

	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: RecvVideoFilter->Init failed, hr=0x%lX\r\n", _fx_, hr));
		hr = DPR_CANT_OPEN_CODEC;
		goto RecvFilterInitError;
	}
	
	// set the max. fragment size
	DEBUGMSG(ZONE_DP,("%s: Video Recv: maxBitRate=%d, maxBPP=%d, MPI=%d\r\n", _fx_ ,vidChannelParams.ns_params.maxBitRate*100, vidChannelParams.ns_params.maxBPP*1024, vidChannelParams.ns_params.MPI ? 30 / vidChannelParams.ns_params.MPI : 30));
	UPDATE_REPORT_ENTRY(g_prptCallParameters, vidChannelParams.ns_params.MPI ? 30 / vidChannelParams.ns_params.MPI : 30, REP_RECV_VIDEO_MAXFPS);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, vidChannelParams.ns_params.maxBitRate*100, REP_RECV_VIDEO_BITRATE);
	RETAILMSG(("NAC: Video Recv Max Frame Rate (negotiated - fps): %ld", vidChannelParams.ns_params.MPI ? 30 / vidChannelParams.ns_params.MPI : 30));
	RETAILMSG(("NAC: Video Recv Max Bitrate (negotiated - bps): %ld", vidChannelParams.ns_params.maxBitRate*100));
	INIT_COUNTER_MAX(g_pctrVideoReceive, vidChannelParams.ns_params.MPI ? 30 / vidChannelParams.ns_params.MPI : 30);
	INIT_COUNTER_MAX(g_pctrVideoReceiveBytes, vidChannelParams.ns_params.maxBitRate*100);

	// Initialize the recv stream
	ZeroMemory (&pcktInit, sizeof (pcktInit));

	pcktInit.pStrmConvSrcFmt = pfRecv;
	pcktInit.pStrmConvDstFmt = &m_fDevRecv;
	pcktInit.dwFlags = dwFlags;
	pcktInit.cbOffsetRawData = 0;
	pcktInit.cbSizeRawData = dwSizeDst;

	m_OutMedia->FillMediaPacketInit (&pcktInit);

	m_pVideoFilter->SuggestSrcSize(dwSizeDst, &m_dwSrcSize);

	pcktInit.cbSizeNetData = m_dwSrcSize;

	pcktInit.cbOffsetNetData = sizeof (RTP_HDR);

	m_OutMedia->GetProp (MC_PROP_SPP, &dwPropVal);
	
	ringSize = 8;		// reserve space for 8 video frames
						// may need to increase the number if a/v sync is enabled.
	fRet = ((RVStream*)m_RecvStream)->Initialize (DP_FLAG_VIDEO, ringSize, NULL, &pcktInit, (DWORD)dwPropVal, pfRecv->nSamplesPerSec, m_pVideoFilter);
	if (! fRet)
	{
		DEBUGMSG (ZONE_DP, ("%s: RxvStream->Init failed, fRet=0%u\r\n", _fx_, fRet));
		hr = DPR_CANT_INIT_RXV_STREAM;
		goto RxStreamInitError;
	}

	// WS2Qos will be called in Start to communicate stream reservations to the
	// remote endpoint using a RESV message
	//
	// We use a peak-rate allocation approach based on our target bitrates
	// Note that for the token bucket size and the maximum SDU size, we now
	// account for IP header overhead, and use the max frame fragment size
	// instead of the maximum compressed image size returned by the codec
	//
	// Some of the parameters are left unspecified because they are set
	// in the sender Tspec.


	// Computer of actual bandwidth 70 % (but it's already been divided by 100)
	dwMaxBitRate = vidChannelParams.ns_params.maxBitRate*70;
	if (dwMaxBitRate > BW_ISDN_BITS)
	{
		dwMaxFrag = 1350;
	}
	else
	{
		dwMaxFrag = 512;
	}

	InitVideoFlowspec(&m_flowspec, dwMaxBitRate, dwMaxFrag, VID_AVG_PACKET_SIZE);


	/*
	// assume no more than 32 fragments for CIF and
	// 20 fragments for SQCIF, QCIF
	//BLOAT WARNING: this could be quite a bit of memory
	// need to fix this to use a heap instead of fixed size buffers.
	
	*/

	// prepare headers for RxvStream
	m_RecvStream->GetRing (&ppPckt, &cPckt);
	m_OutMedia->RegisterData (ppPckt, cPckt);
	m_OutMedia->PrepareHeaders ();

	// Keep a weak reference to the IUnknown interface
	// We will use it to query a Stream Signal interface pointer in Start()
	m_pIUnknown = pUnknown;

	m_DPFlags |= DPFLAG_CONFIGURED_RECV;

#ifdef TEST
	LOG((LOGMSG_TIME_RECV_VIDEO_CONFIGURE,GetTickCount() - dwTicks));
#endif

	return DPR_SUCCESS;

RxStreamInitError:
	m_pVideoFilter->Close();
RecvFilterInitError:
	m_OutMedia->Close();
	if (m_pIRTPRecv)
	{
		m_pIRTPRecv->Release();
		m_pIRTPRecv = NULL;
	}
	DEBUGMSG (1, ("%s:  failed, hr=0%u\r\n", _fx_, hr));
	return hr;
}



void RecvVideoStream::UnConfigure()
{
	

#ifdef TEST
	DWORD dwTicks;

	dwTicks = GetTickCount();
#endif

	if ( (m_DPFlags & DPFLAG_CONFIGURED_RECV)) {
	
		Stop();

		// Close the RTP state if its open
		//m_Net->Close(); We should be able to do this in Disconnect()
		m_Net = NULL;
		if (m_pIRTPRecv)
		{
			m_pIRTPRecv->Release();
			m_pIRTPRecv = NULL;
		}
		m_OutMedia->Reset();
		m_OutMedia->UnprepareHeaders();
		m_OutMedia->Close();

		// Close the filter
		m_pVideoFilter->Close();

		// Close the receive stream
		m_RecvStream->Destroy();

        m_DPFlags &= ~(DPFLAG_CONFIGURED_RECV);
	}

#ifdef TEST
	LOG((LOGMSG_TIME_RECV_VIDEO_UNCONFIGURE,GetTickCount() - dwTicks));
#endif

}



// NOTE: Identical to RecvAudioStream. Move up?
HRESULT
RecvVideoStream::Start()
{
	int nRet=IFRAMES_CAPS_UNKNOWN;
	FX_ENTRY ("RecvVideoStream::Start");

	if (m_DPFlags & DPFLAG_STARTED_RECV)
		return DPR_SUCCESS;

	if ((!(m_DPFlags & DPFLAG_CONFIGURED_RECV)) || (m_pIRTPRecv==NULL))
		return DPR_NOT_CONFIGURED;
		
	ASSERT(!m_hRenderingThread);

	m_ThreadFlags &= ~(DPTFLAG_STOP_PLAY|DPTFLAG_STOP_RECV);

	m_RecvStream->SetRTP(m_pIRTPRecv);

	SetFlowSpec();

// --------------------------------------------------------------------------
//	Decide whether or not we will be making I-Frame requests for lost packets
//  This should be done for all scenarios except when we are calling
//	NetMeeting 2.x.  NM 2.x will send us periodic I-Frames.

	m_fDiscontinuity = FALSE;
	m_dwLastIFrameRequest = 0UL;
	m_ulLastSeq = UINT_MAX;


	if (m_pIUnknown)
	{
		HRESULT hr;

		if (!m_pIStreamSignal)
		{
			hr = m_pIUnknown->QueryInterface(IID_IStreamSignal, (void **)&m_pIStreamSignal);
			if (!HR_SUCCEEDED(hr))
			{
				m_pIStreamSignal = (IStreamSignal *)NULL;
				m_pIUnknown = (IUnknown *)NULL;
			}
		}

		if (m_pIStreamSignal)
		{
			nRet = GetIFrameCaps(m_pIStreamSignal);

			if (nRet == IFRAMES_CAPS_NM2)
			{
				m_pIStreamSignal->Release();
				m_pIStreamSignal = NULL;
				m_pIUnknown = NULL;
			}
		}
	}
// --------------------------------------------------------------------------

	// Start playback thread
	if (!(m_ThreadFlags & DPTFLAG_STOP_PLAY))
		m_hRenderingThread = CreateThread(NULL,0,RecvVideoStream::StartRenderingThread,this,0,&m_RenderingThId);
	// Start receive thread
	#if 0
	if (!m_pDP->m_hRecvThread) {
	    m_pDP->m_hRecvThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)&StartDPRecvThread,m_pDP,0,&m_pDP->m_RecvThId);
	    //Tell the recv Thread we've turned on
	    if (m_pDP->m_hRecvThreadChangeEvent)
	        SetEvent (m_pDP->m_hRecvThreadChangeEvent);
	}
    m_pDP->m_nReceivers++;
	#else
	m_pDP->StartReceiving(this);
	#endif
	m_DPFlags |= DPFLAG_STARTED_RECV;
	DEBUGMSG (ZONE_DP, ("%s: Rendering ThId =%x\r\n",_fx_, m_RenderingThId));
	return DPR_SUCCESS;
}


// LOOK: Identical to RecvAudioStream version.
HRESULT
RecvVideoStream::Stop()
{
	
	DWORD dwWait;
	
	FX_ENTRY ("RecvVideoStream::Stop");

	if(!(m_DPFlags &  DPFLAG_STARTED_RECV))
	{
		return DPR_SUCCESS;
	}

	m_ThreadFlags = m_ThreadFlags  |
		DPTFLAG_STOP_RECV |  DPTFLAG_STOP_PLAY ;

	m_pDP->StopReceiving(this);
	
DEBUGMSG (ZONE_VERBOSE, ("%s: m_hRenderingThread =%x\r\n",_fx_, m_hRenderingThread));

	/*
	 *	we want to wait for all the threads to exit, but we need to handle windows
	 *	messages (mostly from winsock) while waiting.
	 *	we made several attempts at that. When we wait for messages in addition
	 *	to the thread exit events, we crash in rrcm.dll, possibly because we
	 *	process a winsock message to a thread that is terminating.
	 *
	 *	needs more investigation before putting in code that handles messages
	 */

	if(m_hRenderingThread)
	{
		dwWait = WaitForSingleObject (m_hRenderingThread, INFINITE);

		DEBUGMSG (ZONE_VERBOSE, ("%s: dwWait =%d\r\n", _fx_,  dwWait));
		ASSERT(dwWait != WAIT_FAILED);


		CloseHandle(m_hRenderingThread);
		m_hRenderingThread = NULL;
	}

	// Access to the stream signal interface needs to be serialized. We could crash
	// if we release the interface here and we are still using that interface in the
	// RTP callback.
	if (m_pIStreamSignal)
	{
		EnterCriticalSection(&m_crsIStreamSignal);
		m_pIStreamSignal->Release();
		m_pIStreamSignal = (IStreamSignal *)NULL;
		LeaveCriticalSection(&m_crsIStreamSignal);
	}

    //This is per channel, but the variable is "DPFlags"
	m_DPFlags &= ~DPFLAG_STARTED_RECV;

	return DPR_SUCCESS;
}


//  IProperty::GetProperty / SetProperty
//      Properties of the MediaChannel.

STDMETHODIMP
RecvVideoStream::GetProperty(
	DWORD prop,
	PVOID pBuf,
	LPUINT pcbBuf
    )
{
	HRESULT hr = DPR_SUCCESS;
	RTP_STATS RTPStats;
	DWORD dwValue;
    DWORD_PTR dwPropVal;
	UINT len = sizeof(DWORD);	// most props are DWORDs

	if (!pBuf || *pcbBuf < len)
    {
		*pcbBuf = len;
		return DPR_INVALID_PARAMETER;
	}

	switch (prop)
    {
 #ifdef OLDSTUFF
	case PROP_NET_RECV_STATS:
		if (m_Net && *pcbBuf >= sizeof(RTP_STATS))
        {
			m_Net->GetRecvStats((RTP_STATS *)pBuf);
			*pcbBuf = sizeof(RTP_STATS);
		} else
			hr = DPR_INVALID_PROP_VAL;
			
		break;

#endif
	case PROP_DURATION:
		hr = m_OutMedia->GetProp(MC_PROP_DURATION, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_PLAY_ON:
		*(DWORD *)pBuf = ((m_ThreadFlags & DPFLAG_ENABLE_RECV)!=0);
		break;

	case PROP_PLAYBACK_DEVICE:
		*(DWORD *)pBuf = m_RenderingDevice;
		break;

	case PROP_VIDEO_BRIGHTNESS:
		hr = m_pVideoFilter->GetProperty(FM_PROP_VIDEO_BRIGHTNESS, (DWORD *)pBuf);
		break;

	case PROP_VIDEO_CONTRAST:
		hr = m_pVideoFilter->GetProperty(FM_PROP_VIDEO_CONTRAST, (DWORD *)pBuf);
		break;

	case PROP_VIDEO_SATURATION:
		hr = m_pVideoFilter->GetProperty(FM_PROP_VIDEO_SATURATION, (DWORD *)pBuf);
		break;

	case PROP_VIDEO_AUDIO_SYNC:
		*(DWORD *)pBuf = ((m_DPFlags & DPFLAG_AV_SYNC) != 0);
		break;

	case PROP_PAUSE_RECV:
		*(DWORD *)pBuf = ((m_ThreadFlags & DPTFLAG_PAUSE_RECV) != 0);
		break;
	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}


STDMETHODIMP
RecvVideoStream::SetProperty(
	DWORD prop,
	PVOID pBuf,
	UINT cbBuf
    )
{
	DWORD dw;
	HRESULT hr = S_OK;
	
	if (cbBuf < sizeof (DWORD))
		return DPR_INVALID_PARAMETER;

	switch (prop)
    {

#if 0
	case PROP_PLAY_ON:
	{
		DWORD flag = (DPFLAG_ENABLE_RECV);
		if (*(DWORD *)pBuf) {
			m_DPFlags |= flag; // set the flag
			Start();
		}
		else
		{
			m_DPFlags &= ~flag; // clear the flag
			Stop();
		}
		RETAILMSG(("NAC: %s", *(DWORD*)pBuf ? "Enabling":"Disabling"));
		//hr =  EnableStream( *(DWORD*)pBuf);
		break;
	}	
#endif
	case PROP_PLAYBACK_DEVICE:
		m_RenderingDevice = *(DWORD*)pBuf;
	//	RETAILMSG(("NAC: Setting default playback device to %d", m_RenderingDevice));
		break;


	case PROP_VIDEO_BRIGHTNESS:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_BRIGHTNESS, *(DWORD*)pBuf);
		break;

	case PROP_VIDEO_CONTRAST:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_CONTRAST, *(DWORD*)pBuf);
		break;

	case PROP_VIDEO_SATURATION:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_SATURATION, *(DWORD*)pBuf);
		break;

	case PROP_VIDEO_RESET_BRIGHTNESS:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_BRIGHTNESS, VCM_DEFAULT_BRIGHTNESS);
		break;

	case PROP_VIDEO_RESET_CONTRAST:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_CONTRAST, VCM_DEFAULT_CONTRAST);
		break;

	case PROP_VIDEO_RESET_SATURATION:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_SATURATION, VCM_DEFAULT_SATURATION);
		break;

    case PROP_VIDEO_SIZE:
		// For now, do not change anything if we already are connected
		ASSERT(0);
		//return SetVideoSize(m_pDP->m_pNac, *(DWORD*)pBuf);

    case PROP_VIDEO_AUDIO_SYNC:
		if (*(DWORD *)pBuf)
    		m_DPFlags |= DPFLAG_AV_SYNC;
		else
			m_DPFlags &= ~DPFLAG_AV_SYNC;
    	break;
	case PROP_PAUSE_RECV:
		if (*(DWORD *)pBuf)
			m_ThreadFlags |= DPTFLAG_PAUSE_RECV;
		else
			m_ThreadFlags &= ~DPTFLAG_PAUSE_RECV;
		break;

	default:
		return DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}
//---------------------------------------------------------------------
//  IVideoRender implementation and support functions



//  IVideoRender::Init
//  (DataPump::Init)
// identical to SendVideoStream::Init

STDMETHODIMP
RecvVideoStream::Init(
    DWORD_PTR dwUser,
    LPFNFRAMEREADY pfCallback
    )
{
    // Save the event away. Note that we DO allow both send and receive to
    // share an event
	m_hRenderEvent = (HANDLE)dwUser;
	// if pfCallback is NULL then dwUser is an event handle
	m_pfFrameReadyCallback = pfCallback;
		
	
	return DPR_SUCCESS;
}


//  IVideoRender::Done
// idnentical to SendVideoStream::Done
STDMETHODIMP
RecvVideoStream::Done( )
{
	m_hRenderEvent = NULL;
	m_pfFrameReadyCallback = NULL;
    return DPR_SUCCESS;
}





//  IVideoRender::GetFrame
//  (RecvVideoStream::GetFrame)
//  NOTE: subtly different from SendVideoStream implementation!

STDMETHODIMP
RecvVideoStream::GetFrame(
    FRAMECONTEXT* pfc
    )
{
	HRESULT hr;
	PVOID pData = NULL;
	UINT cbData = 0;

    // Validate parameters
    if (!pfc )
        return DPR_INVALID_PARAMETER;

    // Don't arbitrarily call out while holding this crs or you may deadlock...
    EnterCriticalSection(&m_crs);

	if ((m_DPFlags & DPFLAG_CONFIGURED_RECV) && m_pNextPacketToRender && !m_pNextPacketToRender->m_fRendering)
    {
		m_pNextPacketToRender->m_fRendering = TRUE;
		m_pNextPacketToRender->GetDevData(&pData,&cbData);
		pfc->lpData = (PUCHAR) pData;
		pfc->dwReserved = (DWORD_PTR) m_pNextPacketToRender;
		// set bmi length?
		pfc->lpbmi = (PBITMAPINFO)&m_fDevRecv.bih;
		pfc->lpClipRect = &m_cliprect;
		m_cRendering++;
		hr = S_OK;
		LOG((LOGMSG_GET_RECV_FRAME,m_pNextPacketToRender->GetIndex()));
	} else
		hr = S_FALSE; // nothing ready to render

    LeaveCriticalSection(&m_crs);

	return hr;	
}



//  IVideoRender::ReleaseFrame
//  NOTE: subtly different from SendVideoStream implementation!

STDMETHODIMP
RecvVideoStream::ReleaseFrame(
    FRAMECONTEXT* pfc
    )
{
	HRESULT hr;
	MediaPacket *pPacket;

    // Validate parameters
    if (!pfc)
        return DPR_INVALID_PARAMETER;

    // Handle a send frame
    {
        EnterCriticalSection(&m_crs);

        // Don't arbitrarily call out while holding this crs or you may deadlock...

		if ((m_DPFlags & DPFLAG_CONFIGURED_RECV) && (pPacket = (MediaPacket *)pfc->dwReserved) && pPacket->m_fRendering)
        {
			LOG((LOGMSG_RELEASE_SEND_FRAME,pPacket->GetIndex()));
			pPacket->m_fRendering = FALSE;
			pfc->dwReserved = 0;
			// if its not the current frame
			if (m_pNextPacketToRender != pPacket) {
				pPacket->Recycle();
				m_RecvStream->Release(pPacket);
			}
			m_cRendering--;
			hr = S_OK;
		}
        else
			hr = DPR_INVALID_PARAMETER;

        LeaveCriticalSection(&m_crs);
	}
		
	return hr;
}


HRESULT CALLBACK SendVideoStream::QosNotifyVideoCB(LPRESOURCEREQUESTLIST lpResourceRequestList, DWORD_PTR dwThis)
{
	HRESULT hr=NOERROR;
	LPRESOURCEREQUESTLIST prrl=lpResourceRequestList;
	int i;
	int iMaxBWUsage, iMaxCPUUsage;
	DWORD dwCPUUsage, dwBWUsage;
	int iCPUUsageId, iBWUsageId;
	int iCPUDelta, iBWDelta, deltascale;
	int iFrameRate, iMaxFrameRate, iOldFrameRate;
	UINT dwSize = sizeof(int);
	DWORD dwOverallCPUUsage;
#ifdef LOGSTATISTICS_ON
	char szDebug[256];
	HANDLE hDebugFile;
	DWORD d;
#endif
	DWORD dwEpoch;
	SendVideoStream *pThis = (SendVideoStream *)dwThis;

	FX_ENTRY("QosNotifyVideoCB");


	// Get the max for the resources.
	iMaxCPUUsage = -1L; iMaxBWUsage = -1L;
	for (i=0, iCPUUsageId = -1L, iBWUsageId = -1L; i<(int)lpResourceRequestList->cRequests; i++)
		if (lpResourceRequestList->aRequests[i].resourceID == RESOURCE_OUTGOING_BANDWIDTH)
			iBWUsageId = i;
		else if (lpResourceRequestList->aRequests[i].resourceID == RESOURCE_CPU_CYCLES)
			iCPUUsageId = i;

	// Enter critical section to allow QoS thread to read the statistics while capturing
	EnterCriticalSection(&(pThis->m_crsVidQoS));

	// Record the time of this callback call
	pThis->m_Stats.dwNewestTs = timeGetTime();

	// Only do anything if we have at least captured a frame in the previous epoch
	if ((pThis->m_Stats.dwCount) && (pThis->m_Stats.dwNewestTs > pThis->m_Stats.dwOldestTs))
	{

		// Measure the epoch
		dwEpoch = pThis->m_Stats.dwNewestTs - pThis->m_Stats.dwOldestTs;

#ifdef LOGSTATISTICS_ON
		wsprintf(szDebug, "    Epoch = %ld\r\n", dwEpoch);
		OutputDebugString(szDebug);
#endif
		// Compute the current average frame rate
		iOldFrameRate = pThis->m_Stats.dwCount * 100000 / dwEpoch;

		if (iCPUUsageId != -1L)
			iMaxCPUUsage = lpResourceRequestList->aRequests[iCPUUsageId].nUnitsMin;
		if (iBWUsageId != -1L)
			iMaxBWUsage = lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin;

		// Get general BW usage
		dwBWUsage = pThis->m_Stats.dwBits * 1000UL / dwEpoch;

		// Get general CPU usage. In order to reduce oscillations, apply low-pass filtering operation
		// We will use our own CPU usage number ONLY if the call to GetCPUUsage() fails.
		if (pThis->GetCPUUsage(&dwOverallCPUUsage))
		{
			if (pThis->m_Stats.dwSmoothedCPUUsage)
					dwCPUUsage = (pThis->m_Stats.dwSmoothedCPUUsage + dwOverallCPUUsage) >> 1;
			else
				dwCPUUsage = dwOverallCPUUsage;
		}
		else
			dwCPUUsage = (pThis->m_Stats.dwMsCap + pThis->m_Stats.dwMsComp) * 1000UL / dwEpoch;

		// Record current CPU usage
		pThis->m_Stats.dwSmoothedCPUUsage = dwCPUUsage;

#ifdef LOGSTATISTICS_ON
		hDebugFile = CreateFile("C:\\QoS.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
		SetFilePointer(hDebugFile, 0, NULL, FILE_END);
		wsprintf(szDebug, "    Overall CPU usage = %ld\r\n", dwOverallCPUUsage);
		WriteFile(hDebugFile, szDebug, strlen(szDebug), &d, NULL);
		OutputDebugString(szDebug);
		CloseHandle(hDebugFile);

		wsprintf(szDebug, "    Number of frames dwCount = %ld\r\n", pThis->m_Stats.dwCount);
		OutputDebugString(szDebug);
#endif

		// For this first implementation, the only output variable is the frame rate of the
		// video capture
#ifdef USE_NON_LINEAR_FPS_ADJUSTMENT
		if (iCPUUsageId != -1L)
		{
			if (dwCPUUsage)
			{
				iCPUDelta = (iMaxCPUUsage - (int)dwCPUUsage) * 10 / (int)dwCPUUsage;
				if (iCPUDelta >= 10)
					iCPUDelta = 9;
				else if (iCPUDelta <= -1)
					iCPUDelta = -9;
			}
			else
				iCPUDelta = 9;
		}
		else
			iCPUDelta = 0;

		if (iBWUsageId != -1L)
		{
			if (dwBWUsage)
			{
				iBWDelta = (iMaxBWUsage - (int)dwBWUsage) * 10 / (int)dwBWUsage;
				if (iBWDelta >= 10)
					iBWDelta = 9;
				else if (iBWDelta <= -1)
					iBWDelta = -9;
			}
			else
				iBWDelta = 9;
		}
		else
			iBWDelta = 0;
#else
		if (iCPUUsageId != -1L)
		{
			if (dwCPUUsage)
				iCPUDelta = (iMaxCPUUsage - (int)dwCPUUsage) * 100 / (int)dwCPUUsage;
			else
				iCPUDelta = 90;
		}
		else
			iCPUDelta = 0;

		if (iBWUsageId != -1L)
		{
			if (dwBWUsage)
				iBWDelta = (iMaxBWUsage - (int)dwBWUsage) * 100 / (int)dwBWUsage;
			else
				iBWDelta = 90;
		}
		else
			iBWDelta = 0;
#endif

		UPDATE_COUNTER(g_pctrVideoCPUuse, iCPUDelta);
		UPDATE_COUNTER(g_pctrVideoBWuse, iBWDelta);

#ifdef USE_NON_LINEAR_FPS_ADJUSTMENT
		iFrameRate = iOldFrameRate + iOldFrameRate * g_QoSMagic[iCPUDelta + 9][iBWDelta + 9] / 100;
#else
		deltascale = iCPUDelta;
		if (deltascale > iBWDelta) deltascale = iBWDelta;
		if (deltascale > 90) deltascale = 90;
		if (deltascale < -90) deltascale = -90;
		iFrameRate = iOldFrameRate + (iOldFrameRate * deltascale) / 100;
#endif
		
		// Initialize QoS structure. Only the four first fields should be zeroed.
		// The handle to the CPU performance key should not be cleared.
		ZeroMemory(&(pThis->m_Stats), 4UL * sizeof(DWORD));

		// The video should reduce its CPU and bandwidth usage quickly, but probably shouldn't
		// be allowed to increase its CPU and bandwidth usage as fast. Let's increase the
		// frame rate at half the speed it would be decreased when we are above 5fps.
		if ((iFrameRate > iOldFrameRate) && (iFrameRate > 500))
			iFrameRate -= (iFrameRate - iOldFrameRate) >> 1;

		// We should keep our requirements between a minimum that will allow us to catch up
		// quickly and the current max frame rate
		iMaxFrameRate = pThis->m_maxfps;  // max negotiated for call

		// if using a modem, then the frame rate is determined by the
		// temporal spatial tradeoff

		if (pThis->m_pTSTable)
		{
			iMaxFrameRate = min(iMaxFrameRate, pThis->m_pTSTable[pThis->m_dwCurrentTSSetting]);
		}


		if (iFrameRate > iMaxFrameRate)
			iFrameRate = iMaxFrameRate;
		if (iFrameRate < 50)               // make sure framerate is > 0 (this does not mean 50 fps; it is .50 fps)
			iFrameRate = 50;
		
		// Update the frame rate
		if (iFrameRate != iOldFrameRate)
			pThis->SetProperty(PROP_VIDEO_FRAME_RATE, &iFrameRate, sizeof(int));



		// Record the time of this call for the next callback call
		pThis->m_Stats.dwOldestTs = pThis->m_Stats.dwNewestTs;

		// Get the latest RTCP stats and update the counters.
		// we do this here because it is called periodically.
		if (pThis->m_pRTPSend)
		{
			UINT lastPacketsLost = pThis->m_RTPStats.packetsLost;
			if (g_pctrVideoSendLost &&  SUCCEEDED(pThis->m_pRTPSend->GetSendStats(&pThis->m_RTPStats)))
				UPDATE_COUNTER(g_pctrVideoSendLost, pThis->m_RTPStats.packetsLost-lastPacketsLost);
		}

		// Leave critical section
		LeaveCriticalSection(&(pThis->m_crsVidQoS));

		DEBUGMSG(ZONE_QOS, ("%s: Over the last %ld.%lds, video used %ld%% of the CPU (max allowed %ld%%) and %ld bps (max allowed %ld bps)\r\n", _fx_, dwEpoch / 1000UL, dwEpoch - (dwEpoch / 1000UL) * 1000UL, dwCPUUsage / 10UL, iMaxCPUUsage / 10UL, dwBWUsage, iMaxBWUsage));
		DEBUGMSG(ZONE_QOS, ("%s: Ajusting target frame rate from %ld.%ld fps to %ld.%ld fps\r\n", _fx_, iOldFrameRate / 100UL, iOldFrameRate - (iOldFrameRate / 100UL) * 100UL, iFrameRate / 100UL, iFrameRate - (iFrameRate / 100UL) * 100UL));

		// Set the target bitrates and frame rates on the codec
		pThis->SetTargetRates(iFrameRate, iMaxBWUsage);

#ifdef LOGSTATISTICS_ON
		// How are we doing?
		if (iCPUUsageId != -1L)
		{
			if (iCPUDelta > 0)
				wsprintf(szDebug, "Max CPU Usage: %ld, Current CPU Usage: %ld, Increase CPU Usage by: %li, Old Frame Rate: %ld, New Frame Rate: %ld\r\n", lpResourceRequestList->aRequests[iCPUUsageId].nUnitsMin, dwCPUUsage, iCPUDelta, iOldFrameRate, iFrameRate);
			else
				wsprintf(szDebug, "Max CPU Usage: %ld, Current CPU Usage: %ld, Decrese CPU Usage by: %li, Old Frame Rate: %ld, New Frame Rate: %ld\r\n", lpResourceRequestList->aRequests[iCPUUsageId].nUnitsMin, dwCPUUsage, iCPUDelta, iOldFrameRate, iFrameRate);
			hDebugFile = CreateFile("C:\\QoS.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
			SetFilePointer(hDebugFile, 0, NULL, FILE_END);
			WriteFile(hDebugFile, szDebug, strlen(szDebug), &d, NULL);
			CloseHandle(hDebugFile);
			OutputDebugString(szDebug);
		}

		if (iBWUsageId != -1L)
		{
			if (iBWDelta > 0)
				wsprintf(szDebug, "Max BW Usage: %ld, Current BW Usage: %ld, Increase BW Usage by: %li\r\n", lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin, dwBWUsage, iBWDelta);
			else
				wsprintf(szDebug, "Max BW Usage: %ld, Current BW Usage: %ld, Decrease BW Usage by: %li\r\n", lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin, dwBWUsage, iBWDelta);
			hDebugFile = CreateFile("C:\\QoS.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
			SetFilePointer(hDebugFile, 0, NULL, FILE_END);
			WriteFile(hDebugFile, szDebug, strlen(szDebug), &d, NULL);
			CloseHandle(hDebugFile);
			OutputDebugString(szDebug);
		}
#endif
	}
	else
	{
		// Leave critical section
		LeaveCriticalSection(&(pThis->m_crsVidQoS));

#ifdef LOGSTATISTICS_ON
		hDebugFile = CreateFile("C:\\QoS.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
		SetFilePointer(hDebugFile, 0, NULL, FILE_END);
		wsprintf(szDebug, "Not enough data captured -> Leave without any change\r\n");
		WriteFile(hDebugFile, szDebug, strlen(szDebug), &d, NULL);
		CloseHandle(hDebugFile);
		OutputDebugString(szDebug);
#endif
	}

	return hr;
}



//  SortOrder
//      Helper function to search for the specific format type and set its sort
//      order to the desired number
BOOL
SortOrder(
	IAppVidCap *pavc,
    BASIC_VIDCAP_INFO* pvidcaps,
    DWORD dwcFormats,
    DWORD dwFlags,
    WORD wDesiredSortOrder,
	int nNumFormats
    )
{
    int i, j;
	int nNumSizes = 0;
	int *aFrameSizes = (int *)NULL;
	int *aMinFrameSizes = (int *)NULL;
	int iMaxPos;
	WORD wTempPos, wMaxSortIndex;

	// Scale sort value
	wDesiredSortOrder *= (WORD)nNumFormats;

	// Local buffer of sizes that match dwFlags
    if (!(aFrameSizes = (int *)MEMALLOC(nNumFormats * sizeof (int))))
        goto out;

    // Look through all the formats until we find the ones we want
	// Save the position of these entries
    for (i=0; i<(int)dwcFormats; i++)
        if (SIZE_TO_FLAG(pvidcaps[i].enumVideoSize) == dwFlags)
			aFrameSizes[nNumSizes++] = i;

	// Now order those entries from highest to lowest sort index
	for (i=0; i<nNumSizes; i++)
	{
		for (iMaxPos = -1L, wMaxSortIndex=0UL, j=i; j<nNumSizes; j++)
		{
			if (pvidcaps[aFrameSizes[j]].wSortIndex > wMaxSortIndex)
			{
				wMaxSortIndex = pvidcaps[aFrameSizes[j]].wSortIndex;
				iMaxPos = j;
			}
		}
		if (iMaxPos != -1L)
		{
			wTempPos = (WORD)aFrameSizes[i];
			aFrameSizes[i] = aFrameSizes[iMaxPos];
			aFrameSizes[iMaxPos] = wTempPos;
		}
	}

	// Change the sort index of the sorted entries
	for (; nNumSizes--;)
		pvidcaps[aFrameSizes[nNumSizes]].wSortIndex = wDesiredSortOrder++;

	// Release memory
	MEMFREE(aFrameSizes);

	return TRUE;

out:
	return FALSE;
}

// LOOK: this is identical to the RecvAudioStream implementation
HRESULT
RecvVideoStream::GetCurrentPlayNTPTime(NTP_TS *pNtpTime)
{
	DWORD rtpTime;
#ifdef OLDSTUFF
	if ((m_DPFlags & DPFLAG_STARTED_RECV) && m_fReceiving) {
		if (m_Net->RTPtoNTP(m_PlaybackTimestamp,pNtpTime))
			return S_OK;
	}
#endif
	return 0xff;	// return proper error
		
}

BOOL RecvVideoStream::IsEmpty() {
	return m_RecvStream->IsEmpty();
}

/*
	Called by the recv thread to setup the stream for receiving.
	Call RTP object to post the initial recv buffer(s).
*/
// NOTE: identical to audio version except for choice of number of packet buffers
HRESULT
RecvVideoStream::StartRecv(HWND hWnd)
{
	HRESULT hr = S_OK;
	DWORD dwPropVal = 0;
	UINT numPackets;
	if ((!(m_ThreadFlags & DPTFLAG_STOP_RECV) ) && (m_DPFlags  & DPFLAG_CONFIGURED_RECV))
	{
		numPackets = m_dwSrcSize > 10000 ? MAX_VIDEO_FRAGMENTS : MAX_QCIF_VIDEO_FRAGMENTS;	

		hr = m_pIRTPRecv->SetRecvNotification(&RTPRecvCallback, (DWORD_PTR)this, numPackets);
			
		
	}
	return hr;
}


// NOTE: identical to audio version
HRESULT
RecvVideoStream::StopRecv()
{
	// Free any RTP buffers that we're holding on to
	m_RecvStream->ReleaseNetBuffers();
	// dont recv on this stream
	m_pIRTPRecv->CancelRecvNotification();

	return S_OK;		
}


HRESULT RecvVideoStream::RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark)
{
	HRESULT hr;
	DWORD_PTR dwPropVal;
	BOOL fSkippedAFrame;
	BOOL fReceivedKeyframe;

	FX_ENTRY("RecvVideoStream::RTPCallback");

	// if we are paused, reject the packet
	if (m_ThreadFlags & DPTFLAG_PAUSE_RECV)
	{
		return E_FAIL;
	}

	// PutNextNetIn will return DPR_SUCESS to indicate a new frame
	// S_FALSE if success, but no new frame
	// error otherwise
	// It always takes care of freeing the RTP buffers
	hr = m_RecvStream->PutNextNetIn(pWsaBuf, timestamp, seq, fMark, &fSkippedAFrame, &fReceivedKeyframe);

	if (m_pIUnknown)
	{
		// Check out the sequence number
		// If there is a gap between the new sequence number and the last
		// one, a frame got lost. Generate an I-Frame request then, but no more
		// often than one every 15 seconds. How should we go about NM2.0? Other
		// clients that don't support I-Frame requests.
		//
		// Is there a discontinuity in sequence numbers that was detected
		// in the past but not handled because an I-Frame request had alreay
		// been sent less than 15s ago? Is there a new discontinuity?
		if (FAILED(hr) || fSkippedAFrame || m_fDiscontinuity || ((seq > 0) && (m_ulLastSeq != UINT_MAX) && ((seq - 1) > m_ulLastSeq)))
		{
			DWORD dwNow = GetTickCount();

			// Was the last time we issued an I-Frame request more than 15s ago?
			if ((dwNow > m_dwLastIFrameRequest) && ((dwNow - m_dwLastIFrameRequest) > MIN_IFRAME_REQUEST_INTERVAL))
			{
				DEBUGMSG (ZONE_IFRAME, ("%s: Loss detected - Sending I-Frame request...\r\n", _fx_));

				m_dwLastIFrameRequest = dwNow;
				m_fDiscontinuity = FALSE;

				// Access to the stream signal interface needs to be serialized. We could crash
				// if we used the interface here while Stop() is releasing it.
				EnterCriticalSection(&m_crsIStreamSignal);
				if (m_pIStreamSignal)
					m_pIStreamSignal->PictureUpdateRequest();
				LeaveCriticalSection(&m_crsIStreamSignal);
			}
			else
			{
				if (!fReceivedKeyframe)
				{
					DEBUGMSG (ZONE_IFRAME, ("%s: Loss detected but too soon to send I-Frame request. Wait %ld ms.\r\n", _fx_, MIN_IFRAME_REQUEST_INTERVAL - (dwNow - m_dwLastIFrameRequest)));
					m_fDiscontinuity = TRUE;
				}
				else
				{
					DEBUGMSG (ZONE_IFRAME, ("%s: Received a keyframe - resetting packet loss detector\r\n", _fx_));
					m_fDiscontinuity = FALSE;
				}
			}
		}

		m_ulLastSeq = seq;
	}

	if (hr == DPR_SUCCESS)
	{
		m_OutMedia->GetProp (MC_PROP_EVENT_HANDLE, &dwPropVal);
		if (dwPropVal)
		{
			SetEvent( (HANDLE) dwPropVal);
		}
	}
	else if (FAILED(hr))
	{
		DEBUGMSG(ZONE_DP,("RVStream::PutNextNetIn (ts=%d,seq=%d,fMark=%d) failed with 0x%lX\r\n",timestamp,seq,fMark,hr));
	}

	return S_OK;
}

#define TOTAL_BYTES		8192
#define BYTE_INCREMENT	1024

/****************************************************************************
 * @doc EXTERNAL QOSFUNC
 *
 * @func void | StartCPUUsageCollection | This function does all necessary
 * initialization for CPU usage data collection.
 *
 * @rdesc Although this function doesn't ever fail, m_Stats.hPerfKey is set to a
 *   valid HKEY value if initialization occured correctly, and NULL otherwise.
 *
 * @comm This functions executes two different code paths: one for NT and one
 *   for Win95-98.
 *
 * @devnote MSDN references:
 *   Microsoft Knowledge Base, Article ID Q174631
 *   "HOWTO: Access the Performance Registry Under Windows 95"
 *
 *   Microsoft Knowledge Base, Article ID Q107728
 *   "Retrieving Counter Data from the Registry"
 *
 *   Microsoft Knowledge Base, Article ID Q178887
 *   "INFO: Troubleshooting Performance Registry Access Violations"
 *
 *   Also, used section "Platform SDK\Windows Base Services\Windows NT Features\Performance Data Helper"
 ***************************************************************************/
void SendVideoStream::StartCPUUsageCollection(void)
{
	PPERF_DATA_BLOCK pPerfDataBlock;
	PPERF_OBJECT_TYPE pPerfObjectType;
	PPERF_COUNTER_DEFINITION pPerfCounterDefinition;
	PPERF_INSTANCE_DEFINITION pPerfInstanceDefinition;
	PPERF_COUNTER_BLOCK pPerfCounterBlock;
	OSVERSIONINFO osvInfo = {0};
	DWORD cbCounterData;
	DWORD cbTryCounterData;
	DWORD dwType;
	HANDLE hPerfData;
	char *pszData;
	char *pszIndex;
	char szProcessorIndex[16];
	long lRet;

	FX_ENTRY("SendVideoStream::StartCPUUsageCollection");

	// Are we on NT or Win95/98 ?
	osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvInfo);

	if (m_Stats.fWinNT = (BOOL)(osvInfo.dwPlatformId == VER_PLATFORM_WIN32_NT))
	{
		// Enable the collection of CPU performance data on Win NT

		// Open the registry key that contains the performance counter indices and names.
		// 009 is the U.S. English language id. In a non-English version of Windows NT,
		// performance counters are stored both in the native language of the system and
		// in English.
		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009", NULL, KEY_READ, &m_Stats.hPerfKey) != ERROR_SUCCESS)
			goto MyError0;
		else
		{
			// Get all the counter indices and names.

			// Read the performance data from the registry. The size of that data may change
			// between each call to the registry. We first get the current size of the buffer,
			// allocate it, and try to read from the registry into it. If there already isn't
			// enough room in the buffer, we realloc() it until we manage to read all the data.
			if (RegQueryValueEx(m_Stats.hPerfKey, "Counters", NULL, &dwType, NULL, &cbCounterData) != ERROR_SUCCESS)
				cbCounterData = TOTAL_BYTES;

			// Allocate buffer for counter indices and names
			if (!(m_Stats.NtCPUUsage.hPerfData = (PBYTE)LocalAlloc (LMEM_MOVEABLE, cbCounterData)))
			{
				m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)NULL;
				RegCloseKey(m_Stats.hPerfKey);
				goto MyError0;
			}
			else
			{
				m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)LocalLock(m_Stats.NtCPUUsage.hPerfData);

				cbTryCounterData = cbCounterData;
				while((lRet = RegQueryValueEx(m_Stats.hPerfKey, "Counters", NULL, NULL, m_Stats.NtCPUUsage.pbyPerfData, &cbTryCounterData)) == ERROR_MORE_DATA)
				{
					cbCounterData += BYTE_INCREMENT;
					LocalUnlock(m_Stats.NtCPUUsage.hPerfData);
					hPerfData = LocalReAlloc(m_Stats.NtCPUUsage.hPerfData, cbCounterData, LMEM_MOVEABLE);
					if (!hPerfData)
					{
                        RegCloseKey(m_Stats.hPerfKey);
						goto MyError1;
					}
					m_Stats.NtCPUUsage.hPerfData = hPerfData;
					m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)LocalLock(hPerfData);
					cbTryCounterData = cbCounterData;
				}

				// We don't need that key anymore
				RegCloseKey(m_Stats.hPerfKey);

				if (lRet != ERROR_SUCCESS)
					goto MyError1;
				else
				{
					// The data is stored as MULTI_SZ strings. This data type consists
					// of a list of strings, each terminated with NULL. The last string
					// is followed by an additional NULL. The strings are listed in
					// pairs. The first string of each pair is the string of the index,
					// and the second string is the actual name of the index. The Counter
					// data uses only even-numbered indexes. For example, the Counter
					// data contains the following object and counter name strings.
					// Examples:
					// 2    System
					// 4    Memory
					// 6    % Processor Time
					//
					// Look for the "% Processor Time" counter
					pszData = (char *)m_Stats.NtCPUUsage.pbyPerfData;
					pszIndex = (char *)m_Stats.NtCPUUsage.pbyPerfData;

					while (*pszData && lstrcmpi(pszData, "% Processor Time"))
					{
						pszIndex = pszData;
						pszData += lstrlen(pszData) + 1;
					}

					if (!pszData)
					{
						// Couldn't find "% Processor Time" counter!!!
						goto MyError1;
					}
					else
					{
						m_Stats.NtCPUUsage.dwPercentProcessorIndex = atol(pszIndex);

						// Look for the "Processor" object
						pszIndex = pszData = (char *)m_Stats.NtCPUUsage.pbyPerfData;

						while (*pszData && lstrcmpi(pszData, "Processor"))
						{
							pszIndex = pszData;
							pszData += lstrlen(pszData) + 1;
						}

						if (!pszData)
						{
							// Couldn't find "Processor" counter!!!
							goto MyError1;
						}
						else
						{
							m_Stats.NtCPUUsage.dwProcessorIndex = atol(pszIndex);
							CopyMemory(szProcessorIndex, pszIndex, lstrlen(pszIndex));

							// Read the PERF_DATA_BLOCK header structure. It describes the system
							// and the performance data. The PERF_DATA_BLOCK structure is followed
							// by a list of object information blocks (one per object). We use the
							// counter index to retrieve object information.

							// Under some cicumstances (cf. Q178887 for details) the RegQueryValueEx
							// function may cause an Access Violation because of a buggy performance
							// extension DLL such as SQL's.
							__try
							{
								m_Stats.NtCPUUsage.cbPerfData = cbCounterData;
								while((lRet = RegQueryValueEx(HKEY_PERFORMANCE_DATA, szProcessorIndex, NULL, NULL, m_Stats.NtCPUUsage.pbyPerfData, &cbCounterData)) == ERROR_MORE_DATA)
								{
									m_Stats.NtCPUUsage.cbPerfData += BYTE_INCREMENT;
									LocalUnlock(m_Stats.NtCPUUsage.hPerfData);
									hPerfData = LocalReAlloc(m_Stats.NtCPUUsage.hPerfData, m_Stats.NtCPUUsage.cbPerfData, LMEM_MOVEABLE);
									if (!hPerfData)
										goto MyError1;
									m_Stats.NtCPUUsage.hPerfData = hPerfData;
									m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)LocalLock(hPerfData);
									cbCounterData = m_Stats.NtCPUUsage.cbPerfData;
								}
							}
							__except(EXCEPTION_EXECUTE_HANDLER)
							{
								ERRORMESSAGE(("%s: Performance Registry Access Violation -> don't use perf counters for CPU measurements\r\n", _fx_));
								goto MyError1;
							}

							if (lRet != ERROR_SUCCESS)
								goto MyError1;
							else
							{
								// Each object information block contains a PERF_OBJECT_TYPE structure,
								// which describes the performance data for the object. Look for the one
								// that applies to CPU usage based on its index value.
								pPerfDataBlock = (PPERF_DATA_BLOCK)m_Stats.NtCPUUsage.pbyPerfData;
								pPerfObjectType = (PPERF_OBJECT_TYPE)(m_Stats.NtCPUUsage.pbyPerfData + pPerfDataBlock->HeaderLength);
								for (int i = 0; i < (int)pPerfDataBlock->NumObjectTypes; i++)
								{
									if (pPerfObjectType->ObjectNameTitleIndex == m_Stats.NtCPUUsage.dwProcessorIndex)
									{
										// The PERF_OBJECT_TYPE structure is followed by a list of PERF_COUNTER_DEFINITION
										// structures, one for each counter defined for the object. The list of PERF_COUNTER_DEFINITION
										// structures is followed by a list of instance information blocks (one for each instance).
										//
										// Each instance information block contains a PERF_INSTANCE_DEFINITION structure and
										// a PERF_COUNTER_BLOCK structure, followed by the data for each counter.
										//
										// Look for the counter defined for % processor time.
										pPerfCounterDefinition = (PPERF_COUNTER_DEFINITION)((PBYTE)pPerfObjectType + pPerfObjectType->HeaderLength);
										for (int j = 0; j < (int)pPerfObjectType->NumCounters; j++)
										{
											if (pPerfCounterDefinition->CounterNameTitleIndex == m_Stats.NtCPUUsage.dwPercentProcessorIndex)
											{
												// Note: looking at the CounterType filed of the PERF_COUNTER_DEFINITION
												// structure shows that the '% Processor Time' counter has the following properties:
												//   The counter data is a large integer (PERF_SIZE_LARGE set)
												//   The counter data is an increasing numeric value (PERF_TYPE_COUNTER set)
												//   The counter value should be divided by the elapsed time (PERF_COUNTER_RATE set)
												//   The time base units of the 100-nanosecond timer should be used as the base (PERF_TIMER_100NS set)
												//   The difference between the previous counter value and the current counter value is computed before proceeding (PERF_DELTA_BASE set)
												//   The display suffix is '%' (PERF_DISPLAY_PERCENT set)

												// Save the number of object instances for the CPU counter, as well as the
												// starting time.
												m_Stats.NtCPUUsage.dwNumProcessors = pPerfObjectType->NumInstances;
												if (!(m_Stats.NtCPUUsage.pllCounterValue = (PLONGLONG)LocalAlloc(LMEM_FIXED, m_Stats.NtCPUUsage.dwNumProcessors * sizeof(LONGLONG))))
													goto MyError1;
												m_Stats.NtCPUUsage.llPerfTime100nSec = *(PLONGLONG)&pPerfDataBlock->PerfTime100nSec;

												pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)((PBYTE)pPerfObjectType + pPerfObjectType->DefinitionLength);
												for (int k = 0; k < pPerfObjectType->NumInstances; k++)
												{
													// Get a pointer to the PERF_COUNTER_BLOCK
													pPerfCounterBlock = (PPERF_COUNTER_BLOCK)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength);

													// This last offset steps us over any other counters to the one we need
													m_Stats.NtCPUUsage.pllCounterValue[k] = *(PLONGLONG)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength + pPerfCounterDefinition->CounterOffset);

													// Get to the next instance information block
													pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength + pPerfCounterBlock->ByteLength);
												}

												// We're done!
												return;
											}
											else
												pPerfCounterDefinition = (PPERF_COUNTER_DEFINITION)((PBYTE)pPerfCounterDefinition + pPerfCounterDefinition->ByteLength);
										}
										break;
									}
									else
										pPerfObjectType = (PPERF_OBJECT_TYPE)((PBYTE)pPerfObjectType + pPerfObjectType->TotalByteLength);
								}

								// If we get here, we haven't found the counters we were looking for
								goto MyError2;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		// Enable the collection of CPU performance data on Win 95-98 by starting the kernel stat server
		if (RegOpenKeyEx(HKEY_DYN_DATA, "PerfStats\\StartSrv", NULL, KEY_READ, &m_Stats.hPerfKey) != ERROR_SUCCESS)
			m_Stats.hPerfKey = (HKEY)NULL;
		else
		{
			DWORD cbData = sizeof(DWORD);
			DWORD dwData;

			if (RegQueryValueEx(m_Stats.hPerfKey, "KERNEL", NULL, &dwType, (LPBYTE)&dwData, &cbData) != ERROR_SUCCESS)
			{
				RegCloseKey(m_Stats.hPerfKey);
				m_Stats.hPerfKey = (HKEY)NULL;
			}
			else
			{
				RegCloseKey(m_Stats.hPerfKey);

				// The kernel stat server is now started. Now start the CPUUsage data collection on the kernel stat server.
				if (RegOpenKeyEx(HKEY_DYN_DATA, "PerfStats\\StartStat", NULL, KEY_READ, &m_Stats.hPerfKey) != ERROR_SUCCESS)
					m_Stats.hPerfKey = (HKEY)NULL;
				else
				{
					if (RegQueryValueEx(m_Stats.hPerfKey, "KERNEL\\CPUUsage", NULL, &dwType, (LPBYTE)&dwData, &cbData) != ERROR_SUCCESS)
					{
						RegCloseKey(m_Stats.hPerfKey);
						m_Stats.hPerfKey = (HKEY)NULL;
					}
					else
					{
						RegCloseKey(m_Stats.hPerfKey);

						// The data and stat servers are now started. Let's get ready to collect actual data.
						if (RegOpenKeyEx(HKEY_DYN_DATA, "PerfStats\\StatData", NULL, KEY_READ, &m_Stats.hPerfKey) != ERROR_SUCCESS)
							m_Stats.hPerfKey = (HKEY)NULL;
					}
				}
			}
		}
	}

	return;

MyError2:
	if (m_Stats.NtCPUUsage.pllCounterValue)
		LocalFree(m_Stats.NtCPUUsage.pllCounterValue);
	m_Stats.NtCPUUsage.pllCounterValue = (PLONGLONG)NULL;
MyError1:
	if (m_Stats.NtCPUUsage.hPerfData)
	{
		LocalUnlock(m_Stats.NtCPUUsage.hPerfData);
		LocalFree(m_Stats.NtCPUUsage.hPerfData);
	}
	m_Stats.NtCPUUsage.hPerfData = (HANDLE)NULL;
	m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)NULL;
MyError0:
	m_Stats.hPerfKey = (HKEY)NULL;
	
}

/****************************************************************************
 * @doc EXTERNAL QOSFUNC
 *
 * @func void | StopCPUUsageCollection | This function does all necessary
 * CPU usage data collection cleanup.
 *
 * @comm This function executes two different code paths: one for NT and one
 *   for Win95-98.
 *
 * @devnote MSDN references:
 *   Microsoft Knowledge Base, Article ID Q174631
 *   "HOWTO: Access the Performance Registry Under Windows 95"
 *
 *   Microsoft Knowledge Base, Article ID Q107728
 *   "Retrieving Counter Data from the Registry"
 *
 *   Also, used section "Platform SDK\Windows Base Services\Windows NT Features\Performance Data Helper"
 ***************************************************************************/
void SendVideoStream::StopCPUUsageCollection(void)
{
	DWORD dwType;
	DWORD cbData;

	if (m_Stats.fWinNT)
	{
		if (m_Stats.NtCPUUsage.hPerfData)
		{
			LocalUnlock(m_Stats.NtCPUUsage.hPerfData);
			LocalFree(m_Stats.NtCPUUsage.hPerfData);
		}
		m_Stats.NtCPUUsage.hPerfData = (HANDLE)NULL;
		m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)NULL;
		if (m_Stats.NtCPUUsage.pllCounterValue)
			LocalFree(m_Stats.NtCPUUsage.pllCounterValue);
		m_Stats.NtCPUUsage.pllCounterValue = (PLONGLONG)NULL;
	}
	else
	{
		if (m_Stats.hPerfKey)
		{
			// Close the data collection key
			RegCloseKey(m_Stats.hPerfKey);

			// Stop the CPUUsage data collection on the kernel stat server
			if (RegOpenKeyEx(HKEY_DYN_DATA, "PerfStats\\StopStat", 0, KEY_READ, &m_Stats.hPerfKey) == ERROR_SUCCESS)
			{
				RegQueryValueEx(m_Stats.hPerfKey, "KERNEL\\CPUUsage", NULL, &dwType, NULL, &cbData);
				RegCloseKey(m_Stats.hPerfKey);
			}

			// Stop the kernel stat server
			if (RegOpenKeyEx(HKEY_DYN_DATA, "PerfStats\\StopSrv", 0, KEY_READ, &m_Stats.hPerfKey) == ERROR_SUCCESS)
			{
				RegQueryValueEx(m_Stats.hPerfKey, "KERNEL", NULL, &dwType, NULL, &cbData);
				RegCloseKey(m_Stats.hPerfKey);
			}

			m_Stats.hPerfKey = (HKEY)NULL;
		}
	}
}

/****************************************************************************
 * @doc EXTERNAL QOSFUNC
 *
 * @func void | GetCPUUsage | This function does all necessary
 * initialization for CPU usage data collection.
 *
 * @parm PDWORD | [OUT] pdwOverallCPUUsage | Specifies a pointer to a DWORD to
 *   receive the current CPU usage.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 *
 * @comm This functions executes two different code paths: one for NT and one
 *   for Win95-98. Note that we collect data on all CPUs on NT MP machines.
 *
 * @devnote MSDN references:
 *   Microsoft Knowledge Base, Article ID Q174631
 *   "HOWTO: Access the Performance Registry Under Windows 95"
 *
 *   Microsoft Knowledge Base, Article ID Q107728
 *   "Retrieving Counter Data from the Registry"
 *
 *   Also, used section "Platform SDK\Windows Base Services\Windows NT Features\Performance Data Helper"
 ***************************************************************************/
BOOL SendVideoStream::GetCPUUsage(PDWORD pdwOverallCPUUsage)
{

	PPERF_DATA_BLOCK pPerfDataBlock;
	PPERF_OBJECT_TYPE pPerfObjectType;
	PPERF_COUNTER_DEFINITION pPerfCounterDefinition;
	PPERF_INSTANCE_DEFINITION pPerfInstanceDefinition;
	PPERF_COUNTER_BLOCK pPerfCounterBlock;
	DWORD dwType;
	DWORD cbData = sizeof(DWORD);
	DWORD cbTryCounterData;
	HANDLE hPerfData;
	LONGLONG llDeltaPerfTime100nSec;
	LONGLONG llDeltaCPUUsage = (LONGLONG)NULL;
	char szProcessorIndex[16];
	long lRet;

	FX_ENTRY("SendVideoStream::GetCPUUsage");

	// We use the handle to the perf key as a way to figure out if we have been initialized correctly
	if (m_Stats.hPerfKey && pdwOverallCPUUsage)
	{
		// Initialize result value
		*pdwOverallCPUUsage = 0UL;

		if (m_Stats.fWinNT && m_Stats.NtCPUUsage.pbyPerfData)
		{
			// Make a string out of the processor object index.
			_ltoa(m_Stats.NtCPUUsage.dwProcessorIndex, szProcessorIndex, 10);

			// Under some cicumstances (cf. Q178887 for details) the RegQueryValueEx
			// function may cause an Access Violation because of a buggy performance
			// extension DLL such as SQL's.
			__try
			{
				// Read the performance data. Its size may change between each 'registry' access.
				cbTryCounterData = m_Stats.NtCPUUsage.cbPerfData;
				while((lRet = RegQueryValueEx(HKEY_PERFORMANCE_DATA, szProcessorIndex, NULL, &dwType, m_Stats.NtCPUUsage.pbyPerfData, &cbTryCounterData)) == ERROR_MORE_DATA)
				{
					m_Stats.NtCPUUsage.cbPerfData += BYTE_INCREMENT;
					LocalUnlock(m_Stats.NtCPUUsage.hPerfData);
					hPerfData = LocalReAlloc(m_Stats.NtCPUUsage.hPerfData, m_Stats.NtCPUUsage.cbPerfData, LMEM_MOVEABLE);
					if (!hPerfData)
						goto MyError;
					m_Stats.NtCPUUsage.hPerfData = hPerfData;
					m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)LocalLock(hPerfData);
					cbTryCounterData = m_Stats.NtCPUUsage.cbPerfData;
				}
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				ERRORMESSAGE(("%s: Performance Registry Access Violation -> don't use perf counters for CPU measurements\r\n", _fx_));
				goto MyError;
			}

			if (lRet != ERROR_SUCCESS)
				goto MyError;
			else
			{
				// Read the PERF_DATA_BLOCK header structure. It describes the system
				// and the performance data. The PERF_DATA_BLOCK structure is followed
				// by a list of object information blocks (one per object). We use the
				// counter index to retrieve object information.
				//
				// Each object information block contains a PERF_OBJECT_TYPE structure,
				// which describes the performance data for the object. Look for the one
				// that applies to CPU usage based on its index value.
				pPerfDataBlock = (PPERF_DATA_BLOCK)m_Stats.NtCPUUsage.pbyPerfData;
				pPerfObjectType = (PPERF_OBJECT_TYPE)(m_Stats.NtCPUUsage.pbyPerfData + pPerfDataBlock->HeaderLength);
				for (int i = 0; i < (int)pPerfDataBlock->NumObjectTypes; i++)
				{
					if (pPerfObjectType->ObjectNameTitleIndex == m_Stats.NtCPUUsage.dwProcessorIndex)
					{
						// The PERF_OBJECT_TYPE structure is followed by a list of PERF_COUNTER_DEFINITION
						// structures, one for each counter defined for the object. The list of PERF_COUNTER_DEFINITION
						// structures is followed by a list of instance information blocks (one for each instance).
						//
						// Each instance information block contains a PERF_INSTANCE_DEFINITION structure and
						// a PERF_COUNTER_BLOCK structure, followed by the data for each counter.
						//
						// Look for the counter defined for % processor time.
						pPerfCounterDefinition = (PPERF_COUNTER_DEFINITION)((PBYTE)pPerfObjectType + pPerfObjectType->HeaderLength);
						for (int j = 0; j < (int)pPerfObjectType->NumCounters; j++)
						{
							if (pPerfCounterDefinition->CounterNameTitleIndex == m_Stats.NtCPUUsage.dwPercentProcessorIndex)
							{
								// Measure elapsed time
								llDeltaPerfTime100nSec = *(PLONGLONG)&pPerfDataBlock->PerfTime100nSec - m_Stats.NtCPUUsage.llPerfTime100nSec;

								// Save the timestamp for the next round
								m_Stats.NtCPUUsage.llPerfTime100nSec = *(PLONGLONG)&pPerfDataBlock->PerfTime100nSec;

								pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)((PBYTE)pPerfObjectType + pPerfObjectType->DefinitionLength);
								for (int k = 0; k < (int)pPerfObjectType->NumInstances && k < (int)m_Stats.NtCPUUsage.dwNumProcessors; k++)
								{
									// Get a pointer to the PERF_COUNTER_BLOCK
									pPerfCounterBlock = (PPERF_COUNTER_BLOCK)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength);

									// Get the CPU usage
									llDeltaCPUUsage += *(PLONGLONG)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength + pPerfCounterDefinition->CounterOffset) - m_Stats.NtCPUUsage.pllCounterValue[k];

									// Save the value for the next round
									m_Stats.NtCPUUsage.pllCounterValue[k] = *(PLONGLONG)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength + pPerfCounterDefinition->CounterOffset);

									// Go to the next instance information block
									pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength + pPerfCounterBlock->ByteLength);
								}

								// Do a bit of checking on the return value and change its unit to match QoS unit
								if ((llDeltaPerfTime100nSec != (LONGLONG)0) && pPerfObjectType->NumInstances)
									if ((*pdwOverallCPUUsage = (DWORD)((LONGLONG)1000 - (LONGLONG)1000 * llDeltaCPUUsage / llDeltaPerfTime100nSec / (LONGLONG)pPerfObjectType->NumInstances)) > 1000UL)
									{
										*pdwOverallCPUUsage = 0UL;
										return FALSE;
									}

								// We're done!
								return TRUE;
							}
							else
								pPerfCounterDefinition = (PPERF_COUNTER_DEFINITION)((PBYTE)pPerfCounterDefinition + pPerfCounterDefinition->ByteLength);
						}
						break;
					}
					else
						pPerfObjectType = (PPERF_OBJECT_TYPE)((PBYTE)pPerfObjectType + pPerfObjectType->TotalByteLength);
				}

				// If we get here, we haven't found the counters we were looking for
				goto MyError;
			}
		}
		else
		{
			// Do a bit of checking on the return value and change its unit to match QoS unit.
			if ((RegQueryValueEx(m_Stats.hPerfKey, "KERNEL\\CPUUsage", NULL, &dwType, (LPBYTE)pdwOverallCPUUsage, &cbData) == ERROR_SUCCESS) && (*pdwOverallCPUUsage > 0) && (*pdwOverallCPUUsage <= 100))
			{
				*pdwOverallCPUUsage *= 10UL;
				return TRUE;
			}
			else
			{
				*pdwOverallCPUUsage = 0UL;
				return FALSE;
			}
		}
	}
	
	return FALSE;

MyError:
	if (m_Stats.NtCPUUsage.pllCounterValue)
		LocalFree(m_Stats.NtCPUUsage.pllCounterValue);
	m_Stats.NtCPUUsage.pllCounterValue = (PLONGLONG)NULL;
	if (m_Stats.NtCPUUsage.hPerfData)
	{
		LocalUnlock(m_Stats.NtCPUUsage.hPerfData);
		LocalFree(m_Stats.NtCPUUsage.hPerfData);
	}
	m_Stats.NtCPUUsage.hPerfData = (HANDLE)NULL;
	m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)NULL;
	m_Stats.hPerfKey = (HKEY)NULL;

	return FALSE;
}

BOOL SendVideoStream::SetTargetRates(DWORD dwTargetFrameRate, DWORD dwTargetBitrate)
{
	MMRESULT mmr;
	ASSERT(m_pVideoFilter);

	mmr = m_pVideoFilter->SetTargetRates(dwTargetFrameRate, dwTargetBitrate >> 3);
	return (mmr == MMSYSERR_NOERROR);
}


// dwFlags must be one of the following:
// CAPTURE_DIALOG_FORMAT
// CAPTURE_DIALOG_SOURCE
HRESULT __stdcall SendVideoStream::ShowDeviceDialog(DWORD dwFlags)
{
	DWORD dwQueryFlags = 0;
    DWORD_PTR dwPropVal;
	HRESULT hr=DPR_INVALID_PARAMETER;

	// the device must be "open" for us to display the dialog box
	if (!(m_DPFlags & DPFLAG_CONFIGURED_SEND))
		return DPR_NOT_CONFIGURED;

	((VideoInControl*)m_InMedia)->GetProp(MC_PROP_VFW_DIALOGS, &dwPropVal);
    dwQueryFlags = (DWORD)dwPropVal;

	if ((dwQueryFlags & CAPTURE_DIALOG_SOURCE) && (dwFlags & CAPTURE_DIALOG_SOURCE))
	{
		hr = ((VideoInControl *)m_InMedia)->DisplayDriverDialog(GetActiveWindow(), CAPTURE_DIALOG_SOURCE);
	}
	else if ((dwQueryFlags & CAPTURE_DIALOG_FORMAT) && (dwFlags & CAPTURE_DIALOG_FORMAT))
	{
		hr = ((VideoInControl *)m_InMedia)->DisplayDriverDialog(GetActiveWindow(), CAPTURE_DIALOG_FORMAT);
	}

	return hr;

}


// will set dwFlags to one or more of the following bits
// CAPTURE_DIALOG_FORMAT
// CAPTURE_DIALOG_SOURCE
HRESULT __stdcall SendVideoStream::GetDeviceDialog(DWORD *pdwFlags)
{
    HRESULT hr;
    DWORD_PTR dwPropVal;

	hr = ((VideoInControl*)m_InMedia)->GetProp(MC_PROP_VFW_DIALOGS, &dwPropVal);
    *pdwFlags = (DWORD)dwPropVal;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nmcap\capture.cpp ===
#include <objbase.h>
#include <qos.h>
#include <winsock2.h>
#define INITGUID        // Only do this in one file
#include "capture.h"
#include "frameop.h"
#include "filters.h"
#include <confdbg.h>
#include <avutil.h>
#include "..\nac\utils.h"
#include "vidinout.h"
#include "vcmstrm.h"

CCaptureChain::CCaptureChain(void)
{
    m_opchain = NULL;
    m_filterchain = NULL;
    m_filtertags = NULL;
    InitializeCriticalSection(&m_capcs);
}

CCaptureChain::~CCaptureChain(void)
{
    CFrameOp *pchain;

    EnterCriticalSection(&m_capcs);
    pchain = m_opchain;
    m_opchain = NULL;
    LeaveCriticalSection(&m_capcs);
    if (pchain)
        pchain->Release();
    DeleteCriticalSection(&m_capcs);
}


STDMETHODIMP
CCaptureChain::GrabFrame(
    IBitmapSurface** ppBS
    )
{
    CFrameOp *cfo;
    HRESULT hres;

    *ppBS = NULL;
    EnterCriticalSection(&m_capcs);
    if (m_opchain) {
        m_opchain->AddRef();   // lock chain - prevents chain from being released
        cfo = m_opchain;
        while (cfo && ((hres = cfo->DoOp(ppBS)) == NOERROR)) {
            cfo = cfo->m_next;
        }
        if (*ppBS && hres != NOERROR) {
            // failed conversion, so discard last pBSin frame
            (*ppBS)->Release();
            *ppBS = NULL;
        }
        m_opchain->Release();   // unlock chain
    }
    else
        hres = E_UNEXPECTED;

    LeaveCriticalSection(&m_capcs);
    return hres;
}


typedef struct _CONVERTINFO
{
    long ci_width;
    long ci_height;
    long ci_dstwidth;
    long ci_dstheight;
    long ci_delta;
    long ci_UVDownSampling;
    long ci_ZeroingDWORD;
    void (*ci_Copy) (LPBYTE *, LPBYTE *);
    RGBQUAD ci_colortable[1];
} CONVERTINFO, FAR* PCONVERTINFO;

#ifdef ENABLE_ZOOM_CODE
typedef struct _rv
{
    long x_i;
    long p;
    long p1;
} ROW_VALUES;

typedef struct _ZOOMCONVERTINFO
{
    long ci_width;
    long ci_height;
    long ci_dstwidth;
    long ci_dstheight;
    ROW_VALUES *ci_rptr;
    RGBQUAD ci_colortable[1];
} ZOOMCONVERTINFO, FAR* PZOOMCONVERTINFO;
#endif // ENABLE_ZOOM_CODE


// sub worker routines for conversion of RGB16, RGB24 and RGB32 to RGB24
BYTE Byte16[32] = {0,8,16,25,33,41,49,58,66,74,82,91,99,107,115,123,132,140,148,156,165,173,
                   181,189,197,206,214,222,230,239,247,255};

void Copy16(LPBYTE *ppsrc, LPBYTE *ppdst)
{
    DWORD tmp;

    tmp = *(WORD *)(*ppsrc);
    *(*ppdst)++ = Byte16[tmp & 31];            // blue
    *(*ppdst)++ = Byte16[(tmp >> 5) & 31];     // green
    *(*ppdst)++ = Byte16[(tmp >> 10) & 31];    // red
    *ppsrc += 2;
}

void Copy24(LPBYTE *ppsrc, LPBYTE *ppdst)
{
    *(*ppdst)++ = *(*ppsrc)++;   // blue
    *(*ppdst)++ = *(*ppsrc)++;   // green
    *(*ppdst)++ = *(*ppsrc)++;   // red
}

void Copy32(LPBYTE *ppsrc, LPBYTE *ppdst)
{
    *(*ppdst)++ = *(*ppsrc)++;   // blue
    *(*ppdst)++ = *(*ppsrc)++;   // green
    *(*ppdst)++ = *(*ppsrc)++;   // red
    (*ppsrc)++;
}


// worker routine to shrink an RGB16, RGB24 or RGB32 in half (width & height)
//   result is RGB24
BOOL DoHalfSize(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long x, y;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    ipitch = (ipitch * 2) - (refdata->ci_dstwidth * 2 * refdata->ci_delta);
    opitch -= refdata->ci_dstwidth * 3;      // bytes at end of each row
    pIn = pBits;
    pOut = pCvtBits;
    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            refdata->ci_Copy(&pIn, &pOut);
            pIn += refdata->ci_delta;     // skip to next pixel
        }
        pIn += ipitch;          // get to start of row after next
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink an RGB4 in half (width & height)
//   result is RGB24
BOOL DoHalfSize4(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long x, y;
    BYTE pixel;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    ipitch = (ipitch * 2) - refdata->ci_dstwidth;
    opitch -= refdata->ci_dstwidth * 3;      // bytes at end of each row
    pIn = pBits;
    pOut = pCvtBits;
    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            pixel = (*pIn++/16) & 15;
            *pOut++ = refdata->ci_colortable[pixel].rgbBlue;
            *pOut++ = refdata->ci_colortable[pixel].rgbGreen;
            *pOut++ = refdata->ci_colortable[pixel].rgbRed;
        }
        pIn += ipitch;          // get to start of row after next
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink an RGB8 in half (width & height)
//   result is RGB24
BOOL DoHalfSize8(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long x, y;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    ipitch = (ipitch * 2) - refdata->ci_dstwidth * 2;
    opitch -= refdata->ci_dstwidth * 3;      // bytes at end of each row
    pIn = pBits;
    pOut = pCvtBits;
    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            *pOut++ = refdata->ci_colortable[*pIn].rgbBlue;
            *pOut++ = refdata->ci_colortable[*pIn].rgbGreen;
            *pOut++ = refdata->ci_colortable[*pIn].rgbRed;
            pIn += 2;
        }
        pIn += ipitch;          // get to start of row after next
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink a YVU9 or YUV12 in half (width & height)
//   result is YVU9 or YUV12
BOOL DoHalfSizeYUVPlanar(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pIn2, pOut;
    long pitch;
    long x, y, w, h;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &pitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &pitch);

	// Do the Y component first
	pitch = refdata->ci_width * 2 - refdata->ci_dstwidth * 2;   // amount to add for skip
    pIn = pBits;
    pOut = pCvtBits;
    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            *pOut++ = *pIn++;
            pIn++;              // skip to next pixel
        }
        pIn += pitch;           // get to start of row after next
    }
    // if source height is odd, then we've added 1 line too many onto pIn
    if (refdata->ci_height & 1)
        pIn -= refdata->ci_width;

    // Do the first color component next
    h = refdata->ci_dstheight / refdata->ci_UVDownSampling;
    w = refdata->ci_dstwidth / refdata->ci_UVDownSampling;
    pitch = refdata->ci_width / refdata->ci_UVDownSampling * 2 - w * 2;
    pIn2 = pIn + refdata->ci_width / refdata->ci_UVDownSampling;
    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            *pOut++ = (*pIn++ + *(++pIn) + *pIn2++ + *(++pIn2)) / 4;
        }
        pIn += pitch;           // get to start of row after next
        pIn2 += pitch;          // get to start of row after next
    }
    // if source height is odd, then we've added 1 line too many onto pIn
    if (refdata->ci_height & 1)
        pIn -= refdata->ci_width / refdata->ci_UVDownSampling;
    
    // Do the second color component next
    pIn2 = pIn + refdata->ci_width / refdata->ci_UVDownSampling;
    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            *pOut++ = (*pIn++ + *(++pIn) + *pIn2++ + *(++pIn2)) / 4;
        }
        pIn += pitch;           // get to start of row after next
        pIn2 += pitch;          // get to start of row after next
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink a YUV packed DIB in half (width & height)
//   result is YUY2, or UYVY
BOOL DoHalfSizeYUVPacked(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits;
	LPDWORD pIn, pOut;
    long ipitch, opitch;
    long x, y;
    long prelines, postlines, prebytes, postbytes, ibytes, obytes;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    pIn = (LPDWORD)pBits;
    pOut = (LPDWORD)pCvtBits;

    // copy one line out of two
    for (y = 0; y < refdata->ci_dstheight; y++) {
		// copy one pixel out of two
        for (x = 0; x < refdata->ci_dstwidth / 2; x++) {
            *pOut++ = *pIn++;
            pIn++;              // skip to next pixel
        }
        pIn += refdata->ci_width / 2;              // skip to next line
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);

    return TRUE;
}

// worker routine to shrink an RGB16, RGB24 or RGB32 by cropping
//   result is RGB24
BOOL Crop(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long extra, x, y;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    pOut = pCvtBits;

    // pIn starts by skipping half of the height change
    pIn = pBits + (refdata->ci_height - refdata->ci_dstheight) / 2 * ipitch;

    // extra = # of source bytes per scan line that are to be cropped
    extra = (refdata->ci_width - refdata->ci_dstwidth) * refdata->ci_delta;

    // advance pIn by half of extra to crop left most pixels
    pIn += extra / 2;

    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
    ipitch = ipitch - (refdata->ci_width * refdata->ci_delta) + extra;
    opitch -= refdata->ci_dstwidth * 3;      // bytes at end of each row

    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            refdata->ci_Copy(&pIn, &pOut);
        }
        pIn += ipitch;          // get to start of next row
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink an RGB4 by cropping
//   result is RGB24
BOOL Crop4(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long extra, x, y;
    BYTE val, pixel;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    pOut = pCvtBits;

    // pIn starts by skipping half of the height change
    pIn = pBits + (refdata->ci_height - refdata->ci_dstheight) / 2 * ipitch;

    // extra = # of source bytes per scan line that are to be cropped
    extra = (refdata->ci_width - refdata->ci_dstwidth) / 2;

    // advance pIn by half of extra to crop left most pixels
    pIn += extra / 2;

    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
    ipitch = ipitch - (refdata->ci_width / 2) + extra;
    opitch -= refdata->ci_dstwidth * 3;      // bytes at end of each row

    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth/2; x++) {
            val = *pIn++;
            pixel = (val/16) & 15;
            *pOut++ = refdata->ci_colortable[pixel].rgbBlue;
            *pOut++ = refdata->ci_colortable[pixel].rgbGreen;
            *pOut++ = refdata->ci_colortable[pixel].rgbRed;
            pixel = val & 15;
            *pOut++ = refdata->ci_colortable[pixel].rgbBlue;
            *pOut++ = refdata->ci_colortable[pixel].rgbGreen;
            *pOut++ = refdata->ci_colortable[pixel].rgbRed;
        }
        pIn += ipitch;          // get to start of next row
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink an RGB8 by cropping
//   result is RGB24
BOOL Crop8(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long extra, x, y;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    pOut = pCvtBits;

    // pIn starts by skipping half of the height change
    pIn = pBits + (refdata->ci_height - refdata->ci_dstheight) / 2 * ipitch;

    // extra = # of source bytes per scan line that are to be cropped
    extra = refdata->ci_width - refdata->ci_dstwidth;

    // advance pIn by half of extra to crop left most pixels
    pIn += extra / 2;

    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
    ipitch = ipitch - refdata->ci_width + extra;
    opitch -= refdata->ci_dstwidth * 3;      // bytes at end of each row

    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            *pOut++ = refdata->ci_colortable[*pIn].rgbBlue;
            *pOut++ = refdata->ci_colortable[*pIn].rgbGreen;
            *pOut++ = refdata->ci_colortable[*pIn++].rgbRed;
        }
        pIn += ipitch;          // get to start of next row
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink a YVU9 or YUV12 by cropping
//   result is YVU9 or YUV12
BOOL CropYUVPlanar(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long pitch, prelines, bytes, prebytes;
    long extra, y;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &pitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &pitch);

    pOut = pCvtBits;

    // pIn starts by skipping half of the height change
    prelines = ((refdata->ci_height - refdata->ci_dstheight) >> 1) / refdata->ci_UVDownSampling * refdata->ci_UVDownSampling;
    pIn = pBits + prelines * refdata->ci_width;

    // extra = # of source bytes per scan line that are to be cropped
    extra = refdata->ci_width - refdata->ci_dstwidth;
    prebytes = (extra >> 1) / refdata->ci_UVDownSampling * refdata->ci_UVDownSampling;

    // advance pIn by half of extra to crop left most pixels
    pIn += prebytes;

	// Do the Y component first
	pitch = extra + refdata->ci_dstwidth;
    for (y = 0; y < refdata->ci_dstheight; y++) {
        CopyMemory (pOut, pIn, refdata->ci_dstwidth);
        pIn += pitch;
        pOut += refdata->ci_dstwidth;
    }

	// Do the first color component next
    prelines /= refdata->ci_UVDownSampling;
    prebytes /= refdata->ci_UVDownSampling;
	pIn = pBits + (refdata->ci_width * refdata->ci_height) +    // skip Y section
	        prelines * refdata->ci_width / refdata->ci_UVDownSampling +  // skip half of the crop lines
	        prebytes;                                           // skip half of the crop pixels

    pitch /= refdata->ci_UVDownSampling;
    bytes = refdata->ci_dstwidth / refdata->ci_UVDownSampling;
	for (y=0; y < refdata->ci_dstheight / refdata->ci_UVDownSampling; y++)
	{
        CopyMemory (pOut, pIn, bytes);
        pIn += pitch;
        pOut += bytes;
	}

	// Do the second color component next
	pIn = pBits + (refdata->ci_width * refdata->ci_height) +    // skip Y section
	        (refdata->ci_width * refdata->ci_height) / (refdata->ci_UVDownSampling * refdata->ci_UVDownSampling) +     // skip first color component section
	        prelines * refdata->ci_width / refdata->ci_UVDownSampling +                  // skip half of the crop lines
	        prebytes;                                           // skip half of the crop pixels
	for (y=0; y < refdata->ci_dstheight / refdata->ci_UVDownSampling; y++)
	{
        CopyMemory (pOut, pIn, bytes);
        pIn += pitch;
        pOut += bytes;
	}

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink a YUV packed DIB by cropping
//   result is YUY2 or UYVY
BOOL CropYUVPacked(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long extra, x, y;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    pOut = pCvtBits;

    // pIn starts by skipping half of the height change
    pIn = pBits + (refdata->ci_height - refdata->ci_dstheight) * refdata->ci_width * 2;

    // extra = # of source bytes per scan line that are to be cropped
    extra = (refdata->ci_width - refdata->ci_dstwidth) * 2;

    // advance pIn by half of extra to crop left most pixels
    pIn += extra / 2;

    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
    ipitch = refdata->ci_width * 2;
    opitch = refdata->ci_dstwidth * 2;      // bytes at end of each row

    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            CopyMemory(pOut, pIn, refdata->ci_dstwidth * 2);
        }
        pIn += ipitch;          // get to start of next row
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// routine to prepare for calling shrink worker routines
// it allocates and initializes a reference data structure
BOOL
InitShrink(
    LPBITMAPINFOHEADER lpbmhIn,
    long desiredwidth,
    long desiredheight,
    LPBITMAPINFOHEADER *lpbmhOut,
    FRAMECONVERTPROC **convertproc,
    LPVOID *refdata
    )
{
    PCONVERTINFO pcvt;
    DWORD dwSize;
    long crop_ratio, black_ratio, target_size;

    *convertproc = NULL;
    *refdata = NULL;

    if ((lpbmhIn->biCompression != VIDEO_FORMAT_BI_RGB) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_YVU9) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_YUY2) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_UYVY) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_I420) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_IYUV))
        return FALSE;

    // calculate size of convertinfo struct, if we need a colortable, then add 256 entries
    // else subtract off the 1 built into the struct definition
    dwSize = sizeof(CONVERTINFO) - sizeof(RGBQUAD);
    if (lpbmhIn->biBitCount <= 8)
        dwSize += 256 * sizeof(RGBQUAD);

    // for RGB, and YUV input formats, we know that the output format will never need
    // an attached color table, so we can allocate lpbmhOut without one
    if ((pcvt = (PCONVERTINFO)LocalAlloc(LPTR, dwSize)) &&
        (*lpbmhOut = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, lpbmhIn->biSize))) {
        CopyMemory(*lpbmhOut, lpbmhIn, lpbmhIn->biSize);
        pcvt->ci_width = lpbmhIn->biWidth;
        pcvt->ci_height = lpbmhIn->biHeight;

        target_size = desiredwidth * desiredheight;
        crop_ratio = pcvt->ci_width * pcvt->ci_height;
        black_ratio = ((target_size - (crop_ratio / 4)) * 100) / target_size;
        crop_ratio = ((crop_ratio - target_size) * 100) / crop_ratio;
        if (crop_ratio < black_ratio) {
            // cropping the source makes more sense
            pcvt->ci_dstwidth = desiredwidth;
            pcvt->ci_dstheight = desiredheight;
            crop_ratio = 1; // flag that we'll crop
        }
        else {
            // halfsizing makes more sense
            pcvt->ci_dstwidth = lpbmhIn->biWidth / 2;
            pcvt->ci_dstheight = lpbmhIn->biHeight / 2;
            crop_ratio = 0; // flag that we'll half size
        }
        (*lpbmhOut)->biWidth = pcvt->ci_dstwidth;
        (*lpbmhOut)->biHeight = pcvt->ci_dstheight;

        // copy colortable from input bitmapinfoheader
        if (lpbmhIn->biBitCount <= 8)
            CopyMemory(&pcvt->ci_colortable[0], (LPBYTE)lpbmhIn + lpbmhIn->biSize, 256 * sizeof(RGBQUAD));

        if (lpbmhIn->biCompression == VIDEO_FORMAT_BI_RGB) {
            (*lpbmhOut)->biBitCount = 24;
            (*lpbmhOut)->biSizeImage = pcvt->ci_dstwidth * pcvt->ci_dstheight * 3;
            if (lpbmhIn->biBitCount == 4) {
                if (crop_ratio)
                    *convertproc = (FRAMECONVERTPROC*)&Crop4;
                else
                    *convertproc = (FRAMECONVERTPROC*)&DoHalfSize4;
            }
            else if (lpbmhIn->biBitCount == 8) {
                if (crop_ratio)
                    *convertproc = (FRAMECONVERTPROC*)&Crop8;
                else
                    *convertproc = (FRAMECONVERTPROC*)&DoHalfSize8;
            }
            else {
                if (crop_ratio)
                    *convertproc = (FRAMECONVERTPROC*)&Crop;
                else
                    *convertproc = (FRAMECONVERTPROC*)&DoHalfSize;
                pcvt->ci_delta = lpbmhIn->biBitCount / 8;
                if (lpbmhIn->biBitCount == 16) {
                    pcvt->ci_Copy = &Copy16;
                }
                else if (lpbmhIn->biBitCount == 24) {
                    pcvt->ci_Copy = &Copy24;
                }
                else if (lpbmhIn->biBitCount == 32) {
                    pcvt->ci_Copy = &Copy32;
                }
            }
        }
        else if (lpbmhIn->biCompression == VIDEO_FORMAT_YVU9) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = pcvt->ci_dstwidth * pcvt->ci_dstheight + (pcvt->ci_dstwidth * pcvt->ci_dstheight)/8;
            if (crop_ratio)
                *convertproc = (FRAMECONVERTPROC*)&CropYUVPlanar;
            else
                *convertproc = (FRAMECONVERTPROC*)&DoHalfSizeYUVPlanar;
			pcvt->ci_UVDownSampling = 4;
        }
        else if ((lpbmhIn->biCompression == VIDEO_FORMAT_YUY2) || (lpbmhIn->biCompression == VIDEO_FORMAT_UYVY)) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = (DWORD)WIDTHBYTES(pcvt->ci_dstwidth * lpbmhIn->biBitCount) * pcvt->ci_dstheight;
            if (crop_ratio)
                *convertproc = (FRAMECONVERTPROC*)&CropYUVPacked;
            else
                *convertproc = (FRAMECONVERTPROC*)&DoHalfSizeYUVPacked;
        }
        else if ((lpbmhIn->biCompression == VIDEO_FORMAT_I420) || (lpbmhIn->biCompression == VIDEO_FORMAT_IYUV)) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = (DWORD)WIDTHBYTES(pcvt->ci_dstwidth * lpbmhIn->biBitCount) * pcvt->ci_dstheight;
            if (crop_ratio)
                *convertproc = (FRAMECONVERTPROC*)&CropYUVPlanar;
            else
                *convertproc = (FRAMECONVERTPROC*)&DoHalfSizeYUVPlanar;
			pcvt->ci_UVDownSampling = 2;
        }

        *refdata = (LPVOID)pcvt;
        return TRUE;
    }
    else {
        if (pcvt)
            LocalFree((HANDLE)pcvt);
    }
    return FALSE;
}

// worker routine to expand an RGB16, RGB24 or RGB32 by copying source into middle of destination
//   result is RGB24
BOOL DoBlackBar(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch, oextra;
    long x, y;
    long prelines, postlines, prebytes, postbytes, bytes;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    prelines = (refdata->ci_dstheight - refdata->ci_height) / 2;
    postlines = refdata->ci_dstheight - refdata->ci_height - prelines;

    prebytes = (refdata->ci_dstwidth - refdata->ci_width) / 2;
    postbytes = (refdata->ci_dstwidth - refdata->ci_width - prebytes) * 3;
    prebytes *= 3;

    ipitch -= refdata->ci_width * refdata->ci_delta;        // bytes at end of each src row
    bytes = refdata->ci_dstwidth * 3;
    oextra = opitch - bytes + postbytes;                    // bytes at end of each dst row
    
    pIn = pBits;
    pOut = pCvtBits;

    // do blank lines at front of destination
    for (y = 0; y < prelines; y++) {
        ZeroMemory (pOut, bytes);
        pOut += opitch;
    }

    // copy source lines with blank space at front and rear        
    for (y = 0; y < refdata->ci_height; y++) {
        ZeroMemory (pOut, prebytes);
        pOut += prebytes;

        for (x = 0; x < refdata->ci_width; x++) {
            refdata->ci_Copy(&pIn, &pOut);
        }

        ZeroMemory (pOut, postbytes);
        pIn += ipitch;
        pOut += oextra;
    }

    // do blank lines at end of destination
    for (y = 0; y < postlines; y++) {
        ZeroMemory (pOut, bytes);
        pOut += opitch;
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to expand an RGB4 by copying source into middle of destination
//   result is RGB24
BOOL DoBlackBar4(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch, oextra;
    long x, y;
    long prelines, postlines, prebytes, postbytes, bytes;
    BYTE val, pixel;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    prelines = (refdata->ci_dstheight - refdata->ci_height) / 2;
    postlines = refdata->ci_dstheight - refdata->ci_height - prelines;

    prebytes = (refdata->ci_dstwidth - refdata->ci_width) / 2;
    postbytes = (refdata->ci_dstwidth - refdata->ci_width - prebytes) * 3;
    prebytes *= 3;

    ipitch -= refdata->ci_width/2;          // bytes at end of each src row
    bytes = refdata->ci_dstwidth * 3;
    oextra = opitch - bytes + postbytes;    // bytes at end of each dst row
    
    pIn = pBits;
    pOut = pCvtBits;

    // do blank lines at front of destination
    for (y = 0; y < prelines; y++) {
        ZeroMemory (pOut, bytes);
        pOut += opitch;
    }

    // copy source lines with blank space at front and rear        
    for (y = 0; y < refdata->ci_height; y++) {
        ZeroMemory (pOut, prebytes);
        pOut += prebytes;

        for (x = 0; x < refdata->ci_width/2; x++) {
            val = *pIn++;
            pixel = (val/16) & 15;
            *pOut++ = refdata->ci_colortable[pixel].rgbBlue;
            *pOut++ = refdata->ci_colortable[pixel].rgbGreen;
            *pOut++ = refdata->ci_colortable[pixel].rgbRed;
            pixel = val & 15;
            *pOut++ = refdata->ci_colortable[pixel].rgbBlue;
            *pOut++ = refdata->ci_colortable[pixel].rgbGreen;
            *pOut++ = refdata->ci_colortable[pixel].rgbRed;
        }

        ZeroMemory (pOut, postbytes);
        pIn += ipitch;
        pOut += oextra;
    }

    // do blank lines at end of destination
    for (y = 0; y < postlines; y++) {
        ZeroMemory (pOut, bytes);
        pOut += opitch;
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to expand an RGB8 by copying source into middle of destination
//   result is RGB24
BOOL DoBlackBar8(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch, oextra;
    long x, y;
    long prelines, postlines, prebytes, postbytes, bytes;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    prelines = (refdata->ci_dstheight - refdata->ci_height) / 2;
    postlines = refdata->ci_dstheight - refdata->ci_height - prelines;

    prebytes = (refdata->ci_dstwidth - refdata->ci_width) / 2;
    postbytes = (refdata->ci_dstwidth - refdata->ci_width - prebytes) * 3;
    prebytes *= 3;

    ipitch -= refdata->ci_width;                // bytes at end of each src row
    bytes = refdata->ci_dstwidth * 3;
    oextra = opitch - bytes + postbytes;        // bytes at end of each dst row
    
    pIn = pBits;
    pOut = pCvtBits;

    // do blank lines at front of destination
    for (y = 0; y < prelines; y++) {
        ZeroMemory (pOut, bytes);
        pOut += opitch;
    }

    // copy source lines with blank space at front and rear        
    for (y = 0; y < refdata->ci_height; y++) {
        ZeroMemory (pOut, prebytes);
        pOut += prebytes;

        for (x = 0; x < refdata->ci_width; x++) {
            *pOut++ = refdata->ci_colortable[*pIn].rgbBlue;
            *pOut++ = refdata->ci_colortable[*pIn].rgbGreen;
            *pOut++ = refdata->ci_colortable[*pIn++].rgbRed;
        }

        ZeroMemory (pOut, postbytes);
        pIn += ipitch;
        pOut += oextra;
    }

    // do blank lines at end of destination
    for (y = 0; y < postlines; y++) {
        ZeroMemory (pOut, bytes);
        pOut += opitch;
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to expand a YVU9 or YUV12 by copying source into middle of destination
//   result is YVU9 or YUV12
BOOL DoBlackBarYUVPlanar(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits;
    LONG prelines, postlines, bytesperpixel, prebytes, postbytes, y, bytes;
    LONG prelinebytes, postlinebytes;
    LPBYTE lpsrc, lpdst;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &bytes);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &bytes);

	lpsrc = pBits;
	lpdst = pCvtBits;

	// Do the Y component first
    prelines = ((refdata->ci_dstheight - refdata->ci_height) / (refdata->ci_UVDownSampling << 1)) * refdata->ci_UVDownSampling;
    postlines = refdata->ci_dstheight - refdata->ci_height - prelines;

    prebytes = ((refdata->ci_dstwidth - refdata->ci_width) / (refdata->ci_UVDownSampling << 1)) * refdata->ci_UVDownSampling;
    postbytes = (refdata->ci_dstwidth - refdata->ci_width - prebytes);

    bytes = prelines * refdata->ci_dstwidth + prebytes;
    FillMemory (lpdst, bytes, 0x10);
    lpdst += bytes;

	bytes = refdata->ci_width;
    prebytes += postbytes;
	for (y=0; y < refdata->ci_height; y++)
	{
        MoveMemory (lpdst, lpsrc, bytes);
        lpsrc += bytes;
        lpdst += bytes;
        FillMemory (lpdst, prebytes, 0x10);
        lpdst += prebytes;
	}

	// already filled the prebytes of the first postline in loop above
	prebytes -= postbytes;
	bytes = postlines * refdata->ci_dstwidth - prebytes;
	FillMemory (lpdst, bytes, (BYTE)0x10);
	lpdst += bytes;

	// Do the first color component next
    prelines /= refdata->ci_UVDownSampling;
    postlines = refdata->ci_dstheight / refdata->ci_UVDownSampling - refdata->ci_height / refdata->ci_UVDownSampling - prelines;

    prebytes = prebytes / refdata->ci_UVDownSampling;
    postbytes = refdata->ci_dstwidth / refdata->ci_UVDownSampling - refdata->ci_width / refdata->ci_UVDownSampling - prebytes;

    prelinebytes = prelines * refdata->ci_dstwidth / refdata->ci_UVDownSampling + prebytes;
    FillMemory (lpdst, prelinebytes, 0x80);
    lpdst += prelinebytes;
    
	bytes = refdata->ci_width / refdata->ci_UVDownSampling;
    prebytes += postbytes;
	for (y=0; y < refdata->ci_height / refdata->ci_UVDownSampling; y++)
	{
        MoveMemory (lpdst, lpsrc, bytes);
        lpsrc += bytes;
        lpdst += bytes;
        FillMemory (lpdst, prebytes, 0x80);
        lpdst += prebytes;
	}

	// already filled the prebytes of the first postline in loop above
	postlinebytes = postlines * refdata->ci_dstwidth / refdata->ci_UVDownSampling - (prebytes - postbytes);
	FillMemory (lpdst, postlinebytes, 0x80);
	lpdst += postlinebytes;
	
	// Do the second color component next
    FillMemory (lpdst, prelinebytes, 0x80);
    lpdst += prelinebytes;    
	for (y=0; y < refdata->ci_height / refdata->ci_UVDownSampling; y++)
	{
        MoveMemory (lpdst, lpsrc, bytes);
        lpsrc += bytes;
        lpdst += bytes;
        FillMemory (lpdst, prebytes, 0x80);
        lpdst += prebytes;
	}
	FillMemory (lpdst, postlinebytes, 0x80);

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to expand a YUV packed DIB by copying source into middle of destination
//   result is YUY2 or UYVY
BOOL DoBlackBarYUVPacked(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long x, y;
    long prelines, postlines, prebytes, postbytes, ibytes, obytes;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    prelines = (refdata->ci_dstheight - refdata->ci_height) / 2;
    postlines = refdata->ci_dstheight - refdata->ci_height - prelines;

    prebytes = (refdata->ci_dstwidth - refdata->ci_width) / 2;
    postbytes = (refdata->ci_dstwidth - refdata->ci_width - prebytes) / 2;
    prebytes /= 2;

    ibytes = refdata->ci_width * 2;
    obytes = refdata->ci_dstwidth / 2;
    
    pIn = pBits;
    pOut = pCvtBits;

    // do blank lines at front of destination
    for (y = 0; y < prelines; y++) {
		for (x = 0; x < obytes; x++) {
			*(DWORD *)pOut = refdata->ci_ZeroingDWORD;
			pOut += sizeof(DWORD);
		}
    }

    // copy source lines with blank space at front and rear        
    for (y = 0; y < refdata->ci_height; y++) {
		for (x = 0; x < prebytes; x++) {
			*(DWORD *)pOut = refdata->ci_ZeroingDWORD;
			pOut += sizeof(DWORD);
		}

        CopyMemory(pOut, pIn, ibytes);
		pOut += ibytes;
		pIn += ibytes;

		for (x = 0; x < postbytes; x++) {
			*(DWORD *)pOut = refdata->ci_ZeroingDWORD;
			pOut += sizeof(DWORD);
		}
    }

    // do blank lines at end of destination
    for (y = 0; y < postlines; y++) {
		for (x = 0; x < obytes; x++) {
			*(DWORD *)pOut = refdata->ci_ZeroingDWORD;
			pOut += sizeof(DWORD);
		}
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);

    return TRUE;
}

// routine to prepare for calling blackbar worker routines
// it allocates and initializes a reference data structure
BOOL
InitBlackbar(
    LPBITMAPINFOHEADER lpbmhIn,
    long desiredwidth,
    long desiredheight,
    LPBITMAPINFOHEADER *lpbmhOut,
    FRAMECONVERTPROC **convertproc,
    LPVOID *refdata
    )
{
    PCONVERTINFO pcvt;
    DWORD dwSize;

    *convertproc = NULL;
    *refdata = NULL;

    if ((lpbmhIn->biCompression != VIDEO_FORMAT_BI_RGB) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_YVU9) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_YUY2) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_UYVY) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_I420) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_IYUV))
        return FALSE;

    // calculate size of convertinfo struct, if we need a colortable, then add 256 entries
    // else subtract off the 1 built into the struct definition
    dwSize = sizeof(CONVERTINFO) - sizeof(RGBQUAD);
    if (lpbmhIn->biBitCount <= 8)
        dwSize += 256 * sizeof(RGBQUAD);

    // for RGB, YUV input formats, we know that the output format will never need
    // an attached color table, so we can allocate lpbmhOut without one
    if ((pcvt = (PCONVERTINFO)LocalAlloc(LPTR, dwSize)) &&
        (*lpbmhOut = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, lpbmhIn->biSize))) {
        CopyMemory(*lpbmhOut, lpbmhIn, lpbmhIn->biSize);
        pcvt->ci_width = lpbmhIn->biWidth;
        pcvt->ci_height = lpbmhIn->biHeight;
        pcvt->ci_dstwidth = desiredwidth;
        pcvt->ci_dstheight = desiredheight;
        (*lpbmhOut)->biWidth = desiredwidth;
        (*lpbmhOut)->biHeight = desiredheight;

        // copy colortable from input bitmapinfoheader
        if (lpbmhIn->biBitCount <= 8)
            CopyMemory(&pcvt->ci_colortable[0], (LPBYTE)lpbmhIn + lpbmhIn->biSize, 256 * sizeof(RGBQUAD));

        if (lpbmhIn->biCompression == VIDEO_FORMAT_BI_RGB) {
            (*lpbmhOut)->biBitCount = 24;
            (*lpbmhOut)->biSizeImage = desiredwidth * desiredheight * 3;

            if (lpbmhIn->biBitCount == 4) {
                *convertproc = (FRAMECONVERTPROC*)&DoBlackBar4;
            }
            else if (lpbmhIn->biBitCount == 8) {
                *convertproc = (FRAMECONVERTPROC*)&DoBlackBar8;
            }
            else {
                *convertproc = (FRAMECONVERTPROC*)&DoBlackBar;
                pcvt->ci_delta = lpbmhIn->biBitCount / 8;
                if (lpbmhIn->biBitCount == 16) {
                    pcvt->ci_Copy = &Copy16;
                }
                else if (lpbmhIn->biBitCount == 24) {
                    pcvt->ci_Copy = &Copy24;
                }
                else if (lpbmhIn->biBitCount == 32) {
                    pcvt->ci_Copy = &Copy32;
                }
            }
        }
        else if (lpbmhIn->biCompression == VIDEO_FORMAT_YVU9) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = desiredwidth * desiredheight + (desiredwidth * desiredheight)/8;
            *convertproc = (FRAMECONVERTPROC*)&DoBlackBarYUVPlanar;
			pcvt->ci_UVDownSampling = 4;
        }
        else if (lpbmhIn->biCompression == VIDEO_FORMAT_YUY2) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = (DWORD)WIDTHBYTES(desiredwidth * lpbmhIn->biBitCount) * desiredheight;
			pcvt->ci_ZeroingDWORD = 0x80108010;
            *convertproc = (FRAMECONVERTPROC*)&DoBlackBarYUVPacked;
        }
        else if (lpbmhIn->biCompression == VIDEO_FORMAT_UYVY) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = (DWORD)WIDTHBYTES(desiredwidth * lpbmhIn->biBitCount) * desiredheight;
			pcvt->ci_ZeroingDWORD = 0x10801080;
            *convertproc = (FRAMECONVERTPROC*)&DoBlackBarYUVPacked;
        }
        else if ((lpbmhIn->biCompression == VIDEO_FORMAT_I420) || (lpbmhIn->biCompression == VIDEO_FORMAT_IYUV)) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = (DWORD)WIDTHBYTES(desiredwidth * lpbmhIn->biBitCount) * desiredheight;
            *convertproc = (FRAMECONVERTPROC*)&DoBlackBarYUVPlanar;
			pcvt->ci_UVDownSampling = 2;
        }

        *refdata = (LPVOID)pcvt;
        return TRUE;
    }
    else {
        if (pcvt)
            LocalFree((HANDLE)pcvt);
    }
    return FALSE;
}


#ifdef ENABLE_ZOOM_CODE
BOOL Zoom4(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PZOOMCONVERTINFO refdata
    )
{
    return FALSE;
}

BOOL Zoom8(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PZOOMCONVERTINFO refdata
    )
{
    return FALSE;
}

BOOL Zoom16(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PZOOMCONVERTINFO refdata
    )
{
    return FALSE;
}

BOOL Zoom24(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PZOOMCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn1, pIn2, pTmp, pOut;
    ROW_VALUES *rptr;
    long i, j, yfac_inv, src_y, src_y_i, q, q1;
    long a;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &i);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &i);

    pOut = pCvtBits;

    yfac_inv = refdata->ci_height * 256 / refdata->ci_dstheight;

    for (i = 0; i < refdata->ci_dstheight; i++) {
        src_y = i * yfac_inv;
        src_y_i = src_y / 256;
        q = src_y - src_y_i * 256;
        q1 = 256 - q;
        rptr = refdata->ci_rptr;

        pIn1 = pBits + src_y_i * refdata->ci_width * 3;
        pIn2 = pIn1 + refdata->ci_width * 3;
        for (j = 0; j < refdata->ci_dstwidth; j++, rptr++) {
            a = rptr->x_i * 3;
            pIn1 += a;
            pIn2 += a;
            a = (((*pIn1) * rptr->p1 + (*(pIn1+3)) * rptr->p) * q1 +
                   ((*pIn2) * rptr->p1 + (*(pIn2+3)) * rptr->p) * q) / 256 / 256;
            if (a > 256) a = 255;
            *pOut++ = (BYTE)a;                  // blue
            pIn1++;
            pIn2++;

            a = (((*pIn1) * rptr->p1 + (*(pIn1+3)) * rptr->p) * q1 +
                   ((*pIn2) * rptr->p1 + (*(pIn2+3)) * rptr->p) * q) / 256 / 256;
            if (a > 256) a = 255;
            *pOut++ = (BYTE)a;                  // green
            pIn1++;
            pIn2++;

            a = (((*pIn1) * rptr->p1 + (*(pIn1+3)) * rptr->p) * q1 +
                   ((*pIn2) * rptr->p1 + (*(pIn2+3)) * rptr->p) * q) / 256 / 256;
            if (a > 256) a = 255;
            *pOut++ = (BYTE)a;                  // red
            pIn1 -= 2;
            pIn2 -= 2;
        }        
    }


    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

BOOL ZoomYVU9(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PZOOMCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn1, pIn2, pOut, pOut2, pU1;
    ROW_VALUES *rptr;
    long i, j, yfac_inv, src_y, src_y_i, q, q1;
    long a, b, c, d;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &i);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &i);

    pOut = pCvtBits;

    yfac_inv = refdata->ci_height * 256 / refdata->ci_dstheight;

    // Do the Y component first as a bilinear zoom
    for (i = 0; i < refdata->ci_dstheight; i++) {
        src_y = i * yfac_inv;
        src_y_i = src_y / 256;
        q = src_y - src_y_i * 256;
        q1 = 256 - q;
        rptr = refdata->ci_rptr;

        pIn1 = pBits + src_y_i * refdata->ci_width;
        pIn2 = pIn1 + refdata->ci_width;
        for (j = 0; j < refdata->ci_dstwidth; j++, rptr++) {
            pIn1 += rptr->x_i;
            pIn2 += rptr->x_i;
            a = *pIn1;
            b = *(pIn1+1);
            c = *pIn2;
            d = *(pIn2+1);
            a = ((a * rptr->p1 + b * rptr->p) * q1 +
                (c * rptr->p1 + d * rptr->p) * q) / 256 / 256;
            if (a > 256) a = 255;
            *pOut++ = (BYTE)a;
        }        
    }

    // Do the V and U components next as a nearest neighbor zoom
    pIn1 = pBits + refdata->ci_width * refdata->ci_height;      // start of source V table
    pU1 = pIn1 + (refdata->ci_width * refdata->ci_height) / 16; // start of source U table
    pOut2 = pOut + (refdata->ci_dstwidth * refdata->ci_dstheight) / 16; // start of dest U table
    src_y = 0;
    for (i = 0; i < refdata->ci_dstheight; i += 4) {
        src_y_i = (i * yfac_inv) / 256 / 4;
        d = (src_y_i - src_y) * refdata->ci_width / 4;
        pIn1 += d;
        pU1 += d;
        src_y = src_y_i;

        a = 0;
        rptr = refdata->ci_rptr;
        for (j = 0; j < refdata->ci_dstwidth/4; j++) {
            *pOut++ = *(pIn1+a/4);
            *pOut2++ = *(pU1+a/4);

            a += rptr->x_i;
            rptr++;
            a += rptr->x_i;
            rptr++;
            a += rptr->x_i;
            rptr++;
            a += rptr->x_i;
            rptr++;
        }
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

BOOL
InitScale(
    LPBITMAPINFOHEADER lpbmhIn,
    long desiredwidth,
    long desiredheight,
    LPBITMAPINFOHEADER *lpbmhOut,
    FRAMECONVERTPROC **convertproc,
    LPVOID *refdata
    )
{
    PZOOMCONVERTINFO pcvt;
    DWORD dwSize, dwBaseSize;
    ROW_VALUES *rptr;
    long i, x, xfac_inv, x_i_last, tmp;

    *convertproc = NULL;
    *refdata = NULL;

    if ((lpbmhIn->biCompression != VIDEO_FORMAT_BI_RGB) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_YVU9))
        return FALSE;

    // calculate size of zoomconvertinfo struct, if we need a colortable, then add 256 entries
    // else subtract off the 1 built into the struct definition
    dwBaseSize = sizeof(ZOOMCONVERTINFO) - sizeof(RGBQUAD);
    if (lpbmhIn->biBitCount <= 8)
        dwBaseSize += 256 * sizeof(RGBQUAD);

    dwSize = dwBaseSize + desiredwidth * sizeof(ROW_VALUES);

    // for RGB and YVU9 input formats, we know that the output format will never need
    // an attached color table, so we can allocate lpbmhOut without one
    if ((pcvt = (PZOOMCONVERTINFO)LocalAlloc(LPTR, dwSize)) &&
        (*lpbmhOut = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, lpbmhIn->biSize))) {
        CopyMemory(*lpbmhOut, lpbmhIn, lpbmhIn->biSize);
        pcvt->ci_width = lpbmhIn->biWidth;
        pcvt->ci_height = lpbmhIn->biHeight;
        pcvt->ci_dstwidth = desiredwidth;
        pcvt->ci_dstheight = desiredheight;
        (*lpbmhOut)->biWidth = desiredwidth;
        (*lpbmhOut)->biHeight = desiredheight;

        pcvt->ci_rptr = (ROW_VALUES *)(((BYTE *)pcvt) + dwBaseSize);
        rptr = pcvt->ci_rptr;
        xfac_inv = lpbmhIn->biWidth * 256 / desiredwidth;
        x_i_last = 0;
        for (i = 0; i < desiredwidth; i++) {
            x = i * xfac_inv;
            tmp = x / 256;
            rptr->x_i = tmp - x_i_last;
            x_i_last = tmp;
            rptr->p = x - x_i_last * 256;
            rptr->p1 = 256 - rptr->p;
            rptr++;
        }

        // copy colortable from input bitmapinfoheader
        if (lpbmhIn->biBitCount <= 8)
            CopyMemory(&pcvt->ci_colortable[0], (LPBYTE)lpbmhIn + lpbmhIn->biSize, 256 * sizeof(RGBQUAD));

        if (lpbmhIn->biCompression == VIDEO_FORMAT_BI_RGB) {
            (*lpbmhOut)->biBitCount = 24;
            (*lpbmhOut)->biSizeImage = desiredwidth * desiredheight * 3;

            if (lpbmhIn->biBitCount == 4) {
                *convertproc = (FRAMECONVERTPROC*)&Zoom4;
            }
            else if (lpbmhIn->biBitCount == 8) {
                *convertproc = (FRAMECONVERTPROC*)&Zoom8;
            }
            else if (lpbmhIn->biBitCount == 16) {
                *convertproc = (FRAMECONVERTPROC*)&Zoom16;
            }
            else {
                *convertproc = (FRAMECONVERTPROC*)&Zoom24;
            }
        }
        else if (lpbmhIn->biCompression == VIDEO_FORMAT_YVU9) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = desiredwidth * desiredheight + (desiredwidth * desiredheight)/8;
            *convertproc = (FRAMECONVERTPROC*)&ZoomYVU9;
        }

        *refdata = (LPVOID)pcvt;
        return TRUE;
    }
    else {
        if (pcvt)
            LocalFree((HANDLE)pcvt);
    }
    return FALSE;
}
#endif // ENABLE_ZOOM_CODE

STDMETHODIMP
CCaptureChain::InitCaptureChain(
    HCAPDEV hcapdev,
    BOOL streaming,
	LPBITMAPINFOHEADER lpcap,
    LONG desiredwidth,
    LONG desiredheight,
    DWORD desiredformat,
    LPBITMAPINFOHEADER *plpdsp
    )
{
    CFrameOp *ccf;
    CFrameOp *clast;
    CFilterChain *cfilterchain;
    LPBITMAPINFOHEADER lpcvt;
    DWORD lpcapsize;

	FX_ENTRY("CCaptureChain::InitCaptureChain");

    *plpdsp = NULL;

#ifndef SUPPORT_DESIRED_FORMAT
    if (desiredformat != 0) {
        ERRORMESSAGE(("%s: Invalid desiredformat parameter", _fx_));
        return E_FAIL;
    }
#endif

    if (streaming) {
        if ((ccf = new CStreamCaptureFrame)) {
            ccf->AddRef();
            if (hcapdev && !((CStreamCaptureFrame*)ccf)->InitCapture(hcapdev, lpcap)) {
				ERRORMESSAGE(("%s: Failed to init capture object", _fx_));
                ccf->Release();
                return E_FAIL;
            }
        }
    }
    else {
        if ((ccf = new CCaptureFrame)) {
            ccf->AddRef();
            if (hcapdev && !((CCaptureFrame*)ccf)->InitCapture(hcapdev, lpcap)) {
				ERRORMESSAGE(("%s: Failed to init capture object", _fx_));
                ccf->Release();
                return E_FAIL;
            }
        }
    }

    if (!ccf) {
		ERRORMESSAGE(("%s: Failed to alloc capture object", _fx_));
        return E_OUTOFMEMORY;
    }
    clast = ccf;

    lpcapsize = lpcap->biSize;
    if (lpcap->biBitCount <= 8)
        lpcapsize += 256 * sizeof(RGBQUAD);

#if 0
    if ((lpcap->biCompression != BI_RGB) &&
        (lpcap->biCompression != VIDEO_FORMAT_YVU9) &&
        (lpcap->biCompression != VIDEO_FORMAT_INTELI420)) {
#else
    if ((lpcap->biCompression != BI_RGB) &&
        (lpcap->biCompression != VIDEO_FORMAT_YVU9) &&
        (lpcap->biCompression != VIDEO_FORMAT_YUY2) &&
        (lpcap->biCompression != VIDEO_FORMAT_UYVY) &&
        (lpcap->biCompression != VIDEO_FORMAT_I420) &&
        (lpcap->biCompression != VIDEO_FORMAT_IYUV)) {
#endif
        // attempt to instantiate an ICM CFrameOp
        CICMcvtFrame *cicm;

        if ((cicm = new CICMcvtFrame)) {
            cicm->AddRef();
#if 0
            if (cicm->InitCvt(lpcap, lpcapsize, plpdsp, BI_RGB)) {
#else
            if (cicm->InitCvt(lpcap, lpcapsize, plpdsp)) {
#endif
                clast->m_next = (CFrameOp*)cicm; // add ICM FrameOp into chain
                clast = (CFrameOp*)cicm;
            }
            else {
                cicm->Release();

                if (!*plpdsp)
				{
					ERRORMESSAGE(("%s: Failed to find a codec", _fx_));
				}
            }
        }
        else
		{
			ERRORMESSAGE(("%s: Failed to alloc codec object", _fx_));
		}
    }
    else if (!*plpdsp) {
        if (*plpdsp = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, lpcapsize))
            CopyMemory(*plpdsp, lpcap, lpcapsize);
        else
		{
			ERRORMESSAGE(("%s: Failed to alloc display bitmapinfoheader", _fx_));
		}
    }

#ifdef SUPPORT_DESIRED_FORMAT
#if 0
// LOOKLOOK RP - this isn't done yet, something to do beyond NM2.0
    if ((desiredformat == VIDEO_FORMAT_INTELI420) &&
        ((*plpdsp)->biCompression != VIDEO_FORMAT_INTELI420)) {
        CConvertFrame *ccvt;

        if (ccvt = new CConvertFrame) {
            ccvt->AddRef();
            if (ccvt->InitConverter(lpcvt, convertproc, refdata)) {
                LocalFree((HANDLE)*plpdsp);
                *plpdsp = lpcvt;
                clast->m_next = (CFrameOp*)ccvt; // add FrameOp into chain
                clast = (CFrameOp*)ccvt;
            }
            else
                ccvt->Release();
        }
    }
#endif

#if 0
    if (((desiredformat == VIDEO_FORMAT_YVU9) &&
         ((*plpdsp)->biCompression != VIDEO_FORMAT_YVU9)) ||
        ((desiredformat == VIDEO_FORMAT_INTELI420) &&
         ((*plpdsp)->biCompression != VIDEO_FORMAT_INTELI420))) {
#else
    if (((desiredformat == VIDEO_FORMAT_YVU9) &&
        ((*plpdsp)->biCompression != VIDEO_FORMAT_YVU9)) ||
        ((desiredformat == VIDEO_FORMAT_YUY2) &&
        ((*plpdsp)->biCompression != VIDEO_FORMAT_YUY2)) ||
        ((desiredformat == VIDEO_FORMAT_UYVY) &&
        ((*plpdsp)->biCompression != VIDEO_FORMAT_UYVY)) ||
        ((desiredformat == VIDEO_FORMAT_I420) &&
        ((*plpdsp)->biCompression != VIDEO_FORMAT_I420)) ||
        ((desiredformat == VIDEO_FORMAT_IYUV) &&
        ((*plpdsp)->biCompression != VIDEO_FORMAT_IYUV))) {
#endif
        // attempt to instantiate an ICM CFrameOp
        CICMcvtFrame *cicm;

        if ((cicm = new CICMcvtFrame)) {
            cicm->AddRef();
            if (cicm->InitCvt(*plpdsp, lpcapsize, &lpcvt, desiredformat)) {
                clast->m_next = (CFrameOp*)cicm; // add ICM FrameOp into chain
                clast = (CFrameOp*)cicm;
                LocalFree((HANDLE)*plpdsp);
                *plpdsp = lpcvt;
            }
            else {
                cicm->Release();

                if (!*plpdsp)
				{
					ERRORMESSAGE(("%s: Failed to find a codec", _fx_));
				}
            }
        }
        else
		{
			ERRORMESSAGE(("%s: Failed to alloc codec object", _fx_));
		}
    }
#endif // SUPPORT_DESIRED_FORMAT

    {
        CConvertFrame *ccvt;
        FRAMECONVERTPROC *convertproc;
        LPVOID refdata;

#ifdef ENABLE_ZOOM_CODE
        BOOL attemptzoom;

        attemptzoom = TRUE;
#endif

        while (*plpdsp && (((*plpdsp)->biWidth != desiredwidth) ||
                           ((*plpdsp)->biHeight != desiredheight) ||
                           (((*plpdsp)->biCompression == BI_RGB) && ((*plpdsp)->biBitCount <= 8)))) {
            lpcvt = NULL;
#ifdef ENABLE_ZOOM_CODE
            if (attemptzoom) {
                InitScale(*plpdsp, desiredwidth, desiredheight, &lpcvt, &convertproc, &refdata);
                attemptzoom = FALSE;
            }
#endif
            if (!lpcvt) {
                if (((*plpdsp)->biWidth >= desiredwidth) && ((*plpdsp)->biHeight >= desiredheight)) {
                    // try to shrink
                    InitShrink(*plpdsp, desiredwidth, desiredheight, &lpcvt, &convertproc, &refdata);
                }
                else {
                    // try to blackbar
                    InitBlackbar(*plpdsp, desiredwidth, desiredheight, &lpcvt, &convertproc, &refdata);
                }
            }
            if (lpcvt) {
                if (ccvt = new CConvertFrame) {
                    ccvt->AddRef();
                    if (ccvt->InitConverter(lpcvt, convertproc, refdata)) {
                        LocalFree((HANDLE)*plpdsp);
                        *plpdsp = lpcvt;
                        clast->m_next = (CFrameOp*)ccvt; // add FrameOp into chain
                        clast = (CFrameOp*)ccvt;
                        continue;
                    }
                    else
                        ccvt->Release();
                }
            }
            else {
				ERRORMESSAGE(("%s: Can't convert", _fx_));
                LocalFree((HANDLE)*plpdsp);
                *plpdsp = NULL;
            }
        }
    }

    if (*plpdsp) {
        // allocate a placeholder for a filter chain
        if (cfilterchain = new CFilterChain) {
            cfilterchain->AddRef();
            // placeholder needs reference to a pool to pass to added filters
            if (clast->m_pool && clast->m_pool->Growable()) {
                cfilterchain->m_pool = clast->m_pool;
                cfilterchain->m_pool->AddRef();
            }
            else {
                if ((cfilterchain->m_pool = new CVidPool)) {
                    cfilterchain->m_pool->AddRef();
                    if (cfilterchain->m_pool->InitPool(2, *plpdsp) != NO_ERROR) {
						ERRORMESSAGE(("%s: Failed to init filter pool", _fx_));
                        cfilterchain->m_pool->Release();
                        cfilterchain->m_pool = NULL;
                    }
                }
                else
				{
					ERRORMESSAGE(("%s: Failed to alloc filter pool", _fx_));
				}
            }
            if (cfilterchain->m_pool) {
                clast->m_next = (CFrameOp*)cfilterchain; // add placeholder FrameOp into chain
                clast = (CFrameOp*)cfilterchain;
            }
            else {
                cfilterchain->Release();
                cfilterchain = NULL;
            }
        }

        if (m_opchain)
            m_opchain->Release();
        m_opchain = ccf;
        m_filterchain = cfilterchain;
        return NO_ERROR;
    }
    ccf->Release(); // discard partial chain
    return E_FAIL;
}

//  AddFilter
//      Adds a filter to the chain.  If hAfter is NULL, the filter is added
//      to the head of the chain.

STDMETHODIMP
CCaptureChain::AddFilter(
    CLSID* pclsid,
    LPBITMAPINFOHEADER lpbmhIn,
    HANDLE* phNew,
    HANDLE hAfter
    )
{
    HRESULT hres;
    IBitmapEffect *effect;
    CFilterFrame *cff;
    CFilterChain *chain;
    CFilterFrame *previous;

    if (m_filterchain) {
        m_filterchain->AddRef();    // lock chain from destruction

        // find insertion point
        previous = m_filterchain->m_head;
        if (hAfter) {
            while (previous && (previous->m_tag != hAfter))
                previous = (CFilterFrame*)previous->m_next;
            if (!previous) {
                // can't find hAfter, so fail call
                m_filterchain->Release();   // unlock m_filterchain
                return E_INVALIDARG;
            }
        }

        // load, init and link in new filter
        if (cff = new CFilterFrame) {
            cff->AddRef();
            if ((hres = LoadFilter(pclsid, &effect)) == NO_ERROR) {
                m_filterchain->m_pool->AddRef();
                if (cff->InitFilter(effect, lpbmhIn, m_filterchain->m_pool))
                    hres = NO_ERROR;
                else
                    hres = E_OUTOFMEMORY;
                m_filterchain->m_pool->Release();
                if (hres == NO_ERROR) {
                    cff->m_clsid = *pclsid;
                    cff->m_tag = (HANDLE)(++m_filtertags);
                    if (phNew)
                        *phNew = (HANDLE)cff->m_tag;

                    EnterCriticalSection(&m_capcs);
                    if (previous) {
                        cff->m_next = previous->m_next;
                        previous->m_next = cff;
                    }
                    else {
                        cff->m_next = m_filterchain->m_head;
                        m_filterchain->m_head = cff;
                    }
                    LeaveCriticalSection(&m_capcs);
                    m_filterchain->Release();
                    return NO_ERROR;
                }
            }
            cff->Release();
        }
        else
            hres = E_OUTOFMEMORY;
        m_filterchain->Release();   // unlock m_filterchain
        return hres;
    }
    return E_UNEXPECTED;
}

STDMETHODIMP
CCaptureChain::RemoveFilter(
    HANDLE hFilter
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CCaptureChain::DisplayFilterProperties(
    HANDLE hFilter,
    HWND hwndParent
    )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nmcap\filters.h ===
//  FILTERS.H
//
//      Headers for a simple C-callable filter manager
//
//  Created 15-Jan-97 [JonT]

#ifndef __filters_h__
#define __filters_h__

// This file and interfaces contained here will be used by both C and C++

#include <ibitmap.h>
#include <effect.h>

// Equates
#define MAX_FILTER_NAME     256

// Types

typedef struct _FINDFILTER
{
    CLSID clsid;
    char szFilterName[MAX_FILTER_NAME];
    DWORD_PTR dwReserved;
} FINDFILTER;

// Prototypes

HRESULT     FindFirstRegisteredFilter(FINDFILTER* pFF);
HRESULT     FindNextRegisteredFilter(FINDFILTER* pFF);
HRESULT     FindCloseRegisteredFilter(FINDFILTER* pFF);
HRESULT     GetRegisteredFilterCount(LONG* plCount);
HRESULT     GetDescriptionOfFilter(CLSID* pCLSID, char* pszDescription);
HRESULT     LoadFilter(CLSID* pCLSID, IBitmapEffect** ppbe);

#endif  // __filters_h__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nmcap\filters.cpp ===
//  FILTERS.CPP
//
//      Test code for filter chains
//
//  Created 17-Jan-97 [JonT] (by adapting original vftest code by RichP)

#include <windows.h>
#include <comcat.h>
#include <ocidl.h>
#include <olectl.h>
#include "filters.h"

//--------------------------------------------------------------------
//  Filter manager code

typedef struct tagFILTERINFO* PFILTERINFO;
typedef struct tagFILTERINFO
{
    IBitmapEffect *pbe;
    CLSID clsid;
    TCHAR szFilterName[MAX_FILTER_NAME];
    DWORD dwFlags;
} FILTERINFO;

#define ERROREXIT(s,hrFail) \
    {   hr = (hrFail); \
        OutputDebugString(TEXT("VFTEST:"##s##"\r\n")); \
        goto Error; }


void
StringFromGUID(
    const CLSID* piid,
    LPTSTR pszBuf
    )
{
    wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), piid->Data1,
            piid->Data2, piid->Data3, piid->Data4[0], piid->Data4[1], piid->Data4[2],
            piid->Data4[3], piid->Data4[4], piid->Data4[5], piid->Data4[6], piid->Data4[7]);
}


//  FindFirstRegisteredFilter
//      Returns info on the first registered filter

HRESULT
FindFirstRegisteredFilter(
    FINDFILTER* pFF
    )
{
    HRESULT hr;
    IEnumGUID* penum;
    ICatInformation* pci;

    // Get the Component Category interface
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatInformation, (void**)&pci);
	if (FAILED(hr))
        ERROREXIT("Couldn't get IID_ICatInformation from StdComponentCategoriesMgr", E_UNEXPECTED);

    // Get the enumerator for the filter category
    hr = pci->EnumClassesOfCategories(1, (GUID*)&CATID_BitmapEffect, 0, NULL, &penum);
    pci->Release();
    if (FAILED(hr))
        ERROREXIT("Couldn't get enumerator for CATID_BitmapEffect", E_UNEXPECTED);

    // Save away the enumerator for the findnext/close
    pFF->dwReserved = (DWORD_PTR)penum;

    // Use FindNext to get the information (it only needs dwReserved to be set)
    return FindNextRegisteredFilter(pFF);

Error:
    return hr;
}


//  FindNextRegisteredFilter
//      Returns info on the next registered filter

HRESULT
FindNextRegisteredFilter(
    FINDFILTER* pFF
    )
{
    ULONG ulGUIDs;
    IEnumGUID* penum = (IEnumGUID*)pFF->dwReserved;

    // Use the enumerator to get the CLSID
    if (FAILED(penum->Next(1, &pFF->clsid, &ulGUIDs)) || ulGUIDs != 1)
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);

    // Read and return the description
    return GetDescriptionOfFilter(&pFF->clsid, pFF->szFilterName);
}


//  FindCloseRegisteredFilter
//      Signals done with findfirst/next on registered filters so we
//      can free resources

HRESULT
FindCloseRegisteredFilter(
    FINDFILTER* pFF
    )
{
    IEnumGUID* penum = (IEnumGUID*)pFF->dwReserved;

    // Simply free the enumerator
    if (penum)
        penum->Release();

    return NO_ERROR;
}


//  GetRegisteredFilterCount
//      Counts the number of registered filters.
//      The caller of this routine should still be careful for the possibility
//      of filters being installed between this count being made and the findfirst/next.

HRESULT
GetRegisteredFilterCount(
    LONG* plCount
    )
{
    HRESULT hr;
    IEnumGUID* penum = NULL;
    ICatInformation* pci;
    ULONG ulGUIDs;
    CLSID clsid;

    // Get the Component Category interface
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatInformation, (void**)&pci);
	if (FAILED(hr))
        ERROREXIT("Couldn't get IID_ICatInformation from StdComponentCategoriesMgr", E_UNEXPECTED);

    // Get the enumerator for the filter category
    hr = pci->EnumClassesOfCategories(1, (GUID*)&CATID_BitmapEffect, 0, NULL, &penum);
    pci->Release();
    pci = NULL;
    if (FAILED(hr))
        ERROREXIT("Couldn't get enumerator for CATID_BitmapEffect", E_UNEXPECTED);

    // Use the enumerator to walk through and count the items
    *plCount = 0;
    while (TRUE)
    {
        if (FAILED(penum->Next(1, &clsid, &ulGUIDs)) || ulGUIDs != 1)
            break;
        (*plCount)++;
    }
    penum->Release();
    return NO_ERROR;

Error:
    return hr;
}


//  LoadFilter
HRESULT
LoadFilter(
    CLSID* pclsid,
    IBitmapEffect** ppbe
    )
{
    HRESULT hr;

    // Load the filter
    if (FAILED(CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_SERVER, IID_IBitmapEffect, (LPVOID*)ppbe)))
        ERROREXIT("CoCreateInstance on filter failed", E_UNEXPECTED);

    return NO_ERROR;

Error:
    return hr;
}


#if 0
//  GetFilterInterface
//      Returns the filter's status flags

HRESULT
GetFilterStatusBits(
    HANDLE* hFilter,
    DWORD *status
    )
{
    *status = ((PFILTERINFO)hFilter)->dwFlags;
    return NO_ERROR;
}


//  GetFilterInterface
//      Returns an IUnknown pointer for the given handle.
//      The caller must release this pointer.

HRESULT
GetFilterInterface(
    HANDLE hFilter,
    void** ppvoid
    )
{
    return ((PFILTERINFO)hFilter)->pbe->QueryInterface(IID_IUnknown, ppvoid);
}
#endif

//  GetDescriptionOfFilter
//      Returns the description of a filter from the CLSID

HRESULT
GetDescriptionOfFilter(
    CLSID* pCLSID,
    char* pszDescription
    )
{
    HRESULT hr;
    const TCHAR szCLSID[] = TEXT("CLSID");
    HKEY hkCLSID;
    HKEY hkGUID;
    TCHAR szGUID[80];
    unsigned err;
    LONG len;

    if (RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hkCLSID) == ERROR_SUCCESS)
    {
        StringFromGUID(pCLSID, szGUID);
        err = RegOpenKey(hkCLSID, szGUID, &hkGUID);
        RegCloseKey(hkCLSID);
        if (err == ERROR_SUCCESS)
        {
            len = MAX_FILTER_NAME;
            err = RegQueryValue(hkGUID, NULL, pszDescription, &len);
            RegCloseKey(hkGUID);
            if (err != ERROR_SUCCESS)
                ERROREXIT("Couldn't read value associated with filter GUID", E_UNEXPECTED);
        }
    }
    else
        ERROREXIT("Couldn't open HKEY_CLASSES_ROOT!", E_UNEXPECTED);

    return NO_ERROR;

Error:
    return hr;
}


#if 0
#define MAX_PAGES   20      // Can't have more than this many pages in frame (arbitrary)

//  DisplayFilterProperties
//      Displays the property pages for a filter

HRESULT
DisplayFilterProperties(
    HANDLE hFilter,
    HWND hwndParent
    )
{
    PFILTERINFO pfi = (PFILTERINFO)hFilter;
    CLSID clsidTable[MAX_PAGES];
    LONG lcCLSIDs;
    IUnknown* punk;
    ISpecifyPropertyPages* pspp;
    CAUUID cauuid;
    HRESULT hr;

    // Make sure the object supports property pages. If not, just bail
    if (FAILED(pfi->pbe->QueryInterface(IID_ISpecifyPropertyPages, (void**)&pspp)))
        return ERROR_NOT_SUPPORTED;

    // Get the page CLSIDs
    pspp->GetPages(&cauuid);
    lcCLSIDs = cauuid.cElems;
    if (lcCLSIDs > MAX_PAGES)
        lcCLSIDs = MAX_PAGES;
    memcpy(clsidTable, cauuid.pElems, lcCLSIDs * sizeof (CLSID));
    CoTaskMemFree(cauuid.pElems);
    pspp->Release();

    // Get the IUnknown we need
    pfi->pbe->QueryInterface(IID_IUnknown, (void**)&punk);

    hr = OleCreatePropertyFrame(hwndParent, 0, 0, L"Filter",
        1, &punk, lcCLSIDs, clsidTable,
        MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT), SORT_DEFAULT),
        0, NULL);

    // Clean up
    punk->Release();

    return hr;
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nmcap\mydebug.h ===
#ifndef _MYDEBUG_H
#define _MYDEBUG_H

#include <windows.h>
#include <confdbg.h>
#include <avutil.h>

#include "..\nac\utils.h"

#endif //_MYDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nmcap\frameop.h ===
#include <windows.h>
#include <vfw.h>
#include <dcap.h>
#include "vidpool.h"
#include "effect.h"

#ifndef _FRAMEOP_H
#define _FRAMEOP_H

class CFrameOp
{
private:
    LONG m_cRef;

public:
    CFrameOp *m_next;
    CVidPool *m_pool;

    CFrameOp() {m_cRef = 0; m_next = NULL; m_pool = NULL; }
    virtual ~CFrameOp() {};

    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP DoOp(IBitmapSurface** ppbs) = 0;
};

class CCaptureFrame :
    public CFrameOp
{
private:
    HCAPDEV m_hcapdev;
    HFRAMEBUF m_hbuf1;
    HFRAMEBUF m_hbuf2;

public:
    CCaptureFrame() { m_hcapdev = NULL; m_hbuf1 = NULL; m_hbuf2 = NULL; }
    ~CCaptureFrame();

    STDMETHODIMP DoOp(IBitmapSurface** ppbs);

    BOOL InitCapture(HCAPDEV hcapdev, LPBITMAPINFOHEADER lpbmh);
};

class CStreamCaptureFrame :
    public CFrameOp
{
private:
    HCAPDEV m_hcapdev;

public:
    CStreamCaptureFrame() { m_hcapdev = NULL; }
    ~CStreamCaptureFrame();

    STDMETHODIMP DoOp(IBitmapSurface** ppbs);

    BOOL InitCapture(HCAPDEV hcapdev, LPBITMAPINFOHEADER lpbmh);
};

class CICMcvtFrame :
    public CFrameOp
{
private:
    HIC m_hic;
    LPBITMAPINFOHEADER m_inlpbmh;
    LPBITMAPINFOHEADER m_outlpbmh;

public:
    CICMcvtFrame() { m_hic = NULL; m_inlpbmh = NULL; m_outlpbmh = NULL; }
    ~CICMcvtFrame();

    STDMETHODIMP DoOp(IBitmapSurface** ppbs);

    BOOL InitCvt(LPBITMAPINFOHEADER lpbmh, DWORD bmhLen,
                 LPBITMAPINFOHEADER *plpbmhdsp);
        // if TRUE, then plpbmhdsp will point to allocated memory that the caller will
        // be responsible for deallocating
        // if FALSE, then plpbmhdsp will point to a copy lpbmh, if no conversion necessary,
        //      else it will be NULL to indicate that converion is not possible
};


class CFilterFrame :
    public CFrameOp
{
private:
    IBitmapEffect *m_effect;
    BOOL m_inplace;

public:
    CLSID m_clsid;
    HANDLE m_tag;
    BOOL m_enabled;

    CFilterFrame() { m_effect = NULL; m_inplace = TRUE; m_enabled = TRUE; m_tag = 0; }
    ~CFilterFrame();

    STDMETHODIMP DoOp(IBitmapSurface** ppbs);

    BOOL InitFilter(IBitmapEffect *effect, LPBITMAPINFOHEADER lpbmhIn, CVidPool *pool);
};

class CFilterChain :
    public CFrameOp
{
private:

public:
    CFilterFrame *m_head;

    CFilterChain() { m_head = NULL; }
    ~CFilterChain();

    STDMETHODIMP DoOp(IBitmapSurface** ppbs);
};

typedef BOOL (FRAMECONVERTPROC) (IBitmapSurface*, IBitmapSurface*, LPVOID);

class CConvertFrame :
    public CFrameOp
{
private:
    FRAMECONVERTPROC *m_convert;
    LPVOID m_refdata;

public:
    CConvertFrame() { m_convert = NULL; m_refdata = NULL; }
    ~CConvertFrame();

    STDMETHODIMP DoOp(IBitmapSurface** ppbs);

    BOOL InitConverter(LPBITMAPINFOHEADER lpbmh, FRAMECONVERTPROC *convertproc, LPVOID refdata);
};

#endif // #ifndef _FRAMEOP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nmcap\ividpool.h ===
//  IVIDPOOL.H
//
//      Contains the interfaces IVidPool
//
//  Created 17-Jan-97 [RichP]

#ifndef _IVIDPOOL_H
#define _IVIDPOOL_H

// IIDs
// {36447652-7089-11d0-BC25-00AA00A13C86}
DEFINE_GUID(IID_IVidPool, 0x36447652, 0x7089, 0x11d0, 0xbc, 0x25, 0x0, 0xaa, 0x0, 0xa1, 0x3c, 0x86);

// Interfaces

#undef  INTERFACE
#define INTERFACE   IVidPool

DECLARE_INTERFACE_(IVidPool, IBitmapSurfaceFactory)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IBitmapSurfaceFactory methods
    STDMETHOD(CreateBitmapSurface)(THIS_ long width, long height, BFID* pBFID, DWORD dwHintFlags, IBitmapSurface** ppBitmapSurface) PURE;
	STDMETHOD(GetSupportedFormatsCount)(THIS_ long* pcFormats) PURE;
	STDMETHOD(GetSupportedFormats)(THIS_ long cFormats, BFID* pBFIDs) PURE;

	// IVidPool methods
	STDMETHOD(InitPool)(THIS_ int nBuffers, BFID* format, long size, int pitch) PURE;
	STDMETHOD(AddExternalBuffer)(THIS_ void* pBits, int pitch, void* refdata) PURE;
    STDMETHOD(InvalidatePool)(void) PURE;
	STDMETHOD(GetBuffer)(THIS_ IBitmapSurface** ppBitmapSurface, void** prefdata) PURE;
};

#endif // #ifndef _IVIDPOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\qos\debug.cpp ===
/*
 -  DEBUG.CPP
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	Debug code
 *
 *      Revision History:
 *
 *      When		Who                 What
 *      --------	------------------  ---------------------------------------
 *      10.23.96	Yoram Yaacovi       Created
 *      01.04.97	Robert Donner       Added NetMeeting utility routines
 *		01.09.97	Yoram Yaacovi		Added DisplayRequestList
 *
 *	Functions:
 *		DisplayQoSObject
 *		DisplayRequestList
 *		DisplayRequestListInt
 *
 */

#include "precomp.h"

#ifdef DEBUG

int QoSDbgPrintf(LPCSTR lpszFormat, ...)
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("QoS:", lpszFormat, v1);
	va_end(v1);

	return 0;
}

/***************************************************************************

    Name      : DisplayParameters

    Purpose   : Displays parameters of a given function

    Parameters: nFunctionID - ID of the function for which to display parameters
				p1 - p5: up to 5 32-bit function parameters

	Returns   :

    Comment   :
***************************************************************************/
void CQoS::DisplayParameters(ULONG nFunctionID, ULONG_PTR p1, ULONG_PTR p2, ULONG_PTR p3, ULONG_PTR p4, ULONG_PTR p5)
{
	BOOL fDisplay=FALSE;
	TCHAR szGuid[40 /* CCHSZGUID */];

	fDisplay = (m_bInNotify ?
				(ZONE_THREAD && ZONE_PARAMETERS) :
				ZONE_PARAMETERS);

	if (!fDisplay)
		return;

	switch (nFunctionID)
	{
		case REQUEST_RESOURCES_ID:
			GuidToSz((LPGUID) p1 /* lpClientGUID */, szGuid);
			DEBUGMSG(fDisplay, ("Client: %s\n", szGuid));
			DisplayRequestList((LPRESOURCEREQUESTLIST) p2 /* lpResourceRequestList */);
			break;

		case RELEASE_RESOURCES_ID:
			GuidToSz((LPGUID) p1 /* lpClientGUID */, szGuid);
			DEBUGMSG(fDisplay, ("Client: %s\n", szGuid));
			DisplayRequestList((LPRESOURCEREQUESTLIST) p2 /* lpResourceRequestList */);
			break;

		case SET_RESOURCES_ID:
			DisplayResourceList((LPRESOURCELIST) p1 /* lpResourceList */);
			break;

		case SET_CLIENTS_ID:
			DisplayClientList((LPCLIENTLIST) p1 /* lpClientList */);
			break;

		default:
			break;
	}
}

/***************************************************************************

    Name      : DisplayClientList

    Purpose   : Displays a client list given a pointer to the list

    Parameters: pCl - pointer to the list

	Returns   :

    Comment   :
***************************************************************************/
void CQoS::DisplayClientList(LPCLIENTLIST pcl)
{
	BOOL fDisplay=FALSE;
	ULONG i=0;
	LPCLIENT pc=NULL;
	TCHAR szGuid[40 /* CCHSZGUID */];
	char szNoName[]="No Name";
	PSTR pszClientName=szNoName;

	fDisplay = (m_bInNotify ? (ZONE_THREAD && ZONE_PARAMETERS) : ZONE_PARAMETERS);

	DEBUGMSG(fDisplay, ("Number of clients: %d\n", pcl->cClients));
	DEBUGMSG(fDisplay, ("Client              priority  GUID\n"));

	for (i=0; i < pcl->cClients; i++)
	{
		pc = &(pcl->aClients[i]);
		GuidToSz(&(pc->guidClientGUID), szGuid);

		// assuming DEBUGMSG always prints non-Unicode
		if (*(pc->wszName) && (pszClientName = UnicodeToAnsi(pc->wszName)))
		{
			// display the client	
			DEBUGMSG(fDisplay, (" %-20s%-9d %s",
								pszClientName,
								pc->priority,
								szGuid));
			delete pszClientName;
		}
		else
		{
			pszClientName = szNoName;
			// display the client	
			DEBUGMSG(fDisplay, ("   %-20s%-9d %s",
								pszClientName,
								pc->priority,
								szGuid));
		}
	}
}

/***************************************************************************

    Name      : DisplayResourceList

    Purpose   : Displays a resource list given a pointer to the list

    Parameters: prl - pointer to the list

	Returns   :

    Comment   :
***************************************************************************/
void CQoS::DisplayResourceList(LPRESOURCELIST prl)
{
	BOOL fDisplay=FALSE;
	ULONG i=0;
	LPRESOURCE pr=NULL;

	fDisplay = (m_bInNotify ? (ZONE_THREAD && ZONE_PARAMETERS) : ZONE_PARAMETERS);
	
	DEBUGMSG(fDisplay, ("Number of resources: %d\n", prl->cResources));
	DEBUGMSG(fDisplay, ("Resource  Flags   MinUnits MaxUnits Level hResult\n"));

	for (i=0; i < prl->cResources; i++)
	{
		pr = &(prl->aResources[i]);

		// display the resource	
		DEBUGMSG(fDisplay, ("   %-10d%-8x%-9d",
							pr->resourceID,
							pr->ulResourceFlags,
							pr->nUnits));
		
	}
}

/***************************************************************************

    Name      : DisplayRequestList

    Purpose   : Displays a request list given a pointer to the list

    Parameters: prrl - pointer to the list

	Returns   :

    Comment   :
***************************************************************************/
void CQoS::DisplayRequestList(LPRESOURCEREQUESTLIST prrl)
{
	BOOL fDisplay=FALSE;
	ULONG i=0;
	LPRESOURCEREQUEST prr=NULL;

	fDisplay = (m_bInNotify ? (ZONE_THREAD && ZONE_PARAMETERS) : ZONE_PARAMETERS);
	
	DEBUGMSG(fDisplay, ("Number of requests: %d\n", prrl->cRequests));
	DEBUGMSG(fDisplay, ("Resource  Flags   MinUnits MaxUnits Level hResult\n"));

	for (i=0; i < prrl->cRequests; i++)
	{
		prr = &(prrl->aRequests[i]);

		// display the resource	
		DEBUGMSG(fDisplay, ("   %-10d%-8x%-9d%-9d%-6d%-8x",
							prr->resourceID,
							prr->ulRequestFlags,
							prr->nUnitsMin,
							prr->nUnitsMax,
							prr->levelOfGuarantee,
							prr->hResult));
		
	}
}

/***************************************************************************

    Name      : DisplayRequestListInt

    Purpose   : Displays an internal request list given a pointer to the list

    Parameters: prr - pointer to the first request in the list
				fDisplay - a flag to tell DisplayRequestListInt whether to display
					or no. This might seem dumb, since why call DisplayRequestListInt
					if it's not going to display, but this parameter really conveys
					the zone information that thcaller wants.

	Returns   :

    Comment   :
***************************************************************************/
void CQoS::DisplayRequestListInt(LPRESOURCEREQUESTINT prr, BOOL fDisplay)
{
	TCHAR szGuid[40 /* CCHSZGUID */];

	while (prr)
	{
		GuidToSz(&(prr->guidClientGUID), szGuid);

		// display the resource	
		DEBUGMSG(fDisplay, ("   %-10x%-10x%-10d%-8x%-6d%-7d%-11x %s",
							prr,
							prr->fLink,
							prr->sResourceRequest.resourceID,
							prr->sResourceRequest.ulRequestFlags,
							prr->sResourceRequest.levelOfGuarantee,
							prr->sResourceRequest.nUnitsMin,
							prr->pfnQoSNotify,
							szGuid));
		
		// next request
		prr = prr->fLink;
	}
}

/***************************************************************************

    Name      : DisplayQoSObject

    Purpose   : Displays the containing QoS object

    Parameters: none

	Returns   : none

    Comment   :
***************************************************************************/
void CQoS::DisplayQoSObject(void)
{
	LPRESOURCEINT pr=NULL;
	LPRESOURCEREQUESTINT prr=NULL;
	LPCLIENTINT pc=NULL;
	BOOL fDisplay=FALSE;

	// don't waste time if we are not going to print
	fDisplay = (m_bInNotify ? (ZONE_THREAD && ZONE_STRUCTURES) : ZONE_STRUCTURES);
	if (!fDisplay)
		return;

	DEBUGMSG(fDisplay, ("Start object display\n"));
	DEBUGMSG(fDisplay, ("=========================================\n"));

	/*
	 *	Print resources and requests
	 */
	DEBUGMSG(fDisplay, ("Resources\n"));
	DEBUGMSG(fDisplay, ("*********\n"));
	pr = m_pResourceList;
	if (!pr)
	{
		DEBUGMSG(fDisplay, ("No Resources\n"));
	}
	else
	{
		DEBUGMSG(fDisplay, ("Address   fLink     Resource  Flags   Units  Avail\n"));
		DEBUGMSG(fDisplay, ("   Address   fLink     Resource  Flags   Level Units  NotifyProc Client GUID\n"));
	}
	while (pr)
	{
		// display the resource	
		DEBUGMSG(fDisplay, ("Resource: %d\n", pr->resource.resourceID));
		DEBUGMSG(fDisplay, ("%-10x%-10x%-10d%-8x%-7d%-7d\n",
							pr,
							pr->fLink,
							pr->resource.resourceID,
							pr->resource.ulResourceFlags,
							pr->resource.nUnits,
							pr->nNowAvailUnits));

		// display the request list for this reasource
		prr = pr->pRequestList;
		DisplayRequestListInt(prr, fDisplay);			

		//next resource
		pr = pr->fLink;
	}

	/*
	 *	Print clients
	 */
	DEBUGMSG(fDisplay, ("\n"));
	DEBUGMSG(fDisplay, ("Clients\n"));
	DEBUGMSG(fDisplay, ("*******\n"));
	pc = m_pClientList;
	if (!pc)
	{
		DEBUGMSG(fDisplay, ("No Clients\n"));
	}
	else
	{
		DEBUGMSG(fDisplay, ("Address   fLink     Priority\n"));
		DEBUGMSG(fDisplay, ("   Address   fLink     Resource  Flags   Level Units  NotifyProc Client GUID\n"));
	}
	while (pc)
	{
		TCHAR szGuid[40 /* CCHSZGUID */];
		PSTR pszClientName=NULL;
		
		GuidToSz(&(pc->client.guidClientGUID), szGuid);

		// update the list of requests for this client
		// doing this if in the notify thread is bad !!
		if (!m_bInNotify)
			UpdateRequestsForClient (&(pc->client.guidClientGUID));

		// display the client
		// assuming DEBUGMSG always prints non-Unicode
		if (*(pc->client.wszName)	&&
			(pszClientName = UnicodeToAnsi(pc->client.wszName)))
		{
			DEBUGMSG(fDisplay, ("Client: %s   %s", pszClientName, szGuid));
			delete pszClientName;
		}
		else
		{
			DEBUGMSG(fDisplay, ("Client: %s", szGuid));
		}

		DEBUGMSG(fDisplay, ("%-10x%-10x%-10d",
				pc, pc->fLink, pc->client.priority));
				
		// display the request list for this reasource
		prr = pc->pRequestList;
		DisplayRequestListInt(prr, fDisplay);			

		//next resource
		pc = pc->fLink;
	}

	
	
	DEBUGMSG(fDisplay, ("=========================================\n"));
	DEBUGMSG(fDisplay, ("End object display\n"));
}

#else	// DEBUG

void CQoS::DisplayQoSObject(void)
{}
void CQoS::DisplayRequestList(LPRESOURCEREQUESTLIST)
{}
void CQoS::DisplayRequestListInt(LPRESOURCEREQUESTINT, BOOL)
{}
void CQoS::DisplayResourceList(LPRESOURCELIST prl)
{}
void CQoS::DisplayParameters(ULONG nFunctionID, ULONG_PTR P1, ULONG_PTR P2, ULONG_PTR P3, ULONG_PTR P4, ULONG_PTR P5)
{}

#endif	// DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nmcap\vidpool.h ===
#include <windows.h>
#include "ibitmap.h"

#ifndef _VIDPOOL_H
#define _VIDPOOL_H

// {36447655-7089-11d0-BC25-00AA00A13C86}
DEFINE_GUID(BFID_PRIVATEDIB, 0x36447655, 0x7089, 0x11d0, 0xbc, 0x25, 0x0, 0xaa, 0x0, 0xa1, 0x3c, 0x86);

class CVidPool;

class CBitmap :
	public IBitmapSurface
{
private:
    LONG m_cRef;

public:
    LPBYTE m_bits;
    LONG m_pitch;
    int m_lockcount;
    BOOL m_ext;
    CBitmap* m_next;
    CVidPool* m_factory;
    void *m_refdata;

    CBitmap() {m_cRef = 0; m_bits = NULL; m_pitch = 0; m_lockcount = 0; m_ext = FALSE;
               m_next = NULL; m_factory = NULL; m_refdata = NULL;}

    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IBitmapSurface methods
	virtual STDMETHODIMP Clone(IBitmapSurface** ppBitmapSurface);
	virtual STDMETHODIMP GetFormat(BFID* pBFID);
	virtual STDMETHODIMP GetFactory(IBitmapSurfaceFactory** ppBitmapSurfaceFactory);
	virtual STDMETHODIMP GetSize(long* pWidth, long* pHeight);
	virtual STDMETHODIMP LockBits(RECT* prcBounds, DWORD dwLockFlags, void** ppBits, long* pPitch);
	virtual STDMETHODIMP UnlockBits(RECT* prcBounds, void* pBits);
};


typedef void (NotifyAddingToFreeProc) (CBitmap *pBitmap, DWORD_PTR refdata);

class CVidPool :
	public IBitmapSurfaceFactory
{
private:
    LONG m_cRef;
    BOOL m_growable;
    LONG m_nbufs;
    CBitmap* m_free;
    int m_pitch;
    BFID* m_format;
    CRITICAL_SECTION m_cs;
    LPBITMAPINFOHEADER m_pbmh;

public:
    NotifyAddingToFreeProc *m_pAddingToFree;
    DWORD_PTR m_refdata;

    CVidPool(void);

    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IBitmapSurfaceFactory methods
    virtual STDMETHODIMP CreateBitmapSurface(long width, long height, BFID* pBFID, DWORD dwHintFlags, IBitmapSurface** ppBitmapSurface);
	virtual STDMETHODIMP GetSupportedFormatsCount(long* pcFormats);
	virtual STDMETHODIMP GetSupportedFormats(long cFormats, BFID* pBFIDs);

	// private to implementation of CVidPool
	STDMETHODIMP InitPool(int nBuffers, LPBITMAPINFOHEADER lpcap);
	STDMETHODIMP AddExternalBuffer(void* pBits, void* refdata);
	STDMETHODIMP GetBuffer(CBitmap** ppBitmap, void** prefdata);
	STDMETHODIMP GetBuffer(IBitmapSurface** ppBitmap, void** prefdata);

	void AddToFreeList(CBitmap* pBitmap);

    BOOL Growable(void) { return m_growable; }
	BFID* GetFormat(void) {return m_format;}
	long GetWidth(void) { if (m_pbmh)
	                        return m_pbmh->biWidth;
	                      else
	                        return 0; }
	long GetHeight(void) { if (m_pbmh)
	                         return m_pbmh->biHeight;
	                       else
	                         return 0; }
};

#endif // #ifndef _VIDPOOL_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nmcap\frameop.cpp ===
#include <windows.h>
#include <qos.h>
#include <winsock2.h>
#include "frameop.h"
#include <confdbg.h>
#include <avutil.h>
#include "..\nac\utils.h"
#include "vidinout.h"
#include "vcmstrm.h"


#ifdef DEBUG
extern "C" BOOL g_framedebug = TRUE;
#endif

// Base class methods
STDMETHODIMP_(ULONG)
CFrameOp::AddRef(
    void
    )
{
	FX_ENTRY("CFrameOp::AddRef");

	DEBUGMSG(ZONE_NMCAP_REFCOUNT,("%s: refcnt+(0x%08lX [CFrameOp])=%d\r\n", _fx_, this, m_cRef+1));

    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CFrameOp::Release(
    void
    )
{
    LONG res;

	FX_ENTRY("CFrameOp::Release");

	DEBUGMSG(ZONE_NMCAP_REFCOUNT,("%s: refcnt-(0x%08lX [CFrameOp])=%d\r\n", _fx_, this, m_cRef-1));

    res = InterlockedDecrement(&m_cRef);
    if (res == 0) {
        if (m_pool) {
            m_pool->Release();
        }
        if (m_next)
            m_next->Release();

		DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: deleting (0x%08lX [CFrameOp])\r\n", _fx_, this));

        delete this;
    }
    return res;
}

// CCaptureFrame methods
CCaptureFrame::~CCaptureFrame(
    )
{
    if (m_hbuf1)
        FreeFrameBuffer(m_hcapdev, m_hbuf1);
    if (m_hbuf2)
        FreeFrameBuffer(m_hcapdev, m_hbuf2);
}

STDMETHODIMP
CCaptureFrame::DoOp(
    IBitmapSurface** ppbs
    )
{
    HFRAMEBUF hbuf;
    BYTE* pBits;

    m_pool->GetBuffer(ppbs, &hbuf);
    if (*ppbs) {
        pBits = CaptureFrame(m_hcapdev, hbuf);
        return NO_ERROR;
    }
    return E_OUTOFMEMORY;
}

BOOL
CCaptureFrame::InitCapture(
    HCAPDEV hcapdev,
    LPBITMAPINFOHEADER lpbmh
    )
{
	FX_ENTRY("CCaptureFrame::InitCapture");

    if ((m_hbuf1 = AllocFrameBuffer(hcapdev)) &&
        (m_hbuf2 = AllocFrameBuffer(hcapdev))) {
        if ((m_pool = new CVidPool)) {
            m_pool->AddRef();

            if (m_pool->InitPool(0, lpbmh) == NO_ERROR) {
  	            m_pool->AddExternalBuffer(GetFrameBufferPtr(hcapdev, m_hbuf1), (void*)m_hbuf1);
                m_pool->AddExternalBuffer(GetFrameBufferPtr(hcapdev, m_hbuf2), (void*)m_hbuf2);
                m_hcapdev = hcapdev;
				DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: init capture (0x%08lX [CCaptureFrame])\r\n", _fx_, this));
                return TRUE;
            }
            else {
				ERRORMESSAGE(("%s: Failed to init capture pool", _fx_));
                m_pool->Release();
            }
        }
        else
		{
			ERRORMESSAGE(("%s: Failed to alloc capture pool", _fx_));
		}
        FreeFrameBuffer(hcapdev, m_hbuf2);
    }
    else
	{
		ERRORMESSAGE(("%s: Failed to allocate frame buffer", _fx_));
	}

    if (m_hbuf1)
        FreeFrameBuffer(hcapdev, m_hbuf1);
    return FALSE;
}


// CStreamCaptureFrame methods
CStreamCaptureFrame::~CStreamCaptureFrame(
    )
{
    StopStreaming(m_hcapdev);
    UninitializeStreaming(m_hcapdev);
}

STDMETHODIMP
CStreamCaptureFrame::DoOp(
    IBitmapSurface** ppbs
    )
{
    long pitch;
    CAPFRAMEINFO cfi;
    CBitmap *pcb;

	FX_ENTRY ("CStreamCaptureFrame::DoOp")

    m_pool->GetBuffer(&pcb, NULL);
    if (pcb) {
        if (pcb->m_bits) {
            PutBufferIntoStream(m_hcapdev, (BYTE*)pcb->m_bits);
            pcb->m_bits = NULL;
        }
        GetNextReadyBuffer(m_hcapdev, &cfi);
        if (pcb->m_bits = (LPBYTE)cfi.lpData) {
            *ppbs = (IBitmapSurface*)pcb;
            return NO_ERROR;
        }
		DEBUGMSG(ZONE_NMCAP_STREAMING,("%s: Failed to get buffer from DCAP\r\n", _fx_));
        pcb->Release();
    }
    *ppbs = NULL;
    return E_OUTOFMEMORY;
}

void GiveBufferToDriver (CBitmap *pBitmap, DWORD_PTR refdata)
{
    if (pBitmap->m_bits && refdata) {
        PutBufferIntoStream((HCAPDEV)refdata, (BYTE*)pBitmap->m_bits);
        pBitmap->m_bits = NULL;
    }
}

BOOL
CStreamCaptureFrame::InitCapture(
    HCAPDEV hcapdev,
    LPBITMAPINFOHEADER lpbmh
    )
{
    CAPSTREAM cs;
    CAPFRAMEINFO cfi;

	FX_ENTRY("CStreamCaptureFrame::InitCapture");

    // Initialize streaming
    cs.dwSize = sizeof (CAPSTREAM);
    cs.nFPSx100 = 30 * 100;
    cs.ncCapBuffers = 5;
    if (InitializeStreaming(hcapdev, &cs, 0)) {
        if (StartStreaming(hcapdev)) {
            if (WaitForSingleObject(cs.hevWait, 5000) != WAIT_TIMEOUT) {
                if ((m_pool = new CVidPool)) {
                    m_pool->AddRef();

                    if (m_pool->InitPool(0, lpbmh) == NO_ERROR) {
                        m_pool->m_pAddingToFree = &GiveBufferToDriver;
                        m_pool->m_refdata = (DWORD_PTR)hcapdev;
                        m_pool->AddExternalBuffer(NULL, (void*)1);
                        m_pool->AddExternalBuffer(NULL, (void*)2);
                        m_hcapdev = hcapdev;
						DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: init stream capture (0x%08lX [CStreamCaptureFrame])\r\n", _fx_, this));
                        return TRUE;
                    }
                    else
					{
						ERRORMESSAGE(("%s: Failed to init capture pool", _fx_));
                        m_pool->Release();
                    }
                }
                else
				{
					ERRORMESSAGE(("%s: Failed to alloc capture pool", _fx_));
				}
            }
            else
			{
				ERRORMESSAGE(("%s: Error no frame events received", _fx_));
			}
        }
        else
		{
			ERRORMESSAGE(("%s: Error starting streaming", _fx_));
		}
        UninitializeStreaming(hcapdev);
    }
    else
	{
		ERRORMESSAGE(("%s: Error initializing streaming", _fx_));
	}
    return FALSE;
}


// CICMcvtFrame methods
CICMcvtFrame::~CICMcvtFrame(
    )
{
    if (m_hic) {
        ICDecompressEnd(m_hic);
        ICClose(m_hic);
    }
    if (m_inlpbmh)
        LocalFree((HANDLE)m_inlpbmh);
    if (m_outlpbmh)
        LocalFree((HANDLE)m_outlpbmh);
}

STDMETHODIMP
CICMcvtFrame::DoOp(
    IBitmapSurface** ppbs
    )
{
    BYTE* pBits;
    BYTE* pCvtBits;
    long pitch;
    IBitmapSurface *pBS;

    m_pool->GetBuffer(&pBS, NULL);
    if (pBS) {
        (*ppbs)->LockBits(NULL, 0, (void**)&pBits, &pitch);
        pBS->LockBits(NULL, 0, (void**)&pCvtBits, &pitch);
        ICDecompress(m_hic, 0, m_inlpbmh, pBits, m_outlpbmh, pCvtBits);
        (*ppbs)->UnlockBits(NULL, pBits);
        pBS->UnlockBits(NULL, pCvtBits);
        (*ppbs)->Release(); // done with the capture buffer
        *ppbs = pBS;
        return NO_ERROR;
    }
    return E_OUTOFMEMORY;
}

BOOL
CICMcvtFrame::InitCvt(
    LPBITMAPINFOHEADER lpbmh,
    DWORD bmhLen,
    LPBITMAPINFOHEADER *plpbmhdsp
    )
{
    DWORD dwLen;
    HIC hic;

	FX_ENTRY("CICMcvtFrame::InitCvt");

    *plpbmhdsp = lpbmh;
    if (lpbmh->biCompression != BI_RGB) {
        *plpbmhdsp = NULL;
        // make internal copy of input BITMAPINFOHEADER
        m_inlpbmh = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, bmhLen);
        if (!m_inlpbmh) {
			ERRORMESSAGE(("%s: No memory for display bitmapinfoheader", _fx_));
            return FALSE;
        }
        CopyMemory(m_inlpbmh, lpbmh, bmhLen);

        // alloc space for display BITMAPINFOHEADER
        dwLen = sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD);
        m_outlpbmh = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwLen);
        if (!m_outlpbmh) {
            LocalFree((HANDLE)m_inlpbmh);
			ERRORMESSAGE(("%s: No memory for display bitmapinfoheader", _fx_));
            return FALSE;
        }

        // First attempt to find a codec to convert to RGB24
        hic = ICGetDisplayFormat(NULL, lpbmh, m_outlpbmh, 24, 0, 0);
        if (!hic) {
            // nothing available to convert to RGB24, so see what we can get
            hic = ICGetDisplayFormat(NULL, lpbmh, m_outlpbmh, 0, 0, 0);
        }
        if (hic) {
            if (m_outlpbmh->biCompression == BI_RGB) {
                // we got a codec that can convert to RGB
                *plpbmhdsp = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwLen);
                if (*plpbmhdsp) {
                    CopyMemory(*plpbmhdsp, m_outlpbmh, dwLen);
                    if ((m_pool = new CVidPool)) {
                        m_pool->AddRef();
                        if (m_pool->InitPool(2, m_outlpbmh) == NO_ERROR) {
                            m_hic = hic;
                            ICDecompressBegin(m_hic, m_inlpbmh, m_outlpbmh);
							DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: init ICM cvt (0x%08lX [CICMcvtFrame])\r\n", _fx_, this));
                            return TRUE;
                        }
                        else {
							ERRORMESSAGE(("%s: Failed to init codec pool", _fx_));
                            m_pool->Release();
                        }
                    }
                    else
					{
						ERRORMESSAGE(("%s: Failed to alloc codec pool", _fx_));
					}
                    LocalFree((HANDLE)*plpbmhdsp);
                }
                else
				{
					ERRORMESSAGE(("%s: Failed to init codec pool", _fx_));
				}
            }
            ICClose(hic);  // close the opened codec
        }
        else
		{
			ERRORMESSAGE(("%s: No available codecs to decode format", _fx_));
		}

        // free allocate BITMAPINFOHEADER memory
       	LocalFree((HANDLE)m_inlpbmh);
       	m_inlpbmh = NULL;
       	LocalFree((HANDLE)m_outlpbmh);
       	m_outlpbmh = NULL;
    }
    return FALSE;
}


//CFilterChain methods
CFilterChain::~CFilterChain(
    )
{
    if (m_head)
        m_head->Release();
}

STDMETHODIMP
CFilterChain::DoOp(
    IBitmapSurface** ppbs
    )
{
    CFilterFrame *cfo;
    HRESULT hres;

    cfo = m_head;
    while (cfo) {
        if (cfo->m_enabled) {
            if ((hres = cfo->DoOp(ppbs)) != NOERROR) {
                return hres;
            }
        }
        cfo = (CFilterFrame*)cfo->m_next;
    }
    return NOERROR;
}


//CFilterFrame methods
CFilterFrame::~CFilterFrame(
    )
{
    if (m_effect)
        m_effect->Release();
}

STDMETHODIMP
CFilterFrame::DoOp(
    IBitmapSurface** ppbs
    )
{
    HRESULT hres;
    IBitmapSurface* pBS;

    if (m_inplace) {
        return m_effect->DoEffect(*ppbs, NULL, NULL, NULL);
    }
    else {
        m_pool->GetBuffer(&pBS, NULL);
        if (pBS) {
            hres = m_effect->DoEffect(*ppbs, pBS, NULL, NULL);
            (*ppbs)->Release();
            *ppbs = pBS;
            return hres;
        }
        return E_OUTOFMEMORY;
    }
}

BOOL
CFilterFrame::InitFilter(
    IBitmapEffect *effect,
    LPBITMAPINFOHEADER lpbmhIn,
    CVidPool *pool
    )
{
    DWORD dwFlags;

	FX_ENTRY("CFilterFrame::InitFilter");

    m_effect = effect;
    if (effect->GetMiscStatusBits(&dwFlags) == NO_ERROR) {
        m_inplace = (dwFlags & BITMAP_EFFECT_INPLACE);
    }
    else
        m_inplace = TRUE;   // assumption!

    if (!m_inplace) {
        // we'll need a pool
        if (!pool || !(pool->Growable()))
            return FALSE;
        m_pool = pool;
        m_pool->AddRef();
    }
	DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: init filter (0x%08lX [CFilterFrame])\r\n", _fx_, this));
    return TRUE;
}


//CConvertFrame internal routines
//CConvertFrame methods
CConvertFrame::~CConvertFrame()
{
    if (m_refdata)
        LocalFree((HANDLE)m_refdata);
}

STDMETHODIMP
CConvertFrame::DoOp(
    IBitmapSurface** ppbs
    )
{
    IBitmapSurface* pBS;

    if (m_convert) {
        m_pool->GetBuffer(&pBS, NULL);
        if (pBS) {
            if (m_convert(*ppbs, pBS, m_refdata)) {
                (*ppbs)->Release();
                *ppbs = pBS;
                return NO_ERROR;
            }
            else {
                pBS->Release();
                return E_FAIL;
            }
        }
        else
            return E_OUTOFMEMORY;
    }
    return E_UNEXPECTED;
}

BOOL
CConvertFrame::InitConverter(
    LPBITMAPINFOHEADER lpbmh,
    FRAMECONVERTPROC *convertproc,
    LPVOID refdata
    )
{
    if (convertproc) {
        if ((m_pool = new CVidPool)) {
            m_pool->AddRef();
            if (m_pool->InitPool(2, lpbmh) == NO_ERROR) {
                m_convert = convertproc;
                m_refdata = refdata;
                return TRUE;
            }
            m_pool->Release();
            m_pool = NULL;
        }
    }
    return FALSE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nmcap\vidpool.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <qos.h>
#include <mmsystem.h>
#include "ibitmap.h"
#include "ividpool.h"
#include "vidpool.h"
#include <confdbg.h>
#include <avutil.h>
#include "..\nac\utils.h"

#ifdef DEBUG
extern "C" BOOL g_pooldebug = TRUE;
#endif

STDMETHODIMP
CBitmap::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    if (riid == IID_IUnknown || riid == IID_IBitmapSurface)
        *ppvObj = (IBitmapSurface*)this;
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }
    ((IUnknown*)*ppvObj)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG)
CBitmap::AddRef(
    void
    )
{
	FX_ENTRY("CBitmap::AddRef");

	DEBUGMSG(ZONE_NMCAP_REFCOUNT,("%s: refcnt+(0x%08lX [CBitmap])=%d\r\n", _fx_, this, m_cRef+1));

    return InterlockedIncrement(&m_cRef)+1; // make sure that we return something > 0
}

STDMETHODIMP_(ULONG)
CBitmap::Release(
    void
    )
{
    LONG res;

	FX_ENTRY("CBitmap::Release");

	DEBUGMSG(ZONE_NMCAP_REFCOUNT,("%s: refcnt-(0x%08lX [CBitmap])=%d\r\n", _fx_, this, m_cRef-1));

    res = InterlockedDecrement(&m_cRef);
    if (res == 0) {
        if (m_factory) {
            m_factory->AddToFreeList(this);
        }
        else {
            if (!m_ext)
                LocalFree((HANDLE)m_bits);
			DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: released (0x%08lX [CBitmap]) from vidpool (0x%08lX [m_factory])\r\n", _fx_, this, m_factory));
			DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: deleting (0x%08lX [CBitmap])\r\n", _fx_, this));
            delete this;
        }
    }
    return res;
}

STDMETHODIMP
CBitmap::Clone(
    IBitmapSurface** ppBitmapSurface
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CBitmap::GetFormat(
    BFID* pBFID
    )
{
    *pBFID = *(m_factory->GetFormat());
    return NOERROR;
}

STDMETHODIMP
CBitmap::GetFactory(
    IBitmapSurfaceFactory** ppBitmapSurfaceFactory
    )
{
    *ppBitmapSurfaceFactory = (IBitmapSurfaceFactory*)m_factory;
    m_factory->AddRef();
    return NOERROR;
}

STDMETHODIMP
CBitmap::GetSize(
    long* pWidth,
    long* pHeight
    )
{
	*pWidth = m_factory->GetWidth();
	*pHeight = m_factory->GetHeight();
    return NOERROR;
}

STDMETHODIMP
CBitmap::LockBits(
    RECT* prcBounds,
    DWORD dwLockFlags,
    void** ppBits,
    long* pPitch
    )
{
    if (!prcBounds) {
        *ppBits = m_bits;
        *pPitch = m_pitch;
        m_lockcount++;
        return NO_ERROR;
    }
    return E_NOTIMPL;
}

STDMETHODIMP
CBitmap::UnlockBits(
    RECT* prcBounds,
    void* pBits
    )
{
    if (!prcBounds && pBits == m_bits) {
        m_lockcount--;
        return NO_ERROR;
    }
    return E_NOTIMPL;
}


CVidPool::CVidPool(void)
{
    m_cRef = 0;
    m_growable = FALSE;
    m_nbufs = 0;
    m_free = NULL;
    m_pitch = 0;
    ZeroMemory(&m_format, sizeof(BFID));
    InitializeCriticalSection(&m_cs);
    m_pAddingToFree = NULL;
}

STDMETHODIMP
CVidPool::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    if (riid == IID_IUnknown || riid == IID_IBitmapSurfaceFactory)
        *ppvObj = (IBitmapSurfaceFactory*)this;
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }
    ((IUnknown*)*ppvObj)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG)
CVidPool::AddRef(
    void
    )
{
	FX_ENTRY("CVidPool::AddRef");

	DEBUGMSG(ZONE_NMCAP_REFCOUNT,("%s: refcnt+(0x%08lX [CVidPool])=%d\r\n", _fx_, this, m_cRef+1));

    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CVidPool::Release(
    void
    )
{
    CBitmap* pbs;

	FX_ENTRY("CVidPool::Release");

	DEBUGMSG(ZONE_NMCAP_REFCOUNT,("%s: refcnt-(0x%08lX [CVidPool])=%d\r\n", _fx_, this, m_cRef-1));

    if (InterlockedDecrement(&m_cRef) == 0) {

		DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: freeing (0x%08lX [CVidPool])\r\n", _fx_, this));

        EnterCriticalSection(&m_cs);
        while (m_free) {
            pbs = m_free->m_next;
            m_free->AddRef();       // ref the buffer so that release will cause a delete
            m_free->Release();      // this will cause the buffer to be deleted
            m_free = pbs;
#ifdef DEBUG
            m_nbufs--;
#endif
        }
        LeaveCriticalSection(&m_cs);
        LocalFree((HANDLE)m_pbmh);
        DeleteCriticalSection(&m_cs);

		// Buffers not all released
        ASSERT(!m_nbufs);

        delete this;
        return 0;
    }
    return m_cRef;
}

STDMETHODIMP
CVidPool::CreateBitmapSurface(
    long width,
    long height,
    BFID* pBFID,
    DWORD dwHintFlags,
    IBitmapSurface** ppBitmapSurface
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CVidPool::GetSupportedFormatsCount(
    long* pcFormats
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CVidPool::GetSupportedFormats(
    long cFormats,
    BFID* pBFIDs
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CVidPool::InitPool(
    int nBuffers,
    LPBITMAPINFOHEADER lpcap
    )
{
    CBitmap* pbs;
    void *pbuf;

	FX_ENTRY("CVidPool::InitPool");

    if (m_pbmh = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, lpcap->biSize)) {
        CopyMemory(m_pbmh, lpcap, lpcap->biSize);
        if (lpcap->biCompression == BI_RGB) {
            m_pitch = lpcap->biWidth*lpcap->biBitCount/8;
            switch (lpcap->biBitCount) {
                case 1:
                    m_format = (BFID*)&BFID_MONOCHROME;
                    break;

                case 4:
                    m_format = (BFID*)&BFID_RGB_4;
                    break;

                case 8:
                    m_format = (BFID*)&BFID_RGB_8;
                    break;

                case 16:
                    m_format = (BFID*)&BFID_RGB_555;
                    break;

                case 24:
                    m_format = (BFID*)&BFID_RGB_24;
                    break;

                case 32:
                    m_format = (BFID*)&BFID_RGB_32;
            }
        }
        else {
            m_format = (BFID*)&BFID_PRIVATEDIB;
            m_pitch = 1;
        }

        for (m_nbufs = 0; m_nbufs < nBuffers; m_nbufs++) {
            if (pbuf = LocalAlloc(LMEM_FIXED, lpcap->biSizeImage)) {
                if (pbs = new CBitmap) {
                //  pbs->AddRef();  - don't AddRef, we want inpool objects to be 0 based
                    pbs->m_bits = (LPBYTE)pbuf;
                    pbs->m_pitch = m_pitch;
                    EnterCriticalSection(&m_cs);
                    pbs->m_next = m_free;
                    m_free = pbs;
                    LeaveCriticalSection(&m_cs);
                }
                else {
                    LocalFree((HANDLE)pbuf);
                    break;
                }
            }
            else
                break;        
        }
        if (m_nbufs == nBuffers) {
            m_growable = (nBuffers > 0);
			DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: init vidpool (0x%08lX [CVidPool])\r\n", _fx_, this));
            return NO_ERROR;
        }

        EnterCriticalSection(&m_cs);
        while (m_free) {
            pbs = m_free->m_next;
            m_free->Release();
            m_free = pbs;
        }
        LeaveCriticalSection(&m_cs);
    }
    return E_OUTOFMEMORY;
}

STDMETHODIMP
CVidPool::AddExternalBuffer(
    void* pBits,
    void* refdata
    )
{
    CBitmap* pbs;

	FX_ENTRY("CVidPool::AddExternalBuffer");

    if (pbs = new CBitmap) {
    //  pbs->AddRef();  - don't AddRef, because we want inpool objects to be 0 based
        pbs->m_bits = (LPBYTE)pBits;
        pbs->m_pitch = m_pitch;
        pbs->m_ext = TRUE;
        EnterCriticalSection(&m_cs);
        pbs->m_next = m_free;
        pbs->m_refdata = refdata;
        m_free = pbs;
        m_nbufs++;
        LeaveCriticalSection(&m_cs);
		DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: added bitmap (0x%08lX [CBitmap]) to vidpool (0x%08lX [CVidPool])\r\n", _fx_, pbs, this));
    }
    return E_OUTOFMEMORY;
}

STDMETHODIMP
CVidPool::GetBuffer(
    CBitmap** ppBitmap,
    void** prefdata
    )
{
    CBitmap* pbs = NULL;
    void *pbuf;

	FX_ENTRY("CVidPool::GetBuffer");

    if (ppBitmap) {
        if (prefdata)
            *prefdata = NULL;
        EnterCriticalSection(&m_cs);
        if (pbs = m_free) {
            m_free = pbs->m_next;
            LeaveCriticalSection(&m_cs);
        }
        else {
            LeaveCriticalSection(&m_cs);
            if (m_growable) {
                if (pbuf = LocalAlloc(LMEM_FIXED, m_pbmh->biSizeImage)) {
                    if (pbs = new CBitmap) {
                        pbs->m_bits = (LPBYTE)pbuf;
                        pbs->m_pitch = m_pitch;
                        pbs->m_next = m_free;
                        m_nbufs++;
						DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: grew vidpool (0x%08lX [CVidPool]) to %d with cbitmap (0x%08lX [CBitmap])\r\n", _fx_, this, m_nbufs, pbs));
                    }
                    else
                        LocalFree((HANDLE)pbuf);
                }
            }
        }
        if (*ppBitmap = pbs) {
            pbs->m_factory = this;
            AddRef();
            pbs->AddRef();
            if (prefdata)
                *prefdata = pbs->m_refdata;
            return NO_ERROR;
        }
        else
            return E_OUTOFMEMORY;        
    }
    return E_INVALIDARG;
}

STDMETHODIMP
CVidPool::GetBuffer(
    IBitmapSurface** ppBitmap,
    void** prefdata
    )
{
    CBitmap* pbs = NULL;
    GetBuffer (&pbs, prefdata);
    *ppBitmap = (IBitmapSurface*)pbs;
    return NO_ERROR;
}

void
CVidPool::AddToFreeList(
    CBitmap* pBitmap
    )
{
	FX_ENTRY("CVidPool::AddToFreeList");

	DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: queuing cbitmap (0x%08lX [CBitmap]) to vidpool (0x%08lX [CVidPool])\r\n", _fx_, pBitmap, this));

    // notify pool creator, if interested
    if (m_pAddingToFree)
        m_pAddingToFree(pBitmap, m_refdata);

    EnterCriticalSection(&m_cs);
    pBitmap->m_next = m_free;
    m_free = pBitmap;
    LeaveCriticalSection(&m_cs);
    pBitmap->m_factory = NULL;
    Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rrcminc\interop.h ===
#ifndef __INTEROP_H
#define __INTEROP_H

#include <windows.h>

#define INTEROP_EXPORT  __declspec(dllexport)

#define DLLName "CPLS.DLL"


typedef int    (WINAPI *CPLInitialize_t)(const char*);
typedef int    (WINAPI *CPLUninitialize_t)(int) ;
typedef int    (WINAPI *CPLOpen_t)(int, 
							const char*, 
							int);
typedef int    (WINAPI *CPLClose_t)( int );
typedef int    (WINAPI *CPLOutput_t)(int, 
							BYTE*, 
							int,
							unsigned long);



typedef struct {
    CPLInitialize_t       CPLInitialize;
	CPLUninitialize_t     CPLUninitialize;
    CPLOpen_t			  CPLOpen;
    CPLClose_t			  CPLClose;
    CPLOutput_t			  CPLOutput;
	int					  g_ComplianceProtocolLogger;
	int					  g_ProtocolLogID;
	HINSTANCE hInst;
} *LPInteropLogger, InteropLogger;

#ifdef __cplusplus
extern "C" {
#endif

LPInteropLogger INTEROP_EXPORT InteropLoad(const char*  Protocol);
void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger);
void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf, int length, unsigned long userData);

#ifdef __cplusplus
}
#endif


#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\qos\props.cpp ===
/*
 -  PROPS.CPP
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	IProp interfaces
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		11.06.96	Yoram Yaacovi		Created
 *
 *	Functions:
 *		IProp
 *			CQoS::GetProps
 *			CQoS::SetProps
 */

#include "precomp.h"

/***************************************************************************

    Name      : CQoS::SetProps

    Purpose   : Set properties on the QoS object

    Parameters: cValues - number of properties to set
				pPropArray - pointer to the array of the properties to set

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
HRESULT CQoS::SetProps (ULONG cValues,
						PPROPERTY pPropArray)
{
	HRESULT hr=NOERROR;
	ULONG i;

	DEBUGMSG(ZONE_IQOS,("IQoS::SetProps\n"));

	/*
	 *	Parameter validation
	 */
	if (!pPropArray)
	{
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
	}

	/*
	 *	Set the properties
	 */
	// for every property to set...
	for (i=0; i < cValues; i++)
	{
		// just handle the props I know of
		switch (pPropArray[i].ulPropTag)
		{
		case PR_QOS_WINDOW_HANDLE:
			m_hWnd = (HWND) pPropArray[i].Value.ul;
			pPropArray[i].hResult = NOERROR;
			break;
		default:
			pPropArray[i].hResult = QOS_E_NO_SUCH_PROPERTY;
			hr = QOS_E_REQ_ERRORS;
			break;
		}
	}

out:
	DEBUGMSG(ZONE_IQOS,("IQoS::SetProps - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::GetProps

    Purpose   : Get properties from the QoS object

    Parameters: pPropTagArray - array of tags of properties to get
				ulFlags
				pcValues - address of a ULONG into which the function will
					put the number of the properties returned in *ppPropArray
				ppPropArray - address of a pointer where the function will 
					put the address of the returned properties buffer. The 
					caller must free this buffer when done.

    Returns   : HRESULT

    Comment   : Not implemented

***************************************************************************/
HRESULT CQoS::GetProps (PPROPTAGARRAY pPropTagArray,
						ULONG ulFlags,
						ULONG *pcValues,
						PPROPERTY *ppPropArray)
{
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_IQOS,("IQoS::GetProps\n"));

	hr = E_NOTIMPL;

	goto out;

out:
	DEBUGMSG(ZONE_IQOS,("QoS::GetProps - leave, hr=0x%x\n", hr));
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\qos\precomp.h ===
/*
 -  PRECOMP.H
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	QoS pre-compiled header file
 *
 *      Revision History:
 *
 *      When	   Who                 What
 *      --------   ------------------  ---------------------------------------
 *      10.24.96   Yoram Yaacovi       Created
 *      01.04.97   Robert Donner       Added NetMeeting utility routines
 *
 */

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <winsock2.h>
#include <limits.h>

#include <oprahcom.h>
#include <confdbg.h>
#include <confreg.h>
#include <avUtil.h>
#include <regentry.h>
#include <strutil.h>    // for GuidToSz
#include <dcap.h>       // for R0 services

// including common.h for DECLARE_INTERFACE_PTR
#include "common.h"
#include "nmqos.h"
#include "qosint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\qos\guids.cpp ===
/*
 -  GUIDS.CPP
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	QoS GUID definitions
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		10.28.96	Yoram Yaacovi		Created
 *
 *	Functions:
 *
 */

#include "precomp.h"

// define the GUID as "public"
#define INITGUID
#include <initguid.h>

// {DFC1F900-2DCE-11d0-92DD-00A0C922E6B2}
DEFINE_GUID(IID_IQoS, 0xdfc1f900, 0x2dce, 0x11d0, 0x92, 0xdd, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);
// {085C06A0-3CAA-11d0-A00E-00A024A85A2C}
DEFINE_GUID(CLSID_QoS, 0x085c06a0, 0x3caa, 0x11d0, 0xa0, 0x0e, 0x0, 0xa0, 0x24, 0xa8, 0x5a, 0x2c);

// DEFINE_OLEGUID(IID_IUnknown, 0x00000000L, 0, 0);

#undef INITGUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\qos\qosint.h ===
/*
 -  QOSINT.H
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	Internal QoS header file
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		10.24.96	Yoram Yaacovi		Created
 *
 */

#include <pshpack8.h> /* Assume 8 byte packing throughout */


#ifdef DEBUG
/*
 *	Debug stuff
 */

extern HDBGZONE		ghDbgZoneQoS;

#define ZONE_INIT (GETMASK(ghDbgZoneQoS) & 0x0001)
#define ZONE_IQOS (GETMASK(ghDbgZoneQoS) & 0x0002)
#define ZONE_THREAD (GETMASK(ghDbgZoneQoS) & 0x0004)
#define ZONE_STRUCTURES (GETMASK(ghDbgZoneQoS) & 0x0008)
#define ZONE_PARAMETERS (GETMASK(ghDbgZoneQoS) & 0x0010)

int QoSDbgPrintf(LPCSTR lpszFormat, ...);

//	MACRO: DEBUGMSG(zone,message-to-print)
//	PURPOSE: If the zone is enabled, prints a message to the debug output
//	NOTE: in debug build - if the zone is turned on
#define DEBUGMSG(z,s)	( (z) ? (QoSDbgPrintf s) : 0)
//	MACRO: DISPLAYQOSOBJECT()
//	PURPOSE: Displays the internal structures of the QoS object
//	NOTE: in debug build - if the zone is turned on
#define DISPLAYQOSOBJECT()	DisplayQoSObject()
//	MACRO: DISPLAYPARAMETERS(nFunctionID)
//	PURPOSE: Displays the parameters of a given function
//	NOTE: in debug build - if the zone is turned on
#define DISPLAYPARAMETERS(fid, p1, p2, p3, p4, p5)				\
		DisplayParameters(fid, (ULONG_PTR) p1, (ULONG_PTR) p2, (ULONG_PTR) p3, (ULONG_PTR) p4, (ULONG_PTR) p5)
//	MACRO: QOSDEBUGINIT
//	PURPOSE: Initializes the QoS debug zones, ONLY IF not initialized yet
//	NOTE:
#define QOSDEBUGINIT()	\
	if (!ghDbgZoneQoS)	\
		DBGINIT(&ghDbgZoneQoS, _rgZonesQos);

#define WAIT_ON_MUTEX_MSEC	20000

#else	// retail
#define DISPLAYQOSOBJECT()
#define DISPLAYPARAMETERS(fid, p1, p2, p3, p4, p5)
#define DEBUGMSG(z,s)
#define QOSDEBUGINIT()
#define WAIT_ON_MUTEX_MSEC	5000
#endif

/*
 *	Constants
 */
// IDs for parameters display (debug use only)
#define REQUEST_RESOURCES_ID	1
#define SET_RESOURCES_ID		2
#define RELEASE_RESOURCES_ID	3
#define SET_CLIENTS_ID			4

#define QOS_LOWEST_PRIORITY		10

/*
 *	Macros
 */
#define COMPARE_GUIDS(a,b)	RtlEqualMemory((a), (b), sizeof(GUID))
#define ACQMUTEX(hMutex)											\
	while (WaitForSingleObject(hMutex, WAIT_ON_MUTEX_MSEC) == WAIT_TIMEOUT)		\
	{																\
		ERRORMSG(("Thread 0x%x waits on mutex\n", GetCurrentThreadId()));	\
	}																\
		
#define RELMUTEX(hMutex)	ReleaseMutex(hMutex)

/*
 *	Data Structures
 */

// internal resource request structure
typedef struct _resourcerequestint
{
	struct _resourcerequestint	*fLink;
	RESOURCEREQUEST		sResourceRequest;
	GUID				guidClientGUID;
	LPFNQOSNOTIFY		pfnQoSNotify;
	DWORD_PTR			dwParam;

} RESOURCEREQUESTINT, *LPRESOURCEREQUESTINT;

// internal resource structure
typedef struct _resourceint
{
	struct _resourceint	*fLink;
	RESOURCE			resource;
	int					nNowAvailUnits;
	RESOURCEREQUESTINT	*pRequestList;

} RESOURCEINT, *LPRESOURCEINT;

// internal client structure
typedef struct _clientint
{
	struct _clientint	*fLink;
	CLIENT				client;
	RESOURCEREQUESTINT	*pRequestList;

} CLIENTINT, *LPCLIENTINT;

class CQoS : public IQoS
{
public:
//	IUnknown methods
	STDMETHODIMP QueryInterface (REFIID riid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef (void);
	STDMETHODIMP_(ULONG) Release (void);

//	IQoS methods
	STDMETHODIMP RequestResources (LPGUID lpStreamGUID,
										LPRESOURCEREQUESTLIST lpResourceRequestList,
										LPFNQOSNOTIFY lpfnQoSNotify,
										DWORD_PTR dwParam);
	STDMETHODIMP ReleaseResources (LPGUID lpStreamGUID,
										LPRESOURCEREQUESTLIST lpResourceRequestList);
	STDMETHODIMP GetResources (LPRESOURCELIST *lppResourceList);
	STDMETHODIMP SetResources (LPRESOURCELIST lpResourceList);
	STDMETHODIMP SetClients(LPCLIENTLIST lpClientList);
	STDMETHODIMP NotifyNow(void);
	STDMETHODIMP FreeBuffer(LPVOID lpBuffer);

//	IProps methods
	STDMETHODIMP SetProps (ULONG cValues,
							PPROPERTY pPropArray);
	STDMETHODIMP GetProps (PPROPTAGARRAY pPropTagArray,
							ULONG ulFlags,
							ULONG FAR *pcValues,
							PPROPERTY *ppPropArray);


	CQoS (void);
	~CQoS (void);
	HRESULT Initialize(void);

private:
// Private functions
	HRESULT QoSCleanup(void);
	BOOL AnyRequests(void);
	HRESULT FindClientsForResource(	DWORD dwResourceID,
									LPCLIENTINT pc,
									ULONG *puSamePriClients,
									ULONG *puLowerPriClients);
	HRESULT FreeListOfRequests(LPRESOURCEREQUESTINT *lppList);
	HRESULT StoreResourceRequest(LPGUID pClientGUID,
						LPRESOURCEREQUEST pResourceRequest,
						LPFNQOSNOTIFY pfnQoSNotify,
						DWORD_PTR dwParam,
						LPRESOURCEINT pResourceInt);
	HRESULT FreeResourceRequest(LPGUID pClientGUID,
								LPRESOURCEINT pResourceInt,
								int *pnUnits);
	HRESULT UpdateClientInfo (	LPGUID pClientGUID,
								LPFNQOSNOTIFY pfnQoSNotify);
	HRESULT UpdateRequestsForClient (LPGUID pClientGUID);
	HRESULT FindClient(LPGUID pClientGUID, LPCLIENTINT *ppClient);
	HRESULT StartQoSThread(void);
	HRESULT StopQoSThread(void);
	DWORD QoSThread(void);
	HRESULT NotifyQoSClient(void);

// Debug display functions
	void DisplayQoSObject(void);
	void DisplayRequestListInt(LPRESOURCEREQUESTINT prr, BOOL fDisplay);
	void DisplayRequestList(LPRESOURCEREQUESTLIST prrl);
	void DisplayParameters(ULONG nFunctionID, ULONG_PTR P1, ULONG_PTR P2, ULONG_PTR P3, ULONG_PTR P4, ULONG_PTR P5);
	void DisplayResourceList(LPRESOURCELIST prl);
	void DisplayClientList(LPCLIENTLIST pcl);

	friend DWORD QoSThreadWrapper(CQoS *pQoS);

// Variables
	int m_cRef;
	LPRESOURCEINT m_pResourceList;
	ULONG m_cResources;
	LPCLIENTINT m_pClientList;
	HANDLE m_evThreadExitSignal;
	HANDLE m_evImmediateNotify;
	HANDLE m_hThread;			// handle of the QoS notify thread
	BOOL m_bQoSEnabled;			// whether QoS is enabled or not
	BOOL m_bInNotify;
	ULONG m_nSkipHeartBeats;	// how many heartbeats should the QoS notify thread skip
	HWND m_hWnd;
	ULONG m_nLeaveForNextPri;	// percentage of the rsrc to leave for lower priority clients
    BOOL bWin9x;                //Windows 9x (TRUE) or NT (FALSE)
};

/*
 *	QoS Class factory
 */
typedef HRESULT (STDAPICALLTYPE *PFNCREATE)(IUnknown *, REFIID, void **);
class CClassFactory : public IClassFactory
{
    public:
        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, void **);
        STDMETHODIMP         LockServer(BOOL);

        CClassFactory(PFNCREATE);
        ~CClassFactory(void);

    protected:
        ULONG	m_cRef;
		PFNCREATE m_pfnCreate;
};

/*
 *	Globals
 */
EXTERN_C HANDLE g_hQoSMutex;
EXTERN_C class CQoS *g_pQoS;

/*
 *	Function prototypes
 */

#include <poppack.h> /* End byte packing */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\qos\qosmain.cpp ===
/*
 -  QOSMAIN.CPP
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	DLL entry
 *
 *      Revision History:
 *
 *      When	   Who                 What
 *      --------   ------------------  ---------------------------------------
 *      10.23.96   Yoram Yaacovi       Created
 *      01.04.97   Robert Donner       Added NetMeeting utility routines
 *
 *	Functions:
 *
 */

#include <precomp.h>

#ifdef DEBUG
HDBGZONE    ghDbgZone = NULL;

static PTCHAR _rgZonesQos[] = {
	TEXT("qos"),
	TEXT("Init"),
	TEXT("IQoS"),
	TEXT("Thread"),
	TEXT("Structures"),
	TEXT("Parameters"),
};
#endif /* DEBUG */


/****************************************************************************
    FUNCTION:	DllEntryPoint

    PURPOSE:	The DLL entry point. Called by Windows on DLL attach/Detach. Used to
				do DLL initialization/termination.

	PARAMETERS: hInstDLL - instance of the DLL
				fdwReason - the reason the DLL is attached/detached.
				lpvReserved

****************************************************************************/
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE  hinstDLL,
                               DWORD  fdwReason,
                               LPVOID  lpvReserved);

BOOL WINAPI DllEntryPoint(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	BOOL fInit;

	switch (fdwReason)
	{

	case DLL_PROCESS_ATTACH:
		DBGINIT(&ghDbgZone, _rgZonesQos);
		INIT_MEM_TRACK("QoS");

		DisableThreadLibraryCalls(hInstDLL);

		DEBUGMSG(ZONE_INIT, ("DllEntryPoint: 0x%x PROCESS_ATTACH\n", GetCurrentThreadId()));

		// create a no-name mutex to control access to QoS object data
		g_hQoSMutex = CreateMutex(NULL, FALSE, NULL);
		ASSERT(g_hQoSMutex);
		if (!g_hQoSMutex)
		{
			ERRORMSG(("DllEntryPoint: CreateMutex failed, 0x%x\n", GetLastError()));
			return FALSE;
		}

		g_pQoS = (CQoS *)NULL;

		// no break. The attaching process need to go through THREAD_ATTACH.

	case DLL_THREAD_ATTACH:
		break;

	case DLL_PROCESS_DETACH:
		CloseHandle(g_hQoSMutex);

		DEBUGMSG(ZONE_INIT, ("DllEntryPoint: 0x%x PROCESS_DETACH\n", GetCurrentThreadId()));

		UNINIT_MEM_TRACK(0);

		DBGDEINIT(&ghDbgZone);

		// fall through to deinit last thread

	case DLL_THREAD_DETACH:
		break;

	default:
		break;

	}
	
	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\qos\qos.cpp ===
/*
 -  QOS.CPP
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	IQoS interfaces
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		10.23.96	Yoram Yaacovi		Created
 *
 *	Functions:
 *		IQoS
 *			CQoS::QueryInterface
 *			CQoS::AddRef
 *			CQoS::Release
 *			CQoS::RequestResources
 *			CQoS::ReleaseResources
 *			CQoS::SetClients
 *			CQoS::SetResources
 *			CQoS::GetResources
 *			CQoS::FreeBuffer
 *		Public:
 *			CQoS::CQoS
 *			CQoS::~CQoS
 *			CQoS::Initialize
 *		Private
 *			CQoS::AnyRequests
 *			CQoS::FindClientsForResource
 *			CQoS::StoreResourceRequest
 *			CQoS::FreeResourceRequest
 *			CQoS::UpdateClientInfo
 *			CQoS::QoSCleanup
 *			CQoS::FindClient
 *			CQoS::UpdateRequestsForClient
 *		External
 *			CreateQoS
 *			QoSEntryPoint
 */

#include "precomp.h"

EXTERN_C int g_cQoSObjects=0;
EXTERN_C HANDLE g_hQoSMutex=NULL;
class CQoS *g_pQoS;

#ifdef DEBUG
HDBGZONE    ghDbgZoneQoS = NULL;

static PTCHAR _rgZonesQos[] = {
	TEXT("qos"),
	TEXT("Init"),
	TEXT("IQoS"),
	TEXT("Thread"),
	TEXT("Structures"),
	TEXT("Parameters"),
};
#endif /* DEBUG */

/***************************************************************************

    Name      : QoSCleanup

    Purpose   : Cleans up a QoS object before releasing (free memory, etc)

    Parameters: pqos - pointer to a QoS pbject

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::QoSCleanup ()
{
	HRESULT hr=NOERROR;
	LPRESOURCEINT pr=NULL;
	LPCLIENTINT pc=NULL;

	ACQMUTEX(g_hQoSMutex);

	/*
	 *	Free memory
	 */
	// traverse and free all the memory allocated by the QoS object
	// resources and requests first
	pr = m_pResourceList;
	while (pr)
	{
		LPRESOURCEINT prNext=pr->fLink;

		// first, delete the request list for this resource
		FreeListOfRequests(&(pr->pRequestList));

		MEMFREE(pr);
		pr = prNext;
	}
	m_pResourceList = 0;

	// next is clients
	pc = m_pClientList;
	while (pc)
	{
		LPCLIENTINT pcNext=pc->fLink;
		
		// delete the request list for this client
		FreeListOfRequests(&(pc->pRequestList));

		// now delete the client itself
		MEMFREE(pc);
		pc = pcNext;
	}
	m_pClientList = 0;

	// terminate the QoS thread and let it exit
	// the thread should really be terminated when the last request
	// is released, so this is just a safety measure
	StopQoSThread();

	// delete the events
	if (m_evImmediateNotify)
		CloseHandle(m_evImmediateNotify);
	m_evImmediateNotify = NULL;

	if (m_evThreadExitSignal)
		CloseHandle(m_evThreadExitSignal);
	m_evThreadExitSignal = NULL;

	RELMUTEX(g_hQoSMutex);

	return hr;
}

/***************************************************************************

    Name      : AnyRequests

    Purpose   : Finds out if there are any resource requests

    Parameters: none

	Returns   : TRUE - there is at least one request

    Comment   :

***************************************************************************/
BOOL CQoS::AnyRequests(void)
{
	LPRESOURCEINT pr=NULL;
	BOOL bAnyRequests=FALSE;

	pr = m_pResourceList;
	while (pr)
	{
		if (pr->pRequestList)
		{
			bAnyRequests=TRUE;
			break;
		}

		// next resource
		pr = pr->fLink;
	}

	return bAnyRequests;
}

/***************************************************************************

    Name      : FindClientsForResource

    Purpose   : Finds if there are clients for a specific resource

    Parameters: [in] dwResourceID = the ID of the resource
				[in] pc = client pointer to start searching from
				[out] puSamePriClients = number of clients with the same
					priority for this resource is returned here
				[out] puLowerPriClients = number of clients with lower
					priority for this resource is returned here

	Returns   : HRESULT

    Comment   : This function is NOT general purpose. It only counts clients
				with the same priority DOWN the list.

***************************************************************************/
HRESULT CQoS::FindClientsForResource(	DWORD dwResourceID,
										LPCLIENTINT pc,
										ULONG *puSamePriClients,
										ULONG *puLowerPriClients)
{
	LPCLIENTINT pctemp=pc->fLink;
	LPRESOURCEREQUESTINT pcrr=NULL;

	*puLowerPriClients = 0;
	*puSamePriClients = 1;	// the first client (at 'pc')
	while (pctemp)
	{
		LPRESOURCEINT pr=NULL;
		
		// does this client need this specific resource ?
		pcrr = pctemp->pRequestList;
		while (pcrr)
		{
			if (pcrr->sResourceRequest.resourceID == dwResourceID)
			{
				// it is either a same priority client or a lower priority
				// client (the list is sorted)
				(pctemp->client.priority == pc->client.priority ?
					(*puSamePriClients)++ :
					(*puLowerPriClients)++);
				break;
			}

			// next request for this client
			pcrr = pcrr->fLink;
		}
		
		pctemp = pctemp->fLink;
	}	

	return NOERROR;
}

/***************************************************************************

    Name      : FreeListOfRequests

    Purpose   : Free all records of a linked list of requests, given the
				address of the list pointer. Zero's the list pointer

    Parameters: lppRequestList - address of the pointer to the beginning
					of the list

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::FreeListOfRequests(LPRESOURCEREQUESTINT *lppRequestList)
{
	LPRESOURCEREQUESTINT prr=*lppRequestList;
	HRESULT hr=NOERROR;

	while (prr)
	{
		LPRESOURCEREQUESTINT prrNext=prr->fLink;

		MEMFREE(prr);
		prr = prrNext;
	}

	*lppRequestList = NULL;

	return hr;
}

/***************************************************************************

    Name      : FreeResourceRequest

    Purpose   : Frees resource units and respective resource requests

    Parameters: pClientGUID - the GUID of the calling client (stream)
				pnUnits - a pointer of where to return the number of units freed
				pResourceInt - pointer to the resource being freed

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::FreeResourceRequest (	LPGUID pClientGUID,
									LPRESOURCEINT pResourceInt,
									int *pnUnits)
{
	HRESULT hr=NOERROR;
	LPRESOURCEREQUESTINT prr=NULL, *prrPrev=NULL;

	// find the request from this client
	prr = pResourceInt->pRequestList;
	prrPrev = &(pResourceInt->pRequestList);
	while (prr)
	{
		if (COMPARE_GUIDS(&(prr->guidClientGUID), pClientGUID))
		{
			// we do have a request from this client.
			// reclaim the units...
			*pnUnits = prr->sResourceRequest.nUnitsMin;

			// ...and remove it
			*prrPrev = prr->fLink;
			MEMFREE(prr);

			// we're done.
			hr = NOERROR;
			goto out;
		}

		prrPrev = &(prr->fLink);
		prr = prr->fLink;
	}

	hr = QOS_E_NO_SUCH_REQUEST;

out:
	return hr;
}

/***************************************************************************

    Name      : StoreResourceRequest

    Purpose   : Stores a resource request with the resource

    Parameters: pClientGUID - the GUID of the calling client (stream)
				pResourceRequest - the request to store
				pfnQoSNotify - a pointer to a notification function for the
					requesting client
				pResourceInt - pointer to the resource on which to store the
					request

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::StoreResourceRequest (LPGUID pClientGUID,
									LPRESOURCEREQUEST pResourceRequest,
									LPFNQOSNOTIFY pfnQoSNotify,
									DWORD_PTR dwParam,
									LPRESOURCEINT pResourceInt)
{
	HRESULT hr=NOERROR;
	LPRESOURCEREQUESTINT prr=NULL, *prrPrev=NULL;
	BOOL fRequestFound=FALSE;

	/*
	 *	Store the request
	 */

	// do we already have a request from this client ?
	prr = pResourceInt->pRequestList;
	prrPrev = &(pResourceInt->pRequestList);
	while (prr)
	{
		if (COMPARE_GUIDS(&(prr->guidClientGUID), pClientGUID))
		{
			// we do have a request from this client. override it.
			RtlCopyMemory(	&(prr->sResourceRequest),
							pResourceRequest,
							sizeof(RESOURCEREQUEST));
			RtlCopyMemory(&(prr->guidClientGUID), pClientGUID, sizeof(GUID));
			prr->pfnQoSNotify = pfnQoSNotify;
			prr->dwParam = dwParam;

			// we're done.
			hr = NOERROR;
			fRequestFound = TRUE;
			break;
		}

		prrPrev = &(prr->fLink);
		prr = prr->fLink;
	}

	if (!fRequestFound)
	{
		// not found. make one
		prr = (LPRESOURCEREQUESTINT) MEMALLOC(sizeof(RESOURCEREQUESTINT));
		ASSERT(prr);
		if (!prr)
		{
			ERRORMSG(("StoreResourceRequest: MEMALLOC failed on RESOURCEREQUESTINT\n"));
			hr = E_OUTOFMEMORY;
			goto out;
		}
		
		*prrPrev = prr;
		prr->fLink = NULL;

	}

	// whether found or made, copy the contents in
	RtlCopyMemory(	&(prr->sResourceRequest),
					pResourceRequest,
					sizeof(RESOURCEREQUEST));
	RtlCopyMemory(&(prr->guidClientGUID), pClientGUID, sizeof(GUID));
	prr->pfnQoSNotify = pfnQoSNotify;
	prr->dwParam = dwParam;

out:
	return hr;
}

/***************************************************************************

    Name      : UpdateClientInfo

    Purpose   : Updates the client info when a resource request is granted

    Parameters: pClientGUID - the GUID of the calling client (stream)
				pfnQoSNotify - a pointer to a notification function for the
					requesting client

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::UpdateClientInfo (LPGUID pClientGUID,
								LPFNQOSNOTIFY pfnQoSNotify)
{
	HRESULT hr=NOERROR;
	LPCLIENTLIST pcl=NULL;

	/*
	 *	Update client info
	 */

	// we'll do this through calling the SetClients method
	// allocate and fill a CLIENTLIST structure
	pcl = (LPCLIENTLIST) MEMALLOC(sizeof(CLIENTLIST));
	if (!pcl)
	{
		ERRORMSG(("UpdateClientInfo: MEMALLOC failed\n"));
		hr = E_OUTOFMEMORY;
		goto out;
	}

	RtlZeroMemory((PVOID) pcl, sizeof(CLIENTLIST));

	// fill in the resource list
	pcl->cClients = 1;
	RtlCopyMemory(&(pcl->aClients[0].guidClientGUID), pClientGUID, sizeof(GUID));
	pcl->aClients[0].priority = QOS_LOWEST_PRIORITY;

	// set the clients info on the QoS module
	hr = SetClients(pcl);

out:
	if (pcl)
		MEMFREE(pcl);

	return hr;
}

/***************************************************************************

    Name      : UpdateRequestsForClient

    Purpose   : Update a client's request list by finding all existing resource
					requests for this client

    Parameters: pClientGUID - the GUID of the calling client (stream)

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::UpdateRequestsForClient (LPGUID pClientGUID)
{
	HRESULT hr=NOERROR;
	LPRESOURCEINT pr=NULL;
	LPCLIENTINT pc=NULL;
	LPRESOURCEREQUESTINT prr=NULL, *pcrrfLink=NULL, pcrr=NULL;

	/*
	 *	get rid of the current request list for this client
	 */
	// find the client first
	hr = FindClient(pClientGUID, &pc);
	if (FAILED(hr) || !pc)
	{
		hr = QOS_E_NO_SUCH_CLIENT;
		goto out;
	}

	// now delete old request list
	FreeListOfRequests(&(pc->pRequestList));

	/*
	 *	create and add the new request list
	 */
	pr = m_pResourceList;
	pcrrfLink = &(pc->pRequestList);
	while (pr)
	{
		prr = pr->pRequestList;
		while (prr)
		{
			if (COMPARE_GUIDS(&(prr->guidClientGUID), pClientGUID))
			{
				// we found a request from this client.
				// allocate memory for it, and copy it in
				pcrr = (LPRESOURCEREQUESTINT) MEMALLOC(sizeof(RESOURCEREQUESTINT));
				ASSERT(pcrr);
				if (!pcrr)
				{
					ERRORMSG(("UpdateRequestsForClient: MEMALLOC failed on RESOURCEREQUESTINT\n"));
					hr = E_OUTOFMEMORY;
					goto out;
				}
		
				// copy the contents in
				RtlCopyMemory(pcrr, prr, sizeof(RESOURCEREQUESTINT));

				// need a different fLink for the client request list
				*pcrrfLink = pcrr;
				pcrr->fLink = NULL;
				pcrrfLink = &(pcrr->fLink);
			}

			// next request
			prr = prr->fLink;
		}

		// next resource
		pr = pr->fLink;
	}

out:
	return hr;
}

/***************************************************************************

    Name      : FindClient

    Purpose   : Finds and returns a client record

    Parameters: pClientGUID - the GUID whose record to find
				ppClient - address of where to put a pointer to the client found

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::FindClient(LPGUID pClientGUID, LPCLIENTINT *ppClient)
{
	LPCLIENTINT pc=NULL;
	HRESULT hr=NOERROR;

	*ppClient = NULL;
	pc = m_pClientList;
	while (pc)
	{
		if (COMPARE_GUIDS(&(pc->client.guidClientGUID), pClientGUID))
		{
			*ppClient = pc;
			goto out;
		}

		// next client
		pc = pc->fLink;
	}

	hr = QOS_E_NO_SUCH_CLIENT;

out:
	return hr;
}

/***************************************************************************

    IUnknown Methods

***************************************************************************/
HRESULT CQoS::QueryInterface (REFIID riid, LPVOID *lppNewObj)
{
    HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_IQOS,("IQoS::QueryInterface\n"));

    if (IsBadReadPtr(&riid, (UINT) sizeof(IID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadWritePtr(lppNewObj, sizeof(LPVOID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }
	
	*lppNewObj = 0;
	if (riid == IID_IUnknown || riid == IID_IQoS)
		*lppNewObj = (IQoS *) this;
	else
	{
		hr = E_NOINTERFACE;
		goto out;
	}	
	
	((IUnknown *)*lppNewObj)->AddRef ();

out:
	DEBUGMSG(ZONE_IQOS,("IQoS::QueryInterface - leave, hr=0x%x\n", hr));
	return hr;
}

ULONG CQoS::AddRef (void)
{
	DEBUGMSG(ZONE_IQOS,("IQoS::AddRef\n"));

	InterlockedIncrement((long *) &m_cRef);

	DEBUGMSG(ZONE_IQOS,("IQoS::AddRef - leave, m_cRef=%d\n", m_cRef));

	return m_cRef;
}

ULONG CQoS::Release (void)
{
	DEBUGMSG(ZONE_IQOS,("IQoS::Release\n"));

	// if the cRef is already 0 (shouldn't happen), assert, but let it through
	ASSERT(m_cRef);

	if (InterlockedDecrement((long *) &m_cRef) == 0)
	{
		if (m_bQoSEnabled)
			QoSCleanup();
		delete this;
		DEBUGMSG(ZONE_IQOS,("IQoS::Final Release\n"));
		return 0;
	}

	DEBUGMSG(ZONE_IQOS,("IQoS::Release - leave, m_cRef=%d\n", m_cRef));
	
	return m_cRef;
}

/***************************************************************************

    Name      : CQoS::RequestResources

    Purpose   : Requests resources

    Parameters: lpStreamGUID - the GUID of the calling client (stream)
				lpResourceRequestList - a list of resource requests that
					the caller wants to reserve
				lpfnQoSNotify - a pointer to a notification function for the
					requesting client

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::RequestResources (LPGUID lpClientGUID,
								LPRESOURCEREQUESTLIST lpResourceRequestList,
								LPFNQOSNOTIFY lpfnQoSNotify,
								DWORD_PTR dwParam)
{
	HRESULT hr = NOERROR;
	ULONG i;
	BOOL fResourceFound=FALSE, fRequestGranted=FALSE;
	LPRESOURCEINT pResourceInt=NULL, *pPrevResourcefLink=NULL;
	RESOURCEREQUEST *pResourceRequest=NULL;

	DEBUGMSG(ZONE_IQOS,("IQoS::RequestResources\n"));
	
	/*
	 *	Parameter validation
	 */

	// lpResourceRequestList should at least have a count DWORD
	// must have a GUID and a notify callback
	if (!lpResourceRequestList ||
		IsBadReadPtr(lpResourceRequestList, (UINT) sizeof(DWORD)) ||
		!lpClientGUID	||
		!lpfnQoSNotify)
	{
		hr = E_INVALIDARG;
		goto out_nomutex;
	}

	DISPLAYPARAMETERS(	REQUEST_RESOURCES_ID,
						lpClientGUID,
						lpResourceRequestList,
						lpfnQoSNotify,
						dwParam,
						0);

	ACQMUTEX(g_hQoSMutex);
	
	if (!m_bQoSEnabled)
		// just return
		goto out;

	/*
	 *	Find and allocate the resources
	 */

	// for each requested resource
	pResourceRequest=lpResourceRequestList->aRequests;
	for (i=0; i < lpResourceRequestList->cRequests; i++)
	{
		pResourceInt = m_pResourceList;
		fResourceFound = FALSE;
		// find the resource
		while (pResourceInt)
		{
			if (pResourceInt->resource.resourceID == pResourceRequest[i].resourceID)
			{	// resource found
				// see if the resource is available
				// priority will be handled at the first notify callback
				// CHECK: add nUnitsMax handling
				if (pResourceRequest[i].nUnitsMin <= pResourceInt->nNowAvailUnits)
				{
					// resource is available. take the requested share.
					pResourceInt->nNowAvailUnits -= pResourceRequest[i].nUnitsMin;

					// store a local copy of the request
					pResourceRequest[i].hResult = StoreResourceRequest(lpClientGUID,
										&(pResourceRequest[i]),
										lpfnQoSNotify,
										dwParam,
										pResourceInt);
					// if we failed storing, propagate the result to the bottom line
					// returned result
					if (FAILED(pResourceRequest[i].hResult))
					{
						hr = pResourceRequest[i].hResult;
					}
					else
					{	// at least one request was granted to this client
						fRequestGranted = TRUE;
					}
				}
				else	// resource not available
				{
					// let the client know how much is available
					pResourceRequest[i].nUnitsMin = pResourceInt->nNowAvailUnits;
					pResourceRequest[i].hResult = QOS_E_RES_NOT_ENOUGH_UNITS;
					hr = QOS_E_REQ_ERRORS;
				}
				
				fResourceFound = TRUE;

				break;
			}

			// not this one. try next one.
			pResourceInt = pResourceInt->fLink;
		
		}	// while

		if (!fResourceFound)
		{
			pResourceRequest[i].hResult = QOS_E_RES_NOT_AVAILABLE;
			hr = QOS_E_REQ_ERRORS;
		}

		// next request
	}	// for
			
	// if we allocated resources to this client, add it to the client list,
	// provided that it is not already in the list
	// special case: if the call to RequestResources was made from the QoS
	// notification proc, no need to update the client info. Actually, it will
	// be bad to do this, since we are traversing the client list in the
	// notify proc right at this moment...
	if (fRequestGranted && !m_bInNotify)
	{	// add (or update) the client list with this client
		HRESULT hrTemp=NOERROR;
		LPCLIENTINT pc=NULL;

		// if the client is not already in the client list - add it
		FindClient(lpClientGUID, &pc);
		if (!pc)
		{
			hrTemp = UpdateClientInfo (lpClientGUID, lpfnQoSNotify);
			if (FAILED(hrTemp))
				hr = hrTemp;
		}

		// also, make a note that RequestResources has been called. This will
		// make the QoS thread skip one heartbeat in order not call a client
		// too early
		m_nSkipHeartBeats = 1;

		// we have at least one request, so spawn the QoS thread, if not
		// already running
		if (!m_hThread)
			hrTemp = StartQoSThread();

	}
	
out:
	DISPLAYQOSOBJECT();
	RELMUTEX(g_hQoSMutex);
out_nomutex:
	DEBUGMSG(ZONE_IQOS,("IQoS::RequestResources - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::ReleaseResources

    Purpose   : Releases resources

    Parameters: lpClientGUID - the GUID of the calling client (stream)
				lpResourceRequestList - a list of resource requests that
					the caller wants to reserve

    Returns   : HRESULT

    Comment   : The values in the resource list are ignored. The resources
				specified are freed.

***************************************************************************/
HRESULT CQoS::ReleaseResources (LPGUID lpClientGUID,
								LPRESOURCEREQUESTLIST lpResourceRequestList)
{
	ULONG i;
	int nUnits=0;
	BOOL fResourceFound=FALSE;
	LPRESOURCEINT pResourceInt=NULL, *pPrevResourcefLink=NULL;
	RESOURCEREQUEST *pResourceRequest=NULL;
	HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_IQOS,("IQoS::ReleaseResources\n"));

	/*
	 *	parameter validation
	 */

	// lpResourceRequestList should at least have a count DWORD
	if (!lpResourceRequestList ||
		IsBadReadPtr(lpResourceRequestList, (UINT) sizeof(DWORD)))
	{
		hr = E_INVALIDARG;
		goto out_nomutex;
	}

	DISPLAYPARAMETERS(	RELEASE_RESOURCES_ID,
						lpClientGUID,
						lpResourceRequestList,
						0,
						0,
						0);

	ACQMUTEX(g_hQoSMutex);

	if (!m_bQoSEnabled)
		// just return
		goto out;

	// for each requested resource
	pResourceRequest=lpResourceRequestList->aRequests;
	for (i=0; i < lpResourceRequestList->cRequests; i++)
	{
		// make sure we start with no error (caller might not cleared last hresult)
		pResourceRequest[i].hResult = NOERROR;
		pResourceInt = m_pResourceList;
		fResourceFound = FALSE;
		// find the resource
		while (pResourceInt)
		{
			if (pResourceInt->resource.resourceID == pResourceRequest[i].resourceID)
			{	// resource found
				// free the local copy of the request
				pResourceRequest[i].hResult = FreeResourceRequest(lpClientGUID,
									pResourceInt,
									&nUnits);
				
				// if succeeded, claim the units back
				if (SUCCEEDED(pResourceRequest[i].hResult) && (nUnits >= 0))
				{
					// add the freed units
					pResourceInt->nNowAvailUnits += nUnits;
					// in case something went wrong and we now have more available units
					// than total ones
					// NOTE: the ASSERT below is no longer proper. If SetResources was called,
					// and decreased the total units for a resource while there were
					// requests on this resource, the available units for this resource
					// might exceed the total one if released. Since QoS will auto-repair
					// this in the next notify cycle, the window for this is very small
					// ASSERT(!(pResourceInt->nNowAvailUnits > pResourceInt->resource.nUnits));
					if (pResourceInt->nNowAvailUnits > pResourceInt->resource.nUnits)
					{	// we don't want to have more available units than total
						pResourceInt->nNowAvailUnits = pResourceInt->resource.nUnits;
					}
				}
				else
				{
					// no such request
					pResourceRequest[i].hResult = QOS_E_NO_SUCH_REQUEST;
					hr = QOS_E_REQ_ERRORS;
				}
				
				fResourceFound = TRUE;

				break;
			}

			// not this one. try next one.
			pResourceInt = pResourceInt->fLink;
		
		}	// while

		if (!fResourceFound)
		{
			pResourceRequest[i].hResult = QOS_E_NO_SUCH_RESOURCE;
			hr = QOS_E_REQ_ERRORS;
		}
	
		// next request
	}

	// if no requests left, can let the notification thread go...
	if (m_hThread	&&
		!AnyRequests())
	{
		// stop the thread
		StopQoSThread();
	}

out:
	DISPLAYQOSOBJECT();
	RELMUTEX(g_hQoSMutex);

out_nomutex:
	DEBUGMSG(ZONE_IQOS,("IQoS::ReleaseResources - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::SetResources

    Purpose   : Sets the available resources on the QoS module

    Parameters: lpResourceList - list of resources and their availability

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::SetResources (LPRESOURCELIST lpResourceList)
{
	HRESULT hr = NOERROR;
	ULONG i;
	BOOL fResourceFound=FALSE;
	LPRESOURCEINT pResourceInt=NULL, *pPrevResourcefLink=NULL;
	RESOURCE *pResource=NULL;

	RegEntry reQoSResourceRoot(REGKEY_QOS_RESOURCES,
								HKEY_LOCAL_MACHINE,
								FALSE,
								KEY_READ);

	DEBUGMSG(ZONE_IQOS,("IQoS::SetResources\n"));

	/*
	 *	parameter validation
	 */

	// lpResourceList should at least have a count DWORD
	if (!lpResourceList || IsBadReadPtr(lpResourceList, (UINT) sizeof(DWORD)))
	{
		hr = E_INVALIDARG;
		goto out_nomutex;
	}

	DISPLAYPARAMETERS(	SET_RESOURCES_ID,
						lpResourceList,
						0,
						0,
						0,
						0);

	ACQMUTEX(g_hQoSMutex);

	if (!m_bQoSEnabled)
		// just return
		goto out;

	/*
	 *	Get configurable resource info
	 */

	pResource=lpResourceList->aResources;
	for (i=0; i < lpResourceList->cResources; i++)
	{
		TCHAR szKey[10];		// should be way enough for a resource ID
		int nUnits=INT_MAX;
		int nLeaveUnused=0;

		// build and open the key
		wsprintf(szKey, "%d", pResource[i].resourceID);

		RegEntry reQosResource(szKey, reQoSResourceRoot.GetKey(), FALSE, KEY_READ);

		
		// MaxUnits:
		// run through the list of resources and make sure none of the
		// resources was set to a number of units above the allowed maximum
		// if it was, trim and warn

		// get maximum numbers for the resource, if any, from the registry
		nUnits = reQosResource.GetNumberIniStyle(TEXT("MaxUnits"), INT_MAX);
	
		// is the client trying to set the resource to a higher value ?
		if (pResource[i].nUnits > nUnits)
		{
			pResource[i].nUnits = nUnits;
			hr = QOS_W_MAX_UNITS_EXCEEDED;
		}
		
		// LeaveUnused:
		// leave some of the resource unused, as configured	

		// use different default value depending on the resource
		switch (pResource[i].resourceID)
		{
		case RESOURCE_OUTGOING_BANDWIDTH:
			nLeaveUnused = 30;
			break;
		default:
			nLeaveUnused = 10;
			break;
		}

		nLeaveUnused = reQosResource.GetNumberIniStyle(	TEXT("LeaveUnused"),
														nLeaveUnused);

		pResource[i].nUnits = (pResource[i].nUnits * (100 - nLeaveUnused)) / 100;
	}

	/*
	 *	Add the resource to the list
	 */

	// run through the input resource list and store the resources
	// resource availability is NOT accumulative
	pResource=lpResourceList->aResources;
	for (i=0; i < lpResourceList->cResources; i++)
	{
		pResourceInt = m_pResourceList;
		pPrevResourcefLink = &m_pResourceList;
		fResourceFound = FALSE;
		while (pResourceInt != 0)
		{
			if (pResourceInt->resource.resourceID == pResource[i].resourceID)
			{	// found a match
				// did the total number of units change for this resource ?
				if (pResourceInt->resource.nUnits != pResource[i].nUnits)
				{
					// update the now available units
					// since we could end up with less units than what was allocated
					// we are issuing a NotifyNow at the end of this call
					pResourceInt->nNowAvailUnits =	pResource[i].nUnits -
													(pResourceInt->resource.nUnits -
													pResourceInt->nNowAvailUnits);
					if (pResourceInt->nNowAvailUnits < 0)
						pResourceInt->nNowAvailUnits = 0;
				}

				// override the previous setting
				RtlCopyMemory(	&(pResourceInt->resource),
								&(pResource[i]),
								sizeof(RESOURCE));
				fResourceFound = TRUE;
				break;
			}

			// not this one. try next one.
			pPrevResourcefLink = &(pResourceInt->fLink);
			pResourceInt = pResourceInt->fLink;
		
		}	// while

		if (fResourceFound)
			continue;

		// not found. add the resource
		pResourceInt = (LPRESOURCEINT) MEMALLOC(sizeof(RESOURCEINT));
		ASSERT(pResourceInt);
		if (!pResourceInt)
		{
			ERRORMSG(("IQoS::SetResources: MEMALLOC failed on RESOURCEINT\n"));
			hr = E_OUTOFMEMORY;
			goto out;
		}

		// copy the resource in
		RtlCopyMemory(	&(pResourceInt->resource),
						&(pResource[i]),
						sizeof(RESOURCE));
		pResourceInt->fLink = NULL;
		pResourceInt->nNowAvailUnits = pResourceInt->resource.nUnits;
		*pPrevResourcefLink = pResourceInt;

		// increment the number of resources we're tracking
		// this number will never go down
		m_cResources++;

		// next resource

	}	// for

	// since there was a possible change in the resource availability,
	// run an immediate notification cycle
	if (SUCCEEDED(hr))
		NotifyNow();

out:
	DISPLAYQOSOBJECT();
	RELMUTEX(g_hQoSMutex);

out_nomutex:
	DEBUGMSG(ZONE_IQOS,("IQoS::SetResources - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::GetResources

    Purpose   : Gets the list of resources available to the QoS module

    Parameters: lppResourceList - an address where QoS will place a pointer
					to a buffer with the list of resources available to QoS.
					The caller must use CQoS::FreeBuffer to free this buffer.

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::GetResources (LPRESOURCELIST *lppResourceList)
{
	HRESULT hr = NOERROR;
	ULONG i;
	LPRESOURCELIST prl=NULL;
	LPRESOURCEINT pResourceInt=NULL;
	RESOURCE *pResource=NULL;

	DEBUGMSG(ZONE_IQOS,("IQoS::GetResources\n"));

	/*
	 *	parameter validation
	 */

	// lpResourceList should at least have a count DWORD
	if (!lppResourceList || IsBadWritePtr(lppResourceList, (UINT) sizeof(DWORD)))
	{
		hr = E_INVALIDARG;
		goto out_nomutex;
	}

	// no list yet
	*lppResourceList = NULL;

	if (!m_bQoSEnabled)
		// just return
		goto out_nomutex;

	ACQMUTEX(g_hQoSMutex);

	/*
	 *	Get resource info
	 */

	// allocate a buffer for the resources info
	prl = (LPRESOURCELIST) MEMALLOC(sizeof(RESOURCELIST) +
									((LONG_PTR)m_cResources-1)*sizeof(RESOURCE));
	if (!prl)
	{
		hr = E_OUTOFMEMORY;
		ERRORMSG(("GetResources: MEMALLOC failed\n"));
		goto out;
	}

	RtlZeroMemory((PVOID) prl, sizeof(RESOURCELIST) +
									((LONG_PTR)m_cResources-1)*sizeof(RESOURCE));

	// now fill in the information
	prl->cResources = m_cResources;
	pResourceInt=m_pResourceList;
	for (i=0; i < m_cResources; i++)
	{
		ASSERT(pResourceInt);

		// see if we have a NULL resource pointer
		// shouldn't happen, but we shouldn't crash if it does
		if (!pResourceInt)
		{
			hr = QOS_E_INTERNAL_ERROR;
			ERRORMSG(("GetResources: bad QoS internal resource list\n"));
			goto out;
		}

		// copy the resource info into the buffer
		RtlCopyMemory(	&(prl->aResources[i]),
						&(pResourceInt->resource),
						sizeof(RESOURCE));
		
		// next resource
		pResourceInt = pResourceInt->fLink;
	}	// for

	*lppResourceList = prl;
		
out:
	DISPLAYQOSOBJECT();
	RELMUTEX(g_hQoSMutex);

out_nomutex:
	DEBUGMSG(ZONE_IQOS,("IQoS::GetResources - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::SetClients

    Purpose   : Tells the QoS module what are the priorities of the requesting
				streams. This allows the QoS module to allocate resources
				appropriately.

    Parameters: lpClientList - list of clients and their respective
				priorities

    Returns   : HRESULT

    Comment   : client info will override an already existing info for this
				client

***************************************************************************/
HRESULT CQoS::SetClients(LPCLIENTLIST lpClientList)
{
	HRESULT hr = NOERROR;
	ULONG i;
	BOOL fClientFound=FALSE;
	LPCLIENTINT pClientInt=NULL, *pPrevClientfLink=NULL, pClientNew=NULL;;
	LPCLIENT pClient=NULL;

	DEBUGMSG(ZONE_IQOS,("IQoS::SetClients\n"));

	/*
	 *	parameter validation
	 */

	// lpClientList should at least have a count DWORD
	if (!lpClientList || IsBadReadPtr(lpClientList, (UINT) sizeof(DWORD)))
	{
		hr = E_INVALIDARG;
		goto out_nomutex;
	}

	DISPLAYPARAMETERS(	SET_CLIENTS_ID,
						lpClientList,
						0,
						0,
						0,
						0);

	ACQMUTEX(g_hQoSMutex);

	if (!m_bQoSEnabled)
		// just return
		goto out;

	// first remove existing clients that are being set again
	// this will make it easier to store clients in a priority order
	pClient=lpClientList->aClients;
	for (i=0; i < lpClientList->cClients; i++)
	{
		pClientInt = m_pClientList;
		pPrevClientfLink = &m_pClientList;
		fClientFound = FALSE;
		while (pClientInt != 0)
		{
			if (COMPARE_GUIDS(	&(pClientInt->client.guidClientGUID),
								&(pClient[i].guidClientGUID)))
			{	// found a match
				LPCLIENTINT pClientIntNext=pClientInt->fLink;

				// special case for internal calls from RequestResources
				// we want to preserve the original priority before freeing
				if (pClient[i].priority == QOS_LOWEST_PRIORITY)
					pClient[i].priority = pClientInt->client.priority;

				// free the requests for this client
				// NOTE: we're not going to recreate the request list from
				// the one in the resource list. it will be created on the
				// fly when needed.
				FreeListOfRequests(&(pClientInt->pRequestList));

				// free the client record
				MEMFREE(pClientInt);
				*pPrevClientfLink = pClientIntNext;
				fClientFound = TRUE;
				break;
			}

			// not this one. try next one.
			pPrevClientfLink = &(pClientInt->fLink);
			pClientInt = pClientInt->fLink;
		
		}	// while

		// next resource

	}	// for

	// now store the clients in the input list in priority order
	pClient=lpClientList->aClients;
	for (i=0; i < lpClientList->cClients; i++)
	{
		pClientInt = m_pClientList;
		pPrevClientfLink = &m_pClientList;
		while (pClientInt != 0)
		{
			// as long as the priority of the new client is higher than or equal to the one
			// in the list, we continue to traverse the list
			if (pClient[i].priority < pClientInt->client.priority)
			{	// this is the place to insert this client
				break;
			}

			// not time to insert yet. next client
			pPrevClientfLink = &(pClientInt->fLink);
			pClientInt = pClientInt->fLink;
		
		}	// while

		// not found. add the client
		pClientNew = (LPCLIENTINT) MEMALLOC(sizeof(CLIENTINT));
		ASSERT(pClientNew);
		if (!pClientNew)
		{
			ERRORMSG(("IQoS::SetClients: MEMALLOC failed on CLIENTINT\n"));
			hr = E_OUTOFMEMORY;
			goto out;
		}

		// copy the resource in
		RtlCopyMemory(	&(pClientNew->client),
						&(pClient[i]),
						sizeof(CLIENT));
		pClientNew->fLink = pClientInt;
		*pPrevClientfLink = pClientNew;

		// next resource

	}	// for

out:
	DISPLAYQOSOBJECT();
	RELMUTEX(g_hQoSMutex);

out_nomutex:
	DEBUGMSG(ZONE_IQOS,("IQoS::SetClients -leave, hr=0x%x\n", hr));
	return hr;
}


/***************************************************************************

    Name      : CQoS::NotifyNow

    Purpose   : Tells the QoS module to initiate a notification cycle as
				soon as possible.

    Parameters: None

    Returns   : HRESULT

    Comment   : Don't call from within a notify proc.

***************************************************************************/
HRESULT CQoS::NotifyNow(void)
{
	HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_IQOS,("IQoS::NotifyNow\n"));

	SetEvent(m_evImmediateNotify);

	DEBUGMSG(ZONE_IQOS,("IQoS::NotifyNow - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::FreeBuffer

    Purpose   : Frees a buffer allocated by the QoS module.

    Parameters: lpBuffer - a pointer to the buffer to free. This buffer must
					have been allocated by QoS

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::FreeBuffer(LPVOID lpBuffer)
{
	HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_IQOS,("IQoS::FreeBuffer\n"));

	if (lpBuffer)
		MEMFREE(lpBuffer);

	DEBUGMSG(ZONE_IQOS,("IQoS::FreeBuffer - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::CQoS

    Purpose   : The CQoS object constructor

    Parameters: none

    Returns   : None

    Comment   :

***************************************************************************/
inline CQoS::CQoS (void)
{
	m_cRef = 0;	// will be bumped to 1 by the explicit QI in CreateQoS
	m_pResourceList = NULL;
	m_cResources = 0;
	m_pClientList = NULL;
	m_evThreadExitSignal = NULL;
	m_evImmediateNotify = NULL;
	m_hThread = NULL;
	m_bQoSEnabled = TRUE;
	m_bInNotify = FALSE;
	m_nSkipHeartBeats = 0;
	m_hWnd = NULL;
	m_nLeaveForNextPri = 5;
	// can't use ++ because RISC processors may translate to several instructions
	InterlockedIncrement((long *) &g_cQoSObjects);
}

/***************************************************************************

    Name      : CQoS::~CQoS

    Purpose   : The CQoS object destructor

    Parameters: none

    Returns   : None

    Comment   :

***************************************************************************/
inline CQoS::~CQoS (void)
{
	// can't use ++ because RISC processors may translate to several instructions
	InterlockedDecrement((long *) &g_cQoSObjects);
	g_pQoS = (CQoS *)NULL;
}

/***************************************************************************

    Name      : CQoS::Initialize

    Purpose   : Initializes the QoS object

    Parameters:	None

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::Initialize(void)
{
	HRESULT hr=NOERROR;
    OSVERSIONINFO tVersionInfo;

	/*
	 *	Initialize the object
	 */

	ACQMUTEX(g_hQoSMutex);


	// first see if QoS is enabled
	RegEntry reQoS(QOS_KEY,
					HKEY_LOCAL_MACHINE,
					FALSE,
					KEY_READ);

	m_bQoSEnabled = reQoS.GetNumberIniStyle(TEXT("Enable"), TRUE);
	
	if (!m_bQoSEnabled)
	{
		// don't create a thread, but return success
		DEBUGMSG(ZONE_IQOS,("Initialize: QoS not enabled\n"));
		hr = NOERROR;
		goto out;
	}

	/*
	 *	QoS notification thread
	 */

	// create an event that will be used to signal the thread to terminate
	// CreateEvent(No security attr's, no manual reset, not signalled, no name)
	m_evThreadExitSignal = CreateEvent(NULL, FALSE, FALSE, NULL);
	ASSERT(m_evThreadExitSignal);
	if (!(m_evThreadExitSignal))
	{
		ERRORMSG(("Initialize: Exit event creation failed: %x\n", GetLastError()));
		hr = E_FAIL;
		goto out;
	}

	// create an event that will be used to signal the thread to initiate
	// an immediate notify cycle
	// CreateEvent(No security attr's, no manual reset, not signalled, no name)
	m_evImmediateNotify = CreateEvent(NULL, FALSE, FALSE, NULL);
	ASSERT(m_evImmediateNotify);
	if (!(m_evImmediateNotify))
	{
		ERRORMSG(("Initialize: Immediate notify event creation failed: %x\n", GetLastError()));
		hr = E_FAIL;
		goto out;
	}


    //Set the OS flag
    tVersionInfo.dwOSVersionInfoSize=sizeof (OSVERSIONINFO);
    if (!(GetVersionEx (&tVersionInfo))) {
		ERRORMSG(("Initialize: Couldn't get version info: %x\n", GetLastError()));
		hr = E_FAIL;
		goto out;
    }

    if (tVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
        bWin9x=TRUE;
    }else {
        if (tVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            bWin9x=FALSE;
        }else {
            //How on earth did we get here?
            ASSERT (0);
            hr=E_FAIL;
            goto out;

        }
    }


out:
	RELMUTEX(g_hQoSMutex);
	return hr;
}


/***************************************************************************

    Name      : CreateQoS

    Purpose   : Creates the QoS object and return an IQoS interface pointer

    Parameters:

    Returns   : HRESULT

    Comment   : CreateQoS will only create one instance of the QoS object.
				Additional calls will return the same interface pointer

***************************************************************************/
extern "C" HRESULT WINAPI CreateQoS (	IUnknown *punkOuter,
										REFIID riid,
										void **ppv)
{
	CQoS *pQoS;
	HRESULT hr = NOERROR;

	*ppv = 0;
	if (punkOuter)
		 return CLASS_E_NOAGGREGATION;

	/*
	 *	instantiate the QoS object
	 */

	ACQMUTEX(g_hQoSMutex);

	// only instantiate a new object if it doesn't already exist
	if (g_cQoSObjects == 0)
	{
		if (!(pQoS = new CQoS))
		{
			hr = E_OUTOFMEMORY;
			goto out;
		}

		// Save pointer
		g_pQoS = pQoS;
	
		// initialize the QoS object
		hr = pQoS->Initialize();
	
	}
	else
	{
		// this is the case when the object was already instantiaed in this
		// process, so we only want to return the object pointer.
		pQoS = g_pQoS;
	}

	// must have only one QoS object at this point
	ASSERT(g_cQoSObjects == 1);
	
	RELMUTEX(g_hQoSMutex);

	// get the IQoS interface for the caller
	if (pQoS)
	{
		// QueryInterface will get us the interface pointer and will AddRef
		// the object
		hr = pQoS->QueryInterface (riid, ppv);
	}
	else
		hr = E_FAIL;

out:
	return hr;
}

/***************************************************************************

    Name      : QoSEntryPoint

    Purpose   : Called by nac.dll (where the QoS lives these days) to make
				the necessary process attach and detach initializations

    Parameters:	same as a standard DllEntryPoint

    Returns   :


***************************************************************************/
extern "C" BOOL APIENTRY QoSEntryPoint(	HINSTANCE hInstDLL,
										DWORD dwReason,
										LPVOID lpReserved)
{
	BOOL fRet=TRUE;

	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
			QOSDEBUGINIT();

			// create a no-name mutex to control access to QoS object data
			if (!g_hQoSMutex)
			{
				g_hQoSMutex = CreateMutex(NULL, FALSE, NULL);
				ASSERT(g_hQoSMutex);
				if (!g_hQoSMutex)
				{
					ERRORMSG(("QoSEntryPoint: CreateMutex failed, 0x%x\n", GetLastError()));
					fRet = FALSE;
				}
			}
			break;

		case DLL_PROCESS_DETACH:
			if (g_hQoSMutex)
				CloseHandle(g_hQoSMutex);
			g_hQoSMutex = NULL;
			DBGDEINIT(&ghDbgZoneQoS);
			break;

		default:
			break;
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\qos\thread.cpp ===
/*
 -  THREAD.CPP
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	Quality of Service Notification Thread
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		10.30.96	Yoram Yaacovi		Created
 *
 *	Functions:
 *		CQoS::StartQoSThread
 *		CQoS::StopQoSThread
 *		CQoS::QoSThread
 *		QoSThreadWrapper
 */

#include "precomp.h"

/***************************************************************************

    Name      : CQoS::StartQoSThread

    Purpose   : Starts a QoS notification thread

    Parameters: None

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::StartQoSThread(void)
{
	HRESULT hr=NOERROR;
	HANDLE hThread;
	DWORD idThread;

	// prepare the structrue for the thread

	// now spwan the thread
	hThread = CreateThread (NULL,
							0,						// Default (same as main thread) stack size
							(LPTHREAD_START_ROUTINE) QoSThreadWrapper,
							(LPVOID) this,			// Pass the object pointer to thread
							0,						// Run thread now
							&idThread);
	ASSERT(hThread);
	if (!hThread)
	{
		ERRORMSG(("StartQoSThread: failed to create thread: %x\n", GetLastError()));
		hr = E_FAIL;
	}

	m_hThread = hThread;
		
	return hr;
}

/***************************************************************************

    Name      : CQoS::StopQoSThread

    Purpose   : Stops a QoS notification thread

    Parameters: None

	Returns   : HRESULT

    Comment   : It is assumed that when the thread that calls StopQoSThread
				has the QoS mutex.

***************************************************************************/
HRESULT CQoS::StopQoSThread(void)
{
	HRESULT hr=NOERROR;
	HANDLE evExitSignal=m_evThreadExitSignal;
	DWORD dwExitCode=0;
	ULONG i=0;
	HANDLE hThread=NULL;

	if (m_hThread)
	{
		// tell the thread to exit
		SetEvent(evExitSignal);

		hThread = m_hThread;
		m_hThread = NULL;

		// the thread might need the mutex to exit
		RELMUTEX(g_hQoSMutex);

		// wait for the thread to terminate
		if (WaitForSingleObject(hThread, 1000) == WAIT_TIMEOUT)
		{
			// if it didn't take its own life, you take it...
			DEBUGMSG(ZONE_THREAD,("StopQoSThread: QoS thread didn't properly terminate within 1 second. Terminating it\n"));
			TerminateThread(hThread, 0);
		}

		// re-acquire the mutex (for balance)
		ACQMUTEX(g_hQoSMutex);

		CloseHandle(hThread);
	}
		
	return hr;
}


/***************************************************************************

    Name      : CQoS::NotifyQoSClient

    Purpose   : Notifies a QoS client on change in resource availability

    Parameters:

	Returns   : HRESULT

    Comment   : prrl is a pointer to a list of resource requests. This
				list has two purposes:
				1.	The QoS module will fill the list with the current
					availability of resources
				2.	The client will fill the list with its resource requests
				The QoS module is allocating the memory for the resource
				requests list. It will allocate one resource request per
				each available resource.

***************************************************************************/
HRESULT CQoS::NotifyQoSClient(void)
{
	HRESULT hr=NOERROR;
	LPRESOURCEREQUESTLIST prrl=NULL;
	LPRESOURCEINT pr=NULL;
	LPCLIENTINT pc=NULL;
	ULONG cResources=m_cResources;
	LPRESOURCEINT pResourceList=m_pResourceList;

	/*
	 *	here's what happens:
	 *
	 *	the QoS module creates a new resource list from the old one,
	 *	making all resources fully available. It satisfies the new
	 *	client resource requests from this new list.
	 */

	// don't bother if no clients or no resources
	if (!m_pClientList || !m_pResourceList)
	{
		goto out;
	}

	// first update the request list for all clients
	pc = m_pClientList;
	while (pc)
	{
		UpdateRequestsForClient (&(pc->client.guidClientGUID));
		pc = pc->fLink;
	}

	// we are going to wipe all requests from the resource
	// lists, and set all resources back to full availability
	pr = m_pResourceList;
	while (pr)
	{
		// free the request list
		FreeListOfRequests(&(pr->pRequestList));

		// set the resource back to full availability
		pr->nNowAvailUnits = pr->resource.nUnits;

		// next resource
		pr = pr->fLink;
	}

	/*
	 *	Build resource request lists for each client and call it
	 */
	// allocate space for the resource list (which already includes
	// space for one resource), plus (cResources-1) more resources
	prrl = (LPRESOURCEREQUESTLIST) MEMALLOC(sizeof(RESOURCEREQUESTLIST) +
									(cResources-1)*sizeof(RESOURCEREQUEST));
	if (!prrl)
	{
		hr = E_OUTOFMEMORY;
		ERRORMSG(("NotifyQoSClient: MEMALLOC failed in NotifyQoSClient\n"));
		goto out;
	}

	RtlZeroMemory((PVOID) prrl, sizeof(RESOURCEREQUESTLIST) +
									(cResources-1)*sizeof(RESOURCEREQUEST));

	// call each client, in order of priority, with the available resource list
	pc = m_pClientList;
	while (pc)
	{
		LPFNQOSNOTIFY pNotifyProc=NULL;
		DWORD_PTR dwParam=0;
		LPGUID lpGUID=NULL;
		ULONG i=0;
		LPRESOURCEREQUESTINT pcrr=NULL;
		ULONG nSamePriClients=1;
		ULONG nLowerPriClients=0;

		/*
		 *	Building the request list
		 */

		pcrr = pc->pRequestList;
		while (pcrr)
		{
			// remember the address of the notify proc for this client and its GUID
			pNotifyProc = pcrr->pfnQoSNotify;
			dwParam = pcrr->dwParam;
			lpGUID = &(pcrr->guidClientGUID);

			// add the resource to the requestlist we'll send to this client
			prrl->aRequests[i].resourceID = pcrr->sResourceRequest.resourceID;

			// find current availability of the resource
			pr = m_pResourceList;
			while (pr)
			{
				if (pr->resource.resourceID == pcrr->sResourceRequest.resourceID)
				{
					ULONG nNowAvailUnits=pr->nNowAvailUnits;

					// find if there are other clients for this resource
					FindClientsForResource(	pr->resource.resourceID,
											pc,
											&nSamePriClients,
											&nLowerPriClients);

					// leave some of the resource for the next priority clients, if any
					if (nLowerPriClients)
						nNowAvailUnits  = (nNowAvailUnits * (100 - m_nLeaveForNextPri)) / 100;

					prrl->aRequests[i].nUnitsMin = nNowAvailUnits / nSamePriClients;
					prrl->aRequests[i].nUnitsMax = nNowAvailUnits;
					break;
				}

				// next resource
				pr = pr->fLink;
			}

			// next request in the list we're making
			i++;

			// next request
			pcrr = pcrr->fLink;
		}


		// if we have requests from this client, call its notify callback
		prrl->cRequests = i;
		if (pNotifyProc)
		{
			// call the notify callback
			hr = (pNotifyProc)(prrl, dwParam);

			if (SUCCEEDED(hr))
			{
				// the returned request list contains what the client wants
				// request them on behalf of the client
				// let RequestResources know that we're calling from the notify proc
				m_bInNotify = TRUE;
				hr = RequestResources(lpGUID, prrl, pNotifyProc, dwParam);
				if (FAILED(hr))
				{
					ERRORMSG(("NotifyQoSClient: client returned bad resource request list\n"));
				}
				m_bInNotify = FALSE;
			}
		}

		pc = pc->fLink;
	}

out:
	if (prrl)
		MEMFREE(prrl);

	return hr;
}

/***************************************************************************

    Name      : CQoS::QoSThread

    Purpose   : QoS notification thread

    Parameters: None

	Returns   :

    Comment   :

***************************************************************************/
DWORD CQoS::QoSThread(void)
{
	int nTimeout;
	ULONG rc=0;
	HANDLE evSignalExit=m_evThreadExitSignal;
	HANDLE aHandles[2] = {m_evThreadExitSignal, m_evImmediateNotify};

	// wake up every N seconds and notify clients
	RegEntry reQoS(QOS_KEY,
					HKEY_LOCAL_MACHINE,
					FALSE,
					KEY_READ);

	nTimeout = reQoS.GetNumberIniStyle(TEXT("Timeout"), 3000);

	while (1)
	{
		rc = WaitForMultipleObjects(2, aHandles, FALSE, nTimeout);

		// if a timeout or a signal to do an immediate notify cycle...
		if ((rc == WAIT_TIMEOUT) || ((rc - WAIT_OBJECT_0) == 1))
		{	// ..do it
			ACQMUTEX(g_hQoSMutex);

			// NOTE: it is possible that while waiting on the mutex, the thread
			// was stopped (no more requests). In this case, the thread will do
			// a unnecessary (though harmless, since no requests) notify cycle

			DEBUGMSG(ZONE_THREAD,("QoSThread: Notify thread heartbeat, why=%s\n",
						(rc == WAIT_TIMEOUT ? "timeout" : "notify")));
		
			// notify clients, unless this heartbeat should be skipped
			if (m_nSkipHeartBeats == 0)
			{
				DEBUGMSG(ZONE_THREAD,("QoSThread: Notifying client\n"));
				NotifyQoSClient();
			}

			// update the skip counter
			(m_nSkipHeartBeats ? m_nSkipHeartBeats-- : 0);

			RELMUTEX(g_hQoSMutex);
		}

		// anything else (WAIT_FAILED, Exit signal), bail out
		else
			break;
	}
		
	// this is just like ExitThread()
	DEBUGMSG(ZONE_THREAD,("QoSThread: Notify thread exiting...\n"));
	return 0L;

}

/***************************************************************************

    Name      : QoSThreadWrapper

    Purpose   : Wrapper for the QoS notification thread

    Parameters: pQoS - pointer to the QoS object

	Returns   :

    Comment   :

***************************************************************************/
DWORD QoSThreadWrapper(CQoS *pQoS)
{
	return pQoS->QoSThread();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rrcminc\isdmapi.h ===
#ifndef _ISDMAPI_H_
#define _ISDMAPI_H_

/****************************************************************************
 *
 *	$Archive: /rtp/support/isdm/ISDMAPI.H $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision: 5 $
 *	$Date: 6/13/96 2:55p $
 *	$Author: Cmaciocc $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/


#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport

typedef DWORD	HSTATSESSION,	*LPHSTATSESSION;

#define MAX_SESSNAME_LENGTH		25 
#define MAX_MODNAME_LENGTH		20
#define MAX_SESSIDENT_LENGTH	256 //consistant with max cName length
#define MAX_STATNAME_LENGTH		256
//stat item string name
typedef char STATNAME[MAX_STATNAME_LENGTH], *LPSTATNAME;
//session string name
typedef char SESSIONNAME[MAX_SESSNAME_LENGTH], *LPSESSIONNAME;
//module name
typedef char MODULENAME[MAX_MODNAME_LENGTH], *LPMODULENAME;
//identifier length
typedef char SESSIONIDENT[MAX_SESSIDENT_LENGTH], *LPSESSIONIDENT;


typedef struct STATSTRUCT
{
	DWORD		dwStructSize;				// size of the structure
	STATNAME	szStatName;					// string name of the stat item
	DWORD		dwToken;					// session unique id of the stat item
	DWORD		dwValue;					// value(data) of the stat item
	DWORD		dwLow;						// low value for range of value
	DWORD		dwHigh;						// hi value for range of value
	DWORD		dwLastUpdate;				// time stamp of last update
} STAT, *LPSTAT;

// Typedefs for ISDM application entry points to ensure stricter checking
// when functions are called via pointers
//
typedef HRESULT		(*ISD_REGISTER_SESSION)		(LPMODULENAME, LPSESSIONNAME, LPSESSIONIDENT, LPHSTATSESSION);
typedef HRESULT		(*ISD_CREATESTAT)			(HSTATSESSION, LPSTAT, WORD);
typedef HRESULT		(*ISD_UNREGISTERSESSION)	(HSTATSESSION);
typedef HRESULT		(*ISD_DELETESTAT)			(HSTATSESSION, LPSTAT, WORD);
typedef HRESULT		(*ISD_UPDATESTAT)			(HSTATSESSION, LPSTAT, WORD);
typedef HRESULT		(*ISD_GETFIRSTSESSION)		(LPMODULENAME, LPSESSIONNAME, LPSESSIONIDENT, LPHSTATSESSION);
typedef HRESULT		(*ISD_GETNEXTSESSION)		(HSTATSESSION, LPMODULENAME, LPSESSIONNAME, LPSESSIONIDENT, LPHSTATSESSION);
typedef HRESULT		(*ISD_GETNUMSESSIONS)		(WORD *);
typedef HRESULT		(*ISD_GETFIRSTSTAT)			(HSTATSESSION, LPSTAT);
typedef HRESULT		(*ISD_GETNEXTSTAT)			(HSTATSESSION, LPSTAT, LPSTAT);
typedef HRESULT		(*ISD_GETNUMSTATS)			(HSTATSESSION, WORD *);
typedef HRESULT		(*ISD_GETSESSIONSTATS)		(HSTATSESSION, LPSTAT, WORD);

typedef struct _ISDMAPI
{
	ISD_REGISTER_SESSION	ISD_RegisterSession;
	ISD_CREATESTAT			ISD_CreateStat;
	ISD_UNREGISTERSESSION	ISD_UnregisterSession;
	ISD_DELETESTAT			ISD_DeleteStat;
	ISD_UPDATESTAT			ISD_UpdateStat;
	ISD_GETFIRSTSESSION		ISD_GetFirstSession;
	ISD_GETNEXTSESSION		ISD_GetNextSession;
	ISD_GETNUMSESSIONS		ISD_GetNumSessions;
	ISD_GETFIRSTSTAT		ISD_GetFirstStat;
	ISD_GETNEXTSTAT			ISD_GetNextStat;
	ISD_GETNUMSTATS			ISD_GetNumStats;
	ISD_GETSESSIONSTATS		ISD_GetSessionStats;
}
ISDMAPI, *LPISDMAPI;

//HRESULT error defines
#define ISDM_ERROR_BASE 0x7000

#define ERROR_HIT_MAX_SESSIONS		ISDM_ERROR_BASE + 1
#define ERROR_HIT_MAX_STATS			ISDM_ERROR_BASE + 2
#define ERROR_ACCESSING_SESSION		ISDM_ERROR_BASE + 3
#define ERROR_SESSION_EXISTS		ISDM_ERROR_BASE + 4
#define ERROR_INVALID_SESS_HANDLE	ISDM_ERROR_BASE + 5
#define ERROR_INVALID_STAT_HANDLE	ISDM_ERROR_BASE + 6
#define ERROR_NO_SESSIONS			ISDM_ERROR_BASE + 7
#define ERROR_NO_STATS				ISDM_ERROR_BASE + 8
#define ERROR_SESSION_NOT_FOUND		ISDM_ERROR_BASE + 9
#define ERROR_MUTEX_WAIT_FAIL		ISDM_ERROR_BASE + 10
#define ERROR_TOKEN_NOT_UNIQUE		ISDM_ERROR_BASE + 11
#define ERROR_NO_FREE_SESSIONS		ISDM_ERROR_BASE + 12
#define ERROR_SESSION_GET_FAIL		ISDM_ERROR_BASE + 13
#define ERROR_BAD_STAT_ARRAY		ISDM_ERROR_BASE + 14
#define ERROR_BAD_STAT_TOKEN		ISDM_ERROR_BASE + 15
#define ERROR_BAD_SESSION_NAME		ISDM_ERROR_BASE + 16
#define ERROR_NO_FREE_STATS			ISDM_ERROR_BASE + 17
#define ERROR_BAD_MODULE_NAME		ISDM_ERROR_BASE + 18

//token defines
//RRCM
#define RRCM_LOCAL_STREAM				1
#define RRCM_REMOTE_STREAM				2

#define ISDM_TOKEN_BASE 0x0000

#define ISDM_CC_CODEC					ISDM_TOKEN_BASE + 1
#define ISDM_CC_REMOTE					ISDM_TOKEN_BASE + 2
#define ISDM_CC_LOCAL					ISDM_TOKEN_BASE + 3

#define ISDM_RRCM_BASE 0x1000

#define ISDM_SSRC						ISDM_RRCM_BASE + 1
#define ISDM_NUM_PCKT_SENT				ISDM_RRCM_BASE + 2
#define ISDM_NUM_BYTES_SENT				ISDM_RRCM_BASE + 3
#define ISDM_FRACTION_LOST				ISDM_RRCM_BASE + 4
#define ISDM_CUM_NUM_PCKT_LOST			ISDM_RRCM_BASE + 5
#define ISDM_XTEND_HIGHEST_SEQ_NUM		ISDM_RRCM_BASE + 6
#define ISDM_INTERARRIVAL_JITTER		ISDM_RRCM_BASE + 7
#define ISDM_LAST_SR					ISDM_RRCM_BASE + 8
#define ISDM_DLSR						ISDM_RRCM_BASE + 9
#define ISDM_NUM_BYTES_RCVD				ISDM_RRCM_BASE + 10
#define ISDM_NUM_PCKT_RCVD				ISDM_RRCM_BASE + 11
#define ISDM_NTP_FRAC					ISDM_RRCM_BASE + 12
#define ISDM_NTP_SEC					ISDM_RRCM_BASE + 13
#define ISDM_WHO_AM_I					ISDM_RRCM_BASE + 14
#define ISDM_FDBK_FRACTION_LOST			ISDM_RRCM_BASE + 15
#define ISDM_FDBK_CUM_NUM_PCKT_LOST		ISDM_RRCM_BASE + 16
#define ISDM_FDBK_LAST_SR				ISDM_RRCM_BASE + 17
#define ISDM_FDBK_DLSR					ISDM_RRCM_BASE + 18
#define ISDM_FDBK_INTERARRIVAL_JITTER	ISDM_RRCM_BASE + 19


//
//Supplier calls 
//

//registration call
//This call is made whenever a new session is desired. The session name passed in must be unique
//across all sessions.
extern DllExport HRESULT ISD_RegisterSession
(
	LPMODULENAME		pszModuleName,		// module who owns session
	LPSESSIONNAME		pszSessionName,		// string name of new session to register
	LPSESSIONIDENT		pszSessionIdent,	// further level identifier for session
	LPHSTATSESSION		phSession			// return; handle to new session
);

//stat creation call
//add 1+ stat item(s) to a session. 
extern DllExport HRESULT ISD_CreateStat
(
	HSTATSESSION		hSession,			// handle to session
	LPSTAT				pStatArray,		// array of structs holding new stats to create
	WORD				wNumItems			// size of array(number of new stats)
);

//unregistration call
//deletes a session and all associated stat structs
extern DllExport HRESULT ISD_UnregisterSession
(
	HSTATSESSION		hSession			// handle of session to remove
);

//stat deletion call
//delete 1+ stat item(s) from a session
extern DllExport HRESULT ISD_DeleteStat
(
	HSTATSESSION		hSession,			// handle to session
	LPSTAT				pStatArray,			// array of structs
	WORD				wNumItems			// size of array(number of stats to remove)
);

//set stat data call
extern DllExport HRESULT ISD_UpdateStat
(
	HSTATSESSION		hSession,			// handle of session with stat item(s)
	LPSTAT				pStatArray,			// array of structs holding items to update
	WORD				wNumItems			// size of array(number of stats to update)
);

//
//Consumer calls 
//

//query calls
//session query
extern DllExport HRESULT ISD_GetFirstSession
(
	LPMODULENAME		pszModuleName,		// module who owns session
	LPSESSIONNAME		pszSessionName,		// string name of new session to register
	LPSESSIONIDENT		pszSessionIdent,	// further level identifier for session
	LPHSTATSESSION		phSession			// return; the session handle or null if empty list
);

//GetNext uses hCurSession to determine the next item..returned in phNextSession
extern DllExport HRESULT ISD_GetNextSession
(
	HSTATSESSION		hCurSession,		// the current session handle
	LPMODULENAME		pszModuleName,		// module who owns session
	LPSESSIONNAME		pszSessionName,		// string name of new session to register
	LPSESSIONIDENT		pszSessionIdent,	// further level identifier for session
	LPHSTATSESSION		phNextSession		// return; the session handle or null if at the end
);

extern DllExport HRESULT ISD_GetNumSessions
(
	WORD				*wNumSessions		// return; number of sessions
);

//stat query..retreive structs for the first time(get unique ids..initial values..etc)
extern DllExport HRESULT ISD_GetFirstStat
(
	HSTATSESSION		hSession,			// handle to session containing stat
	LPSTAT				pStat				// return; filled struct for first stat item
);

//pCurrentStat and pNextStat can be identical for saving memory.
extern DllExport HRESULT ISD_GetNextStat
(
	HSTATSESSION		hSession,			// handle to session containing stat
	LPSTAT				pCurrentStat,		// pointer to current stat item(for determining next)
	LPSTAT				pNextStat			// return; filled struct for next stat item
);

extern DllExport HRESULT ISD_GetNumStats
(
	HSTATSESSION		hSession,			// what session we are interested in
	WORD				*wNumStats			// return; number of stats in session
);

//stat retreival 
extern DllExport HRESULT ISD_GetSessionStats
(
	HSTATSESSION		hSession,		// what session we are interested in
	LPSTAT				pStatArray,	// return; array of structs holding items 
	WORD				wNumStats		// return; number of items in session
);


#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // ISDTAT.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rrcminc\isrg.h ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/include/rcs/isrg.h $
  $Revision: 1 $
      $Date: 6/19/96 3:46p $
    $Author: Lscline $
    $Locker:  $

	Description
	-----------
	Interrupt Service Routine debug header file
	This module allows for a way of doing OutputDebugString()
	at interrupt time.

****************************************************************************/

#ifndef ISRG_H
#define ISRG_H

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

// Use for Win16
//#define DllExport
//#define DllImport
//#define DLL_EXPORT	_export

// Use for Win32
#define DllExport		__declspec( dllexport )
#define DllImport		__declspec( dllimport )
#define DLL_EXPORT

//
//	directions
//		Pick a number (mod 100) and create a base for the next 
//		100 entries.  Do it this way so that your numbers can
//		be easily moved.  The string assigned to the base you select
//		will be displayed as the filter string in a list box when
//		viewing.  After defining your constants go to isrdsp.rc
//		and assign strings to them.  You will need to build the
//		isrdsp.exe but not the isrdbg.dll.  You only need to
//		inlude this h file and import the functions from this
//		file into your def file.  Happy debugging.


//------------------------------------------------------------------------------
#define kModSNameSize		16
#define kModLNameSize		32

//------------------------------------------------------------------------------
// defines for tISRModule.Flags
#define kCaptureOn			0x01

//------------------------------------------------------------------------------
typedef struct _tISRModule
{
	WORD	Flags;
	BYTE	CaptureFilter;
	BYTE	DisplayFilter;
	char	zSName[kModSNameSize];	// Short name of user registered debug module
	char	zLName[kModLNameSize];	// Long name of user registered debug module
} tISRModule, FAR *ptISRModule;

//------------------------------------------------------------------------------
#define kModuleBufSize		((DWORD) (16*1024L))
#define kMaxModules			((UINT) (kModuleBufSize/sizeof(tISRModule)))


//------------------------------------------------------------------------------
typedef struct _tISRItem
{
	WORD	hISRInst;		// Our handle to registered modules
	BYTE	DbgLevel;		// Caller determined debug level
	BYTE	Flags;
	UINT	IP;				// Callers Instruction Ptr address
	DWORD	Param1;
	DWORD	Param2;
} tISRItem, FAR *ptISRItem;

//------------------------------------------------------------------------------
#define kISRBufSize			((DWORD) (32*1024L))
#define kMaxISRItems		((UINT) (kISRBufSize/sizeof(tISRItem)))
#define kMaxStrTab			((UINT) (60*1024L))


//------------------------------------------------------------------------------
// defines for tISRItem.Flags
#define kParam1IsStr		0x01
#define kParam1IsRes		0x02
#define kParam1IsNum		0x04		// Use only if passed two numbers.


//------------------------------------------------------------------------------
// Supported DbgMsg state values.
//------------------------------------------------------------------------------

// REVIEW: We build with DBG=1
#undef DBG
#define DBG 				0
#define ERR 				1

#define kISRCritical		0x01	// Progammer errors that should never happen
#define kISRError			0x02	// Errors that need to be fixed
#define kISRWarning			0x04	// The user could have problems if not corrected
#define kISRNotify			0x08	// Status, events, settings...
#define kISRTrace			0x10	// Trace info that will not overrun the system
#define kISRTemp			0x20	// Trace info that may be reproduced in heavy loops
#define kISRReserved1		0x40	// Future use
#define kISRReserved2		0x80	// Future use
#define kISRDefault			kISRReserved2	// Historical use only

#define TT_CRITICAL			kISRCritical
#define TT_ERROR			kISRError
#define TT_WARNING			kISRWarning
#define TT_NOTIFY			kISRNotify
#define TT_TRACE			kISRTrace
#define TT_TEMP				kISRTemp


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you want to output at interrupt time.
// The ISR_Hook*() functions are the same as their counterparts.  The only
// difference is that these functions need the Instruction Pointer passed
// in.  If you are using an intermediate library to encapsulate the debug
// functions then you must be responsible for pulling the IP off the stack.

// Register the module and get a handle for making debug calls.  If a debug
// call is made with an invalid handle then the results are not defined.
// It is possible to drop the debug event or to place the event into the 
// compatibility module.  If no more module handles are available then
// the handle returned will be the compatibility handle.
DllExport void WINAPI DLL_EXPORT
ISR_RegisterModule (LPWORD phISRInst, LPSTR zShortName, LPSTR zLongName);


// Allow two strings to be concatenated togeter.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgStrStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgRes (UINT IP, WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);

// Allow two strings to be concatenated togeter.
DllExport void WINAPI DLL_EXPORT
ISR_DbgStrStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_DbgRes (WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_DbgStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);


// WARNING: Call at task time only.  Not reentrant.
DllExport void FAR cdecl DLL_EXPORT
TTDbgMsg 
(
	WORD		hISRInst,	// Module's ISRDBG handle.
	BYTE		DbgLevel,	// Appropriate ISRDBG level.
	LPCSTR		zMsgFmt,	// Output format string (like printf).
	... 					// Optional parameter list.
);


// Old functions for compatibility only.
DllExport void WINAPI DLL_EXPORT
ISR_OutputDbgStr (LPSTR pzStr);

DllExport void WINAPI DLL_EXPORT
ISR_OutputStr (UINT uResId);

DllExport void WINAPI DLL_EXPORT
ISR_OutputNum (UINT uResId, DWORD Num);

// WARNING: Call at task time only.  Not reentrant.
DllExport void FAR cdecl DLL_EXPORT
DbgMsg
	(
	LPCSTR		module,
	int			state,
	LPCSTR		format_str,
	...
	);


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you need to know the state of isrdbg.dll.
// isrdsp.exe needs to do this to display the data at task time.

DllExport void WINAPI DLL_EXPORT
ISR_ClearItems (void);

DllExport UINT WINAPI DLL_EXPORT
ISR_GetNumItems (void);

DllExport ptISRItem WINAPI DLL_EXPORT
ISR_GetItem (UINT uItem,ptISRItem pItem);

DllExport ptISRModule WINAPI DLL_EXPORT
ISR_GetModule (UINT hISRInst);

DllExport int WINAPI DLL_EXPORT
ISR_SetCaptureFilter (WORD hISRInst, BYTE CaptureFilter,  BYTE DisplayFilter);


//------------------------------------------------------------------------------
//	The caller of ISR debug functions can call these Macros and then the
//	retail release will just drop all of the debug statement code.
//------------------------------------------------------------------------------
#if (DEBUG >= 1) || (_DEBUG >= 1)
#define ISRDEBUGINFO	1
extern WORD	ghISRInst;
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)	ISR_RegisterModule(pghISRInst, ShortName, LongName)
#define ISRNOTIFY(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRNotify, Str, Num)
#define ISRCRITICAL(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRCritical, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRError, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRWarning, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTrace, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTemp, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved1, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved2, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRNotify, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRCritical, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRError, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRWarning, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTrace, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTemp, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved1, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved2, Str, Str2)

#define TTDBG			TTDbgMsg

#else

#define ISRNOTIFY(ghISRInst, Str, Num)
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)
#define ISRCRITICAL(ghISRInst, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)

#define ghISRInst		0
#define TTDBG			1 ? (void)0 : TTDbgMsg

#endif


//------------------------------------------------------------------------------
// Local Functions
static void
InitModules (void);

static UINT
ValidCaptureMsg (WORD hISRInst, BYTE DbgLevel);

// Local function but thunk needs to get to it
DllExport void WINAPI
OutputRec
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	DWORD	Param1,
	DWORD	Param2
	);

// Local function but thunk needs to get to it
DllExport void WINAPI
OutputRecStr
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	LPSTR	pzStr1,
	LPSTR	pzStr2,
	DWORD	Param1
	);


//------------------------------------------------------------------------------
// do not use a base of 0.  Reserved for system use.
#define ID_SysBase			0
#define ID_SysStr			(ID_SysBase + 1)
#define ID_SysSInt			(ID_SysBase + 2)
#define ID_SysUInt			(ID_SysBase + 3)
#define ID_SysDWord			(ID_SysBase + 4)
#define ID_SysLong			(ID_SysBase + 5)
#define ID_SysHex			(ID_SysBase + 6)


//------------------------------------------------------------------------------
// IsrDbg.dll
#define ID_IsrDbgBase		100
#define ID_IsrDbgLibMain	(ID_IsrDbgBase + 1)
#define ID_IsrDbgWep		(ID_IsrDbgBase + 2)
#define ID_IsrDbgReentrant	(ID_IsrDbgBase + 3)


//------------------------------------------------------------------------------
// IsrDsp.exe
#define ID_IsrDspBase		200
#define ID_IsrDspInit		(ID_IsrDspBase + 1)
#define ID_IsrDspExit		(ID_IsrDspBase + 2)


//------------------------------------------------------------------------------
// stMem.dll
#define ID_stMemBase		300
#define ID_stMemLibMain		(ID_stMemBase + 1)
#define ID_stMemWep			(ID_stMemBase + 2)
#define ID_stMemPreAlloc	(ID_stMemBase + 3)
#define ID_stMemPageLock	(ID_stMemBase + 4)
#define ID_stMemNoPageLock	(ID_stMemBase + 5)
#define ID_stMemAlloc		(ID_stMemBase + 6)
#define ID_stMemTotMem		(ID_stMemBase + 7)
#define ID_stMemstFree		(ID_stMemBase + 8)

                                                      
//-------------------------------------------------------------------------------
// DLM.dll

// Errors
#define ID_DLMErrorBase		400
#define ID_DLMEnqError      (ID_DLMErrorBase + 1)
#define ID_DLMDeqError      (ID_DLMErrorBase + 2)
#define ID_DLMFreeError     (ID_DLMErrorBase + 3)
#define ID_DLMChanError     (ID_DLMErrorBase + 4)
#define ID_DLMChanNIUErr    (ID_DLMErrorBase + 5)
#define ID_DLMChanNumErr    (ID_DLMErrorBase + 6)
#define ID_DLMInConnErr     (ID_DLMErrorBase + 7)
#define ID_DLMInSessErr     (ID_DLMErrorBase + 8)
#define ID_DLMSessNIU       (ID_DLMErrorBase + 9)
#define ID_DLMSessNO        (ID_DLMErrorBase + 10)
#define ID_DLMConnNIU       (ID_DLMErrorBase + 11)
#define ID_DLMConnNO        (ID_DLMErrorBase + 12)
#define ID_DLMIDErr         (ID_DLMErrorBase + 13)
#define ID_DLMConnErr       (ID_DLMErrorBase + 14)
#define ID_DLMSessErr       (ID_DLMErrorBase + 15)
#define ID_DLMSessNF        (ID_DLMErrorBase + 16)
#define ID_DLMNoFreeConn    (ID_DLMErrorBase + 17)
#define ID_DLMConnCloseErr  (ID_DLMErrorBase + 18)
#define ID_DLMConnNF        (ID_DLMErrorBase + 19)
#define ID_DLMConnNC        (ID_DLMErrorBase + 20)
#define ID_DLMMDMError      (ID_DLMErrorBase + 21)
#define ID_DLMNoSess        (ID_DLMErrorBase + 22)
#define ID_DLMInvalidSess   (ID_DLMErrorBase + 23)
#define ID_DLMEventErr      (ID_DLMErrorBase + 24)
#define ID_DLMNoConn        (ID_DLMErrorBase + 25)
#define ID_DLMChanCloseErr  (ID_DLMErrorBase + 26) 
#define ID_DLMInvalidConn   (ID_DLMErrorBase + 27)
#define ID_DLMCorruptQueue  (ID_DLMErrorBase + 28)
#define ID_DLMInvChanID     (ID_DLMErrorBase + 29)
#define ID_DLMChanInUse     (ID_DLMErrorBase + 30)
#define ID_DLMInvalidChan   (ID_DLMErrorBase + 31)
#define ID_DLMNoBufHdr      (ID_DLMErrorBase + 32)
#define ID_DLMEnqueueErr    (ID_DLMErrorBase + 33)
#define ID_DLMNMBufInProg   (ID_DLMErrorBase + 34)
#define ID_DLMNoBuffer      (ID_DLMErrorBase + 35)
#define ID_DLMEnterDumping  (ID_DLMErrorBase + 36)
#define ID_DLMSizeError     (ID_DLMErrorBase + 37)
#define ID_DLMNoBuf         (ID_DLMErrorBase + 38)
#define ID_DLMInitAlready   (ID_DLMErrorBase + 39)
#define ID_DLMGDLError      (ID_DLMErrorBase + 40)
#define ID_DLMNoEntryPoint  (ID_DLMErrorBase + 41)
#define ID_DLMNoEvent       (ID_DLMErrorBase + 42)
#define ID_DLMNoPackets     (ID_DLMErrorBase + 43)

// Debug level 1 messages
#define ID_DLMDebug1Base         500
#define ID_DLMCloseAllEntered    (ID_DLMDebug1Base + 1)
#define ID_DLMEstabHEntered      (ID_DLMDebug1Base + 2)
#define ID_DLMEstabHExit         (ID_DLMDebug1Base + 3)
#define ID_DLMReqHEntered        (ID_DLMDebug1Base + 4)
#define ID_DLMReqHAlloc          (ID_DLMDebug1Base + 5)
#define ID_DLMReqHExit           (ID_DLMDebug1Base + 6)
#define ID_DLMRejHEntered        (ID_DLMDebug1Base + 7)
#define ID_DLMRejHExit           (ID_DLMDebug1Base + 8)
#define ID_DLMCNoteHEntered      (ID_DLMDebug1Base + 9)
#define ID_DLMCNoteHExit         (ID_DLMDebug1Base + 10)
#define ID_DLMCComHEntered       (ID_DLMDebug1Base + 11)
#define ID_DLMCComHExit          (ID_DLMDebug1Base + 12)
#define ID_DLMSessCloseHEntered  (ID_DLMDebug1Base + 13)
#define ID_DLMSessCloseHExit     (ID_DLMDebug1Base + 14)
#define ID_DLMSessHEntered       (ID_DLMDebug1Base + 15)
#define ID_DLMSessHExit          (ID_DLMDebug1Base + 16)
#define ID_DLMBegSessEntered     (ID_DLMDebug1Base + 17)
#define ID_DLMBegSessExit        (ID_DLMDebug1Base + 18)
#define ID_DLMEndSessEntered     (ID_DLMDebug1Base + 19)
#define ID_DLMEndSessExit        (ID_DLMDebug1Base + 20)
#define ID_DLMListenEntered      (ID_DLMDebug1Base + 21)
#define ID_DLMListenExit         (ID_DLMDebug1Base + 22)
#define ID_DLMDoCloseEntered     (ID_DLMDebug1Base + 23)
#define ID_DLMDoCloseExit        (ID_DLMDebug1Base + 24)
#define ID_DLMMakeConnEntered    (ID_DLMDebug1Base + 25)
#define ID_DLMMakeConnExit       (ID_DLMDebug1Base + 26)
#define ID_DLMRejEntered         (ID_DLMDebug1Base + 27)
#define ID_DLMRejExit            (ID_DLMDebug1Base + 28)
#define ID_DLMAccEntered         (ID_DLMDebug1Base + 29)
#define ID_DLMAccExit            (ID_DLMDebug1Base + 30)
#define ID_DLMCloseConnEntered   (ID_DLMDebug1Base + 31)
#define ID_DLMCloseConnExit      (ID_DLMDebug1Base + 32)
#define ID_DLMTryEntered         (ID_DLMDebug1Base + 33)
#define ID_DLMTryExit            (ID_DLMDebug1Base + 34)
#define ID_DLMOpenEntered        (ID_DLMDebug1Base + 35)
#define ID_DLMOpenExit           (ID_DLMDebug1Base + 36)
#define ID_DLMSendEntered        (ID_DLMDebug1Base + 37)
#define ID_DLMSendExit           (ID_DLMDebug1Base + 38)
#define ID_DLMSendComEntered     (ID_DLMDebug1Base + 39)
#define ID_DLMSendComExit        (ID_DLMDebug1Base + 40)
#define ID_DLMPostEntered        (ID_DLMDebug1Base + 41)
#define ID_DLMPostExit           (ID_DLMDebug1Base + 42)
#define ID_DLMNewMsgEntered      (ID_DLMDebug1Base + 43)
#define ID_DLMNewMsgExit         (ID_DLMDebug1Base + 44)
#define ID_DLMContMsgEntered     (ID_DLMDebug1Base + 45)
#define ID_DLMContMsgExit        (ID_DLMDebug1Base + 46)
#define ID_DLMRecEntered         (ID_DLMDebug1Base + 47)
#define ID_DLMRecExit            (ID_DLMDebug1Base + 48)
#define ID_DLMCloseEntered       (ID_DLMDebug1Base + 49)
#define ID_DLMCloseExit          (ID_DLMDebug1Base + 50)
#define ID_DLMGetCharEntered     (ID_DLMDebug1Base + 51)
#define ID_DLMGetCharExit        (ID_DLMDebug1Base + 52)
#define ID_DLMInitEntered        (ID_DLMDebug1Base + 53)
#define ID_DLMInitExit           (ID_DLMDebug1Base + 54)
#define ID_DLMDeInitEntered      (ID_DLMDebug1Base + 55)
#define ID_DLMDeInitExit         (ID_DLMDebug1Base + 56)
#define ID_DLMCloseAllExit       (ID_DLMDebug1Base + 57)
#define ID_DLMEnqEntered         (ID_DLMDebug1Base + 58)
#define ID_DLMEnqExit            (ID_DLMDebug1Base + 59)
#define ID_DLMDeqEntered         (ID_DLMDebug1Base + 60)
#define ID_DLMDeqExit            (ID_DLMDebug1Base + 61)
#define ID_DLMEnqPEntered        (ID_DLMDebug1Base + 62)
#define ID_DLMEnqPExit           (ID_DLMDebug1Base + 63)


// Debug level 2 messages
#define ID_DLMDebug2Base         600
#define ID_DLMCallback           (ID_DLMDebug2Base + 1)
#define ID_DLMConnection         (ID_DLMDebug2Base + 2)
#define ID_DLMBuffer             (ID_DLMDebug2Base + 3)
#define ID_DLMSize               (ID_DLMDebug2Base + 4)
#define ID_DLMRemaining          (ID_DLMDebug2Base + 5)
#define ID_DLMReceived           (ID_DLMDebug2Base + 6)
#define ID_DLMToken              (ID_DLMDebug2Base + 7)
#define ID_DLMOChannel           (ID_DLMDebug2Base + 8)
#define ID_DLMRChannel           (ID_DLMDebug2Base + 9)
#define ID_DLMStatus             (ID_DLMDebug2Base + 10)
#define ID_DLMEndSessClosing     (ID_DLMDebug2Base + 11)
#define ID_DLMBufferSize         (ID_DLMDebug2Base + 12)
#define ID_DLMLinkPacket         (ID_DLMDebug2Base + 13)
#define ID_DLMChannel            (ID_DLMDebug2Base + 14)
#define ID_DLMInDumping          (ID_DLMDebug2Base + 15)
#define ID_DLMByteCount          (ID_DLMDebug2Base + 16)
#define ID_DLMDeqNoBuf           (ID_DLMDebug2Base + 17)
#define ID_DLMEnqPSkip           (ID_DLMDebug2Base + 18)


//------------------------------------------------------------------------------
// MDM -> mdmnbios.dll

#define ID_mdmBase				700
#define ID_mdmLibMain			(ID_mdmBase + 1)
#define ID_mdmWep				(ID_mdmBase + 2)
#define ID_mdmBadhSesUser		(ID_mdmBase + 3)
#define ID_mdmBadhConUser		(ID_mdmBase + 4)
#define ID_mdmBadhSesFree		(ID_mdmBase + 5)
#define ID_mdmBadhConFree		(ID_mdmBase + 6)
#define ID_mdmBadhSesInt		(ID_mdmBase + 7)
#define ID_mdmBadhConInt		(ID_mdmBase + 8)
#define ID_mdmNoMorehSes		(ID_mdmBase + 9)
#define ID_mdmNoMorehCon		(ID_mdmBase + 10)
#define ID_mdmWepConFree		(ID_mdmBase + 11)
#define ID_mdmActiveCon			(ID_mdmBase + 12)
#define ID_mdmBBegSes			(ID_mdmBase + 13)
#define ID_mdmEBegSes			(ID_mdmBase + 14)
#define ID_mdmBEndSes			(ID_mdmBase + 15)
#define ID_mdmEEndSes			(ID_mdmBase + 16)
#define ID_mdmBListen			(ID_mdmBase + 17)
#define ID_mdmEListen			(ID_mdmBase + 18)
#define ID_mdmBMakeCon			(ID_mdmBase + 19)
#define ID_mdmEMakeCon			(ID_mdmBase + 20)
#define ID_mdmBAcceptCon		(ID_mdmBase + 21)
#define ID_mdmEAcceptCon		(ID_mdmBase + 22)
#define ID_mdmBRejectCon		(ID_mdmBase + 23)
#define ID_mdmERejectCon		(ID_mdmBase + 24)
#define ID_mdmBCloseCon			(ID_mdmBase + 25)
#define ID_mdmECloseCon			(ID_mdmBase + 26)
#define ID_mdmErrNetBios		(ID_mdmBase + 27)
#define ID_mdmNoSendNcb			(ID_mdmBase + 28)
#define ID_mdmNoFreeSndNcbSlot	(ID_mdmBase + 29)
#define ID_mdmInvalidConState	(ID_mdmBase + 30)
#define ID_mdmInvalidParams		(ID_mdmBase + 31)
#define ID_mdmToManyListens		(ID_mdmBase + 32)
#define ID_mdmKillTheListen		(ID_mdmBase + 33)
#define ID_mdmBListenCB			(ID_mdmBase + 34)
#define ID_mdmEListenCB			(ID_mdmBase + 35)
#define ID_mdmBConnectCB		(ID_mdmBase + 36)
#define ID_mdmEConnectCB		(ID_mdmBase + 37)
#define ID_mdmBCloseCB			(ID_mdmBase + 38)
#define ID_mdmECloseCB			(ID_mdmBase + 39)
#define ID_mdmBSndCB			(ID_mdmBase + 40)
#define ID_mdmESndCB			(ID_mdmBase + 41)
#define ID_mdmBRcvCB			(ID_mdmBase + 42)
#define ID_mdmERcvCB			(ID_mdmBase + 43)


//---------------------------------------------------------------------------------
// MDM -> MDM Teleos

// Errors
#define ID_MDMTEBASE               1000
#define ID_MDMTEDeqUnackNoHead     (ID_MDMTEBASE + 1)
#define ID_MDMTEDeqUnackNoNext     (ID_MDMTEBASE + 2)
#define ID_MDMTEDeqUnackNoPrev     (ID_MDMTEBASE + 3)
#define ID_MDMTEDeqArrNoTail       (ID_MDMTEBASE + 4)
#define ID_MDMTENullTCB            (ID_MDMTEBASE + 5)
#define ID_MDMTETCBRet             (ID_MDMTEBASE + 6)
#define ID_MDMTEWinSize            (ID_MDMTEBASE + 7)
#define ID_MDMTENoLinkPacket       (ID_MDMTEBASE + 8)
#define ID_MDMTETooLarge           (ID_MDMTEBASE + 9)
#define ID_MDMTELPNotFound         (ID_MDMTEBASE + 10)
#define ID_MDMTENoTCB              (ID_MDMTEBASE + 11)
#define ID_MDMTEInitAlready        (ID_MDMTEBASE + 12)
#define ID_MDMTETCBInitFail        (ID_MDMTEBASE + 13)
#define ID_MDMTELSNErr             (ID_MDMTEBASE + 14)
#define ID_MDMTESizeError          (ID_MDMTEBASE + 15)
#define ID_MDMTEReceived           (ID_MDMTEBASE + 16)
#define ID_MDMTEExpected           (ID_MDMTEBASE + 17)
#define ID_MDMTECorruptQ           (ID_MDMTEBASE + 18)
#define ID_MDMTENoInit             (ID_MDMTEBASE + 19)
#define ID_MDMTEAbanPack           (ID_MDMTEBASE + 20)
#define ID_MDMTESeqNum             (ID_MDMTEBASE + 21)
#define ID_MDMTESipPend            (ID_MDMTEBASE + 22)
#define ID_MDMTENoConn             (ID_MDMTEBASE + 23)
#define ID_MDMTEInvalidID          (ID_MDMTEBASE + 24)
#define ID_MDMTENoSess             (ID_MDMTEBASE + 25)
#define ID_MDMTENoLPM              (ID_MDMTEBASE + 26)
#define ID_MDMTESessID             (ID_MDMTEBASE + 27)
#define ID_MDMTESessNIU            (ID_MDMTEBASE + 28)
#define ID_MDMTESize               (ID_MDMTEBASE + 29)
#define ID_MDMTEState              (ID_MDMTEBASE + 30)
#define ID_MDMTEConnID             (ID_MDMTEBASE + 31)
#define ID_MDMTEConnNIU            (ID_MDMTEBASE + 32)
#define ID_MDMTETinyPacket         (ID_MDMTEBASE + 33)
#define ID_MDMTEPacketOOS          (ID_MDMTEBASE + 34)
#define ID_MDMTEECBNotFound        (ID_MDMTEBASE + 35)

// Trace Information
#define ID_MDMTTBASE               1100
#define ID_MDMTTB1CEnter         (ID_MDMTTBASE + 1)
#define ID_MDMTTB1CExit          (ID_MDMTTBASE + 2)
#define ID_MDMTTSB1Enter         (ID_MDMTTBASE + 3)
#define ID_MDMTTSB1Exit          (ID_MDMTTBASE + 4)
#define ID_MDMTTB2CEnter         (ID_MDMTTBASE + 5)
#define ID_MDMTTB2CExit          (ID_MDMTTBASE + 6)
#define ID_MDMTTSB2Enter         (ID_MDMTTBASE + 7)
#define ID_MDMTTSB2Exit          (ID_MDMTTBASE + 8)
#define ID_MDMTTSendEnter        (ID_MDMTTBASE + 9)
#define ID_MDMTTSendExit         (ID_MDMTTBASE + 10)
#define ID_MDMTTInitEnter        (ID_MDMTTBASE + 11)
#define ID_MDMTTInitExit         (ID_MDMTTBASE + 12)
#define ID_MDMTTDeInitEnter      (ID_MDMTTBASE + 13)
#define ID_MDMTTDeInitExit       (ID_MDMTTBASE + 14)
#define ID_MDMTTLB1Enter         (ID_MDMTTBASE + 15)
#define ID_MDMTTLB1Exit          (ID_MDMTTBASE + 16)
#define ID_MDMTTLB2Enter         (ID_MDMTTBASE + 17)
#define ID_MDMTTLB2Exit          (ID_MDMTTBASE + 18)
#define ID_MDMTTNBSEnter         (ID_MDMTTBASE + 19)
#define ID_MDMTTNBSExit          (ID_MDMTTBASE + 20)
#define ID_MDMTTRecEnter         (ID_MDMTTBASE + 21)
#define ID_MDMTTRecExit          (ID_MDMTTBASE + 22)
#define ID_MDMTTCTSEnter         (ID_MDMTTBASE + 23)
#define ID_MDMTTCTSExit          (ID_MDMTTBASE + 24)
#define ID_MDMTTGCEnter          (ID_MDMTTBASE + 25)
#define ID_MDMTTGCExit           (ID_MDMTTBASE + 26)
#define ID_MDMTTBegSessEnter     (ID_MDMTTBASE + 27)
#define ID_MDMTTBegSessExit      (ID_MDMTTBASE + 28)
#define ID_MDMTTEndSessEnter     (ID_MDMTTBASE + 29)
#define ID_MDMTTEndSessExit      (ID_MDMTTBASE + 30)
#define ID_MDMTTMakeConEnter     (ID_MDMTTBASE + 31)
#define ID_MDMTTMakeConExit      (ID_MDMTTBASE + 32)
#define ID_MDMTTCloseConEnter    (ID_MDMTTBASE + 33)
#define ID_MDMTTCloseConExit     (ID_MDMTTBASE + 34)
#define ID_MDMTTListEnter        (ID_MDMTTBASE + 35)
#define ID_MDMTTListExit         (ID_MDMTTBASE + 36)
#define ID_MDMTTAccEnter         (ID_MDMTTBASE + 37)
#define ID_MDMTTAccExit          (ID_MDMTTBASE + 38)
#define ID_MDMTTRejEnter         (ID_MDMTTBASE + 39)
#define ID_MDMTTRejExit          (ID_MDMTTBASE + 40)
#define ID_MDMTTRecLookEnter     (ID_MDMTTBASE + 41)
#define ID_MDMTTRecLookExit      (ID_MDMTTBASE + 42)

// Comment Information
#define ID_MDMTCBASE               1200
#define ID_MDMTCSeqNum             (ID_MDMTCBASE + 1)
#define ID_MDMTCFound              (ID_MDMTCBASE + 2)
#define ID_MDMTCWaiting            (ID_MDMTCBASE + 3)
#define ID_MDMTCCTSFail            (ID_MDMTCBASE + 4)
#define ID_MDMTCCTSPass            (ID_MDMTCBASE + 5)
#define ID_MDMTCCTSize             (ID_MDMTCBASE + 6)
#define ID_MDMTCCTSOut             (ID_MDMTCBASE + 7)
#define ID_MDMTCTCB                (ID_MDMTCBASE + 8)
#define ID_MDMTCECBPMAddr          (ID_MDMTCBASE + 9)
#define ID_MDMTCECBRMAddr          (ID_MDMTCBASE + 10)

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif	// h file included already
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rrcminc\rrcm.h ===
/*-------------------------------------------------------------------------
// File : RRCM.H
//
// RRCM's include files .
//
//  INTEL Corporation Proprietary Information
// This listing is supplied under the terms of a license agreement with 
// Intel Corporation and may not be copied nor disclosed except in 
// accordance with the terms of that agreement.
// Copyright (c) 1995 Intel Corporation. 
//-----------------------------------------------------------------------*/


#ifndef __RRCM_H_
#define __RRCM_H_


#define INCL_WINSOCK_API_TYPEDEFS 1
#include <windows.h>
//#include <wsw.h>
#include <winsock2.h>
#include <stdio.h>
#include <io.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>  
#include <math.h>  
#include <process.h> 
#include <mmsystem.h>   
//#include <assert.h>
#include <confdbg.h>

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
#include "interop.h"
#include "rtpplog.h"
#endif

typedef CHAR	*PCHAR;

//#define ENABLE_ISDM2

#ifdef ENABLE_ISDM2
#include "isdmapi2.h"
#endif
#include "rrcm_dll.h"
#include "rrcmdata.h"
#include "rrcmprot.h"
#include "rtp.h"
#include "isrg.h"



//----------------------------------------------------------------------------
// RTP/RTCP: Registry information under:
//				HKEY_LOCAL_MACHINE\SOFTWARE\INTEL\RRCM
//----------------------------------------------------------------------------
#define szRegRRCMSubKey				TEXT("RRCM")
#define szRegRRCMSubKeyIntel		TEXT("iRRCM")
#define szRegRRCMKey				TEXT("SOFTWARE\\Microsoft\\Conferencing\\")
#define szRegRRCMWsLib				TEXT("WsLib")
#define szRegRRCMNumSessions		TEXT("NumSessions")
#define szRegRRCMNumFreeSSRC		TEXT("NumFreeSSRC")
#define szRegRRCMNumRTCPPostedBfr	TEXT("NumRTCPPostedBfr")
#define szRegRRCMRTCPrcvBfrSize		TEXT("RTCPrcvBfrSize")


//----------------------------------------------------------------------------
// RTP/RTCP: Dynamically loaded DLL
//----------------------------------------------------------------------------
#ifdef ENABLE_ISDM2
#define szISDMdll					TEXT("ISDM2")
#endif

#define szRRCMdefaultLib			TEXT("ws2_32")


#ifdef ENABLE_ISDM2
//----------------------------------------------------------------------------
// RTP/RTCP: ISDM module
//----------------------------------------------------------------------------
#define szSSRCtoken					TEXT("SSRC")
#define szPcktSentToken				TEXT("Number of packets send")
#define szByteSentToken				TEXT("Number of bytes send")
#define szPcktRcvdToken				TEXT("Number of packets received")
#define szByteRcvdToken				TEXT("Number of bytes received")
#define szFractionLostToken			TEXT("Fraction lost")
#define szCumNumPcktLostToken		TEXT("Cumulative number of packets lost")
#define szXntHighSeqNumToken		TEXT("Extended highest sequence number")
#define szInterarrivalJitterToken	TEXT("Interarrival jitter")
#define szLastSRtoken				TEXT("Last sender report")
#define szDSLRtoken					TEXT("Delay since last sender report")
#define szNTPfracToken				TEXT("NTP fraction")
#define szNTPsecToken				TEXT("NTP seconds")
#define szWhoAmItoken				TEXT("Who Am I")
#define szFdbkFractionLostToken		TEXT("Fraction lost feedback")
#define szFdbkCumNumPcktLostToken	\
	TEXT("Cumulative number of packets lost feedback")
#define szFdbkLastSRtoken			TEXT("Last sender report feedback")
#define szFdbkDSLRtoken				\
	TEXT("Delay since last sender report feedback")
#define szFdbkInterarrivalJitterToken	TEXT("Interarrival jitter feedback")
#endif


//----------------------------------------------------------------------------
// RTP: Bitmaps used to isolate errors detected for incoming received packets
//----------------------------------------------------------------------------
#define SSRC_LOOP_DETECTED			(1)
#define SSRC_COLLISION_DETECTED		(2)
#define INVALID_RTP_HEADER			(3)
#define MCAST_LOOPBACK_NOT_OFF		(4)
#define RTP_RUNT_PACKET				(5)

//----------------------------------------------------------------------------
// RTP: Default number of RTP sessions
//----------------------------------------------------------------------------
#define NUM_RRCM_SESS				50
#define MIN_NUM_RRCM_SESS			5
#define MAX_NUM_RRCM_SESS			100

//----------------------------------------------------------------------------
// RTP: Number of entries in the hash table
//----------------------------------------------------------------------------
#define NUM_RTP_HASH_SESS			65		

//---------------------------------------------------------------------------- 
//	RTP: DEFINES TO DETERMINE SEQUENCE NUMBER WRAP or STALENESS (per RFC)
//----------------------------------------------------------------------------
#define MAX_DROPOUT					3000
#define MAX_MISORDER				100
#define MIN_SEQUENTIAL				2

//----------------------------------------------------------------------------
//	RTCP: Defined
//----------------------------------------------------------------------------
#define	MAX_RR_ENTRIES				31			// Max # of Receiver Reports
#define TIMEOUT_CHK_FREQ			30000		// Timeout check freq. - 30s
#define RTCP_TIME_OUT_MINUTES		30			// 30 minutes timeout
#define	RTCP_XMT_MINTIME			2500
#define RTCP_TIMEOUT_WITHIN_RANGE	100
#define	ONE_K						1024

#define	NUM_FREE_SSRC				100
#define	MIN_NUM_FREE_SSRC			5
#define	MAX_NUM_FREE_SSRC			500

#define NUM_FREE_CONTEXT_CELLS			100
#define MAXNUM_CONTEXT_CELLS_REALLOC	10

#define	NUM_FREE_RCV_BFR			8
#define	NUM_FREE_XMT_BFR			2
#define NUM_RCV_BFR_POSTED			4
#define MIN_NUM_RCV_BFR_POSTED		1
#define MAX_NUM_RCV_BFR_POSTED		8
#define RRCM_RCV_BFR_SIZE			(8*ONE_K)
#define MIN_RRCM_RCV_BFR_SIZE		(1*ONE_K)
#define MAX_RRCM_RCV_BFR_SIZE		(8*ONE_K)
#define RRCM_XMT_BFR_SIZE			(8*ONE_K)
#define	RCV_BFR_LIST_HEAP_SIZE		(4*ONE_K)	// Rcv bfr list heap size
#define	XMT_BFR_LIST_HEAP_SIZE		(4*ONE_K)	// Xmt bfr list heap size
#define INITIAL_RTCP_BANDWIDTH		50			// BW in bytes/sec (~ G.723)
												//   5% of 6.3Kb/s = 35 bytes
#define	MAX_STREAMS_PER_SESSION		64			// Max number of active 
												//   streams per RTP session
#define MAX_NUM_SDES				9			// Number of SDES support


//----------------------------------------------------------------------------
//	RTP/RTCP Misc defined
//----------------------------------------------------------------------------
#define UNKNOWN_PAYLOAD_TYPE		0xFFFFFFFF
#define szDfltCname					TEXT("No Cname")


//----------------------------------------------------------------------------
//	RTP/RTCP: Debug Defined
//----------------------------------------------------------------------------
#define	DBG_STRING_LEN			200
#define	IO_CHECK				0
#define	FLUSH_RTP_PAYLOAD_TYPE	90

enum ISRBDG_CODE{
	DBG_NOTIFY = 1,
	DBG_CRITICAL,
	DBG_ERROR,
	DBG_WARNING,
	DBG_TRACE,
	DBG_TEMP
	};

#ifdef _DEBUG
//#define ASSERT(x)				assert(x)	// defined in confdbg.h
#define RRCM_DBG_MSG(x,e,f,l,t)	RRCMdebugMsg(x,e,f,l,t)
#else
//#define ASSERT(x)	defined in confdbg.h
#define RRCM_DBG_MSG(x,e,f,l,t)	{}	// DO NOT DELETE BRACKETS ...
#endif

#ifdef IN_OUT_CHK
#define	IN_OUT_STR(x)			OutputDebugString (x);
#else
#define	IN_OUT_STR(x)	
#endif


#endif /* __RRCM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rrcminc\rtp.h ===
/*------------------------------------------------------------------------- 
 * Filename: RTP.H
 *
 * RTP related data structures.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

#ifndef _RTP_H_
#define _RTP_H_

#define RTP_HDR_MIN_LEN	12
#define RTP_SEQ_MOD 	(1<<16)
#define RTP_TS_MOD  	(0xffffffff)

#define RTP_TYPE		2		/* Current version */
#define RTP_MAX_SDES	256		/* maximum text length for SDES */

#define RTCP_SIZE_GAIN	(1./16.)
#define NTWRK_HDR_SIZE	28

typedef enum {
	RTCP_SR   = 200,
	RTCP_RR   = 201,
	RTCP_SDES = 202,
	RTCP_BYE  = 203,
	RTCP_APP  = 204
	} RTCP_TYPE_T;

typedef struct {                             
	// !!! WARNING !!!
	// The following word doesn't need to be swapped for NtoH()
	WORD 			cc:4;       /* CSRC count */  
	WORD 			x:1;        /* header extension flag */  
	WORD 			p:1;        /* padding flag */  
	WORD 			type:2;     /* version type 1/2 */
	WORD		 	pt:7;       /* payload type */
	WORD			m:1;        /* marker bit */  

	WORD			seq;		/* sequence number */
	DWORD 			ts;         /* timestamp */
	DWORD 			ssrc;       /* synchronization source */
	DWORD 			csrc[1];    /* optional CSRC list */
	} RTP_HDR_T;

// macros to get various RTP header fields
#define RTP_TIMESTAMP(p) (((RTP_HDR_T *)p)->ts)
#define RTP_SEQNUM(p) (((RTP_HDR_T *)p)->seq)
#define RTP_MARKBIT(p) (((RTP_HDR_T *)p)->m)
#define RTP_SSRC(p) (((RTP_HDR_T *)p)->ssrc)

typedef struct {
	// !!! WARNING !!!
	// The following word doesn't need to be swapped for NtoH()
	WORD 			count:5;    /* varies by payload type */  
	WORD 			p:1;        /* padding flag */  
	WORD 			type:2;     /* protocol version */
	WORD		 	pt:8;       /* payload type */

    WORD			length;     /* packet length in words, without this word */
	} RTCP_COMMON_T;

/* reception report */
typedef struct {
	DWORD			ssrc;       /* data source being reported */
	DWORD			received;   /* cumulative number of packets received */
	DWORD			expected;   /* cumulative number of packets expected */
	DWORD			jitter;     /* interarrival jitter */
	DWORD			lsr;        /* last SR packet from this source */
	DWORD			dlsr;       /* delay since last SR packet */
	} RTCP_RR_T;

typedef struct {
	BYTE			dwSdesType;       /* type of SDES item (rtcp_sdes_type_t) */
	BYTE			dwSdesLength;     /* length of SDES item (in octets) */
	char 			sdesData[1];    /* text, not zero-terminated */
	} RTCP_SDES_ITEM_T;

typedef struct {
	DWORD 		ssrc;       /* source this RTCP packet refers to */
	DWORD 		ntp_sec;    /* NTP timestamp */
	DWORD 		ntp_frac;
	DWORD 		rtp_ts;     /* RTP timestamp */
	DWORD 		psent;      /* packets sent */
	DWORD 		osent;      /* octets sent */ 
		
	RTCP_RR_T 	rr[1];		/* variable-length list */
	} SENDER_RPT;

typedef struct {
	DWORD 		ssrc;        /* source this generating this report */
	RTCP_RR_T rr[1];		 /* variable-length list */
	} RECEIVER_RPT;

typedef struct {
	DWORD 		src[1];   	 /* list of sources */
		
	/* can't express trailing text */
	} BYE_PCKT;

typedef struct {
	DWORD 	src;              /* first SSRC/CSRC */
	RTCP_SDES_ITEM_T item[1]; /* list of SDES items */
	} RTCP_SDES_T;

/* one RTCP packet */
typedef struct {
	RTCP_COMMON_T	common;     /* common header */
	
	union 
		{
		SENDER_RPT		sr;		/* sender report (SR) */
		RECEIVER_RPT	rr;		/* reception report (RR) */
		BYE_PCKT		bye;	/* BYE */
		RTCP_SDES_T		sdes;	/* source description (SDES) */
		} r;
	} RTCP_T;


typedef DWORD MEMBER_T;


#endif /* ifndef _RTP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rrcminc\rrcmdata.h ===
/*---------------------------------------------------------------------------
 * File : RRCMDATA.H
 *
 * RRCM data structures information.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/

#ifndef	__RRCMDATA_H_
#define	__RRCMDATA_H_

// force 8 byte structure packing
#include <pshpack8.h>

#define MAX_DWORD					4294967295
#define	HASH_MODULO					255	
#define FILENAME_LENGTH				128
#define	RTCP_FEEDBACK_LIST			0


// RTP/RTCP collision data
typedef struct _rtp_collision
	{
	char				collideAddr[MAX_ADDR_LEN];
	int					addrLen;
	DWORD				dwCollideTime;
	DWORD				dwCurRecvRTCPrptNumber;
	DWORD				SSRC;
	} RTP_COLLISION, *PRTP_COLLISION;



//	RTCP Session Information data structure
typedef struct _RTCP_SESSION
	{
	LINK_LIST	RTCPList;					// Next/prev RTCP session ptrs
	
	// Synchronization elements
	CRITICAL_SECTION	critSect;			// Critical section
	HANDLE		hExitEvent;					// Exit RTCP event handle

#ifdef ENABLE_ISDM2
	// ISDM2 Handle
	KEY_HANDLE	hSessKey;					// Key to this sessions ISDM info
#endif

	// List of SSRC(s) on the transmit list, i.e., our own transmit SSRC's
	//  and list of SSRC(s) received
	HEAD_TAIL	RcvSSRCList;				// Rcv SSRC list head/tail ptrs
	HEAD_TAIL	XmtSSRCList;				// Xmt SSRC list head/tail ptrs

	// List of Rcv/Xmt data structure. The data resides in a heap
	//  in order to avoid page fault
	HEAD_TAIL	RTCPrcvBfrList;				// Rcv buffers head/tail ptrs
	HANDLE		hHeapRcvBfrList;			// Heap handle to Rcv bfrs list

	// Rcv/Xmt buffers have their own heap
	HANDLE		hHeapRcvBfr;				// Heap handle to Rcv Bfrs mem.	

	WSABUF		XmtBfr;						// RTCP send buffer descriptor
	// Application provided list of buffers where RRCM will copy the raw
	//  RTCP buffers
	HEAD_TAIL	appRtcpBfrList;				// Head/tail ptrs for app bfr list

	DWORD		dwInitNumFreeRcvBfr;		// Number of Free Rcv Buffers	
	DWORD		dwRcvBfrSize;				// Receive Buffer size			
	DWORD		dwXmtBfrSize;				// Transmit Buffer size			
				
	DWORD		dwSessionStatus;			// Entry status:				

	char		toBfr[MAX_ADDR_LEN];		// Destination address			
	int			toLen;						// Size of lpTo					

	int			avgRTCPpktSizeRcvd;			// Average RTCP pckt size		

	DWORD		dwNumStreamPerSes;			// Num of streams per Session
	DWORD		dwCurNumSSRCperSes;			// Num of SSRC per Session		

#ifdef MONITOR_STATS
	DWORD		dwHiNumSSRCperSes;			// High Num of SSRC per Session	
#endif

	// Receive information (shared by all streams of this session)
	HANDLE		hShutdownDone;				// Shutdown procedure done
	int			dwNumRcvIoPending;			// Number of receive I/O pending

	// Notification callback of RRCM events if desired by the application
	VOID		(*pRRCMcallback)(RRCM_EVENT_T, DWORD_PTR, DWORD_PTR, DWORD_PTR);

	// User information on callback
	DWORD_PTR	dwCallbackUserInfo;			

	// RTP Loop/Collision information
	RTP_COLLISION	collInfo[NUM_COLLISION_ENTRIES];

	} RTCP_SESSION, *PRTCP_SESSION;



// RTCP Xmt information
typedef struct _XMIT_INFO
	{
	DWORD		dwNumPcktSent;				// Number of packet sent 		
	DWORD		dwNumBytesSent;				// Number of bytes sent     	
	DWORD		dwNTPmsw;					// NTP most significant word	
	DWORD		dwNTPlsw;					// NTP least significant word	
	DWORD		dwRTPts;					// RTP timestamp				
	DWORD		dwCurXmtSeqNum;				// Current Xmt sequence number	
	DWORD		dwPrvXmtSeqNum;				// Previous Xmt sequence number
	DWORD		dwRtcpStreamMinBW;			// Minimal session's bandwidth
#ifdef DYNAMIC_RTCP_BW
	DWORD		dwCalculatedXmtBW;			// Session's calculated bandwidth
	DWORD		dwLastTimeBwCalculated;		// Last time BW was calculated
	DWORD		dwLastTimeNumBytesSent;		// Last time number of bytes send
	DWORD		dwLastTimeNumPcktSent;		// Last time number of bytes send
#endif
	DWORD		dwLastSR;					// Last sender report (RTP format)
	DWORD		dwLastSRLocalTime;			// Last sender report local time
	DWORD		dwLastSendRTPSystemTime;	// Last RTP packet send time
	DWORD		dwLastSendRTPTimeStamp;		// RTP timestamp of the last packet
	} XMIT_INFO, *PXMIT_INFO;



// RTCP receive information
typedef struct _RECV_INFO
	{
	DWORD		dwNumPcktRcvd;				// Number of packet received	
	DWORD		dwPrvNumPcktRcvd;			// Previous number of pckt rcvd	
	DWORD		dwExpectedPrior;			// Number previously expected	
	DWORD		dwNumBytesRcvd;				// Number of bytes rcvd     	
	DWORD		dwBaseRcvSeqNum;			// Initial sequence number rcvd
	DWORD		dwBadSeqNum;				// Potential new valid seq num
	DWORD		dwProbation;				// # consec pkts for validation
	RTP_SEQ_NUM	XtendedSeqNum;				// Xtnded highest seq. num rcvd	
	DWORD		dwPropagationTime;			// Last packet's transmit time
	DWORD		interJitter;				// Interarrival jitter 			
#ifdef DYNAMIC_RTCP_BW
	DWORD		dwCalculatedRcvBW;			// Session's calculated bandwidth
	DWORD		dwLastTimeBwCalculated;		// Last time BW was calculated
	DWORD		dwLastTimeNumBytesRcvd;		// Last time number of bytes rcvd
	DWORD		dwLastTimeNumPcktRcvd;		// Last time number of bytes rcvd
#endif
	} RECV_INFO, *PRECV_INFO;



//	RRCM statistics table entry data structure
typedef struct _SSRC_ENTRY
	{
	LINK_LIST	SSRCList;					// Next/prev SSRC entry	

	CRITICAL_SECTION	critSect;			// Critical section synch.		

	PRTCP_SESSION	pRTCPses;				// Point to the parent session	

	DWORD		SSRC;						// Source SSRC 					
	DWORD		PayLoadType;				// payload associated with this SSRC

	DWORD		dwSSRCStatus;				// Entry status 				
#define	NETWK_ADDR_UPDATED		0x80000000	// Network Address already done	
#define	SEQ_NUM_UPDATED			0x40000000	// XMT Sequence already done	
#define THIRD_PARTY_COLLISION	0x20000000	// Third party collsion detected
#define CLOSE_RTCP_SOCKET		0x10000000	// RTCP will close the RTCP socket
#define RTCP_XMT_USER_CTRL		0x08000000	// User's has RTCP timeout control

	// SSRC Transmit information
	// If on our transmit list, this is our SSRC information, and if on our
	// receive list, this is a SR feedback information.
	XMIT_INFO	xmtInfo;

	// SSRC Receive information
	// If on our transmit list, this is undefined information, and if on our
	// receive list, this is the SSRC's receive information, ie, this SSRC
	// is an active sender somewhere on the network. This information is
	// maintained by RTP, and used by RTCP to generate RR.
	RECV_INFO	rcvInfo;

	// Feedback information received about ourselve if we're an active source
	RTCP_FEEDBACK	rrFeedback;				// Feedback	information

	DWORD		dwLastReportRcvdTime;		// Time of last report received
	DWORD		dwNextReportSendTime;		// Next scheduled report time (ms)

#ifdef _DEBUG
	DWORD		dwPrvTime;					// Elapsed time between report	
#endif

	// SSRC SDES information
	SDES_DATA	cnameInfo;					// CNAME information
	SDES_DATA	nameInfo;					// NAME information
	SDES_DATA	emailInfo;					// EMAIL address information
	SDES_DATA	phoneInfo;					// PHONE number information
	SDES_DATA	locInfo;					// LOCation (users) information
	SDES_DATA	toolInfo;					// TOOL name information
	SDES_DATA	txtInfo;					// TEXT (NOTE) information
	SDES_DATA	privInfo;					// PRIVate information

	// SSRC network address information
	int			fromLen;					// From address length
	char		from[MAX_ADDR_LEN];			// From address						

	// !!! Not implemented (entries will grow exponentionally) !!!
	// List of SSRCs in RR received by this SSRC. It might be useful for a
	// sender or a controller to know how other active sources are received
	// by others.
	// The drawback is that the number of entries will grow exponentially
	// with the number of participants.
	// Currently not implemented.
#if RTCP_FEEDBACK_LIST
	HEAD_TAIL	rrFeedbackList;				// Head/Tail of feedback list
#endif

#ifdef ENABLE_ISDM2
	DWORD		hISDM;						// ISDM session handle
#endif

	// All variables below should be in an additional linked list one layer
	// up this one, under the RTCP session link list.
	// They have been moved here when we added multiple streams per session
	// !!! NOTE !!!: There is only 1 transmit thread per stream. It's ID is
	// found in this data structure which is on the Xmt list.
	SOCKET		RTPsd;						// RTP socket descriptor		
	SOCKET		RTCPsd;						// RTCP socket descriptor		
	HANDLE		hXmtThread;					// RTCP session thread handle	
	DWORD		dwXmtThreadID;				// RTCP session thread ID		
	HANDLE		hExitXmtEvent;				// Xmt thread Exit event -
											//  Used to terminate a session
											//  among multiple stream on the
											//  same session
	DWORD		dwNumRptSent;				// Number of RTCP report sent	
	DWORD		dwNumRptRcvd;				// Number of RTCP report rcvd	
	DWORD		dwNumXmtIoPending;			// Number of transmit I/O pending
	DWORD		dwStreamClock;				// Sampling frequency
	DWORD		dwUserXmtTimeoutCtrl;		// User's xmt timer control
											//		0x0		-> RRCM control
											//		0xFFFF	-> No RTCP send
											//		value	-> timer value
	// All the above variables should move in the intermediate layer for
	// multiple stream per session support

	} SSRC_ENTRY, *PSSRC_ENTRY;



//	RTP process data structure
typedef struct _RTP_SESSION
	{
	LINK_LIST		RTPList;				// Next/Prev RTP session

	CRITICAL_SECTION	critSect;			// Critical section

	PRTCP_SESSION	pRTCPSession;			// Pointer to my RTCP side
	} RTP_SESSION, *PRTP_SESSION;
	

#if 0
//	RTP Ordered buffer structure
typedef struct _RTP_BFR_LIST
	{
	LINK_LIST			RTPBufferLink;		// Next/prev					

	LPWSAOVERLAPPED_COMPLETION_ROUTINE	
				pfnCompletionNotification;	// Pointer to Rcv notif. func	
	WSAEVENT			hEvent;				// WSAOverlapped handle			
	LPWSABUF			pBuffer;			// Pointer to WSABuffers		
	PRTP_SESSION		pSession;			// This session's ID			
	DWORD				dwBufferCount;		// Number of bufs in LPWSABUF	
	DWORD				dwFlags;				// WSARecv flags				
	LPVOID				pFrom;				// Pointer to source address
	LPINT				pFromlen;			// Pointer to source address
	SOCKET				RTPsocket;			// Socket descriptor
	} RTP_BFR_LIST, *PRTP_BFR_LIST;



//	RTP Ordered buffer structure
typedef struct _RTP_HASH_LIST
	{
	LINK_LIST			RTPHashLink;		// Next/prev					

	PRTP_SESSION		pSession;			// This session's ID			
	SOCKET				RTPsocket;			// Socket descriptor
	} RTP_HASH_LIST, *PRTP_HASH_LIST;

#endif


//	RTP registry initialization
typedef struct _RRCM_REGISTRY
	{
	DWORD				NumSessions;		// RTP/RTCP sessions
	DWORD				NumFreeSSRC;		// Initial number of free SSRCs
	DWORD				NumRTCPPostedBfr;	// Number of RTCP recv bfr posted
	DWORD				RTCPrcvBfrSize;		// RTCP rcv bfr size

	// Dynamically loaded DLL & Send/Recv function name
	CHAR				WSdll[FILENAME_LENGTH];
	} RRCM_REGISTRY, *PRRCM_REGISTRY;



//	RTP Context Sensitive structure
typedef struct _RTP_CONTEXT
	{
	HEAD_TAIL		pRTPSession;			// Head/tail of RTP session(s)

	CRITICAL_SECTION	critSect;			
	HINSTANCE		hInst;					// DLL instance					


	RRCM_REGISTRY	registry;				// Registry initialization
	} RTP_CONTEXT, *PRTP_CONTEXT;



//	RTCP Context Sensitive structure
typedef struct _RTCP_CONTEXT
	{
	HEAD_TAIL		RTCPSession;			// RTCP sessions head/tail ptrs
	HANDLE			hHeapRTCPSes;			// Heap handle to RTCP sessions	

	CRITICAL_SECTION	critSect;			// Critical section synch.		

	HEAD_TAIL		RRCMFreeStat;			// RRCM entries	head/tail ptrs	
	HANDLE			hHeapRRCMStat;			// Heap handle to RRCM stats	
	DWORD			dwInitNumFreeRRCMStat;	// Number of Free SSRC entries	

	DWORD			dwRtcpThreadID;			// RTCP thread ID
	HANDLE			hRtcpThread;			// RTCP thread hdle
	HANDLE			hTerminateRtcpEvent;	// RTCP terminate thread event hdl
	HANDLE			hRtcpRptRequestEvent;	// RTCP report request event

#ifdef MONITOR_STATS
	DWORD			dwRTCPSesCurNum;		// Num of RTCP Session			
	DWORD			dwRTCPSesHiNum;			// High num RTCP per Session	

	DWORD			dwRRCMStatFreeLoNum;	// Low num of RRCM free Stat 	
	DWORD			dwRRCMStatFreeCurNum;	// Cur num of RRCM Free Stat	
	DWORD			dwRRCMStatFreeHiNum;	// High num of RRCM Free Stat	

	DWORD			dwCurNumRTCPThread;		// Current num of RTCP thread	
	DWORD			dwHiNumRTCPThread;		// High number of RTCP thread	

	DWORD			dwNumRTCPhdrErr;		// Num of RTCP pckt header err.	
	DWORD			dwNumRTCPlenErr;		// Num of RTCP pckt length err.	
#endif
	} RTCP_CONTEXT, *PRTCP_CONTEXT;



//	RTCP Free Buffers List
typedef struct _RTCP_BFR_LIST
	{
	LINK_LIST			bfrList;			// Next/prev buffer in list		

	WSAOVERLAPPED		overlapped;			// Overlapped I/O structure		
	WSABUF				bfr;				// WSABuffers					
	DWORD				dwBufferCount;		// Number of bufs in WSABUF		

	DWORD				dwNumBytesXfr;		// Number of bytes rcv/xmt		
	DWORD				dwFlags;			// Flags						
	char				addr[MAX_ADDR_LEN];	// Network Address
	int					addrLen;			// Address length   		

	PSSRC_ENTRY			pSSRC;				// Pointer to SSRC entry address
	} RTCP_BFR_LIST, *PRTCP_BFR_LIST;


// Dynamically loaded functions
typedef struct _RRCM_WS
	{
	HINSTANCE						hWSdll;
	LPFN_WSASENDTO					sendTo;
	LPFN_WSARECVFROM				recvFrom;
	LPFN_WSANTOHL					ntohl;
	LPFN_WSANTOHS					ntohs;
	LPFN_WSAHTONL					htonl;
	LPFN_WSAHTONS					htons;
	LPFN_GETSOCKNAME				getsockname;
	LPFN_GETHOSTNAME				gethostname;
	LPFN_GETHOSTBYNAME				gethostbyname;
	LPFN_CLOSESOCKET				closesocket;
	LPFN_WSASOCKET					WSASocket;
	LPFN_BIND						bind;
	LPFN_WSAENUMPROTOCOLS			WSAEnumProtocols;
	LPFN_WSAJOINLEAF				WSAJoinLeaf;
	LPFN_WSAIOCTL					WSAIoctl;
	LPFN_SETSOCKOPT 				setsockopt;
	WSAPROTOCOL_INFO 				RTPProtInfo;	// used to open RTP sockets

	} RRCM_WS, *PRRCM_WS;

extern RRCM_WS			RRCMws;

#define WS2Enabled (RRCMws.hWSdll != NULL)
#define WSQOSEnabled (RRCMws.RTPProtInfo.dwServiceFlags1 & XP1_QOS_SUPPORTED)


#ifdef ENABLE_ISDM2
// ISDM support
typedef struct _ISDM2
	{
	CRITICAL_SECTION	critSect;			// Critical section synch.		
	ISDM2API			ISDMEntry;			// DLL entry point
	HINSTANCE			hISDMdll;
	DWORD				hIsdmSession;		// ISDM Session's handle
	} ISDM2, *PISDM2;
#endif // #ifdef ENABLE_ISDM2


// restore structure packing
#include <poppack.h>

#endif // __RRCMDATA_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rrcminc\isdmapi2.h ===
#ifndef __ISDMAPI2_H__
#define __ISDMAPI2_H__

/****************************************************************************
 *
 *	$Archive: /rtp/RRCM32/rrcminc/ISDMAPI2.H $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision: 1 $
 *	$Date: 8/13/96 12:16p $
 *	$Author: Bnkeany $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport


//reserved key define for backwards compatability with old API
//all ISDM1 data falls under this key
#define BACKCOMP_KEY	"BackCompatability"
//value type defines
#define DWORD_VALUE			2
#define STRING_VALUE		3
#define BINARY_VALUE		4

//handle prefix bit codes(these get appended to the actual memmap offset to generate a handle)
#define	KEYBITCODE		0x6969
#define VALUEBITCODE	0xABBA
#define ROOTBITCODE		0x1234

//in case we want multiple roots, this can expand
#define ROOT_MAIN	0x0000

//this is the main root keys handle define
#define MAIN_ROOT_KEY MAKELONG(ROOT_MAIN,ROOTBITCODE)

//typedefs for each kind of handle
typedef DWORD KEY_HANDLE,*LPKEY_HANDLE;
typedef DWORD VALUE_HANDLE,*LPVALUE_HANDLE;
typedef DWORD EVENT_HANDLE,*LPEVENT_HANDLE;

//this structure is an internal status structure
//my test app accesses this for debug. You should never need this.
typedef struct INFODATASTRUCT
{
	UINT			uBindCount;
	UINT			uNumKeys;
	UINT			uMaxKeys;
	UINT			uNumValues;
	UINT			uMaxValues;
	UINT			uNumTableEntries;
	UINT			uMaxTableEntries;
	UINT			uNumEvents;
	UINT			uMaxEvents;
	DWORD			dwBytesFree;
	DWORD			dwMaxChars;
} INFO_DATA, *LPINFO_DATA;

//function typedefs
//supplier
typedef HRESULT (*ISD_CREATEKEY)		(KEY_HANDLE, LPCTSTR, LPKEY_HANDLE);
typedef HRESULT (*ISD_CREATEVALUE)		(KEY_HANDLE, LPCTSTR, DWORD,CONST BYTE *,DWORD,LPVALUE_HANDLE);
typedef HRESULT (*ISD_SETVALUE)			(KEY_HANDLE, VALUE_HANDLE, LPCTSTR, DWORD, CONST BYTE *, DWORD);
//consumer
typedef HRESULT (*ISD_OPENKEY)			(KEY_HANDLE, LPCSTR, LPKEY_HANDLE);
typedef HRESULT (*ISD_ENUMKEY)			(KEY_HANDLE, DWORD, LPTSTR, LPDWORD, LPKEY_HANDLE);
typedef HRESULT (*ISD_ENUMVALUE)		(KEY_HANDLE, DWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD, LPDWORD, LPVALUE_HANDLE);
typedef HRESULT (*ISD_QUERYINFOKEY)		(KEY_HANDLE, LPSTR, LPDWORD, LPDWORD, LPDWORD);
typedef HRESULT (*ISD_QUERYINFOVALUE)	(VALUE_HANDLE, LPSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD, LPDWORD, LPKEY_HANDLE);
typedef HRESULT (*ISD_NOTIFYCHANGEVALUE)	(VALUE_HANDLE, HANDLE);
//used by either
typedef HRESULT (*ISD_DELETEKEY)		(KEY_HANDLE);
typedef HRESULT	(*ISD_DELETEVALUE)		(KEY_HANDLE, VALUE_HANDLE, LPCSTR);
typedef BOOL	(*ISD_GETSTRUCTDATA)	(LPINFO_DATA);
typedef BOOL	(*ISD_ISVALIDKEYHANDLE)	(KEY_HANDLE);
typedef BOOL	(*ISD_ISVALIDVALUEHANDLE)	(VALUE_HANDLE);
typedef HRESULT (*ISD_COMPACTMEMORY)	();

//structure for ISDM entry points
typedef struct _ISDM2API
{
	ISD_CREATEKEY			ISD_CreateKey;
	ISD_CREATEVALUE			ISD_CreateValue;
	ISD_SETVALUE			ISD_SetValue;
	ISD_OPENKEY				ISD_OpenKey;
	ISD_ENUMKEY				ISD_EnumKey;
	ISD_ENUMVALUE			ISD_EnumValue;
	ISD_QUERYINFOKEY		ISD_QueryInfoKey;
	ISD_QUERYINFOVALUE		ISD_QueryInfoValue;
	ISD_NOTIFYCHANGEVALUE	ISD_NotifyChangeValue;
	ISD_DELETEKEY			ISD_DeleteKey;
	ISD_DELETEVALUE			ISD_DeleteValue;
	ISD_GETSTRUCTDATA		ISD_GetStructData;
	ISD_ISVALIDKEYHANDLE	ISD_IsValidKeyHandle;
	ISD_ISVALIDVALUEHANDLE	ISD_IsValidValueHandle;
	ISD_COMPACTMEMORY		ISD_CompactMemory;
}
ISDM2API, *LPISDM2API;

//HRESULT error defines
#define ISDM_ERROR_BASEB 0x8000

#define ERROR_INVALID_KEY_HANDLE		ISDM_ERROR_BASEB + 1
#define ERROR_MORE_DATA_AVAILABLE		ISDM_ERROR_BASEB + 2
#define ERROR_INVALID_STRING_POINTER	ISDM_ERROR_BASEB + 3
#define ERROR_KEY_NOT_FOUND				ISDM_ERROR_BASEB + 4
#define ERROR_VALUE_NOT_FOUND			ISDM_ERROR_BASEB + 5
#define ERROR_NO_MORE_SESSIONS			ISDM_ERROR_BASEB + 6
#define ERROR_INVALID_VALUE_HANDLE		ISDM_ERROR_BASEB + 7
#define ERROR_FAILED_TO_GET_MEM_KEY		ISDM_ERROR_BASEB + 8
#define ERROR_NO_PARENT					ISDM_ERROR_BASEB + 9
#define ERROR_NO_PREV_SIBLING			ISDM_ERROR_BASEB + 10
#define ERROR_NO_NEXT_SIBLING			ISDM_ERROR_BASEB + 11
#define ERROR_NO_CHILD					ISDM_ERROR_BASEB + 12
#define ERROR_INVALID_VALUE_TYPE		ISDM_ERROR_BASEB + 13
#define ERROR_MALLOC_FAILURE			ISDM_ERROR_BASEB + 14
#define ERROR_CREATE_KEY_FAILURE		ISDM_ERROR_BASEB + 15
#define ERROR_NULL_PARAM				ISDM_ERROR_BASEB + 16
#define ERROR_VALUE_EXISTS				ISDM_ERROR_BASEB + 17
#define ERROR_FAILED_TO_GET_MEM_VALUE	ISDM_ERROR_BASEB + 18
#define ERROR_NO_MORE_STR_SPACE			ISDM_ERROR_BASEB + 19
#define ERROR_KEY_EXISTS				ISDM_ERROR_BASEB + 20
#define ERROR_NO_MORE_KEY_SPACE			ISDM_ERROR_BASEB + 21
#define ERROR_NO_MORE_VALUE_SPACE		ISDM_ERROR_BASEB + 22
#define ERROR_INVALID_PARAM				ISDM_ERROR_BASEB + 23
#define ERROR_ROOT_DELETE				ISDM_ERROR_BASEB + 24
#define ERROR_NULL_STRING_TABLE_ENTRY	ISDM_ERROR_BASEB + 25
#define ERROR_NO_MORE_TABLE_ENTRIES		ISDM_ERROR_BASEB + 26
#define ERROR_ISDM_UNKNOWN				ISDM_ERROR_BASEB + 27
#define ERROR_NOT_IMPLEMENTED			ISDM_ERROR_BASEB + 28
#define ERROR_MALLOC_FAILED				ISDM_ERROR_BASEB + 29
#define ERROR_FAILED_TO_GET_MEM_TABLE	ISDM_ERROR_BASEB + 30
#define ERROR_SEMAPHORE_WAIT_FAIL		ISDM_ERROR_BASEB + 31
#define ERROR_NO_MORE_EVENTS			ISDM_ERROR_BASEB + 32
#define ERROR_INVALID_EVENT				ISDM_ERROR_BASEB + 33
#define ERROR_INVALID_EVENT_HANDLE		ISDM_ERROR_BASEB + 34
#define ERROR_EVENT_NONEXISTANT			ISDM_ERROR_BASEB + 35

//token defines..these may just disappear
//RRCM
#define RRCM_LOCAL_STREAM				1
#define RRCM_REMOTE_STREAM				2
#define ISDM_RRCM_BASE 0x1000

#define ISDM_SSRC						ISDM_RRCM_BASE + 1
#define ISDM_NUM_PCKT_SENT				ISDM_RRCM_BASE + 2
#define ISDM_NUM_BYTES_SENT				ISDM_RRCM_BASE + 3
#define ISDM_FRACTION_LOST				ISDM_RRCM_BASE + 4
#define ISDM_CUM_NUM_PCKT_LOST			ISDM_RRCM_BASE + 5
#define ISDM_XTEND_HIGHEST_SEQ_NUM		ISDM_RRCM_BASE + 6
#define ISDM_INTERARRIVAL_JITTER		ISDM_RRCM_BASE + 7
#define ISDM_LAST_SR					ISDM_RRCM_BASE + 8
#define ISDM_DLSR						ISDM_RRCM_BASE + 9
#define ISDM_NUM_BYTES_RCVD				ISDM_RRCM_BASE + 10
#define ISDM_NUM_PCKT_RCVD				ISDM_RRCM_BASE + 11
#define ISDM_NTP_FRAC					ISDM_RRCM_BASE + 12
#define ISDM_NTP_SEC					ISDM_RRCM_BASE + 13
#define ISDM_WHO_AM_I					ISDM_RRCM_BASE + 14

//
//Supplier API
//

//NOTE: always refer to the Win32 Registry equivalent call for more information on the functionality of the call
 
//The create key call is similar to the RegCreateKeyEx call from Win32 in functionality
//NOTE: This call will create the new key or simply return the handle of the key if it already
//exists
extern DllExport HRESULT ISD_CreateKey
(
	KEY_HANDLE hParentKey,	//The key from which to create the new key(can be MAIN_ROOT_KEY)
	LPCTSTR lpSubKey,		//the subkey to create.(see RegCreateKeyEx for details)
	LPKEY_HANDLE lphReturnKey//the handle of the newly created key
);

//The create value call is not part of the Win32 reg calls. It is here for symmetry in my API
//I prefer to use CreateValue then SetValue for my values, you can simply use SetValue and ignore
//CreateValue if you wish. The reason the registry has no such call is because they don't have
//a notion of a handle to a value. I felt it was very useful to have direct handles to the values for
//subsequent update calls.
extern DllExport HRESULT ISD_CreateValue
(
	KEY_HANDLE hKey,				//handle to the key that will own the new value
	LPCTSTR lpName,					//string ID of the value to be create
	DWORD dwType,					//type of value to create(DWORD,STRING,BINARY)
	CONST BYTE *lpData,				//pointer to value data	
	DWORD cbData,					//size of the value data buffer
	LPVALUE_HANDLE lphReturnValue	//return handle to the newly created value
);

//SetValue is similar to the Win32 RegSetValueEx call
DllExport HRESULT ISD_SetValue
(
	KEY_HANDLE hKey,		//handle of valid key
	VALUE_HANDLE hValue,	//handle of value to set
	LPCTSTR lpName,			//address of value name of value to set 
	DWORD dwType,			//flag for value type 
	CONST BYTE *lpData,		//address of value data 
	DWORD cbData 			//size of value data 
);

//
//Consumer API
//

//The OpenKey call is similar to the Win32 RegOpenKeyEx call
DllExport HRESULT ISD_OpenKey
(
	KEY_HANDLE hKey,				//handle of a valid key(can be MAIN_ROOT_KEY)
	LPCSTR lpSubKey,				//name of subkey to open
	LPKEY_HANDLE lphReturnKey		//handle of the opened key
);


//The EnumKey call is similar to the Win32 RegEnumKey call
//NOTES:
//	If lpName is null the size of the name is returned into lpcbName and NOERROR is returned
DllExport HRESULT ISD_EnumKey
(
	KEY_HANDLE hKey,				//key to enumerate
	DWORD dwIndex,					//index of subkey to enumerate
	LPTSTR lpName,					//address of buffer for subkey name(can be NULL)
	LPDWORD lpcbName,				//address for size of subkey buffer (acts like the RegEnumKeyEx version of this param)
	LPKEY_HANDLE lphReturnKey		//handle of subkey(can be NULL) 
);

//The EnumValue call is similar to the Win32 RegEnumValue call
DllExport HRESULT ISD_EnumValue
(
	KEY_HANDLE hKey,				//handle of key where value resides
	DWORD dwIndex,					//index of value to enum
	LPTSTR lpName,					//address of buffer for value name(can be NULL)
	LPDWORD lpcbName,				//address for size of value name buffer(can be NULL only if lpName is NULL)
	LPDWORD lpType,					//address for type of value(can be NULL if you don't care about type)
	LPBYTE lpData,					//address of buffer to receive the value data(can be NULL)
	LPDWORD lpcbData,				//address of size of buffer to receive the value data(can be NULL only if lpData is NULL)
	LPDWORD lpTimeStamp,			//address for timestamp on value(when last updated)(can be NULL)
	LPVALUE_HANDLE lphReturnValue	//address for handle of value(can be NULL)
);

//The QueryKeyInfo call is similar to the RegQueryInfoKey
DllExport HRESULT ISD_QueryInfoKey
(
	KEY_HANDLE hKey,				//handle of a valid key(can be MAIN_ROOT_KEY)
	LPSTR lpKeyName,			    //buffer to receive the name of the key(can be NULL)
	LPDWORD lpcbKeyName,			//address of size of name buffer(can be null only if lpKeyName is NULL)
	LPDWORD lpcNumKeys,				//address for number of direct children of the key(can be NULL)
	LPDWORD lpcNumValues			//address for number of values under the key(can be NULL)
);

//The QueryValueInfo call is NOT similar to the Win32 RegQueryValueEx call
//you must supply a value handle, the Win32 call doesn't have a notion of such a thing
//You can get the handle with subsequent calls to EnumKey
//This is my consumer call to retrieve statistical data
//NOTES:
//		If lpData is NULL and lpcbData is not, the function will return NOERROR with
//		lpcbData containing the buffer size needed for the value
//		If lpName is NULL and lpcbName is not, the function will return NOERROR with
//		lpcbName containing the buffer size needed for the value
DllExport HRESULT ISD_QueryInfoValue
(
	VALUE_HANDLE hValue,		//handle of value to query 
	LPSTR lpName,				//buffer to receive the name of the value(can be NULL)
	LPDWORD lpcbName,			//size of the name buffer(can only be NULL if lpName is NULL)
	LPDWORD lpValueType,		//address to receive the value type
	LPBYTE lpData,				//buffer to receive the value data(can be NULL)
	LPDWORD lpcbData,			//size of the value data buffer(can only be NULL if lpData is NULL)
	LPDWORD lpTime,				//address for timestamp on value(when last updated)(can be NULL)
	LPKEY_HANDLE lphParentKey	//return handle of the key that owns the value(can be NULL) 
);

//NotifyChangeValue is somewhat similar to the Win32 RegNotifyChangeValue call
//I limit you to async notification and also to value notification(no key level notify..yet)
DllExport HRESULT ISD_NotifyChangeValue
(
	VALUE_HANDLE hValue,	//handle of the value to trigger an event from
	HANDLE hEvent			//handle to the event you want triggered when value changes
);

//
//shared API
//

//The DeleteKey call is similar to RegDeleteKey
DllExport HRESULT ISD_DeleteKey
(
	KEY_HANDLE hKey					//handle of key to delete
);

//The DeleteValue call is similar to the RegDeleteValue call
//NOTE: You must supply either hValue or lpValueName. If you have the hValue, use it 
//and pass NULL for the value name.
DllExport HRESULT ISD_DeleteValue
(
	KEY_HANDLE hKey,				//handle of key that owns the value..if you have the value handle..pass NULL
	VALUE_HANDLE hValue,			//handle of value to delete(if known)..if known..pass NULL for key handle and name value
	LPCSTR lpValueName				//buffer holding name of value to delete(if known) pass NULL when hValue is known
);

//The GetStructData call is for retrieving structural info on ISDM itself. This is exposed so
//my test app can check the data structs. You should not need to call this.
DllExport BOOL ISD_GetStructData
(
	LPINFO_DATA pInfo				//structure holding ISDM structural info
);

//
//Handle validation calls
//
//use these anytime you want to check the validity of a handle to an ISDM object
DllExport BOOL ISD_IsValidKeyHandle
(
	KEY_HANDLE		hKey	//handle to key
);

DllExport BOOL ISD_IsValidValueHandle
(
	VALUE_HANDLE	hValue	//handle to value
);

//CompactMemory is my garbage collection function for ISDM. It is exported for
//test purposes with my browser app. You don't ever need to call this.
DllExport HRESULT ISD_CompactMemory
(
);

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // __ISDMAPI2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rrcminc\rtpplog.h ===
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996:  Intel Corporation
// Confidential -- All proprietary rights reserved.
//
// AUTHOR       Stacy Bell
//
// DESCRIPTION
//              This file contains protocol logging definitions needed by RRCM
//              and the RTP PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the RTP and RTCP protocols as the ones to be logged.
// In the RRCM code, it is used only in the CPLInitialize() call.  
// For example:  RTPProtocolLogger = CPLInitialize( RTPLOG_PROTOCOL );
//
#define RTPLOG_PROTOCOL "RTP_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// RRCM to the logging via user data.  Bit zero of the user data represents
// the Protocol type.  Bit 1 represents whether the PDU was sent or received.
//

#define RTCP_PDU                1UL
#define RTP_PDU                 0UL

#define RTPLOG_SENT_PDU		2UL
#define RTPLOG_RECEIVED_PDU	0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rrcminc\rrcmprot.h ===
/*
 * Filename: RRCMPROT.H
 *
 * Functions prototyping.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/

#ifndef _RRCMPROT_H_
#define _RRCMPROT_H_

#include "rrcm.h"
#include "rtp.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)


/*
	RRCMqueu.CPP
*/
extern DWORD allocateLinkedList (PLINK_LIST,
								 HANDLE,
								 PDWORD,
								 DWORD,
								 CRITICAL_SECTION *);
extern void addToHeadOfList (PLINK_LIST,
							 PLINK_LIST,
							 CRITICAL_SECTION *);
extern void addToTailOfList (PLINK_LIST,
							 PLINK_LIST,
							 CRITICAL_SECTION *);
extern PLINK_LIST removePcktFromTail (PLINK_LIST,
									  CRITICAL_SECTION *);
extern PLINK_LIST removePcktFromHead (PLINK_LIST,
									  CRITICAL_SECTION *);


/*
	RTCPINIT.CPP
*/
extern DWORD initRTCP(void);
extern DWORD deleteRTCP(void);

/*
	RTCPSESS.CPP
*/
extern DWORD allocateRTCPContextHeaps (PRTCP_CONTEXT);
extern DWORD allocateRTCPSessionHeaps (PRTCP_SESSION *);
extern DWORD allocateRTCPsessionResources (PRTCP_SESSION *,
										   PSSRC_ENTRY *);
extern PRTCP_SESSION CreateRTCPSession (SOCKET,
										SOCKET,
										LPVOID,
										DWORD,
										PSDES_DATA,
										DWORD,
										PENCRYPT_INFO,
										DWORD,
										PRRCM_EVENT_CALLBACK,
										DWORD_PTR,
										DWORD,
										DWORD,
										PDWORD);
extern DWORD deleteRTCPSession (SOCKET,
								PCHAR);
extern DWORD buildSDESinfo (PSSRC_ENTRY,
						    PSDES_DATA);
extern DWORD frequencyToPckt (DWORD);
extern DWORD CreateRTCPthread (void);
extern void terminateRtcpThread (void);
extern DWORD RTCPflushIO (PSSRC_ENTRY);
extern DWORD flushIO (PSSRC_ENTRY);
extern void CALLBACK RTCPflushCallback (DWORD,
           			  					DWORD,
           			  					LPWSAOVERLAPPED,
           			  					DWORD);


/*
	RTCPSSRC.CPP
*/
extern PSSRC_ENTRY getOneSSRCentry (PLINK_LIST,
								    HANDLE,
									PDWORD,
									CRITICAL_SECTION *);
extern DWORD getSSRC (LINK_LIST,
					  LINK_LIST);
extern DWORD isSSRCunique (PSSRC_ENTRY,
						   PDWORD);
extern PSSRC_ENTRY createSSRCEntry (DWORD,
								    PRTCP_SESSION,
									PSOCKADDR,
									DWORD,
									DWORD);
extern DWORD RRCMChkCollisionTable (PSOCKADDR pFrom,
 							  		UINT fromlen,
									PSSRC_ENTRY);
extern DWORD RRCMAddEntryToCollisionTable (PSOCKADDR pFrom,
 							  			UINT fromlen,
										PSSRC_ENTRY);
extern void RRCMTimeOutCollisionTable (PRTCP_SESSION);
extern DWORD deleteSSRCEntry (DWORD,
							  PRTCP_SESSION);
extern void	 deleteSSRClist (PRTCP_SESSION,
							 PLINK_LIST,
							 PRTCP_CONTEXT);
void clearSSRCEntry (PSSRC_ENTRY);

/*
	RTCPMEM.CPP
*/
extern DWORD allocateRTCPBfrList (PLINK_LIST,
								  HANDLE,
								  HANDLE,
								  PDWORD,
								  DWORD,
								  CRITICAL_SECTION *);


/*
	RTCPTIME.CPP
*/
extern DWORD RTCPxmitInterval (DWORD,
							   DWORD,
							   DWORD,
							   DWORD,
							   DWORD,
							   int *,
							   DWORD);


/*
	RTCPRECV.CPP
*/
extern DWORD RTCPrcvInit (PSSRC_ENTRY);
extern void CALLBACK RTCPrcvCallback (DWORD,
									  DWORD,
           				  	  		  LPWSAOVERLAPPED,
									  DWORD);
extern DWORD parseRTCPsr (SOCKET,
						  RTCP_T *,
						  PRTCP_SESSION,
						  PRTCP_BFR_LIST);
extern DWORD parseRTCPrr (SOCKET,
						  RTCP_RR_T *,
						  PRTCP_SESSION,
						  PRTCP_BFR_LIST,
						  DWORD);
extern PCHAR parseRTCPsdes (SOCKET,
							PCHAR,
							PRTCP_SESSION,
							PRTCP_BFR_LIST);
extern DWORD parseRTCPbye (SOCKET,
						   DWORD,
						   PRTCP_SESSION,
						   PRTCP_BFR_LIST);
extern DWORD ownLoopback (SOCKET,
						  DWORD,
						  PRTCP_SESSION);
extern DWORD updateRRfeedback (SOCKET,
							   DWORD,
							   DWORD,
							   RTCP_RR_T *,
							   PSSRC_ENTRY);
extern void RTCPpostRecvBfr (PSSRC_ENTRY,
							 PRTCP_BFR_LIST);


/*
	RTCPSEND.CPP
*/
extern void CALLBACK RTCPxmtCallback (DWORD,
									  DWORD,
           			  		   		  LPWSAOVERLAPPED,
									  DWORD);
extern BOOL FormatRTCPReport (PRTCP_SESSION,
										PSSRC_ENTRY,
										DWORD);
extern DWORD getSSRCpcktLoss (PSSRC_ENTRY,
							  DWORD);
extern DWORD *RTCPbuildSDES (RTCP_COMMON_T *,
							 PSSRC_ENTRY,
							 SOCKET,
							 char *,
							 PSDES_DATA);
extern void RTCPcheckSDEStoXmit (PSSRC_ENTRY,
								 PSDES_DATA);
extern void	RTCPbuildSenderRpt (PSSRC_ENTRY,
								RTCP_COMMON_T *,
								SENDER_RPT	**,
								SOCKET);
extern  DWORD usec2ntp (DWORD);
extern	DWORD usec2ntpFrac (long);
extern void	RTCPbuildReceiverRpt (PSSRC_ENTRY,
								  RTCP_RR_T	*,
								  SOCKET);
extern void RTCPsendBYE (PSSRC_ENTRY,
						 PCHAR);
extern DWORD getDLSR (PSSRC_ENTRY);

#ifdef DYNAMIC_RTCP_BW
extern DWORD updateRtpXmtBW (PSSRC_ENTRY);
extern DWORD updateRtpRcvBW (PSSRC_ENTRY);
#endif


/*
	RTPINIT.CPP
*/
extern DWORD deleteRTP (HINSTANCE);
extern void addBuf (void);
extern DWORD initRTP (HINSTANCE);
extern void RRCMreadRegistry (PRTP_CONTEXT);
extern void RRCMgetRegistryValue (HKEY,
							      LPTSTR,
								  PDWORD,
								  DWORD,
								  DWORD);
extern DWORD RRCMgetDynamicLink (void);
extern DWORD deleteRTPSession(PRTP_CONTEXT,
							  PRTP_SESSION);


/*
	RTPSEND.CPP
*/
extern void CALLBACK RTPTransmitCallback (DWORD,
										  DWORD,
										  LPWSAOVERLAPPED,
										  DWORD);
extern DWORD CALLBACK  saveWinsockContext(LPWSAOVERLAPPED,
					   					  LPWSAOVERLAPPED_COMPLETION_ROUTINE,
						   				  PRTP_SESSION,
						   				  SOCKET);
#if 0
extern void updateNtpRtpTimeStampOffset (RTP_HDR_T *,
										 PSSRC_ENTRY);
#endif



/*
	RTPRECV.CPP
*/
extern DWORD  RTPReceiveCheck (
						HANDLE hRTPSession,
						SOCKET RTPsocket,
						char *pPacket,
           				DWORD cbTransferred,
           				PSOCKADDR pFrom,
           				UINT fromlen
           				 );
extern BOOL validateRTPHeader(RTP_HDR_T *);					


/*
	RTP_STAT.CPP
*/
extern DWORD calculateJitter (RTP_HDR_T *,
							  PSSRC_ENTRY);
extern DWORD updateRTPStats (RTP_HDR_T *,
							 PSSRC_ENTRY,
							 DWORD);

/*
	RTPMISC.CPP
*/
extern DWORD saveNetworkAddress (PSSRC_ENTRY,
								 PSOCKADDR,
								 int);
extern PSSRC_ENTRY searchforSSRCatHead(PSSRC_ENTRY,
									   DWORD);
extern PSSRC_ENTRY searchforSSRCatTail(PSSRC_ENTRY,
									   DWORD);
extern PSSRC_ENTRY searchForMySSRC(PSSRC_ENTRY,
								   SOCKET);

#ifdef ENABLE_ISDM2
extern void registerSessionToISDM (PSSRC_ENTRY,
								   PRTCP_SESSION,
								   PISDM2);
extern void	updateISDMstat (PSSRC_ENTRY,
							PISDM2,
							DWORD,
							BOOL);
#endif
extern void RRCMdebugMsg (PCHAR,
						  DWORD,
						  PCHAR,
						  DWORD,
						  DWORD);
extern void RRCMnotification (RRCM_EVENT_T,
							  PSSRC_ENTRY,
							  DWORD,
							  DWORD);




/*
	RRCMCRT.CPP
*/
extern void RRCMsrand (unsigned int);
extern int	RRCMrand (void);
extern char *RRCMitoa (int, char *, int);
extern char *RRCMultoa (unsigned long, char *, int);
extern char *RRCMltoa (long, char *, int);

/*
	RTCPTHRD.CPP
*/
extern void RTCPThread (PRTCP_CONTEXT);
extern PSSRC_ENTRY SSRCTimeoutCheck (PRTCP_SESSION,
									 DWORD);


#if defined(__cplusplus)
}
#endif  // (__cplusplus)


#endif /* ifndef _RRCMPROT_H_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtcp\rrcmqueu.cpp ===
/*----------------------------------------------------------------------------
 * File:        RRCMQUEU.C
 * Product:     RTP/RTCP implementation.
 * Description: Provides queue management function for RRCM.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"                                    


 
/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/

                                                                     
                                                                             
/*---------------------------------------------------------------------------
 * Function   : allocateLinkedList
 * Description: Allocates all the necessary memory resource and link the 
 *              cells to the link list.
 * 
 * Input :      *listPtr		: Address of head pointer.
 *				hHeap			: Heap to allocate the data from.
 *              *numCells		: -> to the number of cells to allocate.
 *				elementSize		: Element size.
 *				pCritSect		: -> to critical section
 *
 * Return: 		TRUE  = Error Code, no queues allocated and linked
 *         		FALSE = OK
 --------------------------------------------------------------------------*/
 DWORD allocateLinkedList (PLINK_LIST pList, 
 						   HANDLE hHeap,
 						   DWORD *numCells,
						   DWORD elementSize,
						   CRITICAL_SECTION *pCritSect)
	{
	DWORD		cellsAllocated = *numCells;
	PLINK_LIST	pHead;                            
	PLINK_LIST	pTmp;

	IN_OUT_STR ("RTCP: Enter allocateLinkedList()\n");
	
	// allocate first cell 
	pHead = (PLINK_LIST)HeapAlloc (hHeap, HEAP_ZERO_MEMORY, elementSize);
	if (pHead == NULL)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation failed", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);

		IN_OUT_STR ("RTCP: Exit allocateLinkedList()\n");
		return (RRCMError_RTCPResources);
		}

	// protect the pointers
	EnterCriticalSection (pCritSect);
	
	// initialize list tail pointer 
	pList->prev = pHead;
	
	// update number of cells allocated 
	cellsAllocated--;

	while (cellsAllocated)	
		{
		cellsAllocated--;

		pHead->next = (PLINK_LIST)HeapAlloc (hHeap, HEAP_ZERO_MEMORY, 
											 elementSize);
		if (pHead->next == NULL)
			break;
    
    	// save head pointer 
    	pTmp = pHead;
    	
		// update head ptr 
		pHead = pHead->next;
		pHead->prev = pTmp;
		}                            
		
	// set number of cells allocated 
	*numCells -= cellsAllocated;
	
	// set head/tail pointers 
	pList->next = pHead;

	// unprotect the pointers
	LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Exit allocateLinkedList()\n");	

	return (RRCM_NoError);
	} 

  
/*--------------------------------------------------------------------------
** Function   : addToHeadOfList
** Description: Add a new cell to the specified queue. The queue acts as a
**              FIFO (cells enqueud on the next pointer and dequeued by the
**              starting address of the queue).
**
** Input :		pHead		= Address of head pointer of queue.
**				pNew		= Cell address to be added to the linked list.
**				pCritSect	= -> to critical section object.
**
** Return: None.
--------------------------------------------------------------------------*/
void addToHeadOfList (PLINK_LIST pHead,
				 	  PLINK_LIST pNew,
					  CRITICAL_SECTION *pCritSect)
	{
	ASSERT (pHead);
	ASSERT (pNew);

	IN_OUT_STR ("RTCP: Enter addToHeadOfList()\n");	

	// safe access to pointers
	EnterCriticalSection (pCritSect);
		
	if (pHead->next == NULL) 
		{
		// head is NULL for the first cell. Assign the address of 
		// the free cell
		pHead->next = pHead->prev = pNew;
		pNew->next  = pNew->prev  = NULL;
		}
	else
		// head ptr points to something 
		{
		pNew->prev    = pHead->next;
		(pHead->next)->next = pNew;
		pNew->next    = NULL;

		// update the head pointer now 
		pHead->next = pNew;
		}

	// unlock pointer access 
	LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Exit addToHeadOfList()\n");	
	}


/*--------------------------------------------------------------------------
** Function   : addToTailOfList
** Description: Add a new cell to the specified queue. The queue acts as a
**              FIFO (cells enqueud on the next pointer and dequeued by the
**              starting address of the queue).
**
** Input :		pTail	= Address of tail pointer to enqueue in.
**				pNew	= New cell address to be added to the linked list.
**
** Return: None.
--------------------------------------------------------------------------*/
void addToTailOfList (PLINK_LIST pTail,
				 	  PLINK_LIST pNew,
  					  CRITICAL_SECTION *pCritSect)
	{
	ASSERT (pTail);
	ASSERT (pNew);

	IN_OUT_STR ("RTCP: Enter addToTailOfList()\n");	

	// safe access to pointers
	EnterCriticalSection (pCritSect);
		
	if (pTail->prev == NULL) 
		{
		// head is NULL for the first cell. Assign the address of 
		// the free cell
		pTail->next = pTail->prev = pNew;
		pNew->next  = pNew->prev  = NULL;
		}
	else
		// tail ptr points to something 
		{
		pNew->next    = pTail->prev;
		(pTail->prev)->prev = pNew;
		pNew->prev    = NULL;

		// update the parent tail pointer now 
		pTail->prev = pNew;
		}

	// unlock pointer access 
	LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Exit addToTailOfList()\n");	
	}


/*--------------------------------------------------------------------------
** Function   : removePcktFromHead
** Description: Remove a cell from front of the specified queue.
**
** Input :		pQueue:	-> to the list to remove the packet from
**
** Return: NULL 			==> Empty queue.
**         Buffer Address 	==> OK, cell removed
--------------------------------------------------------------------------*/
PLINK_LIST removePcktFromHead (PLINK_LIST pQueue,
							   CRITICAL_SECTION *pCritSect)
	{
	PLINK_LIST	pReturnQ;

	IN_OUT_STR ("RTCP: Enter removePcktFromHead()\n");	

	// safe access to pointers
	EnterCriticalSection (pCritSect);
		
	if ((pReturnQ = pQueue->next) != NULL) 
		{
		// We have a buffer.  If this is the last buffer in the queue,
		//	mark it empty.	    
	    if (pReturnQ->prev == NULL) 
			{
	    	pQueue->prev = NULL;
	    	pQueue->next = NULL;
			}
	    else 
			{
	    	// Have the new head buffer point to NULL
		    (pReturnQ->prev)->next = NULL;
		    // Have the queue head point to the new head buffer
	    	pQueue->next = pReturnQ->prev;
			}
		}

	// unlock pointer access 
	LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Exit removePcktFromHead()\n");	

	return (pReturnQ);
	}


/*--------------------------------------------------------------------------
** Function   : removePcktFromTail
** Description: Remove a cell from end of the specified queue.
**
** Input :		pQueue:		-> to the list to remove the packet from
**
** Return:		NULL 			==> Empty queue.
**				Buffer Address 	==> OK, cell removed
--------------------------------------------------------------------------*/
PLINK_LIST removePcktFromTail (PLINK_LIST pQueue,
							   CRITICAL_SECTION *pCritSect)
	{
	PLINK_LIST	pReturnQ;

	IN_OUT_STR ("RTCP: Enter removePcktFromTail()\n");	

	// safe access to pointers
	EnterCriticalSection (pCritSect);
	
	if ((pReturnQ = pQueue->prev) != NULL) 
		{
		// We have a buffer.  If this is the last buffer in the queue,
		//	mark it empty.	    
	    if (pReturnQ->next == NULL) 
			{
	    	pQueue->prev = NULL;
	    	pQueue->next = NULL;
			}
	    else 
			{
		    // In any event, the new prev pointer is NULL: end of list
		    (pReturnQ->next)->prev = NULL;
	    	// have the queue prev pointer point to the new 'last' element
	    	pQueue->prev = pReturnQ->next;
			}
		}

	// unlock pointer access 
	LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Enter removePcktFromTail()\n");	

	return (pReturnQ);
	}



// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtcp\rtcpinit.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPINIT.C
 * Product:     RTP/RTCP implementation
 * Description: Provides RTCP initialization functions.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"                                    


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            
PRTCP_CONTEXT	pRTCPContext = NULL;



/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT	pRTPContext;


/*----------------------------------------------------------------------------
 * Function   : initRTCP
 * Description: RTCP initialization procedures. Creates the initial RTCP 
 *				session and allocates all initial memory resources.
 * 
 * Input :      None.
 *
 * Return: 		OK: RRCM_NoError
 *         		!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD initRTCP (void)
	{
	DWORD		dwStatus = RRCM_NoError;  

	IN_OUT_STR ("RTCP: Enter initRTCP()\n");

	// If RTCP has already been initialized, exit and report the error 
	if (pRTCPContext != NULL) 
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Multiple RTCP Instances", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);

		IN_OUT_STR ("RTCP: Exit initRTCP()\n");
		return (RRCMError_RTCPReInit);
		}

	// Obtain RTCP context 
	pRTCPContext = (PRTCP_CONTEXT)GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT, 
											   sizeof(RTCP_CONTEXT));
	if (pRTCPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation failed", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);

		IN_OUT_STR ("RTCP: Exit initRTCP()\n");

		return RRCMError_RTCPResources;
		}

	// initialize the context critical section 
	InitializeCriticalSection(&pRTCPContext->critSect);

	// Initialize number of desired free cells 
	pRTCPContext->dwInitNumFreeRRCMStat = pRTPContext->registry.NumFreeSSRC;

	// allocate heaps 
	dwStatus = allocateRTCPContextHeaps (pRTCPContext);
 	if (dwStatus == RRCM_NoError)
		{
		// allocate free list of SSRCs statistic entries 
 		dwStatus = allocateLinkedList (&pRTCPContext->RRCMFreeStat,
									   pRTCPContext->hHeapRRCMStat,
 						 	 		   &pRTCPContext->dwInitNumFreeRRCMStat,
 						 	 		   sizeof(SSRC_ENTRY),
									   &pRTCPContext->critSect);
		}

	// initialize the pseudo-random number generator, for later MD5 use
	RRCMsrand ((unsigned int)timeGetTime());

	// If initialation failed return all resourses allocated 
	if (dwStatus != RRCM_NoError) 
		deleteRTCP ();

	IN_OUT_STR ("RTCP: Exit initRTCP()\n");

	return (dwStatus); 		
	}

                                                                              
                                                                              
/*----------------------------------------------------------------------------
 * Function   : deleteRTCP
 * Description: RTCP delete procedures. All RTCP sessions have been deleted 
 *				at this point, so just delete what's needed.
 * 
 * Input :      None.
 *
 * Return: 		FALSE	: OK.
 *         		TRUE  	: Error code. RTCP couldn't be initialized.
 ---------------------------------------------------------------------------*/
 DWORD deleteRTCP (void)
	{   
	IN_OUT_STR ("RTCP: Enter deleteRTCP()\n");

	ASSERT (pRTCPContext);

	// protect everything from the top 
	EnterCriticalSection (&pRTCPContext->critSect);

	// delete all heaps 
	if (pRTCPContext->hHeapRRCMStat) 
		{
		if (HeapDestroy (pRTCPContext->hHeapRRCMStat) == FALSE)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	if (pRTCPContext->hHeapRTCPSes) 
		{
		if (HeapDestroy (pRTCPContext->hHeapRTCPSes) == FALSE)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	// protect everything from the top 
	LeaveCriticalSection (&pRTCPContext->critSect);

	DeleteCriticalSection (&pRTCPContext->critSect);

	// Clean up our context resources 
	GlobalFree (pRTCPContext);

	IN_OUT_STR ("RTCP: Exit deleteRTCP()\n");
	return (TRUE);
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtcp\rtcprept.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPREPT.C
 * Product:     RTP/RTCP implementation
 * Description: Provides report functions for the RRCM implementation.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTCP_CONTEXT	pRTCPContext;
extern RRCM_WS			RRCMws;



/*----------------------------------------------------------------------------
 * Function   : RTCPReportRequest
 * Description: The application request a report for a particular RTCP
 *				session, identified by the socket descriptor.
 *
 * Input :		RTCPsd:				RTCP socket descriptor
 *				offset:				Offset to start from in the list
 *				*status:			-> to the report status information
 *				*moreEntries:		-> to a flag
 *				numEntriesInBfr:	Number of entries in buffer
 *				pReportBfr:			-> to report buffer
 *				iFilterFlags		Bit flags specifying filter to apply
 *				pFilterPattern		-> to value of filter pattern to use
 *				dwFltrPtrnLen		Filter pattern length
 *
 * Return:		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
HRESULT WINAPI RTCPReportRequest (SOCKET RTCPsd,
							       DWORD offset,
								   DWORD *status,
								   DWORD *moreEntries,
								   DWORD numEntriesInBfr,
								   PRTCP_REPORT pReportBfr,
								   DWORD dwFilterFlags,
								   LPVOID pFilterPattern,
								   DWORD dwFltrPtrnLen)
	{
	PLINK_LIST	pTmp;
	PSSRC_ENTRY pRRCM;
	DWORD		dwStatus = RRCM_NoError;
	DWORD		numEntryWritten = 0;
	DWORD		index;
	DWORD		dwLost;
	DWORD		dwTmp;
	BOOL		matched;
	
	IN_OUT_STR ("RTCP: Enter RTCPReportRequest()\n");

	ASSERT (pReportBfr);
	ASSERT (numEntriesInBfr);

	// look for the RTCP session
	pTmp  = pRTCPContext->RTCPSession.prev;
	if (pTmp == NULL)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Invalid RTCP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
		}

	pRRCM = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->XmtSSRCList.prev;
	if (pRRCM == NULL)
		{
		RRCM_DBG_MSG ("RCTP : ERROR - No RTCP Xmt list", 0,
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPNoXmtList));
		}

	while (pTmp)
		{
		if (pRRCM->RTCPsd == RTCPsd)
			break;
		else
			{
			pTmp  = pTmp->next;

			if (pTmp)
				{
				pRRCM = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->XmtSSRCList.prev;
				}

			continue;
			}
		}

	if (pTmp == NULL)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Invalid RTCP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
		}

	if (dwFilterFlags && (pFilterPattern == NULL))
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Invalid RTCP FilterPattern is NULL", 0,
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidRequest));
		}

	// go through the list of transmitters for this RTCP session
	pRRCM = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->XmtSSRCList.prev;

	index = 0;
	while (pRRCM && numEntriesInBfr)
		{
		// go to the desired offset
		if (offset)
			{
			offset--;
			pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
			continue;
			}

		if (dwFilterFlags)
			{
			matched = FALSE;
			switch (dwFilterFlags)
				{
				case FLTR_SSRC:
					if(pRRCM->SSRC == *((DWORD *)pFilterPattern))
						matched=TRUE;
					break;
				case FLTR_CNAME:
					if((memcmp ((char *)pFilterPattern,
								pRRCM->cnameInfo.sdesBfr,
								dwFltrPtrnLen)) == 0)
						matched = TRUE;
					break;
				default:
					RRCM_DBG_MSG ("RTCP: ERROR - Invalid FilterFlag", 0,
								  __FILE__, __LINE__, DBG_ERROR);
					IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

					return (MAKE_RRCM_ERROR(RRCMError_RTCPNotImpl));
				}
			if (!matched)
				{
				pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
				continue;
				}
			else
				numEntriesInBfr--;
			}
		else
			numEntriesInBfr--;

		// fill in the our active Sender report information
		pReportBfr[index].status  = LOCAL_SSRC_RPT;
		pReportBfr[index].ssrc    = pRRCM->SSRC;

		// lock-out bytes update
		EnterCriticalSection (&pRRCM->critSect);

		pReportBfr[index].dwSrcNumPcktRealTime = pRRCM->xmtInfo.dwNumPcktSent;
		pReportBfr[index].dwSrcNumByteRealTime = pRRCM->xmtInfo.dwNumBytesSent;

		// release lock
		LeaveCriticalSection (&pRRCM->critSect);

		// a source - It's supposed to know it's own payload type
		pReportBfr[index].PayLoadType  = UNKNOWN_PAYLOAD_TYPE;

		// our own sampling frequency
		pReportBfr[index].dwStreamClock = pRRCM->dwStreamClock;

		if (pRRCM->cnameInfo.dwSdesLength)
			{
			memcpy (pReportBfr[index].cname,
					pRRCM->cnameInfo.sdesBfr,
					pRRCM->cnameInfo.dwSdesLength);

			pReportBfr[index].dwCnameLen = pRRCM->cnameInfo.dwSdesLength;
			}

		if (pRRCM->nameInfo.dwSdesLength)
			{
			memcpy (pReportBfr[index].name,
					pRRCM->nameInfo.sdesBfr,
					pRRCM->nameInfo.dwSdesLength);

			pReportBfr[index].dwNameLen = pRRCM->nameInfo.dwSdesLength;
			}

		if (pRRCM->fromLen)
			{
			memcpy (&pReportBfr[index].fromAddr,
					&pRRCM->from,
					pRRCM->fromLen);

			pReportBfr[index].dwFromLen = pRRCM->fromLen;
			}

		numEntryWritten++;
		index++;

		// go to next entry
		pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
		}

	// go through the list of receivers for this RTCP session
	pRRCM = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->RcvSSRCList.prev;

	while (pRRCM && numEntriesInBfr)
		{
		// go to the desired offset
		if (offset)
			{
			offset--;
			pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
			continue;
			}

		if (dwFilterFlags)
			{
			matched = FALSE;
			switch (dwFilterFlags)
				{
				case FLTR_SSRC:
					if(pRRCM->SSRC == *((DWORD *)pFilterPattern))
						matched=TRUE;
					break;
				case FLTR_CNAME:
					if((memcmp ((char *)pFilterPattern,
								pRRCM->cnameInfo.sdesBfr,
								dwFltrPtrnLen)) == 0)
						matched = TRUE;
					break;
				default:
					RRCM_DBG_MSG ("RTCP: ERROR - Invalid FilterFlag", 0,
								  __FILE__, __LINE__, DBG_ERROR);
					IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

					return (MAKE_RRCM_ERROR(RRCMError_RTCPNotImpl));
				}
			if (!matched)
				{
				pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
				continue;
				}
			else
				numEntriesInBfr--;
			}
		else
			numEntriesInBfr--;

		// fill in the Receiver report information
		pReportBfr[index].ssrc   = pRRCM->SSRC;
		pReportBfr[index].status = REMOTE_SSRC_RPT;

		// lock-out counters update
		EnterCriticalSection (&pRRCM->critSect);

#ifdef ENABLE_FLOATING_POINT
		pReportBfr[index].SrcJitter     = pRRCM->rcvInfo.interJitter;
#else
		// Check RFC for details of the round off
		pReportBfr[index].SrcJitter     = pRRCM->rcvInfo.interJitter >> 4;
#endif
		pReportBfr[index].dwSrcXtndNum  =
			pRRCM->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd;

		// real time receive information
		pReportBfr[index].dwSrcNumPcktRealTime  = pRRCM->rcvInfo.dwNumPcktRcvd;
		pReportBfr[index].dwSrcNumByteRealTime  = pRRCM->rcvInfo.dwNumBytesRcvd;

		// get sender information from Sender's RTCP report
		pReportBfr[index].dwSrcNumPckt  = pRRCM->xmtInfo.dwNumPcktSent;
		pReportBfr[index].dwSrcNumByte  = pRRCM->xmtInfo.dwNumBytesSent;
		pReportBfr[index].dwSrcLsr      = pRRCM->xmtInfo.dwLastSR;
		pReportBfr[index].dwSrcNtpMsw   = pRRCM->xmtInfo.dwNTPmsw;
		pReportBfr[index].dwSrcNtpLsw   = pRRCM->xmtInfo.dwNTPlsw;
		pReportBfr[index].dwSrcRtpTs    = pRRCM->xmtInfo.dwRTPts;

		dwLost = getSSRCpcktLoss (pRRCM, FALSE);

		// release lock
		LeaveCriticalSection (&pRRCM->critSect);

		// the last payload seen on this RTP stream
		pReportBfr[index].PayLoadType  = pRRCM->PayLoadType;

		// last report received time
		pReportBfr[index].dwLastReportRcvdTime  = pRRCM->dwLastReportRcvdTime;

		// fraction lost is in network byte order
		pReportBfr[index].SrcFraction = (dwLost & 0xFF);

		// cumulative lost is a 24 bits value in network byte order
		RRCMws.ntohl (pRRCM->RTPsd, dwLost, &dwTmp);
		dwTmp &= 0x00FFFFFF;
		pReportBfr[index].SrcNumLost = dwTmp;

		// get feedback information
		if (pRRCM->rrFeedback.SSRC)
			{
			pReportBfr[index].status |= FEEDBACK_FOR_LOCAL_SSRC_PRESENT;
			memcpy (&pReportBfr[index].feedback, &pRRCM->rrFeedback,
					sizeof(RTCP_FEEDBACK));
			}

		if (pRRCM->cnameInfo.dwSdesLength)
			{
			memcpy (pReportBfr[index].cname,
					pRRCM->cnameInfo.sdesBfr,
					pRRCM->cnameInfo.dwSdesLength);

			pReportBfr[index].dwCnameLen = pRRCM->cnameInfo.dwSdesLength;
			}

		if (pRRCM->nameInfo.dwSdesLength)
			{
			memcpy (pReportBfr[index].name,
					pRRCM->nameInfo.sdesBfr,
					pRRCM->nameInfo.dwSdesLength);

			pReportBfr[index].dwNameLen = pRRCM->nameInfo.dwSdesLength;
			}

		if (pRRCM->fromLen)
			{
			memcpy (&pReportBfr[index].fromAddr,
					&pRRCM->from,
					pRRCM->fromLen);

			pReportBfr[index].dwFromLen = pRRCM->fromLen;
			}

		numEntryWritten++;
		index++;

		// go to next entry
		pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
		}

	// check to see if there are additional entries
	if (pRRCM != NULL)
		*moreEntries = TRUE;

	*status = numEntryWritten;

	IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");
	return (dwStatus);	
	}



/*----------------------------------------------------------------------------
 * Function   : getRtcpSessionList
 * Description: Get a list of current RTCP session.
 *
 * Input :		pSockBfr:		-> to a socket buffer
 *				pNumEntries:	-> to number of allocated entries in buffers.
 *				pNumUpdated:	-> number of entries updated
 *
 * Return:		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
HRESULT WINAPI getRtcpSessionList (PDWORD_PTR pSockBfr,
								    DWORD dwNumEntries,
								    PDWORD pNumUpdated)
	{
	DWORD			dwStatus = RRCM_NoError;
	PRTCP_SESSION	pRTCP;
	PSSRC_ENTRY		pSSRC;

	IN_OUT_STR ("RTCP: Enter getRtpSessionList()\n");

	// lock out session's access
	EnterCriticalSection (&pRTCPContext->critSect);

	*pNumUpdated = 0;

	// look for the RTCP session
	pRTCP  = (PRTCP_SESSION)pRTCPContext->RTCPSession.prev;
	if (pRTCP == NULL)
		{
		// Unlock out session's access
		LeaveCriticalSection (&pRTCPContext->critSect);

		IN_OUT_STR ("RTCP: Exit getRtpSessionList()\n");

		return (MAKE_RRCM_ERROR (RRCMError_RTPNoSession));
		}

	// loop through the session's list
	while (pRTCP)
		{
		pSSRC = (PSSRC_ENTRY)pRTCP->XmtSSRCList.prev;
		if (pSSRC == NULL)
			{
			// Unlock out session's access
			LeaveCriticalSection (&pRTCPContext->critSect);

			RRCM_DBG_MSG ("RCTP : ERROR - No RTCP Xmt list", 0,
						  __FILE__, __LINE__, DBG_ERROR);

			IN_OUT_STR ("RTCP: Exit getRtpSessionList()\n");

			return (MAKE_RRCM_ERROR (RRCMError_RTCPNoXmtList));
			}

		if (dwNumEntries)
			{
			pSockBfr[*pNumUpdated] = pSSRC->RTCPsd;

			*pNumUpdated += 1;
			dwNumEntries --;
			}

		if (dwNumEntries == 0)
			{
			break;
			}

		// next entry
		pRTCP = (PRTCP_SESSION)(pRTCP->RTCPList.next);
		}

	// Unlock out session's access
	LeaveCriticalSection (&pRTCPContext->critSect);

	IN_OUT_STR ("RTCP: Exit getRtpSessionList()\n");

	return dwStatus;
	}

// [EOF]


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtcp\rtcprecv.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPRECV.C
 * Product:     RTP/RTCP implementation
 * Description: Provides the RTCP receive network I/O.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/


#include "rrcm.h"


#define		MIN(a, b)	((a < b) ? a : b)


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTCP_CONTEXT	pRTCPContext;
extern PRTP_CONTEXT		pRTPContext;
extern RRCM_WS			RRCMws;

#ifdef ENABLE_ISDM2
extern ISDM2			Isdm2;
#endif

#ifdef _DEBUG
extern char		debug_string[];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif



/*----------------------------------------------------------------------------
 * Function   : RTCPrcvInit
 * Description: RTCP receive initialisation.
 *
 * Input :      pRTCP	: Pointer to the RTCP session information
 *
 * Return: 		TRUE/FALSE
 ---------------------------------------------------------------------------*/
DWORD RTCPrcvInit (PSSRC_ENTRY pSSRC)
	{
	PRTCP_BFR_LIST	pRcvStruct;
	PRTCP_SESSION	pRTCP;
	int				dwStatus;
	int				dwError;
	int				errorCnt = 0;
	int				bfrErrorCnt = 0;
	DWORD			idx;
	int				wsockSuccess = FALSE;

	// save a pointer to the corresponding RTCP session
	pRTCP = pSSRC->pRTCPses;

	// Post receive buffers for WS-2. As these buffers are posted per receive
	// thread, few of them should be plenty enough for RTCP.
	for (idx = 0; idx < pRTPContext->registry.NumRTCPPostedBfr; idx++)
		{
		// get a free RTCP buffer for a receive operation
		pRcvStruct =
			(PRTCP_BFR_LIST)removePcktFromTail(&pRTCP->RTCPrcvBfrList,
											   &pRTCP->critSect);

		// check buffer
		if (pRcvStruct == NULL)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - Rcv Bfr Allocation Error", 0,
						  __FILE__, __LINE__, DBG_ERROR);

			// make sure we have at least one buffer
			ASSERT (pRcvStruct);
			break;
			}

		// SSRC entry address of our own session
		pRcvStruct->pSSRC = pSSRC;

		// received address length reset by the receive routine
		pRcvStruct->addrLen = sizeof(SOCKADDR);

		// use hEvent to recover the buffer's address
		pRcvStruct->overlapped.hEvent = (WSAEVENT)pRcvStruct;

		// post the receive buffer for this thread
		dwStatus = RRCMws.recvFrom (pSSRC->RTCPsd,
			   			  			&pRcvStruct->bfr,
				              		pRcvStruct->dwBufferCount,
				   			  		&pRcvStruct->dwNumBytesXfr,
				   			  		&pRcvStruct->dwFlags,
				   			  		(PSOCKADDR)pRcvStruct->addr,
				    		  		&pRcvStruct->addrLen,
				   			  		(LPWSAOVERLAPPED)&pRcvStruct->overlapped,
				   			  		RTCPrcvCallback);

		// Check Winsock status
		if (dwStatus != 0)
			{
			// error, the receive request won't proceed
			dwError = GetLastError();
			if ((dwError != WSA_IO_PENDING) && (dwError != WSAEMSGSIZE))
				{
				RRCM_DBG_MSG ("RTCP: ERROR WSARecvFrom()", GetLastError(),
							  __FILE__, __LINE__, DBG_ERROR);

				// notify application if interested
				RRCMnotification (RRCM_RTCP_WS_RCV_ERROR, pSSRC,
								  pSSRC->SSRC, dwError);

				// Return the buffer to the free queue
				addToHeadOfList (&pRTCP->RTCPrcvBfrList,
						 	  	 (PLINK_LIST)pRcvStruct,
								 &pRTCP->critSect);
				}
			else
				{
				wsockSuccess = TRUE;

				// increment number of I/O pending
				InterlockedIncrement ((long *)&pRTCP->dwNumRcvIoPending);
				}
			}
		else
			{
			wsockSuccess = TRUE;

			// increment number of I/O pending
			InterlockedIncrement ((long *)&pRTCP->dwNumRcvIoPending);
			}
		}

	// make sure we posted at least some buffers
	if (wsockSuccess == FALSE)
		{
		// release all resources and kill the receive thread
#ifdef _DEBUG
		wsprintf(debug_string,
			"RTCP: ERROR - Exit RCV init %s: Line:%d", __FILE__, __LINE__);
		RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
		return(FALSE);
		}
	return (TRUE);
	}



/*----------------------------------------------------------------------------
 * Function   : RTCPrcvCallback
 * Description: Receive callback routine from Winsock2.
 *
 * Input :	dwError:		I/O completion status
 *			cbTransferred:	Number of bytes received
 *			lpOverlapped:	-> to overlapped structure
 *			dwFlags:		Flags
 *
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void CALLBACK RTCPrcvCallback (DWORD dwError,
           			  		   DWORD cbTransferred,
           			  		   LPWSAOVERLAPPED lpOverlapped,
           			  		   DWORD dwFlags)
	{
	PRTCP_BFR_LIST	pRcvStruct;
	RTCP_T 			*pRTCPpckt;
	PRTCP_SESSION	pRTCPses;
	PSSRC_ENTRY		pSSRC;
	PAPP_RTCP_BFR	pAppBfr;
	DWORD			dwStatus = 0;
	DWORD			i;
	DWORD			pcktLen;
	DWORD			dwSSRC;
	USHORT			wHost;
	SOCKET			RTCPsd;
	unsigned char	*pEndPckt;
	unsigned char	*pEndBlock;
	int				tmpSize;
#if IO_CHECK
	DWORD			initTime = timeGetTime();
#endif

	IN_OUT_STR ("RTCP: Enter RTCPrcvCallback\n");

	// hEvent in the WSAOVERLAPPED struct points to our buffer's information
	pRcvStruct = (PRTCP_BFR_LIST)lpOverlapped->hEvent;

	// SSRC entry pointer
	pSSRC = pRcvStruct->pSSRC;

	// check Winsock callback error status
	if (dwError)
		{
		// 65534 is probably a temporary bug in WS2
		if ((dwError == 65534) || (dwError == WSA_OPERATION_ABORTED))
			{
			RRCM_DBG_MSG ("RTCP: I/O Aborted", dwError,
						  __FILE__, __LINE__, DBG_NOTIFY);
			}
		else
			{
			RRCM_DBG_MSG ("RTCP: ERROR - Rcv Callback", dwError,
						  __FILE__, __LINE__, DBG_ERROR);
			}

		// invalid RTCP packet header, re-queue the buffer
		RTCPpostRecvBfr (pSSRC, pRcvStruct);

		IN_OUT_STR ("RTCP: Exit RTCPrcvCallback\n");
		return;
		}

	// read the RTCP packet
    pRTCPpckt = (RTCP_T *)pRcvStruct->bfr.buf;

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
   //INTEROP
	if (RTPLogger)
		{
		InteropOutput (RTPLogger,
				       (BYTE FAR*)(pRcvStruct->bfr.buf),
					   cbTransferred,
					   RTPLOG_RECEIVED_PDU | RTCP_PDU);
		}
#endif

	// get the RTCP session ptr
	pRTCPses = pSSRC->pRTCPses;

	// Check RTCP header validity of first packet in report.
	// Filter out junk. First thing in RTCP packet must be
	// either SR, RR or BYE
	if ((pRTCPpckt->common.type != RTP_TYPE) ||
		((pRTCPpckt->common.pt != RTCP_SR) &&
		 (pRTCPpckt->common.pt != RTCP_RR) &&
		 (pRTCPpckt->common.pt != RTCP_BYE)))
		{
#ifdef MONITOR_STATS
		pRTCPses->dwNumRTCPhdrErr++;
#endif

		// invalid RTCP packet header, re-queue the buffer
		RTCPpostRecvBfr (pSSRC, pRcvStruct);

#if 0	// we could have shutdown so this code can fault
		if (pRTCPpckt->common.pt == FLUSH_RTP_PAYLOAD_TYPE)
			{
			RRCM_DBG_MSG ("RTCP: Flushing RCV I/O", 0, NULL, 0, DBG_NOTIFY);
			}
		else
			{
			wsprintf(debug_string,
				"RTCP: ERROR - Pckt Header Error. Type:%d / Payload:%d",
				pRTCPpckt->common.type, pRTCPpckt->common.pt);
			RRCM_DBG_MSG (debug_string, 0, __FILE__, __LINE__, DBG_TRACE);
			}
#endif

		IN_OUT_STR ("RTCP: Exit RTCPrcvCallback\n");
		return;
		}

	// get the socket descriptor
	RTCPsd = pSSRC->RTCPsd;

	// get the sender's SSRC
	RRCMws.ntohl (RTCPsd, pRTCPpckt->r.sr.ssrc, &dwSSRC);

	// skip our own loopback if we receive it
	if (ownLoopback (RTCPsd, dwSSRC, pRTCPses))
		{
		RTCPpostRecvBfr (pSSRC, pRcvStruct);
		return;
		}

	// at this point we think the RTCP packet's valid. Get the sender's
	//  address, if not already known
	if (!(pRTCPses->dwSessionStatus & RTCP_DEST_LEARNED))
		{
		pRTCPses->dwSessionStatus |= RTCP_DEST_LEARNED;
		pRTCPses->toLen = pRcvStruct->addrLen;
		memcpy (&pRTCPses->toBfr, &pRcvStruct->addr, pRcvStruct->addrLen);

#ifdef ENABLE_ISDM2
		// register our Xmt SSRC - Rcvd one will be found later
		if (Isdm2.hISDMdll)
			registerSessionToISDM (pSSRC, pRTCPses, &Isdm2);
#endif
		}
	
	// Update our RTCP average packet size estimator
 	EnterCriticalSection (&pRTCPses->critSect);
	tmpSize = (cbTransferred + NTWRK_HDR_SIZE) - pRTCPses->avgRTCPpktSizeRcvd;

#ifdef ENABLE_FLOATING_POINT
	// As per RFC
	tmpSize = (int)(tmpSize * RTCP_SIZE_GAIN);
#else
	// Need to remove floating point operation
	tmpSize = tmpSize / 16;
#endif

	pRTCPses->avgRTCPpktSizeRcvd += tmpSize;
	LeaveCriticalSection (&pRTCPses->critSect);

	// check if the raw RTCP packet needs to be copied into an application
	//  buffer - Mainly used by ActiveMovieRTP to propagate the reports up
	//  the filter graph to the Receive Payload Handler
	pAppBfr = (PAPP_RTCP_BFR)removePcktFromHead (&(pRTCPses->appRtcpBfrList),
												 &pRTCPses->critSect);
	if (pAppBfr && !(pAppBfr->dwBfrStatus & RTCP_SR_ONLY))
		{
		// copy the full RTCP packet
		memcpy (pAppBfr->bfr,
				pRTCPpckt,
				MIN(pAppBfr->dwBfrLen, cbTransferred));

		// number of bytes received
		pAppBfr->dwBytesRcvd = MIN(pAppBfr->dwBfrLen, cbTransferred);

		// set the event associated with this buffer
		SetEvent (pAppBfr->hBfrEvent);
		}

	// end of the received packet
	pEndPckt = (unsigned char *)pRTCPpckt + cbTransferred;

	while ((unsigned char *)pRTCPpckt < pEndPckt)
		{
		// get the length
		dwStatus = RRCMws.ntohs (RTCPsd, pRTCPpckt->common.length, &wHost);
		if (dwStatus)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - WSANtohs()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}

		// get this report block length
		pcktLen   = (wHost + 1) << 2;
		pEndBlock = (unsigned char *)pRTCPpckt + pcktLen;

		// sanity check
		if (pEndBlock > pEndPckt)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - Rcv packet length error", 0,
						  __FILE__, __LINE__, DBG_ERROR);

#ifdef MONITOR_STATS
			pRTCPses->dwNumRTCPlenErr++;
#endif
			break;
			}

		// make sure the version is correct for all packets
		if (pRTCPpckt->common.type != RTP_TYPE)
			{
#ifdef MONITOR_STATS
			pRTCPses->dwNumRTCPhdrErr++;
#endif
			// invalid RTCP packet header, packet will be re-queued
			break;
			}

		switch (pRTCPpckt->common.pt)
			{
			case RTCP_SR:
				// check if only the SR needs to be propagated up to the app
				if (pAppBfr && (pAppBfr->dwBfrStatus & RTCP_SR_ONLY))
					{
					// copy the RTCP SR
					memcpy (pAppBfr->bfr,
							pRTCPpckt,
							MIN(pAppBfr->dwBfrLen, 24));

					// number of bytes received
					pAppBfr->dwBytesRcvd = MIN(pAppBfr->dwBfrLen, 24);

					// set the event associated with this buffer
					SetEvent (pAppBfr->hBfrEvent);
					}

				// get the sender's SSRC
				RRCMws.ntohl (RTCPsd, pRTCPpckt->r.sr.ssrc, &dwSSRC);

				// parse the sender report
				parseRTCPsr (RTCPsd, pRTCPpckt, pRTCPses, pRcvStruct);

				// parse additional receiver reports if any
				for (i = 0; i < pRTCPpckt->common.count; i++)
					{
					parseRTCPrr (RTCPsd, &pRTCPpckt->r.sr.rr[i],
								 pRTCPses, pRcvStruct,
								 dwSSRC);
					}

				// notify application if interested
				RRCMnotification (RRCM_RECV_RTCP_SNDR_REPORT_EVENT, pSSRC,
								  dwSSRC, 0);
				break;

			case RTCP_RR:
				// get the sender's SSRC
				RRCMws.ntohl (RTCPsd, pRTCPpckt->r.rr.ssrc, &dwSSRC);

				// parse receiver reports
				for (i = 0; i < pRTCPpckt->common.count; i++)
					{
					parseRTCPrr (RTCPsd, &pRTCPpckt->r.rr.rr[i],
								 pRTCPses, pRcvStruct,
								 dwSSRC);
					}

				// notify application if interested
				RRCMnotification (RRCM_RECV_RTCP_RECV_REPORT_EVENT, pSSRC,
								  dwSSRC, 0);
				break;

			case RTCP_SDES:
				{
				PCHAR	buf;

				buf = (PCHAR)&pRTCPpckt->r.sdes;

				for (i = 0; i < pRTCPpckt->common.count; i++)
					{
					buf = parseRTCPsdes (RTCPsd, buf, pRTCPses, pRcvStruct);
					if (buf == NULL)
						break;
					}
				}
				break;

			case RTCP_BYE:
				for (i = 0; i < pRTCPpckt->common.count; i++)
      				parseRTCPbye (RTCPsd, pRTCPpckt->r.bye.src[i],
								  pRTCPses, pRcvStruct);
				break;

			default:
				break;
			}

		// go to next report block
    	pRTCPpckt = (RTCP_T *)(pEndBlock);
		}

	// post back the buffer to WS-2
	RTCPpostRecvBfr (pSSRC, pRcvStruct);

#if IO_CHECK
	wsprintf(debug_string,
		"RTCP: Leaving Rcv Callback after: %ld msec\n",
		 timeGetTime() - initTime);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	IN_OUT_STR ("RTCP: Exit RTCPrcvCallback\n");
	}



/*----------------------------------------------------------------------------
 * Function   : parseRTCPsr
 * Description: Parse an RTCP sender reports and update the corresponding
 *				statistics.
 *
 * Input :      sd:			RTCP Socket descriptor
 *				pRTCPpckt:	-> to the RTCP packet
 *				pRTCPses:	-> to the RTCP session information
 *				pRcvStruct:	-> to the receive structure information
 *
 * Return: 		OK: RRCM_NoError
 *				!0:	Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD parseRTCPsr (SOCKET sd,
					RTCP_T *pRTCPpckt,
					PRTCP_SESSION pRTCPses,
 					PRTCP_BFR_LIST pRcvStruct)
 	{
	PSSRC_ENTRY	pSSRC;
	DWORD		dwSSRC;

	IN_OUT_STR ("RTCP: Enter parseRTCPsr\n");

	// get the sender's SSRC
	RRCMws.ntohl (sd, pRTCPpckt->r.sr.ssrc, &dwSSRC);

#ifdef _DEBUG
	wsprintf(debug_string, "RTCP: Receive SR from SSRC:x%lX", dwSSRC);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// look for the SSRC entry in the list for this RTCP session
	pSSRC = searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev,
								dwSSRC);
	if (pSSRC == NULL)
		{
		// new SSRC, create an entry in this RTCP session
		pSSRC = createSSRCEntry(dwSSRC,
							 	pRTCPses,
								(PSOCKADDR)pRcvStruct->addr,
								(DWORD)pRcvStruct->addrLen,
								FALSE);

		if (pSSRC == NULL)
			{
			// cannot create a new entry, out of resources
			RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation", 0,
						  __FILE__, __LINE__, DBG_ERROR);

			IN_OUT_STR ("RTCP: Exit parseRTCPsr\n");

			return (RRCMError_RTCPResources);
			}

		// notify application if it desired so
		RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, dwSSRC,
						  UNKNOWN_PAYLOAD_TYPE);
		}

	// get the RTP timestamp
	RRCMws.ntohl (sd, pRTCPpckt->r.sr.rtp_ts, &pSSRC->xmtInfo.dwRTPts);

	// number of packets send
	RRCMws.ntohl (sd, pRTCPpckt->r.sr.psent, &pSSRC->xmtInfo.dwNumPcktSent);

	// number of bytes sent
	RRCMws.ntohl (sd, pRTCPpckt->r.sr.osent, &pSSRC->xmtInfo.dwNumBytesSent);

	// get the NTP most significant word
	RRCMws.ntohl (sd, pRTCPpckt->r.sr.ntp_sec, &pSSRC->xmtInfo.dwNTPmsw);

	// get the NTP least significant word
	RRCMws.ntohl (sd, pRTCPpckt->r.sr.ntp_frac, &pSSRC->xmtInfo.dwNTPlsw);

	// last SR timestamp (middle 32 bits of the NTP timestamp)
	pSSRC->xmtInfo.dwLastSR = ((pSSRC->xmtInfo.dwNTPmsw & 0x0000FFFF) << 16);
	pSSRC->xmtInfo.dwLastSR |= ((pSSRC->xmtInfo.dwNTPlsw & 0xFFFF0000) >> 16);
	
	// last time this SSRC's heard
	pSSRC->dwLastReportRcvdTime = pSSRC->xmtInfo.dwLastSRLocalTime =
		timeGetTime();

	// get the source address information
	if (!(pSSRC->dwSSRCStatus & NETWK_ADDR_UPDATED))
		{
		saveNetworkAddress(pSSRC,
						   (PSOCKADDR)pRcvStruct->addr,
						   pRcvStruct->addrLen);
		}

	// increment the number of report received from this SSRC
	InterlockedIncrement ((long *)&pSSRC->dwNumRptRcvd);

#ifdef ENABLE_ISDM2
	// update ISDM
	if (Isdm2.hISDMdll && pRTCPses->hSessKey)
		{
		if (pSSRC->hISDM)
			updateISDMstat (pSSRC, &Isdm2, RECVR, FALSE);
		else
			registerSessionToISDM (pSSRC, pRTCPses, &Isdm2);
		}
#endif

	IN_OUT_STR ("RTCP: Exit parseRTCPsr\n");

	return (RRCM_NoError);
	}



/*----------------------------------------------------------------------------
 * Function   : parseRTCPrr
 * Description: Parse an RTCP receiver reports and update the corresponding
 *				statistics.
 *
 * Input :      sd:			RTCP socket descriptor
 *				pRR:		-> to receiver report buffer
 *				pRTCPses:	-> to the RTCP session information
 *				pRcvStruct:	-> to the receive structure information
 *				senderSSRC:	Sender's SSRC
 *
 * Return: 		OK: RRCM_NoError
 *				!0:	Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD parseRTCPrr (SOCKET sd,
					RTCP_RR_T *pRR,
 					PRTCP_SESSION pRTCPses,
					PRTCP_BFR_LIST pRcvStruct,
					DWORD senderSSRC)
 	{
	PSSRC_ENTRY	pSSRC;
	DWORD		dwSSRC;
	DWORD		dwGetFeedback = FALSE;

	IN_OUT_STR ("RTCP: Enter parseRTCPrr\n");

#ifdef _DEBUG
	wsprintf(debug_string,
		"RTCP: Receive RR from sender SSRC:x%lX", senderSSRC);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// get the receiver report SSRC
	RRCMws.ntohl (sd, pRR->ssrc, &dwSSRC);

#ifdef _DEBUG
	wsprintf(debug_string, "RTCP: RR for SSRC:x%lX", dwSSRC);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	//
	// NOTE:
	// For now we just keep track of feedback information about ourselve. Later
	// the link list can be used to keep track about everybody feedback
	// information.
	//
	// Check to see if we're interested in this report, ie, does this SSRC report
	// information about one of our active sender.
	dwGetFeedback =
		searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->XmtSSRCList.prev,
						    dwSSRC) != NULL;

	// look for the sender SSRC entry in the list for this RTCP session
	pSSRC =
		searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev,
							senderSSRC);
	if (pSSRC == NULL)
		{
		// new SSRC, create an entry in this RTCP session
		pSSRC = createSSRCEntry(senderSSRC,
							 	pRTCPses,
								(PSOCKADDR)pRcvStruct->addr,
								(DWORD)pRcvStruct->addrLen,
								FALSE);

		if (pSSRC == NULL)
			{
			// cannot create a new entry, out of resources
			RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation", 0,
						  __FILE__, __LINE__, DBG_ERROR);

			IN_OUT_STR ("RTCP: Exit parseRTCPrr\n");
			return (RRCMError_RTCPResources);
			}

		// notify application if it desired so
		RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, senderSSRC,
						  UNKNOWN_PAYLOAD_TYPE);
		}

	// update RR feedback information
	if (dwGetFeedback)
		updateRRfeedback (sd, senderSSRC, dwSSRC, pRR, pSSRC);

	// last time this SSRC's heard
	pSSRC->dwLastReportRcvdTime = timeGetTime();

	// get the source address information
	if (!(pSSRC->dwSSRCStatus & NETWK_ADDR_UPDATED))
		{
		saveNetworkAddress(pSSRC,
						   (PSOCKADDR)pRcvStruct->addr,
						   pRcvStruct->addrLen);
		}

	// increment the number of report received from this SSRC
	InterlockedIncrement ((long *)&pSSRC->dwNumRptRcvd);

#ifdef ENABLE_ISDM2
	// update ISDM
	if (Isdm2.hISDMdll && pRTCPses->hSessKey)
		{
		if (pSSRC->hISDM)
			updateISDMstat (pSSRC, &Isdm2, RECVR, TRUE);
		else
			registerSessionToISDM (pSSRC, pRTCPses, &Isdm2);
		}
#endif

	IN_OUT_STR ("RTCP: Exit parseRTCPrr\n");

	return (RRCM_NoError);
	}



/*----------------------------------------------------------------------------
 * Function   : parseRTCPsdes
 * Description: Parse an RTCP SDES packet
 *
 * Input :      sd:			RTCP socket descriptor
 *				bfr:		-> to SDES buffer
 *				pRTCPses:	-> to the RTCP session information
 *				pRcvStruct:	-> to the receive structure information
 *
 * Return: 		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 PCHAR parseRTCPsdes (SOCKET sd,
					  PCHAR bfr,
					  PRTCP_SESSION pRTCPses,
 					  PRTCP_BFR_LIST pRcvStruct)
	{
	DWORD				dwHost;
	DWORD 				ssrc = *(DWORD *)bfr;
	RTCP_SDES_ITEM_T 	*pSdes;
	PSSRC_ENTRY			pSSRC;

	IN_OUT_STR ("RTCP: Enter parseRTCPsdes\n");

	// get the SSRC
	RRCMws.ntohl (sd, ssrc, &dwHost);

#ifdef _DEBUG
	wsprintf(debug_string, "RTCP: Receive SDES from SSRC: x%lX", dwHost);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// look for the SSRC entry in the list for this RTCP session
	pSSRC = searchforSSRCatTail ((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev,
								 dwHost);
	if (pSSRC == NULL)
		{
#ifdef _DEBUG
		wsprintf(debug_string,
			 "RTCP: SDES and SSRC (x%lX) not found for session (Addr x%p)",
			 dwHost, pRTCPses);
		RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

		// new SSRC, create an entry in this RTCP session
		pSSRC = createSSRCEntry(dwHost,
							 	pRTCPses,
								(PSOCKADDR)pRcvStruct->addr,
								(DWORD)pRcvStruct->addrLen,
								FALSE);

		if (pSSRC == NULL)
			{
			// cannot create a new entry, out of resources
			RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation", 0,
						  __FILE__, __LINE__, DBG_ERROR);

			IN_OUT_STR ("RTCP: Exit parseRTCPsdes\n");

			return (NULL);
			}

		// notify application if it desired so
		RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, dwHost,
						  UNKNOWN_PAYLOAD_TYPE);
		}

	// read the SDES chunk
	pSdes = (RTCP_SDES_ITEM_T *)(bfr + sizeof(DWORD));

	// go through until a 'type = 0' is found
	for (; pSdes->dwSdesType;
		 pSdes = (RTCP_SDES_ITEM_T *)((char *)pSdes + pSdes->dwSdesLength + 2))
		{
		switch (pSdes->dwSdesType)
			{
			case RTCP_SDES_CNAME:
				if (pSSRC->cnameInfo.dwSdesLength == 0)
					{
					pSSRC->cnameInfo.dwSdesLength = pSdes->dwSdesLength;

					// get the Cname
					memcpy (pSSRC->cnameInfo.sdesBfr, pSdes->sdesData,
							min (pSdes->dwSdesLength, MAX_SDES_LEN-1));
					}
				else
					{
					// check to see for a loop/collision of the SSRC
					if (memcmp (pSdes->sdesData, pSSRC->cnameInfo.sdesBfr,
								min (pSdes->dwSdesLength, MAX_SDES_LEN-1)) != 0)
						{
						// loop/collision of a third-party detected
						pSSRC->dwSSRCStatus |= THIRD_PARTY_COLLISION;

						// notify application if interested
						RRCMnotification (RRCM_REMOTE_COLLISION_EVENT, pSSRC,
										  pSSRC->SSRC, 0);

						// RTP & RTCP packet from this SSRC will be rejected
						//  until the senders resolve the collision

						IN_OUT_STR ("RTCP: Exit parseRTCPsdes\n");

						return NULL;
						}
					}

				break;

			case RTCP_SDES_NAME:
				// the name can change, not like the Cname, so update it
				// every time.
				pSSRC->nameInfo.dwSdesLength = pSdes->dwSdesLength;

				// get the name
				memcpy (pSSRC->nameInfo.sdesBfr, pSdes->sdesData,
						min (pSdes->dwSdesLength, MAX_SDES_LEN-1));
				break;

			default:
				break;
			}
		}

	// last time this SSRC's heard
	pSSRC->dwLastReportRcvdTime = timeGetTime();

	// get the source address information
	if (!(pSSRC->dwSSRCStatus & NETWK_ADDR_UPDATED))
		{
		saveNetworkAddress(pSSRC,
						   (PSOCKADDR)pRcvStruct->addr,
						   pRcvStruct->addrLen);
		}

	// adjust pointer
	bfr = (char *)pSdes;

	IN_OUT_STR ("RTCP: Exit parseRTCPsdes\n");

	// go the next 32 bits boundary
	return bfr + ((4 - ((LONG_PTR)bfr & 0x3)) & 0x3);
	}




/*----------------------------------------------------------------------------
 * Function   : parseRTCPbye
 * Description: Parse an RTCP BYE packet
 *
 * Input :      sd:			RTCP socket descriptor
 *				ssrc:		SSRC
 *				pRTCPses:	-> to the RTCP session information
 *				pRcvStruct:	-> to the receive structure
 *
 * Return: 		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD parseRTCPbye (SOCKET sd,
					 DWORD ssrc,
					 PRTCP_SESSION pRTCPses,
					 PRTCP_BFR_LIST pRcvStruct)
	{
	DWORD		dwStatus;
	DWORD		dwHost;
	PSSRC_ENTRY	pSSRC;

	IN_OUT_STR ("RTCP: Enter parseRTCPbye\n");

	RRCMws.ntohl (sd, ssrc, &dwHost);

#ifdef _DEBUG
	wsprintf(debug_string, "RTCP: BYE from SSRC: x%lX", dwHost);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// find the SSRC entry
	pSSRC = searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev,
								dwHost);
	if (pSSRC == NULL)
		{
#ifdef _DEBUG
		wsprintf(debug_string,
			 "RTCP: SSRC: x%lX not found in session: x%p",
			  dwHost, pRTCPses);
		RRCM_DBG_MSG (debug_string, 0, __FILE__, __LINE__, DBG_TRACE);

		IN_OUT_STR ("RTCP: Exit parseRTCPbye\n");
#endif
		return (RRCM_NoError);
		}

	// make sure the BYE is coming from the expected source and not intruder
	if ((pRcvStruct->addrLen != pSSRC->fromLen) ||
#if 0
// There is a bug NT's Winsock2 implememtation. The unused bytes of
// SOCKADDR are not reset to 0 as they should be. Work fine on W95
// Temporarily just check the first 8 bytes, i.e. address family, port
// and IP address.
		(memcmp (&pRcvStruct->addr, &pSSRC->from, pSSRC->fromLen)))
#else
		(memcmp (&pRcvStruct->addr, &pSSRC->from, 8)))
#endif
		return (RRCM_NoError);

	// notify application if interested
	RRCMnotification (RRCM_BYE_EVENT, pSSRC, dwHost, 0);

	// delete this SSRC from the list
	dwStatus = deleteSSRCEntry (dwHost, pRTCPses);
#ifdef _DEBUG
	if (dwStatus == FALSE)
		{
		wsprintf(debug_string,
			 "RTCP: SSRC: x%lX not found in session: x%p",
			  dwHost, pRTCPses);
		RRCM_DBG_MSG (debug_string, 0, __FILE__, __LINE__, DBG_TRACE);
		}
#endif

	IN_OUT_STR ("RTCP: Exit parseRTCPbye\n");
	return (RRCM_NoError);
	}



/*----------------------------------------------------------------------------
 * Function   : ownLoopback
 * Description: Determine if we receive our own loopback. We don't want to
 *				create an entry for ourselve, as we're already in the list.
 *
 * Input :      sd:			RTCP socket descriptor
 *				ssrc:		SSRC
 *				pRTCPses:	-> to the RTCP session's information
 *
 * Return: 		TRUE:	Our loopback
 *				FALSE:	No loopback
 ---------------------------------------------------------------------------*/
 DWORD ownLoopback (SOCKET sd,
					DWORD ssrc,
					PRTCP_SESSION pRTCPses)
	{
	PSSRC_ENTRY	pSSRC;

	IN_OUT_STR ("RTCP: Enter ownLoopback\n");

	// don't create an entry if received our own xmit back
	pSSRC = searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->XmtSSRCList.prev,
								ssrc);

	IN_OUT_STR ("RTCP: Exit ownLoopback\n");

	if (pSSRC)
		return TRUE;
	else
		return FALSE;
	}



/*----------------------------------------------------------------------------
 * Function   : updateRRfeedback
 * Description: Update the Receiver Report feedback for an active source
 *
 * Input :      sd:			RTCP socket descriptor
 *				dwSndSSRC:	Sender's SSRC
 *				pRR:		-> to receiver report entry
 *				pSSRC:		-> to the SSRC entry
 *
 * Return: 		TRUE
 ---------------------------------------------------------------------------*/
 DWORD 	updateRRfeedback (SOCKET sd,
						  DWORD dwSndSSRC,
						  DWORD dwSSRCfedback,
						  RTCP_RR_T *pRR,
						  PSSRC_ENTRY pSSRC)
	{
	DWORD	dwHost;

	IN_OUT_STR ("RTCP: Enter updateRRfeedback\n");

	// Note when we last heard from the receiver
	pSSRC->rrFeedback.dwLastRcvRpt = timeGetTime();
	
	// SSRC who's feedback is for (ourselve for now)
	pSSRC->rrFeedback.SSRC = dwSSRCfedback;

	// get delay since last SR
	RRCMws.ntohl (sd, pRR->dlsr, &pSSRC->rrFeedback.dwDelaySinceLastSR);

	// get last SR
	RRCMws.ntohl (sd, pRR->lsr, &pSSRC->rrFeedback.dwLastSR);

	// get the jitter
	RRCMws.ntohl (sd, pRR->jitter, &pSSRC->rrFeedback.dwInterJitter);

	// highest sequence number received
	RRCMws.ntohl (sd, pRR->expected,
		&pSSRC->rrFeedback.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd);

	// fraction lost
	pSSRC->rrFeedback.fractionLost = (pRR->received & 0xFF);

	// cumulative number of packet lost
	RRCMws.ntohl (sd, pRR->received, &dwHost);
	dwHost &= 0x00FFFFFF;
	pSSRC->rrFeedback.cumNumPcktLost = dwHost;

	IN_OUT_STR ("RTCP: Exit updateRRfeedback\n");

	return TRUE;
	}



/*----------------------------------------------------------------------------
 * Function   : RTCPpostRecvBfr
 * Description: RTCP post a receive buffer to Winsock-2
 *
 * Input :      sd:			RTCP socket descriptor
 *				pSSRC:		-> to the SSRC entry
 *
 * Return: 		TRUE
 ---------------------------------------------------------------------------*/
 void RTCPpostRecvBfr (PSSRC_ENTRY pSSRC,
					   PRTCP_BFR_LIST pRcvStruct)
	{
	DWORD	dwStatus;
	DWORD	dwError;

	IN_OUT_STR ("RTCP: Enter RTCPpostRecvBfr\n");

	// decrement number of I/O pending
	InterlockedDecrement ((long *)&pSSRC->pRTCPses->dwNumRcvIoPending);

	// don't repost any buffer if within the shutdown procedure
	if ((pSSRC->pRTCPses->dwSessionStatus & SHUTDOWN_IN_PROGRESS) &&
		(pSSRC->pRTCPses->dwNumRcvIoPending == 0))
		{
		// shutdown done - set event
		if (SetEvent (pSSRC->pRTCPses->hShutdownDone) == FALSE)
			{
			RRCM_DBG_MSG ("RTCP: SetEvent() Error\n", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}

		IN_OUT_STR ("RTCP: Exit RTCPpostRecvBfr\n");
		return;
		}
	else if (pSSRC->pRTCPses->dwSessionStatus & SHUTDOWN_IN_PROGRESS)
		{
		IN_OUT_STR ("RTCP: Exit RTCPpostRecvBfr\n");
		return;
		}

	// clear number of bytes transferred
	pRcvStruct->dwNumBytesXfr = 0;

	dwStatus = RRCMws.recvFrom (pSSRC->RTCPsd,
		   			  			&pRcvStruct->bfr,
			              		pRcvStruct->dwBufferCount,
			   			  		&pRcvStruct->dwNumBytesXfr,
		   				  		&pRcvStruct->dwFlags,
		   				  		(PSOCKADDR)pRcvStruct->addr,
		    			  		&pRcvStruct->addrLen,
			   			  		(LPWSAOVERLAPPED)&pRcvStruct->overlapped,
			   			  		RTCPrcvCallback);

	// Check Winsock status
	if (dwStatus != 0)
		{
		// error, the receive request won't proceed
		dwError = GetLastError();
		if ((dwError != WSA_IO_PENDING) && (dwError != WSAEMSGSIZE))
			{
			RRCM_DBG_MSG ("RTCP: ERROR - WSARecvFrom()", dwError,
						  __FILE__, __LINE__, DBG_ERROR);

			// notify application if interested
			RRCMnotification (RRCM_RTCP_WS_RCV_ERROR, pSSRC,
							  pSSRC->SSRC, dwError);

			// Return the buffer to the free queue
			addToHeadOfList (&pSSRC->pRTCPses->RTCPrcvBfrList,
					 	  	 (PLINK_LIST)pRcvStruct,
							 &pSSRC->pRTCPses->critSect);
			}
		else
			{
			// increment number of I/O pending
			InterlockedIncrement ((long *)&pSSRC->pRTCPses->dwNumRcvIoPending);
			}
		}
	else
		{
		// synchronous completion - callback has been scheduled
		// increment number of I/O pending
		InterlockedIncrement ((long *)&pSSRC->pRTCPses->dwNumRcvIoPending);
		}

	IN_OUT_STR ("RTCP: Exit RTCPpostRecvBfr\n");
	}


/*----------------------------------------------------------------------------
 * Function   : addApplicationRtcpBfr
 * Description: Add an application provided buffer for RTCP to copy the
 *				raw received reports to be used by the application if it
 *				desired so.
 *
 * Input :      RTPsession:	Handle to the RTP session
 *				pAppBfr:	-> an application buffer data structure
 *
 * Return: 		TRUE
 ---------------------------------------------------------------------------*/
 HRESULT WINAPI addApplicationRtcpBfr (DWORD_PTR	RTPsession,
									    PAPP_RTCP_BFR pAppBfr)
	{
	IN_OUT_STR ("RTCP : Enter addApplicationRtcpBfr()\n");

	PRTP_SESSION    pSession = (PRTP_SESSION)RTPsession;
	PRTCP_SESSION	pRTCPSess;

	if (pSession == NULL)
		{
		RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTCP : Exit addApplicationRtcpBfr()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPSessResources));
		}

	pRTCPSess = (PRTCP_SESSION)pSession->pRTCPSession;
	if (pRTCPSess == NULL)
		{
		RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTCP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTCP : Exit addApplicationRtcpBfr()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
		}

	// Let's add this buffer to our list
	addToTailOfList(&(pRTCPSess->appRtcpBfrList),
					(PLINK_LIST)pAppBfr,
					&pRTCPSess->critSect);

	IN_OUT_STR ("RTCP : Exit addApplicationRtcpBfr()\n");

	return NOERROR;
	}


/*----------------------------------------------------------------------------
 * Function   : removeApplicationRtcpBfr
 * Description: Remove an application provided buffer to this RTCP session.
 *
 * Input :      RTPsession:	RTP session handle
 *
 * Return: 		Application buffer address / NULL
 ---------------------------------------------------------------------------*/
 PAPP_RTCP_BFR WINAPI removeApplicationRtcpBfr (DWORD_PTR RTPsession)
	{
	PRTP_SESSION    pSession = (PRTP_SESSION)RTPsession;
	PRTCP_SESSION	pRTCPSess;
	PAPP_RTCP_BFR	pAppBfr;

	IN_OUT_STR ("RTCP : Enter removeApplicationRtcpBfr()\n");

	if (pSession == NULL)
		{
		RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTCP : Exit removeApplicationRtcpBfr()\n");

		return NULL;
		}

	pRTCPSess = (PRTCP_SESSION)pSession->pRTCPSession;
	if (pRTCPSess == NULL)
		{
		RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTCP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTCP : Exit removeApplicationRtcpBfr()\n");

		return NULL;
		}

	pAppBfr = (PAPP_RTCP_BFR)removePcktFromHead (&(pRTCPSess->appRtcpBfrList),
												 &pRTCPSess->critSect);

	IN_OUT_STR ("RTCP : Exit removeApplicationRtcpBfr()\n");

	return pAppBfr;
	}


// [EOF]





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtcp\rtcpsend.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPIO.C
 * Product:     RTP/RTCP implementation
 * Description: Provides the RTCP network I/O.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/


#include "rrcm.h"


/*---------------------------------------------------------------------------
/                                                       Global Variables
/--------------------------------------------------------------------------*/
#define DBG_CUM_FRACT_LOSS      0
#define FRACTION_ENTRIES        10
#define FRACTION_SHIFT_MAX      32
long    microSecondFrac [FRACTION_ENTRIES] = {500000,
                                                                                          250000,
                                                                                          125000,
                                                                                           62500,
                                                                                           31250,
                                                                                           15625,
                                                                                            7812,       // some precision lost
                                                                                                3906,   // some precision lost
                                                                                                1953,   // some precision lost
                                                                                                 976};  // ~ 1 milli second



/*---------------------------------------------------------------------------
/                                                       External Variables
/--------------------------------------------------------------------------*/
extern PRTCP_CONTEXT    pRTCPContext;
extern RRCM_WS                  RRCMws;

#ifdef ENABLE_ISDM2
extern ISDM2                    Isdm2;
#endif

#ifdef _DEBUG
extern char             debug_string[];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif



/*----------------------------------------------------------------------------
 * Function   : xmtRTCPreport
 * Description: RTCP report generator
 *
 * Input :      pSSRC   : -> to the SSRC entry
 *
 * Return:              None.
 ---------------------------------------------------------------------------*/
BOOL FormatRTCPReport (PRTCP_SESSION pRTCP,
                                                                 PSSRC_ENTRY pSSRC,
                                                                 DWORD curTime)
        {
        PLINK_LIST                      pTmp;
        RTCP_COMMON_T           *pRTCPhdr;
        RTCP_RR_T                       *pRTCPrr;
        RECEIVER_RPT            *pRTCPrecvr;
        SENDER_RPT                      *pRTCPsr;
        DWORD                           numRcvRpt;
        DWORD                           numSrc;
        SOCKET                          sd;
        DWORD                           dwTotalRtpBW = 0;
        PDWORD                          pLastWord;
        SDES_DATA                       sdesBfr[MAX_NUM_SDES];
        PCHAR                           pData;
        unsigned short          pcktLen;
        int                                     weSent = FALSE;

#ifdef _DEBUG
        DWORD                           timeDiff;
#endif

#ifdef ENABLE_ISDM2
        // update ISDM
        if (Isdm2.hISDMdll && pSSRC->hISDM)
                updateISDMstat (pSSRC, &Isdm2, XMITR, TRUE);
#endif

        ASSERT (!pSSRC->dwNumXmtIoPending);     // should only have one pending send
        if (pSSRC->dwNumXmtIoPending)
                return FALSE;
                
        memset (sdesBfr, 0x00, sizeof(SDES_DATA) * MAX_NUM_SDES);

        // lock out access to the SSRC entry
        EnterCriticalSection (&pSSRC->critSect);


        // socket descriptor
        sd = pSSRC->RTCPsd;

        // RTCP common header
        pRTCPhdr = (RTCP_COMMON_T *)pRTCP->XmtBfr.buf;

        // RTP protocol version
        pRTCPhdr->type = RTP_TYPE;

        // reset the flag
        weSent = 0;

        // SR or RR ? Check our Xmt list entry to know if we've sent data
        if (pSSRC->xmtInfo.dwCurXmtSeqNum != pSSRC->xmtInfo.dwPrvXmtSeqNum)
                {
                // set flag for Bw calculation
                weSent = TRUE;

                // update packet count
                pSSRC->xmtInfo.dwPrvXmtSeqNum = pSSRC->xmtInfo.dwCurXmtSeqNum;

                // build SR
                RTCPbuildSenderRpt (pSSRC, pRTCPhdr, &pRTCPsr, sd);

                // set the receiver report pointer
                pData = (PCHAR)(pRTCPsr + 1);

                // adjust for the additional structure defined in the SENDER_RPT
                pData -= sizeof (RTCP_RR_T);

                pRTCPrr = (RTCP_RR_T *)pData;

#ifdef DYNAMIC_RTCP_BW
                // calculate the RTP bandwidth used by this transmitter
                dwTotalRtpBW = updateRtpXmtBW (pSSRC);
#endif
                }
        else
                {
                // payload type, RR
                pRTCPhdr->pt = RTCP_RR;

                // set the receiver report pointer
                pRTCPrecvr = (RECEIVER_RPT *)(pRTCPhdr + 1);

                // set our SSRC as the originator of this report
                RRCMws.htonl (sd, pSSRC->SSRC, &pRTCPrecvr->ssrc);

                pRTCPrr = pRTCPrecvr->rr;
                }

        // build receiver report list
        numRcvRpt = 0;
        numSrc    = 0;

        // go through the received SSRCs list
        pTmp = pRTCP->RcvSSRCList.prev;
        while (pTmp)
                {
                // increment the number of sources for later time-out calculation
                numSrc++;

                // check to see if this entry is an active sender
                if (((PSSRC_ENTRY)pTmp)->rcvInfo.dwNumPcktRcvd ==
                        ((PSSRC_ENTRY)pTmp)->rcvInfo.dwPrvNumPcktRcvd)
                        {
                        // not an active source, don't include it in the RR
                        pTmp = pTmp->next;
                                        
                        // next entry in SSRC list
                        continue;
                        }

                // build RR
                RTCPbuildReceiverRpt ((PSSRC_ENTRY)pTmp, pRTCPrr, sd);

#ifdef DYNAMIC_RTCP_BW
                // calculate the RTP bandwidth used by this remote stream
                dwTotalRtpBW += updateRtpRcvBW ((PSSRC_ENTRY)pTmp);
#endif

                // next entry in receiver report
                pRTCPrr++;

                // next entry in SSRC list
                pTmp = pTmp->next;

                if (++numRcvRpt >= MAX_RR_ENTRIES)
// !!! TODO !!!
// When over 31 sources, generate a second packet or go round robin
                        break;
                }

        // check to see if any Receiver Report. If not, still send an empty RR,
        // that will be followed by an SDES CNAME, for case like initialization
        // time, or when no stream received yet
        if ((numRcvRpt == 0) && (weSent == TRUE))
                {
                // adjust to the right place
                pRTCPrr = (RTCP_RR_T *)pData;
                }

        // report count
        pRTCPhdr->count = (WORD)numRcvRpt;

        // packet length for the previous SR/RR
        pcktLen = (unsigned short)((char *)pRTCPrr - pRTCP->XmtBfr.buf);
        RRCMws.htons (sd, (WORD)((pcktLen >> 2) - 1), &pRTCPhdr->length);

        // check which SDES needs to be send
        RTCPcheckSDEStoXmit (pSSRC, sdesBfr);

        // build the SDES information
        pLastWord = RTCPbuildSDES ((RTCP_COMMON_T *)pRTCPrr, pSSRC, sd,
                                                           pRTCP->XmtBfr.buf, sdesBfr);

        // calculate total RTCP packet length to xmit
        pRTCP->XmtBfr.len = (u_long)((char *)pLastWord - pRTCP->XmtBfr.buf);

        if ( ! (pSSRC->dwSSRCStatus & RTCP_XMT_USER_CTRL))
                {
#ifdef DYNAMIC_RTCP_BW
                // get 5% of the total RTP bandwidth
                dwTotalRtpBW = (dwTotalRtpBW * 5) / 100;

                // calculate the next interval based upon RTCP parameters
                if (dwTotalRtpBW < pSSRC->xmtInfo.dwRtcpStreamMinBW)
                        {
                        dwTotalRtpBW = pSSRC->xmtInfo.dwRtcpStreamMinBW;
                        }

#ifdef _DEBUG
                wsprintf(debug_string, "RTCP: RTCP BW (Bytes/sec) = %ld", dwTotalRtpBW);
                RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

#else
                dwTotalRtpBW = pSSRC->xmtInfo.dwRtcpStreamMinBW;
#endif

                pSSRC->dwNextReportSendTime = curTime + RTCPxmitInterval (numSrc + 1,
                                                                                numRcvRpt,
                                                                                dwTotalRtpBW,
                                                                                weSent,
                                                                                (int)(pRTCP->XmtBfr.len + NTWRK_HDR_SIZE),
                                                                                &pRTCP->avgRTCPpktSizeRcvd,
                                                                                0);
                }
        else
                {
                // user's control of the RTCP timeout interval
                if (pSSRC->dwUserXmtTimeoutCtrl != RTCP_XMT_OFF)
                        {
                        pSSRC->dwNextReportSendTime =
                                timeGetTime() + pSSRC->dwUserXmtTimeoutCtrl;
                        }
                else
                        {
                        pSSRC->dwNextReportSendTime = RTCP_XMT_OFF;
                        }
                }

#ifdef _DEBUG
        timeDiff = curTime - pSSRC->dwPrvTime;
        pSSRC->dwPrvTime = curTime;

        wsprintf(debug_string,
                         "RTCP: Sent report #%ld for SSRC x%lX after %5ld msec - (%s) w/ %d RR",
                         pSSRC->dwNumRptSent,
                         pSSRC->SSRC,
                         timeDiff,
                         (weSent==TRUE) ? "SR": "RR",
                         numRcvRpt);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
        // unlock pointer access
        LeaveCriticalSection (&pSSRC->critSect);        

        return TRUE;
        }



/*----------------------------------------------------------------------------
 * Function   : getSSRCpcktLoss
 * Description: Calculate the packet loss fraction and cumulative number.
 *
 * Input :      pSSRC:  -> to SSRC entry
 *                      update: Flag. Update the number received, or just calculate the
 *                                      number of packet lost w/o updating the counters.
 *
 *
 * Return: Fraction Lost: Number of packet lost (8:24)
 ---------------------------------------------------------------------------*/
 DWORD getSSRCpcktLoss (PSSRC_ENTRY pSSRC,
                                            DWORD update)
        {
        DWORD   expected;
        DWORD   expectedInterval;
        DWORD   rcvdInterval;
        int             lostInterval;
        DWORD   fraction;
        DWORD   cumLost;
        DWORD   dwTmp;

        IN_OUT_STR ("RTCP: Enter getSSRCpcktLoss()\n");

        // if nothing has been received, there is no loss
        if (pSSRC->rcvInfo.dwNumPcktRcvd == 0)
                {
                IN_OUT_STR ("RTCP: Exit getSSRCpcktLoss()\n");

                return 0;
                }

        // as per the RFC, but always one packet off when doing it ???
        expected = pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd -
                                pSSRC->rcvInfo.dwBaseRcvSeqNum + 1;

        cumLost = expected - pSSRC->rcvInfo.dwNumPcktRcvd;

        // 24 bits value
        cumLost &= 0x00FFFFFF;  

#if DBG_CUM_FRACT_LOSS
        wsprintf(debug_string, "RTCP : High Seq. #: %ld - Base: %ld",
                pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd,
                pSSRC->rcvInfo.dwBaseRcvSeqNum + 1);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

        wsprintf(debug_string, "RTCP : Expected: %ld - CumLost: %ld",
                                        expected,
                                        cumLost);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

        // Network byte order the lost number (will be or'ed with the fraction)
        RRCMws.htonl (pSSRC->RTPsd, cumLost, &dwTmp);
        cumLost = dwTmp;

        // fraction lost (per RFC)
        expectedInterval = expected - pSSRC->rcvInfo.dwExpectedPrior;
        rcvdInterval     =
                pSSRC->rcvInfo.dwNumPcktRcvd - pSSRC->rcvInfo.dwPrvNumPcktRcvd;

#if DBG_CUM_FRACT_LOSS
        wsprintf(debug_string, "RTCP : Exp. interval: %ld - Rcv interval: %ld",
                expectedInterval,
                rcvdInterval);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

        // check if need to update the data, or just calculate the loss
        if (update)
                {
                pSSRC->rcvInfo.dwExpectedPrior = expected;
                pSSRC->rcvInfo.dwPrvNumPcktRcvd = pSSRC->rcvInfo.dwNumPcktRcvd;
                }

        lostInterval = expectedInterval - rcvdInterval;

        if (expectedInterval == 0 || lostInterval <= 0)
                fraction = 0;
        else
                {
                fraction = (lostInterval << 8) / expectedInterval;

                // 8 bits value
                if (fraction > 0x000000FF)
                        // 100 % loss
                        fraction = 0x000000FF;

                fraction &= 0x000000FF;
                }

#if DBG_CUM_FRACT_LOSS
        wsprintf(debug_string, "RTCP : Lost interval: %ld - Fraction: %ld",
                                                lostInterval,
                                                fraction);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

        // get the 32 bits fraction/number
        cumLost |= fraction;

        IN_OUT_STR ("RTCP: Exit getSSRCpcktLoss()\n");

        return cumLost;
        }


/*----------------------------------------------------------------------------
 * Function   : RTCPcheckSDEStoXmit
 * Description: Check which SDES needs to be transmitted with this report.
 *                              SDES frequency varies for each type and is defined by the
 *                              application.
 *
 * Input :              pSSRC:          -> to the SSRC entry
 *                              pSdes:          -> to SDES buffer to initialize
 *
 * Return:              None
 ---------------------------------------------------------------------------*/
 void RTCPcheckSDEStoXmit (PSSRC_ENTRY pSSRC,
                                                   PSDES_DATA pSdes)
        {
        PSDES_DATA      pTmpSdes = pSdes;

        IN_OUT_STR ("RTCP: Enter RTCPcheckSDEStoXmit()\n");

        if (pSSRC->cnameInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->cnameInfo.dwSdesFrequency) == 0)
                        {
                        // CNAME
                        pTmpSdes->dwSdesType   = RTCP_SDES_CNAME;
                        pTmpSdes->dwSdesLength = pSSRC->cnameInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->cnameInfo.sdesBfr,
                                        pSSRC->cnameInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->nameInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->nameInfo.dwSdesFrequency) == 0)
                        {
                        // NAME
                        pTmpSdes->dwSdesType   = RTCP_SDES_NAME;
                        pTmpSdes->dwSdesLength = pSSRC->nameInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->nameInfo.sdesBfr,
                                        pSSRC->nameInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->emailInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->emailInfo.dwSdesFrequency) == 0)
                        {
                        // EMAIL
                        pTmpSdes->dwSdesType   = RTCP_SDES_EMAIL;
                        pTmpSdes->dwSdesLength = pSSRC->emailInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->emailInfo.sdesBfr,
                                        pSSRC->emailInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->phoneInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->phoneInfo.dwSdesFrequency) == 0)
                        {
                        // PHONE
                        pTmpSdes->dwSdesType   = RTCP_SDES_PHONE;
                        pTmpSdes->dwSdesLength = pSSRC->phoneInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->phoneInfo.sdesBfr,
                                        pSSRC->phoneInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->locInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->locInfo.dwSdesFrequency) == 0)
                        {
                        // LOCATION
                        pTmpSdes->dwSdesType   = RTCP_SDES_LOC;
                        pTmpSdes->dwSdesLength = pSSRC->locInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->locInfo.sdesBfr,
                                        pSSRC->locInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->toolInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->toolInfo.dwSdesFrequency) == 0)
                        {
                        // TOOL
                        pTmpSdes->dwSdesType   = RTCP_SDES_TOOL;
                        pTmpSdes->dwSdesLength = pSSRC->toolInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->toolInfo.sdesBfr,
                                        pSSRC->toolInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->txtInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->txtInfo.dwSdesFrequency) == 0)
                        {
                        // TEXT
                        pTmpSdes->dwSdesType   = RTCP_SDES_TXT;
                        pTmpSdes->dwSdesLength = pSSRC->txtInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->txtInfo.sdesBfr,
                                        pSSRC->txtInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->privInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->privInfo.dwSdesFrequency) == 0)
                        {
                        // PRIVATE
                        pTmpSdes->dwSdesType   = RTCP_SDES_PRIV;
                        pTmpSdes->dwSdesLength = pSSRC->privInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->privInfo.sdesBfr,
                                        pSSRC->privInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;
        pTmpSdes->dwSdesLength = 0;

        IN_OUT_STR ("RTCP: Exit RTCPcheckSDEStoXmit()\n");
        }


/*----------------------------------------------------------------------------
 * Function   : RTCPbuildSDES
 * Description: Build the SDES report
 *
 * Input :              pRTCPhdr:       -> to the RTCP packet header
 *                              pSSRC:          -> to the SSRC entry
 *                              sd:                     Socket descriptor
 *                              startAddr:      -> to the packet start address
 *                              pSdes:          -> to the SDES information to build
 *
 * Return:              pLastWord:      Address of the packet last Dword
 ---------------------------------------------------------------------------*/
 PDWORD RTCPbuildSDES (RTCP_COMMON_T *pRTCPhdr,
                                           PSSRC_ENTRY pSSRC,
                                           SOCKET sd,
                                           PCHAR startAddr,
                                           PSDES_DATA pSdes)
        {
        RTCP_SDES_T                     *pRTCPsdes;
        RTCP_SDES_ITEM_T        *pRTCPitem;
        int                                     pad = 0;
        PCHAR                           ptr;
        unsigned short          pcktLen;

        IN_OUT_STR ("RTCP: Enter RTCPbuildSDES()\n");

        // setup header
        pRTCPhdr->type  = RTP_TYPE;
        pRTCPhdr->pt    = RTCP_SDES;
        pRTCPhdr->p             = 0;
        pRTCPhdr->count = 1;

        // SDES specific header
        pRTCPsdes = (RTCP_SDES_T *)(pRTCPhdr + 1);

        // Get the SSRC
        RRCMws.htonl (sd, pSSRC->SSRC, &pRTCPsdes->src);

        // SDES item
        pRTCPitem = (RTCP_SDES_ITEM_T *)pRTCPsdes->item;

        while (pSdes->dwSdesLength)
                {
                // set SDES item characteristics
                pRTCPitem->dwSdesType   = (char)pSdes->dwSdesType;

                // make sure we don't go too far
                if (pSdes->dwSdesLength > MAX_SDES_LEN)
                        pSdes->dwSdesLength = MAX_SDES_LEN;

                pRTCPitem->dwSdesLength = (unsigned char)(pSdes->dwSdesLength);

                memcpy (pRTCPitem->sdesData, pSdes->sdesBfr, pSdes->dwSdesLength);

                // packet length
                pcktLen =
                        (unsigned short)((char *)(pRTCPitem->sdesData + pRTCPitem->dwSdesLength) - (char *)pRTCPsdes);

                pRTCPitem = (RTCP_SDES_ITEM_T *)((unsigned char *)pRTCPsdes + pcktLen);

                pSdes->dwSdesLength = 0; // setting this to zero will clear this entry

                // next SDES
                pSdes++;
                }

        // total SDES packet length
        pcktLen = (unsigned short)((char *)pRTCPitem - (char *)pRTCPhdr);

        // Zero the last word of the SDES item chunk, and padd to the
        // 32 bits boundary. If we landed exactly on the boundary then
        // have a whole null word to terminate the sdes, as is needed.
        pad = 4 - (pcktLen & 3);
        pcktLen += (unsigned short)pad;

        ptr = (PCHAR)pRTCPitem;
        while (pad--)
                *ptr++ = 0x00;

        // update packet length in header field
        RRCMws.htons (sd, (WORD)((pcktLen >> 2) - 1), &pRTCPhdr->length);

        IN_OUT_STR ("RTCP: Exit RTCPbuildSDES()\n");

        return ((PDWORD)ptr);
        }


/*----------------------------------------------------------------------------
 * Function   : RTCPbuildSenderRpt
 * Description: Build the RTCP Sender Report
 *
 * Input :              pSSRC:          -> to the SSRC entry
 *                              pRTCPhdr:       -> to the RTCP packet header
 *                              pRTCPsr:        -> to the Sender Report header
 *                              sd:                     Socket descriptor
 *
 * Return:              None
 ---------------------------------------------------------------------------*/
 void   RTCPbuildSenderRpt (PSSRC_ENTRY pSSRC,
                                                        RTCP_COMMON_T *pRTCPhdr,
                                                        SENDER_RPT      **pRTCPsr,
                                                        SOCKET  sd)
        {
        DWORD   dwTmp;
        DWORD   NTPtime;
        DWORD   RTPtime;
        DWORD   RTPtimeStamp = 0;

        IN_OUT_STR ("RTCP: Enter RTCPbuildSenderRpt()\n");

        // payload type, SR
        pRTCPhdr->pt = RTCP_SR;

        // padding
        pRTCPhdr->p      = 0;

        // sender report header
        *pRTCPsr = (SENDER_RPT *)(pRTCPhdr + 1);

        // fill in sender report packet
        RRCMws.htonl (sd, pSSRC->SSRC, &((*pRTCPsr)->ssrc));

        RRCMws.htonl (sd, pSSRC->xmtInfo.dwNumPcktSent, &((*pRTCPsr)->psent));

        RRCMws.htonl (sd, pSSRC->xmtInfo.dwNumBytesSent, &((*pRTCPsr)->osent));

        // NTP timestamp

        NTPtime = RTPtime = timeGetTime ();

        // get the number of seconds (integer calculation)
        dwTmp = NTPtime/1000;

        // NTP Msw
        RRCMws.htonl (sd, (NTPtime/1000), &((*pRTCPsr)->ntp_sec));

        // convert back dwTmp from second to millisecond
        dwTmp *= 1000;

        // get the remaining number of millisecond for the LSW
        NTPtime -= dwTmp;

        // NTP Lsw
        RRCMws.htonl (sd, usec2ntpFrac ((long)NTPtime*1000),
                                  &((*pRTCPsr)->ntp_frac));

        // calculate the RTP timestamp offset which correspond to this NTP
        // time and convert it to stream samples
        if (pSSRC->dwStreamClock)
                {
                RTPtimeStamp =
                        pSSRC->xmtInfo.dwLastSendRTPTimeStamp +
                         ((RTPtime - pSSRC->xmtInfo.dwLastSendRTPSystemTime) *
                          (pSSRC->dwStreamClock / 1000));
                }

        RRCMws.htonl (sd, RTPtimeStamp, &((*pRTCPsr)->rtp_ts));

        IN_OUT_STR ("RTCP: Exit RTCPbuildSenderRpt()\n");
        }


/*----------------------------------------------------------------------------
 * Function   : usec2ntp
 * Description: Convert microsecond to fraction of second for NTP
 *                              As per VIC.
 *                              Convert micro-second to fraction of second * 2^32. This
 *                              routine uses the factorization:
 *                              2^32/10^6 = 4096 + 256 - 1825/32
 *                              which results in a max conversion error of 3*10^-7 and an
 *                              average error of half that
 *
 * Input :              usec:   Micro second
 *
 * Return:              Fraction of second in NTP format
 ---------------------------------------------------------------------------*/
 DWORD usec2ntp (DWORD usec)
        {
        DWORD tmp = (usec * 1825) >>5;
        return ((usec << 12) + (usec << 8) - tmp);
        }


/*----------------------------------------------------------------------------
 * Function   : usec2ntpFrac
 * Description: Convert microsecond to fraction of second for NTP.
 *                              Just uses an array of microsecond and set the corresponding
 *                              bit.
 *
 * Input :              usec:   Micro second
 *
 * Return:              Fraction of second
 ---------------------------------------------------------------------------*/
 DWORD usec2ntpFrac (long usec)
        {
        DWORD   idx;
        DWORD   fraction = 0;
        DWORD   tmpFraction = 0;
        long    tmpVal;
        DWORD   shift;

        for (idx=0, shift=FRACTION_SHIFT_MAX-1;
                 idx < FRACTION_ENTRIES;
                 idx++, shift--)
                {
                tmpVal = usec;
                if ((tmpVal - microSecondFrac[idx]) > 0)
                        {
                        usec -= microSecondFrac[idx];
                        tmpFraction = (1 << shift);
                        fraction |= tmpFraction;
                        }
                else if ((tmpVal - microSecondFrac[idx]) == 0)
                        {
                        tmpFraction = (1 << shift);
                        fraction |= tmpFraction;
                        break;
                        }
                }

        return fraction;
        }


/*----------------------------------------------------------------------------
 * Function   : RTCPbuildReceiverRpt
 * Description: Build the RTCP Receiver Report
 *
 * Input :              pSSRC:          -> to the SSRC entry
 *                              pRTCPsr:        -> to the Receiver Report header
 *                              sd:                     Socket descriptor
 *
 * Return:              None
 ---------------------------------------------------------------------------*/
 void   RTCPbuildReceiverRpt (PSSRC_ENTRY pSSRC,
                                                          RTCP_RR_T     *pRTCPrr,
                                                          SOCKET        sd)
        {
        DWORD   dwDlsr;

        IN_OUT_STR ("RTCP: Enter RTCPbuildReceiverRpt()\n");

        // get the SSRC
        RRCMws.htonl (sd, pSSRC->SSRC, &pRTCPrr->ssrc);

        // get fraction and cumulative number of packet lost (per RFC)
        pRTCPrr->received = getSSRCpcktLoss (pSSRC, TRUE);

        // extended highest sequence number received
        RRCMws.htonl (sd,
                pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd,
                &pRTCPrr->expected);

        // interrarival jitter
#ifdef ENABLE_FLOATING_POINT
        RRCMws.htonl (sd, pSSRC->rcvInfo.interJitter, &pRTCPrr->jitter);
#else
        // Check RFC for details of the round off
        RRCMws.htonl (sd, (pSSRC->rcvInfo.interJitter >> 4), &pRTCPrr->jitter);
#endif

        // last SR
        RRCMws.htonl (sd, pSSRC->xmtInfo.dwLastSR, &pRTCPrr->lsr);

        // delay since last SR (only if an SR has been received from
        // this source, otherwise 0)
        if (pRTCPrr->lsr)
                {
                // get the DLSR
                dwDlsr = getDLSR (pSSRC);

                RRCMws.htonl (sd, dwDlsr, &pRTCPrr->dlsr);
                }
        else
                pRTCPrr->dlsr = 0;

        IN_OUT_STR ("RTCP: Exit RTCPbuildReceiverRpt()\n");
        }

/*----------------------------------------------------------------------------
 * Function   : getDLSR
 * Description: Get a DLSR packet
 *
 * Input :              pSSRC:          -> to the SSRC entry
 *
 * Return:              DLSR in seconds:fraction format
 ---------------------------------------------------------------------------*/
 DWORD getDLSR (PSSRC_ENTRY pSSRC)
        {
        DWORD   dwDlsr;
        DWORD   dwTime;
        DWORD   dwTmp;

        // DLSR in millisecond
        dwTime = timeGetTime() - pSSRC->xmtInfo.dwLastSRLocalTime;

        // get the number of seconds (integer calculation)
        dwTmp = dwTime/1000;

        // set the DLSR upper 16 bits (seconds)
        dwDlsr = dwTmp << 16;

        // convert back dwTmp from second to millisecond
        dwTmp *= 1000;

        // get the remaining number of millisecond for the LSW
        dwTime -= dwTmp;

        // convert microseconds to fraction of seconds
        dwTmp = usec2ntpFrac ((long)dwTime*1000);

        // get only the upper 16 bits
        dwTmp >>= 16;
        dwTmp &= 0x0000FFFF;

        // set the DLSR lower 16 bits (fraction of seconds)
        dwDlsr |= dwTmp;

        return dwDlsr;
        }


/*----------------------------------------------------------------------------
 * Function   : RTCPsendBYE
 * Description: Send an RTCP BYE packet
 *
 * Input :              pRTCP:          -> to the RTCP session
 *                              pSSRC:          -> to the SSRC entry
 *                              byeReason:      -> to the Bye reason, eg, "camera malfunction"...
 *
 * Return:              None
 ---------------------------------------------------------------------------*/
 void RTCPsendBYE (PSSRC_ENTRY pSSRC,
                                   PCHAR pByeReason)
        {
#define MAX_RTCP_BYE_SIZE 500           // ample
        PRTCP_SESSION           pRTCP;
        WSABUF                          wsaBuf;
        char                            buf[MAX_RTCP_BYE_SIZE];
        RTCP_COMMON_T           *pRTCPhdr;
        RTCP_RR_T                       *pRTCPrr;
        RECEIVER_RPT            *pRTCPrecvr;
        BYE_PCKT                        *pBye;
        DWORD                           *pLastWord;
        DWORD                           dwStatus;
        DWORD                           dwNumBytesXfr;
        DWORD                           offset;
        DWORD                           byeLen;
        unsigned short          pcktLen;
        PCHAR                           pBfr;

        IN_OUT_STR ("RTCP: Enter RTCPsendBYE()\n");

        // get the RTCP session
        pRTCP = pSSRC->pRTCPses;

        // check to see if under H.323 conference control. Don't send BYE in
        // this case
        if (pRTCP->dwSessionStatus & H323_CONFERENCE)
                return;

        // make sure the destination address is known
        if (!(pRTCP->dwSessionStatus & RTCP_DEST_LEARNED))
                {
                IN_OUT_STR ("RTCP: Exit RTCPsendBYE()\n");
                return;
                }




        // RTCP common header
        pRTCPhdr = (RTCP_COMMON_T *)buf;

        // RTP protocol version
        pRTCPhdr->type = RTP_TYPE;

        // empty RR
        pRTCPhdr->pt = RTCP_RR;

        // padding
        pRTCPhdr->p     = 0;

        // report count
        pRTCPhdr->count = 0;

        // set the receiver report pointer
        pRTCPrecvr = (RECEIVER_RPT *)(pRTCPhdr + 1);

        // get our SSRC
        RRCMws.htonl (pSSRC->RTCPsd, pSSRC->SSRC, &pRTCPrecvr->ssrc);

        // build receiver report list
        pRTCPrr = pRTCPrecvr->rr;

        // just adjust the size, sending 0 or garbagge doesn't matter, the
        // report count will tell the receiver what's valid
        pRTCPrr++;

        // packet length for the previous RR
        pcktLen = (unsigned short)((char *)pRTCPrr - buf);
        RRCMws.htons (pSSRC->RTCPsd, (WORD)((pcktLen >> 2) - 1), &pRTCPhdr->length);

        // BYE packet
        pRTCPhdr = (RTCP_COMMON_T *)pRTCPrr;
        pRTCPhdr->type  = RTP_TYPE;
        pRTCPhdr->pt    = RTCP_BYE;
        pRTCPhdr->count = 1;

        pBye = (BYE_PCKT *)pRTCPhdr + 1;
        RRCMws.htonl (pSSRC->RTCPsd, pSSRC->SSRC, pBye->src);

        pBye++;

        // send the reason
        pBfr = (PCHAR)pBye;
        if (pByeReason)
                byeLen = min (strlen(pByeReason), MAX_SDES_LEN);
        else
                byeLen = strlen ("Session Terminated");

        // Pre-zero the last word of the SDES item chunk, and padd to the
        // 32 bits boundary. Need to do this before the memcpy, If we
        // landed exactly on the boundary then this will give us a whole
        // null word to terminate the sdes, as is needed.
        offset    = (DWORD)((pBfr - buf) + byeLen);
        pLastWord = (unsigned long *)(buf + (offset & ~3));
        *pLastWord++ = 0;

        if (pByeReason)
                memcpy (pBfr+1, pByeReason, byeLen);
        else
                strcpy (pBfr+1, "Session Terminated");

        *pBfr = (unsigned char)byeLen;

        pcktLen = (unsigned short)((char *)pLastWord - (char *)pRTCPhdr);
        RRCMws.htons (pSSRC->RTCPsd, (WORD)((pcktLen >> 2) - 1), &pRTCPhdr->length);

        // calculate total RTCP packet length to xmit
        wsaBuf.len = (u_long)((char *)pLastWord - buf);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
        if (RTPLogger)
                {
                //INTEROP
                InteropOutput (RTPLogger,
                                           (BYTE FAR*)(buf),
                                           (int)wsaBuf.len,
                                           RTPLOG_SENT_PDU | RTCP_PDU);
                }
#endif

        // send the packet
        dwStatus = RRCMws.sendTo (pSSRC->RTCPsd,
                                                          &wsaBuf,
                                                          1,
                                                          &dwNumBytesXfr,
                                                          0,
                                                          (PSOCKADDR)pRTCP->toBfr,
                                                  pRTCP->toLen,
                                                          NULL,
                                                          NULL);



        IN_OUT_STR ("RTCP: Exit RTCPsendBYE()\n");
        }



/*----------------------------------------------------------------------------
 * Function   : updateRtpXmtBW
 * Description: Calculate a sending stream bandwidth during the last report
 *                              interval.
 *
 * Input :              pSSRC:          -> to the SSRC entry
 *
 * Return:              Bandwith used by transmitter in bytes/sec
 ---------------------------------------------------------------------------*/

#ifdef DYNAMIC_RTCP_BW

DWORD updateRtpXmtBW (PSSRC_ENTRY pSSRC)
        {
        DWORD   dwBW = 0;
        DWORD   dwTimeInterval;
        DWORD   dwByteInterval;
        DWORD   dwTimeNow = timeGetTime();

        IN_OUT_STR ("RTCP: Enter updateRtpXmtBW()\n");

        if (pSSRC->xmtInfo.dwLastTimeBwCalculated == 0)
                {
                pSSRC->xmtInfo.dwLastTimeBwCalculated = dwTimeNow;
                pSSRC->xmtInfo.dwLastTimeNumBytesSent = pSSRC->xmtInfo.dwNumBytesSent;
                pSSRC->xmtInfo.dwLastTimeNumPcktSent  = pSSRC->xmtInfo.dwNumPcktSent;
                }
        else
                {
                dwTimeInterval = dwTimeNow - pSSRC->xmtInfo.dwLastTimeBwCalculated;
                pSSRC->xmtInfo.dwLastTimeBwCalculated = dwTimeNow;

                // get the interval in second (we loose the fractional part)
                dwTimeInterval = dwTimeInterval / 1000;

                dwByteInterval =
                 pSSRC->xmtInfo.dwNumBytesSent - pSSRC->xmtInfo.dwLastTimeNumBytesSent;

                dwBW = dwByteInterval / dwTimeInterval;

                pSSRC->xmtInfo.dwLastTimeNumBytesSent = pSSRC->xmtInfo.dwNumBytesSent;
                pSSRC->xmtInfo.dwLastTimeNumPcktSent  = pSSRC->xmtInfo.dwNumPcktSent;
                }

        IN_OUT_STR ("RTCP: Exit updateRtpXmtBW()\n");

        return dwBW;
        }
#endif // #ifdef DYNAMIC_RTCP_BW


/*----------------------------------------------------------------------------
 * Function   : updateRtpRcvBW
 * Description: Calculate a remote stream RTP bandwidth during the last
 *                              report interval.
 *
 * Input :              pSSRC:          -> to the SSRC entry
 *
 * Return:              Bandwith used by the remote stream in bytes/sec
 ---------------------------------------------------------------------------*/

#ifdef DYNAMIC_RTCP_BW

DWORD updateRtpRcvBW (PSSRC_ENTRY pSSRC)
        {
        DWORD   dwBW = 0;
        DWORD   dwTimeInterval;
        DWORD   dwByteInterval;
        DWORD   dwTimeNow = timeGetTime();

        IN_OUT_STR ("RTCP: Enter updateRtpRcvBW()\n");

        if (pSSRC->rcvInfo.dwLastTimeBwCalculated == 0)
                {
                pSSRC->rcvInfo.dwLastTimeBwCalculated = dwTimeNow;
                pSSRC->rcvInfo.dwLastTimeNumBytesRcvd = pSSRC->rcvInfo.dwNumPcktRcvd;
                pSSRC->rcvInfo.dwLastTimeNumPcktRcvd  = pSSRC->rcvInfo.dwNumBytesRcvd;
                }
        else
                {
                dwTimeInterval = dwTimeNow - pSSRC->rcvInfo.dwLastTimeBwCalculated;
                pSSRC->rcvInfo.dwLastTimeBwCalculated = dwTimeNow;

                // get the interval in second (we loose the fractional part)
                dwTimeInterval = dwTimeInterval / 1000;

                dwByteInterval =
                 pSSRC->rcvInfo.dwNumBytesRcvd - pSSRC->rcvInfo.dwLastTimeNumBytesRcvd;

                dwBW = dwByteInterval / dwTimeInterval;

                pSSRC->rcvInfo.dwLastTimeNumBytesRcvd = pSSRC->rcvInfo.dwNumPcktRcvd;
                pSSRC->rcvInfo.dwLastTimeNumPcktRcvd  = pSSRC->rcvInfo.dwNumBytesRcvd;
                }

        IN_OUT_STR ("RTCP: Exit updateRtpXmtBW()\n");

        return dwBW;
        }
#endif // #ifdef DYNAMIC_RTCP_BW



// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtcp\rtcpsess.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPSESS.C
 * Product:     RTP/RTCP implementation
 * Description: Provides RTCP session management.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/

	
#include "rrcm.h"


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/




/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTCP_CONTEXT	pRTCPContext;
extern PRTP_CONTEXT		pRTPContext;
extern RRCM_WS			RRCMws;

#ifdef ENABLE_ISDM2
extern ISDM2			Isdm2;
#endif

#ifdef _DEBUG
extern char	debug_string[];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger     RTPLogger;
#endif





/*----------------------------------------------------------------------------
 * Function   : CreateRTCPSession
 * Description: Creates an RTCP session.
 *
 * Input :      RTPsd			: RTP socket descriptor
 *				RTCPsd			: RTCP socket descriptor
 *				lpTo			: To address
 *				toLen			: To address length
 *				pSdesInfo		: -> to SDES information
 *				dwStreamClock	: Stream clocking frequency
 *				pEncryptInfo	: -> to encryption information
 *				ssrc			: If set, user selected SSRC
 *				pSSRCcallback	: Callback for user's selected SSRC
 *				dwCallbackInfo	: User callback information
 *				miscInfo		: Miscelleanous information:
 *										H.323Conf:		0x00000002
 *										Encrypt SR/RR:	0x00000004
 *										RTCPon:			0x00000008
 *				dwRtpSessionBw	: RTP session bandwidth used for RTCP BW
 *				*pRTCPStatus	: -> to status information
 *
 * Return: 		NULL 		: Couldn't create RTCP session
 *         		!0  		: RTCP session's address
 ---------------------------------------------------------------------------*/
 PRTCP_SESSION CreateRTCPSession (SOCKET RTPsd,
								  SOCKET RTCPsd,
 						  		  LPVOID lpTo,
								  DWORD toLen,
								  PSDES_DATA pSdesInfo,
								  DWORD dwStreamClock,
								  PENCRYPT_INFO pEncryptInfo,
								  DWORD ssrc,
								  PRRCM_EVENT_CALLBACK pRRCMcallback,
								  DWORD_PTR dwCallbackInfo,
								  DWORD	miscInfo,
								  DWORD dwRtpSessionBw,
								  DWORD *pRTCPstatus)
	{
	PRTCP_SESSION		pRTCPses   = NULL;
	PSSRC_ENTRY			pSSRCentry = NULL;
	DWORD				dwStatus   = RRCM_NoError;
	DWORD				startRtcp  = FALSE;
	char				hName[256];
	int					tmpSize;
	struct sockaddr_in	*pSockAddr;

	IN_OUT_STR ("RTCP: Enter CreateRTCPSession()\n");

	// set status
	*pRTCPstatus = RRCM_NoError;

	// allocate all required resources for the RTCP session
	dwStatus = allocateRTCPsessionResources (&pRTCPses,
											 &pSSRCentry);
	if (dwStatus != RRCM_NoError)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation failed", 0,
					  __FILE__, __LINE__, DBG_CRITICAL);

		IN_OUT_STR ("RTCP: Exit CreateRTCPSession()\n");

		*pRTCPstatus = dwStatus;
		return (NULL);
		}

	// if this is the first session, create the RTCP thread, which
	// will be killed when no more sessions exist.
	if (pRTCPContext->RTCPSession.prev == NULL)
		{
		startRtcp = TRUE;
		}

	// save the parent RTCP session address in the SSRC entry
	pSSRCentry->pRTCPses = pRTCPses;

	// network destination address
	if (toLen)
		{
		pRTCPses->dwSessionStatus = RTCP_DEST_LEARNED;
		pRTCPses->toLen = toLen;
		memcpy (&pRTCPses->toBfr, lpTo, toLen);
		}
	
	// mark the session as new for the benefit of the RTCP thread
	pRTCPses->dwSessionStatus |= NEW_RTCP_SESSION;

#ifdef ENABLE_ISDM2
	// initialize the session key in case ISDM is used
	pRTCPses->hSessKey = NULL;
#endif

	// number of SSRC for this RTCP session
	pRTCPses->dwCurNumSSRCperSes = 1;
#ifdef MONITOR_STATS
	pRTCPses->dwHiNumSSRCperSes  = 1;
#endif

	// SSRC entry related information
    pSSRCentry->RTPsd  = RTPsd;
    pSSRCentry->RTCPsd = RTCPsd;

	// get our own transport address -
	// will be used for collision resolution when using multicast
	tmpSize = sizeof (SOCKADDR);
	dwStatus = RRCMws.getsockname (RTPsd, (PSOCKADDR)pSSRCentry->from, &tmpSize);

	// only process when no error is reported. If the socket is not bound
	// it won't cause any problem for unicast or multicast if the sender
	// has not join the mcast group. If the sender joins the mcast group
	// it's socket should be bound by now as specified in the EPS
	if (dwStatus == 0)
		{
		// if bound to INADDR_ANY, address will be 0
		pSockAddr = (PSOCKADDR_IN)&pSSRCentry->from;
		if (pSockAddr->sin_addr.s_addr == 0)
			{
			// get the host name (to get the local IP address)
			if ( ! RRCMws.gethostname (hName, sizeof(hName)))
				{
				LPHOSTENT	lpHEnt;

				// get the host by name infor
				if ((lpHEnt = RRCMws.gethostbyname (hName)) != NULL)
					{
					// get the local IP address
					pSockAddr->sin_addr.s_addr =
						*((u_long *)lpHEnt->h_addr_list[0]);
					}
				}
			}
		}

	// build session's SDES information
	buildSDESinfo (pSSRCentry, pSdesInfo);

	// link the SSRC to the RTCP session list of Xmt SSRCs entries
	addToHeadOfList (&(pRTCPses->XmtSSRCList),
					 (PLINK_LIST)pSSRCentry,
					 &pRTCPses->critSect);

	// initialize the number of stream for this session
    pRTCPses->dwNumStreamPerSes = 1;

	// get a unique SSRC for this session
	if (ssrc)
		pSSRCentry->SSRC = ssrc;
	else
		pSSRCentry->SSRC = getSSRC (pRTCPses->XmtSSRCList,
									pRTCPses->RcvSSRCList);

	// RRCM callback notification
	pRTCPses->pRRCMcallback		 = pRRCMcallback;
	pRTCPses->dwCallbackUserInfo = dwCallbackInfo;

	// set operation flag
	if (miscInfo & H323_CONFERENCE)
		pRTCPses->dwSessionStatus |= H323_CONFERENCE;
	if (miscInfo & ENCRYPT_SR_RR)
		pRTCPses->dwSessionStatus |= ENCRYPT_SR_RR;

	// estimate the initial session bandwidth
	if (dwRtpSessionBw == 0)
		{
		pSSRCentry->xmtInfo.dwRtcpStreamMinBW  = INITIAL_RTCP_BANDWIDTH;
		}
	else
		{
		// RTCP bandwidth is 5% of the RTP bandwidth
		pSSRCentry->xmtInfo.dwRtcpStreamMinBW  = (dwRtpSessionBw * 5) / 100;
		}

	// the stream clocking frequency
	pSSRCentry->dwStreamClock = dwStreamClock;

	// initialize 'dwLastReportRcvdTime' to now
	pSSRCentry->dwLastReportRcvdTime = timeGetTime();

#ifdef _DEBUG
	wsprintf(debug_string,
		"RTCP: Add new RTCP session: Addr:x%p", pRTCPses);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

	wsprintf(debug_string,
		"RTCP: Add SSRC entry (Addr:x%p, SSRC=x%lX) to session (Addr:x%p)",
		pSSRCentry, pSSRCentry->SSRC, pRTCPses);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

	pSSRCentry->dwPrvTime = timeGetTime();
#endif

	// turn on RTCP or not
	if (miscInfo & RTCP_ON)
		{
		// this session sends and receives RTCP reports
		pRTCPses->dwSessionStatus |= RTCP_ON;
		}

	// link the RTCP session to the head of the list of RTCP sessions
	addToHeadOfList (&(pRTCPContext->RTCPSession),
					 (PLINK_LIST)pRTCPses,
					 &pRTCPContext->critSect);

#ifdef ENABLE_ISDM2
	// register to ISDM only if destination address is known
	if (Isdm2.hISDMdll && (pRTCPses->dwSessionStatus & RTCP_DEST_LEARNED))
		registerSessionToISDM (pSSRCentry, pRTCPses, &Isdm2);
#endif

	// create the RTCP thread if needed
	if (startRtcp == TRUE)
		{
		// No RTCP thread if this fail
		dwStatus = CreateRTCPthread ();
		if (dwStatus != RRCM_NoError)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - Cannot create RTCP thread", 0,
						  __FILE__, __LINE__, DBG_CRITICAL);

			IN_OUT_STR ("RTCP: Exit CreateRTCPSession()\n");

			*pRTCPstatus = dwStatus;
			return (NULL);
			}
		}

	IN_OUT_STR ("RTCP: Exit CreateRTCPSession()\n");

	return (pRTCPses);
	}


/*----------------------------------------------------------------------------
 * Function   : allocateRTCPsessionResources
 * Description: Allocate all required resources for an RTCP session.
 *
 * Input :      *pRTCPses:		->(->) to the RTCP session's information
 *				*pSSRCentry:	->(->) to the SSRC's entry
 *
 * Return: 		OK: RRCM_NoError
 *         		!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD allocateRTCPsessionResources (PRTCP_SESSION *pRTCPses,
									 PSSRC_ENTRY *pSSRCentry)
	{
	DWORD dwStatus = RRCM_NoError;

	IN_OUT_STR ("RTCP: Enter allocateRTCPsessionResources()\n");

	// get an RTCP session
	*pRTCPses = (PRTCP_SESSION)HeapAlloc (pRTCPContext->hHeapRTCPSes,
										  HEAP_ZERO_MEMORY,
										  sizeof(RTCP_SESSION));
	if (*pRTCPses == NULL)
		dwStatus = RRCMError_RTCPResources;

	// 'defined' RTCP resources
	if (dwStatus == RRCM_NoError)
		{
		(*pRTCPses)->dwInitNumFreeRcvBfr = NUM_FREE_RCV_BFR;
		(*pRTCPses)->dwRcvBfrSize	  	 = pRTPContext->registry.RTCPrcvBfrSize;
		(*pRTCPses)->dwXmtBfrSize	  	 = RRCM_XMT_BFR_SIZE;

		// allocate the RTCP session's Rcv/Xmt heaps and Rcv/Xmt buffers
		dwStatus = allocateRTCPSessionHeaps (pRTCPses);
		}

	if (dwStatus == RRCM_NoError)
		{
		// initialize this session's critical section
		InitializeCriticalSection (&(*pRTCPses)->critSect);

		// allocate free list of RTCP receive buffers
		dwStatus = allocateRTCPBfrList (&(*pRTCPses)->RTCPrcvBfrList,
										(*pRTCPses)->hHeapRcvBfrList,
										(*pRTCPses)->hHeapRcvBfr,
										&(*pRTCPses)->dwInitNumFreeRcvBfr,
							 	 	    (*pRTCPses)->dwRcvBfrSize,
										&(*pRTCPses)->critSect);
		}

	if (dwStatus == RRCM_NoError)
		{
		(*pRTCPses)->XmtBfr.buf = (char *)LocalAlloc(0,(*pRTCPses)->dwXmtBfrSize);
		if ((*pRTCPses)->XmtBfr.buf == NULL)
			dwStatus = RRCMError_RTCPResources;
			
		}

	if (dwStatus == RRCM_NoError)
		{
		// get an SSRC entry
		*pSSRCentry = getOneSSRCentry (&pRTCPContext->RRCMFreeStat,
									   pRTCPContext->hHeapRRCMStat,
									   &pRTCPContext->dwInitNumFreeRRCMStat,
									   &pRTCPContext->critSect);
		if (*pSSRCentry == NULL)
			dwStatus = RRCMError_RTCPResources;
		}

	if (dwStatus == RRCM_NoError)
		{
		// manual-reset event that will be used to signal the end of the
		// RTCP session to all of the session's stream
		(*pRTCPses)->hShutdownDone = CreateEvent (NULL, TRUE, FALSE, NULL);

		if ((*pRTCPses)->hShutdownDone == NULL)
			{
			dwStatus = RRCMError_RTCPResources;

			RRCM_DBG_MSG ("RTCP: ERROR - CreateEvent()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}
	
	// any resource allocation problem ?
	if (dwStatus != RRCM_NoError)
		{
		if (*pSSRCentry)
			addToHeadOfList (&pRTCPContext->RRCMFreeStat,
							 (PLINK_LIST)*pSSRCentry,
							 &pRTCPContext->critSect);

		if ((*pSSRCentry)->hXmtThread)
			{
			if (TerminateThread ((*pSSRCentry)->hXmtThread,
								 (*pSSRCentry)->dwXmtThreadID) == FALSE)
				{
				RRCM_DBG_MSG ("RTCP: ERROR - TerminateThread()",
							  GetLastError(), __FILE__, __LINE__, DBG_ERROR);
				}
			}
	
		if (*pRTCPses)
			{
			if (HeapFree (pRTCPContext->hHeapRTCPSes, 0, *pRTCPses) == FALSE)
				{
				RRCM_DBG_MSG ("RTCP: ERROR - HeapFree()", GetLastError(),
							  __FILE__, __LINE__, DBG_ERROR);
				}
			}
		}

	IN_OUT_STR ("RTCP: Exit allocateRTCPsessionResources()\n");

	return dwStatus;
	}


/*----------------------------------------------------------------------------
 * Function   : buildSDESinfo
 * Description: Build the session's SDES information
 *
 * Input :      pRTCPses:	-> to session's
 *				pSdesInfo:	-> to SDES information
 *
 * Return: 		OK: RRCM_NoError
 *         		!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD buildSDESinfo (PSSRC_ENTRY pSSRCentry,
					  PSDES_DATA pSdesInfo)
	{
	PSDES_DATA	pTmpSdes;
	DWORD		CnameOK = FALSE;

	IN_OUT_STR ("RTCP: Enter buildSDESinfo()\n");

	pTmpSdes = pSdesInfo;

	while (pTmpSdes->dwSdesType)
		{
		switch (pTmpSdes->dwSdesType)
			{
			case RTCP_SDES_CNAME:
				pSSRCentry->cnameInfo.dwSdesLength = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->cnameInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->cnameInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->cnameInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;

				CnameOK = TRUE;
				break;

			case RTCP_SDES_NAME:
				pSSRCentry->nameInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->nameInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->nameInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->nameInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;

			case RTCP_SDES_EMAIL:
				pSSRCentry->emailInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->emailInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->emailInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->emailInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;
			
			case RTCP_SDES_PHONE:
				pSSRCentry->phoneInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->phoneInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->phoneInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->phoneInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;
			
			case RTCP_SDES_LOC:
				pSSRCentry->locInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->locInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->locInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->locInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;
			
			case RTCP_SDES_TOOL:
				pSSRCentry->toolInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->toolInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->toolInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->toolInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;
			
			case RTCP_SDES_TXT:
				pSSRCentry->txtInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->txtInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->txtInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->txtInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;
			
			case RTCP_SDES_PRIV:
				pSSRCentry->privInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->privInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->privInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->privInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;
			}

		pTmpSdes++;
		}

	// default CNAME if none provided
	if (CnameOK == FALSE)
		{
		pSSRCentry->cnameInfo.dwSdesLength = sizeof(szDfltCname);
		memcpy (pSSRCentry->cnameInfo.sdesBfr, szDfltCname,
				sizeof(szDfltCname));

		pSSRCentry->cnameInfo.dwSdesFrequency = 1;
		pSSRCentry->cnameInfo.dwSdesEncrypted = 0;
		}

	IN_OUT_STR ("RTCP: Exit buildSDESinfo()\n");
	return (RRCM_NoError);
	}


/*----------------------------------------------------------------------------
 * Function   : frequencyToPckt
 * Description: Transform the required frequency to a number of packet. (To
 *				be used by a modulo function)
 *
 * Input :      freq:	Desired frequency from 0 to 100
 *
 * Return: 		X: Packet to skip, ie, one out of X
 ---------------------------------------------------------------------------*/
 DWORD frequencyToPckt (DWORD freq)
	{
	if (freq <= 10)
		return 9;
	else if (freq <= 20)
		return 5;
	else if (freq <= 25)
		return 4;
	else if (freq <= 33)
		return 3;
	else if (freq <= 50)
		return 2;
	else
		return 1;
	}

	
/*----------------------------------------------------------------------------
 * Function   : deleteRTCPSession
 * Description: Closes an RTCP session.
 *
 * Input :      RTCPsd		: RTCP socket descriptor
 *				byeReason	: -> to the BYE reason
 *
 * Return: 		OK: RRCM_NoError
 *         		!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD deleteRTCPSession (SOCKET RTCPsd,
						  PCHAR byeReason)
	{
	PLINK_LIST		pTmp;
	PSSRC_ENTRY		pSSRC;
	PRTCP_SESSION	pRTCP;
	DWORD			dwStatus = RRCM_NoError;
	DWORD			sessionFound = FALSE;

	IN_OUT_STR ("RTCP: Enter deleteRTCPSEssion()\n");

	// walk through the list from the tail
	pTmp = pRTCPContext->RTCPSession.prev;

#ifdef _DEBUG
	wsprintf(debug_string,
		"RTCP: Deleting RTCP session: (Addr:x%p) ...", pTmp);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	while (pTmp)
		{
		// get the right session to close by walking the transmit list
		pSSRC = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->XmtSSRCList.prev;
		if (pSSRC->RTCPsd == RTCPsd)
			{
			sessionFound = TRUE;

			// save a pointer to the RTCP session
			pRTCP = pSSRC->pRTCPses;

			// RTCP send BYE packet for this active stream
			RTCPsendBYE (pSSRC, NULL);

			// flush out any outstanding I/O
			RTCPflushIO (pSSRC);

			// if this is the only RTCP session left, terminate the RTCP
			// timeout thread, so it doesn't access the session when it expires
			if ((pRTCPContext->RTCPSession.prev)->next == NULL)
				terminateRtcpThread ();

			// lock out access to this RTCP session
			EnterCriticalSection (&pRTCP->critSect);

			// free all Rcv & Xmt SSRC entries used by this session
			deleteSSRClist (pRTCP,
							&pRTCPContext->RRCMFreeStat,
							pRTCPContext);

#ifdef ENABLE_ISDM2
			if (Isdm2.hISDMdll && pRTCP->hSessKey)
				Isdm2.ISDMEntry.ISD_DeleteKey(pRTCP->hSessKey);
#endif

			// release the RTCP session's heap
			if (pRTCP->hHeapRcvBfrList)
				{
				if (HeapDestroy (pRTCP->hHeapRcvBfrList) == FALSE)
					{
					RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy()",
								  GetLastError(), __FILE__, __LINE__,
								  DBG_ERROR);
					}
				}

	
			if (pRTCP->hHeapRcvBfr)
				{
				if (HeapDestroy (pRTCP->hHeapRcvBfr) == FALSE)
					{
					RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy()",
								  GetLastError(), __FILE__, __LINE__,
								  DBG_ERROR);
					}
				}


			if (pRTCP->XmtBfr.buf)
				LocalFree(pRTCP->XmtBfr.buf);
			// remove the entry from the list of RTCP session
			if (pTmp->next == NULL)
				removePcktFromHead (&pRTCPContext->RTCPSession,
									&pRTCPContext->critSect);
			else if (pTmp->prev == NULL)
				removePcktFromTail (&pRTCPContext->RTCPSession,
									&pRTCPContext->critSect);
			else
				{
				// in between, relink around
				(pTmp->prev)->next = pTmp->next;
				(pTmp->next)->prev = pTmp->prev;
				}

			// release the critical section
			LeaveCriticalSection (&pRTCP->critSect);
			DeleteCriticalSection (&pRTCP->critSect);

			// put the RTCP session back on its heap
			if (HeapFree (pRTCPContext->hHeapRTCPSes,
						  0,
						  pRTCP) == FALSE)
				{
				RRCM_DBG_MSG ("RTCP: ERROR - HeapFree()",
							  GetLastError(), __FILE__, __LINE__,
							  DBG_ERROR);
				}

			break;
			}

		pTmp = pTmp->next;
		}	
		
	if (sessionFound != TRUE)
		dwStatus = RRCMError_RTCPInvalidSession;

	IN_OUT_STR ("RTCP: Exit deleteRTCPSEssion()\n");

	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : CreateRTCPthread
 * Description: Create the RTCP thread / timeout thread depending on
 *				compilation flag.
 *
 * Input :      None.
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
 DWORD CreateRTCPthread (void)
	{
	DWORD dwStatus = RRCM_NoError;

	IN_OUT_STR ("RTCP: Enter CreateRTCPthread()\n");

	pRTCPContext->hTerminateRtcpEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
	if (pRTCPContext->hTerminateRtcpEvent == NULL)
		{
		dwStatus = RRCMError_RTCPResources;

		RRCM_DBG_MSG ("RTCP: ERROR - CreateEvent()", GetLastError(),
					  __FILE__, __LINE__, DBG_ERROR);
		}

	pRTCPContext->hRtcpRptRequestEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
	if (pRTCPContext->hRtcpRptRequestEvent == NULL)
		{
		dwStatus = RRCMError_RTCPResources;

		RRCM_DBG_MSG ("RTCP: ERROR - CreateEvent()", GetLastError(),
					  __FILE__, __LINE__, DBG_ERROR);
		}

	if (pRTCPContext->hTerminateRtcpEvent)
		{
		// create RTCP thread
		pRTCPContext->hRtcpThread = CreateThread (
											NULL,
											0,
											(LPTHREAD_START_ROUTINE)RTCPThread,
											pRTCPContext,
											0,
											&pRTCPContext->dwRtcpThreadID);

		if (pRTCPContext->hRtcpThread == FALSE)
			{
			dwStatus = RRCMError_RTCPThreadCreation;

			RRCM_DBG_MSG ("RTCP: ERROR - CreateThread()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
#ifdef _DEBUG
		else
			{
			wsprintf(debug_string,
				"RTCP: Create RTCP thread. Handle: x%p - ID: x%lX",
				 pRTCPContext->hRtcpThread,
				 pRTCPContext->dwRtcpThreadID);
			RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
			}
#endif
		}

	IN_OUT_STR ("RTCP: Exit CreateRTCPthread()\n");

	return dwStatus;
	}


/*----------------------------------------------------------------------------
 * Function   : terminateRtcpThread
 * Description: Terminate the RTCP thread.
 *
 * Input :      None.
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
 void terminateRtcpThread (void)
	{
	DWORD dwStatus;

	IN_OUT_STR ("RTCP: Enter terminateRtcpThread()\n");

	if (pRTCPContext->hRtcpThread)
		{
		// make sure the RTCP thread is running
		RTCPThreadCtrl (RTCP_ON);

		// signal the thread to terminate
		SetEvent (pRTCPContext->hTerminateRtcpEvent);

		// wait for the RTCP thread to be signaled
		dwStatus = WaitForSingleObject (pRTCPContext->hRtcpThread, 500);
		if (dwStatus == WAIT_OBJECT_0)
			;
		else if ((dwStatus == WAIT_TIMEOUT) || (dwStatus == WAIT_FAILED))
			{
			if (dwStatus == WAIT_TIMEOUT)
				{
				RRCM_DBG_MSG ("RTCP: Wait timed-out", GetLastError(),
							  __FILE__, __LINE__, DBG_ERROR);
				}
			else
				{
				RRCM_DBG_MSG ("RTCP: Wait failed", GetLastError(),
							  __FILE__, __LINE__, DBG_ERROR);
				}

			// Force ungraceful thread termination
			dwStatus = TerminateThread (pRTCPContext->hRtcpThread, 1);
			if (dwStatus == FALSE)
				{
				RRCM_DBG_MSG ("RTCP: ERROR - TerminateThread ()",
								GetLastError(), __FILE__, __LINE__,
								DBG_ERROR);
				}
			}

		// close the thread handle
		dwStatus = CloseHandle (pRTCPContext->hRtcpThread);
		if (dwStatus == TRUE)			
			pRTCPContext->hRtcpThread = 0;
		else
			{
			RRCM_DBG_MSG ("RTCP: ERROR - CloseHandle()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}

		// close the event handle
		dwStatus = CloseHandle (pRTCPContext->hTerminateRtcpEvent);
		if (dwStatus == TRUE)
			pRTCPContext->hTerminateRtcpEvent = 0;
		else
			{
			RRCM_DBG_MSG ("RTCP: ERROR - CloseHandle()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}

		// close the request handle
		dwStatus = CloseHandle (pRTCPContext->hRtcpRptRequestEvent);
		if (dwStatus == TRUE)
			pRTCPContext->hRtcpRptRequestEvent = 0;
		else
			{
			RRCM_DBG_MSG ("RTCP: ERROR - CloseHandle()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	IN_OUT_STR ("RTCP: Exit terminateRtcpThread()\n");
	}


/*----------------------------------------------------------------------------
 * Function   : RTCPflushIO
 * Description: Flush the receive queue.
 *
 * Input :      pSSRC:	-> to the SSRC entry
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
 DWORD RTCPflushIO (PSSRC_ENTRY pSSRC)
	{
	DWORD	dwStatus = RRCM_NoError;
	int		IoToFlush;
	int		waitForXmtTrials;

	IN_OUT_STR ("RTCP: Enter RTCPflushIO()\n");

	// set the flush flag
	EnterCriticalSection (&pSSRC->pRTCPses->critSect);
	pSSRC->pRTCPses->dwSessionStatus |= SHUTDOWN_IN_PROGRESS;
	LeaveCriticalSection (&pSSRC->pRTCPses->critSect);

	// check if need to flush or close the socket
	if (pSSRC->dwSSRCStatus & CLOSE_RTCP_SOCKET)
		{
		// get the number of outstanding buffers
		IoToFlush = pSSRC->pRTCPses->dwNumRcvIoPending;
#ifdef _DEBUG
			wsprintf(debug_string,
					 "RTCPflushIO: closing socket(%d) dwNumRcvIoPending (%d)",
					 pSSRC->RTCPsd, pSSRC->pRTCPses->dwNumRcvIoPending);
			RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif					

		// make sure it's not < 0
		if (IoToFlush < 0)
			IoToFlush = pRTPContext->registry.NumRTCPPostedBfr;

		dwStatus = RRCMws.closesocket (pSSRC->RTCPsd);
		if (dwStatus != 0)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - closesocket ()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}
	else
		{
		IoToFlush = flushIO (pSSRC);
		}

	// wait for the receive side to flush it's pending I/Os
	if ((pSSRC->pRTCPses->dwSessionStatus & RTCP_ON) && IoToFlush)
		{
		// wait until the receiver signalled that the shutdown is done
		dwStatus = WaitForSingleObject (pSSRC->pRTCPses->hShutdownDone, 2000);
		if (dwStatus == WAIT_OBJECT_0)
			;
		else if (dwStatus == WAIT_TIMEOUT)
			{
			RRCM_DBG_MSG ("RTCP: Flush Wait timed-out", 0,
						  __FILE__, __LINE__, DBG_ERROR);
			}
		else if (dwStatus == WAIT_FAILED)
			{
			RRCM_DBG_MSG ("RTCP: Flush Wait failed", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	// make sure there is no buffers in transit on the transmit side
	waitForXmtTrials = 3;
	while (waitForXmtTrials--)
		{
		if (pSSRC->dwNumXmtIoPending == 0)
			break;

		RRCM_DBG_MSG ("RTCP: Xmt I/O Pending - Waiting",
						0, NULL, 0, DBG_TRACE);

		// wait in an alertable wait-state
		SleepEx (200, TRUE);
		}
	
	// close the shutdown handle
	dwStatus = CloseHandle (pSSRC->pRTCPses->hShutdownDone);
	if (dwStatus == TRUE)			
		 pSSRC->pRTCPses->hShutdownDone = 0;
	else
		{
		RRCM_DBG_MSG ("RTCP: ERROR - CloseHandle()", GetLastError(),
					  __FILE__, __LINE__, DBG_ERROR);
		}

	IN_OUT_STR ("RTCP: Exit RTCPflushIO()\n");

	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : flushIO
 * Description: Flush the receive queue.
 *
 * Input :      pSSRC:	-> to the SSRC entry
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
 DWORD flushIO (PSSRC_ENTRY pSSRC)
	{
	SOCKET			tSocket;
	SOCKADDR_IN		tAddr;
	char			msg[16];
	WSABUF			msgBuf;
	DWORD			BytesSent;
	int				tmpSize;
	DWORD			dwStatus = RRCM_NoError;
	int				outstanding;
	int				IoToFlush;
	RTCP_COMMON_T	*pRTCPhdr;

	IN_OUT_STR ("RTCP: Enter flushIO()\n");

	// target socket
	tSocket = pSSRC->RTCPsd;

	// RTCP common header
	pRTCPhdr = (RTCP_COMMON_T *)msg;

	// RTP protocol version
	pRTCPhdr->type = RTP_TYPE;
	pRTCPhdr->pt   = FLUSH_RTP_PAYLOAD_TYPE;

	msgBuf.len = sizeof(msg);
	msgBuf.buf = msg;

	// get the address of the socket we are cleaning up
	tmpSize = sizeof(tAddr);
	if (RRCMws.getsockname (tSocket, (PSOCKADDR)&tAddr, &tmpSize))
		{
		dwStatus = GetLastError();
		RRCM_DBG_MSG ("RTCP: ERROR -  getsockname()",
					  dwStatus, __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTP : Exit flushIO()\n");
		
        // (was: return dwStatus;)
        // Since this function is supposed to return number of pending I/O requests
        // to this socket, returning a non-zero error here is BOGUS!
        // Just return zero because if there is an error (socket has been freed)
        // then just say there's no i/o pending.
        return 0;
		}

	if (tAddr.sin_addr.s_addr == 0)
		{
		// send to the local address
		tAddr.sin_addr.S_un.S_un_b.s_b1 = 127;
		tAddr.sin_addr.S_un.S_un_b.s_b2 = 0;
		tAddr.sin_addr.S_un.S_un_b.s_b3 = 0;
		tAddr.sin_addr.S_un.S_un_b.s_b4 = 1;
		}

	// get the number of outstanding buffers
	outstanding = pSSRC->pRTCPses->dwNumRcvIoPending;

	// make sure it's not < 0
	if (outstanding < 0)
		outstanding = pRTPContext->registry.NumRTCPPostedBfr;

	// save number of pending I/Os
	IoToFlush = outstanding;

#if _DEBUG
	wsprintf(debug_string,
		 "RTCP: Flushing %d outstanding RCV buffers", outstanding);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// send datagrams to the RTCP socket
	while (outstanding--)
		{
#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
		if (RTPLogger)
			{
			//INTEROP
			InteropOutput (RTPLogger,
					       (BYTE FAR*)msgBuf.buf,
						   (int)msgBuf.len,
						   RTPLOG_SENT_PDU | RTCP_PDU);
			}
#endif

		dwStatus = RRCMws.sendTo (tSocket,
							      &msgBuf,
								  1,
								  &BytesSent,
								  0,
								  (SOCKADDR *)&tAddr,
								  sizeof(tAddr),
								  NULL,
#if 1
								  NULL);
#else
								  RTCPflushCallback);
#endif
		if (dwStatus == SOCKET_ERROR)
			{
			// If serious error, undo all our work
			dwStatus = GetLastError();

			if (dwStatus != WSA_IO_PENDING)
				{
				RRCM_DBG_MSG ("RTCP: ERROR - sendTo()", dwStatus,
							  __FILE__, __LINE__, DBG_ERROR);
				}
			}
		}

	IN_OUT_STR ("RTCP: Exit flushIO()\n");

	return IoToFlush;
	}



/*----------------------------------------------------------------------------
 * Function   : RTCPflushCallback
 * Description: Flush callback routine
 *
 * Input :	dwError:		I/O completion status
 *			cbTransferred:	Number of bytes received
 *			lpOverlapped:	-> to overlapped structure
 *			dwFlags:		Flags
 *
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void CALLBACK RTCPflushCallback (DWORD dwError,
           			  		     DWORD cbTransferred,
           			  		     LPWSAOVERLAPPED lpOverlapped,
           			  		     DWORD dwFlags)
	{
	IN_OUT_STR ("RTCP: Enter RTCPflushCallback\n");

	// check Winsock callback error status
	if (dwError)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Rcv Callback", dwError,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTCP: Exit RTCPflushCallback\n");
		return;
		}

	IN_OUT_STR ("RTCP: Exit RTCPflushCallback\n");
	}




// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtcp\rtcpssrc.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPSSRC.C
 * Product:     RTP/RTCP implementation
 * Description: Provides SSRC related function.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"
#include "md5.h"



/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/                                       
extern PRTCP_CONTEXT	pRTCPContext;

#ifdef ENABLE_ISDM2
extern KEY_HANDLE		hRRCMRootKey;
extern ISDM2			Isdm2;
#endif

#ifdef _DEBUG
extern char		debug_string[];
#endif
    


/*----------------------------------------------------------------------------
 * Function   : getOneSSRCentry
 * Description: Get an SSRC entry from the free list of entries.
 * 
 * Input :      pList		: -> to the list to get the entry from
 *				hHeap		: Handle to the heap where the data resides
 *				*pNum		: -> to the number of initial free entry in the list
 *				*pCritSect	: -> to the critical section
 *
 * Return: 		OK:		-> to SSRC entry
 *				Error:	NULL
 ---------------------------------------------------------------------------*/
PSSRC_ENTRY getOneSSRCentry (PLINK_LIST pList, 
							 HANDLE hHeap, 
							 DWORD *pNum,
							 CRITICAL_SECTION *pCritSect)
	{     
	PSSRC_ENTRY	pSSRC = NULL;

	IN_OUT_STR ("RTCP: Enter getOneSSRCentry()\n");

	// get an entry from the free list
	pSSRC = (PSSRC_ENTRY)removePcktFromHead (pList, pCritSect);
	if (pSSRC == NULL)
		{
		// try to reallocate some free cells
		if (allocateLinkedList (pList, hHeap, pNum, 
								sizeof(SSRC_ENTRY),
								pCritSect) == RRCM_NoError)
			{		 						
			// get a free cell if some have been reallocated
			pSSRC = (PSSRC_ENTRY)removePcktFromHead (pList, pCritSect);
			}
		}

	if (pSSRC)
		{
		clearSSRCEntry (pSSRC);

		// initialize the critical section
		InitializeCriticalSection(&pSSRC->critSect);
		}

	IN_OUT_STR ("RTCP: Exit getOneSSRCentry()\n");
		
	return (pSSRC);
	}		                                                                                                                                                            
	
                                                                                  
/*----------------------------------------------------------------------------
 * Function   : getSSRC
 * Description: Get a unique 32 bits SSRC
 * 
 * Input :      RcvSSRCList: Session's receive SSRC list address
 *				XmtSSRCList: Session's transmit SSRC list address
 *
 * Return:      Unique 32 bits SSRC
 ---------------------------------------------------------------------------*/
 DWORD getSSRC (LINK_LIST RcvSSRCList, 
				LINK_LIST XmtSSRCList)
	{               
	DWORD		SSRCnum = 0;
	DWORD		dwStatus;
	PSSRC_ENTRY	pSSRC;
	MD5_CTX		context;
	DWORD		i;
	union {
		unsigned char	c[16];
		DWORD			x[4];
		}digest;

	struct {
		DWORD		pid;
		DWORD		time;
		FILETIME	createTime;
		FILETIME	exitTime;
		FILETIME	kernelTime;
		FILETIME	userTime;
		} md5Input;

	IN_OUT_STR ("RTCP: Enter getSSRC()\n");

	// go through all SSRCs of this RTP/RTCP session
	while (SSRCnum == 0)
		{
		// get MD5 inputs
		md5Input.pid  = GetCurrentThreadId();
		md5Input.time = timeGetTime();

		dwStatus = GetProcessTimes (GetCurrentProcess(),
									&md5Input.createTime, 
									&md5Input.exitTime, 
									&md5Input.kernelTime, 
									&md5Input.userTime);
		if (dwStatus == FALSE)
			{
			RRCM_DBG_MSG ("RTCP: GetProcessTimes() failed", GetLastError(),
						  __FILE__, __LINE__, DBG_NOTIFY);
			}

		// Implementation suggested by draft 08, Appendix 6
		MD5Init (&context);
		MD5Update (&context, (unsigned char *)&md5Input, sizeof (md5Input));
        MD5Final (&context);
        CopyMemory( &digest, context.digest, MD5DIGESTLEN );
		SSRCnum = 0;
		for (i=0; i < 3; i++)
			SSRCnum ^= digest.x[i];

		// look through all transmitter for this session
		pSSRC = (PSSRC_ENTRY)XmtSSRCList.prev;
		if (isSSRCunique (pSSRC, &SSRCnum) == TRUE)
			{
			// look through all received SSRC for this session
			pSSRC = (PSSRC_ENTRY)RcvSSRCList.prev;
			isSSRCunique (pSSRC, &SSRCnum);
			}
		}

	IN_OUT_STR ("RTCP: Exit getSSRC()\n");

	return (SSRCnum);
	}


 /*----------------------------------------------------------------------------
 * Function   : getAnSSRC
 * Description: Build an SSRC according to the RFC, but does not check for 
 *				collision. Mainly used by H.323 to get a 32 bits number.
 * 
 * Input :      None
 *
 * Return:      32 bits SSRC
 ---------------------------------------------------------------------------*/
  DWORD WINAPI getAnSSRC (void)
	{               
	DWORD		SSRCnum = 0;
	DWORD		dwStatus;
	MD5_CTX		context;
	DWORD		i;
	union {
		unsigned char	c[16];
		DWORD			x[4];
		}digest;

	struct {
		DWORD		pid;
		DWORD		time;
		FILETIME	createTime;
		FILETIME	exitTime;
		FILETIME	kernelTime;
		FILETIME	userTime;
		} md5Input;

	IN_OUT_STR ("RTCP: Enter getAnSSRC()\n");

	// get MD5 inputs
	md5Input.pid  = GetCurrentThreadId();
	md5Input.time = timeGetTime();

	dwStatus = GetProcessTimes (GetCurrentProcess(),
								&md5Input.createTime, 
								&md5Input.exitTime, 
								&md5Input.kernelTime, 
								&md5Input.userTime);
	if (dwStatus == FALSE)
		{
		RRCM_DBG_MSG ("RTCP: GetProcessTimes() failed", GetLastError(),
					  __FILE__, __LINE__, DBG_NOTIFY);
		}

	// Implementation suggested by draft 08, Appendix 6
	MD5Init (&context);
	MD5Update (&context, (unsigned char *)&md5Input, sizeof (md5Input));
    MD5Final (&context);
    CopyMemory( &digest, context.digest, MD5DIGESTLEN );

    SSRCnum = 0;
	for (i=0; i < 3; i++)
		SSRCnum ^= digest.x[i];

	IN_OUT_STR ("RTCP: Exit getAnSSRC()\n");

	return (SSRCnum);
	}


/*----------------------------------------------------------------------------
 * Function   : isSSRCunique
 * Description: Check to see the SSRC already exist
 * 
 * Input :      pSSRC		:	-> to an SSRC list
 *				*SSRCnum	:	-> to the SSRC to check
 *
 * Return:      0: SSRC already exist
 *				1: SSRC is unique
 ---------------------------------------------------------------------------*/
 DWORD isSSRCunique (PSSRC_ENTRY pSSRC, 
					 DWORD *SSRCnum)
	{
	IN_OUT_STR ("RTCP: Enter isSSRCunique()\n");

	// make sure SSRC is unique for this session 
	while (pSSRC)
		{
		if (pSSRC->SSRC == *SSRCnum)
			{
			// SSRC already in use, get a new one 
			*SSRCnum = 0;
			return FALSE;
			}
					         
		// get next RTCP session 
		pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.next;
		}

	IN_OUT_STR ("RTCP: Exit isSSRCunique()\n");

	return TRUE;
	}                                                                                     
                                                                              
                                                                              
/*----------------------------------------------------------------------------
 * Function   : createSSRCEntry
 * Description: Create an SSRC entry, for a particular RTP/RTCP session
 * 
 * Input :      SSRCnum		: SSRC number
 *				pRTCP		: -> to the RTCP session
 *				fromAddr	: From address
 *				fromLen		: From length
 *				headOfList	: Put the new entry at the head of the list
 *
 * Return:      Address of the SSRC entry data structure.
 ---------------------------------------------------------------------------*/
 PSSRC_ENTRY createSSRCEntry (DWORD SSRCnum, 
							  PRTCP_SESSION pRTCP,
 							  PSOCKADDR fromAddr, 
							  DWORD fromLen, 
							  DWORD headOfList)
	{               
	PSSRC_ENTRY		pSSRCentry;
	PSSRC_ENTRY		pSSRCtmp;
	PLINK_LIST		pTmp;
	BOOL			entryAdded = FALSE;

	IN_OUT_STR ("RTCP: Enter createSSRCEntry()\n");

	// get an SSRC cell from the free list 
	pSSRCentry = getOneSSRCentry (&pRTCPContext->RRCMFreeStat, 
								  pRTCPContext->hHeapRRCMStat,
								  &pRTCPContext->dwInitNumFreeRRCMStat,
								  &pRTCPContext->critSect);
	if (pSSRCentry == NULL)
		return NULL;

	// save the remote source address
	if (saveNetworkAddress(pSSRCentry,
						   fromAddr,
						   fromLen) != RRCM_NoError)
		{
		addToHeadOfList (&pRTCPContext->RRCMFreeStat, 
						 (PLINK_LIST)pSSRCentry,
						 &pRTCPContext->critSect);
		return (NULL);
		}

	pSSRCentry->SSRC = SSRCnum;
	pSSRCentry->rcvInfo.dwProbation = MIN_SEQUENTIAL;

	// set this SSRC entry's RTCP session
	pSSRCentry->pRTCPses  = pRTCP;

	// initialize the socket descriptor
	pSSRCentry->RTPsd  = ((PSSRC_ENTRY)pRTCP->XmtSSRCList.prev)->RTPsd;
	pSSRCentry->RTCPsd = ((PSSRC_ENTRY)pRTCP->XmtSSRCList.prev)->RTCPsd;

	// initialize 'dwLastReportRcvdTime' to now
	pSSRCentry->dwLastReportRcvdTime = timeGetTime();

#ifdef _DEBUG
	wsprintf (debug_string, 
	  "RTCP: Create SSRC entry (Addr:x%p, SSRC=x%lX) for session: (Addr:x%p)",
	  pSSRCentry, pSSRCentry->SSRC, pRTCP);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

#ifdef ENABLE_ISDM2
	// register to ISDM
	if (Isdm2.hISDMdll && (pRTCP->dwSessionStatus & RTCP_DEST_LEARNED))
		registerSessionToISDM (pSSRCentry, pRTCP, &Isdm2);
#endif

	// check to see if it's our entry that needs to be put at the head of 
	//	the SSRC list. If it's not our entry, will find a place for it in the
	//	ordered list
	if (headOfList)
		{
		// Attach the SSRC to the RTCP session list entry head 
		addToHeadOfList (&pRTCP->XmtSSRCList, 
						 (PLINK_LIST)pSSRCentry,
						 &pRTCP->critSect);

		// number of SSRC entry for the RTCP session 
		InterlockedIncrement ((long *)&pRTCP->dwCurNumSSRCperSes);

#ifdef MONITOR_STATS
		// high number of SSRC entry for the RTCP session
		InterlockedIncrement ((long *)&pRTCP->dwHiNumSSRCperSes)
#endif

		return (pSSRCentry);
		}

	// put it on the receive list of SSRCs
	pTmp = (PLINK_LIST)pRTCP->RcvSSRCList.prev;

	// check if it's the first one
	if (pTmp == NULL)
		{
		// Attach the SSRC to the RTCP session list entry head 
		addToHeadOfList (&pRTCP->RcvSSRCList, 
						 (PLINK_LIST)pSSRCentry,
						 &pRTCP->critSect);

		// number of SSRC entry for the RTCP session 
		InterlockedIncrement ((long *)&pRTCP->dwCurNumSSRCperSes);

#ifdef MONITOR_STATS
		// high number of SSRC entry for the RTCP session 
		InterlockedIncrement ((long *)&pRTCP->dwHiNumSSRCperSes)
#endif

		return (pSSRCentry);
		}

	while (!entryAdded)
		{
		if (pTmp != NULL)
			{
			pSSRCtmp = (PSSRC_ENTRY)pTmp;
			if (pSSRCtmp->SSRC < SSRCnum)
				pTmp = pTmp->next;
			else
				{
				// lock at the RTCP session level, for head/tail ptrs access
				EnterCriticalSection (&pRTCP->critSect);

				if ((pTmp->next == NULL) && (pSSRCtmp->SSRC < SSRCnum))
					{
					// attach the SSRC to the RTCP session list entry head 
					// This SSRC is bigger than all other ones
					addToHeadOfList (&pRTCP->RcvSSRCList, 
									 (PLINK_LIST)pSSRCentry,
									 &pRTCP->critSect);
					}
				else if (pTmp->prev == NULL)
					{
					// attach the SSRC to the RTCP session list entry tail 
					// This SSRC is smaller than all other ones
					addToTailOfList (&pRTCP->RcvSSRCList, 
									 (PLINK_LIST)pSSRCentry,
									 &pRTCP->critSect);
					}
				else
					{				
					// this SSRC is in between other SSRCs
					EnterCriticalSection (&((PSSRC_ENTRY)pTmp->prev)->critSect);
					(pTmp->prev)->next = (PLINK_LIST)pSSRCentry;
					LeaveCriticalSection (&((PSSRC_ENTRY)pTmp->prev)->critSect);

					// don't need to lock out pSSRCentry pointers
					pSSRCentry->SSRCList.next = pTmp;
					pSSRCentry->SSRCList.prev = pTmp->prev;

					pTmp->prev = (PLINK_LIST)pSSRCentry;
					}

				// unlock RTCP session access 
				LeaveCriticalSection (&pRTCP->critSect);

				// set loop flag 
				entryAdded = TRUE;
				}
			}
		else
			{
			// attach the SSRC to the RTCP session list entry head 
			addToHeadOfList (&pRTCP->RcvSSRCList, 
							 (PLINK_LIST)pSSRCentry,
							 &pRTCP->critSect);

			// set loop flag 
			entryAdded = TRUE;
			}
		}

	// number of SSRC entry for the RTCP session 
	InterlockedIncrement ((long *)&pRTCP->dwCurNumSSRCperSes);

#ifdef MONITOR_STATS
	// high number of SSRC entry for the RTCP session 
	InterlockedIncrement ((long *)&pRTCP->dwHiNumSSRCperSes)
#endif

	IN_OUT_STR ("RTCP: Exit createSSRCEntry()\n");

	return (pSSRCentry);
	}
                                                                                                                                                            
                                                                              
                                                                              
/*----------------------------------------------------------------------------
 * Function   : deleteSSRCEntry
 * Description: Delete an SSRC entry (for a particular RTP/RTCP session).
 * 
 * Input :      SSRCnum		: SSRC number to delete from the list
 *				pRTCP		: -> to the RTCP session
 *
 * Return:      TRUE:	Deleted
 *				FALSE:	Entry not found
 ---------------------------------------------------------------------------*/
 DWORD deleteSSRCEntry (DWORD SSRCnum, 
						PRTCP_SESSION pRTCP)
	{               
	PSSRC_ENTRY	pSSRCtmp = NULL;
	PLINK_LIST	pTmp;
	DWORD		dwStatus = FALSE;

	IN_OUT_STR ("RTCP: Enter deleteSSRCEntry()\n");

	// walk through the list from the tail 
	pTmp = (PLINK_LIST)pRTCP->RcvSSRCList.prev;

	while (pTmp)
		{
		// lock access to this entry 
		EnterCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);

		if (((PSSRC_ENTRY)pTmp)->SSRC == SSRCnum)
			{
#ifdef _DEBUG
			wsprintf (debug_string, 
					  "RTCP: Delete SSRC=x%lX from session: (Addr:x%p)",
					  SSRCnum, pRTCP);
			RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

#ifdef ENABLE_ISDM2
			// unregister ISDM session
			if (Isdm2.hISDMdll && ((PSSRC_ENTRY)pTmp)->hISDM)
				Isdm2.ISDMEntry.ISD_DeleteValue(hRRCMRootKey, 
												((PSSRC_ENTRY)pTmp)->hISDM, NULL);
#endif

			// remove the entry from the list 
			if (pTmp->next == NULL)
				{
				removePcktFromHead (&pRTCP->RcvSSRCList,
									&pRTCP->critSect);
				}
			else if (pTmp->prev == NULL)
				{
				removePcktFromTail (&pRTCP->RcvSSRCList,
									&pRTCP->critSect);
				}
			else
				{
				// in between, relink around 
				EnterCriticalSection (&((PSSRC_ENTRY)pTmp->prev)->critSect);
				(pTmp->prev)->next = pTmp->next;
				LeaveCriticalSection (&((PSSRC_ENTRY)pTmp->prev)->critSect);

				EnterCriticalSection (&((PSSRC_ENTRY)pTmp->next)->critSect);
				(pTmp->next)->prev = pTmp->prev;
				LeaveCriticalSection (&((PSSRC_ENTRY)pTmp->next)->critSect);
				}

			// number of SSRC entry for the RTCP session 
			InterlockedDecrement ((long *)&pRTCP->dwCurNumSSRCperSes);

			// return entry to the free list 
			addToHeadOfList (&pRTCPContext->RRCMFreeStat, 
							 pTmp,
							 &pRTCPContext->critSect);

			// unlock access to this entry 
			LeaveCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);

			dwStatus = TRUE;
			break;
			}

		// unlock access to this entry 
		LeaveCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);

		pTmp = pTmp->next;
		}	

	IN_OUT_STR ("RTCP: Exit deleteSSRCEntry()\n");	

	return (dwStatus);
	}

 
/*----------------------------------------------------------------------------
 * Function   : deleteSSRClist
 * Description: Delete the SSRC list of an RTP/RTCP session.
 * 
 * Input :      pRTCP	  : -> to RTCP session
 *				pFreeList : -> to the free list of SSRCs
 *				pOwner	  : -> to the free list owner
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
 void deleteSSRClist (PRTCP_SESSION pRTCP, 
					  PLINK_LIST pFreeList, 
					  PRTCP_CONTEXT pOwner)
	{               
	PLINK_LIST	pSSRC;

	IN_OUT_STR ("RTCP: Enter deleteSSRClist()\n");

	ASSERT (pFreeList);
	ASSERT (pRTCP);

	// lock access to the full RTCP session 
	EnterCriticalSection (&pRTCP->critSect);

	// go through the list of transmit SSRCs for this RTCP session 
	while (pRTCP->XmtSSRCList.next != NULL)
		{
		// get packet from the list tail 
		pSSRC = removePcktFromTail ((PLINK_LIST)&pRTCP->XmtSSRCList,
									&pRTCP->critSect);
		if (pSSRC != NULL)
			{
#ifdef _DEBUG
			wsprintf(debug_string, 
					 "RTCP: Delete SSRC entry (x%lX) from session (x%p)",
					 ((PSSRC_ENTRY)pSSRC)->SSRC, pRTCP);
			RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif					

#ifdef ENABLE_ISDM2
			// unregister ISDM session
			if (Isdm2.hISDMdll && ((PSSRC_ENTRY)pSSRC)->hISDM)
				Isdm2.ISDMEntry.ISD_DeleteValue (hRRCMRootKey, 
										((PSSRC_ENTRY)pSSRC)->hISDM, NULL);
#endif

			// put it back to the free list 
			addToHeadOfList (pFreeList, pSSRC, &pOwner->critSect);

			// release the critical section
			DeleteCriticalSection (&((PSSRC_ENTRY)pSSRC)->critSect);
			}
		}

	// go through the list of SSRCs for this RTP/RTCP session 
	while (pRTCP->RcvSSRCList.next != NULL)
		{
		// get packet from the list tail 
		pSSRC = removePcktFromTail ((PLINK_LIST)&pRTCP->RcvSSRCList,
									&pRTCP->critSect);
		if (pSSRC != NULL)
			{
#ifdef _DEBUG
			wsprintf(debug_string, 
					 "RTCP: Delete SSRC entry (x%lX) from session (x%p)",
					 ((PSSRC_ENTRY)pSSRC)->SSRC, pRTCP);
			RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif					

#ifdef ENABLE_ISDM2
			// unregister ISDM session
			if (Isdm2.hISDMdll && ((PSSRC_ENTRY)pSSRC)->hISDM)
				Isdm2.ISDMEntry.ISD_DeleteValue (hRRCMRootKey, 
								((PSSRC_ENTRY)pSSRC)->hISDM, NULL);
#endif

			// put it back to the free list 
			addToHeadOfList (pFreeList, pSSRC, &pOwner->critSect);

			// release the critical section
			DeleteCriticalSection (&((PSSRC_ENTRY)pSSRC)->critSect);
			}
		}

	// unlock access to the full RTCP session 
	LeaveCriticalSection (&pRTCP->critSect);

	IN_OUT_STR ("RTCP: Exit deleteSSRClist()\n");				
	}


/*----------------------------------------------------------------------------
 * Function   : SSRCTimeoutCheck
 * Description: Check if an rcv SSRC needs to be timed out
 *				Since there may be multiple RCV SSRCs, repeat calling
 *				this function until it returns NULL
 * 
 * Input :      pRTCC	: -> to the RTCP session
 *				curTime	: Current time
 *
 * Return: 		NULL  : No action needed
 *				PSSRC : -> to the SSRC entry that should be deleted
 ---------------------------------------------------------------------------*/
PSSRC_ENTRY SSRCTimeoutCheck (PRTCP_SESSION pRTCP, DWORD curTime) 
	{
	PSSRC_ENTRY pSSRC;
	DWORD		tmpTime;

	// check the colliding entries table and clear it if needed
	RRCMTimeOutCollisionTable (pRTCP);

	// get the right session to close 
	pSSRC = (PSSRC_ENTRY)pRTCP->RcvSSRCList.prev;
	while (pSSRC)
		{
		// check if this SSRC timed-out
		tmpTime = curTime - pSSRC->dwLastReportRcvdTime;

		// get the time in minutes
		tmpTime /= (1000*60);
		if (tmpTime > RTCP_TIME_OUT_MINUTES)
			{
				break;
			}

		pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.next;
		}
	return pSSRC;
	}


/*---------------------------------------------------------------------------
 * Function   : RRCMChkCollisionTable
 * Description: Check the collision table to try to find a match 
 * 
 * Input :	pFrom		:	-> recv from address
 *			fromlen		:	-> recv from address length
 *			pSSRC		:	-> to the SSRC entry
 *
 * Return:	TRUE:	Match found
 *			FALSE:	No match found
 --------------------------------------------------------------------------*/
 DWORD RRCMChkCollisionTable (PSOCKADDR pFrom,
 							  UINT fromlen,
							  PSSRC_ENTRY pSSRC)
	{
	DWORD			idx;
	DWORD			dwStatus = FALSE;
	PRTCP_SESSION	pRTCP = pSSRC->pRTCPses;

	IN_OUT_STR ("RRCM: Enter RRCMChkCollisionTable()\n");		 	

	// entry w/ time == 0 are empty
	for (idx = 0; idx < NUM_COLLISION_ENTRIES; idx++)
		{
		if (pRTCP->collInfo[idx].dwCollideTime != 0)
			{
			if (memcmp (&pRTCP->collInfo[idx].collideAddr,
						pFrom, 
						fromlen) == 0)
				{
				// update the time of last collision received
				pRTCP->collInfo[idx].dwCollideTime = timeGetTime();

				dwStatus = TRUE;
				break;
				}
			}
		}

	IN_OUT_STR ("RRCM: Exit RRCMChkCollisionTable()\n");		 	

	return dwStatus;
	}


/*---------------------------------------------------------------------------
 * Function   : RRCMAddEntryToCollisionTable
 * Description: Add an entry into the collision table.
 * 
 * Input :	pFrom		:	-> recv from address
 *			fromlen		:	-> recv from address length
 *			pSSRC		:	-> to the SSRC entry
 *
 * Return:	TRUE:	Entry added
 *			FALSE:	Table full
 --------------------------------------------------------------------------*/
 DWORD RRCMAddEntryToCollisionTable (PSOCKADDR pFrom,
 									 UINT fromlen,
									 PSSRC_ENTRY pSSRC)
	{
	DWORD			idx;
	DWORD			dwStatus = FALSE;
	PRTCP_SESSION	pRTCP = pSSRC->pRTCPses;

	IN_OUT_STR ("RRCM: Enter RRCMAddEntryToCollisionTable()\n");
	
	// entry w/ time == 0 are empty
	for (idx = 0; idx < NUM_COLLISION_ENTRIES; idx++)
		{
		if (pRTCP->collInfo[idx].dwCollideTime == 0)
			{
			memcpy (&pRTCP->collInfo[idx].collideAddr,
					pFrom, 
					fromlen);

			pRTCP->collInfo[idx].addrLen = fromlen;
			pRTCP->collInfo[idx].dwCollideTime = timeGetTime();
			pRTCP->collInfo[idx].dwCurRecvRTCPrptNumber = pSSRC->dwNumRptRcvd;

			pRTCP->collInfo[idx].SSRC = pSSRC->SSRC;

			dwStatus = TRUE;
			break;
			}
		}

	
	IN_OUT_STR ("RRCM: Exit RRCMAddEntryToCollisionTable()\n");		 

	return dwStatus;
	}



/*---------------------------------------------------------------------------
 * Function   : RRCMTimeOutInCollisionTable
 * Description: Check if an entry in the collision table must be timed-out
 * 
 * Input :	pRTCP	:	-> to the RTCP session
 *
 * Return:	None
 --------------------------------------------------------------------------*/
 void RRCMTimeOutCollisionTable (PRTCP_SESSION pRTCP)
	{
	DWORD	idx;
	DWORD	currTime = timeGetTime();
	DWORD	diffTime;

	IN_OUT_STR ("RTCP: Enter RRCMTimeOutCollisionTable()\n");
	
	// entry w/ time == 0 are empty
	for (idx = 0; idx < NUM_COLLISION_ENTRIES; idx++)
		{
		// valid entries have the time set
		if (pRTCP->collInfo[idx].dwCollideTime)
			{
			// remove the entry from this table if 10 RTCP report intervals
			// have occured without a collision

			// clear the entry if over 5'
// !!! TODO !!!
// !!! using the right interval !!!
			diffTime = currTime - pRTCP->collInfo[idx].dwCollideTime;
			diffTime /= 1000;
			if (diffTime > 300)
				{
				pRTCP->collInfo[idx].dwCollideTime = 0;

				// the SSRC entry in the receive list will be deleted by
				// the timeout thread
				}
			}
		}

	IN_OUT_STR ("RTCP: Exit RRCMTimeOutCollisionTable()\n");		 
	}


/*----------------------------------------------------------------------------
 * Function   : clearSSRCEntry
 * Description: Clears what needs to be cleared in an SSRC entry
 * 
 * Input :      pSSRC		: -> to the SSRC entry
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
 void clearSSRCEntry (PSSRC_ENTRY pSSRC)
	{
	IN_OUT_STR ("RTCP: Enter clearSSRCEntry()\n");				

	memset (&pSSRC->xmtInfo, 0x00, sizeof(XMIT_INFO));
	memset (&pSSRC->rcvInfo, 0x00, sizeof(RECV_INFO));
	memset (&pSSRC->rrFeedback, 0x00, sizeof (RTCP_FEEDBACK));
	memset (&pSSRC->cnameInfo, 0x00, sizeof(SDES_DATA));
	memset (&pSSRC->nameInfo, 0x00, sizeof(SDES_DATA));
	memset (&pSSRC->from, 0x00, sizeof(SOCKADDR));

	pSSRC->SSRC					= 0;			
	pSSRC->dwSSRCStatus			= 0;
	pSSRC->dwStreamClock		= 0;
	pSSRC->fromLen				= 0;
	pSSRC->dwLastReportRcvdTime	= 0;
	pSSRC->dwUserXmtTimeoutCtrl = 0;
	pSSRC->RTPsd				= 0;
	pSSRC->RTCPsd				= 0;
	pSSRC->pRTCPses				= NULL;
	pSSRC->dwNumRptSent			= 0;
	pSSRC->dwNumRptRcvd			= 0;

#ifdef ENABLE_ISDM2
	pSSRC->hISDM				= 0;
#endif

#ifdef _DEBUG
	pSSRC->dwPrvTime			= 0;	
#endif

	IN_OUT_STR ("RTCP: Exit clearSSRCEntry()\n");				
	}

                                                                              
// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtcp\rtcpmem.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPMEM.C
 * Product:     RTP/RTCP implementation
 * Description: Provides memory operations functions for RTCP.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"                                    
                                       

/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/                                       
extern PRTP_CONTEXT	pRTPContext;
#ifdef _DEBUG
extern char		debug_string[];
#endif


/*----------------------------------------------------------------------------
 * Function   : allocateRTCPContextHeaps
 * Description: Allocates RTCP context heaps
 * 
 * Input :      pRTCPcntxt:	-> to the RTCP context information
 *
 * Return:		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD allocateRTCPContextHeaps (PRTCP_CONTEXT pRTCPcntxt)
	{
	IN_OUT_STR ("RTCP: Enter allocateRTCPContextHeaps()\n");

	pRTCPcntxt->hHeapRTCPSes = HeapCreate (
			0, 
			(pRTPContext->registry.NumSessions*sizeof(RTCP_SESSION)),
			0);
	if (pRTCPcntxt->hHeapRTCPSes == NULL)
		{
		IN_OUT_STR ("RTCP: Exit allocateRTCPContextHeaps()\n");
		return (RRCMError_RTCPResources);
		}

	pRTCPcntxt->hHeapRRCMStat = HeapCreate (
			0, 
			pRTCPcntxt->dwInitNumFreeRRCMStat*sizeof(SSRC_ENTRY), 
			0);
	if (pRTCPcntxt->hHeapRRCMStat == NULL)
		{
		IN_OUT_STR ("RTCP: Exit allocateRTCPContextHeaps()\n");
		return (RRCMError_RTCPResources);
		}

	IN_OUT_STR ("RTCP: Exit allocateRTCPContextHeaps()\n");
	return (RRCM_NoError);
	}

/*----------------------------------------------------------------------------
 * Function   : allocateRTCPSessionHeaps
 * Description: Allocates RTCP session heaps
 * 
 * Input :      *pRTCPses:		->(->) to the RTCP session's information
 *
 * Return:		OK: RRCM_NoError
 *				!0:	Erro code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD allocateRTCPSessionHeaps (PRTCP_SESSION *pRTCPses)
	{
	DWORD	heapSize;
	DWORD	dwStatus = RRCM_NoError;

	IN_OUT_STR ("RTCP: Enter allocateRTCPSessionHeaps()\n");

	heapSize = NUM_FREE_RCV_BFR*pRTPContext->registry.RTCPrcvBfrSize;
	(*pRTCPses)->hHeapRcvBfr = HeapCreate (0, 
										   heapSize, 
										   0);
	if ((*pRTCPses)->hHeapRcvBfr == NULL)
		dwStatus = RRCMError_RTCPResources;

	if (dwStatus == RRCM_NoError)
		{
		(*pRTCPses)->hHeapRcvBfrList = HeapCreate (0, 
												   RCV_BFR_LIST_HEAP_SIZE, 
												   0);
		if ((*pRTCPses)->hHeapRcvBfrList == NULL)
			dwStatus = RRCMError_RTCPResources;
		}

	if (dwStatus != RRCM_NoError)
		{
		// destroy allocated heaps
		if ((*pRTCPses)->hHeapRcvBfr)
			{
			HeapDestroy ((*pRTCPses)->hHeapRcvBfr);
			(*pRTCPses)->hHeapRcvBfr = NULL;
			}
		if ((*pRTCPses)->hHeapRcvBfrList)
			{
			HeapDestroy ((*pRTCPses)->hHeapRcvBfrList);
			(*pRTCPses)->hHeapRcvBfrList = NULL;
			}
		}

	IN_OUT_STR ("RTCP: Exit allocateRTCPSessionHeaps()\n");
	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : allocateRTCPBfrList
 * Description: Allocates link list of buffers for RTCP (xmit/rcv/...).
 * 
 * Input :      ptr:		-> to the link list to add buffer to
 *				hHeapList:	Handle to the heap list
 *				hHeapBfr:	Handle to the heap buffer
 *				*numBfr:	-> to the number of buffers to allocate
 *				bfrSize:	Individual buffer size
 *
 * Return:		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD allocateRTCPBfrList (PLINK_LIST ptr, 
							HANDLE hHeapList, 
							HANDLE hHeapBfr,
 							DWORD *numBfr, 
							DWORD bfrSize,
							CRITICAL_SECTION *pCritSect)
	{
	PRTCP_BFR_LIST	bfrPtr;
	PLINK_LIST		tmpPtr;
	
#ifdef IN_OUT_CHK
	OutputDebugString ("RTCP: Enter allocateRTCPBfrList()\n");
#endif

	ASSERT (ptr);
	ASSERT (hHeapList);
	ASSERT (hHeapBfr);

	// make sure at least one buffer is requested 
	if (*numBfr == 0)
		return (RRCMError_RTCPInvalidRequest);

	// allocate link list on the data structure's heap 
	if (allocateLinkedList (ptr, hHeapList, numBfr, 
							sizeof(RTCP_BFR_LIST), pCritSect))
		return (RRCMError_RTCPResources);

	// allocate buffer pool resources starting from the tail 
	tmpPtr = ptr->prev;
    while (tmpPtr != NULL)
    	{
		// points to buffer structure 
		bfrPtr = (PRTCP_BFR_LIST)tmpPtr;
		ASSERT (bfrPtr);

    	// initialize the WSABUF structure on its own heap 
    	bfrPtr->bfr.buf = (char *)HeapAlloc (hHeapBfr, 
											 HEAP_ZERO_MEMORY, 
											 bfrSize);
		if (bfrPtr->bfr.buf == NULL)
			{
			RRCM_DBG_MSG ("RTCP: Error - Cannot Allocate Xmt/Rcv Bfr", 
							0, __FILE__, __LINE__, DBG_ERROR);

// !!! TODO !!!

			// update head/tail pointers 

			// delete remaining cells until end of list 

			break;
			}

		// buffer length 
		bfrPtr->bfr.len = bfrSize;

		// buffer attributes 
		bfrPtr->dwBufferCount = 1;

		// new head pointer 
		tmpPtr = bfrPtr->bfrList.next;
    	}
    
#ifdef IN_OUT_CHK
	OutputDebugString ("RTCP: Exit allocateRTCPBfrList()\n");
#endif
	return (RRCM_NoError);
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtcp\rtcpthrd.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPIO.C
 * Product:     RTP/RTCP implementation
 * Description: Provides the RTCP network I/O.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/

#include "rrcm.h"



/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTCP_CONTEXT	pRTCPContext;
extern RRCM_WS			RRCMws;

#ifdef _DEBUG
extern char		debug_string[];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif



/*----------------------------------------------------------------------------
 * Function   : RTCPThread
 * Description: RTCP thread
 *
 * Input :      pRTCPctxt:	-> to RTCP context
 *
 * Return: 		None.
 ---------------------------------------------------------------------------*/
void RTCPThread (PRTCP_CONTEXT pRTCPctxt)
	{
	PSSRC_ENTRY			pSSRC;
	PSSRC_ENTRY			pRecvSSRC;
	PRTCP_SESSION		pRTCP;
	long				timerPeriod;
	long				minTimeInterval;
	long				prvTimeoutChkTime = 0;
	DWORD				initTime;
	long				deltaTime;
	int					dwStatus;
	DWORD				curTime;
	DWORD				dwNumBytesXfr;
	HANDLE				bfrHandle[2];
	DWORD				dwHandleCnt;

	RRCM_DBG_MSG ("RTCP: RTCP thread running ...", 0, NULL, 0, DBG_NOTIFY);

	// setup buffer Events
	bfrHandle[0] = pRTCPctxt->hTerminateRtcpEvent;
	bfrHandle[1] = pRTCPctxt->hRtcpRptRequestEvent;
	dwHandleCnt  = 2;

	// loop as long as there are sessions in the RTCP session list
	//
	while (1)
		{
		//LOOK: Claim global critical section?
		// walk through the RTCP session list from the tail and check which
		//  SSRC entry timed out if any
		curTime = timeGetTime();
		minTimeInterval = TIMEOUT_CHK_FREQ;		// 30 seconds

		for (pRTCP = (PRTCP_SESSION)pRTCPctxt->RTCPSession.prev;
			 pRTCP;
			 pRTCP = (PRTCP_SESSION)(pRTCP->RTCPList.next))
			{
			// if RTCP is disabled or shutdown is in progress, ignore
			// this session and move on.
			if (!(pRTCP->dwSessionStatus & RTCP_ON)
				|| (pRTCP->dwSessionStatus & SHUTDOWN_IN_PROGRESS))
				continue;
				
			// lock out access to this RTCP session
			EnterCriticalSection (&pRTCP->critSect);

			// NOTE: this assumes only one SSRC in the transmit list but
			// that assumption has been made elsewhere too
			pSSRC = (PSSRC_ENTRY)pRTCP->XmtSSRCList.prev;

			// if its a new session, post RECVs
			if (pRTCP->dwSessionStatus & NEW_RTCP_SESSION)
				{
				// post RTCP receive buffers
				dwStatus = RTCPrcvInit(pSSRC);
#ifdef _DEBUG
				if (dwStatus == FALSE)
					{
					RRCM_DBG_MSG ("RTCP: Couldn't initialize RTCP receive", 0,
								  __FILE__, __LINE__, DBG_TRACE);
					}
#endif
				// get initial transmit time
				timerPeriod = (long)RTCPxmitInterval (1, 0,
									  pSSRC->xmtInfo.dwRtcpStreamMinBW,
					 				  0, 100,
									  &pRTCP->avgRTCPpktSizeRcvd,
					 				  1);
					 				
				pSSRC->dwNextReportSendTime = curTime + timerPeriod;
				pRTCP->dwSessionStatus &= ~NEW_RTCP_SESSION;
				}

			// check if it has any expired SSRCs
			if ((curTime - prvTimeoutChkTime) > TIMEOUT_CHK_FREQ)
				{
				while (pRecvSSRC = SSRCTimeoutCheck (pRTCP, curTime))
					{
					// notify application if interested
					// NOTE: may be do this outside the loop?
					RRCMnotification (RRCM_TIMEOUT_EVENT, pRecvSSRC,
									  pRecvSSRC->SSRC, 0);

					// remove this entry from the list
					deleteSSRCEntry (pRecvSSRC->SSRC, pRTCP);
					}

				prvTimeoutChkTime = curTime;
				}
			
			if ( ! (pRTCP->dwSessionStatus & RTCP_DEST_LEARNED))
				{
				// cant send yet because we dont know who to
				// send to. Delay for 3 seconds
				pSSRC->dwNextReportSendTime = curTime + 3000;
				}

			//  if its time to send RTCP reports on this session
			//  then break out of the loop and send it  (cannot
			//  send with the global critsect held)
			//
			timerPeriod = (pSSRC->dwNextReportSendTime - curTime);
			if (timerPeriod <= RTCP_TIMEOUT_WITHIN_RANGE
				&& FormatRTCPReport(pRTCP, pSSRC, curTime))
				{
				// increment Xmt count in anticipation. This will prevent
				// the session from being deleted while the send is in progress.
				InterlockedIncrement ((long *)&pSSRC->dwNumXmtIoPending);
				InterlockedIncrement ((long *)&pSSRC->dwNumRptSent);
					
				LeaveCriticalSection(&pRTCP->critSect);
				break;
				}

			// if not then check how long before the next scheduled
			// transmission and save the minimum. We will sleep
			// for this much time and then start again.
			if (minTimeInterval > timerPeriod)
				minTimeInterval = timerPeriod;

			LeaveCriticalSection(&pRTCP->critSect);
			}
			
		if (pRTCP)
			{
			
			
#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
			if (RTPLogger)
				{
			   //INTEROP
				InteropOutput (RTPLogger,
							   (BYTE FAR*)(pRTCP->XmtBfr.buf),
							   (int)pRTCP->XmtBfr.len,
							   RTPLOG_SENT_PDU | RTCP_PDU);
				}
#endif

			// send the RTCP packet
			dwStatus = RRCMws.sendTo (pSSRC->RTCPsd,
				   					  &pRTCP->XmtBfr,
									  1,
					   				  &dwNumBytesXfr,
					   				  0,
				   					  (PSOCKADDR)pRTCP->toBfr,
				    				  pRTCP->toLen,
				   					  NULL,
					   				  NULL);

			// check SendTo status
			if (dwStatus == SOCKET_ERROR)
				{
				RRCM_DBG_MSG ("RTCP: ERROR - WSASendTo()", dwStatus,
							  __FILE__, __LINE__, DBG_ERROR);


                //If dwStatus is WSAENOTSOCK (or worse, a fault)
                //We're likely shutting down, and the RTCP session
                //is going away, don't touch it and let the normal
                //shutdown code take over
                if (dwStatus != WSAENOTSOCK && dwStatus != WSAEFAULT) {

                    // notify application if interested
                    RRCMnotification (RRCM_RTCP_WS_XMT_ERROR, pSSRC,
								  pSSRC->SSRC, dwStatus);

					InterlockedDecrement ((long *)&pSSRC->dwNumRptSent);
                }

				}
			InterlockedDecrement ((long *)&pSSRC->dwNumXmtIoPending);

			// run through the session list again
			continue;
			}

		// grab an initial timestamp so we can reset WaitForSingleObjectEx
		initTime = timeGetTime();

		// now we've gone through all the RTCP sessions and
		// verified that none have pending reports to be sent
		// We also know the earliest scheduled timeout so
		// lets sleep till then.
		while (1)
			{
				dwStatus = WaitForMultipleObjectsEx (dwHandleCnt,
													bfrHandle,
													FALSE,
												    (DWORD)minTimeInterval,
												    TRUE);
			if (dwStatus == WAIT_OBJECT_0)
				{
				// Exit event was signalled
#ifdef _DEBUG
				wsprintf(debug_string,
					"RTCP: Exit RTCP thread - Handle: x%p - ID: x%lX",
					 pRTCPctxt->hRtcpThread, pRTCPctxt->dwRtcpThreadID);
				RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

				ExitThread (0);
				}
			else if (dwStatus == WAIT_OBJECT_0+1)
				{
				// the application requested a non-periodic control
				//   of the RTCP report frequency
				break;
				}
			else if (dwStatus == WAIT_IO_COMPLETION)
				{
				// decrement the timerPeriod so the WaitForSingleObjectEx
				// can continue but if we're less than 250 milliseconds from
				// the original timeout go ahead and call it close enough.
				curTime = timeGetTime();
				deltaTime = curTime - initTime;
				if (deltaTime < 0)
					break;
				else
					{
					if (minTimeInterval >
						  (deltaTime + (RTCP_TIMEOUT_WITHIN_RANGE * 2)))
						{
						minTimeInterval -= deltaTime;
						}
					else
						break;
					}
				}
			else if (dwStatus == WAIT_TIMEOUT)
				{
				// the expected completion status
				break;
				}
			else if (dwStatus == WAIT_FAILED)
				{
				RRCM_DBG_MSG ("RTCP: Wait() Error", GetLastError(),
							  __FILE__, __LINE__, DBG_ERROR);

				break;
				}
			}
		}
	}


/*----------------------------------------------------------------------------
 * Function   : RTCPThreadCtrl
 * Description: RTCP thread ON / OFF
 *
 * Input :      dwState:	ON / OFF
 *
 * Return: 		0 (success) / 0xFFFFFFFF (failure)
 ---------------------------------------------------------------------------*/
DWORD WINAPI RTCPThreadCtrl (DWORD dwState)
	{
	IN_OUT_STR ("RTCP : Enter RTCPThreadCtrl()\n");

	DWORD	dwStatus = RRCM_NoError;
	DWORD	dwSuspendCnt;
	DWORD	idx;

	if (pRTCPContext->hRtcpThread == 0)
		{
		IN_OUT_STR ("RTCP : Exit RTCPThreadCtrl()\n");

		return dwStatus;
		}

	if (dwState == RTCP_ON)
		{
		idx = MAXIMUM_SUSPEND_COUNT;

		while (idx--)
			{
			dwSuspendCnt = ResumeThread (pRTCPContext->hRtcpThread);

			if (dwSuspendCnt <= 1)
				{
				break;
				}
			else if (dwSuspendCnt == 0xFFFFFFFF)
				{
				dwStatus = RRCM_NoError;
				break;
				}
			}
		}
	else if (dwState == RTCP_OFF)
		{
		if (SuspendThread (pRTCPContext->hRtcpThread) == 0xFFFFFFFF)
			{
			RRCM_DBG_MSG ("RTCP: SuspendThread() Error", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	IN_OUT_STR ("RTCP : Exit RTCPThreadCtrl()\n");

	return dwStatus;
	}


/*----------------------------------------------------------------------------
 * Function   : RTCPSendSessionCtrl
 * Description: Gives RTCP control to the application if the application
 *				desire to do so. The application is now responsible to comply
 *				with the RTP specification.
 *
 * Input :      hRtpSession:	Handle of the RTP session
 *				dwTimeout:		RTCP send message timeout
 *										0x0			-> RRCM control
 *										0x7FFFFFFF	-> RTCP xmt disabled
 *										value		-> selected timeout
 *														(periodic or not)
 *
 * Return: 		0 (success) / 0xFFFFFFFF (failure)
 ---------------------------------------------------------------------------*/
HRESULT WINAPI RTCPSendSessionCtrl (DWORD_PTR RTPSession,
									 DWORD dwTimeOut)
	{
	IN_OUT_STR ("RTCP : Enter RTCPSendSessionCtrl()\n");

	PRTP_SESSION    pSession;
	PSSRC_ENTRY		pSSRC;
	DWORD			dwStatus = RRCM_NoError;

	// Cast Session ID to obtain the session pointer.
	pSession = (PRTP_SESSION)RTPSession;
	if (pSession == NULL)
		{
		RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTP : Exit RTCPSendSessionCtrl()\n");

		return (MAKE_RRCM_ERROR (RRCMError_RTPSessResources));
		}

	// Get this RTP session's transmit SSRC
	pSSRC = (PSSRC_ENTRY)pSession->pRTCPSession->XmtSSRCList.prev;
	if (pSSRC == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - No SSRC entry on the Xmt list", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTCP : Exit RTCPSendSessionCtrl()\n");

		return (MAKE_RRCM_ERROR (RRCMError_RTCPInvalidSSRCentry));
		}

	// set the new RTCP control timeout value
	if (dwTimeOut == RRCM_CTRL_RTCP)
		pSSRC->dwSSRCStatus &= ~RTCP_XMT_USER_CTRL;
	else if (dwTimeOut & RTCP_ONE_SEND_ONLY)
		{
		pSSRC->dwNextReportSendTime = RTCP_TIMEOUT_WITHIN_RANGE;

		// report are then turned off
		pSSRC->dwUserXmtTimeoutCtrl = RTCP_XMT_OFF;

		// signal the thread to terminate
		SetEvent (pRTCPContext->hRtcpRptRequestEvent);
		}
	else
		{
		if (dwTimeOut < RTCP_XMT_MINTIME)
			dwTimeOut = RTCP_XMT_MINTIME;

		pSSRC->dwUserXmtTimeoutCtrl = dwTimeOut;

		pSSRC->dwSSRCStatus |= RTCP_XMT_USER_CTRL;
		}

	IN_OUT_STR ("RTCP : Exit RTCPSendSessionCtrl()\n");

	return dwStatus;
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\queue.h ===
// generic queue class
// usage: 
// QueueOf<char *> charq;

#ifndef _QUEUE_H_
#define _QUEUE_H_

template <class T>
class QueueOf
{
public:
	QueueOf(): m_maxItems(8),m_iFirst(0),m_iLast(0)
	{
		// m_maxItems  is always a power of 2
		m_List = new T [m_maxItems];
	}

	// returns TRUE if the queue is empty and FALSE otherwise
	BOOL IsEmpty(void) { return (m_iLast == m_iFirst);}

	// add an element to the tail of the queue
	// makes a copy of the element
	BOOL Put(const T &itemT)
	{
		int inext;
		inext = (m_iLast+1)&(m_maxItems-1);
	
		if (inext == m_iFirst)
		{
			// too many items
			if (!Grow())
			{	

				return FALSE;
			}
			inext = (m_iLast+1)&(m_maxItems-1);
		}

		m_List[m_iLast] =  itemT;
		m_iLast = inext;

		return TRUE;
	}

	// get the first element in the queue
	BOOL Get(T *pT)
	{
		if (IsEmpty())
			return FALSE;	// nothing in queue
		else
		{
			if (pT)
				*pT = m_List[m_iFirst];
			m_iFirst = (m_iFirst+1)&(m_maxItems-1);
			return TRUE;
		}
	}
	// get the ith element in the queue without removing it
	BOOL Peek(T *pT, UINT pos=0)
	{
		if (pos >= GetCount())
			return FALSE;
		else
		{
			*pT = m_List[(m_iFirst+pos)&(m_maxItems-1)];
			return TRUE;
		}
	}

	// delete the ith element in the queue (this is not an efficient function!)
	BOOL Remove(UINT pos)
	{
		if (pos >= GetCount())
			return FALSE;
		else
		{
			int i1 = (m_iFirst+(int)pos)&(m_maxItems-1);
			int i2 = (i1+1)&(m_maxItems-1);
			// shift left to fill the gap
			for (; i2 != m_iLast; i1=i2,i2=(i2+1)&(m_maxItems-1))
			{
				m_List[i1] = m_List[i2];
			}
			m_iLast = i1;	// i1 = m_iLast-1
			return TRUE;
		}
			
	}
	
	// return the number of elements in the queue
	UINT GetCount(void)
	{
		return (m_iLast >= m_iFirst ? m_iLast-m_iFirst : m_iLast+m_maxItems-m_iFirst);
	}
	~QueueOf()
	{
		delete []m_List;
	}
private:
	BOOL Grow(void)
	{
		int i,j;
	// double the size of the queue array
		T* pNewList = new T [m_maxItems*2];
		if (!pNewList)
			return FALSE;
		for (i=0, j=m_iFirst; j != m_iLast; i++, j = ((++j)&(m_maxItems-1)))
		{
			pNewList[i] = m_List[j];
		}
		m_iFirst = 0;
		m_iLast = i;
		m_maxItems = m_maxItems*2;
		delete [] m_List;
		m_List = pNewList;
		return TRUE;
	}
	int m_maxItems;
	int m_iFirst;
	int m_iLast;
	T *m_List;
};
;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rrcmver.rc
//
#define V_FILEFLAGS                     0

#define IDR_RTP                         101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\rrcmmain.cpp ===
//---------------------------------------------------------------------------
//  File:  RRCMMAIN.C
//
//  This file contains the DLL's entry and exit points.
//
// INTEL Corporation Proprietary Information
// This listing is supplied under the terms of a license agreement with 
// Intel Corporation and may not be copied nor disclosed except in 
// accordance with the terms of that agreement.
// Copyright (c) 1995 Intel Corporation. 
//---------------------------------------------------------------------------

#ifndef STRICT
#define STRICT
#endif
#include "stdafx.h"
#include "windows.h"
#include <confdbg.h>
#include <memtrack.h>
// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f mpps.mk in the project directory.

#include "resource.h"
#include "initguid.h"
#include "irtp.h"

#include "irtp_i.c"
//#include <cmmstrm.h>
#include "RTPSess.h"
#include "thread.h"



CComModule _Module;
CRITICAL_SECTION g_CritSect;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_RTP, CRTP)
END_OBJECT_MAP()

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
#include "interop.h"
#include "rtpplog.h"
#endif

#ifdef ISRDBG
#include "isrg.h"
WORD    ghISRInst = 0;
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
LPInteropLogger            RTPLogger;
#endif


#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

extern DWORD deleteRTP (HINSTANCE);
extern DWORD initRTP (HINSTANCE);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#ifdef _DEBUG
HDBGZONE  ghDbgZoneRRCM = NULL;
static PTCHAR _rgZones[] = {
	TEXT("RRCM"),
	TEXT("Trace"),
	TEXT("Error"),
};

#endif /* DEBUG */


//---------------------------------------------------------------------------
// Function: dllmain
//
// Description: DLL entry/exit points.
//
//	Inputs:
//    			hInstDll	: DLL instance.
//    			fdwReason	: Reason the main function is called.
//    			lpReserved	: Reserved.
//
//	Return: 	TRUE		: OK
//				FALSE		: Error, DLL won't load
//---------------------------------------------------------------------------
BOOL WINAPI DllMain (HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpvReserved)
{
BOOL	status = TRUE;

switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		// The DLL is being loaded for the first time by a given process.
		// Perform per-process initialization here.  If the initialization
		// is successful, return TRUE; if unsuccessful, return FALSE.

#ifdef ISRDBG
		ISRREGISTERMODULE(&ghISRInst, "RRCM", "RTP/RTCP");
#endif

		DBGINIT(&ghDbgZoneRRCM, _rgZones);

        DBG_INIT_MEMORY_TRACKING(hInstDll);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
		RTPLogger = InteropLoad(RTPLOG_PROTOCOL);
#endif

		_Module.Init(ObjectMap, hInstDll);
		DisableThreadLibraryCalls(hInstDll);
		//LogInit();
		InitializeCriticalSection(&g_CritSect);

		// initialize RTP/RTCP
		status = (initRTP (hInstDll) == FALSE) ? TRUE:FALSE;
		break;

	case DLL_PROCESS_DETACH:
		// The DLL is being unloaded by a given process.  Do any
		// per-process clean up here.The return value is ignored.
		// delete RTP resource
		deleteRTP (hInstDll);

		_Module.Term();
		//LogClose();
		DeleteCriticalSection(&g_CritSect);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
		if (RTPLogger)
			InteropUnload(RTPLogger);
#endif
        DBG_CHECK_MEMORY_TRACKING(hInstDll);
		DBGDEINIT(&ghDbgZoneRRCM);
		break;

    case DLL_THREAD_ATTACH:
		// A thread is being created in a process that has already loaded
		// this DLL.  Perform any per-thread initialization here.
		break;

    case DLL_THREAD_DETACH:
		// A thread is exiting cleanly in a process that has already
		// loaded this DLL.  Perform any per-thread clean up here.
		break;
	}

return (status);  
}



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}




// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\rtpinit.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTPINIT.C
 * Product:     RTP/RTCP implementation
 * Description: Provides initialization functions.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"
/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/



extern SOCKET PASCAL WS2EmulSocket(
    int af, int type,int protocol, LPWSAPROTOCOL_INFO ,GROUP,DWORD);
extern int PASCAL WS2EmulCloseSocket(SOCKET s);
extern int PASCAL WS2EmulSetSockOpt(SOCKET s, int level,int optname,const char FAR * optval,int optlen);
extern int PASCAL WS2EmulBind( SOCKET s, const struct sockaddr FAR * name, int namelen);
extern int PASCAL WS2EmulRecvFrom(
    SOCKET s,LPWSABUF , DWORD, LPDWORD, LPDWORD,struct sockaddr FAR *,   LPINT,
    LPWSAOVERLAPPED,LPWSAOVERLAPPED_COMPLETION_ROUTINE );
extern int PASCAL WS2EmulSendTo(
	SOCKET s,LPWSABUF, DWORD ,LPDWORD , DWORD , const struct sockaddr FAR *, int,
    LPWSAOVERLAPPED , LPWSAOVERLAPPED_COMPLETION_ROUTINE );
extern int PASCAL WS2EmulGetSockName(	SOCKET s, struct sockaddr * name, int * namelen );
extern int PASCAL WS2EmulHtonl( SOCKET s,u_long hostlong,u_long FAR * lpnetlong);
extern int PASCAL WS2EmulNtohl( SOCKET s,u_long ,u_long FAR * );
extern int PASCAL WS2EmulHtons( SOCKET s,u_short ,u_short FAR *);
extern int PASCAL WS2EmulNtohs( SOCKET s,u_short ,u_short FAR *);
extern int PASCAL WS2EmulGetHostName(char *name, int namelen);
extern struct hostent FAR * PASCAL WS2EmulGetHostByName(const char * name);
extern SOCKET PASCAL WS2EmulJoinLeaf(SOCKET s, const struct sockaddr FAR * name,int , LPWSABUF , LPWSABUF , LPQOS, LPQOS, DWORD dwFlags);
extern int PASCAL WS2EmulIoctl(SOCKET s, DWORD, LPVOID,DWORD cbInBuffer, LPVOID ,
	DWORD, LPDWORD lpcbBytesReturned,LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);

extern void WS2EmulInit();

extern void WS2EmulTerminate();

/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            
PRTP_CONTEXT	pRTPContext = NULL;
RRCM_WS			RRCMws = 
	{
		NULL,		// hWSdll
		WS2EmulSendTo,
		WS2EmulRecvFrom,
		WS2EmulNtohl,
		WS2EmulNtohs,
		WS2EmulHtonl,
		WS2EmulHtons,
		WS2EmulGetSockName,
		WS2EmulGetHostName,
		WS2EmulGetHostByName,
		WS2EmulCloseSocket,
		WS2EmulSocket,
		WS2EmulBind,
		NULL,		//WSAEnumProtocols
		WS2EmulJoinLeaf,		//WSAJoinLeaf
		WS2EmulIoctl,		//WSAIoctl
		WS2EmulSetSockOpt
	};				

DWORD g_fDisableWinsock2 = 0;

#ifdef ENABLE_ISDM2
KEY_HANDLE		hRRCMRootKey;
ISDM2			Isdm2;
#endif

#ifdef _DEBUG
char			debug_string[DBG_STRING_LEN];
#endif

#ifdef UNICODE
static const char szWSASocket[] = "WSASocketW";
static const char szWSAEnumProtocols[] = "WSAEnumProtocolsW";
#else
static const char szWSASocket[] = "WSASocketA";
static const char szWSAEnumProtocols[] = "WSAEnumProtocolsA";
#endif





/*----------------------------------------------------------------------------
 * Function   : initRTP
 * Description: Initializes the RTP task.
 * 
 * Input : hInst:	Handle to the DLL instance
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Initialization Error (see RRCM.H).
 ---------------------------------------------------------------------------*/
DWORD initRTP (HINSTANCE hInst)
	{
	DWORD	dwStatus;
	DWORD	hashTableEntries = NUM_RTP_HASH_SESS;

	IN_OUT_STR ("RTP : Enter initRTP()\n");

	// If RTP has already been initialized, stop, report the error and return
	if (pRTPContext != NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - Multiple RTP Instances", 0, 
				      __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit initRTP()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPReInit));
		}

	// Obtain our context
	pRTPContext = (PRTP_CONTEXT)GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT,
											 sizeof(RTP_CONTEXT));

	// if no resources, exit with appropriate error
	if (pRTPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - Resource allocation failed", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit initRTP()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPResources));
		}

	// Get information from the registry if any present
	RRCMreadRegistry (pRTPContext);

	// Perform dynamic linking of what we need
	if ((dwStatus = RRCMgetDynamicLink ()) != RRCM_NoError)
		{
		GlobalFree(pRTPContext);
		pRTPContext = NULL;

		RRCM_DBG_MSG ("RTP : ERROR - Winsock library not found", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit initRTP()\n");

		return MAKE_RRCM_ERROR(dwStatus);
		}

	// Initialize RTP context critical section
	InitializeCriticalSection(&pRTPContext->critSect);

	//Initialize WS2Emulation critical section
	WS2EmulInit();

	// Create RTCP and look at return value.  If error, don't proceed 
	// any further.  Pass this error to the calling function
	if ((dwStatus = initRTCP()) == RRCM_NoError) 
		{
		// RTCP is up.  We need to initialize our context
		pRTPContext->hInst = hInst;
		pRTPContext->pRTPSession.next = NULL;
		pRTPContext->pRTPSession.prev = NULL;

		}
			
	// if any part of initialation did not succeed, declare it all a failure
	//	and return all resourses allocated
	if (dwStatus != RRCM_NoError) 
		{
		if (pRTPContext) 
			{
	
			GlobalFree(pRTPContext);
			pRTPContext = NULL;
			}
		}

	IN_OUT_STR ("RTP : Exit initRTP()\n");

	if (dwStatus != RRCM_NoError)
		dwStatus = MAKE_RRCM_ERROR(dwStatus);

	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : deleteRTP
 * Description: Deletes RTP. Closes all RTP and RTCP sessions and releases all
 *				resources.
 * 
 * Input : hInst:	 Handle to the DLL instance.
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Initialization Error (see RRCM.H).
 ---------------------------------------------------------------------------*/
DWORD deleteRTP (HINSTANCE hInst)
	{
	DWORD			dwStatus;
	PRTP_SESSION	pDeleteSession;

#ifdef ENABLE_ISDM2
	HRESULT			hError;
#endif

	IN_OUT_STR ("RTP : Enter deleteRTP()\n");

	// If RTP context doesn't exist, report error and return.
	if (pRTPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - No RTP instance", 0, 
						__FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTP : Exit deleteRTP()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidDelete));
		}

	if (pRTPContext->hInst != hInst) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid DLL instance handle", 0, 
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTP : Exit deleteRTP()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPNoContext));
		}

	// If we still have sessions open, clean them up
	while ((pDeleteSession = 
			(PRTP_SESSION)pRTPContext->pRTPSession.prev) != NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - Session x still open at DLL exit", 0, 
					  __FILE__, __LINE__, DBG_ERROR);
		ASSERT(0);
		//Close all open sessions
		CloseRTPSession (pDeleteSession, NULL, FALSE);
		}

	// Call RTCP to terminate and cleanup
	dwStatus = deleteRTCP();
		
#ifdef ENABLE_ISDM2
	// Query ISDM key
	if (Isdm2.hISDMdll)
		{
		DWORD dwKeys = 0;
		DWORD dwValues = 0;

		if (SUCCEEDED (Isdm2.ISDMEntry.ISD_QueryInfoKey (hRRCMRootKey, 
														 NULL, NULL, 
														 &dwKeys, &dwValues)))
			{
			if (!dwKeys && !dwValues)
				{
				hError = Isdm2.ISDMEntry.ISD_DeleteKey(hRRCMRootKey);
				if(FAILED(hError))
					RRCM_DBG_MSG ("RTP: ISD_DeleteKey failed", 0,
									NULL, 0, DBG_NOTIFY);
				}
			}

		DeleteCriticalSection (&Isdm2.critSect);

		if (FreeLibrary (Isdm2.hISDMdll) == FALSE)
			{
			RRCM_DBG_MSG ("RTP : ERROR - Freeing WS Lib", GetLastError(), 
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}
#endif

	// unload the WS library
	if (RRCMws.hWSdll)
		{
		if (FreeLibrary (RRCMws.hWSdll) == FALSE)
			{
			RRCM_DBG_MSG ("RTP : ERROR - Freeing WS Lib", GetLastError(), 
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	// delete RTP context critical section
	DeleteCriticalSection(&pRTPContext->critSect);

	// delete WS2 Emulation
	WS2EmulTerminate();
	
	// delete RTP context
	GlobalFree(pRTPContext);
	pRTPContext = NULL;

	IN_OUT_STR ("RTP : Exit deleteRTP()\n");

	if (dwStatus != RRCM_NoError)
		dwStatus = MAKE_RRCM_ERROR(dwStatus);

	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : RRCMreadRegistry
 * Description: Access the registry
 * 
 * Input : pCtxt:	-> to the RTP context
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void RRCMreadRegistry (PRTP_CONTEXT	pCtxt)
	{
	HKEY	hKey;
	long	lRes;
	char	keyBfr[50];

	// open the key
	strcpy (keyBfr, szRegRRCMKey);

	// INTEL key vs MICROSOFT KEY
#ifndef INTEL
	strcat (keyBfr, szRegRRCMSubKey);
#else
	strcat (keyBfr, szRegRRCMSubKeyIntel);
#endif
	lRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
						 keyBfr,	
						 0, 
						 KEY_READ,
						 &hKey);
	if (lRes || !hKey)
		{
		// key not found, setup default values
		pCtxt->registry.NumSessions      = NUM_RRCM_SESS;
		pCtxt->registry.NumFreeSSRC      = NUM_FREE_SSRC;
		pCtxt->registry.NumRTCPPostedBfr = NUM_RCV_BFR_POSTED;
		pCtxt->registry.RTCPrcvBfrSize   = RRCM_RCV_BFR_SIZE;
		return;
		}

	// get the number of RRCM sessions
	RRCMgetRegistryValue (hKey, szRegRRCMNumSessions, 
				          &pCtxt->registry.NumSessions, 
						  REG_DWORD, sizeof(DWORD));
	// check range
	if (pCtxt->registry.NumSessions < MIN_NUM_RRCM_SESS)
		pCtxt->registry.NumSessions = MIN_NUM_RRCM_SESS;
	else if (pCtxt->registry.NumSessions > MAX_NUM_RRCM_SESS)
		pCtxt->registry.NumSessions = MAX_NUM_RRCM_SESS;

	// get the number of initial free SSRC
	RRCMgetRegistryValue (hKey, szRegRRCMNumFreeSSRC,
					      &pCtxt->registry.NumFreeSSRC, 
						  REG_DWORD, sizeof(DWORD));

	// check range
	if (pCtxt->registry.NumFreeSSRC < MIN_NUM_FREE_SSRC)
		pCtxt->registry.NumFreeSSRC = MIN_NUM_FREE_SSRC;
	else if (pCtxt->registry.NumFreeSSRC > MAX_NUM_FREE_SSRC)
		pCtxt->registry.NumFreeSSRC = MAX_NUM_FREE_SSRC;

	// get the number of RTCP rcv buffers to be posted
	RRCMgetRegistryValue (hKey, szRegRRCMNumRTCPPostedBfr,
					      &pCtxt->registry.NumRTCPPostedBfr, 
						  REG_DWORD, sizeof(DWORD));

	// check range
	if (pCtxt->registry.NumRTCPPostedBfr < MIN_NUM_RCV_BFR_POSTED)
		pCtxt->registry.NumRTCPPostedBfr = MIN_NUM_RCV_BFR_POSTED;
	else if (pCtxt->registry.NumRTCPPostedBfr > MAX_NUM_RCV_BFR_POSTED)
		pCtxt->registry.NumRTCPPostedBfr = MAX_NUM_RCV_BFR_POSTED;

	// get the RTCP rcv buffer size
	RRCMgetRegistryValue (hKey, szRegRRCMRTCPrcvBfrSize,
					      &pCtxt->registry.RTCPrcvBfrSize, 
						  REG_DWORD, sizeof(DWORD));

	// check range
	if (pCtxt->registry.RTCPrcvBfrSize < MIN_RRCM_RCV_BFR_SIZE)
		pCtxt->registry.RTCPrcvBfrSize = MIN_RRCM_RCV_BFR_SIZE;
	else if (pCtxt->registry.RTCPrcvBfrSize > MAX_RRCM_RCV_BFR_SIZE)
		pCtxt->registry.RTCPrcvBfrSize = MAX_RRCM_RCV_BFR_SIZE;

	RRCMgetRegistryValue(hKey, "DisableWinsock2",
					      &g_fDisableWinsock2, 
						  REG_DWORD, sizeof(DWORD));

	// close the key
	RegCloseKey (hKey);
	}


/*----------------------------------------------------------------------------
 * Function   : RRCMgetRegistryValue
 * Description: Read a value from the registry
 * 
 * Input :		hKey	: Key handle
 *				pValStr	: -> to string value
 *				pKeyVal : -> to value
 *				type	: Type to read
 *				len		: Receiving buffer length
 *
 * Return:		None
 ---------------------------------------------------------------------------*/
void RRCMgetRegistryValue (HKEY hKey, LPTSTR pValStr, 
					       PDWORD pKeyVal, DWORD type, DWORD len)
	{
	DWORD	dwType = type;
	DWORD	retSize = len;

	// query the value
	RegQueryValueEx (hKey,
				     pValStr,
					 NULL,
					 &dwType,
					 (BYTE *)pKeyVal,
					 &retSize);
	}


/*----------------------------------------------------------------------------
 * Function   : RRCMgetDynamicLink
 * Description: Get all dynamic linked DLL entries
 * 
 * Input :		None
 *
 * Return:		None
 ---------------------------------------------------------------------------*/
DWORD RRCMgetDynamicLink (void)
	{
	HINSTANCE		hWSdll;

#ifdef ENABLE_ISDM2
	HRESULT			hError;

	Isdm2.hISDMdll = LoadLibrary(szISDMdll);

	// make sure the LoadLibrary call did not fail
	if (Isdm2.hISDMdll)
		{
		RRCM_DBG_MSG ("RTP: ISDM2 LoadLibrary worked", 0, NULL, 0, DBG_NOTIFY);
		// get the ISDM entry points used by RRCM
		Isdm2.ISDMEntry.ISD_CreateKey = 
			(ISD_CREATEKEY) GetProcAddress (Isdm2.hISDMdll, 
												   "ISD_CreateKey");

		Isdm2.ISDMEntry.ISD_CreateValue = 
			(ISD_CREATEVALUE) GetProcAddress (Isdm2.hISDMdll, "ISD_CreateValue");

		Isdm2.ISDMEntry.ISD_SetValue = 
			(ISD_SETVALUE) GetProcAddress (Isdm2.hISDMdll, "ISD_SetValue");

		Isdm2.ISDMEntry.ISD_DeleteValue = 
			(ISD_DELETEVALUE) GetProcAddress (Isdm2.hISDMdll, "ISD_DeleteValue");

		Isdm2.ISDMEntry.ISD_DeleteKey = 
			(ISD_DELETEKEY) GetProcAddress (Isdm2.hISDMdll, "ISD_DeleteKey");

		Isdm2.ISDMEntry.ISD_QueryInfoKey = 
			(ISD_QUERYINFOKEY) GetProcAddress (Isdm2.hISDMdll, "ISD_QueryInfoKey");

		// initialize critical section
		InitializeCriticalSection (&Isdm2.critSect);

		// make sure we have all of them
		if (Isdm2.ISDMEntry.ISD_CreateKey == NULL ||
			Isdm2.ISDMEntry.ISD_CreateValue == NULL ||
			Isdm2.ISDMEntry.ISD_SetValue == NULL ||
			Isdm2.ISDMEntry.ISD_DeleteValue == NULL ||
			Isdm2.ISDMEntry.ISD_DeleteKey == NULL ||
			Isdm2.ISDMEntry.ISD_QueryInfoKey == NULL )
			{
			Isdm2.hISDMdll = 0;
			RRCM_DBG_MSG ("RTP: Failed to load all ISDM2 functions",
							0, NULL, 0, DBG_NOTIFY);
			// delete critical section
			DeleteCriticalSection (&Isdm2.critSect);
			}
		else
			{
			hError = Isdm2.ISDMEntry.ISD_CreateKey(MAIN_ROOT_KEY, szRRCMISDM, &hRRCMRootKey);
			if(FAILED(hError))
				{
				RRCM_DBG_MSG ("RTP: ISD_CreateKey Failed",0, NULL, 0, DBG_NOTIFY);
				hRRCMRootKey = 0;
				}
			}
		}
#endif

	if (!g_fDisableWinsock2)
		{
		// load Winsock2 if present
		hWSdll = LoadLibrary(szRRCMdefaultLib);

		if (hWSdll)
			{
			RRCMws.hWSdll = hWSdll;

			RRCMws.sendTo = (LPFN_WSASENDTO)GetProcAddress (hWSdll, 
															  "WSASendTo");
			RRCMws.recvFrom = (LPFN_WSARECVFROM)GetProcAddress (hWSdll, 
															"WSARecvFrom");
			RRCMws.getsockname = (LPFN_GETSOCKNAME)GetProcAddress (hWSdll, 
															"getsockname");
			RRCMws.gethostname = (LPFN_GETHOSTNAME)GetProcAddress (hWSdll, 
															"gethostname");
			RRCMws.gethostbyname = (LPFN_GETHOSTBYNAME)GetProcAddress (hWSdll, 
															"gethostbyname");
			RRCMws.WSASocket = (LPFN_WSASOCKET)GetProcAddress (hWSdll, 
															szWSASocket);
			RRCMws.closesocket = (LPFN_CLOSESOCKET)GetProcAddress (hWSdll, 
																"closesocket");
			RRCMws.bind = (LPFN_BIND)GetProcAddress (hWSdll, 
																"bind");
		
			RRCMws.WSAEnumProtocols = (LPFN_WSAENUMPROTOCOLS) ::GetProcAddress(hWSdll, szWSAEnumProtocols);
			RRCMws.WSAIoctl = (LPFN_WSAIOCTL) ::GetProcAddress(hWSdll, "WSAIoctl");
			RRCMws.WSAJoinLeaf = (LPFN_WSAJOINLEAF) ::GetProcAddress(hWSdll, "WSAJoinLeaf");
			RRCMws.setsockopt = (LPFN_SETSOCKOPT) ::GetProcAddress(hWSdll, "setsockopt");
			RRCMws.ntohl = (LPFN_WSANTOHL)GetProcAddress (hWSdll, "WSANtohl");
			RRCMws.ntohs = (LPFN_WSANTOHS)GetProcAddress (hWSdll, "WSANtohs");
			RRCMws.htonl = (LPFN_WSAHTONL)GetProcAddress (hWSdll, "WSAHtonl");
			RRCMws.htons = (LPFN_WSAHTONS)GetProcAddress (hWSdll, "WSAHtons");
			
			if (RRCMws.WSAEnumProtocols)
			{
				int nProt = 0, i;
				int iProt[2];	// array of protocols we're interested in
				DWORD dwBufLength = sizeof(WSAPROTOCOL_INFO);
				LPWSAPROTOCOL_INFO pProtInfo = (LPWSAPROTOCOL_INFO) LocalAlloc(0,dwBufLength);

				iProt[0] = IPPROTO_UDP;
				iProt[1] = 0;
				// figure out the buffer size needed for WSAPROTOCOLINFO structs
				nProt = RRCMws.WSAEnumProtocols(iProt,pProtInfo,&dwBufLength);
				if (nProt < 0 && GetLastError() == WSAENOBUFS) {
					LocalFree(pProtInfo);
					pProtInfo = (LPWSAPROTOCOL_INFO) LocalAlloc(0,dwBufLength);
					if (pProtInfo)
						nProt = RRCMws.WSAEnumProtocols(iProt,pProtInfo,&dwBufLength);
				}

				if (nProt > 0) {
					for (i=0;i < nProt; i++) {
						if (pProtInfo[i].iProtocol == IPPROTO_UDP
							&& pProtInfo[i].iSocketType == SOCK_DGRAM
							&& ((pProtInfo[i].dwServiceFlags1 & XP1_QOS_SUPPORTED) || RRCMws.RTPProtInfo.iProtocol == 0)
							)
						{	// make a copy of the matching WSAPROTOCOL_INFO
							RRCMws.RTPProtInfo = pProtInfo[i];
							
							if (pProtInfo[i].dwServiceFlags1 & XP1_QOS_SUPPORTED)
							{
								RRCM_DBG_MSG ("QOS UDP provider found.\n", 0, 
		 		      			__FILE__, __LINE__, DBG_WARNING);
								break;
							}
							// else keep looking for a provider that supports QOS
						}
					}
				}
				if (pProtInfo)
					LocalFree(pProtInfo);

				if (RRCMws.RTPProtInfo.iProtocol == IPPROTO_UDP)
				{
					// we found the protocol(s) we wanted
					//RETAILMSG(("NAC: Using Winsock 2"));
				}
				else
				{
					FreeLibrary(RRCMws.hWSdll);
					RRCMws.hWSdll = NULL;
				}
			}
			}
		}
	// make sure we have the Xmt/Recv functionality
	if (RRCMws.sendTo == NULL || 
		RRCMws.recvFrom == NULL ||
		RRCMws.getsockname == NULL ||
		RRCMws.ntohl == NULL ||
		RRCMws.ntohs == NULL ||
		RRCMws.htonl == NULL ||
		RRCMws.htons == NULL ||
		RRCMws.gethostname == NULL ||
		RRCMws.gethostbyname == NULL ||
		RRCMws.WSASocket == NULL ||
		RRCMws.closesocket == NULL ||
		RRCMws.WSAIoctl == NULL ||
		RRCMws.WSAJoinLeaf == NULL 
		)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid Winsock DLL", 0, 
		 		      __FILE__, __LINE__, DBG_CRITICAL);

		return RRCMError_WinsockLibNotFound;
		}
	else
		return RRCM_NoError;
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtcp\rtcptime.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPTIME.C
 * Product:     RTP/RTCP implementation
 * Description: Provides timers related functions for RTCP.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"                                    


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/  
extern PRTCP_CONTEXT	pRTCPContext;
#ifdef _DEBUG
extern char	debug_string[];
#endif




/*----------------------------------------------------------------------------
 * Function   : RTCPxmitInterval
 * Description: Calculate the RTCP transmission interval
 * 
 * Input :	members:	Estimated number of session members including 
 *						ourselves. On the initial call, should be 1.
 *
 *			senders:	Number of active senders since last report, known from
 *						construction of receiver reports for this packet. 
 *						Includes ourselves if we sent.
 *
 *			rtcpBw:		The target RTCP bandwidth, ie, the total Bw that will 
 *						be used by RTCP by all members of this session, in 
 *						bytes per seconds. Should be 5% of the session Bw.
 *
 *			weSent:		True if we've sent data during the last two RTCP 
 *						intervals. If TRUE, the compound RTCP packet just
 *						sent contained an SR packet.
 *
 *			packetSize:	Size of the RTCP packet just sent, in bytes, including
 *						network encapsulation, eg 28 bytes for UDP over IP.
 *
 *			*avgRtcpSize: Estimator to RTCP packet size, initialized and 
 *						 updated by this function for the packet just sent.
 *
 *			initial:	Initial transmission flag.
 *
 * Return: 		Interval time before the next transmission in msec.
 ---------------------------------------------------------------------------*/
DWORD RTCPxmitInterval (DWORD members, 
					    DWORD senders, 
						DWORD rtcpBw,
						DWORD weSent, 
						DWORD packetSize, 
						int *avgRtcpSize,
						DWORD initial)
	{
#ifdef ENABLE_FLOATING_POINT
//	// Minimum time between RTCP packets from this site in seconds. This time
//	// prevents the reports from clumping when sessions are small and the law
//	// of large numbers isn't helping to smooth out the traffic. It also keeps
//	// the report intervals from becoming ridiculously small during transient
//	// outages like a network partition.
//	double const RTCP_MinTime = 5.;
//
//	// Fraction of the RTCP bandwidth to be shared among active senders. This 
//	// fraction was chosen so that in a typical session with one or two active 
//	// senders, the computed report time would be roughly equal to the minimum
//	// report time so that we don't unnecessarily slow down receiver reports. 
//	// The receiver fraction must be 1 - the sender fraction.
//	double const RTCP_SenderBwFraction = 0.25;
//	double const RTCP_RcvrBwFraction   = (1 - RTCP_SenderBwFraction);
//
//	// Gain (smoothing constant) for the low-pass filter that estimates the 
//	// average RTCP packet size.
//	double const RTCP_sizeGain = RTCP_SIZE_GAIN;
//
//	// Interval 
//	double	t = 0;
//	double	rtcp_min_time = RTCP_MinTime;
//
//	// Number of member for computation 
//	unsigned int 	n;
//	int				tmpSize;
//
//	// Random number 
//	double	randNum;
//
//	// Very first call at application start-up uses half the min delay for 
//	// quicker notification while still allowing some time before reporting
//	// for randomization and to learn about other sources so the report
//	// interval will converge to the correct interval more quickly. The
//	// average RTCP size is initialized to 128 octects which is conservative.
//	// It assumes everyone else is generating SRs instead of RRs:
//	// 		20 IP + 8 UDP + 52 SR + 48 SDES CNAME
//	if (initial)
//		{
//		rtcp_min_time /= 2;
//		*avgRtcpSize = 128;
//		}
//
//	// If there were active senders, give them at least a minimum share of the 
//	// RTCP bandwidth. Otherwise all participants share the RTCP Bw equally.
//	n = members;
//	if (senders > 0 && (senders < (members * RTCP_SenderBwFraction)))
//		{
//		if (weSent)
//			{
//			rtcpBw *= RTCP_SenderBwFraction;
//			n = senders;
//			}
//		else
//			{
//			rtcpBw *= RTCP_RcvrBwFraction;
//			n -= senders;
//			}
//		}
//
//	// Update the average size estimate by the size of the report packet we 
//	// just sent out.
//	tmpSize = packetSize - *avgRtcpSize;
//	tmpSize = (int)(tmpSize * RTCP_sizeGain);
//	*avgRtcpSize += tmpSize;
//
//	// The effective number of sites times the average packet size is the 
//	// total number of octets sent when each site sends a report. Dividing 
//	// this by the effective bandwidth gives the time interval over which 
//	// those packets must be sent in order to meet the bandwidth target, 
//	// with a minimum enforced. In that time interval we send one report so
//	// this time is also our average time between reports.
//	t = (*avgRtcpSize) * n / rtcpBw;
//
//	if (t < rtcp_min_time)
//		t = rtcp_min_time;
//
//	// To avoid traffic burst from unintended synchronization with other sites
//	// we then pick our actual next report interval as a random number 
//	// uniformely distributed between 0.5*t and 1.5*t.
//
//	// Get a random number between 0 and 1
//	//  rand() gives a number between 0-32767. 
//	randNum = RRCMrand() % 32767;
//	randNum /= 32767.0;
//
//  // return timeout in msec
//	return (t * (randNum + 0.5) * 1000);
#else
	// Minimum time between RTCP packets from this site in Msec. This time
	// prevents the reports from clumping when sessions are small and the law
	// of large numbers isn't helping to smooth out the traffic. It also keeps
	// the report intervals from becoming ridiculously small during transient
	// outages like a network partition.
	int RTCP_MinTime = 5000;

	// Interval 
	int				t = 0;
	int				rtcp_min_time = RTCP_MinTime;

	// Number of member for computation 
	unsigned int 	n;
	int				tmpSize;

	// Random number 
	int				randNum;

	// Very first call at application start-up uses half the min delay for 
	// quicker notification while still allowing some time before reporting
	// for randomization and to learn about other sources so the report
	// interval will converge to the correct interval more quickly. The
	// average RTCP size is initialized to 128 octects which is conservative.
	// It assumes everyone else is generating SRs instead of RRs:
	// 		20 IP + 8 UDP + 52 SR + 48 SDES CNAME
	if (initial)
		{
		rtcp_min_time /= 2;
		*avgRtcpSize = 128;
		}

	// If there were active senders, give them at least a minimum share of the 
	// RTCP bandwidth. Otherwise all participants share the RTCP Bw equally.
	n = members;

	// Only a quart of the bandwidth (=> /4). Check above with floatting point
	if (senders > 0 && (senders < (members / 4)))
		{
		if (weSent)
			{
			// Only a quart of the bandwidth for the sender
			rtcpBw /= 4;
			n = senders;
			}
		else
			{
			// 3/4 of the bandwidth for the receiver
			rtcpBw = (3*rtcpBw)/4;
			n -= senders;
			}
		}

	// Update the average size estimate by the size of the report packet we 
	// just sent out.
	tmpSize = packetSize - *avgRtcpSize;
	tmpSize = (tmpSize+8) / 16;
	*avgRtcpSize += tmpSize;

	// The effective number of sites times the average packet size is the 
	// total number of octets sent when each site sends a report. Dividing 
	// this by the effective bandwidth gives the time interval over which 
	// those packets must be sent in order to meet the bandwidth target, 
	// with a minimum enforced. In that time interval we send one report so
	// this time is also our average time between reports.
	if (rtcpBw)
		t = (*avgRtcpSize) * n / rtcpBw;

	if (t < rtcp_min_time)
		t = rtcp_min_time;

	// To avoid traffic burst from unintended synchronization with other sites
	// we then pick our actual next report interval as a random number 
	// uniformely distributed between 0.5*t and 1.5*t.

	// Get a random number between 0 and 1
	// In order to avoid floating point operation, get a number between 
	// 0 and 1000, i.e. converted in Msec already. Add 500 Msec instead of 
	// 0.5 to the random number
	randNum = RRCMrand() % 1000;

	return ((t * (randNum + 500))/1000);
#endif
	}




// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\rtpio.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTPIO.C
 * Product:     RTP/RTCP implementation
 * Description: Provides Session Creation/Deletion Functionality.
 *
 *
 * This listing is supplied under the terms
 * of a license agreement with Intel Corporation and
 * many not be copied nor disclosed except in accordance
 * with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/

#include "rrcm.h"
		

/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT	pRTPContext;

#ifdef _DEBUG
extern char   debug_string[];
#endif


/*----------------------------------------------------------------------------
 * Function   : CreateRTPSession
 * Description: Creates an RTP (and RTCP) session for a new stream.
 *
 * Input :		RTPsocket		: RTP socket descriptor
 *				RTCPsd			: RTCP socket descriptor
 *				pRTCPTo			: RTCP destination address
 *				toRTCPLen		: RTCP destination address length
 *				pSdesInfo		: -> to SDES information
 *				dwStreamClock	: Stream clocking frequency
 *				ssrc			: If set, user selected SSRC
 *				pRRCMcallback	: RRCM notification
 *				dwCallbackInfo	: User callback info
 *				miscInfo		: Miscelleanous information:
 *										H.323Conf:		0x00000002
 *										Encrypt SR/RR:	0x00000004
 *										RTCPon:			0x00000008
 *				dwRtpSessionBw	: RTP session bandwidth used for RTCP BW
 *				*pStatus		: -> to status information
 *
 * Return: handle to created session if successful
 *         Otherwise(0)	*pStatus = Initialization Error (see RRCM.H)
 ---------------------------------------------------------------------------*/
HANDLE WINAPI CreateRTPSession (SOCKET RTPsocket,
								  SOCKET RTCPsocket,
								  LPVOID pRTCPTo,
								  DWORD toRTCPLen,
								  PSDES_DATA pSdesInfo,
								  DWORD dwStreamClock,
								  PENCRYPT_INFO pEncryptInfo,
								  DWORD ssrc,
								  PRRCM_EVENT_CALLBACK pRRCMcallback,
								  DWORD_PTR dwCallbackInfo,
								  DWORD miscInfo,
								  DWORD dwRtpSessionBw,
								  DWORD *pStatus)
	{
	DWORD			numCells = NUM_FREE_CONTEXT_CELLS;
	DWORD			dwStatus;
	DWORD			dwRTCPstatus;
	PRTP_SESSION    pSession = NULL;
	PSSRC_ENTRY		pSSRC;

	IN_OUT_STR ("RTP : Enter CreateRTPSession()\n");

	// set status code
	*pStatus = dwStatus = RRCM_NoError;

	// If RTP context doesn't exist, report error and return.
	if (pRTPContext == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - No RTP Instance",
					  0, __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

		*pStatus = MAKE_RRCM_ERROR(RRCMError_RTPNoContext);

		return 0;
		}

	#if 0
	// look for an existing session - Sender/Receiver for the same session
	// will be on two different graph under ActiveMovie
	if (pSession = findSessionID (RTPsocket))
		{
		RRCM_DBG_MSG ("RTP : Session already created", 0,
					  __FILE__, __LINE__, DBG_TRACE);

		IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

		// return the unique RTP session ID
		return ((HANDLE)pSession);
		}
	#endif

	// Allocate a new session pointer.
	pSession = (PRTP_SESSION)GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT,
									      sizeof(RTP_SESSION));
		
	// Report error if could not allocate context
	if (pSession == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Resource allocation failed", 0,
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

		*pStatus = MAKE_RRCM_ERROR(RRCMError_RTPSessResources);

		return 0;
		}

	// Initialize the RTP session's critical section
	InitializeCriticalSection(&pSession->critSect);
	

	// All seems OK, initialize RTCP for this session
	pSession->pRTCPSession = CreateRTCPSession(RTPsocket,
											   RTCPsocket,
											   pRTCPTo,
											   toRTCPLen,
											   pSdesInfo,
											   dwStreamClock,
											   pEncryptInfo,
											   ssrc,
											   pRRCMcallback,
											   dwCallbackInfo,
											   miscInfo,
											   dwRtpSessionBw,
											   &dwRTCPstatus);

	if (pSession->pRTCPSession == NULL)
		{
		dwStatus = dwRTCPstatus;


		// Can't proceed, return session pointer
		if (pSession)
			{
			GlobalFree (pSession);
			pSession = NULL;
			}
		}
	else
		{
#if 0
		// Associate the socket with the Session address
		dwStatus = createHashEntry (pSession, RTPsocket);
#endif

		if (dwStatus == RRCM_NoError)
			{
			pSSRC =
				(PSSRC_ENTRY)pSession->pRTCPSession->XmtSSRCList.prev;

			if (pSSRC == NULL)
				{
				RRCM_DBG_MSG ("RTP : ERROR - No RTCP Xmt list", 0,
						  __FILE__, __LINE__, DBG_CRITICAL);

				dwStatus = RRCMError_RTCPNoXmtList;
				}
			else
				{
				// Let's add this to our context
				addToHeadOfList(&(pRTPContext->pRTPSession),
							(PLINK_LIST)pSession,
							&pRTPContext->critSect);
#ifdef _DEBUG
				wsprintf(debug_string, "RTP : Adding RTP Session. (Addr:0x%p)",
								pSession);
				RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
				}
			}

		}

	// set status code
	if (dwStatus != RRCM_NoError)
		*pStatus = MAKE_RRCM_ERROR(dwStatus);

	IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

	// return the unique RTP session ID
	return ((HANDLE)pSession);
	}


/*----------------------------------------------------------------------------
 * Function   : CloseRTPSession
 * Description: Terminates a local stream session.
 *
 * Input : RTPSession		= RTP session ID
 *		   byeReason		= -> to BYE reason
 *		   closeRTCPSocket	= TRUE/FALSE. RTCP will close or not the socket
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Error (see RRCM.H)
 ---------------------------------------------------------------------------*/
HRESULT WINAPI CloseRTPSession (HANDLE RTPSession,
							     PCHAR byeReason,
							     DWORD closeRTCPSocket)
	{
	PRTP_SESSION    pSession;
	PSSRC_ENTRY		pSSRCList;
	PSSRC_ENTRY		pSSRC;
	DWORD			dwStatus;

	IN_OUT_STR ("RTP : Enter CloseRTPSession()\n");

	// If RTP context doesn't exist, report error and return.
	if (pRTPContext == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - No RTP Instance", 0,
						__FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTP : Exit CloseRTPSession()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPNoContext));
		}

	// Cast Session ID to obtain the session pointer.
	pSession = (PRTP_SESSION)RTPSession;
	if (pSession == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTP : Exit CloseRTPSession()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
		}

	// Remove the session from the linked list of sessions
	dwStatus = deleteRTPSession (pRTPContext, pSession);
	if (dwStatus != RRCM_NoError)
		{
#ifdef _DEBUG
		wsprintf(debug_string,
				 "RTP : ERROR - RTP session (Addr:0x%p) not found",
				 RTPSession);

		RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_ERROR);
#endif
		return (MAKE_RRCM_ERROR(dwStatus));
		}

	// lock out the session - it's on a free list now
	EnterCriticalSection (&pSession->critSect);

#if 0
	// clean up the Hash table for any stream still left in the Session
	for (pSSRCList = (PSSRC_ENTRY)pSession->pRTCPSession->XmtSSRCList.prev;
		 pSSRCList != NULL;
		 pSSRCList = (PSSRC_ENTRY)pSSRCList->SSRCList.next)
		{
		deleteHashEntry (pSSRCList->RTPsd);
		}
#endif
			
	// All seems OK, close RTCP for each stream still open
	pSSRC = (PSSRC_ENTRY)pSession->pRTCPSession->XmtSSRCList.prev;
	if (pSSRC == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - No SSRC entry on the Xmt list", 0,
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTP : Exit CloseRTPSession()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSSRCentry));
		}

	// reset the close socket flag
	if (closeRTCPSocket)
		pSSRC->dwSSRCStatus |= CLOSE_RTCP_SOCKET;

	dwStatus = deleteRTCPSession (pSSRC->RTCPsd, byeReason);
#ifdef _DEBUG
	if (dwStatus != RRCM_NoError)
		{
		wsprintf(debug_string,
				 "RTP : ERROR - RTCP delete Session (Addr: x%p) error:%d",
			     pSession, dwStatus);
		RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
		}
#endif


#ifdef _DEBUG
	wsprintf(debug_string, "RTP : Deleting Session x%p", pSession);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// lock out the session - it's on a free list now
	LeaveCriticalSection (&pSession->critSect);
	DeleteCriticalSection (&pSession->critSect);

	GlobalFree (pSession);
	pSession = NULL;

	IN_OUT_STR ("RTP : Exit CloseRTPSession()\n");

	if (dwStatus != RRCM_NoError)
		dwStatus = MAKE_RRCM_ERROR(dwStatus);

	return (dwStatus);
	}


/*--------------------------------------------------------------------------
** Function   : deleteRTPSession
** Description: Remove from	RTP session queue and restore links for other
**				sessions.
**
** Input :		pRTPContext:	-> to the RTP context
**				pSession:		-> to the RTP session
**
** Return:		OK:	RRCM_NoError
**				!0: Error code (see RRCM.H)
--------------------------------------------------------------------------*/
DWORD deleteRTPSession(PRTP_CONTEXT pRTPContext,
					   PRTP_SESSION pSession)
	{
	PLINK_LIST	pTmp;

	IN_OUT_STR ("RTP : Enter deleteRTPSession()\n");

	// make sure the session exist
	pTmp = pRTPContext->pRTPSession.prev;
	while (pTmp)
		{
		if (pTmp == (PLINK_LIST)pSession)
			break;

		pTmp = pTmp->next;
		}

	if (pTmp == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTP : Exit deleteRTPSession()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
		}

	// lock out queue access
	EnterCriticalSection (&pRTPContext->critSect);
	EnterCriticalSection (&pSession->critSect);

	if (pSession->RTPList.prev == NULL)
		// this was the first entry in the queue
		pRTPContext->pRTPSession.prev = pSession->RTPList.next;
	else
		(pSession->RTPList.prev)->next = pSession->RTPList.next;

	if (pSession->RTPList.next == NULL)
		// this was the last entry in the queue
		pRTPContext->pRTPSession.next = pSession->RTPList.prev;
	else
		(pSession->RTPList.next)->prev = pSession->RTPList.prev;

	// unlock out queue access
	LeaveCriticalSection (&pSession->critSect);
	LeaveCriticalSection (&pRTPContext->critSect);

	IN_OUT_STR ("RTP : Exit deleteRTPSession()\n");

	return (RRCM_NoError);
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\rtpmisc.cpp ===
/*----------------------------------------------------------------------------
 * File:        RRCMMISC.C
 * Product:     RTP/RTCP implementation.
 * Description: Provides common RTP/RTCP support functionality.
 *
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/


#include "rrcm.h"

/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
#ifdef ENABLE_ISDM2
extern KEY_HANDLE hRRCMRootKey;
extern ISDM2	  Isdm2;
#endif

extern RRCM_WS	RRCMws;				

#ifdef _DEBUG
extern char		debug_string[];
#endif

#ifdef ISRDBG
extern WORD		ghISRInst;
#endif


/*--------------------------------------------------------------------------
 * Function   : searchForMySSRC
 * Description: Find the SSRC for this stream.
 *
 * Input :	pSSRC		:	-> to the SSRC entry
 *			RTPSocket	:	RTP socket descriptor
 *
 * Return: NULL 			==> Session not found.
 *         Buffer Address 	==> OK, Session ptr returned
 --------------------------------------------------------------------------*/
 PSSRC_ENTRY searchForMySSRC(PSSRC_ENTRY pSSRC,
							 SOCKET RTPSocket)
	{
	PSSRC_ENTRY	pRRCMSession;

	IN_OUT_STR ("RTP : Enter searchForMySSRC()\n");

	for (pRRCMSession = NULL;
		 (pSSRC != NULL);
		 pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.prev)
		{
		if (pSSRC->RTPsd == RTPSocket)
			{
			pRRCMSession = pSSRC;
			break;
			}
		}

	IN_OUT_STR ("RTP : Exit searchForMySSRC()\n");		

	return (pRRCMSession);
	}


/*--------------------------------------------------------------------------
 * Function   : searchforSSRCatHead
 * Description: Search through linked list of RTCP entries starting at the
 *					head of the list.
 *
 * Input :	pSSRC	:	-> to the SSRC entry
 *			ssrc	:	ssrc to look for
 *
 * Return: NULL 			==> Session not found.
 *         Non-NULL		 	==> OK, SSRC entry found
 --------------------------------------------------------------------------*/
 PSSRC_ENTRY searchforSSRCatHead(PSSRC_ENTRY pSSRC,
								 DWORD ssrc)					
	{
	PSSRC_ENTRY	pRRCMSession;

	IN_OUT_STR ("RTP : Enter searchForMySSRCatHead()\n");		
	
	for (pRRCMSession = NULL;
		 (pSSRC != NULL) &&
		 (pRRCMSession == NULL) && (ssrc <= pSSRC->SSRC);
		 pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.prev)
		{
		if (pSSRC->SSRC == ssrc)
			{
			pRRCMSession = pSSRC;
			}
		}

	IN_OUT_STR ("RTP : Exit searchForMySSRCatHead()\n");		 		

	return (pRRCMSession);
	}


/*--------------------------------------------------------------------------
 * Function   : searchforSSRCatTail
 * Description: Search through linked list of RTCP entries starting at the
 *					tail of the list.
 *
 * Input :	pSSRC	:	-> to the SSRC entry
 *			ssrc	:	SSRC to look for
 *
 * Return: NULL 			==> Session not found.
 *         Non-NULL		 	==> OK, SSRC entry found
 --------------------------------------------------------------------------*/
 PSSRC_ENTRY searchforSSRCatTail(PSSRC_ENTRY pSSRC,
								 DWORD ssrc)					
	{
	PSSRC_ENTRY	pRRCMSession;

	IN_OUT_STR ("RTP : Enter searchForMySSRCatTail()\n");		
	
	for (pRRCMSession = NULL;
		 (pSSRC != NULL) &&
		 (pRRCMSession == NULL) && (ssrc >= pSSRC->SSRC);
		 pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.next)
		{
		if (pSSRC->SSRC == ssrc)
			{
			pRRCMSession = pSSRC;
			}
		}

	IN_OUT_STR ("RTP : Exit searchForMySSRCatTail()\n");		
	
	return (pRRCMSession);
	}


/*---------------------------------------------------------------------------
 * Function   : saveNetworkAddress
 * Description: Saves the received or local network Address in the local
 *					context.
 *
 * Input :	pSSRCEntry	:	-> to the SSRC entry
 *			pNetAddr	:	-> to the network address
 *			addrLen		:	Address length
 *
 * Return:	OK: RRCM_NoError
 --------------------------------------------------------------------------*/
 DWORD saveNetworkAddress (PSSRC_ENTRY pSSRC,
 						   PSOCKADDR pNetAddr,
 						   int addrLen)
	{
	IN_OUT_STR ("RTP : Enter saveNetworkAddress()\n");		

	pSSRC->dwSSRCStatus |= NETWK_ADDR_UPDATED;
	pSSRC->fromLen = addrLen;
	memcpy (&pSSRC->from, pNetAddr, addrLen);

	IN_OUT_STR ("RTP : Exit saveNetworkAddress()\n");

	return RRCM_NoError;			
	}


/*---------------------------------------------------------------------------
 * Function   : updateRTCPDestinationAddress
 * Description: The applicatino updates the RTCP destination address
 *				
 * Input :	hRTPSess		:	RTP session
 *			pAddr		:	-> to address structure	of RTCP information
 *			addrLen		:	Address length
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Check RRCM.h file for references.
 --------------------------------------------------------------------------*/
 DWORD WINAPI updateRTCPDestinationAddress (HANDLE hRTPSess,
	 										 PSOCKADDR pRtcpAddr,
											 int addrLen)	
	{
	PRTP_SESSION	pRTPSession = (PRTP_SESSION) hRTPSess;
	PRTCP_SESSION	pRTCPses;

#ifdef ENABLE_ISDM2
	PSSRC_ENTRY		pSSRC;
#endif
	
	IN_OUT_STR ("RTP : Enter updateRTCPDestinationAddress()\n");

	if (pRTPSession == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit updateRTCPDestinationAddress()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
		}

	// get the RTCP session
	pRTCPses = pRTPSession->pRTCPSession;
	if (pRTCPses == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTCP session", 0,
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit updateRTCPDestinationAddress()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
		}

	if (!(pRTCPses->dwSessionStatus & RTCP_DEST_LEARNED))
		{
		pRTCPses->dwSessionStatus |= RTCP_DEST_LEARNED;
		pRTCPses->toLen = addrLen;
		memcpy (&pRTCPses->toBfr, pRtcpAddr, addrLen);

		// register our Xmt SSRC - Rcvd one will be found later
#ifdef ENABLE_ISDM2
		if (Isdm2.hISDMdll)
			{
			pSSRC = (PSSRC_ENTRY)pRTCPses->XmtSSRCList.prev;
			if (pSSRC != NULL)
				registerSessionToISDM (pSSRC, pRTCPses, &Isdm2);
			}
#endif
		}

	IN_OUT_STR ("RTP : Exit updateRTCPDestinationAddress()\n");

	return RRCM_NoError;
	}


/*---------------------------------------------------------------------------
 * Function   : updateSSRCentry
 * Description: The application updates some of the SSRC information
 *				
 * Input :	RTPsd		:	RTP socket descriptor
 *			updateType	:	Type of update desired
 *			updateInfo	:	Update information
 *			misc		:	Miscelleanous information
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Check RRCM.h file for references.
 --------------------------------------------------------------------------*/
 HRESULT WINAPI updateSSRCentry ( HANDLE hRTPSess,
 								  SOCKET RTPsd,
								  DWORD updateType,
	 						      DWORD_PTR updateInfo,
								  DWORD_PTR misc)	
	{
	PRTP_SESSION	pRTPSession = (PRTP_SESSION) hRTPSess;
	PRTCP_SESSION	pRTCPses;
	PSSRC_ENTRY		pSSRC;
	PLINK_LIST		pTmp;
	PSDES_DATA		pSdes;
	
	IN_OUT_STR ("RTP : Enter updateRTCPSdes ()\n");

	if (pRTPSession == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit updateRTCPSdes ()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
		}

	// get the RTCP session
	pRTCPses = pRTPSession->pRTCPSession;
	if (pRTCPses == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTCP session", 0,
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit updateRTCPSdes ()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
		}

	// search for the socket descriptor (unique per session)
	// walk through the list from the tail
	pTmp = (PLINK_LIST)pRTCPses->XmtSSRCList.prev;

	while (pTmp)
		{
		if (((PSSRC_ENTRY)pTmp)->RTPsd == RTPsd)
			{
			// lock access to this entry
			EnterCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);

			pSSRC = (PSSRC_ENTRY)pTmp;

			switch (updateType)
				{
				case RRCM_UPDATE_SDES:
					// update the SDES
					pSdes = (PSDES_DATA)updateInfo;

					switch (pSdes->dwSdesType)
						{
						case RTCP_SDES_CNAME:
							pSSRC->cnameInfo.dwSdesLength = pSdes->dwSdesLength;
							memcpy (pSSRC->cnameInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->cnameInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->cnameInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_NAME:
							pSSRC->nameInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->nameInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->nameInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->nameInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_EMAIL:
							pSSRC->emailInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->emailInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->emailInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->emailInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_PHONE:
							pSSRC->phoneInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->phoneInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->phoneInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->phoneInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_LOC:
							pSSRC->locInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->locInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->locInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->locInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_TOOL:
							pSSRC->toolInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->toolInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->toolInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->toolInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_TXT:
							pSSRC->txtInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->txtInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->txtInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->txtInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_PRIV:
							pSSRC->privInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->privInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->privInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->privInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;
						}
					break;

				case RRCM_UPDATE_STREAM_FREQUENCY:
					// upate the stream clocking frequency
					pSSRC->dwStreamClock = (DWORD)updateInfo;
					break;

				case RRCM_UPDATE_RTCP_STREAM_MIN_BW:
					// upate the stream clocking frequency
					pSSRC->xmtInfo.dwRtcpStreamMinBW = (DWORD)updateInfo;
					break;

				case RRCM_UPDATE_CALLBACK:
					// update the callback information
					EnterCriticalSection (&pRTCPses->critSect);
					pRTCPses->pRRCMcallback      = (PRRCM_EVENT_CALLBACK)updateInfo;
					pRTCPses->dwCallbackUserInfo = misc;
					LeaveCriticalSection (&pRTCPses->critSect);
					break;
				}

			// unlock access to this entry
			LeaveCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);
			}

		pTmp = pTmp->next;
		}	


	IN_OUT_STR ("RTP : Exit updateRTCPSdes ()\n");

	return RRCM_NoError;
	}



/*---------------------------------------------------------------------------
 * Function   : RRCMnotification
 * Description: Notify the application that one of the RTP/RTCP events that
 *				we keep track of has occured.
 *
 * Input :	RRCMevent	:	RRCM event to report
 *			pSSRC		:	-> to the SSRC entry
 *			ssrc		:	SSRC which generated the event
 *			misc		:	Miscelleanous value
 *
 * Return:	OK: RRCM_NoError
 --------------------------------------------------------------------------*/
 void RRCMnotification (RRCM_EVENT_T RRCMevent,
						PSSRC_ENTRY pSSRC,
						DWORD dwSSRC,
						DWORD misc)
	{
	IN_OUT_STR ("RRCM: Enter RRCMnotification()\n");		

	// check to see if the application is interested by the RRCM event
	if (pSSRC->pRTCPses->pRRCMcallback == NULL)				
		return;

	switch (RRCMevent)
		{
		case RRCM_NEW_SOURCE_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, misc,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_LOCAL_COLLISION_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, pSSRC->SSRC, dwSSRC,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_REMOTE_COLLISION_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, 0,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_RECV_RTCP_SNDR_REPORT_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, pSSRC->RTCPsd,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_RECV_RTCP_RECV_REPORT_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, pSSRC->RTCPsd,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_TIMEOUT_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, 0,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_BYE_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, 0,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_RTCP_WS_RCV_ERROR:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, misc,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_RTCP_WS_XMT_ERROR:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, misc,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		default:
			break;
		}

	IN_OUT_STR ("RRCM: Exit RRCMnotification()\n");
	}



/*----------------------------------------------------------------------------
 * Function   : registerSessionToISDM
 * Description: Register an RTP/RTCP session with ISDM
 *
 * Input :      pSSRC	:	-> to the SSRC's entry
 *				pRTCP	:	-> to the RTCP session's information
 *				pIsdm	:	-> to the ISDM information
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
#ifdef ENABLE_ISDM2

#define SESSION_BFR_SIZE	30
void registerSessionToISDM (PSSRC_ENTRY pSSRC,
							PRTCP_SESSION pRTCPses,
							PISDM2 pIsdm2)
	{
	struct sockaddr_in	*pSSRCadr;
	unsigned short		port;
	unsigned long		netAddr;
	CHAR				SsrcBfr[10];
	CHAR				sessionBfr[SESSION_BFR_SIZE];
	unsigned char		*ptr;
	int					num;
	HRESULT				hError;
	ISDM2_ENTRY			Isdm2Stat;

	// get the destination address as the session identifier
	pSSRCadr = (struct sockaddr_in *)&pRTCPses->toBfr;
	RRCMws.htons (pSSRC->RTPsd, pSSRCadr->sin_port, &port);
	netAddr  = pSSRCadr->sin_addr.S_un.S_addr;

	ptr = (unsigned char *)&netAddr;
	memset (sessionBfr, 0x00, SESSION_BFR_SIZE);

	num = (int)*ptr++;
	RRCMitoa (num, sessionBfr, 10);
	strcat (sessionBfr, ".");
	num = (int)*ptr++;
	RRCMitoa (num, (sessionBfr + strlen(sessionBfr)), 10);
	strcat (sessionBfr, ".");
	num = (int)*ptr++;
	RRCMitoa (num, (sessionBfr + strlen(sessionBfr)), 10);
	strcat (sessionBfr, ".");
	num = (int)*ptr;
	RRCMitoa (num, (sessionBfr + strlen(sessionBfr)), 10);
	strcat (sessionBfr, ".");
	RRCMitoa (port, (sessionBfr + strlen(sessionBfr)), 10);

	// get the SSRC
	RRCMultoa (pSSRC->SSRC, SsrcBfr, 16);

	// register the session
	if (pRTCPses->hSessKey == NULL)
		{
		hError = Isdm2.ISDMEntry.ISD_CreateKey (hRRCMRootKey,
												sessionBfr,
												&pRTCPses->hSessKey);
		if(FAILED(hError))
			RRCM_DBG_MSG ("RTP: ISD_CreateKey Failed",0, NULL, 0, DBG_NOTIFY);
			
		}

	memset(&Isdm2Stat, 0x00, sizeof(ISDM2_ENTRY));

	hError = Isdm2.ISDMEntry.ISD_CreateValue (pRTCPses->hSessKey,
											  SsrcBfr,
											  BINARY_VALUE,
											  (BYTE *)&Isdm2Stat,
											  sizeof(ISDM2_ENTRY),
											  &pSSRC->hISDM);
	if(FAILED(hError))
		RRCM_DBG_MSG ("RTP: ISD_CreateValue Failed",0, NULL, 0, DBG_NOTIFY);				
	}


/*----------------------------------------------------------------------------
 * Function   : udpateISDMsta
 * Description: Update an ISDM data structure
 *
 * Input :      pSSRC	:	-> to the SSRC's entry
 *				pIsdm	:	-> to the ISDM entry
 *				flag	:	Sender/Receive flag
 *				LocalFB :	do or dont't update the local feedback
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
void updateISDMstat (PSSRC_ENTRY pSSRC,
					 PISDM2 pIsdm2,
					 DWORD flag,
					 BOOL LocalFB)
	{
	DWORD			curTime = timeGetTime();
	DWORD			dwTmp;
	DWORD			dwValue;
	ISDM2_ENTRY		Isdm2Stat;
	HRESULT			hError;

	unsigned short	idx = 0;
	
	EnterCriticalSection (&pIsdm2->critSect);
	
	Isdm2Stat.SSRC = pSSRC->SSRC;
	Isdm2Stat.PayLoadType = pSSRC->PayLoadType;

	if (flag == RECVR)
		{
		Isdm2Stat.dwSSRCStatus = RECVR;
		Isdm2Stat.rcvInfo.dwNumPcktRcvd = pSSRC->rcvInfo.dwNumPcktRcvd;
		Isdm2Stat.rcvInfo.dwPrvNumPcktRcvd = pSSRC->rcvInfo.dwPrvNumPcktRcvd;
		Isdm2Stat.rcvInfo.dwExpectedPrior  = pSSRC->rcvInfo.dwExpectedPrior;
		Isdm2Stat.rcvInfo.dwNumBytesRcvd   = pSSRC->rcvInfo.dwNumBytesRcvd;
		Isdm2Stat.rcvInfo.dwBaseRcvSeqNum  = pSSRC->rcvInfo.dwBaseRcvSeqNum;
		Isdm2Stat.rcvInfo.dwBadSeqNum      = pSSRC->rcvInfo.dwBadSeqNum;
		Isdm2Stat.rcvInfo.dwProbation      = pSSRC->rcvInfo.dwProbation;
		Isdm2Stat.rcvInfo.dwPropagationTime= pSSRC->rcvInfo.dwPropagationTime;
		Isdm2Stat.rcvInfo.interJitter      = pSSRC->rcvInfo.interJitter;
		Isdm2Stat.rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd =
			pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd;
		}
	else // (flag == ISDM_UPDATE_XMTSTAT)
		{
		Isdm2Stat.dwSSRCStatus = XMITR;

		Isdm2Stat.xmitinfo.dwNumPcktSent  = pSSRC->xmtInfo.dwNumPcktSent;
		Isdm2Stat.xmitinfo.dwNumBytesSent = pSSRC->xmtInfo.dwNumBytesSent;
		Isdm2Stat.xmitinfo.dwNTPmsw		  = pSSRC->xmtInfo.dwNTPmsw;
		Isdm2Stat.xmitinfo.dwNTPlsw		  = pSSRC->xmtInfo.dwNTPlsw;
		Isdm2Stat.xmitinfo.dwRTPts		  = pSSRC->xmtInfo.dwRTPts;
		Isdm2Stat.xmitinfo.dwCurXmtSeqNum = pSSRC->xmtInfo.dwCurXmtSeqNum;
		Isdm2Stat.xmitinfo.dwPrvXmtSeqNum = pSSRC->xmtInfo.dwPrvXmtSeqNum;
		Isdm2Stat.xmitinfo.sessionBW	  = pSSRC->xmtInfo.dwRtcpStreamMinBW;
		Isdm2Stat.xmitinfo.dwLastSR       = pSSRC->xmtInfo.dwLastSR;
		Isdm2Stat.xmitinfo.dwLastSRLocalTime =
			pSSRC->xmtInfo.dwLastSRLocalTime;
		Isdm2Stat.xmitinfo.dwLastSendRTPSystemTime =
			pSSRC->xmtInfo.dwLastSendRTPSystemTime;
		Isdm2Stat.xmitinfo.dwLastSendRTPTimeStamp =
			pSSRC->xmtInfo.dwLastSendRTPTimeStamp;
		}

	if(LocalFB)
		{
		memcpy(&Isdm2Stat.rrFeedback, &pSSRC->rrFeedback, sizeof(RTCP_FEEDBACK));
		}
	else
		{
		Isdm2Stat.rrFeedback.SSRC = pSSRC->rrFeedback.SSRC;
#ifdef ENABLE_FLOATING_POINT
		Isdm2Stat.rrFeedback.dwInterJitter = pSSRC->rcvInfo.interJitter;
#else
		// Check RFC for details of the round off
		Isdm2Stat.rrFeedback.dwInterJitter = pSSRC->rcvInfo.interJitter >> 4;
#endif
		Isdm2Stat.rrFeedback.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd =
			pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd;

		// fraction/cumulative number lost are in network order
		dwTmp = getSSRCpcktLoss (pSSRC, FALSE);
		Isdm2Stat.rrFeedback.fractionLost = (dwTmp & 0xFF);
		RRCMws.ntohl (pSSRC->RTPsd, dwTmp, &dwValue);
		Isdm2Stat.rrFeedback.cumNumPcktLost = (dwValue & 0x00FFFFFF);
		
		Isdm2Stat.rrFeedback.dwLastRcvRpt = pSSRC->rrFeedback.dwLastRcvRpt;
		Isdm2Stat.rrFeedback.dwLastSR = pSSRC->xmtInfo.dwLastSR;
		Isdm2Stat.rrFeedback.dwDelaySinceLastSR = getDLSR (pSSRC);
		}

	Isdm2Stat.dwLastReportRcvdTime = pSSRC->dwLastReportRcvdTime;

	memcpy(&Isdm2Stat.cnameInfo, &pSSRC->cnameInfo, sizeof(SDES_DATA));
	memcpy(&Isdm2Stat.nameInfo, &pSSRC->nameInfo, sizeof(SDES_DATA));
	memcpy(&Isdm2Stat.from, &pSSRC->from, sizeof(SOCKADDR));

	Isdm2Stat.fromLen = pSSRC->fromLen;
	Isdm2Stat.dwNumRptSent = pSSRC->dwNumRptSent;
	Isdm2Stat.dwNumRptRcvd = pSSRC->dwNumRptRcvd;
	Isdm2Stat.dwNumXmtIoPending = pSSRC->dwNumXmtIoPending;
	Isdm2Stat.dwStreamClock = pSSRC->dwStreamClock;

	hError = Isdm2.ISDMEntry.ISD_SetValue (NULL,
										   pSSRC->hISDM,
										   NULL,
										   BINARY_VALUE,
										   (BYTE *)&Isdm2Stat,
										   sizeof(ISDM2_ENTRY));
	
	if(FAILED(hError))
		RRCM_DBG_MSG ("RTP: ISD_SetValue Failed",0, NULL, 0, DBG_NOTIFY);				

	LeaveCriticalSection (&pIsdm2->critSect);

	}
#endif // #ifdef ENABLE_ISDM2


/*---------------------------------------------------------------------------
 * Function   : RRCMdebugMsg
 * Description: Output RRCM debug messages
 *
 * Input :      pMsg:		-> to message
 *				err:		Error code
 *				pFile:		-> to file where the error occured
 *				line:		Line number where the error occured
 *
 * Return:		None
 --------------------------------------------------------------------------*/
 void RRCMdebugMsg (PCHAR pMsg,
				    DWORD err,
				    PCHAR pFile,
				    DWORD line,
					DWORD type)
	{
#ifdef ISRDBG
	wsprintf (debug_string, "%s", pMsg);
	if (err)
		wsprintf (debug_string+strlen(debug_string), " Error:%d", err);
	if (pFile != NULL)
		wsprintf (debug_string+strlen(debug_string), " - %s, line:%d",
					pFile, line);
	switch (type)
		{
		case DBG_NOTIFY:
			ISRNOTIFY(ghISRInst, debug_string, 0);
			break;
		case DBG_TRACE:
			ISRTRACE(ghISRInst, debug_string, 0);
			break;
		case DBG_ERROR:
			ISRERROR(ghISRInst, debug_string, 0);
			break;
		case DBG_WARNING:
			ISRWARNING(ghISRInst, debug_string, 0);
			break;
		case DBG_TEMP:
			ISRTEMP(ghISRInst, debug_string, 0);
			break;
		case DBG_CRITICAL:
			ISRCRITICAL(ghISRInst, debug_string, 0);
			break;
		default:
			break;
		}
#elif DEBUG
extern HDBGZONE  ghDbgZoneRRCM ;
	lstrcpyn(debug_string, pMsg, DBG_STRING_LEN);
	if (err)
		wsprintf (debug_string+strlen(debug_string), " Error:%d", err);
	if (pFile != NULL)
		wsprintf (debug_string+strlen(debug_string), " - %s, line:%d",
					pFile, line);
	
	switch (type)
		{
		case DBG_NOTIFY:
		case DBG_TRACE:
		case DBG_WARNING:
		case DBG_TEMP:
			DBGMSG(ghDbgZoneRRCM,0,(debug_string)); // Trace Zone
			break;
		case DBG_ERROR:
		case DBG_CRITICAL:
			DBGMSG(ghDbgZoneRRCM,1,(debug_string));	// Error Zone
			break;
		default:
			break;
		}

#endif
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\rrcmcrt.cpp ===
/*----------------------------------------------------------------------------
 * File:        RRCMCRT.C
 * Product:     RTP/RTCP implementation.
 * Description: Provides Microsoft 'C' run-time support
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"

 
/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
#ifdef _DEBUG
extern char		debug_string[];
#endif


/*--------------------------------------------------------------------------
 * Function   : RRCMsrand
 * Description: Seeds the random number generator with the int given.  
 *				Adapted from the BASIC random number generator.
 *
 * WARNING:		There is no per thread seed. All threads of the process are
 *				using the same seed.
 *
 * Input :	seed:	Seed
 *			
 *
 * Return: None
 --------------------------------------------------------------------------*/

static long holdrand = 1L;

void RRCMsrand (unsigned int seed)
	{
	holdrand = (long)seed;
	}
 

/*--------------------------------------------------------------------------
 * Function   : RRCMrand
 * Description: Returns a pseudo-random number 0 through 32767.
 *
 * WARNING:		There is no per thread number. All threads of the process 
 *				share the random number
 *
 * Input :	None
 *			
 * Return:	Pseudo-random number 0 through 32767.
 --------------------------------------------------------------------------*/
int RRCMrand (void)
	{
	return(((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff);
	}



/***
*char *_itoa, *_ltoa, *_ultoa(val, buf, radix) - convert binary int to ASCII
*       string
*
*Purpose:
*       Converts an int to a character string.
*
*Entry:
*       val - number to be converted (int, long or unsigned long)
*       int radix - base to convert into
*       char *buf - ptr to buffer to place result
*
*Exit:
*       fills in space pointed to by buf with string result
*       returns a pointer to this buffer
*
*Exceptions:
*
*******************************************************************************/

/* helper routine that does the main job. */

static void RRCMxtoa (unsigned long val,
					  char *buf,
					  unsigned radix,
					  int is_neg)
	{
	char		*p;                /* pointer to traverse string */
	char		*firstdig;         /* pointer to first digit */
	char		temp;              /* temp char */
	unsigned	digval;        /* value of digit */

	p = buf;

	if (is_neg) {
		/* negative, so output '-' and negate */
		*p++ = '-';
		val = (unsigned long)(-(long)val);
	}

	firstdig = p;           /* save pointer to first digit */

	do {
		digval = (unsigned) (val % radix);
		val /= radix;   /* get next digit */

		/* convert to ascii and store */
		if (digval > 9)
			*p++ = (char) (digval - 10 + 'a');      /* a letter */
		else
			*p++ = (char) (digval + '0');           /* a digit */
		} while (val > 0);

	/* We now have the digit of the number in the buffer, but in reverse
	   order. Thus we reverse them now. */

	*p-- = '\0';            /* terminate string; p points to last digit */

	do {
		temp = *p;
		*p = *firstdig;
		*firstdig = temp;       /* swap *p and *firstdig */
		--p;
		++firstdig;             /* advance to next two digits */
		} while (firstdig < p); /* repeat until halfway */
	}


/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

char *RRCMitoa (int val, char *buf, int radix)
	{
	if (radix == 10 && val < 0)
		RRCMxtoa((unsigned long)val, buf, radix, 1);
	else
		RRCMxtoa((unsigned long)(unsigned int)val, buf, radix, 0);
	return buf;
	}


char *RRCMltoa (long val, char *buf, int radix)
	{
	RRCMxtoa((unsigned long)val, buf, radix, (radix == 10 && val < 0));
	return buf;
	}


char *RRCMultoa (unsigned long val, char *buf, int radix)
	{
	RRCMxtoa(val, buf, radix, 0);
	return buf;
	}



// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\rtpsess.cpp ===
// RTPSink.cpp : Implementation of CRTPSession
#include "stdafx.h"
#include <qossp.h>
#include "irtp.h"
#include "rtp.h"
#include "RTPSess.h"
//#include "rtpsink.h"
//#include "RTPMS.h"
//#include "RTPSamp.h"
#include "thread.h"
#include <rrcm.h>

#define DEFAULT_RTPBUF_SIZE 1500

#define IPPORT_FIRST_DYNAMIC	49152
#define IPPORT_FIRST_DYNAMIC_END	(IPPORT_FIRST_DYNAMIC + 200)
#define IPPORT_FIRST_DYNAMIC_BEGIN	(IPPORT_FIRST_DYNAMIC_END + 256)

// Port number allocation starts at IPPORT_FIRST_DYNAMIC_BEGIN.
// Everytime a port number is allocated we decrease g_alport, until
// we reach IPPORT_FIRST_DYNAMIC_END. We then reset it back to its
// original value (IPPORT_FIRST_DYNAMIC_BEGIN) and start this process
// all over again. This way we will avoid reusing the same port
// numbers between sessions.
u_short g_alport = IPPORT_FIRST_DYNAMIC_BEGIN;
void __cdecl RRCMNotification(int,DWORD_PTR,DWORD_PTR,DWORD_PTR);



#define IsMulticast(p) ((p->sin_addr.S_un.S_un_b.s_b1 & 0xF0) == 0xE0)


BOOL CRTP::m_WSInitialized = 0;



STDMETHODIMP CRTP::OpenSession(
			UINT sessionId,	// client specified unique identifier for the session
			DWORD flags,	// SESSIONF_SEND, SESSIONF_RECV, SESSIONF_MULTICAST etc.
			BYTE *localAddr,
			UINT cbAddr,
			IRTPSession **ppIRTP) // [output] pointer to RTPSession
{
	// the session is named by the sessionId

	CRTPSession *pRTPSess ;
	HRESULT hr= E_FAIL;
	UINT mediaId = flags & (SESSIONF_AUDIO | SESSIONF_VIDEO);

	EnterCriticalSection(&g_CritSect);
	for (pRTPSess=  CRTPSession::m_pSessFirst; pRTPSess; pRTPSess = pRTPSess->m_pSessNext ) {
// check for existing session of the same media type
// if the sessionId is not zero, also check for matching session id
		if (sessionId == pRTPSess->m_sessionId)
			if (mediaId == pRTPSess->m_mediaId)
			break;
// if the local address or remote address is not NULL, search for an exising RTP session bound to
// the same address
// TODO	
			
	}

	if (!pRTPSess)
	{
		if (!(flags & SESSIONF_EXISTING)) {
			// create the session
			ObjRTPSession *pObj;
			DEBUGMSG(ZONE_DP,("Creating new RTP session\n"));
			hr = ObjRTPSession::CreateInstance(&pObj);
			if (hr == S_OK) {
				pRTPSess = pObj;	// pointer conversion
				hr = pRTPSess->Initialize(sessionId, mediaId,localAddr,cbAddr);
				if (hr != S_OK)
					delete pObj;
			}
		}
		else
			hr = E_FAIL;	// matching session does not exist
		
	} else {
		DEBUGMSG(ZONE_DP,("Reusing RTP session\n"));
		hr = S_OK;
	}
	if (hr == S_OK) {
		hr = ((IRTPSession *)pRTPSess)->QueryInterface(IID_IRTPSession,(void **) ppIRTP);
		
	}
	LeaveCriticalSection(&g_CritSect);
	return hr;
}


CRTPSession *CRTPSession::m_pSessFirst = NULL;
/////////////////////////////////////////////////////////////////////////////
// CRTPSession

CRTPSession::CRTPSession()
:  m_hRTPSession(NULL), m_uMaxPacketSize(1500),m_nBufsPosted(0),m_pRTPCallback(NULL),
	m_fSendingSync(FALSE)
{
	ZeroMemory(&m_sOverlapped,sizeof(m_sOverlapped));
	ZeroMemory(&m_ss, sizeof(m_ss));
	ZeroMemory(&m_rs, sizeof(m_rs));
	m_sOverlapped.hEvent = (WSAEVENT)this;
}

/*
HRESULT CRTPSession::GetLocalAddress(
            unsigned char *sockaddr,
            UINT  *paddrlen)
{
	if (m_pRTPSess && *paddrlen >= sizeof(SOCKADDR_IN))
	{
		*paddrlen = sizeof(SOCKADDR_IN);
		CopyMemory(sockaddr, m_pRTPSess->GetLocalAddress(), *paddrlen);
	}
}
*/
HRESULT
CRTPSession::FinalRelease()
{

	CRTPPacket1 *pRTPPacket;
	// remove myself from the session list
	EnterCriticalSection(&g_CritSect);
	if (m_pSessFirst == this)
		m_pSessFirst = m_pSessNext;
	else {
		CRTPSession *pRTPSess = m_pSessFirst;
		while (pRTPSess && pRTPSess->m_pSessNext != this) {
			pRTPSess = pRTPSess->m_pSessNext;
		}
		if (pRTPSess)
			pRTPSess->m_pSessNext = m_pSessNext;
	}
	LeaveCriticalSection(&g_CritSect);

	if (m_rtpsock) {
		delete m_rtpsock;
		m_rtpsock = NULL;
	}
	// BUGBUG: in case the buffers have not been canceled yet (an error case),
	// they should complete now with WSA_OPERATION_ABORTED
	// or WSAEINTR. This happens in the context of the RecvThread
	if (m_nBufsPosted != 0)
		Sleep(500);		// time for APCs to be processed in RecvThread
		
	// close the RTP session. Also ask RRCM to close the rtcp socket if its WS2
	// because that is a more reliable way of cleaning up overlapped recvs than
	// sending loopback packets.
	CloseRTPSession (m_hRTPSession, NULL,  TRUE );
	
	if (m_rtcpsock) {
		delete m_rtcpsock;
		m_rtcpsock = NULL;
	}
	m_hRTPSession = 0;
	// free receive buffers
	while (m_FreePkts.Get(&pRTPPacket))
	{
		delete pRTPPacket;
	}

			
	return S_OK;
}



HRESULT CRTPSession::CreateRecvRTPStream(DWORD ssrc, IRTPRecv **ppIRTPRecv)
{
	HRESULT hr;
	Lock();
	if (ssrc != 0)
		return E_NOTIMPL;

#if 0
	ObjRTPRecvSource *pRecvS;
	hr = ObjRTPMediaStream::CreateInstance(&pMS);

	if (SUCCEEDED(hr))
	{
		pMS->AddRef();
		pMS->Init(this, m_mediaId);
		hr = pMS->QueryInterface(IID_IRTPMediaStream, (void**)ppIRTPMediaStream);
		pMS->Release();
	}
#else
	*ppIRTPRecv = this;
	(*ppIRTPRecv)->AddRef();
	hr = S_OK;
#endif
	Unlock();
	return hr;
}



ULONG GetRandom()
{
	return GetTickCount();
}

HRESULT CRTPSession::Initialize(UINT sessionId, UINT mediaId, BYTE *pLocalAddr, UINT cbAddr)
{
	DWORD		APIstatus;
	HRESULT		hr = E_OUTOFMEMORY;
	char		tmpBfr[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD		tmpBfrLen = sizeof(tmpBfr);
	SDES_DATA	sdesInfo[3];
	ENCRYPT_INFO encryptInfo;
	SOCKADDR_IN *pSockAddr;


	m_sessionId = sessionId;
	m_mediaId = mediaId;
	m_rtpsock	= new UDPSOCKET();
	m_rtcpsock  = new UDPSOCKET();

	if (!m_rtpsock || !m_rtcpsock)
		goto ERROR_EXIT;

	
	if(!m_rtpsock->NewSock() || !m_rtcpsock->NewSock())
	{
		goto ERROR_EXIT;
	}
	
	// if the local address is specified do a bind on the sockets
	if (pLocalAddr) {
		//  setup both channels for the current local address
		hr = SetLocalAddress(pLocalAddr,cbAddr);

		if (hr != S_OK)
			goto ERROR_EXIT;
	}
/*
	// if the remote address is specified make a note of it
	SetRemoteAddresses(pChanDesc->pRemoteAddr, pChanDesc->pRemoteRTCPAddr);
*/
	// init send state
	memset (&m_ss.sendStats,0,sizeof(m_ss.sendStats));
	// init RTP send header
	// time stamp and marker bit have to specified per packet
	m_ss.hdr.p = 0;		// no padding needed
	m_ss.hdr.x = 0;		// no extensions
	m_ss.hdr.cc = 0;		// no contributing sources
	m_ss.hdr.seq = (WORD)GetRandom();
	

	m_clockRate = (m_mediaId == SESSIONF_VIDEO ? 90000 : 8000);	// typically 8KHz for audio
	m_ss.hdr.pt = 0;
	

	// Initialize list of overlapped structs
	
	// build a Cname
	memcpy(tmpBfr,"CName",6);
	GetComputerName(tmpBfr,&tmpBfrLen);

	// build the SDES information
	sdesInfo[0].dwSdesType = 1;
	memcpy (sdesInfo[0].sdesBfr, tmpBfr, strlen(tmpBfr)+1);
	sdesInfo[0].dwSdesLength = strlen(sdesInfo[0].sdesBfr);
	sdesInfo[0].dwSdesFrequency = 100;
	sdesInfo[0].dwSdesEncrypted = 0;

	// Build a Name
	tmpBfrLen = sizeof(tmpBfr);
	memcpy(tmpBfr,"UserName",9);
	GetUserName(tmpBfr,&tmpBfrLen);
	sdesInfo[1].dwSdesType = 2;
	memcpy (sdesInfo[1].sdesBfr, tmpBfr, strlen(tmpBfr)+1);
	sdesInfo[1].dwSdesLength = strlen(sdesInfo[1].sdesBfr);
	sdesInfo[1].dwSdesFrequency = 25;
	sdesInfo[1].dwSdesEncrypted = 0;

	// end of SDES list
	sdesInfo[2].dwSdesType = 0;

	pSockAddr = m_rtcpsock->GetRemoteAddress();
#ifdef DEBUG
	if (pSockAddr->sin_addr.s_addr == INADDR_ANY)
		DEBUGMSG(ZONE_DP,("Null dest RTCP addr\n"));
#endif

	// Create the RTP/RTCP session
	
	m_hRTPSession = CreateRTPSession(
									 (m_rtpsock->GetSock()),
									 (m_rtcpsock->GetSock()),
								     (LPVOID)pSockAddr,
								     (pSockAddr->sin_addr.s_addr == INADDR_ANY)? 0 : sizeof(SOCKADDR_IN),
								     sdesInfo,
								     (DWORD)m_clockRate,
								     &encryptInfo,
								     0,
								     (PRRCM_EVENT_CALLBACK)RRCMNotification,		// callback function
									 (DWORD_PTR) this,			// callback info
								     RTCP_ON|H323_CONFERENCE,
									 0, //rtp session bandwidth
								     &APIstatus);
	
	if (m_hRTPSession == NULL)
		{
			DEBUGMSG(ZONE_DP,("Couldnt create RRCM session\n"));
			hr = GetLastError();
			goto ERROR_EXIT;
		}

      	m_Qos.SendingFlowspec.ServiceType = SERVICETYPE_NOTRAFFIC;
  		m_Qos.SendingFlowspec.TokenRate = QOS_NOT_SPECIFIED;
       	m_Qos.SendingFlowspec.TokenBucketSize = QOS_NOT_SPECIFIED;
  		m_Qos.SendingFlowspec.PeakBandwidth = QOS_NOT_SPECIFIED;
    	m_Qos.SendingFlowspec.Latency = QOS_NOT_SPECIFIED;
    	m_Qos.SendingFlowspec.DelayVariation = QOS_NOT_SPECIFIED;
    	m_Qos.SendingFlowspec.MaxSduSize = QOS_NOT_SPECIFIED;
    	m_Qos.ReceivingFlowspec = m_Qos.SendingFlowspec;
    	m_Qos.ProviderSpecific.buf = NULL;
    	m_Qos.ProviderSpecific.len = 0;
    	

	// insert RTPSession in global list
	m_pSessNext = m_pSessFirst;
	m_pSessFirst = this;
	
	return S_OK;
	
ERROR_EXIT:
	if (m_rtpsock)
	{
		delete m_rtpsock;
		m_rtpsock = NULL;
	}
	if (m_rtcpsock)
	{
		delete m_rtcpsock;
		m_rtcpsock = NULL;
	}

	return hr;

}



BOOL CRTPSession::SelectPorts()
{

	// try port pairs in the dynamic range ( > 49152)
	if (g_alport <= IPPORT_FIRST_DYNAMIC_END)
		g_alport = IPPORT_FIRST_DYNAMIC_BEGIN;



	for (;g_alport >= IPPORT_FIRST_DYNAMIC;)
	{
	    m_rtpsock->SetLocalPort(g_alport);
	
	    if (m_rtpsock->BindMe() == 0)
	    {
	        /* it worked for the data, try the adjacent port for control*/
	        ++g_alport;

			m_rtcpsock->SetLocalPort(g_alport);
			if (m_rtcpsock->BindMe() == 0)
			{
				g_alport-=3;
				return TRUE;
			}
			else	// start over at the previous even numbered port
			{
				if( WSAGetLastError() != WSAEADDRINUSE)
				{
	    			DEBUGMSG(ZONE_DP,("ObjRTPSession::SelectPorts failed with error %d\n",WSAGetLastError()));
					goto ERROR_EXIT;
				}
				m_rtpsock->Cleanup();
				if(!m_rtpsock->NewSock())
				{
					ASSERT(0);
					return FALSE;
				}
	        	g_alport-=3;	
	        	continue;
	        }

	    }
	    if (WSAGetLastError() != WSAEADDRINUSE)
	    {
	    	DEBUGMSG(ZONE_DP,("ObjRTPSession::SelectPorts failed with error %d\n",WSAGetLastError()));
	       goto ERROR_EXIT;
	    }
	    g_alport-=2; // try the next lower even numbered port
	}
	
ERROR_EXIT:
	m_rtcpsock->SetLocalPort(0);
	m_rtpsock->SetLocalPort(0);
	return FALSE;
}

STDMETHODIMP CRTPSession::SetLocalAddress(BYTE *pbAddr, UINT cbAddr)
{
	HRESULT hr;
	SOCKADDR_IN *pAddr = (SOCKADDR_IN *)pbAddr;
	ASSERT(pbAddr);
	
	Lock();
	if ( IsMulticast(pAddr))
		hr = SetMulticastAddress(pAddr);
	else
	if (m_rtpsock->GetLocalAddress()->sin_port != 0)
		hr =  S_OK;	// already bound
	else
	{
		m_rtpsock->SetLocalAddress(pAddr);
		m_rtcpsock->SetLocalAddress(pAddr);
		if (pAddr->sin_port != 0)
		{
			// port already chosen
			m_rtcpsock->SetLocalPort(ntohs(pAddr->sin_port) + 1);
			if (m_rtpsock->BindMe() != 0 ||  m_rtcpsock->BindMe() != 0)
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
				m_rtpsock->SetLocalPort(0);
				m_rtcpsock->SetLocalPort(0);
			}
			else
				hr = S_OK;
		}
		else
		{
			// client wants us to choose the port

			if (SelectPorts()) {
				hr = S_OK;
			}
			else
				hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	Unlock();
	return hr;
}

HRESULT
CRTPSession::SetMulticastAddress(PSOCKADDR_IN pAddr)
{
	SOCKET s ;
	SOCKADDR_IN rtcpAddr = *pAddr;
	s = RRCMws.WSAJoinLeaf( m_rtpsock->GetSock(), (struct sockaddr *)pAddr, sizeof(SOCKADDR_IN), NULL, NULL, NULL, NULL, JL_BOTH);
	if (s == INVALID_SOCKET)
		return E_FAIL;
	else {
		rtcpAddr.sin_port = htons(ntohs(pAddr->sin_port)+1);
		s = RRCMws.WSAJoinLeaf( m_rtcpsock->GetSock(), (struct sockaddr *)&rtcpAddr, sizeof(SOCKADDR_IN), NULL, NULL, NULL, NULL, JL_BOTH);
			
		return S_OK;
	}
}


STDMETHODIMP
CRTPSession::SetRemoteRTPAddress(BYTE *sockaddr, UINT cbAddr)
{
	SOCKADDR_IN *pRTPAddr = (SOCKADDR_IN *)sockaddr;
	Lock();
	
	if (pRTPAddr) {
#ifdef DEBUG
		if (m_rtpsock->GetRemoteAddress()->sin_addr.s_addr != INADDR_ANY
			&& m_rtpsock->GetRemoteAddress()->sin_addr.s_addr != pRTPAddr->sin_addr.s_addr) {
			DEBUGMSG(ZONE_DP,("Changing RTP Session remote address (already set)!\n"));
		}
#endif
		m_rtpsock->SetRemoteAddr(pRTPAddr);
	}

	Unlock();
	return S_OK;
}


STDMETHODIMP
CRTPSession::SetRemoteRTCPAddress(BYTE *sockaddr, UINT cbAddr)
{
	SOCKADDR_IN *pRTCPAddr = (SOCKADDR_IN *)sockaddr;
	
	Lock();
	
	if (pRTCPAddr) {
#ifdef DEBUG
		if (m_rtcpsock->GetRemoteAddress()->sin_addr.s_addr != INADDR_ANY
			&& m_rtcpsock->GetRemoteAddress()->sin_addr.s_addr != pRTCPAddr->sin_addr.s_addr) {
			DEBUGMSG(ZONE_DP,("Changing RTCP Session remote address (already set)!\n"));
		}
#endif
		m_rtcpsock->SetRemoteAddr(pRTCPAddr);
		if (m_hRTPSession)
			updateRTCPDestinationAddress( m_hRTPSession,
			(SOCKADDR *)m_rtcpsock->GetRemoteAddress(), sizeof(SOCKADDR_IN));
	}
	Unlock();
	return S_OK;
}

STDMETHODIMP
CRTPSession::GetLocalAddress(const BYTE **sockaddr, UINT *pcbAddr)
{
	if (sockaddr && pcbAddr)
	{
		Lock();
		*sockaddr = (BYTE *)m_rtpsock->GetLocalAddress();
		*pcbAddr = sizeof(SOCKADDR_IN);
		Unlock();
		return S_OK;
	} else
	{
		return E_INVALIDARG;
	}
}

STDMETHODIMP
CRTPSession::GetRemoteRTPAddress(const BYTE **sockaddr, UINT *pcbAddr)
{
	if (sockaddr && pcbAddr )
	{
		Lock();
		*sockaddr = (BYTE *)m_rtpsock->GetRemoteAddress();
		*pcbAddr = sizeof(SOCKADDR_IN);
		Unlock();
		return S_OK;
	} else
	{
		return E_INVALIDARG;
	}
}

STDMETHODIMP
CRTPSession::GetRemoteRTCPAddress(const BYTE **sockaddr, UINT *pcbAddr)
{
	if (sockaddr && pcbAddr)
	{
		Lock();
		*sockaddr = (BYTE *)m_rtcpsock->GetRemoteAddress();
		*pcbAddr = sizeof(SOCKADDR_IN);
		Unlock();
		return S_OK;
	} else
	{
		return E_INVALIDARG;
	}
}

STDMETHODIMP
CRTPSession::SetSendFlowspec(FLOWSPEC *pFlowspec)
{
	QOS_DESTADDR qosDest;
	DWORD cbRet;
	int optval = pFlowspec->MaxSduSize;
	// Set the RTP socket to not buffer more than one packet
	// This will allow us to influence the packet scheduling.
	if(RRCMws.setsockopt(m_rtpsock->GetSock(),SOL_SOCKET, SO_SNDBUF,(char *)&optval,sizeof(optval)) != 0)
	{
	
		RRCM_DBG_MSG ("setsockopt failed ", GetLastError(),
					  __FILE__, __LINE__, DBG_ERROR);
	}

	if (WSQOSEnabled && m_rtpsock)
	{
    	
		m_Qos.SendingFlowspec = *pFlowspec;
		m_Qos.ProviderSpecific.buf = (char *)&qosDest;	// NULL
		m_Qos.ProviderSpecific.len = sizeof (qosDest);	// 0

		// check to see if the receive flowspec has already been
		// set.  If it has, specify NOCHANGE for the receive service
		// type.  If not, specify NOTRAFFIC.  This is done to circumvent
		// a bug in the Win98 QOS/RSVP layer.

		if (m_Qos.ReceivingFlowspec.TokenRate == QOS_NOT_SPECIFIED)
		{
			m_Qos.ReceivingFlowspec.ServiceType = SERVICETYPE_NOTRAFFIC;
		}
		else
		{
			m_Qos.ReceivingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;
		}

		qosDest.ObjectHdr.ObjectType = QOS_OBJECT_DESTADDR;
		qosDest.ObjectHdr.ObjectLength = sizeof(qosDest);
		qosDest.SocketAddress = (PSOCKADDR)m_rtpsock->GetRemoteAddress();
		qosDest.SocketAddressLength = sizeof(SOCKADDR_IN);
		if (RRCMws.WSAIoctl(m_rtpsock->GetSock(),SIO_SET_QOS, &m_Qos, sizeof(m_Qos), NULL, 0, &cbRet, NULL,NULL) == 0)
			return S_OK;
		else
			return GetLastError();
	} else
		return E_NOTIMPL;
	
}

STDMETHODIMP
CRTPSession::SetRecvFlowspec(FLOWSPEC *pFlowspec)
{

	SOCKADDR_IN *pAddr = NULL;

	DWORD cbRet;
	if (WSQOSEnabled && m_rtpsock)
	{

		pAddr = m_rtpsock->GetRemoteAddress();

		m_Qos.ReceivingFlowspec = *pFlowspec;
		m_Qos.ProviderSpecific.buf = NULL;
		m_Qos.ProviderSpecific.len = 0;

		// check to see if the send flowspec has already been
		// set.  If it has, specify NOCHANGE for the receive service
		// type.  If not, specify NOTRAFFIC.  This is done to circumvent
		// a bug in the Win98 QOS/RSVP layer.

		if (m_Qos.SendingFlowspec.TokenRate == QOS_NOT_SPECIFIED)
		{
			m_Qos.SendingFlowspec.ServiceType = SERVICETYPE_NOTRAFFIC;
		}
		else
		{
			m_Qos.SendingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;
		}
		
		if (RRCMws.WSAIoctl(m_rtpsock->GetSock(),SIO_SET_QOS, &m_Qos, sizeof(m_Qos), NULL, 0, &cbRet, NULL,NULL) == 0)
			return S_OK;
		else
			return GetLastError();
	} else
		return E_NOTIMPL;
}

// set the size used for receive packet buffers
STDMETHODIMP
CRTPSession::SetMaxPacketSize(UINT maxPacketSize)
{
	m_uMaxPacketSize = maxPacketSize;
	return S_OK;
}

HRESULT CRTPSession::SetRecvNotification(
	PRTPRECVCALLBACK pRTPRecvCB,	// pointer to callback function
	DWORD_PTR dwCB,		// callback arg
	UINT nBufs							// suggested number of receives to post
	)
{
	CRTPPacket1 *pRTPPacket;
	if (!m_hRTPSession)
		return E_FAIL;
		
	m_pRTPCallback = pRTPRecvCB;
	m_dwCallback = dwCB;
	
	if (m_nBufsPosted >= nBufs)
		return S_OK;	// packets already posted

	int nBufsToAllocate = nBufs - m_nBufsPosted - m_FreePkts.GetCount();
	// allocate packets if necessary
	while (nBufsToAllocate-- > 0)
	{
		if (pRTPPacket = new CRTPPacket1) {
			if (!SUCCEEDED(pRTPPacket->Init(m_uMaxPacketSize)))
			{
				delete pRTPPacket;
				break;
			}
			m_FreePkts.Put(pRTPPacket);
		}
		else
			break;
	}
	PostRecv();
	return m_nBufsPosted ? S_OK : E_OUTOFMEMORY;		
}

HRESULT
CRTPSession::CancelRecvNotification()
{
	m_pRTPCallback = NULL;
	if (m_rtpsock) {
		struct sockaddr myaddr;
		int myaddrlen = sizeof(myaddr);
		UINT i;
		char buf = 0;
		WSABUF wsabuf;
		DWORD bytesSent;
		UINT nBufsPosted;
		wsabuf.buf = &buf;
		wsabuf.len = 0;
		BOOL fCanceled = FALSE;
		if (RRCMws.getsockname(m_rtpsock->GetSock(),&myaddr,&myaddrlen)== 0) {
		// send  loopback packets (as many as there are recvs outstanding)
		// on this socket to get back our buffers.
		// NOTE: Winsock 2 on Win95 seems to have a bug where we get recv callbacks
		// within sendto() rather than in the subsequent SleepEx, so we
		// have to make a local copy of m_nBufsPosted
			for (i=0, nBufsPosted = m_nBufsPosted;i < nBufsPosted;i++) {
				if (RRCMws.sendTo(m_rtpsock->GetSock(),&wsabuf,1,&bytesSent,0,&myaddr, myaddrlen, NULL, NULL) < 0) {
					DEBUGMSG(ZONE_DP,("CancelRecv: loopback send failed\n"));
					break;
				}
			}
			fCanceled = (i > 0);
		} else {
			DEBUGMSG(ZONE_DP,("RTPState::CancelRecv: getsockname returned %d\n",GetLastError()));
		}
		if (fCanceled)
			while (m_nBufsPosted) {
				DWORD dwStatus;
				dwStatus = SleepEx(200,TRUE);
	    		ASSERT(dwStatus==WAIT_IO_COMPLETION);
				if (dwStatus !=WAIT_IO_COMPLETION)
					break;		// timed out => bail
			}


	}
	return S_OK;
}

HRESULT
CRTPSession::PostRecv()
{
	HRESULT hr;
	DWORD dwError = 0;
	DWORD	dwRcvFlag;
	WSAOVERLAPPED *pOverlapped;
	DWORD nBytesRcvd;
	CRTPPacket1 *pRTPPacket;

	if (!m_hRTPSession || !m_pRTPCallback)
		return E_FAIL;

	// post buffers in the free queue
	while (m_FreePkts.Get(&pRTPPacket))
	{
		pOverlapped = (WSAOVERLAPPED *)(pRTPPacket->GetOverlapped());
		pOverlapped->hEvent = (WSAEVENT) this;

		m_rcvSockAddrLen = sizeof(SOCKADDR);

		dwRcvFlag = 0;
		pRTPPacket->RestoreSize();
		dwError = RRCMws.recvFrom (m_rtpsock->GetSock(),
								pRTPPacket->GetWSABUF(),
	                            1,
								&nBytesRcvd,
								&dwRcvFlag,
								&m_rcvSockAddr,
								&m_rcvSockAddrLen,
								pOverlapped,
								(LPWSAOVERLAPPED_COMPLETION_ROUTINE)WS2RecvCB);
		if (dwError == SOCKET_ERROR) {
			dwError = WSAGetLastError();
			if (dwError != WSA_IO_PENDING) {
				DEBUGMSG(ZONE_DP,("RTP recv error %d\n",dwError));
			//	m_rs.rcvStats.packetErrors++;
				// return the buffer to the free list
				m_FreePkts.Put(pRTPPacket);
				break;
			}
			
		}
		++m_nBufsPosted;
	}
	return m_nBufsPosted ? S_OK : S_FALSE;		
}

HRESULT
CRTPSession::FreePacket(WSABUF *pBuf)
{
	m_FreePkts.Put(CRTPPacket1::GetRTPPacketFromWSABUF(pBuf));
	PostRecv();
	return S_OK;
}

/*----------------------------------------------------------------------------
 * Function: WS2SendCB
 * Description: Winsock callback provided by the application to Winsock
 *
 * Input:
 *
 * Return: None
 *--------------------------------------------------------------------------*/
void CALLBACK WS2SendCB (DWORD dwError,
						 DWORD cbTransferred,
                         LPWSAOVERLAPPED lpOverlapped,
                         DWORD dwFlags)
{
	CRTPSession *pSess;
    //get the RTPSession pointer so that we can mark the
    //IO complete on the object
    pSess= (CRTPSession *)lpOverlapped->hEvent;
	ASSERT (&pSess->m_sOverlapped == lpOverlapped);
	pSess->m_lastSendError = dwError;
    pSess->m_fSendingSync=FALSE;
}

	
void CALLBACK WS2RecvCB (DWORD dwError,
						 DWORD len,
                         LPWSAOVERLAPPED lpOverlapped,
                         DWORD dwFlags)
{

	CRTPSession *pRTP;
	CRTPPacket1 *pRTPPacket;

	DWORD ts, ssrc;
	
	// GEORGEJ: catch Winsock 2 bug (94903) where I get a bogus callback
	// after WSARecv returns WSAEMSGSIZE.
	if (!dwError && ((int) len < 0)) {
		RRCM_DBG_MSG ("RTP : RCV Callback : bad cbTransferred", len,
						  __FILE__, __LINE__, DBG_ERROR);
		return;
	}
	pRTP = (CRTPSession *)lpOverlapped->hEvent;	// cached by PostRecv
	ASSERT(pRTP);
	ASSERT(lpOverlapped);
	ASSERT(pRTP->m_nBufsPosted > 0);
	--pRTP->m_nBufsPosted;	// one recv just completed

	// Winsock 2 sometimes chooses to indicate a buffer-too-small
	// error via the dwFlags parameter.
	if (dwFlags & MSG_PARTIAL)
		dwError = WSAEMSGSIZE;
	
	pRTPPacket = CRTPPacket1::GetRTPPacketFromOverlapped(lpOverlapped);
	if (!dwError)
	{
		// validate RTP header and update receive stats
		dwError = RTPReceiveCheck(
					pRTP->m_hRTPSession,
					pRTP->m_rtpsock->GetSock(),
					pRTPPacket->GetWSABUF()->buf,
					len,
					&pRTP->m_rcvSockAddr,
					pRTP->m_rcvSockAddrLen
					);
	}
	if (!pRTP->m_pRTPCallback)
	{
		// we have stopped doing notifications
		// return the buffer to the free list
		pRTP->FreePacket(pRTPPacket->GetWSABUF());
	}
	else if (!dwError) {
		// call the callback
		//++pRTP->m_nBufsRecvd;
		// convert the RTP header fields to host order
		pRTPPacket->SetTimestamp(ntohl(pRTPPacket->GetTimestamp()));
		pRTPPacket->SetSeq(ntohs(( u_short)pRTPPacket->GetSeq()));
		pRTPPacket->SetActual(len);
		//LOG((LOGMSG_NET_RECVD,pRTPPacket->GetTimestamp(), pRTPPacket->GetSeq(), GetTickCount()));
		if (!pRTP->m_pRTPCallback(pRTP->m_dwCallback, pRTPPacket->GetWSABUF()))
			pRTP->FreePacket(pRTPPacket->GetWSABUF());
	} else {
		// packet error
		// repost the buffer
		pRTP->PostRecv();
	}
}

// the way its defined now, this Send() method is synchronous or asynchronous
// depending on whether pOverlapped is NULL or not
HRESULT CRTPSession::Send(
	WSABUF *pWsabufs,
	UINT nWsabufs,
	WSAOVERLAPPED *pOverlapped,
	LPWSAOVERLAPPED_COMPLETION_ROUTINE pWSAPC )
{
	DWORD   dwError;

	Lock();
	RTP_HDR_T *pHdr = (RTP_HDR_T *)pWsabufs[0].buf;
	// convert RTP header fields to network-order
	pHdr->ts = htonl (pHdr->ts);
	pHdr->seq = htons(pHdr->seq);
	//*pHdr = m_ss.hdr;
	pHdr->seq = htons(++m_ss.hdr.seq);
	// update send stats
	//m_ss.packetsSent++;
	//m_ss.bytesSent += cbBuf-sizeof(RTP_HDR_MIN_LEN);
	//bIOPending=TRUE;	// reset when send completes

	dwError = RTPSendTo (
				  m_hRTPSession,
				  (m_rtpsock->GetSock()),
				  pWsabufs,
				  nWsabufs,
  				  &m_numBytesSend,
  				  0,	
  				  (LPVOID)m_rtpsock->GetRemoteAddress(),
				  sizeof(SOCKADDR),
  				  pOverlapped,
  				  pWSAPC);
	
	if (dwError == SOCKET_ERROR) {
		dwError = WSAGetLastError();
		if (dwError != WSA_IO_PENDING) {
			DEBUGMSG(1, ("RTPSendTo error %d\n",dwError));
			m_lastSendError = dwError;
			m_ss.sendStats.packetErrors++;
			m_fSendingSync = FALSE;
			goto ErrorExit;
		}
		dwError = 0;	// return success for ERROR_IO_PENDING
	}
		
ErrorExit:
	Unlock();
	return dwError;
}
void CRTPSession::RTCPNotify(
	int rrcmEvent,
	DWORD_PTR dwSSRC,
	DWORD_PTR rtcpsock)
{

	switch (rrcmEvent) {
	case RRCM_RECV_RTCP_SNDR_REPORT_EVENT:
		GetRTCPReport();
		//DispRTCPReport(rtcpsock);
		break;
	case RRCM_RECV_RTCP_RECV_REPORT_EVENT:
		GetRTCPReport();
		break;
	case RRCM_NEW_SOURCE_EVENT:
		RRCM_DBG_MSG ("RTP : New SSRC", 0,
						  __FILE__, __LINE__, DBG_TRACE);
		break;
	default:
		RRCM_DBG_MSG ("RTP : RRCMNotification", rrcmEvent,
						  __FILE__, __LINE__, DBG_TRACE);
	break;
	}
}

void RRCMNotification(
//	RRCM_EVENT_T rrcmEvent,
	int rrcmEvent,
	DWORD_PTR dwSSRC,
	DWORD_PTR rtcpsock,
	DWORD_PTR dwUser)
{
	if (dwUser)
		((CRTPSession *)dwUser)->RTCPNotify(rrcmEvent,dwSSRC,rtcpsock);


}

// Get the useful fields from the RTCP report and store them
// Only works for unicast sessions now (one sender, one receiver)
BOOL CRTPSession::GetRTCPReport()
{
#define MAX_RTCP_REPORT 2
	RTCP_REPORT 	rtcpReport[MAX_RTCP_REPORT];
	DWORD		moreEntries = 0;
	DWORD		numEntry = 0;
	DWORD		i;

	ZeroMemory(rtcpReport,sizeof(rtcpReport));
	// Get latest RTCP report
	// for all SSRCs in this session
	if (S_OK != RTCPReportRequest ( m_rtcpsock->GetSock(),
						   0, &numEntry,
						   &moreEntries, MAX_RTCP_REPORT,
						   rtcpReport,
						   0,NULL,0))
		return FALSE;

	for (i = 0; i < numEntry; i++)
	{
		if (rtcpReport[i].status & LOCAL_SSRC_RPT)
		{
			m_ss.sendStats.ssrc =			rtcpReport[i].ssrc;
			m_ss.sendStats.packetsSent =	rtcpReport[i].dwSrcNumPcktRealTime;
			m_ss.sendStats.bytesSent = 		rtcpReport[i].dwSrcNumByteRealTime;
		} else {
			m_rs.rcvStats.ssrc = rtcpReport[i].ssrc;
			m_rs.rcvStats.packetsSent = rtcpReport[i].dwSrcNumPckt;
			m_rs.rcvStats.bytesSent = rtcpReport[i].dwSrcNumByte;
			m_rs.rcvStats.packetsLost = rtcpReport[i].SrcNumLost;
			m_rs.rcvStats.jitter = rtcpReport[i].SrcJitter;
			// Get the SR timestamp information
			m_rs.ntpTime = ((NTP_TS)rtcpReport[i].dwSrcNtpMsw << 32) + rtcpReport[i].dwSrcNtpLsw;
			m_rs.rtpTime = rtcpReport[i].dwSrcRtpTs;

			// check if any feedback information
			if (rtcpReport[i].status & FEEDBACK_FOR_LOCAL_SSRC_PRESENT)
			{
				DWORD prevPacketsLost = m_ss.sendStats.packetsLost;
				
				m_ss.sendStats.packetsLost = rtcpReport[i].feedback.cumNumPcktLost;
/*
				if (prevPacketsLost != m_ss.sendStats.packetsLost) {
					DEBUGMSG(ZONE_DP,("RTCP: fraction Lost=%d/256 , totalLost =%d, StreamClock=%d\n",rtcpReport[i].feedback.fractionLost,m_ss.sendStats.packetsLost,m_clockRate));
				}
*/
				m_ss.sendStats.jitter = 	rtcpReport[i].feedback.dwInterJitter;
			}
		}

	}
	m_ss.sendStats.packetsDelivered =	m_ss.sendStats.packetsSent - m_ss.sendStats.packetsLost;

	return TRUE;

}

// CRTPPacket1 methods

HRESULT CRTPPacket1::Init(UINT uMaxPacketSize)
{
	m_wsabuf.buf = new char [uMaxPacketSize];
	if (!m_wsabuf.buf)
		return E_OUTOFMEMORY;
	m_wsabuf.len = uMaxPacketSize;
	m_cbSize = uMaxPacketSize;

	return S_OK;
}

CRTPPacket1::~CRTPPacket1()
{
	if (m_wsabuf.buf)
		delete [] m_wsabuf.buf;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\rtpsess.h ===
// RTPSession.h : Declaration of the CRTPSession

#ifndef __RTPSESSION_H_
#define __RTPSESSION_H_

#include "resource.h"       // main symbols
#include "queue.h"

#ifndef MAX_MISORDER
const int MAX_MISORDER =20;
#endif
const int MAX_DROPPED =30;

typedef short PORT;




typedef unsigned __int64 NTP_TS;


//typedef void (* PRTPRECVCALLBACK)(DWORD dwStatus, DWORD_PTR dwCallback, NETBUF *pNetBuf, DWORD ssrc, DWORD ts, UINT seq, BOOL fMark);

typedef struct {
	UINT sessionId;
	UINT mediaId;
	BOOL fSend;
	PSOCKADDR_IN pLocalAddr;
	PSOCKADDR_IN pLocalRTCPAddr;
	PSOCKADDR_IN pRemoteAddr;
	PSOCKADDR_IN pRemoteRTCPAddr;
} RTPCHANNELDESC;

typedef struct {
	RTP_HDR_T hdr;	// header template for quick formatting
	RTP_STATS sendStats;	// statistics
} RTP_SEND_STATE;

typedef struct {
	RTP_STATS rcvStats;	// statistics
	NTP_TS ntpTime;
	DWORD rtpTime;
	
} RTP_RECV_STATE;


// generic UDP socket wrapper
// defined in its entirety here
class UDPSOCKET {
	SOCKET Sock;
	SOCKADDR_IN local_sin;
	SOCKADDR_IN remote_sin;	
	int local_sin_len;
	int remote_sin_len;

public:
	UDPSOCKET()  {
		ZeroMemory(&local_sin,sizeof(local_sin));
		ZeroMemory(&remote_sin,sizeof(remote_sin));
		Sock = INVALID_SOCKET;}
	~UDPSOCKET()
	{
		Cleanup();
	}

	VOID SetRemoteAddr(PSOCKADDR_IN psin) {remote_sin = *psin;};
	VOID SetLocalAddress(PSOCKADDR_IN psin) {local_sin = *psin;};
	PSOCKADDR_IN GetLocalAddress() {return &local_sin;};
	PSOCKADDR_IN GetRemoteAddress() {return &remote_sin;};
	VOID SetRemotePort(PORT port) {remote_sin.sin_port = htons(port);};
	VOID SetLocalPort(PORT port) {local_sin.sin_port = htons(port);};
	PORT GetRemotePort() {return (ntohs(remote_sin.sin_port));};
	PORT GetLocalPort() {return(ntohs(local_sin.sin_port));};
	SOCKET GetSock() {return Sock;};
	BOOL NewSock()
	{
		if(Sock == INVALID_SOCKET)
		{
				
			Sock = (*RRCMws.WSASocket) (AF_INET,
							  SOCK_DGRAM,
							  WS2Enabled ? FROM_PROTOCOL_INFO : 0,
							  &RRCMws.RTPProtInfo,
							  0,
							  WSA_FLAG_OVERLAPPED);
		}
		return(Sock != INVALID_SOCKET);
	}

	VOID Cleanup()
	{
		if(Sock != INVALID_SOCKET)
		{
			(*RRCMws.closesocket)(Sock);
			Sock = INVALID_SOCKET;
		}

	}
	int BindMe()
	{
		return (*RRCMws.bind)(Sock, (LPSOCKADDR)&local_sin, sizeof (local_sin));
	}

};

/////////////////////////////////////////////////////////////////////////////
// CRTPPacket (internal object representing a received RTPPacket)
class  CRTPPacket1
{
public:
	CRTPPacket1()
	{
		m_wsabuf.buf = NULL;
		m_wsabuf.len = 0;
		m_cbSize = 0;

	}
	~CRTPPacket1();

public:

	HRESULT Init(UINT cbMaxSize);	// allocates buffer of size cbMaxSize
	
	WSAOVERLAPPED *GetOverlapped() {return &m_overlapped;}
	void SetActual(UINT len) {m_wsabuf.len = len;}
	void RestoreSize() {m_wsabuf.len = m_cbSize;}
	static CRTPPacket1 *GetRTPPacketFromOverlapped(WSAOVERLAPPED *pOverlapped)
	{
		return ( (CRTPPacket1 *)((char *)pOverlapped - (UINT_PTR)(&((CRTPPacket1 *)0)->m_overlapped)));
	}
	static CRTPPacket1 *GetRTPPacketFromWSABUF(WSABUF *pBuf)
	{
		return ( (CRTPPacket1 *)((char *)pBuf - (UINT_PTR)(&((CRTPPacket1 *)0)->m_wsabuf)));
	}
	WSABUF *GetWSABUF() {return &m_wsabuf;}
	DWORD GetTimestamp() {return (((RTP_HDR_T *)m_wsabuf.buf)->ts);}
	void SetTimestamp(DWORD timestamp) {((RTP_HDR_T *)m_wsabuf.buf)->ts = timestamp;}
	UINT GetSeq() {return (((RTP_HDR_T *)m_wsabuf.buf)->seq);}
	void SetSeq(UINT seq) {((RTP_HDR_T *)m_wsabuf.buf)->seq = (WORD)seq;}
	BOOL GetMarkBit() {return (((RTP_HDR_T *)m_wsabuf.buf)->m);}
private:
	WSAOVERLAPPED m_overlapped;
	WSABUF m_wsabuf;
	UINT m_cbSize;	// (max) size of packet
};


/////////////////////////////////////////////////////////////////////////////
// CRTPSession
class ATL_NO_VTABLE CRTPSession :
	public CComObjectRootEx<CComMultiThreadModel>,
//	public CComCoClass<CRTPSession, &CLSID_RTPSession>,
	public IRTPSend,
	public IRTPSession,
	public IRTPRecv
{
public:
	CRTPSession();
	HRESULT FinalRelease();

	

//DECLARE_REGISTRY_RESOURCEID(IDR_RTPSESSION)

BEGIN_COM_MAP(CRTPSession)
	COM_INTERFACE_ENTRY(IRTPSend)
	COM_INTERFACE_ENTRY(IRTPSession)
	COM_INTERFACE_ENTRY(IRTPRecv)
END_COM_MAP()

// IRTPSend
public:
	STDMETHOD(Send)(
		WSABUF *pWsabufs,
		UINT nWsabufs,
		WSAOVERLAPPED *pOverlapped,
		LPWSAOVERLAPPED_COMPLETION_ROUTINE pWSAPC );
	STDMETHOD(GetSendStats)(RTP_STATS *pSendStats) {
		*pSendStats = m_ss.sendStats;return S_OK;
	}

// IRTPRecv
	STDMETHOD(SetRecvNotification) (PRTPRECVCALLBACK , DWORD_PTR dwCallback, UINT nBufs);
	STDMETHOD(CancelRecvNotification) ();
	// called by CRTPMediaStream to free accumulated packets
	STDMETHOD (FreePacket)(WSABUF *pBuf) ;
	STDMETHOD(GetRecvStats)(RTP_STATS *pSendStats) {
		*pSendStats = m_rs.rcvStats;return S_OK;
	}


// IRTPSession
	STDMETHOD(SetLocalAddress)(BYTE *sockaddr, UINT cbAddr);
	STDMETHOD(SetRemoteRTPAddress)(BYTE *sockaddr, UINT cbAddr);
	STDMETHOD(SetRemoteRTCPAddress)(BYTE *sockaddr, UINT cbAddr);
	STDMETHOD(GetLocalAddress)(const BYTE **sockaddr, UINT *pcbAddr);
	STDMETHOD(GetRemoteRTPAddress)(const BYTE **sockaddr, UINT *pcbAddr);
	STDMETHOD(GetRemoteRTCPAddress)(const BYTE **sockaddr, UINT *pcbAddr);
	STDMETHOD(CreateRecvRTPStream)(DWORD ssrc, IRTPRecv **ppIRTPRecv);
	STDMETHOD(SetSendFlowspec)(FLOWSPEC *pSendFlowspec);
	STDMETHOD(SetRecvFlowspec)(FLOWSPEC *pRecvFlowspec);
	STDMETHOD (SetMaxPacketSize) (UINT cbPacketSize);

// other non-COM methods
	// called by CRTPMediaStream to request that receive buffers be posted
	HRESULT PostRecv();

private:
	
	UDPSOCKET *m_rtpsock;
	UDPSOCKET *m_rtcpsock;
	UINT m_sessionId;
	UINT m_mediaId;
	class CRTPSession *m_pSessNext;
	static class CRTPSession *m_pSessFirst;

	HANDLE			m_hRTPSession;
	QOS	m_Qos;
	
	UINT m_clockRate;

	// receive stuff
	UINT m_uMaxPacketSize;
	QueueOf<CRTPPacket1 *> m_FreePkts;
	UINT m_nBufsPosted;
	// this should be per remote SSRC
	PRTPRECVCALLBACK m_pRTPCallback;
	DWORD_PTR m_dwCallback;
	RTP_RECV_STATE m_rs;
	
	// used by RTPRecvFrom()
	int m_rcvSockAddrLen;
	SOCKADDR m_rcvSockAddr;

	// send stuff
	DWORD			m_numBytesSend;
	int m_lastSendError;
	WSAOVERLAPPED	m_sOverlapped;	// used only for synchronous Send()
	BOOL 	m_fSendingSync;			// TRUE if m_sOverlapped is in use
	RTP_SEND_STATE m_ss;
	
	HRESULT Initialize(UINT sessionId, UINT mediaId,BYTE *sockaddr, UINT cbAddr);
	BOOL SelectPorts();
	HRESULT SetMulticastAddress(PSOCKADDR_IN );

	friend void RRCMNotification(int ,DWORD_PTR,DWORD_PTR,DWORD_PTR);
	friend void CALLBACK WS2SendCB (DWORD ,	DWORD, LPWSAOVERLAPPED, DWORD );
	friend void CALLBACK WS2RecvCB (DWORD ,	DWORD, LPWSAOVERLAPPED, DWORD );
	friend class CRTP;


	void RTCPNotify(int,DWORD_PTR dwSSRC,DWORD_PTR rtcpsock);

	BOOL GetRTCPReport();

};

typedef CComObject<CRTPSession> ObjRTPSession;	// instantiable class


/////////////////////////////////////////////////////////////////////////////
// CRTP - top level RTP interface
//
class ATL_NO_VTABLE CRTP:
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CRTP, &CLSID_RTP>,
	public IRTP
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_RTP)

BEGIN_COM_MAP(CRTP)
	COM_INTERFACE_ENTRY(IRTP)
END_COM_MAP()

// IRTP
public:
	STDMETHOD(OpenSession)(
			UINT sessionId,	// client specified unique identifier for the session
			DWORD flags,	// SESSION_SEND, SESSION_RECV, SESSION_MULTICAST
			BYTE *localAddr, // Local  socket interface addr to bind to
			UINT cbAddr,	// sizeof(SOCKADDR)
			IRTPSession **ppIRTP); // [output] pointer to RTPSession

//	STDMETHOD(CreateSink)( IRTPSink **ppIRTPSink);
private:
	static BOOL m_WSInitialized;
};

#endif //__RTPSINK_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\rtp_hash.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTP_HASH.C
 * Product:     RTP/RTCP implementation
 * Description: Associate sockets/streams with their RTP Session in a hash table
 *
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

	
#include "rrcm.h"


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            
extern PRTP_CONTEXT	pRTPContext;


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/





/*----------------------------------------------------------------------------
 * Function   : createHashEntry
 * Description: Adds stream unique socket ID to hash table.  
 * 
 * Input :  pSession	:  RTP Session containing the stream
 *			socket		: unique socket ID for stream
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Initialization Error.
 ---------------------------------------------------------------------------*/
DWORD createHashEntry (PRTP_SESSION pSession, 
					   SOCKET socket)
	{
	PRTP_HASH_LIST  pNewCell;
	WORD			hashEntry;
	DWORD			dwStatus = RRCM_NoError;
	DWORD			hashTableEntries = NUM_RTP_HASH_SESS;

	IN_OUT_STR ("RTP : Enter createHashEntry()\n");
	
	// Get a PRTP Buffer from the free list	and assign the values
	pNewCell = (PRTP_HASH_LIST)removePcktFromTail(
					(PLINK_LIST)&pRTPContext->pRTPHashList,
					&pRTPContext->critSect);

	if (pNewCell == NULL)
		{

		if ( allocateLinkedList (&pRTPContext->pRTPHashList, 
								 pRTPContext->hHashFreeList,
								 &hashTableEntries,
				 				 sizeof(RTP_HASH_LIST),
								 &pRTPContext->critSect) == RRCM_NoError)
	
		{		 						
			pNewCell = (PRTP_HASH_LIST)removePcktFromTail (
										(PLINK_LIST)&pRTPContext->pRTPHashList,
										&pRTPContext->critSect);
			}
		}

	if (pNewCell != NULL)
		{
		pNewCell->RTPsocket = socket;
		pNewCell->pSession  = pSession;

		// Get entry in table
		hashEntry = socket & HASH_MODULO;

		// Just insert the entry at the head of list
		addToHeadOfList (
			(PLINK_LIST)&pRTPContext->RTPHashTable[hashEntry].RTPHashLink,
			(PLINK_LIST)pNewCell,
			&pRTPContext->critSect);
		}
	else
		dwStatus = RRCMError_RTPResources;

	IN_OUT_STR ("RTP : Exit createHashEntry()\n");
	
	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : deleteHashEntry
 * Description: Searches hash table based on unique socket.  Deletes session from
 *					hash table and returns buffer to free list
 * 
 * Input : socket: unique socket ID for stream
 *
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Deletion Error.
 ---------------------------------------------------------------------------*/
DWORD deleteHashEntry (SOCKET socket)
	{
	PRTP_HASH_LIST  pNewCell;
	WORD			hashEntry;
	DWORD			dwStatus = RRCMError_RTPStreamNotFound;

	IN_OUT_STR ("RTP : Enter deleteHashEntry()\n");
	
	// Get entry in table
	hashEntry = socket & HASH_MODULO;

	// Search for entry in table.  if found, remove from RTPHashTable and insert
	//	back in free list
	for (pNewCell = (PRTP_HASH_LIST)pRTPContext->RTPHashTable[hashEntry].RTPHashLink.prev;
		 pNewCell != NULL;
		 pNewCell = (PRTP_HASH_LIST)pNewCell->RTPHashLink.next) 
		{
		if (pNewCell->RTPsocket == socket) 
			{
			EnterCriticalSection (&pRTPContext->critSect);

			if (pNewCell->RTPHashLink.prev == NULL) 
				{
				// first entry in the queue - update the tail pointer
				pRTPContext->RTPHashTable[hashEntry].RTPHashLink.prev = 
					pNewCell->RTPHashLink.next;

				// check if only one entry in the list 
				if (pNewCell->RTPHashLink.next == NULL)
					pRTPContext->RTPHashTable[hashEntry].RTPHashLink.next = NULL;
				else
					(pNewCell->RTPHashLink.next)->prev = NULL;
				}
			else if (pNewCell->RTPHashLink.next == NULL) 
				{
				// last entry in the queue - update the head pointer
				// this was the last entry in the queue
				pRTPContext->RTPHashTable[hashEntry].RTPHashLink.next = 
					pNewCell->RTPHashLink.prev;

				(pNewCell->RTPHashLink.prev)->next = NULL;
				}
			else
				{
				// in the middle of the list - link around it
				(pNewCell->RTPHashLink.prev)->next = pNewCell->RTPHashLink.next;
				(pNewCell->RTPHashLink.next)->prev = pNewCell->RTPHashLink.prev;
				}
	
			LeaveCriticalSection (&pRTPContext->critSect);			

			addToHeadOfList ((PLINK_LIST)&pRTPContext->pRTPHashList,
					 	  	 (PLINK_LIST)pNewCell,
							 &pRTPContext->critSect);
			
			dwStatus = RRCM_NoError;
			
			break;
			}
		}

	if (dwStatus != RRCM_NoError) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - DeleteHashEntry()", 0, 
					  __FILE__, __LINE__, DBG_ERROR);
		}

	IN_OUT_STR ("RTP : Exit deleteHashEntry()\n");
	
	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : findSessionID
 * Description: Searches hash table based on unique socket to identify session ID
 * 
 * Input : socket: unique socket ID for stream
 *
 *
 * Return: Session ptr	= OK.
 *         NULL			= Search Error.
 ---------------------------------------------------------------------------*/
PRTP_SESSION findSessionID (SOCKET socket)
	{
	PRTP_HASH_LIST  pNewCell;
	WORD			hashEntry;
	PRTP_SESSION 	pSession = NULL;

	IN_OUT_STR ("RTP : Enter findSessionID()\n");
	
	// Get entry in table
	hashEntry = socket & HASH_MODULO;

	// Search for entry in table.  
	// If found, remove from RTPHashTable and insert back in free list
	for (pNewCell = (PRTP_HASH_LIST)pRTPContext->RTPHashTable[hashEntry].RTPHashLink.prev;
		 pNewCell != NULL;
		 pNewCell =  (PRTP_HASH_LIST)pNewCell->RTPHashLink.next) 
		{
		if (pNewCell->RTPsocket == socket) 
			{
			pSession = pNewCell->pSession;
			break;
			}
		}

	IN_OUT_STR ("RTP : Exit findSessionID()\n");
	
	return (pSession); 
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\rtp_stat.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTP_STAT.C
 * Product:     RTP/RTCP implementation
 * Description: Provides statistical calculations for RTP packets
 *
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"


#define DBG_JITTER_ENABLE	0


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT	pRTPContext;
extern RRCM_WS		RRCMws;				

#ifdef _DEBUG
extern char	debug_string[];
#endif





/*----------------------------------------------------------------------------
 * Function   : calculateJitter
 * Description: Determines jitter between current and last received packet.
 * 
 * Input :		pRTPHeader	: -> to the RTP header
 *				pSSRC		: -> to the session's SSRC list
 *
 * Note: Implementataion adapted from IETF RFC1889
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Error.
 ---------------------------------------------------------------------------*/
DWORD calculateJitter (RTP_HDR_T *pRTPHeader, 
					   PSSRC_ENTRY pSSRC)
	{
	DWORD		dwStatus = RRCM_NoError;
	DWORD		streamClk;
	DWORD		dwTmp;
	int			dwPropagationTime;	// packet's transmit time
	int			dwIASourceTime;		// Packet's timestamp for IA
	int			delta;				// of 2 consec. packets

	IN_OUT_STR ("RTP : Enter calculateJitter()\n");

	// Convert the RTP timestamp to host order
	RRCMws.ntohl (pSSRC->RTPsd, pRTPHeader->ts, (PDWORD)&dwIASourceTime);

	// lock access
	EnterCriticalSection (&pSSRC->critSect);

	// Take the difference, after having adjusted the clock to the payload
	// type frequency
	streamClk = 
		((PSSRC_ENTRY)pSSRC->pRTCPses->XmtSSRCList.prev)->dwStreamClock;
	if (streamClk) 
		{
		dwTmp = streamClk / 1000;

		// update the time to be in unit of the source clock
		dwPropagationTime = (timeGetTime() * dwTmp) - dwIASourceTime;
		}
	else
		dwPropagationTime = timeGetTime() - dwIASourceTime;

	// initialize for the first valid packet, otherwise jitter will be off
	if (pSSRC->rcvInfo.dwPropagationTime == 0)
		{
		pSSRC->rcvInfo.dwPropagationTime = dwPropagationTime;

		LeaveCriticalSection (&pSSRC->critSect);

		IN_OUT_STR ("RTP : Exit calculateJitter()\n");	
		return (dwStatus);
		}

#if DBG_JITTER_ENABLE
	wsprintf(debug_string, "RTP : Time: %ld - Src Timestamp: %ld",
							timeGetTime(), 
							dwIASourceTime);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

	wsprintf(debug_string, "RTP : Propagation (Src unit): %ld",
							dwPropagationTime);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

	wsprintf(debug_string, "RTP : Previous Propagation (Src unit): %ld",
							pSSRC->rcvInfo.dwPropagationTime);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// Determine the difference in the transit times and save the latest
	delta = dwPropagationTime - pSSRC->rcvInfo.dwPropagationTime;
	if (delta < 0)
		delta = -delta;

	// check for a wrap-around, which is always possible, and avoid sending
	// the jitter through the roof - It will take a long time thereafter to 
	// go back down to a reasonable level 
	// Check against arbitrary large number
	if (delta > 20000)
		{
		pSSRC->rcvInfo.dwPropagationTime = dwPropagationTime;

		LeaveCriticalSection (&pSSRC->critSect);

		IN_OUT_STR ("RTP : Exit calculateJitter()\n");	
		return (dwStatus);
		}

#if DBG_JITTER_ENABLE
	wsprintf(debug_string, "RTP : Delta (Src unit): %ld", delta);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	pSSRC->rcvInfo.dwPropagationTime = dwPropagationTime;

#ifdef ENABLE_FLOATING_POINT
	// This is the RFC way to do it
	pSSRC->rcvInfo.interJitter += 
		((1./16.) * ((double)delta - pSSRC->rcvInfo.interJitter));
#else
	// and this is when we need to remove floating point operation
	pSSRC->rcvInfo.interJitter += 
		(delta - (((long)pSSRC->rcvInfo.interJitter + 8) >> 4));
#endif

	LeaveCriticalSection (&pSSRC->critSect);

#if DBG_JITTER_ENABLE
	if (streamClk)
		{
		wsprintf(debug_string, "RTP : iJitter: %ld - iJitter (msec): %ld",
								pSSRC->rcvInfo.interJitter,
								(pSSRC->rcvInfo.interJitter / (streamClk / 1000)));
		}
	else
		{
		wsprintf(debug_string, "RTP : iJitter: %ld - Delta: %ld",
								pSSRC->rcvInfo.interJitter,
								delta);
		}
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

	wsprintf(debug_string, "RTP : Next RTCP RR iJitter: %ld",
							(pSSRC->rcvInfo.interJitter >> 4));
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
	
	IN_OUT_STR ("RTP : Exit calculateJitter()\n");	

	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : initRTPStats
 * Description: initializes statistics table for newly recieved SSRC
 * 
 * Input : RTPSequence	: Sequence number received in the packet.
 *						  NB: Must be in LittleEndian(IA) format
 *		   pSSRC		: -> to SSRC table entry for this terminal
 *
 * Note: Implementataion adapted from draftspec 08, Appendix A.1
 *
 * Return: None.
 ---------------------------------------------------------------------------*/
void initRTPStats (WORD	RTPSequence, 
				   PSSRC_ENTRY pSSRC)
	{
	IN_OUT_STR ("RTP : Enter initRTPStats()\n");

	pSSRC->rcvInfo.dwNumPcktRcvd    = 0;	
	pSSRC->rcvInfo.dwPrvNumPcktRcvd = 0;
	pSSRC->rcvInfo.dwExpectedPrior  = 0;
	pSSRC->rcvInfo.dwNumBytesRcvd   = 0;				
	pSSRC->rcvInfo.dwBadSeqNum      = RTP_SEQ_MOD + 1;		// Out of range
	pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = 
		RTPSequence;
	pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wCycle = 0;

#if 0
	// as per the RFC, but always 1 packet off by doing this ???
	pSSRC->rcvInfo.dwBaseRcvSeqNum  = RTPSequence - 1;
#else
	pSSRC->rcvInfo.dwBaseRcvSeqNum  = RTPSequence;
#endif

	IN_OUT_STR ("RTP : Exit initRTPStats()\n");
	}


/*----------------------------------------------------------------------------
 * Function   : sequenceCheck
 * Description: Determines whether received packet sequence number is in a
 *				valid range to include for statistical tracking purposes.
 * 
 * Input : RTPSequence	:	Sequence number received in the packet.
 *							NB:	Must be in LittleEndian(IA) format
 *		   pSSRC		:	-> to SSRC table entry for this terminal
 *
 * Note: Implementataion adapted from draftspec 08, Appendix A.1
 *
 * Return: TRUE		= OK.
 *         FALSE	= Stale or invalid data.
 ---------------------------------------------------------------------------*/
#if 1
BOOL sequenceCheck (WORD RTPSequence, 
					PSSRC_ENTRY pSSRC)
	{
	WORD delta = RTPSequence - 
		pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum;
		
	IN_OUT_STR ("RTP : Enter sequenceCheck()\n");

	// Have we received enough consecutive sequence numbered pckts in order 
	// to valide ?
	if (pSSRC->rcvInfo.dwProbation) 
		{
		// Is the sequence received the expected one ?
		if (RTPSequence == 
			(pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum + 1)) 
			{
			// Decrement the number of consecutive packets we need before we
			//	consider statistics to be valid
			pSSRC->rcvInfo.dwProbation--;
			pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = 
				RTPSequence;

			if (pSSRC->rcvInfo.dwProbation == 0) 
				{
				initRTPStats(RTPSequence, pSSRC);

				IN_OUT_STR ("RTP : Exit sequenceCheck()\n");

				return TRUE;
				}
			}
		else 
			{
			pSSRC->rcvInfo.dwProbation = MIN_SEQUENTIAL - 1;
			pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = 
				RTPSequence;
			}

		IN_OUT_STR ("RTP : Exit sequenceCheck()\n");

		return FALSE;
		}
	else if (delta < MAX_DROPOUT)
		{
		// In order with permissible gap
		if (RTPSequence < pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum)
			// sequence number wrapped - count another 64K cycle
			pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wCycle += 1;

		pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
		}
	else if (delta <= RTP_SEQ_MOD - MAX_MISORDER)
		{
		// the sequence number made a very large jump
		if (RTPSequence == pSSRC->rcvInfo.dwBadSeqNum)
			// two sequential packet. Assume the other side restarted w/o telling
			// us, so just re-sync, i.e., pretend this was the first packet
			initRTPStats(RTPSequence, pSSRC);	
		else
			{
			pSSRC->rcvInfo.dwBadSeqNum = (RTPSequence + 1) & (RTP_SEQ_MOD - 1);

			IN_OUT_STR ("RTP : Exit sequenceCheck()\n");

			return FALSE;
			}
		}
	else
		{
		// duplicate or reordered packet
		}

	IN_OUT_STR ("RTP : Exit sequenceCheck()\n");

	return (TRUE);
	}

#else
//BOOL sequenceCheck (WORD RTPSequence, 
//					PSSRC_ENTRY lpSSRCList)
//{
//	BOOL			bStatus;
//	WORD			delta;
//		
//#ifdef IN_OUT_CHK
//	OutputDebugString ("\nEnter sequenceCheck()");
//#endif
//
//	// Have we received a couple of consecutive sequence numbered packets for
//	//	validation?
//	if (lpSSRCList->probation) {
//
//		// Default status is don't include since the source hasn't been validated yet
//		bStatus = FALSE;
//
//		// Is the sequence received the expected one?
//		if (RTPSequence == (lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum + 1)) {
//			// Decrement the number of consecutive packets we need before we
//			//	consider statistics to be valid
//			lpSSRCList->probation--;
//			lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
//			if (lpSSRCList->probation == 0) {
//				initRTPStats(RTPSequence, lpSSRCList);
//				bStatus = TRUE;
//			}
//		}
//		else {
//			lpSSRCList->probation = MIN_SEQUENTIAL - 1;
//			lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
//		}
//	}
//	else {
//		// Default status is include since the source has been validated
//		bStatus = TRUE;
//		
//		// First consider the case where delta is positive (or a duplicate packet)
//		if (RTPSequence >= lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum)	{
//
//			delta = RTPSequence - lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum;
//
//			if (delta < MAX_DROPOUT) {
//				// packets may be missing, but not too many so as to be deemed restarted
//				lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
//			}
//			else if (delta  > (RTP_SEQ_MOD - MAX_MISORDER)) {
//				// There has been a recent wraparound, and this is just a recent old packet
//				//	Nothing to do but include for statistical processing
//			}
//			else {
//				// there was a very large jump in sequence numbers
//				if (RTPSequence == lpSSRCList->badSeqNum ) {
//					// Two sequential packets after what was thought was a bad packet or
//					//	(assume a very large jump and proceed as if the sender restarted
//					//	without telling us) or a new terminal is in the session.
//					initRTPStats(RTPSequence, lpSSRCList);
//				}
//				else {
//					lpSSRCList->badSeqNum = (RTPSequence + 1) & (RTP_SEQ_MOD - 1);
//					bStatus = FALSE;
//				}
//			}
//		}
//		else {
//			// sequence number is less than the last we received.  Could be either
//			//	a recent late packet, a very late packet, a wraparound or a restartup 
//			//	of a new session for an SSRC from which we hadn't received a BYE
//
// 			delta = lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum - RTPSequence;
//
//			if (delta < MAX_MISORDER) {
//				// Packet arrived a little bit late, it's still OK
//				// do nothing here, will be counted in stat routines
//			}
//			else if (delta > (RTP_SEQ_MOD - MAX_DROPOUT)) {
//				// wrap around, adjust cycle number and sequence number
//				lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.cycle++;
//				lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
//			}
//			else {
//				// there was a very large jump in sequence numbers
//				if (RTPSequence == lpSSRCList->badSeqNum) {
//					// Two sequential packets after what was thought was a bad packet.
//					//	Assume a very large jump and proceed as if the sender restarted
//					//	without telling us
//					initRTPStats(RTPSequence, lpSSRCList);
//				}
//				else {
//					lpSSRCList->badSeqNum = (RTPSequence + 1) & (RTP_SEQ_MOD - 1);
//					bStatus = FALSE;
//				}
//			}
//		}
//	}
//
//#ifdef IN_OUT_CHK
//	OutputDebugString ("\nExit sequenceCheck()");
//#endif
//
//	return (bStatus);
//}
#endif


/*----------------------------------------------------------------------------
 * Function   : updateRTPStats
 * Description: Updates statistics for RTP packets received from net
 * 
 * Input : 	pRTPHeader		: -> to packet's RTP header field
 *			pSSRC			: -> to remote source's statistics table
 *			cbTransferred	: Number of bytes transferred
 *
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Initialization Error.
 ---------------------------------------------------------------------------*/
DWORD updateRTPStats (RTP_HDR_T *pRTPHeader, 
					  PSSRC_ENTRY pSSRC,
					  DWORD cbTransferred)
	{
	WORD	RTPSequenceNum;

	IN_OUT_STR ("RTP : Enter updateRTPStats()\n");

	// Update statistics only if the data looks good.  Check the sequence number
	//	to ensure it is within an appropriate range.  First, we must convert the
	//	sequence number to IA (little Endian) format
	RRCMws.ntohs (pSSRC->RTPsd, pRTPHeader->seq, 
				  (unsigned short *)&RTPSequenceNum);

	if (sequenceCheck (RTPSequenceNum, pSSRC)) 
		{
		// lock access to data
		EnterCriticalSection (&pSSRC->critSect);

		// update number of packet received
		pSSRC->rcvInfo.dwNumPcktRcvd++;			

		// Number octets received (exclusive of header) depends on whether
		//	a mixer (CSRC != 0) was involved
		if (pRTPHeader->cc == 0) 
			{
			pSSRC->rcvInfo.dwNumBytesRcvd += 
				(cbTransferred - (sizeof(RTP_HDR_T) - sizeof(pRTPHeader->csrc[0])));
			}
		else 
			{
			pSSRC->rcvInfo.dwNumBytesRcvd += 
				(cbTransferred - sizeof(RTP_HDR_T) +
					((pRTPHeader->cc - 1) * sizeof(pRTPHeader->csrc[0])));
			}

		// Packet received sequentially in order (difference 
		// of 1, or -1 if wraparound) save new current 
		//	sequence number
		RRCMws.ntohs (pSSRC->RTPsd, pRTPHeader->seq, 
					  (unsigned short *)&pSSRC->xmtInfo.dwCurXmtSeqNum);

		//	Calculate JITTER
		calculateJitter (pRTPHeader, pSSRC);

		// unlock access to data
		LeaveCriticalSection (&pSSRC->critSect);
		}

	IN_OUT_STR ("RTP : Exit updateRTPStats()\n");

	return (RRCM_NoError);
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3C90D0D6_5F80_11D1_AA64_00C04FC9B202__INCLUDED_)
#define AFX_STDAFX_H__3C90D0D6_5F80_11D1_AA64_00C04FC9B202__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//#define STRICT
//#define _ATL_STATIC_REGISTRY

#ifndef WIN32
#define WIN32
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include "rrcm.h"

// We should really only put this in for w2k
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(expr) ASSERT(expr)


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
extern CRITICAL_SECTION g_CritSect;
#include <atlcom.h>
//#include "log.h"
// temp. debug defns.
#define DEBUGMSG(x,y) ATLTRACE y
#define RETAILMSG(x) ATLTRACE x
#ifdef _DEBUG
#define FX_ENTRY(s)	static CHAR _fx_ [] = (s);
#else
#define FX_ENTRY(s)
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3C90D0D6_5F80_11D1_AA64_00C04FC9B202__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\rtprecv.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTPRECV.C
 * Product:     RTP/RTCP implementation
 * Description: Provides Receive Data Functionality.
 *
 * This listing is supplied under the terms 
 * of a license agreement with Intel Corporation and
 * many not be copied nor disclosed except in accordance
 * with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            



/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT		pRTPContext;
extern RRCM_WS			RRCMws;

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif

/*----------------------------------------------------------------------------
 * Function   : RTPReceiveCheck
 * Description: Called when a packet is received. Handles any statistical
 *				processing required for RTCP.  
 * 
 * Input :		hRTPSession: handle returned by CreateRTPSession
 				RTPsocket: socket on which the packet was received
 				char *pPacket: pointer to packet buffer
 *				cbTransferred:	Number of bytes in packet
 *				pFrom:			sender address
 *				fromlen:		sender address length
 *
 * !!! IMPORTANT NOTE !!!
 *   Currently assumes CSRC = 0
 * !!! IMPORTANT NOTE !!!
 *
 * Return: Status indicating if the packet is OK or has a problem
 ---------------------------------------------------------------------------*/
DWORD  RTPReceiveCheck (
						HANDLE hRTPSession,
						SOCKET RTPsocket,
						char *pPacket,
           				DWORD cbTransferred,
           				PSOCKADDR pFrom,
           				UINT fromlen
           				 )
	{
	PRTP_SESSION		pRTPSession = (PRTP_SESSION) hRTPSession;
	RTP_HDR_T 			*pRTPHeader = (RTP_HDR_T *)pPacket;
	PSSRC_ENTRY			pSSRC = NULL;
	DWORD				dwSSRC;
	DWORD				oldSSRC;
	PSSRC_ENTRY			pMySSRC;
	DWORD				dwStatus = 0;
	struct sockaddr_in	*pSSRCadr;

	IN_OUT_STR ("RTP : Enter RTPReceiveCheck()\n");


	ASSERT (pRTPSession);

	// If Winsock error or runt packet(used to cancel recvs), signal completion to application 
	// and do not repost.
	if (cbTransferred < RTP_HDR_MIN_LEN)
		{
		// don't report closeSocket() as an error when the application
		//  have some pending buffers remaining

		// notify the user if an error occured, so he can free up 
		// its receive resources. The byte count is set to 0

		return RTP_RUNT_PACKET;
		}

	// Perform validity checking
	ASSERT (pRTPHeader);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
	if (RTPLogger)
		{
		//INTEROP
		InteropOutput (RTPLogger,
					   (BYTE FAR*)(pRTPHeader),
					   (int)cbTransferred,
					   RTPLOG_RECEIVED_PDU | RTP_PDU);
		}
#endif

	// Check RTP Headers for validity.  If not valid, then repost buffers 
	// to the network layer for a new receive.
	if (validateRTPHeader (pRTPHeader) ) 
		{
		// Get pointer to SSRC entry table for this session
		// If SSRC in packet is > 1/2 MAX_RANGE of DWORD, start search from
		//	tail of SSRC list, otherwise, start from front
		RRCMws.ntohl (RTPsocket, pRTPHeader->ssrc, &dwSSRC);
					    
		if (dwSSRC > MAX_DWORD/2) 
			{
			pSSRC = searchforSSRCatTail (
				(PSSRC_ENTRY)pRTPSession->pRTCPSession->RcvSSRCList.prev,
				dwSSRC);
			}
		else 
			{
			pSSRC = searchforSSRCatHead (
				(PSSRC_ENTRY)pRTPSession->pRTCPSession->RcvSSRCList.next,
				dwSSRC);
			}

		// get my own SSRC used for this stream
		pMySSRC = searchForMySSRC (
			(PSSRC_ENTRY)pRTPSession->pRTCPSession->XmtSSRCList.prev,
			RTPsocket);
		ASSERT (pMySSRC);
		
		// is this SSRC already known on the receive list ?
		if (pSSRC == NULL) 
			{
			// don't create an entry for my own packet looping back on 
			// a mcast group where loopback has not been turned off
			if (pMySSRC->SSRC != dwSSRC)
				{
				// new party heard from. Create an entry for it
				pSSRC = createSSRCEntry (dwSSRC,
										 pRTPSession->pRTCPSession,
										 pFrom,
										 fromlen,
										 FALSE);

				// notify application if interested
				RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, dwSSRC, 
								  pRTPHeader->pt);
				}
			else
				{
				// my own SSRC received back

				// A collision occurs if the SSRC in the rcvd packet is 
				// equal to mine, and the network transport address is
				// different from mine.
				// A loop occurs if after a collision has been resolved the
				// SSRC collides again from the same source transport address
				pSSRCadr = (PSOCKADDR_IN)&pMySSRC->from;
				if (((PSOCKADDR_IN)pFrom)->sin_addr.S_un.S_addr !=
					  pSSRCadr->sin_addr.S_un.S_addr)
					{
					// check if the source address is already in the 
					// conflicting table. This identifes that somebody out 
					// there is looping pckts back to me
					if (RRCMChkCollisionTable (pFrom, fromlen, pMySSRC))
						{
						RRCM_DBG_MSG ("RTP : Loop Detected ...", 0, NULL, 0,
										DBG_NOTIFY);

						// loop already known
						dwStatus |= SSRC_LOOP_DETECTED;
						}
					else
						{
						RRCM_DBG_MSG ("RTP : Collision Detected ...", 0, NULL, 0,
										DBG_NOTIFY);

						// create new entry in conflicting address table 
						RRCMAddEntryToCollisionTable (pFrom, fromlen, pMySSRC);

						// send RTCP BYE packet w/ old SSRC 
						RTCPsendBYE (pMySSRC, "Loop/collision detected");

						// select new SSRC
						oldSSRC = pMySSRC->SSRC;
						dwSSRC  = getSSRC (pMySSRC->pRTCPses->RcvSSRCList, 
										   pMySSRC->pRTCPses->XmtSSRCList);

					 	EnterCriticalSection (&pMySSRC->critSect);
						pMySSRC->SSRC = dwSSRC;
					 	LeaveCriticalSection (&pMySSRC->critSect);

						// create new entry w/ old SSRC plus actual source
						// transport address in our receive list side, so the 
						// packet actually en-route will be dealt with
						createSSRCEntry (oldSSRC,
										 pRTPSession->pRTCPSession,
										 pFrom,
										 fromlen,
										 FALSE);

						// notify application if interested
						RRCMnotification (RRCM_LOCAL_COLLISION_EVENT, 
										  pMySSRC, oldSSRC, 0);

						// loop already known
						dwStatus |= SSRC_COLLISION_DETECTED;
						}
					}
				else
					{
					// own packet looped back because the sender joined the
					// multicast group and loopback is not turned off
					dwStatus |= MCAST_LOOPBACK_NOT_OFF;
					}
				}
			}
		else if (pSSRC->dwSSRCStatus & THIRD_PARTY_COLLISION)
			{
			// this SSRC is marked as colliding. Reject the data
			dwStatus = THIRD_PARTY_COLLISION;
			}

		if (dwStatus == 0)
			{
			// do all the statistical updating stuff
			updateRTPStats (pRTPHeader, pSSRC, cbTransferred);

			// update the payload type for this SSRC
			pSSRC->PayLoadType = pRTPHeader->pt;

			}	// SSRCList != NULL
		}		// valid RTP Header
	else 
		{
		dwStatus |= INVALID_RTP_HEADER;
		}


	IN_OUT_STR ("RTP : Exit RTPReceiveCallback()\n");
	return dwStatus;
	}

/*----------------------------------------------------------------------------
 * Function   : validateRTPHeader
 * Description: Performs basic checking of RTP Header (e.g., version number 
 *				and	payload type range).
 * 
 * Input : pRTPHeader:	-> to an RTP header
 *
 * Return: TRUE, RTP Packet Header is valid
 *		   FALSE: Header is invalid
 ---------------------------------------------------------------------------*/
 BOOL validateRTPHeader(RTP_HDR_T *pRTPHeader)
	{   
	BOOL	bStatus = TRUE;

	IN_OUT_STR ("RTP : Enter validateRTPHeader()\n");

	if (! pRTPHeader)
		return FALSE;

	// Check version number is correct
	if (pRTPHeader->type != RTP_TYPE) 
		bStatus = FALSE;
	                                  
	// Next check that the Packet types look somewhat reasonable, 
	// at least out of the RTCP range
	if (pRTPHeader->pt >= RTCP_SR)
		bStatus = FALSE;

	IN_OUT_STR ("RTP : Exit validateRTPHeader()\n");
	
	return bStatus;
	}


#if 0
/*----------------------------------------------------------------------------
 * Function   : RTPRecvFrom
 * Description: Intercepts receive requests from app.  Handles any statistical
 *				processing required for RTCP.  Copies completion routine 
 *				from app and substitutes its own.  Apps completion routine
 *				will be called after RTP's completion routine gets called.
 * 
 * Input :	RTPsocket:			RTP socket descriptor
 *			pBuffers:			-> to WSAbuf structure
 *		  	dwBufferCount:		Buffer count in WSAbuf structure
 *			pNumBytesRecvd:		-> to number of bytes received
 *			pFlags:				-> to flags
 *			pFrom:				-> to the source address
 *			pFromLen:			-> to source address length
 *			pOverlapped:		-> to overlapped I/O structure
 *			pCompletionRoutine:	-> to completion routine
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Check RRCM.h file for references.
 ---------------------------------------------------------------------------*/
 DWORD WINAPI RTPRecvFrom (SOCKET RTPsocket,
					        LPWSABUF pBuffers,
						    DWORD  dwBufferCount,
						    LPDWORD pNumBytesRecvd, 
						    LPDWORD pFlags,
						    PSOCKADDR pFrom,
						    LPINT pFromlen,
						    LPWSAOVERLAPPED pOverlapped, 
						    LPWSAOVERLAPPED_COMPLETION_ROUTINE pCompletionRoutine)
	{
	int					dwStatus = RRCM_NoError;
	int					dwError;
	PRTP_SESSION		pRTPSession;
	PRTP_BFR_LIST		pRCVStruct;

	IN_OUT_STR ("RTP : Enter RTPRecvFrom()\n");

	// If RTP context doesn't exist, report error and return.
	if (pRTPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - No RTP Instance", 0, 
						__FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit RTPRecvFrom()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalid));
		}

	// Search for the proper session based on incoming socket
	pRTPSession = findSessionID(RTPsocket);
	if (pRTPSession == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit RTPRecvFrom()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
		}

	// We need to associate a completionRoutine's lpOverlapped with a 
	// session. We look at each buffer and associate a socket so when 
	// the completion routine is called, we can pull out the socket.
	if (dwStatus = saveRCVWinsockContext(pOverlapped,
										  pBuffers,
					   					  pCompletionRoutine,
					   					  pRTPSession,
					   					  dwBufferCount,
			  		   					  pNumBytesRecvd, 
					   					  pFlags,
					   					  pFrom,
					   					  pFromlen,
					   					  RTPsocket) != RRCM_NoError)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Out of resources...", 0, 
					  __FILE__, __LINE__, DBG_NOTIFY);
		IN_OUT_STR ("RTP : Exit RTPRecvFrom()\n");

		return (MAKE_RRCM_ERROR(dwStatus));
		}

	// Forward to winsock, substituting our completion routine for the
	//	one handed to us.
	dwStatus = RRCMws.recvFrom (RTPsocket,
			   		  			pBuffers,
			              		dwBufferCount,
		   				  		pNumBytesRecvd, 
		   				  		pFlags,
		   				  		pFrom,
		    		  			pFromlen,
			   			  		pOverlapped,
			   			  		RTPReceiveCallback); 

	// Check if Winsock Call succeeded
	if (dwStatus != 0) 
		{
		// If serious error, the receive request won't proceed so
		//	we must undo all our work
		dwError = GetLastError();
		if ((dwError != WSA_IO_PENDING) && (dwError != WSAEMSGSIZE)) 
			{
			// Reinstate the Apps WSAEVENT
			pRCVStruct = (PRTP_BFR_LIST)pOverlapped->hEvent;
			pOverlapped->hEvent =  pRCVStruct->hEvent;

			RRCM_DBG_MSG ("RTP : ERROR - WSARecvFrom()", dwError, 
						  __FILE__, __LINE__, DBG_NOTIFY);

			// Return the struct to the free queue
			addToHeadOfList (&pRTPSession->pRTPFreeList,
					 	  	 (PLINK_LIST)pRCVStruct,
							 &pRTPSession->critSect);
			}
		}
	
	IN_OUT_STR ("RTP : Exit RTPRecvFrom()\n");

	return (dwStatus);
	}
	
/*----------------------------------------------------------------------------
 * Function   : RTPReceiveCallback
 * Description: Callback routine from Winsock2  Handles any statistical
 *				processing required for RTCP.  Copies completion routine 
 *				from app and substitutes its own.  Apps completion routine
 *				will be called after RTP's completion routine gets called.
 * 
 * Input :		dwError:		I/O completion error code
 *				cbTransferred:	Number of bytes transferred
 *				pOverlapped:	-> to overlapped I/O structure
 *				dwFlags:		Flags
 *
 * !!! IMPORTANT NOTE !!!
 *   Currently assumes CSRC = 0
 * !!! IMPORTANT NOTE !!!
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void CALLBACK RTPReceiveCallback (DWORD dwError,
           				  		  DWORD cbTransferred,
           				  		  LPWSAOVERLAPPED pOverlapped,
           				  		  DWORD dwFlags)
	{
	PRTP_SESSION		pRTPSession;
	RTP_HDR_T 			*pRTPHeader;
	PRTP_BFR_LIST		pRCVStruct;
	PSSRC_ENTRY			pSSRC = NULL;
	DWORD				dwSSRC;
	DWORD				oldSSRC;
	PSSRC_ENTRY			pMySSRC;
	DWORD				dwRequeue = 0;
	struct sockaddr_in	*pSSRCadr;

	IN_OUT_STR ("RTP : Enter RTPReceiveCallback()\n");

	// GEORGEJ: catch Winsock 2 bug (94903) where I get a bogus callback
	// after WSARecv returns WSAEMSGSIZE.
	if (!dwError && ((int) cbTransferred < 0)) {
		RRCM_DBG_MSG ("RTP : RCV Callback : bad cbTransferred", cbTransferred, 
						  __FILE__, __LINE__, DBG_ERROR);
		return;
	}
	// The returning hEvent in the LPWSAOVERLAPPED struct contains the 
	// information mapping the session and the buffer.
	pRCVStruct = (PRTP_BFR_LIST)pOverlapped->hEvent;

	// Search for the proper session based on incoming socket
	pRTPSession = (PRTP_SESSION)pRCVStruct->pSession;
	ASSERT (pRTPSession);

	// If Winsock error or runt packet(used to cancel recvs), signal completion to application 
	// and do not repost.
	if (dwError || cbTransferred < RTP_HDR_MIN_LEN)
		{
		// don't report closeSocket() as an error when the application
		//  have some pending buffers remaining
		if ((dwError != 65534) && (dwError == WSA_OPERATION_ABORTED))
			{
			RRCM_DBG_MSG ("RTP : RCV Callback", dwError, 
						  __FILE__, __LINE__, DBG_ERROR);
			}

		// notify the user if an error occured, so he can free up 
		// its receive resources. The byte count is set to 0

		// Reinstate the AppSs WSAEVENT
		pOverlapped->hEvent = pRCVStruct->hEvent;
			
		// And call the apps completion routine
		pRCVStruct->pfnCompletionNotification (dwError,
					       					   cbTransferred,
						       				   pOverlapped,
						       				   dwFlags);

		// Return the struct to the free queue
		addToHeadOfList (&pRTPSession->pRTPFreeList,
				 	  	 (PLINK_LIST)pRCVStruct,
						 &pRTPSession->critSect);

		IN_OUT_STR ("RTP : Exit RTPReceiveCallback()\n");
		return;
		}

	// Perform validity checking
    pRTPHeader = (RTP_HDR_T *)pRCVStruct->pBuffer->buf;
	ASSERT (pRTPHeader);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
	if (RTPLogger)
		{
		//INTEROP
		InteropOutput (RTPLogger,
					   (BYTE FAR*)(pRCVStruct->pBuffer->buf),
					   (int)cbTransferred,
					   RTPLOG_RECEIVED_PDU | RTP_PDU);
		}
#endif

	// Check RTP Headers for validity.  If not valid, then repost buffers 
	// to the network layer for a new receive.
	if (validateRTPHeader (pRTPHeader) && (dwError == 0)) 
		{
		// Get pointer to SSRC entry table for this session
		// If SSRC in packet is > 1/2 MAX_RANGE of DWORD, start search from
		//	tail of SSRC list, otherwise, start from front
		RRCMws.ntohl (pRCVStruct->RTPsocket, pRTPHeader->ssrc, &dwSSRC);
					    
		if (dwSSRC > MAX_DWORD/2) 
			{
			pSSRC = searchforSSRCatTail (
				(PSSRC_ENTRY)pRTPSession->pRTCPSession->RcvSSRCList.prev,
				dwSSRC);
			}
		else 
			{
			pSSRC = searchforSSRCatHead (
				(PSSRC_ENTRY)pRTPSession->pRTCPSession->RcvSSRCList.next,
				dwSSRC);
			}

		// get my own SSRC used for this stream
		pMySSRC = searchForMySSRC (
			(PSSRC_ENTRY)pRTPSession->pRTCPSession->XmtSSRCList.prev,
			pRCVStruct->RTPsocket);
		ASSERT (pMySSRC);
		
		// is this SSRC already known on the receive list ?
		if (pSSRC == NULL) 
			{
			// don't create an entry for my own packet looping back on 
			// a mcast group where loopback has not been turned off
			if (pMySSRC->SSRC != dwSSRC)
				{
				// new party heard from. Create an entry for it
				pSSRC = createSSRCEntry (dwSSRC,
										 pRTPSession->pRTCPSession,
										 (PSOCKADDR)pRCVStruct->pFrom,
										 (DWORD)*pRCVStruct->pFromlen,
										 FALSE);

				// notify application if interested
				RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, dwSSRC, 
								  pRTPHeader->pt);
				}
			else
				{
				// my own SSRC received back

				// A collision occurs if the SSRC in the rcvd packet is 
				// equal to mine, and the network transport address is
				// different from mine.
				// A loop occurs if after a collision has been resolved the
				// SSRC collides again from the same source transport address
				pSSRCadr = (PSOCKADDR_IN)&pMySSRC->from;
				if (((PSOCKADDR_IN)pRCVStruct->pFrom)->sin_addr.S_un.S_addr !=
					  pSSRCadr->sin_addr.S_un.S_addr)
					{
					// check if the source address is already in the 
					// conflicting table. This identifes that somebody out 
					// there is looping pckts back to me
					if (RRCMChkCollisionTable ((PSOCKADDR)pRCVStruct->pFrom,*pRCVStruct->pFromlen, pMySSRC))
						{
						RRCM_DBG_MSG ("RTP : Loop Detected ...", 0, NULL, 0,
										DBG_NOTIFY);

						// loop already known
						dwRequeue |= SSRC_LOOP_DETECTED;
						}
					else
						{
						RRCM_DBG_MSG ("RTP : Collision Detected ...", 0, NULL, 0,
										DBG_NOTIFY);

						// create new entry in conflicting address table 
						RRCMAddEntryToCollisionTable ((PSOCKADDR)pRCVStruct->pFrom,*pRCVStruct->pFromlen, pMySSRC);

						// send RTCP BYE packet w/ old SSRC 
						RTCPsendBYE (pMySSRC, "Loop/collision detected");

						// select new SSRC
						oldSSRC = pMySSRC->SSRC;
						dwSSRC  = getSSRC (pMySSRC->pRTCPses->RcvSSRCList, 
										   pMySSRC->pRTCPses->XmtSSRCList);

					 	EnterCriticalSection (&pMySSRC->critSect);
						pMySSRC->SSRC = dwSSRC;
					 	LeaveCriticalSection (&pMySSRC->critSect);

						// create new entry w/ old SSRC plus actual source
						// transport address in our receive list side, so the 
						// packet actually en-route will be dealt with
						createSSRCEntry (oldSSRC,
										 pRTPSession->pRTCPSession,
										 (PSOCKADDR)pRCVStruct->pFrom,
										 (DWORD)*pRCVStruct->pFromlen,
										 FALSE);

						// notify application if interested
						RRCMnotification (RRCM_LOCAL_COLLISION_EVENT, 
										  pMySSRC, oldSSRC, 0);

						// loop already known
						dwRequeue |= SSRC_COLLISION_DETECTED;
						}
					}
				else
					{
					// own packet looped back because the sender joined the
					// multicast group and loopback is not turned off
					dwRequeue |= MCAST_LOOPBACK_NOT_OFF;
					}
				}
			}
		else if (pSSRC->dwSSRCStatus & THIRD_PARTY_COLLISION)
			{
			// this SSRC is marked as colliding. Reject the data
			dwRequeue = THIRD_PARTY_COLLISION;
			}

		if ((pSSRC != NULL)  && (dwRequeue == 0))
			{
			// do all the statistical updating stuff
			updateRTPStats (pRTPHeader, pSSRC, cbTransferred);

			// update the payload type for this SSRC
			pSSRC->PayLoadType = pRTPHeader->pt;

			// Reinstate the AppSs WSAEVENT
			pOverlapped->hEvent = pRCVStruct->hEvent;
			
			// And call the apps completion routine
			pRCVStruct->pfnCompletionNotification (dwError,
						       					   cbTransferred,
							       				   pOverlapped,
							       				   dwFlags);

			// Return the struct to the free queue
			addToHeadOfList (&pRTPSession->pRTPFreeList,
					 	  	 (PLINK_LIST)pRCVStruct,
							 &pRTPSession->critSect);
			}	// SSRCList != NULL
		}		// valid RTP Header
	else 
		{
		dwRequeue |= INVALID_RTP_HEADER;
		}

	if (dwRequeue) 
		{
		// The RTP packet was invalid for some reason
		RTPpostRecvBfr (dwError, cbTransferred, pOverlapped, dwFlags);
		} 

	IN_OUT_STR ("RTP : Exit RTPReceiveCallback()\n");
	}


/*----------------------------------------------------------------------------
 * Function   : saveRCVWinsockContext
 * Description: Saves context for this buffer so that when a completion 
 *				routine	returns with a handle, we know exactly what 
 *				buffer/stream this refers to.
 * 
 * Input :		pOverlapped		:	-> to overlapped structure
 *				pBuffers		:	-> to WSA buffers
 *				pFunc			:	-> to completion routine 
 *				pSession		:	-> to the RTP session
 *				dwBufferCount	:	Number of WSA buffers
 *				pNumBytesRecvd	:	-> to number of bytes received 
 *				pFlags			:	-> to flags
 *				pFrom			:	-> to the From address field
 *				pFromlen		:	-> to the from address field length
 *				RTPsocket		:	RTP socket descriptor
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Check RRCM.h file for references.
 ---------------------------------------------------------------------------*/
DWORD CALLBACK saveRCVWinsockContext(LPWSAOVERLAPPED pOverlapped,
				   					 LPWSABUF pBuffers,
				   					 LPWSAOVERLAPPED_COMPLETION_ROUTINE pFunc, 
				   					 PRTP_SESSION pSession,
								   	 DWORD dwBufferCount,
							   		 LPDWORD pNumBytesRecvd, 
									 LPDWORD pFlags,
							      	 LPVOID pFrom,
							      	 LPINT pFromlen,
							      	 SOCKET RTPsocket)
	{
	PRTP_BFR_LIST	pNewCell;
	DWORD			dwStatus = RRCM_NoError;
	DWORD			numCells = NUM_FREE_CONTEXT_CELLS;

	IN_OUT_STR ("RTP : Enter saveRCVWinsockContext()\n");
	
	// Get a PRTP Buffer from the free list
	pNewCell = (PRTP_BFR_LIST)removePcktFromTail (
								(PLINK_LIST)&pSession->pRTPFreeList,
								&pSession->critSect);

	if (pNewCell == NULL)
		{
		// try to reallocate some free cells
		if (pSession->dwNumTimesFreeListAllocated <= MAXNUM_CONTEXT_CELLS_REALLOC)
			{
			// increment the number of reallocated times even if the realloc
			//   fails next. Will avoid trying to realloc of a realloc problem
			pSession->dwNumTimesFreeListAllocated++;

			if (allocateLinkedList (&pSession->pRTPFreeList, 
								    pSession->hHeapFreeList,
		   							&numCells,
	   								sizeof(RTP_BFR_LIST),
									&pSession->critSect) == RRCM_NoError)
				{		 						
				pNewCell = (PRTP_BFR_LIST)removePcktFromTail (
											(PLINK_LIST)&pSession->pRTPFreeList,
											&pSession->critSect);
				}
			}
		}

	if (pNewCell != NULL) 
		{
		// Initialize the params
		pNewCell->hEvent		  = pOverlapped->hEvent;
		pNewCell->pBuffer		  = pBuffers;
		pNewCell->pSession		  = pSession;
		pNewCell->dwFlags		  = *pFlags;
		pNewCell->pFrom			  = pFrom;
		pNewCell->pFromlen		  = pFromlen;
		pNewCell->RTPsocket		  = RTPsocket;
		pNewCell->dwBufferCount   = dwBufferCount;
		pNewCell->pfnCompletionNotification = pFunc;		
		
		// Overwrite the hEvent handed down from app.  
		// Will return the real one when the completion routine is called
		pOverlapped->hEvent = (WSAEVENT)pNewCell;
		}
	else
		dwStatus = RRCMError_RTPResources;

	IN_OUT_STR ("RTP : Exit saveRCVWinsockContext()\n");
	
	return (dwStatus);
	}



/*----------------------------------------------------------------------------
 * Function   : RTPpostRecvBfr
 * Description: RTP post a receive buffer to Winsock
 * 
 * Input :      dwError			: Error code
 *    			cbTransferred	: Bytes transferred
 *				pOverlapped		: -> to overlapped structure
 *				dwFlags			: Flags
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
 void RTPpostRecvBfr (DWORD dwError,
           			  DWORD cbTransferred,
           			  LPWSAOVERLAPPED pOverlapped,
           			  DWORD dwFlags)
	{
	DWORD			dwStatus;
	PRTP_BFR_LIST  	pRCVStruct;
	PRTP_SESSION	pRTPSession;

	IN_OUT_STR ("RTP : Enter RTPpostRecvBfr\n");

	// Reuse the packet with another receive
	pRCVStruct = (PRTP_BFR_LIST)pOverlapped->hEvent;

	// Corresponding RTP session
	pRTPSession = (PRTP_SESSION)pRCVStruct->pSession;

	dwStatus = RRCMws.recvFrom (pRCVStruct->RTPsocket,
		   			  			pRCVStruct->pBuffer,
			              		pRCVStruct->dwBufferCount,
			   			  		&cbTransferred, 
			   			  		&pRCVStruct->dwFlags,
			   			  		(PSOCKADDR)pRCVStruct->pFrom,
			    		  		pRCVStruct->pFromlen,
			   			  		pOverlapped, 
			   			  		RTPReceiveCallback); 

	// Check if Winsock Call succeeded
	if (dwStatus == SOCKET_ERROR) 
		{
		// If serious error, the receive request won't proceed
		dwStatus = GetLastError();
		if ((dwStatus != WSA_IO_PENDING) && (dwStatus != WSAEMSGSIZE)) 
			{
			RRCM_DBG_MSG ("RTP : ERROR - WSARecvFrom()", dwError, 
						  __FILE__, __LINE__, DBG_ERROR);

			// notify the user if an error occured, so he can free up 
			// its receive resources. The byte count is set to 0

			// Reinstate the AppSs WSAEVENT
			pOverlapped->hEvent = pRCVStruct->hEvent;
			
			// And call the apps completion routine
			pRCVStruct->pfnCompletionNotification (dwStatus,
					       					       0,
								       			   pOverlapped,
								       			   dwFlags);

			// Return the receive structure to the free list
			addToHeadOfList (&pRTPSession->pRTPFreeList,
					 	  	 (PLINK_LIST)pRCVStruct,
							 &pRTPSession->critSect);
			}
		}

	IN_OUT_STR ("RTP : Exit RTPpostRecvBfr\n");
	}
#endif


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\rtpsend.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTPSEND.C
 * Product:     RTP/RTCP implementation
 * Description: Provides WSA Send functions.
 *
 * This listing is supplied under the terms 
 * of a license agreement with Intel Corporation and
 * many not be copied nor disclosed except in accordance
 * with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            



/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT		pRTPContext;
extern RRCM_WS			RRCMws;


#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif


/*----------------------------------------------------------------------------
 * Function   : RTPSendTo
 * Description: Intercepts sendto requests from the application.  
 *				Handles any statistical	processing required for RTCP.  
 *				Copies completion routine from app and substitutes its own.  
 *				Apps completion routine	will be called after RTP's completion 
 *				routine gets called by Winsock2.
 * 
 * Input :	RTPsocket:			RTP socket descriptor
 *			pBufs:				-> to WSAbuf structure
 *		  	dwBufCount:			Buffer count in WSAbuf structure
 *			pNumBytesSent:		-> to number of bytes sent
 *			socketFlags:		Flags
 *			pTo:				-> to the destination address
 *			toLen:				Destination address length
 *			pOverlapped:		-> to overlapped I/O structure
 *			pCompletionRoutine:	-> to completion routine
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Check RRCM.h file for references.
 ---------------------------------------------------------------------------*/
 DWORD WINAPI RTPSendTo (
 						  HANDLE hRTPSess,
 						  SOCKET RTPsocket,
					      LPWSABUF pBufs,
						  DWORD  dwBufCount,
						  LPDWORD pNumBytesSent, 
						  int socketFlags,
						  LPVOID pTo,
						  int toLen,
						  LPWSAOVERLAPPED pOverlapped, 
						  LPWSAOVERLAPPED_COMPLETION_ROUTINE pCompletionRoutine)
	{
	int				dwStatus;
	int				dwErrorStatus;
	PRTP_SESSION	pRTPSession = (PRTP_SESSION) hRTPSess;
	RTP_HDR_T 		*pRTPHeader;
	PSSRC_ENTRY		pSSRC;

	IN_OUT_STR ("RTP : Enter RTPSendTo()\n");

	// If RTP context doesn't exist, report error and return.
	if (pRTPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - No RTP Instance", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit RTPSendTo()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalid));
		}

	ASSERT(pRTPSession);
	
	// Complete filling in header.  First cast a pointer
	// of type RTP_HDR_T to ease accessing
	pRTPHeader = (RTP_HDR_T *)pBufs->buf;
	ASSERT (pRTPHeader);
			
	// Now setup some of the RTP header fields
	pRTPHeader->type = RTP_TYPE;	// RTP Version 2

	// Get pointer to our entry in SSRC table for this session
	pSSRC = searchForMySSRC (
		(PSSRC_ENTRY)pRTPSession->pRTCPSession->XmtSSRCList.prev,
		RTPsocket);
	ASSERT (pSSRC);

	// lock out access to this RTCP session variable 
	EnterCriticalSection (&pSSRC->critSect);

	// save the RTP timestamp
    RRCMws.ntohl (RTPsocket, pRTPHeader->ts, 
					&pSSRC->xmtInfo.dwLastSendRTPTimeStamp);

	// save the last transmit time
	pSSRC->xmtInfo.dwLastSendRTPSystemTime = timeGetTime ();

	// copy over sequence number sent
	RRCMws.ntohs (RTPsocket, pRTPHeader->seq, 
				  (WORD *)&pSSRC->xmtInfo.dwCurXmtSeqNum);

	// SSRC
    RRCMws.htonl (RTPsocket, pSSRC->SSRC, &pRTPHeader->ssrc);

	// Update initial XmtSeqNum so RTCP knows the baseline
	if ((pSSRC->dwSSRCStatus & SEQ_NUM_UPDATED) == 0) 
		{
		pSSRC->xmtInfo.dwPrvXmtSeqNum = pSSRC->xmtInfo.dwCurXmtSeqNum;
		pSSRC->dwSSRCStatus |= SEQ_NUM_UPDATED;
		}

	// update the payload type for this SSRC_ENTRY
	pSSRC->PayLoadType = pRTPHeader->pt;

 	// unlock pointer access 
	LeaveCriticalSection (&pSSRC->critSect);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
		if (RTPLogger)
			{
			//INTEROP
			InteropOutput (RTPLogger,
					       (BYTE FAR*)(pBufs->buf),
						   (int)pBufs->len,
						   RTPLOG_SENT_PDU | RTP_PDU);
			}
#endif

		dwStatus = RRCMws.sendTo (RTPsocket,
		   					      pBufs,
								  dwBufCount,
				   				  pNumBytesSent, 
				   				  socketFlags,
			   					  (PSOCKADDR)pTo,
			    				  toLen,
			   					  pOverlapped, 
			   					  pCompletionRoutine);


	if (dwStatus != SOCKET_ERROR || GetLastError() == WSA_IO_PENDING)
	{
		DWORD i, cbTransferred = 0;
		// assume the send will succeed
		/* lock out access to this RTCP session variable */
		EnterCriticalSection (&pSSRC->critSect);

		// calculate statistics (-DWORD) for the CRSC entry defined 
		// in the RTP header (but we should remove it from the data structure)
		for (i = 0;i < dwBufCount; i++)
			cbTransferred += pBufs[i].len;
			
	    pSSRC->xmtInfo.dwNumBytesSent += (cbTransferred -
	    							(sizeof(RTP_HDR_T) - sizeof(DWORD)));

	    pSSRC->xmtInfo.dwNumPcktSent++;
			    
	 	/* unlock access */
		LeaveCriticalSection (&pSSRC->critSect);
	}

	IN_OUT_STR ("RTP : Exit RTPSendTo()\n");

	return (dwStatus);
	}




// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\thread.cpp ===
#include "stdafx.h"
#include "thread.h"
// general purpose worker thread
// The thread exists in an alertable Wait state and does most of its work
// in APCs.
CEventThread::CEventThread()
{
	InitializeCriticalSection(&m_cs);
	m_uRef=0;
	m_dwFlags = 0;
	m_hThread = 0;
	m_hSignalEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
	m_hAckEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
}

CEventThread::~CEventThread()
{
	DeleteCriticalSection(&m_cs);
	if (m_hSignalEvent)
		CloseHandle(m_hSignalEvent);
	if (m_hAckEvent)
		CloseHandle(m_hAckEvent);
}

BOOL
CEventThread::Start()
{
	BOOL fRet;
	EnterCriticalSection(&m_cs);
	if (++m_uRef == 1)
	{
		m_hThread = CreateThread(
			NULL,0,
			EventThreadProc,
			this, 0, &m_idThread);
	}
	fRet = !!m_hThread;
	LeaveCriticalSection(&m_cs);
	return fRet;
}

BOOL
CEventThread::Stop()
{
	BOOL fRet;
	EnterCriticalSection(&m_cs);
	if (--m_uRef == 0)
	{
		m_dwFlags |= CTHREADF_STOP;
		SetEvent(m_hSignalEvent);
		WaitForSingleObject(m_hThread, INFINITE);
		CloseHandle(m_hThread);
		m_hThread = NULL;
		m_dwFlags &= ~CTHREADF_STOP;
	}
	LeaveCriticalSection(&m_cs);
	return TRUE;
}

DWORD
CEventThread::ThreadMethod()
{
	DWORD dwWait;
	while (1) {
		dwWait = WaitForSingleObjectEx(m_hSignalEvent, INFINITE, TRUE);
		if (dwWait == WAIT_OBJECT_0)
		{
			if (m_dwFlags & CTHREADF_STOP)
			{
				break;	// exit thread
			}
		}
		else if (dwWait == WAIT_IO_COMPLETION)
		{
			 
		}
		else
		if (dwWait == WAIT_FAILED)
		{
			break;	// exit thread
		}
	}

	return dwWait;
}

// Executes the CallProc in the worker thread in a synchronous fashion
// (similar to SendMessage). When this method returns the CallProc has been called
// and the return value is returned.
BOOL CEventThread::CallNow(THREADCALLBACK CallProc, PVOID pParam, DWORD dwParam)
{
	BOOL fRet = FALSE;
	EnterCriticalSection(&m_cs);
	m_Callback.CallProc = CallProc;
	m_Callback.pParam = pParam;
	m_Callback.dwParam = dwParam;
	ResetEvent(m_hAckEvent);
	if (QueueUserAPC(HandleCallNowAPC, m_hThread, (DWORD)this))
	{
		DWORD dwWait;
		dwWait = WaitForSingleObject(m_hAckEvent, INFINITE);
		if (dwWait == WAIT_OBJECT_0)
			fRet = (BOOL) m_Callback.dwParam;	//get the cached return value
	}
	LeaveCriticalSection(&m_cs);
	return fRet;
}

void APIENTRY CEventThread::HandleCallNowAPC(DWORD dwArg)
{
	CEventThread *pThis = (CEventThread *)dwArg;
	if (pThis->m_Callback.CallProc)
	{
		pThis->m_Callback.dwParam = pThis->m_Callback.CallProc(pThis->m_Callback.pParam, pThis->m_Callback.dwParam);
		SetEvent(pThis->m_hAckEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\thread.h ===
typedef BOOL (* THREADCALLBACK)(PVOID pParam, DWORD dwParam);

// general purpose worker thread
// The thread exists in an alertable Wait state and does most of its work
// in APCs.

struct ThreadCallback
{
	THREADCALLBACK CallProc;
	PVOID pParam;
	DWORD dwParam;
};

class CEventThread
{
public:
	CEventThread();
	~CEventThread();
	int Start();
	int Stop();
	BOOL CallNow(THREADCALLBACK CallProc, PVOID pParam, DWORD dwParam);
	//BOOL WaitOnEvent(THREADCALLBACK OnEventProc, PVOID pParam, DWORD dwParam);
private:
#define CTHREADF_STOP		0x00000001
	static DWORD  __stdcall EventThreadProc(PVOID pObj)
	{
		return ((class CEventThread *)pObj)->ThreadMethod();
	}
	static void APIENTRY HandleCallNowAPC(DWORD dwArg);
	DWORD ThreadMethod();

	HANDLE m_hThread;
	DWORD m_idThread;
	UINT m_uRef;
	HANDLE m_hSignalEvent;	// signal to worker thread to do something
	HANDLE m_hAckEvent;		// ack from worker thread
	DWORD m_dwFlags;
	CRITICAL_SECTION m_cs;	// serializes client calls. Not used by worker thread
	ThreadCallback m_Callback;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\avdefs.h ===
// File: avDefs.h

#ifndef _AVDEFS_H_

//To bring in the video stuff...from the NAC interface
#ifndef WSA_IO_PENDING

typedef struct _OVERLAPPED *    LPWSAOVERLAPPED;

typedef struct _WSABUF {
    u_long      len;     /* the length of the buffer */
    char FAR *  buf;     /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;

typedef
void
(CALLBACK * LPWSAOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwError,
    DWORD cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwFlags
    );

#define WSA_IO_PENDING          (ERROR_IO_PENDING)

#endif // } WSA_IO_PENDING

#include <mmreg.h>
#include <msacm.h>
#include <vidinout.h>
#include <vcmstrm.h>
#include <iacapapi.h>

#endif /* _AVDEFS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\clrefcnt.cpp ===
// File: clrefcnt.cpp
//
// RefCount class

#include "precomp.h"


/*  R E F  C O U N T  */
/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount(OBJECTDESTROYEDPROC ObjectDestroyed)
{
	ASSERT((!ObjectDestroyed) ||
		IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

	m_ulcRef = 1;
	m_ObjectDestroyed = ObjectDestroyed;
	DbgMsgRefCount("Ref: %08X c=%d (created)", this, m_ulcRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
}


RefCount::~RefCount(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	// m_ulcRef may be any value.
	DbgMsgRefCount("Ref: %08X c=%d (destroyed)", this, m_ulcRef);

	if (m_ObjectDestroyed)
	{
		m_ObjectDestroyed();
		m_ObjectDestroyed = NULL;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	ASSERT(m_ulcRef < ULONG_MAX);
	m_ulcRef++;
	DbgMsgRefCount("Ref: %08X c=%d (AddRef)", this, m_ulcRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	return m_ulcRef;
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	if (m_ulcRef > 0)
	{
		m_ulcRef--;
	}

	ULONG ulcRef = m_ulcRef;
	DbgMsgRefCount("Ref: %08X c=%d (Release)", this, m_ulcRef);

	if (! ulcRef)
	{
		delete this;
	}

	return ulcRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\clclsfct.cpp ===
// File: clclsfct.cpp
//
// IClassFactory and related routines
//
//		ULONG DLLAddRef(void);
//		ULONG DLLRelease(void);
//
//		STDAPI DllCanUnloadNow(void);
//		VOID   DllLock(void);
//		VOID   DllRelease(void);
//
//////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "clclsfct.h"


// from imanager.cpp
PIUnknown NewNmManager(OBJECTDESTROYEDPROC ObjectDestroyed);



CCLASSCONSTRUCTOR s_cclscnstr[] =
{
	{&CLSID_NmManager2,  &NewNmManager},
};


// DLL reference count == number of class factories +
//                        number of URLs +
//                        LockServer() count

ULONG s_ulcDLLRef = 0;

///////////////////////////////////////////////////////////////////////////


/*  G E T  C L A S S  C O N S T R U C T O R  */
/*-------------------------------------------------------------------------
    %%Function: GetClassConstructor
    
-------------------------------------------------------------------------*/
HRESULT GetClassConstructor(REFCLSID rclsid, PNEWOBJECTPROC pNewObject)
{
   HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
   UINT u;

   ASSERT(IsValidREFCLSID(rclsid));
   ASSERT(IS_VALID_WRITE_PTR(pNewObject, NEWOBJECTPROC));

   *pNewObject = NULL;

   for (u = 0; u < ARRAY_ELEMENTS(s_cclscnstr); u++)
   {
      if (rclsid == *(s_cclscnstr[u].pcclsid))
      {
         *pNewObject = s_cclscnstr[u].NewObject;
         hr = S_OK;
      }
   }

   ASSERT((hr == S_OK &&
           IS_VALID_CODE_PTR(*pNewObject, NEWOBJECTPROC)) ||
          (hr == CLASS_E_CLASSNOTAVAILABLE &&
           ! *pNewObject));

   return hr;
}


VOID STDMETHODCALLTYPE DLLObjectDestroyed(void)
{
   TRACE_OUT(("DLLObjectDestroyed(): Object destroyed."));

   DllRelease();
}



/****************************** Public Functions *****************************/

ULONG DLLAddRef(void)
{
	ASSERT(s_ulcDLLRef < ULONG_MAX);

	ULONG ulcRef = ++s_ulcDLLRef;

	DbgMsgRefCount("DLLAddRef(): DLL reference count is now %lu.", ulcRef);

	return ulcRef;
}


ULONG DLLRelease(void)
{
	ULONG ulcRef;

	if (s_ulcDLLRef > 0)
	{
	  s_ulcDLLRef--;
	}

	ulcRef = s_ulcDLLRef;

	DbgMsgRefCount("DLLRelease(): DLL reference count is now %lu.", ulcRef);

	return ulcRef;
}


PULONG GetDLLRefCountPtr(void)
{
   return(&s_ulcDLLRef);
}


/********************************** Methods **********************************/


CCLClassFactory::CCLClassFactory(NEWOBJECTPROC NewObject,
                           OBJECTDESTROYEDPROC ObjectDestroyed) :
   RefCount(ObjectDestroyed)
{
	// Don't validate this until after construction.
	ASSERT(IS_VALID_CODE_PTR(NewObject, NEWOBJECTPROC));

	m_NewObject = NewObject;

	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
}


CCLClassFactory::~CCLClassFactory(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

	m_NewObject = NULL;
}


ULONG STDMETHODCALLTYPE CCLClassFactory::AddRef(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

	ULONG ulcRef = RefCount::AddRef();

	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
	return ulcRef;
}


ULONG STDMETHODCALLTYPE CCLClassFactory::Release(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

	ULONG ulcRef = RefCount::Release();
	return ulcRef;
}


HRESULT STDMETHODCALLTYPE CCLClassFactory::QueryInterface(REFIID riid, PVOID *ppvObject)
{
	HRESULT hr = S_OK;

	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
	ASSERT(IsValidREFIID(riid));
	ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

	if (riid == IID_IClassFactory)
	{
		*ppvObject = (PIClassFactory)this;
		ASSERT(IS_VALID_INTERFACE_PTR((PIClassFactory)*ppvObject, IClassFactory));
		TRACE_OUT(("CCLClassFactory::QueryInterface(): Returning IClassFactory."));
	}
	else if (riid == IID_IUnknown)
	{
		*ppvObject = (PIUnknown)this;
		ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
		TRACE_OUT(("CCLClassFactory::QueryInterface(): Returning IUnknown."));
	}
	else
	{
		*ppvObject = NULL;
		hr = E_NOINTERFACE;
		TRACE_OUT(("CCLClassFactory::QueryInterface(): Called on unknown interface."));
	}

	if (hr == S_OK)
	{
		AddRef();
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
	return hr;
}


HRESULT STDMETHODCALLTYPE CCLClassFactory::CreateInstance(PIUnknown piunkOuter,
         REFIID riid, PVOID *ppvObject)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
	ASSERT(! piunkOuter || IS_VALID_INTERFACE_PTR(piunkOuter, IUnknown));
	ASSERT(IsValidREFIID(riid));
	ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

	*ppvObject = NULL;

	if (NULL != piunkOuter)
	{
		WARNING_OUT(("CCLClassFactory::CreateInstance(): Aggregation not supported."));
		return CLASS_E_NOAGGREGATION;
	}

	PIUnknown piunk = (*m_NewObject)(  (void(__stdcall *)(void))   &DLLObjectDestroyed);
	if (NULL == piunk)
	{
		return E_OUTOFMEMORY;
	}
	
	DllLock();
	HRESULT hr = piunk->QueryInterface(riid, ppvObject);

	// N.b., the Release() method will destroy the object if the
	// QueryInterface() method failed.
	piunk->Release();

	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
	return hr;
}


HRESULT STDMETHODCALLTYPE CCLClassFactory::LockServer(BOOL fLock)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

	if (fLock)
	{
		DllLock();
	}
	else
	{
		DllRelease();
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
	return S_OK;
}


/***************************** Exported Functions ****************************/


/*  D L L  G E T  C L A S S  O B J E C T  */
/*-------------------------------------------------------------------------
    %%Function: DllGetClassObject
    
-------------------------------------------------------------------------*/
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PVOID *ppvObject)
{

	ASSERT(IsValidREFCLSID(rclsid));
	ASSERT(IsValidREFIID(riid));
	ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

	*ppvObject = NULL;

	NEWOBJECTPROC NewObject;
	HRESULT hr = GetClassConstructor(rclsid, &NewObject);
	if (S_OK != hr)
	{
		WARNING_OUT(("DllGetClassObject(): Called on unknown class."));
		return hr;
	}

	if ((riid != IID_IUnknown) && (riid != IID_IClassFactory))
	{
		WARNING_OUT(("DllGetClassObject(): Called on unknown interface."));
		return E_NOINTERFACE;
	}

	PCCLClassFactory pcf = new CCLClassFactory(NewObject,
		(void(__stdcall *)(void)) &DLLObjectDestroyed);
	if (NULL == pcf)
	{
		return E_OUTOFMEMORY;
	}

	if (riid == IID_IClassFactory)
	{
		*ppvObject = (PIClassFactory)pcf;
		ASSERT(IS_VALID_INTERFACE_PTR((PIClassFactory)*ppvObject, IClassFactory));
		TRACE_OUT(("DllGetClassObject(): Returning IClassFactory."));
	}
	else
	{
		ASSERT(riid == IID_IUnknown);
		*ppvObject = (PIUnknown)pcf;
		ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
		TRACE_OUT(("DllGetClassObject(): Returning IUnknown."));
	}

	DllLock();

	TRACE_OUT(("DllGetClassObject(): Created a new class factory."));
	return S_OK;
}


/*  D L L  C A N  U N L O A D  N O W  */
/*-------------------------------------------------------------------------
    %%Function: DllCanUnloadNow
    
-------------------------------------------------------------------------*/
STDAPI DllCanUnloadNow(void)
{
	HRESULT hr = (s_ulcDLLRef > 0) ? S_FALSE : S_OK;
	TRACE_OUT(("DllCanUnloadNow(): DLL reference count is %lu.", s_ulcDLLRef));
	return hr;
}


/*  D L L  L O C K  */
/*-------------------------------------------------------------------------
    %%Function: DllLock
    
-------------------------------------------------------------------------*/
VOID DllLock(void)
{
    InterlockedIncrement((LPLONG) &s_ulcDLLRef);
    DbgMsgRefCount("Ref: DllLock count=%d", s_ulcDLLRef);
}


/*  D L L  R E L E A S E  */
/*-------------------------------------------------------------------------
    %%Function: DllRelease
    
-------------------------------------------------------------------------*/
VOID DllRelease(void)
{
	LONG cRef = InterlockedDecrement((LPLONG) &s_ulcDLLRef);

#ifdef DEBUG
	DbgMsgRefCount("Ref: DllLock count=%d", s_ulcDLLRef);
	if (0 == cRef)
	{
		WARNING_OUT(("NMCOM.DLL Can now be unloaded"));
	}
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\audio.cpp ===
/****************************************************************************
*
*	 FILE:	   Audio.cpp
*
*	 CREATED:  Mike VanBuskirk (MikeV) 3-02-98
*
*	 CONTENTS: Audio control object
*
****************************************************************************/


#include "precomp.h"

#include "avdefs.h"
#include "audio.h"
#include "h323.h"
#include <nacguids.h>


#include "audio.h"

CAudioControl::CAudioControl(BOOL fLocal)
:	m_fPaused(FALSE),
	m_fLocal(fLocal),
	m_fChannelOpen(FALSE),
	m_fOpenPending(FALSE),
	m_fReopenPending(FALSE),
	m_fClosePending(FALSE),
	m_pCommChannel(NULL),
	m_pConnection(NULL),
	m_pMediaStream(NULL),
	m_NewFormat(INVALID_MEDIA_FORMAT)

{

}

CAudioControl::~CAudioControl()
{
	if (NULL != m_pCommChannel)
	{
		m_pCommChannel->Release();
	}
}

BOOL CAudioControl::ChanInitialize(ICommChannel* pCommChannel)
{
	ASSERT(m_pCommChannel == NULL);
	m_pCommChannel = pCommChannel;
	m_pCommChannel->AddRef();
	
	return TRUE;
}


VOID CAudioControl::Open(MEDIA_FORMAT_ID format_id)
{
	if(!m_pCommChannel)
	{
		return;
	}
	
	m_pCommChannel->PauseNetworkStream(FALSE);
	m_pCommChannel->EnableOpen(TRUE);

	if (m_fLocal)
	{

		HRESULT hr;
		// if the channel is not open and a call is in progress, now is the time
		if(m_pConnection && m_pCommChannel)
		{
			// a call is in progress
			if(!IsChannelOpen()  
				&& !m_fOpenPending)
			{
				// so, the channel is not open

				if(format_id != INVALID_MEDIA_FORMAT)
				{
					// try to open a channel using specified format 
					m_fOpenPending = TRUE;	// do this first (callbacks!)
					hr = m_pCommChannel->Open(format_id, m_pConnection);
					if(FAILED(hr))
						m_fOpenPending = FALSE;
				}
 
			}
			else if (m_fClosePending)
			{
				m_NewFormat = format_id;
				if(format_id != INVALID_MEDIA_FORMAT)
				{
					m_fClosePending = FALSE;
					m_fReopenPending = TRUE;
					hr = m_pCommChannel->Close();
				}
			}
		}
	}
	
}
VOID CAudioControl::Close()
{
	HRESULT hr;
	hr = m_pCommChannel->Close();
	// what to do about an error?
}

VOID CAudioControl::EnableXfer(BOOL fEnable)
{
	m_fXfer = fEnable;
	if(m_pCommChannel)
	{
		BOOL bPause = (fEnable)? FALSE :TRUE;
		m_pCommChannel->PauseNetworkStream(bPause);
		m_pCommChannel->EnableOpen(fEnable);
	}
	
}

BOOL CAudioControl::IsXferEnabled()
{
	return m_fXfer;
}
VOID CAudioControl::Pause(BOOL fPause)
{
	m_fPaused = fPause;
	if (m_fPaused)
	{
		EnableXfer(FALSE);
	}
	else
	{
		EnableXfer(TRUE);
	}
}


BOOL CAudioControl::Initialize(IH323CallControl *pNac, IMediaChannel *, 
    DWORD dwUser)
{
	HRESULT hr;

	m_fChannelOpen = FALSE;
	m_fOpenPending = m_fReopenPending = FALSE;
	m_fPaused = TRUE;
	EnableXfer(FALSE);	// need to store state locally, set it in OnChannelOpen

	return TRUE;
}


VOID CAudioControl::OnConnected(IH323Endpoint * lpConnection, ICommChannel *pIChannel)
{
	m_pConnection = lpConnection;
	m_fOpenPending = m_fReopenPending = m_fClosePending = FALSE;
	ChanInitialize(pIChannel);
}
VOID CAudioControl::OnChannelOpened(ICommChannel *pIChannel)
{
	m_fChannelOpen = TRUE;
	m_fOpenPending = m_fReopenPending = FALSE;
	if(!m_pMediaStream)
	{
		m_pMediaStream = m_pCommChannel->GetMediaChannel(); 
		ASSERT(m_pMediaStream);
	}
	if (m_fLocal || m_fXfer)	// start streams always if sending, or if transfer is enabled
	{
		EnableXfer(TRUE);
	}
	else
	{
		EnableXfer(FALSE);
	}


}
VOID CAudioControl::OnChannelError()
{
		m_fOpenPending = FALSE; 
}

VOID CAudioControl::OnChannelClosed()
{
	HRESULT hr;
	m_fChannelOpen = FALSE;
	if(m_fLocal && m_fReopenPending)
	{

		m_fReopenPending = FALSE;
		if(m_NewFormat != INVALID_MEDIA_FORMAT )
		{
			m_fOpenPending = TRUE;
			hr = m_pCommChannel->Open(m_NewFormat, m_pConnection);
			if(FAILED(hr))
				m_fOpenPending = FALSE;
		}
	}
	else
	{
		if(m_pCommChannel)
		{
			m_pCommChannel->Release();
			m_pCommChannel = NULL;	
		}
	}
	
}
VOID CAudioControl::OnDisconnected()
{
	m_pConnection = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\audio.h ===
/****************************************************************************
*
*	 FILE:	   audio.h
*
*	 CREATED:  Mike VanBiskirk (mikev) 2-26-98
*
****************************************************************************/

#ifndef _AUDIOUI_H_
#define _AUDIOUI_H_


class CAudioControl
{
private:

	ICommChannel*	m_pCommChannel;
	IMediaChannel*   m_pMediaStream;
	IH323Endpoint *	m_pConnection;
	
	BOOL			m_fOpenPending;
	BOOL			m_fReopenPending;
	BOOL			m_fClosePending;

	BOOL			m_fPaused;
	BOOL			m_fLocal;
	BOOL			m_fChannelOpen;
    BOOL            m_fXfer;
   	MEDIA_FORMAT_ID m_NewFormat;
   	
public:
	// Methods:
				CAudioControl(BOOL fLocal);
				~CAudioControl();
	BOOL		ChanInitialize(ICommChannel* pCommChannel);

	BOOL		IsLocal() { return m_fLocal; }
	VOID		EnableXfer(BOOL fEnable);
	VOID        Open(MEDIA_FORMAT_ID format_id);
	VOID        Close();
	BOOL		IsXferEnabled();
	VOID		Pause(BOOL fPause);
	BOOL		IsPaused() { return m_fPaused; };

	BOOL		Initialize(IH323CallControl *pNac, IMediaChannel *pMC, 
	    DWORD dwUser);
	BOOL		IsChannelOpen() { return m_fChannelOpen; }

		// Handlers:
	VOID		OnConnected(IH323Endpoint * lpConnection, ICommChannel *pIChannel);
	VOID		OnChannelOpened(ICommChannel *pIChannel);
	VOID		OnChannelError();
	VOID		OnChannelClosed();
	VOID		OnDisconnected();
};

#endif // _AUDIOUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\rrcm\rtp\ws2emul.cpp ===
#include <rrcm.h>
#include <queue.h>
// Forward declarations
DWORD WINAPI WS1MsgThread (LPVOID );
LRESULT CALLBACK WS1WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL StartWS1MsgThread();
BOOL StopWS1MsgThread();
void __stdcall SendRecvCompleteAPC(ULONG_PTR dw);

class CWS2EmulSock;

#define WM_WSA_READWRITE	(WM_USER + 100)
// structure used to store WSASendTo/WSARecvFrom parameters
struct WSAIOREQUEST {
	WSAOVERLAPPED *pOverlapped;
	WSABUF wsabuf[2];
	DWORD dwBufCount;
	union {
		struct {
			struct sockaddr *pRecvFromAddr;
			LPINT pRecvFromLen;
		};
		struct sockaddr SendToAddr;
	};
};

// global Winsock emulation state
struct WS2Emul {
#define MAX_EMUL_SOCKETS 10
	CWS2EmulSock *m_pEmulSocks[MAX_EMUL_SOCKETS];
	int		numSockets;
	HWND	hWnd;
	HANDLE 	hMsgThread;
	HANDLE 	hAckEvent;
	// external crit sect serializes the WS2EmulXX apis
	// to make them multi-thread safe
	CRITICAL_SECTION extcs;	
	// internal crit sect serializes access between
	// MsgThread and WS2EmulXX apis
	// Never claim extcs while holding intcs.
	// (Is there a more elegant way to do this?)
	CRITICAL_SECTION intcs;
	
} g_WS2Emul;

/*
	CWS2EmulSock -
	WS2 socket emulation class
	Manages  queues of overlapped i/o requests
*/

class CWS2EmulSock
{
public:
	CWS2EmulSock(int myIndex) : m_myIndex(myIndex), m_RecvThreadId(0),m_SendThreadId(0),
		m_hRecvThread(NULL), m_hSendThread(NULL), m_sock(INVALID_SOCKET)
		{ ZeroMemory(&m_SendOverlapped, sizeof(m_SendOverlapped));}
			;
	BOOL NewSock(int af, int type, int protocol);
	int Close();
	int RecvFrom(
	    LPWSABUF lpBuffers,DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags,
	    struct sockaddr FAR * lpFrom, LPINT lpFromlen,
	    LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
	int SendTo(
		LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent,DWORD dwFlags,
	    const struct sockaddr FAR * lpTo, int iTolen,
	    LPWSAOVERLAPPED lpOverlapped,LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

	LRESULT HandleMessage(WPARAM wParam, LPARAM lParam); //  WS1 window msg handler
	SOCKET GetSocket() { return m_sock;}
	WSAOVERLAPPED *GetSendOverlapped() {return &m_SendOverlapped;}
private:
	SOCKET m_sock;					// real socket handle
	int m_myIndex;					// fake socket handle
	QueueOf<WSAIOREQUEST> m_RecvQ;	// queue of overlapped recv requests
	QueueOf<WSAIOREQUEST> m_SendQ;	// queue of overlapped send requests
	WSAOVERLAPPED m_SendOverlapped; // used only for synchronous send calls
	// the following fields are used to issue Send/Recv APCs
	DWORD m_RecvThreadId;
	DWORD m_SendThreadId;
	HANDLE m_hRecvThread;		// thread issuing receive requests
	HANDLE m_hSendThread;		// thread issuing send requests
};

void WS2EmulInit()
{
	InitializeCriticalSection(&g_WS2Emul.extcs);
	InitializeCriticalSection(&g_WS2Emul.intcs);
}

void WS2EmulTerminate()
{
	DeleteCriticalSection(&g_WS2Emul.extcs);
	DeleteCriticalSection(&g_WS2Emul.intcs);
}

BOOL
CWS2EmulSock::NewSock(int af,int type, int protocol)
{
	m_sock = socket(af,type,protocol);
	if (m_sock != INVALID_SOCKET)
	{
		WSAAsyncSelect(m_sock, g_WS2Emul.hWnd, WM_WSA_READWRITE+m_myIndex, FD_READ|FD_WRITE);
	}
	return m_sock != INVALID_SOCKET;
}

int
CWS2EmulSock::RecvFrom(
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
	WSAIOREQUEST ioreq;
	int error = 0;
	
	if (lpCompletionRoutine) {
		DWORD thid = GetCurrentThreadId();
		HANDLE hCurProcess;
		if (thid != m_RecvThreadId) {
			// need to create a thread handle for QueueUserAPC
			// typically this will only happen once
			if (!m_RecvQ.IsEmpty())
			{
				// dont allow simultaneous recv access by more than one thread
				error = WSAEINVAL;
			}
			else
			{
				if (m_hRecvThread)
					CloseHandle(m_hRecvThread);
				m_hRecvThread = NULL;

				hCurProcess = GetCurrentProcess();
				m_RecvThreadId = thid;
				if (!DuplicateHandle(

	    			hCurProcess,	// handle to process with handle to duplicate
	    			GetCurrentThread(),	// handle to duplicate
	    			hCurProcess,	// handle to process to duplicate to
	    			&m_hRecvThread,	// pointer to duplicate handle
	    			0,				// access for duplicate handle
	    			FALSE,			// handle inheritance flag
	    			DUPLICATE_SAME_ACCESS 	// optional actions
	   				))
	   			{
	   				error = WSAEINVAL;
	   				m_RecvThreadId = 0;
	   			}
			}
		}
	}
	if (error || dwBufferCount != 1 || !lpOverlapped)
	{
		WSASetLastError(WSAENOBUFS);
		return SOCKET_ERROR;
	}
	
	ioreq.pOverlapped = lpOverlapped;
	if (lpOverlapped)	// cache away ptr to completion routine
		lpOverlapped->Pointer = lpCompletionRoutine;
	ioreq.pRecvFromAddr = lpFrom;
	ioreq.pRecvFromLen = lpFromlen;
	ioreq.wsabuf[0] = lpBuffers[0];
	ioreq.dwBufCount = dwBufferCount;

	m_RecvQ.Put(ioreq);
	//LOG((LOGMSG_RECVFROM1,(UINT)lpOverlapped));
	// signal WS1 send/recv thread
	PostMessage(g_WS2Emul.hWnd, WM_WSA_READWRITE+m_myIndex, m_sock, FD_READ);
	
	WSASetLastError(ERROR_IO_PENDING);
	return SOCKET_ERROR;
}

int CWS2EmulSock::SendTo(
	LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
	WSAIOREQUEST ioreq;
	int error = 0;

	if (lpCompletionRoutine) {
		DWORD thid = GetCurrentThreadId();
		HANDLE hCurProcess;
		if (thid != m_SendThreadId) {
			// need to create a thread handle for QueueUserAPC
			if (!m_SendQ.IsEmpty())
			{
				// dont allow simultaneous send access by more than one thread
				error = WSAEINVAL;
			}
			else
			{
				if (m_hSendThread)
					CloseHandle(m_hSendThread);
				m_hSendThread = NULL;

				hCurProcess = GetCurrentProcess();
				m_SendThreadId = thid;
				if (!DuplicateHandle(

	    			hCurProcess,	// handle to process with handle to duplicate
	    			GetCurrentThread(),	// handle to duplicate
	    			hCurProcess,	// handle to process to duplicate to
	    			&m_hSendThread,	// pointer to duplicate handle
	    			0,				// access for duplicate handle
	    			FALSE,			// handle inheritance flag
	    			DUPLICATE_SAME_ACCESS 	// optional actions
	   				))
	   			{
	   				error = WSAEINVAL;
	   				m_SendThreadId = 0;
	   			}
			}
		}
	}
	if (error || dwBufferCount != 1 || iTolen != sizeof(struct sockaddr) || !lpOverlapped)
	{
		WSASetLastError(WSAEINVAL);
		return SOCKET_ERROR;
	}
		
	
	ioreq.pOverlapped = lpOverlapped;
	if (lpOverlapped)	// cache away ptr to completion routine
		lpOverlapped->Pointer = lpCompletionRoutine;
	ioreq.SendToAddr = *lpTo;
	ioreq.wsabuf[0] = lpBuffers[0];
	ioreq.dwBufCount = dwBufferCount;

	m_SendQ.Put(ioreq);
	// signal WS1 send/recv thread
	PostMessage(g_WS2Emul.hWnd, WM_WSA_READWRITE+m_myIndex, m_sock, FD_WRITE);
	
	WSASetLastError(ERROR_IO_PENDING);
	return SOCKET_ERROR;
}

/*
	Close - close the socket and cancel pending i/o
*/
int
CWS2EmulSock::Close()
{
	WSAIOREQUEST ioreq;
	int status;
	
	status = closesocket(m_sock);
	m_sock = NULL;
	while (m_SendQ.Get(&ioreq))
	{
		// complete the request
		ioreq.pOverlapped->Internal = WSA_OPERATION_ABORTED;
		// if there is a callback routine, its address is cached in pOverlapped->Offset
		if (ioreq.pOverlapped->Pointer)
		{
			QueueUserAPC(SendRecvCompleteAPC,m_hSendThread,(DWORD_PTR)ioreq.pOverlapped);
		}
		else
		{
			SetEvent((HANDLE)ioreq.pOverlapped->hEvent);
		}
	}
	while (m_RecvQ.Get(&ioreq))
	{
		// complete the request
		ioreq.pOverlapped->Internal = WSA_OPERATION_ABORTED;
		if (ioreq.pOverlapped->Pointer)
		{
			QueueUserAPC(SendRecvCompleteAPC,m_hRecvThread,(DWORD_PTR)ioreq.pOverlapped);
		}
		else
		{
			SetEvent((HANDLE)ioreq.pOverlapped->hEvent);
		}
	}
	if (m_hSendThread)
	{
		CloseHandle(m_hSendThread);
		m_hSendThread = NULL;
	}
	if (m_hRecvThread)
	{
		CloseHandle(m_hRecvThread);
		m_hRecvThread = NULL;
	}
	return 0;
}

LRESULT
CWS2EmulSock::HandleMessage(WPARAM sock, LPARAM lParam)
{
	WORD wEvent= (WSAGETSELECTEVENT(lParam));
	WORD wError= (WSAGETSELECTERROR(lParam));
	int iRet;
	int status;
	WSAIOREQUEST ioreq;
	HANDLE hThread;
	// make sure the message is intended for this socket
	if ((SOCKET) sock != m_sock)
		return 0;

	// get the first RecvFrom or SendTo request, but leave it on the queue
	// in case the request blocks
	//if (wEvent == FD_READ)
	//	LOG((LOGMSG_ONREAD1, (UINT)sock));
	
	if (wEvent == FD_READ && m_RecvQ.Peek(&ioreq))
	{
		//LOG((LOGMSG_ONREAD2, (UINT)ioreq.pOverlapped));
		iRet = recvfrom(m_sock, ioreq.wsabuf[0].buf, ioreq.wsabuf[0].len, 0, ioreq.pRecvFromAddr, ioreq.pRecvFromLen);
	}
	else if (wEvent == FD_WRITE && m_SendQ.Peek(&ioreq))
	{
		iRet = sendto(m_sock, ioreq.wsabuf[0].buf, ioreq.wsabuf[0].len, 0, &ioreq.SendToAddr, sizeof(ioreq.SendToAddr));
	}
	else	// some other event or no queued request
		return 1;

	// complete send and recv
	
	if(iRet >=0)
	{
		status = 0;
		ioreq.pOverlapped->InternalHigh = iRet;	// numBytesReceived
		
	} else {
		// error (or "would block") case falls out here
		ASSERT(iRet == SOCKET_ERROR);
		status  = WSAGetLastError();
		ioreq.pOverlapped->InternalHigh = 0;
	}
	// check the error - it could be blocking
	if (status != WSAEWOULDBLOCK)
	{
		ioreq.pOverlapped->Internal = status;
		// pull request off the queue
		if (wEvent == FD_READ)
		{
			m_RecvQ.Get(NULL);
			hThread = m_hRecvThread;
			//LOG((LOGMSG_ONREADDONE1, (UINT)ioreq.pOverlapped));
		}
		else // wEvent == FD_WRITE
		{
			m_SendQ.Get(NULL);
			hThread = m_hSendThread;
		}
		
		// complete the request
		if (ioreq.pOverlapped->Pointer)
		{
			// if there is a callback routine, its address is cached in pOverlapped->Offset
			QueueUserAPC(SendRecvCompleteAPC,hThread, (DWORD_PTR)ioreq.pOverlapped);
		}
		else
		{
			SetEvent((HANDLE)ioreq.pOverlapped->hEvent);
		}
			
	}
	return 1;
}	

void __stdcall
SendRecvCompleteAPC(ULONG_PTR dw)
{
	WSAOVERLAPPED *pOverlapped = (WSAOVERLAPPED *)dw;
	LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
		= (LPWSAOVERLAPPED_COMPLETION_ROUTINE) pOverlapped->Pointer;

	//LOG((LOGMSG_RECVFROM2,(UINT)pOverlapped));
	lpCompletionRoutine((DWORD)pOverlapped->Internal, (DWORD)pOverlapped->InternalHigh, pOverlapped, 0);
}
	
inline
CWS2EmulSock *
EmulSockFromSocket(SOCKET s)
{
	return ( ((UINT) s < MAX_EMUL_SOCKETS) ? g_WS2Emul.m_pEmulSocks[s] : NULL);
}

inline SOCKET MapSocket(SOCKET s)
{
	return (((UINT) s < MAX_EMUL_SOCKETS) && g_WS2Emul.m_pEmulSocks[s] ? g_WS2Emul.m_pEmulSocks[s]->GetSocket() : INVALID_SOCKET);
}

SOCKET
PASCAL
WS2EmulSocket(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFO lpProtocolInfo,
    GROUP,
    DWORD)
{
	SOCKET s = INVALID_SOCKET;
	int i;
	CWS2EmulSock *pESock;
	if (g_WS2Emul.numSockets == MAX_EMUL_SOCKETS)
		return s;

	EnterCriticalSection(&g_WS2Emul.extcs);
	if (af == FROM_PROTOCOL_INFO)
		af = lpProtocolInfo->iAddressFamily;
	if (type == FROM_PROTOCOL_INFO)
		type = lpProtocolInfo->iSocketType;
	if (protocol == FROM_PROTOCOL_INFO)
		protocol = lpProtocolInfo->iProtocol;

	for (i=0;i<MAX_EMUL_SOCKETS;i++)
	{
		if (g_WS2Emul.m_pEmulSocks[i] == NULL)
		{
			pESock = new CWS2EmulSock(i);
			if (pESock) {
				if (++g_WS2Emul.numSockets == 1)
				{
					StartWS1MsgThread();
				}
				if (pESock->NewSock(af,type,protocol))
				{
					g_WS2Emul.m_pEmulSocks[i] = pESock;
					s = (SOCKET)i;
				} else {
					delete pESock;
					if (--g_WS2Emul.numSockets == 0)
					{
						StopWS1MsgThread();
					}
				}
			}
			break;
		}
	}
	LeaveCriticalSection(&g_WS2Emul.extcs);
	return s;
			
}

int
PASCAL
WS2EmulRecvFrom(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
	CWS2EmulSock *pESock;
	int iret;
	EnterCriticalSection(&g_WS2Emul.extcs);

	if (pESock = EmulSockFromSocket(s))
	{
		EnterCriticalSection(&g_WS2Emul.intcs);
		iret =  pESock->RecvFrom(lpBuffers, dwBufferCount, lpNumberOfBytesRecvd,
 						lpFlags,
    					lpFrom, lpFromlen,
    					lpOverlapped, lpCompletionRoutine);
    	LeaveCriticalSection(&g_WS2Emul.intcs);
    }
    else
    {
    	WSASetLastError(WSAENOTSOCK);
    	iret = SOCKET_ERROR;
    }
    LeaveCriticalSection(&g_WS2Emul.extcs);

	return iret;
}
/*----------------------------------------------------------------------------
 * Function: WS2EmulSendCB
 * Description: private Winsock callback
 * This is only called if WS2EmulSendTo is called in synchronous mode
 * (i.e.) lpOverlapped == NULL. In that case, the sync call is converted to async
 * using a private Overlapped struct, and the WS2EmulSendTo api blocks until
 * this routine sets the hEvent field to TRUE;
 * Input:
 *
 * Return: None
 *--------------------------------------------------------------------------*/
void CALLBACK WS2EmulSendCB (DWORD dwError,
						 DWORD cbTransferred,
                         LPWSAOVERLAPPED lpOverlapped,
                         DWORD dwFlags)
{
	lpOverlapped->Internal = dwError;
    lpOverlapped->InternalHigh = cbTransferred;
    lpOverlapped->hEvent = (WSAEVENT) TRUE;
}

int
PASCAL
WS2EmulSendTo(
	SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
	CWS2EmulSock *pESock;
	int iret;
	BOOL fSync = FALSE;
	
	EnterCriticalSection(&g_WS2Emul.extcs);
	if (pESock = EmulSockFromSocket(s))
	{
		if (!lpOverlapped)
		{
			// synchronous call - we use our own overlapped struct to issue the
			// send request.
			lpOverlapped = pESock->GetSendOverlapped();
			lpOverlapped->hEvent = (WSAEVENT) FALSE;	// will be set to TRUE in Callback
			lpCompletionRoutine =  &WS2EmulSendCB;
			fSync = TRUE;
		}

		EnterCriticalSection(&g_WS2Emul.intcs);
		iret = pESock->SendTo(lpBuffers, dwBufferCount, lpNumberOfBytesSent,
 						dwFlags,
    					lpTo, iTolen,
    					lpOverlapped, lpCompletionRoutine);
		LeaveCriticalSection(&g_WS2Emul.intcs);

		if (fSync) {
			DWORD dwError;
			if (iret == SOCKET_ERROR)
			{
				dwError = WSAGetLastError();
				if (dwError != WSA_IO_PENDING) {
					// there was an error so there will not be a callback
					lpOverlapped->hEvent = (WSAEVENT) TRUE;
					lpOverlapped->Internal = dwError;
				}
			}
			// wait for the call to complete
			// WS2EmulSendCB sets the hEvent field to TRUE and sets the Internal field to
			// the completion status
			while (!lpOverlapped->hEvent)
			{
				dwError =SleepEx(5000,TRUE);	// WARNING: sleeping inside a Critical Section
				ASSERT(dwError == WAIT_IO_COMPLETION);
			}
			WSASetLastError((int)lpOverlapped->Internal);
			if (lpNumberOfBytesSent)
				*lpNumberOfBytesSent = (DWORD)lpOverlapped->InternalHigh;
			iret = lpOverlapped->Internal ? SOCKET_ERROR : 0;
		}

    }
    else
    {
    	WSASetLastError(WSAENOTSOCK);
    	iret = SOCKET_ERROR;
    }
	LeaveCriticalSection(&g_WS2Emul.extcs);
	return iret;
}

int
PASCAL
WS2EmulCloseSocket(SOCKET s)
{
	CWS2EmulSock *pESock;	
	int iret;
	EnterCriticalSection(&g_WS2Emul.extcs);

	if (pESock = EmulSockFromSocket(s))
	{
		// shut out access to this socket
		// by the MsgThread
		EnterCriticalSection(&g_WS2Emul.intcs);
		g_WS2Emul.m_pEmulSocks[s] = NULL;
		pESock->Close();
		delete pESock;
		LeaveCriticalSection(&g_WS2Emul.intcs);
		if (--g_WS2Emul.numSockets == 0)
		{
			// cant stop the thread with while holding intcs
			StopWS1MsgThread();
		}

		iret =  0;
    }
    else
    {
    	WSASetLastError(WSAENOTSOCK);
    	iret = SOCKET_ERROR;
    }
	LeaveCriticalSection(&g_WS2Emul.extcs);
	return iret;
}

int
PASCAL
WS2EmulSetSockOpt(
	SOCKET s, int level,int optname,const char FAR * optval,int optlen)
{
	return setsockopt(MapSocket(s), level, optname, optval, optlen);
}

int
PASCAL
WS2EmulBind( SOCKET s, const struct sockaddr FAR * name, int namelen)
{
	return bind(MapSocket(s), name, namelen);
}

int
PASCAL
WS2EmulGetSockName(	SOCKET s, 	
    struct sockaddr * name,	
    int * namelen )
{
	return getsockname(MapSocket(s), name, namelen);
}

int
PASCAL
WS2EmulHtonl(
    SOCKET s,
    u_long hostlong,
    u_long FAR * lpnetlong
    )
{
	*lpnetlong = htonl(hostlong);
	return 0;
}
int
PASCAL
WS2EmulHtons(
    SOCKET s,
    u_short hostshort,
    u_short FAR * lpnetshort
    )
{
	*lpnetshort = htons(hostshort);
	return 0;
}

int
PASCAL
WS2EmulNtohl(
    SOCKET s,
    u_long netlong,
    u_long FAR * lphostlong
    )
{
	*lphostlong = ntohl(netlong);
	return 0;
}

int
PASCAL
WS2EmulNtohs(
    SOCKET s,
    u_short netshort,
    u_short FAR * lphostshort
    )
{
	*lphostshort = ntohs(netshort);
	return 0;
}

int
PASCAL
WS2EmulGetHostName(char *name, int namelen)
{
	return gethostname(name, namelen);
}

struct hostent FAR *
PASCAL
WS2EmulGetHostByName(const char * name)
{
	return gethostbyname(name);
}

SOCKET
PASCAL
WS2EmulJoinLeaf(
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    DWORD dwFlags
    )
{
	ASSERT(0);
	return (-1);
}

int
PASCAL
WS2EmulIoctl(SOCKET s,    DWORD dwIoControlCode,    LPVOID lpvInBuffer,
    DWORD cbInBuffer,    LPVOID lpvOutBuffer,    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,    LPWSAOVERLAPPED,    LPWSAOVERLAPPED_COMPLETION_ROUTINE
    )

{
	ASSERT(0);
	return -1;
}

BOOL StartWS1MsgThread()
{
	DWORD threadId;
	DWORD dwStatus;
	ASSERT(g_WS2Emul.hMsgThread == 0);
	g_WS2Emul.hAckEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
	g_WS2Emul.hMsgThread = CreateThread(NULL,0, WS1MsgThread, 0, 0, &threadId);
	dwStatus = WaitForSingleObject(g_WS2Emul.hAckEvent,INFINITE);
	return dwStatus == WAIT_OBJECT_0;
}

BOOL StopWS1MsgThread()
{
	if (g_WS2Emul.hMsgThread && g_WS2Emul.hWnd)
	{
		PostMessage(g_WS2Emul.hWnd, WM_CLOSE, 0, 0);
		WaitForSingleObject(g_WS2Emul.hMsgThread,INFINITE);
		CloseHandle(g_WS2Emul.hMsgThread);
		CloseHandle(g_WS2Emul.hAckEvent);
		g_WS2Emul.hMsgThread = NULL;
		g_WS2Emul.hAckEvent = NULL;
	}
	return TRUE;
}

LRESULT CALLBACK WS1WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int i;
	CWS2EmulSock *pESock;
	EnterCriticalSection(&g_WS2Emul.intcs);
	
	if (pESock = EmulSockFromSocket(msg - WM_WSA_READWRITE))
	{
		
		LRESULT l = pESock->HandleMessage(wParam, lParam);
		LeaveCriticalSection(&g_WS2Emul.intcs);
		return l;
	}
	LeaveCriticalSection(&g_WS2Emul.intcs);
	if (msg == WM_DESTROY)
		PostQuitMessage(0);

	return (DefWindowProc(hWnd, msg, wParam, lParam));
}

DWORD WINAPI WS1MsgThread (LPVOID )
{

	HRESULT hr;
	BOOL fChange = FALSE;
	MSG msg;

	// Register hidden window class:
	WNDCLASS wcHidden =
	{
		0L,
		WS1WindowProc,
		0,
		0,
		GetModuleHandle(NULL),
		NULL,
		NULL,
		NULL,
		NULL,
		"WS1EmulWindowClass"
	};
	if (RegisterClass(&wcHidden)) {
	// Create hidden window
			// Create a hidden window for event processing:
		g_WS2Emul.hWnd = ::CreateWindow(	"WS1EmulWindowClass",
										"",
										WS_POPUP, // not visible!
										0, 0, 0, 0,
										NULL,
										NULL,
										GetModuleHandle(NULL),
										NULL);
		
	}

	if(!g_WS2Emul.hWnd)
	{	
		hr = GetLastError();
		goto CLEANUPEXIT;
	}
	//SetThreadPriority(m_hRecvThread, THREAD_PRIORITY_ABOVE_NORMAL);

    // This function is guaranteed to create a queue on this thread
    PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

	// notify thread creator that we're ready to recv messages
	SetEvent(g_WS2Emul.hAckEvent);


	// Wait for control messages  or Winsock messages directed to
	// our hidden window
	while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
	g_WS2Emul.hWnd = NULL;
    hr = S_OK;

CLEANUPEXIT:
	UnregisterClass("WS1EmulWindowClass",GetModuleHandle(NULL));
    SetEvent(g_WS2Emul.hAckEvent);
    return hr;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\clclsfct.h ===
// File: clclsfct.h

#ifndef _CLCLSFCT_H_
#define _CLCLSFCT_H_


//////////////////////////////////////////////////////////////////////////
// New Object
typedef PIUnknown (*NEWOBJECTPROC)(OBJECTDESTROYEDPROC);
DECLARE_STANDARD_TYPES(NEWOBJECTPROC);

typedef struct classconstructor
{
	PCCLSID pcclsid;

	NEWOBJECTPROC NewObject;
}
CLASSCONSTRUCTOR;
DECLARE_STANDARD_TYPES(CLASSCONSTRUCTOR);



//////////////////////////////////////////////////////////////////////////
// object class factory
class CCLClassFactory : public RefCount, public IClassFactory
{
private:
	NEWOBJECTPROC m_NewObject;

public:
	CCLClassFactory(NEWOBJECTPROC NewObject, OBJECTDESTROYEDPROC ObjectDestroyed);
	~CCLClassFactory(void);

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);

	// IClassFactory methods
	HRESULT STDMETHODCALLTYPE CreateInstance(PIUnknown piunkOuter, REFIID riid, PVOID *ppvObject);
	HRESULT STDMETHODCALLTYPE LockServer(BOOL bLock);

};
DECLARE_STANDARD_TYPES(CCLClassFactory);


HRESULT GetClassConstructor(REFCLSID rclsid, PNEWOBJECTPROC pNewObject);

VOID DllLock(void);
VOID DllRelease(void);

#endif /* _CLCLSFCT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\confqos.cpp ===
// File: confqos.cpp

#include "precomp.h"

#include <nacguids.h>
#include <initguid.h>
#include <datguids.h>
#include <common.h>
#include <nmqos.h>
#include "confqos.h"

/***************************************************************************

    Name      : CQoS

    Purpose   :

    Parameters:	NONE

    Returns   : HRESULT

    Comment   :

***************************************************************************/
CQoS::CQoS() :
    m_pIQoS(NULL)
{
}

/***************************************************************************

    Name      : ~CQoS

    Purpose   : Releases the Quality of Service objects and frees the DLL

    Parameters:	NONE

    Returns   : HRESULT

    Comment   :

***************************************************************************/
CQoS::~CQoS()
{
	// release the object
	if (m_pIQoS)
    {
		m_pIQoS->Release();
    }
}

/***************************************************************************

    Name      : Initialize

    Purpose   : Loads the QoS DLL and instantiates a QoS object

    Parameters:	hWnd    - handle to the window/dialog which called us

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::Initialize(void)
{
	HRESULT hr = S_OK;

	// create the QoS object and get the IQoS interface
	// CoInitialize is called in conf.cpp
	hr = CoCreateInstance(	CLSID_QoS,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_IQoS,
							(void **) &m_pIQoS);
	if (FAILED(hr))
	{
		WARNING_OUT(("CQoS: Could not obtain an IQoS interface, hr=0x%08lX", hr));		
	}
	else
	{
		SetClients();
		// Tell the QoS about available resources. Since the wizard will
        // provide the bandwidth info, we'll have to call SetResources
		// again later with the bandwidth, but we need to call it here
		// to make the CPU info available to the wizard
		SetResources(BW_288KBS_BITS);
	}

    return hr;
}

/***************************************************************************

    Name      : CQoS::SetResources

    Purpose   : Sets the initial available resources on the QoS module,
					i.e. configures the QoS module to how much is
					available from each resource.

    Parameters:	nBandWidth  - Maximum connection speed

    Returns   : HRESULT

    Comment   : The QoS module may select to override these settings

***************************************************************************/
HRESULT CQoS::SetResources(int nBandWidth)
{
	LPRESOURCELIST prl = NULL;
	HRESULT hr = S_OK;
    const int cResources = 3;

    ASSERT(m_pIQoS);

    DbgMsg(iZONE_API, "CQoS: SetResources(Bandwidth = %d)", nBandWidth);

    // allocate space for the resource list (which already includes
	// space for one resource), plus (cResources-1) more resources
	prl = (LPRESOURCELIST) MemAlloc(sizeof(RESOURCELIST) +
									(cResources-1)*sizeof(RESOURCE));
	if (NULL == prl)
	{
		ERROR_OUT(("CQoS: SetResources - MemAlloc failed"));
	}
	else
	{
        ZeroMemory(prl, sizeof(RESOURCELIST) + (cResources-1)*sizeof(RESOURCE));

		// fill in the resource list
		prl->cResources = cResources;
		prl->aResources[0].resourceID = RESOURCE_OUTGOING_BANDWIDTH;
		prl->aResources[0].nUnits = nBandWidth;
		prl->aResources[1].resourceID = RESOURCE_INCOMING_BANDWIDTH;
		prl->aResources[1].nUnits = nBandWidth;
		prl->aResources[2].resourceID = RESOURCE_CPU_CYCLES;
		prl->aResources[2].nUnits = MSECS_PER_SEC;

		// set the resources on the QoS object
		hr = m_pIQoS->SetResources(prl);
		if (FAILED(hr))
		{
			ERROR_OUT(("CQoS: SetResources: Fail, hr=0x%x", hr));
		}

		MemFree(prl);
	}

	return hr;
}

/***************************************************************************

    Name      : CQoS::SetBandwidth

    Purpose   : Sets the initial available resources on the QoS module,
					i.e. configures the QoS module to how much is
					available from each resource.

    Parameters:

    Returns   : HRESULT

    Comment   : The QoS module may select to override these settings

***************************************************************************/
HRESULT CQoS::SetBandwidth(UINT uBandwidth)
{
    return SetResources(uBandwidth);
}

/***************************************************************************

	Name	  : CQoS::GetCPULimit

	Purpose   : Gets the total allowed CPU percentage use from QoS

	Parameters: 

	Returns   : How much of the CPU can be used, in percents. 0 means failure

	Comment   :

***************************************************************************/
ULONG CQoS::GetCPULimit()
{
	LPRESOURCELIST pResourceList=NULL;
	ULONG ulCPUPercents=0;
	ULONG i;
	HRESULT hr = NOERROR;

    ASSERT(m_pIQoS);

	// get a list of all resources from QoS
	hr = m_pIQoS->GetResources(&pResourceList);
	if (FAILED(hr) || (NULL == pResourceList))
	{
		ERROR_OUT(("GetQoSCPULimit: GetResources failed"));
	}
	else
	{
		// find the CPU resource
		for (i=0; i < pResourceList->cResources; i++)
		{
			if (pResourceList->aResources[i].resourceID == RESOURCE_CPU_CYCLES)
			{
				// QoS keeps the CPU units as the number of ms in a sec that the
				// CPU can be used. Need to divide by 10 to get percents
				ulCPUPercents = pResourceList->aResources[i].nUnits / 10;
				break;
			}
		}
		m_pIQoS->FreeBuffer(pResourceList);
	}

	return ulCPUPercents;
}


/***************************************************************************

    Name      : CQoS::SetClients

    Purpose   : Set the priorities of requesting clients so that the QoS module
					will know who should get more resources

    Parameters:	None

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::SetClients(void)
{
	LPCLIENTLIST pcl = NULL;
	ULONG i;
	HRESULT hr = S_OK;
	ULONG cClients = 3;	// audio, video and data

    ASSERT(m_pIQoS);


	// allocate space for the client list (which already includes
	// space for one client), plus (cClients-1) more clients
	pcl = (LPCLIENTLIST) MemAlloc(sizeof(CLIENTLIST) +
									(cClients-1)*sizeof(CLIENT));
	if (NULL == pcl)
	{
		ERROR_OUT(("CQoS: SetClient - MemAlloc failed"));
	}
	else
	{
		ZeroMemory(pcl, sizeof(CLIENTLIST) +
										(cClients-1)*sizeof(CLIENT));

		// fill in the resource list
		pcl->cClients = cClients;

		i=0;
		// Audio
		pcl->aClients[i].guidClientGUID = MEDIA_TYPE_H323AUDIO;
		pcl->aClients[i].wszName[0] = L'A'; // A=Audio
		pcl->aClients[i++].priority = 1;

		// Data
		pcl->aClients[i].guidClientGUID = MEDIA_TYPE_T120DATA;
		pcl->aClients[i].wszName[0] = L'D'; // D=Data
		pcl->aClients[i++].priority = 2;

		// Audio
		pcl->aClients[i].guidClientGUID = MEDIA_TYPE_H323VIDEO;
		pcl->aClients[i].wszName[0] = L'V';  // V=Video
		pcl->aClients[i++].priority = 3;

		// the rest of the fields are not important and were set to 0 above

		// set the clients info on the QoS module
		hr = m_pIQoS->SetClients(pcl);
		if (FAILED(hr))
		{
			ERROR_OUT(("CQoS: SetClients: Fail, hr=0x%x", hr));
		}

		MemFree(pcl);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\cncodes.h ===
#ifndef _CNCODES_H_
#define _CNCODES_H_

const UINT_PTR CN_RC_NOERROR =							0;
const UINT_PTR CN_MASK =								0xee00;
const UINT_PTR CN_RC_CONFERENCE_CREATE_FAILED = 		(CN_MASK | 0x01);
const UINT_PTR CN_RC_CONNECT_FAILED =					(CN_MASK | 0x02);
const UINT_PTR CN_RC_ALREADY_IN_CONFERENCE =			(CN_MASK | 0x03);
const UINT_PTR CN_RC_CONFERENCE_JOIN_DENIED =			(CN_MASK | 0x04);
const UINT_PTR CN_RC_CONFERENCE_INVITE_DENIED = 		(CN_MASK | 0x05);
const UINT_PTR CN_RC_CONFERENCE_NAME_NEEDED =			(CN_MASK | 0x06);
const UINT_PTR CN_RC_CONFERENCE_LEAVE_FAILED =			(CN_MASK | 0x07);
const UINT_PTR CN_RC_INVALID_PASSWORD = 				(CN_MASK | 0x08);
const UINT_PTR CN_RC_NAME_RESOLUTION_FAILED =			(CN_MASK | 0x09);
const UINT_PTR CN_RC_NOT_INITIALIZED =					(CN_MASK | 0x0a);
const UINT_PTR CN_RC_UNSPECIFIED_ERROR =				(CN_MASK | 0x0b);
const UINT_PTR CN_RC_CONFERENCE_DOES_NOT_EXIST =		(CN_MASK | 0x0c);
const UINT_PTR CN_RC_AUDIO_CONNECT_FAILED = 			(CN_MASK | 0x0d);
const UINT_PTR CN_RC_AUDIO_FAILED_AFTER_DATA =			(CN_MASK | 0x0e);
const UINT_PTR CN_RC_CONFERENCE_ENDED_BEFORE_JOIN = 	(CN_MASK | 0x0f);
const UINT_PTR CN_RC_CANT_INVITE_MCU =					(CN_MASK | 0x10);
const UINT_PTR CN_RC_INVITE_DENIED_REMOTE_IN_CONF = 	(CN_MASK | 0x11);
const UINT_PTR CN_RC_AUDIO_IN_USE_REMOTE_AFTER_DATA =	(CN_MASK | 0x12);
const UINT_PTR CN_RC_AUDIO_IN_USE_REMOTE =				(CN_MASK | 0x13);
const UINT_PTR CN_RC_AUDIO_IN_USE_LOCAL_AFTER_DATA =	(CN_MASK | 0x14);
const UINT_PTR CN_RC_AUDIO_IN_USE_LOCAL =				(CN_MASK | 0x15);
const UINT_PTR CN_RC_ALREADY_IN_CONFERENCE_MCU =		(CN_MASK | 0x16);
const UINT_PTR CN_RC_AUDIO_NOT_AVAILABLE =				(CN_MASK | 0x17);
const UINT_PTR CN_RC_REMOTE_PLACING_CALL =				(CN_MASK | 0x18);
const UINT_PTR CN_RC_INCOMPATIBLE_REMOTE_VERSION =		(CN_MASK | 0x1a);
const UINT_PTR CN_RC_NO_TRANSPORTS =					(CN_MASK | 0x1b);
const UINT_PTR CN_RC_CANT_JOIN_ALREADY_IN_CALL =		(CN_MASK | 0x1e);
const UINT_PTR CN_RC_TRANSPORT_FAILURE =				(CN_MASK | 0x1f);
const UINT_PTR CN_RC_LOOPBACK = 						(CN_MASK | 0x20);
const UINT_PTR CN_RC_CONFERENCE_ENDED_BEFORE_ACCEPTED = (CN_MASK | 0x22);
const UINT_PTR CN_RC_GK_CALLEE_NOT_REGISTERED =			(CN_MASK | 0x23);
const UINT_PTR CN_RC_GK_TIMEOUT =						(CN_MASK | 0x24);
const UINT_PTR CN_RC_GK_REJECTED =						(CN_MASK | 0x25);
const UINT_PTR CN_RC_GK_NOT_REGISTERED =				(CN_MASK | 0x26);
const UINT_PTR CN_RC_CONNECT_REMOTE_NO_SECURITY =		(CN_MASK | 0x27);
const UINT_PTR CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY =	(CN_MASK | 0x28);
const UINT_PTR CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY =	(CN_MASK | 0x29);
const UINT_PTR CN_RC_QUERY_FAILED =						(CN_MASK | 0x2a);
const UINT_PTR CN_RC_INVITE_FAILED =					(CN_MASK | 0x2a);
const UINT_PTR CN_RC_JOIN_FAILED =						(CN_MASK | 0x2b);
const UINT_PTR CN_RC_LOCAL_CANCELED =					(CN_MASK | 0x2c);
const UINT_PTR CN_RC_SECURITY_FAILED =					(CN_MASK | 0x2d);
const UINT_PTR CN_RC_CONNECT_AUTHENTICATION_FAILED =    (CN_MASK | 0x2e);

typedef UINT_PTR CNSTATUS;

#endif // _CNCODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\connpnts.h ===
// File: connpnts.h

#ifndef _IMCONNPT_H_
#define _IMCONNPT_H_

#include "nmenum.h"


typedef HRESULT (*CONN_NOTIFYPROC)(IUnknown *pUnk, void *pv, REFIID riid);

//****************************************************************************
// CConnectionPoint definition
//****************************************************************************
//

class CConnectionPoint : public IConnectionPoint, public DllRefCount
{
private:
	IID 					m_riid;
	IConnectionPointContainer *m_pCPC;
	ULONG					m_cSinks;
    ULONG                   m_cAllocatedSinks;
	IUnknown				**m_rgSinks;

public:
	// Constructor and destructor
	CConnectionPoint (
		const IID *pIID,
		IConnectionPointContainer *pCPCInit);
	~CConnectionPoint (void);

	// Class public functions
	void					ContainerReleased() {m_pCPC = NULL;}
	STDMETHODIMP			Notify (void *pv, CONN_NOTIFYPROC pfn);

	// IUnknown
	STDMETHODIMP			QueryInterface (REFIID iid, void **ppv);
	STDMETHODIMP_(ULONG)	AddRef (void);
	STDMETHODIMP_(ULONG)	Release (void);

	// IConnectionPoint
	STDMETHODIMP			GetConnectionInterface(IID *pIID);
	STDMETHODIMP			GetConnectionPointContainer(IConnectionPointContainer **ppCPC);
	STDMETHODIMP			Advise(IUnknown *pUnk, DWORD *pdwCookie);
	STDMETHODIMP			Unadvise(DWORD dwCookie);
	STDMETHODIMP			EnumConnections(IEnumConnections **ppEnum);
};

//****************************************************************************
// CEnumConnections definition
//****************************************************************************
//
class CEnumConnections : public IEnumConnections, public DllRefCount
{
private:
	int				m_iIndex;
	int				m_cConnections;
	CONNECTDATA*	m_pCD;

public:
	// Constructor and Initialization
	CEnumConnections (IUnknown **pSinks, ULONG cSink, ULONG cAllocatedSinks);
	~CEnumConnections (void);

	// IUnknown
	STDMETHODIMP			QueryInterface (REFIID iid, void **ppv);
	STDMETHODIMP_(ULONG)	AddRef (void);
	STDMETHODIMP_(ULONG)	Release (void);

	// IEnumConnections
	STDMETHODIMP			Next(ULONG cConnections, CONNECTDATA *rgpcn,
								 ULONG *pcFetched);
	STDMETHODIMP			Skip(ULONG cConnections);
	STDMETHODIMP			Reset();
	STDMETHODIMP			Clone(IEnumConnections **ppEnum);
};

VOID RemoveCp(CConnectionPoint ** ppCp);

class CConnectionPointContainer : public IConnectionPointContainer
{
private:
	CConnectionPoint ** m_ppCp;
	int m_cCp;

public:
	CConnectionPointContainer(const IID **ppiid, int cCp);
	~CConnectionPointContainer();

	HRESULT STDMETHODCALLTYPE NotifySink(void *pv, CONN_NOTIFYPROC pfn);

	// IConnectionPointContainer methods
	STDMETHODIMP EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
	STDMETHODIMP FindConnectionPoint(REFIID riid, IConnectionPoint **ppCp);
};

typedef CEnumNmX<IEnumConnectionPoints, &IID_IEnumConnectionPoints, IConnectionPoint, CConnectionPoint> CEnumConnectionPoints;

#endif // _IMCONNPT_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\connpnts.cpp ===
// File: connpnts.cpp
//
// CConnectionPoint
// CConnectionPointContainer
// CEnumConnections
///////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "connpnts.h"

#include <olectl.h>


/*  C  C O N N E C T I O N  P O I N T  */
/*-------------------------------------------------------------------------
    %%Function: CConnectionPoint

-------------------------------------------------------------------------*/
CConnectionPoint::CConnectionPoint(const IID *pIID, IConnectionPointContainer *pCPCInit) :
	m_riid(*pIID),
	m_pCPC(pCPCInit),
	m_cSinks(0),
    m_cAllocatedSinks(0),
    m_rgSinks(NULL)
{
	DbgMsgApi("CConnectionPoint - Constructed(%08X)", this);
}

CConnectionPoint::~CConnectionPoint (void)
{
    for (ULONG x = 0; x < m_cAllocatedSinks; x += 1)
    {
        if (m_rgSinks[x] != NULL)
        {
		    IUnknown *pUnk = (IUnknown *)m_rgSinks[x];
			pUnk->Release();
        }
    }

    if (m_cAllocatedSinks != 0)
    {
        HeapFree(GetProcessHeap(), 0, m_rgSinks);
    }

	DbgMsgApi("CConnectionPoint - Destructed(%p)", this);
}

STDMETHODIMP_(ULONG) CConnectionPoint::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CConnectionPoint::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CConnectionPoint::QueryInterface(REFIID riid, void **ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_IUnknown) || (riid == IID_IConnectionPoint))
	{
		*ppv = (IConnectionPoint *)this;
		DbgMsgApi("CConnectionPoint::QueryInterface(): Returning IConnectionPoint.");
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		DbgMsgApi("CConnectionPoint::QueryInterface(): Called on unknown interface.");
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}


/*  N O T I F Y  */
/*-------------------------------------------------------------------------
    %%Function: Notify

-------------------------------------------------------------------------*/
STDMETHODIMP CConnectionPoint::Notify(void *pv, CONN_NOTIFYPROC pfn)
{
    //
	// Enumerate each connection
	//

	AddRef();
    for (ULONG x = 0; x < m_cAllocatedSinks; x += 1)
    {
		if (m_rgSinks[x] != NULL)
		{
		    IUnknown *pUnk = (IUnknown *)m_rgSinks[x];
			pUnk->AddRef();
			(*pfn)(pUnk, pv, m_riid);
			pUnk->Release();
		}
    }

	Release();
	return S_OK;
}

/*  G E T  C O N N E C T I O N  I N T E R F A C E  */
/*-------------------------------------------------------------------------
    %%Function: GetConnectionInterface

-------------------------------------------------------------------------*/
STDMETHODIMP CConnectionPoint::GetConnectionInterface(IID *pIID)
{
	// Validate the parameter
	//
	if (pIID == NULL)
		return E_POINTER;

	// Support only one connection interface
	//
	*pIID = m_riid;
	return S_OK;
}

STDMETHODIMP CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
	// Validate the parameter
	//
	if (ppCPC == NULL)
		return E_POINTER;

	// Return the container and add its reference count
	//
	*ppCPC = m_pCPC;

	if (m_pCPC != NULL)
	{
		// The container is still alive
		//
		m_pCPC->AddRef();
		return S_OK;
	}
	else
	{
		// The container no longer exists
		//
		return E_FAIL;
	}
}

/*  A D V I S E  */
/*-------------------------------------------------------------------------
    %%Function: Advise

-------------------------------------------------------------------------*/
STDMETHODIMP CConnectionPoint::Advise(IUnknown *pUnk, DWORD *pdwCookie)
{
	IUnknown *pSinkInterface;

	// Validate the parameter
	//
	if (pdwCookie == NULL)
		return E_POINTER;

	*pdwCookie = 0;
	if (pUnk == NULL)
		return E_INVALIDARG;

	HRESULT hr = CONNECT_E_CANNOTCONNECT;

    //
	// Get the sink interface
	//

	if (SUCCEEDED(pUnk->QueryInterface(m_riid, (void **)&pSinkInterface)))
	{

        //
        // If the number of active sinks is less than the number of allocated
        // sinks, then there is a free slot in the sink table. Otherwise, the
        // table must be expanded.
        //

        ULONG x = m_cAllocatedSinks;
        if (m_cSinks < m_cAllocatedSinks)
        {
            for (x = 0; x < m_cAllocatedSinks; x += 1)
            {
                if (m_rgSinks[x] == NULL)
                {
                    break;
                }
            }
        }

        //
        // If a free slot was found in the table, then use the slot. Otherwise,
        // expand the sink table.
        //

        if (x == m_cAllocatedSinks)
        {
            IUnknown **rgSinks = (IUnknown **)HeapAlloc(GetProcessHeap(),
                                                        HEAP_ZERO_MEMORY,
                                                        (m_cAllocatedSinks + 8) * sizeof(IUnknown *));

            if (rgSinks == NULL)
            {
			    pSinkInterface->Release();
                return E_OUTOFMEMORY;
            }

            for (ULONG z = 0; z < m_cAllocatedSinks; z += 1)
            {
                rgSinks[z] = m_rgSinks[z];
            }

            m_cAllocatedSinks += 8;
            if (m_rgSinks != NULL) {
                HeapFree(GetProcessHeap(), 0, m_rgSinks);
            }

            m_rgSinks = rgSinks;
        }

        //
		// Add new sink to the table.
		//

        m_rgSinks[x] = pSinkInterface;
		m_cSinks += 1;
		*pdwCookie = x + 1;
		hr = S_OK;
	}

	return hr;
}

/*  U N A D V I S E  */
/*-------------------------------------------------------------------------
    %%Function: Unadvise

-------------------------------------------------------------------------*/
STDMETHODIMP CConnectionPoint::Unadvise(DWORD dwCookie)
{
	HRESULT hr = CONNECT_E_NOCONNECTION;

    //
	// Traverse the sink list to find the specified sink object
	//

    if ((dwCookie != 0) &&
        (dwCookie <= m_cAllocatedSinks) &&
        (m_rgSinks[dwCookie - 1] != NULL))
    {
		IUnknown *pUnk = (IUnknown *) m_rgSinks[dwCookie - 1];
	    pUnk->Release();
        m_rgSinks[dwCookie - 1] = NULL;
        m_cSinks -= 1;
		hr = S_OK;
    }

	return hr;
}

STDMETHODIMP CConnectionPoint::EnumConnections(IEnumConnections **ppEnum)
{
	HRESULT hr = E_POINTER;

	// Validate parameters
	//
	if (ppEnum != NULL)
	{
		// Create an enumerator
		//
		*ppEnum = new CEnumConnections(m_rgSinks, m_cSinks, m_cAllocatedSinks);
		hr = (NULL != *ppEnum) ? S_OK : E_OUTOFMEMORY;
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////

/*  C  E N U M  C O N N E C T I O N S  */
/*-------------------------------------------------------------------------
    %%Function: CEnumConnections

-------------------------------------------------------------------------*/
CEnumConnections::CEnumConnections(IUnknown **pSinks, ULONG cSinks, ULONG cAllocatedSinks) :
	m_iIndex(0),
	m_cConnections(0),
	m_pCD(NULL)
{
	// Snapshot the connection list
	//
	if (cSinks > 0)
	{
		m_pCD = new CONNECTDATA[cSinks];
		if (NULL != m_pCD)
		{
            for (ULONG x = 0; x < cAllocatedSinks; x += 1)
            {
                if (pSinks[x] != NULL) {
				    IUnknown *pUnk = (IUnknown *) pSinks[x];
                    pUnk->AddRef();
					m_pCD[m_cConnections++].pUnk = pUnk;
					m_pCD[m_cConnections++].dwCookie = x + 1;
                }
            }
		}
	}

	DbgMsgApi("CEnumConnections - Constructed(%p)", this);
}

CEnumConnections::~CEnumConnections(void)
{
	if (m_pCD != NULL)
	{
		for (int i = 0; i < m_cConnections; i++)
		{
			m_pCD[i].pUnk->Release();
		};
		delete [] m_pCD;
	};

	DbgMsgApi("CEnumConnections - Destructed(%08X)", this);
}

STDMETHODIMP_(ULONG) CEnumConnections::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CEnumConnections::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CEnumConnections::QueryInterface(REFIID riid, void **ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_IEnumConnections) || (riid == IID_IUnknown))
	{
		*ppv = (IEnumConnections *)this;
		DbgMsgApi("CEnumConnections::QueryInterface(): Returning IEnumConnections.");
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		DbgMsgApi("CEnumConnections::QueryInterface(): Called on unknown interface.");
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

STDMETHODIMP CEnumConnections::Next(ULONG cConnections, CONNECTDATA *rgpcd, ULONG *pcFetched)
{
	ULONG cCopied = 0;

	if ((0 == cConnections) && (NULL == rgpcd) && (NULL != pcFetched))
	{
		// Return the number of remaining elements
		*pcFetched = m_cConnections - m_iIndex;
		return S_OK;
	}
	
	if ((NULL == rgpcd) || ((NULL == pcFetched) && (cConnections != 1)))
		return E_POINTER;

	if (NULL != m_pCD)
	{
		while ((cCopied < cConnections) && (m_iIndex < m_cConnections))
		{
			*rgpcd = m_pCD[m_iIndex];
			(*rgpcd).pUnk->AddRef();
			rgpcd++;
			cCopied++;
			m_iIndex++;
		}
	}

	if (pcFetched != NULL)
		*pcFetched = cCopied;

	return (cConnections == cCopied) ? S_OK : S_FALSE;
}

STDMETHODIMP CEnumConnections::Skip(ULONG cConnections)
{
    m_iIndex += cConnections;
	if (m_iIndex >= m_cConnections)
	{
		// Past the end of the list
		m_iIndex = m_cConnections;
		return S_FALSE;
	}

	return S_OK;
}


STDMETHODIMP CEnumConnections::Reset(void)
{
	m_iIndex = 0;
	return S_OK;
}

STDMETHODIMP CEnumConnections::Clone(IEnumConnections **ppEnum)
{
	// Validate parameters
	//
	if (ppEnum == NULL)
		return E_POINTER;

	HRESULT hr = S_OK;
	CEnumConnections * pEnum = new CEnumConnections(NULL, 0, 0);
	if (NULL == pEnum)
	{
		hr = E_OUTOFMEMORY;
	}
	else if (NULL != m_pCD)
	{
		pEnum->m_pCD = new CONNECTDATA[m_cConnections];
		if (NULL == pEnum->m_pCD)
		{
			delete pEnum;
			pEnum = NULL;
    		hr = E_OUTOFMEMORY;
		}
		else
		{
			pEnum->m_iIndex = m_iIndex;
			pEnum->m_cConnections = m_cConnections;

            for (int i = 0; i < m_cConnections; ++i)
            {
        		m_pCD[i].pUnk->AddRef();
                pEnum->m_pCD[i] = m_pCD[i];
            }
		}
	}

	*ppEnum = pEnum;
	return hr;
}


///////////////////////////////////////////////////////////////////////////

/*  C  C O N N E C T I O N  P O I N T  C O N T A I N E R  */
/*-------------------------------------------------------------------------
    %%Function: CConnectionPointContainer

-------------------------------------------------------------------------*/
CConnectionPointContainer::CConnectionPointContainer(const IID **ppiid, int cCp) :
	m_ppCp(NULL),
	m_cCp(0)
{
	m_ppCp = new CConnectionPoint* [cCp];
	if (NULL != m_ppCp)
	{
		for (int i = 0; i < cCp; ++i)
		{
			CConnectionPoint *pCp = new CConnectionPoint(ppiid[i], this);
			if (NULL != pCp)
			{
				m_ppCp[m_cCp++] = pCp;
			}
		}
	}
}

CConnectionPointContainer::~CConnectionPointContainer()
{
	if (NULL != m_ppCp)
	{
		for (int i = 0; i < m_cCp; ++i)
		{
			CConnectionPoint *pCp = m_ppCp[i];
			if (NULL != pCp)
			{
				pCp->ContainerReleased();
				pCp->Release();
			}
		}
		delete[] m_ppCp;
	}
}


HRESULT STDMETHODCALLTYPE
CConnectionPointContainer::NotifySink(void *pv, CONN_NOTIFYPROC pfn)
{
	if (NULL != m_ppCp)
	{
		for (int i = 0; i < m_cCp; ++i)
		{
			m_ppCp[i]->Notify(pv, pfn);
		}
	}

	return S_OK;
}

STDMETHODIMP
CConnectionPointContainer::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;

	// Create an enumerator
	*ppEnum = new CEnumConnectionPoints(m_ppCp, m_cCp);

	return (NULL != *ppEnum) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP
CConnectionPointContainer::FindConnectionPoint(REFIID riid, IConnectionPoint **ppCp)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppCp)
	{
		hr = CONNECT_E_NOCONNECTION;
		*ppCp = NULL;

		if (NULL != m_ppCp)
		{
			for (int i = 0; i < m_cCp; ++i)
			{
				IID iid;
				IConnectionPoint *pCp = m_ppCp[i];
				if (S_OK == pCp->GetConnectionInterface(&iid))
				{
					if (riid == iid)
					{
						pCp->AddRef();
						*ppCp = pCp;
						hr = S_OK;
						break;
					}
				}
			}
		}
	}

	return hr;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\cuserdta.cpp ===
#include "precomp.h"

// CP: DCL's header redefines this:
#ifdef CLEAR_FLAG
#undef CLEAR_FLAG
#endif // CLEAR_FLAG

#include <cstring.hpp>
#include <cuserdta.hpp>
#include <oprahcom.h>

USER_DATA_LIST::USER_DATA_LIST()
{
    numEntries = 0;
    pUserDataArray = NULL;
}

USER_DATA_LIST::~USER_DATA_LIST()
{
	POSITION pHead;

	while ((pHead = GetHeadPosition()) != NULL)
	{
		RemoveAt(pHead);
	}

    delete[] pUserDataArray;
}

DWORD USER_DATA_LIST::AddUserData(GUID * pGUID, unsigned short nData, PVOID pData)
{
    ASSERT(pGUID);
    ASSERT(!nData || pData);

    POSITION            Position;
    unsigned char *     pWork;
    unsigned short      nDataPlusHeader = nData+sizeof(GUID);
    GCCUserData *       pUserData;
    LPOSTR              pOctetString;

    // If there is already an entry in the list
    // for the GUID, then delete it.

    DeleteEntry(pGUID);

    // Now go and add the new entry to the list.

    pUserData = new GCCUserData;
    pOctetString = new OSTR;
    if ((pUserData) && 
        (pOctetString) &&
        (nDataPlusHeader <= 0xffff)) {
        pWork = new unsigned char[nDataPlusHeader];
        if (pWork) {
            pUserData->octet_string = pOctetString;
            pOctetString->value = pWork;
            pOctetString->length = nDataPlusHeader;
            *(GUID *)pWork = *pGUID;
            pWork += sizeof(GUID);
            memcpy(pWork, pData, nData);
            Position = AddTail(pUserData);
            if (Position) {
                numEntries++;
                return NO_ERROR;
            }
            delete [] pWork;
        }
    }
    delete pOctetString;
    delete pUserData;
    return UI_RC_OUT_OF_MEMORY;
}

void USER_DATA_LIST::DeleteEntry(GUID * pGUID)
{
    POSITION    Position;

    Position = Lookup(pGUID);
    if (Position) {
        RemoveAt(Position);
    }
}

void * USER_DATA_LIST::RemoveAt(POSITION Position)
{
    ASSERT(Position);
    GCCUserData * pUserData = (GCCUserData *)GetFromPosition(Position);

    if (pUserData) {

        delete pUserData->octet_string->value;
        delete pUserData->octet_string;
        delete pUserData;
        COBLIST::RemoveAt(Position);
        numEntries--;
    }
    return pUserData;
}

DWORD USER_DATA_LIST::GetUserDataList(unsigned short * pnRecords,
                                      GCCUserData *** pppUserData)
{
    POSITION        Position;
    GCCUserData **  pUserDataArrayTemp;
    DWORD           Status = NO_ERROR;

    delete[] pUserDataArray;
    *pnRecords = 0;
    *pppUserData = NULL;
    if (numEntries) {

        // Allocate memory.

        pUserDataArray = new GCCUserData * [numEntries];
        if (!pUserDataArray) {
            Status = UI_RC_OUT_OF_MEMORY;
        }
        else {
            *pnRecords = numEntries;
            *pppUserData = pUserDataArray;

            // Fill in array.

            pUserDataArrayTemp = pUserDataArray;
	        Position = GetHeadPosition();
	        while (Position) {
		        *(pUserDataArrayTemp++) = (GCCUserData *)GetNext(Position);
	        }
        }
    }
    return NO_ERROR;
}

BOOL USER_DATA_LIST::Compare(void* pItemToCompare, void* pGUID)
{
    return(memcmp(((GCCUserData *)pItemToCompare)->octet_string->value, 
                  pGUID, 
                  sizeof(GUID)) == 0);
}

HRESULT USER_DATA_LIST::GetUserData(REFGUID rguid, BYTE ** ppb, ULONG *pcb)
{
	POSITION Position = Lookup((PVOID)&rguid);

	if (pcb == NULL)
		return E_POINTER;

	if (Position) {
		GCCUserData * pUserData = (GCCUserData *)Position->pItem;
		*pcb = pUserData->octet_string->length - sizeof(GUID);
		*ppb = (PBYTE)CoTaskMemAlloc(*pcb);
		CopyMemory(*ppb,pUserData->octet_string->value + sizeof(GUID),*pcb);
		return S_OK;
	}
	else {
		*ppb = NULL;
		*pcb = 0;
		return E_INVALIDARG;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\confqos.h ===
// File: confqos.h

#ifndef _CONFQOS_H_
#define _CONFQOS_H_


// Don't use more than 90% of the CPU among all the components
// registered with the QoS module
#define MSECS_PER_SEC    900

struct IQoS;

class CQoS
{
protected:
	IQoS  * m_pIQoS;

	HRESULT SetClients(void);
	HRESULT SetResources(int nBandWidth);

public:
	CQoS();
	~CQoS();
	HRESULT  Initialize();
	HRESULT  SetBandwidth(UINT uBandwidth);
	ULONG    GetCPULimit();
};

extern CQoS* g_pQoS;

#endif  // _CONFQOS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\cuserdta.hpp ===
// cuserdta.hpp
// Data structure for managing user data.

#ifndef	USERDATA_INC
#define	USERDATA_INC

#include <nmutil.h>
#include <oblist.h>
#include <confdbg.h>
#include <confguid.h>

extern "C"
{
#include <t120.h>
}

// GetUserData extracts user data from a T120 event message.
// The caller passes in the T120 data structures and the GUID
// associated with the user data, and receives back a pointer to
// the buffer containing the user data. 
// This buffer will be invalidated by the user returning from
// the event. If the user data consisted just
// of the GUID, then *pnData == NULL and *ppData == NULL.

HRESULT NMINTERNAL GetUserData(unsigned short     nRecords,
                               GCCUserData **     ppUserData,
                               GUID *             pGUID,
                               unsigned short *   pnData, 
                               PVOID *            ppData);

/*************************************************************************

    NAME:		USER_DATA

    INTERFACE:	USER_DATA(object ID)
					Construct the container for the list.

				~USER_DATA_GUID()
					Destructor automatically releases data allocated.

				AddUserData()
					Add some user data to the list, keyed by a unique
                    GUID. If the GUID is already in the list, then its
                    data will be overwritten.

				GetUserData()
					Used in conjunction with GetNumUserData() to put the
                    user data into a T120 request.

                GetNumUserData()
					See GetUserData().

    PARENT:		None

    USES:		None

    CAVEATS:	1) The user data binary information must fit in an unsigned
                short field, less the bytes for the GUID header and byte count.

    NOTES:		None.

    HISTORY:
		06/04/96	lens	Created

**************************************************************************/

class USER_DATA_LIST : COBLIST
{
public:
	USER_DATA_LIST();
	~USER_DATA_LIST();
    DWORD AddUserData(GUID * pGUID, unsigned short nData, PVOID pData);
    DWORD GetUserDataList(unsigned short * pnRecords,
                          GCCUserData *** pppUserData);
    HRESULT GetUserData(REFGUID rguid, BYTE ** ppb, ULONG *pcb);
    inline unsigned short GetNumUserData(){return (numEntries);}

    void DeleteEntry(GUID * pGUID);

private:
    void * RemoveAt(POSITION Position);
    BOOL Compare(void* pItemToCompare, void* pComparator);
    unsigned short  numEntries;
    GCCUserData **  pUserDataArray;
};

#endif /* ndef USERDATA_INC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\debug.cpp ===
// File: debug.cpp

#include "precomp.h"

#ifdef DEBUG  // THE WHOLE FILE !

#ifndef HACK
HDBGZONE ghZoneOther = NULL; // Other, conf.exe specific zones
#define ghZones  ghZoneOther // Hack: The above should be called ghZones
#else
HDBGZONE ghZones = NULL; // Other, conf.exe specific zones
#endif

static PTCHAR _rgZones[] = {
	TEXT("Core"),
	TEXT("Api"),
	TEXT("RefCount"),
	TEXT("Manager"),
	TEXT("Calls"),
	TEXT("Conference"),
	TEXT("Members"),
	TEXT("A/V"),
	TEXT("FT"),
	TEXT("SysInfo"),
	TEXT("Objects "),
	TEXT("DC"),
};

VOID DbgMsg(int iZone, PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & (1 << iZone))
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZone, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgInitZones(VOID)
{
	ASSERT(::InitDebugModule(TEXT("NMCOM")));
	DBGINIT(&ghZones, _rgZones);
}

VOID DbgFreeZones(VOID)
{
	DBGDEINIT(&ghZones);
	ExitDebugModule();
}

VOID DbgMsgRefCount(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_REFCOUNT)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_REFCOUNT, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgApi(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_API)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_API, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgManager(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_MANAGER)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_MANAGER, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgCall(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_CALL)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_CALL, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgConference(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_CONFERENCE)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_CONFERENCE, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgMember(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_MEMBER)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_MEMBER, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgAV(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_AV)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_AV, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgFT(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_FT)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_FT, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgSysInfo(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_SYSINFO)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_SYSINFO, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgDc(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_DC)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_DC, pszFormat, v1);
		va_end(v1);
	}
}

#endif /* DEBUG  - THE WHOLE FILE ! */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\global.h ===
// File: global.h

extern HINSTANCE g_hInst;
inline HINSTANCE GetInstanceHandle()	{ return g_hInst; }

extern BOOL g_fLoggedOn;
inline BOOL FIsLoggedOn() { return g_fLoggedOn; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\h323.cpp ===
#include "precomp.h"

//
//	H323UI.cpp
//
//	ChrisPi
//
//	Created:	03-04-96 (as audioui.cpp)
//	Renamed:	02-20-97
//

#include <mmreg.h>
#include <mmsystem.h>

#include "h323.h"

#include <ih323cc.h>
#include <mperror.h>

PORT g_ListenPort;	// port # that this app is listening on

static const char g_cszCreateStreamProviderEP[] = _TEXT("CreateStreamProvider");

// static member initialization:
CH323UI* CH323UI::m_spH323UI = NULL;

CH323UI::CH323UI() :
	m_pH323CallControl(NULL),
	m_pStreamProvider(NULL),
	m_pConnEvent(NULL),
	m_pConfAdvise(NULL),
    m_uCaps(0),
	m_uRef(1)

{
	DebugEntry(CH323UI::CH323UI);

	if (NULL == CH323UI::m_spH323UI)
	{
		m_spH323UI = this;
	}
	else
	{
		ERROR_OUT(("CH323UI class can only be constructed once for now!"));
	}

	DebugExitVOID(CH323UI::CH323UI);
}

CH323UI::~CH323UI()
{
	DebugEntry(CH323UI::~CH323UI);

	if (NULL != m_pH323CallControl)
	{
		m_pH323CallControl->Release();
		m_pH323CallControl = NULL;
	}

	if(NULL != m_pStreamProvider)
	{
		m_pStreamProvider->Release();
		m_pStreamProvider = NULL;
	}

	if (m_spH323UI == this)
	{
		m_spH323UI = NULL;
	}

	DebugExitVOID(CH323UI::~CH323UI);
}

ULONG CH323UI::AddRef()
{
	m_uRef++;
	return m_uRef;
}

ULONG CH323UI::Release()
{
	m_uRef--;
	if(m_uRef == 0)
	{
		delete this;
		return 0;
	}
	return m_uRef;
}

STDMETHODIMP CH323UI::QueryInterface( REFIID iid,	void ** ppvObject)
{

	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if((iid == IID_IH323ConfAdvise)
	|| (iid == IID_IUnknown))
	{
        *ppvObject = (IH323ConfAdvise *)this;
   		hr = hrSuccess;
    	AddRef();
	}
	
	return (hr);
}

STDMETHODIMP CH323UI::GetMediaChannel (GUID *pmediaID,
        BOOL bSendDirection, IMediaChannel **ppI)
{
	ASSERT(m_pStreamProvider);
	
	// delegate to the appropriate stream provider.  For the time being
	// there is only one provider that does both audio & video

	// the assignment of media streams to channels should be under control of this
	// (CH323UI) module and the related (i.e. CVideoPump) objects. There is no
	// current way to for CH323UI to tell CVideoPump what the media stream interface
	// pointer is, but the underlying CommChannel (CVideoPump::m_pCommChannel) has to
	// remember this assignment for other reasons.  For the time being, let CVideoPump
	// get the assigned media stream from the CommChannel.
	
	return (::GetConfObject())->GetMediaChannel(pmediaID, 	
		bSendDirection, ppI);	
}

HRESULT CH323UI::Init(HWND hwnd, HINSTANCE hInstance, UINT uCaps,
    CH323ConnEvent *pConnEvent,	IH323ConfAdvise *pConfAdvise)
{
	DebugEntry(CH323UI::Init);

	HINSTANCE hLibH323CC = NULL;
	HINSTANCE hLibStream = NULL;
	CREATEH323CC pfnCreateH323CC = NULL;
	CREATE_SP pfnCreateStreamProvider =NULL;
	
	HRESULT hr = E_FAIL;

    ASSERT(uCaps & CAPFLAG_H323_CC);
    m_uCaps = uCaps;

	ASSERT(NULL == m_pH323CallControl);

    //
    // Initialize H323 call control
    //
	hLibH323CC = NmLoadLibrary(H323DLL,FALSE);
	if (hLibH323CC == NULL)
	{
		WARNING_OUT(("NmLoadLibrary(H323DLL) failed"));
		hr = GetLastHR();
		goto MyExit;
	}

	pfnCreateH323CC = (CREATEH323CC) ::GetProcAddress(hLibH323CC, SZ_FNCREATEH323CC);
	if (pfnCreateH323CC == NULL)
	{
		ERROR_OUT(("GetProcAddress(CreateH323CC) failed"));
		hr = GetLastHR();
		goto MyExit;
	}

	hr = pfnCreateH323CC(&m_pH323CallControl, TRUE, uCaps);
	if (FAILED(hr))
	{
		ERROR_OUT(("CreateH323CC failed, hr=0x%lx", hr));
		goto MyExit;
	}

	hr = m_pH323CallControl->Initialize(&g_ListenPort);
	if (FAILED(hr))
	{
		// Made this a warning because it is common (occurs on all machines
		// without sound cards)
		WARNING_OUT(("H323CallControlInitialize failed, hr=0x%lx", hr));
		goto MyExit;
	}

    //
    // If H323 AV streaming is allowed, initialize that too.
    //
    if (uCaps & CAPFLAGS_AV_STREAMS)
    {
    	hLibStream = NmLoadLibrary(NACDLL,FALSE);
	    if (hLibStream == NULL)
    	{
	    	WARNING_OUT(("NmLoadLibrary(NACDLL) failed"));
		    hr = GetLastHR();
    		goto MyExit;
	    }

    	pfnCreateStreamProvider = (CREATE_SP) ::GetProcAddress(hLibStream, g_cszCreateStreamProviderEP);
	    if (pfnCreateStreamProvider == NULL)
    	{
	    	ERROR_OUT(("GetProcAddress(CreateStreamProvider) failed"));
		    hr = GetLastHR();
    		goto MyExit;
	    }
	
    	hr = pfnCreateStreamProvider(&m_pStreamProvider);
	    if (FAILED(hr))
    	{
	    	ERROR_OUT(("CreateStreamProvider failed, hr=0x%lx", hr));
		    goto MyExit;
    	}

    	hr = m_pStreamProvider->Initialize(hwnd, hInstance);
	    if (FAILED(hr))
    	{
	    	// Made this a warning because it is common (occurs on all machines
		    // without sound cards)
    		WARNING_OUT(("m_pStreamProvider ->Initialize failed, hr=0x%lx", hr));
	    	goto MyExit;
        }
   	}
	
	hr = m_pH323CallControl->RegisterConnectionNotify(CH323UI::ConnectionNotify);
	if (FAILED(hr))
	{
		ERROR_OUT(("RegisterConnectionNotify failed, hr=0x%lx", hr));
		goto MyExit;
	}

	// store the callback interfaces
	m_pConnEvent = pConnEvent;
	m_pConfAdvise = pConfAdvise;
	
MyExit:
	if (FAILED(hr))
	{
		if(NULL != m_pStreamProvider)
		{
			m_pStreamProvider->Release();
			m_pStreamProvider = NULL;
		}

		if(NULL != m_pH323CallControl)
		{
			// If there was an error during init, ensure that the nac
			// object is released and the pointer is set to NULL
			m_pH323CallControl->Release();
			m_pH323CallControl = NULL;
		}
	}
	
	DebugExitULONG(CH323UI::Init, hr);
	return hr;
}


CREQ_RESPONSETYPE CH323UI::_ConnectionNotify(	IH323Endpoint* pConn,
												P_APP_CALL_SETUP_DATA lpvMNMData)
{
	CREQ_RESPONSETYPE resp = CRR_REJECT;
	HRESULT hr;
	ASSERT(m_pConfAdvise);
	hr = pConn->SetAdviseInterface (m_pConfAdvise);
	if (FAILED(hr))
	{
		ERROR_OUT(("ConnectionNotify: couldn't SetAdviseInterface, hr=0x%lx\r", hr));
	}

	if (NULL != m_pConnEvent)
	{
		resp = m_pConnEvent->OnH323IncomingCall(pConn, lpvMNMData);
	}
	
	// BUGBUG: the caller is assuming that the callee will be doing the release
	// this should be changed so that the caller does the release
	pConn->Release();

	return resp;
}

CREQ_RESPONSETYPE CALLBACK CH323UI::ConnectionNotify(	IH323Endpoint* pConn,
														P_APP_CALL_SETUP_DATA lpvMNMData)
{
	DebugEntry(CH323UI::ConnectionNotify);
	
	CREQ_RESPONSETYPE resp = CRR_REJECT;

	if (pConn == NULL)
	{
		ERROR_OUT(("ConnectionNotify called with NULL pConn!"));
	}
	else
	{
		ASSERT(m_spH323UI);
		resp = m_spH323UI->_ConnectionNotify(pConn, lpvMNMData);
	}

	DebugExitINT(CH323UI::ConnectionNotify, resp);
	return resp;
}

VOID CH323UI::SetCaptureDevice(DWORD dwCaptureID)
{
	// Select the proper capture device
	HRESULT hr;
	IVideoDevice *pVideoDevice = NULL;

    if (m_pStreamProvider)
    {
    	hr = m_pStreamProvider->QueryInterface(IID_IVideoDevice, (void **)&pVideoDevice);
	    if(FAILED(hr))
    	{
            ERROR_OUT(("CH323UI::SetCaptureDevice failed"));
		    return;
        }

    	if(pVideoDevice)
	    {
		    pVideoDevice->SetCurrCapDevID(dwCaptureID);
    		pVideoDevice->Release();
	    }
    }
}
	
VOID CH323UI::SetBandwidth(DWORD dwBandwidth)
{
	HRESULT hr = m_pH323CallControl->SetMaxPPBandwidth(dwBandwidth);
	ASSERT(SUCCEEDED(hr));
}

// This (SetUserName) is not really sufficient for H.323 calls and gatekeeper
// registration.  2 items are needed (display name, H.323 ID)
// And a third is optional.  (users phone number in E.164 form).
// This hack takes the single display name and sets BOTH the H323ID and user
// display name.

VOID CH323UI::SetUserName(BSTR bstrName)
{
	HRESULT hr;
	ASSERT(bstrName);
	H323ALIASLIST AliasList;
	H323ALIASNAME AliasName;
	AliasName.aType = AT_H323_ID;
	AliasList.wCount = 1;
	AliasList.pItems = &AliasName;
	AliasName.lpwData = bstrName;
	AliasName.wDataLength = (WORD)SysStringLen(bstrName);// # of unicode chars, w/o NULL terminator

	hr = m_pH323CallControl->SetUserAliasNames(&AliasList);
	ASSERT(SUCCEEDED(hr));
	hr = m_pH323CallControl->SetUserDisplayName(AliasName.lpwData);
	ASSERT(SUCCEEDED(hr));
}

IMediaChannelBuilder* CH323UI::GetStreamProvider()
{
	if (m_pStreamProvider)
	{
		m_pStreamProvider->AddRef();
	}

	return m_pStreamProvider;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\h323.h ===
#ifndef _H323_H_
#define _H323_H_

#include <winerror.h>
#include <appavcap.h>
#include <ih323cc.h>
#include "video.h"
#include "audio.h"
#include <nacguids.h>
#include "capflags.h"

const DWORD H323UDF_ALREADY_IN_T120_CALL =	0x01000001;

const DWORD H323UDF_INVITE =				0x00000001;
const DWORD H323UDF_JOIN =					0x00000002;
const DWORD H323UDF_SECURE =				0x00000004;
const DWORD H323UDF_AUDIO =					0x00000008;
const DWORD H323UDF_VIDEO =					0x00000010;

class CH323ConnEvent
{
public:
	virtual CREQ_RESPONSETYPE OnH323IncomingCall(IH323Endpoint* pConnection, P_APP_CALL_SETUP_DATA lpvMNMData) = 0;
};

class CH323UI 
{
public:
					CH323UI();
					~CH323UI();

	// IH323ConfAdvise Methods:
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHOD_(ULONG, AddRef());
	STDMETHOD_(ULONG, Release());
    STDMETHODIMP GetMediaChannel (GUID *pmediaID, 
        BOOL bSendDirection, IMediaChannel **ppI);	

	// Other Methods:
	HRESULT		Init(HWND hWnd, HINSTANCE m_hInstance, UINT caps,
        CH323ConnEvent *pConnEvent, IH323ConfAdvise *pConfAdvise);
	IH323CallControl*		GetH323CallControl() { return m_pH323CallControl; };
	IMediaChannelBuilder*		GetStreamProvider();

	VOID		SetBandwidth(DWORD uBandwidth);
	VOID		SetUserName(BSTR bstrName);
	VOID		SetCaptureDevice(DWORD dwCaptureID);

protected:
	// Members:
	UINT                    m_uRef;
    UINT                    m_uCaps;
	IH323CallControl*       m_pH323CallControl;
	IMediaChannelBuilder*   m_pStreamProvider;

	static CH323UI*		m_spH323UI;

	CH323ConnEvent*		m_pConnEvent;
    IH323ConfAdvise*    m_pConfAdvise;
	
protected:
	// Callbacks:
	static CREQ_RESPONSETYPE CALLBACK ConnectionNotify(	IH323Endpoint* pConn,
														P_APP_CALL_SETUP_DATA lpvMNMData);
	CREQ_RESPONSETYPE CALLBACK _ConnectionNotify(	IH323Endpoint* pConn,
													P_APP_CALL_SETUP_DATA lpvMNMData);
};

// The global instance that is declared in conf.cpp:
extern CH323UI* g_pH323UI;

#endif // _H323_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\debug.h ===
// File: debug.h

// Debug Zones (depends on order of strings in debug.cpp)

#ifndef _DEBUG_H_
#define _DEBUG_H_

#define ZONE_API        0x0001  // General API output
#define ZONE_REFCOUNT   0x0002  // Object reference counts
#define ZONE_MANAGER    0x0004  // INmManager
#define ZONE_CALL       0x0008  // INmCall
#define ZONE_CONFERENCE 0x0010  // INmConference
#define ZONE_MEMBER     0x0020  // INmMember
#define ZONE_AV         0x0040  // INmAudio/Video
#define ZONE_FT         0x0080  // INmFileTransfer
#define ZONE_SYSINFO    0x0100  // INmSysInfo
#define ZONE_OBJECTS    0x0200  // General object create/destruction
#define ZONE_DC         0x0400  // Data Channel

#define iZONE_API        0
#define iZONE_REFCOUNT   1
#define iZONE_MANAGER    2
#define iZONE_CALL       3
#define iZONE_CONFERENCE 4
#define iZONE_MEMBER     5
#define iZONE_AV         6
#define iZONE_FT         7
#define iZONE_SYSINFO    8
#define iZONE_OBJECTS    9
#define iZONE_DC        10


#ifdef DEBUG
VOID DbgInitZones(void);
VOID DbgFreeZones(void);

VOID DbgMsgApi(PSTR pszFormat,...);
VOID DbgMsgRefCount(PSTR pszFormat,...);
VOID DbgMsgManager(PSTR pszFormat,...);
VOID DbgMsgCall(PSTR pszFormat,...);
VOID DbgMsgMember(PSTR pszFormat,...);
VOID DbgMsgAV(PSTR pszFormat,...);
VOID DbgMsgFT(PSTR pszFormat,...);
VOID DbgMsgSysInfo(PSTR pszFormat,...);
VOID DbgMsgDc(PSTR pszFormat,...);

VOID DbgMsg(int iZone, PSTR pszFormat,...);

#else // no debug messages

inline void WINAPI DbgMsgNop(LPCTSTR, ...) { }

#define DbgMsgApi      1 ? (void)0 : ::DbgMsgNop
#define DbgMsgRefCount 1 ? (void)0 : ::DbgMsgNop
#define DbgMsgManager  1 ? (void)0 : ::DbgMsgNop
#define DbgMsgCall     1 ? (void)0 : ::DbgMsgNop
#define DbgMsgMember   1 ? (void)0 : ::DbgMsgNop
#define DbgMsgAV       1 ? (void)0 : ::DbgMsgNop
#define DbgMsgFT       1 ? (void)0 : ::DbgMsgNop
#define DbgMsgSysInfo  1 ? (void)0 : ::DbgMsgNop
#define DbgMsgDc       1 ? (void)0 : ::DbgMsgNop

inline void WINAPI DbgMsgZoneNop(UINT, LPCTSTR, ...) { }
#define DbgMsg  1 ? (void) 0 : ::DbgMsgZoneNop

#define DbgInitZones()
#define DbgFreeZones()

#endif

#define ApiDebugMsg(s)    DbgMsgApi s

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\icall.cpp ===
// File: icall.cpp

#include "precomp.h"

#include "icall.h"
#include "rostinfo.h"
#include "imanager.h"
#include "mperror.h"
#include "nmremote.h"
#include "util.h"

typedef struct
{
	BOOL    fMCU;
	PWSTR * pwszConfNames;
	BSTR  * pbstrConfToJoin;
} REMOTE_CONFERENCE;

typedef struct
{
	BSTR bstrConference;
	BSTR *pbstrPassword;
	PBYTE pbRemoteCred;
	DWORD cbRemoteCred;
	BOOL fIsService;
} REMOTE_PASSWORD;


HRESULT OnNotifyCallError(IUnknown *pCallNotify, PVOID pv, REFIID riid);

static HRESULT OnNotifyRemoteConference(IUnknown *pCallNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyRemotePassword(IUnknown *pCallNotify, PVOID pv, REFIID riid);

static const IID * g_apiidCP[] =
{
	{&IID_INmCallNotify},
	{&IID_INmCallNotify2}
};

// String Functions
inline VOID FreeBstr(BSTR *pbstr)
{
	if (NULL != pbstr)
	{
		SysFreeString(*pbstr);
		*pbstr = NULL;
	}
}

/*  P S Z  A L L O C  */
/*-------------------------------------------------------------------------
    %%Function: PszAlloc

-------------------------------------------------------------------------*/
LPTSTR PszAlloc(LPCTSTR pszSrc)
{
	if (NULL == pszSrc)
		return NULL;

	LPTSTR pszDest = new TCHAR[lstrlen(pszSrc) + 1];
	if (NULL != pszDest)
	{
		lstrcpy(pszDest, pszSrc);
	}
	return pszDest;
}

COutgoingCall::COutgoingCall(CConfObject* pco,
		DWORD dwFlags, NM_ADDR_TYPE addrType,
		BSTR bstrName, BSTR bstrDest, BSTR bstrAlias,
		BSTR bstrConference, BSTR bstrPassword,	BSTR bstrUserString) :
	CConnectionPointContainer(g_apiidCP, ARRAY_ELEMENTS(g_apiidCP)),
	m_pConfObject			(pco),
	m_addrType				(addrType),
	m_dwFlags				(dwFlags),
	m_bstrName				(SysAllocString(bstrName)),
	m_bstrAlias				(SysAllocString(bstrAlias)),
	m_bstrConfToJoin		(SysAllocString(bstrConference)),
	m_bstrPassword			(SysAllocString(bstrPassword)),
	m_bstrUserString		(SysAllocString(bstrUserString)),
	m_hRequest				(NULL),
	m_pH323Connection		(NULL),
	m_fCanceled 			(FALSE),
	m_cnResult				(CN_RC_NOERROR),
	m_cnState				(CNS_IDLE),
	m_fService				(FALSE)
{
	m_pszAddr =	PszAlloc(CUSTRING(bstrDest));
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created COutgoingCall", this);
}

COutgoingCall::~COutgoingCall()
{
	delete m_pszAddr;

	FreeBstr(&m_bstrName);
	FreeBstr(&m_bstrAlias);
	FreeBstr(&m_bstrConfToJoin);
	FreeBstr(&m_bstrPassword);
	FreeBstr(&m_bstrUserString);

	ASSERT(NULL == m_pH323Connection);

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed COutgoingCall", this);
}


BOOL COutgoingCall::MatchActiveCallee(LPCTSTR pszAddr, BSTR bstrAlias, BSTR bstrConference)
{
	return ((0 == lstrcmp(pszAddr, m_pszAddr)) &&
			(0 == UnicodeCompare(bstrAlias, m_bstrAlias)));

}

/*  P L A C E  C A L L  */
/*-------------------------------------------------------------------------
    %%Function: PlaceCall

-------------------------------------------------------------------------*/
VOID COutgoingCall::PlaceCall(void)
{
	DebugEntry(COutgoingCall::PlaceCall);

	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	ASSERT(NULL != pOprahNCUI);

	SetCallState(CNS_SEARCHING);

	if ((CRPCF_H323CC & m_dwFlags) && (NULL != g_pH323UI))
	{
		SetCallState(CNS_CONNECTING_H323);

		// Start placing the H.323 call:
		CNSTATUS cnResult = ConnectH323();
		if (CN_RC_NOERROR != cnResult)
		{
			m_cnResult = cnResult;
			SetCallState(CNS_COMPLETE);
		}
	}
	else if ((CRPCF_DATA & m_dwFlags) && (NULL != g_pNodeController))
	{
		// Start placing the T.120 call
		CNSTATUS cnResult = StartT120Call();
		if (CN_RC_NOERROR != cnResult)
		{
			m_cnResult = cnResult;
			SetCallState(CNS_COMPLETE);
		}
	}
	else
	{
		m_cnResult = CN_RC_TRANSPORT_FAILURE;
		SetCallState(CNS_COMPLETE);
	}

	DebugExitVOID(COutgoingCall::PlaceCall);
}

CNSTATUS COutgoingCall::ConnectH323()
{
	DBGENTRY(COutgoingCall::ConnectH323);
	H323ALIASLIST AliasList;
	H323ALIASNAME AliasName;
	P_H323ALIASLIST pAliasList = &AliasList;
	SOCKADDR_IN sin;
	LPCWSTR pcwszPhone = NULL;
	CNSTATUS cnResult = CN_RC_NOERROR;

	if (NULL == g_pH323UI)
		return cnResult;
	
	AliasName.aType = AT_H323_ID;
	AliasName.lpwData = m_bstrAlias;
	AliasName.wDataLength = (WORD)SysStringLen(m_bstrAlias);// # of unicode chars, w/o NULL terminator
	AliasList.wCount = 1;
	AliasList.pItems = &AliasName;

	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = inet_addr(m_pszAddr);

	switch (m_addrType)
	{
	case NM_ADDR_PSTN:
	case NM_ADDR_H323_GATEWAY:
	case NM_ADDR_ALIAS_E164:
		// overide alias type and phone number
		AliasName.aType = AT_H323_E164;
		pcwszPhone = m_bstrAlias;
		break;

	case NM_ADDR_IP:
	case NM_ADDR_MACHINENAME:
		// overide alias list
		pAliasList = NULL;
		break;

	case NM_ADDR_ALIAS_ID:
	case NM_ADDR_ULS:
	default:
		break;
	}

	if (INADDR_NONE != sin.sin_addr.s_addr)
	{
		HRESULT hr;
		ASSERT(g_pH323UI);

		DWORD dwUserData = 0;
		APP_CALL_SETUP_DATA acsd;
		P_APP_CALL_SETUP_DATA pacsd = NULL;
		BYTE *pbUserData = NULL;
	
		COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
		ASSERT(NULL !=pOprahNCUI);
		
		if (CRPCF_DATA & m_dwFlags)
		{
			if (CRPCF_SECURE & m_dwFlags)
			{
				dwUserData |= H323UDF_SECURE;
			}

			if (m_pConfObject->IsConferenceActive())
			{
				dwUserData |= H323UDF_INVITE;
			}
			else if (m_bstrConfToJoin != NULL)
			{
				dwUserData |= H323UDF_JOIN;
			}
			else
			{
				dwUserData |= H323UDF_INVITE | H323UDF_JOIN;
			}
		}

		if (CRPCF_AUDIO & m_dwFlags)
		{
			dwUserData |= H323UDF_AUDIO;
		}
		if (CRPCF_VIDEO & m_dwFlags)
		{
			dwUserData |= H323UDF_VIDEO;
		}

		CRosterInfo ri;
		PVOID pvRosterData;
		UINT cbRosterData = 0;

		if (pOprahNCUI->GetULSName(&ri))
		{
			if (FAILED(ri.Save(&pvRosterData, &cbRosterData)))
			{
				cbRosterData = 0;
			}
		}

		UINT cbUserString = 0;
		if (m_bstrUserString)
		{
			cbUserString = SysStringByteLen(m_bstrUserString);
		}
		
		DWORD dwTotalSize =	sizeof(DWORD);
		if (cbRosterData)
		{
			dwTotalSize += sizeof(GUID) + sizeof(DWORD) + cbRosterData;
		}
		if (cbUserString)
		{
			dwTotalSize += sizeof(GUID) + sizeof(DWORD) + cbUserString;
		}
		dwTotalSize += sizeof(GUID) + sizeof(DWORD) + sizeof(GUID);

		pbUserData = new BYTE [dwTotalSize];
		if (NULL != pbUserData)
		{
			BYTE *pb = pbUserData;

			// H323UDF_ first
			*((DWORD*)pb) = dwUserData;
			pb += sizeof(DWORD);

			if(cbRosterData)
			{
				// RosterInfo GUID next
				*((GUID*)pb) = g_csguidRostInfo,
				pb += sizeof(GUID);

				// then RosterInfo size (a DWORD)
				*((DWORD*)pb) = cbRosterData;
				pb += sizeof(DWORD);

				// then RosterInfo data
				CopyMemory(pb, pvRosterData, cbRosterData);
				pb += cbRosterData;
			}

			if(cbUserString)
			{
				// string GUID next
				*((GUID*)pb) = g_csguidUserString,
				pb += sizeof(GUID);

				// then string size (a DWORD)
				*((DWORD*)pb) = cbUserString;
				pb += sizeof(DWORD);

				// then string data
				CopyMemory(pb, m_bstrUserString, cbUserString);
				pb += cbUserString;
			}

			{
				// string GUID next
				*((GUID*)pb) = g_csguidNodeIdTag,
				pb += sizeof(GUID);

				// then string size (a DWORD)
				*((DWORD*)pb) = sizeof(GUID);
				pb += sizeof(DWORD);

				// then GUID data
				*(GUID*)pb = g_guidLocalNodeId;
				pb += sizeof(GUID);
			}

			acsd.dwDataSize = dwTotalSize;
			acsd.lpData = pbUserData;
			pacsd = &acsd;
		}

		sin.sin_port = htons(H323_PORT);
		hr = Connect(&sin, pAliasList, pcwszPhone, pacsd, PID_H323, &m_pH323Connection);
		delete [] pbUserData;

		if (SUCCEEDED(hr))
		{
			TRACE_OUT(("COutgoingCall - Connect() succeeded!"));
			cnResult = CN_RC_NOERROR;
		}
		else
		{
			WARNING_OUT(("COutgoingCall - Connect() failed!"));
			if (CONN_E_GK_NOT_REGISTERED == hr)
			{
				cnResult = CN_RC_GK_NOT_REGISTERED;
			}
			else
			{
				cnResult = CN_RC_AUDIO_CONNECT_FAILED;
			}
		}
	}
	else
	{
		WARNING_OUT(("COutgoingCall - inet_addr failed!"));
		cnResult = CN_RC_NAME_RESOLUTION_FAILED;
	}
	return cnResult;
}


HRESULT COutgoingCall::Connect(	PSOCKADDR_IN psin,
						    P_H323ALIASLIST pAliasList,
							LPCWSTR pcwszPSTNAddress,
							P_APP_CALL_SETUP_DATA lpvMNMData,
							GUID PIDofProtocolType,
							IH323Endpoint * *ppConnection)
{
	DebugEntry(CH323UI::Connect);

	HRESULT hr = E_ACCESSDENIED;

	*ppConnection = NULL;

	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	ASSERT(NULL != pOprahNCUI);

	IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();
		
	// create the connection
	IH323Endpoint* pConn = NULL;
	ASSERT(pH323CallControl);
	
	hr = pH323CallControl->CreateConnection(&pConn, PIDofProtocolType);
	if (FAILED(hr) || (NULL == pConn))
	{
		ERROR_OUT(("Could not create a connection, hr=0x%lx", hr));
	}
	else
	{
		// if the following operations fail, we still can delete this conn obj
		*ppConnection = pConn;

		if (!pOprahNCUI->AcquireAV(pConn))
		{
			// we did not get AV, clear out the flags
			m_dwFlags &= ~(CRPCF_AUDIO | CRPCF_VIDEO);
		}
	
		hr = pConn->SetAdviseInterface (pOprahNCUI);
		ASSERT(SUCCEEDED(hr));

		// if we are using an alias, tell the Gatekeeper to resolve it
		BOOL fUseGKResolution = (NULL != pAliasList);

		// start the connection
		hr = pConn->PlaceCall (fUseGKResolution, psin, pAliasList, NULL, pcwszPSTNAddress, lpvMNMData);
		if (FAILED(hr))
		{
			// ERROR_OUT(("COutgoingCall::Connect: couldn't StartConnection, hr=0x%lx", hr));
			if(hr == CONN_E_GK_NOT_REGISTERED)
			{
				WARNING_OUT(("COutgoingCall::Connect: not registered. Do you want to re-register..., hr=0x%lx", hr));
			}
			*ppConnection = NULL;

			pConn->Release();

			pOprahNCUI->ReleaseAV(pConn);
		}
	}

	DebugExitULONG(CH323UI::Connect, hr);

	return hr;
}

BOOL COutgoingCall::OnConferenceEnded()
{
	DebugEntry(COutgoingCall::OnConferenceEnded);

	BOOL bRet = FALSE;

	switch (m_cnState)
	{
		case CNS_INVITING_REMOTE:
		{
			TRACE_OUT(("COutgoingCall (calling) rec. UNEXPECTED ConfEnded event"));

			SetCallState(CNS_COMPLETE);

			bRet = TRUE;
			break;
		}

		case CNS_JOINING_REMOTE:
		{
			// JoinConference failed!
			TRACE_OUT(("COutgoingCall (joining) received ConferenceEnded event"));

			m_cnResult = CN_RC_CONFERENCE_JOIN_DENIED;
			SetCallState(CNS_COMPLETE);

			bRet = TRUE;
			break;
		}

		case CNS_TERMINATING_AFTER_INVITE:
		{
			TRACE_OUT(("COutgoingCall (terminating after invite) received ConferenceEnded event"));

			SetCallState(CNS_QUERYING_REMOTE_AFTER_INVITE);

			ASSERT(g_pNodeController);

			HRESULT hr = g_pNodeController->QueryRemote(this, m_pszAddr,
				m_pConfObject->IsConfObjSecure(),
				m_pConfObject->IsConferenceActive());
			if (S_OK != hr)
			{
				m_cnResult = CN_RC_QUERY_FAILED;
				SetCallState(CNS_COMPLETE);
			}

			bRet = TRUE;
			break;
		}

		default:
		{
			WARNING_OUT(("COutgoingCall received unexpected ConfEnded event"));
		}
	}

	DebugExitBOOL(COutgoingCall::OnConferenceEnded, bRet);
	return bRet;
}

BOOL COutgoingCall::OnInviteResult(HRESULT ncsResult, UINT uNodeID)
{
	DebugEntry(COutgoingCall::OnInviteResult);

	BOOL bRet = TRUE;

	ASSERT(CNS_INVITING_REMOTE == m_cnState);

	TRACE_OUT(("COutgoingCall (calling) received InviteResult event"));

	// Clear the current request handle
	m_hRequest = NULL;
	
	if (0 == ncsResult)
	{
		SetCallState(CNS_COMPLETE);
		if (m_pH323Connection)
		{
			m_pConfObject->OnT120Connected(m_pH323Connection, uNodeID);
		}
	}
	else
	{
		if (UI_RC_USER_REJECTED == ncsResult)
		{
			SetCallState(CNS_TERMINATING_AFTER_INVITE);

			// Issue "soft" leave attempt (to allow auto-terminate)
			ASSERT(m_pConfObject);
			if (S_OK != m_pConfObject->LeaveConference(FALSE))
			{
				m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
				SetCallState(CNS_COMPLETE);
			}
		}
		else
		{
			// make sure that we are not recieving this notification due to
			// the conference going away
			ASSERT(m_pConfObject);
			if (CS_GOING_DOWN != m_pConfObject->GetT120State())
			{
				TRACE_OUT(("COutgoingCall - invite failed / couldn't connect -> leaving"));
			
				m_cnResult = CN_RC_INVITE_FAILED;
				SetCallState(CNS_COMPLETE);

				// Issue "soft" leave attempt (to allow auto-terminate)
				ASSERT(m_pConfObject);
				m_pConfObject->LeaveConference(FALSE);
			}
		}
	}

	DebugExitBOOL(COutgoingCall::OnInviteResult, bRet);
	return bRet;
}

BOOL COutgoingCall::OnQueryRemoteResult(HRESULT ncsResult,
									BOOL fMCU,
									PWSTR pwszConfNames[],
									PT120PRODUCTVERSION pVersion,
									PWSTR pwszConfDescriptors[])
{
	DebugEntry(COutgoingCall::OnQueryRemoteResult);

	ASSERT ((CNS_QUERYING_REMOTE == m_cnState) ||
			(CNS_QUERYING_REMOTE_AFTER_INVITE == m_cnState));
	ASSERT (NULL == m_bstrConfToJoin);

	if (SUCCEEDED(ncsResult))
	{
		BOOL fRemoteInConf = FALSE;
		if ((NULL != pwszConfNames) && (NULL != pwszConfNames[0]))
		{
			fRemoteInConf = TRUE;
		}

		m_fService = FALSE;
		if (fRemoteInConf && (NULL != pwszConfDescriptors) && (NULL != pwszConfDescriptors[0]))
		{
			if (0 == UnicodeCompare(pwszConfDescriptors[0],RDS_CONFERENCE_DESCRIPTOR))
			{
				m_fService = TRUE;
			}
		}

		if (m_pConfObject->IsConferenceActive())
		{
			if (fMCU)
			{
				TRACE_OUT(("COutgoingCall - QR ok, but is MCU -> complete"));
				m_cnResult = CN_RC_CANT_INVITE_MCU;
			}
			else if (fRemoteInConf)
			{
				TRACE_OUT(("COutgoingCall - QR ok, but callee is in a conference"));
				m_cnResult = CN_RC_INVITE_DENIED_REMOTE_IN_CONF;
			}
			else
			{
				if (CNS_QUERYING_REMOTE_AFTER_INVITE == m_cnState)
				{
					m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
					SetCallState(CNS_COMPLETE);
				}
				else
				{
					SetCallState(CNS_INVITING_REMOTE);

					HRESULT hr = m_pConfObject->InviteConference(m_pszAddr, m_bstrUserString, &m_hRequest);
					if (S_OK != hr)
					{
						// Failure while inviting:
						m_cnResult = CN_RC_INVITE_FAILED;
					}
				}
			}

			if (CN_RC_NOERROR != m_cnResult)
			{
				SetCallState(CNS_COMPLETE);
			}
		}
		else if (fRemoteInConf || fMCU)
		{
			TRACE_OUT(("COutgoingCall - QR succeeded (>0 conf) -> joining"));
			TRACE_OUT(("\tfMCU is %d", fMCU));
		
			// There are remote conferences
			HRESULT hr = E_FAIL; // Assume a failure

			SetCallState(CNS_JOINING_REMOTE);

			if (!fMCU && (NULL == pwszConfNames[1]))
			{
				// we're not calling an MCU and we have just one conference, so join it
				m_bstrConfToJoin = SysAllocString(pwszConfNames[0]);
				hr = m_pConfObject->JoinConference(	m_bstrConfToJoin,
													m_bstrPassword,
													m_pszAddr,
													m_bstrUserString);
			}
			else
			{
				ASSERT(NULL == m_bstrConfToJoin);
				REMOTE_CONFERENCE remoteConf;
				remoteConf.fMCU = fMCU;
				remoteConf.pwszConfNames = pwszConfNames;
				remoteConf.pbstrConfToJoin = &m_bstrConfToJoin;

				// Ask the app which conference to join
				NotifySink(&remoteConf, OnNotifyRemoteConference);

				if (NULL != m_bstrConfToJoin)
				{
					hr = m_pConfObject->JoinConference(	m_bstrConfToJoin,
														m_bstrPassword,
														m_pszAddr,
														m_bstrUserString);
				}
			}

			if (S_OK != hr)
			{
				// JoinConference failed!
				m_cnResult = CN_RC_JOIN_FAILED;
				SetCallState(CNS_COMPLETE);
			}
		}
		else
		{
			if (CNS_QUERYING_REMOTE_AFTER_INVITE == m_cnState)
			{
				m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
				SetCallState(CNS_COMPLETE);
			}
			else
			{
				// No conferences on remote machine, so create local:
				TRACE_OUT(("COutgoingCall - QR succeeded (no conf)-> creating local"));

				// Create local conf
				ASSERT(m_pConfObject);
				SetCallState(CNS_CREATING_LOCAL);
				HRESULT hr = m_pConfObject->CreateConference();

				if (S_OK != hr)
				{
					// CreateConference failed!
					m_cnResult = CN_RC_CONFERENCE_CREATE_FAILED;
					SetCallState(CNS_COMPLETE);
				}
			}
		}
	}
	else
	{
		// The QueryRemote failed
		switch( ncsResult )
		{
			case UI_RC_USER_REJECTED:
				// The initial QueryRemote failed because GCC symmetry determined
				// that the other node is calling someone, and it might be us
				// See Bug 1886
				TRACE_OUT(("COutgoingCall - QueryRemote rejected -> complete"));
				m_cnResult = CN_RC_REMOTE_PLACING_CALL;
				break;
			case UI_RC_T120_REMOTE_REQUIRE_SECURITY:
				m_cnResult = CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY;
				break;
			case UI_RC_T120_SECURITY_FAILED:
				m_cnResult = CN_RC_SECURITY_FAILED;
				break;
			case UI_RC_T120_REMOTE_NO_SECURITY:
				m_cnResult = CN_RC_CONNECT_REMOTE_NO_SECURITY;
				break;
			case UI_RC_T120_REMOTE_DOWNLEVEL_SECURITY:
				m_cnResult = CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY;
				break;
			case UI_RC_T120_AUTHENTICATION_FAILED:
				m_cnResult = CN_RC_CONNECT_AUTHENTICATION_FAILED;
				break;
			default:
				m_cnResult = CN_RC_CONNECT_FAILED;
				break;
		}
		SetCallState(CNS_COMPLETE);
	}

	DebugExitBOOL(COutgoingCall::OnQueryRemoteResult, TRUE);
	return TRUE;
}

BOOL COutgoingCall::OnConferenceStarted(CONF_HANDLE hNewConf, HRESULT ncsResult)
{
	DebugEntry(COutgoingCall::OnConferenceStarted);

	switch (m_cnState)
	{
		case CNS_CREATING_LOCAL:
		{
			TRACE_OUT(("COutgoingCall (inviting) received ConferenceStarted event"));
			
			if (0 == ncsResult)
			{
				ASSERT(m_pConfObject);
				ASSERT(NULL == m_hRequest);

				SetCallState(CNS_INVITING_REMOTE);

				HRESULT hr = m_pConfObject->InviteConference(m_pszAddr, m_bstrUserString, &m_hRequest);
				if (S_OK != hr)
				{
					m_hRequest = NULL;
					m_cnResult = CN_RC_INVITE_FAILED;
					SetCallState(CNS_COMPLETE);
					
					// Issue "soft" leave attempt (to allow auto-terminate)
					ASSERT(m_pConfObject);
					hr = m_pConfObject->LeaveConference(FALSE);
					if (FAILED(hr))
					{
						WARNING_OUT(("Couldn't leave after failed invite"));
					}
				}
			}
			else
			{
				WARNING_OUT(("CreateConference (local) failed - need UI here!"));
				m_cnResult = CN_RC_CONFERENCE_CREATE_FAILED;
				SetCallState(CNS_COMPLETE);
			}
			
			break;
		}

		case CNS_JOINING_REMOTE:
		{
			TRACE_OUT(("COutgoingCall (joining) received ConferenceStarted event"));

			if (0 == ncsResult)
			{
				SetCallState(CNS_COMPLETE);
				if (m_pH323Connection)
				{
					UINT uNodeID = hNewConf->GetParentNodeID();

					m_pConfObject->OnT120Connected(m_pH323Connection, uNodeID);
				}
			}
			else if (UI_RC_INVALID_PASSWORD == ncsResult)
			{
				TRACE_OUT(("COutgoingCall - invalid password, prompt for password"));

				BSTR bstrPassword = NULL;
				REMOTE_PASSWORD remotePw;
				remotePw.bstrConference = m_bstrConfToJoin;
				remotePw.pbstrPassword = &bstrPassword;
				if (NO_ERROR != hNewConf->GetCred(&remotePw.pbRemoteCred, &remotePw.cbRemoteCred))
				{
					remotePw.pbRemoteCred = NULL;
					remotePw.cbRemoteCred = 0;
				}
				remotePw.fIsService = m_fService;
				NotifySink(&remotePw, OnNotifyRemotePassword);

				if (NULL != bstrPassword)
				{
					SysFreeString(m_bstrPassword);
					m_bstrPassword = bstrPassword;

					// reissue join with new password
					ASSERT(m_pConfObject);
					HRESULT ncs =
						m_pConfObject->JoinConference(	m_bstrConfToJoin,
														m_bstrPassword,
														m_pszAddr,
														m_bstrUserString,
														TRUE); // retry

					if (0 != ncs)
					{
						// JoinConference failed!
						m_cnResult = CN_RC_JOIN_FAILED;
						SetCallState(CNS_COMPLETE);
					}
				}
				else
				{
					// cancel from pw dlg
					m_cnResult = CN_RC_INVALID_PASSWORD;
					SetCallState(CNS_COMPLETE);
					
					ASSERT(m_pConfObject);
					HRESULT hr = m_pConfObject->LeaveConference(TRUE);
					if (FAILED(hr))
					{
						ERROR_OUT(("Couldn't leave after cancelling pw join!"));
					}
				}
			}
			else if (UI_RC_UNKNOWN_CONFERENCE == ncsResult)
			{
				TRACE_OUT(("Join failed (conf does not exist) "
							"- notifying user"));
						
				// error while joining
				m_cnResult = CN_RC_CONFERENCE_DOES_NOT_EXIST;
				SetCallState(CNS_COMPLETE);
			}
			else
			{
				TRACE_OUT(("Join failed - notifying user"));
						
				// error while joining
				m_cnResult = CN_RC_CONFERENCE_JOIN_DENIED;
				SetCallState(CNS_COMPLETE);
			}

			break;
		}

		default:
		{
			if (m_pConfObject->GetConfHandle() == hNewConf)
			{
				WARNING_OUT(("COutgoingCall received unexpected ConferenceStarted event"));
			}
			else
			{
				TRACE_OUT(("COutgoingCall ignoring ConferenceStarted event - not our conf"));
			}
		}
	}

	DebugExitBOOL(COutgoingCall::OnConferenceStarted, TRUE);
	return TRUE;
}

BOOL COutgoingCall::OnH323Connected(IH323Endpoint * pConnection)
{
	DebugEntry(COutgoingCall::OnH323Connected);

	BOOL bRet = TRUE;

	ASSERT(m_pH323Connection == pConnection);

	if (m_dwFlags & CRPCF_DATA)
	{
		PCC_VENDORINFO pLocalVendorInfo;
		PCC_VENDORINFO pRemoteVendorInfo;

		pConnection->GetVersionInfo(&pLocalVendorInfo, &pRemoteVendorInfo);
		H323VERSION version = GetH323Version(pRemoteVendorInfo);

		if (H323_NetMeeting20 == version)
		{
			if ((m_addrType != NM_ADDR_H323_GATEWAY) &&
				(m_addrType != NM_ADDR_PSTN) &&
				(m_addrType != NM_ADDR_ALIAS_ID) &&
				(m_addrType != NM_ADDR_ALIAS_E164))
			{
				CNSTATUS cnResult = StartT120Call();
				if (CN_RC_NOERROR != cnResult)
				{
					m_cnResult = cnResult;
					SetCallState(CNS_COMPLETE);
				}
			}
			else
			{
				SetCallState(CNS_COMPLETE);
			}
		}
		else
		{
			// wait for results of T.120 open logical channel
			TRACE_OUT(("COutgoingCall - H323Connected received -> waiting for T120 channel open"));
			SetCallState(CNS_WAITING_T120_OPEN);
		}
	}
	else
	{
		// no T120 for this call
		TRACE_OUT(("COutgoingCall - our H323 call started -> complete"));
		SetCallState(CNS_COMPLETE);
	}
	
	CConfObject *pco = ::GetConfObject();
	if (NULL != pco)
	{
		// add member if we are calling with A/V
		BOOL fAddMember = m_dwFlags & (CRPCF_AUDIO | CRPCF_VIDEO);

		pco->OnH323Connected(pConnection, m_dwFlags, fAddMember, GUID_NULL);
	}

	DebugExitBOOL(COutgoingCall::OnH323Connected, bRet);
	return bRet;
}

BOOL COutgoingCall::OnH323Disconnected(IH323Endpoint * pConnection)
{
	DebugEntry(COutgoingCall::OnH323Disconnected);

	BOOL bRet = TRUE;
	
	ASSERT(m_pH323Connection == pConnection);

	HRESULT hSummary = m_pH323Connection->GetSummaryCode();
	// Check summary code for gatekeeper-caused disconnect
	// Note: this applies only to MY gatekeeper, not the callee's gatekeeper
	if(CUSTOM_FACILITY(hSummary) == FACILITY_GKIADMISSION)
	{
		DWORD dwRejectReason;
		dwRejectReason = CUSTOM_FACILITY_CODE(hSummary);
		
		// should the T.120 call be placed anyway?
		switch (dwRejectReason)
		{
			case ARJ_CALLEE_NOT_REGISTERED:
				m_cnResult = CN_RC_GK_CALLEE_NOT_REGISTERED;
				break;
			case ARJ_TIMEOUT:
				m_cnResult = CN_RC_GK_TIMEOUT;
				break;
			case ARJ_INVALID_PERMISSION:
			case ARJ_REQUEST_DENIED:
			case ARJ_UNDEFINED:
			case ARJ_CALLER_NOT_REGISTERED:
			case ARJ_ROUTE_TO_GK:
			case ARJ_INVALID_ENDPOINT_ID:
			case ARJ_RESOURCE_UNAVAILABLE:
			case ARJ_SECURTY_DENIAL:
			case ARJ_QOS_CONTROL_NOT_SUPPORTED:
			case ARJ_INCOMPLETE_ADDRESS:
			default:
				m_cnResult = CN_RC_GK_REJECTED;
				break;
		}

		SetCallState(CNS_COMPLETE);
	}
	else if (CNS_CONNECTING_H323 == m_cnState)
	{
		// attempted an H.323 call without success.

		TRACE_OUT(("COutgoingCall - our leading H323 call ended -> complete"));

		// check for cases of remote refusing the call
		switch (hSummary)
		{
			case CCR_REMOTE_DISCONNECT:
			case CCR_REMOTE_REJECTED:
				m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
				SetCallState(CNS_COMPLETE);
				break;
			case CCR_LOCAL_DISCONNECT:
				// cancelled by user, do not report error
				m_cnResult = CN_RC_LOCAL_CANCELED;
				m_fCanceled = TRUE;
				SetCallState(CNS_COMPLETE);
				break;
			case CCR_GK_NO_RESOURCES:
				// callee's gatekeeper would not let callee answer
				// do the same as CCR_REMOTE_REJECTED
				// as a temporary measure !!!!
				m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
				SetCallState(CNS_COMPLETE);
				break;
			case CCR_REMOTE_SECURITY_DENIED:
				if (m_pConfObject->IsConfObjSecure())
				{
					m_cnResult = CN_RC_CONNECT_REMOTE_NO_SECURITY;
				}
				else
				{
					m_cnResult = CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY;
				}
				SetCallState(CNS_COMPLETE);
				break;
			case CCR_REMOTE_BUSY:
				if (m_pConfObject->IsConferenceActive())
				{
					m_cnResult = CN_RC_INVITE_DENIED_REMOTE_IN_CONF;
					SetCallState(CNS_COMPLETE);
					break;
				}
				// else fall through

			default:
				if ((m_dwFlags & CRPCF_DATA) &&
					(m_addrType != NM_ADDR_H323_GATEWAY) &&
					(m_addrType != NM_ADDR_PSTN) &&
					(m_addrType != NM_ADDR_ALIAS_ID) &&
					(m_addrType != NM_ADDR_ALIAS_E164))
				{
					// The endpoint is not there, not listening for H.323 calls, or is busy,
					// and the address is a resolvable type (not an H.323 alias or E.164 number)
					// go back into the T.120 call state path
					CNSTATUS cnResult = StartT120Call();
					if (CN_RC_NOERROR != cnResult)
					{
						m_cnResult = cnResult;
						SetCallState(CNS_COMPLETE);
						bRet = FALSE;
					}
				}
				else
				{
					switch (hSummary)
					{
						case CCR_REMOTE_BUSY:
							m_cnResult = CN_RC_INVITE_DENIED_REMOTE_IN_CONF;
							break;
						case CCR_REMOTE_MEDIA_ERROR:
							m_cnResult = CN_RC_AUDIO_IN_USE_REMOTE;
							break;
						case CCR_LOCAL_MEDIA_ERROR:
							m_cnResult = CN_RC_AUDIO_IN_USE_LOCAL;
							break;
						case CCR_GK_NO_RESOURCES:
							m_cnResult = CN_RC_GK_REJECTED;
							break;
						default:
							m_cnResult = CN_RC_AUDIO_CONNECT_FAILED;
							break;
					}
					SetCallState(CNS_COMPLETE);
				}
				break;
		}
	}
	else if (CNS_WAITING_T120_OPEN == m_cnState)
	{
		TRACE_OUT(("COutgoingCall - OnH323Disconnected received -> call is canceled"));
		m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
		SetCallState(CNS_COMPLETE);
	}
	else
	{
		TRACE_OUT(("COutgoingCall - OnH323Disconnected received -> canceling call"));
		ASSERT(m_pConfObject);

		if (NULL != m_hRequest)
		{
			REQUEST_HANDLE hRequest = m_hRequest;
			m_hRequest = NULL;
			m_pConfObject->CancelInvite(hRequest);
		}

		if (m_pConfObject->IsConferenceActive())
		{
			// Issue "soft" leave attempt (to allow auto-terminate)
			m_pConfObject->LeaveConference(FALSE);
		}
	}

	// the connection may have been released due to the LeaveConference above
	// bug 3996
	if (m_pH323Connection)
	{
		m_pH323Connection->Release();
		m_pH323Connection = NULL;
	}

	DebugExitBOOL(COutgoingCall::OnH323Disconnected, bRet);
	return bRet;
}

BOOL COutgoingCall::OnT120ChannelOpen(ICommChannel *pIChannel, DWORD dwStatus)
{
	DebugEntry(COutgoingCall::OnT120ChannelOpen);

	BOOL bRet = TRUE;

	// sometimes we get an extra T120 channel open
	// this is most likely due the master/slave anomolies that
	// venkatg discovered.
	if (CNS_WAITING_T120_OPEN == m_cnState)
	{
		switch(dwStatus)
		{
			case CHANNEL_OPEN:
				{
					// start the T.120 part of the call
					// get the negotiated address
					SOCKADDR_IN sin_T120;
					HRESULT hr = pIChannel->GetRemoteAddress(&sin_T120);
					delete m_pszAddr;  // we won't be needing this anymore

					TCHAR szAddress[256];  // allow plenty of room for conversion from numberic to string
					wsprintf(szAddress, "%s:%d", inet_ntoa(sin_T120.sin_addr), ntohs(sin_T120.sin_port));
					m_pszAddr =  PszAlloc(szAddress);

					CNSTATUS cnResult = StartT120Call();
					if (CN_RC_NOERROR != cnResult)
					{
						m_cnResult = cnResult;
						SetCallState(CNS_COMPLETE);
					}
				}
				break;
			case CHANNEL_CLOSED:	
				// if the T.120 channel is being closed
				// the H.323 call is going down, so don't continue waiting for
				// T.120 to connect!
				m_cnResult = CN_RC_CONNECT_FAILED;
				SetCallState(CNS_COMPLETE);

				if (NULL != m_hRequest)
				{
					REQUEST_HANDLE hRequest = m_hRequest;
					m_hRequest = NULL;
					ASSERT(m_pConfObject);
					m_pConfObject->CancelInvite(hRequest);
				}
				break;
				
			case CHANNEL_NO_CAPABILITY:
			case CHANNEL_REJECTED:
			case CHANNEL_OPEN_ERROR:
			default:
				m_cnResult = CN_RC_CONNECT_FAILED;
				SetCallState(CNS_COMPLETE);
				break;
		}
	}

	DebugExitBOOL(COutgoingCall::OnT120ChannelOpen, bRet);
	return bRet;
}


void COutgoingCall::CallComplete()
{
	DebugEntry(COutgoingCall::CallComplete);

	// If this fails, we are being destructed unexpectedly
	
	ASSERT( (m_cnState == CNS_IDLE) ||
			(m_cnState == CNS_COMPLETE));

	// The request handle should have been reset
	ASSERT(NULL == m_hRequest);

	// make sure that the H323 connection is released
	if (m_pH323Connection)
	{
		if (!IsDataOnly() &&
			((CN_RC_TRANSPORT_FAILURE == m_cnResult) ||
			(CN_RC_QUERY_FAILED == m_cnResult) ||
			(CN_RC_CONNECT_FAILED == m_cnResult)))
		{
			m_cnResult = CN_RC_NOERROR;
		}

		if (CN_RC_NOERROR != m_cnResult)
		{
			m_pH323Connection->Disconnect();
		}
		m_pH323Connection->Release();
		m_pH323Connection = NULL;
	}

	if (!FCanceled() && (CN_RC_NOERROR != m_cnResult))
	{
		ReportError(m_cnResult);
	}

	NM_CALL_STATE state;
	GetState(&state);
	NotifySink((PVOID) state, OnNotifyCallStateChanged);

	TRACE_OUT(("ConfNode destroying addr %s", m_pszAddr));
	DebugExitVOID(COutgoingCall::CallComplete);
}

BOOL COutgoingCall::ReportError(CNSTATUS cns)
{
	DebugEntry(COutgoingCall::ReportError);
	TRACE_OUT(("CNSTATUS 0x%08x", cns));
	
	NotifySink((PVOID)cns, OnNotifyCallError);

	DebugExitBOOL(COutgoingCall::ReportError, TRUE);
	return TRUE;
}

CNSTATUS COutgoingCall::StartT120Call()
{
	DebugEntry(COutgoingCall::StartT120Call);
	
	CNSTATUS cnResult = CN_RC_NOERROR;

	if (NULL == m_bstrConfToJoin)
	{
		// conference name not specified
		// need to start out with a QueryRemote
		SetCallState(CNS_QUERYING_REMOTE);

		ASSERT(g_pNodeController);

		HRESULT hr = g_pNodeController->QueryRemote(this, m_pszAddr,
			m_pConfObject->IsConfObjSecure(),
			m_pConfObject->IsConferenceActive());
		if (S_OK != hr)
		{
			cnResult = CN_RC_QUERY_FAILED;
		}
	}
	else
	{
		ASSERT(m_pConfObject);
		// conference name has been specified
		// time to do a JoinConference
		SetCallState(CNS_JOINING_REMOTE);

		HRESULT hr = m_pConfObject->JoinConference(	m_bstrConfToJoin,
													m_bstrPassword,
													m_pszAddr,
													m_bstrUserString);
		if (S_OK != hr)
		{
			cnResult = CN_RC_JOIN_FAILED;
		}
	}
	
	DebugExitINT(COutgoingCall::StartT120Call, cnResult);
	return cnResult;
}


VOID COutgoingCall::SetCallState(CNODESTATE cnState)
{
	NM_CALL_STATE stateOld;
	NM_CALL_STATE stateNew;
	GetState(&stateOld);

	m_cnState = cnState;

	// completion state will be fired off later
	if (CNS_COMPLETE != cnState)
	{
		GetState(&stateNew);
		if (stateOld != stateNew)
		{
			NotifySink((PVOID) stateNew, OnNotifyCallStateChanged);
		}
	}
}

HRESULT COutgoingCall::_Cancel(BOOL fLeaving)
{
	DebugEntry(COutgoingCall::Cancel);

	BOOL fAbortT120 = (m_cnState != CNS_COMPLETE);

	if (fAbortT120)
	{
		m_fCanceled = TRUE;

		// Abort T.120 Call:


		// Attempt to make this transition regardless of our
		// current state:
		SetCallState(CNS_COMPLETE);

		ASSERT(m_pConfObject);

		if (NULL != m_hRequest)
		{
			REQUEST_HANDLE hRequest = m_hRequest;
			m_hRequest = NULL;
			m_pConfObject->CancelInvite(hRequest);
		}

		if (!fLeaving && m_pConfObject->IsConferenceActive())
		{
			HRESULT hr = m_pConfObject->LeaveConference(FALSE);
			if (FAILED(hr))
			{
				WARNING_OUT(("Couldn't leave after disconnecting"));
			}
		}
	}

	if (NULL != m_pH323Connection)
	{
		m_fCanceled = TRUE;

		// Abort H.323 Call:
		m_pH323Connection->Disconnect();
	}

	DebugExitULONG(COutgoingCall::Abort, m_cnResult);

	return CN_RC_NOERROR ? S_OK : E_FAIL;
}

STDMETHODIMP_(ULONG) COutgoingCall::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) COutgoingCall::Release(void)
{
	return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE COutgoingCall::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmCall) || (riid == IID_IUnknown))
	{
		*ppv = (INmCall *)this;
		ApiDebugMsg(("COutgoingCall::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		ApiDebugMsg(("CNmCall::QueryInterface(): Returning IConnectionPointContainer."));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("COutgoingCall::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

HRESULT COutgoingCall::IsIncoming(void)
{
	return S_FALSE;
}

HRESULT COutgoingCall::GetState(NM_CALL_STATE *pState)
{
	HRESULT hr = E_POINTER;

	if (NULL != pState)
	{
		if (FCanceled())
		{
			*pState = NM_CALL_CANCELED;
		}
		else
		{
			switch (m_cnState)
			{
				case CNS_IDLE:
					*pState = NM_CALL_INIT;
					break;

				case CNS_SEARCHING:
					*pState = NM_CALL_SEARCH;
					break;

				case CNS_CONNECTING_H323:
				case CNS_WAITING_T120_OPEN:
				case CNS_QUERYING_REMOTE:
				case CNS_CREATING_LOCAL:
				case CNS_INVITING_REMOTE:
				case CNS_JOINING_REMOTE:
					*pState = NM_CALL_WAIT;
					break;

				case CNS_COMPLETE:
					switch (m_cnResult)
					{
					case CN_RC_NOERROR:
						*pState = NM_CALL_ACCEPTED;
						break;
					case CN_RC_CONFERENCE_JOIN_DENIED:
					case CN_RC_CONFERENCE_INVITE_DENIED:
					case CN_RC_CONFERENCE_DOES_NOT_EXIST:
					case CN_RC_AUDIO_CONNECT_FAILED:
					case CN_RC_GK_CALLEE_NOT_REGISTERED:
					case CN_RC_GK_TIMEOUT:
					case CN_RC_GK_REJECTED:
					case CN_RC_GK_NOT_REGISTERED:
					case CN_RC_CONNECT_REMOTE_NO_SECURITY:
					case CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY:
					case CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY:
					case CN_RC_TRANSPORT_FAILURE:
					case CN_RC_QUERY_FAILED:
					case CN_RC_CONNECT_FAILED:
						*pState = NM_CALL_REJECTED;
						break;

					case CN_RC_ALREADY_IN_CONFERENCE:
					case CN_RC_CANT_INVITE_MCU:
					case CN_RC_CANT_JOIN_ALREADY_IN_CALL:
					case CN_RC_INVITE_DENIED_REMOTE_IN_CONF:
					case CN_RC_REMOTE_PLACING_CALL:
					case CN_RC_ALREADY_IN_CONFERENCE_MCU:
					case CN_RC_INVALID_PASSWORD:
					default:
						*pState = NM_CALL_CANCELED;
						break;
					}
					break;

				default:
					*pState = NM_CALL_INVALID;
					break;
			}
		}

		hr = S_OK;
	}
	return hr;
}

HRESULT COutgoingCall::GetName(BSTR * pbstrName)
{
	if (NULL == pbstrName)
		return E_POINTER;

	*pbstrName = SysAllocString(m_bstrName);
	return (*pbstrName ? S_OK : E_FAIL);
}


HRESULT COutgoingCall::GetAddr(BSTR *pbstrAddr, NM_ADDR_TYPE *puType)
{
	if ((NULL == pbstrAddr) || (NULL == puType))
		return E_POINTER;

	*pbstrAddr = SysAllocString(CUSTRING(m_pszAddr));
	*puType = m_addrType;

	return *pbstrAddr ? S_OK : E_FAIL;
}

HRESULT COutgoingCall::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	return E_NOTIMPL;
}

HRESULT COutgoingCall::GetConference(INmConference **ppConference)
{
	HRESULT hr = E_POINTER;

	if (NULL != ppConference)
	{
		*ppConference = m_pConfObject;
		return S_OK;
	}

	return hr;
}

HRESULT COutgoingCall::Accept(void)
{
	return E_UNEXPECTED;
}

HRESULT COutgoingCall::Reject(void)
{
	return E_UNEXPECTED;
}

HRESULT COutgoingCall::Cancel(void)
{
	DebugEntry(COutgoingCall::Cancel);

	AddRef();		// protect against Release() while processing
					// disconnect related indications & callbacks

	HRESULT hr = _Cancel(FALSE);
	
	if (FIsComplete())
	{
		COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
		ASSERT(NULL !=pOprahNCUI);
		pOprahNCUI->OnOutgoingCallCanceled(this);
	}

	DebugExitULONG(COutgoingCall::Abort, m_cnResult);

	Release();

	return hr;
}

/*	O N  N O T I F Y  C A L L  E R R O R  */
/*-------------------------------------------------------------------------
	%%Function: OnNotifyCallError
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyCallError(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pCallNotify);
	CNSTATUS cnStatus = (CNSTATUS)((DWORD_PTR)pv);
	switch (cnStatus)
	{
		case CN_RC_ALREADY_IN_CONFERENCE:
		case CN_RC_CANT_INVITE_MCU:
		case CN_RC_CANT_JOIN_ALREADY_IN_CALL:
		case CN_RC_INVITE_DENIED_REMOTE_IN_CONF:
		case CN_RC_REMOTE_PLACING_CALL:
		case CN_RC_ALREADY_IN_CONFERENCE_MCU:
			((INmCallNotify*)pCallNotify)->NmUI(CONFN_CALL_IN_CONFERENCE);
			break;
		case CN_RC_CONFERENCE_JOIN_DENIED:
		case CN_RC_CONFERENCE_INVITE_DENIED:
		case CN_RC_CONFERENCE_DOES_NOT_EXIST:
		case CN_RC_GK_CALLEE_NOT_REGISTERED:
		case CN_RC_GK_TIMEOUT:
		case CN_RC_GK_REJECTED:
		case CN_RC_GK_NOT_REGISTERED:
		case CN_RC_CONNECT_REMOTE_NO_SECURITY:
		case CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY:
		case CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY:
			((INmCallNotify*)pCallNotify)->NmUI(CONFN_CALL_IGNORED);
			break;
		case CN_RC_CONNECT_FAILED:
		case CN_RC_AUDIO_CONNECT_FAILED:
			((INmCallNotify*)pCallNotify)->NmUI(CONFN_CALL_FAILED);
			break;
		default:
			break;
	}

	if (IID_INmCallNotify2 == riid)
	{
		((INmCallNotify2*)pCallNotify)->CallError(cnStatus);
	}
	return S_OK;
}

/*	O N  N O T I F Y  R E M O T E  C O N F E R E N C E	*/
/*-------------------------------------------------------------------------
	%%Function: OnNotifyRemoteConference
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyRemoteConference(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	REMOTE_CONFERENCE *prc = (REMOTE_CONFERENCE *)pv;

	// WARNING: pwszConfName is an PWSTR array, not a BSTR

	ASSERT(NULL != pCallNotify);
	((INmCallNotify2*)pCallNotify)->RemoteConference(prc->fMCU,
		(BSTR *) prc->pwszConfNames, prc->pbstrConfToJoin);
	return S_OK;
}

/*	O N  N O T I F Y  R E M O T E  P A S S W O R D	*/
/*-------------------------------------------------------------------------
	%%Function: OnNotifyRemotePassword
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyRemotePassword(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	REMOTE_PASSWORD *prp = (REMOTE_PASSWORD *)pv;

	ASSERT(NULL != pCallNotify);
	((INmCallNotify2*)pCallNotify)->RemotePassword(prp->bstrConference, prp->pbstrPassword, prp->pbRemoteCred, prp->cbRemoteCred, prp->fIsService);
	return S_OK;
}

COutgoingCallManager::COutgoingCallManager()
{
}

COutgoingCallManager::~COutgoingCallManager()
{
	// Empty the call list:
	while (!m_CallList.IsEmpty())
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.RemoveHead();
		// Shouldn't have any NULL entries:
		ASSERT(pCall);
		pCall->Release();
	}
}

UINT COutgoingCallManager::GetCallCount()
{
	UINT nNodes = 0;
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		nNodes++;
		m_CallList.GetNext(pos);
	}
	return nNodes;
}

COutgoingCall* COutgoingCallManager::FindCall(IH323Endpoint * lpConnection)
{
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			(pCall->GetH323Connection() == lpConnection))
		{
			return pCall;
		}
	}
	return NULL;
}

BOOL COutgoingCallManager::MatchActiveCallee(LPCTSTR pszDest, BSTR bstrAlias, BSTR bstrConference)
{
	// Try to find a matching callee
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			if (pCall->MatchActiveCallee(pszDest, bstrAlias, bstrConference))
			{
				return TRUE;
			}
		}
	}
	return FALSE;
}

HRESULT COutgoingCallManager::Call(
    INmCall **ppCall,
	COprahNCUI* pManager,
    DWORD dwFlags,
    NM_ADDR_TYPE addrType,
    BSTR bstrName,
    BSTR bstrSetup,
    BSTR bstrDest,
    BSTR bstrAlias,
    BSTR bstrURL,
    BSTR bstrConference,
    BSTR bstrPassword,
	BSTR bstrUserString)
{
	DebugEntry(COutgoingCallManager::CallConference);
	HRESULT hr = E_FAIL;
	COutgoingCall* pCall = NULL;
	CConfObject* pConfObject = pManager->GetConfObject();
	
	if (NULL != ppCall)
	{
		*ppCall = NULL;
	}

	if (MatchActiveCallee(CUSTRING(bstrDest), bstrAlias, bstrConference))
	{
		hr = NM_CALLERR_ALREADY_CALLING;
	}
	else if (pConfObject->IsConferenceActive() && (NULL != bstrConference))
	{
		hr= NM_CALLERR_IN_CONFERENCE;	
	}
	else
	{
		if (!pConfObject->IsConferenceActive())
		{
			pConfObject->SetConfSecurity(0 != (CRPCF_SECURE & dwFlags));
		}

        //
        // Check outgoing call settings
        //
        if (pConfObject->GetNumMembers() >= pConfObject->GetConfMaxParticipants())
        {
            ASSERT(pConfObject->GetNumMembers() == pConfObject->GetConfMaxParticipants());
            WARNING_OUT(("Outgoing call denied, reached limit of participants"));
            goto END_CALL;
        }

        if ((pConfObject->IsHosting() != S_OK) &&
            !(pConfObject->GetConfAttendeePermissions() & NM_PERMIT_OUTGOINGCALLS))
        {
            WARNING_OUT(("Outgoing call denied, not permitted by meeting settings"));
            goto END_CALL;
        }

		pCall = new COutgoingCall(	pConfObject,
									dwFlags,
									addrType,
									bstrName,
									bstrDest,
									bstrAlias,
									bstrConference,
									bstrPassword,
									bstrUserString);
		if (NULL != pCall)
		{
			m_CallList.AddTail(pCall);

			if (NULL != ppCall)
			{
				pCall->AddRef();

				// This MUST be set before OnNotifyCallCreated
				*ppCall = pCall;
			}

			pCall->AddRef();

			pManager->OnOutgoingCallCreated(pCall);

			pCall->PlaceCall();

			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}

			pCall->Release();

			// let the caller know that we successfully created the call
			// any error will be reported asynchronously
			hr = S_OK;
		}
	}

END_CALL:
	DebugExitHRESULT(COutgoingCallManager::CallConference, hr);
	return hr;
}

BOOL COutgoingCallManager::RemoveFromList(COutgoingCall* pCall)
{
	DebugEntry(COutgoingCallManager::RemoveFromList);
	ASSERT(pCall);
	BOOL bRet = FALSE;

	POSITION pos = m_CallList.GetPosition(pCall);
	if (NULL != pos)
	{
		m_CallList.RemoveAt(pos);

		pCall->CallComplete();
		pCall->Release();

		bRet = TRUE;
	}
	else
	{
		WARNING_OUT(("COutgoingCallManager::RemoveFromList() could not match call"));
	}

	DebugExitBOOL(COutgoingCallManager::RemoveFromList, bRet);
	return bRet;
}

BOOL COutgoingCallManager::OnH323Connected(IH323Endpoint* lpConnection)
{
	DebugEntry(COutgoingCallManager::OnH323Connected);

	BOOL fFound = FALSE;

	COutgoingCall* pCall = FindCall(lpConnection);
	if (pCall)
	{
		fFound = TRUE;

		pCall->AddRef();
		pCall->OnH323Connected(lpConnection);
		if (pCall->FIsComplete())
		{
			RemoveFromList(pCall);
		}
		pCall->Release();
	}
	
	DebugExitBOOL(COutgoingCallManager::OnH323Connected, fFound);

	return fFound;
}


BOOL COutgoingCallManager::OnH323Disconnected(IH323Endpoint * lpConnection)
{
	DebugEntry(COutgoingCallManager::OnH323Disconnected);

	BOOL fFound = FALSE;

	COutgoingCall* pCall = FindCall(lpConnection);
	if (pCall)
	{
		fFound = TRUE;

		pCall->AddRef();
		pCall->OnH323Disconnected(lpConnection);
		if (pCall->FIsComplete())
		{
			RemoveFromList(pCall);
		}
		pCall->Release();
	}

	DebugExitBOOL(COutgoingCallManager::OnH323Disconnected, fFound);

	return fFound;
}

VOID COutgoingCallManager::OnT120ChannelOpen(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus)
{
	DebugEntry(COutgoingCallManager::OnT120ChannelOpen);

	COutgoingCall* pCall = FindCall(lpConnection);
	if (pCall)
	{
		pCall->AddRef();
		pCall->OnT120ChannelOpen(pIChannel, dwStatus);
		if (pCall->FIsComplete())
		{
			RemoveFromList(pCall);
		}
		pCall->Release();
	}

	DebugExitVOID(COutgoingCallManager::OnT120ChannelOpen);
}

VOID COutgoingCallManager::OnConferenceStarted(CONF_HANDLE hConference, HRESULT hResult)
{
	DebugEntry(COutgoingCallManager::OnConferenceStarted);

	// Tell all ConfNode's that a conference has started
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			pCall->AddRef();
			pCall->OnConferenceStarted(hConference, hResult);
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
		}
	}

	DebugExitVOID(COutgoingCallManager::OnConferenceStarted);
}

VOID COutgoingCallManager::OnQueryRemoteResult(PVOID pvCallerContext,
										HRESULT hResult,
										BOOL fMCU,
										PWSTR* ppwszConferenceNames,
										PT120PRODUCTVERSION pVersion,
										PWSTR* ppwszConfDescriptors)
{
	DebugEntry(COutgoingCallManager::OnQueryRemoteResult);

	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		// Notify the node that issued the query:
		
		if ((COutgoingCall*) pvCallerContext == pCall)
		{
			pCall->AddRef();
			pCall->OnQueryRemoteResult(	hResult,
										fMCU,
										ppwszConferenceNames,
										pVersion,
										ppwszConfDescriptors);
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
			break;
		}
	}
	
	DebugExitVOID(COutgoingCallManager::OnQueryRemoteResult);
}

VOID COutgoingCallManager::OnInviteResult(	CONF_HANDLE hConference,
											REQUEST_HANDLE hRequest,
											UINT uNodeID,
											HRESULT hResult,
											PT120PRODUCTVERSION pVersion)
{
	DebugEntry(COutgoingCallManager::OnInviteResult);

	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			(pCall->GetCurrentRequestHandle() == hRequest))
		{
			pCall->AddRef();
			pCall->OnInviteResult(hResult, uNodeID);
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
			break;
		}
	}

	DebugExitVOID(COutgoingCallManager::OnInviteResult);
}

VOID COutgoingCallManager::OnConferenceEnded(CONF_HANDLE hConference)
{
	DebugEntry(COutgoingCallManager::OnConferenceEnded);

	// Tell all ConfNode's that a conference has started
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			pCall->AddRef();
			pCall->OnConferenceEnded();
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
		}
	}

	DebugExitVOID(COutgoingCallManager::OnConferenceEnded);
}

VOID COutgoingCallManager::CancelCalls()
{
	DebugEntry(COutgoingCallManager::CancelCalls);

	// Tell all ConfNode's that a conference has started
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			pCall->AddRef();
			pCall->_Cancel(TRUE);
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
		}
	}

	DebugExitVOID(COutgoingCallManager::CancelCalls);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\icall_in.cpp ===
// File: icallin.cpp

#include "precomp.h"

#include <regentry.h>

#include "cncodes.h"		// needed for CN_
#include "icall_in.h"
#include "imanager.h"
#include "util.h"

extern HRESULT OnNotifyCallError(IUnknown *pCallNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyCallAccepted(IUnknown *pCallNotify, PVOID pv, REFIID riid);

// Internal code to indicate that there was no security data available in an incoming call.
const int CALL_NO_SECURITY_DATA = -1;


static const IID * g_apiidCP_Call[] =
{
    {&IID_INmCallNotify},
	{&IID_INmCallNotify2}
};

CIncomingCall::CIncomingCall(
	COprahNCUI	  * pOprahNCUI,
	BOOL			fInvite,
	CONF_HANDLE		hConf,
	PCWSTR			pcwszNodeName,
	PUSERDATAINFO	pUserDataInfoEntries,
	UINT			cUserDataEntries) :
	CConnectionPointContainer(g_apiidCP_Call, ARRAY_ELEMENTS(g_apiidCP_Call)),
	m_pOprahNCUI(pOprahNCUI),
	m_pConnection(NULL),
	m_fInvite(fInvite),
	m_hConf(hConf),
	m_bstrCaller(SysAllocString(pcwszNodeName)),
	m_State(NM_CALL_INIT),
	m_dwFlags(0)
	{
	DebugEntry(CIncomingCall::CIncomingCall[T120]);

	ProcessT120UserData(pUserDataInfoEntries, cUserDataEntries);


	DebugExitVOID(CIncomingCall::CIncomingCall);
}

CIncomingCall::CIncomingCall(COprahNCUI *pOprahNCUI, 
	IH323Endpoint* pConnection, P_APP_CALL_SETUP_DATA lpvMNMData,
	DWORD dwFlags) :
	CConnectionPointContainer(g_apiidCP_Call, ARRAY_ELEMENTS(g_apiidCP_Call)),
	m_pOprahNCUI(pOprahNCUI),
	m_pConnection(pConnection),
	m_fInvite(FALSE),
	m_hConf(NULL),
	m_bstrCaller(NULL),
	m_State(NM_CALL_INIT),
	m_guidNode(GUID_NULL),
	m_dwFlags(dwFlags),
	m_fMemberAdded(FALSE)
{
	DebugEntry(CIncomingCall::CIncomingCall[H323]);
	HRESULT hr;
	ASSERT(m_pConnection);

	m_pConnection->AddRef();

	WCHAR wszCaller[MAX_CALLER_NAME];
	if (SUCCEEDED(m_pConnection->GetRemoteUserName(wszCaller, MAX_CALLER_NAME)))
	{
		m_bstrCaller = SysAllocString(wszCaller);
	}

	if ((NULL != lpvMNMData) && (lpvMNMData->dwDataSize > sizeof(DWORD)))
	{
		BYTE *pbData = ((BYTE*)lpvMNMData->lpData) + sizeof(DWORD);
		DWORD cbRemaining = lpvMNMData->dwDataSize - sizeof(DWORD);

		while ((sizeof(GUID) + sizeof(DWORD)) < cbRemaining)
		{
			DWORD cbData = *(DWORD*)(pbData + sizeof(GUID));
			DWORD cbRecord = cbData + sizeof(GUID) + sizeof(DWORD);

			if (cbRemaining < cbRecord)
			{
				break;
			}

			if (*(GUID *)pbData == g_csguidNodeIdTag)
			{
				m_guidNode = *(GUID *)(pbData + sizeof(GUID) + sizeof(DWORD));
			}

			m_UserData.AddUserData((GUID *)pbData,
					(unsigned short)cbData,
					pbData + sizeof(GUID) + sizeof(DWORD));
			cbRemaining -= cbRecord;
			pbData += cbRecord;
		}
	}

	DebugExitVOID(CIncomingCall::CIncomingCall);
}

CIncomingCall::~CIncomingCall()
{
	DebugEntry(CIncomingCall::~CIncomingCall);

	if(m_pConnection)
	{
		m_pConnection->Release();
		m_pConnection = NULL;
	}

	SysFreeString(m_bstrCaller);

	DebugExitVOID(CIncomingCall::CIncomingCall);
}

VOID CIncomingCall::ProcessT120UserData(
	PUSERDATAINFO	pUserDataInfoEntries,
	UINT			cUserDataEntries)
{
	if (cUserDataEntries > 0)
	{
		ASSERT(pUserDataInfoEntries);
		for (UINT u = 0; u < cUserDataEntries; u++)
		{
			m_UserData.AddUserData(pUserDataInfoEntries[u].pGUID,
					(unsigned short)pUserDataInfoEntries[u].cbData,
					pUserDataInfoEntries[u].pData);

		}
	}
}

BOOL CIncomingCall::MatchAcceptedCaller(PCWSTR pcwszNodeName)
{
	// check to see if this caller matches someone whom we already accepted 
	if ((NULL != m_pConnection) &&
		(NM_CALL_ACCEPTED == m_State) &&
		(GUID_NULL == m_guidNode) &&
		(NULL != m_bstrCaller) &&
		(0 == UnicodeCompare(m_bstrCaller, pcwszNodeName)) )
	{
		return TRUE;
	}

	return FALSE;
}

BOOL CIncomingCall::MatchAcceptedCaller(GUID* pguidNodeId)
{
	// check to see if this caller matches someone whom we already accepted 
	if ((NULL != m_pConnection) &&
		((NM_CALL_INIT == m_State) ||
		(NM_CALL_ACCEPTED == m_State)) &&
		(GUID_NULL != m_guidNode) &&
		(*pguidNodeId == m_guidNode))
	{
		return TRUE;
	}

	return FALSE;
}

BOOL CIncomingCall::MatchActiveCaller(GUID* pguidNodeId)
{
	// check to see if this caller matches someone whom we already accepted
	// or is in the process of calling us
	if ((NULL != m_pConnection) &&
		((NM_CALL_INIT == m_State) ||
		(NM_CALL_RING == m_State) ||
		(NM_CALL_ACCEPTED == m_State)) &&
		(GUID_NULL != m_guidNode) &&
		(*pguidNodeId == m_guidNode))
	{
		return TRUE;
	}

	return FALSE;
}

void CIncomingCall::Ring()
{
	m_State = NM_CALL_RING;
	NotifySink((PVOID) m_State, OnNotifyCallStateChanged);
}

HRESULT CIncomingCall::OnH323Connected()
{
	CConfObject *pco = ::GetConfObject();
	if (NULL != pco)
	{
		BOOL fAddMember = DidUserAccept();
	
		pco->OnH323Connected(m_pConnection, m_dwFlags, fAddMember, m_guidNode);

		m_fMemberAdded = fAddMember;
	}

	return S_OK;
}

HRESULT CIncomingCall::OnH323Disconnected()
{
	if (NM_CALL_RING == m_State)
	{
		if (m_hConf)
		{
			CONF_HANDLE hConf = m_hConf;
			m_hConf = NULL;
			// if there is an invite or join pending, kill it
			if ( m_fInvite )
				hConf->InviteResponse(FALSE);
			else
				hConf->JoinResponse(FALSE);
		}
	}

	if(m_pConnection)
	{
		m_pConnection->Release();
		m_pConnection = NULL;
	}

	if ((NM_CALL_RING == m_State) ||
		(NM_CALL_INIT == m_State))
	{
		m_State = NM_CALL_CANCELED;
		NotifySink((PVOID) m_State, OnNotifyCallStateChanged);
	}

	return m_hConf ? S_FALSE : S_OK;
}

VOID CIncomingCall::OnIncomingT120Call(
			BOOL fInvite,
			PUSERDATAINFO pUserDataInfoEntries,
			UINT cUserDataEntries)
{
	m_fInvite = fInvite;

	ProcessT120UserData(pUserDataInfoEntries, cUserDataEntries);
}

HRESULT CIncomingCall::OnT120ConferenceEnded()
{
	m_hConf = NULL;

	if(!m_fMemberAdded && m_pConnection)
	{
		// we didn't hand off this connection to the member
		IH323Endpoint* pConnection = m_pConnection;
		m_pConnection = NULL;
		pConnection->Disconnect();
		pConnection->Release();
	}

	if (NM_CALL_RING == m_State)
	{
		m_State = NM_CALL_CANCELED;
		NotifySink((PVOID) m_State, OnNotifyCallStateChanged);
	}

	return m_pConnection ? S_FALSE : S_OK;
}

HRESULT CIncomingCall::Terminate(BOOL fReject)
{
	HRESULT hr = E_FAIL;

	// need to make sure that we are still ringing
	if ((NM_CALL_ACCEPTED != m_State) &&
		(NM_CALL_REJECTED != m_State) &&
		(NM_CALL_CANCELED != m_State))
	{
		m_State = fReject ? NM_CALL_REJECTED : NM_CALL_CANCELED;

		TRACE_OUT(("CIncomingCall: Call not accepted - responding"));

		if (NULL != m_hConf)
		{
			CONF_HANDLE hConf = m_hConf;
			m_hConf = NULL;
			if (m_fInvite)
			{
				hConf->InviteResponse(FALSE);
			}
			else
			{
				CConfObject *pco = ::GetConfObject();
				if ((NULL != pco) && (pco->GetConfHandle() == hConf))
				{
					hConf->JoinResponse(FALSE);
				}
			}
		}

		if (NULL != m_pConnection)
		{
			ConnectStateType state;	
			hr = m_pConnection->GetState(&state);
			ASSERT(SUCCEEDED(hr));
			if(CLS_Alerting == state)
			{
				IH323Endpoint* pConn = m_pConnection;
				m_pConnection = NULL;
				pConn->AcceptRejectConnection(CRR_REJECT);
				pConn->Release();
				m_pOprahNCUI->ReleaseAV(pConn);
			}
		}

		NotifySink((PVOID) m_State, OnNotifyCallStateChanged);

		hr = S_OK;
	}

    return hr;
}


STDMETHODIMP_(ULONG) CIncomingCall::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CIncomingCall::Release(void)
{
	return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE CIncomingCall::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmCall) || (riid == IID_IUnknown))
	{
		*ppv = (INmCall *)this;
		ApiDebugMsg(("CIncomingCall::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		ApiDebugMsg(("CIncomingCall::QueryInterface(): Returning IConnectionPointContainer."));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CIncomingCall::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

HRESULT CIncomingCall::IsIncoming(void)
{
	return S_OK;
}

HRESULT CIncomingCall::GetState(NM_CALL_STATE *pState)
{
	HRESULT hr = E_POINTER;

	if (NULL != pState)
	{
		*pState = m_State;
		hr = S_OK;
	}
	return hr;
}

HRESULT CIncomingCall::GetName(BSTR * pbstrName)
{
	if (NULL == pbstrName)
		return E_POINTER;

	*pbstrName = SysAllocString(m_bstrCaller);
	return (*pbstrName ? S_OK : E_FAIL);
}

HRESULT CIncomingCall::GetAddr(BSTR * pbstrAddr, NM_ADDR_TYPE *puType)
{
	// for now we just do the same thing as NM2.11
	if ((NULL == pbstrAddr) || (NULL == puType))
		return E_POINTER;

	*puType = NM_ADDR_UNKNOWN;
	*pbstrAddr = SysAllocString(L"");
	return (*pbstrAddr ? S_OK : E_FAIL);
}

HRESULT CIncomingCall::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	return m_UserData.GetUserData(rguid,ppb,pcb);
}

HRESULT CIncomingCall::GetConference(INmConference **ppConference)
{
#ifdef NOTYET
	*ppConference = NULL;

	CConfObject *pco = ::GetConfObject();
	if (NULL != pco)
	{
		if (pco->GetConfHandle() == m_hConf)
		{
			*ppConference = pco;
			return S_OK;
		}
		return E_UNEXPECTED;
	}
#endif
	return S_FALSE;

}

HRESULT CIncomingCall::Accept(void)
{
	HRESULT hr = E_FAIL;

	// need to make sure that we are still ringing
	if (NM_CALL_RING == m_State)
	{
		m_pOprahNCUI->OnIncomingCallAccepted();

		CConfObject *pco = ::GetConfObject();
		ASSERT(pco);

		if ((NULL != m_hConf) && ( NULL != pco ) && (pco->GetConfHandle() == m_hConf))
		{
			if (m_fInvite)
			{
				hr = m_hConf->InviteResponse(TRUE);
			}
			else
			if (pco->GetConfHandle() == m_hConf)
			{
				hr = m_hConf->JoinResponse(TRUE);
			}
		}
		else if (NULL != m_pConnection)
		{
			ConnectStateType state;	
			HRESULT hrTemp = m_pConnection->GetState(&state);
			ASSERT(SUCCEEDED(hrTemp));
			if(CLS_Alerting == state)
			{
				hr = m_pConnection->AcceptRejectConnection(CRR_ACCEPT);
			}
		}

		if (S_OK == hr)
		{
			// notify all call observers that the call was accepted
			m_State = NM_CALL_ACCEPTED;
			NotifySink((INmConference *) pco, OnNotifyCallAccepted);
		}
		else
		{
			// call went away before it was accepted
			m_State = NM_CALL_CANCELED;
			NotifySink((PVOID)CN_RC_CONFERENCE_ENDED_BEFORE_ACCEPTED, OnNotifyCallError);
			if(m_pOprahNCUI)
			{
				m_pOprahNCUI->OnH323Disconnected(m_pConnection);
			}
		}

		// notify all call observers of the state change
		NotifySink((PVOID) m_State, OnNotifyCallStateChanged);
	}
	else
	{
		hr = ((NM_CALL_ACCEPTED == m_State) ? S_OK : E_FAIL);
	}

	return hr;
}

HRESULT CIncomingCall::Reject(void)
{
	return Terminate(TRUE);
}

HRESULT CIncomingCall::Cancel(void)
{
	return Terminate(FALSE);
}

/*  O N  N O T I F Y  C A L L  A C C E P T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyCallAccepted
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyCallAccepted(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pCallNotify);
	((INmCallNotify*)pCallNotify)->Accepted((INmConference *) pv);
	return S_OK;
}



CIncomingCallManager::CIncomingCallManager()
{
}

CIncomingCallManager::~CIncomingCallManager()
{
	// Empty the call list:
	while (!m_CallList.IsEmpty())
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.RemoveHead();
		// Shouldn't have any NULL entries:
		ASSERT(pCall);
		pCall->Release();
	}
}

CREQ_RESPONSETYPE CIncomingCallManager::OnIncomingH323Call(
	    COprahNCUI *pManager,
		IH323Endpoint* pConnection,
		P_APP_CALL_SETUP_DATA lpvMNMData)
{
	CREQ_RESPONSETYPE resp;

///////////////////////////////////////////////////
//	first we determine the capabilities the caller	
///////////////////////////////////////////////////	
	
	BOOL fRequestAutoAccept = FALSE;
	// don't assume anything about security
	BOOL fT120SecureCall = FALSE;
	BOOL fT120NonSecureCall = FALSE;
	// assume that the caller can do an invite or a join
	BOOL fT120Invite = TRUE;
	BOOL fT120Join = TRUE;
	// assume that the caller wants a/v
	BOOL fRequestAV = TRUE;
	// assume that the caller is not NM2.X
	BOOL fCallerNM2x = FALSE;

	PCC_VENDORINFO pLocalVendorInfo;
	PCC_VENDORINFO pRemoteVendorInfo;
	if (S_OK == pConnection->GetVersionInfo(&pLocalVendorInfo, &pRemoteVendorInfo))
	{
		H323VERSION version = GetH323Version(pRemoteVendorInfo);

		switch (version)
		{
			case H323_NetMeeting20:
			case H323_NetMeeting21:
			case H323_NetMeeting211:
				fCallerNM2x = TRUE;
				break;
			default:
				break;
		}
	}

	if ((NULL != lpvMNMData) &&
		(lpvMNMData->dwDataSize >= sizeof(DWORD)))
	{
		DWORD dwUserData = *((LPDWORD)lpvMNMData->lpData);
		if (fCallerNM2x)
		{
			fRequestAutoAccept = (H323UDF_ALREADY_IN_T120_CALL == dwUserData);
			fT120SecureCall = FALSE;
			fT120NonSecureCall = TRUE;
			fT120Invite = TRUE;
			fT120Join = TRUE;
			fRequestAV = TRUE;
		}
		else if (0 != dwUserData)
		{
			fT120SecureCall = (H323UDF_SECURE & dwUserData);
			fT120NonSecureCall = !fT120SecureCall;
			fT120Invite = (H323UDF_INVITE & dwUserData);
			fT120Join = (H323UDF_JOIN & dwUserData);
			fRequestAV = ((H323UDF_AUDIO | H323UDF_VIDEO) & dwUserData);
		}
	}

////////////////////////////////////////////////
// next we determine the state of us the callee
////////////////////////////////////////////////
	
	DWORD dwFlags = CRPCF_DATA;
	BOOL fAcceptSecure  = TRUE;
    BOOL fAcceptNonSecure = TRUE;

	CConfObject *pco = ::GetConfObject();
	if(	NULL ==	pco	)
	{
		ERROR_OUT((	"CConfObject not found"	));
		resp = CRR_REJECT;
		goto REJECT_CALL;
	}

	BOOL fInActiveConference = pco->IsConferenceActive();
	
	if (fInActiveConference)
	{
        //
        // If we've reached our limit of attendees, reject it.  Also reject
        // it if incoming calls are prevented by settings.
        //
        if (pco->GetNumMembers() >= pco->GetConfMaxParticipants())
        {
            ASSERT(pco->GetNumMembers() == pco->GetConfMaxParticipants());

            WARNING_OUT(("Rejecting incoming H.323 call, reached limit setting of %d",
                pco->GetConfMaxParticipants()));
            resp = CRR_REJECT;
            goto REJECT_CALL;
        }

        if ((pco->IsHosting() != S_OK) &&
            !(pco->GetConfAttendeePermissions() & NM_PERMIT_INCOMINGCALLS))
        {
            WARNING_OUT(("Rejecting incoming H.323 call, not permitted by meeting setting"));
            resp = CRR_REJECT;
            goto REJECT_CALL;
        }

        //
        // We're in a conference, the security settings are whatever those
        // of the conference are.  The user prefs are just for establishing
        // the first call.
        //
		if (pco->IsConfObjSecure())
		{
			fAcceptNonSecure = FALSE;
		}
		else
		{
            fAcceptSecure = FALSE;
		}
	}
    else
    {
		// we are not in a conference so use the prefered settings

        RegEntry reConf(POLICIES_KEY, HKEY_CURRENT_USER);
        switch (reConf.GetNumber(REGVAL_POL_SECURITY, DEFAULT_POL_SECURITY))
        {
            case DISABLED_POL_SECURITY:
                fAcceptSecure = FALSE;
                break;

            case REQUIRED_POL_SECURITY:
                fAcceptNonSecure = FALSE;
                break;

            default:
            {
                RegEntry rePref(CONFERENCING_KEY, HKEY_CURRENT_USER);

                // Is incoming required to be secure by preference?
		    	if (rePref.GetNumber(REGVAL_SECURITY_INCOMING_REQUIRED,
								 DEFAULT_SECURITY_INCOMING_REQUIRED))
			    {
				    fAcceptNonSecure = FALSE;
    			}
                break;
            }
        }
    }


//////////////////////////////////////////
// now we weed out non acceptable callers	
//////////////////////////////////////////	
	
	if (fCallerNM2x && !fAcceptNonSecure)
	{
		// NetMeeting 2.X cannot speak security
		return CRR_REJECT;
	}

	if (fT120SecureCall || !fAcceptNonSecure)
	{
        //
        // If we insist on security, or the call is secure and we can 
        // handle it, the result is secure.
        //
		dwFlags |= CRPCF_SECURE;
	}
	else if (fRequestAV && pManager->AcquireAV(pConnection))
	{
		dwFlags |= CRPCF_VIDEO | CRPCF_AUDIO;
	}

	if (fCallerNM2x && (0 == ((CRPCF_VIDEO | CRPCF_AUDIO) & dwFlags)))
	{
		// a/v is not available
		// if leading with H323, caller will try again with T120
		// else their done
		resp = CRR_BUSY;
	}
	else if (fRequestAutoAccept)
	{
		// Auto accept this call if it came from NetMeeting 2.X and the caller is telling
		// us that we are already in a T.120 call with them.  This allows audio after data
		// calls to be accepted and also means that you aren't prompted when someone
		// switches a/v using the UI's "Send audio and video to..."

		if (fInActiveConference)
		{
			// we most likely have a matching call already but may not be able to find it
			CIncomingCall *pCall = new CIncomingCall(pManager, pConnection, lpvMNMData, dwFlags);
			// This transfers the implicit reference of pConnection to the
			// new CIncomingCall.  It will Release().
			if (NULL != pCall)
			{
				// add call to the list of incoming calls
				m_CallList.AddTail(pCall);

				resp = CRR_ACCEPT;
			}
			else
			{
				resp = CRR_REJECT;
			}
		}
		else
		{
			// we're not really in a T120 call like the caller said. reject this call!
			resp = CRR_REJECT;
		}
	}
	else if (!fT120Join && fInActiveConference)
	{
		// need to change this to CRR_IN_CONFERENCE
		resp = CRR_BUSY;
		TRACE_OUT(("Can only accept joins; in a conference"));
	}
	else if (fT120Join && !fT120Invite && !fInActiveConference)
	{
		resp = CRR_REJECT;
		TRACE_OUT(("Cannot accept H323 Join Request; not in a conference"));
	}
	else if (!fRequestAV && !fT120Join && !fT120Invite && !fInActiveConference)
	{
		resp = CRR_REJECT;
		TRACE_OUT(("No av/ or data; reject"));
	}
	else if (fT120SecureCall && !fAcceptSecure)
	{
		resp = CRR_SECURITY_DENIED;
		TRACE_OUT(("Can not accept secure H323 Call"));
	}
	else if (fT120NonSecureCall && !fAcceptNonSecure)
	{
		resp = CRR_SECURITY_DENIED;
		TRACE_OUT(("Can not accept non secure H323 Call"));
	}
	else
	{
		CIncomingCall *pCall = new CIncomingCall(pManager, pConnection, lpvMNMData, dwFlags);
		// This transfers the implicit reference of pConnection to the
		// new CIncomingCall.  It will Release().
		if (NULL != pCall)
		{
			if (g_guidLocalNodeId != *pCall->GetNodeGuid())
			{
				// Check for multiple calls from the same caller
				if (!MatchActiveCaller(pCall->GetNodeGuid()))
				{
					// add call to the list of incoming calls
					m_CallList.AddTail(pCall);

					pManager->OnIncomingCallCreated(pCall);

					// Don't ring on data only calls.
					// Wait for T120 call to come in.
					if (pCall->IsDataOnly())
					{
						resp = CRR_ACCEPT;
      				}
					else
					{	
						pCall->Ring();

						resp = CRR_ASYNC;
					}
				}
				else
				{
					// we're already in call with this person
					delete pCall;

					resp = CRR_REJECT;
				}
			}
			else
			{
				// we somehow called ourself
				delete pCall;

				resp = CRR_REJECT;
			}
		}
		else
		{
			resp = CRR_REJECT;
		}
	}

REJECT_CALL:
	if ((resp != CRR_ACCEPT) && (resp != CRR_ASYNC))
	{
		// make sure we are not holding on to AV
		pManager->ReleaseAV(pConnection);
	}

	return resp;
}

VOID CIncomingCallManager::OnH323Connected(IH323Endpoint* lpConnection)
{
	POSITION pos = m_CallList.GetHeadPosition();
	POSITION posItem;
	while (posItem = pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			(lpConnection == pCall->GetH323Connection()))
		{
			pCall->OnH323Connected();
			break;
		}
	}
}

VOID CIncomingCallManager::OnH323Disconnected(IH323Endpoint * lpConnection)
{
	POSITION pos = m_CallList.GetHeadPosition();
	POSITION posItem;
	while (posItem = pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			(lpConnection == pCall->GetH323Connection()))
		{
			if (S_OK == pCall->OnH323Disconnected())
			{
				m_CallList.RemoveAt(posItem);
				pCall->Release();
			}
			break;
		}
	}
}

VOID CIncomingCallManager::OnT120ConferenceEnded(CONF_HANDLE hConference)
{
	POSITION pos = m_CallList.GetHeadPosition();
	POSITION posItem;
	while (posItem = pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			(hConference == pCall->GetConfHandle()))
		{
			if (S_OK == pCall->OnT120ConferenceEnded())
			{
				m_CallList.RemoveAt(posItem);
				pCall->Release();
			}
		}
	}
}

HRESULT CIncomingCallManager::OnIncomingT120Call(
		COprahNCUI *pManager,
		BOOL fInvite,
		CONF_HANDLE hConf,
		PCWSTR pcwszNodeName,
		PUSERDATAINFO pUserDataInfoEntries,
		UINT cUserDataEntries,
		BOOL fSecure)
{
	HRESULT hr = S_OK;

	// need to scan through all accepted calls passing the T120 params
	// if someone returns S_OK, we accept the call

	CIncomingCall *pMatchedCall = NULL;

	GUID* pguidNodeID = GetGuidFromT120UserData(pUserDataInfoEntries, cUserDataEntries);
	if (pguidNodeID)
	{
		pMatchedCall = MatchAcceptedCaller(pguidNodeID);
	}
	else
	{
		pMatchedCall = MatchAcceptedCaller(pcwszNodeName);
	}

	if (pMatchedCall)
	{
		pMatchedCall->SetConfHandle(hConf);

		// we should always ring the client when the call is secure
		// or when we haven't rang already
		if (!pMatchedCall->DidUserAccept())
		{
			pMatchedCall->OnIncomingT120Call(fInvite,
											 pUserDataInfoEntries,
											 cUserDataEntries);

			pMatchedCall->Ring();
		}
		else
		{
			if (fInvite)
			{
				hr = hConf->InviteResponse(TRUE);
			}
			else
			{
				hr = hConf->JoinResponse(TRUE);
			}
		}
		pMatchedCall->Release();
	}
	else
	{
		CIncomingCall *pCall = new CIncomingCall(pManager,
												 fInvite,
												 hConf,
												 pcwszNodeName,
												 pUserDataInfoEntries,
												 cUserDataEntries);
		if (NULL != pCall)
		{
			// currently we don't add T120 calls to the call list

			pManager->OnIncomingCallCreated(pCall);

			pCall->Ring();

			// we're not holding on to the call so release it
			pCall->Release();
		}
		else
		{
			// unable to accept call
			if (fInvite)
			{
				hr = hConf->InviteResponse(FALSE);
			}
			else
			{
				hConf->JoinResponse(FALSE);
			}

			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}


CIncomingCall* CIncomingCallManager::MatchAcceptedCaller(PCWSTR pcwszNodeName)
{
	// we won't auto accept anyone who is already in the roster
	CNmMember* pMember = PDataMemberFromName(pcwszNodeName);
	if (NULL != pMember)
	{
		return FALSE;
	}

	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			pCall->MatchAcceptedCaller(pcwszNodeName))
		{
			TRACE_OUT(("Matched accepted caller"));
			pCall->AddRef();
			return pCall;
		}
	}

	return NULL;
}

CIncomingCall* CIncomingCallManager::MatchAcceptedCaller(GUID* pguidNodeId)
{
	if (GUID_NULL == *pguidNodeId)
	{
		return FALSE;
	}

	// we wont auto accept anyone who is already in the roster
	CNmMember* pMember = PMemberFromNodeGuid(*pguidNodeId);
	if ((NULL != pMember) && pMember->FHasData())
	{
		return FALSE;
	}

	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			pCall->MatchAcceptedCaller(pguidNodeId))
		{
			TRACE_OUT(("Matched accepted caller"));
			pCall->AddRef();
			return pCall;
		}
	}

	return NULL;
}

CIncomingCall* CIncomingCallManager::MatchActiveCaller(GUID* pguidNodeId)
{
	if (GUID_NULL == *pguidNodeId)
	{
		return FALSE;
	}

	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			pCall->MatchActiveCaller(pguidNodeId))
		{
			TRACE_OUT(("Matched active caller"));
			pCall->AddRef();
			return pCall;
		}
	}

	return NULL;
}

GUID* CIncomingCallManager::GetGuidFromT120UserData(
			PUSERDATAINFO	pUserDataInfoEntries,
			UINT			cUserDataEntries)
{
	if (cUserDataEntries > 0)
	{
		ASSERT(pUserDataInfoEntries);
		for (UINT u = 0; u < cUserDataEntries; u++)
		{
			if ((*pUserDataInfoEntries[u].pGUID == g_csguidNodeIdTag) &&
				(pUserDataInfoEntries[u].cbData == sizeof(GUID)))
			{
				return (GUID*)pUserDataInfoEntries[u].pData;
			}
		}
	}
	return NULL;
}

VOID CIncomingCallManager::CancelCalls()
{
	DebugEntry(CIncomingCallManager::CancelCalls);

	POSITION pos = m_CallList.GetHeadPosition();
	POSITION posItem;
	while (posItem = pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			if (SUCCEEDED(pCall->Terminate(FALSE)))
			{
				m_CallList.RemoveAt(posItem);
				pCall->Release();
			}
		}
	}

	DebugExitVOID(CIncomingCallManager::CancelCalls);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\icall_in.h ===
#ifndef _ICALL_IN_H_
#define _ICALL_IN_H_

#include "rostinfo.h"

// BUGBUG:
// This is defined as 128 because the RNC_ROSTER structure has the
// same limitation.  Investigate what the appropriate number is.
const int MAX_CALLER_NAME = 128;

class COprahNCUI;

class CIncomingCall : public INmCall, public DllRefCount, public CConnectionPointContainer
{
private:
	COprahNCUI	  * m_pOprahNCUI;
	IH323Endpoint*	m_pConnection;
	BOOL			m_fInvite;
	CONF_HANDLE 	m_hConf;
	BSTR			m_bstrCaller;
	NM_CALL_STATE	m_State;
	UINT			m_dwFlags;
	USER_DATA_LIST	m_UserData;
	GUID			m_guidNode;
	BOOL			m_fMemberAdded;

	VOID			ProcessT120UserData(
						PUSERDATAINFO pUserDataInfoEntries,
						UINT cUserDataEntries);

public:
	CIncomingCall(  COprahNCUI *pOprahNCUI, 
    	                IH323Endpoint* pConnection, 
    	                P_APP_CALL_SETUP_DATA lpvMNMData,
						DWORD dwFlags);

	CIncomingCall(	COprahNCUI *pOprahNCUI,
						BOOL fInvite,
						CONF_HANDLE hConf,
						PCWSTR pcwszNodeName,
						PUSERDATAINFO pUserDataInfoEntries,
						UINT cUserDataEntries);

	~CIncomingCall();

	// this method will need to be changed to support proposed the cookie for NM3.0 callers
	// it will still need to handle 2.X callers
	BOOL			MatchAcceptedCaller(PCWSTR pcwszNodeName);
	BOOL			MatchAcceptedCaller(GUID* pguidNodeId);
	BOOL			MatchActiveCaller(GUID* pguidNodeId);

	IH323Endpoint *	GetH323Connection()	{ return m_pConnection; }
	HRESULT			OnH323Connected();
	HRESULT			OnH323Disconnected();
	UINT			GetFlags() { return m_dwFlags; }
	BOOL			IsDataOnly() { return (0 == ((CRPCF_AUDIO | CRPCF_VIDEO) & m_dwFlags));	}
	BOOL			DidUserAccept() { return (NM_CALL_ACCEPTED == m_State); }

	VOID			SetConfHandle(CONF_HANDLE hConf) { m_hConf = hConf; }
	CONF_HANDLE		GetConfHandle() { return m_hConf; }
	VOID			OnIncomingT120Call(
						BOOL fInvite,
						PUSERDATAINFO pUserDataInfoEntries,
						UINT cUserDataEntries);
	HRESULT			OnT120ConferenceEnded();
	HRESULT			Terminate(BOOL fReject);
	GUID *			GetNodeGuid() { return &m_guidNode; }

	void Ring();

	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	STDMETHODIMP IsIncoming(void);
	STDMETHODIMP GetState(NM_CALL_STATE *pState);
	STDMETHODIMP GetName(BSTR *pbstrName);
	STDMETHODIMP GetAddr(BSTR *pbstrAddr, NM_ADDR_TYPE *puType);
	STDMETHODIMP GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	STDMETHODIMP GetConference(INmConference **ppConference);
	STDMETHODIMP Accept(void);
	STDMETHODIMP Reject(void);
	STDMETHODIMP Cancel(void);
};

class CIncomingCallManager
{
private:
	COBLIST m_CallList;

public:
	CIncomingCallManager();
	~CIncomingCallManager();

	CREQ_RESPONSETYPE OnIncomingH323Call(
			COprahNCUI *pManager,
			IH323Endpoint* pConnection,
			P_APP_CALL_SETUP_DATA lpvMNMData);

	VOID OnH323Connected(IH323Endpoint * lpConnection);

	VOID OnH323Disconnected(IH323Endpoint * lpConnection);

	HRESULT OnIncomingT120Call(
			COprahNCUI *pManager,
			BOOL fInvite,
			CONF_HANDLE hConf,
			PCWSTR pcwszNodeName,
			PUSERDATAINFO pUserDataInfoEntries,
			UINT cUserDataEntries,
			BOOL fSecure);

	VOID	OnT120ConferenceEnded(CONF_HANDLE hConference);

	CIncomingCall* MatchAcceptedCaller(PCWSTR pcwszNodeName);
	CIncomingCall* MatchAcceptedCaller(GUID* pguidNodeId);
	CIncomingCall* MatchActiveCaller(GUID* pguidNodeId);

	GUID* GetGuidFromT120UserData(
				PUSERDATAINFO	pUserDataInfoEntries,
				UINT			cUserDataEntries);

	VOID CancelCalls();
};

#endif // _ICALL_IN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\icall.h ===
/***************************************************************************/
/** 				 Microsoft Windows									  **/
/** 		   Copyright(c) Microsoft Corp., 1995-1996					  **/
/***************************************************************************/

//
//	The COutgoingCall class is defined, which is used while placing calls
//

#ifndef _ICALL_H_
#define _ICALL_H_

#include <nameres.h>		// need for RN_
#include "cncodes.h"		// needed for CNSTATUS and CN_

class CConfObject;

class COutgoingCall : public INmCall, public DllRefCount, 
    public CConnectionPointContainer
{
private:
	enum CNODESTATE
	{
		CNS_IDLE,

		CNS_SEARCHING,		// dummy state to keep compatible with NM2.X

		CNS_CONNECTING_H323,

		CNS_WAITING_T120_OPEN,

		CNS_QUERYING_REMOTE,

		CNS_CREATING_LOCAL,
		CNS_INVITING_REMOTE,
		CNS_TERMINATING_AFTER_INVITE,
		CNS_QUERYING_REMOTE_AFTER_INVITE,

		CNS_JOINING_REMOTE,

		CNS_COMPLETE
	};

	// Attributes:
	CNODESTATE      m_cnState;
	CConfObject*	m_pConfObject;
	REQUEST_HANDLE	m_hRequest;
	IH323Endpoint *	m_pH323Connection;
	BOOL            m_fCanceled;
	
	// User Info
	BSTR            m_bstrName;
	LPTSTR          m_pszAddr;
	BSTR            m_bstrAlias;
	BSTR            m_bstrConfToJoin;
	BSTR            m_bstrPassword;
	BSTR            m_bstrUserString;
	NM_ADDR_TYPE    m_addrType;
	DWORD           m_dwFlags;


	// Info that we obtain during processing
	CNSTATUS        m_cnResult;
	BOOL            m_fService;

	// Protected Methods:
	BOOL			ReportError(CNSTATUS cns);
	CNSTATUS		MapAudioSummaryToCNStatus(DWORD dwSummary);
	CNSTATUS 		StartT120Call();
	CNSTATUS		ConnectH323();
	VOID			SetCallState(CNODESTATE cnState);

	BOOL			IsDataOnly() { return (0 == ((CRPCF_AUDIO | CRPCF_VIDEO) & m_dwFlags));	}

	HRESULT			Connect(
						PSOCKADDR_IN psin,
						P_H323ALIASLIST pAliasList,
						LPCWSTR pcwszPSTNAddress,
						P_APP_CALL_SETUP_DATA lpvMNMData, 
						GUID PIDofProtocolType,
						IH323Endpoint * *ppConnection);

public:

	COutgoingCall(CConfObject* pco, DWORD dwFlags, NM_ADDR_TYPE addrType, BSTR bstrName,
		BSTR bstrDest, BSTR bstrAlias, BSTR bstrConference, BSTR bstrPassword, BSTR bstrUserString);

	~COutgoingCall();

						
	// Methods:
	VOID			PlaceCall(void);
	VOID			CallComplete(void);
	HRESULT 		_Cancel(BOOL fLeaving);

	// Properties:
	DWORD			GetFlags()					{ return m_dwFlags; }
	REQUEST_HANDLE	GetCurrentRequestHandle()	{ return m_hRequest; }
	IH323Endpoint *	GetH323Connection()			{ return m_pH323Connection; }
	BOOL			FCanceled() 				{ return m_fCanceled; }
	BOOL			FIsComplete()				{ return (CNS_COMPLETE == m_cnState); }

	BOOL			MatchActiveCallee(LPCTSTR pszDest, BSTR bstrAlias, BSTR bstrConference);


	
	// Event Handlers:
	
	// Received by only this COutgoingCall object
	BOOL			OnQueryRemoteResult(HRESULT ncsResult,
										BOOL fMCU,
										PWSTR pwszConfNames[],
										PT120PRODUCTVERSION pVersion,
										PWSTR pwszConfDescriptors[]);
	BOOL			OnInviteResult(HRESULT ncsResult, UINT uNodeID);
	
	// Received by all COutgoingCall objects sharing the same conference
	BOOL			OnConferenceEnded();
	
	// Received by all COutgoingCall objects
	BOOL			OnConferenceStarted(CONF_HANDLE hNewConf, 
										HRESULT ncsResult);
	BOOL			OnH323Connected(IH323Endpoint * pConnection);
	BOOL			OnH323Disconnected(IH323Endpoint * pConnection);
	BOOL            OnT120ChannelOpen(ICommChannel *pIChannel, DWORD dwStatus);

	STDMETHODIMP_(ULONG)	AddRef(void);
	STDMETHODIMP_(ULONG)	Release(void);
	STDMETHODIMP			QueryInterface(REFIID riid, PVOID *ppvObj);

	STDMETHODIMP 		IsIncoming(void);
	STDMETHODIMP 		GetState(NM_CALL_STATE *pState);
	STDMETHODIMP 		GetName(BSTR *pbstr);
	STDMETHODIMP 		GetAddr(BSTR *pbstr, NM_ADDR_TYPE *puType);
	STDMETHODIMP 		GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	STDMETHODIMP 		GetConference(INmConference **ppConference);
	STDMETHODIMP 		Accept(void);
	STDMETHODIMP 		Reject(void);
	STDMETHODIMP 		Cancel(void);

};

class COprahNCUI;

class COutgoingCallManager
{
private:
	COBLIST	m_CallList;

	UINT			GetNodeCount();

	COutgoingCall*	FindCall(IH323Endpoint * lpConnection);
	BOOL MatchActiveCallee(LPCTSTR pszDest, BSTR bstrAlias, BSTR bstrConference);

public:

	COutgoingCallManager();

	~COutgoingCallManager();

	UINT	GetCallCount();

	BOOL	RemoveFromList(COutgoingCall* pCall);

	HRESULT Call(	INmCall **ppCall,
					COprahNCUI* pManager,
					DWORD dwFlags,
					NM_ADDR_TYPE addrType,
					BSTR bstrName,
					BSTR bstrSetup,
					BSTR bstrDest,
					BSTR bstrAlias,
					BSTR bstrURL,
					BSTR bstrConference,
					BSTR bstrPassword,
					BSTR bstrUserString);

	BOOL OnH323Connected(IH323Endpoint * lpConnection);

	BOOL OnH323Disconnected(IH323Endpoint * lpConnection);
	
	VOID OnT120ChannelOpen(	ICommChannel *pIChannel,
							IH323Endpoint * lpConnection,
							DWORD dwStatus);

	VOID OnConferenceStarted(CONF_HANDLE hConference, HRESULT hResult);

	VOID OnQueryRemoteResult(	PVOID pvCallerContext,
								HRESULT hResult,
								BOOL fMCU,
								PWSTR* ppwszConferenceNames,
								PT120PRODUCTVERSION pVersion,
								PWSTR* ppwszConfDescriptors);

	VOID OnInviteResult(	CONF_HANDLE hConference,
							REQUEST_HANDLE hRequest,
							UINT uNodeID,
							HRESULT hResult,
							PT120PRODUCTVERSION pVersion);

	VOID OnConferenceEnded(CONF_HANDLE hConference);

	VOID CancelCalls();
};

#endif // _ICALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\icawrap.cpp ===
// File: icawrap.cpp

#include "precomp.h"

#include "icawrap.h"

CICA* CICA::m_pThis = NULL;


CICA::CICA() :
	RefCount(NULL),
	m_pfnICA_Start(NULL),
	m_pfnICA_Stop(NULL),
	m_pfnICA_DisplayPanel(NULL),
	m_pfnICA_RemovePanel(NULL),
	m_pfnICA_SetOptions(NULL),
	m_hICA_General(NULL),
	m_hICA_Audio(NULL),
	m_hICA_Video(NULL),
	m_hICA_SetOptions(NULL),
	m_hWndICADlg(NULL)
{
}

CICA::~CICA()
{
	m_pThis = NULL;
}

CICA* CICA::Instance()
{
	if (NULL == m_pThis)
	{
		m_pThis = new CICA;
		if (!m_pThis->Initialize())
		{
			WARNING_OUT(("ICA Failed to initialize"));
			delete m_pThis;
			m_pThis = NULL;
		}
	}
	else
	{
		m_pThis->AddRef();
	}
	
	return m_pThis;
}

BOOL CICA::Initialize()
{
	HINSTANCE hInst = NmLoadLibrary(SZ_ICADLL,FALSE);
	if (NULL == hInst)
	{
		return FALSE;
	}

	m_pfnICA_Start = (PFnICA_Start)GetProcAddress(hInst, TEXT("ICA_Start"));
	if (NULL == m_pfnICA_Start)
	{
		goto ErrorLeave;
	}

	m_pfnICA_Stop = (PFnICA_Stop)GetProcAddress(hInst, TEXT("ICA_Stop"));
	if( NULL == m_pfnICA_Stop)
	{
		goto ErrorLeave;
	}

	m_pfnICA_DisplayPanel =
		(PFnICA_DisplayPanel)GetProcAddress(hInst, TEXT("ICA_DisplayPanel"));
	if(NULL == m_pfnICA_DisplayPanel)
	{
		goto ErrorLeave;
	}
	
	m_pfnICA_RemovePanel =
		(PFnICA_RemovePanel)GetProcAddress(hInst, TEXT("ICA_RemovePanel"));
	if(NULL == m_pfnICA_RemovePanel)
	{
		goto ErrorLeave;
	}

	m_pfnICA_SetOptions =
		(PFnICA_SetOptions)GetProcAddress(hInst, TEXT("ICA_SetOptions"));
	if(NULL == m_pfnICA_SetOptions)
	{
		goto ErrorLeave;
	}
	return TRUE;

ErrorLeave:
	FreeLibrary(hInst);
	return FALSE;
}
	

BOOL CICA::Start()
{
	if (IsRunning())
	{
		return TRUE;
	}

	LPSTR pszHelpFile = SZ_ICAHELP;

	ASSERT(m_pfnICA_Start);
	if (S_OK != m_pfnICA_Start(TEXT(""), TEXT("RRCM.DLL"), &m_hWndICADlg))
	{
		return FALSE;
	}

	ASSERT(m_pfnICA_DisplayPanel);
	if (S_OK != m_pfnICA_DisplayPanel(
		NULL,					// pszModuleName
		"ICA_GENERAL_PANEL",	// pzName
		pszHelpFile,			// pszHelpFile
		NULL,
		&m_hICA_General))
	{
		m_hICA_General = NULL;
		goto ErrorLeave;
	}

	if (S_OK != m_pfnICA_DisplayPanel(
		NULL,					// pszModuleName
		"NM2.0_H323_AUDIO",		// pzName
		pszHelpFile,			// pszHelpFile
		NULL,
		&m_hICA_Audio))
	{
		m_hICA_Audio = NULL;
		goto ErrorLeave;
	}

	if (S_OK != m_pfnICA_DisplayPanel(
		NULL,					// pszModuleName
		"NM2.0_H323_VIDEO",		// pzName
		pszHelpFile,			// pszHelpFile
		NULL,
		&m_hICA_Video))
	{
		m_hICA_Video = NULL;
		goto ErrorLeave;
	}

#if 0
	RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );
	UINT uSoundCardCaps = re.GetNumber(REGVAL_SOUNDCARDCAPS,SOUNDCARD_NONE);

	BOOL fFullDuplex = FALSE;
	ASSERT(ISSOUNDCARDPRESENT(uSoundCardCaps));
	if (ISSOUNDCARDFULLDUPLEX(uSoundCardCaps))
	{					
		fFullDuplex = (BOOL)
			( re.GetNumber(REGVAL_FULLDUPLEX,0) == FULLDUPLEX_ENABLED );
	}					

	ASSERT(g_pfnICA_SetOptions);
	if (S_OK != m_pfnICA_SetOptions( (fFullDuplex ? ICA_SET_FULL_DUPLEX : ICA_SET_HALF_DUPLEX)))
	{
		m_hICA_SetOptions = NULL;
		goto ErrorLeave;
	}
#endif // 0
	
	// normal return path
	return TRUE;

ErrorLeave:
	Stop();
	return FALSE;
}

VOID CICA::Stop()
{
	ASSERT(m_hWndICADlg);

	ASSERT(m_pfnICA_RemovePanel);
	if (NULL != m_hICA_General)
	{
		m_pfnICA_RemovePanel(m_hICA_General);
		m_hICA_General = NULL;
	}
	
	if (NULL != m_hICA_Audio)
	{
		m_pfnICA_RemovePanel(m_hICA_Audio);
		m_hICA_Audio = NULL;
	}
	
	if (NULL != m_hICA_Video)
	{
		m_pfnICA_RemovePanel(m_hICA_Video);
		m_hICA_Video = NULL;
	}

	ASSERT(m_pfnICA_Stop);
	m_pfnICA_Stop();

	m_hWndICADlg = NULL;
}


VOID CICA::SetInTray(BOOL fInTray)
{
	if (NULL != m_pfnICA_SetOptions)
	{
		UINT uOptions = ICA_DONT_SHOW_TRAY_ICON;

		if (fInTray)
		{
			uOptions = ICA_SHOW_TRAY_ICON;
		}

		m_pfnICA_SetOptions(uOptions);
	}
}

STDMETHODIMP_(ULONG) CICA::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CICA::Release(void)
{
	return RefCount::Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\ichannel.h ===
// File: ichannel.h

#ifndef _ICHANNEL_H_
#define _ICHANNEL_H_

HRESULT OnNotifyChannelMemberAdded(IUnknown *pChannelNotify, PVOID pv, REFIID riid);
HRESULT OnNotifyChannelMemberUpdated(IUnknown *pChannelNotify, PVOID pv, REFIID riid);
HRESULT OnNotifyChannelMemberRemoved(IUnknown *pChannelNotify, PVOID pv, REFIID riid);

#endif // _CHANNEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\icawrap.h ===
#ifndef _ICAWRAP_H_
#define _ICAWRAP_H_

#include <icaapi.h>

class CICA : public RefCount
{
protected:
	static CICA* m_pThis;
	PFnICA_Start m_pfnICA_Start;
	PFnICA_Stop m_pfnICA_Stop;
	PFnICA_DisplayPanel m_pfnICA_DisplayPanel;
	PFnICA_RemovePanel m_pfnICA_RemovePanel;
	PFnICA_SetOptions m_pfnICA_SetOptions;

	HANDLE m_hICA_General;
	HANDLE m_hICA_Audio;
	HANDLE m_hICA_Video;
	HANDLE m_hICA_SetOptions;
	
	HWND m_hWndICADlg;

	CICA();
	~CICA();
	
	BOOL Initialize();

public:
	static CICA* Instance();
	
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	BOOL Start();
	VOID Stop();

	BOOL IsRunning() { return NULL != m_hWndICADlg; }
	HWND GetHwnd()   { return m_hWndICADlg; }

	VOID SetInTray(BOOL fInTray);
};

#endif	// _ICAWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\ichnlaud.h ===
// File: ichnlaud.h

#ifndef _ICHNLAUD_H_
#define _ICHNLAUD_H_

// we have no notification on the channel "callback" that the state changed
// to determine if a/v is active we need to get both the video and the audio channel

class CNmChannelAudio : public INmChannelAudio,
	public DllRefCount, public CConnectionPointContainer
{
private:
	int				m_cMembers;
	BOOL			m_fIncoming;
	DWORD			m_dwFlags;
	IAudioChannel*	m_pAudioChannel;
	IAudioDevice *	m_pAudioDevice;
	ICommChannel*	m_pCommChannel;
	MEDIA_FORMAT_ID m_MediaFormat;
    CAudioControl   m_AudioControl;

public:
	CNmChannelAudio(BOOL fIncoming);
	~CNmChannelAudio();

	VOID CommChannelOpened(ICommChannel *pCommChannel);
	VOID CommChannelActive(ICommChannel *pCommChannel);
	VOID CommChannelClosed();
	ICommChannel * GetCommChannel() { return m_pCommChannel; }
	VOID SetFormat(MEDIA_FORMAT_ID id) { m_MediaFormat = id;}
	
	VOID OnConnected(IH323Endpoint * pConnection, ICommChannel *pIChannel)
        { m_AudioControl.OnConnected(pConnection, pIChannel); }
	VOID OnDisconnected() {	m_AudioControl.OnDisconnected(); }
	
	VOID OnMemberAdded(CNmMember *pMember);
	VOID OnMemberRemoved(CNmMember *pMember);
	VOID OnMemberUpdated(CNmMember *pMember);

	IMediaChannel *GetMediaChannelInterface(void);


	DWORD GetLevel();
	BOOL IsPaused();
	BOOL IsAutoMixing();

    VOID Open();
    VOID Close();

	// IUnknown
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	// INmChannel
    STDMETHODIMP IsSameAs(INmChannel *pChannel);
    STDMETHODIMP IsActive();
    STDMETHODIMP SetActive(BOOL fActive);
    STDMETHODIMP GetConference(INmConference **ppConference);
    STDMETHODIMP GetInterface(IID *piid);
    STDMETHODIMP GetNmch(ULONG *puCh);
    STDMETHODIMP EnumMember(IEnumNmMember **ppEnum);
    STDMETHODIMP GetMemberCount(ULONG * puCount);

	// INmChannelAudio
    STDMETHODIMP IsIncoming(void);
    STDMETHODIMP GetState(NM_AUDIO_STATE *puState);
    STDMETHODIMP GetProperty(NM_AUDPROP uID, ULONG_PTR *puValue);
    STDMETHODIMP SetProperty(NM_AUDPROP uID, ULONG_PTR uValue);
};

HRESULT OnNotifyPropertyChanged(IUnknown *pAudioChannelNotify, PVOID pv, REFIID riid);
HRESULT OnNotifyStateChanged(IUnknown *pAudioChannelNotify, PVOID pv, REFIID riid);

#endif // _ICHNLAUD_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\ichannel.cpp ===
// File: ichannel.cpp

#include "precomp.h"


/*  O N  N O T I F Y  C H A N N E L  M E M B E R  A D D E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyChannelMemberAdded
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyChannelMemberAdded(IUnknown *pChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pChannelNotify);
	((INmChannelNotify*)pChannelNotify)->MemberChanged(NM_MEMBER_ADDED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C H A N N E L  M E M B E R  U P D A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyChannelMemberUpdated
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyChannelMemberUpdated(IUnknown *pChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pChannelNotify);
	((INmChannelNotify*)pChannelNotify)->MemberChanged(NM_MEMBER_UPDATED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C H A N N E L  M E M B E R  R E M O V E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyChannelMemberRemoved
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyChannelMemberRemoved(IUnknown *pChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pChannelNotify);
	((INmChannelNotify*)pChannelNotify)->MemberChanged(NM_MEMBER_REMOVED, (INmMember *) pv);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\ichnlaud.cpp ===
// File: ichnlaud.cpp

#include "precomp.h"
#include "ichnlaud.h"

static const IID * g_apiidCP[] =
{
    {&IID_INmChannelNotify},
    {&IID_INmChannelAudioNotify}
};

CNmChannelAudio::CNmChannelAudio(BOOL fIncoming) :
	CConnectionPointContainer(g_apiidCP, ARRAY_ELEMENTS(g_apiidCP)),
	m_cMembers	(0),
	m_dwFlags(0),
	m_pAudioChannel(NULL),
	m_pAudioDevice(NULL),
	m_pCommChannel(NULL),
	m_fIncoming(fIncoming),
	m_AudioControl(!fIncoming /* fLocal */),
	m_MediaFormat(INVALID_MEDIA_FORMAT)
{
	IMediaChannel *pMC = NULL;
	HRESULT hr;

	if (NULL != g_pH323UI)
	{
		IMediaChannelBuilder * pMCProvider = g_pH323UI->GetStreamProvider();
		ASSERT(NULL != pMCProvider);

		// create the channel, and get the device interface
		pMCProvider->CreateMediaChannel(MCF_AUDIO | (fIncoming ? MCF_RECV : MCF_SEND), &pMC);
		if (NULL != pMC)
		{
			pMCProvider->QueryInterface(IID_IAudioDevice, (void**)&m_pAudioDevice);
			pMC->QueryInterface(IID_IAudioChannel, (void**)&m_pAudioChannel);

			ASSERT(m_pAudioChannel);
			ASSERT(m_pAudioDevice);

			pMC->Release();
		}
		else
		{
			WARNING_OUT(("CreateMediaChannel failed"));
		}
		pMCProvider->Release();
	}
	
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CNmChannelAudio", this);
}

CNmChannelAudio::~CNmChannelAudio()
{
	if (NULL != m_pCommChannel)
	{
		m_pCommChannel->Release();
	}

	if (NULL != m_pAudioChannel)
	{
		m_pAudioChannel->Release();
	}

	if (NULL != m_pAudioDevice)
	{
		m_pAudioDevice->Release();
	}

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CNmChannelAudio", this);
}

VOID CNmChannelAudio::CommChannelOpened(ICommChannel *pCommChannel)
{
	ASSERT(NULL == m_pCommChannel);
	m_pCommChannel = pCommChannel;
	pCommChannel->AddRef();
}
VOID CNmChannelAudio::CommChannelActive(ICommChannel *pCommChannel)
{
	ASSERT(m_pCommChannel == pCommChannel);
}

VOID CNmChannelAudio::CommChannelClosed()
{
	if (NULL != m_pCommChannel)
	{
		m_pCommChannel->Release();
		m_pCommChannel = NULL;
	}
}

VOID CNmChannelAudio::OnMemberAdded(CNmMember *pMember)
{
	// Don't add to the channel if we already belong.
	if (0 != (pMember->GetNmchCaps() & NMCH_AUDIO))
	{
		return;
	}
	
	++m_cMembers;

	pMember->AddNmchCaps(NMCH_AUDIO);

	CConfObject *pco = ::GetConfObject();
	pco->OnMemberUpdated(pMember);

	NotifySink((INmMember *) pMember, OnNotifyChannelMemberAdded);
}

VOID CNmChannelAudio::OnMemberRemoved(CNmMember *pMember)
{

	// If member does not belong to this channel, don't remove it.
	if (0 == (pMember->GetNmchCaps() & NMCH_AUDIO))
	{
		return;
	}
	
	--m_cMembers;

	pMember->RemoveNmchCaps(NMCH_AUDIO);

	CConfObject *pco = ::GetConfObject();
	pco->OnMemberUpdated(pMember);

	NotifySink((INmMember *) pMember, OnNotifyChannelMemberRemoved);
}

VOID CNmChannelAudio::OnMemberUpdated(CNmMember *pMember)
{
	NotifySink((INmMember *) pMember, OnNotifyChannelMemberUpdated);
}

DWORD CNmChannelAudio::GetLevel()
{
	UINT uLevel = 0;

	if (NULL != m_pAudioChannel)
	{
		m_pAudioChannel->GetSignalLevel(&uLevel);
	}

	return uLevel;
}


BOOL CNmChannelAudio::IsAutoMixing()
{
	BOOL bOn=FALSE;


	if ((NULL != m_pAudioChannel) && (!m_fIncoming))
	{
		m_pAudioDevice->GetAutoMix(&bOn);
	}

	return bOn;
}


BOOL CNmChannelAudio::IsPaused()
{
	BOOL fPaused = TRUE;
	if (NULL != m_pCommChannel)
	{
		DWORD dwOn = FALSE;
		UINT uSize = sizeof(dwOn);
		DWORD dwPropID = m_fIncoming ? PROP_PLAY_ON : PROP_RECORD_ON;
		m_pCommChannel->GetProperty(dwPropID, &dwOn, &uSize);
		fPaused = (0 == dwOn);
	}
	return fPaused;
}

VOID CNmChannelAudio::Open()
{
	ASSERT(m_MediaFormat !=  INVALID_MEDIA_FORMAT);
	m_AudioControl.Open(m_MediaFormat);

}

VOID CNmChannelAudio::Close()
{
	m_AudioControl.Close();
}

STDMETHODIMP_(ULONG) CNmChannelAudio::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CNmChannelAudio::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CNmChannelAudio::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmChannelAudio) || (riid == IID_INmChannel) || (riid == IID_IUnknown))
	{
		*ppv = (INmChannel *)this;
		DbgMsgApi("CNmChannelAudio::QueryInterface()");
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		DbgMsgApi("CNmChannelAudio::QueryInterface(): Returning IConnectionPointContainer.");
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		DbgMsgApi("CNmChannelAudio::QueryInterface(): Called on unknown interface.");
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

STDMETHODIMP CNmChannelAudio::IsSameAs(INmChannel *pChannel)
{
	return (((INmChannel *) this) == pChannel) ? S_OK : S_FALSE;
}

STDMETHODIMP CNmChannelAudio::IsActive()
{
	return (NULL != m_pCommChannel) ? S_OK : S_FALSE;
}

STDMETHODIMP CNmChannelAudio::SetActive(BOOL fActive)
{
	return E_FAIL;
}

STDMETHODIMP CNmChannelAudio::GetConference(INmConference **ppConference)
{
	return ::GetConference(ppConference);
}

STDMETHODIMP CNmChannelAudio::GetInterface(IID *piid)
{
	HRESULT hr = E_POINTER;

	if (NULL != piid)
	{
		*piid = IID_INmChannelAudio;
		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CNmChannelAudio::GetNmch(ULONG *puCh)
{
	HRESULT hr = E_POINTER;

	if (NULL != puCh)
	{
		*puCh = NMCH_AUDIO;
		hr = S_OK;
	}
	return hr;
}
	
STDMETHODIMP CNmChannelAudio::EnumMember(IEnumNmMember **ppEnum)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppEnum)
	{
		int cMembers = 0;
		COBLIST MemberList;
		COBLIST* pPartList = ::GetMemberList();
		if (NULL != pPartList)
		{
			POSITION pos = pPartList->GetHeadPosition();
			while (pos)
			{
				CNmMember * pMember = (CNmMember *) pPartList->GetNext(pos);
				ASSERT(NULL != pMember);

				if (NMCH_AUDIO & pMember->GetNmchCaps())
				{
					MemberList.AddTail(pMember);
					pMember->AddRef();
					cMembers++;
				}
			}
		}

		*ppEnum = new CEnumNmMember(&MemberList, cMembers);

		while (!MemberList.IsEmpty())
		{
			INmMember *pMember = (INmMember *) (CNmMember *) MemberList.RemoveHead();
			pMember->Release();
		}
		hr = (NULL != *ppEnum)? S_OK : E_OUTOFMEMORY;
	}
	return hr;
}

STDMETHODIMP CNmChannelAudio::GetMemberCount(ULONG * puCount)
{
	HRESULT hr = E_POINTER;
	if (NULL != puCount)
	{
		*puCount = m_cMembers;
		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CNmChannelAudio::IsIncoming(void)
{
	return m_fIncoming ? S_OK : S_FALSE;
}

STDMETHODIMP CNmChannelAudio::GetState(NM_AUDIO_STATE *puState)
{
	HRESULT hr = E_POINTER;

	if (NULL != puState)
	{
		if (NULL != m_pCommChannel)
		{
			if (IsPaused())
			{
				*puState = NM_AUDIO_LOCAL_PAUSED;
			}
			else
			{
				*puState = NM_AUDIO_TRANSFERRING;
			}
		}
		else
		{
			*puState = NM_AUDIO_IDLE;
		}
		hr = S_OK;
	}
	return hr;
}


IMediaChannel* CNmChannelAudio::GetMediaChannelInterface(void)
{
	IMediaChannel *pMC=NULL;

	if (m_pAudioChannel)
	{
		m_pAudioChannel->QueryInterface(IID_IMediaChannel, (void**)&pMC);
	}
	return pMC;
}





STDMETHODIMP CNmChannelAudio::GetProperty(NM_AUDPROP uID, ULONG_PTR *puValue)
{
	HRESULT hr = E_POINTER;

	if (NULL != puValue)
	{
		switch (uID)
		{
		case NM_AUDPROP_LEVEL:
			*puValue = GetLevel();
			hr = S_OK;
			break;

		case NM_AUDPROP_PAUSE:
			*puValue = IsPaused();
			hr = S_OK;
			break;

		case NM_AUDPROP_AUTOMIX:
			*puValue = IsAutoMixing();
			hr = S_OK;
			break;

		default:
			hr = E_FAIL;
			break;
		}
	}
	return hr;
}

HRESULT OnNotifyPropertyChanged(IUnknown *pAudioChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pAudioChannelNotify);
	((INmChannelAudioNotify*)pAudioChannelNotify)->PropertyChanged((DWORD)((DWORD_PTR)pv));
	return S_OK;
}

HRESULT OnNotifyStateChanged(IUnknown *pAudioChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pAudioChannelNotify);
	((INmChannelAudioNotify*)pAudioChannelNotify)->StateChanged(static_cast<NM_AUDIO_STATE>((DWORD)((DWORD_PTR)pv)));
	return S_OK;
}


STDMETHODIMP CNmChannelAudio::SetProperty(NM_AUDPROP uID, ULONG_PTR uValue)
{
	HRESULT hr = E_FAIL;

	if ((NULL != m_pAudioDevice) && (NULL != m_pAudioChannel))
	{
		switch (uID)
		{
		case NM_AUDPROP_PAUSE:
		{
			DWORD dwOn = (0 == uValue);
			DWORD dwPropID = m_fIncoming ? PROP_PLAY_ON : PROP_RECORD_ON;
			if (m_pCommChannel)
			{
				hr = m_pCommChannel->SetProperty(dwPropID, &dwOn, sizeof(dwOn));

				if(S_OK == hr)
				{		
						// The Mute state has changed
					NotifySink((void*)NM_AUDPROP_PAUSE, OnNotifyPropertyChanged);

						// The Channel state has changed
					NM_AUDIO_STATE uState;
					if(SUCCEEDED(GetState(&uState)))
					{
						NotifySink((void*)uState, OnNotifyStateChanged);
					}
				}
			}
			break;
		}
		case NM_AUDPROP_LEVEL:
		{
			hr = m_pAudioDevice->SetSilenceLevel(uValue);
			break;
		}
		case NM_AUDPROP_FULL_DUPLEX:
		{
			DWORD dwDuplex = uValue;
			hr = m_pAudioDevice->SetDuplex((BOOL)uValue);
			break;
		}
		case NM_AUDPROP_WAVE_DEVICE:
		{
			if (m_fIncoming)
			{
				hr = m_pAudioDevice->SetPlaybackID(uValue);
			}
			else
			{
				hr = m_pAudioDevice->SetRecordID(uValue);
			}
			break;
		}

		case NM_AUDPROP_AUTOMIX:
		{
			hr = m_pAudioDevice->SetAutoMix((BOOL)uValue);
			break;
		}

		case NM_AUDPROP_DTMF_DIGIT:
		{
			IDTMFSend *pDTMF=NULL;

			if (!m_fIncoming)
			{
				hr = m_pAudioChannel->QueryInterface(IID_IDTMFSend, (void**)&pDTMF);
				if (SUCCEEDED(hr))
				{
					hr = pDTMF->AddDigit((int)uValue);
					pDTMF->Release();
				}
			}
		}

		default:
			break;
		}
	}
	return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\ichnldat.h ===
// File: ichnldat.h
//

#ifndef _ICHNLDAT_H_
#define _ICHNLDAT_H_

#include "pfnt120.h"

typedef enum _scState {               /* State of data channel */
	SCS_UNINITIALIZED = 0,           // Nothing is valid
	SCS_CREATESAP,                   // Creating m_gcc_pIAppSap
	SCS_ATTACH,                      // Attaching
	SCS_ENROLL,                      // Enrolling in a conference
	SCS_JOIN_PRIVATE,                // Join the private channel
	SCS_REGRETRIEVE,                 // Checking the registry
	SCS_REGRETRIEVE_NEW,             // new channel must be created
	SCS_REGRETRIEVE_EXISTS,          // channel already exists
	SCS_JOIN_NEW,                    // Creating a new MCS channel
	SCS_REGCHANNEL,                  // Registering the MCS channel
	SCS_JOIN_OLD,                    // Joining an existing channel
	SCS_REGPRIVATE,                  // Register the private channel
	SCS_CONNECTED,                   // m_mcs_channel_id is valid
	SCS_TERMINATING,                 // shutting down
	SCS_JOIN_STATIC_CHANNEL          // Join a static channel
} SCSTATE;


// An application key consists of an MS Object ID + guid identifier + guid + node id
#define cbKeyApp (4 + 1 + sizeof(GUID) + sizeof(DWORD))
#define MAX_CHECKID_COUNT 80  // Maximum number of times to ask for channel Id

typedef struct _tagUcid {
	DWORD     dwUserId;           // Node ID
	ChannelID channelId;          // Private channel ID
	UserID    sender_id_public;
	UserID    sender_id_private;
} UCID;

// CNmMemberId
class CNmMemberId
{
private:
	UINT      m_cCheckId;          // non-zero means checking the ID

	ChannelID m_channelId;         // Private channel ID
	UserID    m_sender_id_public;
	UserID    m_sender_id_private;

	CNmMember *m_pMember;

public:
	CNmMemberId(CNmMember *pMember, UCID *pucid);

	ChannelID GetChannelId(void)  {return m_channelId;}
	ChannelID SenderId(void)      {return m_sender_id_public;}

	VOID  UpdateRosterInfo(UCID * pucid);
	BOOL  FSenderId(UserID id)    {return ((id == m_sender_id_public) || (id == m_sender_id_private));}

	UINT  GetCheckIdCount(void)   {return m_cCheckId;}
	VOID  SetCheckIdCount(UINT c) {m_cCheckId = c;}

	CNmMember *GetMember(void)    {return m_pMember;}
};




// INmChannelData
//
class CNmChannelData : public INmChannelData2,
	public DllRefCount, public CConnectionPointContainer
{
private:
	GUID	m_guid;                  // SetGuid/GetGuid
	BOOL    m_fClosed;               // TRUE when CloseConnection is called
	BOOL    m_fActive;               // TRUE when data channel is active
	DWORD   m_dwUserIdLocal;         // Data channel needs to know local user id
	CConfObject * m_pConference;	 //	Helpful to get member list

	ULONG       m_cMember;           // Number of members in this channel
	COBLIST   * m_pListMemberId;	 // Member id list
	COBLIST	  * m_pListMember;       // Member list
	PGCCEnrollRequest	m_pGCCER;     // Enroll request from enrolling app

public:
	CNmChannelData(CConfObject * pConference, REFGUID rguid, PGCCEnrollRequest pER = NULL);
	~CNmChannelData();


	// Internal functions
	GUID * PGuid(void)      {return &m_guid;}
	VOID UpdatePeer(CNmMember * pMember, UCID *pucid, BOOL fAdd);
	VOID UpdateRoster(UCID * rgPeer, int cPeer, BOOL fAdd, BOOL fRemove);
	VOID UpdateMemberChannelId(DWORD dwUserId, ChannelID channelId);
	HRESULT OpenConnection(void);
	HRESULT CloseConnection(void);

	ULONG IsEmpty()               {return 0 == m_cMember;}
	COBLIST * GetMemberList()     {return m_pListMember;}
	VOID AddMember(CNmMember * pMember);
	VOID RemoveMember(CNmMember * pMember);

	CNmMemberId *GetMemberId(CNmMember *pMember);
	CNmMemberId *GetMemberId(DWORD dwUserId);
	VOID  UpdateRosterInfo(CNmMember *pMember, UCID * pucid);
	ChannelID GetChannelId(CNmMember *pMember);
	CNmMember *PMemberFromSenderId(UserID id);
	CConfObject * PConference() {return m_pConference;}
	DWORD GetLocalId()          {return m_dwUserIdLocal;}

	// INmChannelData methods
	HRESULT STDMETHODCALLTYPE GetGuid(GUID *pguid);
	HRESULT STDMETHODCALLTYPE SendData(INmMember *pMember, ULONG uSize, LPBYTE pb, ULONG uOptions);
	HRESULT STDMETHODCALLTYPE RegistryAllocateHandle(ULONG numberOfHandlesRequested);
	
	// INmChannel methods
	HRESULT STDMETHODCALLTYPE IsSameAs(INmChannel *pChannel);
	HRESULT STDMETHODCALLTYPE IsActive(void);
	HRESULT STDMETHODCALLTYPE SetActive(BOOL fActive);
	HRESULT STDMETHODCALLTYPE GetConference(INmConference **ppConference);
	HRESULT STDMETHODCALLTYPE GetInterface(IID *piid);
	HRESULT STDMETHODCALLTYPE GetNmch(ULONG *puCh);
	HRESULT STDMETHODCALLTYPE EnumMember(IEnumNmMember **ppEnum);
	HRESULT STDMETHODCALLTYPE GetMemberCount(ULONG * puCount);

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);

/////////////////////////////////////////////////////////////


// class CT120Channel

private:
	DWORD DoJoin(SCSTATE scs);

	DWORD DoJoinStatic(ChannelID staticChannel);
	DWORD DoCreateSap(void);
	DWORD DoEnroll(void);
	DWORD DoJoinPrivate(void);
	DWORD DoAttach(void);
	DWORD DoRegRetrieve(void);
	DWORD DoRegChannel(void);
	DWORD DoJoinNew(void);
	DWORD DoJoinOld(void);
	DWORD DoRegPrivate(void);

	VOID  OnEntryConfirmRemote(GCCAppSapMsg * pMsg);
	VOID  OnEntryConfirmLocal(GCCAppSapMsg * pMsg);

public:
	// Methods:
	VOID InitCT120Channel(DWORD dwUserId);

	GUID * m_pGuid;
	CNmChannelData * m_pChannel;

	DWORD   m_dwUserId;
	BYTE    m_keyApp[cbKeyApp];
	BYTE    m_keyChannel[cbKeyApp];

	SCSTATE m_scs;         // Current state

	GCCConferenceID m_gcc_conference_id;
	IGCCAppSap      *m_gcc_pIAppSap;
	GCCSessionKey   m_gcc_session_key;
	GCCRegistryKey  m_gcc_registry_key;
	GCCRegistryItem m_gcc_registry_item;

	GCCRegistryKey  m_registry_key_Private;
	GCCRegistryItem m_registry_item_Private;
	
	ChannelID       m_mcs_channel_id;  // public channel ID
	PIMCSSap	    m_pmcs_sap;

	UserID          m_gcc_node_id;

	// m_mcs_sender_id is the result of MCS_ATTACH_USER_CONFIRM.
	// It is also the "sender_id" in MCS_SEND_DATA_INDICATION
	UserID          m_mcs_sender_id;

	// Properties:
	BOOL    FConnected(void)       {return (SCS_CONNECTED == m_scs);}
	ChannelID GetMcsChannelId()    {return m_mcs_channel_id;}
	ChannelID SenderChannelId()    {return m_mcs_sender_id;}

	VOID    CloseChannel(VOID);
	HRESULT HrSendData(ChannelID channelId, DWORD dwUserId, LPVOID lpv, DWORD cb, DWORD opt);
	VOID    UpdateScState(SCSTATE scs, DWORD dwErr);
	VOID    ProcessEntryConfirm(GCCAppSapMsg * pMsg);
	BOOL    UpdateRoster(GCCAppSapMsg * pMsg);
	VOID    RemovePeer(UINT iPeer);
	VOID    RequestChannelId(DWORD dwUserId);
	VOID    NotifyChannelConnected(void);
	VOID    ProcessHandleConfirm(GCCAppSapMsg * pMsg);

};
DECLARE_STANDARD_TYPES(CNmChannelData);

void CALLBACK NmGccMsgHandler(GCCAppSapMsg * pMsg);
void CALLBACK NmMcsMsgHandler(unsigned int uMsg, LPARAM lParam, PVOID pv);

// list management
POSITION AddNode(PVOID pv, COBLIST **ppList);
PVOID RemoveNodePos(POSITION * pPos, COBLIST *pList);
VOID  RemoveNode(PVOID pv, COBLIST * pList);

// Data Notification Structure
typedef struct {
	INmMember * pMember;
	LPBYTE   pb;
	ULONG    cb;
	ULONG    dwFlags;
} NMN_DATA_XFER;


// Global Routines
VOID FreeMemberIdList(COBLIST ** ppList);
HRESULT	OnNmDataSent(IUnknown *pConferenceNotify, void *pv, REFIID riid);
HRESULT OnNmDataReceived(IUnknown *pConferenceNotify, void *pv, REFIID riid);
HRESULT	OnAllocateHandleConfirm(IUnknown *pConferenceNotify, void *pv, REFIID riid);



#endif // _ICHNLDAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\ichnlvid.h ===
// File: ichnlvid.h

#ifndef _ICHNLVID_H_
#define _ICHNLVID_H_

// we have no notification on the channel "callback" that the state changed
// to determine if a/v is active we need to get both the video and the audio channel

class CNmChannelVideo : public INmChannelVideo,
	public DllRefCount, public CConnectionPointContainer
{
private:
	int			m_cMembers;
	BOOL		m_fIncoming;
	static CNmChannelVideo * m_pPreviewChannel;
	FRAMECONTEXT m_FrameContext;
	IMediaChannel *m_pMediaChannel;
	ICommChannel* m_pCommChannel;
	CVideoPump	m_VideoPump;
	MEDIA_FORMAT_ID m_MediaFormat;
	
	BOOL IsCaptureAvailable() { return m_VideoPump.IsCaptureAvailable(); }
public:
	CNmChannelVideo(BOOL fIncoming);
	~CNmChannelVideo();

	static CNmChannelVideo * CreatePreviewChannel();
	static CNmChannelVideo * CreateChannel(BOOL fIncoming);

	VOID OnConnected(IH323Endpoint * pConnection, ICommChannel *pIChannel)
        { m_VideoPump.OnConnected(pConnection, pIChannel); }
	VOID OnDisconnected() {	m_VideoPump.OnDisconnected(); }

	VOID CommChannelOpened(ICommChannel *pCommChannel);
	VOID CommChannelActive(ICommChannel *pCommChannel);
	VOID CommChannelError(DWORD dwStatus) { m_VideoPump.OnChannelError(); }
	VOID CommChannelRemotePaused(BOOL fPause) { OnStateChange(); }
	VOID CommChannelClosed();
	ICommChannel * GetCommChannel() { return m_pCommChannel; }
	ICommChannel * GetPreviewCommChannel() { return m_VideoPump.GetCommChannel();}
	VOID SetFormat(MEDIA_FORMAT_ID id) { m_MediaFormat = id;}
    BOOL IsSendEnabled() { return m_VideoPump.IsSendEnabled(); }
    BOOL IsPreviewEnabled() { return m_VideoPump.IsPreviewEnabled(); }

	VOID OnMemberAdded(CNmMember *pMember);
	VOID OnMemberRemoved(CNmMember *pMember);
	VOID OnMemberUpdated(CNmMember *pMember);

	IMediaChannel *GetMediaChannelInterface(void)
		{ if (m_pMediaChannel) m_pMediaChannel->AddRef(); return m_pMediaChannel;}

	VOID OnStateChange();
	VOID OnFrameAvailable();

    VOID Open();
    VOID Close();

	// IUnknown
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	// INmChannel
    STDMETHODIMP IsSameAs(INmChannel *pChannel);
    STDMETHODIMP IsActive();
    STDMETHODIMP SetActive(BOOL fActive);
    STDMETHODIMP GetConference(INmConference **ppConference);
    STDMETHODIMP GetInterface(IID *piid);
    STDMETHODIMP GetNmch(ULONG *puCh);
    STDMETHODIMP EnumMember(IEnumNmMember **ppEnum);
    STDMETHODIMP GetMemberCount(ULONG * puCount);

	// INmChannelVideo
    STDMETHODIMP IsIncoming(void);
    STDMETHODIMP GetState(NM_VIDEO_STATE *puState);
    STDMETHODIMP GetProperty(NM_VIDPROP uID, ULONG_PTR *puValue);
    STDMETHODIMP SetProperty(NM_VIDPROP uID, ULONG_PTR uValue);

	static VOID __stdcall FrameReadyCallback(DWORD_PTR dwMyThis);
};

#endif // _ICHNLVID_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\ichnlvid.cpp ===
// File: ichnlvid.cpp

#include "precomp.h"
#include "ichnlvid.h"

typedef struct
{
	DWORD *pdwCapDevIDs;
	LPTSTR pszCapDevNames;
	DWORD dwNumCapDev;
} ENUM_CAP_DEV;

static HRESULT OnNotifyStateChanged(IUnknown *pChannelNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyPropertyChanged(IUnknown *pChannelNotify, PVOID pv, REFIID riid);

static const IID * g_apiidCP[] =
{
	{&IID_INmChannelNotify},
	{&IID_INmChannelVideoNotify}
};

CNmChannelVideo * CNmChannelVideo::m_pPreviewChannel = NULL;


CNmChannelVideo::CNmChannelVideo(BOOL fIncoming) :
	CConnectionPointContainer(g_apiidCP, ARRAY_ELEMENTS(g_apiidCP)),
	m_VideoPump(!fIncoming /* fLocal */),
	m_cMembers	(0),
	m_fIncoming(fIncoming),
	m_pMediaChannel(NULL),
	m_pCommChannel(NULL),
	m_MediaFormat(INVALID_MEDIA_FORMAT)
{
	if (NULL != g_pH323UI)
	{
		IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();
		IMediaChannelBuilder * pMCProvider = g_pH323UI->GetStreamProvider();
		IVideoDevice *pVideoDevice=NULL;
		ASSERT((NULL !=  pH323CallControl) && (NULL != pMCProvider));
		pMCProvider->CreateMediaChannel(MCF_VIDEO | (fIncoming ? MCF_RECV : MCF_SEND), &m_pMediaChannel);
		if (m_pMediaChannel)
		{
			pMCProvider->QueryInterface(IID_IVideoDevice, (void**)&pVideoDevice);
			m_VideoPump.Initialize(pH323CallControl, m_pMediaChannel, pVideoDevice, (DWORD_PTR)this, FrameReadyCallback);
			pVideoDevice->Release();
		}
		pMCProvider->Release();
	}

	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CNmChannelVideo", this);
}

CNmChannelVideo::~CNmChannelVideo()
{
	if (!m_fIncoming)
	{
		// make sure we're no longer capturing
		m_VideoPump.EnableXfer(FALSE);
	}

	if (this == m_pPreviewChannel)
	{
		m_pPreviewChannel = NULL;
	}

	if (NULL != m_pCommChannel)
	{
		m_pCommChannel->Release();
	}
	if (NULL != m_pMediaChannel)
	{
		m_pMediaChannel->Release();
	}
	

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CNmChannelVideo", this);
}

VOID CNmChannelVideo::CommChannelOpened(ICommChannel *pCommChannel)
{
	ASSERT(NULL == m_pCommChannel);
	m_pCommChannel = pCommChannel;
	m_pCommChannel->AddRef();
}

VOID CNmChannelVideo::CommChannelActive(ICommChannel *pCommChannel)
{
	ASSERT(m_pCommChannel == pCommChannel);
	m_VideoPump.OnChannelOpened(pCommChannel);
	OnStateChange();
}

VOID CNmChannelVideo::CommChannelClosed()
{
	if (NULL != m_pCommChannel)
	{
		m_pCommChannel->Release();
		m_pCommChannel = NULL;

		m_VideoPump.OnChannelClosed();
		OnStateChange();
	}
}

CNmChannelVideo * CNmChannelVideo::CreateChannel(BOOL fIncoming)
{
	if (fIncoming)
	{
		return new CNmChannelVideo(TRUE /* fIncoming */);
	}
	else
	{
		if (NULL != m_pPreviewChannel)
		{
			m_pPreviewChannel->AddRef();
		}
		return m_pPreviewChannel;
	}
}

CNmChannelVideo * CNmChannelVideo::CreatePreviewChannel()
{
	ASSERT(NULL == m_pPreviewChannel);
	m_pPreviewChannel = new CNmChannelVideo(FALSE /* fIncoming */);
	if (NULL != m_pPreviewChannel)
	{
		if (!m_pPreviewChannel->IsCaptureAvailable())
		{
			delete m_pPreviewChannel;
			m_pPreviewChannel = NULL;
		}
	}
	return m_pPreviewChannel;
}

VOID CNmChannelVideo::OnMemberAdded(CNmMember *pMember)
{
	// Don't add to the channel if we already belong.
	if (0 != (pMember->GetNmchCaps() & NMCH_VIDEO))
	{
		return;
	}
	
	++m_cMembers;

	pMember->AddNmchCaps(NMCH_VIDEO);

	CConfObject *pco = ::GetConfObject();
	pco->OnMemberUpdated(pMember);

	NotifySink((INmMember *) pMember, OnNotifyChannelMemberAdded);
}

VOID CNmChannelVideo::OnMemberRemoved(CNmMember *pMember)
{
		// If member does not belong to this channel, don't remove it.
	if (0 == (pMember->GetNmchCaps() & NMCH_VIDEO))
	{
		return;
	}
	
	--m_cMembers;

	pMember->RemoveNmchCaps(NMCH_VIDEO);

	CConfObject *pco = ::GetConfObject();
	pco->OnMemberUpdated(pMember);

	NotifySink((INmMember *) pMember, OnNotifyChannelMemberRemoved);
}

VOID CNmChannelVideo::OnMemberUpdated(CNmMember *pMember)
{
	NotifySink((INmMember *) pMember, OnNotifyChannelMemberUpdated);
}

VOID CNmChannelVideo::OnStateChange()
{
	NM_VIDEO_STATE state;
	GetState(&state);
	NotifySink((PVOID) state, OnNotifyStateChanged);
}

VOID CNmChannelVideo::OnFrameAvailable()
{
	NotifySink((PVOID) NM_VIDPROP_FRAME, OnNotifyPropertyChanged);
}

VOID CNmChannelVideo::Open()
{
	ASSERT(m_MediaFormat !=  INVALID_MEDIA_FORMAT);
	m_VideoPump.Open(m_MediaFormat);
}

VOID CNmChannelVideo::Close()
{
	m_VideoPump.Close();
}


STDMETHODIMP_(ULONG) CNmChannelVideo::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CNmChannelVideo::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CNmChannelVideo::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmChannelVideo) || (riid == IID_INmChannel) || (riid == IID_IUnknown))
	{
		*ppv = (INmChannel *)this;
		DbgMsgApi("CNmChannelVideo::QueryInterface()");
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		DbgMsgApi("CNmChannelVideo::QueryInterface(): Returning IConnectionPointContainer.");
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		DbgMsgApi("CNmChannelVideo::QueryInterface(): Called on unknown interface.");
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

STDMETHODIMP CNmChannelVideo::IsSameAs(INmChannel *pChannel)
{
	return (((INmChannel *) this) == pChannel) ? S_OK : S_FALSE;
}

STDMETHODIMP CNmChannelVideo::IsActive()
{
	return (NULL != m_pCommChannel) ? S_OK : S_FALSE;
}

STDMETHODIMP CNmChannelVideo::SetActive(BOOL fActive)
{
	return E_FAIL;
}

STDMETHODIMP CNmChannelVideo::GetConference(INmConference **ppConference)
{
	return ::GetConference(ppConference);
}

STDMETHODIMP CNmChannelVideo::GetInterface(IID *piid)
{
	HRESULT hr = E_POINTER;

	if (NULL != piid)
	{
		*piid = IID_INmChannelVideo;
		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CNmChannelVideo::GetNmch(ULONG *puCh)
{
	HRESULT hr = E_POINTER;

	if (NULL != puCh)
	{
		*puCh = NMCH_VIDEO;
		hr = S_OK;
	}
	return hr;
}
	
STDMETHODIMP CNmChannelVideo::EnumMember(IEnumNmMember **ppEnum)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppEnum)
	{
		int cMembers = 0;
		COBLIST MemberList;
		COBLIST* pPartList = ::GetMemberList();
		if (NULL != pPartList)
		{
			POSITION pos = pPartList->GetHeadPosition();
			while (pos)
			{
				CNmMember * pMember = (CNmMember *) pPartList->GetNext(pos);
				ASSERT(NULL != pMember);

				if (NMCH_AUDIO & pMember->GetNmchCaps())
				{
					MemberList.AddTail(pMember);
					pMember->AddRef();
					cMembers++;
				}
			}
		}

		*ppEnum = new CEnumNmMember(&MemberList, cMembers);

		while (!MemberList.IsEmpty())
		{
			INmMember *pMember = (INmMember *) (CNmMember *) MemberList.RemoveHead();
			pMember->Release();
		}
		hr = (NULL != *ppEnum)? S_OK : E_OUTOFMEMORY;
	}
	return hr;
}

STDMETHODIMP CNmChannelVideo::GetMemberCount(ULONG * puCount)
{
	HRESULT hr = E_POINTER;
	if (NULL != puCount)
	{
		*puCount = m_cMembers;
		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CNmChannelVideo::IsIncoming(void)
{
	return m_fIncoming ? S_OK : S_FALSE;
}

STDMETHODIMP CNmChannelVideo::GetState(NM_VIDEO_STATE *puState)
{
	HRESULT hr = E_POINTER;
	if (NULL != puState)
	{
		*puState = m_VideoPump.GetState();
		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CNmChannelVideo::GetProperty(NM_VIDPROP uID, ULONG_PTR *puValue)
{
	HRESULT hr = S_OK;

	switch (uID)
	{
	case NM_VIDPROP_PAUSE:
		*puValue = m_VideoPump.IsPaused();
		break;
	case NM_VIDPROP_IMAGE_PREFERRED_SIZE:
		*puValue = m_VideoPump.GetFrameSize();
		break;
	case NM_VIDPROP_IMAGE_QUALITY:
		if (m_fIncoming)
		{
			*puValue = m_VideoPump.GetReceiveQuality();
		}
		break;
	case NM_VIDPROP_CAMERA_DIALOG:
		*puValue = 0;
		if (m_VideoPump.HasSourceDialog())
		{
			*puValue |= NM_VIDEO_SOURCE_DIALOG;
		}
		if (m_VideoPump.HasFormatDialog())
		{
			*puValue |= NM_VIDEO_FORMAT_DIALOG;
		}
		break;
	case NM_VIDPROP_IMAGE_SIZES:
		// get all the sizes, not just a size for one video format
		*puValue = m_VideoPump.GetFrameSizes(INVALID_MEDIA_FORMAT);
		break;
	case NM_VIDPROP_FRAME:
	{
		FRAMECONTEXT *pfc = (FRAMECONTEXT*) puValue;
		hr = m_VideoPump.GetFrame(pfc);
		break;
	}
	case NM_VIDPROP_NUM_CAPTURE_DEVS:
		*puValue = m_VideoPump.GetNumCapDev();
		break;
	case NM_VIDPROP_CAPTURE_DEV_ID:
		*puValue = m_VideoPump.GetCurrCapDevID();
		break;
	case NM_VIDPROP_MAX_CAPTURE_NAME:
		*puValue = m_VideoPump.GetMaxCapDevNameLen();
		break;
	case NM_VIDPROP_CAPTURE_LIST:
		{
			ENUM_CAP_DEV *pEnumCapDev = (ENUM_CAP_DEV *)puValue;

			if(m_VideoPump.EnumCapDev(pEnumCapDev->pdwCapDevIDs,
					pEnumCapDev->pszCapDevNames,
					pEnumCapDev->dwNumCapDev))
			{
			    hr = E_FAIL;
			}
			
			break;
		}
	default:
		hr = E_INVALIDARG;
		break;
	}

	return hr;
}

STDMETHODIMP CNmChannelVideo::SetProperty(NM_VIDPROP uID, ULONG_PTR uValue)
{
	HRESULT hr = S_OK;

	switch (uID)
	{
	case NM_VIDPROP_PAUSE:
		m_VideoPump.Pause(uValue);
		OnStateChange();
		break;
	case NM_VIDPROP_IMAGE_PREFERRED_SIZE:
		switch(uValue)
		{
		case NM_VIDEO_SMALL:
		case NM_VIDEO_MEDIUM:
		case NM_VIDEO_LARGE:
			m_VideoPump.SetFrameSize(uValue);
			break;
		default:
			hr = E_INVALIDARG;
			break;
		}
		break;
	case NM_VIDPROP_IMAGE_QUALITY:
		if /* ((uValue >= NM_VIDEO_MIN_QUALITY) || Always True */ ((uValue <= NM_VIDEO_MAX_QUALITY))
		{
			if (m_fIncoming)
			{
				m_VideoPump.SetReceiveQuality(uValue);
			}
		}
		else
		{
			hr = E_INVALIDARG;
		}
		break;
	case NM_VIDPROP_CAMERA_DIALOG:
		switch(uValue)
		{
		case NM_VIDEO_SOURCE_DIALOG:
			m_VideoPump.ShowSourceDialog();
			break;
		case NM_VIDEO_FORMAT_DIALOG:
			m_VideoPump.ShowFormatDialog();
			break;
		default:
			hr = E_INVALIDARG;
			break;
		}
		break;
	case NM_VIDPROP_SUSPEND_CAPTURE:
		m_VideoPump.SuspendCapture(uValue);
		break;
	case NM_VIDPROP_FRAME:
		hr = m_VideoPump.ReleaseFrame((FRAMECONTEXT *)uValue);
		break;
	case NM_VIDPROP_CAPTURE_DEV_ID:
		m_VideoPump.SetCurrCapDevID(uValue);
		break;

	default:
		hr = E_INVALIDARG;
		break;
	}
	return hr;
}

VOID __stdcall CNmChannelVideo::FrameReadyCallback(DWORD_PTR dwMyThis)
{
	CNmChannelVideo *pChannel = (CNmChannelVideo *)dwMyThis;
	if (NULL != pChannel)
	{
		pChannel->OnFrameAvailable();
	}
}


/*	O N  N O T I F Y  S T A T E  C H A N G E D	*/
/*-------------------------------------------------------------------------
	%%Function: OnNotifyStateChanged
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyStateChanged(IUnknown *pChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pChannelNotify);
	if (IID_INmChannelVideoNotify == riid)
	{
		((INmChannelVideoNotify*)pChannelNotify)->StateChanged((NM_VIDEO_STATE) (DWORD)((DWORD_PTR)pv));
	}
	return S_OK;
}

/*	O N  N O T I F Y  P R O P E R T Y  C H A N G E D  */
/*-------------------------------------------------------------------------
	%%Function: OnNotifyPropertyChanged
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyPropertyChanged(IUnknown *pChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pChannelNotify);
	if (IID_INmChannelVideoNotify == riid)
	{
		((INmChannelVideoNotify*)pChannelNotify)->PropertyChanged((DWORD)((DWORD_PTR)pv));
	}
	return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\iconf.cpp ===
// File: iconf.cpp

#include "precomp.h"
#include "version.h"
#include "ichnlaud.h"
#include "ichnlvid.h"
#include "ichnldat.h"
#include "rostinfo.h"
#include "imanager.h"
#include "isysinfo.h"
#include "imstream.h"
#include "medialst.h"
#include <tsecctrl.h>

typedef CEnumNmX<IEnumNmChannel, &IID_IEnumNmChannel, INmChannel, INmChannel> CEnumNmChannel;

// BUGBUG:
// This is defined as 128 because the RNC_ROSTER structure has the
// same limitation.  Investigate what the appropriate number is.
const int MAX_CALLER_NAME = 128;

static const WCHAR _szConferenceNameDefault[] = L"Personal Conference";


static HRESULT OnNotifyStateChanged(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyMemberAdded(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyMemberUpdated(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyMemberRemoved(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyChannelAdded(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyChannelUpdated(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyChannelRemoved(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyNmUI(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyStreamEvent(IUnknown *pConfNotify, PVOID pv, REFIID riid);


static DWORD PF_VER_FromDw(DWORD dw);
static DWORD PF_VER_FromUserData(ROSTER_DATA_HANDLE hUserData);

static const IID * g_apiidCP[] =
{
    {&IID_INmConferenceNotify},
    {&IID_INmConferenceNotify2}
};

struct StreamEventInfo
{
	INmChannel *pChannel;
	NM_STREAMEVENT uEventCode;
	UINT uSubCode;
};

class CUserDataOut
{
private:
	int m_nEntries;
	PUSERDATAINFO m_pudi;
	CRosterInfo m_ri;
	PBYTE m_pbSecurity;

public:
		CUserDataOut(BOOL fSecure, BSTR bstrUserString);
		~CUserDataOut()
		{
			delete [] m_pbSecurity;
			delete [] m_pudi;
		}

		PUSERDATAINFO Data() { return m_pudi; }
		int Entries() { return m_nEntries; }
};

CUserDataOut::CUserDataOut(BOOL fSecure, BSTR bstrUserString) :
	m_nEntries(0),
	m_pudi(NULL),
	m_pbSecurity(NULL)
{
	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	if (NULL != pOprahNCUI)
	{
		BOOL fULSNameValid = FALSE;

		ULONG cbSecurity = 0;
		ULONG cbUserString = 0;

		if (fULSNameValid = pOprahNCUI->GetULSName(&m_ri))
			m_nEntries++;

		DWORD dwResult;
		if ( fSecure )
		{
			if (cbSecurity = 
					pOprahNCUI->GetAuthenticatedName(&m_pbSecurity)) {
				m_nEntries++;
			}
		}
		
		if (bstrUserString)
		{
			if (cbUserString = SysStringByteLen(bstrUserString))
			{
				m_nEntries++;
			}
		}

		// only add the LocalNodeId to the call user data if H323 is enabled
		if (pOprahNCUI->IsH323Enabled())
		{
			m_nEntries++;
		}

		m_pudi = new USERDATAINFO[m_nEntries];

		if (m_pudi != NULL)
		{
			
			m_nEntries = 0;

			if (fULSNameValid)
			{
				m_pudi[m_nEntries].pData = NULL;
				m_pudi[m_nEntries].pGUID = (PGUID) &g_csguidRostInfo;
				m_ri.Save(&(m_pudi[m_nEntries].pData), &(m_pudi[m_nEntries].cbData));
				m_nEntries++;

			}

			if (cbSecurity > 0) {
				m_pudi[m_nEntries].pData = m_pbSecurity;
				m_pudi[m_nEntries].cbData = cbSecurity;
				m_pudi[m_nEntries].pGUID = (PGUID) &g_csguidSecurity;
				m_nEntries++;
			}

			if (cbUserString > 0) {
				m_pudi[m_nEntries].pData = bstrUserString;
				m_pudi[m_nEntries].cbData = cbUserString;
				m_pudi[m_nEntries].pGUID = (PGUID) &g_csguidUserString;
				m_nEntries++;
			}

			// only add the LocalNodeId to the call user data if H323 is enabled
			if (pOprahNCUI->IsH323Enabled())
			{
				m_pudi[m_nEntries].pData = &g_guidLocalNodeId;
				m_pudi[m_nEntries].cbData = sizeof(g_guidLocalNodeId);
				m_pudi[m_nEntries].pGUID = (PGUID) &g_csguidNodeIdTag;
				m_nEntries++;
			}
		}
	}
}

CConfObject::CConfObject() :
	CConnectionPointContainer(g_apiidCP, ARRAY_ELEMENTS(g_apiidCP)),
	m_hConf				(NULL),
	m_csState			(CS_UNINITIALIZED),
	m_fConferenceCreated(FALSE),
	m_bstrConfName      (NULL),
	m_bstrConfPassword  (NULL),
	m_pbConfHashedPassword    (NULL),
	m_cbConfHashedPassword	(0),
	m_fServerMode		(FALSE),
	m_uDataMembers		(0),
	m_uMembers			(0),
	m_uH323Endpoints	(0),
	m_ourNodeID			(0),
	m_pMemberLocal      (NULL),
	m_uGCCConferenceID	(0),
	m_pChannelAudioLocal(NULL),
	m_pChannelVideoLocal(NULL),
	m_pChannelAudioRemote(NULL),
	m_pChannelVideoRemote(NULL),
	m_fSecure			(FALSE),
    m_attendeePermissions (NM_PERMIT_ALL),
    m_maxParticipants   (-1),
	m_cRef				(1)
{
	DebugEntry(CConfObject::CConfObject);

	DebugExitVOID(CConfObject::CConfObject);
}

CConfObject::~CConfObject()
{
	DebugEntry(CConfObject::~CConfObject);

	// Empty the participant list:
	while (!m_MemberList.IsEmpty())
	{
		CNmMember * pMember = (CNmMember *) m_MemberList.RemoveHead();
		// Shouldn't have any NULL entries:
		ASSERT(pMember);
		pMember->Release();
	}

	_EraseDataChannelGUIDS();

	SysFreeString(m_bstrConfName);
	SysFreeString(m_bstrConfPassword);
	delete []m_pbConfHashedPassword;

	DebugExitVOID(CConfObject::~CConfObject);
}

VOID CConfObject::SetConfName(BSTR bstr)
{
	SysFreeString(m_bstrConfName);
	m_bstrConfName = SysAllocString(bstr);
}

VOID CConfObject::SetConfPassword(BSTR bstr)
{
	ASSERT (NULL == m_pbConfHashedPassword);
	SysFreeString(m_bstrConfPassword);
	m_bstrConfPassword = SysAllocString(bstr);
}

VOID CConfObject::SetConfHashedPassword(BSTR bstr)
{
	int cch = 0;

	ASSERT (NULL == m_bstrConfPassword);
	delete []m_pbConfHashedPassword;
        m_pbConfHashedPassword = NULL;
	if (NULL == bstr) return;
	cch = SysStringByteLen(bstr);
        m_pbConfHashedPassword = (PBYTE) new BYTE[cch];
        if (NULL == m_pbConfHashedPassword) {
		ERROR_OUT(("CConfObject::SetConfHashedPassword() - Out of merory."));
		return;
	}
	memcpy(m_pbConfHashedPassword, bstr, cch);
	m_cbConfHashedPassword = cch;
}

VOID CConfObject::SetConfSecurity(BOOL fSecure)
{
	NM_CONFERENCE_STATE NmState;

	m_fSecure = fSecure;

	// Force update of the status icon to reflect security
	GetState(&NmState);
	NotifySink((PVOID) NmState, OnNotifyStateChanged);
}


VOID CConfObject::SetConfAttendeePermissions(NM30_MTG_PERMISSIONS attendeePermissions)
{
    m_attendeePermissions = attendeePermissions;
}


VOID CConfObject::SetConfMaxParticipants(UINT maxParticipants)
{
    m_maxParticipants = maxParticipants;
}



HRESULT CConfObject::CreateConference(void)
{
	DebugEntry(CConfObject::CreateConference);
	HRESULT nsRet = E_FAIL;

	switch (m_csState)
	{
		case CS_UNINITIALIZED:
		case CS_TERMINATED:
		{
			if ((NULL == m_bstrConfName) || (0 == *m_bstrConfName))
			{
				m_bstrConfName = SysAllocString(_szConferenceNameDefault);
			}
			TRACE_OUT(("CConfObject:CreateConference [%ls]", m_bstrConfName));
			
			ASSERT(g_pNodeController);
			ASSERT(NULL == m_hConf);
			nsRet = g_pNodeController->CreateConference(
											m_bstrConfName,
											m_bstrConfPassword,
											m_pbConfHashedPassword,
											m_cbConfHashedPassword,
											m_fSecure,
											&m_hConf);
			
			if (0 == nsRet)
			{
				SetT120State(CS_CREATING);
			}
			else
			{
				m_hConf = NULL;
			}
			break;
		}

		default:
		{
			WARNING_OUT(("CConfObject: Can't create - bad state"));
			nsRet = E_FAIL;
		}
	}
	
	DebugExitINT(CConfObject::CreateConference, nsRet);
	return nsRet;
}

HRESULT CConfObject::JoinConference(    LPCWSTR pcwszConferenceName,
										LPCWSTR	pcwszPassword,
									 	LPCSTR	pcszAddress,
										BSTR bstrUserString,
										BOOL fRetry)
{
	DebugEntry(CConfObject::JoinConference);
	HRESULT nsRet = E_FAIL;



	switch (m_csState)
	{
		case CS_COMING_UP:
		{
			if (!fRetry)
			{
				break;
			}
			// fall through if this is another attempt to join
		}
		case CS_UNINITIALIZED:
		case CS_TERMINATED:
		{
			TRACE_OUT(("CConfObject: Joining conference..."));
			
			CUserDataOut userData(m_fSecure, bstrUserString);

			ASSERT(g_pNodeController);
			nsRet = g_pNodeController->JoinConference(pcwszConferenceName,
														pcwszPassword,
														pcszAddress,
														m_fSecure,
														userData.Data(),
														userData.Entries(),
														&m_hConf);
			
			if (0 == nsRet)
			{
				SetT120State(CS_COMING_UP);
			}
			else
			{
				m_hConf = NULL;
			}
			break;
		}

		case CS_GOING_DOWN:
		default:
		{
			WARNING_OUT(("CConfObject: Can't join - bad state"));
			// BUGBUG: define return values
			nsRet = S_FALSE;
		}
	}
	
	DebugExitINT(CConfObject::JoinConference, nsRet);

	return nsRet;
}



HRESULT CConfObject::InviteConference(	LPCSTR	Address,
										BSTR bstrUserString,
										REQUEST_HANDLE *phRequest )
{
	DebugEntry(CConfObject::InviteConference);
	HRESULT nsRet = E_FAIL;
	ASSERT(phRequest);

	switch (m_csState)
	{
		case CS_RUNNING:
		{
			TRACE_OUT(("CConfObject: Inviting conference..."));
			
			CUserDataOut userData(m_fSecure, bstrUserString);

			ASSERT(g_pNodeController);
			ASSERT(m_hConf);
			m_hConf->SetSecurity(m_fSecure);
			nsRet = m_hConf->Invite(Address,
									userData.Data(),
									userData.Entries(),
									phRequest);
			
			break;
		}

		default:
		{
			WARNING_OUT(("CConfObject: Can't invite - bad state"));
			nsRet = E_FAIL;
		}
	}
	
	DebugExitINT(CConfObject::InviteConference, nsRet);
	return nsRet;
}
	
HRESULT CConfObject::LeaveConference(BOOL fForceLeave)
{
	DebugEntry(CConfObject::LeaveConference);
	HRESULT nsRet = E_FAIL;
	REQUEST_HANDLE hReq = NULL;

	switch (m_csState)
	{
		case CS_GOING_DOWN:
		{
			// we're already going down
			nsRet = S_OK;
			break;
		}
	
		case CS_COMING_UP:
		case CS_RUNNING:
		{
			if (FALSE == fForceLeave)
			{
				COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
				if (NULL != pOprahNCUI)
				{
					int nNodes = pOprahNCUI->GetOutgoingCallCount();

					if (m_fServerMode || (nNodes > 1) || (m_uDataMembers > 1))
					{
						// We are either in the process of calling another node
						// or we have other people in our conference roster
						TRACE_OUT(("CConfObject: Not leaving (there are other nodes)"));
						break;
					}
				}
			}
			
			TRACE_OUT(("CConfObject: Leaving conference..."));
			
			ASSERT(g_pNodeController);
			ASSERT(m_hConf);
			
			SetT120State(CS_GOING_DOWN);
			nsRet = m_hConf->Leave();
			break;
		}

		default:
		{
			WARNING_OUT(("CConfObject: Can't leave - bad state"));
			break;
		}
	}
	
	DebugExitINT(CConfObject::LeaveConference, nsRet);
	return nsRet;
}
	

BOOL CConfObject::OnT120Invite(CONF_HANDLE hConference, BOOL fSecure)
{
	DebugEntry(CConfObject::OnT120Invite);

	BOOL bRet = FALSE;

	switch (m_csState)
	{
		case CS_UNINITIALIZED:
		case CS_TERMINATED:
		{
			TRACE_OUT(("CConfObject: Accepting a conference invitation..."));
			
			ASSERT(g_pNodeController);
			ASSERT(NULL == m_hConf);
			m_hConf = hConference;

            m_fSecure = fSecure;
			hConference->SetSecurity(m_fSecure);

			// WORKITEM need to issue INmManagerNotify::ConferenceCreated()
			SetT120State(CS_COMING_UP);

			bRet = TRUE;
			break;
		}

		default:
		{
			WARNING_OUT(("CConfObject: Can't accept invite - bad state"));
		}
	}
	
	DebugExitBOOL(CConfObject::OnT120Invite, bRet);
	return bRet;
}

BOOL CConfObject::OnRosterChanged(PNC_ROSTER pRoster)
{
	DebugEntry(CConfObject::OnRosterChanged);

	BOOL bRet = TRUE;
	int i;

	// REVIEW: Could these be done more efficiently?
	
	if (NULL != pRoster)
	{
#ifdef DEBUG
		TRACE_OUT(("Data Roster Dump: for conference ID = %d", pRoster->uConferenceID));
		for (i = 0; i < (int) pRoster->uNumNodes; i++)
		{
			TRACE_OUT((	"\tID:%d\tName:%ls", 
						pRoster->nodes[i].uNodeID,
						pRoster->nodes[i].pwszNodeName));

		    ASSERT(g_pNodeController);
			UINT cbData;
			PVOID pData;
			if (NOERROR == g_pNodeController->GetUserData(
									pRoster->nodes[i].hUserData, 
									(GUID*) &g_csguidRostInfo, 
									&cbData, 
									&pData))
			{
				CRosterInfo ri;
				ri.Load(pData);
				ri.Dump();
			}
		}
#endif // DEBUG

		UINT nExistingParts = 0;
		// Allocate an array of markers:
		UINT uRosterNodes = pRoster->uNumNodes;
		LPBOOL pMarkArray = new BOOL[uRosterNodes];

		m_ourNodeID = pRoster->uLocalNodeID;
		m_uGCCConferenceID = pRoster->uConferenceID;

		if (NULL != pRoster->pwszConferenceName)
		{
			SysFreeString(m_bstrConfName);
			m_bstrConfName = SysAllocString(pRoster->pwszConferenceName);
		}
		
		if (NULL != pMarkArray)
		{
			// Zero out the array:
            for (UINT iNode = 0; iNode < uRosterNodes; iNode++)
            {
                pMarkArray[iNode] = FALSE;
            }
			
			// For all participants still in the roster,
			//   clear out the reserved flags and
			//   copy in new UserInfo
			POSITION pos = m_MemberList.GetHeadPosition();
            // lous: Preserve previous pos so we can check list integrity
            POSITION prevpos = pos;
			while (NULL != pos)
			{
				CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
				ASSERT(pMember);
				pMember->RemovePf(PF_RESERVED);
				UINT uNodeID = INVALID_GCCID;
				if (PF_T120 & pMember->GetDwFlags())
				{
					uNodeID = pMember->GetGCCID();
				}
				
				for (UINT uNode = 0; uNode < uRosterNodes; uNode++)
				{
					if (uNodeID == pRoster->nodes[uNode].uNodeID)
					{
						nExistingParts++;
						pMarkArray[uNode] = TRUE;	// mark this node as "existing member"
						ResetDataMember(pMember, pRoster->nodes[uNode].hUserData);
                        // lou: Check pos to make sure we didn't just wipe out the end of
                        // the list in ResetDataMember.
                        if (NULL == prevpos->pNext)
                        {
                            pos = NULL;
                        }
						break;
					}
				}
                // lou: Store previous pos so we can check list integrity.
                prevpos = pos;
			}
			
			RemoveOldDataMembers(m_uDataMembers - nExistingParts);

			if (pRoster->uNumNodes > nExistingParts)
			{
#ifdef _DEBUG
				UINT nAdded = 0;
#endif // _DEBUG
				// At least one participant joined:
				// find the new participant(s)
				for (UINT uNode = 0; uNode < uRosterNodes; uNode++)
				{
					if (FALSE == pMarkArray[uNode]) 	// a new participant?
					{
						BOOL fLocal = FALSE;
						CNmMember * pMember = NULL;
						PVOID pvUserInfo;
						UINT cbUserInfo;
						ASSERT(g_pNodeController);
						if (NOERROR != g_pNodeController->GetUserData(
												pRoster->nodes[uNode].hUserData, 
												(GUID*) &g_csguidRostInfo, 
												&cbUserInfo, 
												&pvUserInfo))
						{
							pvUserInfo = NULL;
							cbUserInfo = 0;
						}
						
						
						UINT uCaps;
						UINT cbCaps;
						PVOID pvCaps;
						if (NOERROR != g_pNodeController->GetUserData(
												pRoster->nodes[uNode].hUserData, 
												(GUID*) &g_csguidRosterCaps, 
												&cbCaps, 
												&pvCaps))
						{
							uCaps = 0;
						}
						else
						{
							ASSERT(pvCaps && (sizeof(uCaps) == cbCaps));
							uCaps = *((PUINT)pvCaps);
						}

						PGUID pguidNodeId;
						UINT cbNodeId;
						if (NOERROR != g_pNodeController->GetUserData(
												pRoster->nodes[uNode].hUserData, 
												(GUID*) &g_csguidNodeIdTag, 
												&cbNodeId,
												(PVOID*) &pguidNodeId))
						{
							pguidNodeId = NULL;
						}
						else
						{
							if (sizeof(GUID) != cbNodeId)
							{
								pguidNodeId = NULL;
							}
						}

						if (m_ourNodeID == pRoster->nodes[uNode].uNodeID)
						{
							fLocal = TRUE;
						}
			
						REFGUID rguidNodeId = pguidNodeId ? *pguidNodeId : GUID_NULL;

						if (fLocal)
						{
							pMember = GetLocalMember();
						}
						else
						{
							pMember = MatchDataToH323Member(rguidNodeId, pRoster->nodes[uNode].uNodeID, pvUserInfo);
						}

						if(pMember)
						{
								AddDataToH323Member(pMember,
													pvUserInfo,
													cbUserInfo,
													uCaps,
													&pRoster->nodes[uNode]);
#ifdef _DEBUG
								nAdded++; // a data participant was effectively added
#endif // _DEBUG
						}
						else
						{
							pMember = CreateDataMember(
												fLocal,
												rguidNodeId,
												pvUserInfo,
												cbUserInfo,
												uCaps,
												&pRoster->nodes[uNode]);
#ifdef _DEBUG
							if (NULL != pMember)
							{
								nAdded++;
							}
#endif // _DEBUG
							AddMember(pMember, NULL);
						}
					}
				}
				// Validate that we did the right thing:
				ASSERT(nAdded == (uRosterNodes - nExistingParts));
			}
			delete [] pMarkArray;
			pMarkArray = NULL;
		}
		else
		{
			ERROR_OUT(("Couldn't allocate pMarkArray - no roster diff done"));
		}

		UINT uPrevDataMembers = m_uDataMembers;
		
		m_uDataMembers = pRoster->uNumNodes;

		// Check to decide if we should auto-terminate here..
		if ((1 == pRoster->uNumNodes) &&
			(uPrevDataMembers > 1) &&
			(1 == m_uDataMembers))
		{
			if (!m_fServerMode)
			{
				LeaveConference(FALSE); // don't force (we could be inviting)
			}
		}	
	}
	else
	{
		WARNING_OUT(("NULL pRoster passed to CConfObject::OnRosterChanged!"));
	}

	DebugExitBOOL(CConfObject::OnRosterChanged, bRet);
	return bRet;
}

VOID CConfObject::AddMember(CNmMember * pMember, IH323Endpoint * pConnection)
{
	DebugEntry(CConfObject::AddMember);

	if (NULL == pMember)
	{
		ERROR_OUT(("AddMember - null member!"));
		return;
	}

	NM_CONFERENCE_STATE oldNmState, newNmState;
	GetState(&oldNmState);

	m_MemberList.AddTail(pMember);
	if(pConnection)
	{
		pMember->AddH323Endpoint(pConnection);
		++m_uH323Endpoints;

		CheckState(oldNmState);
		GetState(&oldNmState);
	}
	m_uMembers++;

	CheckState(oldNmState);

	NotifySink((INmMember *) pMember, OnNotifyMemberAdded);

	DebugExitVOID(CConfObject::AddMember);
}

VOID CConfObject::RemoveMember(POSITION pos)
{
	DebugEntry(CConfObject::RemoveMember);

	NM_CONFERENCE_STATE oldNmState, newNmState;

	GetState(&oldNmState);

	CNmMember * pMember = (CNmMember *) m_MemberList.RemoveAt(pos);
	--m_uMembers;

	if (pMember->FLocal())
	{
		// this is the local node:
		m_pMemberLocal = NULL;
	}

	IH323Endpoint *pConnection = pMember->GetH323Endpoint();
	if(pConnection)
	{
		pMember->DeleteH323Endpoint(pConnection);
		--m_uH323Endpoints;
	}

	NotifySink((INmMember *) pMember, OnNotifyMemberRemoved);
	pMember->Release();

	CheckState(oldNmState);

	DebugExitVOID(CConfObject::RemoveMember);
}

BOOL CConfObject::OnConferenceEnded()
{
	DebugEntry(CConfObject::OnConferenceEnded);
	BOOL bRet = TRUE;

	switch (m_csState)
	{
		case CS_GOING_DOWN:
		{
			TRACE_OUT(("ConfEnded received (from CS_GOING_DOWN)"));
			break;
		}

		case CS_RUNNING:
		{
			TRACE_OUT(("ConfEnded received (from CS_RUNNING)"));
			break;
		}

		case CS_COMING_UP:
		{
			TRACE_OUT(("ConfEnded received (from CS_COMING_UP)"));
			break;
		}

		default:
		{
			WARNING_OUT(("ConfEnded received (UNEXPECTED)"));
		}
	}

	if (NULL != m_hConf)
	{
		m_hConf->ReleaseInterface();
		m_hConf = NULL;
	}
	SetT120State(CS_TERMINATED);

	TRACE_OUT(("OnConferenceEnded(), num participants is %d", m_uMembers));

	// Empty the participant list:
	NC_ROSTER FakeRoster;
	ClearStruct(&FakeRoster);
	FakeRoster.uConferenceID = m_uGCCConferenceID;
	OnRosterChanged(&FakeRoster);

	ASSERT(0 == m_ourNodeID);
	ASSERT(0 == m_uDataMembers);

	// Reset member variables that pertain to a conference
	m_uGCCConferenceID = 0;
	m_fServerMode = FALSE;
    m_attendeePermissions = NM_PERMIT_ALL;
    m_maxParticipants = (UINT)-1;

	SysFreeString(m_bstrConfName);
	m_bstrConfName = NULL;
	SysFreeString(m_bstrConfPassword);
	m_bstrConfPassword = NULL;

	LeaveH323(TRUE /* fKeepAV */);
	
	DebugExitBOOL(CConfObject::OnConferenceEnded, bRet);
	return bRet;
}

BOOL CConfObject::OnConferenceStarted(CONF_HANDLE hConf, HRESULT hResult)
{
	DebugEntry(CConfObject::OnConferenceStarted);
	BOOL bRet = TRUE;

	ASSERT(hConf == m_hConf);

	switch (m_csState)
	{
		case CS_CREATING:
		case CS_COMING_UP:
		{
			switch(hResult)
			{
				case S_OK:
					TRACE_OUT(("ConfStarted received -> now running"));
					SetT120State(CS_RUNNING);
					break;
				case UI_RC_INVALID_PASSWORD:
					// nop, don't mess with state
					// the conference is still coming up
					// the incoming call handler will deal with this
					break;
				default:
					SetT120State(CS_GOING_DOWN);
					TRACE_OUT(("ConfStarted failed"));
					break;
			}
			break;
		}

		default:
		{
			WARNING_OUT(("OnConferenceStarted received (UNEXPECTED)"));
			break;
		}
	}

	DebugExitBOOL(CConfObject::OnConferenceStarted, bRet);
	return bRet;
}

VOID CConfObject::OnH323ChannelChange(DWORD dwFlags, BOOL fIncoming, BOOL fOpen, ICommChannel *pIChannel)
{
	CConfObject *pco = ::GetConfObject();
	IEnumNmMember *pEnumMember = NULL;
	ULONG cFetched;
	INmChannel *pINmChannel;
	DWORD dwMediaFlag;
	HRESULT hr;
	// find the INmChannel instance that would be associated with the
	// comm channel (pIChannel).  

	// note the current issues with making this work for any number/type of
	// channels
	//
	//	- CConfObject has 4 hardcoded instances of send/receive audio/video
	//	- Those instances aren't yet associated with the ICommChannel instance
	//		other than by media type and direction.  For receive, new instances
	//		could even be created dynamically as rx channel requests are 
	//		processed.  For send, need to change CNmChannelAudio
	//		and CNmChannelVideo to keep a reference to ICommChannel before 
	//		the channel open attempt occurs
	//	- There is no base interface common to CNmChannelAudio
	//		and CNmChannelVideo
	//	- There is no internal interface on CNmMember
	//	
	
	CNmMember *pMember = NULL;
	INmMember *pIMember = NULL;

	if (PF_MEDIA_AUDIO & dwFlags)
	{
		dwMediaFlag = PF_MEDIA_AUDIO;
		CNmChannelAudio *pChannelAudio;
		if (fIncoming)
		{
			pChannelAudio = m_pChannelAudioRemote;
		}
		else
		{
			pChannelAudio = m_pChannelAudioLocal;
		}
		if (NULL != pChannelAudio)
		{
			pINmChannel = (INmChannel *) pChannelAudio;
			if (fOpen)
			{
				pChannelAudio->CommChannelOpened(pIChannel);
			}
			else
			{
				pChannelAudio->CommChannelClosed();
			}
			
			// for every member associated with this channel, do the
			// member update thing
			
			hr = pChannelAudio->EnumMember(&pEnumMember);
			if(pEnumMember)
			{
				ASSERT(hr == S_OK);

				while(hr == S_OK)
				{
					pIMember = NULL;
	           		hr = pEnumMember->Next(1, &pIMember, &cFetched);
     				if(!pIMember)
     				{
     					break;
     				}
     				else
					{
						ASSERT(hr == S_OK);
						// this cast is ugly, but necessary because there is no
						// real internal interface of CNmMember to query for.
						// When in Rome........
						pMember = (CNmMember *)pIMember;

						if (fOpen)
						{
							pMember->AddPf(dwMediaFlag);
						}
						else
						{
							pMember->RemovePf(dwMediaFlag);
						}
						// ugly - OnMemberUpdated() should be a base interface
						// method so that this code didn't have to be copied
						// for the video case
						pChannelAudio->OnMemberUpdated(pMember);
						pco->OnMemberUpdated(pMember);

						if (pMember->FLocal() && (NULL != m_hConf) && (CS_RUNNING == m_csState))
						{
//							m_hConf->UpdateUserData();
						}
						pMember->Release();
					}
				}
				pEnumMember->Release();
			}
			NotifySink(pINmChannel, OnNotifyChannelUpdated);
		}
	}
	else if (PF_MEDIA_VIDEO & dwFlags)
	{
		dwMediaFlag = PF_MEDIA_VIDEO;
		CNmChannelVideo *pChannelVideo;
		if (fIncoming)
		{
			pChannelVideo = m_pChannelVideoRemote;
		}
		else
		{
			pChannelVideo = m_pChannelVideoLocal;
		}
		if (NULL != pChannelVideo)
		{
			pINmChannel = (INmChannel *) pChannelVideo;
			if (fOpen)
			{
				pChannelVideo->CommChannelOpened(pIChannel);
			}
			else
			{
				pChannelVideo->CommChannelClosed();
			}

			// for every member associated with this channel, do the
			// member update thing
		
			hr = pChannelVideo->EnumMember(&pEnumMember);
			if(pEnumMember)
			{
				ASSERT(hr == S_OK);
				while(hr == S_OK)
				{
					pIMember = NULL;
	           		hr = pEnumMember->Next(1, &pIMember, &cFetched);
     				if(!pIMember)
     				{
     					break;
     				}
     				else
					{
						ASSERT(hr == S_OK);
						// this cast is ugly, but necessary because there is no
						// real internal interface of CNmMember to query for.
						// When in Rome........
						pMember = (CNmMember *)pIMember;

						if (fOpen)
						{
							pMember->AddPf(dwMediaFlag);
						}
						else
						{
							pMember->RemovePf(dwMediaFlag);
						}
						// ugly - OnMemberUpdated() should be a base interface
						// method so that this code didn't have to be copied
						// from the audio case
						pChannelVideo->OnMemberUpdated(pMember);
						pco->OnMemberUpdated(pMember);

						if (pMember->FLocal() && (NULL != m_hConf) && (CS_RUNNING == m_csState))
						{
//							m_hConf->UpdateUserData();
						}
						pMember->Release();
					}
				}
				pEnumMember->Release();
			}
			NotifySink(pINmChannel, OnNotifyChannelUpdated);
		
		}
	}
	else
		ASSERT(0);
}


VOID CConfObject::OnAudioChannelStatus(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus)
{
	BOOL bIncoming = (pIChannel->IsSendChannel())? FALSE:TRUE; 
	CNmChannelAudio *pChannelAudio;
	switch (dwStatus)
	{
	case CHANNEL_ACTIVE:
		if (bIncoming)
		{
			pChannelAudio = m_pChannelAudioRemote;
		}
		else
		{
			pChannelAudio = m_pChannelAudioLocal;
		}
		if (NULL != pChannelAudio)
		{
			pChannelAudio->CommChannelActive(pIChannel);
		}
		break;
	case CHANNEL_OPEN:
		OnH323ChannelChange(PF_MEDIA_AUDIO, bIncoming, TRUE, pIChannel);
		break;
	case CHANNEL_CLOSED:
		OnH323ChannelChange(PF_MEDIA_AUDIO, bIncoming, FALSE, pIChannel);
		break;
	default:
		return;
	}
}

VOID CConfObject::OnVideoChannelStatus(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus)
{
	BOOL bIncoming = (pIChannel->IsSendChannel())? FALSE:TRUE; 
	CNmChannelVideo *pChannelVideo;
	switch (dwStatus)
	{
	case CHANNEL_ACTIVE:
		if (bIncoming)
		{
			pChannelVideo = m_pChannelVideoRemote;
		}
		else
		{
			pChannelVideo = m_pChannelVideoLocal;
		}
		if (NULL != pChannelVideo)
		{
			pChannelVideo->CommChannelActive(pIChannel);
		}
		break;

	case CHANNEL_OPEN:
		OnH323ChannelChange(PF_MEDIA_VIDEO, bIncoming, TRUE, pIChannel);
		break;
	case CHANNEL_CLOSED:
		OnH323ChannelChange(PF_MEDIA_VIDEO, bIncoming, FALSE, pIChannel);
		break;
	case CHANNEL_REJECTED:
	case CHANNEL_OPEN_ERROR:
	case CHANNEL_NO_CAPABILITY:
		if(bIncoming)
		{
			if (NULL != m_pChannelVideoRemote)
			{
				m_pChannelVideoRemote->CommChannelError(dwStatus);
			}
		}
		else
		{
			if (NULL != m_pChannelVideoLocal)
			{
				m_pChannelVideoLocal->CommChannelError(dwStatus);
			}
		}
		break;

	case CHANNEL_REMOTE_PAUSE_ON:
	case CHANNEL_REMOTE_PAUSE_OFF:
		if(bIncoming)
		{
			if (NULL != m_pChannelVideoRemote)
			{
				BOOL fPause = CHANNEL_REMOTE_PAUSE_ON == dwStatus;
				m_pChannelVideoRemote->CommChannelRemotePaused(fPause);
			}
		}
		else
		{
			if (NULL != m_pChannelVideoLocal)
			{
				BOOL fPause = CHANNEL_REMOTE_PAUSE_ON == dwStatus;
				m_pChannelVideoLocal->CommChannelRemotePaused(fPause);
			}
		}
		break;
	default:
		break;
	}
}

VOID CConfObject::CreateMember(IH323Endpoint * pConnection, REFGUID rguidNode, UINT uNodeID)
{
	ASSERT(g_pH323UI);
	WCHAR wszRemoteName[MAX_CALLER_NAME];
	if (FAILED(pConnection->GetRemoteUserName(wszRemoteName, MAX_CALLER_NAME)))
	{
		ERROR_OUT(("GetRemoteUserName() failed!"));
		return;
	}
	
	// Add the local member
	CNmMember * pMemberLocal = GetLocalMember();
	if (NULL != pMemberLocal)
	{
		AddH323ToDataMember(pMemberLocal, NULL);
	}
	else
	{
		// We aren't already in the list, so add ourselves here:
		BSTR bstrName = NULL;

		COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
		if (NULL != pOprahNCUI)
		{
			bstrName = pOprahNCUI->GetUserName();
		}
		pMemberLocal = new CNmMember(bstrName, H323_GCCID_LOCAL,
			PF_H323 | PF_LOCAL_NODE | PF_VER_CURRENT, 0, g_guidLocalNodeId, NULL, 0);
		if (NULL != pMemberLocal)
		{
			AddMember(pMemberLocal, NULL);

			ASSERT(NULL == m_pMemberLocal);
			m_pMemberLocal = pMemberLocal;
		}
	}

	// Add the remote member
	CNmMember * pMemberRemote = MatchH323ToDataMembers(rguidNode, pConnection);
	if (NULL != pMemberRemote)
	{
		AddH323ToDataMember(pMemberRemote, pConnection);
	}
	else
	{
		// BUGBUG: A version number should be added here, if possible
		pMemberRemote = new CNmMember(	wszRemoteName,
										uNodeID,
										PF_H323,
										0,
										rguidNode,
										NULL,
										0);
		if (NULL != pMemberRemote)
		{
			AddMember(pMemberRemote, pConnection);
		}
	}

	if (NULL != m_hConf && (CS_RUNNING == m_csState))
	{
//			m_hConf->UpdateUserData();
	}
}


VOID CConfObject::OnH323Connected(IH323Endpoint * pConnection, DWORD dwFlags, BOOL fAddMember,  REFGUID rguidNode)
{
	HRESULT hr;
	UINT ui;
	ASSERT(NULL != pConnection);
	// alloc and initialize media guids.

	CMediaList MediaList;

	GUID MediaType;
	BOOL fEnableMedia;

	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	if (NULL != pOprahNCUI)
	{
		MediaType = MEDIA_TYPE_H323VIDEO;
		fEnableMedia = pOprahNCUI->IsSendVideoAllowed() && (dwFlags & CRPCF_VIDEO);
		MediaList.EnableMedia(&MediaType, TRUE /*send */, fEnableMedia);
		fEnableMedia = pOprahNCUI->IsReceiveVideoAllowed() && (dwFlags & CRPCF_VIDEO);
		MediaList.EnableMedia(&MediaType, FALSE /* recv, NOT send */, fEnableMedia);
		
		MediaType = MEDIA_TYPE_H323AUDIO;
		fEnableMedia = pOprahNCUI->IsAudioAllowed() && (dwFlags & CRPCF_AUDIO);
		MediaList.EnableMedia(&MediaType, TRUE /* send */, fEnableMedia);
		MediaList.EnableMedia(&MediaType, FALSE /* recv, NOT send */, fEnableMedia);

		MediaType = MEDIA_TYPE_H323_T120;
		fEnableMedia = (dwFlags & CRPCF_DATA);
		MediaList.EnableMedia(&MediaType, TRUE /* send */, fEnableMedia);
		MediaList.EnableMedia(&MediaType, FALSE /* recv, NOT send */, fEnableMedia);
	}

	hr = MediaList.ResolveSendFormats(pConnection);
	
	if(!(SUCCEEDED(hr)))
	{
		// Well, there is no way we can ever open any send channel.  But It is a
		// product requirement to keep the connection up just in case the other
		// endpoint(s) ever wants to open a send video channel to this endpoint.
	}

	ICommChannel* pChannelT120 = CreateT120Channel(pConnection, &MediaList);
	CreateAVChannels(pConnection, &MediaList);
	if (pChannelT120)
	{
		OpenT120Channel(pConnection, &MediaList, pChannelT120);
		// no need to hold onto the T120 channel
		pChannelT120->Release();
	}
	OpenAVChannels(pConnection, &MediaList);


	if (fAddMember)
	{
		CreateMember(pConnection, rguidNode, H323_GCCID_REMOTE);

		if (dwFlags & (CRPCF_AUDIO | CRPCF_VIDEO))
		{
			CNmMember* pMemberLocal = GetLocalMember();
			if (pMemberLocal)
			{
				AddMemberToAVChannels(pMemberLocal);
			}

			CNmMember* pMemberRemote = PMemberFromH323Endpoint(pConnection);
			if (pMemberRemote)
			{
				AddMemberToAVChannels(pMemberRemote);
			}
		}

	}
}

VOID CConfObject::OnH323Disconnected(IH323Endpoint * pConnection, BOOL fHasAV)
{
	DebugEntry(CConfObject::OnH323Disconnected);

	POSITION pos = m_MemberList.GetHeadPosition();
	while (NULL != pos)
	{
		POSITION oldpos = pos;
		CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
		ASSERT(pMember);
		if (pMember->GetH323Endpoint() == pConnection)
		{
			if (fHasAV)
			{
				RemoveMemberFromAVChannels(pMember);
			}

			if (0 == (PF_T120 & pMember->GetDwFlags()))
			{
				// This is an H323 only participant, so remove now:
				RemoveMember(oldpos);
			}
			else
			{
				RemoveH323FromDataMember(pMember, pConnection);
			}
		}
	}

	CNmMember *pLocalMember = GetLocalMember();
	if (pLocalMember)
	{
		if (fHasAV)
		{
			RemoveMemberFromAVChannels(pLocalMember);
		}

		if (0 == m_uH323Endpoints)
		{
			if (0 == (PF_T120 & pLocalMember->GetDwFlags()))
			{
				// This is an H323 only participant, so remove now:
				RemoveMember(pLocalMember);
			}
			else
			{
				RemoveH323FromDataMember(pLocalMember, NULL);
			}
		}
	}

	if (fHasAV)
	{
		DestroyAVChannels();
	}

#ifdef REPORT_ALL_ERRORS
	DWORD dwSummary;
	dwSummary = pConnection->GetSummaryCode()
	if(CCR_REMOTE_MEDIA_ERROR == dwSummary)
	{
		::PostConfMsgBox(IDS_REMOTE_MEDIA_ERROR);
	}
#endif

	if ((NULL != m_hConf) && (CS_RUNNING == m_csState))
	{
//		m_hConf->UpdateUserData();
	}

	DebugExitVOID(CConfObject::OnH323Disconnected);
}


VOID CConfObject::OnT120Connected(IH323Endpoint * pConnection, UINT uNodeID)
{
	CNmMember *pMember = PMemberFromH323Endpoint(pConnection);
	if (pMember)
	{
		// save away the GCC id so that we can match this up when the member is added
		pMember->SetGCCID(uNodeID);
	}
	else
	{
		CreateMember(pConnection, GUID_NULL, uNodeID);
	}
}

//	StoreAndVerifyMemberUserData
//
//	Processes a member's user data and stores them for the GetUserData API call.
//	If security data is among the user data, verification against the transport-level
//  credentials is performed.

//  Returns FALSE if security verification fails, TRUE otherwise.

BOOL StoreAndVerifyMemberUserData(CNmMember * pMember, ROSTER_DATA_HANDLE hData)
{
	BOOL rc = TRUE;
	BOOL fUserDataSet;

 	GCCNodeRecord * pRosterEntry = (GCCNodeRecord *)hData;
	GCCUserData ** ppUserData = pRosterEntry->user_data_list;
	for (int i = 0; i < pRosterEntry->number_of_user_data_members; i++)
	{

		fUserDataSet = FALSE;

/* Always False		if ((int)ppUserData[i]->octet_string->length - sizeof(GUID) < 0)
		{
			WARNING_OUT(("StoreAndVerifyMemberUserData: bad user data"));
			rc = FALSE;
			break;
		}*/
		if (!pMember->FLocal() && 0 == CompareGuid((GUID *)ppUserData[i]->octet_string->value,(GUID *)&g_csguidSecurity))
		{
			PBYTE pb = NULL;
			ULONG cb = 0;
			if (pMember->GetSecurityData(&pb,&cb))
			{

				//
				// Check to make sure that the current user data matches
				// the transport security data.
				//

				if (memcmp(pb,ppUserData[i]->octet_string->value + sizeof(GUID),
					ppUserData[i]->octet_string->length - sizeof(GUID) - 1))
				{

					//
					// This should NOT happen. Either there is a bug
					// in the security code (credentials failed up update
					// in the transport or the like), or someone is trying
					// to deceive us.
					ERROR_OUT(("SECURITYDATA MISMATCH"));
					fUserDataSet = TRUE; // so we don't do it below.
					rc = FALSE;
				}
			}
			else {
				WARNING_OUT(("StoreAndVerifyMemberUserData: failed to get security data"));
				rc = FALSE;
			}
			CoTaskMemFree(pb);
		}
		if ( FALSE == fUserDataSet )
		{
			pMember->SetUserData(*(GUID *)ppUserData[i]->octet_string->value,
				(BYTE *)ppUserData[i]->octet_string->value + sizeof(GUID),
				ppUserData[i]->octet_string->length - sizeof(GUID));
		}
	}
	return rc;
}

VOID CConfObject::ResetDataMember(	CNmMember * pMember,
										ROSTER_DATA_HANDLE hData)
{
	DebugEntry(CConfObject::ResetDataMember);

	pMember->AddPf(PF_RESERVED);
	pMember->SetUserInfo(NULL, 0);

	UINT cbData;
	PVOID pData;
	ASSERT(g_pNodeController);
	if (NOERROR == g_pNodeController->GetUserData(
							hData, 
							(GUID*) &g_csguidRostInfo, 
							&cbData, 
							&pData))
	{
		pMember->SetUserInfo(pData, cbData);
	}

	UINT cbCaps;
	PVOID pvCaps;
	if (NOERROR != g_pNodeController->GetUserData(
							hData, 
							(GUID*) &g_csguidRosterCaps, 
							&cbCaps, 
							&pvCaps))
	{
		WARNING_OUT(("roster update is missing caps information"));
	}
	else
	{
		ASSERT(NULL != pvCaps);
		ASSERT(sizeof(ULONG) == cbCaps);
		pMember->SetCaps( *((PULONG)pvCaps) );
	}

	if (StoreAndVerifyMemberUserData(pMember, hData) == FALSE) {
		// Need to disconnect the conference in this case.
		WARNING_OUT(("ResetDataMember Security Warning: Authentication data could not be verified."));
	}

	NotifySink((INmMember *) pMember, OnNotifyMemberUpdated);

	DebugExitVOID(CConfObject::ResetDataMember);
}


VOID CConfObject::RemoveOldDataMembers(int nExpected)
{
	DebugEntry(CConfObject::RemoveOldDataMembers);

#ifdef _DEBUG
	int nRemoved = 0;
#endif // _DEBUG
	ASSERT(nExpected >= 0);

	if (nExpected > 0)
	{
		// At least one participant left:
		POSITION pos = m_MemberList.GetHeadPosition();
		while (NULL != pos)
		{
			POSITION oldpos = pos;
			CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
			ASSERT(pMember);
			DWORD dwFlags = pMember->GetDwFlags();
			if (!(PF_RESERVED & dwFlags))
			{
				// This one is not in the data call:
				TRACE_OUT(("CConfObject Roster: %ls (%d) has left.", 
							pMember->GetName(), pMember->GetGCCID()));

#ifdef _DEBUG
				if (dwFlags & PF_T120)
				{
					nRemoved++;
				}
#endif // _DEBUG

				if (0 == (dwFlags & PF_H323))
				{
					// If they were data only, then remove:
					RemoveMember(oldpos);
				}
				else
				{
					pMember->RemovePf(PF_DATA_ALL);
					pMember->SetGCCID(pMember->FLocal() ? H323_GCCID_LOCAL : H323_GCCID_REMOTE);
					pMember->SetGccIdParent(INVALID_GCCID);
					pMember->SetCaps(0);
					pMember->SetUserInfo(NULL, 0);

					NotifySink((INmMember *) pMember, OnNotifyMemberUpdated);
				}
			}
		}

		// Validate that we did the right thing:
		ASSERT(nRemoved == nExpected);
	}

	DebugExitVOID(CConfObject::RemoveOldDataMembers);
}


CNmMember *CConfObject::MatchDataToH323Member(	REFGUID rguidNode,
											    UINT uNodeId,
												PVOID pvUserInfo)
{
	DebugEntry(CConfObject::MatchDataToH323Member);
	CNmMember *pMemberRet = NULL;
	BOOL bRet = FALSE;
	
	if (GUID_NULL != rguidNode)
	{
		// try matching up guids
		pMemberRet = PMemberFromNodeGuid(rguidNode);
	}

	if (NULL == pMemberRet)
	{
		// try matching up node ids
		pMemberRet = PMemberFromGCCID(uNodeId);
	}

	if ((NULL == pMemberRet) && pvUserInfo)
	{
		// All else failed try mathcing IP addresses
		CRosterInfo ri;
		if(SUCCEEDED(ri.Load(pvUserInfo)))
		{
			POSITION pos = m_MemberList.GetHeadPosition();
			while (NULL != pos)
			{
				SOCKADDR_IN sin;
				CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
				IH323Endpoint * pConnection = pMember->GetH323Endpoint();
				if (pConnection && (S_OK == pConnection->GetRemoteUserAddr(&sin)))
				{

					TCHAR szAudioIP[MAX_PATH];
					TCHAR szDataIP[MAX_PATH];
					HROSTINFO hRI = NULL;
			
					// BUGBUG: UNICODE issues?
					lstrcpyn(szAudioIP, inet_ntoa(sin.sin_addr), CCHMAX(szAudioIP));
					while (SUCCEEDED(ri.ExtractItem(&hRI,
													g_cwszIPTag,
													szDataIP,
													CCHMAX(szDataIP))))
					{
						TRACE_OUT(("Comparing data IP \"%s\" with "
									"audio IP \"%s\"", szDataIP, szAudioIP));
						if (0 == lstrcmp(szDataIP, szAudioIP))
						{
							pMemberRet = pMember;
							break;	// out of outer while loop
						}
					}
				}
			}
		}
	}

	DebugExitPVOID(CConfObject::MatchDataToH323Member, pMemberRet);
	return pMemberRet;
}

VOID CConfObject::AddDataToH323Member(	CNmMember * pMember,
											PVOID pvUserInfo,
											UINT cbUserInfo,
											UINT uCaps,
											NC_ROSTER_NODE_ENTRY* pRosterNode)
{
	DebugEntry(CConfObject::AddDataToH323Member);

	ASSERT(pMember);
	ASSERT(NULL != pRosterNode);

	DWORD dwFlags = pMember->GetDwFlags();
	ASSERT(0 == ((PF_MEDIA_DATA | PF_T120) & dwFlags));
	dwFlags |= (PF_T120 | PF_MEDIA_DATA | PF_CA_DETACHED);

	// Add version information
	dwFlags = (dwFlags & ~PF_VER_MASK) |
		PF_VER_FromUserData(pRosterNode->hUserData);

	pMember->SetDwFlags(dwFlags);
	pMember->SetGCCID(pRosterNode->uNodeID);
	pMember->SetGccIdParent(pRosterNode->uSuperiorNodeID);

	ASSERT(0 == pMember->GetCaps());
	pMember->SetCaps(uCaps);

	pMember->SetUserInfo(pvUserInfo, cbUserInfo);

	NotifySink((INmMember *) pMember, OnNotifyMemberUpdated);

	ROSTER_DATA_HANDLE hData = pRosterNode->hUserData;

	if (StoreAndVerifyMemberUserData(pMember, hData) == FALSE) {
		// Need to disconnect the conference in this case.
		WARNING_OUT(("AddDataToH323Member Security Warning: Authentication data could not be verified."));
	}

	DebugExitVOID(CConfObject::AddDataToH323Member);
}

CNmMember * CConfObject::CreateDataMember(BOOL fLocal,
				  								REFGUID rguidNode,
												PVOID pvUserInfo,
												UINT cbUserInfo,
												UINT uCaps,
											    NC_ROSTER_NODE_ENTRY* pRosterNode)
{
	DebugEntry(CConfObject::CreateDataMember);

	ASSERT(NULL != pRosterNode);

	DWORD dwFlags = PF_T120 | PF_MEDIA_DATA | PF_CA_DETACHED;
	if (fLocal)
	{
		dwFlags |= (PF_LOCAL_NODE | PF_VER_CURRENT);
	}
	if (pRosterNode->fMCU)
	{
		dwFlags |= PF_T120_MCU;
	}

	if (0 != cbUserInfo)
	{
		dwFlags = (dwFlags & ~PF_VER_MASK)
				| PF_VER_FromUserData(pRosterNode->hUserData);
	}

	CNmMember * pMember = new CNmMember(pRosterNode->pwszNodeName,
										pRosterNode->uNodeID,
										dwFlags,
										uCaps,
										rguidNode,
										pvUserInfo,
										cbUserInfo);

	if (NULL != pMember)
	{
		pMember->SetGccIdParent(pRosterNode->uSuperiorNodeID);
		
		if (fLocal)
		{
			ASSERT(NULL == m_pMemberLocal);
			m_pMemberLocal = pMember;
		}
	}

	ROSTER_DATA_HANDLE hData = pRosterNode->hUserData;

	if (StoreAndVerifyMemberUserData(pMember, hData) == FALSE) {
		// Need to disconnect the conference in this case.
		WARNING_OUT(("CreateDataMember Security Warning: Authentication data could not be verified."));
	}

	TRACE_OUT(("CConfObject Roster: %ls (%d) has joined.", pRosterNode->pwszNodeName, pRosterNode->uNodeID));

	DebugExitPVOID(CConfObject::CreateDataMember, pMember);
	return pMember;
}

CNmMember * CConfObject::MatchH323ToDataMembers(REFGUID rguidNodeId,
												IH323Endpoint * pConnection)
{
	DebugEntry(CConfObject::MatchH323ToDataMembers);
	CNmMember * pMemberRet = NULL;

	// This is currently called only by OnH323Connected().  Terminal label isn't assigned yet.
	// so there is no need yet to INSERT SEARCH FOR MATCHING TERMINAL LABEL HERE

	if (GUID_NULL != rguidNodeId)
	{
		pMemberRet = PMemberFromNodeGuid(rguidNodeId);
	}
	else
	{
		SOCKADDR_IN sin;

		if (S_OK == pConnection->GetRemoteUserAddr(&sin))
		{
			TCHAR szAudioIP[MAX_PATH];
			lstrcpyn(szAudioIP, inet_ntoa(sin.sin_addr), CCHMAX(szAudioIP));

			POSITION pos = m_MemberList.GetHeadPosition();
			while (NULL != pos)
			{
				CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);

				// need to try to match IP addresses
				// this is how things were done in NM2.11 and earlier
				TCHAR szDataIP[MAX_PATH];
				HROSTINFO hRI = NULL;
				CRosterInfo ri;
				if (SUCCEEDED(ri.Load(pMember->GetUserInfo())) )
				{
					while (SUCCEEDED(ri.ExtractItem(&hRI,
													g_cwszIPTag,
													szDataIP,
													CCHMAX(szDataIP))))
					{
						TRACE_OUT(("Comparing data IP \"%s\" with "
									"h323 IP \"%s\"", szDataIP, szAudioIP));
						if (0 == lstrcmp(szDataIP, szAudioIP))
						{
							// close enough
							return pMember;
						}
					}
				}
			}
		}
	}

	DebugExitPVOID(CConfObject::MatchH323ToDataMembers, pMemberRet);
	return pMemberRet;
}

VOID CConfObject::AddMemberToAVChannels(CNmMember *pMember)
{
	CNmChannelAudio *pChannelAudio;
	CNmChannelVideo *pChannelVideo;

	if (pMember->FLocal())
	{
		pChannelAudio = m_pChannelAudioLocal;

		pChannelVideo = m_pChannelVideoLocal;
	}
	else
	{
		pChannelAudio = m_pChannelAudioRemote;

		pChannelVideo = m_pChannelVideoRemote;
	}

	if (pChannelAudio)
	{
		pChannelAudio->OnMemberAdded(pMember);
		// set media flags if channel is open
		if(S_OK == pChannelAudio->IsActive())
		{
			pMember->AddPf(PF_MEDIA_AUDIO);
			pChannelAudio->OnMemberUpdated(pMember);
			OnMemberUpdated(pMember);
		}
	}
	if (pChannelVideo)
	{
		pChannelVideo->OnMemberAdded(pMember);
		// set media flags if channel is open
		if(S_OK == pChannelVideo->IsActive())
		{
			pMember->AddPf(PF_MEDIA_VIDEO);
			pChannelVideo->OnMemberUpdated(pMember);
			OnMemberUpdated(pMember);
		}
	}

}

VOID CConfObject::RemoveMemberFromAVChannels(CNmMember *pMember)
{
	CNmChannelAudio *pChannelAudio;
	CNmChannelVideo *pChannelVideo;

	if (pMember->FLocal())
	{
		pChannelAudio = m_pChannelAudioLocal;

		pChannelVideo = m_pChannelVideoLocal;
	}
	else
	{
		pChannelAudio = m_pChannelAudioRemote;

		pChannelVideo = m_pChannelVideoRemote;
	}

	if ((NULL != pChannelVideo) && (PF_MEDIA_VIDEO & pMember->GetDwFlags()))
	{
		pMember->RemovePf(PF_MEDIA_VIDEO);
		pChannelVideo->OnMemberRemoved(pMember);
		OnMemberUpdated(pMember);
	}

	if ((NULL != pChannelAudio) && (PF_MEDIA_AUDIO & pMember->GetDwFlags()))
	{
		pMember->RemovePf(PF_MEDIA_AUDIO);
		pChannelAudio->OnMemberRemoved(pMember);
		OnMemberUpdated(pMember);
	}
}


/*  C R E A T E  A V  C H A N N E L S  */
/*-------------------------------------------------------------------------
    %%Function: CreateAVChannels
    
    Create AV channels.
-------------------------------------------------------------------------*/
VOID CConfObject::CreateAVChannels(IH323Endpoint * pConnection, CMediaList* pMediaList)
{
	HRESULT hr;
	GUID MediaGuid;
	ICommChannel *pCommChannel = NULL;
	
	MediaGuid = MEDIA_TYPE_H323AUDIO;
	if (pMediaList->IsInSendList(&MediaGuid))
	{
		m_pChannelAudioLocal = new CNmChannelAudio(FALSE /* fIncoming */);
		if (NULL != m_pChannelAudioLocal)
		{
			hr = pConnection->CreateCommChannel(&MediaGuid, &pCommChannel, TRUE /* fSend*/);
			ASSERT(SUCCEEDED(hr) && (NULL != pCommChannel));
			//if(SUCCEEDED(hr) && (NULL != pCommChannel))
			{
				NotifySink((INmChannel *) m_pChannelAudioLocal, OnNotifyChannelAdded);
				m_pChannelAudioLocal->OnConnected(pConnection, pCommChannel);
				hr = pCommChannel->EnableOpen(TRUE);
				ASSERT(SUCCEEDED(hr));
			}
			pCommChannel->Release();
			pCommChannel = NULL; // bug detection that can be removed later
		}
	}

	if (pMediaList->IsInRecvList(&MediaGuid))
	{
		m_pChannelAudioRemote = new CNmChannelAudio(TRUE /* fIncoming */);
		if (NULL != m_pChannelAudioRemote)
		{
			hr = pConnection->CreateCommChannel(&MediaGuid, &pCommChannel, FALSE /* fSend*/);
			ASSERT(SUCCEEDED(hr) && (NULL != pCommChannel));
			//if(SUCCEEDED(hr) && (NULL != pCommChannel))
			{
				NotifySink((INmChannel *) m_pChannelAudioRemote, OnNotifyChannelAdded);
				m_pChannelAudioRemote->OnConnected(pConnection, pCommChannel);
				hr = pCommChannel->EnableOpen(TRUE);
				ASSERT(SUCCEEDED(hr));
			}
			pCommChannel->Release();
			pCommChannel = NULL; // bug detection that can be removed later
		}
	}
	
	MediaGuid = MEDIA_TYPE_H323VIDEO;	// now doing video channels
	if (pMediaList->IsInSendList(&MediaGuid))
	{
		m_pChannelVideoLocal = CNmChannelVideo::CreateChannel(FALSE /* fIncoming */);
		if (NULL != m_pChannelVideoLocal)
		{
			BOOL fCreated = FALSE;
			// check for previous existence of preview stream/preview channel
			if(NULL == (pCommChannel= m_pChannelVideoLocal->GetPreviewCommChannel()))
			{
				hr = pConnection->CreateCommChannel(&MediaGuid, &pCommChannel, TRUE /* fSend*/);
				ASSERT(SUCCEEDED(hr) && (NULL != pCommChannel));
				fCreated = TRUE;
			}
			else
			{
				pCommChannel->SetAdviseInterface(m_pIH323ConfAdvise);
			}

			//if(SUCCEEDED(hr) && (NULL != pCommChannel))
			{
				NotifySink((INmChannel *) m_pChannelVideoLocal, OnNotifyChannelAdded);
				m_pChannelVideoLocal->OnConnected(pConnection, pCommChannel);
				hr = pCommChannel->EnableOpen(TRUE);
				ASSERT(SUCCEEDED(hr));			
			}
			if (fCreated)
				pCommChannel->Release();
			pCommChannel = NULL; // bug detection that can be removed later
		}

	}

	if (pMediaList->IsInRecvList(&MediaGuid))
	{
		m_pChannelVideoRemote = CNmChannelVideo::CreateChannel(TRUE /* fIncoming */);
		if (NULL != m_pChannelVideoRemote)
		{
			BOOL fCreated = FALSE;
			// check for previous existence of preview stream/preview channel
			if(NULL == (pCommChannel= m_pChannelVideoRemote->GetCommChannel()))
			{
				hr = pConnection->CreateCommChannel(&MediaGuid, &pCommChannel, FALSE /* fSend*/);
				fCreated = TRUE;
			}
			else
			{
				pCommChannel->SetAdviseInterface(m_pIH323ConfAdvise);
			}
			ASSERT(SUCCEEDED(hr) && (NULL != pCommChannel));
			//if(SUCCEEDED(hr) && (NULL != pCommChannel))
			{
				NotifySink((INmChannel *) m_pChannelVideoRemote, OnNotifyChannelAdded);
				m_pChannelVideoRemote->OnConnected(pConnection, pCommChannel);
				hr = pCommChannel->EnableOpen(TRUE);
				ASSERT(SUCCEEDED(hr));
			}
			if (fCreated)
				pCommChannel->Release();
		}
	}
}


/*  O P E N  A V  C H A N N E L S  */
/*-------------------------------------------------------------------------
    %%Function: OpenAVChannels
    
    Open AV channels.
-------------------------------------------------------------------------*/
VOID CConfObject::OpenAVChannels(IH323Endpoint * pConnection, CMediaList* pMediaList)
{
	MEDIA_FORMAT_ID idLocal;

	if(m_pChannelAudioLocal)
	{
		if (pMediaList->GetSendFormatLocalID(MEDIA_TYPE_H323AUDIO, &idLocal))
		{
			m_pChannelAudioLocal->SetFormat(idLocal);
			// open only if a valid negotiated format exists.
			// it won't hurt to always call the Open() method, but there is 
			// no need to.  This will and should probably change. Calling
			// this with INVALID_MEDIA_FORMAT results in a call to the event 
			// handler for the channel, notifying the upper layer(s) that the
			// channel could not be opened due to no compatible caps.  User 
			// feedback could be much improved if it took advantage of this.  
			if(idLocal != INVALID_MEDIA_FORMAT)
			{
				m_pChannelAudioLocal->Open();
			}
		}
	}

	if(m_pChannelVideoLocal)
	{
		if (pMediaList->GetSendFormatLocalID(MEDIA_TYPE_H323VIDEO, &idLocal))
		{
			m_pChannelVideoLocal->SetFormat(idLocal);
			if(m_pChannelVideoLocal->IsPreviewEnabled())
			{
				// open only if a valid negotiated format exists. see comments 
				// in the MEDIA_TYPE_H323AUDIO case above 
				if(idLocal != INVALID_MEDIA_FORMAT)
				{
					m_pChannelVideoLocal->Open();
				}
			}
		}
	}
}


ICommChannel* CConfObject::CreateT120Channel(IH323Endpoint * pConnection, CMediaList* pMediaList)
{
	ICommChannel *pChannelT120 = NULL;
	
	// create a T.120 channel stub 
	GUID MediaGuid = MEDIA_TYPE_H323_T120;
	if (pMediaList->IsInSendList(&MediaGuid))
	{
		HRESULT hr = pConnection->CreateCommChannel(&MediaGuid, &pChannelT120, TRUE /* fSend*/);
		if(SUCCEEDED(hr))
		{
			ASSERT(NULL != pChannelT120);
			hr = pChannelT120->EnableOpen(TRUE);
			ASSERT(SUCCEEDED(hr));
		}
	}

	return pChannelT120;
}

VOID CConfObject::OpenT120Channel(IH323Endpoint * pConnection, CMediaList* pMediaList, ICommChannel* pChannelT120)
{
	if(pChannelT120)
	{
		MEDIA_FORMAT_ID idLocal;

		if (pMediaList->GetSendFormatLocalID(MEDIA_TYPE_H323_T120, &idLocal))
		{
			// T.120 channels are different.  Always call the Open() method
			// If there are no common T.120 capabilities.  This lets the 
			// channel event handler know of the absence of remote T.120
			// caps. 
			// The T.120 call side of things is tied into the T.120 channel
			// event handler.
			pChannelT120->Open(idLocal, pConnection);
		}
	}
}

/*  D E S T R O Y  A V  C H A N N E L S  */
/*-------------------------------------------------------------------------
    %%Function: DestroyAVChannels
    
    Destroy AV channels.
-------------------------------------------------------------------------*/
VOID CConfObject::DestroyAVChannels()
{
	if (NULL != m_pChannelAudioLocal)
	{
		NotifySink((INmChannel *) m_pChannelAudioLocal, OnNotifyChannelRemoved);
		m_pChannelAudioLocal->Release();
		m_pChannelAudioLocal = NULL;
	}
	if (NULL != m_pChannelAudioRemote)
	{
		NotifySink((INmChannel *) m_pChannelAudioRemote, OnNotifyChannelRemoved);
		m_pChannelAudioRemote->Release();
		m_pChannelAudioRemote = NULL;
	}
	if (NULL != m_pChannelVideoLocal)
	{
		m_pChannelVideoLocal->OnDisconnected();
		NotifySink((INmChannel *) m_pChannelVideoLocal, OnNotifyChannelRemoved);
		m_pChannelVideoLocal->Release();
		m_pChannelVideoLocal = NULL;
	}
	if (NULL != m_pChannelVideoRemote)
	{
		m_pChannelVideoRemote->OnDisconnected();
		NotifySink((INmChannel *) m_pChannelVideoRemote, OnNotifyChannelRemoved);
		m_pChannelVideoRemote->Release();
		m_pChannelVideoRemote = NULL;
	}
}


HRESULT CConfObject::GetMediaChannel (GUID *pmediaID,BOOL bSendDirection, IMediaChannel **ppI)
{
	*ppI = NULL;
	if (*pmediaID == MEDIA_TYPE_H323AUDIO)
	{
		CNmChannelAudio *pAudChan = (bSendDirection ? m_pChannelAudioLocal : m_pChannelAudioRemote);
		*ppI = (pAudChan ? pAudChan->GetMediaChannelInterface() : NULL);
	}
	else if (*pmediaID == MEDIA_TYPE_H323VIDEO)
	{
		CNmChannelVideo *pVidChan = (bSendDirection ? m_pChannelVideoLocal : m_pChannelVideoRemote);
		*ppI = (pVidChan ? pVidChan->GetMediaChannelInterface() : NULL);
	}
	return (*ppI == NULL ? E_NOINTERFACE : S_OK);
}	

VOID CConfObject::AddH323ToDataMember(CNmMember * pMember, IH323Endpoint * pConnection)
{
	DebugEntry(CConfObject::AddH323ToDataMember);

	// Add the H323 flag bit to the member:
	pMember->AddPf(PF_H323);

	if (pConnection)
	{
		ASSERT(NULL == pMember->GetH323Endpoint());

		pMember->AddH323Endpoint(pConnection);
		++m_uH323Endpoints;
	}

	DebugExitVOID(CConfObject::AddH323ToDataMember);
}

VOID CConfObject::RemoveH323FromDataMember(CNmMember * pMember, IH323Endpoint * pConnection)
{
	DebugEntry(CConfObject::RemoveH323FromDataMember);

	// Remove the H323 flag from the member:
	pMember->RemovePf(PF_H323);

	if (pConnection)
	{
		pMember->DeleteH323Endpoint(pConnection);
		--m_uH323Endpoints;
	}

	DebugExitVOID(CConfObject::RemoveH323FromDataMember);
}

VOID CConfObject::OnMemberUpdated(INmMember *pMember)
{
	NotifySink(pMember, OnNotifyMemberUpdated);
}

VOID CConfObject::OnChannelUpdated(INmChannel *pChannel)
{
	NotifySink(pChannel, OnNotifyChannelUpdated);
}

VOID CConfObject::SetT120State(CONFSTATE state)
{
	NM_CONFERENCE_STATE oldNmState;

	GetState(&oldNmState);
	m_csState = state;
	if ( state == CS_TERMINATED )
		m_fSecure = FALSE; // Reset secure flag
	CheckState(oldNmState);
}

VOID CConfObject::CheckState(NM_CONFERENCE_STATE oldNmState)
{
	NM_CONFERENCE_STATE newNmState;
	GetState(&newNmState);
	if (oldNmState != newNmState)
	{
		NotifySink((PVOID) newNmState, OnNotifyStateChanged);
		if (NM_CONFERENCE_IDLE == newNmState)
		{
			_EraseDataChannelGUIDS();
			m_fConferenceCreated = FALSE;
		}
	}
}

void CConfObject::RemoveDataChannelGUID(REFGUID rguid)
{
	POSITION pCur = m_DataChannelGUIDS.GetHeadPosition();
	POSITION pNext = pCur;
	while(pCur)
	{
		GUID* pG = reinterpret_cast<GUID*>(m_DataChannelGUIDS.GetNext(pNext));
		if(*pG == rguid)
		{
			m_DataChannelGUIDS.RemoveAt(pCur);
		}
		pCur = pNext;
	}
}

void CConfObject::_EraseDataChannelGUIDS(void)
{
	POSITION pCur = m_DataChannelGUIDS.GetHeadPosition();
	while(pCur)
	{
		GUID* pG = reinterpret_cast<GUID*>(m_DataChannelGUIDS.GetNext(pCur));
		delete pG;
	}

	m_DataChannelGUIDS.EmptyList();
}

ULONG CConfObject::AddRef(void)
{
	return ++m_cRef;
}
	
ULONG CConfObject::Release(void)
{
	ASSERT(m_cRef > 0);

	if (m_cRef > 0)
	{
		m_cRef--;
	}

	ULONG cRef = m_cRef;

	if (0 == cRef)
	{
		delete this;
	}

	return cRef;
}

HRESULT STDMETHODCALLTYPE CConfObject::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if((riid == IID_INmConference2) || (riid == IID_INmConference) || (riid == IID_IUnknown))
	{
		*ppv = (INmConference2 *)this;
		ApiDebugMsg(("CConfObject::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		ApiDebugMsg(("CConfObject::QueryInterface(): Returning IConnectionPointContainer."));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CConfObject::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

HRESULT CConfObject::GetName(BSTR *pbstrName)
{
	HRESULT hr = E_POINTER;

	if (NULL != pbstrName)
	{
		*pbstrName = SysAllocString(m_bstrConfName);
		hr = *pbstrName ? S_OK : E_FAIL;
	}
	return hr;
}

HRESULT CConfObject::GetID(ULONG *puID)
{
	HRESULT hr = E_POINTER;

	if (NULL != puID)
	{
		*puID = m_uGCCConferenceID;
		hr = S_OK;
	}
	return hr;
}

HRESULT CConfObject::GetState(NM_CONFERENCE_STATE *pState)
{
	HRESULT hr = E_POINTER;

	if (NULL != pState)
	{
		hr = S_OK;

		switch (m_csState)
		{
			// Note: All states are valid (at least, for now)
			case CS_CREATING:
			case CS_UNINITIALIZED:
			case CS_TERMINATED:
				if (0 == m_uH323Endpoints)
				{
					*pState = NM_CONFERENCE_IDLE;
					break;
				}
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				// else fall through !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				//////////////////////////////////////////////////////////////////////////
			case CS_COMING_UP:
			case CS_GOING_DOWN:
			case CS_RUNNING:
				if (m_uMembers < 2)
				{
					if (m_fServerMode)
					{
						*pState = NM_CONFERENCE_WAITING;
					}
					else
					{
						*pState = NM_CONFERENCE_INITIALIZING;
					}
				}
				else
				{
					*pState = NM_CONFERENCE_ACTIVE;
				}
				break;
			default:
				hr = E_FAIL;
				break;
		}
	}
	return hr;
}

HRESULT CConfObject::GetNmchCaps(ULONG *puchCaps)
{
	HRESULT hr = E_POINTER;

	// BUGBUG: this returns secure cap only, used to be NOTIMPL

	if (NULL != puchCaps)
	{
		*puchCaps = m_fSecure ? NMCH_SECURE : 0;
		hr = S_OK;
	}
	return hr;
}

HRESULT CConfObject::GetTopProvider(INmMember **ppMember)
{
	CNmMember *pMemberRet = NULL;
	HRESULT hr = E_POINTER;

	if (NULL != ppMember)
	{
		POSITION pos = m_MemberList.GetHeadPosition();
		while (NULL != pos)
		{
			CNmMember *pMember = (CNmMember *) m_MemberList.GetNext(pos);
			ASSERT(pMember);

			if (pMember->FTopProvider())
			{
				// We have found the top provider
				pMemberRet = pMember;
				break;
			}
		}

		*ppMember = pMemberRet;
		hr = (NULL != pMemberRet) ? S_OK : S_FALSE;
	}
	return hr;
}


HRESULT CConfObject::EnumMember(IEnumNmMember **ppEnum)
{
	HRESULT hr = E_POINTER;

	if (NULL != ppEnum)
	{
		*ppEnum = new CEnumNmMember(&m_MemberList, m_uMembers);
		hr = (NULL != *ppEnum) ? S_OK : E_OUTOFMEMORY;
	}
	return hr;
}

HRESULT CConfObject::GetMemberCount(ULONG *puCount)
{
	HRESULT hr = E_POINTER;

	if (NULL != puCount)
	{
		*puCount = m_uMembers;
		hr = S_OK;
	}
	return hr;
}

HRESULT CConfObject::EnumChannel(IEnumNmChannel **ppEnum)
{
 	HRESULT hr = E_POINTER;
 
 	if (NULL != ppEnum)
 	{
 		COBLIST ChannelList;
 		ULONG cChannels = 0;
 
 		if (NULL != m_pChannelAudioLocal)
 		{
 			ChannelList.AddTail(m_pChannelAudioLocal);
 			++cChannels;
 		}
 		if (NULL != m_pChannelAudioRemote)
 		{
 			ChannelList.AddTail(m_pChannelAudioRemote);
 			++cChannels;
 		}
 		if (NULL != m_pChannelVideoLocal)
 		{
 			ChannelList.AddTail(m_pChannelVideoLocal);
 			++cChannels;
 		}
 		if (NULL != m_pChannelVideoRemote)
 		{
 			ChannelList.AddTail(m_pChannelVideoRemote);
 			++cChannels;
 		}
 
 		*ppEnum = new CEnumNmChannel(&ChannelList, cChannels);
 		hr = (NULL != ppEnum) ? S_OK : E_OUTOFMEMORY;
 
 		ChannelList.EmptyList();
 	}
 
 	return hr;
}

HRESULT CConfObject::GetChannelCount(ULONG *puCount)
{
	HRESULT hr = E_POINTER;

	if (NULL != puCount)
	{
		ULONG cChannels = 0;

		if (NULL != m_pChannelAudioLocal)
		{
			++cChannels;
		}
		if (NULL != m_pChannelAudioRemote)
		{
			++cChannels;
		}
		if (NULL != m_pChannelVideoLocal)
		{
			++cChannels;
		}
		if (NULL != m_pChannelVideoRemote)
		{
			++cChannels;
		}

		*puCount = cChannels;
		hr = S_OK;
	}
	return hr;
}

/*  P  M E M B E R  L O C A L  */
/*-------------------------------------------------------------------------
    %%Function: PMemberLocal
    
-------------------------------------------------------------------------*/
CNmMember * PMemberLocal(COBLIST *pList)
{
	if (NULL != pList)
	{
		POSITION posCurr;
		POSITION pos = pList->GetHeadPosition();
		while (NULL != pos)
		{
			posCurr = pos;
			CNmMember * pMember = (CNmMember *) pList->GetNext(pos);
			ASSERT(NULL != pMember);
			if (pMember->FLocal())
				return pMember;
		}
	}
	return NULL;
}


HRESULT STDMETHODCALLTYPE CConfObject::CreateDataChannelEx(INmChannelData **ppChannel, REFGUID rguid, BYTE * pER)
{
	if (NULL != ppChannel)
	{
		if (IsBadWritePtr(ppChannel, sizeof(LPVOID)))
			return E_POINTER;
		*ppChannel = NULL;
	}

	if (GUID_NULL == rguid)
	{
		WARNING_OUT(("CreateDataChannel: Null guid"));
		return E_INVALIDARG;
	}


	{	// Make sure we're in a data conference
		CNmMember * pMember = PMemberLocal(&m_MemberList);
		if (NULL == pMember)
			return E_FAIL;

		// Data must be available
		if (!FValidGccId(pMember->GetGCCID()))
			return NM_E_NO_T120_CONFERENCE;
	}

	// Make sure the data channel has not already been created
	GUID g = rguid;

	POSITION pCur = m_DataChannelGUIDS.GetHeadPosition();
	while(pCur)
	{
		GUID* pG = reinterpret_cast<GUID*>(m_DataChannelGUIDS.GetNext(pCur));
		if(*pG == rguid)
		{
			return NM_E_CHANNEL_ALREADY_EXISTS;			
		}
	}

	CNmChannelData * pChannel = new CNmChannelData(this, rguid, (PGCCEnrollRequest) pER);
	if (NULL == pChannel)
	{
		WARNING_OUT(("CreateChannelData: Unable to create data channel"));
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pChannel->OpenConnection();
	if (FAILED(hr))
	{
		ERROR_OUT(("CreateDataChannel: Unable to set guid / create T.120 channels"));
		// Failed to create T.120 data channels
		delete pChannel;
		*ppChannel = NULL;
		return hr;
	}

	GUID* pG = new GUID;
	*pG = g;

	m_DataChannelGUIDS.AddTail(pG);

	NotifySink((INmChannel *) pChannel, OnNotifyChannelAdded);
	TRACE_OUT(("CreateChannelData: Created data channel %08X", pChannel));

		// Now we are active
	NotifySink((INmChannel*) pChannel, OnNotifyChannelUpdated);

	if (NULL != ppChannel)
	{
		*ppChannel = (INmChannelData *)pChannel;
//		pChannel->AddRef(); // Caller needs to release the initial lock
	}
	else
	{
		pChannel->Release(); // No one is watching this channel? - free it now
	}

	return S_OK;
}




HRESULT STDMETHODCALLTYPE CConfObject::CreateDataChannel(INmChannelData **ppChannel, REFGUID rguid)
{
	return CreateDataChannelEx(ppChannel, rguid, NULL);
}

HRESULT CConfObject::IsHosting(void)
{
	return m_fServerMode ? S_OK : S_FALSE;
}


HRESULT CConfObject::Host(void)
{
	HRESULT hr = E_FAIL;

	if (m_fServerMode || IsConferenceActive())
	{
		WARNING_OUT(("Conference already exists!"));
//		ncsRet = UI_RC_CONFERENCE_ALREADY_EXISTS;
	}
	else
	{
		HRESULT ncsRet = CreateConference();
		if (S_OK == ncsRet)
		{
			// The only success case:
			TRACE_OUT(("Create local issued successfully"));
			m_fServerMode = TRUE;
			hr = S_OK;
		}
		else
		{
			// UI?
			WARNING_OUT(("Create local failed!"));
		}
	}
	return hr;
}

HRESULT CConfObject::Leave(void)
{
	DebugEntry(CConfObject::Leave);

	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	if (NULL != pOprahNCUI)
	{
		pOprahNCUI->CancelCalls();
	}

	HRESULT hr = S_OK;
	switch (m_csState)
	{
		case CS_GOING_DOWN:
			// we are already exiting
			break;

		case CS_COMING_UP:
		case CS_RUNNING:
		{
			SetT120State(CS_GOING_DOWN);
			ASSERT(m_hConf);
			TRACE_OUT(("Calling IDataConference::Leave"));
			hr = m_hConf->Leave();
			if (FAILED(hr))
			{
				WARNING_OUT(("IDataConference::Leave failed"));
			}
			break;
		}

		default:
			hr = E_FAIL;
			break;
	}

	if(FAILED(LeaveH323(FALSE /* fKeepAV */ )))
	{
		// overwrite return value.... I guess this error is as good as any error
		hr = E_FAIL;
	}

	DebugExitHRESULT(CConfObject::Leave, hr);
	return hr;
}

HRESULT CConfObject::LeaveH323(BOOL fKeepAV)
{
	HRESULT hrRet = S_OK;
	POSITION pos = m_MemberList.GetHeadPosition();
	while (NULL != pos && !m_MemberList.IsEmpty())
	{
		CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
		ASSERT(pMember);
		HRESULT hr;
		DWORD dwFlags = pMember->GetDwFlags();
		IH323Endpoint * pConnection = pMember->GetH323Endpoint();
		if(pConnection)
		{
			if (!fKeepAV || !((PF_MEDIA_AUDIO | PF_MEDIA_VIDEO) & dwFlags))
			{
				ConnectStateType state = CLS_Idle;
				hr = pConnection->GetState(&state);
				if (SUCCEEDED(hr))
				{
					if(state != CLS_Idle)
					{
						ASSERT(dwFlags & PF_H323);
						hr = pConnection->Disconnect();
						if (SUCCEEDED(hr))
						{
							TRACE_OUT(("pConnection->Disconnect() succeeded!"));
						}
						else
						{
							hrRet = E_FAIL;
							WARNING_OUT(("pConnection->Disconnect() failed!"));
						}
					}
				}
				else
				{
					hrRet = E_FAIL;
				}
			}
		}
	}
	return hrRet;
}

HRESULT CConfObject::LaunchRemote(REFGUID rguid, INmMember *pMember)
{
	DWORD dwUserId = 0;
	if(m_hConf)
	{
		if (NULL != pMember)
		{
			dwUserId = ((CNmMember*)pMember)->GetGCCID();
		}

		ASSERT(g_pNodeController);
		ASSERT(m_hConf);
		HRESULT nsRet = m_hConf->LaunchGuid(&rguid,
			(PUINT) &dwUserId, (0 == dwUserId) ? 0 : 1);

		return (S_OK == nsRet) ? S_OK : E_FAIL;
	}

	return NM_E_NO_T120_CONFERENCE;
}


STDMETHODIMP CConfObject::DisconnectAV(INmMember *pMember)
{
	return E_FAIL;
}

/****************************************************************************
*
*	 CLASS:    CConfObject
*
*	 FUNCTION: ConnectAV(LPCTSTR, LPCTSTR)
*
*	 PURPOSE:  Switches Audio and Video to a new person (given an IP address)
*
****************************************************************************/

STDMETHODIMP CConfObject::ConnectAV(INmMember *pMember)
{
	DebugEntry(CConfRoom::SwitchAV);

	HRESULT hr = E_FAIL;

	DebugExitHRESULT(CConfRoom::SwitchAV, hr);
	return hr;
}

/****************************************************************************
*
*	 CLASS:    CConfObject
*
*	 FUNCTION: GetConferenceHandle(DWORD *)
*
*	 PURPOSE:  Gets the T120 conference handle
*
****************************************************************************/

STDMETHODIMP CConfObject::GetConferenceHandle(DWORD_PTR *pdwHandle)
{
	HRESULT hr = E_FAIL;

	if (NULL != pdwHandle)
	{
		CONF_HANDLE hConf = GetConfHandle();
		*pdwHandle = (DWORD_PTR)hConf;
		hr = S_OK;
	}
	return hr;

}

/*  O N  N O T I F Y  S T A T E  C H A N G E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyStateChanged
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyStateChanged(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->StateChanged((NM_CONFERENCE_STATE)((DWORD_PTR)pv));
	return S_OK;
}

/*  O N  N O T I F Y  M E M B E R  A D D E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyMemberAdded
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyMemberAdded(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->MemberChanged(NM_MEMBER_ADDED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  M E M B E R  U P D A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyMemberUpdated
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyMemberUpdated(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->MemberChanged(NM_MEMBER_UPDATED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  M E M B E R  R E M O V E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyMemberRemoved
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyMemberRemoved(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->MemberChanged(NM_MEMBER_REMOVED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C H A N N E L  A D D E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyChannelAdded
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyChannelAdded(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->ChannelChanged(NM_CHANNEL_ADDED, (INmChannel *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C H A N N E L  U P D A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyChannelUpdated
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyChannelUpdated(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->ChannelChanged(NM_CHANNEL_UPDATED, (INmChannel *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C H A N N E L  R E M O V E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyChannelRemoved
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyChannelRemoved(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->ChannelChanged(NM_CHANNEL_REMOVED, (INmChannel *) pv);
	return S_OK;
}

HRESULT OnNotifyStreamEvent(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	StreamEventInfo *pInfo = (StreamEventInfo*)pv;
	ASSERT(NULL != pConfNotify);
	HRESULT hr;

	if (riid != IID_INmConferenceNotify2)
		return E_NOINTERFACE;

	((INmConferenceNotify2*)pConfNotify)->StreamEvent(pInfo->uEventCode, pInfo->uSubCode, pInfo->pChannel);
	return S_OK;
}


/*  O N  N O T I F Y  N M  U I  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyNmUI
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyNmUI(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->NmUI((CONFN)((DWORD_PTR)pv));
	return S_OK;
}

/*  G E T  C O N F  O B J E C T  */
/*-------------------------------------------------------------------------
    %%Function: GetConfObject

    Global function to get the conference object
-------------------------------------------------------------------------*/
CConfObject * GetConfObject(void)
{
	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	if (NULL != pOprahNCUI)
	{
		return pOprahNCUI->GetConfObject();
	}
	return NULL;
}

/*  G E T  C O N F E R E N C E  */
/*-------------------------------------------------------------------------
    %%Function: GetConference

    Global function to get the INmConference interface to the conf object
-------------------------------------------------------------------------*/
HRESULT GetConference(INmConference **ppConference)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppConference)
	{
		hr = E_FAIL;
		INmConference *pConference = GetConfObject();
		if (NULL != pConference)
		{
			pConference->AddRef();
			hr = S_OK;
		}
		*ppConference = pConference;
	}
	return hr;
}

/*  G E T  M E M B E R  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: GetMemberList

    Global function to get the member list
-------------------------------------------------------------------------*/
COBLIST * GetMemberList(void)
{
	CConfObject* pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;
	return pco->GetMemberList();
}

/*  P  F _  V  E  R _  F R O M  D W  */
/*-------------------------------------------------------------------------
    %%Function: PF_VER_FromDw

-------------------------------------------------------------------------*/
DWORD PF_VER_FromDw(DWORD dw)
{
	if (DWVERSION_NM_1 == dw)
		return PF_VER_NM_1;

	if ((DWVERSION_NM_2b2 <= dw) && (DWVERSION_NM_2 >= dw))
		return PF_VER_NM_2;

	if ((DWVERSION_NM_3a1 <= dw) && (DWVERSION_NM_3max >= dw))
		return PF_VER_NM_3;

	if ((DWVERSION_NM_4a1 <= dw) && (DWVERSION_NM_CURRENT >= dw))
		return PF_VER_NM_4;

	if (dw > DWVERSION_NM_CURRENT)
		return PF_VER_FUTURE;

	return PF_VER_UNKNOWN;
}


/*  P  F _  V  E  R _  F R O M  U S E R  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: PV_VER_FromUserData
    
-------------------------------------------------------------------------*/
DWORD PF_VER_FromUserData(ROSTER_DATA_HANDLE hUserData)
{
	UINT cb;
	PT120PRODUCTVERSION pVersion;
	PVOID pv;

	static const GUID g_csguidVerInfo = GUID_VERSION;

	ASSERT(NULL != g_pNodeController);

	if (NULL == hUserData)
		return PF_VER_UNKNOWN; // not NetMeeting

	// Try to find the T.120 Product Version guid
	if ((NOERROR == g_pNodeController->GetUserData(hUserData,
			&g_csguidVerInfo, &cb, (PVOID *) &pVersion))
		&& (cb < sizeof(T120PRODUCTVERSION)) )
	{
		return PF_VER_FromDw(pVersion->dwVersion);
	}

	// Try to extract the build number from the hex string for VER_PRODUCTVERSION_DW
	if ((NOERROR == g_pNodeController->GetUserData(hUserData,
			(GUID *) &g_csguidRostInfo, &cb, &pv)))
	{
		CRosterInfo ri;
		ri.Load(pv);

		TCHAR szVersion[MAX_PATH];
		if (SUCCEEDED(ri.ExtractItem(NULL,
			g_cwszVerTag, szVersion, CCHMAX(szVersion))))
		{
			return PF_VER_FromDw(DwFromHex(szVersion));
		}
	}

	return PF_VER_NM_1; // Must be at least NetMeeting 1.0
}

DWORD CConfObject::GetDwUserIdLocal(void)
{
	CNmMember * pMemberLocal = GetLocalMember();

	if (NULL != pMemberLocal)
	{
		return pMemberLocal->GetGCCID();
	}

	return 0;
}


CNmMember * CConfObject::PMemberFromGCCID(UINT uNodeID)
{
	COBLIST* pMemberList = ::GetMemberList();
	if (NULL != pMemberList)
	{
		POSITION pos = pMemberList->GetHeadPosition();
		while (pos)
		{
			CNmMember * pMember = (CNmMember *) pMemberList->GetNext(pos);
			ASSERT(NULL != pMember);
			if (uNodeID == pMember->GetGCCID())
			{
				return pMember;
			}
		}
	}
	return NULL;
}

CNmMember * CConfObject::PMemberFromNodeGuid(REFGUID rguidNode)
{
	POSITION pos = m_MemberList.GetHeadPosition();
	while (NULL != pos)
	{
		CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);

		if (pMember->GetNodeGuid() == rguidNode)
		{
			return  pMember;
		}
	}
	return NULL;
}

CNmMember * CConfObject::PMemberFromH323Endpoint(IH323Endpoint * pConnection)
{
	COBLIST* pMemberList = ::GetMemberList();
	if (NULL != pMemberList)
	{
		POSITION pos = pMemberList->GetHeadPosition();
		while (pos)
		{
			CNmMember * pMember = (CNmMember *) pMemberList->GetNext(pos);
			ASSERT(NULL != pMember);
			if (pConnection == pMember->GetH323Endpoint())
			{
				return pMember;
			}
		}
	}
	return NULL;
}
	

CNmMember * CConfObject::PDataMemberFromName(PCWSTR pwszName)
{
	POSITION pos = m_MemberList.GetHeadPosition();
	while (NULL != pos)
	{
		CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);

		if(pMember->FHasData())
		{
			if (0 == UnicodeCompare(pwszName, pMember->GetName()))
			{
				return  pMember;
			}
		}
	}
	return NULL;
}


// IStreamEventNotify method
// get called whenever a major event on the stream occurs
HRESULT __stdcall CConfObject::EventNotification(UINT uDirection, UINT uMediaType, UINT uEventCode, UINT uSubCode)
{
	CNmChannelAudio *pChannel = NULL;
	ULONG uStatus = 0;
	StreamEventInfo seInfo;

	if (uMediaType == MCF_AUDIO)
	{

		if (uDirection == MCF_SEND)
		{
			pChannel = m_pChannelAudioLocal;
		}
		else if (uDirection == MCF_RECV)
		{
			pChannel = m_pChannelAudioRemote;
		}
	}

	if (pChannel)
	{
		// If we get a device failure notification,
		// do a quick check to see if the device is indeed
		// jammed.  The device may have opened by the time we
		// got this notification

		seInfo.pChannel = pChannel;
		seInfo.uSubCode = uSubCode;

		switch (uEventCode)
		{
			case STREAM_EVENT_DEVICE_FAILURE:
			{
				seInfo.uEventCode = (NM_STREAMEVENT)NM_STREAMEVENT_DEVICE_FAILURE;
				NotifySink((void*)&seInfo, OnNotifyStreamEvent);
				break;
			}
			case STREAM_EVENT_DEVICE_OPEN:
			{
				seInfo.uEventCode = (NM_STREAMEVENT)NM_STREAMEVENT_DEVICE_OPENED;
				NotifySink((void*)&seInfo, OnNotifyStreamEvent);
				break;
			}
			default:
			{
				break;
			}
		}
	}

	else
	{
		return E_FAIL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\ichnldat.cpp ===
// File: ichnldat.cpp
//
// INmChannelData
//

#include "precomp.h"

#include <wbguid.h>
#include <confguid.h>
#include "pfnt120.h"
#include "ichnldat.h"

static const IID * g_apiidCP[] =
{
    {&IID_INmChannelDataNotify2},
    {&IID_INmChannelDataNotify},
    {&IID_INmChannelNotify}
};

#define CopyStruct(pDest, pSrc)  CopyMemory(pDest, pSrc, sizeof(*(pDest)))
#define MAX_NM_PEER  256 // Maximum number of NetMeeting Peer applications/users


#ifdef DEBUG  /* T.120 Debug utilities */
LPCTSTR GetGccErrorString(GCCError uErr);
LPCTSTR GetMcsErrorString(MCSError uErr);
LPCTSTR GetGccResultString(UINT uErr);
LPCTSTR GetMcsResultString(UINT uErr);
#else
#define GetGccErrorString(uErr) ""
#define GetMcsErrorString(uErr) ""
#define GetGccResultString(uErr) ""
#define GetMcsResultString(uErr) ""
#endif /* DEBUG */



// code from nm\ui\conf\cuserdta.cpp:
static unsigned char H221IDGUID[5] = {H221GUIDKEY0,
                                      H221GUIDKEY1,
                                      H221GUIDKEY2,
                                      H221GUIDKEY3,
                                      H221GUIDKEY4};
// Create an H.221 application key with a guid
VOID NMINTERNAL CreateH221AppKeyFromGuid(LPBYTE lpb, GUID * pguid)
{
	CopyMemory(lpb, H221IDGUID, sizeof(H221IDGUID));
	CopyMemory(lpb + sizeof(H221IDGUID), pguid, sizeof(GUID));
}


/*  S E T  A P P  K E Y */
/*----------------------------------------------------------------------------
    %%Function: SetAppKey

	Set the two pieces of an OctetString (the length and the data.)
	Note that the length always includes the terminating null character.
----------------------------------------------------------------------------*/
VOID SetAppKey(LPOSTR pOct, LPBYTE lpb)
{
	pOct->length = cbKeyApp;
	pOct->value = lpb;
}

/*  C R E A T E  A P P  K E Y */
/*----------------------------------------------------------------------------
    %%Function: CreateAppKey

	Given a guid and a userid, create the appropriate application key.

	The key is formated as:
	0xB5 0x00 0x53 0x4C  - Microsoft Object Identifier
	0x01                 - guid identifier
	<binary guid>        - guid data
	<dword node id>      - user node id
----------------------------------------------------------------------------*/
VOID CreateAppKey(LPBYTE lpb, GUID * pguid, DWORD dwUserId)
{
	CreateH221AppKeyFromGuid(lpb, pguid);
	CopyMemory(lpb + cbKeyApp - sizeof(DWORD), &dwUserId, sizeof(DWORD));

#ifdef DEBUG
	TCHAR szGuid[LENGTH_SZGUID_FORMATTED];
	GuidToSz(pguid, szGuid);
	DbgMsgDc("CreateAppKey: %s %08X", szGuid, dwUserId);
#endif
}


/*  P  M E M B E R  F R O M  D W  U S E R  I D  */
/*-------------------------------------------------------------------------
    %%Function: PMemberFromDwUserId

-------------------------------------------------------------------------*/
CNmMember * PMemberFromDwUserId(DWORD dwUserId, COBLIST *pList)
{
	if (NULL != pList)
	{
		POSITION posCurr;
		POSITION pos = pList->GetHeadPosition();
		while (NULL != pos)
		{
			posCurr = pos;
			CNmMember * pMember = (CNmMember *) pList->GetNext(pos);
			if (dwUserId == pMember->GetGCCID())
			{
				pMember->AddRef();
				return pMember;
			}
		}
	}
	return NULL;
}


/*  A D D  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: AddNode

    Add a node to a list.
    Initializes the ObList, if necessary.
    Returns the position in the list or NULL if there was a problem.
-------------------------------------------------------------------------*/
POSITION AddNode(PVOID pv, COBLIST ** ppList)
{
	ASSERT(NULL != ppList);
	if (NULL == *ppList)
	{
		*ppList = new COBLIST();
		if (NULL == *ppList)
			return NULL;
	}

	return (*ppList)->AddTail(pv);
}

/*  R E M O V E  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: RemoveNode

    Remove a node from a list.
    Sets pPos to NULL
-------------------------------------------------------------------------*/
PVOID RemoveNodePos(POSITION * pPos, COBLIST *pList)
{
	if ((NULL == pList) || (NULL == pPos))
		return NULL;

	PVOID pv = pList->RemoveAt(*pPos);
	*pPos = NULL;
	return pv;
}


/*  R E M O V E  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: RemoveNode

-------------------------------------------------------------------------*/
VOID RemoveNode(PVOID pv, COBLIST * pList)
{
	ASSERT(NULL != pv);

	if (NULL != pList)
	{
		POSITION pos = pList->GetPosition(pv);
		RemoveNodePos(&pos, pList);
	}
}

VOID CNmChannelData::InitCT120Channel(DWORD dwUserId)
{
	m_dwUserId = dwUserId;
	m_gcc_conference_id = 0;
	m_gcc_pIAppSap = NULL;
	m_mcs_channel_id = 0;
	m_pmcs_sap = NULL;
	m_gcc_node_id = 0;
	m_scs = SCS_UNINITIALIZED;

	m_pGuid = PGuid();
	ASSERT((NULL != m_pGuid) && (GUID_NULL != *m_pGuid));

	CreateAppKey(m_keyApp, m_pGuid, 0);
	CreateAppKey(m_keyChannel, m_pGuid, dwUserId);

	// initialize other gcc & mcs stuff
	GCCObjectKey FAR * pObjKey;
	ClearStruct(&m_gcc_session_key);
	pObjKey = &(m_gcc_session_key.application_protocol_key);
	pObjKey->key_type = GCC_H221_NONSTANDARD_KEY;
	SetAppKey(&(pObjKey->h221_non_standard_id), m_keyApp);
	ASSERT(0 == m_gcc_session_key.session_id);

	ClearStruct(&m_gcc_registry_item);
	ClearStruct(&m_gcc_registry_key);
	CopyStruct(&m_gcc_registry_key.session_key, &m_gcc_session_key);
	SetAppKey(&m_gcc_registry_key.resource_id, m_keyApp);

	ClearStruct(&m_registry_item_Private);
	ClearStruct(&m_registry_key_Private);
	CopyStruct(&m_registry_key_Private.session_key, &m_gcc_session_key);
	SetAppKey(&m_registry_key_Private.resource_id, m_keyChannel);

	UpdateScState(SCS_UNINITIALIZED, 0);
}


/*  C L O S E  C H A N N E L */
/*----------------------------------------------------------------------------
    %%Function: CloseChannel

	Close the channel.

	Note there are no confirm messages expected for any of the GCC/MCS calls.
----------------------------------------------------------------------------*/
VOID CNmChannelData::CloseChannel(void)
{
	GCCError gccError = GCC_NO_ERROR;
	MCSError mcsError = MCS_NO_ERROR;

	if (SCS_UNINITIALIZED == m_scs)
    {
        WARNING_OUT(("in CT120Channel::CloseChannel, m_scs is SCS_UNINITIALIZED, is this OK?"));
        return;
    }

	DbgMsgDc("CT120Channel::CloseChannel %08X (userHandle=%p)", m_mcs_channel_id, m_pmcs_sap);

	m_scs = SCS_TERMINATING;

	if (0 != m_mcs_channel_id)
	{
		ASSERT (m_pmcs_sap);
		mcsError = m_pmcs_sap->ChannelLeave(m_mcs_channel_id);
		DbgMsgDc("CT120Channel::CloseChannel: ChannelLeave %s", GetMcsErrorString(mcsError));
		m_mcs_channel_id = 0;
	}

	if (NULL != m_pmcs_sap)
	{
		mcsError = m_pmcs_sap->ReleaseInterface();
		DbgMsgDc("CT120Channel::CloseChannel: MCS ReleaseInterface %s", GetMcsErrorString(mcsError));
		m_pmcs_sap = NULL;
	}

	if (NULL != m_gcc_pIAppSap)
	{
		m_gcc_pIAppSap->RegistryDeleteEntry(m_gcc_conference_id, &m_registry_key_Private);
		// ignore the above result

        m_gcc_pIAppSap->ReleaseInterface();
		DbgMsgDc("CT120Channel::CloseChannel: GCCDeleteSap %s", GetGccErrorString(gccError));
		m_gcc_pIAppSap = NULL;
	}

	m_scs = SCS_UNINITIALIZED;
	m_gcc_conference_id = 0;

	// make sure no one is around
	UpdateRoster(NULL, 0, FALSE, TRUE /* fRemove */);;
}


/*  U P D A T E  S C  S T A T E */
/*----------------------------------------------------------------------------
    %%Function: UpdateScState

	The system progresses from one state to another
	by making an GCC (or MCS) call that is guarenteed to
	produce a notification that calls this function.
	The calling process is released by UnBlockThread.
----------------------------------------------------------------------------*/
VOID CNmChannelData::UpdateScState(SCSTATE scs, DWORD dwErr)
{
    DBGENTRY(CNmChannelData::UpdateScState)
	if (m_scs != scs)
	{
		WARNING_OUT(("UpdateScState - invalid state transition (%d - %d)", m_scs, scs));
		dwErr = INVALID_T120_ERROR; // We should never get here
	}

	if (0 == dwErr)
	{
	switch (m_scs)
		{
	case SCS_UNINITIALIZED:
		dwErr = DoCreateSap();
		break;
	case SCS_CREATESAP:
		dwErr = DoAttach();
		break;
	case SCS_ATTACH:
		dwErr = DoEnroll();
		break;
	case SCS_ENROLL:
		dwErr = DoJoinPrivate();
		break;
	case SCS_JOIN_PRIVATE:
		dwErr = DoRegRetrieve();
		break;
	case SCS_REGRETRIEVE_NEW:
		dwErr = DoJoinNew();
		break;
	case SCS_REGRETRIEVE_EXISTS:
		dwErr = DoJoinOld();
		break;
	case SCS_JOIN_NEW:
		dwErr = DoRegChannel();
		break;
	case SCS_REGCHANNEL:
	case SCS_JOIN_OLD:
		dwErr = DoRegPrivate();
		break;
	case SCS_REGPRIVATE:
		DbgMsgDc(">>>>>>>>>>>UpdateScState: Complete");
		m_scs = SCS_CONNECTED;
		NotifyChannelConnected();
		break;
	case SCS_CONNECTED:
	case SCS_REGRETRIEVE:
		// we should never be called when we're in these states
		// so, treat it as an error and fall thru to the default case
	default:
		dwErr = INVALID_T120_ERROR; // We should never get here
		break;
		}
	}

	DbgMsgDc("UpdateScState: New state (%d) channelId=%04X", m_scs, GetMcsChannelId());

	if (0 != dwErr)
	{
		WARNING_OUT(("UpdateScState: Err=%d", dwErr));
		CloseConnection();
	}

    DBGEXIT(CNmChannelData::UpdateScState)
}

DWORD CNmChannelData::DoCreateSap(void)
{
	ASSERT(SCS_UNINITIALIZED == m_scs);
	m_scs = SCS_CREATESAP;

    GCCError gccError = PFNT120::CreateAppSap(&m_gcc_pIAppSap, this, NmGccMsgHandler);
	DbgMsgDc("GCCCreateSap err=%s", GetGccErrorString(gccError));
	return (DWORD) gccError;
}

DWORD CNmChannelData::DoAttach(void)
{
	ASSERT(SCS_CREATESAP == m_scs);
	m_scs = SCS_ATTACH;

	MCSError mcsError = PFNT120::AttachRequest(&m_pmcs_sap,
		(DomainSelector) &m_gcc_conference_id,
		sizeof(m_gcc_conference_id),
		NmMcsMsgHandler,
		this,
		ATTACHMENT_DISCONNECT_IN_DATA_LOSS | ATTACHMENT_MCS_FREES_DATA_IND_BUFFER);
	// This generates an async MCS_ATTACH_USER_CONFIRM

	DbgMsgDc("MCS_AttachRequest err=%s", GetMcsErrorString(mcsError));
	return (DWORD) mcsError;
}

DWORD CNmChannelData::DoEnroll(void)
{
	ASSERT(SCS_ATTACH == m_scs || SCS_JOIN_STATIC_CHANNEL);
	m_scs = SCS_ENROLL;

	GCCEnrollRequest er;
    GCCRequestTag nReqTag;

	if(m_pGCCER)
	{
		m_pGCCER->pSessionKey = &m_gcc_session_key;
		m_pGCCER->nUserID = m_mcs_sender_id;

	}
	else
	{
    	// fill in enroll request structure
	    ::ZeroMemory(&er, sizeof(er));
	    er.pSessionKey = &m_gcc_session_key;
	    er.fEnrollActively = TRUE;
	    er.nUserID = m_mcs_sender_id;
	    // er.fConductingCapabable = FALSE;
	    er.nStartupChannelType = MCS_DYNAMIC_MULTICAST_CHANNEL;
	    // er.cNonCollapsedCaps = 0;
	    // er.apNonCollapsedCaps = NULL;
	    // er.cCollapsedCaps = 0;
    	// er.apCollapsedCaps = NULL;
	    er.fEnroll = TRUE;
	}

	GCCError gccError = m_gcc_pIAppSap->AppEnroll(m_gcc_conference_id, m_pGCCER != NULL ? m_pGCCER : &er, &nReqTag);

	DbgMsgDc("GCCApplicationEnrollRequest err=%s", GetGccErrorString(gccError));

	if (GCC_NO_ERROR != gccError)
	{
		ERROR_OUT(("DoEnroll failed - WHY?"));
	}

	return (DWORD) gccError;
}

// Join the PRIVATE data channel (m_mcs_sender_id)
DWORD CNmChannelData::DoJoinPrivate(void)
{
	ASSERT(SCS_ENROLL == m_scs || SCS_ATTACH == m_scs);
	m_scs = SCS_JOIN_PRIVATE;

	MCSError mcsError = m_pmcs_sap->ChannelJoin(m_mcs_sender_id);
	// This generates an async MCS_CHANNEL_JOIN_CONFIRM

	DbgMsgDc("MCSChannelJoinRequest (private) %04X, err=%s",
		m_mcs_sender_id, GetMcsErrorString(mcsError));
	return (DWORD) mcsError;
}


DWORD CNmChannelData::DoRegRetrieve(void)
{
	ASSERT(SCS_JOIN_PRIVATE == m_scs);
	m_scs = SCS_REGRETRIEVE;

	GCCError gccError = m_gcc_pIAppSap->RegistryRetrieveEntry(
		m_gcc_conference_id, &m_gcc_registry_key);
	// This generates an async GCC_RETRIEVE_ENTRY_CONFIRM

	DbgMsgDc("GCCRegistryRetrieveEntryRequest err=%s", GetGccErrorString(gccError));
	return (DWORD) gccError;
}

// Register the PUBLIC channel
DWORD CNmChannelData::DoRegChannel(void)
{
	ASSERT(SCS_JOIN_NEW == m_scs);
	m_scs = SCS_REGCHANNEL;

	GCCError gccError = m_gcc_pIAppSap->RegisterChannel(
		m_gcc_conference_id, &m_gcc_registry_key, m_mcs_channel_id);
	// This generates an async GCC_REGISTER_CHANNEL_CONFIRM

	DbgMsgDc("GCCRegisterChannelRequest err=%s", GetGccErrorString(gccError));
	return (DWORD) gccError;
}

DWORD CNmChannelData::DoJoinStatic(ChannelID staticChannel)
{
	m_scs = SCS_JOIN_STATIC_CHANNEL;
	MCSError mcsError = m_pmcs_sap->ChannelJoin(staticChannel);
	// This generates an async MCS_CHANNEL_JOIN_CONFIRM

	DbgMsgDc("MCSChannelJoinRequest %04X, err=%s",
		staticChannel, GetMcsErrorString(mcsError));
	return (DWORD) mcsError;
}

DWORD CNmChannelData::DoJoin(SCSTATE scs)
{
	m_scs = scs;

	MCSError mcsError = m_pmcs_sap->ChannelJoin(m_mcs_channel_id);
	// This generates an async MCS_CHANNEL_JOIN_CONFIRM

	DbgMsgDc("MCSChannelJoinRequest %04X, err=%s",
		m_mcs_channel_id, GetMcsErrorString(mcsError));
	return (DWORD) mcsError;
}

DWORD CNmChannelData::DoJoinNew(void)
{
	ASSERT(0 == m_mcs_channel_id);
	ASSERT(SCS_REGRETRIEVE_NEW == m_scs);
	return DoJoin(SCS_JOIN_NEW);
}

DWORD CNmChannelData::DoJoinOld(void)
{
	ASSERT(0 != m_mcs_channel_id);
	ASSERT(SCS_REGRETRIEVE_EXISTS == m_scs);
	return DoJoin(SCS_JOIN_OLD);
}


// Register the PRIVATE data channel. (m_mcs_sender_id)
DWORD CNmChannelData::DoRegPrivate(void)
{
	ASSERT(0 != m_mcs_sender_id);
	ASSERT((SCS_REGCHANNEL == m_scs) || (SCS_JOIN_OLD == m_scs));
	m_scs = SCS_REGPRIVATE;

	DbgMsgDc("DoRegPrivate: channelId %04X as private for %08X", m_mcs_sender_id, m_dwUserId);

	GCCError gccError = m_gcc_pIAppSap->RegisterChannel(
			m_gcc_conference_id, &m_registry_key_Private, m_mcs_sender_id);
	// This generates an async GCC_REGISTER_CHANNEL_CONFIRM

	DbgMsgDc("GCCRegisterChannelRequest err=%s", GetGccErrorString(gccError));
	return (DWORD) gccError;
}


// deal with a GCC_RETRIEVE_ENTRY_CONFIRM notification
VOID CNmChannelData::ProcessEntryConfirm(GCCAppSapMsg * pMsg)
{
	if (pMsg->RegistryConfirm.pRegKey->resource_id.length >=
	    m_gcc_registry_key.resource_id.length
	    &&
        0 != memcmp(m_gcc_registry_key.resource_id.value,
		pMsg->RegistryConfirm.pRegKey->resource_id.value,
		m_gcc_registry_key.resource_id.length))
	{
		OnEntryConfirmRemote(pMsg);
	}
	else
	{
		OnEntryConfirmLocal(pMsg);
	}
}



// deal with a GCC_REGISTRY_HANDLE_CONFIRM notification
VOID CNmChannelData::ProcessHandleConfirm(GCCAppSapMsg * pMsg)
{
	ASSERT(NULL != pMsg);
	NotifySink(&pMsg->RegAllocHandleConfirm, OnAllocateHandleConfirm);
}


VOID CNmChannelData::OnEntryConfirmRemote(GCCAppSapMsg * pMsg)
{
	DWORD dwUserId;
	ASSERT(cbKeyApp ==
		pMsg->RegistryConfirm.pRegKey->resource_id.length);
	CopyMemory(&dwUserId,
		pMsg->RegistryConfirm.pRegKey->resource_id.value +
		cbKeyApp - sizeof(DWORD), sizeof(DWORD));

	DbgMsgDc("GCC_RETRIEVE_ENTRY_CONFIRM: user private channelId = %04X for userId=%04X result=%s",
		pMsg->RegistryConfirm.pRegItem->channel_id, dwUserId,
		GetGccResultString(pMsg->RegistryConfirm.nResult));

	if (GCC_RESULT_SUCCESSFUL == pMsg->RegistryConfirm.nResult)
	{
		UpdateMemberChannelId(dwUserId,
			pMsg->RegistryConfirm.pRegItem->channel_id);
	}
	else
	{
		CNmMemberId * pMemberId = GetMemberId(dwUserId);
		if (NULL != pMemberId)
		{
			UINT cCount = pMemberId->GetCheckIdCount();
			if (0 == cCount)
			{
				DbgMsgDc("CT120Channel: No more ChannelId requests %08X", dwUserId);
			}
			else
			{
				cCount--;
				DbgMsgDc("CT120Channel: Request Count for %08X = %0d", dwUserId, cCount);
				pMemberId->SetCheckIdCount(cCount);

				// BUGBUG: T.120 should notify us when this information is available
				RequestChannelId(dwUserId);
			}
		}
	}
}

VOID CNmChannelData::OnEntryConfirmLocal(GCCAppSapMsg * pMsg)
{
	DbgMsgDc("GCC_RETRIEVE_ENTRY_CONFIRM: public channelId = %04X result=%s",
		pMsg->RegistryConfirm.pRegItem->channel_id,
		GetGccResultString(pMsg->RegistryConfirm.nResult));

	// Processing initial request for guid channel information
	ASSERT(sizeof(m_gcc_registry_item) == sizeof(*(pMsg->RegistryConfirm.pRegItem)));
	CopyMemory(&m_gcc_registry_item, pMsg->RegistryConfirm.pRegItem,
		sizeof(m_gcc_registry_item));
	if (GCC_RESULT_SUCCESSFUL == pMsg->RegistryConfirm.nResult)
	{

		m_mcs_channel_id = m_gcc_registry_item.channel_id;
		ASSERT(SCS_REGRETRIEVE == m_scs);
		m_scs = SCS_REGRETRIEVE_EXISTS;
		UpdateScState(SCS_REGRETRIEVE_EXISTS, 0);
	}
	else if (GCC_RESULT_ENTRY_DOES_NOT_EXIST == pMsg->RegistryConfirm.nResult)
	{
		DbgMsgDc(" channel does not exist - proceeding to new state");
		ASSERT(0 == m_mcs_channel_id);
		ASSERT(SCS_REGRETRIEVE == m_scs);
		m_scs = SCS_REGRETRIEVE_NEW;
		UpdateScState(SCS_REGRETRIEVE_NEW, 0);
	}
}
	

// deal with a GCC_APP_ROSTER_REPORT_INDICATION
BOOL CNmChannelData::UpdateRoster(GCCAppSapMsg * pMsg)
{
	UINT iRoster;
	GCCApplicationRoster * lpAppRoster;
	int iRecord;
	GCCApplicationRecord * lpAppRecord;
	DWORD dwUserId;
	UCID  rgPeerTemp[MAX_NM_PEER];
	int   cPeer;
	int   i;
	BOOL  fAdd = FALSE;
	BOOL  fRemove = FALSE;
	BOOL  fLocal = FALSE;

	DbgMsgDc("CT120Channel::UpdateRoster: conf=%d, roster count=%d",
		pMsg->AppRosterReportInd.nConfID,
		pMsg->AppRosterReportInd.cRosters);

	ZeroMemory(rgPeerTemp, sizeof(rgPeerTemp));

	/* Create rgPeerTemp[], cPeer */
	cPeer = 0;
	for (iRoster = 0;
		iRoster < pMsg->AppRosterReportInd.cRosters;
		iRoster++)
	{
		lpAppRoster = pMsg->AppRosterReportInd.apAppRosters[iRoster];
		if (lpAppRoster->session_key.session_id != m_gcc_session_key.session_id)
			continue;
		
		// Must pay attention to these flags to avoid GCC weirdness
		if (lpAppRoster->nodes_were_added)
			fAdd = TRUE;
		if (lpAppRoster->nodes_were_removed)
			fRemove = TRUE;

		for (iRecord = 0;
			iRecord < lpAppRoster->number_of_records;
			iRecord++)
		{
			lpAppRecord = lpAppRoster->application_record_list[iRecord];
			TRACE_OUT(("Node=%X, Entity=%X, AppId=%X", lpAppRecord->node_id,
				lpAppRecord->entity_id, lpAppRecord->application_user_id));

			// Search for the node in the list
			dwUserId = lpAppRecord->node_id;
			
			//
			// Check for local node
			//
			fLocal |= (dwUserId == m_dwUserIdLocal);
			
			for (i = 0; i < cPeer; i++)
			{
				if (dwUserId == rgPeerTemp[i].dwUserId)
					break;
			}
			if (i >= cPeer)
			{
				if (cPeer >= MAX_NM_PEER)
					continue; // over our limit!

				// Add the node to our new list
				rgPeerTemp[cPeer++].dwUserId = dwUserId;
			}


			// Make sure we know the sender_id's
			if (MCS_DYNAMIC_PRIVATE_CHANNEL == lpAppRecord->startup_channel_type)
			{
				rgPeerTemp[i].sender_id_private = lpAppRecord->application_user_id;
			}
			else
			{
				rgPeerTemp[i].sender_id_public = lpAppRecord->application_user_id;
			}
		}

		break; // out of for (iRoster) loop
	}

	UpdateRoster(rgPeerTemp, cPeer, fAdd, fRemove);

	return (fAdd && fLocal);
}


/*  H R  S E N D  D A T A */
/*----------------------------------------------------------------------------
    %%Function: HrSendData

	Send data on a specific channel
----------------------------------------------------------------------------*/
HRESULT CNmChannelData::HrSendData(ChannelID channel_id, DWORD dwUserId, LPVOID lpv, DWORD cb, DWORD dwFlags)
{
	DbgMsgDc("CT120Channel::HrSendData: %d bytes", cb);



	PDUPriority priority = MEDIUM_PRIORITY;
	SendDataFlags allocation = APP_ALLOCATION;
	DataRequestType requestType =	NORMAL_SEND_DATA;

	if(dwFlags)
	{
	 	if(dwFlags & TOP_PRIORITY_MASK)
	 	{
		 	priority = TOP_PRIORITY;
	 	}
	 	else if (dwFlags & HIGH_PRIORITY_MASK)
	 	{
		 	priority = HIGH_PRIORITY;
	 	}
	 	else if (dwFlags & LOW_PRIORITY_MASK)
	 	{
		 	priority = LOW_PRIORITY;
	 	}

		if (dwFlags & UNIFORM_SEND_DATA_MASK)
		{
			requestType = UNIFORM_SEND_DATA;
		}
	
		if (dwFlags & MCS_ALLOCATION_MASK)
		{
			allocation = MCS_ALLOCATION;
		}
	}

	if ((0 == m_mcs_channel_id) || (NULL == m_pmcs_sap) || (0 == channel_id))
	{
		WARNING_OUT(("*** Attempted to send data on invalid channel"));
		return E_INVALIDARG;
	}

	MCSError mcsError = m_pmcs_sap->SendData(requestType, channel_id, priority,
									(unsigned char *)lpv, cb, allocation);

	if (0 != mcsError)
	{
		TRACE_OUT(("SendData err=%s", GetMcsErrorString(mcsError)));
		// Usually MCS_TRANSMIT_BUFFER_FULL
		return E_OUTOFMEMORY;
	}

	{	// Inform the app the data has been sent
		NMN_DATA_XFER nmnData;
		nmnData.pMember = NULL;
		nmnData.pb = (LPBYTE) lpv;
		nmnData.cb = cb;
		nmnData.dwFlags = 0;

		if (0 == dwUserId)
		{
			// send out notification with NULL member (BROADCAST)
			NotifySink(&nmnData, OnNmDataSent);
		}
		else
		{
			nmnData.pMember = (INmMember *) PMemberFromDwUserId(dwUserId, GetMemberList());
			if (nmnData.pMember)
			{
				NotifySink(&nmnData, OnNmDataSent);
				nmnData.pMember->Release();
			}
		}
	}

	TRACE_OUT(("SendData completed successfully"));
	return S_OK;
}


// Ask GCC for the private channel id.
VOID CNmChannelData::RequestChannelId(DWORD dwUserId)
{
	BYTE   keyChannel[cbKeyApp];
	GCCRegistryKey  registry_key;

	DbgMsgDc("Requesting channel id for %08X", dwUserId);

	CopyStruct(&registry_key.session_key, &m_gcc_session_key);
	CreateAppKey(keyChannel, m_pGuid, dwUserId);
	SetAppKey(&registry_key.resource_id, keyChannel);

	GCCError gccError = m_gcc_pIAppSap->RegistryRetrieveEntry(
		m_gcc_conference_id, &registry_key);
	// This generates an async GCC_RETRIEVE_ENTRY_CONFIRM

	if (0 != gccError)
	{
		WARNING_OUT(("RequestChannelId - problem with GCCRegistryRectreiveEntryRequest"));
	}
}


VOID CNmChannelData::NotifyChannelConnected(void)
{
    DBGENTRY(CNmChannelData::NotifyChannelConnected);
	if (S_OK != IsActive())
	{
		CConfObject * pConference = PConference();
		if (NULL != pConference)
		{
		   	m_fActive = TRUE;

            TRACE_OUT(("The channel is now officially active"));
			// The channel is now officially active
			pConference->OnChannelUpdated(this);
		}
        else
        {
            WARNING_OUT(("PConference is NULL!"));

        }
    }
    DBGEXIT(CNmChannelData::NotifyChannelConnected);
}


/*  N M  G C C  M S G  H A N D L E R  */
/*-------------------------------------------------------------------------
    %%Function: NmGccMsgHandler

-------------------------------------------------------------------------*/
void CALLBACK NmGccMsgHandler(GCCAppSapMsg * pMsg)
{
	TRACE_OUT(("NmGccMsgHandler: [%d]", pMsg->eMsgType));

	CNmChannelData * psc = (CNmChannelData *) (pMsg->pAppData);
	ASSERT(NULL != psc);
	psc->AddRef();

	switch (pMsg->eMsgType)
		{
	case GCC_PERMIT_TO_ENROLL_INDICATION:
		TRACE_OUT((" m_conference_id = %X", pMsg->AppPermissionToEnrollInd.nConfID));
		TRACE_OUT((" permission = %X", pMsg->AppPermissionToEnrollInd.fPermissionGranted));
		if ((SCS_CONNECTED == psc->m_scs) &&
			(0 == pMsg->AppPermissionToEnrollInd.fPermissionGranted))
		{
			psc->CloseConnection();
			break;
		}

		if (SCS_CREATESAP != psc->m_scs)
		{
			TRACE_OUT((" ignoring Enroll Indication"));
			break;
		}
		psc->m_gcc_conference_id = pMsg->AppPermissionToEnrollInd.nConfID;
		psc->UpdateScState(SCS_CREATESAP, !pMsg->AppPermissionToEnrollInd.fPermissionGranted);
		break;

	case GCC_ENROLL_CONFIRM:
		TRACE_OUT((" result = %s", GetGccResultString(pMsg->AppEnrollConfirm.nResult)));

		if (GCC_RESULT_SUCCESSFUL == pMsg->AppEnrollConfirm.nResult)
		{
			TRACE_OUT((" m_conference_id = %X", pMsg->AppEnrollConfirm.nConfID));
			TRACE_OUT((" entity_id = %X", pMsg->AppEnrollConfirm.eidMyself));
			TRACE_OUT((" node_id = %X", pMsg->AppEnrollConfirm.nidMyself));
			psc->m_gcc_node_id = pMsg->AppEnrollConfirm.nidMyself;
		}
		break;

	case GCC_APP_ROSTER_REPORT_INDICATION:
		if(psc->UpdateRoster(pMsg) && psc->m_scs == SCS_ENROLL)
		{
			psc->UpdateScState(SCS_ENROLL, GCC_RESULT_SUCCESSFUL);
		}
		break;

	case GCC_REGISTER_CHANNEL_CONFIRM:
		DbgMsgDc("GCC_REGISTER_CHANNEL_CONFIRM: channel id = %04X  result = %s",
			pMsg->RegistryConfirm.pRegItem->channel_id,
			GetGccResultString(pMsg->RegistryConfirm.nResult));
		if (GCC_RESULT_SUCCESSFUL == pMsg->RegistryConfirm.nResult)
		{
			if (psc->GetMcsChannelId() ==
				pMsg->RegistryConfirm.pRegItem->channel_id)
			{
				ASSERT((0 == psc->m_gcc_registry_item.item_type) ||
					(GCC_REGISTRY_NONE == psc->m_gcc_registry_item.item_type));

    		    ASSERT(sizeof(psc->m_gcc_registry_item) == sizeof(*(pMsg->RegistryConfirm.pRegItem)));
				CopyMemory(&psc->m_gcc_registry_item, pMsg->RegistryConfirm.pRegItem,
					sizeof(psc->m_gcc_registry_item));
			}
			else
			{
				ASSERT(psc->SenderChannelId() ==
						pMsg->RegistryConfirm.pRegItem->channel_id);
				ASSERT(0 == psc->m_registry_item_Private.item_type);

    		    ASSERT(sizeof(psc->m_registry_item_Private) == sizeof(*(pMsg->RegistryConfirm.pRegItem)));
				CopyMemory(&psc->m_registry_item_Private, pMsg->RegistryConfirm.pRegItem,
					sizeof(psc->m_registry_item_Private));
			}
		}
		ASSERT((SCS_REGCHANNEL == psc->m_scs) || (SCS_REGPRIVATE == psc->m_scs));
		psc->UpdateScState(psc->m_scs, pMsg->RegistryConfirm.nResult);
		break;

	case GCC_RETRIEVE_ENTRY_CONFIRM:
		psc->ProcessEntryConfirm(pMsg);
		break;

	case GCC_ALLOCATE_HANDLE_CONFIRM:
		psc->ProcessHandleConfirm(pMsg);
		break;

	default:
		break;
		}

	psc->Release();
}



/*  N M  M C S  M S G  H A N D L E R  */
/*-------------------------------------------------------------------------
    %%Function: NmMcsMsgHandler

-------------------------------------------------------------------------*/
void CALLBACK NmMcsMsgHandler(unsigned int uMsg, LPARAM lParam, PVOID pv)
{
	CNmChannelData * psc = (CNmChannelData *) pv;
	ASSERT(NULL != psc);
//	TRACE_OUT(("[%s]", GetMcsMsgString(uMsg)));
	psc->AddRef();

	switch (uMsg)
		{
	case MCS_ATTACH_USER_CONFIRM:
	{
		DbgMsgDc("MCS_ATTACH_USER_CONFIRM channelId=%04X result=%s",
			LOWORD(lParam), GetMcsResultString(HIWORD(lParam) ));
		if (RESULT_SUCCESSFUL == HIWORD(lParam))
		{
			DbgMsgDc(" Local m_mcs_sender_id = %04X", LOWORD(lParam));
			psc->m_mcs_sender_id = LOWORD(lParam);
		}
		psc->UpdateScState(SCS_ATTACH, (DWORD) HIWORD(lParam));
		break;
	}

	case MCS_CHANNEL_JOIN_CONFIRM:
	{
		DbgMsgDc("MCS_CHANNEL_JOIN_CONFIRM channelId=%04X result=%s",
			LOWORD(lParam), GetMcsResultString(HIWORD(lParam) ));
		if (RESULT_SUCCESSFUL == HIWORD(lParam))
		{
			if (psc->m_mcs_sender_id == LOWORD(lParam))
			{
				ASSERT(SCS_JOIN_PRIVATE == psc->m_scs);
			}
			else
			{
				ASSERT((0 == psc->m_mcs_channel_id) ||
					(psc->m_mcs_channel_id == LOWORD(lParam)));

				psc->m_mcs_channel_id = LOWORD(lParam);
			}			
		}
		ASSERT((SCS_JOIN_NEW == psc->m_scs) ||
		       (SCS_JOIN_OLD == psc->m_scs) ||
		       (SCS_JOIN_PRIVATE == psc->m_scs) ||
			   (SCS_CONNECTED == psc->m_scs)||
			   (SCS_JOIN_STATIC_CHANNEL == psc->m_scs));

		psc->UpdateScState(psc->m_scs, (DWORD) HIWORD(lParam));
		break;
	}

	case MCS_UNIFORM_SEND_DATA_INDICATION:
	case MCS_SEND_DATA_INDICATION:  // lParam == SendData *
	{
		SendData * pSendData = (SendData *) lParam;
		ASSERT(NULL != pSendData);
		CNmMember * pMember = psc->PMemberFromSenderId(pSendData->initiator);

		if (NULL != pMember)
		{
            if (uMsg == MCS_UNIFORM_SEND_DATA_INDICATION)
            {
                //
                // Skip UNIFORM notifications that came from us
                //

                ULONG memberID;
                pMember->GetID(&memberID);

                if (memberID == psc->m_gcc_node_id)
                {
                    // We sent this, skip it.
                    goto RelMember;
                }
            }

			ASSERT (pSendData->segmentation == (SEGMENTATION_BEGIN | SEGMENTATION_END));
					
			NMN_DATA_XFER nmnData;
			nmnData.pMember =(INmMember *) pMember;
			nmnData.pb = pSendData->user_data.value;
			nmnData.cb = pSendData->user_data.length;
			nmnData.dwFlags = (ULONG)
				(NM_DF_SEGMENT_BEGIN | NM_DF_SEGMENT_END) |
				((psc->GetMcsChannelId() == pSendData->channel_id) ?
				NM_DF_BROADCAST : NM_DF_PRIVATE);

			psc->NotifySink((PVOID) &nmnData, OnNmDataReceived);

RelMember:
			pMember->Release();
		}
		break;
	}
	
	default:
		break;
		}

	psc->Release();
}



//
//	CNmMemberId
//

CNmMemberId::CNmMemberId(CNmMember *pMember, UCID * pucid) :
	m_channelId(pucid->channelId),
	m_sender_id_public(pucid->sender_id_public),
	m_sender_id_private(pucid->sender_id_private),
	m_cCheckId(0),
	m_pMember(pMember)
{
}

VOID CNmMemberId::UpdateRosterInfo(UCID * pucid)
{
	if (0 == m_channelId)
		m_channelId = pucid->channelId;
	if (0 == m_sender_id_private)
		m_sender_id_private = pucid->sender_id_private;
	if (0 == m_sender_id_public)
		m_sender_id_public = pucid->sender_id_public;
}

//
// CNmChannelData
//

CNmChannelData::CNmChannelData(CConfObject * pConference, REFGUID rguid, PGCCEnrollRequest pER) :
	CConnectionPointContainer(g_apiidCP, ARRAY_ELEMENTS(g_apiidCP)),
	m_pConference(pConference),
	m_fClosed(TRUE),
	m_fActive(FALSE),
	m_cMember(0),
	m_pListMemberId(NULL),
	m_pListMember(NULL),
	m_pGCCER(pER)
{
	m_guid = rguid;
	ASSERT(GUID_NULL != rguid);

	m_dwUserIdLocal = pConference->GetDwUserIdLocal();
	ASSERT(INVALID_GCCID != m_dwUserIdLocal);

	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CNmChannelData", this);
}


CNmChannelData::~CNmChannelData(void)
{
    DBGENTRY(CNmChannelData::~CNmChannelData);

		// This will keep us from being deleted again...
	++m_ulcRef;

	CloseConnection();

	FreeMemberIdList(&m_pListMemberId);
	delete m_pListMember;

	if(m_pConference)
	{
		m_pConference->RemoveDataChannelGUID(m_guid);
	}

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CNmChannelData", this);

    DBGEXIT(CNmChannelData::~CNmChannelData);
}


/*  A D D  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: AddMember

-------------------------------------------------------------------------*/
VOID CNmChannelData::AddMember(CNmMember * pMember)
{
	DbgMsgDc("CNmChannelData::AddMember [%ls] id=%08X",
		pMember->GetName(), pMember->GetGCCID());

	m_cMember++;
	pMember->AddRef();
	AddNode(pMember, &m_pListMember);

	INmMember * pNmMember = (INmMember *) pMember;
	NotifySink(pNmMember, OnNotifyChannelMemberAdded);
}


/*  R E M O V E  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: RemoveMember

-------------------------------------------------------------------------*/
VOID CNmChannelData::RemoveMember(CNmMember * pMember)
{
	DbgMsgDc("CNmChannelData::RemoveMember [%ls] id=%08X",
		pMember->GetName(), pMember->GetGCCID());

	m_cMember--;
	ASSERT((int)m_cMember >= 0);
	RemoveNode(pMember, m_pListMember);

	INmMember * pNmMember = (INmMember *) pMember;
	NotifySink(pNmMember, OnNotifyChannelMemberRemoved);

 	pMember->Release(); // Release AFTER notifying everyone
}


/*  O P E N  C O N N E C T I O N  */
/*-------------------------------------------------------------------------
    %%Function: OpenConnection

    Open a T.120 data connection (init both public and private channels)
-------------------------------------------------------------------------*/
HRESULT	CNmChannelData::OpenConnection(void)
{
	TRACE_OUT(("CNmChannelData::OpenConection()"));

	if (!m_fClosed)
		return E_FAIL; // already open
	m_fClosed = FALSE; // need to call CloseConnection after this

	if (FAILED(PFNT120::Init()))
		return E_FAIL;

	InitCT120Channel(m_dwUserIdLocal);
	return S_OK;
}


/*  C L O S E  C O N N E C T I O N  */
/*-------------------------------------------------------------------------
    %%Function: CloseConnection

	Close the data channel - this matches what is done in OpenConnection
-------------------------------------------------------------------------*/
HRESULT CNmChannelData::CloseConnection(void)
{
	DBGENTRY(CNmChannelData::CloseConnection);

    HRESULT hr = S_OK;

	if (!m_fClosed)
    {
	    m_fClosed = TRUE;

	    // Close any open T.120 channels
		CloseChannel();

	    if (0 != m_cMember)
	    {
		    // force roster update with no peers
		    DbgMsgDc("CloseConnection: %d members left", m_cMember);
		    UpdateRoster(NULL, 0, FALSE, TRUE /* fRemove */);
		    ASSERT(IsEmpty());
	    }

	    CConfObject * pConference = PConference();
	    if (NULL != pConference)
	    {
	    	m_fActive = FALSE;
		    // The channel is now officially inactive
		    pConference->OnChannelUpdated(this);
	    }
    }

    DBGEXIT_HR(CNmChannelData::CloseConnection, hr);
	return hr;
}


/*  U P D A T E  P E E R  */
/*-------------------------------------------------------------------------
    %%Function: UpdatePeer

-------------------------------------------------------------------------*/
VOID CNmChannelData::UpdatePeer(CNmMember * pMember, UCID *pucid, BOOL fAdd)
{
#ifdef DEBUG
	DbgMsgDc("UpdatePeer (%08X) fAdd=%d fLocal=%d", pMember, fAdd, pMember->FLocal());
	if (NULL != pucid)
	{
		DbgMsgDc(" channelId=(%04X) dwUserId=%08X", pucid->channelId, pucid->dwUserId);
	}
#endif /* DEBUG */

	if (fAdd)
	{
		CNmMemberId *pMemberId = new CNmMemberId(pMember, pucid);
		if (NULL != pMemberId)
		{
			AddNode(pMemberId, &m_pListMemberId);
			AddMember(pMember);
		}
	}
	else
	{
		CNmMemberId *pMemberId = GetMemberId(pMember);
		if (NULL != pMemberId)
		{
			RemoveNode(pMemberId, m_pListMemberId);
			delete pMemberId;
			RemoveMember(pMember);
		}
	}
}

/*  U P D A T E  R O S T E R  */
/*-------------------------------------------------------------------------
    %%Function: UpdateRoster

    Update the local peer list based on the new roster data
-------------------------------------------------------------------------*/
VOID CNmChannelData::UpdateRoster(UCID * rgPeer, int cPeer, BOOL fAdd, BOOL fRemove)
{
	int   iPeer;
	DWORD dwUserId;
	CNmMember * pMember;
	COBLIST * pList;

	DbgMsgDc("CNmChannelData::UpdateRoster: %d peers, fAdd=%d, fRemove=%d",
		cPeer, fAdd, fRemove);

	if (NULL != m_pListMemberId)
	{
		for (POSITION pos = m_pListMemberId->GetHeadPosition(); NULL != pos; )
		{
			BOOL fFound = FALSE;
			CNmMemberId *pMemberId = (CNmMemberId *) m_pListMemberId->GetNext(pos);
			ASSERT(NULL != pMemberId);
			pMember = pMemberId->GetMember();
			ASSERT(NULL != pMember);
			dwUserId = pMember->GetGCCID();

			if (0 != dwUserId)
			{
				for (iPeer = 0; iPeer < cPeer; iPeer++)
				{
					if (dwUserId == rgPeer[iPeer].dwUserId)
					{
						fFound = TRUE;
						// remove from the new list
						// so that the peer will not be added below
						rgPeer[iPeer].dwUserId = 0;

						// no change, but make sure we know sender_ids
						pMemberId->UpdateRosterInfo(&rgPeer[iPeer]);

						// try to find channel id, if necessary
						if ((0 == pMemberId->GetChannelId()) &&
							(0 == pMemberId->GetCheckIdCount())
							&& !pMember->FLocal())
						{
							pMemberId->SetCheckIdCount(MAX_CHECKID_COUNT);
							RequestChannelId(dwUserId);
						}
						break;
					}
				}
			}

			if (!fFound && fRemove)
			{
				pMember->AddRef();

				// Unable to find old peer in new list - delete it
				UpdatePeer(pMember, NULL, FALSE /* fAdd */ );

				pMember->Release();
			}
		}
	}

	if (!fAdd)
		return;


	// Use the conference list to find member data
	pList = PConference()->GetMemberList();
	/* Add new peers */
	for (iPeer = 0; iPeer < cPeer; iPeer++)
	{
		dwUserId = rgPeer[iPeer].dwUserId;
		if (0 == dwUserId)
			continue;

		// PMemberFromDwUserId returns AddRef'd member
		pMember = PMemberFromDwUserId(dwUserId, pList);

		if (NULL == pMember)
		{
			WARNING_OUT(("UpdateRoster: Member not found! dwUserId=%08X", dwUserId));
		}
		else
		{
			UpdatePeer(pMember, &rgPeer[iPeer], TRUE /* fAdd */);
			pMember->Release();
		}
	}
}


/*  U P D A T E  M E M B E R  C H A N N E L  I D  */
/*-------------------------------------------------------------------------
    %%Function: UpdateMemberChannelId

-------------------------------------------------------------------------*/
VOID CNmChannelData::UpdateMemberChannelId(DWORD dwUserId, ChannelID channelId)
{
		// PMemberFromDwUserId returns AddRef'd member
	CNmMember * pMember = PMemberFromDwUserId(dwUserId, PConference()->GetMemberList());
	TRACE_OUT(("Member (%08X) private channelId=(%04X)", pMember, channelId));
	if (NULL != pMember)
	{
		UCID ucid;
		ClearStruct(&ucid);
		ucid.channelId = channelId;
		UpdateRosterInfo(pMember, &ucid);
		pMember->Release();
	}
}


/*  G E T  M E M B E R  I D  */
/*-------------------------------------------------------------------------
    %%Function: GetMemberId

-------------------------------------------------------------------------*/
CNmMemberId * CNmChannelData::GetMemberId(CNmMember *pMember)
{
	if (NULL != m_pListMemberId)
	{
		POSITION pos = m_pListMemberId->GetHeadPosition();
		while (NULL != pos)
		{
			CNmMemberId *pMemberId = (CNmMemberId *) m_pListMemberId->GetNext(pos);
			ASSERT(NULL != pMemberId);
			if (pMemberId->GetMember() == pMember)
			{
				return pMemberId;
			}
		}
	}
	return NULL;
}

/*  G E T  M E M B E R  I D  */
/*-------------------------------------------------------------------------
    %%Function: GetMemberId

-------------------------------------------------------------------------*/
CNmMemberId * CNmChannelData::GetMemberId(DWORD dwUserId)
{
	if (NULL != m_pListMemberId)
	{
		POSITION pos = m_pListMemberId->GetHeadPosition();
		while (NULL != pos)
		{
			CNmMemberId *pMemberId = (CNmMemberId *) m_pListMemberId->GetNext(pos);
			ASSERT(NULL != pMemberId);
			CNmMember *pMember = pMemberId->GetMember();
			ASSERT(NULL != pMember);
			if (pMember->GetGCCID() == dwUserId)
			{
				return pMemberId;
			}
		}
	}
	return NULL;
}


/*  U P D A T E  R O S T E R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: UpdateRosterInfo

-------------------------------------------------------------------------*/
VOID CNmChannelData::UpdateRosterInfo(CNmMember *pMember, UCID * pucid)
{
	CNmMemberId *pMemberId = GetMemberId(pMember);
	if (NULL != pMemberId)
	{
		pMemberId->UpdateRosterInfo(pucid);
	}
}

/*  G E T  C H A N N E L  I D  */
/*-------------------------------------------------------------------------
    %%Function: GetChannelId

-------------------------------------------------------------------------*/
ChannelID CNmChannelData::GetChannelId(CNmMember *pMember)
{
	CNmMemberId *pMemberId = GetMemberId(pMember);
	if (NULL != pMemberId)
	{
		return pMemberId->GetChannelId();
	}
	return 0;
}

/*  P  M E M B E R  F R O M  S E N D E R  I D  */
/*-------------------------------------------------------------------------
    %%Function: PMemberFromSenderId

-------------------------------------------------------------------------*/
CNmMember * CNmChannelData::PMemberFromSenderId(UserID id)
{
	if (NULL != m_pListMemberId)
	{
		POSITION pos = m_pListMemberId->GetHeadPosition();
		while (NULL != pos)
		{
			CNmMemberId * pMemberId = (CNmMemberId *) m_pListMemberId->GetNext(pos);
			ASSERT(NULL != pMemberId);
			if (pMemberId->FSenderId(id))
			{
				CNmMember* pMember = pMemberId->GetMember();
				ASSERT(NULL != pMember);
				pMember->AddRef();
				return pMember;
			}
		}
	}
	return NULL;
}

///////////////////////////
//  CNmChannelData:IUknown

ULONG STDMETHODCALLTYPE CNmChannelData::AddRef(void)
{
    TRACE_OUT(("CNmChannelData::AddRef this = 0x%X", this));
	return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CNmChannelData::Release(void)
{
    TRACE_OUT(("CNmChannelData::Release this = 0x%X", this));
	return RefCount::Release();
}


HRESULT STDMETHODCALLTYPE CNmChannelData::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_IUnknown) ||  (riid == IID_INmChannelData2) || (riid == IID_INmChannelData) || (riid == IID_INmChannel))
	{
		*ppv = (INmChannelData2 *)this;
		TRACE_OUT(("CNmChannel::QueryInterface(): Returning INmChannelData."));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		TRACE_OUT(("CNmChannel::QueryInterface(): Returning IConnectionPointContainer."));
	}

	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		TRACE_OUT(("CNmChannel::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}


///////////////////////
// INmChannelData

HRESULT STDMETHODCALLTYPE CNmChannelData::GetGuid(GUID *pGuid)
{
	if (NULL == pGuid)
		return E_POINTER;

	*pGuid = m_guid;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::SendData(INmMember *pMember, ULONG cb, LPBYTE pv, ULONG uOptions)
{
	HRESULT hr = S_OK;

	if (!m_fActive)
	{
		// No active Channels, yet
		return E_FAIL;
	}

	if ((NULL == pv) || (0 == cb))
	{
		return S_FALSE;
	}
	if (IsBadReadPtr(pv, cb))
	{
		return E_POINTER;
	}

	CNmMember * pDest = (CNmMember *) pMember;
	COBLIST * pList = GetMemberList();
	if (NULL == pMember)
	{
		hr = HrSendData(GetMcsChannelId(), 0, pv, cb, uOptions);
	}
	else if ((NULL == pList) || (NULL == pList->Lookup(pDest)) )
	{
		// Destination is not in list
		hr = E_INVALIDARG;
	}
	else
	{
		ChannelID channel_id = GetChannelId(pDest);
		if (0 == channel_id)
		{
			WARNING_OUT(("Unable to find user destination channel?"));

			CNmMemberId *pMemberId = GetMemberId(pDest);
			if (NULL == pMemberId)
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				channel_id = pMemberId->SenderId();
				hr = (0 == channel_id) ? E_FAIL : S_OK;
			}
		}
		
		if (SUCCEEDED(hr))
		{
			hr = HrSendData(channel_id, pDest->GetGCCID(), pv, cb, uOptions);
		}
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::RegistryAllocateHandle(ULONG numberOfHandlesRequested)
{
	if (!m_fActive)
	{
		// No active Channels, yet
		return E_FAIL;
	}

	if(numberOfHandlesRequested == 0)
	{
		return E_INVALIDARG;
	}

	//
	// Request handles from gcc
	//
	GCCError gccError = m_gcc_pIAppSap->RegistryAllocateHandle(m_gcc_conference_id, numberOfHandlesRequested);
	
	if(gccError == GCC_NO_ERROR)
	{
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}

///////////////
// INmChannel

HRESULT STDMETHODCALLTYPE CNmChannelData::IsSameAs(INmChannel *pChannel)
{
	HRESULT hr;
	PVOID pv;

	if (pChannel == NULL)
	{
		hr = E_INVALIDARG;
	}
	else
	{
		hr = pChannel->QueryInterface(IID_INmChannelData, &pv);
		if (SUCCEEDED(hr))
		{
			hr = (this == (PVOID) ((CNmChannelData *)(INmChannelData *)pv)) ? S_OK : S_FALSE;
			((IUnknown *) pv)->Release();
		}
	}
	
	return hr;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::IsActive(void)
{
	return m_fActive ? S_OK : S_FALSE;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::SetActive(BOOL fActive)
{
	TRACE_OUT(("CNmChannelData::SetActive(%d)", fActive));

	NM_CONFERENCE_STATE state;
	// Must be in a non-idle conference
	CConfObject * pConference = PConference();
	pConference->GetState(&state);
	if ((NULL == pConference) || state == NM_CONFERENCE_IDLE)
		return E_FAIL;

	if (fActive)
	{
		if (S_OK == IsActive())
			return S_OK;
		return OpenConnection();
	}
	else
	{
		if (S_FALSE == IsActive())
			return S_OK;
		return CloseConnection();
	}
}


HRESULT STDMETHODCALLTYPE CNmChannelData::GetConference(INmConference **ppConference)
{
	return ::GetConference(ppConference);
}

HRESULT STDMETHODCALLTYPE CNmChannelData::GetInterface(IID *piid)
{
	HRESULT hr = E_POINTER;
	if (NULL != piid)
	{
		*piid = IID_INmChannelData;
		hr = S_OK;
	}
	return hr;
}
	

HRESULT STDMETHODCALLTYPE CNmChannelData::GetNmch(ULONG *puch)
{
	HRESULT hr = E_POINTER;

	if (NULL != puch)
	{
		*puch = NMCH_DATA;
		hr = S_OK;
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::EnumMember(IEnumNmMember **ppEnum)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppEnum)
	{
		*ppEnum = new CEnumNmMember( GetMemberList(), m_cMember);

		hr = (NULL != *ppEnum)? S_OK : E_OUTOFMEMORY;
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::GetMemberCount(ULONG *puCount)
{
	HRESULT hr = E_POINTER;

	if (NULL != puCount)
	{
		*puCount = m_cMember;
		hr = S_OK;
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////
// Utility Functions

HRESULT OnNmDataSent(IUnknown *pChannelDataNotify, void *pv, REFIID riid)
{
	NMN_DATA_XFER * pData = (NMN_DATA_XFER *) pv;

    if (IID_INmChannelDataNotify.Data1 == riid.Data1 || IID_INmChannelDataNotify2.Data1 == riid.Data1)
    {
	    ((INmChannelDataNotify2*)pChannelDataNotify)->DataSent(
		    pData->pMember, pData->cb, pData->pb);
    }
	return S_OK;
}

HRESULT OnNmDataReceived(IUnknown *pChannelDataNotify, void *pv, REFIID riid)
{
	NMN_DATA_XFER * pData = (NMN_DATA_XFER *) pv;

    if (IID_INmChannelDataNotify.Data1 == riid.Data1 || IID_INmChannelDataNotify2.Data1 == riid.Data1)
    {
	    ((INmChannelDataNotify2*)pChannelDataNotify)->DataReceived(
		    pData->pMember, pData->cb, pData->pb, pData->dwFlags);
    }
	return S_OK;
}

HRESULT OnAllocateHandleConfirm(IUnknown *pChannelDataNotify, void *pv, REFIID riid)
{


	if(IID_INmChannelDataNotify2.Data1 == riid.Data1)
	{
		GCCRegAllocateHandleConfirm *pConfirm =  (GCCRegAllocateHandleConfirm *)pv;

		((INmChannelDataNotify2*)pChannelDataNotify)->AllocateHandleConfirm(pConfirm->nFirstHandle,
															    pConfirm->cHandles);
	}											
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////
// Utility Functions

/*  F R E E  M E M B E R  ID  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: FreeMemberIdList

-------------------------------------------------------------------------*/
VOID FreeMemberIdList(COBLIST ** ppList)
{
	DBGENTRY(FreeMemberIdList);

	ASSERT(NULL != ppList);
	if (NULL != *ppList)
	{
		while (!(*ppList)->IsEmpty())
		{
			CNmMemberId * pMemberId = (CNmMemberId *)  (*ppList)->RemoveHead();
			delete pMemberId;
		}
		delete *ppList;
		*ppList = NULL;
	}
}


///////////////////////////////////////////////////////////////////////////
//
// GCC / MCS Errors

#ifdef DEBUG
LPCTSTR _FormatSzErr(LPTSTR psz, UINT uErr)
{
	static char szErr[MAX_PATH];
	wsprintf(szErr, "%s 0x%08X (%d)", psz, uErr, uErr);
	return szErr;
}

#define STRING_CASE(val)               case val: pcsz = #val; break

LPCTSTR GetGccErrorString(GCCError uErr)
{
	LPCTSTR pcsz;

	switch (uErr)
		{
	STRING_CASE(GCC_NO_ERROR);
	STRING_CASE(GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	STRING_CASE(GCC_NOT_INITIALIZED);
	STRING_CASE(GCC_ALREADY_INITIALIZED);
	STRING_CASE(GCC_ALLOCATION_FAILURE);
	STRING_CASE(GCC_NO_SUCH_APPLICATION);
	STRING_CASE(GCC_INVALID_CONFERENCE);

	default:
		pcsz = _FormatSzErr("GccError", uErr);
		break;
		}

	return pcsz;
}

LPCTSTR GetMcsErrorString(MCSError uErr)
{
	LPCTSTR pcsz;

	switch (uErr)
		{
	STRING_CASE(MCS_NO_ERROR);
	STRING_CASE(MCS_USER_NOT_ATTACHED);
	STRING_CASE(MCS_NO_SUCH_USER);
	STRING_CASE(MCS_TRANSMIT_BUFFER_FULL);
	STRING_CASE(MCS_NO_SUCH_CONNECTION);

	default:
		pcsz = _FormatSzErr("McsError", uErr);
		break;
		}

	return pcsz;
}

LPCTSTR GetGccResultString(UINT uErr)
{
	LPCTSTR pcsz;

	switch (uErr)
		{
	STRING_CASE(GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	default:
		pcsz = _FormatSzErr("GccResult", uErr);
		break;
		}

	return pcsz;
}

LPCTSTR GetMcsResultString(UINT uErr)
{
	return _FormatSzErr("McsResult", uErr);
}
#endif /* DEBUG (T.120 Error routines) */



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\iconf.h ===
/***************************************************************************/
/** 				 Microsoft Windows									  **/
/** 		   Copyright(c) Microsoft Corp., 1995-1996					  **/
/***************************************************************************/

//
//	File:		iconf.h
//	Created:	ChrisPi 	12/6/95
//	Modified:
//
//	The CConfObject class is defined
//

#ifndef _ICONF_H_
#define _ICONF_H_

#include <inodecnt.h>
#include "h323.h"
#include "connpnts.h"
#include "medialst.h"
#include <atlbase.h>
#include <lst.h>

enum CONFSTATE
{
	CS_UNINITIALIZED,
	CS_CREATING,
	CS_COMING_UP,
	CS_RUNNING,
	CS_GOING_DOWN,
	CS_TERMINATED
};

enum AC_TYPE
{
	CLT_T120,
	CLT_H323
};

class CNmMember;
class CNmChannelAudio;
class CNmChannelVideo;
class CNmChannelData;

class CConfObject : public INmConference2, public CConnectionPointContainer,
    public IStreamEventNotify
{
protected:
	COBLIST m_MemberList;
	COBLIST m_DataChannelGUIDS;

	CNmChannelAudio * m_pChannelAudioLocal;
	CNmChannelVideo * m_pChannelVideoLocal;
	CNmChannelAudio * m_pChannelAudioRemote;
	CNmChannelVideo * m_pChannelVideoRemote;
    IH323ConfAdvise * m_pIH323ConfAdvise;
	// Attributes:
	
	CONFSTATE		m_csState;
	CONF_HANDLE 	m_hConf;
	BOOL			m_fConferenceCreated;
	BOOL			m_fServerMode;

	BSTR            m_bstrConfName;
	BSTR            m_bstrConfPassword;
	PBYTE		    m_pbConfHashedPassword;
	DWORD		    m_cbConfHashedPassword;

    NM30_MTG_PERMISSIONS m_attendeePermissions;
    UINT            m_maxParticipants;

	CNmMember * 	m_pMemberLocal;
	UINT			m_uDataMembers;
	UINT			m_uH323Endpoints;
	UINT			m_uMembers;
	UINT			m_ourNodeID;
	UINT			m_uGCCConferenceID;
	ULONG			m_cRef;
	BOOL			m_fSecure;

	VOID			AddMember(CNmMember * pMember, IH323Endpoint * pConnection);
	VOID			RemoveMember(POSITION pos);
	VOID			RemoveMember(CNmMember * pMember)
					{
						POSITION pos = m_MemberList.GetPosition(pMember);
						if (NULL != pos)
						{
							RemoveMember(pos);
						}
					}
	VOID			ResetDataMember(CNmMember * pMember,
											ROSTER_DATA_HANDLE hData);
    VOID            RemoveOldDataMembers(int nExpected);
	CNmMember *     MatchDataToH323Member(REFGUID pguidNodeId,
								UINT uNodeId,
								PVOID pvUserInfo);
	VOID			AddDataToH323Member(CNmMember * pMember,
								PVOID pvUserInfo,
								UINT cbUserInfo,
								UINT uCaps,
								NC_ROSTER_NODE_ENTRY* pRosterNode);
	CNmMember * 	CreateDataMember(BOOL fLocal, 
								REFGUID pguidNodeId,
								PVOID pvUserInfo,
								UINT cbUserInfo,
								UINT uCaps,
								NC_ROSTER_NODE_ENTRY* pRosterNode);
	CNmMember * 	MatchH323ToDataMembers(REFGUID pguidNodeId,
								IH323Endpoint * pConnection);
    
	VOID			CreateMember(IH323Endpoint * pConnection, REFGUID rguidNode, UINT uNodeID);
	VOID			AddH323ToDataMember(CNmMember * pMember, IH323Endpoint * pConnection);
	VOID			RemoveH323FromDataMember(CNmMember * pMember, IH323Endpoint * pConnection);
	VOID			SetT120State(CONFSTATE state);
	VOID			OnH323ChannelChange(DWORD dwFlags, BOOL fIncoming, BOOL fOpen, ICommChannel *pIChannel);
	VOID			AddMemberToAVChannels(CNmMember *pMember);
	VOID			RemoveMemberFromAVChannels(CNmMember *pMember);
	VOID			CreateAVChannels(IH323Endpoint * pConnection, CMediaList* pMediaList);
    VOID            OpenAVChannels(IH323Endpoint * pConnection, CMediaList* pMediaList);
	VOID			DestroyAVChannels();
	ICommChannel *	CreateT120Channel(IH323Endpoint * pConnection, CMediaList* pMediaList);
    VOID            OpenT120Channel(IH323Endpoint * pConnection, CMediaList* pMediaList, ICommChannel *pChannelT120);
	VOID		    CheckState(NM_CONFERENCE_STATE pState);

	HRESULT __stdcall EventNotification(UINT uDirection, UINT uMediaType, UINT uEventCode, UINT uSubCode);


public:
	
	// Methods:

				CConfObject();
				~CConfObject();
    VOID        Init(IH323ConfAdvise * pci) {m_pIH323ConfAdvise = pci; };
	VOID		OnConferenceCreated() {m_fConferenceCreated = TRUE; }
	VOID		OnMemberUpdated(INmMember *pMember);
	VOID		OnChannelUpdated(INmChannel *pChannel);
	
	HRESULT 	CreateConference(void);
	HRESULT 	JoinConference(LPCWSTR	pcwszConferenceName,
							   LPCWSTR	pcwszPassword,
							   LPCSTR	pcszAddress,
							   BSTR		bstrUserString,
							   BOOL		fRetry = FALSE);
	HRESULT 	InviteConference(LPCSTR pszAddr,
								 BSTR bstrUserString,
	                             REQUEST_HANDLE *phRequest);
	HRESULT 	LeaveConference(BOOL fForceLeave=TRUE);
	HRESULT		CancelInvite(REQUEST_HANDLE hRequest)
				{
					if (NULL == m_hConf)
					{
						return E_FAIL;
					}
					return m_hConf->CancelInvite(hRequest);
				}

    HRESULT     LeaveH323(BOOL fKeepAV);

	// Properties:

	BSTR	 	GetConfName()			{ return m_bstrConfName;         };
	UINT		GetOurNodeID()			{ return m_ourNodeID;				};
	UINT		GetGCCConferenceID()	{ return m_uGCCConferenceID;		};
	UINT		GetNumMembers()			{ return m_uMembers;			};
	BOOL		InCall()				{ return (m_uMembers > 0); 	};
	COBLIST*	GetMemberList()			{ return &m_MemberList;		};
	CONF_HANDLE GetConfHandle() 		{ return m_hConf;					};
	CONFSTATE	GetT120State()			{ return m_csState; 				};
	BOOL		IsConferenceActive()	{ return m_hConf!= NULL;			};
	BOOL		IsConferenceCreated()	{ return m_fConferenceCreated;		};
	BOOL		IsConfObjSecure()		{ return m_fSecure; };
	CNmMember * GetLocalMember()		{ return m_pMemberLocal;			};
    NM30_MTG_PERMISSIONS GetConfAttendeePermissions() { return m_attendeePermissions; }
    UINT        GetConfMaxParticipants() { return m_maxParticipants; }

	DWORD       GetDwUserIdLocal(void);
    HRESULT     GetMediaChannel (GUID *pmediaID,BOOL bSendDirection, IMediaChannel **ppI);

	VOID        SetConfName(BSTR bstr);
	VOID        SetConfPassword(BSTR bstr);
	VOID        SetConfHashedPassword(BSTR bstr);
	VOID        SetConfSecurity(BOOL fSecure);
    VOID        SetConfAttendeePermissions(NM30_MTG_PERMISSIONS attendeePermissions);
    VOID        SetConfMaxParticipants(UINT maxParticipants);
	
	CNmMember *	PMemberFromNodeGuid(REFGUID pguidNode);
	CNmMember *	PMemberFromGCCID(UINT uNodeID);
	CNmMember * PMemberFromH323Endpoint(IH323Endpoint * pConnection);
	CNmMember *	PDataMemberFromName(PCWSTR pwszName);

	// Event Handlers:
	
	VOID OnT120Connected(IH323Endpoint * pConnection, UINT uNodeID);

	// Data Conferencing (R1.1, T.120) events from NCUI:
	BOOL		OnRosterChanged(PNC_ROSTER pRoster);
	BOOL		OnT120Invite(CONF_HANDLE hConference, BOOL fSecure);
	BOOL		OnConferenceEnded();
	BOOL		OnConferenceStarted(CONF_HANDLE hNewConf,
									HRESULT Result);
									
	// H323 Connection events from opncui.cpp:
	VOID		OnH323Connected(IH323Endpoint * pConnection, DWORD dwFlags, BOOL fAddMember, REFGUID rguidNode);
	VOID		OnH323Disconnected(IH323Endpoint * pConnection, BOOL fHasAV);
	VOID		OnAudioChannelStatus(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus);
	VOID		OnVideoChannelStatus(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus);

	// INmConference
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	STDMETHODIMP GetName(BSTR *pbstrName);
	STDMETHODIMP GetID(ULONG *puID);
	STDMETHODIMP GetState(NM_CONFERENCE_STATE *pState);
	STDMETHODIMP GetNmchCaps(ULONG *puchCaps);
	STDMETHODIMP GetTopProvider(INmMember **ppMember);
	STDMETHODIMP EnumMember(IEnumNmMember **ppEnum);
	STDMETHODIMP GetMemberCount(ULONG *puCount);
	STDMETHODIMP EnumChannel(IEnumNmChannel **ppEnum);
	STDMETHODIMP GetChannelCount(ULONG *puCount);
	STDMETHODIMP CreateDataChannel(INmChannelData **ppChannel, REFGUID rguid);
	STDMETHODIMP IsHosting(void);
	STDMETHODIMP Host(void);
	STDMETHODIMP Leave(void);
	STDMETHODIMP LaunchRemote(REFGUID rguid, INmMember *pMember);

	// INmConference3
	STDMETHODIMP DisconnectAV(INmMember *pMember);
	STDMETHODIMP ConnectAV(INmMember *pMember);
	STDMETHODIMP GetConferenceHandle(DWORD_PTR *pdwHandle);
	STDMETHODIMP CreateDataChannelEx(INmChannelData **ppChannel, REFGUID rguid, BYTE* pER);

	void _EraseDataChannelGUIDS(void);
	void RemoveDataChannelGUID(REFGUID rguid);
};

CConfObject * GetConfObject(void);
HRESULT GetConference(INmConference **ppConference);
COBLIST * GetMemberList(void);

#endif /* _ICONF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\imanager.cpp ===
// File: imanager.cpp

#include "precomp.h"

extern "C"
{
	#include "t120.h"
}
#include <version.h>
#include <confcli.h>
#include "icall.h"
#include "icall_in.h"
#include "imanager.h"
#include "ichnlvid.h"
#include "isysinfo.h"
#include <tsecctrl.h>
#include <imbft.h>
#include <objbase.h>
#include <regentry.h>

#include <initguid.h>
// GUID to receive userdata from "callto:" via INmCall::GetUserData
//
// {068B0780-718C-11d0-8B1A-00A0C91BC90E}
DEFINE_GUID(GUID_CallToUserData,
0x068b0780, 0x718c, 0x11d0, 0x8b, 0x1a, 0x0, 0xa0, 0xc9, 0x1b, 0xc9, 0x0e);


class CH323ChannelEvent
{
private:
	ICommChannel *m_pIChannel;
	IH323Endpoint *m_lpConnection;
	DWORD m_dwStatus;

public:
	static DWORD ms_msgChannelEvent;

	CH323ChannelEvent(ICommChannel *pIChannel,
			IH323Endpoint *lpConnection,
			DWORD dwStatus):
		m_pIChannel(pIChannel),
		m_lpConnection(lpConnection),
		m_dwStatus(dwStatus)
	{
		if(!ms_msgChannelEvent)
		{
			ms_msgChannelEvent = RegisterWindowMessage(_TEXT("NetMeeting::H323ChannelEvent"));
		}
		
		m_pIChannel->AddRef();
		m_lpConnection->AddRef();
	}

	~CH323ChannelEvent()
	{
		m_pIChannel->Release();
		m_lpConnection->Release();
	}


	ICommChannel*	GetChannel() { return m_pIChannel; }
	IH323Endpoint*	GetEndpoint() { return m_lpConnection; }
	DWORD			GetStatus() { return m_dwStatus; }

};

//static
DWORD CH323ChannelEvent::ms_msgChannelEvent = 0;

static HRESULT OnNotifyConferenceCreated(IUnknown *pManagerNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyCallCreated(IUnknown *pManagerNotify, PVOID pv, REFIID riid);

GUID g_csguidRosterCaps = GUID_CAPS;
GUID g_csguidSecurity = GUID_SECURITY;
GUID g_csguidMeetingSettings = GUID_MTGSETTINGS;
GUID g_csguidUserString = GUID_CallToUserData;
GUID g_csguidNodeIdTag = GUID_NODEID;

// this guid is dynamically created each time we start
GUID g_guidLocalNodeId;



CH323UI* g_pH323UI = NULL;
INodeController* g_pNodeController = NULL;
SOCKADDR_IN g_sinGateKeeper;

const TCHAR cszDllHiddenWndClassName[] = _TEXT("OPNCUI_HiddenWindow");


COprahNCUI *COprahNCUI::m_pOprahNCUI = NULL;

static const IID * g_apiidCP_Manager[] =
{
    {&IID_INmManagerNotify}
};

COprahNCUI::COprahNCUI(OBJECTDESTROYEDPROC ObjectDestroyed) :
	RefCount(ObjectDestroyed),
	CConnectionPointContainer(g_apiidCP_Manager, ARRAY_ELEMENTS(g_apiidCP_Manager)),
	m_uCaps(0),
	m_pQoS(NULL),
	m_pPreviewChannel(NULL),
	m_fAllowAV(TRUE),
	m_pAVConnection(NULL),
	m_hwnd(NULL),
	m_pSysInfo(NULL),
    m_pOutgoingCallManager(NULL),
    m_pIncomingCallManager(NULL),
    m_pConfObject(NULL)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CNmManager", this);
	
//	DllLock() is called by CClClassFactory::CreateInstance
	m_pOprahNCUI = this;

	ClearStruct(&g_sinGateKeeper);
	g_sinGateKeeper.sin_addr.s_addr = INADDR_NONE;

	m_pSysInfo = new CNmSysInfo();
}


COprahNCUI::~COprahNCUI()
{
	// need to unregister the H323 callback
	// need to unregister the T120 callback

	delete m_pIncomingCallManager;
	m_pIncomingCallManager = NULL;

	delete m_pOutgoingCallManager;
	m_pOutgoingCallManager = NULL;

	if( m_pSysInfo )
	{
		m_pSysInfo->Release();
		m_pSysInfo = NULL;
	}

	if (m_pConfObject)
	{
		// turn off stream notifications
		if (g_pH323UI)
		{
			IMediaChannelBuilder *pStreamProvider = NULL;
			pStreamProvider = g_pH323UI->GetStreamProvider();
			if (pStreamProvider)
			{
				pStreamProvider->SetStreamEventObj(NULL);
				pStreamProvider->Release();
			}
		}

		m_pConfObject->Release();
		m_pConfObject = NULL;
	}

	if (NULL != m_pPreviewChannel)
	{
		m_pPreviewChannel->Release();
		m_pPreviewChannel = NULL;
	}

	// Shutdown H323
	delete g_pH323UI;
	g_pH323UI = NULL;

	if (NULL != m_hwnd)
	{
		HWND hwnd = m_hwnd;
		m_hwnd = NULL;

#if 0	// if we start leaking th CH323ChannelEvents we may need to reenable this
		MSG msg;
		while (::PeekMessage(&msg, hwnd,
					CH323ChannelEvent::ms_msgChannelEvent,
					CH323ChannelEvent::ms_msgChannelEvent,
					PM_REMOVE))
		{
			CH323ChannelEvent *pEvent = reinterpret_cast<CH323ChannelEvent*>(msg.lParam);
			delete pEvent;
		}
#endif
	
		::DestroyWindow(hwnd);
	}

        if (0==UnregisterClass(cszDllHiddenWndClassName, GetInstanceHandle()))
        {
            ERROR_OUT(("COprahNCUI::~COprahNCUI - failed to unregister window class"));
        }
	// cleanup the node controller:
	if (NULL != g_pNodeController)
	{
		g_pNodeController->ReleaseInterface();
		g_pNodeController = NULL;
	}
	// Shutdown QoS
	delete m_pQoS;
    m_pQoS = NULL;

	m_pOprahNCUI = NULL;

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CNmManager", this);
}

BSTR COprahNCUI::GetUserName()
{
	return m_pSysInfo ? m_pSysInfo->GetUserName() : NULL;
}

UINT COprahNCUI::GetOutgoingCallCount()
{
	return m_pOutgoingCallManager->GetCallCount();
}

VOID COprahNCUI::OnOutgoingCallCreated(INmCall* pCall)
{
	// notify the UI about this outgoing call
	NotifySink(pCall, OnNotifyCallCreated);

	if (!m_pConfObject->IsConferenceCreated())
	{
		m_pConfObject->OnConferenceCreated();
		NotifySink((INmConference*) m_pConfObject, OnNotifyConferenceCreated);
	}
}

VOID COprahNCUI::OnOutgoingCallCanceled(COutgoingCall* pCall)
{
	m_pOutgoingCallManager->RemoveFromList(pCall);
}

VOID COprahNCUI::OnIncomingCallAccepted()
{
	if (!m_pConfObject->IsConferenceCreated())
	{
		m_pConfObject->OnConferenceCreated();
		NotifySink((INmConference*) m_pConfObject, OnNotifyConferenceCreated);
	}
}

VOID COprahNCUI::OnIncomingCallCreated(INmCall* pCall)
{
	NotifySink(pCall, OnNotifyCallCreated);
}

VOID COprahNCUI::CancelCalls()
{
	m_pOutgoingCallManager->CancelCalls();
	m_pIncomingCallManager->CancelCalls();
}
			
BOOL COprahNCUI::AcquireAV(IH323Endpoint* pConnection)
{
	if (NULL == m_pAVConnection)
	{
		m_pAVConnection = pConnection;
		TRACE_OUT(("AV acquired"));
		return TRUE;
	}
	TRACE_OUT(("AV not acquired"));
	return FALSE;
}

BOOL COprahNCUI::ReleaseAV(IH323Endpoint* pConnection)
{
	if (m_pAVConnection == pConnection)
	{
		m_pAVConnection = NULL;
		TRACE_OUT(("AV released"));
		return TRUE;
	}
	return FALSE;
}




HRESULT COprahNCUI::AllowH323(BOOL fAllowAV)
{
	m_fAllowAV = fAllowAV;
	if (m_pConfObject->IsConferenceActive())
	{
		// Force a roster update
		CONF_HANDLE hConf = m_pConfObject->GetConfHandle();
		if (NULL != hConf)
		{
			ASSERT(g_pNodeController);
			hConf->UpdateUserData();
		}
	}
	return S_OK;
}

CREQ_RESPONSETYPE COprahNCUI::OnH323IncomingCall(IH323Endpoint* pConnection,
	P_APP_CALL_SETUP_DATA lpvMNMData)
{
	CREQ_RESPONSETYPE resp = m_pIncomingCallManager->OnIncomingH323Call(this, pConnection, lpvMNMData);

	if ((CRR_REJECT == resp) ||
		(CRR_BUSY == resp) ||
		(CRR_SECURITY_DENIED == resp))
	{
		ReleaseAV(pConnection);
	}

	return resp;
}


VOID COprahNCUI::OnH323Connected(IH323Endpoint * lpConnection)
{
	DebugEntry(COprahNCUI::OnH323Connected);

	if (!m_pOutgoingCallManager->OnH323Connected(lpConnection))
	{
		m_pIncomingCallManager->OnH323Connected(lpConnection);
	}
	
	DebugExitVOID(COprahNCUI::OnH323Connected);
}

VOID COprahNCUI::OnH323Disconnected(IH323Endpoint * lpConnection)
{
	DebugEntry(COprahNCUI::OnH323Disconnected);

	if (!m_pOutgoingCallManager->OnH323Disconnected(lpConnection))
	{
		m_pIncomingCallManager->OnH323Disconnected(lpConnection);
	}

	m_pConfObject->OnH323Disconnected(lpConnection, IsOwnerOfAV(lpConnection));

	ReleaseAV(lpConnection);

	DebugExitVOID(COprahNCUI::OnH323Disconnected);
}

VOID COprahNCUI::OnT120ChannelOpen(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus)
{
	DebugEntry(COprahNCUI::OnT120ChannelOpen);

	m_pOutgoingCallManager->OnT120ChannelOpen(pIChannel, lpConnection, dwStatus);

	DebugExitVOID(COprahNCUI::OnT120ChannelOpen);
}


VOID COprahNCUI::OnVideoChannelStatus(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus)
{
	DebugEntry(COprahNCUI::OnVideoChannelStatus);

	m_pConfObject->OnVideoChannelStatus(pIChannel, lpConnection, dwStatus);

	DebugExitVOID(COprahNCUI::OnVideoChannelStatus);
}

VOID COprahNCUI::OnAudioChannelStatus(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus)
{
	DebugEntry(COprahNCUI::OnAudioChannelStatus);

	m_pConfObject->OnAudioChannelStatus(pIChannel, lpConnection, dwStatus);

	DebugExitVOID(COprahNCUI::OnAudioChannelStatus);
}

BOOL COprahNCUI::GetULSName(CRosterInfo *pri)
{
	if (FIsLoggedOn())
	{
		RegEntry reULS(	ISAPI_KEY _TEXT("\\") REGKEY_USERDETAILS,
						HKEY_CURRENT_USER);
		CUSTRING custrULSName(reULS.GetString(REGVAL_ULS_RES_NAME));
		if ((NULL != (PWSTR)custrULSName) &&
			(L'\0' != ((PWSTR)custrULSName)[0]))
		{
			pri->AddItem(g_cwszULSTag, (PWSTR)custrULSName);
			return TRUE;
		}
	}
	return FALSE;
}

VOID COprahNCUI::GetRosterInfo(CRosterInfo *pri)
{
	RegEntry reULS(	ISAPI_KEY _TEXT("\\") REGKEY_USERDETAILS,
					HKEY_CURRENT_USER);

	// This code is here in addition to the code above to fix bug 3367.
	// Add the single IP address to the list that is obtained by calling
	// gethostname() and then gethostbyname().
	// This shouldn't be detrimental, even though we may end up adding the
	// same IP address that has already been added by the code above.
	// This is because the code that looks for matching IP addresses searches
	// through all of them until it finds a match.
	CHAR szHostName[MAX_PATH];
	if (SOCKET_ERROR != gethostname(szHostName, CCHMAX(szHostName)))
	{
		HOSTENT* phe = gethostbyname(szHostName);
		if (NULL != phe)
		{
			ASSERT(phe->h_addrtype == AF_INET);
			ASSERT(phe->h_length == sizeof(DWORD));

			struct in_addr in;
			in.s_addr = *((DWORD *)phe->h_addr);
			CHAR szIPAddress[MAX_PATH];
			lstrcpyn(szIPAddress, inet_ntoa(in), CCHMAX(szIPAddress));
			pri->AddItem(	g_cwszIPTag, CUSTRING(szIPAddress));
		}
	}

	// Add the build/version string
	pri->AddItem(g_cwszVerTag, (PWSTR)VER_PRODUCTVERSION_DWSTR);
	if (FIsLoggedOn())
	{
		CUSTRING custrULSName(reULS.GetString(REGVAL_ULS_RES_NAME));
		if ((NULL != (PWSTR)custrULSName) &&
			(L'\0' != ((PWSTR)custrULSName)[0]))
		{
			pri->AddItem(g_cwszULSTag, (PWSTR)custrULSName);
		}
	}

	CUSTRING custrULSEmail(reULS.GetString(REGVAL_ULS_EMAIL_NAME));
	if ((NULL != (PWSTR)custrULSEmail) &&
		(L'\0' != ((PWSTR)custrULSEmail)[0]))
	{
		pri->AddItem(g_cwszULS_EmailTag, (PWSTR)custrULSEmail);
	}

	CUSTRING custrULSLocation(reULS.GetString(REGVAL_ULS_LOCATION_NAME));
	if ((NULL != (PWSTR)custrULSLocation) &&
		(L'\0' != ((PWSTR)custrULSLocation)[0]))
	{
		pri->AddItem(g_cwszULS_LocationTag, (PWSTR)custrULSLocation);
	}

	CUSTRING custrULSPhoneNum(reULS.GetString(REGVAL_ULS_PHONENUM_NAME));
	if ((NULL != (PWSTR)custrULSPhoneNum) &&
		(L'\0' != ((PWSTR)custrULSPhoneNum)[0]))
	{
		pri->AddItem(g_cwszULS_PhoneNumTag, (PWSTR)custrULSPhoneNum);
	}
}


ULONG COprahNCUI::GetRosterCaps()
{
	ULONG uCaps = m_uCaps;

	CNmMember * pMember = m_pConfObject->GetLocalMember();
	if (NULL != pMember)
	{
		DWORD dwFlags = pMember->GetDwFlags();
		if (dwFlags & PF_MEDIA_VIDEO)
		{
			uCaps |= CAPFLAG_VIDEO_IN_USE;
		}
		if (dwFlags & PF_MEDIA_AUDIO)
		{
			uCaps |= CAPFLAG_AUDIO_IN_USE;
		}
		if (dwFlags & PF_MEDIA_DATA)
		{
			uCaps |= CAPFLAG_DATA_IN_USE;
		}
		if (dwFlags & PF_H323)
		{
			uCaps |= CAPFLAG_H323_IN_USE;
		}
	}

	if (!m_fAllowAV)
	{
		uCaps &= ~(CAPFLAGS_AV_ALL);
	}

	return uCaps;
}


ULONG COprahNCUI::GetAuthenticatedName(PBYTE * ppb)
{
	// Buffer created here should be freed by caller.

	ULONG cb;

	if (::T120_GetSecurityInfoFromGCCID(0,NULL,&cb)) {
		(*ppb) = new BYTE[cb];
		if ((*ppb) != NULL) {
			::T120_GetSecurityInfoFromGCCID(0,*ppb,&cb);
			return cb;
		}
	}
	(* ppb) = NULL;	
	return 0;

}

HRESULT COprahNCUI::OnUpdateUserData(CONF_HANDLE hConference)
{
	CRosterInfo ri;

	// This string will contain addresses in the form:
	// L"TCP:157.55.143.3\0TCP:157.55.143.4\0\0" - 512 character max for now
	WCHAR wszAddresses[512];
	ASSERT(g_pNodeController);
	ASSERT(hConference);
	if (NOERROR == hConference->GetLocalAddressList(wszAddresses,
													CCHMAX(wszAddresses)))
	{
		ri.Load(wszAddresses);
	}

	// First, handle roster information
	GetRosterInfo(&ri);

	PVOID pvData;
	UINT cbDataLen;
	if (SUCCEEDED(ri.Save(&pvData, &cbDataLen)))
	{
	    ASSERT(g_pNodeController);
	    ASSERT(hConference);
		hConference->SetUserData(&g_csguidRostInfo,
								cbDataLen,
								pvData);
	}

	// Next, handle caps information
	ULONG uCaps = GetRosterCaps();
	ASSERT(g_pNodeController);
	ASSERT(hConference);
	hConference->SetUserData(&g_csguidRosterCaps, sizeof(uCaps), &uCaps);

	// Next, handle credentials

	if ( hConference->IsSecure() )
	{
		BYTE * pb = NULL;
		ULONG cb = GetAuthenticatedName(&pb);
		if (cb > 0) {
			ASSERT(g_pNodeController);
			ASSERT(hConference);
			TRACE_OUT(("COprahNCUI::OnUpdateUserData: adding %d bytes SECURITY data", cb));
			hConference->SetUserData(&g_csguidSecurity, cb, pb);
		}
		else
		{
			WARNING_OUT(("OnUpdateUserData: 0 bytes security data?"));
		}
		delete [] pb;			
	}

    // Next, set meeting settings if we hosted the meeting
    ASSERT(m_pConfObject);
    if (m_pConfObject->IsHosting() == S_OK)
    {
        NM30_MTG_PERMISSIONS attendeePermissions = m_pConfObject->GetConfAttendeePermissions();

        WARNING_OUT(("Hosted Meeting Settings 0x%08lx", attendeePermissions));

        hConference->SetUserData(&g_csguidMeetingSettings,
            sizeof(attendeePermissions), &attendeePermissions);
    }

	ULONG nRecords;
	GCCUserData ** ppUserData = NULL;
	if (m_pSysInfo)
	{
		m_pSysInfo->GetUserDataList(&nRecords,&ppUserData);
		for (unsigned int i = 0; i < nRecords; i++) {
			// Do not add user data that was already set above.
			if (memcmp(ppUserData[i]->octet_string->value,(PVOID)&g_csguidRostInfo,sizeof(GUID)) == 0)
				continue;
			if (memcmp(ppUserData[i]->octet_string->value,(PVOID)&g_csguidRosterCaps,sizeof(GUID)) == 0)
				continue;
			if (memcmp(ppUserData[i]->octet_string->value,(PVOID)&g_csguidSecurity,sizeof(GUID)) == 0)
				continue;
			if (memcmp(ppUserData[i]->octet_string->value,(PVOID)&g_csguidMeetingSettings,sizeof(GUID)) == 0)
                continue;

			ASSERT(g_pNodeController);
			ASSERT(hConference);
			hConference->SetUserData((GUID *)(ppUserData[i]->octet_string->value),
				ppUserData[i]->octet_string->length - sizeof(GUID), ppUserData[i]->octet_string->value + sizeof(GUID));
		}
	}

	// only add the LocalNodeId to the roster if H323 is enabled
	if (IsH323Enabled())
	{
		hConference->SetUserData((GUID *)(&g_csguidNodeIdTag), sizeof(GUID), (PVOID)&g_guidLocalNodeId);
	}
	return S_OK;
}
	
HRESULT COprahNCUI::OnIncomingInviteRequest(CONF_HANDLE hConference,
											PCWSTR pcwszNodeName,
											PT120PRODUCTVERSION pRequestorVersion,
											PUSERDATAINFO		pUserDataInfoEntries,
											UINT				cUserDataEntries,
											BOOL				fSecure)
{
	DebugEntry(COprahNCUI::OnIncomingInviteRequest);

    //  Fix an AV problem ONLY for RTC client
    if (m_pConfObject == NULL)
    {
        return S_OK;
    }
	
	if (!m_pConfObject->OnT120Invite(hConference, fSecure))
	{
		// Respond negatively - already in a call
		TRACE_OUT(("Rejecting invite - already in a call"));
		ASSERT(g_pNodeController);
		ASSERT(hConference);
		hConference->InviteResponse(FALSE);
	}
	else
	{
		m_pIncomingCallManager->OnIncomingT120Call(	this,
												TRUE,
												hConference,
												pcwszNodeName,
												pUserDataInfoEntries,
												cUserDataEntries,
												fSecure);

        //
        // This will simply notify the UI about the call state.
        //
		m_pConfObject->SetConfSecurity(fSecure);
	}

	DebugExitHRESULT(COprahNCUI::OnIncomingInviteRequest, S_OK);
	return S_OK;
}


HRESULT COprahNCUI::OnIncomingJoinRequest(	CONF_HANDLE hConference,
											PCWSTR pcwszNodeName,
											PT120PRODUCTVERSION pRequestorVersion,
											PUSERDATAINFO		pUserDataInfoEntries,
											UINT				cUserDataEntries)
{
	DebugEntry(COprahNCUI::OnIncomingJoinRequest);

	// shouldn't we be checking for an active conference before accepting a join
	// or will T120 not present this

	m_pIncomingCallManager->OnIncomingT120Call(	this,
											FALSE,
											hConference,
											pcwszNodeName,
											pUserDataInfoEntries,
											cUserDataEntries,
											m_pConfObject->IsConfObjSecure());

	DebugExitHRESULT(COprahNCUI::OnIncomingJoinRequest, S_OK);
	return S_OK;
}


HRESULT COprahNCUI::OnConferenceStarted(CONF_HANDLE hConference, HRESULT hResult)
{
	DebugEntry(COprahNCUI::OnConferenceStarted);

	if (m_pConfObject->GetConfHandle() == hConference)
	{
		m_pConfObject->OnConferenceStarted(hConference, hResult);

		m_pOutgoingCallManager->OnConferenceStarted(hConference, hResult);
	}

	DebugExitHRESULT(COprahNCUI::OnConferenceStarted, S_OK);
	return S_OK;
}

HRESULT COprahNCUI::OnQueryRemoteResult(PVOID pvCallerContext,
										HRESULT hResult,
										BOOL fMCU,
										PWSTR* ppwszConferenceNames,
										PT120PRODUCTVERSION pVersion,
										PWSTR* ppwszConfDescriptors)
{
	DebugEntry(COprahNCUI::OnQueryRemoteResult);

	if (NO_ERROR == hResult)
	{
		TRACE_OUT(("COprahNCUI: OnQueryRemoteResult Success!"));
	}
	else
	{
		TRACE_OUT(("COprahNCUI: OnQueryRemoteResult Failure!"));
	}

	m_pOutgoingCallManager->OnQueryRemoteResult(pvCallerContext,
												hResult,
												fMCU,
												ppwszConferenceNames,
												pVersion,
												ppwszConfDescriptors);
	
	DebugExitHRESULT(COprahNCUI::OnQueryRemoteResult, S_OK);
	return S_OK;
}

HRESULT COprahNCUI::OnInviteResult(	CONF_HANDLE hConference,
									REQUEST_HANDLE hRequest,
									UINT uNodeID,
									HRESULT hResult,
									PT120PRODUCTVERSION pVersion)
{
	DebugEntry(COprahNCUI::OnInviteResult);

	if (hConference == m_pConfObject->GetConfHandle())
	{
		m_pOutgoingCallManager->OnInviteResult(	hConference,
												hRequest,
												uNodeID,
												hResult,
												pVersion);
	}

	DebugExitHRESULT(COprahNCUI::OnInviteResult, S_OK);
	return S_OK;
}

HRESULT COprahNCUI::OnConferenceEnded(CONF_HANDLE hConference)
{
	DebugEntry(COprahNCUI::OnConferenceEnded);

	if (m_pConfObject && (hConference == m_pConfObject->GetConfHandle()))
	{
		m_pConfObject->OnConferenceEnded();

		m_pOutgoingCallManager->OnConferenceEnded(hConference);

		m_pIncomingCallManager->OnT120ConferenceEnded(hConference);
	}

	DebugExitHRESULT(COprahNCUI::OnConferenceEnded, S_OK);
	return S_OK;
}

HRESULT COprahNCUI::OnRosterChanged(CONF_HANDLE hConf, PNC_ROSTER pRoster)
{
	TRACE_OUT(("COprahNCUI::OnRosterChanged"));

	if (hConf == m_pConfObject->GetConfHandle())
	{
		m_pConfObject->OnRosterChanged(pRoster);
	}
	return S_OK;
}



ULONG STDMETHODCALLTYPE COprahNCUI::AddRef(void)
{
	return RefCount::AddRef();
}
	
ULONG STDMETHODCALLTYPE COprahNCUI::Release(void)
{
	return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE COprahNCUI::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmManager2) || (riid == IID_INmManager) || (riid == IID_IUnknown))
	{
		*ppv = (INmManager2 *)this;
		ApiDebugMsg(("COprahNCUI::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		ApiDebugMsg(("COprahNCUI::QueryInterface(): Returning IConnectionPointContainer."));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("COprahNCUI::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

/*  I N I T I A L I Z E  */
/*-------------------------------------------------------------------------
    %%Function: Initialize

    REVIEW: What should the return value be if any of these parts fail
    to initialize or load?
-------------------------------------------------------------------------*/
HRESULT COprahNCUI::Initialize(ULONG *puOptions, ULONG *puchCaps)
{
	HRESULT hr = S_OK;

    // puOptions is UNUSED

    ASSERT(puchCaps);

	m_pOutgoingCallManager = new COutgoingCallManager;
    if (!m_pOutgoingCallManager)
    {
        ERROR_OUT(("COprahNCUI::Initialize -- failed to create outgoing call mgr"));
        return(E_OUTOFMEMORY);
    }

	m_pIncomingCallManager = new CIncomingCallManager;
    if (!m_pIncomingCallManager)
    {
        ERROR_OUT(("COprahNCUI::Initialize -- failed to create incoming call mgr"));
        return(E_OUTOFMEMORY);
    }

	// The lifetime of this object is up to the reference counting crap
	m_pConfObject = new CConfObject;
    if (!m_pConfObject)
    {
        ERROR_OUT(("COprahNCUI::Initialize -- failed to create conf object"));
        return(E_OUTOFMEMORY);
    }

	m_pConfObject->Init(this);

	WNDCLASS wcHidden =
	{
		0L,
		COprahNCUI::WndProc,
		0,
		0,
		GetInstanceHandle(),
		NULL,
		NULL,
		NULL,
		NULL,
		cszDllHiddenWndClassName
	};

	if (!RegisterClass(&wcHidden))
    {
        ERROR_OUT(("COprahNCUI::Initialize -- failed to register HiddenWnd class"));
        return(E_OUTOFMEMORY);
    }

	// Create a hidden window for event processing:
	m_hwnd = ::CreateWindow(cszDllHiddenWndClassName,
									_TEXT(""),
									WS_POPUP, // not visible!
									0, 0, 0, 0,
									NULL,
									NULL,
									GetInstanceHandle(),
									NULL);

	if (NULL == m_hwnd)
	{
		return E_FAIL;
	}

    //
    // INIT QOS only if AV is in the picture (otherwise, there's nothing
    // to arbitrate).
    //
    if (CAPFLAGS_AV_STREAMS & *puchCaps)
    {
    	m_pQoS = new CQoS();
	    if (NULL != m_pQoS)
    	{
		    hr = m_pQoS->Initialize();
	    	if (FAILED(hr))
    		{
		    	WARNING_OUT(("CQoS::Init() failed!"));

                // let NetMeeting hobble along without QoS.
                delete m_pQoS;
                m_pQoS = NULL;
                hr = S_FALSE; // we can live without QOS
	    	}
    	}
	    else
    	{
		    WARNING_OUT(("Could not allocate CQoS object"));
	    }
    }

    //
    // IF DATA CONFERENCING IS ALLOWED
    //
    if (CAPFLAG_DATA & *puchCaps)
    {
        //
        // Create the node controller
        //
	    hr = ::T120_CreateNodeController(&g_pNodeController, this);
    	if (FAILED(hr))
	    {
		    ERROR_OUT(("T120_CreateNodeController() failed!"));
    		return hr;
	    }
    }

	// Initialize audio/video
	if (CAPFLAGS_AV_ALL & *puchCaps)
	{
		g_pH323UI = new CH323UI();
		if (NULL != g_pH323UI)
		{
			hr = g_pH323UI->Init(m_hwnd, ::GetInstanceHandle(), *puchCaps, this, this);
			if (FAILED(hr))
			{
				WARNING_OUT(("CH323UI::Init() failed!"));
				delete g_pH323UI;
				g_pH323UI = NULL;
				*puchCaps &= ~(CAPFLAGS_AV_ALL);
				hr = S_FALSE;  // We can run without AV
			}
			else
			{
                if (CAPFLAGS_VIDEO & *puchCaps)
                {
    				// if we can get a Preview channel, we can send video
	    			m_pPreviewChannel = CNmChannelVideo::CreatePreviewChannel();
		    		if (NULL == m_pPreviewChannel)
			    	{
				    	*puchCaps &= ~CAPFLAG_SEND_VIDEO;
    				}
                }

				if (m_pConfObject && (CAPFLAGS_AV_STREAMS & *puchCaps))
				{
					IMediaChannelBuilder *pStreamProvider;

					pStreamProvider = g_pH323UI->GetStreamProvider();
					if (pStreamProvider)
					{
						pStreamProvider->SetStreamEventObj(m_pConfObject);
						pStreamProvider->Release();
					}
				}

			}
		}
		else
		{
			ERROR_OUT(("Could not allocate CH323UI object"));
		}
	}

	m_uCaps = *puchCaps;

	return CoCreateGuid(&g_guidLocalNodeId);
}



HRESULT COprahNCUI::GetSysInfo(INmSysInfo **ppSysInfo)
{
	HRESULT hr = S_OK;

	if( ppSysInfo )
	{
		if(m_pSysInfo )
		{
			m_pSysInfo->AddRef();
			*ppSysInfo = m_pSysInfo;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = E_POINTER;
	}

	return hr;
}

HRESULT COprahNCUI::EnumConference(IEnumNmConference **ppEnum)
{
	return E_NOTIMPL;
}

HRESULT COprahNCUI::CreateConference(	INmConference **ppConference,
										BSTR bstrName,
										BSTR bstrPassword,
										ULONG uchCaps)
{
    return(CreateConferenceEx(ppConference, bstrName, bstrPassword,
        uchCaps, NM_PERMIT_ALL, (UINT)-1));
}


HRESULT COprahNCUI::EnumCall(IEnumNmCall **ppEnum)
{
	return E_NOTIMPL;
}

HRESULT COprahNCUI::CreateCall(
    INmCall **ppCall,
    NM_CALL_TYPE callType,
    NM_ADDR_TYPE addrType,
    BSTR bstrAddress,
    INmConference * pConference)
{
	return E_NOTIMPL;
}

HRESULT COprahNCUI::CallConference(
    INmCall **ppCall,
    NM_CALL_TYPE callType,
    NM_ADDR_TYPE addrType,
    BSTR bstrAddress,
    BSTR bstrConfToJoin,
    BSTR bstrPassword)
{
	return E_NOTIMPL;
}

STDMETHODIMP COprahNCUI::GetPreviewChannel(INmChannelVideo **ppChannelVideo)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppChannelVideo)
	{
		*ppChannelVideo = m_pPreviewChannel;
		if (NULL != m_pPreviewChannel)
		{
			m_pPreviewChannel->AddRef();
			hr = S_OK;
		}
		else
		{
			hr = E_FAIL;
		}
	}
	return hr;
}


STDMETHODIMP COprahNCUI::CreateASObject
(
    IUnknown *  pNotify,
    ULONG       flags,
    IUnknown ** ppAS
)
{
    return(::CreateASObject((IAppSharingNotify *)pNotify, flags,
        (IAppSharing **)ppAS));
}


HRESULT COprahNCUI::CallEx(
    INmCall **ppCall,
    DWORD dwFlags,
    NM_ADDR_TYPE addrType,
	BSTR bstrName,
    BSTR bstrSetup,
    BSTR bstrDest,
    BSTR bstrAlias,
    BSTR bstrURL,
    BSTR bstrConference,
    BSTR bstrPassword,
    BSTR bstrUserData)
{
	DebugEntry(COprahNCUI::CallEx);

	HRESULT hr = m_pOutgoingCallManager->Call(	ppCall,
												this,
												dwFlags,
												addrType,
												bstrName,
												bstrSetup,
												bstrDest,
												bstrAlias,
												bstrURL,
												bstrConference,
												bstrPassword,
												bstrUserData);

	DebugExitHRESULT(COprahNCUI::CallEx, hr);
	return hr;
}


HRESULT COprahNCUI::CreateConferenceEx
(
    INmConference **ppConference,
    BSTR            bstrName,
    BSTR            bstrPassword,
    DWORD           uchCaps,
    DWORD           attendeePermissions,
    DWORD           maxParticipants
)
{
	if (NULL == ppConference)
    {
        ERROR_OUT(("CreateConferenceEx:  null ppConference passed in"));
		return E_POINTER;
    }

    if (maxParticipants < 2)
    {
        ERROR_OUT(("CreateConferenceEx:  bad maxParticipants %d", maxParticipants));
        return E_INVALIDARG;
    }

	if (m_pConfObject->IsConferenceActive())
	{
		WARNING_OUT(("CreateConference is failing because IsConferenceActive return TRUE"));
		return NM_CALLERR_IN_CONFERENCE;
	}

	m_pConfObject->SetConfName(bstrName);
	if (uchCaps & NMCH_SRVC)
		m_pConfObject->SetConfHashedPassword(bstrPassword);
	else
		m_pConfObject->SetConfPassword(bstrPassword);


	if (uchCaps & NMCH_SECURE)
		m_pConfObject->SetConfSecurity(TRUE);
	else
		m_pConfObject->SetConfSecurity(FALSE);


    m_pConfObject->SetConfAttendeePermissions(attendeePermissions);
    m_pConfObject->SetConfMaxParticipants(maxParticipants);

	if (!m_pConfObject->IsConferenceCreated())
	{
		m_pConfObject->OnConferenceCreated();
	}

	NotifySink((INmConference*) m_pConfObject, OnNotifyConferenceCreated);


	*ppConference = m_pConfObject;
	if(*ppConference)
	{
		(*ppConference)->AddRef();
	}
	return S_OK;
}


/*  O N  N O T I F Y  C O N F E R E N C E  C R E A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyConferenceCreated

-------------------------------------------------------------------------*/
HRESULT OnNotifyConferenceCreated(IUnknown *pManagerNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pManagerNotify);
	((INmManagerNotify*)pManagerNotify)->ConferenceCreated((INmConference *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C A L L  C R E A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyCallCreated

-------------------------------------------------------------------------*/
HRESULT OnNotifyCallCreated(IUnknown *pManagerNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pManagerNotify);
	((INmManagerNotify*)pManagerNotify)->CallCreated((INmCall *) pv);
	return S_OK;
}


/*  O N  N O T I F Y  C A L L  S T A T E  C H A N G E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyCallStateChanged

-------------------------------------------------------------------------*/
HRESULT OnNotifyCallStateChanged(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pCallNotify);
	((INmCallNotify*)pCallNotify)->StateChanged((NM_CALL_STATE)(DWORD_PTR)pv);
	return S_OK;
}

VOID SetBandwidth(UINT uBandwidth)
{
	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	if (NULL != pOprahNCUI)
	{
        pOprahNCUI->SetBandwidth(uBandwidth);
	}
	if (NULL != g_pH323UI)
	{
		//Inform the NAC of the connection speed
		g_pH323UI->SetBandwidth(uBandwidth);
	}
}


//
// BOGUS LAURABU!
// Do we need this HWND anymore?  The hidden window is used now only to
// pass to H323, which passes it to the MediaStream interfaces in the NAC,
// which passes it to DirectX.
//

LRESULT CALLBACK COprahNCUI::WndProc(HWND hwnd, UINT uMsg,
										WPARAM wParam, LPARAM lParam)
{
	
		// if ms_msgChannelEvent is 0, that means that we are not initialized
		// RegisterWindowMessage returns MSGIds in the range 0xC000 through 0xFFFF
	if(CH323ChannelEvent::ms_msgChannelEvent && CH323ChannelEvent::ms_msgChannelEvent == uMsg)
	{
		COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
		if (pOprahNCUI)
		{
			CH323ChannelEvent *pEvent = reinterpret_cast<CH323ChannelEvent*>(lParam);
			if(pEvent)
			{
				// if we're shutting down m_hwnd will be NULL
				if (pOprahNCUI->m_hwnd)
				{
					pOprahNCUI->_ChannelEvent(
							pEvent->GetChannel(),
							pEvent->GetEndpoint(),
							pEvent->GetStatus());
				}
				delete pEvent;
			}
			else
			{
				WARNING_OUT(("Why are we getting a NULL pEvent?"));
			}
		}
		return 1;
	}

	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

PIUnknown NewNmManager(OBJECTDESTROYEDPROC ObjectDestroyed)
{
	COprahNCUI *pManager = new COprahNCUI(ObjectDestroyed);
	if (NULL != pManager)
	{
		return (INmManager2 *) pManager;
	}
	return NULL;
}


VOID COprahNCUI::_ChannelEvent (ICommChannel *pIChannel,
                IH323Endpoint * lpConnection,	DWORD dwStatus )
{
	ASSERT(pIChannel);
	GUID guidMedia;
	if (SUCCEEDED(pIChannel->GetMediaType(&guidMedia)))
	{
		if (MEDIA_TYPE_H323AUDIO == guidMedia)
		{
			OnAudioChannelStatus(pIChannel, lpConnection, dwStatus);
		}
		else if (MEDIA_TYPE_H323VIDEO == guidMedia)
		{
			OnVideoChannelStatus(pIChannel, lpConnection, dwStatus);
		}
		else if (MEDIA_TYPE_H323_T120 == guidMedia)
		{
			switch (dwStatus)
			{
				case CHANNEL_OPEN_ERROR:
				case CHANNEL_OPEN:
				case CHANNEL_CLOSED:
				case CHANNEL_REJECTED:
				case CHANNEL_NO_CAPABILITY:
					OnT120ChannelOpen(pIChannel, lpConnection, dwStatus);
					break;
				
				default:
					WARNING_OUT(("COprahNCUI::ChannelEvent - unrecognized T120 status"));
					break;				
					
			}
		}
		else
		{
			WARNING_OUT(("COprahNCUI::ChannelEvent - unknown media type"));
		}
	}
	else
	{
		WARNING_OUT(("COprahNCUI::ChannelEvent - pIChannel->GetMediaType() failed"));
	}
}

STDMETHODIMP COprahNCUI::ChannelEvent (ICommChannel *pIChannel,
                IH323Endpoint * lpConnection,	DWORD dwStatus )
{
	ASSERT(pIChannel);
	GUID guidMedia;
	if (SUCCEEDED(pIChannel->GetMediaType(&guidMedia)))
	{
		if (MEDIA_TYPE_H323_T120 == guidMedia)
		{
			if (NULL != m_hwnd)
			{
				CH323ChannelEvent* pEvent = new CH323ChannelEvent(
													pIChannel,
													lpConnection,
													dwStatus);
				if (pEvent)
				{
					PostMessage(m_hwnd,
								CH323ChannelEvent::ms_msgChannelEvent,
								0,
								reinterpret_cast<LPARAM>(pEvent));
					return S_OK;
				}
			}
		}
		else
		{
			_ChannelEvent(pIChannel, lpConnection, dwStatus);
			return S_OK;
		}
	}

	return E_FAIL;
}

#ifdef DEBUG
VOID TraceStatus(DWORD dwStatus)
{
	switch(dwStatus)
	{
		case CONNECTION_DISCONNECTED:
			TRACE_OUT(("COprahNCUI::CallEvent: CONNECTION_DISCONNECTED"));
			break;

		case CONNECTION_CONNECTED:
			TRACE_OUT(("COprahNCUI::CallEvent: CONNECTION_CONNECTED"));
			break;

		case CONNECTION_RECEIVED_DISCONNECT:
			TRACE_OUT(( "COprahNCUI::CallEvent: RECEIVED_DISCONNECT"));
			break;

		case CONNECTION_PROCEEDING:
			TRACE_OUT(("COprahNCUI::CallEvent: CONNECTION_PROCEEDING"));
			break;

		case CONNECTION_REJECTED:
			TRACE_OUT(("COprahNCUI::CallEvent: CONNECTION_REJECTED"));
			break;

		default:
			TRACE_OUT(("COprahNCUI::CallEvent: dwStatus = %d", dwStatus));
			break;
	}
}
#endif

STDMETHODIMP COprahNCUI::CallEvent(IH323Endpoint * lpConnection, DWORD dwStatus)
{

	DebugEntry(COprahNCUI::CallEvent);
	IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();
#ifdef DEBUG
	TraceStatus(dwStatus);
#endif

	switch (dwStatus)
	{
		case CONNECTION_DISCONNECTED:
			OnH323Disconnected(lpConnection);
			break;

		case CONNECTION_CONNECTED:
		// This is currently interpreted as CONNECTION_CAPABILITIES_READY.
		// Lower layers are continuing to post CONNECTION_CONNECTED only after
		// capabilities are exchanged. note that channels may be opened while
		// inside OnH323Connected();
			OnH323Connected(lpConnection);
			break;
	}

	DebugExitVOID(COprahNCUI::CallEvent);
	return S_OK;
}

STDMETHODIMP COprahNCUI::GetMediaChannel (GUID *pmediaID,
        BOOL bSendDirection, IMediaChannel **ppI)
{
	// delegate to the appropriate stream provider.  For the time being
	// there is only one provider that does both audio & video
		return g_pH323UI->GetMediaChannel (pmediaID, bSendDirection, ppI);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\imember.cpp ===
// File: iMember.cpp
//
// INmMember interface  (participant routines)

#include "precomp.h"
#include "imember.h"
#include "rostinfo.h"
#include "imanager.h" // for g_pNodeController

/*  C  N M  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: CNmMember Constructor
    
-------------------------------------------------------------------------*/
CNmMember::CNmMember(PWSTR pwszName, DWORD dwGCCID, DWORD dwFlags, ULONG uCaps,
						REFGUID rguidNode, PVOID pwszUserInfo, UINT cbUserInfo) :
	m_bstrName     (SysAllocString(pwszName)),
	m_dwGCCID      (dwGCCID),
	m_dwFlags      (dwFlags),
	m_uCaps        (uCaps),
	m_guidNode     (rguidNode),
	m_cbUserInfo   (cbUserInfo),
	m_uNmchCaps    (0),
	m_dwGccIdParent(INVALID_GCCID),
	m_pwszUserInfo (NULL),
	m_pConnection(NULL)
{
	// Local state never changes
	m_fLocal = 0 != (PF_LOCAL_NODE & m_dwFlags);

	// check to see if we have the right GUID for local member
	// guid will be NULL if we have H323 disabled.
	ASSERT (!m_fLocal || (GUID_NULL == rguidNode) || (g_guidLocalNodeId == rguidNode));

	SetUserInfo(pwszUserInfo, cbUserInfo);

	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CNmMember", this);
}


CNmMember::~CNmMember(void)
{
	SysFreeString(m_bstrName);

	delete m_pwszUserInfo;
	if(m_pConnection)
		m_pConnection->Release();
		
	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CNmMember", this);
}

VOID CNmMember::SetGccIdParent(DWORD dwGccId)
{
	m_dwGccIdParent = dwGccId;
	if (0 == dwGccId)
	{
		// No Parent means this is the Top Provider
		m_dwFlags |= PF_T120_TOP_PROV;
	}
	else
	{
		m_dwFlags &= ~PF_T120_TOP_PROV;
	}
}

VOID CNmMember::SetUserInfo(PVOID pwszUserInfo, UINT cbUserInfo)
{
	// clear out any previous data
	delete m_pwszUserInfo;
	m_cbUserInfo = 0;

	if (0 == cbUserInfo)
	{
		m_pwszUserInfo = NULL;
	}
	else
	{
		m_pwszUserInfo = (PWSTR) new BYTE[cbUserInfo];
		if (NULL == m_pwszUserInfo)
		{
			WARNING_OUT(("CNmMember: unable to alloc space for user data"));
		}
		else
		{
			m_cbUserInfo = cbUserInfo;
			CopyMemory(m_pwszUserInfo, pwszUserInfo, m_cbUserInfo);
		}
	}
}

BOOL CNmMember::GetSecurityData(PBYTE * ppb, ULONG * pcb)
{
	DWORD dwGCCID = FLocal() ? 0 : GetGCCID();

	(* pcb) = 0;
	(* ppb) = NULL;
	
	// If this node is directly connected to the member, we use the transport data...
	if (::T120_GetSecurityInfoFromGCCID(dwGCCID,NULL,pcb)) {
		if (0 != (* pcb)) {
			// We are directly connected and security data is valid.
			(*ppb) = (PBYTE)CoTaskMemAlloc(*pcb);
			if ((*ppb) != NULL)
			{
				::T120_GetSecurityInfoFromGCCID(dwGCCID,*ppb,pcb);
				return TRUE;
			}
			else
			{
				ERROR_OUT(("CoTaskMemAlloc failed in GetSecurityData"));
			}
		}
		else if (GetUserData(g_csguidSecurity,ppb,pcb) == S_OK)
		{
			// We are not directly connected, so get security data from roster.
			return TRUE;
		}
	}	
	return FALSE;
}

HRESULT CNmMember::ExtractUserData(LPTSTR psz, UINT cchMax, PWSTR pwszKey)
{
	CRosterInfo ri;
	HRESULT hr = ri.Load(GetUserInfo());
	if (FAILED(hr))
		return hr;

	hr = ri.ExtractItem(NULL, pwszKey, psz, cchMax);
	return hr;
}

HRESULT CNmMember::GetIpAddr(LPTSTR psz, UINT cchMax)
{
	return ExtractUserData(psz, cchMax, (PWSTR) g_cwszIPTag);
}

///////////////////////////
//  CNmMember:IUknown

ULONG STDMETHODCALLTYPE CNmMember::AddRef(void)
{

    DBGENTRY(CNmMember::AddRef);

    TRACE_OUT(("CNmMember [%ls]:  AddRef this = 0x%X", m_bstrName ? m_bstrName : L"", this));

    ULONG ul = RefCount::AddRef();

    DBGEXIT(CNmMember::AddRef);

	return ul;
}
	
ULONG STDMETHODCALLTYPE CNmMember::Release(void)
{

    DBGENTRY(CNmMember::Release);

    TRACE_OUT(("CNmMember [%ls]: Release this = 0x%X", m_bstrName ? m_bstrName : L"", this));

    ULONG ul = RefCount::Release();

    DBGEXIT(CNmMember::Release);

	return ul;
}


HRESULT STDMETHODCALLTYPE CNmMember::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmMember) || (riid == IID_IUnknown))
	{
		*ppv = (INmMember *)this;
		ApiDebugMsg(("CNmMember::QueryInterface()"));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CNmMember::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}



///////////////
// INmMember


HRESULT STDMETHODCALLTYPE CNmMember::GetName(BSTR *pbstrName)
{
	if (NULL == pbstrName)
		return E_POINTER;

	*pbstrName = SysAllocString(m_bstrName);

	return *pbstrName ? S_OK : E_FAIL;
}

HRESULT STDMETHODCALLTYPE CNmMember::GetID(ULONG *puID)
{
	if (NULL == puID)
		return E_POINTER;

	*puID = m_dwGCCID;
	return (0 != m_dwGCCID) ? S_OK : NM_E_NO_T120_CONFERENCE;
}

HRESULT STDMETHODCALLTYPE CNmMember::GetNmVersion(ULONG *puVersion)
{
	if (NULL == puVersion)
		return E_POINTER;

	*puVersion = (ULONG) HIWORD(m_dwFlags & PF_VER_MASK);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNmMember::GetAddr(BSTR *pbstrAddr, NM_ADDR_TYPE *puType)
{
	if ((NULL == pbstrAddr) || (NULL == puType))
		return E_POINTER;

	TCHAR szIp[MAX_PATH];

	if (S_OK != GetIpAddr(szIp, CCHMAX(szIp)))
	{
		return E_FAIL;
	}

	*puType = NM_ADDR_IP;
	*pbstrAddr = SysAllocString(CUSTRING(szIp));

	return *pbstrAddr ? S_OK : E_FAIL;
}

HRESULT STDMETHODCALLTYPE CNmMember::SetUserData(REFGUID rguid, BYTE *pb, ULONG cb)
{
	return m_UserData.AddUserData((GUID *)&rguid,(unsigned short)cb,pb);
}

HRESULT STDMETHODCALLTYPE CNmMember::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	return m_UserData.GetUserData(rguid,ppb,pcb);
}

STDMETHODIMP CNmMember::GetConference(INmConference **ppConference)
{
	return ::GetConference(ppConference);
}

HRESULT STDMETHODCALLTYPE CNmMember::GetNmchCaps(ULONG *puCaps)
{
	if (NULL == puCaps)
		return E_POINTER;

	if (m_dwFlags & PF_T120)
	{
		// this can be removed when NMCH_SHARE and NMCH_DATA is reliable
        *puCaps = m_uNmchCaps | NMCH_SHARE | NMCH_DATA;
	}
	else
	{
		*puCaps = m_uNmchCaps;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNmMember::GetShareState(NM_SHARE_STATE *puState)
{
    return(E_FAIL);
}

HRESULT STDMETHODCALLTYPE CNmMember::IsSelf(void)
{
	return m_fLocal ? S_OK : S_FALSE;
}

HRESULT STDMETHODCALLTYPE CNmMember::IsMCU(void)
{
	return (m_dwFlags & PF_T120_MCU) ? S_OK : S_FALSE;
}

HRESULT STDMETHODCALLTYPE CNmMember::Eject(void)
{
	if (m_fLocal)
		return E_FAIL; // can't eject ourselves.

	if (PF_T120 & m_dwFlags)
	{
		CNmMember * pMemberLocal = GetLocalMember();
		if ((NULL == pMemberLocal) || !pMemberLocal->FTopProvider())
			return E_FAIL; // only top providers should be allowed to do this

		CConfObject * pco = ::GetConfObject();
		if (NULL != pco)
		{
			ASSERT(g_pNodeController);
			ASSERT(pco->GetConfHandle());
			pco->GetConfHandle()->EjectUser(m_dwGCCID);
		}
	}

	if (NULL != m_pConnection)
	{
		HRESULT hr = m_pConnection->Disconnect();
		if (FAILED(hr))
		{
			WARNING_OUT(("m_pConnection->Disconnect() failed - hr = %s",
						::GetHRESULTString(hr)));
		}
	}
	return S_OK;
}


///////////////////////////////////////////////////////////////////////
// Utility Functions


/*  G E T  L O C A L  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: GetLocalMember
    
-------------------------------------------------------------------------*/
CNmMember * GetLocalMember(void)
{
	CConfObject * pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;

	return pco->GetLocalMember();
}


/*  P  M E M B E R  F R O M  G  C  C  I  D  */
/*-------------------------------------------------------------------------
    %%Function: PMemberFromGCCID
    
-------------------------------------------------------------------------*/
CNmMember * PMemberFromGCCID(UINT uNodeID)
{
	CConfObject* pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;

	return pco->PMemberFromGCCID(uNodeID);
}


/*  P  M E M B E R  F R O M  N O D E  G U I D  */
/*-------------------------------------------------------------------------
    %%Function: PMemberFromNodeGuid
    
-------------------------------------------------------------------------*/
CNmMember * PMemberFromNodeGuid(REFGUID rguidNode)
{
	CConfObject* pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;

	return pco->PMemberFromNodeGuid(rguidNode);
}

CNmMember *	PDataMemberFromName(PCWSTR pwszName)
{
	CConfObject* pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;

	return pco->PDataMemberFromName(pwszName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\imanager.h ===
#ifndef _IMANAGER_H_
#define _IMANAGER_H_

#include "confqos.h"
#include <ias.h>
#include "SDKInternal.h"

extern GUID g_csguidSecurity;
extern GUID g_csguidUserString;
extern GUID g_csguidNodeIdTag;
extern GUID g_guidLocalNodeId;

class COutgoingCall;
class COutgoingCallManager;
class CIncomingCallManager;
class CConfObject;
class CRosterInfo;
class CQoS;
class CNmSysInfo;

class COprahNCUI : public RefCount, public INodeControllerEvents, public CH323ConnEvent,
				   public INmManager2, public CConnectionPointContainer,
				   public IH323ConfAdvise
{
friend CNmSysInfo;

protected:
	static COprahNCUI *m_pOprahNCUI;
	COutgoingCallManager* m_pOutgoingCallManager;
	CIncomingCallManager* m_pIncomingCallManager;

	CNmSysInfo*  m_pSysInfo;
	CConfObject* m_pConfObject;
	HWND		m_hwnd;
	UINT		m_uCaps;
	CQoS      * m_pQoS;		// The quality of service object

	INmChannelVideo * m_pPreviewChannel;

	static VOID CALLBACK AudioConnectResponse(	LPVOID pContext1,
												LPVOID pContext2,
												DWORD dwFlags);
	static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg,
									WPARAM wParam, LPARAM lParam);

	BOOL            m_fAllowAV;
	IH323Endpoint*	m_pAVConnection;

public:
	COprahNCUI(OBJECTDESTROYEDPROC ObjectDestroyed);
	~COprahNCUI();

	BSTR	GetUserName();
	UINT	GetOutgoingCallCount();
	BOOL	GetULSName(CRosterInfo *pri);
	VOID	GetRosterInfo(CRosterInfo *pri);
	ULONG	GetRosterCaps();
	ULONG	GetAuthenticatedName(PBYTE * ppb);
	VOID	OnOutgoingCallCreated(INmCall* pCall);
	VOID	OnOutgoingCallCanceled(COutgoingCall* pCall);
	VOID	OnIncomingCallAccepted();
	VOID	OnIncomingCallCreated(INmCall* pCall);

	BOOL	AcquireAV(IH323Endpoint* pConnection);
	BOOL	ReleaseAV(IH323Endpoint* pConnection);
	BOOL	IsOwnerOfAV(IH323Endpoint* pConnection) { return m_pAVConnection == pConnection; }

	VOID	CancelCalls();

	BOOL	IsAudioAllowed()		{ return m_fAllowAV && (m_uCaps & (CAPFLAG_SEND_AUDIO | CAPFLAG_RECV_AUDIO)); }
	BOOL	IsReceiveVideoAllowed() { return m_fAllowAV && (m_uCaps & CAPFLAG_RECV_VIDEO); }
	BOOL	IsSendVideoAllowed()	{ return m_fAllowAV && (m_uCaps & CAPFLAG_SEND_VIDEO); }
	BOOL	IsH323Enabled()			{ return m_uCaps & CAPFLAG_H323_CC; }

	CREQ_RESPONSETYPE OnH323IncomingCall(IH323Endpoint* pConn, P_APP_CALL_SETUP_DATA lpvMNMData);
    //
    // IH323ConfAdvise methods
    //
    STDMETHODIMP CallEvent (IH323Endpoint * lpConnection, DWORD dwStatus);
    STDMETHODIMP ChannelEvent (ICommChannel *pIChannel, 
        IH323Endpoint * lpConnection,	DWORD dwStatus );
    STDMETHODIMP GetMediaChannel (GUID *pmediaID, 
        BOOL bSendDirection, IMediaChannel **ppI);	
        
	VOID	_ChannelEvent ( ICommChannel *pIChannel, 
							IH323Endpoint * lpConnection,
							DWORD dwStatus);
	// H323 Connection events from H323UI:
	VOID		OnH323Connected(IH323Endpoint * lpConnection);
	VOID		OnH323Disconnected(IH323Endpoint * lpConnection);
	// Audio Conferencing events from H323UI:
	VOID		OnAudioChannelStatus(ICommChannel *pIChannel, 
							IH323Endpoint * lpConnection, DWORD dwStatus);
	// Video Conferencing events from H323UI:
	VOID		OnVideoChannelStatus(ICommChannel *pIChannel, 
							IH323Endpoint * lpConnection, DWORD dwStatus);
	// T.120 events from H323UI
    VOID		OnT120ChannelOpen(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus);
    
	static COprahNCUI *GetInstance() { return m_pOprahNCUI; }
	CConfObject *GetConfObject() { return m_pConfObject; }
	VOID		SetBandwidth(UINT uBandwidth) { if (NULL != m_pQoS) m_pQoS->SetBandwidth(uBandwidth); }
	HRESULT		AbortResolve(UINT uAsyncRequest);

	//
	// INodeControllerEvents methods:
	//
	STDMETHODIMP OnConferenceStarted(	CONF_HANDLE 		hConference,
										HRESULT 			hResult);
	STDMETHODIMP OnConferenceEnded( 	CONF_HANDLE 		hConference);
	STDMETHODIMP OnRosterChanged(		CONF_HANDLE 		hConference,
										PNC_ROSTER			pRoster);
	STDMETHODIMP OnIncomingInviteRequest( CONF_HANDLE 		hConference,
										PCWSTR				pcwszNodeName,
										PT120PRODUCTVERSION pRequestorVersion,
										PUSERDATAINFO		pUserDataInfoEntries,
										UINT				cUserDataEntries,
										BOOL				fSecure);
	STDMETHODIMP OnIncomingJoinRequest( CONF_HANDLE 		hConference,
										PCWSTR				pcwszNodeName,
										PT120PRODUCTVERSION pRequestorVersion,
										PUSERDATAINFO		pUserDataInfoEntries,
										UINT				cUserDataEntries);
	STDMETHODIMP OnQueryRemoteResult(	PVOID				pvCallerContext,
										HRESULT 			hResult,
										BOOL				fMCU,
										PWSTR*				ppwszConferenceNames,
										PT120PRODUCTVERSION pVersion,
										PWSTR*                          ppwszConfDescriptors);
	STDMETHODIMP OnInviteResult(		CONF_HANDLE 		hConference,
										REQUEST_HANDLE		hRequest,
										UINT				uNodeID,
										HRESULT 			hResult,
										PT120PRODUCTVERSION pVersion);
	STDMETHODIMP OnUpdateUserData(		CONF_HANDLE 		hConference);


	//
	// INmManager methods
	//
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);
	STDMETHODIMP Initialize(ULONG *puOptions, ULONG *puchCaps);
	STDMETHODIMP GetSysInfo(INmSysInfo **ppSysInfo);
	STDMETHODIMP EnumConference(IEnumNmConference **ppEnum);
	STDMETHODIMP CreateConference(INmConference **ppConference,
								BSTR bstrName,
								BSTR bstrPassword,
								ULONG uchCaps);
	STDMETHODIMP EnumCall(IEnumNmCall **ppEnum);
	STDMETHODIMP CreateCall(INmCall **ppCall,
						NM_CALL_TYPE callType,
						NM_ADDR_TYPE addrType,
						BSTR bstrAddr,
						INmConference *pConference);
	STDMETHODIMP CallConference(INmCall **ppCall,
							NM_CALL_TYPE callType,
							NM_ADDR_TYPE addrType,
							BSTR bstrAddr,
							BSTR bstrName,
							BSTR bstrPassword);
	//
	// INmManager2 methods
	//
	STDMETHODIMP GetPreviewChannel(INmChannelVideo **ppChannelVideo);
    STDMETHODIMP CreateASObject(IUnknown * pNotify, ULONG flags, IUnknown ** ppAS);
	STDMETHODIMP AllowH323(BOOL fAllow);
    STDMETHODIMP CallEx(INmCall **ppCall,
						DWORD	dwFlags,
						NM_ADDR_TYPE addrType,
						BSTR bstrName,
						BSTR bstrSetup,
						BSTR bstrDest,
						BSTR bstrAlias,
						BSTR bstrURL,
						BSTR userData,
						BSTR bstrConference,
						BSTR bstrPassword);

    STDMETHODIMP CreateConferenceEx(INmConference **ppConference,
                        BSTR  bstrName,
                        BSTR  bstrPassword,
                        DWORD dwTypeFlags,
                        DWORD attendeePermissions,
                        DWORD maxParticipants);

};

// The global instance that is declared in conf.cpp:
extern INodeController* g_pNodeController;
// The GUID is declared in opncui.cpp:
extern GUID g_csguidRosterCaps;

extern SOCKADDR_IN g_sinGateKeeper;

HRESULT OnNotifyCallStateChanged(IUnknown *pCallNotify, PVOID pv, REFIID riid);

typedef BOOL (WINAPI * PFNGETUSERSECURITYINFO) (DWORD dwGCCID, PBYTE pInfo, PDWORD pcbInfo);
typedef DWORD (WINAPI * PFNPROCESSSECURITYDATA) ( DWORD dwCode, DWORD dwParam1, DWORD dwParam2 );

#endif // _IMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\isysinfo.h ===
// File: iSysInfo.h

#ifndef _ISYSINFO_H_
#define _ISYSINFO_H_

class USER_DATA_LIST;

class CNmSysInfo : public DllRefCount, public INmSysInfo2, public CConnectionPointContainer
{
private:
	static CNmSysInfo* m_pSysInfo;
	USER_DATA_LIST m_UserData;
	BSTR m_bstrUserName;

public:
	CNmSysInfo();
	~CNmSysInfo();

	BSTR GetUserName() { return m_bstrUserName; }

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
	
	// INmSysInfo methods
	HRESULT STDMETHODCALLTYPE IsInstalled(void);
	HRESULT STDMETHODCALLTYPE GetProperty(NM_SYSPROP uProp, BSTR *pbstrProp);
	HRESULT STDMETHODCALLTYPE SetProperty(NM_SYSPROP uProp, BSTR bstrName);
	HRESULT STDMETHODCALLTYPE GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	HRESULT STDMETHODCALLTYPE SetUserData(REFGUID rguid, BYTE *pb, ULONG cb);
	HRESULT STDMETHODCALLTYPE GetNmApp(REFGUID rguid,
		BSTR *pbstrApplication, BSTR *pbstrCommandLine, BSTR *pbstrDirectory);
	HRESULT STDMETHODCALLTYPE SetNmApp(REFGUID rguid,
		BSTR bstrApplication, BSTR bstrCommandLine, BSTR bstrDirectory);
	HRESULT STDMETHODCALLTYPE GetNmchCaps(ULONG *pchCaps);
	HRESULT STDMETHODCALLTYPE GetLaunchInfo(INmConference **ppConference, INmMember **pMember);

	// INmSysInfo2 methods
	HRESULT STDMETHODCALLTYPE GetOption(NM_SYSOPT uOption, ULONG * plOption);
	HRESULT STDMETHODCALLTYPE SetOption(NM_SYSOPT uOption, ULONG lOption);
	HRESULT STDMETHODCALLTYPE ProcessSecurityData(DWORD dwTaskCode, DWORD_PTR dwParam1, DWORD_PTR dwParam2,
    	DWORD * pdwResult);
	HRESULT STDMETHODCALLTYPE GkLogon(BSTR bstrAddr, BSTR bstrAliasID, BSTR bstrAliasE164);
	HRESULT STDMETHODCALLTYPE GkLogoff(void);
	HRESULT STDMETHODCALLTYPE GkState(NM_GK_STATE * pgkState);
    	
	// Internal Methods
	HRESULT STDMETHODCALLTYPE GetUserDataList(ULONG * pnRecords, GCCUserData *** pppUserData);
	static VOID CALLBACK RasNotify(DWORD dwRasEvent, HRESULT hReason);

};


#endif /* _ISysInfo_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\medialst.h ===
#ifndef _MEDIALST_H_
#define _MEDIALST_H_

#include "common.h"

class CMediaList
{
private:
	typedef struct _guidlist
	{
		GUID guid;
		struct _guidlist *pnext;
	}GUIDLIST, *PGUIDLIST;

	RES_PAIR    *m_pResolvedFormatIDs;
	PGUIDLIST   m_pSendMediaList, m_pRecvMediaList;
	UINT        m_uNumSendMedia, m_uNumRecvMedia;
	GUID        *m_pSendMediaGuids;
	UINT        m_uNumResolvedMedia;
	
    VOID AddSendMedia(LPGUID pMediaTypeGuid);
    VOID RemoveSendMedia(LPGUID pMediaTypeGuid);
    VOID AddRecvMedia(LPGUID pMediaTypeGuid);
    VOID RemoveRecvMedia(LPGUID pMediaTypeGuid);
    BOOL IsInList(LPGUID pMediaTypeGuid, PGUIDLIST pList);

public:
	CMediaList();
	~CMediaList();

	HRESULT ResolveSendFormats(IH323Endpoint* pConnection);
	BOOL	GetSendFormatLocalID(REFGUID guidMedia, MEDIA_FORMAT_ID* pId);
	VOID	EnableMedia(LPGUID pMediaTypeGuid, BOOL fSendDirection, BOOL fEnabled);
	BOOL	IsInSendList(LPGUID pMediaTypeGuid) { return IsInList(pMediaTypeGuid, m_pSendMediaList); }
	BOOL	IsInRecvList(LPGUID pMediaTypeGuid) { return IsInList(pMediaTypeGuid, m_pRecvMediaList); }
	VOID	Clear();
};

#endif // _MEDIALST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\medialst.cpp ===
#include "precomp.h"
#include "medialst.h"


CMediaList::CMediaList() :
	m_pResolvedFormatIDs (NULL),
	m_pSendMediaGuids	(NULL),
    m_pSendMediaList	(NULL), 
    m_pRecvMediaList	(NULL),
    m_uNumSendMedia 	(0),
    m_uNumRecvMedia		(0),
	m_uNumResolvedMedia	(0)
{
}

CMediaList::~CMediaList()
{
	if(m_pResolvedFormatIDs)
		LocalFree(m_pResolvedFormatIDs);
	if(m_pSendMediaGuids)
		LocalFree(m_pSendMediaGuids);
	if(m_pSendMediaList)
	{
		PGUIDLIST pNext, pThis;
		pThis = m_pSendMediaList;
		while(pThis)
		{
			pNext = pThis->pnext;
			delete pThis;
			pThis = pNext;
		}
	}
	if(m_pRecvMediaList)
	{
		PGUIDLIST pNext, pThis;
		pThis = m_pRecvMediaList;
		while(pThis)
		{
			pNext = pThis->pnext;
			delete pThis;
			pThis = pNext;
		}
	}
}

VOID CMediaList::AddSendMedia(LPGUID pMediaTypeGuid)
{
	PGUIDLIST pGLThis;
	pGLThis = new GUIDLIST;
	ASSERT(pGLThis);
	
	pGLThis->pnext = m_pSendMediaList;
	m_pSendMediaList = pGLThis;
	pGLThis->guid = *pMediaTypeGuid;
	m_uNumSendMedia++;
}

VOID CMediaList::RemoveSendMedia(LPGUID pMediaTypeGuid)
{
	PGUIDLIST pGLThis, pGLToast = m_pSendMediaList;
	while(pGLToast)
	{
		if(pGLToast->guid == *pMediaTypeGuid)
		{
			// check head case
			if(pGLToast == m_pSendMediaList)
			{
				m_pSendMediaList = pGLToast->pnext;
			}
			else
			{
				pGLThis->pnext = pGLToast->pnext;
			}
			delete pGLToast;
			m_uNumSendMedia--;
			break;
		}
		pGLThis = pGLToast;
		pGLToast = pGLToast->pnext;
	}
}
VOID CMediaList::AddRecvMedia(LPGUID pMediaTypeGuid)
{
	PGUIDLIST pGLThis;
	pGLThis = new GUIDLIST;
	ASSERT(pGLThis);
	
	pGLThis->pnext = m_pRecvMediaList;
	m_pRecvMediaList = pGLThis;
	pGLThis->guid = *pMediaTypeGuid;
	m_uNumRecvMedia++;
}
VOID CMediaList::RemoveRecvMedia(LPGUID pMediaTypeGuid)
{
	PGUIDLIST pGLThis, pGLToast = m_pRecvMediaList;
	while(pGLToast)
	{
		if(pGLToast->guid == *pMediaTypeGuid)
		{
			// check head case
			if(pGLToast == m_pRecvMediaList)
			{
				m_pSendMediaList = pGLToast->pnext;
			}
			else
			{
				pGLThis->pnext = pGLToast->pnext;
			}
			delete pGLToast;
			m_uNumRecvMedia--;
			break;
		}
		pGLThis = pGLToast;
		pGLToast = pGLToast->pnext;
	}
}

VOID CMediaList::EnableMedia(LPGUID pMediaTypeGuid, BOOL fSendDirection, BOOL fEnabled)
{
	// two bits of info: Send = 1, enable = 2
	// 0 - disable receive
	// 1 - disable send
	// 2 - enable receive
	// 3 - enable send
	int the_case;
	
	the_case = (fSendDirection)?1:0;
	the_case |= (fEnabled)? 2:0;

	switch(the_case)
	{
		case 0:
			RemoveRecvMedia(pMediaTypeGuid);
		break;
		case 1:
			RemoveSendMedia(pMediaTypeGuid);
		break;
		case 2:
			AddRecvMedia(pMediaTypeGuid);
		break;
		case 3:
			AddSendMedia(pMediaTypeGuid);
		break;		
	}
}

BOOL CMediaList::IsInList(LPGUID pMediaTypeGuid, PGUIDLIST pList)
{
	PGUIDLIST pGLThis = pList;
	while(pGLThis)
	{
		if(pGLThis->guid == *pMediaTypeGuid)
		{
			return TRUE;
		}
		//else
		pGLThis = pGLThis->pnext;
	}
	return FALSE;
}

HRESULT CMediaList::ResolveSendFormats(IH323Endpoint* pConnection)
{
	UINT ui;
	PGUIDLIST pGLThis;

	ASSERT(NULL == m_pSendMediaGuids);
	ASSERT((0 != m_uNumSendMedia) && (NULL != m_pSendMediaList));
	
	m_pSendMediaGuids = (GUID *)LocalAlloc(LMEM_FIXED, m_uNumSendMedia*sizeof(GUID));
	ASSERT(NULL != m_pSendMediaGuids);

	for(ui=0, pGLThis = m_pSendMediaList; ui<m_uNumSendMedia; ui++)
	{
		ASSERT(NULL != pGLThis);
		*(m_pSendMediaGuids+ui) = pGLThis->guid;
		pGLThis = pGLThis->pnext;
	}
	
	// alloc space for resolved format IDs.
	ASSERT(NULL == m_pResolvedFormatIDs);
	m_pResolvedFormatIDs = 
		(RES_PAIR *)LocalAlloc(LMEM_FIXED, m_uNumSendMedia*sizeof(RES_PAIR));
	
	ASSERT(NULL != m_pResolvedFormatIDs);
	
	// and set m_uNumResolvedMedia
	m_uNumResolvedMedia = m_uNumSendMedia;

	// resolve capabilities
	return pConnection->ResolveFormats(m_pSendMediaGuids, m_uNumResolvedMedia, 
		m_pResolvedFormatIDs);
}

BOOL CMediaList::GetSendFormatLocalID(REFGUID guidMedia, MEDIA_FORMAT_ID* pId)
{
	UINT ui;
	PGUIDLIST pGLThis;

	// find the index of the appropriate media type.  Need to do this because
	// the order of media types in the list is unknown and there isn't a
	// table that relates the types with the resolved ID's.  Need to 
	// add such a table when decentralized media is supported.
	for(ui=0, pGLThis = m_pSendMediaList; ui<m_uNumSendMedia; ui++)
	{
		ASSERT(NULL != pGLThis);
		if (pGLThis->guid == guidMedia)
		{
			*pId = m_pResolvedFormatIDs[ui].idLocal;
			return TRUE;
		}
		pGLThis = pGLThis->pnext;
	}

	return FALSE;
}

VOID CMediaList::Clear()
{
	if(m_pResolvedFormatIDs)
	{
		LocalFree(m_pResolvedFormatIDs);
		m_pResolvedFormatIDs = NULL;
	}
	if(m_pSendMediaGuids)
	{
		LocalFree(m_pSendMediaGuids);
		m_pSendMediaGuids = NULL;
	}
	if(m_pSendMediaList)
	{
		PGUIDLIST pNext, pThis;
		pThis = m_pSendMediaList;
		while(pThis)
		{
			pNext = pThis->pnext;
			delete pThis;
			pThis = pNext;
		}
		m_pSendMediaList = NULL;
	}
	if(m_pRecvMediaList)
	{
		PGUIDLIST pNext, pThis;
		pThis = m_pRecvMediaList;
		while(pThis)
		{
			pNext = pThis->pnext;
			delete pThis;
			pThis = pNext;
		}
		m_pRecvMediaList = NULL;
	}
	m_uNumSendMedia = 0;
	m_uNumRecvMedia = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\imember.h ===
// File: iMember.h

#ifndef _IMEMBER_H_
#define _IMEMBER_H_

#include "nmenum.h"
#include "cuserdta.hpp"
#include <ih323cc.h>

#define INVALID_GCCID      ((DWORD) -1)
#define H323_GCCID_LOCAL   ((DWORD) -2)
#define H323_GCCID_REMOTE  ((DWORD) -3)

class USER_DATA_LIST;

// A valid T.120 GCC ID must be in this range:
#define FValidGccId(dw)    ((dw >= 1) && (dw <= 65535))


// *** DO NOT CHANGE these flags without checking the
// corresponding CONF_UF_* items in msconf.h

// PARTICIPANT flags:

// Media Types: 
const DWORD PF_MEDIA_DATA     = 0x00000001;
const DWORD PF_MEDIA_AUDIO    = 0x00000002;
const DWORD PF_MEDIA_VIDEO    = 0x00000004;
 
const DWORD PF_T120           = 0x00000010;
const DWORD PF_H323           = 0x00000020;
const DWORD PF_T127_LAUNCHED  = 0x00000040; // Requested T.127 (FT) be started
 
const DWORD PF_LOCAL_NODE     = 0x00000100; // Local User
const DWORD PF_T120_MCU       = 0x00000200; // MCU
const DWORD PF_T120_TOP_PROV  = 0x00000400; // Top Provider
 
// Control Arbitration specific 
const DWORD PF_CA_VIEWING     = 0x00001000;
const DWORD PF_CA_DETACHED    = 0x00002000; // Working alone
const DWORD PF_CA_CONTROL     = 0x00004000; // In Control
const DWORD PF_CA_MASK        = 0x0000F000;
const DWORD PF_CA_MODEMASK = (PF_CA_VIEWING | PF_CA_DETACHED);
 
// NetMeeting Version
const DWORD PF_VER_UNKNOWN    = 0x00000000; // Not Microsoft NetMeeting
const DWORD PF_VER_NM_1       = 0x00010000; // NetMeeting 1.0 (Build 1133)
const DWORD PF_VER_NM_2       = 0x00020000; // NetMeeting 2.0 (Build 1368)
const DWORD PF_VER_NM_3       = 0x00030000; // NetMeeting 2.1x (Build 2135)
const DWORD PF_VER_NM_4       = 0x00040000; // NetMeeting 3.0
const DWORD PF_VER_FUTURE     = 0x000F0000; // Future NetMeeting version
const DWORD PF_VER_MASK       = 0x000F0000;
 
const DWORD PF_RESERVED       = 0x80000000;

const DWORD PF_VER_CURRENT = PF_VER_NM_4;   // Current version

const DWORD PF_DATA_ALL =	(	PF_MEDIA_DATA |
								PF_CA_MASK |
								PF_T120 |
								PF_T120_MCU |
								PF_T120_TOP_PROV);

class CNmMember : public DllRefCount, public INmMember
{
private:
	BSTR   m_bstrName;            // Display Name
	DWORD  m_dwGCCID;            // GCC UserId
	BOOL   m_fLocal;             // True if local user
	ULONG  m_uCaps;              // Current Roster Caps (CAPFLAG_*)
	ULONG  m_uNmchCaps;           // Current Channel Capabilities (NMCH_*)
	DWORD  m_dwFlags;            // PF_*
	DWORD  m_dwGccIdParent;      // GCCID of parent node
	GUID   m_guidNode;           // unique Id of this node
	UINT   m_cbUserInfo;         // size of user info (in bytes)
	PWSTR  m_pwszUserInfo;       // user info
	USER_DATA_LIST m_UserData;	 // user data
	IH323Endpoint* m_pConnection;

public:
	CNmMember(PWSTR pwszName, DWORD dwGCCID, DWORD dwFlags, ULONG uCaps,
	          REFGUID pguidNode, PVOID pwszUserInfo, UINT cbUserInfo);
	~CNmMember();

	// Internal methods
	IH323Endpoint *  GetH323Endpoint() { return m_pConnection;};
	VOID AddH323Endpoint(IH323Endpoint *pConnection) 
	{
        if(pConnection)
        {
            ASSERT(m_pConnection == NULL);
            m_pConnection = pConnection;
            m_pConnection->AddRef();
        }
	}
	VOID DeleteH323Endpoint(IH323Endpoint *pConnection) 
	{
        ASSERT(m_pConnection && (m_pConnection == pConnection ));
        m_pConnection->Release();
        m_pConnection = NULL;
    }
	DWORD GetDwFlags()            {return m_dwFlags;}
	VOID  SetDwFlags(DWORD dw)    {m_dwFlags = dw;}
	
	VOID AddPf(DWORD dw)          {m_dwFlags |= dw;}
	VOID RemovePf(DWORD dw)       {m_dwFlags &= ~dw;}

	ULONG GetNmchCaps()                  {return m_uNmchCaps;}
	VOID SetNmchCaps(ULONG uNmchCaps)    {m_uNmchCaps = uNmchCaps;}

	VOID AddNmchCaps(ULONG uNmchCaps)    {m_uNmchCaps |= uNmchCaps;}
	VOID RemoveNmchCaps(ULONG uNmchCaps) {m_uNmchCaps &= ~uNmchCaps;}

	DWORD GetGCCID()              {return m_dwGCCID;}
	VOID  SetGCCID(DWORD dw)      {m_dwGCCID = dw;}

	DWORD GetGccIdParent()        {return m_dwGccIdParent;}
	VOID  SetGccIdParent(DWORD dw);

	ULONG GetCaps()               {return m_uCaps;}
	VOID  SetCaps(ULONG uCaps)    {m_uCaps = uCaps;}

	PVOID GetUserInfo()           {return m_pwszUserInfo;}
	VOID  SetUserInfo(PVOID pwszUserInfo, UINT cbUserInfo);

	BOOL  GetSecurityData(PBYTE * ppb, ULONG * pcb);
	
	BOOL  FLocal()                {return m_fLocal;}
	BOOL  FTopProvider()          {return (0 != (m_dwFlags & PF_T120_TOP_PROV));}
	BOOL  FMcu()                  {return (0 != (m_dwFlags & PF_T120_MCU));}
	BOOL  FHasData()              {return (0 != (m_dwFlags & PF_T120));}

	BSTR GetName()                    {return m_bstrName;}
	REFGUID GetNodeGuid()		      {return m_guidNode;}

	HRESULT ExtractUserData(LPTSTR psz, UINT cchMax, PWSTR pwszKey);
	HRESULT GetIpAddr(LPTSTR psz, UINT cchMax);

	HRESULT STDMETHODCALLTYPE SetUserData(REFGUID rguid, BYTE *pb, ULONG cb);

	// INmMember methods
	HRESULT STDMETHODCALLTYPE GetName(BSTR *pbstrName);
	HRESULT STDMETHODCALLTYPE GetID(ULONG * puID);
	HRESULT STDMETHODCALLTYPE GetNmVersion(ULONG *puVersion);
	HRESULT STDMETHODCALLTYPE GetAddr(BSTR *pbstrAddr, NM_ADDR_TYPE *puType);
	HRESULT STDMETHODCALLTYPE GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	HRESULT STDMETHODCALLTYPE GetConference(INmConference **ppConference);
	HRESULT STDMETHODCALLTYPE GetNmchCaps(ULONG *puchCaps);
	HRESULT STDMETHODCALLTYPE GetShareState(NM_SHARE_STATE *puState);
	HRESULT STDMETHODCALLTYPE IsSelf(void);
	HRESULT STDMETHODCALLTYPE IsMCU(void);
	HRESULT STDMETHODCALLTYPE Eject(void);

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
};

// Utility Functions
CNmMember * GetLocalMember(void);
CNmMember * PMemberFromGCCID(UINT uNodeID);
CNmMember *	PMemberFromNodeGuid(REFGUID rguidNode);
CNmMember *	PDataMemberFromName(PCWSTR pwszName);

typedef CEnumNmX<IEnumNmMember, &IID_IEnumNmMember, INmMember, CNmMember> CEnumNmMember;

#endif // _IMEMBER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\isysinfo.cpp ===
// File: isysinfo.cpp
//
// INmSysInfo interface  (system information)

#include "precomp.h"
#include "imanager.h"
#include "cuserdta.hpp"
#include "isysinfo.h"
#include <iappldr.h>
#include <tsecctrl.h>

extern VOID SetBandwidth(UINT uBandwidth);

CNmSysInfo* CNmSysInfo::m_pSysInfo = NULL;

BOOL g_fLoggedOn = FALSE; // Set by NM_SYSOPT_LOGGED_ON

static HRESULT OnGateKeeperNotify(IUnknown *pNmSysNotify, LPVOID code, REFIID riid);


static const IID * g_apiidCP_Manager[] =
{
    {&IID_INmSysInfoNotify}
};

/*  C  N M  S Y S  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: CNmSysInfo

-------------------------------------------------------------------------*/
CNmSysInfo::CNmSysInfo() :
	CConnectionPointContainer(g_apiidCP_Manager, ARRAY_ELEMENTS(g_apiidCP_Manager)),
	m_bstrUserName(NULL)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CNmSysInfo", this);

	ASSERT(NULL == m_pSysInfo);

	m_pSysInfo = this;
}


CNmSysInfo::~CNmSysInfo(void)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CNmSysInfo", this);

	SysFreeString(m_bstrUserName);

	m_pSysInfo = NULL;
}


//////////////////////////////////////////////////////////////////////////
//  CNmSysInfo:IUknown

ULONG STDMETHODCALLTYPE CNmSysInfo::AddRef(void)
{
	return RefCount::AddRef();
}
	
ULONG STDMETHODCALLTYPE CNmSysInfo::Release(void)
{
	return RefCount::Release();
}


HRESULT STDMETHODCALLTYPE CNmSysInfo::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmSysInfo2) || (riid == IID_INmSysInfo) || (riid == IID_IUnknown))
	{
		*ppv = (INmSysInfo *)this;
		ApiDebugMsg(("CNmSysInfo::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		DbgMsgApi("CNmSysInfo::QueryInterface(): Returning IConnectionPointContainer.");
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CNmSysInfo::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////
// INmSysInfo

HRESULT STDMETHODCALLTYPE CNmSysInfo::IsInstalled(void)
{
	// TODO: GetLaunchInfo isn't useful for in-proc
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::GetProperty(NM_SYSPROP uProp, BSTR *pbstrProp)
{
	return E_NOTIMPL;
}	


HRESULT STDMETHODCALLTYPE CNmSysInfo::SetProperty(NM_SYSPROP uProp, BSTR bstrData)
{
	switch (uProp)
	{
		case NM_SYSPROP_USER_NAME:
			SysFreeString(m_bstrUserName);
			m_bstrUserName = SysAllocString(bstrData);

			if (NULL != g_pH323UI)
			{
				g_pH323UI->SetUserName(bstrData);
			}
			return S_OK;

		default:
			break;
	}

	return E_INVALIDARG;
}


HRESULT STDMETHODCALLTYPE CNmSysInfo::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	return m_UserData.GetUserData(rguid,ppb,pcb);
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::SetUserData(REFGUID rguid, BYTE *pb, ULONG cb)
{
	return m_UserData.AddUserData((GUID *)&rguid,(unsigned short)cb,pb);
}


HRESULT STDMETHODCALLTYPE CNmSysInfo::GetNmApp(REFGUID rguid,
		BSTR *pbstrApplication, BSTR *pbstrCommandLine, BSTR *pbstrDirectory)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::SetNmApp(REFGUID rguid,
		BSTR bstrApplication, BSTR bstrCommandLine, BSTR bstrDirectory)
{
	return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CNmSysInfo::GetNmchCaps(ULONG *pchCaps)
{
	return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CNmSysInfo::GetLaunchInfo(INmConference **ppConference, INmMember **ppMember)
{
	return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////
// INmSysInfo3

HRESULT STDMETHODCALLTYPE CNmSysInfo::GetOption(NM_SYSOPT uOption, ULONG * plValue)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::SetOption(NM_SYSOPT uOption, ULONG lValue)
{
	IAudioDevice *pAudioDevice = NULL;
	IMediaChannelBuilder *pMCB = NULL;

	switch (uOption)
		{
	case NM_SYSOPT_BANDWIDTH:
	{
		::SetBandwidth(lValue);
		return S_OK;
	}
	
	case NM_SYSOPT_CAPTURE_DEVICE:
	{
		if (NULL == g_pH323UI)
			return E_FAIL;

		g_pH323UI->SetCaptureDevice(lValue);
		return S_OK;
	}
	
	case NM_SYSOPT_LOGGED_ON:
	{
		g_fLoggedOn = lValue;
		return S_OK;
	}

	case NM_SYSOPT_DIRECTSOUND:
	{
		if (NULL == g_pH323UI)
			return E_FAIL;

		pMCB = g_pH323UI->GetStreamProvider();

		if (pMCB)
		{
			pMCB->QueryInterface(IID_IAudioDevice, (void**)&pAudioDevice);
			pAudioDevice->SetDirectSound((BOOL)lValue);
			pAudioDevice->Release();
			pMCB->Release();
			return S_OK;
		}
	}

	case NM_SYSOPT_FULLDUPLEX:
	{
		if (NULL == g_pH323UI)
			return E_FAIL;

		pMCB = g_pH323UI->GetStreamProvider();
		if (pMCB)
		{
			pMCB->QueryInterface(IID_IAudioDevice, (void**)&pAudioDevice);
			pAudioDevice->SetDuplex((BOOL)lValue);  // true==full, false==half
			pAudioDevice->Release();
			pMCB->Release();
			return S_OK;
		}
	}

	default:
		break;
	}

	return E_INVALIDARG;
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::ProcessSecurityData(DWORD dwTaskCode, DWORD_PTR dwParam1, DWORD_PTR dwParam2,
    	DWORD * pdwResult)
{
    switch (dwTaskCode)
    {
        case LOADFTAPPLET:
        {
            ::T120_LoadApplet(APPLET_ID_FT, TRUE, 0, FALSE, NULL);
            return S_OK;
        }
        case UNLOADFTAPPLET:
        {
            ::T120_CloseApplet(APPLET_ID_FT, TRUE, TRUE, 600);
            return S_OK;
        }
        default:
        {
            if (NULL != pdwResult) {
				(* pdwResult) = ::T120_TprtSecCtrl(dwTaskCode, dwParam1, dwParam2);
				return S_OK;
            }
            else {
				return E_FAIL;
            }
        }
    }
}


//////////////////////////////////////////////////////////////////////////
// Gatekeeper / Alias routines

HRESULT STDMETHODCALLTYPE CNmSysInfo::GkLogon(BSTR bstrServer, BSTR bstrAliasID, BSTR bstrAliasE164)
{
	TRACE_OUT(("Gatekeeper Logon: Server=[%ls] AliasID=[%ls] AliasE164=[%ls]",
		bstrServer,
		bstrAliasID ? bstrAliasID : L"<NULL>",
		bstrAliasE164 ? bstrAliasE164 : L"<NULL>"));

	HRESULT hr = E_FAIL;
	
	if (NULL != g_pH323UI)
	{
		IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();
		if (NULL != pH323CallControl)
		{
			SOCKADDR_IN sin;
			sin.sin_family = AF_INET;
			sin.sin_addr.s_addr = inet_addr(CUSTRING(bstrServer));

			// If inet_addr failed, this may be a host address, so try to
			// resolve it

			if (INADDR_NONE == sin.sin_addr.s_addr)
			{
				HOSTENT *host_info;
				
				if ( NULL != (host_info = gethostbyname(CUSTRING(bstrServer))))
				{
					// Only expecting IP addresses..
					ASSERT(( host_info->h_addrtype == AF_INET ));
					ASSERT(( host_info->h_length == sizeof(DWORD)));

					sin.sin_addr.s_addr = *((DWORD *)host_info->h_addr);
				}
			}

			if ((INADDR_NONE != sin.sin_addr.s_addr)
			 && (INADDR_ANY != sin.sin_addr.s_addr))
			{
				H323ALIASLIST AliasList;
				H323ALIASNAME AliasNames[2];
				UINT nAliases = 0;
				UINT nLen;
				
				nLen = SysStringLen(bstrAliasID);
				if (nLen > 0)
				{
					AliasNames[nAliases].aType = AT_H323_ID;
					AliasNames[nAliases].lpwData = bstrAliasID;
					AliasNames[nAliases].wDataLength = (WORD)nLen;// # of unicode chars, w/o NULL terminator
					++nAliases;
				}
				nLen = SysStringLen(bstrAliasE164);
				if (nLen > 0)
				{
					AliasNames[nAliases].aType = AT_H323_E164;
					AliasNames[nAliases].lpwData = bstrAliasE164;
					AliasNames[nAliases].wDataLength = (WORD)nLen;// # of unicode chars, w/o NULL terminator
					++nAliases;
				}
				AliasList.wCount = (WORD)nAliases;
				AliasList.pItems = AliasNames;

				hr = pH323CallControl->EnableGatekeeper(TRUE, &sin, &AliasList, CNmSysInfo::RasNotify);
				if (SUCCEEDED(hr))
				{
					// keep a global copy of the Getkeeper SOCKADDR_IN
					g_sinGateKeeper = sin;
				}
			}
		}
	}
	
	return hr;
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::GkLogoff(void)
{
	TRACE_OUT(("Gatekeeper Logoff"));

	HRESULT hr = S_OK;

	if (NULL != g_pH323UI)
	{
		IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();
		if (NULL != pH323CallControl)
		{
			hr = pH323CallControl->EnableGatekeeper(FALSE,  NULL, NULL, CNmSysInfo::RasNotify);
			if (SUCCEEDED(hr))
			{
				// invalidate the global Getkeeper SOCKADDR_IN
				g_sinGateKeeper.sin_addr.s_addr = INADDR_NONE;
			}
		}
	}


	return hr;
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::GkState(NM_GK_STATE * pgkState)
{
	if (NULL == pgkState)
		return E_POINTER;

	*pgkState = NM_GK_INVALID;
	return E_NOTIMPL;
}


VOID CALLBACK CNmSysInfo::RasNotify(DWORD dwRasEvent, HRESULT hReason)
{
	
	NM_GK_NOTIFY_CODE code = NM_GKNC_INVALID;

	switch(dwRasEvent)
	{
		case RAS_REG_TIMEOUT:	// GK did not respond.  (no hReason)
			code = NM_GKNC_LOGON_TIMEOUT;
			break;

		case RAS_REG_CONFIRM:	// received RCF (registration confirmed)  (no hReason)
			code = NM_GKNC_REG_CONFIRM;
			break;

		case RAS_UNREG_CONFIRM: // received UCF (unregistration confirmed)  (no hReason)
			code = NM_GKNC_UNREG_CONFIRM;
			break;

		case RAS_REJECTED:		// received RRJ (registration rejected)
			
			code = NM_GKNC_REJECTED;

			ASSERT(CUSTOM_FACILITY(hReason) == FACILITY_GKIREGISTRATION);
			switch(CUSTOM_FACILITY_CODE(hReason))
			{
				case RRJ_DISCOVERY_REQ:					TRACE_OUT(("NmSysInfo::RasNotify: GateKeeper logon failed with code RRJ_DISCOVERY_REQ"));
					break;

				case RRJ_INVALID_REVISION:				TRACE_OUT(("GateKeeper logon failed with code RRJ_INVALID_REVISION"));
					break;

				case RRJ_INVALID_CALL_ADDR:				TRACE_OUT(("GateKeeper logon failed with code RRJ_INVALID_CALL_ADDR"));
					break;

				case RRJ_INVALID_RAS_ADDR:				TRACE_OUT(("GateKeeper logon failed with code RRJ_INVALID_RAS_ADDR"));
					break;	

				case RRJ_DUPLICATE_ALIAS:				TRACE_OUT(("GateKeeper logon failed with code RRJ_DUPLICATE_ALIAS"));
					break;

				case RRJ_INVALID_TERMINAL_TYPE:			TRACE_OUT(("GateKeeper logon failed with code RRJ_INVALID_TERMINAL_TYPE"));
					break;

				case RRJ_UNDEFINED:						TRACE_OUT(("GateKeeper logon failed with code RRJ_UNDEFINED"));
					break;

				case RRJ_TRANSPORT_NOT_SUPPORTED:		TRACE_OUT(("GateKeeper logon failed with code RRJ_TRANSPORT_NOT_SUPPORTED"));
					break;

				case RRJ_TRANSPORT_QOS_NOT_SUPPORTED:	TRACE_OUT(("GateKeeper logon failed with code RRJ_TRANSPORT_QOS_NOT_SUPPORTED"));
					break;

				case RRJ_RESOURCE_UNAVAILABLE:			TRACE_OUT(("GateKeeper logon failed with code RRJ_RESOURCE_UNAVAILABLE"));
					break;

				case RRJ_INVALID_ALIAS:					TRACE_OUT(("GateKeeper logon failed with code RRJ_INVALID_ALIAS"));
					break;

				case RRJ_SECURITY_DENIAL:				TRACE_OUT(("GateKeeper logon failed with code RRJ_SECURITY_DENIAL"));
					break;

				default:
				break;
			}
			
		break;
		case RAS_UNREG_REQ:		// received URQ
			code = NM_GKNC_UNREG_REQ;
		// (unregistration request - means that gatekeeper booted the endpoint off)
			ASSERT(CUSTOM_FACILITY(hReason) == FACILITY_GKIUNREGREQ);
			switch(CUSTOM_FACILITY_CODE(hReason))
			{
				case URQ_REREG_REQUIRED:	// GK wants another registration
				case URQ_TTL_EXPIRED:		// TimeToLive expired
				case URQ_SECURITY_DENIAL:	
				case URQ_UNDEFINED:
				default:
				break;
			}
		break;
		default:
		break;
	}

	if( NM_GKNC_INVALID != code )
	{
		if (m_pSysInfo)
		{
			m_pSysInfo->NotifySink(reinterpret_cast<LPVOID>(code), OnGateKeeperNotify);
		}
	}
}

HRESULT OnGateKeeperNotify(IUnknown *pNmSysNotify, LPVOID code, REFIID riid)
{
	HRESULT hr = S_OK;

	if( riid == IID_INmSysInfoNotify )
	{
		NM_GK_NOTIFY_CODE gknc = (NM_GK_NOTIFY_CODE)((DWORD_PTR)(code));
		static_cast<INmSysInfoNotify*>(pNmSysNotify)->GateKeeperNotify( gknc );
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////
// Internal Methods

HRESULT STDMETHODCALLTYPE CNmSysInfo::GetUserDataList(ULONG * pnRecords, GCCUserData *** pppUserData)
{
	unsigned short nsRecords;
	HRESULT hr = m_UserData.GetUserDataList(&nsRecords,pppUserData);
	*pnRecords = nsRecords;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\pfnt120.cpp ===
// File: pfnt120.cpp

#include "precomp.h"
#include "pfnt120.h"

PFN_T120_AttachRequest PFNT120::AttachRequest = NULL;
PFN_T120_CreateAppSap  PFNT120::CreateAppSap = NULL;

HINSTANCE PFNT120::m_hInstance = NULL;

APIFCN s_apiFcnT120[] = {
	{(PVOID *) &PFNT120::AttachRequest, "MCS_AttachRequest"},
	{(PVOID *) &PFNT120::CreateAppSap,  "GCC_CreateAppSap"},
};

HRESULT PFNT120::Init(void)
{
	if (NULL != m_hInstance)
		return S_OK;

	return HrInitLpfn(s_apiFcnT120, ARRAY_ELEMENTS(s_apiFcnT120), &m_hInstance, TEXT("MST120.DLL"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\pfnt120.h ===
// File: pfnt120.h

#ifndef _PFNT120_H_
#define _PFNT120_H_

extern "C" {
#include <t120.h>
}
#include <gcc.h>
#include <igccapp.h>
#include <imcsapp.h>

extern "C" {
typedef MCSError (WINAPI * PFN_T120_AttachRequest)(IMCSSap **, DomainSelector, UINT, MCSCallBack, PVOID, UINT);
typedef GCCError (WINAPI * PFN_T120_CreateAppSap)(IGCCAppSap **, PVOID, LPFN_APP_SAP_CB);
}

class PFNT120
{
private:
	static HINSTANCE m_hInstance;

protected:
	PFNT120() {};
	~PFNT120() {};
	
public:
	static HRESULT Init(void);
	
	static PFN_T120_AttachRequest AttachRequest;
	static PFN_T120_CreateAppSap  CreateAppSap;
};

#endif /* _PFNT120_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\nmdll.cpp ===
// File: nmdll.cpp

#include "precomp.h"

///////////////////////////////////////////////////////////////////////////
// Globals

HINSTANCE g_hInst = NULL;

///////////////////////////////////////////////////////////////////////////


/*  D L L  M A I N  */
/*-------------------------------------------------------------------------
    %%Function: DllMain
    
-------------------------------------------------------------------------*/
BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID lpv)
{
	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
	{
		g_hInst = hDllInst;
		DisableThreadLibraryCalls(hDllInst);
		DbgInitZones();
        DBG_INIT_MEMORY_TRACKING(hDllInst);
		TRACE_OUT(("*** NMCOM.DLL: Attached process thread %X", GetCurrentThreadId()));
		break;
	}

	case DLL_PROCESS_DETACH:
		TRACE_OUT(("*** NMCOM.DLL: Detaching process thread %X", GetCurrentThreadId()));
        DBG_CHECK_MEMORY_TRACKING(hDllInst);
		DbgFreeZones();
		break;

	default:
		break;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\nmenum.h ===
#ifndef _NMENUM_H_
#define _NMENUM_H_

#include "oblist.h"
// IEnumNmX
//
template <class IEnumNmX, const IID* piidEnumNmX, class INmX, class CNmX>
class CEnumNmX : public IEnumNmX
{
private:
	INmX	**m_pList;		   // The list
	int 	  m_iCurr;		   // Current index number
	int 	  m_iMax;		   // Maximum index
	ULONG	  m_cRef;

public:
	CEnumNmX(COBLIST * pList, int cItems) :
		m_iCurr(0),
		m_iMax(0),
		m_pList(NULL),
		m_cRef(1)
	{
		if ((NULL != pList) && (0 != cItems))
		{
			m_pList = new INmX* [cItems];
			if (NULL != m_pList)
			{
				POSITION pos = pList->GetHeadPosition();
				while ((NULL != pos) && (m_iMax < cItems))
				{
					INmX *pINmX = (INmX *) (CNmX *) pList->GetNext(pos);
					ASSERT(NULL != pINmX);
					pINmX->AddRef();
					m_pList[m_iMax] = pINmX;
					m_iMax++;
				}
			}
		}
//		ApiDebugMsg(("CEnumNmX - Constructed(%08X)", this));
	}

	CEnumNmX(COBLIST * pList)
	{
		int cItems = 0;
		if (NULL != pList)
		{
			POSITION pos = pList->GetHeadPosition();
			while (NULL != pos)
			{
				pList->GetNext(pos);
				cItems++;
			}
		}
		CEnumNmX(pList, cItems);
	}


	CEnumNmX(CNmX **rgpNmX, ULONG cItems) :
		m_iCurr(0),
		m_iMax(0),
		m_pList(NULL),
		m_cRef(1)
	{
		if (NULL != rgpNmX)
		{
			m_pList = new INmX* [cItems];
			if (NULL != m_pList)
			{
				m_iMax = cItems;

				for (int i = 0; i < m_iMax; ++i)
				{
					ASSERT(NULL != rgpNmX[i]);
					rgpNmX[i]->AddRef();
					m_pList[i] = rgpNmX[i];
				}
			}
		}
//		ApiDebugMsg(("CEnumNmX - Constructed(%08X)", this));
	}

	~CEnumNmX(void)
	{
		for (int i = 0; i < m_iMax; ++i)
		{
			ASSERT(NULL != m_pList[i]);
			m_pList[i]->Release();
		}
		delete m_pList;

//		ApiDebugMsg(("CEnumNmX - Destructed (%08X)", this));
	}

	STDMETHODIMP_(ULONG) AddRef(void)
	{
		return ++m_cRef;
	}
		
	STDMETHODIMP_(ULONG) Release(void)
	{
		ASSERT(m_cRef > 0);

		if (m_cRef > 0)
		{
			m_cRef--;
		}

		ULONG cRef = m_cRef;

		if (0 == cRef)
		{
			delete this;
		}

		return cRef;
	}

	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv)
	{
		HRESULT hr = S_OK;

		if ((riid == *piidEnumNmX) || (riid == IID_IUnknown))
		{
			*ppv = (IEnumNmX *)this;
//			ApiDebugMsg(("CEnumNmX::QueryInterface(): Returning IEnumNmX."));
		}
		else
		{
			hr = E_NOINTERFACE;
			*ppv = NULL;
//			ApiDebugMsg(("CEnumNmX::QueryInterface(): Called on unknown interface."));
		}

		if (S_OK == hr)
		{
			AddRef();
		}

		return hr;
	}

	STDMETHODIMP Next(ULONG cItem, INmX **rgpNmX, ULONG *pcFetched)
	{
		ULONG cCopied = 0;

		if ((0 == cItem) && (NULL == rgpNmX) && (NULL != pcFetched))
		{
			// Return the number of remaining elements
			*pcFetched = m_iMax - m_iCurr;
			return S_OK;
		}
		
		if ((NULL == rgpNmX) || ((NULL == pcFetched) && (cItem != 1)))
			return E_POINTER;

		if (NULL != m_pList)
		{
			while ((cCopied < cItem) && (m_iCurr < m_iMax))
			{
				*rgpNmX = m_pList[m_iCurr];
				ASSERT(NULL != *rgpNmX);
				(*rgpNmX)->AddRef();
				rgpNmX++;
				cCopied++;
				m_iCurr++;
			}
		}

		if (pcFetched != NULL)
			*pcFetched = cCopied;

		return ((cItem == cCopied) ? S_OK : S_FALSE);
	}

	STDMETHODIMP Skip(ULONG cItem)
	{
		m_iCurr += cItem;
		if (m_iCurr >= m_iMax)
		{
			// Past the end of the list
			m_iCurr = m_iMax;
			return S_FALSE;
		}

		return S_OK;
	}

	STDMETHODIMP Reset()
	{
		m_iCurr = 0;
		return S_OK;
	}

	STDMETHODIMP Clone(IEnumNmX **ppEnum)
	{
		if (NULL == ppEnum)
			return E_POINTER;

		HRESULT hr = S_OK;
		CEnumNmX * pEnum = new CEnumNmX(NULL, 0);
		if (NULL == pEnum)
		{
			hr = E_OUTOFMEMORY;
		}
		else if (NULL != m_pList)
		{
			pEnum->m_pList = new INmX*[m_iMax];
			if (NULL == pEnum->m_pList)
			{
				delete pEnum;
				pEnum = NULL;
				hr = E_OUTOFMEMORY;
			}
			else
			{
				pEnum->m_iCurr = m_iCurr;
				pEnum->m_iMax = m_iMax;

				for (int i = 0; i < m_iMax; ++i)
				{
					ASSERT(NULL != m_pList[i]);
					m_pList[i]->AddRef();
					pEnum->m_pList[i] = m_pList[i];
				}
			}
		}

		*ppEnum = pEnum;
		return hr;
	}
};

#endif	// _NMENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\refcount.cpp ===
// File: refcount.cpp
//
// RefCount class

#include "precomp.h"


/*  R E F  C O U N T  */
/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount(OBJECTDESTROYEDPROC ObjectDestroyed)
{
	ASSERT((!ObjectDestroyed) ||
		IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

	m_ulcRef = 1;
	m_ObjectDestroyed = ObjectDestroyed;
	DbgMsgRefCount("Ref: %08X c=%d (created)", this, m_ulcRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
#ifdef DEBUG
	m_fTrack = FALSE;
#endif
}


RefCount::~RefCount(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	// m_ulcRef may be any value.
	DbgMsgRefCount("Ref: %08X c=%d (destroyed)", this, m_ulcRef);

	if (m_ObjectDestroyed)
	{
		m_ObjectDestroyed();
		m_ObjectDestroyed = NULL;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	ASSERT(m_ulcRef < ULONG_MAX);
	m_ulcRef++;
	DbgMsgRefCount("Ref: %08X c=%d (AddRef)", this, m_ulcRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

#ifdef DEBUG
	if (m_fTrack)
	{
		DbgMsg(iZONE_OBJECTS, "Obj: %08X c=%d (AddRef)  *** Tracking", this, m_ulcRef);
	}
#endif
	return m_ulcRef;
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	if (m_ulcRef > 0)
	{
		m_ulcRef--;
	}

#ifdef DEBUG
	if (m_fTrack)
	{
		DbgMsg(iZONE_OBJECTS, "Obj: %08X c=%d (Release) *** Tracking", this, m_ulcRef);
	}
#endif

	ULONG ulcRef = m_ulcRef;
	DbgMsgRefCount("Ref: %08X c=%d (Release)", this, m_ulcRef);

	if (! ulcRef)
	{
		delete this;
	}

	return ulcRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\refcount.h ===
// File: refcount.h

#ifndef _REFCOUNT_H_
#define _REFCOUNT_H_

// RefCount destructor callback function
typedef void (*OBJECTDESTROYEDPROC)(void);
VOID STDMETHODCALLTYPE DLLObjectDestroyed(void);
VOID DllLock(void);


//////////////////////////////////////////////////////////////////////////


class RefCount
{
protected:
	ULONG m_ulcRef;
	OBJECTDESTROYEDPROC m_ObjectDestroyed;

#ifdef DEBUG
	BOOL m_fTrack;
#endif

public:
	RefCount(OBJECTDESTROYEDPROC ObjectDestroyed);
	// Virtual destructor defers to destructor of derived class.
	virtual ~RefCount(void);

	// IUnknown
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);

#ifdef DEBUG
	VOID SetTrack(BOOL fTrack)  {m_fTrack = fTrack;}
#endif
};
DECLARE_STANDARD_TYPES(RefCount);


// Special version of the above that calls our standard Dll locking functions
class DllRefCount : public RefCount
{
public:
	DllRefCount() : RefCount(&DLLObjectDestroyed) {DllLock();}
	~DllRefCount(void) {};
};

#endif /* _REFCOUNT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\precomp.h ===
// File: precomp.h

#define OEMRESOURCE
#define INC_OLE2

// Standard Windows includes
#include <windows.h>
#include <tchar.h>
#include <ocidl.h>
#include <mmsystem.h>
#include <winsock.h>
#include <time.h>

// Standard NetMeeting includes
#include <ConfDbg.h>
#include <debspew.h>
#include <oblist.h>
#include <CSTRING.hpp>
#include <ConfReg.h>
#include <oprahcom.h>
#include <confevt.h>
#include <dllutil.h>
#include <mtgset.h>

#include "SDKInternal.h"

#include "debug.h"
#include "global.h"

#include "refcount.h"
#include "connpnts.h"
#include "imember.h"
#include "ichannel.h"
#include "iconf.h"





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\util.h ===
// File: util.h

#ifndef _UTIL_H_
#define _UTIL_H_

enum H323VERSION
{
	H323_Unknown,
	H323_NetMeeting20,
	H323_NetMeeting21,
	H323_NetMeeting211,
	H323_NetMeeting30,
	H323_NetMeetingFuture,
	H323_TAPI30,
	H323_TAPIFuture,
	H323_MicrosoftFuture,
};

H323VERSION GetH323Version(PCC_VENDORINFO pRemoteVendorInfo);

#endif _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\resource.h ===
// File: resource.h

#define IDS_COPY_OF             2001
#define IDS_COPY_N_OF           2002
#define IDS_INVALID_NAME        2003
#define IDS_FT_RECDIR_DEFAULT   566
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\util.cpp ===
// File: util.cpp
//
// General Utilities

#include "precomp.h"
#include "avcommon.h"
#include "util.h"

static BOOL VersionCheck(PCC_VENDORINFO pVendorInfo, LPCSTR pszVersion)
{
	return (0 == _StrCmpN((char*)(pVendorInfo->pVersionNumber->pOctetString),
					pszVersion,
					pVendorInfo->pVersionNumber->wOctetStringLength));
}


static BOOL ProductCheck(PCC_VENDORINFO pVendorInfo, LPCSTR pszName)
{
	BOOL fFound = FALSE;
	// Octet string may not be terminated allow for terminator
	int len = pVendorInfo->pProductNumber->wOctetStringLength + 1;
	char* pszPN = new char[len];

	if (NULL != pszPN)
	{

		lstrcpyn(pszPN, (char*)pVendorInfo->pProductNumber->pOctetString, len);

		fFound = (NULL != _StrStr(pszPN, pszName));

		delete[] pszPN;
	}

	return fFound;
}


H323VERSION GetH323Version(PCC_VENDORINFO pRemoteVendorInfo)
{
	if (NULL == pRemoteVendorInfo)
	{
		return H323_Unknown;
	}


	// make sure we are dealing with a Microsoft product
	if ((pRemoteVendorInfo->bCountryCode != USA_H221_COUNTRY_CODE) ||
	    (pRemoteVendorInfo->wManufacturerCode != MICROSOFT_H_221_MFG_CODE) ||
	    (pRemoteVendorInfo->pProductNumber == NULL) ||
		(pRemoteVendorInfo->pVersionNumber == NULL)
	   )
	{
		return H323_Unknown;
	}


	// redundant check to make sure we are a Microsoft H.323 product
	if (!ProductCheck(pRemoteVendorInfo, H323_COMPANYNAME_STR))
	{
		return H323_Unknown;
	}


	// check for NetMeeting in the string
	if (ProductCheck(pRemoteVendorInfo, H323_PRODUCTNAME_SHORT_STR))
	{
		if (VersionCheck(pRemoteVendorInfo, H323_20_PRODUCTRELEASE_STR))
		{
			return H323_NetMeeting20;
		}

		if (VersionCheck(pRemoteVendorInfo, H323_21_PRODUCTRELEASE_STR))
		{
			return H323_NetMeeting21;
		}

		if (VersionCheck(pRemoteVendorInfo, H323_21_SP1_PRODUCTRELEASE_STR))
		{
			return H323_NetMeeting21;
		}

		if (VersionCheck(pRemoteVendorInfo, H323_211_PRODUCTRELEASE_STR))
		{
			return H323_NetMeeting211;
		}

		if (VersionCheck(pRemoteVendorInfo, H323_30_PRODUCTRELEASE_STR))
		{
			return H323_NetMeeting30;
		}

		// must be future version of NetMeeting 3.1
		return H323_NetMeetingFuture;
	}

	// filter out TAPI v3.0
	// their version string is "Version 3.0"
	if (VersionCheck(pRemoteVendorInfo, H323_TAPI30_PRODUCTRELEASE_STR))
	{
		return H323_TAPI30;
	}

	// must be TAPI 3.1, or some other Microsoft product
	return H323_MicrosoftFuture;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\rostinfo.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/

//
//	File:		RostInfo.cpp
//	Created:	ChrisPi		6/17/96
//	Modified:
//
//	The CRosterInfo class is implemented, which is used for adding user
//  information to the T.120 roster
//

#include "precomp.h"
#include <RostInfo.h>

GUID g_csguidRostInfo = GUID_ROSTINFO;

static const HROSTINFO g_cshriEOList = (HROSTINFO)((LONG_PTR)-1);

CRosterInfo::~CRosterInfo()
{
	DebugEntry(CRosterInfo::~CRosterInfo);

	while (FALSE == m_ItemList.IsEmpty())
	{
		PWSTR pwszItem = (PWSTR) m_ItemList.RemoveHead();
		ASSERT(pwszItem);
		delete pwszItem;
	}
	delete m_pvSaveData;

	DebugExitVOID(CRosterInfo::~CRosterInfo);
}

HRESULT CRosterInfo::AddItem(PCWSTR pcwszTag, PCWSTR pcwszData)
{
	DebugEntry(CRosterInfo::AddItem);
	ASSERT(pcwszTag);
	ASSERT(pcwszData);
	HRESULT hr = E_OUTOFMEMORY;

	int nTagLength = lstrlenW(pcwszTag);
	int nDataLength = lstrlenW(pcwszData);

	// +1 for tag sep, +1 for rost info sep
	PWSTR pwszNewItem = new WCHAR[nTagLength + 1 + nDataLength + 1];
	if (NULL != pwszNewItem)
	{
		::CopyMemory(	(PVOID) pwszNewItem,
						pcwszTag,
						sizeof(WCHAR) * nTagLength);
		pwszNewItem[nTagLength] = g_cwchRostInfoTagSeparator;
		::CopyMemory(	(PVOID) &(pwszNewItem[nTagLength + 1]),
						pcwszData,
						sizeof(WCHAR) * nDataLength);
		pwszNewItem[nTagLength + 1 + nDataLength] = g_cwchRostInfoSeparator;
		m_ItemList.AddTail(pwszNewItem);
		hr = S_OK;
	}

	DebugExitHRESULT(CRosterInfo::AddItem, hr);
	return hr;
}

HRESULT CRosterInfo::ExtractItem(	PHROSTINFO phRostInfo,
									PCWSTR pcwszTag,
									LPTSTR pszBuffer,
									UINT cbLength)
{
	DebugEntry(CRosterInfo::ExtractItem);
	ASSERT(pcwszTag);
	HRESULT hr = E_FAIL;
	
	POSITION pos;
	if ((NULL == phRostInfo) ||
		(NULL == *phRostInfo))
	{
		pos = m_ItemList.GetHeadPosition();
	}
	else
	{
		pos = *phRostInfo;
	}

	if (g_cshriEOList != pos)
	{
		while (NULL != pos)
		{
			PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
			if (NULL != phRostInfo)
			{
				*phRostInfo = (NULL != pos) ? pos : g_cshriEOList;
			}
			ASSERT(pwszItem);
			int nItemLength = lstrlenW(pwszItem);
			int nTagLength = lstrlenW(pcwszTag);
			
			// NOTE: CRT is used for memcmp
			if ((nItemLength > nTagLength) &&
				(0 == memcmp(	pcwszTag,
								pwszItem,
								sizeof(WCHAR) * nTagLength)) &&
				(g_cwchRostInfoTagSeparator == pwszItem[nTagLength]))
			{
				// This is a match
				PWSTR pwszItemData = &(pwszItem[nTagLength + 1]);
				CUSTRING custrItemData(pwszItemData);
				LPTSTR pszItemData = custrItemData;
				if (NULL != pszBuffer)
				{
					lstrcpyn(pszBuffer, pszItemData, cbLength);
				}

				hr = S_OK;
				break;
			}
		}
	}

	DebugExitHRESULT(CRosterInfo::ExtractItem, hr);
	return hr;
}

HRESULT CRosterInfo::Load(PVOID pData)
{
	DebugEntry(CRosterInfo::Load);
	HRESULT hr = E_FAIL;

	PWSTR pwszUserInfo = (PWSTR) pData;
	if (NULL != pwszUserInfo)
	{
		hr = S_OK;
		while (L'\0' != pwszUserInfo[0])
		{
			// this includes the null terminator
			int nItemLenNT = lstrlenW(pwszUserInfo) + 1;
			PWSTR pwszNewItem = new WCHAR[nItemLenNT];
			if (NULL != pwszNewItem)
			{
				::CopyMemory(	pwszNewItem,
								pwszUserInfo,
								sizeof(WCHAR) * nItemLenNT);
				m_ItemList.AddTail(pwszNewItem);
				// Skip past this item and the n.t.
				pwszUserInfo += nItemLenNT;
			}
			else
			{
				hr = E_OUTOFMEMORY;
				break;
			}
		}
	}
	else
	{
		TRACE_OUT(("CRosterInfo::Load() called with NULL pData"));
	}

	DebugExitHRESULT(CRosterInfo::Load, hr);
	return hr;
}

UINT CRosterInfo::GetSize()
{
	UINT uSize = sizeof(WCHAR); // for last separator

	POSITION pos = m_ItemList.GetHeadPosition();
	while (NULL != pos)
	{
		PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
		ASSERT(pwszItem);
		uSize += sizeof(WCHAR) * (lstrlenW(pwszItem) + 1);
	}

	return uSize;
}

HRESULT CRosterInfo::Save(PVOID* ppvData, PUINT pcbLength)
{
	DebugEntry(CRosterInfo::Save);
	ASSERT(ppvData);
	ASSERT(pcbLength);
	HRESULT hr = E_FAIL;

	*pcbLength = GetSize();
	delete m_pvSaveData;
	m_pvSaveData = new BYTE[*pcbLength];
	if (NULL != m_pvSaveData)
	{
		PWSTR pwszDest = (PWSTR) m_pvSaveData;
		POSITION pos = m_ItemList.GetHeadPosition();
		while (NULL != pos)
		{
			PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
			ASSERT(pwszItem);
			::CopyMemory(	pwszDest,
							pwszItem,
							sizeof(WCHAR) * (lstrlenW(pwszItem) + 1));
			pwszDest += (lstrlenW(pwszItem) + 1);
		}
		int nLastSepPos = (*pcbLength / sizeof(WCHAR)) - 1;
		((PWSTR)m_pvSaveData)[nLastSepPos] = g_cwchRostInfoSeparator;
		*ppvData = m_pvSaveData;
		hr = S_OK;
	}

	DebugExitHRESULT(CRosterInfo::Save, hr);
	return hr;
}

#ifdef DEBUG
VOID CRosterInfo::Dump()
{
	POSITION pos = m_ItemList.GetHeadPosition();
	while (NULL != pos)
	{
		PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
		ASSERT(pwszItem);
		TRACE_OUT(("\t%ls", pwszItem));
	}
}
#endif // DEBUG

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\setupdd.cpp ===
// File: setupdd.cpp

// The code to install the NM display driver for Windows NT.

// TODO: NM-specific HRESULT codes 

#include "precomp.h"
#include "resource.h"

#ifdef NMDLL_HACK
inline HINSTANCE GetInstanceHandle()	{ return g_hInst; }
#endif

const TCHAR g_pcszDisplayCPLName[]       = TEXT("DESK.CPL");
const CHAR  g_pcszInstallDriverAPIName[] = "InstallGraphicsDriver";
const WCHAR g_pcwszDefaultModelName[]    = L"Microsoft NetMeeting graphics driver";
const WCHAR g_pcwszDefaultINFName[]      = L"MNMDD.INF";


// Maxmimum size of the model name string
const int NAME_BUFFER_SIZE = 128;

// Prototype for the function installed by the Display CPL
typedef DWORD (*PFNINSTALLGRAPHICSDRIVER)(
    HWND    hwnd,
    LPCWSTR pszSourceDirectory,
    LPCWSTR pszModel,
    LPCWSTR pszInf
    );



/*  C A N  I N S T A L L  N  T  D I S P L A Y  D R I V E R  */
/*-------------------------------------------------------------------------
    %%Function: CanInstallNTDisplayDriver
    
	This function determines whether the entry point for installing the
	NT display driver is availalble (i.e. NT 4.0 SP3 or later).
    
-------------------------------------------------------------------------*/
HRESULT CanInstallNTDisplayDriver(void)
{
	if (!IsWindowsNT())
	{
		return E_FAIL;
	}

	// We verify that the major version number is exactly 4 and either
	// the minor version number is greater than 0 or the service pack
	// number (which is stored in the high byte of the low word of the
	// CSD version) is 3 or greater.
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(osvi);
	if (FALSE == ::GetVersionEx(&osvi))
	{
		ERROR_OUT(("CanInstallNTDisplayDriver: GetVersionEx failed"));
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;
	if (4 == osvi.dwMajorVersion)
	{
		if (0 == osvi.dwMinorVersion)
		{
			RegEntry re(NT_WINDOWS_SYSTEM_INFO_KEY, HKEY_LOCAL_MACHINE, FALSE);
			DWORD dwCSDVersion = re.GetNumber(REGVAL_NT_CSD_VERSION, 0);
			if (3 <= HIBYTE(LOWORD(dwCSDVersion)))
			{
				// This is NT 4.0, SP 3 or later
				hr = S_OK;
			}
		}
		else
		{
			// We assume that any future version of Windows NT 4.x (x > 0)
			// will support this.
			hr = S_OK;
		}
	}

	return hr;
}


/*  I N S T A L L  A P P  S H A R I N G  D  D  */
/*-------------------------------------------------------------------------
    %%Function: InstallAppSharingDD

	This function attempts to install the NT display driver.
	If it succeeds the machine MUST BE RESTARTED before it can be used.
-------------------------------------------------------------------------*/
HRESULT InstallAppSharingDD(HWND hwnd)
{
	HRESULT  hr;
	CUSTRING custrPath;
	TCHAR    szDir[MAX_PATH];
	LPWSTR   pwszSourcePath = NULL;
	LPWSTR   pwszSourcePathEnd;
	WCHAR    pwszModelNameBuffer[NAME_BUFFER_SIZE];
	LPCWSTR  pcwszModelName;
	WCHAR    pwszINFNameBuffer[MAX_PATH];
	LPCWSTR  pcwszINFName;
	PFNINSTALLGRAPHICSDRIVER pfnInstallGraphicsDriver;


	// REVIEW: Need NM-specific HRESULTS for all of these
	if (!IsWindowsNT())
	{
		return E_FAIL;
	}

	if (!CanInstallNTDisplayDriver())
	{
		return E_FAIL;
	}

	// The driver files are located in the NM directory.
	if (!GetInstallDirectory(szDir))
	{
		ERROR_OUT(("GetInstallDirectory() fails"));
		return E_FAIL;
	}

	// Convert the install directory to Unicode, if necessary
	custrPath.AssignString(szDir);
	pwszSourcePath = custrPath;
	if (NULL == pwszSourcePath)
	{
		ERROR_OUT(("AnsiToUnicode() fails"));
		return E_FAIL;
	}

	// Strip the trailing backslash that GetInstallDirectory appends
	pwszSourcePathEnd = pwszSourcePath + lstrlenW(pwszSourcePath);
	// Handle X:\, just to be safe
	if (pwszSourcePathEnd - pwszSourcePath > 3)
	{
		ASSERT(L'\\' == *(pwszSourcePathEnd - 1));
		*--pwszSourcePathEnd = L'\0';
	}

	// Read the model name string from the resource file
	if (0 != ::LoadStringW(::GetInstanceHandle(), IDS_NMDD_DISPLAYNAME, 
				pwszModelNameBuffer, CCHMAX(pwszModelNameBuffer)))
	{
		pcwszModelName = pwszModelNameBuffer;
	}
	else
	{
		ERROR_OUT(("LoadStringW() fails, err=%lu", GetLastError()));
		pcwszModelName = g_pcwszDefaultModelName;
	}

	// Read the INF name string from the resource file
	if (0 < ::LoadStringW(::GetInstanceHandle(), 
			IDS_NMDD_INFNAME,  pwszINFNameBuffer, CCHMAX(pwszINFNameBuffer)))
	{
		pcwszINFName = pwszINFNameBuffer;
	}
	else
	{
		ERROR_OUT(("LoadStringW() fails, err=%lu", GetLastError()));
		pcwszINFName = g_pcwszDefaultINFName;
	}


	// Get the entry point for display driver installation
	HMODULE hDll = NmLoadLibrary(g_pcszDisplayCPLName,TRUE);
	if (NULL == hDll)
	{
		ERROR_OUT(("NmLoadLibrary failed on %s", g_pcszDisplayCPLName));
		return E_FAIL;
	}

	pfnInstallGraphicsDriver = (PFNINSTALLGRAPHICSDRIVER) 
				GetProcAddress(hDll, g_pcszInstallDriverAPIName);
	if (NULL == pfnInstallGraphicsDriver)
	{
		ERROR_OUT(("GetInstallDisplayDriverEntryPoint() fails"));
		hr = E_FAIL;
	}
	else
	{	// Now we're set to call the actual installation function
		DWORD dwErr = (*pfnInstallGraphicsDriver)(hwnd,
					pwszSourcePath, pcwszModelName, pcwszINFName);
		if (0 != dwErr)
		{
			ERROR_OUT(("InstallGraphicsDriver() fails, err=%lu", dwErr));
			hr = E_FAIL;
		}
		else
		{
			WARNING_OUT(("InstallGraphicsDriver() succeeded"));
			hr = S_OK;
		}
	}

	// Cleanup
	ASSERT(NULL != hDll);
	FreeLibrary(hDll);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\video.cpp ===
/****************************************************************************
*
*	 FILE:	   Videoui.cpp
*
*	 CREATED:  Mark MacLin (MMacLin) 10-17-96
*
*	 CONTENTS: CVideo object
*
****************************************************************************/
// File: VideoUI.cpp

#include "precomp.h"

#include "avdefs.h"
#include "video.h"
#include "h323.h"
#include <mperror.h>
#include <initguid.h>
#include <nacguids.h>


#define INITIAL_FRAMERATE		  700

#define DibHdrSize(lpbi)		((lpbi)->biSize + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))
#define DibDataSize(lpbi)		((lpbi)->biSizeImage)
#define DibSize(lpbi)			(DibHdrSize(lpbi) + DibDataSize(lpbi))




//
//  SortOrder() and SetVideoSize() are helper functions for reordering the video
//  based on the notion of a "small", "medium", or "large" user preference that is
//  exposed by a property setting in INmChannelVideo::Setproperty. This
//  notion is flawed because there may be more or less than three sizes.
//  We should expose the possible sizes and let the application choose
//  a format.  Unil then, this hack has to be here.  The code for these two functions
//  was originally in vidstrm.cpp (in NAC.DLL)
//

//
// types & globals used by SortOrder() and SetVideoSize()
//

// Used to translate between frame sizes and the FRAME_* bit flags
#define NON_STANDARD    0x80000000
#define SIZE_TO_FLAG(s) (s == Small  ? FRAME_SQCIF : s == Medium ? FRAME_QCIF: s == Large ? FRAME_CIF : NON_STANDARD)

// FORMATORDER: structure used in ::SetVideoSize to
// use predefined frame size orders for different set size requests
typedef struct _FORMATORDER
{
    WORD indexCIF;
    WORD indexQCIF;
    WORD indexSQCIF;
} FORMATORDER;

// Table of sizes in order
const FORMATORDER g_fmtOrderTable[3] =
{
    { 0, 1, 2 }, // requestor asked for CIF
    { 2, 0, 1 }, // requestor asked for QCIF
    { 2, 1, 0 }  // requestor asked for SQCIF
};

//  SortOrder
//      Helper function to search for the specific format type and set its sort
//      order to the desired number
//  THIS WAS MOVED HERE FROM vidstrm.cpp
//
BOOL
SortOrder(
	IAppVidCap *pavc,
    BASIC_VIDCAP_INFO* pvidcaps,
    DWORD dwcFormats,
    DWORD dwFlags,
    WORD wDesiredSortOrder,
	int nNumFormats
    )
{
    int i, j;
	int nNumSizes = 0;
	int *aFrameSizes = (int *)NULL;
	int *aMinFrameSizes = (int *)NULL;
	int iMaxPos;
	WORD wTempPos, wMaxSortIndex;

	// Scale sort value
	wDesiredSortOrder *= (WORD)nNumFormats;

	// Local buffer of sizes that match dwFlags
    if (!(aFrameSizes = (int *)LocalAlloc(LPTR,nNumFormats * sizeof (int))))
        goto out;

    // Look through all the formats until we find the ones we want
	// Save the position of these entries
    for (i=0; i<(int)dwcFormats; i++)
        if (SIZE_TO_FLAG(pvidcaps[i].enumVideoSize) == dwFlags)
			aFrameSizes[nNumSizes++] = i;

	// Now order those entries from highest to lowest sort index
	for (i=0; i<nNumSizes; i++)
	{
		for (iMaxPos = -1L, wMaxSortIndex=0UL, j=i; j<nNumSizes; j++)
		{
			if (pvidcaps[aFrameSizes[j]].wSortIndex > wMaxSortIndex)
			{
				wMaxSortIndex = pvidcaps[aFrameSizes[j]].wSortIndex;
				iMaxPos = j;
			}
		}
		if (iMaxPos != -1L)
		{
			wTempPos = (WORD)aFrameSizes[i];
			aFrameSizes[i] = aFrameSizes[iMaxPos];
			aFrameSizes[iMaxPos] = wTempPos;
		}
	}

	// Change the sort index of the sorted entries
	for (; nNumSizes--;)
		pvidcaps[aFrameSizes[nNumSizes]].wSortIndex = wDesiredSortOrder++;

	// Release memory
	LocalFree(aFrameSizes);

	return TRUE;

out:
	return FALSE;
}



//  ::SetVideoSize
//
//  THIS WAS MOVED HERE FROM vidstrm.cpp

HRESULT
SetVideoSize(
	IH323CallControl *pH323CallControl,
    DWORD dwSizeFlags
    )
{
    IAppVidCap* pavc;
    DWORD dwcFormats;
    DWORD dwcFormatsReturned;
    BASIC_VIDCAP_INFO* pvidcaps = NULL;
    BASIC_VIDCAP_INFO* pmin;
	DWORD *pvfx = NULL;
    DWORD i, j;
	int k;
    HRESULT hr = S_OK;
	int nNumFormatTags;

    // Validate parameters
    if (dwSizeFlags != FRAME_CIF && dwSizeFlags != FRAME_QCIF && dwSizeFlags != FRAME_SQCIF)
        return S_FALSE;;

    // Prepare for error
    hr = S_FALSE;

    // Get a vid cap interface
    if (pH323CallControl->QueryInterface(IID_IAppVidCap, (void **)&pavc) != S_OK)
        goto out;

    // Get the number of BASIC_VIDCAP_INFO structures available
    if (pavc->GetNumFormats((UINT*)&dwcFormats) != S_OK)
        goto out;

    // Allocate some memory to hold the list in
    if (!(pvidcaps = (BASIC_VIDCAP_INFO*)LocalAlloc(LPTR,dwcFormats * sizeof (BASIC_VIDCAP_INFO))))
        goto out;

    // Get the list
    if (pavc->EnumFormats(pvidcaps, dwcFormats * sizeof (BASIC_VIDCAP_INFO),
        (UINT*)&dwcFormatsReturned) != S_OK)
        goto out;

    // Use the preformatted list of choice here
    switch (dwSizeFlags)
    {
    default:
    case FRAME_CIF:     i = 0; break;
    case FRAME_QCIF:    i = 1; break;
    case FRAME_SQCIF:   i = 2; break;
    }

	// Get the number of different format tags
    if (!(pvfx = (DWORD*)LocalAlloc(LPTR,dwcFormatsReturned * sizeof (DWORD))))
        goto out;
	ZeroMemory(pvfx,dwcFormatsReturned * sizeof (DWORD));

	if (dwcFormatsReturned)
	{
		for (nNumFormatTags = 1, pvfx[0] = pvidcaps[0].dwFormatTag, j=1; j<dwcFormatsReturned; j++)
		{
			for (k=0; k<nNumFormatTags; k++)
				if (pvidcaps[j].dwFormatTag == pvfx[k])
					break;

			if (k==nNumFormatTags)
				pvfx[nNumFormatTags++] = pvidcaps[j].dwFormatTag;
			
		}
	}

    // Set the sort order for the desired item
    if (!SortOrder(pavc, pvidcaps, dwcFormatsReturned, FRAME_CIF, g_fmtOrderTable[i].indexCIF, nNumFormatTags) ||
        !SortOrder(pavc, pvidcaps, dwcFormatsReturned, FRAME_QCIF, g_fmtOrderTable[i].indexQCIF, nNumFormatTags) ||
        !SortOrder(pavc, pvidcaps, dwcFormatsReturned, FRAME_SQCIF, g_fmtOrderTable[i].indexSQCIF, nNumFormatTags))
	{
        goto out;
	}

	// Always pack indices
	for (i=0; i<dwcFormatsReturned; i++)
	{
		// First find an entry with a sort index larger or equal to i
		for (j=0; j<dwcFormatsReturned; j++)
		{
			// if ((pvidcaps[j].wSortIndex >= i) || (!i && (pvidcaps[j].wSortIndex == 0)))
			if (pvidcaps[j].wSortIndex >= i)
			{
				pmin = &pvidcaps[j];
				break;
			}
		}
		// First the smallest entry larger or equal to i
		for (; j<dwcFormatsReturned; j++)
		{
			if ((pvidcaps[j].wSortIndex < pmin->wSortIndex) && (pvidcaps[j].wSortIndex >= i))
				pmin = &pvidcaps[j];
		}
		// Update sort index
		pmin->wSortIndex = (WORD)i;
	}

    // Ok, now submit this list
    if (pavc->ApplyAppFormatPrefs(pvidcaps, dwcFormats) != S_OK)
	{
        goto out;
	}


	hr = S_OK;

out:
    // Free the memory, we're done
    if (pvidcaps)
        LocalFree(pvidcaps);
    if (pvfx)
        LocalFree(pvfx);

	// let the interface go
	if (pavc)
		pavc->Release();

	return hr;
}


CVideoPump::CVideoPump(BOOL fLocal) :
	m_fPaused(FALSE),
	m_dwUser(0),
	m_pfnCallback(NULL),
	m_dwLastFrameRate(0),
	m_fLocal(fLocal),
	m_fChannelOpen(FALSE),
	m_pImage(NULL),
	m_pVideoRender(NULL),
	m_BestFormat(INVALID_MEDIA_FORMAT),
	m_NewFormat(INVALID_MEDIA_FORMAT),
	m_fOpenPending(FALSE),
	m_fReopenPending(FALSE),
	m_fClosePending(FALSE)
{
}

CVideoPump::~CVideoPump()
{
	if (NULL != m_pVideoRender)
	{
		m_pVideoRender->Done();
		m_pVideoRender->Release();
	}
	ReleaseImage();
	if (NULL != m_pIVideoDevice)
	{
		m_pIVideoDevice->Release();
	}
	if (NULL != m_pMediaStream)
	{
		m_pMediaStream->Release();
	}

	if (NULL != m_pPreviewChannel)
	{
		m_pPreviewChannel->Release();
	}
	if (NULL != m_pCommChannel)
	{
		m_pCommChannel->Release();
	}
}

BOOL CVideoPump::ChanInitialize(ICommChannel* pCommChannel)
{
	HRESULT hr;
	BOOL bRet = TRUE;
	if(m_pPreviewChannel && m_pPreviewChannel == pCommChannel)
	{
		ASSERT(m_pVideoRender && m_pCommChannel == pCommChannel);
		//m_pCommChannel = pCommChannel;
	}
	else
	{
		m_pCommChannel = pCommChannel;
		m_pCommChannel->AddRef();
	}
	
	return bRet;
}

BOOL CVideoPump::Initialize(IH323CallControl *pH323CallControl, IMediaChannel *pMC,
                            IVideoDevice *pVideoDevice,	DWORD_PTR dwUser, LPFNFRAMEREADY pfnCallback)
{
	HRESULT hr;

	m_dwUser = dwUser;
	m_pfnCallback = pfnCallback;

	m_pMediaStream = pMC;
	m_pMediaStream->AddRef();
	
	if(m_fLocal)
	{
		GUID mediaID = MEDIA_TYPE_H323VIDEO;

		hr = pH323CallControl->CreateLocalCommChannel(&m_pPreviewChannel, &mediaID, m_pMediaStream);
		if(FAILED(hr))
		{
			ASSERT(0);
			return FALSE;
		}

		m_pCommChannel = m_pPreviewChannel;
		m_pCommChannel->AddRef();

	}

	hr = m_pMediaStream->QueryInterface(IID_IVideoRender, (void **)&m_pVideoRender);
	if(FAILED(hr))
	{
		ASSERT(0);
		return FALSE;
	}
	
	hr = m_pVideoRender->Init(m_dwUser, m_pfnCallback);
	if(FAILED(hr))
	{
		ASSERT(0);
		m_pVideoRender->Release();
		m_pVideoRender = NULL;
		return FALSE;
	}	


	ASSERT(pVideoDevice);
	m_pIVideoDevice = pVideoDevice;
	m_pIVideoDevice->AddRef();

	
	m_fChannelOpen = FALSE;
	m_dwLastFrameRate = INITIAL_FRAMERATE;
	
	m_fPaused = TRUE;
	EnableXfer(FALSE);	// need to store state locally, set it in OnChannelOpen

	return TRUE;
}

HRESULT CVideoPump::GetFrame(FRAMECONTEXT *pFrameContext)
{
	HRESULT hr;
	
	// if we are paused m_pImage will be a pointer to the saved DIB
	if (NULL != m_pImage)
	{
		*pFrameContext = m_FrameContext;
		hr = S_OK;
	}
	else
	{
		if(m_pVideoRender)
		{
			hr = m_pVideoRender->GetFrame(pFrameContext);
		}
		else
		{
			hr = S_FALSE;
		}

		if (S_OK == hr)
		{
			// data pump may be sending a bogus lpClipRect, so ...
			
			// if lpClipRect is NULL, calculate rect from bmiHeader
			if (NULL == pFrameContext->lpClipRect) {
				// calculate clip rect from BITMAPINFOHEADER
				m_ClipRect.left = m_ClipRect.top = 0;
				m_ClipRect.right = pFrameContext->lpbmi->bmiHeader.biWidth;
				m_ClipRect.bottom = pFrameContext->lpbmi->bmiHeader.biHeight;
				pFrameContext->lpClipRect = &m_ClipRect;
			}
		}
	}
	return hr;
}

HRESULT CVideoPump::ReleaseFrame(FRAMECONTEXT *pFrameContext)
{
	// release the frame if it is not the saved DIB
	if ((m_pImage != (LPBYTE)pFrameContext->lpbmi) && m_pVideoRender)
	{
		// if lpClipRect was NULL (see GetFrame), restore it
		if (&m_ClipRect == pFrameContext->lpClipRect)
		{
			pFrameContext->lpClipRect = NULL;
		}
		return m_pVideoRender->ReleaseFrame(pFrameContext);
	}
	return S_OK;
}

VOID CVideoPump::SnapImage ()
{
	FRAMECONTEXT FrameContext;
	
	if ((NULL == m_pImage) && m_pVideoRender)
	{
		if (S_OK == m_pVideoRender->GetFrame(&FrameContext))
		{
			BITMAPINFOHEADER *pbmih;
			
			pbmih = &FrameContext.lpbmi->bmiHeader;
			m_pImage = (LPBYTE)LocalAlloc(LPTR, DibSize(pbmih));
			if (NULL != m_pImage)
			{
				int nHdrSize = DibHdrSize(pbmih);

				CopyMemory(m_pImage, pbmih, nHdrSize);
				CopyMemory(m_pImage + nHdrSize, FrameContext.lpData, DibDataSize(pbmih));

				m_FrameContext.lpbmi = (LPBITMAPINFO)m_pImage;
				m_FrameContext.lpData = (LPBYTE)m_pImage + nHdrSize;
				if (NULL != FrameContext.lpClipRect)
				{
					m_ClipRect = *FrameContext.lpClipRect;
				}
				else
				{
					m_ClipRect.left = m_ClipRect.top = 0;
					m_ClipRect.right = m_FrameContext.lpbmi->bmiHeader.biWidth;
					m_ClipRect.bottom = m_FrameContext.lpbmi->bmiHeader.biHeight;
				}
				m_FrameContext.lpClipRect = &m_ClipRect;
			}
			m_pVideoRender->ReleaseFrame(&FrameContext);
		}
	}
}

VOID CVideoPump::ReleaseImage ()
{
	if (NULL != m_pImage)
	{
		LocalFree(m_pImage);
		m_pImage = NULL;
	}
}

VOID CVideoPump::Pause(BOOL fPause)
{
	m_fPaused = fPause;
	
	// ideally we would like the data pump to hold onto the last frame
	// so that we don't have to do this
	if (m_fPaused)
	{
		if (m_fChannelOpen)
		{
			SnapImage();
		}
		EnableXfer(FALSE);
	}
	else
	{
		EnableXfer(TRUE);
		ReleaseImage();
	}
}

BOOL CVideoPump::IsXferEnabled()
{
	if (m_fLocal)
	{
		return IsSendEnabled();
	}
	return IsReceiveEnabled();
}

VOID CVideoPump::Open(MEDIA_FORMAT_ID format_id)
{
	if(!m_pCommChannel)
	{
		return;
	}
	
	m_pCommChannel->PauseNetworkStream(FALSE);
	m_pCommChannel->EnableOpen(TRUE);

	if (m_fLocal)
	{
		HRESULT hr;
		// if the channel is not open and a call is in progress, now is the time
		if(m_pConnection && m_pCommChannel)
		{
			// a call is in progress
			if(!IsChannelOpen()
				&& !m_fOpenPending)
			{
				// so, the channel is not open

				if(format_id != INVALID_MEDIA_FORMAT)
				{
					// try to open a channel using specified format
					m_fOpenPending = TRUE;	// do this first (callbacks!)
					hr = m_pCommChannel->Open(format_id, m_pConnection);
					if(FAILED(hr))
						m_fOpenPending = FALSE;
				}

			}
			else if (m_fClosePending)
			{
				m_NewFormat = format_id;
				if(format_id != INVALID_MEDIA_FORMAT)
				{
					m_fClosePending = FALSE;
					m_fReopenPending = TRUE;
					hr = m_pCommChannel->Close();
				}
			}
		}
	}
}
VOID CVideoPump::Close()
{
	HRESULT hr;
	hr = m_pCommChannel->Close();
	// what to do about an error?
}

VOID CVideoPump::EnableXfer(BOOL fEnable)
{
	if (m_fLocal)
	{
		if (fEnable)
		{
			HRESULT hr;
			SetFrameRate(m_dwLastFrameRate);

			EnablePreview(TRUE);
			EnableSend(TRUE);

			// if the channel is not open and a call is in progress, now is the time
			if(m_pConnection && m_pCommChannel)
			{
				// a call is in progress
				if(!IsChannelOpen()
					&& !m_fOpenPending)
				{
					// so, the channel is not open
					m_BestFormat = m_NewFormat = CVideoProp::GetBestFormat();
					if(m_BestFormat != INVALID_MEDIA_FORMAT)
					{
						// try to open a channel using format m_BestFormat
						m_fOpenPending = TRUE;	// do this first (callbacks!)
						hr = m_pCommChannel->Open(m_BestFormat, m_pConnection);
						if(FAILED(hr))
							m_fOpenPending = FALSE;
					}
					// else no common video formats exist and a channel cannot
					// be opened.
				}
				else if (m_fClosePending)
				{
					m_BestFormat = m_NewFormat = CVideoProp::GetBestFormat();
					if(m_BestFormat != INVALID_MEDIA_FORMAT)
					{
						m_fClosePending = FALSE;
						m_fReopenPending = TRUE;
						hr = m_pCommChannel->Close();
					}
				}
			}

		}
		else
		{
			if (IsSendEnabled())
			{
				m_dwLastFrameRate = GetFrameRate();
			}

			EnablePreview(FALSE);
			EnableSend(FALSE);
		}
	}
	else
	{
		EnableReceive(fEnable);
	}
	
}

VOID CVideoPump::SetFrameSize(DWORD dwValue)
{
	CVideoProp::SetFrameSize(dwValue);
	
	ForceCaptureChange();
}

VOID CVideoPump::OnConnected(IH323Endpoint * lpConnection, ICommChannel *pIChannel)
{
	m_pConnection = lpConnection;
	m_fOpenPending = m_fReopenPending = m_fClosePending = FALSE;
}

VOID CVideoPump::OnChannelOpened(ICommChannel *pIChannel)
{
	HRESULT hr;
	m_fChannelOpen = TRUE;
	m_fOpenPending = FALSE;
	ChanInitialize(pIChannel);
	ASSERT(m_pMediaStream);
		
	if (m_fLocal)
	{
		m_fSend = TRUE;
		EnableXfer(TRUE);

		// if video size changed while waiting for the channel to be opened,
		// then need to close again, then reopen again using the new format
		if(m_BestFormat != m_NewFormat)
		{
			ForceCaptureChange();
		}
		else // make sure to track the video size
		{
			GetFrameSize();
		}
	}
	else
	{
		EnableXfer(m_fReceive);
		SetReceiveQuality(m_dwImageQuality);
	}
	ReleaseImage();
}

VOID CVideoPump::OnChannelError()
{
	m_fOpenPending = FALSE;
}

NM_VIDEO_STATE CVideoPump::GetState()
{
	NM_VIDEO_STATE state = NM_VIDEO_IDLE;

	if (IsChannelOpen())
	{
		if (IsXferEnabled())
		{
			if (IsRemotePaused())
			{
				state  = NM_VIDEO_REMOTE_PAUSED;
			}
			else
			{
				state  = NM_VIDEO_TRANSFERRING;
			}
		}
		else
		{
			if (IsRemotePaused())
			{
				state  = NM_VIDEO_BOTH_PAUSED;
			}
			else
			{
				state  = NM_VIDEO_LOCAL_PAUSED;
			}
		}
	}
	else
	{
		if (IsXferEnabled())
		{
			state = NM_VIDEO_PREVIEWING;
		}
	}
	return state;
}

VOID CVideoPump::OnChannelClosed()
{
	m_fChannelOpen = FALSE;
	HRESULT hr;
	if(m_pPreviewChannel)
	{
		if(m_fReopenPending)
		{
			m_fReopenPending = FALSE;
			if(m_BestFormat != INVALID_MEDIA_FORMAT )
			{
				m_fOpenPending = TRUE;
				hr = m_pCommChannel->Open(m_BestFormat, m_pConnection);
				if(FAILED(hr))
					m_fOpenPending = FALSE;
			}
		}
		else if(CVideoProp::IsPreviewEnabled())
		{
			EnablePreview(TRUE);
		}
	}
	else
	{
		if(m_pCommChannel)
		{
			m_pCommChannel->Release();
			m_pCommChannel = NULL;	
		}
	}
}

VOID CVideoPump::OnDisconnected()
{
	m_pConnection = NULL;

	if(m_dwFrameSize != m_dwPreferredFrameSize)
	{
		SetFrameSize(m_dwPreferredFrameSize);
	}
			
	if (!IsLocal())
	{
		EnableXfer(FALSE);
	}

	ReleaseImage();
}


CVideoProp::CVideoProp() :
	m_pCommChannel(NULL),
	m_pPreviewChannel(NULL),
	m_pConnection(NULL),
	m_pMediaStream(NULL),
	m_pIVideoDevice(NULL)
{
}

VOID CVideoProp::EnableSend(BOOL fEnable)
{
	m_fSend = fEnable;
	BOOL bPause = (fEnable)? FALSE :TRUE;
	ASSERT(m_pCommChannel);
	m_pCommChannel->PauseNetworkStream(bPause);
	m_pCommChannel->EnableOpen(fEnable);

}

BOOL CVideoProp::IsSendEnabled()
{
	return m_fSend;
}

VOID CVideoProp::EnableReceive(BOOL fEnable)
{
	m_fReceive = fEnable;
	BOOL fPause = !fEnable;

	if(m_pCommChannel)
	{
		m_pCommChannel->PauseNetworkStream(fPause);
	}
}

BOOL CVideoProp::IsReceiveEnabled()
{
	return m_fReceive;
}

VOID CVideoProp::EnablePreview(BOOL fEnable)
{
	m_fPreview = fEnable;
	MEDIA_FORMAT_ID FormatID;
	if(m_pCommChannel)
	{
		if(m_fPreview)
		{
			// get format to preview, then do it
			FormatID = GetBestFormat();
			if(FormatID != INVALID_MEDIA_FORMAT)
			{
				m_pCommChannel->Preview(FormatID, m_pMediaStream);
			}
		}
		else
		{
				m_pCommChannel->Preview(INVALID_MEDIA_FORMAT, NULL);
		}
	}
}

BOOL CVideoProp::IsPreviewEnabled()
{
	return m_fPreview;
}

BOOL CVideoProp::IsRemotePaused()
{

	if(m_pCommChannel)
		return m_pCommChannel->IsRemotePaused();
	else
		return FALSE;
}

VOID CVideoProp::SetFrameRate(DWORD dwValue)
{
	m_dwFrameRate = dwValue;

	ASSERT(m_pMediaStream);
	m_pMediaStream->SetProperty(
		PROP_VIDEO_FRAME_RATE,
		&dwValue,
		sizeof(dwValue));
}

DWORD CVideoProp::GetFrameRate()
{
	DWORD dwValue;
	UINT uSize = sizeof(dwValue);

	ASSERT(m_pMediaStream);
	m_pMediaStream->GetProperty(
		PROP_VIDEO_FRAME_RATE,
		&dwValue,
		&uSize);

	TRACE_OUT(("GetFrameRate returns %d", dwValue));
	return dwValue;
}


MEDIA_FORMAT_ID CVideoProp::GetBestFormat()
{
	IAppVidCap* pavc = NULL;
	UINT cFormats;
	BASIC_VIDCAP_INFO* pvidcaps = NULL;

	MEDIA_FORMAT_ID FormatID = INVALID_MEDIA_FORMAT;
  	// Get a vid cap interface.  If in a call, use the best common format
	//
	if(!m_pConnection)
	{
		// not in a call - use the best local format period
		if(!m_pCommChannel)
			goto out;
		if (m_pCommChannel->QueryInterface(IID_IAppVidCap, (void **)&pavc) != S_OK)
			goto out;
		// Get the number of BASIC_VIDCAP_INFO structures available
		if (pavc->GetNumFormats(&cFormats) != S_OK)
			goto out;

		if(cFormats < 1)
			goto out;
			
		// Allocate some memory to hold the list in
		if (!(pvidcaps = (BASIC_VIDCAP_INFO*)LocalAlloc(LPTR, cFormats * sizeof (BASIC_VIDCAP_INFO))))
			goto out;

		// Get the list of local capabilities
		// (by the way, this is never called for receive video)
		if (pavc->EnumFormats(pvidcaps, cFormats * sizeof (BASIC_VIDCAP_INFO),
			&cFormats) != S_OK)
			goto out;

		// the output of EnumCommonFormats is in preferred order
		FormatID = pvidcaps[0].Id;
	}
	else
	{
		if (m_pConnection->QueryInterface(IID_IAppVidCap, (void **)&pavc) != S_OK)
			goto out;

		// Get the number of BASIC_VIDCAP_INFO structures available
		if (pavc->GetNumFormats(&cFormats) != S_OK)
			goto out;

		if(cFormats < 1)
			goto out;
			
		// Allocate some memory to hold the list in
		if (!(pvidcaps = (BASIC_VIDCAP_INFO*)LocalAlloc(LPTR, cFormats * sizeof (BASIC_VIDCAP_INFO))))
			goto out;

		// Get the list of viable transmit capabilities
		// (by the way, this is never called for receive video)
		if (pavc->EnumCommonFormats(pvidcaps, cFormats * sizeof (BASIC_VIDCAP_INFO),
			&cFormats, TRUE) != S_OK)
			goto out;

		// the output of EnumCommonFormats is in preferred order
		FormatID = pvidcaps[0].Id;

	}
	
out:
	// Free the memory, we're done
	if (pvidcaps)
		LocalFree(pvidcaps);

	// let the interface go
	if (pavc)
		pavc->Release();

	return FormatID;
}



VOID CVideoProp::SetFrameSize(DWORD dwValue)
{
	IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();
	m_dwFrameSize = m_dwPreferredFrameSize = dwValue;
	::SetVideoSize(pH323CallControl, m_dwFrameSize);
}

DWORD CVideoProp::GetFrameSize()
{
	MEDIA_FORMAT_ID idCurrent;
	if(m_pCommChannel)
	{
		idCurrent = m_pCommChannel->GetConfiguredFormatID();
		m_dwFrameSize = GetFrameSizes(idCurrent);
	}
	return m_dwFrameSize;
}

DWORD CVideoProp::GetFrameSizes(MEDIA_FORMAT_ID idSpecificFormat)
{
	DWORD dwValue =  0; //FRAME_SQCIF | FRAME_QCIF | FRAME_CIF;
	HRESULT hr;
	BOOL bOpen = FALSE;
	ASSERT(m_pCommChannel);
	// Used to translate between frame sizes and the FRAME_* bit flags
	#define NON_STANDARD    0x80000000
	#define SIZE_TO_FLAG(s) (s == Small  ? FRAME_SQCIF : s == Medium ? FRAME_QCIF: s == Large ? FRAME_CIF : NON_STANDARD)

    IAppVidCap* pavc = NULL;
    DWORD dwcFormats;
    DWORD dwcFormatsReturned;
    BASIC_VIDCAP_INFO* pvidcaps = NULL;
    DWORD i;
    DWORD dwSizes = 0;
    DWORD dwThisSize;

   // Get a vid cap interface
    hr = m_pCommChannel->QueryInterface(IID_IAppVidCap, (void **)&pavc);
    if (hr != S_OK)
    	goto out;

	   // Get the number of BASIC_VIDCAP_INFO structures available
    hr = pavc->GetNumFormats((UINT*)&dwcFormats);
    if (hr != S_OK)
    	goto out;

    // Allocate some memory to hold the list in
    if (!(pvidcaps = (BASIC_VIDCAP_INFO*)LocalAlloc(LPTR, dwcFormats * sizeof (BASIC_VIDCAP_INFO))))
    {
    	// report that no sizes are available?
    	// dwValue =  0FRAME_SQCIF | FRAME_QCIF | FRAME_CIF;
        goto out;
	}
	// if an active session, use common caps from that session
	hr = m_pCommChannel->IsChannelOpen(&bOpen);
	// if hr is an error, so what. it will take the channel not open path
	if(bOpen)
	{
	    // Get the list of common formats
	    hr = pavc->EnumCommonFormats(pvidcaps, dwcFormats * sizeof (BASIC_VIDCAP_INFO),
	        (UINT*)&dwcFormatsReturned, m_fSend);
		if(hr != S_OK)
		{
	    	// if the error is simply because there are no remote video caps, get the local formats
			if(hr == CAPS_E_NOCAPS)
			{
	    		hr = pavc->EnumFormats(pvidcaps, dwcFormats * sizeof (BASIC_VIDCAP_INFO),
	        		(UINT*)&dwcFormatsReturned);
				if (hr != S_OK)
        			goto out;
			}
			else
				goto out;
	    }
	}
	else
	{
		hr = pavc->EnumFormats(pvidcaps, dwcFormats * sizeof (BASIC_VIDCAP_INFO),
       		(UINT*)&dwcFormatsReturned);
		if (hr != S_OK)
   			goto out;
	}
	if(bOpen && (idSpecificFormat != INVALID_MEDIA_FORMAT ))
	{
	 // Now walk through the list to see what sizes are supported
	    for (i = 0 ; i < dwcFormatsReturned ; i++)
	    {
	    	if(pvidcaps[i].Id == idSpecificFormat)
	    	{
				dwThisSize = SIZE_TO_FLAG(pvidcaps[i].enumVideoSize);
			    // As long as the macro found the size, return it to the property requester
	        	if (dwThisSize != NON_STANDARD)
	        	{
	        	   	dwSizes |= dwThisSize;
	        	}
			    break;
	    	}
	    }
	}
	else
	{
	    // Now walk through the list to see what sizes are supported
	    for (i = 0 ; i < dwcFormatsReturned ; i++)
	    {
	    	if(m_fSend)
	    	{
				if(!pvidcaps[i].bSendEnabled)
					continue;
	    	}
	    	else
	    	{
				if(!pvidcaps[i].bRecvEnabled)
					continue;
	    	}
	        // Convert to bit field sizes or NON_STANDARD
	        dwThisSize = SIZE_TO_FLAG(pvidcaps[i].enumVideoSize);

	        // As long as the macro found the size, return it to the property requester
	        if (dwThisSize != NON_STANDARD)
	            dwSizes |= dwThisSize;
	    }
	}
    // Now that we've accumulated all the sizes, return them
    dwValue = dwSizes;

out:
    // Free the memory, we're done
    if (pvidcaps)
        LocalFree(pvidcaps);
	// let the interface go
	if (pavc)
		pavc->Release();
	return dwValue;
}

BOOL CVideoProp::HasSourceDialog()
{
	HRESULT hr;
	IVideoChannel *pVideoChannel=NULL;
	DWORD dwFlags;

	ASSERT(m_pMediaStream);
	hr = m_pMediaStream->QueryInterface(IID_IVideoChannel, (void**)&pVideoChannel);
	ASSERT(pVideoChannel);

	if (FAILED(hr))
	{
		return FALSE;
	}

	pVideoChannel->GetDeviceDialog(&dwFlags);
	pVideoChannel->Release();

	return dwFlags & CAPTURE_DIALOG_SOURCE;
}

BOOL CVideoProp::HasFormatDialog()
{
	HRESULT hr;
	IVideoChannel *pVideoChannel=NULL;
	DWORD dwFlags;

	ASSERT(m_pMediaStream);
	hr = m_pMediaStream->QueryInterface(IID_IVideoChannel, (void**)&pVideoChannel);
	ASSERT(pVideoChannel);

	if (FAILED(hr))
	{
		return FALSE;
	}

	pVideoChannel->GetDeviceDialog(&dwFlags);
	pVideoChannel->Release();

	return dwFlags & CAPTURE_DIALOG_FORMAT;
}

VOID CVideoProp::ShowSourceDialog()
{
	DWORD dwFlags = CAPTURE_DIALOG_SOURCE;
	HRESULT hr;
	IVideoChannel *pVideoChannel=NULL;

	ASSERT(m_pMediaStream);

	hr = m_pMediaStream->QueryInterface(IID_IVideoChannel, (void**)&pVideoChannel);
	ASSERT(pVideoChannel);

	if (SUCCEEDED(hr))
	{

		pVideoChannel->ShowDeviceDialog(dwFlags);
		pVideoChannel->Release();
	}
}

VOID CVideoProp::ShowFormatDialog()
{
	DWORD dwFlags = CAPTURE_DIALOG_FORMAT;
	HRESULT hr;
	IVideoChannel *pVideoChannel=NULL;

	ASSERT(m_pMediaStream);

	hr = m_pMediaStream->QueryInterface(IID_IVideoChannel, (void**)&pVideoChannel);
	ASSERT(pVideoChannel);

	if (SUCCEEDED(hr))
	{

		pVideoChannel->ShowDeviceDialog(dwFlags);
		pVideoChannel->Release();
	}
}

VOID CVideoProp::SetReceiveQuality(DWORD dwValue)
{
	m_dwImageQuality = dwValue;
	if(m_pCommChannel)
	{
		dwValue = MAX_VIDEO_QUALITY - dwValue;
		m_pCommChannel->SetProperty(
			PROP_TS_TRADEOFF,
			&dwValue,
			sizeof(dwValue));
	}
}

DWORD CVideoProp::GetReceiveQuality()
{
	return m_dwImageQuality;
}

BOOL CVideoProp::IsCaptureAvailable()
{
	ULONG uNumCapDevs;

	ASSERT(m_pIVideoDevice);

	uNumCapDevs = m_pIVideoDevice->GetNumCapDev();
	
	return (uNumCapDevs > 0);
}

BOOL CVideoProp::IsCaptureSuspended()
{
	BOOL fStandby;
	UINT uSize = sizeof(fStandby);

	ASSERT(m_pCommChannel);
	m_pCommChannel->GetProperty(
		PROP_VIDEO_PREVIEW_STANDBY,
		&fStandby,
		&uSize);
	
	return fStandby;
}


VOID CVideoProp::SuspendCapture(BOOL fSuspend)
{
	ASSERT(m_pCommChannel);
	if (fSuspend)
	{
		// Enable standby
		m_pCommChannel->SetProperty(
			PROP_VIDEO_PREVIEW_STANDBY,
			&fSuspend,
			sizeof(fSuspend));
			
		m_pCommChannel->Preview(INVALID_MEDIA_FORMAT, NULL);
	}
	else
	{
		if(m_fPreview)
		{
			// get format to preview, then do it
			MEDIA_FORMAT_ID FormatID = GetBestFormat();
			if(FormatID != INVALID_MEDIA_FORMAT)
			{
				m_pCommChannel->Preview(FormatID, m_pMediaStream);
			}
			// Disable standby
			m_pCommChannel->SetProperty(
				PROP_VIDEO_PREVIEW_STANDBY,
				&fSuspend,
				sizeof(fSuspend));
		}
		else
		{
			m_pCommChannel->Preview(INVALID_MEDIA_FORMAT, NULL);
		}
	}
}


// Gets the number of enabled capture devices
// Returns -1L on error
int CVideoProp::GetNumCapDev()
{
	ASSERT(m_pIVideoDevice);
	return (m_pIVideoDevice->GetNumCapDev());
}

// Gets the max size of the captuire device name
// Returns -1L on error
int CVideoProp::GetMaxCapDevNameLen()
{
	ASSERT(m_pIVideoDevice);
	return (m_pIVideoDevice->GetMaxCapDevNameLen());
}

// Enum list of enabled capture devices
// Fills up 1st buffer with device IDs, 2nd buffer with device names
// Third parameter is the number of devices to enum
// Returns -1L on error
BOOL CVideoProp::EnumCapDev(DWORD *pdwCapDevIDs, TCHAR *pszCapDevNames, DWORD dwNumCapDev)
{
	ASSERT(m_pIVideoDevice);
	return (S_OK != m_pIVideoDevice->EnumCapDev(pdwCapDevIDs, pszCapDevNames, dwNumCapDev));
}

// Returns the ID of the currently selected device
// Returns -1L on error
int CVideoProp::GetCurrCapDevID()
{
	ASSERT(m_pIVideoDevice);
	return (m_pIVideoDevice->GetCurrCapDevID());
}

// Selects the current capture device
// Returns -1L on error
BOOL CVideoProp::SetCurrCapDevID(int nCapDevID)
{
	ASSERT(m_pIVideoDevice);
	return (S_OK != m_pIVideoDevice->SetCurrCapDevID(nCapDevID));
}

// Selects the current capture device
// Returns -1L on error
BOOL CVideoPump::SetCurrCapDevID(int nCapDevID)
{
    if (nCapDevID == -1)
    {
        WARNING_OUT(("CVideoPump::SetCurrCapDevID called with %d", nCapDevID));

        // This will release the capture device  for Exchange RTC video stuff
        if (m_pMediaStream)
        {
            m_pMediaStream->Configure(NULL, 0, NULL, 0, NULL);
        }

        return TRUE;
    }
    else
    {
    	HRESULT hr;
	    IDualPubCap *pCapability = NULL;
    	LPAPPVIDCAPPIF pVidCap = NULL;
	    IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();

    	// change the capture device
	    CVideoProp::SetCurrCapDevID(nCapDevID);

    	// reinitialize local capability data
        hr = pH323CallControl->QueryInterface(IID_IDualPubCap, (void **)&pCapability);
    	if(FAILED(hr))
	    	goto out;
		
    	ASSERT(pCapability);
        hr = pCapability->QueryInterface(IID_IAppVidCap, (void **)&pVidCap);
    	if(FAILED(hr))
	    	goto out;
    	ASSERT(pVidCap);
	    hr = pVidCap->SetDeviceID(nCapDevID);
    	if(FAILED(hr))
	    	goto out;
    	hr = pCapability->ReInitialize();

out:
	    if (pVidCap)
    		pVidCap->Release();
	    if (pCapability)
		    pCapability->Release();

      	return ForceCaptureChange();
    }
}	


BOOL CVideoPump::ForceCaptureChange()
{
	HRESULT hr = S_OK;

	if (m_fLocal)
	{
		if (m_pConnection)
		{
			if (IsXferEnabled())
			{
				if (!m_fReopenPending && !m_fOpenPending)
				{
					// if the send channel, and a call exists and the channel is open, and not
					// already closing or opening .....
					if(IsChannelOpen())
					{
						ASSERT(m_pCommChannel);
						// need to close and re-open
						// don't lose a good channel if there is no longer
						// a compatible format, otherwise, close and reopen
						m_BestFormat = m_NewFormat = CVideoProp::GetBestFormat();
						if(m_BestFormat != INVALID_MEDIA_FORMAT)
						{
							m_fReopenPending = TRUE;
							hr = m_pCommChannel->Close();
						}
					}
					else
					{
						if(m_BestFormat != INVALID_MEDIA_FORMAT )
						{
							m_fOpenPending = TRUE;
							hr = m_pCommChannel->Open(m_BestFormat, m_pConnection);
							if(FAILED(hr))
								m_fOpenPending = FALSE;
						}
					}
				}
				else	// already waiting for channel to be opened using some format
				{
					m_NewFormat = CVideoProp::GetBestFormat();
				}
			}
			else
			{
				if(IsChannelOpen())
				{
					m_fClosePending = TRUE;
				}
			}
		}
		else
		{
			if (!IsChannelOpen() && IsPreviewEnabled())
			{
				// togle preview to commit size change
				EnablePreview(FALSE);
				EnablePreview(TRUE);
			}
		}
	}

	if (FAILED(hr))
		return FALSE;
	else
		return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\core\video.h ===
/****************************************************************************
*
*	 FILE:	   VideoUI.h
*
*	 CREATED:  Mark MacLin (MMacLin) 10-17-96
*
****************************************************************************/

#ifndef _VIDEOUI_H_
#define _VIDEOUI_H_

#include "appavcap.h"
#include "ih323cc.h"
#include <vfw.h>

#define MIN_VIDEO_QUALITY		0
#define MAX_VIDEO_QUALITY		31

class CVideoProp
{
protected:

	ICommChannel*	m_pCommChannel;
	ICommChannel*	m_pPreviewChannel;
	IMediaChannel*   m_pMediaStream;
	IH323Endpoint *	m_pConnection;

	IVideoDevice*		m_pIVideoDevice;

	BOOL			m_fSend;
	BOOL			m_fReceive;
	DWORD			m_dwImageQuality;

	VOID			SetFrameRate(DWORD dwValue);
	DWORD			GetFrameRate();
	MEDIA_FORMAT_ID GetBestFormat();

	DWORD			m_dwFrameSize;
	DWORD           m_dwPreferredFrameSize;
private:
	BOOL			m_fPreview;
	DWORD			m_dwFrameRate;

public:

	// Methods:
				CVideoProp();
	VOID		EnableSend(BOOL fEnable);
	BOOL		IsSendEnabled();
	VOID		EnableReceive(BOOL fEnable);
	BOOL		IsReceiveEnabled();
	VOID		EnablePreview(BOOL fEnable);
	BOOL		IsPreviewEnabled();
	BOOL		IsRemotePaused();
	VOID		SetFrameSize(DWORD dwValue);
	DWORD		GetFrameSize();
	DWORD		GetFrameSizes(MEDIA_FORMAT_ID idSpecificFormat);
	BOOL		HasSourceDialog();
	BOOL		HasFormatDialog();
	VOID		ShowSourceDialog();
	VOID		ShowFormatDialog();
	VOID		SetReceiveQuality(DWORD dwValue);
	DWORD		GetReceiveQuality();
	BOOL		IsCaptureAvailable();
	BOOL		IsCaptureSuspended();
	VOID		SuspendCapture(BOOL fSuspend);
	int			GetNumCapDev();
	int			GetMaxCapDevNameLen();
	BOOL		EnumCapDev(DWORD *pdwCapDevIDs, TCHAR *pszCapDevNames, DWORD dwNumCapDev);
	int			GetCurrCapDevID();
	BOOL		SetCurrCapDevID(int nCapDevID);
	ICommChannel * GetCommChannel() { return m_pCommChannel; }
};


class CVideoPump : public CVideoProp
{
private:
	BOOL			m_fPaused;
	DWORD			m_dwLastFrameRate;
	BOOL			m_fLocal;
	BOOL			m_fChannelOpen;
	LPBYTE			m_pImage;
	IVideoRender*	m_pVideoRender;
	FRAMECONTEXT	m_FrameContext;
	RECT			m_ClipRect;
	MEDIA_FORMAT_ID m_BestFormat;
	MEDIA_FORMAT_ID m_NewFormat;
	BOOL			m_fOpenPending;
	BOOL			m_fReopenPending;
	BOOL			m_fClosePending;
	DWORD_PTR		m_dwUser;
	LPFNFRAMEREADY	m_pfnCallback;

public:
	// Methods:
				CVideoPump(BOOL fLocal);
				~CVideoPump();
	BOOL		ChanInitialize(ICommChannel* pCommChannel);
	VOID        Open(MEDIA_FORMAT_ID format_id);
	VOID        Close();
	BOOL		IsLocal() { return m_fLocal; }
	VOID		EnableXfer(BOOL fEnable);
	BOOL		IsXferEnabled();
	VOID		Pause(BOOL fPause);
	BOOL		IsPaused() { return m_fPaused; };
	NM_VIDEO_STATE	GetState();

	VOID		SnapImage();
	VOID		ReleaseImage();
	HRESULT 	GetFrame(FRAMECONTEXT *pFrameContext);
	HRESULT 	ReleaseFrame(FRAMECONTEXT *pFrameContext);
	VOID		SetFrameSize(DWORD dwValue);
	BOOL		SetCurrCapDevID(int nCapDevID);
	BOOL		ForceCaptureChange();
	BOOL		Initialize(IH323CallControl *pNac, IMediaChannel *pMC, IVideoDevice *pVideoDevice,
	    DWORD_PTR dwUser, LPFNFRAMEREADY pfCallback);
	BOOL		IsChannelOpen() { return m_fChannelOpen; }

	// Handlers:
	VOID		OnConnected(IH323Endpoint * lpConnection, ICommChannel *pIChannel);
	VOID		OnChannelOpened(ICommChannel *pIChannel);
	VOID		OnChannelError();
	VOID		OnChannelClosed();
	VOID		OnDisconnected();
};

#endif // _VIDEOUI_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\dev\common.inc ===
#
#  GHOST: h\shlguid.h and all of dev except this file.
#

##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1991-96
#   All Rights Reserved.
#
##########################################################################

#
# Common include file 'sources' files in the NetMeeting project.
#
# History:
#    Common NetMeeting makefile created 13-Aug-96 Chris Pirich (chrispi)
#    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
#    Created 27-Sep-94 by Bob Day (bobday)
#    from template created 12-Apr-1990 by Steve Wood (stevewo)
#
#
#
#
# Required definitions:
#     FREEBUILD
#        Set by makefile.def file.  One of the following:
#          0      - build debug
#          1      - build retail
#
#

!if "$(BUILD_PRODUCT)" != "NT"
OAK_INC_PATH=$(NMROOT)\h		# A hack so version.rc can always be found.
SDK_LIB_PATH    = $(DEVROOT)\lib\*
SDK_INC_PATH    = $(DEVROOT)\inc
CRT_LIB_PATH    = $(DEVROOT)\lib\*
CRT_INC_PATH    = $(DEVROOT)\inc
#
# Set private paths
#

INCLUDES        = ..;$(NMROOT)\dev\inc;$(NMROOT)\h;$(NMROOT)\h\t120;$(INCLUDES)
!else
INCLUDES        = ..;$(NMROOT)\h;$(NMROOT)\h\t120;$(INCLUDES);
!endif

COFFBASE_TXT_FILE = $(NMROOT)\h\coffbase.txt
MASTER_VERSION_FILE=$(NMROOT)\h\version.h

#
# Set common options
#

# Defining this allows windows.h to include other headers
#NOT_LEAN_AND_MEAN = 1

# Don't link to NT libs - defining this brings in int64.lib
# USE_NOLIBS      = 1

# Use multi-thread CRT by default
USE_LIBCMT        = 1

# Use C-runtime DLL by default
USE_MSVCRT        = 1

# don't use stdcall by default
386_STDCALL       = 0

UMTYPE            = windows

#
# Lego options
#
!if defined(NTBBT)

#NTPROFILEINPUT  = 1
!endif

# ****** "FINAL" should be defined only for golden builds ******
C_DEFINES       = $(C_DEFINES) -DFINAL

!if defined(USE_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
NMUTIL_LIB      = nmutilw
!else
NMUTIL_LIB      = nmutila
# Insure that we will work on Win 95
CHICAGO_PROJECT   = 1
CHICAGO_PRODUCT   = 1
NO_NTDLL          = 1
!endif

#
# Additional compiler flags
#
!if "$(BUILD_PRODUCT)" == "NT"
WIN32_WINNT_VERSION=0x500
#WIN32_WIN95_VERSION=0x040a
WIN32_IE_VERSION   =0x0500
WIN32_DEFINE= -D_WIN32_WINDOWS=0x500 -D_WIN32_WINNT=0x0500
#C_DEFINES          =$(C_DEFINES) -DSTRICT -DOS_WINDOWS -DWIN_95_32_BIT -DNASHVILLE
C_DEFINES          =$(C_DEFINES) -DSTRICT -DWIN32 -D_WIN32
!if !$(FREEBUILD)
C_DEFINES          = $(C_DEFINES) -D_DEBUG -DDEBUG
!endif
ATL_VER            = 30
USE_STATIC_ATL     = 1
#-D_ATL_NO_DEBUG_CRT
!else

#WIN32_DEFINE=-DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=0x040a -D_WIN32_WINNT=0x0400
#C_DEFINES       = $(C_DEFINES) -DSTRICT -DWIN32 -D_WIN32 -DOS_WINDOWS -DWIN_95_32_BIT

!if !$(FREEBUILD)
C_DEFINES          = $(C_DEFINES) -D_DEBUG -DDEBUG
DEBUG_CRTS         = 1
NTDEBUG            = ntsd
NTDEBUGTYPE        = windbg
!endif

USE_PDB            = 1
USE_PDB_TO_COMPILE = 1
#
# Additional linker flags
#

LINKER_FLAGS    = $(LINKER_FLAGS) -map

#
# Get all maps and syms
#

USE_MAPSYM = 1
!endif		# BUILD_PRODUCT != NT

# Make warnings equivalent to errors

!if !defined(MSC_WARNING_LEVEL)
MSC_WARNING_LEVEL= /W3
!endif
MSC_WARNING_LEVEL= $(MSC_WARNING_LEVEL) /WX

# Since we build as a Chicago product, we don't pull in ntdll.lib on FRE builds.
# Use the non-NTDLL version of overrun detection as a result.

BUFFER_OVERFLOW_CHECKS=NO_NTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\appavcap.h ===
/*
 *  	File: appavcap.h
 *
 *      Network audio/video application capability interface. Provides
 * 		data structures for adding, removing, enumerating, prioritizing,\
 *		and enabling/disabling codecs independently for send/receive.
 *
 */


#ifndef _APPAVCAP_H
#define _APPAVCAP_H

#include <mmreg.h>
#include <msacm.h>

#include <pshpack8.h> /* Assume 8 byte packing throughout */

// For use as dimension for variable size arrays
#define VARIABLE_DIM 1

// CPU utilization numbers for NetMeeting-provided codecs
#define LNH_48_CPU 97
#define LNH_8_CPU  47
#define LNH_12_CPU 48
#define LNH_16_CPU 49
#define MS_G723_CPU 70
#define CCITT_A_CPU 24
#define	CCITT_U_CPU 25
#define MSRT24_CPU 55


// AUDIO_FORMAT_ID is an index into an array of AUDCAPS structures
typedef DWORD AUDIO_FORMAT_ID;
#define INVALID_AUDIO_FORMAT 0xffffffff
typedef DWORD MEDIA_FORMAT_ID;
#define INVALID_MEDIA_FORMAT 0xffffffff
// VIDEO_FORMAT_ID is an index into an array of VIDCAPS structures
typedef DWORD VIDEO_FORMAT_ID;
#define INVALID_VIDEO_FORMAT 0xffffffff

/*
 *  @doc  EXTERNAL DATASTRUC
 *
 *	AUDIO capabilities info structure
 *
 *	@struct AUDCAP_INFO | AUDIO capabilities info structure.
 *	Use for both input and output when calling capabilties APIs.
 *	The fields are input-only, output-only or input/output depending on the API used.
 *	Behavior is undefined if these are altered.
 */

// basic audcap structure
typedef struct BasicAudCapInfo
{
	WORD wFormatTag;			// @field The ACM format tag
	AUDIO_FORMAT_ID	Id;			// @field (OUTPUT only) The local id (a.k.a. *Handle*) of this capability entry
	char szFormat[ACMFORMATDETAILS_FORMAT_CHARS];	// @field (OUTPUT only) Descriptive string of
													// the format, e.g. "Microsoft GSM 6.10"
	UINT uMaxBitrate;			// @field (OUTPUT only) Worst case bitrate
	UINT uAvgBitrate;			// @field The average bitrate for this codec
	WORD wCPUUtilizationEncode;	// @field % of Pentium 90Mhz needed for compress
	WORD wCPUUtilizationDecode;	// @field % of Pentium 90Mhz needed for decompress
	
	BOOL bSendEnabled;			// @field OK to use this format for sending
	BOOL bRecvEnabled;			// @field OK to use this format for receiving
	WORD wSortIndex;			// @field The ordered position of this entry
								// in the capability table. Can be used as input only 
								// in ReorderFormats
}BASIC_AUDCAP_INFO, *PBASIC_AUDCAP_INFO, AUDCAP_INFO, *PAUDCAP_INFO;

/*
 *	@struct AUDCAP_INFO_LIST | List of AUDCAP_INFO structures
 */
typedef struct _audcapinfolist
{
	ULONG	cFormats;			// @field Number of AUDCAP_INFO structures in this list
	AUDCAP_INFO	aFormats[VARIABLE_DIM];	// @field cFormats AUDCAP_INFO structures
} AUDCAP_INFO_LIST, *PAUDCAP_INFO_LIST;

/*
 *	@enum VIDEO_SIZES | Enumeration values for the three video sizes supported by NetMeeting
 */
typedef enum
{
	Small = 0,	// @emem Small size video
	Medium,		// @emem Medium size video
	Large		// @emem Large size video
} VIDEO_SIZES;

/*
 *	VIDEO capabilities info structure
 *
 *	@struct VIDCAP_INFO | VIDEO capabilities info structure.
 *	Use for both input and output when calling capabilties APIs.
 *	The fields are input-only, output-only or input/output depending on the API used.
 *	Behavior is undefined if these are altered.
 */

// VIDCAP_INFO structure
typedef struct BasicVidCapInfo
{
	// format identification
	DWORD dwFormatTag;			// @field The format tag of this format
	VIDEO_FORMAT_ID	Id;			// @field (OUTPUT only) The local id (a.k.a. *Handle*) of this capability entry
	char szFormat[ACMFORMATDETAILS_FORMAT_CHARS];	// @field (OUTPUT only) Descriptive string of,
													// the formate.g. "Microsoft H.263"
	// NetMeeting specific info
	WORD wCPUUtilizationEncode;	// @field % of Pentium 90Mhz needed for compress
	WORD wCPUUtilizationDecode;	// @field % of Pentium 90Mhz needed for decompress
	BOOL bSendEnabled;			// @field OK to use this format for sending
	BOOL bRecvEnabled;			// @field OK to use this format for receiving
	WORD wSortIndex;			// @field (OUTPUT only) The ordered position of this entry
								// in the capability table.

	// video format details
	VIDEO_SIZES enumVideoSize;	// @field The video size for this format. Different video sizes for 
								// the same formats must be added as separate formats 
    BITMAPINFOHEADER bih;		// @field The BITMAPINFOHEADER sturcture for the video 
								// size in enumVideosize
	UINT uFrameRate;			// @field Number of frames per second
	DWORD dwBitsPerSample;		// @field number of bits per sample for this format. Must
								// match the value in bih.biBitCount
	UINT uAvgBitrate;			// @field The average bitrate for this codec
	UINT uMaxBitrate;			// @field (OUTPUT only) Worst case bitrate
}BASIC_VIDCAP_INFO, *PBASIC_VIDCAP_INFO, VIDCAP_INFO, *PVIDCAP_INFO;


/*
 *	@struct VIDCAP_INFO_LIST | List of VIDCAP_INFO structures
 */
typedef struct _vidcapinfolist
{
	ULONG	cFormats;// @field Number of VIDCAP_INFO structures in this list
	VIDCAP_INFO	aFormats[VARIABLE_DIM];	// @field cFormats VIDCAP_INFO structures
} VIDCAP_INFO_LIST, *PVIDCAP_INFO_LIST;

#include <poppack.h> /* End byte packing */


#endif	//#ifndef _APPAVCAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\dev\warning.h ===
#pragma warning(3:4092)   // sizeof returns 'unsigned long'
#pragma warning(4:4121)   // structure is sensitive to alignment
#pragma warning(3:4125)   // decimal digit in octal sequence
#pragma warning(3:4130)   // logical operation on address of string constant
#pragma warning(3:4132)   // const object should be initialized
#pragma warning(4:4206)   // Source File is empty
#pragma warning(4:4101)   // Unreferenced local variable
#pragma warning(4:4208)   // delete[exp] - exp evaluated but ignored
#pragma warning(3:4212)   // function declaration used ellipsis
#pragma warning(3:4242)   // convertion possible loss of data
#pragma warning(4:4267)   // convertion from size_t to smaller type
#pragma warning(4:4312)   // conversion to type of greater size
#pragma warning(error:4700)    // Local used w/o being initialized
//#pragma warning(3:4700)    // Local used w/o being initialized
#pragma warning(error:4259)    // pure virtual function was not defined
#pragma warning(error:4071)    // no function prototype given
#pragma warning(error:4072)    // no function prototype given (fastcall)
#pragma warning(error:4171)    // no function prototype given (old style)
#pragma warning(error:4013)    // 'function' undefined - assuming extern returning int
#pragma warning(error:4551)    // Function call missing argument list
#pragma warning(error:4806)    // unsafe operation involving type 'bool'
#pragma warning(4:4509)   // use of SEH with destructor
#pragma warning(4:4177)   // pragma data_seg s/b at global scope
#pragma warning(disable:4274)  // #ident ignored
#pragma warning(disable:4786)  // identifier was truncated to 255 chararcers in debug information.
#pragma warning(disable:4503)  // decorated name length exceeded, name was truncated.
#pragma warning(disable:4263)  // Derived override doesn't match base - who cares...
#pragma warning(disable:4264)  // base function is hidden - again who cares.
#pragma warning(disable:4710)  // Function marked as inline - wasn't
#pragma warning(disable:4917)  // A GUID can only be associated with a class, interface or namespace
#pragma warning(error:4552)    // <<, >> ops used to no effect (probably missing an = sign)
#pragma warning(error:4553)    // == op used w/o effect (probably s/b an = sign)

#if 0
#pragma warning(3:4100)   // Unreferenced formal parameter
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4706)   // assignment w/i conditional expression
#pragma warning(3:4709)   // command operator w/o index expression
#endif

#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\apierror.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/apierror.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the tERROR of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.28  $
 *	$Date:   Jan 22 1997 11:38:04  $
 *	$Author:   plantz  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		Media Service Manager "public" header file. This file contains
 *		#defines, typedefs, struct definitions and prototypes used by
 *		and in conjunction with MSM. Any EXE or DLL which interacts with
 *		MSM will include this header file.
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef APIERROR_H
#define APIERROR_H

#include <objbase.h>

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus


#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport


// Prototype for function that converts HRESULT into a string.  The function
// and string resources are contained in NETMMERR.DLL.
//
typedef WORD	(*NETMMERR_ERRORTOSTRING)	(HRESULT, LPSTR, int);


extern DllExport BOOL GetResultUserString(HRESULT hResult, LPSTR lpBuffer, int iBufferSize);
extern DllExport BOOL GetResultSubStrings(HRESULT hResult, LPSTR lpBuffer, int iBufferSize);


// This description was extracted from winerror.h.  It appears here only for
// the purpose of convenience.

//
// OLE error definitions and values
//
// The return value of OLE APIs and methods is an HRESULT.
// This is not a handle to anything, but is merely a 32-bit value
// with several fields encoded in the value.  The parts of an
// HRESULT are shown below.
//
// Many of the macros and functions below were orginally defined to
// operate on SCODEs.  SCODEs are no longer used.  The macros are
// still present for compatibility and easy porting of Win16 code.
// Newly written code should use the HRESULT macros and functions.
//

//
//  HRESULTs are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//


// Macro to create a custom HRESULT
//
#define MAKE_CUSTOM_HRESULT(sev,cus,fac,code) \
((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(cus)<<29) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )


// Macro to test for custom HRESULT
//
#define HRESULT_CUS